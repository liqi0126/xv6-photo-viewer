
_zombie：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <main>:
#include "stat.h"
#include "user.h"

int
main(void)
{
       0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
       4:	83 e4 f0             	and    $0xfffffff0,%esp
       7:	ff 71 fc             	pushl  -0x4(%ecx)
       a:	55                   	push   %ebp
       b:	89 e5                	mov    %esp,%ebp
       d:	51                   	push   %ecx
       e:	83 ec 04             	sub    $0x4,%esp
  if(fork() > 0)
      11:	e8 65 02 00 00       	call   27b <fork>
      16:	85 c0                	test   %eax,%eax
      18:	7e 0d                	jle    27 <main+0x27>
    sleep(5);  // Let child exit before parent.
      1a:	83 ec 0c             	sub    $0xc,%esp
      1d:	6a 05                	push   $0x5
      1f:	e8 ef 02 00 00       	call   313 <sleep>
      24:	83 c4 10             	add    $0x10,%esp
  exit();
      27:	e8 57 02 00 00       	call   283 <exit>

0000002c <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
      2c:	55                   	push   %ebp
      2d:	89 e5                	mov    %esp,%ebp
      2f:	57                   	push   %edi
      30:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
      31:	8b 4d 08             	mov    0x8(%ebp),%ecx
      34:	8b 55 10             	mov    0x10(%ebp),%edx
      37:	8b 45 0c             	mov    0xc(%ebp),%eax
      3a:	89 cb                	mov    %ecx,%ebx
      3c:	89 df                	mov    %ebx,%edi
      3e:	89 d1                	mov    %edx,%ecx
      40:	fc                   	cld    
      41:	f3 aa                	rep stos %al,%es:(%edi)
      43:	89 ca                	mov    %ecx,%edx
      45:	89 fb                	mov    %edi,%ebx
      47:	89 5d 08             	mov    %ebx,0x8(%ebp)
      4a:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
      4d:	90                   	nop
      4e:	5b                   	pop    %ebx
      4f:	5f                   	pop    %edi
      50:	5d                   	pop    %ebp
      51:	c3                   	ret    

00000052 <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
      52:	55                   	push   %ebp
      53:	89 e5                	mov    %esp,%ebp
      55:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
      58:	8b 45 08             	mov    0x8(%ebp),%eax
      5b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
      5e:	90                   	nop
      5f:	8b 45 08             	mov    0x8(%ebp),%eax
      62:	8d 50 01             	lea    0x1(%eax),%edx
      65:	89 55 08             	mov    %edx,0x8(%ebp)
      68:	8b 55 0c             	mov    0xc(%ebp),%edx
      6b:	8d 4a 01             	lea    0x1(%edx),%ecx
      6e:	89 4d 0c             	mov    %ecx,0xc(%ebp)
      71:	0f b6 12             	movzbl (%edx),%edx
      74:	88 10                	mov    %dl,(%eax)
      76:	0f b6 00             	movzbl (%eax),%eax
      79:	84 c0                	test   %al,%al
      7b:	75 e2                	jne    5f <strcpy+0xd>
    ;
  return os;
      7d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
      80:	c9                   	leave  
      81:	c3                   	ret    

00000082 <strcmp>:

int
strcmp(const char *p, const char *q)
{
      82:	55                   	push   %ebp
      83:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
      85:	eb 08                	jmp    8f <strcmp+0xd>
    p++, q++;
      87:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      8b:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
      8f:	8b 45 08             	mov    0x8(%ebp),%eax
      92:	0f b6 00             	movzbl (%eax),%eax
      95:	84 c0                	test   %al,%al
      97:	74 10                	je     a9 <strcmp+0x27>
      99:	8b 45 08             	mov    0x8(%ebp),%eax
      9c:	0f b6 10             	movzbl (%eax),%edx
      9f:	8b 45 0c             	mov    0xc(%ebp),%eax
      a2:	0f b6 00             	movzbl (%eax),%eax
      a5:	38 c2                	cmp    %al,%dl
      a7:	74 de                	je     87 <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
      a9:	8b 45 08             	mov    0x8(%ebp),%eax
      ac:	0f b6 00             	movzbl (%eax),%eax
      af:	0f b6 d0             	movzbl %al,%edx
      b2:	8b 45 0c             	mov    0xc(%ebp),%eax
      b5:	0f b6 00             	movzbl (%eax),%eax
      b8:	0f b6 c0             	movzbl %al,%eax
      bb:	29 c2                	sub    %eax,%edx
      bd:	89 d0                	mov    %edx,%eax
}
      bf:	5d                   	pop    %ebp
      c0:	c3                   	ret    

000000c1 <strlen>:

uint
strlen(char *s)
{
      c1:	55                   	push   %ebp
      c2:	89 e5                	mov    %esp,%ebp
      c4:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
      c7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
      ce:	eb 04                	jmp    d4 <strlen+0x13>
      d0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
      d4:	8b 55 fc             	mov    -0x4(%ebp),%edx
      d7:	8b 45 08             	mov    0x8(%ebp),%eax
      da:	01 d0                	add    %edx,%eax
      dc:	0f b6 00             	movzbl (%eax),%eax
      df:	84 c0                	test   %al,%al
      e1:	75 ed                	jne    d0 <strlen+0xf>
    ;
  return n;
      e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
      e6:	c9                   	leave  
      e7:	c3                   	ret    

000000e8 <memset>:

void*
memset(void *dst, int c, uint n)
{
      e8:	55                   	push   %ebp
      e9:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
      eb:	8b 45 10             	mov    0x10(%ebp),%eax
      ee:	50                   	push   %eax
      ef:	ff 75 0c             	pushl  0xc(%ebp)
      f2:	ff 75 08             	pushl  0x8(%ebp)
      f5:	e8 32 ff ff ff       	call   2c <stosb>
      fa:	83 c4 0c             	add    $0xc,%esp
  return dst;
      fd:	8b 45 08             	mov    0x8(%ebp),%eax
}
     100:	c9                   	leave  
     101:	c3                   	ret    

00000102 <strchr>:

char*
strchr(const char *s, char c)
{
     102:	55                   	push   %ebp
     103:	89 e5                	mov    %esp,%ebp
     105:	83 ec 04             	sub    $0x4,%esp
     108:	8b 45 0c             	mov    0xc(%ebp),%eax
     10b:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     10e:	eb 14                	jmp    124 <strchr+0x22>
    if(*s == c)
     110:	8b 45 08             	mov    0x8(%ebp),%eax
     113:	0f b6 00             	movzbl (%eax),%eax
     116:	3a 45 fc             	cmp    -0x4(%ebp),%al
     119:	75 05                	jne    120 <strchr+0x1e>
      return (char*)s;
     11b:	8b 45 08             	mov    0x8(%ebp),%eax
     11e:	eb 13                	jmp    133 <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     120:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     124:	8b 45 08             	mov    0x8(%ebp),%eax
     127:	0f b6 00             	movzbl (%eax),%eax
     12a:	84 c0                	test   %al,%al
     12c:	75 e2                	jne    110 <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     12e:	b8 00 00 00 00       	mov    $0x0,%eax
}
     133:	c9                   	leave  
     134:	c3                   	ret    

00000135 <gets>:

char*
gets(char *buf, int max)
{
     135:	55                   	push   %ebp
     136:	89 e5                	mov    %esp,%ebp
     138:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     13b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     142:	eb 42                	jmp    186 <gets+0x51>
    cc = read(0, &c, 1);
     144:	83 ec 04             	sub    $0x4,%esp
     147:	6a 01                	push   $0x1
     149:	8d 45 ef             	lea    -0x11(%ebp),%eax
     14c:	50                   	push   %eax
     14d:	6a 00                	push   $0x0
     14f:	e8 47 01 00 00       	call   29b <read>
     154:	83 c4 10             	add    $0x10,%esp
     157:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     15a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     15e:	7e 33                	jle    193 <gets+0x5e>
      break;
    buf[i++] = c;
     160:	8b 45 f4             	mov    -0xc(%ebp),%eax
     163:	8d 50 01             	lea    0x1(%eax),%edx
     166:	89 55 f4             	mov    %edx,-0xc(%ebp)
     169:	89 c2                	mov    %eax,%edx
     16b:	8b 45 08             	mov    0x8(%ebp),%eax
     16e:	01 c2                	add    %eax,%edx
     170:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     174:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     176:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     17a:	3c 0a                	cmp    $0xa,%al
     17c:	74 16                	je     194 <gets+0x5f>
     17e:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     182:	3c 0d                	cmp    $0xd,%al
     184:	74 0e                	je     194 <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     186:	8b 45 f4             	mov    -0xc(%ebp),%eax
     189:	83 c0 01             	add    $0x1,%eax
     18c:	3b 45 0c             	cmp    0xc(%ebp),%eax
     18f:	7c b3                	jl     144 <gets+0xf>
     191:	eb 01                	jmp    194 <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     193:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     194:	8b 55 f4             	mov    -0xc(%ebp),%edx
     197:	8b 45 08             	mov    0x8(%ebp),%eax
     19a:	01 d0                	add    %edx,%eax
     19c:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     19f:	8b 45 08             	mov    0x8(%ebp),%eax
}
     1a2:	c9                   	leave  
     1a3:	c3                   	ret    

000001a4 <stat>:

int
stat(char *n, struct stat *st)
{
     1a4:	55                   	push   %ebp
     1a5:	89 e5                	mov    %esp,%ebp
     1a7:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     1aa:	83 ec 08             	sub    $0x8,%esp
     1ad:	6a 00                	push   $0x0
     1af:	ff 75 08             	pushl  0x8(%ebp)
     1b2:	e8 0c 01 00 00       	call   2c3 <open>
     1b7:	83 c4 10             	add    $0x10,%esp
     1ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     1bd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     1c1:	79 07                	jns    1ca <stat+0x26>
    return -1;
     1c3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     1c8:	eb 25                	jmp    1ef <stat+0x4b>
  r = fstat(fd, st);
     1ca:	83 ec 08             	sub    $0x8,%esp
     1cd:	ff 75 0c             	pushl  0xc(%ebp)
     1d0:	ff 75 f4             	pushl  -0xc(%ebp)
     1d3:	e8 03 01 00 00       	call   2db <fstat>
     1d8:	83 c4 10             	add    $0x10,%esp
     1db:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     1de:	83 ec 0c             	sub    $0xc,%esp
     1e1:	ff 75 f4             	pushl  -0xc(%ebp)
     1e4:	e8 c2 00 00 00       	call   2ab <close>
     1e9:	83 c4 10             	add    $0x10,%esp
  return r;
     1ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     1ef:	c9                   	leave  
     1f0:	c3                   	ret    

000001f1 <atoi>:

int
atoi(const char *s)
{
     1f1:	55                   	push   %ebp
     1f2:	89 e5                	mov    %esp,%ebp
     1f4:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     1f7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     1fe:	eb 25                	jmp    225 <atoi+0x34>
    n = n*10 + *s++ - '0';
     200:	8b 55 fc             	mov    -0x4(%ebp),%edx
     203:	89 d0                	mov    %edx,%eax
     205:	c1 e0 02             	shl    $0x2,%eax
     208:	01 d0                	add    %edx,%eax
     20a:	01 c0                	add    %eax,%eax
     20c:	89 c1                	mov    %eax,%ecx
     20e:	8b 45 08             	mov    0x8(%ebp),%eax
     211:	8d 50 01             	lea    0x1(%eax),%edx
     214:	89 55 08             	mov    %edx,0x8(%ebp)
     217:	0f b6 00             	movzbl (%eax),%eax
     21a:	0f be c0             	movsbl %al,%eax
     21d:	01 c8                	add    %ecx,%eax
     21f:	83 e8 30             	sub    $0x30,%eax
     222:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     225:	8b 45 08             	mov    0x8(%ebp),%eax
     228:	0f b6 00             	movzbl (%eax),%eax
     22b:	3c 2f                	cmp    $0x2f,%al
     22d:	7e 0a                	jle    239 <atoi+0x48>
     22f:	8b 45 08             	mov    0x8(%ebp),%eax
     232:	0f b6 00             	movzbl (%eax),%eax
     235:	3c 39                	cmp    $0x39,%al
     237:	7e c7                	jle    200 <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     239:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     23c:	c9                   	leave  
     23d:	c3                   	ret    

0000023e <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     23e:	55                   	push   %ebp
     23f:	89 e5                	mov    %esp,%ebp
     241:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     244:	8b 45 08             	mov    0x8(%ebp),%eax
     247:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     24a:	8b 45 0c             	mov    0xc(%ebp),%eax
     24d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     250:	eb 17                	jmp    269 <memmove+0x2b>
    *dst++ = *src++;
     252:	8b 45 fc             	mov    -0x4(%ebp),%eax
     255:	8d 50 01             	lea    0x1(%eax),%edx
     258:	89 55 fc             	mov    %edx,-0x4(%ebp)
     25b:	8b 55 f8             	mov    -0x8(%ebp),%edx
     25e:	8d 4a 01             	lea    0x1(%edx),%ecx
     261:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     264:	0f b6 12             	movzbl (%edx),%edx
     267:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     269:	8b 45 10             	mov    0x10(%ebp),%eax
     26c:	8d 50 ff             	lea    -0x1(%eax),%edx
     26f:	89 55 10             	mov    %edx,0x10(%ebp)
     272:	85 c0                	test   %eax,%eax
     274:	7f dc                	jg     252 <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     276:	8b 45 08             	mov    0x8(%ebp),%eax
}
     279:	c9                   	leave  
     27a:	c3                   	ret    

0000027b <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     27b:	b8 01 00 00 00       	mov    $0x1,%eax
     280:	cd 40                	int    $0x40
     282:	c3                   	ret    

00000283 <exit>:
SYSCALL(exit)
     283:	b8 02 00 00 00       	mov    $0x2,%eax
     288:	cd 40                	int    $0x40
     28a:	c3                   	ret    

0000028b <wait>:
SYSCALL(wait)
     28b:	b8 03 00 00 00       	mov    $0x3,%eax
     290:	cd 40                	int    $0x40
     292:	c3                   	ret    

00000293 <pipe>:
SYSCALL(pipe)
     293:	b8 04 00 00 00       	mov    $0x4,%eax
     298:	cd 40                	int    $0x40
     29a:	c3                   	ret    

0000029b <read>:
SYSCALL(read)
     29b:	b8 05 00 00 00       	mov    $0x5,%eax
     2a0:	cd 40                	int    $0x40
     2a2:	c3                   	ret    

000002a3 <write>:
SYSCALL(write)
     2a3:	b8 10 00 00 00       	mov    $0x10,%eax
     2a8:	cd 40                	int    $0x40
     2aa:	c3                   	ret    

000002ab <close>:
SYSCALL(close)
     2ab:	b8 15 00 00 00       	mov    $0x15,%eax
     2b0:	cd 40                	int    $0x40
     2b2:	c3                   	ret    

000002b3 <kill>:
SYSCALL(kill)
     2b3:	b8 06 00 00 00       	mov    $0x6,%eax
     2b8:	cd 40                	int    $0x40
     2ba:	c3                   	ret    

000002bb <exec>:
SYSCALL(exec)
     2bb:	b8 07 00 00 00       	mov    $0x7,%eax
     2c0:	cd 40                	int    $0x40
     2c2:	c3                   	ret    

000002c3 <open>:
SYSCALL(open)
     2c3:	b8 0f 00 00 00       	mov    $0xf,%eax
     2c8:	cd 40                	int    $0x40
     2ca:	c3                   	ret    

000002cb <mknod>:
SYSCALL(mknod)
     2cb:	b8 11 00 00 00       	mov    $0x11,%eax
     2d0:	cd 40                	int    $0x40
     2d2:	c3                   	ret    

000002d3 <unlink>:
SYSCALL(unlink)
     2d3:	b8 12 00 00 00       	mov    $0x12,%eax
     2d8:	cd 40                	int    $0x40
     2da:	c3                   	ret    

000002db <fstat>:
SYSCALL(fstat)
     2db:	b8 08 00 00 00       	mov    $0x8,%eax
     2e0:	cd 40                	int    $0x40
     2e2:	c3                   	ret    

000002e3 <link>:
SYSCALL(link)
     2e3:	b8 13 00 00 00       	mov    $0x13,%eax
     2e8:	cd 40                	int    $0x40
     2ea:	c3                   	ret    

000002eb <mkdir>:
SYSCALL(mkdir)
     2eb:	b8 14 00 00 00       	mov    $0x14,%eax
     2f0:	cd 40                	int    $0x40
     2f2:	c3                   	ret    

000002f3 <chdir>:
SYSCALL(chdir)
     2f3:	b8 09 00 00 00       	mov    $0x9,%eax
     2f8:	cd 40                	int    $0x40
     2fa:	c3                   	ret    

000002fb <dup>:
SYSCALL(dup)
     2fb:	b8 0a 00 00 00       	mov    $0xa,%eax
     300:	cd 40                	int    $0x40
     302:	c3                   	ret    

00000303 <getpid>:
SYSCALL(getpid)
     303:	b8 0b 00 00 00       	mov    $0xb,%eax
     308:	cd 40                	int    $0x40
     30a:	c3                   	ret    

0000030b <sbrk>:
SYSCALL(sbrk)
     30b:	b8 0c 00 00 00       	mov    $0xc,%eax
     310:	cd 40                	int    $0x40
     312:	c3                   	ret    

00000313 <sleep>:
SYSCALL(sleep)
     313:	b8 0d 00 00 00       	mov    $0xd,%eax
     318:	cd 40                	int    $0x40
     31a:	c3                   	ret    

0000031b <uptime>:
SYSCALL(uptime)
     31b:	b8 0e 00 00 00       	mov    $0xe,%eax
     320:	cd 40                	int    $0x40
     322:	c3                   	ret    

00000323 <createwindow>:
SYSCALL(createwindow)
     323:	b8 16 00 00 00       	mov    $0x16,%eax
     328:	cd 40                	int    $0x40
     32a:	c3                   	ret    

0000032b <repaintwindow>:
SYSCALL(repaintwindow)
     32b:	b8 17 00 00 00       	mov    $0x17,%eax
     330:	cd 40                	int    $0x40
     332:	c3                   	ret    

00000333 <getmessage>:
SYSCALL(getmessage)
     333:	b8 18 00 00 00       	mov    $0x18,%eax
     338:	cd 40                	int    $0x40
     33a:	c3                   	ret    

0000033b <settimer>:
SYSCALL(settimer)
     33b:	b8 19 00 00 00       	mov    $0x19,%eax
     340:	cd 40                	int    $0x40
     342:	c3                   	ret    

00000343 <updatewindow>:
SYSCALL(updatewindow)
     343:	b8 1a 00 00 00       	mov    $0x1a,%eax
     348:	cd 40                	int    $0x40
     34a:	c3                   	ret    

0000034b <destroywindow>:
SYSCALL(destroywindow)
     34b:	b8 1b 00 00 00       	mov    $0x1b,%eax
     350:	cd 40                	int    $0x40
     352:	c3                   	ret    

00000353 <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     353:	55                   	push   %ebp
     354:	89 e5                	mov    %esp,%ebp
     356:	83 ec 18             	sub    $0x18,%esp
     359:	8b 45 0c             	mov    0xc(%ebp),%eax
     35c:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     35f:	83 ec 04             	sub    $0x4,%esp
     362:	6a 01                	push   $0x1
     364:	8d 45 f4             	lea    -0xc(%ebp),%eax
     367:	50                   	push   %eax
     368:	ff 75 08             	pushl  0x8(%ebp)
     36b:	e8 33 ff ff ff       	call   2a3 <write>
     370:	83 c4 10             	add    $0x10,%esp
}
     373:	90                   	nop
     374:	c9                   	leave  
     375:	c3                   	ret    

00000376 <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     376:	55                   	push   %ebp
     377:	89 e5                	mov    %esp,%ebp
     379:	53                   	push   %ebx
     37a:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     37d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     384:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     388:	74 17                	je     3a1 <printint+0x2b>
     38a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     38e:	79 11                	jns    3a1 <printint+0x2b>
    neg = 1;
     390:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     397:	8b 45 0c             	mov    0xc(%ebp),%eax
     39a:	f7 d8                	neg    %eax
     39c:	89 45 ec             	mov    %eax,-0x14(%ebp)
     39f:	eb 06                	jmp    3a7 <printint+0x31>
  } else {
    x = xx;
     3a1:	8b 45 0c             	mov    0xc(%ebp),%eax
     3a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     3a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     3ae:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     3b1:	8d 41 01             	lea    0x1(%ecx),%eax
     3b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
     3b7:	8b 5d 10             	mov    0x10(%ebp),%ebx
     3ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
     3bd:	ba 00 00 00 00       	mov    $0x0,%edx
     3c2:	f7 f3                	div    %ebx
     3c4:	89 d0                	mov    %edx,%eax
     3c6:	0f b6 80 80 e0 01 00 	movzbl 0x1e080(%eax),%eax
     3cd:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     3d1:	8b 5d 10             	mov    0x10(%ebp),%ebx
     3d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
     3d7:	ba 00 00 00 00       	mov    $0x0,%edx
     3dc:	f7 f3                	div    %ebx
     3de:	89 45 ec             	mov    %eax,-0x14(%ebp)
     3e1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     3e5:	75 c7                	jne    3ae <printint+0x38>
  if(neg)
     3e7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     3eb:	74 2d                	je     41a <printint+0xa4>
    buf[i++] = '-';
     3ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
     3f0:	8d 50 01             	lea    0x1(%eax),%edx
     3f3:	89 55 f4             	mov    %edx,-0xc(%ebp)
     3f6:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     3fb:	eb 1d                	jmp    41a <printint+0xa4>
    putc(fd, buf[i]);
     3fd:	8d 55 dc             	lea    -0x24(%ebp),%edx
     400:	8b 45 f4             	mov    -0xc(%ebp),%eax
     403:	01 d0                	add    %edx,%eax
     405:	0f b6 00             	movzbl (%eax),%eax
     408:	0f be c0             	movsbl %al,%eax
     40b:	83 ec 08             	sub    $0x8,%esp
     40e:	50                   	push   %eax
     40f:	ff 75 08             	pushl  0x8(%ebp)
     412:	e8 3c ff ff ff       	call   353 <putc>
     417:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     41a:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     41e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     422:	79 d9                	jns    3fd <printint+0x87>
    putc(fd, buf[i]);
}
     424:	90                   	nop
     425:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     428:	c9                   	leave  
     429:	c3                   	ret    

0000042a <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     42a:	55                   	push   %ebp
     42b:	89 e5                	mov    %esp,%ebp
     42d:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     430:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
     437:	8d 45 0c             	lea    0xc(%ebp),%eax
     43a:	83 c0 04             	add    $0x4,%eax
     43d:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
     440:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     447:	e9 59 01 00 00       	jmp    5a5 <printf+0x17b>
    c = fmt[i] & 0xff;
     44c:	8b 55 0c             	mov    0xc(%ebp),%edx
     44f:	8b 45 f0             	mov    -0x10(%ebp),%eax
     452:	01 d0                	add    %edx,%eax
     454:	0f b6 00             	movzbl (%eax),%eax
     457:	0f be c0             	movsbl %al,%eax
     45a:	25 ff 00 00 00       	and    $0xff,%eax
     45f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
     462:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     466:	75 2c                	jne    494 <printf+0x6a>
      if(c == '%'){
     468:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     46c:	75 0c                	jne    47a <printf+0x50>
        state = '%';
     46e:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
     475:	e9 27 01 00 00       	jmp    5a1 <printf+0x177>
      } else {
        putc(fd, c);
     47a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     47d:	0f be c0             	movsbl %al,%eax
     480:	83 ec 08             	sub    $0x8,%esp
     483:	50                   	push   %eax
     484:	ff 75 08             	pushl  0x8(%ebp)
     487:	e8 c7 fe ff ff       	call   353 <putc>
     48c:	83 c4 10             	add    $0x10,%esp
     48f:	e9 0d 01 00 00       	jmp    5a1 <printf+0x177>
      }
    } else if(state == '%'){
     494:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
     498:	0f 85 03 01 00 00    	jne    5a1 <printf+0x177>
      if(c == 'd'){
     49e:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
     4a2:	75 1e                	jne    4c2 <printf+0x98>
        printint(fd, *ap, 10, 1);
     4a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
     4a7:	8b 00                	mov    (%eax),%eax
     4a9:	6a 01                	push   $0x1
     4ab:	6a 0a                	push   $0xa
     4ad:	50                   	push   %eax
     4ae:	ff 75 08             	pushl  0x8(%ebp)
     4b1:	e8 c0 fe ff ff       	call   376 <printint>
     4b6:	83 c4 10             	add    $0x10,%esp
        ap++;
     4b9:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     4bd:	e9 d8 00 00 00       	jmp    59a <printf+0x170>
      } else if(c == 'x' || c == 'p'){
     4c2:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
     4c6:	74 06                	je     4ce <printf+0xa4>
     4c8:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
     4cc:	75 1e                	jne    4ec <printf+0xc2>
        printint(fd, *ap, 16, 0);
     4ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
     4d1:	8b 00                	mov    (%eax),%eax
     4d3:	6a 00                	push   $0x0
     4d5:	6a 10                	push   $0x10
     4d7:	50                   	push   %eax
     4d8:	ff 75 08             	pushl  0x8(%ebp)
     4db:	e8 96 fe ff ff       	call   376 <printint>
     4e0:	83 c4 10             	add    $0x10,%esp
        ap++;
     4e3:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     4e7:	e9 ae 00 00 00       	jmp    59a <printf+0x170>
      } else if(c == 's'){
     4ec:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
     4f0:	75 43                	jne    535 <printf+0x10b>
        s = (char*)*ap;
     4f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
     4f5:	8b 00                	mov    (%eax),%eax
     4f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
     4fa:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
     4fe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     502:	75 25                	jne    529 <printf+0xff>
          s = "(null)";
     504:	c7 45 f4 80 5d 01 00 	movl   $0x15d80,-0xc(%ebp)
        while(*s != 0){
     50b:	eb 1c                	jmp    529 <printf+0xff>
          putc(fd, *s);
     50d:	8b 45 f4             	mov    -0xc(%ebp),%eax
     510:	0f b6 00             	movzbl (%eax),%eax
     513:	0f be c0             	movsbl %al,%eax
     516:	83 ec 08             	sub    $0x8,%esp
     519:	50                   	push   %eax
     51a:	ff 75 08             	pushl  0x8(%ebp)
     51d:	e8 31 fe ff ff       	call   353 <putc>
     522:	83 c4 10             	add    $0x10,%esp
          s++;
     525:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
     529:	8b 45 f4             	mov    -0xc(%ebp),%eax
     52c:	0f b6 00             	movzbl (%eax),%eax
     52f:	84 c0                	test   %al,%al
     531:	75 da                	jne    50d <printf+0xe3>
     533:	eb 65                	jmp    59a <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
     535:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
     539:	75 1d                	jne    558 <printf+0x12e>
        putc(fd, *ap);
     53b:	8b 45 e8             	mov    -0x18(%ebp),%eax
     53e:	8b 00                	mov    (%eax),%eax
     540:	0f be c0             	movsbl %al,%eax
     543:	83 ec 08             	sub    $0x8,%esp
     546:	50                   	push   %eax
     547:	ff 75 08             	pushl  0x8(%ebp)
     54a:	e8 04 fe ff ff       	call   353 <putc>
     54f:	83 c4 10             	add    $0x10,%esp
        ap++;
     552:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     556:	eb 42                	jmp    59a <printf+0x170>
      } else if(c == '%'){
     558:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     55c:	75 17                	jne    575 <printf+0x14b>
        putc(fd, c);
     55e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     561:	0f be c0             	movsbl %al,%eax
     564:	83 ec 08             	sub    $0x8,%esp
     567:	50                   	push   %eax
     568:	ff 75 08             	pushl  0x8(%ebp)
     56b:	e8 e3 fd ff ff       	call   353 <putc>
     570:	83 c4 10             	add    $0x10,%esp
     573:	eb 25                	jmp    59a <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
     575:	83 ec 08             	sub    $0x8,%esp
     578:	6a 25                	push   $0x25
     57a:	ff 75 08             	pushl  0x8(%ebp)
     57d:	e8 d1 fd ff ff       	call   353 <putc>
     582:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
     585:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     588:	0f be c0             	movsbl %al,%eax
     58b:	83 ec 08             	sub    $0x8,%esp
     58e:	50                   	push   %eax
     58f:	ff 75 08             	pushl  0x8(%ebp)
     592:	e8 bc fd ff ff       	call   353 <putc>
     597:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
     59a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
     5a1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     5a5:	8b 55 0c             	mov    0xc(%ebp),%edx
     5a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
     5ab:	01 d0                	add    %edx,%eax
     5ad:	0f b6 00             	movzbl (%eax),%eax
     5b0:	84 c0                	test   %al,%al
     5b2:	0f 85 94 fe ff ff    	jne    44c <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
     5b8:	90                   	nop
     5b9:	c9                   	leave  
     5ba:	c3                   	ret    

000005bb <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
     5bb:	55                   	push   %ebp
     5bc:	89 e5                	mov    %esp,%ebp
     5be:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
     5c1:	8b 45 08             	mov    0x8(%ebp),%eax
     5c4:	83 e8 08             	sub    $0x8,%eax
     5c7:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     5ca:	a1 c8 e4 01 00       	mov    0x1e4c8,%eax
     5cf:	89 45 fc             	mov    %eax,-0x4(%ebp)
     5d2:	eb 24                	jmp    5f8 <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
     5d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
     5d7:	8b 00                	mov    (%eax),%eax
     5d9:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     5dc:	77 12                	ja     5f0 <free+0x35>
     5de:	8b 45 f8             	mov    -0x8(%ebp),%eax
     5e1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     5e4:	77 24                	ja     60a <free+0x4f>
     5e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
     5e9:	8b 00                	mov    (%eax),%eax
     5eb:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     5ee:	77 1a                	ja     60a <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     5f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
     5f3:	8b 00                	mov    (%eax),%eax
     5f5:	89 45 fc             	mov    %eax,-0x4(%ebp)
     5f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
     5fb:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     5fe:	76 d4                	jbe    5d4 <free+0x19>
     600:	8b 45 fc             	mov    -0x4(%ebp),%eax
     603:	8b 00                	mov    (%eax),%eax
     605:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     608:	76 ca                	jbe    5d4 <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
     60a:	8b 45 f8             	mov    -0x8(%ebp),%eax
     60d:	8b 40 04             	mov    0x4(%eax),%eax
     610:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     617:	8b 45 f8             	mov    -0x8(%ebp),%eax
     61a:	01 c2                	add    %eax,%edx
     61c:	8b 45 fc             	mov    -0x4(%ebp),%eax
     61f:	8b 00                	mov    (%eax),%eax
     621:	39 c2                	cmp    %eax,%edx
     623:	75 24                	jne    649 <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
     625:	8b 45 f8             	mov    -0x8(%ebp),%eax
     628:	8b 50 04             	mov    0x4(%eax),%edx
     62b:	8b 45 fc             	mov    -0x4(%ebp),%eax
     62e:	8b 00                	mov    (%eax),%eax
     630:	8b 40 04             	mov    0x4(%eax),%eax
     633:	01 c2                	add    %eax,%edx
     635:	8b 45 f8             	mov    -0x8(%ebp),%eax
     638:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
     63b:	8b 45 fc             	mov    -0x4(%ebp),%eax
     63e:	8b 00                	mov    (%eax),%eax
     640:	8b 10                	mov    (%eax),%edx
     642:	8b 45 f8             	mov    -0x8(%ebp),%eax
     645:	89 10                	mov    %edx,(%eax)
     647:	eb 0a                	jmp    653 <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
     649:	8b 45 fc             	mov    -0x4(%ebp),%eax
     64c:	8b 10                	mov    (%eax),%edx
     64e:	8b 45 f8             	mov    -0x8(%ebp),%eax
     651:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
     653:	8b 45 fc             	mov    -0x4(%ebp),%eax
     656:	8b 40 04             	mov    0x4(%eax),%eax
     659:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     660:	8b 45 fc             	mov    -0x4(%ebp),%eax
     663:	01 d0                	add    %edx,%eax
     665:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     668:	75 20                	jne    68a <free+0xcf>
    p->s.size += bp->s.size;
     66a:	8b 45 fc             	mov    -0x4(%ebp),%eax
     66d:	8b 50 04             	mov    0x4(%eax),%edx
     670:	8b 45 f8             	mov    -0x8(%ebp),%eax
     673:	8b 40 04             	mov    0x4(%eax),%eax
     676:	01 c2                	add    %eax,%edx
     678:	8b 45 fc             	mov    -0x4(%ebp),%eax
     67b:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
     67e:	8b 45 f8             	mov    -0x8(%ebp),%eax
     681:	8b 10                	mov    (%eax),%edx
     683:	8b 45 fc             	mov    -0x4(%ebp),%eax
     686:	89 10                	mov    %edx,(%eax)
     688:	eb 08                	jmp    692 <free+0xd7>
  } else
    p->s.ptr = bp;
     68a:	8b 45 fc             	mov    -0x4(%ebp),%eax
     68d:	8b 55 f8             	mov    -0x8(%ebp),%edx
     690:	89 10                	mov    %edx,(%eax)
  freep = p;
     692:	8b 45 fc             	mov    -0x4(%ebp),%eax
     695:	a3 c8 e4 01 00       	mov    %eax,0x1e4c8
}
     69a:	90                   	nop
     69b:	c9                   	leave  
     69c:	c3                   	ret    

0000069d <morecore>:

static Header*
morecore(uint nu)
{
     69d:	55                   	push   %ebp
     69e:	89 e5                	mov    %esp,%ebp
     6a0:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
     6a3:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
     6aa:	77 07                	ja     6b3 <morecore+0x16>
    nu = 4096;
     6ac:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
     6b3:	8b 45 08             	mov    0x8(%ebp),%eax
     6b6:	c1 e0 03             	shl    $0x3,%eax
     6b9:	83 ec 0c             	sub    $0xc,%esp
     6bc:	50                   	push   %eax
     6bd:	e8 49 fc ff ff       	call   30b <sbrk>
     6c2:	83 c4 10             	add    $0x10,%esp
     6c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
     6c8:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     6cc:	75 07                	jne    6d5 <morecore+0x38>
    return 0;
     6ce:	b8 00 00 00 00       	mov    $0x0,%eax
     6d3:	eb 26                	jmp    6fb <morecore+0x5e>
  hp = (Header*)p;
     6d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
     6d8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
     6db:	8b 45 f0             	mov    -0x10(%ebp),%eax
     6de:	8b 55 08             	mov    0x8(%ebp),%edx
     6e1:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
     6e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
     6e7:	83 c0 08             	add    $0x8,%eax
     6ea:	83 ec 0c             	sub    $0xc,%esp
     6ed:	50                   	push   %eax
     6ee:	e8 c8 fe ff ff       	call   5bb <free>
     6f3:	83 c4 10             	add    $0x10,%esp
  return freep;
     6f6:	a1 c8 e4 01 00       	mov    0x1e4c8,%eax
}
     6fb:	c9                   	leave  
     6fc:	c3                   	ret    

000006fd <malloc>:

void*
malloc(uint nbytes)
{
     6fd:	55                   	push   %ebp
     6fe:	89 e5                	mov    %esp,%ebp
     700:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
     703:	8b 45 08             	mov    0x8(%ebp),%eax
     706:	83 c0 07             	add    $0x7,%eax
     709:	c1 e8 03             	shr    $0x3,%eax
     70c:	83 c0 01             	add    $0x1,%eax
     70f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
     712:	a1 c8 e4 01 00       	mov    0x1e4c8,%eax
     717:	89 45 f0             	mov    %eax,-0x10(%ebp)
     71a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     71e:	75 23                	jne    743 <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
     720:	c7 45 f0 c0 e4 01 00 	movl   $0x1e4c0,-0x10(%ebp)
     727:	8b 45 f0             	mov    -0x10(%ebp),%eax
     72a:	a3 c8 e4 01 00       	mov    %eax,0x1e4c8
     72f:	a1 c8 e4 01 00       	mov    0x1e4c8,%eax
     734:	a3 c0 e4 01 00       	mov    %eax,0x1e4c0
    base.s.size = 0;
     739:	c7 05 c4 e4 01 00 00 	movl   $0x0,0x1e4c4
     740:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     743:	8b 45 f0             	mov    -0x10(%ebp),%eax
     746:	8b 00                	mov    (%eax),%eax
     748:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
     74b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     74e:	8b 40 04             	mov    0x4(%eax),%eax
     751:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     754:	72 4d                	jb     7a3 <malloc+0xa6>
      if(p->s.size == nunits)
     756:	8b 45 f4             	mov    -0xc(%ebp),%eax
     759:	8b 40 04             	mov    0x4(%eax),%eax
     75c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     75f:	75 0c                	jne    76d <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
     761:	8b 45 f4             	mov    -0xc(%ebp),%eax
     764:	8b 10                	mov    (%eax),%edx
     766:	8b 45 f0             	mov    -0x10(%ebp),%eax
     769:	89 10                	mov    %edx,(%eax)
     76b:	eb 26                	jmp    793 <malloc+0x96>
      else {
        p->s.size -= nunits;
     76d:	8b 45 f4             	mov    -0xc(%ebp),%eax
     770:	8b 40 04             	mov    0x4(%eax),%eax
     773:	2b 45 ec             	sub    -0x14(%ebp),%eax
     776:	89 c2                	mov    %eax,%edx
     778:	8b 45 f4             	mov    -0xc(%ebp),%eax
     77b:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
     77e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     781:	8b 40 04             	mov    0x4(%eax),%eax
     784:	c1 e0 03             	shl    $0x3,%eax
     787:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
     78a:	8b 45 f4             	mov    -0xc(%ebp),%eax
     78d:	8b 55 ec             	mov    -0x14(%ebp),%edx
     790:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
     793:	8b 45 f0             	mov    -0x10(%ebp),%eax
     796:	a3 c8 e4 01 00       	mov    %eax,0x1e4c8
      return (void*)(p + 1);
     79b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     79e:	83 c0 08             	add    $0x8,%eax
     7a1:	eb 3b                	jmp    7de <malloc+0xe1>
    }
    if(p == freep)
     7a3:	a1 c8 e4 01 00       	mov    0x1e4c8,%eax
     7a8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     7ab:	75 1e                	jne    7cb <malloc+0xce>
      if((p = morecore(nunits)) == 0)
     7ad:	83 ec 0c             	sub    $0xc,%esp
     7b0:	ff 75 ec             	pushl  -0x14(%ebp)
     7b3:	e8 e5 fe ff ff       	call   69d <morecore>
     7b8:	83 c4 10             	add    $0x10,%esp
     7bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
     7be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     7c2:	75 07                	jne    7cb <malloc+0xce>
        return 0;
     7c4:	b8 00 00 00 00       	mov    $0x0,%eax
     7c9:	eb 13                	jmp    7de <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     7cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
     7d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7d4:	8b 00                	mov    (%eax),%eax
     7d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
     7d9:	e9 6d ff ff ff       	jmp    74b <malloc+0x4e>
}
     7de:	c9                   	leave  
     7df:	c3                   	ret    

000007e0 <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
     7e0:	55                   	push   %ebp
     7e1:	89 e5                	mov    %esp,%ebp
    ++g_seed;
     7e3:	a1 cc e4 01 00       	mov    0x1e4cc,%eax
     7e8:	83 c0 01             	add    $0x1,%eax
     7eb:	a3 cc e4 01 00       	mov    %eax,0x1e4cc
    g_seed = (214013*g_seed+2531011);
     7f0:	a1 cc e4 01 00       	mov    0x1e4cc,%eax
     7f5:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
     7fb:	05 c3 9e 26 00       	add    $0x269ec3,%eax
     800:	a3 cc e4 01 00       	mov    %eax,0x1e4cc
    return (g_seed>>16)&0x7FFF;
     805:	a1 cc e4 01 00       	mov    0x1e4cc,%eax
     80a:	c1 e8 10             	shr    $0x10,%eax
     80d:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
     812:	5d                   	pop    %ebp
     813:	c3                   	ret    

00000814 <abs>:

#define PI 3.1415926536

float abs(float x) 
{
     814:	55                   	push   %ebp
     815:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
     817:	d9 45 08             	flds   0x8(%ebp)
     81a:	d9 ee                	fldz   
     81c:	d9 c9                	fxch   %st(1)
     81e:	df e9                	fucomip %st(1),%st
     820:	dd d8                	fstp   %st(0)
     822:	76 05                	jbe    829 <abs+0x15>
     824:	d9 45 08             	flds   0x8(%ebp)
     827:	eb 05                	jmp    82e <abs+0x1a>
	return -x;
     829:	d9 45 08             	flds   0x8(%ebp)
     82c:	d9 e0                	fchs   
}
     82e:	5d                   	pop    %ebp
     82f:	c3                   	ret    

00000830 <pow>:

float pow(float a, int b)
{
     830:	55                   	push   %ebp
     831:	89 e5                	mov    %esp,%ebp
     833:	83 ec 10             	sub    $0x10,%esp
	float r = a;
     836:	d9 45 08             	flds   0x8(%ebp)
     839:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
     83c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     840:	7e 17                	jle    859 <pow+0x29>
		while (--b)
     842:	eb 09                	jmp    84d <pow+0x1d>
			r *= a;
     844:	d9 45 fc             	flds   -0x4(%ebp)
     847:	d8 4d 08             	fmuls  0x8(%ebp)
     84a:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
     84d:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
     851:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     855:	75 ed                	jne    844 <pow+0x14>
     857:	eb 2a                	jmp    883 <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
     859:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     85d:	79 1f                	jns    87e <pow+0x4e>
		while (++b)
     85f:	eb 09                	jmp    86a <pow+0x3a>
			r *= a;
     861:	d9 45 fc             	flds   -0x4(%ebp)
     864:	d8 4d 08             	fmuls  0x8(%ebp)
     867:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
     86a:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
     86e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     872:	75 ed                	jne    861 <pow+0x31>
			r *= a;
		r = 1.0 / r;
     874:	d9 e8                	fld1   
     876:	d8 75 fc             	fdivs  -0x4(%ebp)
     879:	d9 5d fc             	fstps  -0x4(%ebp)
     87c:	eb 05                	jmp    883 <pow+0x53>
	}
	else r = 0;
     87e:	d9 ee                	fldz   
     880:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
     883:	d9 45 fc             	flds   -0x4(%ebp)
}
     886:	c9                   	leave  
     887:	c3                   	ret    

00000888 <sqrt>:

float sqrt(float number) {
     888:	55                   	push   %ebp
     889:	89 e5                	mov    %esp,%ebp
     88b:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
     88e:	d9 ee                	fldz   
     890:	d9 45 08             	flds   0x8(%ebp)
     893:	d9 c9                	fxch   %st(1)
     895:	df e9                	fucomip %st(1),%st
     897:	dd d8                	fstp   %st(0)
     899:	76 06                	jbe    8a1 <sqrt+0x19>
		return -1;
     89b:	d9 e8                	fld1   
     89d:	d9 e0                	fchs   
     89f:	eb 3a                	jmp    8db <sqrt+0x53>
	}

	new_guess = 1;
     8a1:	d9 e8                	fld1   
     8a3:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
     8a6:	d9 45 fc             	flds   -0x4(%ebp)
     8a9:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
     8ac:	d9 45 08             	flds   0x8(%ebp)
     8af:	d8 75 f8             	fdivs  -0x8(%ebp)
     8b2:	d8 45 f8             	fadds  -0x8(%ebp)
     8b5:	d9 05 88 5d 01 00    	flds   0x15d88
     8bb:	de f9                	fdivrp %st,%st(1)
     8bd:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
     8c0:	d9 45 fc             	flds   -0x4(%ebp)
     8c3:	d9 45 f8             	flds   -0x8(%ebp)
     8c6:	df e9                	fucomip %st(1),%st
     8c8:	dd d8                	fstp   %st(0)
     8ca:	7a da                	jp     8a6 <sqrt+0x1e>
     8cc:	d9 45 fc             	flds   -0x4(%ebp)
     8cf:	d9 45 f8             	flds   -0x8(%ebp)
     8d2:	df e9                	fucomip %st(1),%st
     8d4:	dd d8                	fstp   %st(0)
     8d6:	75 ce                	jne    8a6 <sqrt+0x1e>

	return new_guess;
     8d8:	d9 45 fc             	flds   -0x4(%ebp)
}
     8db:	c9                   	leave  
     8dc:	c3                   	ret    

000008dd <cos>:

float cos(float x)
{
     8dd:	55                   	push   %ebp
     8de:	89 e5                	mov    %esp,%ebp
     8e0:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     8e3:	d9 e8                	fld1   
     8e5:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     8e8:	d9 45 08             	flds   0x8(%ebp)
     8eb:	dd 05 90 5d 01 00    	fldl   0x15d90
     8f1:	d9 c9                	fxch   %st(1)
     8f3:	df e9                	fucomip %st(1),%st
     8f5:	dd d8                	fstp   %st(0)
     8f7:	77 0f                	ja     908 <cos+0x2b>
     8f9:	d9 45 08             	flds   0x8(%ebp)
     8fc:	dd 05 98 5d 01 00    	fldl   0x15d98
     902:	df e9                	fucomip %st(1),%st
     904:	dd d8                	fstp   %st(0)
     906:	76 3c                	jbe    944 <cos+0x67>
     908:	d9 45 08             	flds   0x8(%ebp)
     90b:	d9 45 08             	flds   0x8(%ebp)
     90e:	dd 05 90 5d 01 00    	fldl   0x15d90
     914:	de f9                	fdivrp %st,%st(1)
     916:	d9 7d e2             	fnstcw -0x1e(%ebp)
     919:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     91d:	b4 0c                	mov    $0xc,%ah
     91f:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     923:	d9 6d e0             	fldcw  -0x20(%ebp)
     926:	db 5d dc             	fistpl -0x24(%ebp)
     929:	d9 6d e2             	fldcw  -0x1e(%ebp)
     92c:	8b 45 dc             	mov    -0x24(%ebp),%eax
     92f:	01 c0                	add    %eax,%eax
     931:	89 45 d8             	mov    %eax,-0x28(%ebp)
     934:	db 45 d8             	fildl  -0x28(%ebp)
     937:	dd 05 a0 5d 01 00    	fldl   0x15da0
     93d:	de c9                	fmulp  %st,%st(1)
     93f:	de e9                	fsubrp %st,%st(1)
     941:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     944:	d9 45 08             	flds   0x8(%ebp)
     947:	dd 05 a0 5d 01 00    	fldl   0x15da0
     94d:	d9 c9                	fxch   %st(1)
     94f:	df e9                	fucomip %st(1),%st
     951:	dd d8                	fstp   %st(0)
     953:	76 0e                	jbe    963 <cos+0x86>
     955:	d9 45 08             	flds   0x8(%ebp)
     958:	dd 05 90 5d 01 00    	fldl   0x15d90
     95e:	de e9                	fsubrp %st,%st(1)
     960:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     963:	d9 45 08             	flds   0x8(%ebp)
     966:	dd 05 a8 5d 01 00    	fldl   0x15da8
     96c:	df e9                	fucomip %st(1),%st
     96e:	dd d8                	fstp   %st(0)
     970:	76 0e                	jbe    980 <cos+0xa3>
     972:	d9 45 08             	flds   0x8(%ebp)
     975:	dd 05 90 5d 01 00    	fldl   0x15d90
     97b:	de c1                	faddp  %st,%st(1)
     97d:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     980:	d9 45 08             	flds   0x8(%ebp)
     983:	dd 05 b0 5d 01 00    	fldl   0x15db0
     989:	d9 c9                	fxch   %st(1)
     98b:	df e9                	fucomip %st(1),%st
     98d:	dd d8                	fstp   %st(0)
     98f:	76 16                	jbe    9a7 <cos+0xca>
    {
        x -= PI;
     991:	d9 45 08             	flds   0x8(%ebp)
     994:	dd 05 a0 5d 01 00    	fldl   0x15da0
     99a:	de e9                	fsubrp %st,%st(1)
     99c:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     99f:	d9 45 f4             	flds   -0xc(%ebp)
     9a2:	d9 e0                	fchs   
     9a4:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     9a7:	d9 45 08             	flds   0x8(%ebp)
     9aa:	dd 05 b8 5d 01 00    	fldl   0x15db8
     9b0:	df e9                	fucomip %st(1),%st
     9b2:	dd d8                	fstp   %st(0)
     9b4:	76 16                	jbe    9cc <cos+0xef>
    {
        x += PI;
     9b6:	d9 45 08             	flds   0x8(%ebp)
     9b9:	dd 05 a0 5d 01 00    	fldl   0x15da0
     9bf:	de c1                	faddp  %st,%st(1)
     9c1:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     9c4:	d9 45 f4             	flds   -0xc(%ebp)
     9c7:	d9 e0                	fchs   
     9c9:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
     9cc:	d9 45 08             	flds   0x8(%ebp)
     9cf:	dd 05 c0 5d 01 00    	fldl   0x15dc0
     9d5:	d9 c9                	fxch   %st(1)
     9d7:	df e9                	fucomip %st(1),%st
     9d9:	dd d8                	fstp   %st(0)
     9db:	76 28                	jbe    a05 <cos+0x128>
     9dd:	d9 45 08             	flds   0x8(%ebp)
     9e0:	dd 05 b0 5d 01 00    	fldl   0x15db0
     9e6:	de e1                	fsubp  %st,%st(1)
     9e8:	d9 5d e4             	fstps  -0x1c(%ebp)
     9eb:	d9 45 e4             	flds   -0x1c(%ebp)
     9ee:	83 ec 0c             	sub    $0xc,%esp
     9f1:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     9f5:	d9 1c 24             	fstps  (%esp)
     9f8:	e8 83 00 00 00       	call   a80 <sin>
     9fd:	83 c4 10             	add    $0x10,%esp
     a00:	d8 4d f4             	fmuls  -0xc(%ebp)
     a03:	eb 79                	jmp    a7e <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
     a05:	83 ec 08             	sub    $0x8,%esp
     a08:	6a 02                	push   $0x2
     a0a:	ff 75 08             	pushl  0x8(%ebp)
     a0d:	e8 1e fe ff ff       	call   830 <pow>
     a12:	83 c4 10             	add    $0x10,%esp
     a15:	d9 05 88 5d 01 00    	flds   0x15d88
     a1b:	de f9                	fdivrp %st,%st(1)
     a1d:	d9 e8                	fld1   
     a1f:	de e1                	fsubp  %st,%st(1)
     a21:	d9 5d d8             	fstps  -0x28(%ebp)
     a24:	83 ec 08             	sub    $0x8,%esp
     a27:	6a 04                	push   $0x4
     a29:	ff 75 08             	pushl  0x8(%ebp)
     a2c:	e8 ff fd ff ff       	call   830 <pow>
     a31:	83 c4 10             	add    $0x10,%esp
     a34:	d9 05 c8 5d 01 00    	flds   0x15dc8
     a3a:	de f9                	fdivrp %st,%st(1)
     a3c:	d8 45 d8             	fadds  -0x28(%ebp)
     a3f:	d9 5d d8             	fstps  -0x28(%ebp)
     a42:	83 ec 08             	sub    $0x8,%esp
     a45:	6a 06                	push   $0x6
     a47:	ff 75 08             	pushl  0x8(%ebp)
     a4a:	e8 e1 fd ff ff       	call   830 <pow>
     a4f:	83 c4 10             	add    $0x10,%esp
     a52:	d9 05 cc 5d 01 00    	flds   0x15dcc
     a58:	de f9                	fdivrp %st,%st(1)
     a5a:	d8 6d d8             	fsubrs -0x28(%ebp)
     a5d:	d9 5d d8             	fstps  -0x28(%ebp)
     a60:	83 ec 08             	sub    $0x8,%esp
     a63:	6a 08                	push   $0x8
     a65:	ff 75 08             	pushl  0x8(%ebp)
     a68:	e8 c3 fd ff ff       	call   830 <pow>
     a6d:	83 c4 10             	add    $0x10,%esp
     a70:	d9 05 d0 5d 01 00    	flds   0x15dd0
     a76:	de f9                	fdivrp %st,%st(1)
     a78:	d8 45 d8             	fadds  -0x28(%ebp)
     a7b:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     a7e:	c9                   	leave  
     a7f:	c3                   	ret    

00000a80 <sin>:

float sin(float x)
{
     a80:	55                   	push   %ebp
     a81:	89 e5                	mov    %esp,%ebp
     a83:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     a86:	d9 e8                	fld1   
     a88:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     a8b:	d9 45 08             	flds   0x8(%ebp)
     a8e:	dd 05 90 5d 01 00    	fldl   0x15d90
     a94:	d9 c9                	fxch   %st(1)
     a96:	df e9                	fucomip %st(1),%st
     a98:	dd d8                	fstp   %st(0)
     a9a:	77 0f                	ja     aab <sin+0x2b>
     a9c:	d9 45 08             	flds   0x8(%ebp)
     a9f:	dd 05 98 5d 01 00    	fldl   0x15d98
     aa5:	df e9                	fucomip %st(1),%st
     aa7:	dd d8                	fstp   %st(0)
     aa9:	76 3c                	jbe    ae7 <sin+0x67>
     aab:	d9 45 08             	flds   0x8(%ebp)
     aae:	d9 45 08             	flds   0x8(%ebp)
     ab1:	dd 05 90 5d 01 00    	fldl   0x15d90
     ab7:	de f9                	fdivrp %st,%st(1)
     ab9:	d9 7d e2             	fnstcw -0x1e(%ebp)
     abc:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     ac0:	b4 0c                	mov    $0xc,%ah
     ac2:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     ac6:	d9 6d e0             	fldcw  -0x20(%ebp)
     ac9:	db 5d dc             	fistpl -0x24(%ebp)
     acc:	d9 6d e2             	fldcw  -0x1e(%ebp)
     acf:	8b 45 dc             	mov    -0x24(%ebp),%eax
     ad2:	01 c0                	add    %eax,%eax
     ad4:	89 45 d8             	mov    %eax,-0x28(%ebp)
     ad7:	db 45 d8             	fildl  -0x28(%ebp)
     ada:	dd 05 a0 5d 01 00    	fldl   0x15da0
     ae0:	de c9                	fmulp  %st,%st(1)
     ae2:	de e9                	fsubrp %st,%st(1)
     ae4:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     ae7:	d9 45 08             	flds   0x8(%ebp)
     aea:	dd 05 a0 5d 01 00    	fldl   0x15da0
     af0:	d9 c9                	fxch   %st(1)
     af2:	df e9                	fucomip %st(1),%st
     af4:	dd d8                	fstp   %st(0)
     af6:	76 0e                	jbe    b06 <sin+0x86>
     af8:	d9 45 08             	flds   0x8(%ebp)
     afb:	dd 05 90 5d 01 00    	fldl   0x15d90
     b01:	de e9                	fsubrp %st,%st(1)
     b03:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     b06:	d9 45 08             	flds   0x8(%ebp)
     b09:	dd 05 a8 5d 01 00    	fldl   0x15da8
     b0f:	df e9                	fucomip %st(1),%st
     b11:	dd d8                	fstp   %st(0)
     b13:	76 0e                	jbe    b23 <sin+0xa3>
     b15:	d9 45 08             	flds   0x8(%ebp)
     b18:	dd 05 90 5d 01 00    	fldl   0x15d90
     b1e:	de c1                	faddp  %st,%st(1)
     b20:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     b23:	d9 45 08             	flds   0x8(%ebp)
     b26:	dd 05 b0 5d 01 00    	fldl   0x15db0
     b2c:	d9 c9                	fxch   %st(1)
     b2e:	df e9                	fucomip %st(1),%st
     b30:	dd d8                	fstp   %st(0)
     b32:	76 16                	jbe    b4a <sin+0xca>
    {
        x -= PI;
     b34:	d9 45 08             	flds   0x8(%ebp)
     b37:	dd 05 a0 5d 01 00    	fldl   0x15da0
     b3d:	de e9                	fsubrp %st,%st(1)
     b3f:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     b42:	d9 45 f4             	flds   -0xc(%ebp)
     b45:	d9 e0                	fchs   
     b47:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     b4a:	d9 45 08             	flds   0x8(%ebp)
     b4d:	dd 05 b8 5d 01 00    	fldl   0x15db8
     b53:	df e9                	fucomip %st(1),%st
     b55:	dd d8                	fstp   %st(0)
     b57:	76 16                	jbe    b6f <sin+0xef>
    {
        x += PI;
     b59:	d9 45 08             	flds   0x8(%ebp)
     b5c:	dd 05 a0 5d 01 00    	fldl   0x15da0
     b62:	de c1                	faddp  %st,%st(1)
     b64:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     b67:	d9 45 f4             	flds   -0xc(%ebp)
     b6a:	d9 e0                	fchs   
     b6c:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
     b6f:	d9 ee                	fldz   
     b71:	d9 45 08             	flds   0x8(%ebp)
     b74:	d9 c9                	fxch   %st(1)
     b76:	df e9                	fucomip %st(1),%st
     b78:	dd d8                	fstp   %st(0)
     b7a:	76 10                	jbe    b8c <sin+0x10c>
    {
        x *= -1;
     b7c:	d9 45 08             	flds   0x8(%ebp)
     b7f:	d9 e0                	fchs   
     b81:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     b84:	d9 45 f4             	flds   -0xc(%ebp)
     b87:	d9 e0                	fchs   
     b89:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
     b8c:	d9 45 08             	flds   0x8(%ebp)
     b8f:	dd 05 c0 5d 01 00    	fldl   0x15dc0
     b95:	d9 c9                	fxch   %st(1)
     b97:	df e9                	fucomip %st(1),%st
     b99:	dd d8                	fstp   %st(0)
     b9b:	76 28                	jbe    bc5 <sin+0x145>
     b9d:	d9 45 08             	flds   0x8(%ebp)
     ba0:	dd 05 b0 5d 01 00    	fldl   0x15db0
     ba6:	de e1                	fsubp  %st,%st(1)
     ba8:	d9 5d e4             	fstps  -0x1c(%ebp)
     bab:	d9 45 e4             	flds   -0x1c(%ebp)
     bae:	83 ec 0c             	sub    $0xc,%esp
     bb1:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     bb5:	d9 1c 24             	fstps  (%esp)
     bb8:	e8 20 fd ff ff       	call   8dd <cos>
     bbd:	83 c4 10             	add    $0x10,%esp
     bc0:	d8 4d f4             	fmuls  -0xc(%ebp)
     bc3:	eb 7a                	jmp    c3f <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
     bc5:	83 ec 08             	sub    $0x8,%esp
     bc8:	6a 03                	push   $0x3
     bca:	ff 75 08             	pushl  0x8(%ebp)
     bcd:	e8 5e fc ff ff       	call   830 <pow>
     bd2:	83 c4 10             	add    $0x10,%esp
     bd5:	d9 05 d4 5d 01 00    	flds   0x15dd4
     bdb:	de f9                	fdivrp %st,%st(1)
     bdd:	d9 45 08             	flds   0x8(%ebp)
     be0:	de e1                	fsubp  %st,%st(1)
     be2:	d9 5d d8             	fstps  -0x28(%ebp)
     be5:	83 ec 08             	sub    $0x8,%esp
     be8:	6a 05                	push   $0x5
     bea:	ff 75 08             	pushl  0x8(%ebp)
     bed:	e8 3e fc ff ff       	call   830 <pow>
     bf2:	83 c4 10             	add    $0x10,%esp
     bf5:	d9 05 d8 5d 01 00    	flds   0x15dd8
     bfb:	de f9                	fdivrp %st,%st(1)
     bfd:	d8 45 d8             	fadds  -0x28(%ebp)
     c00:	d9 5d d8             	fstps  -0x28(%ebp)
     c03:	83 ec 08             	sub    $0x8,%esp
     c06:	6a 07                	push   $0x7
     c08:	ff 75 08             	pushl  0x8(%ebp)
     c0b:	e8 20 fc ff ff       	call   830 <pow>
     c10:	83 c4 10             	add    $0x10,%esp
     c13:	d9 05 dc 5d 01 00    	flds   0x15ddc
     c19:	de f9                	fdivrp %st,%st(1)
     c1b:	d8 6d d8             	fsubrs -0x28(%ebp)
     c1e:	d9 5d d8             	fstps  -0x28(%ebp)
     c21:	83 ec 08             	sub    $0x8,%esp
     c24:	6a 09                	push   $0x9
     c26:	ff 75 08             	pushl  0x8(%ebp)
     c29:	e8 02 fc ff ff       	call   830 <pow>
     c2e:	83 c4 10             	add    $0x10,%esp
     c31:	d9 05 e0 5d 01 00    	flds   0x15de0
     c37:	de f9                	fdivrp %st,%st(1)
     c39:	d8 45 d8             	fadds  -0x28(%ebp)
     c3c:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     c3f:	c9                   	leave  
     c40:	c3                   	ret    

00000c41 <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
     c41:	55                   	push   %ebp
     c42:	89 e5                	mov    %esp,%ebp
     c44:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
     c47:	83 ec 04             	sub    $0x4,%esp
     c4a:	6a 0e                	push   $0xe
     c4c:	ff 75 0c             	pushl  0xc(%ebp)
     c4f:	ff 75 08             	pushl  0x8(%ebp)
     c52:	e8 44 f6 ff ff       	call   29b <read>
     c57:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
     c5a:	83 ec 04             	sub    $0x4,%esp
     c5d:	6a 28                	push   $0x28
     c5f:	ff 75 10             	pushl  0x10(%ebp)
     c62:	ff 75 08             	pushl  0x8(%ebp)
     c65:	e8 31 f6 ff ff       	call   29b <read>
     c6a:	83 c4 10             	add    $0x10,%esp
}
     c6d:	90                   	nop
     c6e:	c9                   	leave  
     c6f:	c3                   	ret    

00000c70 <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
     c70:	55                   	push   %ebp
     c71:	89 e5                	mov    %esp,%ebp
     c73:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     c79:	83 ec 08             	sub    $0x8,%esp
     c7c:	6a 00                	push   $0x0
     c7e:	ff 75 08             	pushl  0x8(%ebp)
     c81:	e8 3d f6 ff ff       	call   2c3 <open>
     c86:	83 c4 10             	add    $0x10,%esp
     c89:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     c8c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     c90:	79 0a                	jns    c9c <readBitmapFile+0x2c>
        return -1;
     c92:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     c97:	e9 6e 01 00 00       	jmp    e0a <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     c9c:	83 ec 04             	sub    $0x4,%esp
     c9f:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     ca2:	50                   	push   %eax
     ca3:	8d 45 ca             	lea    -0x36(%ebp),%eax
     ca6:	50                   	push   %eax
     ca7:	ff 75 ec             	pushl  -0x14(%ebp)
     caa:	e8 92 ff ff ff       	call   c41 <readBitmapHeader>
     caf:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     cb2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     cb5:	83 e8 36             	sub    $0x36,%eax
     cb8:	83 ec 04             	sub    $0x4,%esp
     cbb:	50                   	push   %eax
     cbc:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     cc2:	50                   	push   %eax
     cc3:	ff 75 ec             	pushl  -0x14(%ebp)
     cc6:	e8 d0 f5 ff ff       	call   29b <read>
     ccb:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     cce:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     cd1:	8b 45 14             	mov    0x14(%ebp),%eax
     cd4:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     cd6:	8b 55 aa             	mov    -0x56(%ebp),%edx
     cd9:	8b 45 10             	mov    0x10(%ebp),%eax
     cdc:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     cde:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     ce1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     ce4:	8b 45 aa             	mov    -0x56(%ebp),%eax
     ce7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     cea:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     cee:	0f b7 c0             	movzwl %ax,%eax
     cf1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
     cf4:	8b 45 e8             	mov    -0x18(%ebp),%eax
     cf7:	0f af 45 e0          	imul   -0x20(%ebp),%eax
     cfb:	8d 50 07             	lea    0x7(%eax),%edx
     cfe:	85 c0                	test   %eax,%eax
     d00:	0f 48 c2             	cmovs  %edx,%eax
     d03:	c1 f8 03             	sar    $0x3,%eax
     d06:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     d09:	8b 45 0c             	mov    0xc(%ebp),%eax
     d0c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     d0f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     d12:	83 e8 01             	sub    $0x1,%eax
     d15:	89 45 f4             	mov    %eax,-0xc(%ebp)
     d18:	e9 d0 00 00 00       	jmp    ded <readBitmapFile+0x17d>
        if (bits == 32) {
     d1d:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
     d21:	75 22                	jne    d45 <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     d23:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d26:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     d2a:	89 c2                	mov    %eax,%edx
     d2c:	8b 45 d8             	mov    -0x28(%ebp),%eax
     d2f:	01 d0                	add    %edx,%eax
     d31:	83 ec 04             	sub    $0x4,%esp
     d34:	ff 75 dc             	pushl  -0x24(%ebp)
     d37:	50                   	push   %eax
     d38:	ff 75 ec             	pushl  -0x14(%ebp)
     d3b:	e8 5b f5 ff ff       	call   29b <read>
     d40:	83 c4 10             	add    $0x10,%esp
     d43:	eb 65                	jmp    daa <readBitmapFile+0x13a>
        } else {
            int j = 0;
     d45:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     d4c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     d53:	eb 4d                	jmp    da2 <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
     d55:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d58:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     d5c:	c1 e0 02             	shl    $0x2,%eax
     d5f:	89 c2                	mov    %eax,%edx
     d61:	8b 45 f0             	mov    -0x10(%ebp),%eax
     d64:	c1 e0 02             	shl    $0x2,%eax
     d67:	01 c2                	add    %eax,%edx
     d69:	8b 45 d8             	mov    -0x28(%ebp),%eax
     d6c:	01 d0                	add    %edx,%eax
     d6e:	83 ec 04             	sub    $0x4,%esp
     d71:	6a 03                	push   $0x3
     d73:	50                   	push   %eax
     d74:	ff 75 ec             	pushl  -0x14(%ebp)
     d77:	e8 1f f5 ff ff       	call   29b <read>
     d7c:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
     d7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d82:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     d86:	c1 e0 02             	shl    $0x2,%eax
     d89:	89 c2                	mov    %eax,%edx
     d8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
     d8e:	c1 e0 02             	shl    $0x2,%eax
     d91:	01 d0                	add    %edx,%eax
     d93:	8d 50 03             	lea    0x3(%eax),%edx
     d96:	8b 45 d8             	mov    -0x28(%ebp),%eax
     d99:	01 d0                	add    %edx,%eax
     d9b:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
     d9e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     da2:	8b 45 f0             	mov    -0x10(%ebp),%eax
     da5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     da8:	7c ab                	jl     d55 <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
     daa:	8b 45 dc             	mov    -0x24(%ebp),%eax
     dad:	99                   	cltd   
     dae:	c1 ea 1e             	shr    $0x1e,%edx
     db1:	01 d0                	add    %edx,%eax
     db3:	83 e0 03             	and    $0x3,%eax
     db6:	29 d0                	sub    %edx,%eax
     db8:	85 c0                	test   %eax,%eax
     dba:	7e 2d                	jle    de9 <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
     dbc:	8b 45 dc             	mov    -0x24(%ebp),%eax
     dbf:	99                   	cltd   
     dc0:	c1 ea 1e             	shr    $0x1e,%edx
     dc3:	01 d0                	add    %edx,%eax
     dc5:	83 e0 03             	and    $0x3,%eax
     dc8:	29 d0                	sub    %edx,%eax
     dca:	ba 04 00 00 00       	mov    $0x4,%edx
     dcf:	29 c2                	sub    %eax,%edx
     dd1:	89 d0                	mov    %edx,%eax
     dd3:	83 ec 04             	sub    $0x4,%esp
     dd6:	50                   	push   %eax
     dd7:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     ddd:	50                   	push   %eax
     dde:	ff 75 ec             	pushl  -0x14(%ebp)
     de1:	e8 b5 f4 ff ff       	call   29b <read>
     de6:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
     de9:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     ded:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     df1:	0f 89 26 ff ff ff    	jns    d1d <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
     df7:	83 ec 0c             	sub    $0xc,%esp
     dfa:	ff 75 ec             	pushl  -0x14(%ebp)
     dfd:	e8 a9 f4 ff ff       	call   2ab <close>
     e02:	83 c4 10             	add    $0x10,%esp
    return 0;
     e05:	b8 00 00 00 00       	mov    $0x0,%eax
}
     e0a:	c9                   	leave  
     e0b:	c3                   	ret    

00000e0c <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
     e0c:	55                   	push   %ebp
     e0d:	89 e5                	mov    %esp,%ebp
     e0f:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     e15:	83 ec 08             	sub    $0x8,%esp
     e18:	6a 00                	push   $0x0
     e1a:	ff 75 08             	pushl  0x8(%ebp)
     e1d:	e8 a1 f4 ff ff       	call   2c3 <open>
     e22:	83 c4 10             	add    $0x10,%esp
     e25:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     e28:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     e2c:	79 0a                	jns    e38 <read24BitmapFile+0x2c>
        return -1;
     e2e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     e33:	e9 66 01 00 00       	jmp    f9e <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     e38:	83 ec 04             	sub    $0x4,%esp
     e3b:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     e3e:	50                   	push   %eax
     e3f:	8d 45 ca             	lea    -0x36(%ebp),%eax
     e42:	50                   	push   %eax
     e43:	ff 75 ec             	pushl  -0x14(%ebp)
     e46:	e8 f6 fd ff ff       	call   c41 <readBitmapHeader>
     e4b:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     e4e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     e51:	83 e8 36             	sub    $0x36,%eax
     e54:	83 ec 04             	sub    $0x4,%esp
     e57:	50                   	push   %eax
     e58:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     e5e:	50                   	push   %eax
     e5f:	ff 75 ec             	pushl  -0x14(%ebp)
     e62:	e8 34 f4 ff ff       	call   29b <read>
     e67:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     e6a:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     e6d:	8b 45 14             	mov    0x14(%ebp),%eax
     e70:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     e72:	8b 55 aa             	mov    -0x56(%ebp),%edx
     e75:	8b 45 10             	mov    0x10(%ebp),%eax
     e78:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     e7a:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     e7d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     e80:	8b 45 aa             	mov    -0x56(%ebp),%eax
     e83:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     e86:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     e8a:	0f b7 c0             	movzwl %ax,%eax
     e8d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
     e90:	8b 55 e8             	mov    -0x18(%ebp),%edx
     e93:	89 d0                	mov    %edx,%eax
     e95:	01 c0                	add    %eax,%eax
     e97:	01 d0                	add    %edx,%eax
     e99:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     e9c:	8b 45 0c             	mov    0xc(%ebp),%eax
     e9f:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     ea2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     ea5:	83 e8 01             	sub    $0x1,%eax
     ea8:	89 45 f4             	mov    %eax,-0xc(%ebp)
     eab:	e9 d1 00 00 00       	jmp    f81 <read24BitmapFile+0x175>
        if (bits == 24) {
     eb0:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
     eb4:	75 22                	jne    ed8 <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     eb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
     eb9:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     ebd:	89 c2                	mov    %eax,%edx
     ebf:	8b 45 d8             	mov    -0x28(%ebp),%eax
     ec2:	01 d0                	add    %edx,%eax
     ec4:	83 ec 04             	sub    $0x4,%esp
     ec7:	ff 75 dc             	pushl  -0x24(%ebp)
     eca:	50                   	push   %eax
     ecb:	ff 75 ec             	pushl  -0x14(%ebp)
     ece:	e8 c8 f3 ff ff       	call   29b <read>
     ed3:	83 c4 10             	add    $0x10,%esp
     ed6:	eb 66                	jmp    f3e <read24BitmapFile+0x132>
        } else {
            int j = 0;
     ed8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     edf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     ee6:	eb 4e                	jmp    f36 <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
     ee8:	8b 45 f4             	mov    -0xc(%ebp),%eax
     eeb:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     eef:	89 c2                	mov    %eax,%edx
     ef1:	89 d0                	mov    %edx,%eax
     ef3:	01 c0                	add    %eax,%eax
     ef5:	01 d0                	add    %edx,%eax
     ef7:	89 c1                	mov    %eax,%ecx
     ef9:	8b 55 f0             	mov    -0x10(%ebp),%edx
     efc:	89 d0                	mov    %edx,%eax
     efe:	01 c0                	add    %eax,%eax
     f00:	01 d0                	add    %edx,%eax
     f02:	8d 14 01             	lea    (%ecx,%eax,1),%edx
     f05:	8b 45 d8             	mov    -0x28(%ebp),%eax
     f08:	01 d0                	add    %edx,%eax
     f0a:	83 ec 04             	sub    $0x4,%esp
     f0d:	6a 03                	push   $0x3
     f0f:	50                   	push   %eax
     f10:	ff 75 ec             	pushl  -0x14(%ebp)
     f13:	e8 83 f3 ff ff       	call   29b <read>
     f18:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
     f1b:	83 ec 04             	sub    $0x4,%esp
     f1e:	6a 01                	push   $0x1
     f20:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     f26:	50                   	push   %eax
     f27:	ff 75 ec             	pushl  -0x14(%ebp)
     f2a:	e8 6c f3 ff ff       	call   29b <read>
     f2f:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
     f32:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     f36:	8b 45 f0             	mov    -0x10(%ebp),%eax
     f39:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     f3c:	7c aa                	jl     ee8 <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
     f3e:	8b 45 dc             	mov    -0x24(%ebp),%eax
     f41:	99                   	cltd   
     f42:	c1 ea 1e             	shr    $0x1e,%edx
     f45:	01 d0                	add    %edx,%eax
     f47:	83 e0 03             	and    $0x3,%eax
     f4a:	29 d0                	sub    %edx,%eax
     f4c:	85 c0                	test   %eax,%eax
     f4e:	7e 2d                	jle    f7d <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
     f50:	8b 45 dc             	mov    -0x24(%ebp),%eax
     f53:	99                   	cltd   
     f54:	c1 ea 1e             	shr    $0x1e,%edx
     f57:	01 d0                	add    %edx,%eax
     f59:	83 e0 03             	and    $0x3,%eax
     f5c:	29 d0                	sub    %edx,%eax
     f5e:	ba 04 00 00 00       	mov    $0x4,%edx
     f63:	29 c2                	sub    %eax,%edx
     f65:	89 d0                	mov    %edx,%eax
     f67:	83 ec 04             	sub    $0x4,%esp
     f6a:	50                   	push   %eax
     f6b:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     f71:	50                   	push   %eax
     f72:	ff 75 ec             	pushl  -0x14(%ebp)
     f75:	e8 21 f3 ff ff       	call   29b <read>
     f7a:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
     f7d:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     f81:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     f85:	0f 89 25 ff ff ff    	jns    eb0 <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
     f8b:	83 ec 0c             	sub    $0xc,%esp
     f8e:	ff 75 ec             	pushl  -0x14(%ebp)
     f91:	e8 15 f3 ff ff       	call   2ab <close>
     f96:	83 c4 10             	add    $0x10,%esp
    return 0;
     f99:	b8 00 00 00 00       	mov    $0x0,%eax
}
     f9e:	c9                   	leave  
     f9f:	c3                   	ret    

00000fa0 <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
     fa0:	55                   	push   %ebp
     fa1:	89 e5                	mov    %esp,%ebp
     fa3:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
     fa6:	8b 55 10             	mov    0x10(%ebp),%edx
     fa9:	89 d0                	mov    %edx,%eax
     fab:	01 c0                	add    %eax,%eax
     fad:	01 d0                	add    %edx,%eax
     faf:	c1 e0 03             	shl    $0x3,%eax
     fb2:	83 c0 1f             	add    $0x1f,%eax
     fb5:	8d 50 1f             	lea    0x1f(%eax),%edx
     fb8:	85 c0                	test   %eax,%eax
     fba:	0f 48 c2             	cmovs  %edx,%eax
     fbd:	c1 f8 05             	sar    $0x5,%eax
     fc0:	c1 e0 02             	shl    $0x2,%eax
     fc3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
     fc6:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
     fcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
     fcf:	0f af 45 0c          	imul   0xc(%ebp),%eax
     fd3:	83 c0 36             	add    $0x36,%eax
     fd6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
     fd9:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
     fdf:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
     fe5:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
     fec:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
     ff3:	8b 45 10             	mov    0x10(%ebp),%eax
     ff6:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
     ff9:	8b 45 0c             	mov    0xc(%ebp),%eax
     ffc:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
     fff:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    1005:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    100b:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    1012:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1015:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1019:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    101c:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    1023:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    102a:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    1031:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    1038:	83 ec 04             	sub    $0x4,%esp
    103b:	6a 0e                	push   $0xe
    103d:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    1040:	50                   	push   %eax
    1041:	ff 75 08             	pushl  0x8(%ebp)
    1044:	e8 5a f2 ff ff       	call   2a3 <write>
    1049:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    104c:	83 ec 04             	sub    $0x4,%esp
    104f:	6a 28                	push   $0x28
    1051:	8d 45 be             	lea    -0x42(%ebp),%eax
    1054:	50                   	push   %eax
    1055:	ff 75 08             	pushl  0x8(%ebp)
    1058:	e8 46 f2 ff ff       	call   2a3 <write>
    105d:	83 c4 10             	add    $0x10,%esp
}
    1060:	90                   	nop
    1061:	c9                   	leave  
    1062:	c3                   	ret    

00001063 <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    1063:	55                   	push   %ebp
    1064:	89 e5                	mov    %esp,%ebp
    1066:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    1069:	83 ec 08             	sub    $0x8,%esp
    106c:	68 02 02 00 00       	push   $0x202
    1071:	ff 75 08             	pushl  0x8(%ebp)
    1074:	e8 4a f2 ff ff       	call   2c3 <open>
    1079:	83 c4 10             	add    $0x10,%esp
    107c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    107f:	8b 55 14             	mov    0x14(%ebp),%edx
    1082:	89 d0                	mov    %edx,%eax
    1084:	01 c0                	add    %eax,%eax
    1086:	01 d0                	add    %edx,%eax
    1088:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    108b:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    108f:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    1093:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    1097:	83 ec 04             	sub    $0x4,%esp
    109a:	ff 75 14             	pushl  0x14(%ebp)
    109d:	ff 75 10             	pushl  0x10(%ebp)
    10a0:	ff 75 f0             	pushl  -0x10(%ebp)
    10a3:	e8 f8 fe ff ff       	call   fa0 <write24BitmapFileHeader>
    10a8:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    10ab:	8b 45 10             	mov    0x10(%ebp),%eax
    10ae:	83 e8 01             	sub    $0x1,%eax
    10b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    10b4:	eb 66                	jmp    111c <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    10b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    10b9:	0f af 45 14          	imul   0x14(%ebp),%eax
    10bd:	89 c2                	mov    %eax,%edx
    10bf:	89 d0                	mov    %edx,%eax
    10c1:	01 c0                	add    %eax,%eax
    10c3:	01 c2                	add    %eax,%edx
    10c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    10c8:	01 d0                	add    %edx,%eax
    10ca:	83 ec 04             	sub    $0x4,%esp
    10cd:	ff 75 ec             	pushl  -0x14(%ebp)
    10d0:	50                   	push   %eax
    10d1:	ff 75 f0             	pushl  -0x10(%ebp)
    10d4:	e8 ca f1 ff ff       	call   2a3 <write>
    10d9:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    10dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    10df:	99                   	cltd   
    10e0:	c1 ea 1e             	shr    $0x1e,%edx
    10e3:	01 d0                	add    %edx,%eax
    10e5:	83 e0 03             	and    $0x3,%eax
    10e8:	29 d0                	sub    %edx,%eax
    10ea:	85 c0                	test   %eax,%eax
    10ec:	7e 2a                	jle    1118 <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    10ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
    10f1:	99                   	cltd   
    10f2:	c1 ea 1e             	shr    $0x1e,%edx
    10f5:	01 d0                	add    %edx,%eax
    10f7:	83 e0 03             	and    $0x3,%eax
    10fa:	29 d0                	sub    %edx,%eax
    10fc:	ba 04 00 00 00       	mov    $0x4,%edx
    1101:	29 c2                	sub    %eax,%edx
    1103:	89 d0                	mov    %edx,%eax
    1105:	83 ec 04             	sub    $0x4,%esp
    1108:	50                   	push   %eax
    1109:	8d 45 e9             	lea    -0x17(%ebp),%eax
    110c:	50                   	push   %eax
    110d:	ff 75 f0             	pushl  -0x10(%ebp)
    1110:	e8 8e f1 ff ff       	call   2a3 <write>
    1115:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    1118:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    111c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1120:	79 94                	jns    10b6 <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1122:	83 ec 0c             	sub    $0xc,%esp
    1125:	ff 75 f0             	pushl  -0x10(%ebp)
    1128:	e8 7e f1 ff ff       	call   2ab <close>
    112d:	83 c4 10             	add    $0x10,%esp
    return 0;
    1130:	b8 00 00 00 00       	mov    $0x0,%eax
    1135:	c9                   	leave  
    1136:	c3                   	ret    

00001137 <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    1137:	55                   	push   %ebp
    1138:	89 e5                	mov    %esp,%ebp
    113a:	57                   	push   %edi
    113b:	56                   	push   %esi
    113c:	53                   	push   %ebx
    113d:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    1140:	8b 45 08             	mov    0x8(%ebp),%eax
    1143:	8b 50 10             	mov    0x10(%eax),%edx
    1146:	8b 40 0c             	mov    0xc(%eax),%eax
    1149:	89 45 e0             	mov    %eax,-0x20(%ebp)
    114c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    114f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1152:	8b 55 e0             	mov    -0x20(%ebp),%edx
    1155:	83 c2 1e             	add    $0x1e,%edx
    1158:	0f af d0             	imul   %eax,%edx
    115b:	89 d0                	mov    %edx,%eax
    115d:	01 c0                	add    %eax,%eax
    115f:	01 d0                	add    %edx,%eax
    1161:	83 ec 0c             	sub    $0xc,%esp
    1164:	50                   	push   %eax
    1165:	e8 93 f5 ff ff       	call   6fd <malloc>
    116a:	83 c4 10             	add    $0x10,%esp
    116d:	89 c2                	mov    %eax,%edx
    116f:	8b 45 08             	mov    0x8(%ebp),%eax
    1172:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    1175:	8b 45 08             	mov    0x8(%ebp),%eax
    1178:	8b 40 1c             	mov    0x1c(%eax),%eax
    117b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    117e:	6b d2 5a             	imul   $0x5a,%edx,%edx
    1181:	01 c2                	add    %eax,%edx
    1183:	8b 45 08             	mov    0x8(%ebp),%eax
    1186:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    1189:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    118c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    118f:	0f af d0             	imul   %eax,%edx
    1192:	89 d0                	mov    %edx,%eax
    1194:	01 c0                	add    %eax,%eax
    1196:	01 d0                	add    %edx,%eax
    1198:	89 c2                	mov    %eax,%edx
    119a:	8b 45 08             	mov    0x8(%ebp),%eax
    119d:	8b 40 18             	mov    0x18(%eax),%eax
    11a0:	83 ec 04             	sub    $0x4,%esp
    11a3:	52                   	push   %edx
    11a4:	68 ff 00 00 00       	push   $0xff
    11a9:	50                   	push   %eax
    11aa:	e8 39 ef ff ff       	call   e8 <memset>
    11af:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    11b2:	8b 45 08             	mov    0x8(%ebp),%eax
    11b5:	8b 78 1c             	mov    0x1c(%eax),%edi
    11b8:	8b 45 08             	mov    0x8(%ebp),%eax
    11bb:	8b 70 14             	mov    0x14(%eax),%esi
    11be:	8b 45 08             	mov    0x8(%ebp),%eax
    11c1:	8b 58 0c             	mov    0xc(%eax),%ebx
    11c4:	8b 45 08             	mov    0x8(%ebp),%eax
    11c7:	8b 48 10             	mov    0x10(%eax),%ecx
    11ca:	8b 45 08             	mov    0x8(%ebp),%eax
    11cd:	8b 50 08             	mov    0x8(%eax),%edx
    11d0:	8b 45 08             	mov    0x8(%ebp),%eax
    11d3:	8b 40 04             	mov    0x4(%eax),%eax
    11d6:	83 ec 08             	sub    $0x8,%esp
    11d9:	57                   	push   %edi
    11da:	56                   	push   %esi
    11db:	53                   	push   %ebx
    11dc:	51                   	push   %ecx
    11dd:	52                   	push   %edx
    11de:	50                   	push   %eax
    11df:	e8 3f f1 ff ff       	call   323 <createwindow>
    11e4:	83 c4 20             	add    $0x20,%esp
    11e7:	89 c2                	mov    %eax,%edx
    11e9:	8b 45 08             	mov    0x8(%ebp),%eax
    11ec:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    11ee:	8b 45 08             	mov    0x8(%ebp),%eax
    11f1:	8b 00                	mov    (%eax),%eax
}
    11f3:	8d 65 f4             	lea    -0xc(%ebp),%esp
    11f6:	5b                   	pop    %ebx
    11f7:	5e                   	pop    %esi
    11f8:	5f                   	pop    %edi
    11f9:	5d                   	pop    %ebp
    11fa:	c3                   	ret    

000011fb <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    11fb:	55                   	push   %ebp
    11fc:	89 e5                	mov    %esp,%ebp
    11fe:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    1201:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1208:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    120f:	8b 45 08             	mov    0x8(%ebp),%eax
    1212:	8b 40 18             	mov    0x18(%eax),%eax
    1215:	ff 75 1c             	pushl  0x1c(%ebp)
    1218:	ff 75 18             	pushl  0x18(%ebp)
    121b:	ff 75 1c             	pushl  0x1c(%ebp)
    121e:	ff 75 18             	pushl  0x18(%ebp)
    1221:	8b 55 08             	mov    0x8(%ebp),%edx
    1224:	ff 72 10             	pushl  0x10(%edx)
    1227:	ff 72 0c             	pushl  0xc(%edx)
    122a:	ff 75 f4             	pushl  -0xc(%ebp)
    122d:	ff 75 f0             	pushl  -0x10(%ebp)
    1230:	ff 75 14             	pushl  0x14(%ebp)
    1233:	ff 75 10             	pushl  0x10(%ebp)
    1236:	ff 75 0c             	pushl  0xc(%ebp)
    1239:	50                   	push   %eax
    123a:	e8 d5 07 00 00       	call   1a14 <drawBitmap>
    123f:	83 c4 30             	add    $0x30,%esp
    return 0;
    1242:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1247:	c9                   	leave  
    1248:	c3                   	ret    

00001249 <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    1249:	55                   	push   %ebp
    124a:	89 e5                	mov    %esp,%ebp
    124c:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    124f:	8b 45 08             	mov    0x8(%ebp),%eax
    1252:	8b 40 18             	mov    0x18(%eax),%eax
    1255:	ff 75 2c             	pushl  0x2c(%ebp)
    1258:	ff 75 28             	pushl  0x28(%ebp)
    125b:	ff 75 24             	pushl  0x24(%ebp)
    125e:	ff 75 20             	pushl  0x20(%ebp)
    1261:	8b 55 08             	mov    0x8(%ebp),%edx
    1264:	ff 72 10             	pushl  0x10(%edx)
    1267:	ff 72 0c             	pushl  0xc(%edx)
    126a:	ff 75 1c             	pushl  0x1c(%ebp)
    126d:	ff 75 18             	pushl  0x18(%ebp)
    1270:	ff 75 14             	pushl  0x14(%ebp)
    1273:	ff 75 10             	pushl  0x10(%ebp)
    1276:	ff 75 0c             	pushl  0xc(%ebp)
    1279:	50                   	push   %eax
    127a:	e8 95 07 00 00       	call   1a14 <drawBitmap>
    127f:	83 c4 30             	add    $0x30,%esp
    return 0;
    1282:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1287:	c9                   	leave  
    1288:	c3                   	ret    

00001289 <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    1289:	55                   	push   %ebp
    128a:	89 e5                	mov    %esp,%ebp
    128c:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    128f:	8b 45 08             	mov    0x8(%ebp),%eax
    1292:	8b 40 18             	mov    0x18(%eax),%eax
    1295:	ff 75 2c             	pushl  0x2c(%ebp)
    1298:	ff 75 28             	pushl  0x28(%ebp)
    129b:	ff 75 24             	pushl  0x24(%ebp)
    129e:	ff 75 20             	pushl  0x20(%ebp)
    12a1:	8b 55 08             	mov    0x8(%ebp),%edx
    12a4:	ff 72 10             	pushl  0x10(%edx)
    12a7:	ff 72 0c             	pushl  0xc(%edx)
    12aa:	ff 75 1c             	pushl  0x1c(%ebp)
    12ad:	ff 75 18             	pushl  0x18(%ebp)
    12b0:	ff 75 14             	pushl  0x14(%ebp)
    12b3:	ff 75 10             	pushl  0x10(%ebp)
    12b6:	ff 75 0c             	pushl  0xc(%ebp)
    12b9:	50                   	push   %eax
    12ba:	e8 75 08 00 00       	call   1b34 <drawTransparentBitmap>
    12bf:	83 c4 30             	add    $0x30,%esp
    return 0;
    12c2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    12c7:	c9                   	leave  
    12c8:	c3                   	ret    

000012c9 <api_repaint>:

int api_repaint(Window* wnd)
{
    12c9:	55                   	push   %ebp
    12ca:	89 e5                	mov    %esp,%ebp
    12cc:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    12cf:	8b 45 08             	mov    0x8(%ebp),%eax
    12d2:	8b 00                	mov    (%eax),%eax
    12d4:	83 ec 0c             	sub    $0xc,%esp
    12d7:	50                   	push   %eax
    12d8:	e8 4e f0 ff ff       	call   32b <repaintwindow>
    12dd:	83 c4 10             	add    $0x10,%esp
    return 0;
    12e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    12e5:	c9                   	leave  
    12e6:	c3                   	ret    

000012e7 <api_update>:

int api_update(Window* wnd, Rect rect)
{
    12e7:	55                   	push   %ebp
    12e8:	89 e5                	mov    %esp,%ebp
    12ea:	56                   	push   %esi
    12eb:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    12ec:	8b 75 18             	mov    0x18(%ebp),%esi
    12ef:	8b 5d 14             	mov    0x14(%ebp),%ebx
    12f2:	8b 4d 10             	mov    0x10(%ebp),%ecx
    12f5:	8b 55 0c             	mov    0xc(%ebp),%edx
    12f8:	8b 45 08             	mov    0x8(%ebp),%eax
    12fb:	8b 00                	mov    (%eax),%eax
    12fd:	83 ec 0c             	sub    $0xc,%esp
    1300:	56                   	push   %esi
    1301:	53                   	push   %ebx
    1302:	51                   	push   %ecx
    1303:	52                   	push   %edx
    1304:	50                   	push   %eax
    1305:	e8 39 f0 ff ff       	call   343 <updatewindow>
    130a:	83 c4 20             	add    $0x20,%esp
    return 0;
    130d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1312:	8d 65 f8             	lea    -0x8(%ebp),%esp
    1315:	5b                   	pop    %ebx
    1316:	5e                   	pop    %esi
    1317:	5d                   	pop    %ebp
    1318:	c3                   	ret    

00001319 <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    1319:	55                   	push   %ebp
    131a:	89 e5                	mov    %esp,%ebp
    131c:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    131f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    1326:	8b 45 08             	mov    0x8(%ebp),%eax
    1329:	8b 00                	mov    (%eax),%eax
    132b:	83 ec 08             	sub    $0x8,%esp
    132e:	8d 55 c8             	lea    -0x38(%ebp),%edx
    1331:	52                   	push   %edx
    1332:	50                   	push   %eax
    1333:	e8 fb ef ff ff       	call   333 <getmessage>
    1338:	83 c4 10             	add    $0x10,%esp
    133b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    133e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1342:	74 e2                	je     1326 <api_exec+0xd>
        {
            pf(&msg);
    1344:	83 ec 0c             	sub    $0xc,%esp
    1347:	8d 45 c8             	lea    -0x38(%ebp),%eax
    134a:	50                   	push   %eax
    134b:	8b 45 0c             	mov    0xc(%ebp),%eax
    134e:	ff d0                	call   *%eax
    1350:	83 c4 10             	add    $0x10,%esp
        }
    }
    1353:	eb d1                	jmp    1326 <api_exec+0xd>

00001355 <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    1355:	55                   	push   %ebp
    1356:	89 e5                	mov    %esp,%ebp
    1358:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    135b:	8b 45 08             	mov    0x8(%ebp),%eax
    135e:	8b 00                	mov    (%eax),%eax
    1360:	83 ec 08             	sub    $0x8,%esp
    1363:	ff 75 0c             	pushl  0xc(%ebp)
    1366:	50                   	push   %eax
    1367:	e8 cf ef ff ff       	call   33b <settimer>
    136c:	83 c4 10             	add    $0x10,%esp
    return 0;
    136f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1374:	c9                   	leave  
    1375:	c3                   	ret    

00001376 <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    1376:	55                   	push   %ebp
    1377:	89 e5                	mov    %esp,%ebp
    1379:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    137c:	8b 45 08             	mov    0x8(%ebp),%eax
    137f:	8b 50 18             	mov    0x18(%eax),%edx
    1382:	ff 75 18             	pushl  0x18(%ebp)
    1385:	ff 75 14             	pushl  0x14(%ebp)
    1388:	83 ec 04             	sub    $0x4,%esp
    138b:	89 e0                	mov    %esp,%eax
    138d:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    1391:	66 89 08             	mov    %cx,(%eax)
    1394:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    1398:	88 48 02             	mov    %cl,0x2(%eax)
    139b:	8b 45 08             	mov    0x8(%ebp),%eax
    139e:	ff 70 10             	pushl  0x10(%eax)
    13a1:	ff 70 0c             	pushl  0xc(%eax)
    13a4:	ff 75 10             	pushl  0x10(%ebp)
    13a7:	ff 75 0c             	pushl  0xc(%ebp)
    13aa:	52                   	push   %edx
    13ab:	e8 6f 04 00 00       	call   181f <drawRect>
    13b0:	83 c4 20             	add    $0x20,%esp
    return 0;
    13b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13b8:	c9                   	leave  
    13b9:	c3                   	ret    

000013ba <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    13ba:	55                   	push   %ebp
    13bb:	89 e5                	mov    %esp,%ebp
    13bd:	83 ec 28             	sub    $0x28,%esp
    13c0:	8b 45 14             	mov    0x14(%ebp),%eax
    13c3:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    13c6:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    13ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    13cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
    13d0:	8b 45 10             	mov    0x10(%ebp),%eax
    13d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    13d6:	8b 45 08             	mov    0x8(%ebp),%eax
    13d9:	8b 40 18             	mov    0x18(%eax),%eax
    13dc:	83 ec 04             	sub    $0x4,%esp
    13df:	ff 75 18             	pushl  0x18(%ebp)
    13e2:	52                   	push   %edx
    13e3:	8b 55 08             	mov    0x8(%ebp),%edx
    13e6:	ff 72 10             	pushl  0x10(%edx)
    13e9:	ff 72 0c             	pushl  0xc(%edx)
    13ec:	ff 75 f4             	pushl  -0xc(%ebp)
    13ef:	ff 75 f0             	pushl  -0x10(%ebp)
    13f2:	50                   	push   %eax
    13f3:	e8 d4 02 00 00       	call   16cc <drawCharacter>
    13f8:	83 c4 20             	add    $0x20,%esp
    return 0;
    13fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1400:	c9                   	leave  
    1401:	c3                   	ret    

00001402 <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    1402:	55                   	push   %ebp
    1403:	89 e5                	mov    %esp,%ebp
    1405:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    1408:	8b 45 0c             	mov    0xc(%ebp),%eax
    140b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    140e:	8b 45 10             	mov    0x10(%ebp),%eax
    1411:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1414:	8b 45 08             	mov    0x8(%ebp),%eax
    1417:	8b 40 18             	mov    0x18(%eax),%eax
    141a:	83 ec 04             	sub    $0x4,%esp
    141d:	ff 75 18             	pushl  0x18(%ebp)
    1420:	ff 75 14             	pushl  0x14(%ebp)
    1423:	8b 55 08             	mov    0x8(%ebp),%edx
    1426:	ff 72 10             	pushl  0x10(%edx)
    1429:	ff 72 0c             	pushl  0xc(%edx)
    142c:	ff 75 f4             	pushl  -0xc(%ebp)
    142f:	ff 75 f0             	pushl  -0x10(%ebp)
    1432:	50                   	push   %eax
    1433:	e8 8e 03 00 00       	call   17c6 <drawString>
    1438:	83 c4 20             	add    $0x20,%esp
    return 0;
    143b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1440:	c9                   	leave  
    1441:	c3                   	ret    

00001442 <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    1442:	55                   	push   %ebp
    1443:	89 e5                	mov    %esp,%ebp
    1445:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    1448:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    144c:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    1450:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    1454:	83 ec 08             	sub    $0x8,%esp
    1457:	83 ec 04             	sub    $0x4,%esp
    145a:	89 e0                	mov    %esp,%eax
    145c:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    1460:	66 89 10             	mov    %dx,(%eax)
    1463:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    1467:	88 50 02             	mov    %dl,0x2(%eax)
    146a:	ff 75 18             	pushl  0x18(%ebp)
    146d:	ff 75 14             	pushl  0x14(%ebp)
    1470:	ff 75 10             	pushl  0x10(%ebp)
    1473:	ff 75 0c             	pushl  0xc(%ebp)
    1476:	ff 75 08             	pushl  0x8(%ebp)
    1479:	e8 f8 fe ff ff       	call   1376 <api_drawRect>
    147e:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    1481:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    1485:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    1489:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    148d:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    1491:	8b 45 10             	mov    0x10(%ebp),%eax
    1494:	8d 50 0a             	lea    0xa(%eax),%edx
    1497:	8b 45 0c             	mov    0xc(%ebp),%eax
    149a:	83 c0 0a             	add    $0xa,%eax
    149d:	83 ec 0c             	sub    $0xc,%esp
    14a0:	ff 75 f4             	pushl  -0xc(%ebp)
    14a3:	ff 75 1c             	pushl  0x1c(%ebp)
    14a6:	52                   	push   %edx
    14a7:	50                   	push   %eax
    14a8:	ff 75 08             	pushl  0x8(%ebp)
    14ab:	e8 52 ff ff ff       	call   1402 <api_drawString>
    14b0:	83 c4 20             	add    $0x20,%esp
    return 0;
    14b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    14b8:	c9                   	leave  
    14b9:	c3                   	ret    

000014ba <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    14ba:	55                   	push   %ebp
    14bb:	89 e5                	mov    %esp,%ebp
    14bd:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    14c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    14c7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    14ce:	8b 45 08             	mov    0x8(%ebp),%eax
    14d1:	8b 40 18             	mov    0x18(%eax),%eax
    14d4:	ff 75 1c             	pushl  0x1c(%ebp)
    14d7:	ff 75 18             	pushl  0x18(%ebp)
    14da:	ff 75 1c             	pushl  0x1c(%ebp)
    14dd:	ff 75 18             	pushl  0x18(%ebp)
    14e0:	8b 55 08             	mov    0x8(%ebp),%edx
    14e3:	ff 72 10             	pushl  0x10(%edx)
    14e6:	ff 72 0c             	pushl  0xc(%edx)
    14e9:	ff 75 f4             	pushl  -0xc(%ebp)
    14ec:	ff 75 f0             	pushl  -0x10(%ebp)
    14ef:	ff 75 14             	pushl  0x14(%ebp)
    14f2:	ff 75 10             	pushl  0x10(%ebp)
    14f5:	ff 75 0c             	pushl  0xc(%ebp)
    14f8:	50                   	push   %eax
    14f9:	e8 16 05 00 00       	call   1a14 <drawBitmap>
    14fe:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    1501:	8b 45 08             	mov    0x8(%ebp),%eax
    1504:	8b 40 18             	mov    0x18(%eax),%eax
    1507:	ff 75 28             	pushl  0x28(%ebp)
    150a:	ff 75 1c             	pushl  0x1c(%ebp)
    150d:	ff 75 18             	pushl  0x18(%ebp)
    1510:	8b 55 08             	mov    0x8(%ebp),%edx
    1513:	ff 72 10             	pushl  0x10(%edx)
    1516:	ff 72 0c             	pushl  0xc(%edx)
    1519:	ff 75 14             	pushl  0x14(%ebp)
    151c:	ff 75 10             	pushl  0x10(%ebp)
    151f:	50                   	push   %eax
    1520:	e8 99 07 00 00       	call   1cbe <colorShift>
    1525:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    1528:	8b 45 08             	mov    0x8(%ebp),%eax
    152b:	8b 50 18             	mov    0x18(%eax),%edx
    152e:	83 ec 0c             	sub    $0xc,%esp
    1531:	ff 75 20             	pushl  0x20(%ebp)
    1534:	ff 75 1c             	pushl  0x1c(%ebp)
    1537:	ff 75 18             	pushl  0x18(%ebp)
    153a:	83 ec 04             	sub    $0x4,%esp
    153d:	89 e0                	mov    %esp,%eax
    153f:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    1543:	66 89 08             	mov    %cx,(%eax)
    1546:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    154a:	88 48 02             	mov    %cl,0x2(%eax)
    154d:	8b 45 08             	mov    0x8(%ebp),%eax
    1550:	ff 70 10             	pushl  0x10(%eax)
    1553:	ff 70 0c             	pushl  0xc(%eax)
    1556:	ff 75 14             	pushl  0x14(%ebp)
    1559:	ff 75 10             	pushl  0x10(%ebp)
    155c:	52                   	push   %edx
    155d:	e8 6d 03 00 00       	call   18cf <drawBorder>
    1562:	83 c4 30             	add    $0x30,%esp
    return 0;
    1565:	b8 00 00 00 00       	mov    $0x0,%eax
}
    156a:	c9                   	leave  
    156b:	c3                   	ret    

0000156c <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    156c:	55                   	push   %ebp
    156d:	89 e5                	mov    %esp,%ebp
    156f:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    1572:	8b 45 08             	mov    0x8(%ebp),%eax
    1575:	8b 00                	mov    (%eax),%eax
    1577:	83 ec 0c             	sub    $0xc,%esp
    157a:	50                   	push   %eax
    157b:	e8 cb ed ff ff       	call   34b <destroywindow>
    1580:	83 c4 10             	add    $0x10,%esp
    return 0;
    1583:	b8 00 00 00 00       	mov    $0x0,%eax
    1588:	c9                   	leave  
    1589:	c3                   	ret    

0000158a <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    158a:	55                   	push   %ebp
    158b:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    158d:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    1591:	8b 45 08             	mov    0x8(%ebp),%eax
    1594:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    1597:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    159b:	8b 45 08             	mov    0x8(%ebp),%eax
    159e:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    15a1:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    15a5:	8b 45 08             	mov    0x8(%ebp),%eax
    15a8:	88 10                	mov    %dl,(%eax)
}
    15aa:	90                   	nop
    15ab:	5d                   	pop    %ebp
    15ac:	c3                   	ret    

000015ad <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    15ad:	55                   	push   %ebp
    15ae:	89 e5                	mov    %esp,%ebp
    15b0:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    15b3:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    15b7:	3c ff                	cmp    $0xff,%al
    15b9:	75 22                	jne    15dd <drawPointAlpha+0x30>
        color->R = origin.R;
    15bb:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    15bf:	8b 45 08             	mov    0x8(%ebp),%eax
    15c2:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    15c5:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    15c9:	8b 45 08             	mov    0x8(%ebp),%eax
    15cc:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    15cf:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    15d3:	8b 45 08             	mov    0x8(%ebp),%eax
    15d6:	88 10                	mov    %dl,(%eax)
        return;
    15d8:	e9 ed 00 00 00       	jmp    16ca <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    15dd:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    15e1:	84 c0                	test   %al,%al
    15e3:	0f 84 e0 00 00 00    	je     16c9 <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    15e9:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    15ed:	0f b6 c0             	movzbl %al,%eax
    15f0:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    15f4:	df 45 e4             	fild   -0x1c(%ebp)
    15f7:	d9 05 40 9c 01 00    	flds   0x19c40
    15fd:	de f9                	fdivrp %st,%st(1)
    15ff:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    1602:	8b 45 08             	mov    0x8(%ebp),%eax
    1605:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1609:	0f b6 c0             	movzbl %al,%eax
    160c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    160f:	db 45 e4             	fildl  -0x1c(%ebp)
    1612:	d9 e8                	fld1   
    1614:	d8 65 fc             	fsubs  -0x4(%ebp)
    1617:	de c9                	fmulp  %st,%st(1)
    1619:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    161d:	0f b6 c0             	movzbl %al,%eax
    1620:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1623:	db 45 e4             	fildl  -0x1c(%ebp)
    1626:	d8 4d fc             	fmuls  -0x4(%ebp)
    1629:	de c1                	faddp  %st,%st(1)
    162b:	d9 7d ee             	fnstcw -0x12(%ebp)
    162e:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    1632:	b4 0c                	mov    $0xc,%ah
    1634:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    1638:	d9 6d ec             	fldcw  -0x14(%ebp)
    163b:	df 5d ea             	fistp  -0x16(%ebp)
    163e:	d9 6d ee             	fldcw  -0x12(%ebp)
    1641:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1645:	89 c2                	mov    %eax,%edx
    1647:	8b 45 08             	mov    0x8(%ebp),%eax
    164a:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    164d:	8b 45 08             	mov    0x8(%ebp),%eax
    1650:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1654:	0f b6 c0             	movzbl %al,%eax
    1657:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    165a:	db 45 e4             	fildl  -0x1c(%ebp)
    165d:	d9 e8                	fld1   
    165f:	d8 65 fc             	fsubs  -0x4(%ebp)
    1662:	de c9                	fmulp  %st,%st(1)
    1664:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    1668:	0f b6 c0             	movzbl %al,%eax
    166b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    166e:	db 45 e4             	fildl  -0x1c(%ebp)
    1671:	d8 4d fc             	fmuls  -0x4(%ebp)
    1674:	de c1                	faddp  %st,%st(1)
    1676:	d9 6d ec             	fldcw  -0x14(%ebp)
    1679:	df 5d ea             	fistp  -0x16(%ebp)
    167c:	d9 6d ee             	fldcw  -0x12(%ebp)
    167f:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1683:	89 c2                	mov    %eax,%edx
    1685:	8b 45 08             	mov    0x8(%ebp),%eax
    1688:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    168b:	8b 45 08             	mov    0x8(%ebp),%eax
    168e:	0f b6 00             	movzbl (%eax),%eax
    1691:	0f b6 c0             	movzbl %al,%eax
    1694:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1697:	db 45 e4             	fildl  -0x1c(%ebp)
    169a:	d9 e8                	fld1   
    169c:	d8 65 fc             	fsubs  -0x4(%ebp)
    169f:	de c9                	fmulp  %st,%st(1)
    16a1:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    16a5:	0f b6 c0             	movzbl %al,%eax
    16a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16ab:	db 45 e4             	fildl  -0x1c(%ebp)
    16ae:	d8 4d fc             	fmuls  -0x4(%ebp)
    16b1:	de c1                	faddp  %st,%st(1)
    16b3:	d9 6d ec             	fldcw  -0x14(%ebp)
    16b6:	df 5d ea             	fistp  -0x16(%ebp)
    16b9:	d9 6d ee             	fldcw  -0x12(%ebp)
    16bc:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    16c0:	89 c2                	mov    %eax,%edx
    16c2:	8b 45 08             	mov    0x8(%ebp),%eax
    16c5:	88 10                	mov    %dl,(%eax)
    16c7:	eb 01                	jmp    16ca <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    16c9:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    16ca:	c9                   	leave  
    16cb:	c3                   	ret    

000016cc <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    16cc:	55                   	push   %ebp
    16cd:	89 e5                	mov    %esp,%ebp
    16cf:	83 ec 14             	sub    $0x14,%esp
    16d2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    16d5:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    16d8:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    16dc:	83 e8 20             	sub    $0x20,%eax
    16df:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    16e2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    16e6:	0f 88 d7 00 00 00    	js     17c3 <drawCharacter+0xf7>
    16ec:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    16f0:	0f 8f cd 00 00 00    	jg     17c3 <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    16f6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    16fd:	e9 b5 00 00 00       	jmp    17b7 <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    1702:	8b 55 10             	mov    0x10(%ebp),%edx
    1705:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1708:	01 c2                	add    %eax,%edx
    170a:	8b 45 14             	mov    0x14(%ebp),%eax
    170d:	39 c2                	cmp    %eax,%edx
    170f:	0f 8f af 00 00 00    	jg     17c4 <drawCharacter+0xf8>
    1715:	8b 55 10             	mov    0x10(%ebp),%edx
    1718:	8b 45 fc             	mov    -0x4(%ebp),%eax
    171b:	01 d0                	add    %edx,%eax
    171d:	85 c0                	test   %eax,%eax
    171f:	0f 88 9f 00 00 00    	js     17c4 <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1725:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    172c:	eb 7b                	jmp    17a9 <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    172e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1731:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    1734:	89 d0                	mov    %edx,%eax
    1736:	c1 e0 03             	shl    $0x3,%eax
    1739:	01 d0                	add    %edx,%eax
    173b:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    1741:	01 c2                	add    %eax,%edx
    1743:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1746:	01 d0                	add    %edx,%eax
    1748:	05 20 60 01 00       	add    $0x16020,%eax
    174d:	0f b6 00             	movzbl (%eax),%eax
    1750:	3c 01                	cmp    $0x1,%al
    1752:	75 51                	jne    17a5 <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    1754:	8b 55 0c             	mov    0xc(%ebp),%edx
    1757:	8b 45 f8             	mov    -0x8(%ebp),%eax
    175a:	01 c2                	add    %eax,%edx
    175c:	8b 45 18             	mov    0x18(%ebp),%eax
    175f:	39 c2                	cmp    %eax,%edx
    1761:	7f 50                	jg     17b3 <drawCharacter+0xe7>
    1763:	8b 55 0c             	mov    0xc(%ebp),%edx
    1766:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1769:	01 d0                	add    %edx,%eax
    176b:	85 c0                	test   %eax,%eax
    176d:	78 44                	js     17b3 <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    176f:	8b 55 10             	mov    0x10(%ebp),%edx
    1772:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1775:	01 c2                	add    %eax,%edx
    1777:	8b 45 18             	mov    0x18(%ebp),%eax
    177a:	0f af c2             	imul   %edx,%eax
    177d:	89 c2                	mov    %eax,%edx
    177f:	8b 45 0c             	mov    0xc(%ebp),%eax
    1782:	01 c2                	add    %eax,%edx
    1784:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1787:	01 c2                	add    %eax,%edx
    1789:	89 d0                	mov    %edx,%eax
    178b:	01 c0                	add    %eax,%eax
    178d:	01 c2                	add    %eax,%edx
    178f:	8b 45 08             	mov    0x8(%ebp),%eax
    1792:	01 d0                	add    %edx,%eax
    1794:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    1797:	ff 75 20             	pushl  0x20(%ebp)
    179a:	ff 75 f0             	pushl  -0x10(%ebp)
    179d:	e8 0b fe ff ff       	call   15ad <drawPointAlpha>
    17a2:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    17a5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    17a9:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    17ad:	0f 8e 7b ff ff ff    	jle    172e <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    17b3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    17b7:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    17bb:	0f 8e 41 ff ff ff    	jle    1702 <drawCharacter+0x36>
    17c1:	eb 01                	jmp    17c4 <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    17c3:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    17c4:	c9                   	leave  
    17c5:	c3                   	ret    

000017c6 <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    17c6:	55                   	push   %ebp
    17c7:	89 e5                	mov    %esp,%ebp
    17c9:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    17cc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    17d3:	eb 3d                	jmp    1812 <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    17d5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    17d8:	0f b6 00             	movzbl (%eax),%eax
    17db:	0f be c0             	movsbl %al,%eax
    17de:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    17e1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    17e4:	01 ca                	add    %ecx,%edx
    17e6:	89 55 f4             	mov    %edx,-0xc(%ebp)
    17e9:	8b 55 10             	mov    0x10(%ebp),%edx
    17ec:	89 55 f8             	mov    %edx,-0x8(%ebp)
    17ef:	ff 75 20             	pushl  0x20(%ebp)
    17f2:	50                   	push   %eax
    17f3:	ff 75 18             	pushl  0x18(%ebp)
    17f6:	ff 75 14             	pushl  0x14(%ebp)
    17f9:	ff 75 f8             	pushl  -0x8(%ebp)
    17fc:	ff 75 f4             	pushl  -0xc(%ebp)
    17ff:	ff 75 08             	pushl  0x8(%ebp)
    1802:	e8 c5 fe ff ff       	call   16cc <drawCharacter>
    1807:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    180a:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    180e:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    1812:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1815:	0f b6 00             	movzbl (%eax),%eax
    1818:	84 c0                	test   %al,%al
    181a:	75 b9                	jne    17d5 <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    181c:	90                   	nop
    181d:	c9                   	leave  
    181e:	c3                   	ret    

0000181f <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    181f:	55                   	push   %ebp
    1820:	89 e5                	mov    %esp,%ebp
    1822:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1825:	8b 45 20             	mov    0x20(%ebp),%eax
    1828:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    182b:	8b 45 24             	mov    0x24(%ebp),%eax
    182e:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1831:	8b 55 14             	mov    0x14(%ebp),%edx
    1834:	8b 45 10             	mov    0x10(%ebp),%eax
    1837:	29 c2                	sub    %eax,%edx
    1839:	89 d0                	mov    %edx,%eax
    183b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    183e:	7d 0d                	jge    184d <drawRect+0x2e>
        draw_h = s.h - p.y;
    1840:	8b 55 14             	mov    0x14(%ebp),%edx
    1843:	8b 45 10             	mov    0x10(%ebp),%eax
    1846:	29 c2                	sub    %eax,%edx
    1848:	89 d0                	mov    %edx,%eax
    184a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    184d:	8b 55 18             	mov    0x18(%ebp),%edx
    1850:	8b 45 0c             	mov    0xc(%ebp),%eax
    1853:	29 c2                	sub    %eax,%edx
    1855:	89 d0                	mov    %edx,%eax
    1857:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    185a:	7d 0d                	jge    1869 <drawRect+0x4a>
        draw_w = s.w - p.x;
    185c:	8b 55 18             	mov    0x18(%ebp),%edx
    185f:	8b 45 0c             	mov    0xc(%ebp),%eax
    1862:	29 c2                	sub    %eax,%edx
    1864:	89 d0                	mov    %edx,%eax
    1866:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1869:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1870:	eb 52                	jmp    18c4 <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    1872:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1879:	eb 3d                	jmp    18b8 <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    187b:	8b 55 10             	mov    0x10(%ebp),%edx
    187e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1881:	01 c2                	add    %eax,%edx
    1883:	8b 45 18             	mov    0x18(%ebp),%eax
    1886:	0f af c2             	imul   %edx,%eax
    1889:	89 c2                	mov    %eax,%edx
    188b:	8b 45 0c             	mov    0xc(%ebp),%eax
    188e:	01 c2                	add    %eax,%edx
    1890:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1893:	01 c2                	add    %eax,%edx
    1895:	89 d0                	mov    %edx,%eax
    1897:	01 c0                	add    %eax,%eax
    1899:	01 c2                	add    %eax,%edx
    189b:	8b 45 08             	mov    0x8(%ebp),%eax
    189e:	01 d0                	add    %edx,%eax
    18a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    18a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    18a6:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    18aa:	66 89 10             	mov    %dx,(%eax)
    18ad:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    18b1:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    18b4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    18b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    18bb:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    18be:	7c bb                	jl     187b <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    18c0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    18c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    18c7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    18ca:	7c a6                	jl     1872 <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    18cc:	90                   	nop
    18cd:	c9                   	leave  
    18ce:	c3                   	ret    

000018cf <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    18cf:	55                   	push   %ebp
    18d0:	89 e5                	mov    %esp,%ebp
    18d2:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    18d5:	8b 45 28             	mov    0x28(%ebp),%eax
    18d8:	89 45 c8             	mov    %eax,-0x38(%ebp)
    18db:	8b 45 24             	mov    0x24(%ebp),%eax
    18de:	89 45 cc             	mov    %eax,-0x34(%ebp)
    18e1:	ff 75 cc             	pushl  -0x34(%ebp)
    18e4:	ff 75 c8             	pushl  -0x38(%ebp)
    18e7:	83 ec 04             	sub    $0x4,%esp
    18ea:	89 e0                	mov    %esp,%eax
    18ec:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    18f0:	66 89 10             	mov    %dx,(%eax)
    18f3:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    18f7:	88 50 02             	mov    %dl,0x2(%eax)
    18fa:	ff 75 18             	pushl  0x18(%ebp)
    18fd:	ff 75 14             	pushl  0x14(%ebp)
    1900:	ff 75 10             	pushl  0x10(%ebp)
    1903:	ff 75 0c             	pushl  0xc(%ebp)
    1906:	ff 75 08             	pushl  0x8(%ebp)
    1909:	e8 11 ff ff ff       	call   181f <drawRect>
    190e:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    1911:	8b 45 28             	mov    0x28(%ebp),%eax
    1914:	89 45 d0             	mov    %eax,-0x30(%ebp)
    1917:	8b 45 24             	mov    0x24(%ebp),%eax
    191a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    191d:	8b 45 0c             	mov    0xc(%ebp),%eax
    1920:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1923:	8b 55 10             	mov    0x10(%ebp),%edx
    1926:	8b 45 20             	mov    0x20(%ebp),%eax
    1929:	01 d0                	add    %edx,%eax
    192b:	2b 45 28             	sub    0x28(%ebp),%eax
    192e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1931:	ff 75 d4             	pushl  -0x2c(%ebp)
    1934:	ff 75 d0             	pushl  -0x30(%ebp)
    1937:	83 ec 04             	sub    $0x4,%esp
    193a:	89 e0                	mov    %esp,%eax
    193c:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1940:	66 89 10             	mov    %dx,(%eax)
    1943:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1947:	88 50 02             	mov    %dl,0x2(%eax)
    194a:	ff 75 18             	pushl  0x18(%ebp)
    194d:	ff 75 14             	pushl  0x14(%ebp)
    1950:	ff 75 dc             	pushl  -0x24(%ebp)
    1953:	ff 75 d8             	pushl  -0x28(%ebp)
    1956:	ff 75 08             	pushl  0x8(%ebp)
    1959:	e8 c1 fe ff ff       	call   181f <drawRect>
    195e:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1961:	8b 45 20             	mov    0x20(%ebp),%eax
    1964:	8b 55 28             	mov    0x28(%ebp),%edx
    1967:	01 d2                	add    %edx,%edx
    1969:	29 d0                	sub    %edx,%eax
    196b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    196e:	8b 45 28             	mov    0x28(%ebp),%eax
    1971:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1974:	8b 45 0c             	mov    0xc(%ebp),%eax
    1977:	89 45 e8             	mov    %eax,-0x18(%ebp)
    197a:	8b 55 10             	mov    0x10(%ebp),%edx
    197d:	8b 45 28             	mov    0x28(%ebp),%eax
    1980:	01 d0                	add    %edx,%eax
    1982:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1985:	ff 75 e4             	pushl  -0x1c(%ebp)
    1988:	ff 75 e0             	pushl  -0x20(%ebp)
    198b:	83 ec 04             	sub    $0x4,%esp
    198e:	89 e0                	mov    %esp,%eax
    1990:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1994:	66 89 10             	mov    %dx,(%eax)
    1997:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    199b:	88 50 02             	mov    %dl,0x2(%eax)
    199e:	ff 75 18             	pushl  0x18(%ebp)
    19a1:	ff 75 14             	pushl  0x14(%ebp)
    19a4:	ff 75 ec             	pushl  -0x14(%ebp)
    19a7:	ff 75 e8             	pushl  -0x18(%ebp)
    19aa:	ff 75 08             	pushl  0x8(%ebp)
    19ad:	e8 6d fe ff ff       	call   181f <drawRect>
    19b2:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    19b5:	8b 45 20             	mov    0x20(%ebp),%eax
    19b8:	8b 55 28             	mov    0x28(%ebp),%edx
    19bb:	01 d2                	add    %edx,%edx
    19bd:	29 d0                	sub    %edx,%eax
    19bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    19c2:	8b 45 28             	mov    0x28(%ebp),%eax
    19c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    19c8:	8b 55 0c             	mov    0xc(%ebp),%edx
    19cb:	8b 45 24             	mov    0x24(%ebp),%eax
    19ce:	01 d0                	add    %edx,%eax
    19d0:	2b 45 28             	sub    0x28(%ebp),%eax
    19d3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    19d6:	8b 55 10             	mov    0x10(%ebp),%edx
    19d9:	8b 45 28             	mov    0x28(%ebp),%eax
    19dc:	01 d0                	add    %edx,%eax
    19de:	89 45 fc             	mov    %eax,-0x4(%ebp)
    19e1:	ff 75 f4             	pushl  -0xc(%ebp)
    19e4:	ff 75 f0             	pushl  -0x10(%ebp)
    19e7:	83 ec 04             	sub    $0x4,%esp
    19ea:	89 e0                	mov    %esp,%eax
    19ec:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    19f0:	66 89 10             	mov    %dx,(%eax)
    19f3:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    19f7:	88 50 02             	mov    %dl,0x2(%eax)
    19fa:	ff 75 18             	pushl  0x18(%ebp)
    19fd:	ff 75 14             	pushl  0x14(%ebp)
    1a00:	ff 75 fc             	pushl  -0x4(%ebp)
    1a03:	ff 75 f8             	pushl  -0x8(%ebp)
    1a06:	ff 75 08             	pushl  0x8(%ebp)
    1a09:	e8 11 fe ff ff       	call   181f <drawRect>
    1a0e:	83 c4 20             	add    $0x20,%esp
}
    1a11:	90                   	nop
    1a12:	c9                   	leave  
    1a13:	c3                   	ret    

00001a14 <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1a14:	55                   	push   %ebp
    1a15:	89 e5                	mov    %esp,%ebp
    1a17:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1a1a:	8b 45 30             	mov    0x30(%ebp),%eax
    1a1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    1a20:	8b 45 34             	mov    0x34(%ebp),%eax
    1a23:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    1a26:	8b 55 20             	mov    0x20(%ebp),%edx
    1a29:	8b 45 14             	mov    0x14(%ebp),%eax
    1a2c:	29 c2                	sub    %eax,%edx
    1a2e:	89 d0                	mov    %edx,%eax
    1a30:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1a33:	7d 0d                	jge    1a42 <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    1a35:	8b 55 20             	mov    0x20(%ebp),%edx
    1a38:	8b 45 14             	mov    0x14(%ebp),%eax
    1a3b:	29 c2                	sub    %eax,%edx
    1a3d:	89 d0                	mov    %edx,%eax
    1a3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1a42:	8b 55 28             	mov    0x28(%ebp),%edx
    1a45:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1a48:	29 c2                	sub    %eax,%edx
    1a4a:	89 d0                	mov    %edx,%eax
    1a4c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1a4f:	7d 0d                	jge    1a5e <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1a51:	8b 55 28             	mov    0x28(%ebp),%edx
    1a54:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1a57:	29 c2                	sub    %eax,%edx
    1a59:	89 d0                	mov    %edx,%eax
    1a5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1a5e:	8b 55 24             	mov    0x24(%ebp),%edx
    1a61:	8b 45 10             	mov    0x10(%ebp),%eax
    1a64:	29 c2                	sub    %eax,%edx
    1a66:	89 d0                	mov    %edx,%eax
    1a68:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1a6b:	7d 0d                	jge    1a7a <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    1a6d:	8b 55 24             	mov    0x24(%ebp),%edx
    1a70:	8b 45 10             	mov    0x10(%ebp),%eax
    1a73:	29 c2                	sub    %eax,%edx
    1a75:	89 d0                	mov    %edx,%eax
    1a77:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1a7a:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1a7d:	8b 45 18             	mov    0x18(%ebp),%eax
    1a80:	29 c2                	sub    %eax,%edx
    1a82:	89 d0                	mov    %edx,%eax
    1a84:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1a87:	7d 0d                	jge    1a96 <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    1a89:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1a8c:	8b 45 18             	mov    0x18(%ebp),%eax
    1a8f:	29 c2                	sub    %eax,%edx
    1a91:	89 d0                	mov    %edx,%eax
    1a93:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1a96:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    1a9d:	e9 83 00 00 00       	jmp    1b25 <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    1aa2:	8b 55 14             	mov    0x14(%ebp),%edx
    1aa5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1aa8:	01 d0                	add    %edx,%eax
    1aaa:	85 c0                	test   %eax,%eax
    1aac:	78 72                	js     1b20 <drawBitmap+0x10c>
    1aae:	8b 55 14             	mov    0x14(%ebp),%edx
    1ab1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ab4:	01 c2                	add    %eax,%edx
    1ab6:	8b 45 20             	mov    0x20(%ebp),%eax
    1ab9:	39 c2                	cmp    %eax,%edx
    1abb:	7d 63                	jge    1b20 <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    1abd:	8b 55 14             	mov    0x14(%ebp),%edx
    1ac0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ac3:	01 c2                	add    %eax,%edx
    1ac5:	8b 45 24             	mov    0x24(%ebp),%eax
    1ac8:	0f af c2             	imul   %edx,%eax
    1acb:	89 c2                	mov    %eax,%edx
    1acd:	8b 45 10             	mov    0x10(%ebp),%eax
    1ad0:	01 c2                	add    %eax,%edx
    1ad2:	89 d0                	mov    %edx,%eax
    1ad4:	01 c0                	add    %eax,%eax
    1ad6:	01 c2                	add    %eax,%edx
    1ad8:	8b 45 08             	mov    0x8(%ebp),%eax
    1adb:	01 d0                	add    %edx,%eax
    1add:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    1ae0:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1ae3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ae6:	01 c2                	add    %eax,%edx
    1ae8:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1aeb:	0f af c2             	imul   %edx,%eax
    1aee:	89 c2                	mov    %eax,%edx
    1af0:	8b 45 18             	mov    0x18(%ebp),%eax
    1af3:	01 c2                	add    %eax,%edx
    1af5:	89 d0                	mov    %edx,%eax
    1af7:	01 c0                	add    %eax,%eax
    1af9:	01 c2                	add    %eax,%edx
    1afb:	8b 45 0c             	mov    0xc(%ebp),%eax
    1afe:	01 d0                	add    %edx,%eax
    1b00:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    1b03:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1b06:	89 d0                	mov    %edx,%eax
    1b08:	01 c0                	add    %eax,%eax
    1b0a:	01 d0                	add    %edx,%eax
    1b0c:	83 ec 04             	sub    $0x4,%esp
    1b0f:	50                   	push   %eax
    1b10:	ff 75 e4             	pushl  -0x1c(%ebp)
    1b13:	ff 75 e8             	pushl  -0x18(%ebp)
    1b16:	e8 23 e7 ff ff       	call   23e <memmove>
    1b1b:	83 c4 10             	add    $0x10,%esp
    1b1e:	eb 01                	jmp    1b21 <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    1b20:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1b21:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    1b25:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b28:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1b2b:	0f 8c 71 ff ff ff    	jl     1aa2 <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    1b31:	90                   	nop
    1b32:	c9                   	leave  
    1b33:	c3                   	ret    

00001b34 <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1b34:	55                   	push   %ebp
    1b35:	89 e5                	mov    %esp,%ebp
    1b37:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1b3a:	8b 45 30             	mov    0x30(%ebp),%eax
    1b3d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    1b40:	8b 45 34             	mov    0x34(%ebp),%eax
    1b43:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    1b46:	8b 55 20             	mov    0x20(%ebp),%edx
    1b49:	8b 45 14             	mov    0x14(%ebp),%eax
    1b4c:	29 c2                	sub    %eax,%edx
    1b4e:	89 d0                	mov    %edx,%eax
    1b50:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1b53:	7d 0d                	jge    1b62 <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    1b55:	8b 55 20             	mov    0x20(%ebp),%edx
    1b58:	8b 45 14             	mov    0x14(%ebp),%eax
    1b5b:	29 c2                	sub    %eax,%edx
    1b5d:	89 d0                	mov    %edx,%eax
    1b5f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1b62:	8b 55 28             	mov    0x28(%ebp),%edx
    1b65:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1b68:	29 c2                	sub    %eax,%edx
    1b6a:	89 d0                	mov    %edx,%eax
    1b6c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1b6f:	7d 0d                	jge    1b7e <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1b71:	8b 55 28             	mov    0x28(%ebp),%edx
    1b74:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1b77:	29 c2                	sub    %eax,%edx
    1b79:	89 d0                	mov    %edx,%eax
    1b7b:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1b7e:	8b 55 24             	mov    0x24(%ebp),%edx
    1b81:	8b 45 10             	mov    0x10(%ebp),%eax
    1b84:	29 c2                	sub    %eax,%edx
    1b86:	89 d0                	mov    %edx,%eax
    1b88:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1b8b:	7d 0d                	jge    1b9a <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    1b8d:	8b 55 24             	mov    0x24(%ebp),%edx
    1b90:	8b 45 10             	mov    0x10(%ebp),%eax
    1b93:	29 c2                	sub    %eax,%edx
    1b95:	89 d0                	mov    %edx,%eax
    1b97:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1b9a:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1b9d:	8b 45 18             	mov    0x18(%ebp),%eax
    1ba0:	29 c2                	sub    %eax,%edx
    1ba2:	89 d0                	mov    %edx,%eax
    1ba4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1ba7:	7d 0d                	jge    1bb6 <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    1ba9:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1bac:	8b 45 18             	mov    0x18(%ebp),%eax
    1baf:	29 c2                	sub    %eax,%edx
    1bb1:	89 d0                	mov    %edx,%eax
    1bb3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    1bb6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1bbd:	e9 b8 00 00 00       	jmp    1c7a <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    1bc2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1bc9:	e9 9c 00 00 00       	jmp    1c6a <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    1bce:	8b 55 14             	mov    0x14(%ebp),%edx
    1bd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1bd4:	01 c2                	add    %eax,%edx
    1bd6:	8b 45 24             	mov    0x24(%ebp),%eax
    1bd9:	0f af c2             	imul   %edx,%eax
    1bdc:	89 c2                	mov    %eax,%edx
    1bde:	8b 45 10             	mov    0x10(%ebp),%eax
    1be1:	01 c2                	add    %eax,%edx
    1be3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1be6:	01 c2                	add    %eax,%edx
    1be8:	89 d0                	mov    %edx,%eax
    1bea:	01 c0                	add    %eax,%eax
    1bec:	01 c2                	add    %eax,%edx
    1bee:	8b 45 08             	mov    0x8(%ebp),%eax
    1bf1:	01 d0                	add    %edx,%eax
    1bf3:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    1bf6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1bf9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1bfc:	01 c2                	add    %eax,%edx
    1bfe:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1c01:	0f af c2             	imul   %edx,%eax
    1c04:	89 c2                	mov    %eax,%edx
    1c06:	8b 45 18             	mov    0x18(%ebp),%eax
    1c09:	01 c2                	add    %eax,%edx
    1c0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1c0e:	01 c2                	add    %eax,%edx
    1c10:	89 d0                	mov    %edx,%eax
    1c12:	01 c0                	add    %eax,%eax
    1c14:	01 c2                	add    %eax,%edx
    1c16:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c19:	01 d0                	add    %edx,%eax
    1c1b:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    1c1e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c21:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1c25:	3c ff                	cmp    $0xff,%al
    1c27:	75 15                	jne    1c3e <drawTransparentBitmap+0x10a>
    1c29:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c2c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1c30:	3c ff                	cmp    $0xff,%al
    1c32:	75 0a                	jne    1c3e <drawTransparentBitmap+0x10a>
    1c34:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c37:	0f b6 00             	movzbl (%eax),%eax
    1c3a:	3c ff                	cmp    $0xff,%al
    1c3c:	74 27                	je     1c65 <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    1c3e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c41:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    1c45:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c48:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    1c4b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c4e:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    1c52:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c55:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    1c58:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c5b:	0f b6 10             	movzbl (%eax),%edx
    1c5e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c61:	88 10                	mov    %dl,(%eax)
    1c63:	eb 01                	jmp    1c66 <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    1c65:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    1c66:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1c6a:	8b 45 34             	mov    0x34(%ebp),%eax
    1c6d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1c70:	0f 8f 58 ff ff ff    	jg     1bce <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    1c76:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1c7a:	8b 45 30             	mov    0x30(%ebp),%eax
    1c7d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1c80:	0f 8f 3c ff ff ff    	jg     1bc2 <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    1c86:	90                   	nop
    1c87:	c9                   	leave  
    1c88:	c3                   	ret    

00001c89 <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    1c89:	55                   	push   %ebp
    1c8a:	89 e5                	mov    %esp,%ebp
    1c8c:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    1c8f:	ff 75 24             	pushl  0x24(%ebp)
    1c92:	ff 75 20             	pushl  0x20(%ebp)
    1c95:	ff 75 1c             	pushl  0x1c(%ebp)
    1c98:	ff 75 18             	pushl  0x18(%ebp)
    1c9b:	ff 75 1c             	pushl  0x1c(%ebp)
    1c9e:	ff 75 18             	pushl  0x18(%ebp)
    1ca1:	ff 75 14             	pushl  0x14(%ebp)
    1ca4:	ff 75 10             	pushl  0x10(%ebp)
    1ca7:	ff 75 14             	pushl  0x14(%ebp)
    1caa:	ff 75 10             	pushl  0x10(%ebp)
    1cad:	ff 75 0c             	pushl  0xc(%ebp)
    1cb0:	ff 75 08             	pushl  0x8(%ebp)
    1cb3:	e8 5c fd ff ff       	call   1a14 <drawBitmap>
    1cb8:	83 c4 30             	add    $0x30,%esp
}
    1cbb:	90                   	nop
    1cbc:	c9                   	leave  
    1cbd:	c3                   	ret    

00001cbe <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    1cbe:	55                   	push   %ebp
    1cbf:	89 e5                	mov    %esp,%ebp
    1cc1:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1cc4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1cc7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1cca:	8b 45 20             	mov    0x20(%ebp),%eax
    1ccd:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1cd0:	8b 55 14             	mov    0x14(%ebp),%edx
    1cd3:	8b 45 10             	mov    0x10(%ebp),%eax
    1cd6:	29 c2                	sub    %eax,%edx
    1cd8:	89 d0                	mov    %edx,%eax
    1cda:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1cdd:	7d 0d                	jge    1cec <colorShift+0x2e>
        draw_h = s.h - p.y;
    1cdf:	8b 55 14             	mov    0x14(%ebp),%edx
    1ce2:	8b 45 10             	mov    0x10(%ebp),%eax
    1ce5:	29 c2                	sub    %eax,%edx
    1ce7:	89 d0                	mov    %edx,%eax
    1ce9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1cec:	8b 55 18             	mov    0x18(%ebp),%edx
    1cef:	8b 45 0c             	mov    0xc(%ebp),%eax
    1cf2:	29 c2                	sub    %eax,%edx
    1cf4:	89 d0                	mov    %edx,%eax
    1cf6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1cf9:	7d 0d                	jge    1d08 <colorShift+0x4a>
        draw_w = s.w - p.x;
    1cfb:	8b 55 18             	mov    0x18(%ebp),%edx
    1cfe:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d01:	29 c2                	sub    %eax,%edx
    1d03:	89 d0                	mov    %edx,%eax
    1d05:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1d08:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1d0f:	e9 fc 00 00 00       	jmp    1e10 <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    1d14:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1d1b:	e9 e0 00 00 00       	jmp    1e00 <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    1d20:	8b 55 10             	mov    0x10(%ebp),%edx
    1d23:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1d26:	01 c2                	add    %eax,%edx
    1d28:	8b 45 18             	mov    0x18(%ebp),%eax
    1d2b:	0f af c2             	imul   %edx,%eax
    1d2e:	89 c2                	mov    %eax,%edx
    1d30:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d33:	01 c2                	add    %eax,%edx
    1d35:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1d38:	01 c2                	add    %eax,%edx
    1d3a:	89 d0                	mov    %edx,%eax
    1d3c:	01 c0                	add    %eax,%eax
    1d3e:	01 c2                	add    %eax,%edx
    1d40:	8b 45 08             	mov    0x8(%ebp),%eax
    1d43:	01 d0                	add    %edx,%eax
    1d45:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    1d48:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d4b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1d4f:	3c c8                	cmp    $0xc8,%al
    1d51:	0f 86 a5 00 00 00    	jbe    1dfc <colorShift+0x13e>
    1d57:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d5a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1d5e:	3c c8                	cmp    $0xc8,%al
    1d60:	0f 86 96 00 00 00    	jbe    1dfc <colorShift+0x13e>
    1d66:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d69:	0f b6 00             	movzbl (%eax),%eax
    1d6c:	3c c8                	cmp    $0xc8,%al
    1d6e:	0f 86 88 00 00 00    	jbe    1dfc <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    1d74:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d77:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1d7b:	0f b6 d0             	movzbl %al,%edx
    1d7e:	8b 45 24             	mov    0x24(%ebp),%eax
    1d81:	01 d0                	add    %edx,%eax
    1d83:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1d89:	89 d0                	mov    %edx,%eax
    1d8b:	c1 f8 1f             	sar    $0x1f,%eax
    1d8e:	c1 e8 18             	shr    $0x18,%eax
    1d91:	01 c2                	add    %eax,%edx
    1d93:	0f b6 d2             	movzbl %dl,%edx
    1d96:	29 c2                	sub    %eax,%edx
    1d98:	89 d0                	mov    %edx,%eax
    1d9a:	89 c2                	mov    %eax,%edx
    1d9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d9f:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    1da2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1da5:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1da9:	0f b6 d0             	movzbl %al,%edx
    1dac:	8b 45 24             	mov    0x24(%ebp),%eax
    1daf:	01 d0                	add    %edx,%eax
    1db1:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1db7:	89 d0                	mov    %edx,%eax
    1db9:	c1 f8 1f             	sar    $0x1f,%eax
    1dbc:	c1 e8 18             	shr    $0x18,%eax
    1dbf:	01 c2                	add    %eax,%edx
    1dc1:	0f b6 d2             	movzbl %dl,%edx
    1dc4:	29 c2                	sub    %eax,%edx
    1dc6:	89 d0                	mov    %edx,%eax
    1dc8:	89 c2                	mov    %eax,%edx
    1dca:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1dcd:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    1dd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1dd3:	0f b6 00             	movzbl (%eax),%eax
    1dd6:	0f b6 d0             	movzbl %al,%edx
    1dd9:	8b 45 24             	mov    0x24(%ebp),%eax
    1ddc:	01 d0                	add    %edx,%eax
    1dde:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1de4:	89 d0                	mov    %edx,%eax
    1de6:	c1 f8 1f             	sar    $0x1f,%eax
    1de9:	c1 e8 18             	shr    $0x18,%eax
    1dec:	01 c2                	add    %eax,%edx
    1dee:	0f b6 d2             	movzbl %dl,%edx
    1df1:	29 c2                	sub    %eax,%edx
    1df3:	89 d0                	mov    %edx,%eax
    1df5:	89 c2                	mov    %eax,%edx
    1df7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1dfa:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1dfc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1e00:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e03:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1e06:	0f 8c 14 ff ff ff    	jl     1d20 <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1e0c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1e10:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e13:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1e16:	0f 8c f8 fe ff ff    	jl     1d14 <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    1e1c:	90                   	nop
    1e1d:	c9                   	leave  
    1e1e:	c3                   	ret    

00001e1f <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    1e1f:	55                   	push   %ebp
    1e20:	89 e5                	mov    %esp,%ebp
    1e22:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1e25:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1e2c:	e9 fb 00 00 00       	jmp    1f2c <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    1e31:	8b 55 14             	mov    0x14(%ebp),%edx
    1e34:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1e37:	01 c2                	add    %eax,%edx
    1e39:	0f b7 05 d6 e4 01 00 	movzwl 0x1e4d6,%eax
    1e40:	0f b7 c0             	movzwl %ax,%eax
    1e43:	39 c2                	cmp    %eax,%edx
    1e45:	0f 8f eb 00 00 00    	jg     1f36 <drawMouse+0x117>
    1e4b:	8b 55 14             	mov    0x14(%ebp),%edx
    1e4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1e51:	01 d0                	add    %edx,%eax
    1e53:	85 c0                	test   %eax,%eax
    1e55:	0f 88 db 00 00 00    	js     1f36 <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1e5b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1e62:	e9 b7 00 00 00       	jmp    1f1e <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    1e67:	8b 55 10             	mov    0x10(%ebp),%edx
    1e6a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1e6d:	01 c2                	add    %eax,%edx
    1e6f:	0f b7 05 d4 e4 01 00 	movzwl 0x1e4d4,%eax
    1e76:	0f b7 c0             	movzwl %ax,%eax
    1e79:	39 c2                	cmp    %eax,%edx
    1e7b:	0f 8f a7 00 00 00    	jg     1f28 <drawMouse+0x109>
    1e81:	8b 55 10             	mov    0x10(%ebp),%edx
    1e84:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1e87:	01 d0                	add    %edx,%eax
    1e89:	85 c0                	test   %eax,%eax
    1e8b:	0f 88 97 00 00 00    	js     1f28 <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    1e91:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1e94:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1e97:	89 d0                	mov    %edx,%eax
    1e99:	c1 e0 04             	shl    $0x4,%eax
    1e9c:	29 d0                	sub    %edx,%eax
    1e9e:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    1ea4:	01 c2                	add    %eax,%edx
    1ea6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1ea9:	01 d0                	add    %edx,%eax
    1eab:	05 00 5e 01 00       	add    $0x15e00,%eax
    1eb0:	0f b6 00             	movzbl (%eax),%eax
    1eb3:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    1eb6:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    1eba:	74 5e                	je     1f1a <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    1ebc:	8b 55 14             	mov    0x14(%ebp),%edx
    1ebf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1ec2:	01 c2                	add    %eax,%edx
    1ec4:	0f b7 05 d4 e4 01 00 	movzwl 0x1e4d4,%eax
    1ecb:	0f b7 c0             	movzwl %ax,%eax
    1ece:	0f af c2             	imul   %edx,%eax
    1ed1:	89 c2                	mov    %eax,%edx
    1ed3:	8b 45 10             	mov    0x10(%ebp),%eax
    1ed6:	01 c2                	add    %eax,%edx
    1ed8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1edb:	01 c2                	add    %eax,%edx
    1edd:	89 d0                	mov    %edx,%eax
    1edf:	01 c0                	add    %eax,%eax
    1ee1:	01 c2                	add    %eax,%edx
    1ee3:	8b 45 08             	mov    0x8(%ebp),%eax
    1ee6:	01 d0                	add    %edx,%eax
    1ee8:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    1eeb:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    1eef:	8d 50 ff             	lea    -0x1(%eax),%edx
    1ef2:	89 d0                	mov    %edx,%eax
    1ef4:	01 c0                	add    %eax,%eax
    1ef6:	01 d0                	add    %edx,%eax
    1ef8:	05 dc e4 01 00       	add    $0x1e4dc,%eax
    1efd:	83 ec 04             	sub    $0x4,%esp
    1f00:	89 e2                	mov    %esp,%edx
    1f02:	0f b7 08             	movzwl (%eax),%ecx
    1f05:	66 89 0a             	mov    %cx,(%edx)
    1f08:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1f0c:	88 42 02             	mov    %al,0x2(%edx)
    1f0f:	ff 75 f0             	pushl  -0x10(%ebp)
    1f12:	e8 73 f6 ff ff       	call   158a <drawPoint>
    1f17:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1f1a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    1f1e:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    1f22:	0f 8e 3f ff ff ff    	jle    1e67 <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1f28:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    1f2c:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    1f30:	0f 8e fb fe ff ff    	jle    1e31 <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    1f36:	90                   	nop
    1f37:	c9                   	leave  
    1f38:	c3                   	ret    

00001f39 <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    1f39:	55                   	push   %ebp
    1f3a:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    1f3c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1f40:	78 1b                	js     1f5d <getColor+0x24>
    1f42:	8b 45 08             	mov    0x8(%ebp),%eax
    1f45:	8b 40 04             	mov    0x4(%eax),%eax
    1f48:	3b 45 0c             	cmp    0xc(%ebp),%eax
    1f4b:	7c 10                	jl     1f5d <getColor+0x24>
    1f4d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    1f51:	78 0a                	js     1f5d <getColor+0x24>
    1f53:	8b 45 08             	mov    0x8(%ebp),%eax
    1f56:	8b 00                	mov    (%eax),%eax
    1f58:	3b 45 10             	cmp    0x10(%ebp),%eax
    1f5b:	7d 10                	jge    1f6d <getColor+0x34>
    {
        *isInPic = 1;
    1f5d:	8b 45 14             	mov    0x14(%ebp),%eax
    1f60:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    1f66:	b8 91 e0 01 00       	mov    $0x1e091,%eax
    1f6b:	eb 44                	jmp    1fb1 <getColor+0x78>
    }

    if (y == pic->height)
    1f6d:	8b 45 08             	mov    0x8(%ebp),%eax
    1f70:	8b 40 04             	mov    0x4(%eax),%eax
    1f73:	3b 45 0c             	cmp    0xc(%ebp),%eax
    1f76:	75 04                	jne    1f7c <getColor+0x43>
        y--;
    1f78:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    1f7c:	8b 45 08             	mov    0x8(%ebp),%eax
    1f7f:	8b 00                	mov    (%eax),%eax
    1f81:	3b 45 10             	cmp    0x10(%ebp),%eax
    1f84:	75 04                	jne    1f8a <getColor+0x51>
        x--;
    1f86:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    1f8a:	8b 45 14             	mov    0x14(%ebp),%eax
    1f8d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    1f93:	8b 45 08             	mov    0x8(%ebp),%eax
    1f96:	8b 48 08             	mov    0x8(%eax),%ecx
    1f99:	8b 45 08             	mov    0x8(%ebp),%eax
    1f9c:	8b 00                	mov    (%eax),%eax
    1f9e:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1fa2:	89 c2                	mov    %eax,%edx
    1fa4:	8b 45 10             	mov    0x10(%ebp),%eax
    1fa7:	01 c2                	add    %eax,%edx
    1fa9:	89 d0                	mov    %edx,%eax
    1fab:	01 c0                	add    %eax,%eax
    1fad:	01 d0                	add    %edx,%eax
    1faf:	01 c8                	add    %ecx,%eax
}
    1fb1:	5d                   	pop    %ebp
    1fb2:	c3                   	ret    

00001fb3 <setColor>:

int setColor(RGB *src, RGB *dst)
{
    1fb3:	55                   	push   %ebp
    1fb4:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    1fb6:	8b 45 08             	mov    0x8(%ebp),%eax
    1fb9:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    1fbd:	8b 45 0c             	mov    0xc(%ebp),%eax
    1fc0:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    1fc3:	8b 45 08             	mov    0x8(%ebp),%eax
    1fc6:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    1fca:	8b 45 0c             	mov    0xc(%ebp),%eax
    1fcd:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    1fd0:	8b 45 08             	mov    0x8(%ebp),%eax
    1fd3:	0f b6 10             	movzbl (%eax),%edx
    1fd6:	8b 45 0c             	mov    0xc(%ebp),%eax
    1fd9:	88 10                	mov    %dl,(%eax)

    return 1;
    1fdb:	b8 01 00 00 00       	mov    $0x1,%eax
}
    1fe0:	5d                   	pop    %ebp
    1fe1:	c3                   	ret    

00001fe2 <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    1fe2:	55                   	push   %ebp
    1fe3:	89 e5                	mov    %esp,%ebp
    1fe5:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    1fe8:	d9 45 10             	flds   0x10(%ebp)
    1feb:	d9 7d be             	fnstcw -0x42(%ebp)
    1fee:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    1ff2:	b4 0c                	mov    $0xc,%ah
    1ff4:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    1ff8:	d9 6d bc             	fldcw  -0x44(%ebp)
    1ffb:	db 5d fc             	fistpl -0x4(%ebp)
    1ffe:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    2001:	d9 45 0c             	flds   0xc(%ebp)
    2004:	d9 6d bc             	fldcw  -0x44(%ebp)
    2007:	db 5d f8             	fistpl -0x8(%ebp)
    200a:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    200d:	db 45 fc             	fildl  -0x4(%ebp)
    2010:	d9 45 10             	flds   0x10(%ebp)
    2013:	d9 c9                	fxch   %st(1)
    2015:	df e9                	fucomip %st(1),%st
    2017:	dd d8                	fstp   %st(0)
    2019:	76 04                	jbe    201f <mixColor+0x3d>
        x--;
    201b:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    201f:	db 45 f8             	fildl  -0x8(%ebp)
    2022:	d9 45 0c             	flds   0xc(%ebp)
    2025:	d9 c9                	fxch   %st(1)
    2027:	df e9                	fucomip %st(1),%st
    2029:	dd d8                	fstp   %st(0)
    202b:	76 04                	jbe    2031 <mixColor+0x4f>
        y--;
    202d:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2031:	8d 45 c0             	lea    -0x40(%ebp),%eax
    2034:	50                   	push   %eax
    2035:	ff 75 fc             	pushl  -0x4(%ebp)
    2038:	ff 75 f8             	pushl  -0x8(%ebp)
    203b:	ff 75 08             	pushl  0x8(%ebp)
    203e:	e8 f6 fe ff ff       	call   1f39 <getColor>
    2043:	83 c4 10             	add    $0x10,%esp
    2046:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    2049:	8b 45 f8             	mov    -0x8(%ebp),%eax
    204c:	83 c0 01             	add    $0x1,%eax
    204f:	8d 55 c0             	lea    -0x40(%ebp),%edx
    2052:	83 c2 04             	add    $0x4,%edx
    2055:	52                   	push   %edx
    2056:	ff 75 fc             	pushl  -0x4(%ebp)
    2059:	50                   	push   %eax
    205a:	ff 75 08             	pushl  0x8(%ebp)
    205d:	e8 d7 fe ff ff       	call   1f39 <getColor>
    2062:	83 c4 10             	add    $0x10,%esp
    2065:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    2068:	8b 45 fc             	mov    -0x4(%ebp),%eax
    206b:	83 c0 01             	add    $0x1,%eax
    206e:	8d 55 c0             	lea    -0x40(%ebp),%edx
    2071:	83 c2 08             	add    $0x8,%edx
    2074:	52                   	push   %edx
    2075:	50                   	push   %eax
    2076:	ff 75 f8             	pushl  -0x8(%ebp)
    2079:	ff 75 08             	pushl  0x8(%ebp)
    207c:	e8 b8 fe ff ff       	call   1f39 <getColor>
    2081:	83 c4 10             	add    $0x10,%esp
    2084:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    2087:	8b 45 fc             	mov    -0x4(%ebp),%eax
    208a:	8d 50 01             	lea    0x1(%eax),%edx
    208d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2090:	83 c0 01             	add    $0x1,%eax
    2093:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    2096:	83 c1 0c             	add    $0xc,%ecx
    2099:	51                   	push   %ecx
    209a:	52                   	push   %edx
    209b:	50                   	push   %eax
    209c:	ff 75 08             	pushl  0x8(%ebp)
    209f:	e8 95 fe ff ff       	call   1f39 <getColor>
    20a4:	83 c4 10             	add    $0x10,%esp
    20a7:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    20aa:	db 45 fc             	fildl  -0x4(%ebp)
    20ad:	d9 45 10             	flds   0x10(%ebp)
    20b0:	de e1                	fsubp  %st,%st(1)
    20b2:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    20b5:	db 45 f8             	fildl  -0x8(%ebp)
    20b8:	d9 45 0c             	flds   0xc(%ebp)
    20bb:	de e1                	fsubp  %st,%st(1)
    20bd:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    20c0:	d9 45 e4             	flds   -0x1c(%ebp)
    20c3:	d8 4d e0             	fmuls  -0x20(%ebp)
    20c6:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    20c9:	d9 e8                	fld1   
    20cb:	d8 65 e0             	fsubs  -0x20(%ebp)
    20ce:	d8 4d e4             	fmuls  -0x1c(%ebp)
    20d1:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    20d4:	d9 e8                	fld1   
    20d6:	d8 65 e4             	fsubs  -0x1c(%ebp)
    20d9:	d8 4d e0             	fmuls  -0x20(%ebp)
    20dc:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    20df:	d9 e8                	fld1   
    20e1:	d8 65 e4             	fsubs  -0x1c(%ebp)
    20e4:	d9 e8                	fld1   
    20e6:	d8 65 e0             	fsubs  -0x20(%ebp)
    20e9:	de c9                	fmulp  %st,%st(1)
    20eb:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    20ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    20f1:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    20f5:	0f b6 c0             	movzbl %al,%eax
    20f8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    20fb:	db 45 b4             	fildl  -0x4c(%ebp)
    20fe:	d8 4d d0             	fmuls  -0x30(%ebp)
    2101:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2104:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2107:	db 45 b4             	fildl  -0x4c(%ebp)
    210a:	de c9                	fmulp  %st,%st(1)
    210c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    210f:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2113:	0f b6 c0             	movzbl %al,%eax
    2116:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2119:	db 45 b4             	fildl  -0x4c(%ebp)
    211c:	d8 4d d4             	fmuls  -0x2c(%ebp)
    211f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2122:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2125:	db 45 b4             	fildl  -0x4c(%ebp)
    2128:	de c9                	fmulp  %st,%st(1)
    212a:	de c1                	faddp  %st,%st(1)
    212c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    212f:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2133:	0f b6 c0             	movzbl %al,%eax
    2136:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2139:	db 45 b4             	fildl  -0x4c(%ebp)
    213c:	d8 4d d8             	fmuls  -0x28(%ebp)
    213f:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2142:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2145:	db 45 b4             	fildl  -0x4c(%ebp)
    2148:	de c9                	fmulp  %st,%st(1)
    214a:	de c1                	faddp  %st,%st(1)
    214c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    214f:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2153:	0f b6 c0             	movzbl %al,%eax
    2156:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2159:	db 45 b4             	fildl  -0x4c(%ebp)
    215c:	d8 4d dc             	fmuls  -0x24(%ebp)
    215f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2162:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2165:	db 45 b4             	fildl  -0x4c(%ebp)
    2168:	de c9                	fmulp  %st,%st(1)
    216a:	de c1                	faddp  %st,%st(1)
    216c:	d9 7d be             	fnstcw -0x42(%ebp)
    216f:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    2173:	b4 0c                	mov    $0xc,%ah
    2175:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    2179:	d9 6d bc             	fldcw  -0x44(%ebp)
    217c:	db 5d b8             	fistpl -0x48(%ebp)
    217f:	d9 6d be             	fldcw  -0x42(%ebp)
    2182:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2185:	89 c2                	mov    %eax,%edx
    2187:	8b 45 14             	mov    0x14(%ebp),%eax
    218a:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    218d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2190:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2194:	0f b6 c0             	movzbl %al,%eax
    2197:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    219a:	db 45 b4             	fildl  -0x4c(%ebp)
    219d:	d8 4d d0             	fmuls  -0x30(%ebp)
    21a0:	8b 45 c0             	mov    -0x40(%ebp),%eax
    21a3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21a6:	db 45 b4             	fildl  -0x4c(%ebp)
    21a9:	de c9                	fmulp  %st,%st(1)
    21ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
    21ae:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    21b2:	0f b6 c0             	movzbl %al,%eax
    21b5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21b8:	db 45 b4             	fildl  -0x4c(%ebp)
    21bb:	d8 4d d4             	fmuls  -0x2c(%ebp)
    21be:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    21c1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21c4:	db 45 b4             	fildl  -0x4c(%ebp)
    21c7:	de c9                	fmulp  %st,%st(1)
    21c9:	de c1                	faddp  %st,%st(1)
    21cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    21ce:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    21d2:	0f b6 c0             	movzbl %al,%eax
    21d5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21d8:	db 45 b4             	fildl  -0x4c(%ebp)
    21db:	d8 4d d8             	fmuls  -0x28(%ebp)
    21de:	8b 45 c8             	mov    -0x38(%ebp),%eax
    21e1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21e4:	db 45 b4             	fildl  -0x4c(%ebp)
    21e7:	de c9                	fmulp  %st,%st(1)
    21e9:	de c1                	faddp  %st,%st(1)
    21eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    21ee:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    21f2:	0f b6 c0             	movzbl %al,%eax
    21f5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21f8:	db 45 b4             	fildl  -0x4c(%ebp)
    21fb:	d8 4d dc             	fmuls  -0x24(%ebp)
    21fe:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2201:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2204:	db 45 b4             	fildl  -0x4c(%ebp)
    2207:	de c9                	fmulp  %st,%st(1)
    2209:	de c1                	faddp  %st,%st(1)
    220b:	d9 6d bc             	fldcw  -0x44(%ebp)
    220e:	db 5d b8             	fistpl -0x48(%ebp)
    2211:	d9 6d be             	fldcw  -0x42(%ebp)
    2214:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2217:	89 c2                	mov    %eax,%edx
    2219:	8b 45 14             	mov    0x14(%ebp),%eax
    221c:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    221f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2222:	0f b6 00             	movzbl (%eax),%eax
    2225:	0f b6 c0             	movzbl %al,%eax
    2228:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    222b:	db 45 b4             	fildl  -0x4c(%ebp)
    222e:	d8 4d d0             	fmuls  -0x30(%ebp)
    2231:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2234:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2237:	db 45 b4             	fildl  -0x4c(%ebp)
    223a:	de c9                	fmulp  %st,%st(1)
    223c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    223f:	0f b6 00             	movzbl (%eax),%eax
    2242:	0f b6 c0             	movzbl %al,%eax
    2245:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2248:	db 45 b4             	fildl  -0x4c(%ebp)
    224b:	d8 4d d4             	fmuls  -0x2c(%ebp)
    224e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2251:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2254:	db 45 b4             	fildl  -0x4c(%ebp)
    2257:	de c9                	fmulp  %st,%st(1)
    2259:	de c1                	faddp  %st,%st(1)
    225b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    225e:	0f b6 00             	movzbl (%eax),%eax
    2261:	0f b6 c0             	movzbl %al,%eax
    2264:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2267:	db 45 b4             	fildl  -0x4c(%ebp)
    226a:	d8 4d d8             	fmuls  -0x28(%ebp)
    226d:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2270:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2273:	db 45 b4             	fildl  -0x4c(%ebp)
    2276:	de c9                	fmulp  %st,%st(1)
    2278:	de c1                	faddp  %st,%st(1)
    227a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    227d:	0f b6 00             	movzbl (%eax),%eax
    2280:	0f b6 c0             	movzbl %al,%eax
    2283:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2286:	db 45 b4             	fildl  -0x4c(%ebp)
    2289:	d8 4d dc             	fmuls  -0x24(%ebp)
    228c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    228f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2292:	db 45 b4             	fildl  -0x4c(%ebp)
    2295:	de c9                	fmulp  %st,%st(1)
    2297:	de c1                	faddp  %st,%st(1)
    2299:	d9 6d bc             	fldcw  -0x44(%ebp)
    229c:	db 5d b8             	fistpl -0x48(%ebp)
    229f:	d9 6d be             	fldcw  -0x42(%ebp)
    22a2:	8b 45 b8             	mov    -0x48(%ebp),%eax
    22a5:	89 c2                	mov    %eax,%edx
    22a7:	8b 45 14             	mov    0x14(%ebp),%eax
    22aa:	88 10                	mov    %dl,(%eax)

    return 1;
    22ac:	b8 01 00 00 00       	mov    $0x1,%eax
}
    22b1:	c9                   	leave  
    22b2:	c3                   	ret    

000022b3 <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    22b3:	55                   	push   %ebp
    22b4:	89 e5                	mov    %esp,%ebp
    22b6:	53                   	push   %ebx
    22b7:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    22ba:	8b 45 10             	mov    0x10(%ebp),%eax
    22bd:	c1 f8 10             	sar    $0x10,%eax
    22c0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    22c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    22c6:	c1 f8 10             	sar    $0x10,%eax
    22c9:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    22cc:	8d 45 bc             	lea    -0x44(%ebp),%eax
    22cf:	50                   	push   %eax
    22d0:	ff 75 f8             	pushl  -0x8(%ebp)
    22d3:	ff 75 f4             	pushl  -0xc(%ebp)
    22d6:	ff 75 08             	pushl  0x8(%ebp)
    22d9:	e8 5b fc ff ff       	call   1f39 <getColor>
    22de:	83 c4 10             	add    $0x10,%esp
    22e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    22e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    22e7:	83 c0 01             	add    $0x1,%eax
    22ea:	8d 55 bc             	lea    -0x44(%ebp),%edx
    22ed:	83 c2 04             	add    $0x4,%edx
    22f0:	52                   	push   %edx
    22f1:	ff 75 f8             	pushl  -0x8(%ebp)
    22f4:	50                   	push   %eax
    22f5:	ff 75 08             	pushl  0x8(%ebp)
    22f8:	e8 3c fc ff ff       	call   1f39 <getColor>
    22fd:	83 c4 10             	add    $0x10,%esp
    2300:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    2303:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2306:	83 c0 01             	add    $0x1,%eax
    2309:	8d 55 bc             	lea    -0x44(%ebp),%edx
    230c:	83 c2 08             	add    $0x8,%edx
    230f:	52                   	push   %edx
    2310:	50                   	push   %eax
    2311:	ff 75 f4             	pushl  -0xc(%ebp)
    2314:	ff 75 08             	pushl  0x8(%ebp)
    2317:	e8 1d fc ff ff       	call   1f39 <getColor>
    231c:	83 c4 10             	add    $0x10,%esp
    231f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    2322:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2325:	8d 50 01             	lea    0x1(%eax),%edx
    2328:	8b 45 f4             	mov    -0xc(%ebp),%eax
    232b:	83 c0 01             	add    $0x1,%eax
    232e:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    2331:	83 c1 0c             	add    $0xc,%ecx
    2334:	51                   	push   %ecx
    2335:	52                   	push   %edx
    2336:	50                   	push   %eax
    2337:	ff 75 08             	pushl  0x8(%ebp)
    233a:	e8 fa fb ff ff       	call   1f39 <getColor>
    233f:	83 c4 10             	add    $0x10,%esp
    2342:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    2345:	8b 45 10             	mov    0x10(%ebp),%eax
    2348:	0f b7 c0             	movzwl %ax,%eax
    234b:	c1 f8 08             	sar    $0x8,%eax
    234e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    2351:	8b 45 0c             	mov    0xc(%ebp),%eax
    2354:	0f b7 c0             	movzwl %ax,%eax
    2357:	c1 f8 08             	sar    $0x8,%eax
    235a:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    235d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2360:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    2364:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    2367:	b8 ff 00 00 00       	mov    $0xff,%eax
    236c:	2b 45 dc             	sub    -0x24(%ebp),%eax
    236f:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    2373:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    2376:	b8 ff 00 00 00       	mov    $0xff,%eax
    237b:	2b 45 e0             	sub    -0x20(%ebp),%eax
    237e:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    2382:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    2385:	b8 ff 00 00 00       	mov    $0xff,%eax
    238a:	2b 45 e0             	sub    -0x20(%ebp),%eax
    238d:	89 c2                	mov    %eax,%edx
    238f:	b8 ff 00 00 00       	mov    $0xff,%eax
    2394:	2b 45 dc             	sub    -0x24(%ebp),%eax
    2397:	0f af c2             	imul   %edx,%eax
    239a:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    239d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    23a0:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    23a4:	0f b6 c0             	movzbl %al,%eax
    23a7:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    23ab:	8b 55 bc             	mov    -0x44(%ebp),%edx
    23ae:	0f af d0             	imul   %eax,%edx
    23b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    23b4:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    23b8:	0f b6 c0             	movzbl %al,%eax
    23bb:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    23bf:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    23c2:	0f af c1             	imul   %ecx,%eax
    23c5:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    23c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    23cb:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    23cf:	0f b6 c0             	movzbl %al,%eax
    23d2:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    23d6:	8b 55 c8             	mov    -0x38(%ebp),%edx
    23d9:	0f af d0             	imul   %eax,%edx
    23dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    23df:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    23e3:	0f b6 c0             	movzbl %al,%eax
    23e6:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    23ea:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    23ed:	0f af c1             	imul   %ecx,%eax
    23f0:	01 d0                	add    %edx,%eax
    23f2:	01 d8                	add    %ebx,%eax
    23f4:	c1 e8 10             	shr    $0x10,%eax
    23f7:	89 c2                	mov    %eax,%edx
    23f9:	8b 45 14             	mov    0x14(%ebp),%eax
    23fc:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    23ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2402:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2406:	0f b6 c0             	movzbl %al,%eax
    2409:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    240d:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2410:	0f af d0             	imul   %eax,%edx
    2413:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2416:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    241a:	0f b6 c0             	movzbl %al,%eax
    241d:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2421:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2424:	0f af c1             	imul   %ecx,%eax
    2427:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    242a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    242d:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2431:	0f b6 c0             	movzbl %al,%eax
    2434:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2438:	8b 55 c8             	mov    -0x38(%ebp),%edx
    243b:	0f af d0             	imul   %eax,%edx
    243e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2441:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2445:	0f b6 c0             	movzbl %al,%eax
    2448:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    244c:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    244f:	0f af c1             	imul   %ecx,%eax
    2452:	01 d0                	add    %edx,%eax
    2454:	01 d8                	add    %ebx,%eax
    2456:	c1 e8 10             	shr    $0x10,%eax
    2459:	89 c2                	mov    %eax,%edx
    245b:	8b 45 14             	mov    0x14(%ebp),%eax
    245e:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    2461:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2464:	0f b6 00             	movzbl (%eax),%eax
    2467:	0f b6 c0             	movzbl %al,%eax
    246a:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    246e:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2471:	0f af d0             	imul   %eax,%edx
    2474:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2477:	0f b6 00             	movzbl (%eax),%eax
    247a:	0f b6 c0             	movzbl %al,%eax
    247d:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2481:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2484:	0f af c1             	imul   %ecx,%eax
    2487:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    248a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    248d:	0f b6 00             	movzbl (%eax),%eax
    2490:	0f b6 c0             	movzbl %al,%eax
    2493:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2497:	8b 55 c8             	mov    -0x38(%ebp),%edx
    249a:	0f af d0             	imul   %eax,%edx
    249d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    24a0:	0f b6 00             	movzbl (%eax),%eax
    24a3:	0f b6 c0             	movzbl %al,%eax
    24a6:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    24aa:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    24ad:	0f af c1             	imul   %ecx,%eax
    24b0:	01 d0                	add    %edx,%eax
    24b2:	01 d8                	add    %ebx,%eax
    24b4:	c1 e8 10             	shr    $0x10,%eax
    24b7:	89 c2                	mov    %eax,%edx
    24b9:	8b 45 14             	mov    0x14(%ebp),%eax
    24bc:	88 10                	mov    %dl,(%eax)
}
    24be:	90                   	nop
    24bf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    24c2:	c9                   	leave  
    24c3:	c3                   	ret    

000024c4 <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    24c4:	55                   	push   %ebp
    24c5:	89 e5                	mov    %esp,%ebp
    24c7:	53                   	push   %ebx
    24c8:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    24cb:	8b 45 08             	mov    0x8(%ebp),%eax
    24ce:	8b 00                	mov    (%eax),%eax
    24d0:	c1 e0 10             	shl    $0x10,%eax
    24d3:	89 c1                	mov    %eax,%ecx
    24d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    24d8:	8b 18                	mov    (%eax),%ebx
    24da:	89 c8                	mov    %ecx,%eax
    24dc:	99                   	cltd   
    24dd:	f7 fb                	idiv   %ebx
    24df:	83 c0 01             	add    $0x1,%eax
    24e2:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    24e5:	8b 45 08             	mov    0x8(%ebp),%eax
    24e8:	8b 40 04             	mov    0x4(%eax),%eax
    24eb:	c1 e0 10             	shl    $0x10,%eax
    24ee:	89 c1                	mov    %eax,%ecx
    24f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    24f3:	8b 58 04             	mov    0x4(%eax),%ebx
    24f6:	89 c8                	mov    %ecx,%eax
    24f8:	99                   	cltd   
    24f9:	f7 fb                	idiv   %ebx
    24fb:	83 c0 01             	add    $0x1,%eax
    24fe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    2501:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2504:	d1 f8                	sar    %eax
    2506:	2d 00 80 00 00       	sub    $0x8000,%eax
    250b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    250e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2511:	d1 f8                	sar    %eax
    2513:	2d 00 80 00 00       	sub    $0x8000,%eax
    2518:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    251b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    251e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    2521:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2528:	eb 5d                	jmp    2587 <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    252a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    252d:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    2530:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    2537:	eb 3a                	jmp    2573 <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    2539:	8b 45 0c             	mov    0xc(%ebp),%eax
    253c:	8b 48 08             	mov    0x8(%eax),%ecx
    253f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2542:	8b 00                	mov    (%eax),%eax
    2544:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2548:	89 c2                	mov    %eax,%edx
    254a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    254d:	01 c2                	add    %eax,%edx
    254f:	89 d0                	mov    %edx,%eax
    2551:	01 c0                	add    %eax,%eax
    2553:	01 d0                	add    %edx,%eax
    2555:	01 c8                	add    %ecx,%eax
    2557:	50                   	push   %eax
    2558:	ff 75 f0             	pushl  -0x10(%ebp)
    255b:	ff 75 f8             	pushl  -0x8(%ebp)
    255e:	ff 75 08             	pushl  0x8(%ebp)
    2561:	e8 4d fd ff ff       	call   22b3 <mixColorInt>
    2566:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    2569:	8b 45 e8             	mov    -0x18(%ebp),%eax
    256c:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    256f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    2573:	8b 45 0c             	mov    0xc(%ebp),%eax
    2576:	8b 00                	mov    (%eax),%eax
    2578:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    257b:	7f bc                	jg     2539 <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    257d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2580:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    2583:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2587:	8b 45 0c             	mov    0xc(%ebp),%eax
    258a:	8b 40 04             	mov    0x4(%eax),%eax
    258d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2590:	7f 98                	jg     252a <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    2592:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2597:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    259a:	c9                   	leave  
    259b:	c3                   	ret    

0000259c <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    259c:	55                   	push   %ebp
    259d:	89 e5                	mov    %esp,%ebp
    259f:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    25a2:	8b 45 08             	mov    0x8(%ebp),%eax
    25a5:	8b 00                	mov    (%eax),%eax
    25a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    25aa:	db 45 e4             	fildl  -0x1c(%ebp)
    25ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    25b0:	8b 00                	mov    (%eax),%eax
    25b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    25b5:	db 45 e4             	fildl  -0x1c(%ebp)
    25b8:	de f9                	fdivrp %st,%st(1)
    25ba:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    25bd:	8b 45 08             	mov    0x8(%ebp),%eax
    25c0:	8b 40 04             	mov    0x4(%eax),%eax
    25c3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    25c6:	db 45 e4             	fildl  -0x1c(%ebp)
    25c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    25cc:	8b 40 04             	mov    0x4(%eax),%eax
    25cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    25d2:	db 45 e4             	fildl  -0x1c(%ebp)
    25d5:	de f9                	fdivrp %st,%st(1)
    25d7:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    25da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    25e1:	eb 5e                	jmp    2641 <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    25e3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    25ea:	eb 47                	jmp    2633 <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    25ec:	db 45 f8             	fildl  -0x8(%ebp)
    25ef:	d8 4d f4             	fmuls  -0xc(%ebp)
    25f2:	d9 7d ee             	fnstcw -0x12(%ebp)
    25f5:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    25f9:	b4 0c                	mov    $0xc,%ah
    25fb:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    25ff:	d9 6d ec             	fldcw  -0x14(%ebp)
    2602:	db 5d e8             	fistpl -0x18(%ebp)
    2605:	d9 6d ee             	fldcw  -0x12(%ebp)
    2608:	8b 55 e8             	mov    -0x18(%ebp),%edx
    260b:	db 45 fc             	fildl  -0x4(%ebp)
    260e:	d8 4d f0             	fmuls  -0x10(%ebp)
    2611:	d9 6d ec             	fldcw  -0x14(%ebp)
    2614:	db 5d e8             	fistpl -0x18(%ebp)
    2617:	d9 6d ee             	fldcw  -0x12(%ebp)
    261a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    261d:	6a 00                	push   $0x0
    261f:	52                   	push   %edx
    2620:	50                   	push   %eax
    2621:	ff 75 08             	pushl  0x8(%ebp)
    2624:	e8 10 f9 ff ff       	call   1f39 <getColor>
    2629:	83 c4 10             	add    $0x10,%esp
    262c:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    262f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2633:	8b 45 0c             	mov    0xc(%ebp),%eax
    2636:	8b 00                	mov    (%eax),%eax
    2638:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    263b:	7f af                	jg     25ec <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    263d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2641:	8b 45 0c             	mov    0xc(%ebp),%eax
    2644:	8b 40 04             	mov    0x4(%eax),%eax
    2647:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    264a:	7f 97                	jg     25e3 <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    264c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2651:	c9                   	leave  
    2652:	c3                   	ret    

00002653 <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    2653:	55                   	push   %ebp
    2654:	89 e5                	mov    %esp,%ebp
    2656:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    2659:	8b 45 08             	mov    0x8(%ebp),%eax
    265c:	8b 00                	mov    (%eax),%eax
    265e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2661:	db 45 e0             	fildl  -0x20(%ebp)
    2664:	d9 5d e0             	fstps  -0x20(%ebp)
    2667:	83 ec 0c             	sub    $0xc,%esp
    266a:	ff 75 10             	pushl  0x10(%ebp)
    266d:	e8 6b e2 ff ff       	call   8dd <cos>
    2672:	83 c4 10             	add    $0x10,%esp
    2675:	d9 5d dc             	fstps  -0x24(%ebp)
    2678:	8b 45 dc             	mov    -0x24(%ebp),%eax
    267b:	83 ec 0c             	sub    $0xc,%esp
    267e:	50                   	push   %eax
    267f:	e8 90 e1 ff ff       	call   814 <abs>
    2684:	83 c4 10             	add    $0x10,%esp
    2687:	d8 4d e0             	fmuls  -0x20(%ebp)
    268a:	d9 5d e0             	fstps  -0x20(%ebp)
    268d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2690:	8b 00                	mov    (%eax),%eax
    2692:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2695:	db 45 dc             	fildl  -0x24(%ebp)
    2698:	d9 5d dc             	fstps  -0x24(%ebp)
    269b:	83 ec 0c             	sub    $0xc,%esp
    269e:	ff 75 10             	pushl  0x10(%ebp)
    26a1:	e8 da e3 ff ff       	call   a80 <sin>
    26a6:	83 c4 10             	add    $0x10,%esp
    26a9:	d9 5d d8             	fstps  -0x28(%ebp)
    26ac:	8b 45 d8             	mov    -0x28(%ebp),%eax
    26af:	83 ec 0c             	sub    $0xc,%esp
    26b2:	50                   	push   %eax
    26b3:	e8 5c e1 ff ff       	call   814 <abs>
    26b8:	83 c4 10             	add    $0x10,%esp
    26bb:	d8 4d dc             	fmuls  -0x24(%ebp)
    26be:	d8 45 e0             	fadds  -0x20(%ebp)
    26c1:	d9 7d e6             	fnstcw -0x1a(%ebp)
    26c4:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    26c8:	b4 0c                	mov    $0xc,%ah
    26ca:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    26ce:	d9 6d e4             	fldcw  -0x1c(%ebp)
    26d1:	db 5d f4             	fistpl -0xc(%ebp)
    26d4:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    26d7:	8b 45 08             	mov    0x8(%ebp),%eax
    26da:	8b 00                	mov    (%eax),%eax
    26dc:	89 45 e0             	mov    %eax,-0x20(%ebp)
    26df:	db 45 e0             	fildl  -0x20(%ebp)
    26e2:	d9 5d e0             	fstps  -0x20(%ebp)
    26e5:	83 ec 0c             	sub    $0xc,%esp
    26e8:	ff 75 10             	pushl  0x10(%ebp)
    26eb:	e8 90 e3 ff ff       	call   a80 <sin>
    26f0:	83 c4 10             	add    $0x10,%esp
    26f3:	d9 5d dc             	fstps  -0x24(%ebp)
    26f6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    26f9:	83 ec 0c             	sub    $0xc,%esp
    26fc:	50                   	push   %eax
    26fd:	e8 12 e1 ff ff       	call   814 <abs>
    2702:	83 c4 10             	add    $0x10,%esp
    2705:	d8 4d e0             	fmuls  -0x20(%ebp)
    2708:	d9 5d e0             	fstps  -0x20(%ebp)
    270b:	8b 45 0c             	mov    0xc(%ebp),%eax
    270e:	8b 00                	mov    (%eax),%eax
    2710:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2713:	db 45 dc             	fildl  -0x24(%ebp)
    2716:	d9 5d dc             	fstps  -0x24(%ebp)
    2719:	83 ec 0c             	sub    $0xc,%esp
    271c:	ff 75 10             	pushl  0x10(%ebp)
    271f:	e8 b9 e1 ff ff       	call   8dd <cos>
    2724:	83 c4 10             	add    $0x10,%esp
    2727:	d9 5d d8             	fstps  -0x28(%ebp)
    272a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    272d:	83 ec 0c             	sub    $0xc,%esp
    2730:	50                   	push   %eax
    2731:	e8 de e0 ff ff       	call   814 <abs>
    2736:	83 c4 10             	add    $0x10,%esp
    2739:	d8 4d dc             	fmuls  -0x24(%ebp)
    273c:	d8 45 e0             	fadds  -0x20(%ebp)
    273f:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2742:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    2746:	b4 0c                	mov    $0xc,%ah
    2748:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    274c:	d9 6d e4             	fldcw  -0x1c(%ebp)
    274f:	db 5d f0             	fistpl -0x10(%ebp)
    2752:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    2755:	8b 45 0c             	mov    0xc(%ebp),%eax
    2758:	8b 55 f0             	mov    -0x10(%ebp),%edx
    275b:	89 10                	mov    %edx,(%eax)
    *width = w;
    275d:	8b 45 08             	mov    0x8(%ebp),%eax
    2760:	8b 55 f4             	mov    -0xc(%ebp),%edx
    2763:	89 10                	mov    %edx,(%eax)
    return 1;
    2765:	b8 01 00 00 00       	mov    $0x1,%eax
}
    276a:	c9                   	leave  
    276b:	c3                   	ret    

0000276c <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    276c:	55                   	push   %ebp
    276d:	89 e5                	mov    %esp,%ebp
    276f:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    2772:	8b 45 08             	mov    0x8(%ebp),%eax
    2775:	8b 40 04             	mov    0x4(%eax),%eax
    2778:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    277b:	db 45 c4             	fildl  -0x3c(%ebp)
    277e:	d9 05 44 9c 01 00    	flds   0x19c44
    2784:	de f9                	fdivrp %st,%st(1)
    2786:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    2789:	8b 45 08             	mov    0x8(%ebp),%eax
    278c:	8b 00                	mov    (%eax),%eax
    278e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2791:	db 45 c4             	fildl  -0x3c(%ebp)
    2794:	d9 05 44 9c 01 00    	flds   0x19c44
    279a:	de f9                	fdivrp %st,%st(1)
    279c:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    279f:	8b 45 0c             	mov    0xc(%ebp),%eax
    27a2:	8b 50 04             	mov    0x4(%eax),%edx
    27a5:	8b 45 08             	mov    0x8(%ebp),%eax
    27a8:	8b 40 04             	mov    0x4(%eax),%eax
    27ab:	29 c2                	sub    %eax,%edx
    27ad:	89 d0                	mov    %edx,%eax
    27af:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    27b2:	db 45 c4             	fildl  -0x3c(%ebp)
    27b5:	d9 05 44 9c 01 00    	flds   0x19c44
    27bb:	de f9                	fdivrp %st,%st(1)
    27bd:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    27c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    27c3:	8b 10                	mov    (%eax),%edx
    27c5:	8b 45 08             	mov    0x8(%ebp),%eax
    27c8:	8b 00                	mov    (%eax),%eax
    27ca:	29 c2                	sub    %eax,%edx
    27cc:	89 d0                	mov    %edx,%eax
    27ce:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    27d1:	db 45 c4             	fildl  -0x3c(%ebp)
    27d4:	d9 05 44 9c 01 00    	flds   0x19c44
    27da:	de f9                	fdivrp %st,%st(1)
    27dc:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    27df:	d9 45 10             	flds   0x10(%ebp)
    27e2:	d9 e0                	fchs   
    27e4:	83 ec 0c             	sub    $0xc,%esp
    27e7:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    27eb:	d9 1c 24             	fstps  (%esp)
    27ee:	e8 ea e0 ff ff       	call   8dd <cos>
    27f3:	83 c4 10             	add    $0x10,%esp
    27f6:	d9 5d c4             	fstps  -0x3c(%ebp)
    27f9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    27fc:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    27ff:	d9 45 10             	flds   0x10(%ebp)
    2802:	d9 e0                	fchs   
    2804:	83 ec 0c             	sub    $0xc,%esp
    2807:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    280b:	d9 1c 24             	fstps  (%esp)
    280e:	e8 6d e2 ff ff       	call   a80 <sin>
    2813:	83 c4 10             	add    $0x10,%esp
    2816:	d9 5d c4             	fstps  -0x3c(%ebp)
    2819:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    281c:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    281f:	d9 ee                	fldz   
    2821:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    2824:	d9 ee                	fldz   
    2826:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    2829:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2830:	e9 28 01 00 00       	jmp    295d <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    2835:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    283c:	e9 0a 01 00 00       	jmp    294b <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    2841:	db 45 f4             	fildl  -0xc(%ebp)
    2844:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2847:	d8 65 ec             	fsubs  -0x14(%ebp)
    284a:	d8 4d dc             	fmuls  -0x24(%ebp)
    284d:	db 45 f0             	fildl  -0x10(%ebp)
    2850:	d8 65 e0             	fsubs  -0x20(%ebp)
    2853:	d8 65 e8             	fsubs  -0x18(%ebp)
    2856:	d8 4d d8             	fmuls  -0x28(%ebp)
    2859:	de c1                	faddp  %st,%st(1)
    285b:	d8 45 ec             	fadds  -0x14(%ebp)
    285e:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    2861:	db 45 f0             	fildl  -0x10(%ebp)
    2864:	d8 65 e0             	fsubs  -0x20(%ebp)
    2867:	d8 65 e8             	fsubs  -0x18(%ebp)
    286a:	d8 4d dc             	fmuls  -0x24(%ebp)
    286d:	db 45 f4             	fildl  -0xc(%ebp)
    2870:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2873:	d8 65 ec             	fsubs  -0x14(%ebp)
    2876:	d8 4d d8             	fmuls  -0x28(%ebp)
    2879:	de e9                	fsubrp %st,%st(1)
    287b:	d8 45 e8             	fadds  -0x18(%ebp)
    287e:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    2881:	d9 45 d4             	flds   -0x2c(%ebp)
    2884:	d9 ee                	fldz   
    2886:	d9 c9                	fxch   %st(1)
    2888:	df e9                	fucomip %st(1),%st
    288a:	dd d8                	fstp   %st(0)
    288c:	0f 93 c0             	setae  %al
    288f:	83 f0 01             	xor    $0x1,%eax
    2892:	84 c0                	test   %al,%al
    2894:	75 52                	jne    28e8 <picTurn+0x17c>
    2896:	8b 45 08             	mov    0x8(%ebp),%eax
    2899:	8b 40 04             	mov    0x4(%eax),%eax
    289c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    289f:	db 45 c4             	fildl  -0x3c(%ebp)
    28a2:	d9 45 d4             	flds   -0x2c(%ebp)
    28a5:	d9 c9                	fxch   %st(1)
    28a7:	df e9                	fucomip %st(1),%st
    28a9:	dd d8                	fstp   %st(0)
    28ab:	0f 97 c0             	seta   %al
    28ae:	83 f0 01             	xor    $0x1,%eax
    28b1:	84 c0                	test   %al,%al
    28b3:	75 33                	jne    28e8 <picTurn+0x17c>
    28b5:	d9 45 d0             	flds   -0x30(%ebp)
    28b8:	d9 ee                	fldz   
    28ba:	d9 c9                	fxch   %st(1)
    28bc:	df e9                	fucomip %st(1),%st
    28be:	dd d8                	fstp   %st(0)
    28c0:	0f 93 c0             	setae  %al
    28c3:	83 f0 01             	xor    $0x1,%eax
    28c6:	84 c0                	test   %al,%al
    28c8:	75 1e                	jne    28e8 <picTurn+0x17c>
    28ca:	8b 45 08             	mov    0x8(%ebp),%eax
    28cd:	8b 00                	mov    (%eax),%eax
    28cf:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    28d2:	db 45 c4             	fildl  -0x3c(%ebp)
    28d5:	d9 45 d0             	flds   -0x30(%ebp)
    28d8:	d9 c9                	fxch   %st(1)
    28da:	df e9                	fucomip %st(1),%st
    28dc:	dd d8                	fstp   %st(0)
    28de:	0f 97 c0             	seta   %al
    28e1:	83 f0 01             	xor    $0x1,%eax
    28e4:	84 c0                	test   %al,%al
    28e6:	74 2f                	je     2917 <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    28e8:	8b 45 0c             	mov    0xc(%ebp),%eax
    28eb:	8b 48 08             	mov    0x8(%eax),%ecx
    28ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    28f1:	8b 00                	mov    (%eax),%eax
    28f3:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    28f7:	89 c2                	mov    %eax,%edx
    28f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    28fc:	01 c2                	add    %eax,%edx
    28fe:	89 d0                	mov    %edx,%eax
    2900:	01 c0                	add    %eax,%eax
    2902:	01 d0                	add    %edx,%eax
    2904:	01 c8                	add    %ecx,%eax
    2906:	83 ec 08             	sub    $0x8,%esp
    2909:	50                   	push   %eax
    290a:	68 91 e0 01 00       	push   $0x1e091
    290f:	e8 9f f6 ff ff       	call   1fb3 <setColor>
    2914:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    2917:	8b 45 0c             	mov    0xc(%ebp),%eax
    291a:	8b 48 08             	mov    0x8(%eax),%ecx
    291d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2920:	8b 00                	mov    (%eax),%eax
    2922:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2926:	89 c2                	mov    %eax,%edx
    2928:	8b 45 f0             	mov    -0x10(%ebp),%eax
    292b:	01 c2                	add    %eax,%edx
    292d:	89 d0                	mov    %edx,%eax
    292f:	01 c0                	add    %eax,%eax
    2931:	01 d0                	add    %edx,%eax
    2933:	01 c8                	add    %ecx,%eax
    2935:	50                   	push   %eax
    2936:	ff 75 d0             	pushl  -0x30(%ebp)
    2939:	ff 75 d4             	pushl  -0x2c(%ebp)
    293c:	ff 75 08             	pushl  0x8(%ebp)
    293f:	e8 9e f6 ff ff       	call   1fe2 <mixColor>
    2944:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    2947:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    294b:	8b 45 0c             	mov    0xc(%ebp),%eax
    294e:	8b 00                	mov    (%eax),%eax
    2950:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2953:	0f 8f e8 fe ff ff    	jg     2841 <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    2959:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    295d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2960:	8b 40 04             	mov    0x4(%eax),%eax
    2963:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2966:	0f 8f c9 fe ff ff    	jg     2835 <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    296c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2971:	c9                   	leave  
    2972:	c3                   	ret    

00002973 <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    2973:	55                   	push   %ebp
    2974:	89 e5                	mov    %esp,%ebp
    2976:	53                   	push   %ebx
    2977:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    297a:	8b 45 08             	mov    0x8(%ebp),%eax
    297d:	8b 10                	mov    (%eax),%edx
    297f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2982:	8b 00                	mov    (%eax),%eax
    2984:	39 c2                	cmp    %eax,%edx
    2986:	75 10                	jne    2998 <picRollingOver+0x25>
    2988:	8b 45 08             	mov    0x8(%ebp),%eax
    298b:	8b 50 04             	mov    0x4(%eax),%edx
    298e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2991:	8b 40 04             	mov    0x4(%eax),%eax
    2994:	39 c2                	cmp    %eax,%edx
    2996:	74 0a                	je     29a2 <picRollingOver+0x2f>
        return 0;
    2998:	b8 00 00 00 00       	mov    $0x0,%eax
    299d:	e9 88 00 00 00       	jmp    2a2a <picRollingOver+0xb7>

    int h = src->height;
    29a2:	8b 45 08             	mov    0x8(%ebp),%eax
    29a5:	8b 40 04             	mov    0x4(%eax),%eax
    29a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    29ab:	8b 45 08             	mov    0x8(%ebp),%eax
    29ae:	8b 00                	mov    (%eax),%eax
    29b0:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    29b3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    29ba:	eb 61                	jmp    2a1d <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    29bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    29c3:	eb 4c                	jmp    2a11 <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    29c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    29c8:	8b 48 08             	mov    0x8(%eax),%ecx
    29cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    29ce:	2b 45 f8             	sub    -0x8(%ebp),%eax
    29d1:	83 e8 01             	sub    $0x1,%eax
    29d4:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    29d8:	89 c2                	mov    %eax,%edx
    29da:	8b 45 f4             	mov    -0xc(%ebp),%eax
    29dd:	01 c2                	add    %eax,%edx
    29df:	89 d0                	mov    %edx,%eax
    29e1:	01 c0                	add    %eax,%eax
    29e3:	01 d0                	add    %edx,%eax
    29e5:	01 c1                	add    %eax,%ecx
    29e7:	8b 45 08             	mov    0x8(%ebp),%eax
    29ea:	8b 58 08             	mov    0x8(%eax),%ebx
    29ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
    29f0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    29f4:	89 c2                	mov    %eax,%edx
    29f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    29f9:	01 c2                	add    %eax,%edx
    29fb:	89 d0                	mov    %edx,%eax
    29fd:	01 c0                	add    %eax,%eax
    29ff:	01 d0                	add    %edx,%eax
    2a01:	01 d8                	add    %ebx,%eax
    2a03:	51                   	push   %ecx
    2a04:	50                   	push   %eax
    2a05:	e8 a9 f5 ff ff       	call   1fb3 <setColor>
    2a0a:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2a0d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2a11:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a14:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2a17:	7c ac                	jl     29c5 <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2a19:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2a1d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a20:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2a23:	7c 97                	jl     29bc <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    2a25:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2a2a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2a2d:	c9                   	leave  
    2a2e:	c3                   	ret    

00002a2f <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    2a2f:	55                   	push   %ebp
    2a30:	89 e5                	mov    %esp,%ebp
    2a32:	53                   	push   %ebx
    2a33:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2a36:	8b 45 08             	mov    0x8(%ebp),%eax
    2a39:	8b 10                	mov    (%eax),%edx
    2a3b:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a3e:	8b 00                	mov    (%eax),%eax
    2a40:	39 c2                	cmp    %eax,%edx
    2a42:	75 10                	jne    2a54 <picTurnAround+0x25>
    2a44:	8b 45 08             	mov    0x8(%ebp),%eax
    2a47:	8b 50 04             	mov    0x4(%eax),%edx
    2a4a:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a4d:	8b 40 04             	mov    0x4(%eax),%eax
    2a50:	39 c2                	cmp    %eax,%edx
    2a52:	74 0a                	je     2a5e <picTurnAround+0x2f>
        return 0;
    2a54:	b8 00 00 00 00       	mov    $0x0,%eax
    2a59:	e9 88 00 00 00       	jmp    2ae6 <picTurnAround+0xb7>

    int h = src->height;
    2a5e:	8b 45 08             	mov    0x8(%ebp),%eax
    2a61:	8b 40 04             	mov    0x4(%eax),%eax
    2a64:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2a67:	8b 45 08             	mov    0x8(%ebp),%eax
    2a6a:	8b 00                	mov    (%eax),%eax
    2a6c:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2a6f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2a76:	eb 61                	jmp    2ad9 <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    2a78:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2a7f:	eb 4c                	jmp    2acd <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    2a81:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a84:	8b 48 08             	mov    0x8(%eax),%ecx
    2a87:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a8a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2a8e:	89 c2                	mov    %eax,%edx
    2a90:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2a93:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2a96:	01 c2                	add    %eax,%edx
    2a98:	89 d0                	mov    %edx,%eax
    2a9a:	01 c0                	add    %eax,%eax
    2a9c:	01 d0                	add    %edx,%eax
    2a9e:	83 e8 03             	sub    $0x3,%eax
    2aa1:	01 c1                	add    %eax,%ecx
    2aa3:	8b 45 08             	mov    0x8(%ebp),%eax
    2aa6:	8b 58 08             	mov    0x8(%eax),%ebx
    2aa9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2aac:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2ab0:	89 c2                	mov    %eax,%edx
    2ab2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ab5:	01 c2                	add    %eax,%edx
    2ab7:	89 d0                	mov    %edx,%eax
    2ab9:	01 c0                	add    %eax,%eax
    2abb:	01 d0                	add    %edx,%eax
    2abd:	01 d8                	add    %ebx,%eax
    2abf:	51                   	push   %ecx
    2ac0:	50                   	push   %eax
    2ac1:	e8 ed f4 ff ff       	call   1fb3 <setColor>
    2ac6:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2ac9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ad0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2ad3:	7c ac                	jl     2a81 <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2ad5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2ad9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2adc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2adf:	7c 97                	jl     2a78 <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    2ae1:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2ae6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2ae9:	c9                   	leave  
    2aea:	c3                   	ret    

00002aeb <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    2aeb:	55                   	push   %ebp
    2aec:	89 e5                	mov    %esp,%ebp
    2aee:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    2af1:	83 ec 0c             	sub    $0xc,%esp
    2af4:	ff 75 08             	pushl  0x8(%ebp)
    2af7:	e8 c5 d5 ff ff       	call   c1 <strlen>
    2afc:	83 c4 10             	add    $0x10,%esp
    2aff:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    2b02:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b05:	8d 50 ff             	lea    -0x1(%eax),%edx
    2b08:	8b 45 08             	mov    0x8(%ebp),%eax
    2b0b:	01 d0                	add    %edx,%eax
    2b0d:	0f b6 00             	movzbl (%eax),%eax
    2b10:	3c 67                	cmp    $0x67,%al
    2b12:	75 2b                	jne    2b3f <type+0x54>
    2b14:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b17:	8d 50 fe             	lea    -0x2(%eax),%edx
    2b1a:	8b 45 08             	mov    0x8(%ebp),%eax
    2b1d:	01 d0                	add    %edx,%eax
    2b1f:	0f b6 00             	movzbl (%eax),%eax
    2b22:	3c 70                	cmp    $0x70,%al
    2b24:	75 19                	jne    2b3f <type+0x54>
    2b26:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b29:	8d 50 fd             	lea    -0x3(%eax),%edx
    2b2c:	8b 45 08             	mov    0x8(%ebp),%eax
    2b2f:	01 d0                	add    %edx,%eax
    2b31:	0f b6 00             	movzbl (%eax),%eax
    2b34:	3c 6a                	cmp    $0x6a,%al
    2b36:	75 07                	jne    2b3f <type+0x54>
    2b38:	b8 00 00 00 00       	mov    $0x0,%eax
    2b3d:	eb 7f                	jmp    2bbe <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    2b3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b42:	8d 50 ff             	lea    -0x1(%eax),%edx
    2b45:	8b 45 08             	mov    0x8(%ebp),%eax
    2b48:	01 d0                	add    %edx,%eax
    2b4a:	0f b6 00             	movzbl (%eax),%eax
    2b4d:	3c 70                	cmp    $0x70,%al
    2b4f:	75 2b                	jne    2b7c <type+0x91>
    2b51:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b54:	8d 50 fe             	lea    -0x2(%eax),%edx
    2b57:	8b 45 08             	mov    0x8(%ebp),%eax
    2b5a:	01 d0                	add    %edx,%eax
    2b5c:	0f b6 00             	movzbl (%eax),%eax
    2b5f:	3c 6d                	cmp    $0x6d,%al
    2b61:	75 19                	jne    2b7c <type+0x91>
    2b63:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b66:	8d 50 fd             	lea    -0x3(%eax),%edx
    2b69:	8b 45 08             	mov    0x8(%ebp),%eax
    2b6c:	01 d0                	add    %edx,%eax
    2b6e:	0f b6 00             	movzbl (%eax),%eax
    2b71:	3c 62                	cmp    $0x62,%al
    2b73:	75 07                	jne    2b7c <type+0x91>
    2b75:	b8 01 00 00 00       	mov    $0x1,%eax
    2b7a:	eb 42                	jmp    2bbe <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    2b7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b7f:	8d 50 ff             	lea    -0x1(%eax),%edx
    2b82:	8b 45 08             	mov    0x8(%ebp),%eax
    2b85:	01 d0                	add    %edx,%eax
    2b87:	0f b6 00             	movzbl (%eax),%eax
    2b8a:	3c 67                	cmp    $0x67,%al
    2b8c:	75 2b                	jne    2bb9 <type+0xce>
    2b8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b91:	8d 50 fe             	lea    -0x2(%eax),%edx
    2b94:	8b 45 08             	mov    0x8(%ebp),%eax
    2b97:	01 d0                	add    %edx,%eax
    2b99:	0f b6 00             	movzbl (%eax),%eax
    2b9c:	3c 6e                	cmp    $0x6e,%al
    2b9e:	75 19                	jne    2bb9 <type+0xce>
    2ba0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ba3:	8d 50 fd             	lea    -0x3(%eax),%edx
    2ba6:	8b 45 08             	mov    0x8(%ebp),%eax
    2ba9:	01 d0                	add    %edx,%eax
    2bab:	0f b6 00             	movzbl (%eax),%eax
    2bae:	3c 70                	cmp    $0x70,%al
    2bb0:	75 07                	jne    2bb9 <type+0xce>
    2bb2:	b8 02 00 00 00       	mov    $0x2,%eax
    2bb7:	eb 05                	jmp    2bbe <type+0xd3>
    else return NONE;
    2bb9:	b8 03 00 00 00       	mov    $0x3,%eax
}
    2bbe:	c9                   	leave  
    2bbf:	c3                   	ret    

00002bc0 <LoadBmp>:

PBitmap LoadBmp(char* filename){
    2bc0:	55                   	push   %ebp
    2bc1:	89 e5                	mov    %esp,%ebp
    2bc3:	56                   	push   %esi
    2bc4:	53                   	push   %ebx
    2bc5:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    2bc8:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    2bcf:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    2bd6:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    2bdd:	83 ec 08             	sub    $0x8,%esp
    2be0:	6a 00                	push   $0x0
    2be2:	ff 75 0c             	pushl  0xc(%ebp)
    2be5:	e8 d9 d6 ff ff       	call   2c3 <open>
    2bea:	83 c4 10             	add    $0x10,%esp
    2bed:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2bf0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2bf4:	79 2c                	jns    2c22 <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    2bf6:	83 ec 08             	sub    $0x8,%esp
    2bf9:	ff 75 0c             	pushl  0xc(%ebp)
    2bfc:	68 48 9c 01 00       	push   $0x19c48
    2c01:	e8 24 d8 ff ff       	call   42a <printf>
    2c06:	83 c4 10             	add    $0x10,%esp
        return bmp;
    2c09:	8b 45 08             	mov    0x8(%ebp),%eax
    2c0c:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2c0f:	89 10                	mov    %edx,(%eax)
    2c11:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2c14:	89 50 04             	mov    %edx,0x4(%eax)
    2c17:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2c1a:	89 50 08             	mov    %edx,0x8(%eax)
    2c1d:	e9 2d 02 00 00       	jmp    2e4f <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    2c22:	83 ec 04             	sub    $0x4,%esp
    2c25:	6a 0e                	push   $0xe
    2c27:	8d 45 aa             	lea    -0x56(%ebp),%eax
    2c2a:	50                   	push   %eax
    2c2b:	ff 75 ec             	pushl  -0x14(%ebp)
    2c2e:	e8 68 d6 ff ff       	call   29b <read>
    2c33:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    2c36:	83 ec 04             	sub    $0x4,%esp
    2c39:	6a 28                	push   $0x28
    2c3b:	8d 45 82             	lea    -0x7e(%ebp),%eax
    2c3e:	50                   	push   %eax
    2c3f:	ff 75 ec             	pushl  -0x14(%ebp)
    2c42:	e8 54 d6 ff ff       	call   29b <read>
    2c47:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2c4a:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2c4e:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2c51:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2c55:	0f b7 d8             	movzwl %ax,%ebx
    2c58:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    2c5b:	8b 55 ac             	mov    -0x54(%ebp),%edx
    2c5e:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    2c62:	0f b7 c0             	movzwl %ax,%eax
    2c65:	83 ec 04             	sub    $0x4,%esp
    2c68:	6a 36                	push   $0x36
    2c6a:	56                   	push   %esi
    2c6b:	53                   	push   %ebx
    2c6c:	51                   	push   %ecx
    2c6d:	52                   	push   %edx
    2c6e:	50                   	push   %eax
    2c6f:	68 58 9c 01 00       	push   $0x19c58
    2c74:	e8 b1 d7 ff ff       	call   42a <printf>
    2c79:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    2c7c:	8b 45 86             	mov    -0x7a(%ebp),%eax
    2c7f:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    2c82:	8b 45 8a             	mov    -0x76(%ebp),%eax
    2c85:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    2c88:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2c8b:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2c8e:	0f af c2             	imul   %edx,%eax
    2c91:	89 c2                	mov    %eax,%edx
    2c93:	89 d0                	mov    %edx,%eax
    2c95:	01 c0                	add    %eax,%eax
    2c97:	01 d0                	add    %edx,%eax
    2c99:	83 ec 0c             	sub    $0xc,%esp
    2c9c:	50                   	push   %eax
    2c9d:	e8 5b da ff ff       	call   6fd <malloc>
    2ca2:	83 c4 10             	add    $0x10,%esp
    2ca5:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    2ca8:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2cac:	0f b7 c0             	movzwl %ax,%eax
    2caf:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    2cb2:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2cb5:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    2cb9:	83 c0 1f             	add    $0x1f,%eax
    2cbc:	c1 f8 05             	sar    $0x5,%eax
    2cbf:	c1 e0 02             	shl    $0x2,%eax
    2cc2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    2cc5:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2cc8:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2ccc:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    2ccf:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2cd2:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2cd5:	83 ec 08             	sub    $0x8,%esp
    2cd8:	52                   	push   %edx
    2cd9:	50                   	push   %eax
    2cda:	ff 75 e8             	pushl  -0x18(%ebp)
    2cdd:	ff 75 e0             	pushl  -0x20(%ebp)
    2ce0:	ff 75 e4             	pushl  -0x1c(%ebp)
    2ce3:	68 80 9c 01 00       	push   $0x19c80
    2ce8:	e8 3d d7 ff ff       	call   42a <printf>
    2ced:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    2cf0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    2cf3:	83 e8 36             	sub    $0x36,%eax
    2cf6:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    2cf9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2cfc:	83 ec 0c             	sub    $0xc,%esp
    2cff:	50                   	push   %eax
    2d00:	e8 f8 d9 ff ff       	call   6fd <malloc>
    2d05:	83 c4 10             	add    $0x10,%esp
    2d08:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    2d0b:	83 ec 04             	sub    $0x4,%esp
    2d0e:	ff 75 dc             	pushl  -0x24(%ebp)
    2d11:	ff 75 d8             	pushl  -0x28(%ebp)
    2d14:	ff 75 ec             	pushl  -0x14(%ebp)
    2d17:	e8 7f d5 ff ff       	call   29b <read>
    2d1c:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    2d1f:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2d22:	83 ec 0c             	sub    $0xc,%esp
    2d25:	50                   	push   %eax
    2d26:	e8 d2 d9 ff ff       	call   6fd <malloc>
    2d2b:	83 c4 10             	add    $0x10,%esp
    2d2e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    2d31:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2d34:	83 ec 04             	sub    $0x4,%esp
    2d37:	50                   	push   %eax
    2d38:	ff 75 d4             	pushl  -0x2c(%ebp)
    2d3b:	ff 75 ec             	pushl  -0x14(%ebp)
    2d3e:	e8 58 d5 ff ff       	call   29b <read>
    2d43:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    2d46:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2d4a:	66 c1 e8 03          	shr    $0x3,%ax
    2d4e:	0f b7 c0             	movzwl %ax,%eax
    2d51:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    2d54:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2d5b:	e9 c1 00 00 00       	jmp    2e21 <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    2d60:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2d63:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2d66:	8d 50 ff             	lea    -0x1(%eax),%edx
    2d69:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2d6c:	0f af c2             	imul   %edx,%eax
    2d6f:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    2d72:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2d75:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2d79:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    2d7c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2d83:	e9 89 00 00 00       	jmp    2e11 <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    2d88:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2d8b:	83 c0 01             	add    $0x1,%eax
    2d8e:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2d92:	89 c2                	mov    %eax,%edx
    2d94:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2d97:	01 d0                	add    %edx,%eax
    2d99:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    2d9c:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2d9f:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2da2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2da5:	01 c8                	add    %ecx,%eax
    2da7:	89 c1                	mov    %eax,%ecx
    2da9:	89 c8                	mov    %ecx,%eax
    2dab:	01 c0                	add    %eax,%eax
    2dad:	01 c8                	add    %ecx,%eax
    2daf:	01 c2                	add    %eax,%edx
    2db1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2db4:	8d 48 ff             	lea    -0x1(%eax),%ecx
    2db7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2dba:	01 c8                	add    %ecx,%eax
    2dbc:	0f b6 00             	movzbl (%eax),%eax
    2dbf:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    2dc2:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2dc5:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2dc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2dcb:	01 c8                	add    %ecx,%eax
    2dcd:	89 c1                	mov    %eax,%ecx
    2dcf:	89 c8                	mov    %ecx,%eax
    2dd1:	01 c0                	add    %eax,%eax
    2dd3:	01 c8                	add    %ecx,%eax
    2dd5:	01 c2                	add    %eax,%edx
    2dd7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2dda:	8d 48 fe             	lea    -0x2(%eax),%ecx
    2ddd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2de0:	01 c8                	add    %ecx,%eax
    2de2:	0f b6 00             	movzbl (%eax),%eax
    2de5:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    2de8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2deb:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2dee:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2df1:	01 c8                	add    %ecx,%eax
    2df3:	89 c1                	mov    %eax,%ecx
    2df5:	89 c8                	mov    %ecx,%eax
    2df7:	01 c0                	add    %eax,%eax
    2df9:	01 c8                	add    %ecx,%eax
    2dfb:	01 c2                	add    %eax,%edx
    2dfd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2e00:	8d 48 fd             	lea    -0x3(%eax),%ecx
    2e03:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2e06:	01 c8                	add    %ecx,%eax
    2e08:	0f b6 00             	movzbl (%eax),%eax
    2e0b:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    2e0d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2e11:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2e14:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2e17:	0f 8f 6b ff ff ff    	jg     2d88 <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    2e1d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2e21:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2e24:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2e27:	0f 8f 33 ff ff ff    	jg     2d60 <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    2e2d:	83 ec 0c             	sub    $0xc,%esp
    2e30:	ff 75 ec             	pushl  -0x14(%ebp)
    2e33:	e8 73 d4 ff ff       	call   2ab <close>
    2e38:	83 c4 10             	add    $0x10,%esp
    return bmp;
    2e3b:	8b 45 08             	mov    0x8(%ebp),%eax
    2e3e:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2e41:	89 10                	mov    %edx,(%eax)
    2e43:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2e46:	89 50 04             	mov    %edx,0x4(%eax)
    2e49:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e4c:	89 50 08             	mov    %edx,0x8(%eax)
}
    2e4f:	8b 45 08             	mov    0x8(%ebp),%eax
    2e52:	8d 65 f8             	lea    -0x8(%ebp),%esp
    2e55:	5b                   	pop    %ebx
    2e56:	5e                   	pop    %esi
    2e57:	5d                   	pop    %ebp
    2e58:	c2 04 00             	ret    $0x4

00002e5b <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    2e5b:	55                   	push   %ebp
    2e5c:	89 e5                	mov    %esp,%ebp
    2e5e:	53                   	push   %ebx
    2e5f:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    2e62:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    2e66:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    2e6a:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    2e6e:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    2e72:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    2e76:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    2e7a:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    2e7e:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    2e82:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    2e86:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    2e8a:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    2e8e:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    2e92:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    2e96:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    2e9a:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    2e9e:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    2ea2:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    2ea6:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    2eaa:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    2eae:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    2eb2:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    2eb6:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    2eba:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    2ebe:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    2ec2:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    2ec6:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    2eca:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    2ece:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    2ed2:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    2ed6:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    2eda:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    2ede:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    2ee2:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    2ee6:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    2eea:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    2eee:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    2ef2:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    2ef6:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    2efa:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    2efe:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    2f02:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    2f06:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    2f0a:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    2f0e:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    2f12:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    2f16:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    2f1a:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    2f1e:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    2f22:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    2f26:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    2f2a:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    2f2e:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    2f32:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    2f36:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    2f3a:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    2f3e:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    2f42:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    2f46:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    2f4a:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    2f4e:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    2f52:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    2f56:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    2f5a:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    2f5e:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    2f62:	83 ec 0c             	sub    $0xc,%esp
    2f65:	68 c8 02 08 00       	push   $0x802c8
    2f6a:	e8 8e d7 ff ff       	call   6fd <malloc>
    2f6f:	83 c4 10             	add    $0x10,%esp
    2f72:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    2f75:	83 ec 04             	sub    $0x4,%esp
    2f78:	68 c8 02 08 00       	push   $0x802c8
    2f7d:	6a 00                	push   $0x0
    2f7f:	ff 75 f0             	pushl  -0x10(%ebp)
    2f82:	e8 61 d1 ff ff       	call   e8 <memset>
    2f87:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    2f8a:	83 ec 08             	sub    $0x8,%esp
    2f8d:	6a 00                	push   $0x0
    2f8f:	ff 75 0c             	pushl  0xc(%ebp)
    2f92:	e8 2c d3 ff ff       	call   2c3 <open>
    2f97:	83 c4 10             	add    $0x10,%esp
    2f9a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    2f9d:	83 ec 0c             	sub    $0xc,%esp
    2fa0:	68 40 42 0f 00       	push   $0xf4240
    2fa5:	e8 53 d7 ff ff       	call   6fd <malloc>
    2faa:	83 c4 10             	add    $0x10,%esp
    2fad:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    2fb0:	83 ec 04             	sub    $0x4,%esp
    2fb3:	68 40 42 0f 00       	push   $0xf4240
    2fb8:	ff 75 e8             	pushl  -0x18(%ebp)
    2fbb:	ff 75 ec             	pushl  -0x14(%ebp)
    2fbe:	e8 d8 d2 ff ff       	call   29b <read>
    2fc3:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    2fc6:	83 ec 0c             	sub    $0xc,%esp
    2fc9:	ff 75 ec             	pushl  -0x14(%ebp)
    2fcc:	e8 da d2 ff ff       	call   2ab <close>
    2fd1:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    2fd4:	68 40 42 0f 00       	push   $0xf4240
    2fd9:	ff 75 e8             	pushl  -0x18(%ebp)
    2fdc:	8d 45 9c             	lea    -0x64(%ebp),%eax
    2fdf:	50                   	push   %eax
    2fe0:	ff 75 f0             	pushl  -0x10(%ebp)
    2fe3:	e8 5e 0c 01 00       	call   13c46 <_DecodeJPEG>
    2fe8:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    2feb:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    2ff2:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    2ff9:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    3000:	83 ec 0c             	sub    $0xc,%esp
    3003:	ff 75 f0             	pushl  -0x10(%ebp)
    3006:	e8 29 0b 01 00       	call   13b34 <GetImageSize>
    300b:	83 c4 10             	add    $0x10,%esp
    300e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    3011:	83 ec 0c             	sub    $0xc,%esp
    3014:	ff 75 f0             	pushl  -0x10(%ebp)
    3017:	e8 e1 0a 01 00       	call   13afd <GetImage>
    301c:	83 c4 10             	add    $0x10,%esp
    301f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    3022:	83 ec 0c             	sub    $0xc,%esp
    3025:	ff 75 f0             	pushl  -0x10(%ebp)
    3028:	e8 f1 0a 01 00       	call   13b1e <GetWidth>
    302d:	83 c4 10             	add    $0x10,%esp
    3030:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    3033:	83 ec 0c             	sub    $0xc,%esp
    3036:	ff 75 f0             	pushl  -0x10(%ebp)
    3039:	e8 eb 0a 01 00       	call   13b29 <GetHeight>
    303e:	83 c4 10             	add    $0x10,%esp
    3041:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    3044:	8b 55 90             	mov    -0x70(%ebp),%edx
    3047:	8b 45 94             	mov    -0x6c(%ebp),%eax
    304a:	0f af c2             	imul   %edx,%eax
    304d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    3050:	8b 55 dc             	mov    -0x24(%ebp),%edx
    3053:	89 d0                	mov    %edx,%eax
    3055:	01 c0                	add    %eax,%eax
    3057:	01 d0                	add    %edx,%eax
    3059:	83 ec 0c             	sub    $0xc,%esp
    305c:	50                   	push   %eax
    305d:	e8 9b d6 ff ff       	call   6fd <malloc>
    3062:	83 c4 10             	add    $0x10,%esp
    3065:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    3068:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    306f:	e9 9c 00 00 00       	jmp    3110 <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    3074:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3077:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    307a:	ba 56 55 55 55       	mov    $0x55555556,%edx
    307f:	89 c8                	mov    %ecx,%eax
    3081:	f7 ea                	imul   %edx
    3083:	89 c8                	mov    %ecx,%eax
    3085:	c1 f8 1f             	sar    $0x1f,%eax
    3088:	29 c2                	sub    %eax,%edx
    308a:	89 d0                	mov    %edx,%eax
    308c:	89 c2                	mov    %eax,%edx
    308e:	89 d0                	mov    %edx,%eax
    3090:	01 c0                	add    %eax,%eax
    3092:	01 d0                	add    %edx,%eax
    3094:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3097:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    309a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    309d:	01 c8                	add    %ecx,%eax
    309f:	0f b6 00             	movzbl (%eax),%eax
    30a2:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    30a5:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    30a8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    30ab:	ba 56 55 55 55       	mov    $0x55555556,%edx
    30b0:	89 c8                	mov    %ecx,%eax
    30b2:	f7 ea                	imul   %edx
    30b4:	89 c8                	mov    %ecx,%eax
    30b6:	c1 f8 1f             	sar    $0x1f,%eax
    30b9:	29 c2                	sub    %eax,%edx
    30bb:	89 d0                	mov    %edx,%eax
    30bd:	89 c2                	mov    %eax,%edx
    30bf:	89 d0                	mov    %edx,%eax
    30c1:	01 c0                	add    %eax,%eax
    30c3:	01 d0                	add    %edx,%eax
    30c5:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    30c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    30cb:	8d 48 01             	lea    0x1(%eax),%ecx
    30ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
    30d1:	01 c8                	add    %ecx,%eax
    30d3:	0f b6 00             	movzbl (%eax),%eax
    30d6:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    30d9:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    30dc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    30df:	ba 56 55 55 55       	mov    $0x55555556,%edx
    30e4:	89 c8                	mov    %ecx,%eax
    30e6:	f7 ea                	imul   %edx
    30e8:	89 c8                	mov    %ecx,%eax
    30ea:	c1 f8 1f             	sar    $0x1f,%eax
    30ed:	29 c2                	sub    %eax,%edx
    30ef:	89 d0                	mov    %edx,%eax
    30f1:	89 c2                	mov    %eax,%edx
    30f3:	89 d0                	mov    %edx,%eax
    30f5:	01 c0                	add    %eax,%eax
    30f7:	01 d0                	add    %edx,%eax
    30f9:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    30fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    30ff:	8d 48 02             	lea    0x2(%eax),%ecx
    3102:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3105:	01 c8                	add    %ecx,%eax
    3107:	0f b6 00             	movzbl (%eax),%eax
    310a:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    310c:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    3110:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3113:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    3116:	0f 8c 58 ff ff ff    	jl     3074 <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    311c:	8b 45 08             	mov    0x8(%ebp),%eax
    311f:	8b 55 90             	mov    -0x70(%ebp),%edx
    3122:	89 10                	mov    %edx,(%eax)
    3124:	8b 55 94             	mov    -0x6c(%ebp),%edx
    3127:	89 50 04             	mov    %edx,0x4(%eax)
    312a:	8b 55 98             	mov    -0x68(%ebp),%edx
    312d:	89 50 08             	mov    %edx,0x8(%eax)
}
    3130:	8b 45 08             	mov    0x8(%ebp),%eax
    3133:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3136:	c9                   	leave  
    3137:	c2 04 00             	ret    $0x4

0000313a <LoadPng>:

PBitmap LoadPng(char* filename){
    313a:	55                   	push   %ebp
    313b:	89 e5                	mov    %esp,%ebp
    313d:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    3140:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    3147:	ff 75 0c             	pushl  0xc(%ebp)
    314a:	8d 45 e0             	lea    -0x20(%ebp),%eax
    314d:	50                   	push   %eax
    314e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    3151:	50                   	push   %eax
    3152:	8d 45 e8             	lea    -0x18(%ebp),%eax
    3155:	50                   	push   %eax
    3156:	e8 d3 d3 00 00       	call   1052e <lodepng_decode24_file>
    315b:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    315e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3161:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    3164:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3167:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    316a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    3171:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    3174:	8b 45 d8             	mov    -0x28(%ebp),%eax
    3177:	0f af c2             	imul   %edx,%eax
    317a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    317d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3180:	89 d0                	mov    %edx,%eax
    3182:	01 c0                	add    %eax,%eax
    3184:	01 d0                	add    %edx,%eax
    3186:	83 ec 0c             	sub    $0xc,%esp
    3189:	50                   	push   %eax
    318a:	e8 6e d5 ff ff       	call   6fd <malloc>
    318f:	83 c4 10             	add    $0x10,%esp
    3192:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    3195:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    319c:	e9 87 00 00 00       	jmp    3228 <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    31a1:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    31a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    31a7:	89 d0                	mov    %edx,%eax
    31a9:	01 c0                	add    %eax,%eax
    31ab:	01 d0                	add    %edx,%eax
    31ad:	01 c8                	add    %ecx,%eax
    31af:	0f b6 00             	movzbl (%eax),%eax
    31b2:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    31b5:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    31b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    31bb:	89 d0                	mov    %edx,%eax
    31bd:	01 c0                	add    %eax,%eax
    31bf:	01 d0                	add    %edx,%eax
    31c1:	83 c0 01             	add    $0x1,%eax
    31c4:	01 c8                	add    %ecx,%eax
    31c6:	0f b6 00             	movzbl (%eax),%eax
    31c9:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    31cc:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    31cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    31d2:	89 d0                	mov    %edx,%eax
    31d4:	01 c0                	add    %eax,%eax
    31d6:	01 d0                	add    %edx,%eax
    31d8:	83 c0 02             	add    $0x2,%eax
    31db:	01 c8                	add    %ecx,%eax
    31dd:	0f b6 00             	movzbl (%eax),%eax
    31e0:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    31e3:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    31e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    31e9:	89 d0                	mov    %edx,%eax
    31eb:	01 c0                	add    %eax,%eax
    31ed:	01 d0                	add    %edx,%eax
    31ef:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    31f2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    31f6:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    31f9:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    31fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    31ff:	89 d0                	mov    %edx,%eax
    3201:	01 c0                	add    %eax,%eax
    3203:	01 d0                	add    %edx,%eax
    3205:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3208:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    320c:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    320f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3212:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3215:	89 d0                	mov    %edx,%eax
    3217:	01 c0                	add    %eax,%eax
    3219:	01 d0                	add    %edx,%eax
    321b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    321e:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    3222:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    3224:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3228:	8b 45 f4             	mov    -0xc(%ebp),%eax
    322b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    322e:	0f 8c 6d ff ff ff    	jl     31a1 <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    3234:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3237:	83 ec 0c             	sub    $0xc,%esp
    323a:	50                   	push   %eax
    323b:	e8 7b d3 ff ff       	call   5bb <free>
    3240:	83 c4 10             	add    $0x10,%esp
    return bmp;
    3243:	8b 45 08             	mov    0x8(%ebp),%eax
    3246:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    3249:	89 10                	mov    %edx,(%eax)
    324b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    324e:	89 50 04             	mov    %edx,0x4(%eax)
    3251:	8b 55 dc             	mov    -0x24(%ebp),%edx
    3254:	89 50 08             	mov    %edx,0x8(%eax)

}
    3257:	8b 45 08             	mov    0x8(%ebp),%eax
    325a:	c9                   	leave  
    325b:	c2 04 00             	ret    $0x4

0000325e <LoadImg>:

PBitmap LoadImg(char* filename){
    325e:	55                   	push   %ebp
    325f:	89 e5                	mov    %esp,%ebp
    3261:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    3264:	83 ec 0c             	sub    $0xc,%esp
    3267:	ff 75 0c             	pushl  0xc(%ebp)
    326a:	e8 7c f8 ff ff       	call   2aeb <type>
    326f:	83 c4 10             	add    $0x10,%esp
    3272:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    3275:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3278:	83 f8 01             	cmp    $0x1,%eax
    327b:	74 1d                	je     329a <LoadImg+0x3c>
    327d:	83 f8 02             	cmp    $0x2,%eax
    3280:	74 2c                	je     32ae <LoadImg+0x50>
    3282:	85 c0                	test   %eax,%eax
    3284:	75 3c                	jne    32c2 <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    3286:	8b 45 08             	mov    0x8(%ebp),%eax
    3289:	83 ec 08             	sub    $0x8,%esp
    328c:	ff 75 0c             	pushl  0xc(%ebp)
    328f:	50                   	push   %eax
    3290:	e8 c6 fb ff ff       	call   2e5b <LoadJpeg>
    3295:	83 c4 0c             	add    $0xc,%esp
    3298:	eb 3c                	jmp    32d6 <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    329a:	8b 45 08             	mov    0x8(%ebp),%eax
    329d:	83 ec 08             	sub    $0x8,%esp
    32a0:	ff 75 0c             	pushl  0xc(%ebp)
    32a3:	50                   	push   %eax
    32a4:	e8 17 f9 ff ff       	call   2bc0 <LoadBmp>
    32a9:	83 c4 0c             	add    $0xc,%esp
    32ac:	eb 28                	jmp    32d6 <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    32ae:	8b 45 08             	mov    0x8(%ebp),%eax
    32b1:	83 ec 08             	sub    $0x8,%esp
    32b4:	ff 75 0c             	pushl  0xc(%ebp)
    32b7:	50                   	push   %eax
    32b8:	e8 7d fe ff ff       	call   313a <LoadPng>
    32bd:	83 c4 0c             	add    $0xc,%esp
    32c0:	eb 14                	jmp    32d6 <LoadImg+0x78>

        default: return bmp;
    32c2:	8b 45 08             	mov    0x8(%ebp),%eax
    32c5:	8b 55 e8             	mov    -0x18(%ebp),%edx
    32c8:	89 10                	mov    %edx,(%eax)
    32ca:	8b 55 ec             	mov    -0x14(%ebp),%edx
    32cd:	89 50 04             	mov    %edx,0x4(%eax)
    32d0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    32d3:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    32d6:	8b 45 08             	mov    0x8(%ebp),%eax
    32d9:	c9                   	leave  
    32da:	c2 04 00             	ret    $0x4

000032dd <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    32dd:	55                   	push   %ebp
    32de:	89 e5                	mov    %esp,%ebp
    32e0:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    32e3:	8b 45 08             	mov    0x8(%ebp),%eax
    32e6:	83 ec 0c             	sub    $0xc,%esp
    32e9:	50                   	push   %eax
    32ea:	e8 0e d4 ff ff       	call   6fd <malloc>
    32ef:	83 c4 10             	add    $0x10,%esp
}
    32f2:	c9                   	leave  
    32f3:	c3                   	ret    

000032f4 <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    32f4:	55                   	push   %ebp
    32f5:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    32f7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    32fc:	5d                   	pop    %ebp
    32fd:	c3                   	ret    

000032fe <lodepng_free>:

static void lodepng_free(void* ptr) {
    32fe:	55                   	push   %ebp
    32ff:	89 e5                	mov    %esp,%ebp
    3301:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    3304:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    3308:	74 0e                	je     3318 <lodepng_free+0x1a>
    free(ptr);
    330a:	83 ec 0c             	sub    $0xc,%esp
    330d:	ff 75 08             	pushl  0x8(%ebp)
    3310:	e8 a6 d2 ff ff       	call   5bb <free>
    3315:	83 c4 10             	add    $0x10,%esp
}
    3318:	90                   	nop
    3319:	c9                   	leave  
    331a:	c3                   	ret    

0000331b <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    331b:	55                   	push   %ebp
    331c:	89 e5                	mov    %esp,%ebp
    331e:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    3321:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3328:	eb 19                	jmp    3343 <lodepng_memcpy+0x28>
    332a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    332d:	8b 45 08             	mov    0x8(%ebp),%eax
    3330:	01 c2                	add    %eax,%edx
    3332:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3335:	8b 45 0c             	mov    0xc(%ebp),%eax
    3338:	01 c8                	add    %ecx,%eax
    333a:	0f b6 00             	movzbl (%eax),%eax
    333d:	88 02                	mov    %al,(%edx)
    333f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3343:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3346:	3b 45 10             	cmp    0x10(%ebp),%eax
    3349:	7c df                	jl     332a <lodepng_memcpy+0xf>
}
    334b:	90                   	nop
    334c:	c9                   	leave  
    334d:	c3                   	ret    

0000334e <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    334e:	55                   	push   %ebp
    334f:	89 e5                	mov    %esp,%ebp
    3351:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    3354:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    335b:	eb 11                	jmp    336e <lodepng_memset+0x20>
    335d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3360:	8b 45 08             	mov    0x8(%ebp),%eax
    3363:	01 d0                	add    %edx,%eax
    3365:	8b 55 0c             	mov    0xc(%ebp),%edx
    3368:	88 10                	mov    %dl,(%eax)
    336a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    336e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3371:	3b 45 10             	cmp    0x10(%ebp),%eax
    3374:	7c e7                	jl     335d <lodepng_memset+0xf>
}
    3376:	90                   	nop
    3377:	c9                   	leave  
    3378:	c3                   	ret    

00003379 <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    3379:	55                   	push   %ebp
    337a:	89 e5                	mov    %esp,%ebp
    337c:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    337f:	8b 45 08             	mov    0x8(%ebp),%eax
    3382:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    3385:	eb 04                	jmp    338b <lodepng_strlen+0x12>
    3387:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    338b:	8b 45 08             	mov    0x8(%ebp),%eax
    338e:	0f b6 00             	movzbl (%eax),%eax
    3391:	84 c0                	test   %al,%al
    3393:	75 f2                	jne    3387 <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    3395:	8b 55 08             	mov    0x8(%ebp),%edx
    3398:	8b 45 fc             	mov    -0x4(%ebp),%eax
    339b:	29 c2                	sub    %eax,%edx
    339d:	89 d0                	mov    %edx,%eax
}
    339f:	c9                   	leave  
    33a0:	c3                   	ret    

000033a1 <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    33a1:	55                   	push   %ebp
    33a2:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    33a4:	8b 55 08             	mov    0x8(%ebp),%edx
    33a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    33aa:	01 c2                	add    %eax,%edx
    33ac:	8b 45 10             	mov    0x10(%ebp),%eax
    33af:	89 10                	mov    %edx,(%eax)
  return *result < a;
    33b1:	8b 45 10             	mov    0x10(%ebp),%eax
    33b4:	8b 00                	mov    (%eax),%eax
    33b6:	3b 45 08             	cmp    0x8(%ebp),%eax
    33b9:	0f 9c c0             	setl   %al
    33bc:	0f b6 c0             	movzbl %al,%eax
}
    33bf:	5d                   	pop    %ebp
    33c0:	c3                   	ret    

000033c1 <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    33c1:	55                   	push   %ebp
    33c2:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    33c4:	8b 45 08             	mov    0x8(%ebp),%eax
    33c7:	0f af 45 0c          	imul   0xc(%ebp),%eax
    33cb:	89 c2                	mov    %eax,%edx
    33cd:	8b 45 10             	mov    0x10(%ebp),%eax
    33d0:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    33d2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    33d6:	74 15                	je     33ed <lodepng_mulofl+0x2c>
    33d8:	8b 45 10             	mov    0x10(%ebp),%eax
    33db:	8b 00                	mov    (%eax),%eax
    33dd:	99                   	cltd   
    33de:	f7 7d 08             	idivl  0x8(%ebp)
    33e1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    33e4:	74 07                	je     33ed <lodepng_mulofl+0x2c>
    33e6:	b8 01 00 00 00       	mov    $0x1,%eax
    33eb:	eb 05                	jmp    33f2 <lodepng_mulofl+0x31>
    33ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
    33f2:	5d                   	pop    %ebp
    33f3:	c3                   	ret    

000033f4 <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    33f4:	55                   	push   %ebp
    33f5:	89 e5                	mov    %esp,%ebp
    33f7:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    33fa:	8d 45 fc             	lea    -0x4(%ebp),%eax
    33fd:	50                   	push   %eax
    33fe:	ff 75 0c             	pushl  0xc(%ebp)
    3401:	ff 75 08             	pushl  0x8(%ebp)
    3404:	e8 98 ff ff ff       	call   33a1 <lodepng_addofl>
    3409:	83 c4 0c             	add    $0xc,%esp
    340c:	85 c0                	test   %eax,%eax
    340e:	74 07                	je     3417 <lodepng_gtofl+0x23>
    3410:	b8 01 00 00 00       	mov    $0x1,%eax
    3415:	eb 0c                	jmp    3423 <lodepng_gtofl+0x2f>
  return d > c;
    3417:	8b 45 fc             	mov    -0x4(%ebp),%eax
    341a:	3b 45 10             	cmp    0x10(%ebp),%eax
    341d:	0f 9f c0             	setg   %al
    3420:	0f b6 c0             	movzbl %al,%eax
}
    3423:	c9                   	leave  
    3424:	c3                   	ret    

00003425 <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    3425:	55                   	push   %ebp
    3426:	89 e5                	mov    %esp,%ebp
    3428:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    342b:	8b 45 08             	mov    0x8(%ebp),%eax
    342e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    3435:	8b 45 08             	mov    0x8(%ebp),%eax
    3438:	8b 50 08             	mov    0x8(%eax),%edx
    343b:	8b 45 08             	mov    0x8(%ebp),%eax
    343e:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    3441:	8b 45 08             	mov    0x8(%ebp),%eax
    3444:	8b 00                	mov    (%eax),%eax
    3446:	83 ec 0c             	sub    $0xc,%esp
    3449:	50                   	push   %eax
    344a:	e8 af fe ff ff       	call   32fe <lodepng_free>
    344f:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    3452:	8b 45 08             	mov    0x8(%ebp),%eax
    3455:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    345b:	90                   	nop
    345c:	c9                   	leave  
    345d:	c3                   	ret    

0000345e <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    345e:	55                   	push   %ebp
    345f:	89 e5                	mov    %esp,%ebp
    3461:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    3464:	8b 45 0c             	mov    0xc(%ebp),%eax
    3467:	c1 e0 02             	shl    $0x2,%eax
    346a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    346d:	8b 45 08             	mov    0x8(%ebp),%eax
    3470:	8b 40 08             	mov    0x8(%eax),%eax
    3473:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    3476:	7d 46                	jge    34be <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    3478:	8b 45 08             	mov    0x8(%ebp),%eax
    347b:	8b 40 08             	mov    0x8(%eax),%eax
    347e:	d1 f8                	sar    %eax
    3480:	89 c2                	mov    %eax,%edx
    3482:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3485:	01 d0                	add    %edx,%eax
    3487:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    348a:	8b 45 08             	mov    0x8(%ebp),%eax
    348d:	8b 00                	mov    (%eax),%eax
    348f:	ff 75 f8             	pushl  -0x8(%ebp)
    3492:	50                   	push   %eax
    3493:	e8 5c fe ff ff       	call   32f4 <lodepng_realloc>
    3498:	83 c4 08             	add    $0x8,%esp
    349b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    349e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    34a2:	74 13                	je     34b7 <uivector_resize+0x59>
      p->allocsize = newsize;
    34a4:	8b 45 08             	mov    0x8(%ebp),%eax
    34a7:	8b 55 f8             	mov    -0x8(%ebp),%edx
    34aa:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    34ad:	8b 45 08             	mov    0x8(%ebp),%eax
    34b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    34b3:	89 10                	mov    %edx,(%eax)
    34b5:	eb 07                	jmp    34be <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    34b7:	b8 00 00 00 00       	mov    $0x0,%eax
    34bc:	eb 0e                	jmp    34cc <uivector_resize+0x6e>
  }
  p->size = size;
    34be:	8b 45 08             	mov    0x8(%ebp),%eax
    34c1:	8b 55 0c             	mov    0xc(%ebp),%edx
    34c4:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    34c7:	b8 01 00 00 00       	mov    $0x1,%eax
}
    34cc:	c9                   	leave  
    34cd:	c3                   	ret    

000034ce <uivector_init>:

static void uivector_init(uivector* p) {
    34ce:	55                   	push   %ebp
    34cf:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    34d1:	8b 45 08             	mov    0x8(%ebp),%eax
    34d4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    34da:	8b 45 08             	mov    0x8(%ebp),%eax
    34dd:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    34e4:	8b 45 08             	mov    0x8(%ebp),%eax
    34e7:	8b 50 08             	mov    0x8(%eax),%edx
    34ea:	8b 45 08             	mov    0x8(%ebp),%eax
    34ed:	89 50 04             	mov    %edx,0x4(%eax)
}
    34f0:	90                   	nop
    34f1:	5d                   	pop    %ebp
    34f2:	c3                   	ret    

000034f3 <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    34f3:	55                   	push   %ebp
    34f4:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    34f6:	8b 45 08             	mov    0x8(%ebp),%eax
    34f9:	8b 40 04             	mov    0x4(%eax),%eax
    34fc:	83 c0 01             	add    $0x1,%eax
    34ff:	50                   	push   %eax
    3500:	ff 75 08             	pushl  0x8(%ebp)
    3503:	e8 56 ff ff ff       	call   345e <uivector_resize>
    3508:	83 c4 08             	add    $0x8,%esp
    350b:	85 c0                	test   %eax,%eax
    350d:	75 07                	jne    3516 <uivector_push_back+0x23>
    350f:	b8 00 00 00 00       	mov    $0x0,%eax
    3514:	eb 1f                	jmp    3535 <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    3516:	8b 45 08             	mov    0x8(%ebp),%eax
    3519:	8b 10                	mov    (%eax),%edx
    351b:	8b 45 08             	mov    0x8(%ebp),%eax
    351e:	8b 40 04             	mov    0x4(%eax),%eax
    3521:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    3526:	c1 e0 02             	shl    $0x2,%eax
    3529:	01 c2                	add    %eax,%edx
    352b:	8b 45 0c             	mov    0xc(%ebp),%eax
    352e:	89 02                	mov    %eax,(%edx)
  return 1;
    3530:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3535:	c9                   	leave  
    3536:	c3                   	ret    

00003537 <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    3537:	55                   	push   %ebp
    3538:	89 e5                	mov    %esp,%ebp
    353a:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    353d:	8b 45 08             	mov    0x8(%ebp),%eax
    3540:	8b 40 08             	mov    0x8(%eax),%eax
    3543:	3b 45 0c             	cmp    0xc(%ebp),%eax
    3546:	7d 46                	jge    358e <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    3548:	8b 45 08             	mov    0x8(%ebp),%eax
    354b:	8b 40 08             	mov    0x8(%eax),%eax
    354e:	d1 f8                	sar    %eax
    3550:	89 c2                	mov    %eax,%edx
    3552:	8b 45 0c             	mov    0xc(%ebp),%eax
    3555:	01 d0                	add    %edx,%eax
    3557:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    355a:	8b 45 08             	mov    0x8(%ebp),%eax
    355d:	8b 00                	mov    (%eax),%eax
    355f:	ff 75 fc             	pushl  -0x4(%ebp)
    3562:	50                   	push   %eax
    3563:	e8 8c fd ff ff       	call   32f4 <lodepng_realloc>
    3568:	83 c4 08             	add    $0x8,%esp
    356b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    356e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    3572:	74 13                	je     3587 <ucvector_resize+0x50>
      p->allocsize = newsize;
    3574:	8b 45 08             	mov    0x8(%ebp),%eax
    3577:	8b 55 fc             	mov    -0x4(%ebp),%edx
    357a:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    357d:	8b 45 08             	mov    0x8(%ebp),%eax
    3580:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3583:	89 10                	mov    %edx,(%eax)
    3585:	eb 07                	jmp    358e <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    3587:	b8 00 00 00 00       	mov    $0x0,%eax
    358c:	eb 0e                	jmp    359c <ucvector_resize+0x65>
  }
  p->size = size;
    358e:	8b 45 08             	mov    0x8(%ebp),%eax
    3591:	8b 55 0c             	mov    0xc(%ebp),%edx
    3594:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    3597:	b8 01 00 00 00       	mov    $0x1,%eax
}
    359c:	c9                   	leave  
    359d:	c3                   	ret    

0000359e <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    359e:	55                   	push   %ebp
    359f:	89 e5                	mov    %esp,%ebp
    35a1:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    35a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    35a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    35aa:	8b 45 10             	mov    0x10(%ebp),%eax
    35ad:	89 45 f8             	mov    %eax,-0x8(%ebp)
    35b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    35b3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    35b6:	8b 45 08             	mov    0x8(%ebp),%eax
    35b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    35bc:	89 10                	mov    %edx,(%eax)
    35be:	8b 55 f8             	mov    -0x8(%ebp),%edx
    35c1:	89 50 04             	mov    %edx,0x4(%eax)
    35c4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    35c7:	89 50 08             	mov    %edx,0x8(%eax)
}
    35ca:	8b 45 08             	mov    0x8(%ebp),%eax
    35cd:	c9                   	leave  
    35ce:	c2 04 00             	ret    $0x4

000035d1 <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    35d1:	55                   	push   %ebp
    35d2:	89 e5                	mov    %esp,%ebp
    35d4:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    35d7:	8b 45 08             	mov    0x8(%ebp),%eax
    35da:	8b 00                	mov    (%eax),%eax
    35dc:	83 ec 0c             	sub    $0xc,%esp
    35df:	50                   	push   %eax
    35e0:	e8 19 fd ff ff       	call   32fe <lodepng_free>
    35e5:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    35e8:	8b 45 08             	mov    0x8(%ebp),%eax
    35eb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    35f1:	90                   	nop
    35f2:	c9                   	leave  
    35f3:	c3                   	ret    

000035f4 <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    35f4:	55                   	push   %ebp
    35f5:	89 e5                	mov    %esp,%ebp
    35f7:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    35fa:	8b 45 0c             	mov    0xc(%ebp),%eax
    35fd:	83 c0 01             	add    $0x1,%eax
    3600:	83 ec 0c             	sub    $0xc,%esp
    3603:	50                   	push   %eax
    3604:	e8 d4 fc ff ff       	call   32dd <lodepng_malloc>
    3609:	83 c4 10             	add    $0x10,%esp
    360c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    360f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3613:	74 1f                	je     3634 <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    3615:	83 ec 04             	sub    $0x4,%esp
    3618:	ff 75 0c             	pushl  0xc(%ebp)
    361b:	ff 75 08             	pushl  0x8(%ebp)
    361e:	ff 75 f4             	pushl  -0xc(%ebp)
    3621:	e8 f5 fc ff ff       	call   331b <lodepng_memcpy>
    3626:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    3629:	8b 55 0c             	mov    0xc(%ebp),%edx
    362c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    362f:	01 d0                	add    %edx,%eax
    3631:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    3634:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3637:	c9                   	leave  
    3638:	c3                   	ret    

00003639 <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    3639:	55                   	push   %ebp
    363a:	89 e5                	mov    %esp,%ebp
    363c:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    363f:	ff 75 08             	pushl  0x8(%ebp)
    3642:	e8 32 fd ff ff       	call   3379 <lodepng_strlen>
    3647:	83 c4 04             	add    $0x4,%esp
    364a:	83 ec 08             	sub    $0x8,%esp
    364d:	50                   	push   %eax
    364e:	ff 75 08             	pushl  0x8(%ebp)
    3651:	e8 9e ff ff ff       	call   35f4 <alloc_string_sized>
    3656:	83 c4 10             	add    $0x10,%esp
}
    3659:	c9                   	leave  
    365a:	c3                   	ret    

0000365b <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    365b:	55                   	push   %ebp
    365c:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    365e:	8b 45 08             	mov    0x8(%ebp),%eax
    3661:	0f b6 00             	movzbl (%eax),%eax
    3664:	0f b6 c0             	movzbl %al,%eax
    3667:	c1 e0 18             	shl    $0x18,%eax
    366a:	89 c2                	mov    %eax,%edx
    366c:	8b 45 08             	mov    0x8(%ebp),%eax
    366f:	83 c0 01             	add    $0x1,%eax
    3672:	0f b6 00             	movzbl (%eax),%eax
    3675:	0f b6 c0             	movzbl %al,%eax
    3678:	c1 e0 10             	shl    $0x10,%eax
    367b:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    367d:	8b 45 08             	mov    0x8(%ebp),%eax
    3680:	83 c0 02             	add    $0x2,%eax
    3683:	0f b6 00             	movzbl (%eax),%eax
    3686:	0f b6 c0             	movzbl %al,%eax
    3689:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    368c:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    368e:	8b 45 08             	mov    0x8(%ebp),%eax
    3691:	83 c0 03             	add    $0x3,%eax
    3694:	0f b6 00             	movzbl (%eax),%eax
    3697:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    369a:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    369c:	5d                   	pop    %ebp
    369d:	c3                   	ret    

0000369e <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    369e:	55                   	push   %ebp
    369f:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    36a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    36a4:	c1 e8 18             	shr    $0x18,%eax
    36a7:	89 c2                	mov    %eax,%edx
    36a9:	8b 45 08             	mov    0x8(%ebp),%eax
    36ac:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    36ae:	8b 45 08             	mov    0x8(%ebp),%eax
    36b1:	83 c0 01             	add    $0x1,%eax
    36b4:	8b 55 0c             	mov    0xc(%ebp),%edx
    36b7:	c1 ea 10             	shr    $0x10,%edx
    36ba:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    36bc:	8b 45 08             	mov    0x8(%ebp),%eax
    36bf:	83 c0 02             	add    $0x2,%eax
    36c2:	8b 55 0c             	mov    0xc(%ebp),%edx
    36c5:	c1 ea 08             	shr    $0x8,%edx
    36c8:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    36ca:	8b 45 08             	mov    0x8(%ebp),%eax
    36cd:	83 c0 03             	add    $0x3,%eax
    36d0:	8b 55 0c             	mov    0xc(%ebp),%edx
    36d3:	88 10                	mov    %dl,(%eax)
}
    36d5:	90                   	nop
    36d6:	5d                   	pop    %ebp
    36d7:	c3                   	ret    

000036d8 <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    36d8:	55                   	push   %ebp
    36d9:	89 e5                	mov    %esp,%ebp
    36db:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    36de:	83 ec 08             	sub    $0x8,%esp
    36e1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    36e4:	50                   	push   %eax
    36e5:	ff 75 08             	pushl  0x8(%ebp)
    36e8:	e8 b7 ca ff ff       	call   1a4 <stat>
    36ed:	83 c4 10             	add    $0x10,%esp
  return s.size;
    36f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    36f3:	c9                   	leave  
    36f4:	c3                   	ret    

000036f5 <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    36f5:	55                   	push   %ebp
    36f6:	89 e5                	mov    %esp,%ebp
    36f8:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    36fb:	83 ec 08             	sub    $0x8,%esp
    36fe:	6a 00                	push   $0x0
    3700:	ff 75 10             	pushl  0x10(%ebp)
    3703:	e8 bb cb ff ff       	call   2c3 <open>
    3708:	83 c4 10             	add    $0x10,%esp
    370b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    370e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3712:	79 07                	jns    371b <lodepng_buffer_file+0x26>
  {
      return -1;
    3714:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    3719:	eb 19                	jmp    3734 <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    371b:	83 ec 04             	sub    $0x4,%esp
    371e:	ff 75 0c             	pushl  0xc(%ebp)
    3721:	ff 75 08             	pushl  0x8(%ebp)
    3724:	ff 75 f4             	pushl  -0xc(%ebp)
    3727:	e8 6f cb ff ff       	call   29b <read>
    372c:	83 c4 10             	add    $0x10,%esp
  return 0;
    372f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3734:	c9                   	leave  
    3735:	c3                   	ret    

00003736 <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    3736:	55                   	push   %ebp
    3737:	89 e5                	mov    %esp,%ebp
    3739:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    373c:	83 ec 0c             	sub    $0xc,%esp
    373f:	ff 75 10             	pushl  0x10(%ebp)
    3742:	e8 91 ff ff ff       	call   36d8 <lodepng_filesize>
    3747:	83 c4 10             	add    $0x10,%esp
    374a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    374d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3751:	79 07                	jns    375a <lodepng_load_file+0x24>
    3753:	b8 4e 00 00 00       	mov    $0x4e,%eax
    3758:	eb 4a                	jmp    37a4 <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    375a:	8b 45 0c             	mov    0xc(%ebp),%eax
    375d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3760:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    3762:	83 ec 0c             	sub    $0xc,%esp
    3765:	ff 75 f4             	pushl  -0xc(%ebp)
    3768:	e8 70 fb ff ff       	call   32dd <lodepng_malloc>
    376d:	83 c4 10             	add    $0x10,%esp
    3770:	89 c2                	mov    %eax,%edx
    3772:	8b 45 08             	mov    0x8(%ebp),%eax
    3775:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    3777:	8b 45 08             	mov    0x8(%ebp),%eax
    377a:	8b 00                	mov    (%eax),%eax
    377c:	85 c0                	test   %eax,%eax
    377e:	75 0d                	jne    378d <lodepng_load_file+0x57>
    3780:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3784:	7e 07                	jle    378d <lodepng_load_file+0x57>
    3786:	b8 53 00 00 00       	mov    $0x53,%eax
    378b:	eb 17                	jmp    37a4 <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    378d:	8b 45 08             	mov    0x8(%ebp),%eax
    3790:	8b 00                	mov    (%eax),%eax
    3792:	83 ec 04             	sub    $0x4,%esp
    3795:	ff 75 10             	pushl  0x10(%ebp)
    3798:	ff 75 f4             	pushl  -0xc(%ebp)
    379b:	50                   	push   %eax
    379c:	e8 54 ff ff ff       	call   36f5 <lodepng_buffer_file>
    37a1:	83 c4 10             	add    $0x10,%esp
}
    37a4:	c9                   	leave  
    37a5:	c3                   	ret    

000037a6 <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    37a6:	55                   	push   %ebp
    37a7:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    37a9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    37ae:	5d                   	pop    %ebp
    37af:	c3                   	ret    

000037b0 <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    37b0:	55                   	push   %ebp
    37b1:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    37b3:	8b 45 08             	mov    0x8(%ebp),%eax
    37b6:	8b 55 0c             	mov    0xc(%ebp),%edx
    37b9:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    37bb:	8b 45 08             	mov    0x8(%ebp),%eax
    37be:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    37c2:	90                   	nop
    37c3:	5d                   	pop    %ebp
    37c4:	c3                   	ret    

000037c5 <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    37c5:	55                   	push   %ebp
    37c6:	89 e5                	mov    %esp,%ebp
    37c8:	56                   	push   %esi
    37c9:	53                   	push   %ebx
    37ca:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    37cd:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    37d1:	0f 85 aa 00 00 00    	jne    3881 <writeBits+0xbc>
    WRITEBIT(writer, value);
    37d7:	8b 45 08             	mov    0x8(%ebp),%eax
    37da:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    37de:	0f b6 c0             	movzbl %al,%eax
    37e1:	83 e0 07             	and    $0x7,%eax
    37e4:	85 c0                	test   %eax,%eax
    37e6:	75 39                	jne    3821 <writeBits+0x5c>
    37e8:	8b 45 08             	mov    0x8(%ebp),%eax
    37eb:	8b 00                	mov    (%eax),%eax
    37ed:	8b 40 04             	mov    0x4(%eax),%eax
    37f0:	8d 50 01             	lea    0x1(%eax),%edx
    37f3:	8b 45 08             	mov    0x8(%ebp),%eax
    37f6:	8b 00                	mov    (%eax),%eax
    37f8:	52                   	push   %edx
    37f9:	50                   	push   %eax
    37fa:	e8 38 fd ff ff       	call   3537 <ucvector_resize>
    37ff:	83 c4 08             	add    $0x8,%esp
    3802:	85 c0                	test   %eax,%eax
    3804:	0f 84 44 01 00 00    	je     394e <writeBits+0x189>
    380a:	8b 45 08             	mov    0x8(%ebp),%eax
    380d:	8b 00                	mov    (%eax),%eax
    380f:	8b 10                	mov    (%eax),%edx
    3811:	8b 45 08             	mov    0x8(%ebp),%eax
    3814:	8b 00                	mov    (%eax),%eax
    3816:	8b 40 04             	mov    0x4(%eax),%eax
    3819:	83 e8 01             	sub    $0x1,%eax
    381c:	01 d0                	add    %edx,%eax
    381e:	c6 00 00             	movb   $0x0,(%eax)
    3821:	8b 45 08             	mov    0x8(%ebp),%eax
    3824:	8b 00                	mov    (%eax),%eax
    3826:	8b 10                	mov    (%eax),%edx
    3828:	8b 45 08             	mov    0x8(%ebp),%eax
    382b:	8b 00                	mov    (%eax),%eax
    382d:	8b 40 04             	mov    0x4(%eax),%eax
    3830:	83 e8 01             	sub    $0x1,%eax
    3833:	01 c2                	add    %eax,%edx
    3835:	8b 45 08             	mov    0x8(%ebp),%eax
    3838:	8b 00                	mov    (%eax),%eax
    383a:	8b 08                	mov    (%eax),%ecx
    383c:	8b 45 08             	mov    0x8(%ebp),%eax
    383f:	8b 00                	mov    (%eax),%eax
    3841:	8b 40 04             	mov    0x4(%eax),%eax
    3844:	83 e8 01             	sub    $0x1,%eax
    3847:	01 c8                	add    %ecx,%eax
    3849:	0f b6 00             	movzbl (%eax),%eax
    384c:	88 45 e7             	mov    %al,-0x19(%ebp)
    384f:	8b 45 08             	mov    0x8(%ebp),%eax
    3852:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3856:	0f b6 c0             	movzbl %al,%eax
    3859:	83 e0 07             	and    $0x7,%eax
    385c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    385f:	89 de                	mov    %ebx,%esi
    3861:	89 c1                	mov    %eax,%ecx
    3863:	d3 e6                	shl    %cl,%esi
    3865:	89 f0                	mov    %esi,%eax
    3867:	0a 45 e7             	or     -0x19(%ebp),%al
    386a:	88 02                	mov    %al,(%edx)
    386c:	8b 45 08             	mov    0x8(%ebp),%eax
    386f:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3873:	8d 50 01             	lea    0x1(%eax),%edx
    3876:	8b 45 08             	mov    0x8(%ebp),%eax
    3879:	88 50 04             	mov    %dl,0x4(%eax)
    387c:	e9 d1 00 00 00       	jmp    3952 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3881:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3888:	e9 b3 00 00 00       	jmp    3940 <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    388d:	8b 45 08             	mov    0x8(%ebp),%eax
    3890:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3894:	0f b6 c0             	movzbl %al,%eax
    3897:	83 e0 07             	and    $0x7,%eax
    389a:	85 c0                	test   %eax,%eax
    389c:	75 39                	jne    38d7 <writeBits+0x112>
    389e:	8b 45 08             	mov    0x8(%ebp),%eax
    38a1:	8b 00                	mov    (%eax),%eax
    38a3:	8b 40 04             	mov    0x4(%eax),%eax
    38a6:	8d 50 01             	lea    0x1(%eax),%edx
    38a9:	8b 45 08             	mov    0x8(%ebp),%eax
    38ac:	8b 00                	mov    (%eax),%eax
    38ae:	52                   	push   %edx
    38af:	50                   	push   %eax
    38b0:	e8 82 fc ff ff       	call   3537 <ucvector_resize>
    38b5:	83 c4 08             	add    $0x8,%esp
    38b8:	85 c0                	test   %eax,%eax
    38ba:	0f 84 91 00 00 00    	je     3951 <writeBits+0x18c>
    38c0:	8b 45 08             	mov    0x8(%ebp),%eax
    38c3:	8b 00                	mov    (%eax),%eax
    38c5:	8b 10                	mov    (%eax),%edx
    38c7:	8b 45 08             	mov    0x8(%ebp),%eax
    38ca:	8b 00                	mov    (%eax),%eax
    38cc:	8b 40 04             	mov    0x4(%eax),%eax
    38cf:	83 e8 01             	sub    $0x1,%eax
    38d2:	01 d0                	add    %edx,%eax
    38d4:	c6 00 00             	movb   $0x0,(%eax)
    38d7:	8b 45 08             	mov    0x8(%ebp),%eax
    38da:	8b 00                	mov    (%eax),%eax
    38dc:	8b 10                	mov    (%eax),%edx
    38de:	8b 45 08             	mov    0x8(%ebp),%eax
    38e1:	8b 00                	mov    (%eax),%eax
    38e3:	8b 40 04             	mov    0x4(%eax),%eax
    38e6:	83 e8 01             	sub    $0x1,%eax
    38e9:	01 c2                	add    %eax,%edx
    38eb:	8b 45 08             	mov    0x8(%ebp),%eax
    38ee:	8b 00                	mov    (%eax),%eax
    38f0:	8b 08                	mov    (%eax),%ecx
    38f2:	8b 45 08             	mov    0x8(%ebp),%eax
    38f5:	8b 00                	mov    (%eax),%eax
    38f7:	8b 40 04             	mov    0x4(%eax),%eax
    38fa:	83 e8 01             	sub    $0x1,%eax
    38fd:	01 c8                	add    %ecx,%eax
    38ff:	0f b6 00             	movzbl (%eax),%eax
    3902:	89 c6                	mov    %eax,%esi
    3904:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3907:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    390a:	89 c1                	mov    %eax,%ecx
    390c:	d3 eb                	shr    %cl,%ebx
    390e:	89 d8                	mov    %ebx,%eax
    3910:	83 e0 01             	and    $0x1,%eax
    3913:	89 c3                	mov    %eax,%ebx
    3915:	8b 45 08             	mov    0x8(%ebp),%eax
    3918:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    391c:	0f b6 c0             	movzbl %al,%eax
    391f:	83 e0 07             	and    $0x7,%eax
    3922:	89 c1                	mov    %eax,%ecx
    3924:	d3 e3                	shl    %cl,%ebx
    3926:	89 d8                	mov    %ebx,%eax
    3928:	09 f0                	or     %esi,%eax
    392a:	88 02                	mov    %al,(%edx)
    392c:	8b 45 08             	mov    0x8(%ebp),%eax
    392f:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3933:	8d 50 01             	lea    0x1(%eax),%edx
    3936:	8b 45 08             	mov    0x8(%ebp),%eax
    3939:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    393c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3940:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3943:	3b 45 10             	cmp    0x10(%ebp),%eax
    3946:	0f 85 41 ff ff ff    	jne    388d <writeBits+0xc8>
    394c:	eb 04                	jmp    3952 <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    394e:	90                   	nop
    394f:	eb 01                	jmp    3952 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3951:	90                   	nop
    }
  }
}
    3952:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3955:	5b                   	pop    %ebx
    3956:	5e                   	pop    %esi
    3957:	5d                   	pop    %ebp
    3958:	c3                   	ret    

00003959 <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3959:	55                   	push   %ebp
    395a:	89 e5                	mov    %esp,%ebp
    395c:	56                   	push   %esi
    395d:	53                   	push   %ebx
    395e:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3961:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3968:	e9 bd 00 00 00       	jmp    3a2a <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    396d:	8b 45 08             	mov    0x8(%ebp),%eax
    3970:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3974:	0f b6 c0             	movzbl %al,%eax
    3977:	83 e0 07             	and    $0x7,%eax
    397a:	85 c0                	test   %eax,%eax
    397c:	75 39                	jne    39b7 <writeBitsReversed+0x5e>
    397e:	8b 45 08             	mov    0x8(%ebp),%eax
    3981:	8b 00                	mov    (%eax),%eax
    3983:	8b 40 04             	mov    0x4(%eax),%eax
    3986:	8d 50 01             	lea    0x1(%eax),%edx
    3989:	8b 45 08             	mov    0x8(%ebp),%eax
    398c:	8b 00                	mov    (%eax),%eax
    398e:	52                   	push   %edx
    398f:	50                   	push   %eax
    3990:	e8 a2 fb ff ff       	call   3537 <ucvector_resize>
    3995:	83 c4 08             	add    $0x8,%esp
    3998:	85 c0                	test   %eax,%eax
    399a:	0f 84 98 00 00 00    	je     3a38 <writeBitsReversed+0xdf>
    39a0:	8b 45 08             	mov    0x8(%ebp),%eax
    39a3:	8b 00                	mov    (%eax),%eax
    39a5:	8b 10                	mov    (%eax),%edx
    39a7:	8b 45 08             	mov    0x8(%ebp),%eax
    39aa:	8b 00                	mov    (%eax),%eax
    39ac:	8b 40 04             	mov    0x4(%eax),%eax
    39af:	83 e8 01             	sub    $0x1,%eax
    39b2:	01 d0                	add    %edx,%eax
    39b4:	c6 00 00             	movb   $0x0,(%eax)
    39b7:	8b 45 08             	mov    0x8(%ebp),%eax
    39ba:	8b 00                	mov    (%eax),%eax
    39bc:	8b 10                	mov    (%eax),%edx
    39be:	8b 45 08             	mov    0x8(%ebp),%eax
    39c1:	8b 00                	mov    (%eax),%eax
    39c3:	8b 40 04             	mov    0x4(%eax),%eax
    39c6:	83 e8 01             	sub    $0x1,%eax
    39c9:	01 c2                	add    %eax,%edx
    39cb:	8b 45 08             	mov    0x8(%ebp),%eax
    39ce:	8b 00                	mov    (%eax),%eax
    39d0:	8b 08                	mov    (%eax),%ecx
    39d2:	8b 45 08             	mov    0x8(%ebp),%eax
    39d5:	8b 00                	mov    (%eax),%eax
    39d7:	8b 40 04             	mov    0x4(%eax),%eax
    39da:	83 e8 01             	sub    $0x1,%eax
    39dd:	01 c8                	add    %ecx,%eax
    39df:	0f b6 00             	movzbl (%eax),%eax
    39e2:	89 c6                	mov    %eax,%esi
    39e4:	8b 4d 10             	mov    0x10(%ebp),%ecx
    39e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    39ea:	29 c1                	sub    %eax,%ecx
    39ec:	89 c8                	mov    %ecx,%eax
    39ee:	83 e8 01             	sub    $0x1,%eax
    39f1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    39f4:	89 c1                	mov    %eax,%ecx
    39f6:	d3 eb                	shr    %cl,%ebx
    39f8:	89 d8                	mov    %ebx,%eax
    39fa:	83 e0 01             	and    $0x1,%eax
    39fd:	89 c3                	mov    %eax,%ebx
    39ff:	8b 45 08             	mov    0x8(%ebp),%eax
    3a02:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a06:	0f b6 c0             	movzbl %al,%eax
    3a09:	83 e0 07             	and    $0x7,%eax
    3a0c:	89 c1                	mov    %eax,%ecx
    3a0e:	d3 e3                	shl    %cl,%ebx
    3a10:	89 d8                	mov    %ebx,%eax
    3a12:	09 f0                	or     %esi,%eax
    3a14:	88 02                	mov    %al,(%edx)
    3a16:	8b 45 08             	mov    0x8(%ebp),%eax
    3a19:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a1d:	8d 50 01             	lea    0x1(%eax),%edx
    3a20:	8b 45 08             	mov    0x8(%ebp),%eax
    3a23:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3a26:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3a2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a2d:	3b 45 10             	cmp    0x10(%ebp),%eax
    3a30:	0f 85 37 ff ff ff    	jne    396d <writeBitsReversed+0x14>
    3a36:	eb 01                	jmp    3a39 <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3a38:	90                   	nop
  }
}
    3a39:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3a3c:	5b                   	pop    %ebx
    3a3d:	5e                   	pop    %esi
    3a3e:	5d                   	pop    %ebp
    3a3f:	c3                   	ret    

00003a40 <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    3a40:	55                   	push   %ebp
    3a41:	89 e5                	mov    %esp,%ebp
    3a43:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    3a46:	8b 45 08             	mov    0x8(%ebp),%eax
    3a49:	8b 55 0c             	mov    0xc(%ebp),%edx
    3a4c:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    3a4e:	8b 45 08             	mov    0x8(%ebp),%eax
    3a51:	8b 55 10             	mov    0x10(%ebp),%edx
    3a54:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    3a57:	8b 45 08             	mov    0x8(%ebp),%eax
    3a5a:	83 c0 08             	add    $0x8,%eax
    3a5d:	50                   	push   %eax
    3a5e:	6a 08                	push   $0x8
    3a60:	ff 75 10             	pushl  0x10(%ebp)
    3a63:	e8 59 f9 ff ff       	call   33c1 <lodepng_mulofl>
    3a68:	83 c4 0c             	add    $0xc,%esp
    3a6b:	85 c0                	test   %eax,%eax
    3a6d:	74 07                	je     3a76 <LodePNGBitReader_init+0x36>
    3a6f:	b8 69 00 00 00       	mov    $0x69,%eax
    3a74:	eb 39                	jmp    3aaf <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    3a76:	8b 45 08             	mov    0x8(%ebp),%eax
    3a79:	8b 40 08             	mov    0x8(%eax),%eax
    3a7c:	8d 55 fc             	lea    -0x4(%ebp),%edx
    3a7f:	52                   	push   %edx
    3a80:	6a 40                	push   $0x40
    3a82:	50                   	push   %eax
    3a83:	e8 19 f9 ff ff       	call   33a1 <lodepng_addofl>
    3a88:	83 c4 0c             	add    $0xc,%esp
    3a8b:	85 c0                	test   %eax,%eax
    3a8d:	74 07                	je     3a96 <LodePNGBitReader_init+0x56>
    3a8f:	b8 69 00 00 00       	mov    $0x69,%eax
    3a94:	eb 19                	jmp    3aaf <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    3a96:	8b 45 08             	mov    0x8(%ebp),%eax
    3a99:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    3aa0:	8b 45 08             	mov    0x8(%ebp),%eax
    3aa3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    3aaa:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3aaf:	c9                   	leave  
    3ab0:	c3                   	ret    

00003ab1 <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    3ab1:	55                   	push   %ebp
    3ab2:	89 e5                	mov    %esp,%ebp
    3ab4:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3ab7:	8b 45 08             	mov    0x8(%ebp),%eax
    3aba:	8b 40 0c             	mov    0xc(%eax),%eax
    3abd:	c1 f8 03             	sar    $0x3,%eax
    3ac0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3ac3:	8b 45 08             	mov    0x8(%ebp),%eax
    3ac6:	8b 40 04             	mov    0x4(%eax),%eax
    3ac9:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    3acc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3acf:	8d 50 01             	lea    0x1(%eax),%edx
    3ad2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ad5:	39 c2                	cmp    %eax,%edx
    3ad7:	73 4e                	jae    3b27 <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    3ad9:	8b 45 08             	mov    0x8(%ebp),%eax
    3adc:	8b 10                	mov    (%eax),%edx
    3ade:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ae1:	01 d0                	add    %edx,%eax
    3ae3:	0f b6 00             	movzbl (%eax),%eax
    3ae6:	0f b6 d0             	movzbl %al,%edx
    3ae9:	8b 45 08             	mov    0x8(%ebp),%eax
    3aec:	8b 00                	mov    (%eax),%eax
    3aee:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3af1:	83 c1 01             	add    $0x1,%ecx
    3af4:	01 c8                	add    %ecx,%eax
    3af6:	0f b6 00             	movzbl (%eax),%eax
    3af9:	0f b6 c0             	movzbl %al,%eax
    3afc:	c1 e0 08             	shl    $0x8,%eax
    3aff:	09 c2                	or     %eax,%edx
    3b01:	8b 45 08             	mov    0x8(%ebp),%eax
    3b04:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3b07:	8b 45 08             	mov    0x8(%ebp),%eax
    3b0a:	8b 50 10             	mov    0x10(%eax),%edx
    3b0d:	8b 45 08             	mov    0x8(%ebp),%eax
    3b10:	8b 40 0c             	mov    0xc(%eax),%eax
    3b13:	83 e0 07             	and    $0x7,%eax
    3b16:	89 c1                	mov    %eax,%ecx
    3b18:	d3 ea                	shr    %cl,%edx
    3b1a:	8b 45 08             	mov    0x8(%ebp),%eax
    3b1d:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3b20:	b8 01 00 00 00       	mov    $0x1,%eax
    3b25:	eb 64                	jmp    3b8b <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    3b27:	8b 45 08             	mov    0x8(%ebp),%eax
    3b2a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3b31:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3b34:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3b37:	39 c2                	cmp    %eax,%edx
    3b39:	73 1e                	jae    3b59 <ensureBits9+0xa8>
    3b3b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b3e:	8b 50 10             	mov    0x10(%eax),%edx
    3b41:	8b 45 08             	mov    0x8(%ebp),%eax
    3b44:	8b 08                	mov    (%eax),%ecx
    3b46:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3b49:	01 c8                	add    %ecx,%eax
    3b4b:	0f b6 00             	movzbl (%eax),%eax
    3b4e:	0f b6 c0             	movzbl %al,%eax
    3b51:	09 c2                	or     %eax,%edx
    3b53:	8b 45 08             	mov    0x8(%ebp),%eax
    3b56:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3b59:	8b 45 08             	mov    0x8(%ebp),%eax
    3b5c:	8b 50 10             	mov    0x10(%eax),%edx
    3b5f:	8b 45 08             	mov    0x8(%ebp),%eax
    3b62:	8b 40 0c             	mov    0xc(%eax),%eax
    3b65:	83 e0 07             	and    $0x7,%eax
    3b68:	89 c1                	mov    %eax,%ecx
    3b6a:	d3 ea                	shr    %cl,%edx
    3b6c:	8b 45 08             	mov    0x8(%ebp),%eax
    3b6f:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3b72:	8b 45 08             	mov    0x8(%ebp),%eax
    3b75:	8b 50 0c             	mov    0xc(%eax),%edx
    3b78:	8b 45 0c             	mov    0xc(%ebp),%eax
    3b7b:	01 c2                	add    %eax,%edx
    3b7d:	8b 45 08             	mov    0x8(%ebp),%eax
    3b80:	8b 40 08             	mov    0x8(%eax),%eax
    3b83:	39 c2                	cmp    %eax,%edx
    3b85:	0f 9e c0             	setle  %al
    3b88:	0f b6 c0             	movzbl %al,%eax
  }
}
    3b8b:	c9                   	leave  
    3b8c:	c3                   	ret    

00003b8d <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    3b8d:	55                   	push   %ebp
    3b8e:	89 e5                	mov    %esp,%ebp
    3b90:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3b93:	8b 45 08             	mov    0x8(%ebp),%eax
    3b96:	8b 40 0c             	mov    0xc(%eax),%eax
    3b99:	c1 f8 03             	sar    $0x3,%eax
    3b9c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3b9f:	8b 45 08             	mov    0x8(%ebp),%eax
    3ba2:	8b 40 04             	mov    0x4(%eax),%eax
    3ba5:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    3ba8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3bab:	8d 50 02             	lea    0x2(%eax),%edx
    3bae:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3bb1:	39 c2                	cmp    %eax,%edx
    3bb3:	73 6d                	jae    3c22 <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3bb5:	8b 45 08             	mov    0x8(%ebp),%eax
    3bb8:	8b 10                	mov    (%eax),%edx
    3bba:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3bbd:	01 d0                	add    %edx,%eax
    3bbf:	0f b6 00             	movzbl (%eax),%eax
    3bc2:	0f b6 d0             	movzbl %al,%edx
    3bc5:	8b 45 08             	mov    0x8(%ebp),%eax
    3bc8:	8b 00                	mov    (%eax),%eax
    3bca:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3bcd:	83 c1 01             	add    $0x1,%ecx
    3bd0:	01 c8                	add    %ecx,%eax
    3bd2:	0f b6 00             	movzbl (%eax),%eax
    3bd5:	0f b6 c0             	movzbl %al,%eax
    3bd8:	c1 e0 08             	shl    $0x8,%eax
    3bdb:	89 d1                	mov    %edx,%ecx
    3bdd:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    3bdf:	8b 45 08             	mov    0x8(%ebp),%eax
    3be2:	8b 00                	mov    (%eax),%eax
    3be4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3be7:	83 c2 02             	add    $0x2,%edx
    3bea:	01 d0                	add    %edx,%eax
    3bec:	0f b6 00             	movzbl (%eax),%eax
    3bef:	0f b6 c0             	movzbl %al,%eax
    3bf2:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3bf5:	09 c1                	or     %eax,%ecx
    3bf7:	89 ca                	mov    %ecx,%edx
    3bf9:	8b 45 08             	mov    0x8(%ebp),%eax
    3bfc:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    3bff:	8b 45 08             	mov    0x8(%ebp),%eax
    3c02:	8b 50 10             	mov    0x10(%eax),%edx
    3c05:	8b 45 08             	mov    0x8(%ebp),%eax
    3c08:	8b 40 0c             	mov    0xc(%eax),%eax
    3c0b:	83 e0 07             	and    $0x7,%eax
    3c0e:	89 c1                	mov    %eax,%ecx
    3c10:	d3 ea                	shr    %cl,%edx
    3c12:	8b 45 08             	mov    0x8(%ebp),%eax
    3c15:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3c18:	b8 01 00 00 00       	mov    $0x1,%eax
    3c1d:	e9 95 00 00 00       	jmp    3cb7 <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    3c22:	8b 45 08             	mov    0x8(%ebp),%eax
    3c25:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3c2c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3c2f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c32:	39 c2                	cmp    %eax,%edx
    3c34:	73 1e                	jae    3c54 <ensureBits17+0xc7>
    3c36:	8b 45 08             	mov    0x8(%ebp),%eax
    3c39:	8b 50 10             	mov    0x10(%eax),%edx
    3c3c:	8b 45 08             	mov    0x8(%ebp),%eax
    3c3f:	8b 08                	mov    (%eax),%ecx
    3c41:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c44:	01 c8                	add    %ecx,%eax
    3c46:	0f b6 00             	movzbl (%eax),%eax
    3c49:	0f b6 c0             	movzbl %al,%eax
    3c4c:	09 c2                	or     %eax,%edx
    3c4e:	8b 45 08             	mov    0x8(%ebp),%eax
    3c51:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3c54:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c57:	8d 50 01             	lea    0x1(%eax),%edx
    3c5a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c5d:	39 c2                	cmp    %eax,%edx
    3c5f:	73 24                	jae    3c85 <ensureBits17+0xf8>
    3c61:	8b 45 08             	mov    0x8(%ebp),%eax
    3c64:	8b 50 10             	mov    0x10(%eax),%edx
    3c67:	8b 45 08             	mov    0x8(%ebp),%eax
    3c6a:	8b 00                	mov    (%eax),%eax
    3c6c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3c6f:	83 c1 01             	add    $0x1,%ecx
    3c72:	01 c8                	add    %ecx,%eax
    3c74:	0f b6 00             	movzbl (%eax),%eax
    3c77:	0f b6 c0             	movzbl %al,%eax
    3c7a:	c1 e0 08             	shl    $0x8,%eax
    3c7d:	09 c2                	or     %eax,%edx
    3c7f:	8b 45 08             	mov    0x8(%ebp),%eax
    3c82:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3c85:	8b 45 08             	mov    0x8(%ebp),%eax
    3c88:	8b 50 10             	mov    0x10(%eax),%edx
    3c8b:	8b 45 08             	mov    0x8(%ebp),%eax
    3c8e:	8b 40 0c             	mov    0xc(%eax),%eax
    3c91:	83 e0 07             	and    $0x7,%eax
    3c94:	89 c1                	mov    %eax,%ecx
    3c96:	d3 ea                	shr    %cl,%edx
    3c98:	8b 45 08             	mov    0x8(%ebp),%eax
    3c9b:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3c9e:	8b 45 08             	mov    0x8(%ebp),%eax
    3ca1:	8b 50 0c             	mov    0xc(%eax),%edx
    3ca4:	8b 45 0c             	mov    0xc(%ebp),%eax
    3ca7:	01 c2                	add    %eax,%edx
    3ca9:	8b 45 08             	mov    0x8(%ebp),%eax
    3cac:	8b 40 08             	mov    0x8(%eax),%eax
    3caf:	39 c2                	cmp    %eax,%edx
    3cb1:	0f 9e c0             	setle  %al
    3cb4:	0f b6 c0             	movzbl %al,%eax
  }
}
    3cb7:	c9                   	leave  
    3cb8:	c3                   	ret    

00003cb9 <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    3cb9:	55                   	push   %ebp
    3cba:	89 e5                	mov    %esp,%ebp
    3cbc:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3cbf:	8b 45 08             	mov    0x8(%ebp),%eax
    3cc2:	8b 40 0c             	mov    0xc(%eax),%eax
    3cc5:	c1 f8 03             	sar    $0x3,%eax
    3cc8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3ccb:	8b 45 08             	mov    0x8(%ebp),%eax
    3cce:	8b 40 04             	mov    0x4(%eax),%eax
    3cd1:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    3cd4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3cd7:	8d 50 03             	lea    0x3(%eax),%edx
    3cda:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3cdd:	39 c2                	cmp    %eax,%edx
    3cdf:	0f 83 85 00 00 00    	jae    3d6a <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3ce5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ce8:	8b 10                	mov    (%eax),%edx
    3cea:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ced:	01 d0                	add    %edx,%eax
    3cef:	0f b6 00             	movzbl (%eax),%eax
    3cf2:	0f b6 d0             	movzbl %al,%edx
    3cf5:	8b 45 08             	mov    0x8(%ebp),%eax
    3cf8:	8b 00                	mov    (%eax),%eax
    3cfa:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3cfd:	83 c1 01             	add    $0x1,%ecx
    3d00:	01 c8                	add    %ecx,%eax
    3d02:	0f b6 00             	movzbl (%eax),%eax
    3d05:	0f b6 c0             	movzbl %al,%eax
    3d08:	c1 e0 08             	shl    $0x8,%eax
    3d0b:	89 d1                	mov    %edx,%ecx
    3d0d:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3d0f:	8b 45 08             	mov    0x8(%ebp),%eax
    3d12:	8b 00                	mov    (%eax),%eax
    3d14:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d17:	83 c2 02             	add    $0x2,%edx
    3d1a:	01 d0                	add    %edx,%eax
    3d1c:	0f b6 00             	movzbl (%eax),%eax
    3d1f:	0f b6 c0             	movzbl %al,%eax
    3d22:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d25:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3d27:	8b 45 08             	mov    0x8(%ebp),%eax
    3d2a:	8b 00                	mov    (%eax),%eax
    3d2c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d2f:	83 c2 03             	add    $0x3,%edx
    3d32:	01 d0                	add    %edx,%eax
    3d34:	0f b6 00             	movzbl (%eax),%eax
    3d37:	0f b6 c0             	movzbl %al,%eax
    3d3a:	c1 e0 18             	shl    $0x18,%eax
    3d3d:	09 c1                	or     %eax,%ecx
    3d3f:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d41:	8b 45 08             	mov    0x8(%ebp),%eax
    3d44:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3d47:	8b 45 08             	mov    0x8(%ebp),%eax
    3d4a:	8b 50 10             	mov    0x10(%eax),%edx
    3d4d:	8b 45 08             	mov    0x8(%ebp),%eax
    3d50:	8b 40 0c             	mov    0xc(%eax),%eax
    3d53:	83 e0 07             	and    $0x7,%eax
    3d56:	89 c1                	mov    %eax,%ecx
    3d58:	d3 ea                	shr    %cl,%edx
    3d5a:	8b 45 08             	mov    0x8(%ebp),%eax
    3d5d:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3d60:	b8 01 00 00 00       	mov    $0x1,%eax
    3d65:	e9 c6 00 00 00       	jmp    3e30 <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    3d6a:	8b 45 08             	mov    0x8(%ebp),%eax
    3d6d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3d74:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d77:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3d7a:	39 c2                	cmp    %eax,%edx
    3d7c:	73 1e                	jae    3d9c <ensureBits25+0xe3>
    3d7e:	8b 45 08             	mov    0x8(%ebp),%eax
    3d81:	8b 50 10             	mov    0x10(%eax),%edx
    3d84:	8b 45 08             	mov    0x8(%ebp),%eax
    3d87:	8b 08                	mov    (%eax),%ecx
    3d89:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d8c:	01 c8                	add    %ecx,%eax
    3d8e:	0f b6 00             	movzbl (%eax),%eax
    3d91:	0f b6 c0             	movzbl %al,%eax
    3d94:	09 c2                	or     %eax,%edx
    3d96:	8b 45 08             	mov    0x8(%ebp),%eax
    3d99:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3d9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d9f:	8d 50 01             	lea    0x1(%eax),%edx
    3da2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3da5:	39 c2                	cmp    %eax,%edx
    3da7:	73 24                	jae    3dcd <ensureBits25+0x114>
    3da9:	8b 45 08             	mov    0x8(%ebp),%eax
    3dac:	8b 50 10             	mov    0x10(%eax),%edx
    3daf:	8b 45 08             	mov    0x8(%ebp),%eax
    3db2:	8b 00                	mov    (%eax),%eax
    3db4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3db7:	83 c1 01             	add    $0x1,%ecx
    3dba:	01 c8                	add    %ecx,%eax
    3dbc:	0f b6 00             	movzbl (%eax),%eax
    3dbf:	0f b6 c0             	movzbl %al,%eax
    3dc2:	c1 e0 08             	shl    $0x8,%eax
    3dc5:	09 c2                	or     %eax,%edx
    3dc7:	8b 45 08             	mov    0x8(%ebp),%eax
    3dca:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    3dcd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3dd0:	8d 50 02             	lea    0x2(%eax),%edx
    3dd3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3dd6:	39 c2                	cmp    %eax,%edx
    3dd8:	73 24                	jae    3dfe <ensureBits25+0x145>
    3dda:	8b 45 08             	mov    0x8(%ebp),%eax
    3ddd:	8b 50 10             	mov    0x10(%eax),%edx
    3de0:	8b 45 08             	mov    0x8(%ebp),%eax
    3de3:	8b 00                	mov    (%eax),%eax
    3de5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3de8:	83 c1 02             	add    $0x2,%ecx
    3deb:	01 c8                	add    %ecx,%eax
    3ded:	0f b6 00             	movzbl (%eax),%eax
    3df0:	0f b6 c0             	movzbl %al,%eax
    3df3:	c1 e0 10             	shl    $0x10,%eax
    3df6:	09 c2                	or     %eax,%edx
    3df8:	8b 45 08             	mov    0x8(%ebp),%eax
    3dfb:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3dfe:	8b 45 08             	mov    0x8(%ebp),%eax
    3e01:	8b 50 10             	mov    0x10(%eax),%edx
    3e04:	8b 45 08             	mov    0x8(%ebp),%eax
    3e07:	8b 40 0c             	mov    0xc(%eax),%eax
    3e0a:	83 e0 07             	and    $0x7,%eax
    3e0d:	89 c1                	mov    %eax,%ecx
    3e0f:	d3 ea                	shr    %cl,%edx
    3e11:	8b 45 08             	mov    0x8(%ebp),%eax
    3e14:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3e17:	8b 45 08             	mov    0x8(%ebp),%eax
    3e1a:	8b 50 0c             	mov    0xc(%eax),%edx
    3e1d:	8b 45 0c             	mov    0xc(%ebp),%eax
    3e20:	01 c2                	add    %eax,%edx
    3e22:	8b 45 08             	mov    0x8(%ebp),%eax
    3e25:	8b 40 08             	mov    0x8(%eax),%eax
    3e28:	39 c2                	cmp    %eax,%edx
    3e2a:	0f 9e c0             	setle  %al
    3e2d:	0f b6 c0             	movzbl %al,%eax
  }
}
    3e30:	c9                   	leave  
    3e31:	c3                   	ret    

00003e32 <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    3e32:	55                   	push   %ebp
    3e33:	89 e5                	mov    %esp,%ebp
    3e35:	53                   	push   %ebx
    3e36:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3e39:	8b 45 08             	mov    0x8(%ebp),%eax
    3e3c:	8b 40 0c             	mov    0xc(%eax),%eax
    3e3f:	c1 f8 03             	sar    $0x3,%eax
    3e42:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    3e45:	8b 45 08             	mov    0x8(%ebp),%eax
    3e48:	8b 40 04             	mov    0x4(%eax),%eax
    3e4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    3e4e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e51:	8d 50 04             	lea    0x4(%eax),%edx
    3e54:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3e57:	39 c2                	cmp    %eax,%edx
    3e59:	0f 83 c3 00 00 00    	jae    3f22 <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3e5f:	8b 45 08             	mov    0x8(%ebp),%eax
    3e62:	8b 10                	mov    (%eax),%edx
    3e64:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e67:	01 d0                	add    %edx,%eax
    3e69:	0f b6 00             	movzbl (%eax),%eax
    3e6c:	0f b6 d0             	movzbl %al,%edx
    3e6f:	8b 45 08             	mov    0x8(%ebp),%eax
    3e72:	8b 00                	mov    (%eax),%eax
    3e74:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3e77:	83 c1 01             	add    $0x1,%ecx
    3e7a:	01 c8                	add    %ecx,%eax
    3e7c:	0f b6 00             	movzbl (%eax),%eax
    3e7f:	0f b6 c0             	movzbl %al,%eax
    3e82:	c1 e0 08             	shl    $0x8,%eax
    3e85:	89 d1                	mov    %edx,%ecx
    3e87:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3e89:	8b 45 08             	mov    0x8(%ebp),%eax
    3e8c:	8b 00                	mov    (%eax),%eax
    3e8e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3e91:	83 c2 02             	add    $0x2,%edx
    3e94:	01 d0                	add    %edx,%eax
    3e96:	0f b6 00             	movzbl (%eax),%eax
    3e99:	0f b6 c0             	movzbl %al,%eax
    3e9c:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3e9f:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3ea1:	8b 45 08             	mov    0x8(%ebp),%eax
    3ea4:	8b 00                	mov    (%eax),%eax
    3ea6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3ea9:	83 c2 03             	add    $0x3,%edx
    3eac:	01 d0                	add    %edx,%eax
    3eae:	0f b6 00             	movzbl (%eax),%eax
    3eb1:	0f b6 c0             	movzbl %al,%eax
    3eb4:	c1 e0 18             	shl    $0x18,%eax
    3eb7:	09 c1                	or     %eax,%ecx
    3eb9:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3ebb:	8b 45 08             	mov    0x8(%ebp),%eax
    3ebe:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3ec1:	8b 45 08             	mov    0x8(%ebp),%eax
    3ec4:	8b 50 10             	mov    0x10(%eax),%edx
    3ec7:	8b 45 08             	mov    0x8(%ebp),%eax
    3eca:	8b 40 0c             	mov    0xc(%eax),%eax
    3ecd:	83 e0 07             	and    $0x7,%eax
    3ed0:	89 c1                	mov    %eax,%ecx
    3ed2:	d3 ea                	shr    %cl,%edx
    3ed4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ed7:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    3eda:	8b 45 08             	mov    0x8(%ebp),%eax
    3edd:	8b 50 10             	mov    0x10(%eax),%edx
    3ee0:	8b 45 08             	mov    0x8(%ebp),%eax
    3ee3:	8b 00                	mov    (%eax),%eax
    3ee5:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3ee8:	83 c1 04             	add    $0x4,%ecx
    3eeb:	01 c8                	add    %ecx,%eax
    3eed:	0f b6 00             	movzbl (%eax),%eax
    3ef0:	0f b6 c0             	movzbl %al,%eax
    3ef3:	c1 e0 18             	shl    $0x18,%eax
    3ef6:	89 c3                	mov    %eax,%ebx
    3ef8:	8b 45 08             	mov    0x8(%ebp),%eax
    3efb:	8b 40 0c             	mov    0xc(%eax),%eax
    3efe:	83 e0 07             	and    $0x7,%eax
    3f01:	b9 08 00 00 00       	mov    $0x8,%ecx
    3f06:	29 c1                	sub    %eax,%ecx
    3f08:	89 c8                	mov    %ecx,%eax
    3f0a:	89 c1                	mov    %eax,%ecx
    3f0c:	d3 e3                	shl    %cl,%ebx
    3f0e:	89 d8                	mov    %ebx,%eax
    3f10:	09 c2                	or     %eax,%edx
    3f12:	8b 45 08             	mov    0x8(%ebp),%eax
    3f15:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3f18:	b8 01 00 00 00       	mov    $0x1,%eax
    3f1d:	e9 f7 00 00 00       	jmp    4019 <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    3f22:	8b 45 08             	mov    0x8(%ebp),%eax
    3f25:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3f2c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3f2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3f32:	39 c2                	cmp    %eax,%edx
    3f34:	73 1e                	jae    3f54 <ensureBits32+0x122>
    3f36:	8b 45 08             	mov    0x8(%ebp),%eax
    3f39:	8b 50 10             	mov    0x10(%eax),%edx
    3f3c:	8b 45 08             	mov    0x8(%ebp),%eax
    3f3f:	8b 08                	mov    (%eax),%ecx
    3f41:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f44:	01 c8                	add    %ecx,%eax
    3f46:	0f b6 00             	movzbl (%eax),%eax
    3f49:	0f b6 c0             	movzbl %al,%eax
    3f4c:	09 c2                	or     %eax,%edx
    3f4e:	8b 45 08             	mov    0x8(%ebp),%eax
    3f51:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3f54:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f57:	8d 50 01             	lea    0x1(%eax),%edx
    3f5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3f5d:	39 c2                	cmp    %eax,%edx
    3f5f:	73 24                	jae    3f85 <ensureBits32+0x153>
    3f61:	8b 45 08             	mov    0x8(%ebp),%eax
    3f64:	8b 50 10             	mov    0x10(%eax),%edx
    3f67:	8b 45 08             	mov    0x8(%ebp),%eax
    3f6a:	8b 00                	mov    (%eax),%eax
    3f6c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3f6f:	83 c1 01             	add    $0x1,%ecx
    3f72:	01 c8                	add    %ecx,%eax
    3f74:	0f b6 00             	movzbl (%eax),%eax
    3f77:	0f b6 c0             	movzbl %al,%eax
    3f7a:	c1 e0 08             	shl    $0x8,%eax
    3f7d:	09 c2                	or     %eax,%edx
    3f7f:	8b 45 08             	mov    0x8(%ebp),%eax
    3f82:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    3f85:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f88:	8d 50 02             	lea    0x2(%eax),%edx
    3f8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3f8e:	39 c2                	cmp    %eax,%edx
    3f90:	73 24                	jae    3fb6 <ensureBits32+0x184>
    3f92:	8b 45 08             	mov    0x8(%ebp),%eax
    3f95:	8b 50 10             	mov    0x10(%eax),%edx
    3f98:	8b 45 08             	mov    0x8(%ebp),%eax
    3f9b:	8b 00                	mov    (%eax),%eax
    3f9d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3fa0:	83 c1 02             	add    $0x2,%ecx
    3fa3:	01 c8                	add    %ecx,%eax
    3fa5:	0f b6 00             	movzbl (%eax),%eax
    3fa8:	0f b6 c0             	movzbl %al,%eax
    3fab:	c1 e0 10             	shl    $0x10,%eax
    3fae:	09 c2                	or     %eax,%edx
    3fb0:	8b 45 08             	mov    0x8(%ebp),%eax
    3fb3:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    3fb6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3fb9:	8d 50 03             	lea    0x3(%eax),%edx
    3fbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3fbf:	39 c2                	cmp    %eax,%edx
    3fc1:	73 24                	jae    3fe7 <ensureBits32+0x1b5>
    3fc3:	8b 45 08             	mov    0x8(%ebp),%eax
    3fc6:	8b 50 10             	mov    0x10(%eax),%edx
    3fc9:	8b 45 08             	mov    0x8(%ebp),%eax
    3fcc:	8b 00                	mov    (%eax),%eax
    3fce:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3fd1:	83 c1 03             	add    $0x3,%ecx
    3fd4:	01 c8                	add    %ecx,%eax
    3fd6:	0f b6 00             	movzbl (%eax),%eax
    3fd9:	0f b6 c0             	movzbl %al,%eax
    3fdc:	c1 e0 18             	shl    $0x18,%eax
    3fdf:	09 c2                	or     %eax,%edx
    3fe1:	8b 45 08             	mov    0x8(%ebp),%eax
    3fe4:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3fe7:	8b 45 08             	mov    0x8(%ebp),%eax
    3fea:	8b 50 10             	mov    0x10(%eax),%edx
    3fed:	8b 45 08             	mov    0x8(%ebp),%eax
    3ff0:	8b 40 0c             	mov    0xc(%eax),%eax
    3ff3:	83 e0 07             	and    $0x7,%eax
    3ff6:	89 c1                	mov    %eax,%ecx
    3ff8:	d3 ea                	shr    %cl,%edx
    3ffa:	8b 45 08             	mov    0x8(%ebp),%eax
    3ffd:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4000:	8b 45 08             	mov    0x8(%ebp),%eax
    4003:	8b 50 0c             	mov    0xc(%eax),%edx
    4006:	8b 45 0c             	mov    0xc(%ebp),%eax
    4009:	01 c2                	add    %eax,%edx
    400b:	8b 45 08             	mov    0x8(%ebp),%eax
    400e:	8b 40 08             	mov    0x8(%eax),%eax
    4011:	39 c2                	cmp    %eax,%edx
    4013:	0f 9e c0             	setle  %al
    4016:	0f b6 c0             	movzbl %al,%eax
  }
}
    4019:	83 c4 10             	add    $0x10,%esp
    401c:	5b                   	pop    %ebx
    401d:	5d                   	pop    %ebp
    401e:	c3                   	ret    

0000401f <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    401f:	55                   	push   %ebp
    4020:	89 e5                	mov    %esp,%ebp
    4022:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    4023:	8b 45 08             	mov    0x8(%ebp),%eax
    4026:	8b 50 10             	mov    0x10(%eax),%edx
    4029:	8b 45 0c             	mov    0xc(%ebp),%eax
    402c:	bb 01 00 00 00       	mov    $0x1,%ebx
    4031:	89 c1                	mov    %eax,%ecx
    4033:	d3 e3                	shl    %cl,%ebx
    4035:	89 d8                	mov    %ebx,%eax
    4037:	83 e8 01             	sub    $0x1,%eax
    403a:	21 d0                	and    %edx,%eax
}
    403c:	5b                   	pop    %ebx
    403d:	5d                   	pop    %ebp
    403e:	c3                   	ret    

0000403f <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    403f:	55                   	push   %ebp
    4040:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    4042:	8b 45 08             	mov    0x8(%ebp),%eax
    4045:	8b 50 10             	mov    0x10(%eax),%edx
    4048:	8b 45 0c             	mov    0xc(%ebp),%eax
    404b:	89 c1                	mov    %eax,%ecx
    404d:	d3 ea                	shr    %cl,%edx
    404f:	8b 45 08             	mov    0x8(%ebp),%eax
    4052:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    4055:	8b 45 08             	mov    0x8(%ebp),%eax
    4058:	8b 50 0c             	mov    0xc(%eax),%edx
    405b:	8b 45 0c             	mov    0xc(%ebp),%eax
    405e:	01 c2                	add    %eax,%edx
    4060:	8b 45 08             	mov    0x8(%ebp),%eax
    4063:	89 50 0c             	mov    %edx,0xc(%eax)
}
    4066:	90                   	nop
    4067:	5d                   	pop    %ebp
    4068:	c3                   	ret    

00004069 <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    4069:	55                   	push   %ebp
    406a:	89 e5                	mov    %esp,%ebp
    406c:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    406f:	ff 75 0c             	pushl  0xc(%ebp)
    4072:	ff 75 08             	pushl  0x8(%ebp)
    4075:	e8 a5 ff ff ff       	call   401f <peekBits>
    407a:	83 c4 08             	add    $0x8,%esp
    407d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    4080:	ff 75 0c             	pushl  0xc(%ebp)
    4083:	ff 75 08             	pushl  0x8(%ebp)
    4086:	e8 b4 ff ff ff       	call   403f <advanceBits>
    408b:	83 c4 08             	add    $0x8,%esp
  return result;
    408e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    4091:	c9                   	leave  
    4092:	c3                   	ret    

00004093 <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    4093:	55                   	push   %ebp
    4094:	89 e5                	mov    %esp,%ebp
    4096:	53                   	push   %ebx
    4097:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    409a:	ff 75 0c             	pushl  0xc(%ebp)
    409d:	ff 75 08             	pushl  0x8(%ebp)
    40a0:	8d 45 d8             	lea    -0x28(%ebp),%eax
    40a3:	50                   	push   %eax
    40a4:	e8 97 f9 ff ff       	call   3a40 <LodePNGBitReader_init>
    40a9:	83 c4 0c             	add    $0xc,%esp
    40ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    40af:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    40b3:	74 0a                	je     40bf <lode_png_test_bitreader+0x2c>
    40b5:	b8 00 00 00 00       	mov    $0x0,%eax
    40ba:	e9 c3 00 00 00       	jmp    4182 <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    40bf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    40c6:	e9 a6 00 00 00       	jmp    4171 <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    40cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    40ce:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    40d5:	8b 45 14             	mov    0x14(%ebp),%eax
    40d8:	01 d0                	add    %edx,%eax
    40da:	8b 00                	mov    (%eax),%eax
    40dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    40df:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    40e3:	7e 14                	jle    40f9 <lode_png_test_bitreader+0x66>
    40e5:	ff 75 ec             	pushl  -0x14(%ebp)
    40e8:	8d 45 d8             	lea    -0x28(%ebp),%eax
    40eb:	50                   	push   %eax
    40ec:	e8 41 fd ff ff       	call   3e32 <ensureBits32>
    40f1:	83 c4 08             	add    $0x8,%esp
    40f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    40f7:	eb 46                	jmp    413f <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    40f9:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    40fd:	7e 14                	jle    4113 <lode_png_test_bitreader+0x80>
    40ff:	ff 75 ec             	pushl  -0x14(%ebp)
    4102:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4105:	50                   	push   %eax
    4106:	e8 ae fb ff ff       	call   3cb9 <ensureBits25>
    410b:	83 c4 08             	add    $0x8,%esp
    410e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4111:	eb 2c                	jmp    413f <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    4113:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    4117:	7e 14                	jle    412d <lode_png_test_bitreader+0x9a>
    4119:	ff 75 ec             	pushl  -0x14(%ebp)
    411c:	8d 45 d8             	lea    -0x28(%ebp),%eax
    411f:	50                   	push   %eax
    4120:	e8 68 fa ff ff       	call   3b8d <ensureBits17>
    4125:	83 c4 08             	add    $0x8,%esp
    4128:	89 45 f4             	mov    %eax,-0xc(%ebp)
    412b:	eb 12                	jmp    413f <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    412d:	ff 75 ec             	pushl  -0x14(%ebp)
    4130:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4133:	50                   	push   %eax
    4134:	e8 78 f9 ff ff       	call   3ab1 <ensureBits9>
    4139:	83 c4 08             	add    $0x8,%esp
    413c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    413f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4143:	75 07                	jne    414c <lode_png_test_bitreader+0xb9>
    4145:	b8 00 00 00 00       	mov    $0x0,%eax
    414a:	eb 36                	jmp    4182 <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    414c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    414f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4156:	8b 45 18             	mov    0x18(%ebp),%eax
    4159:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    415c:	ff 75 ec             	pushl  -0x14(%ebp)
    415f:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4162:	50                   	push   %eax
    4163:	e8 01 ff ff ff       	call   4069 <readBits>
    4168:	83 c4 08             	add    $0x8,%esp
    416b:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    416d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4171:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4174:	3b 45 10             	cmp    0x10(%ebp),%eax
    4177:	0f 8c 4e ff ff ff    	jl     40cb <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    417d:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4182:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4185:	c9                   	leave  
    4186:	c3                   	ret    

00004187 <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    4187:	55                   	push   %ebp
    4188:	89 e5                	mov    %esp,%ebp
    418a:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    418d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    4194:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    419b:	eb 27                	jmp    41c4 <reverseBits+0x3d>
    419d:	8b 45 0c             	mov    0xc(%ebp),%eax
    41a0:	2b 45 fc             	sub    -0x4(%ebp),%eax
    41a3:	83 e8 01             	sub    $0x1,%eax
    41a6:	8b 55 08             	mov    0x8(%ebp),%edx
    41a9:	89 c1                	mov    %eax,%ecx
    41ab:	d3 ea                	shr    %cl,%edx
    41ad:	89 d0                	mov    %edx,%eax
    41af:	83 e0 01             	and    $0x1,%eax
    41b2:	89 c2                	mov    %eax,%edx
    41b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    41b7:	89 c1                	mov    %eax,%ecx
    41b9:	d3 e2                	shl    %cl,%edx
    41bb:	89 d0                	mov    %edx,%eax
    41bd:	09 45 f8             	or     %eax,-0x8(%ebp)
    41c0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    41c4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    41c7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    41ca:	72 d1                	jb     419d <reverseBits+0x16>
  return result;
    41cc:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    41cf:	c9                   	leave  
    41d0:	c3                   	ret    

000041d1 <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    41d1:	55                   	push   %ebp
    41d2:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    41d4:	8b 45 08             	mov    0x8(%ebp),%eax
    41d7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    41dd:	8b 45 08             	mov    0x8(%ebp),%eax
    41e0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    41e7:	8b 45 08             	mov    0x8(%ebp),%eax
    41ea:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    41f1:	8b 45 08             	mov    0x8(%ebp),%eax
    41f4:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    41fb:	90                   	nop
    41fc:	5d                   	pop    %ebp
    41fd:	c3                   	ret    

000041fe <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    41fe:	55                   	push   %ebp
    41ff:	89 e5                	mov    %esp,%ebp
    4201:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    4204:	8b 45 08             	mov    0x8(%ebp),%eax
    4207:	8b 00                	mov    (%eax),%eax
    4209:	83 ec 0c             	sub    $0xc,%esp
    420c:	50                   	push   %eax
    420d:	e8 ec f0 ff ff       	call   32fe <lodepng_free>
    4212:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    4215:	8b 45 08             	mov    0x8(%ebp),%eax
    4218:	8b 40 04             	mov    0x4(%eax),%eax
    421b:	83 ec 0c             	sub    $0xc,%esp
    421e:	50                   	push   %eax
    421f:	e8 da f0 ff ff       	call   32fe <lodepng_free>
    4224:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    4227:	8b 45 08             	mov    0x8(%ebp),%eax
    422a:	8b 40 10             	mov    0x10(%eax),%eax
    422d:	83 ec 0c             	sub    $0xc,%esp
    4230:	50                   	push   %eax
    4231:	e8 c8 f0 ff ff       	call   32fe <lodepng_free>
    4236:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    4239:	8b 45 08             	mov    0x8(%ebp),%eax
    423c:	8b 40 14             	mov    0x14(%eax),%eax
    423f:	83 ec 0c             	sub    $0xc,%esp
    4242:	50                   	push   %eax
    4243:	e8 b6 f0 ff ff       	call   32fe <lodepng_free>
    4248:	83 c4 10             	add    $0x10,%esp
}
    424b:	90                   	nop
    424c:	c9                   	leave  
    424d:	c3                   	ret    

0000424e <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    424e:	55                   	push   %ebp
    424f:	89 e5                	mov    %esp,%ebp
    4251:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    4254:	a1 68 b5 01 00       	mov    0x1b568,%eax
    4259:	c1 e0 02             	shl    $0x2,%eax
    425c:	83 ec 0c             	sub    $0xc,%esp
    425f:	50                   	push   %eax
    4260:	e8 78 f0 ff ff       	call   32dd <lodepng_malloc>
    4265:	83 c4 10             	add    $0x10,%esp
    4268:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    426b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    426f:	75 0a                	jne    427b <HuffmanTree_makeTable+0x2d>
    4271:	b8 53 00 00 00       	mov    $0x53,%eax
    4276:	e9 61 04 00 00       	jmp    46dc <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    427b:	a1 68 b5 01 00       	mov    0x1b568,%eax
    4280:	c1 e0 02             	shl    $0x2,%eax
    4283:	83 ec 04             	sub    $0x4,%esp
    4286:	50                   	push   %eax
    4287:	6a 00                	push   $0x0
    4289:	ff 75 dc             	pushl  -0x24(%ebp)
    428c:	e8 bd f0 ff ff       	call   334e <lodepng_memset>
    4291:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    4294:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    429b:	eb 7d                	jmp    431a <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    429d:	8b 45 08             	mov    0x8(%ebp),%eax
    42a0:	8b 00                	mov    (%eax),%eax
    42a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    42a5:	c1 e2 02             	shl    $0x2,%edx
    42a8:	01 d0                	add    %edx,%eax
    42aa:	8b 00                	mov    (%eax),%eax
    42ac:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    42af:	8b 45 08             	mov    0x8(%ebp),%eax
    42b2:	8b 40 04             	mov    0x4(%eax),%eax
    42b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    42b8:	c1 e2 02             	shl    $0x2,%edx
    42bb:	01 d0                	add    %edx,%eax
    42bd:	8b 00                	mov    (%eax),%eax
    42bf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    42c2:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    42c6:	76 4d                	jbe    4315 <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    42c8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    42cb:	83 e8 09             	sub    $0x9,%eax
    42ce:	8b 55 d8             	mov    -0x28(%ebp),%edx
    42d1:	89 c1                	mov    %eax,%ecx
    42d3:	d3 ea                	shr    %cl,%edx
    42d5:	89 d0                	mov    %edx,%eax
    42d7:	83 ec 08             	sub    $0x8,%esp
    42da:	6a 09                	push   $0x9
    42dc:	50                   	push   %eax
    42dd:	e8 a5 fe ff ff       	call   4187 <reverseBits>
    42e2:	83 c4 10             	add    $0x10,%esp
    42e5:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    42e8:	8b 45 d0             	mov    -0x30(%ebp),%eax
    42eb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    42f2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    42f5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    42f8:	8b 45 d0             	mov    -0x30(%ebp),%eax
    42fb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4302:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4305:	01 d0                	add    %edx,%eax
    4307:	8b 10                	mov    (%eax),%edx
    4309:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    430c:	39 c2                	cmp    %eax,%edx
    430e:	0f 43 c2             	cmovae %edx,%eax
    4311:	89 01                	mov    %eax,(%ecx)
    4313:	eb 01                	jmp    4316 <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    4315:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    4316:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    431a:	8b 45 08             	mov    0x8(%ebp),%eax
    431d:	8b 50 0c             	mov    0xc(%eax),%edx
    4320:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4323:	39 c2                	cmp    %eax,%edx
    4325:	0f 87 72 ff ff ff    	ja     429d <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    432b:	a1 68 b5 01 00       	mov    0x1b568,%eax
    4330:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    4333:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    433a:	eb 35                	jmp    4371 <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    433c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    433f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4346:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4349:	01 d0                	add    %edx,%eax
    434b:	8b 00                	mov    (%eax),%eax
    434d:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    4350:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    4354:	76 17                	jbe    436d <HuffmanTree_makeTable+0x11f>
    4356:	8b 45 cc             	mov    -0x34(%ebp),%eax
    4359:	83 e8 09             	sub    $0x9,%eax
    435c:	ba 01 00 00 00       	mov    $0x1,%edx
    4361:	89 c1                	mov    %eax,%ecx
    4363:	d3 e2                	shl    %cl,%edx
    4365:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4368:	01 d0                	add    %edx,%eax
    436a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    436d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4371:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4374:	a1 68 b5 01 00       	mov    0x1b568,%eax
    4379:	39 c2                	cmp    %eax,%edx
    437b:	72 bf                	jb     433c <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    437d:	83 ec 0c             	sub    $0xc,%esp
    4380:	ff 75 e8             	pushl  -0x18(%ebp)
    4383:	e8 55 ef ff ff       	call   32dd <lodepng_malloc>
    4388:	83 c4 10             	add    $0x10,%esp
    438b:	89 c2                	mov    %eax,%edx
    438d:	8b 45 08             	mov    0x8(%ebp),%eax
    4390:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    4393:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4396:	01 c0                	add    %eax,%eax
    4398:	83 ec 0c             	sub    $0xc,%esp
    439b:	50                   	push   %eax
    439c:	e8 3c ef ff ff       	call   32dd <lodepng_malloc>
    43a1:	83 c4 10             	add    $0x10,%esp
    43a4:	89 c2                	mov    %eax,%edx
    43a6:	8b 45 08             	mov    0x8(%ebp),%eax
    43a9:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    43ac:	8b 45 08             	mov    0x8(%ebp),%eax
    43af:	8b 40 10             	mov    0x10(%eax),%eax
    43b2:	85 c0                	test   %eax,%eax
    43b4:	74 0a                	je     43c0 <HuffmanTree_makeTable+0x172>
    43b6:	8b 45 08             	mov    0x8(%ebp),%eax
    43b9:	8b 40 14             	mov    0x14(%eax),%eax
    43bc:	85 c0                	test   %eax,%eax
    43be:	75 18                	jne    43d8 <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    43c0:	83 ec 0c             	sub    $0xc,%esp
    43c3:	ff 75 dc             	pushl  -0x24(%ebp)
    43c6:	e8 33 ef ff ff       	call   32fe <lodepng_free>
    43cb:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    43ce:	b8 53 00 00 00       	mov    $0x53,%eax
    43d3:	e9 04 03 00 00       	jmp    46dc <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    43d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    43df:	eb 12                	jmp    43f3 <HuffmanTree_makeTable+0x1a5>
    43e1:	8b 45 08             	mov    0x8(%ebp),%eax
    43e4:	8b 50 10             	mov    0x10(%eax),%edx
    43e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    43ea:	01 d0                	add    %edx,%eax
    43ec:	c6 00 10             	movb   $0x10,(%eax)
    43ef:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    43f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    43f6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    43f9:	7c e6                	jl     43e1 <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    43fb:	a1 68 b5 01 00       	mov    0x1b568,%eax
    4400:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    4403:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    440a:	eb 5b                	jmp    4467 <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    440c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    440f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4416:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4419:	01 d0                	add    %edx,%eax
    441b:	8b 00                	mov    (%eax),%eax
    441d:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    4420:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    4424:	76 3c                	jbe    4462 <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    4426:	8b 45 08             	mov    0x8(%ebp),%eax
    4429:	8b 50 10             	mov    0x10(%eax),%edx
    442c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    442f:	01 d0                	add    %edx,%eax
    4431:	8b 55 c8             	mov    -0x38(%ebp),%edx
    4434:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    4436:	8b 45 08             	mov    0x8(%ebp),%eax
    4439:	8b 40 14             	mov    0x14(%eax),%eax
    443c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    443f:	01 d2                	add    %edx,%edx
    4441:	01 d0                	add    %edx,%eax
    4443:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4446:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    4449:	8b 45 c8             	mov    -0x38(%ebp),%eax
    444c:	83 e8 09             	sub    $0x9,%eax
    444f:	ba 01 00 00 00       	mov    $0x1,%edx
    4454:	89 c1                	mov    %eax,%ecx
    4456:	d3 e2                	shl    %cl,%edx
    4458:	8b 45 ec             	mov    -0x14(%ebp),%eax
    445b:	01 d0                	add    %edx,%eax
    445d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    4460:	eb 01                	jmp    4463 <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    4462:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    4463:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4467:	8b 55 f4             	mov    -0xc(%ebp),%edx
    446a:	a1 68 b5 01 00       	mov    0x1b568,%eax
    446f:	39 c2                	cmp    %eax,%edx
    4471:	72 99                	jb     440c <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    4473:	83 ec 0c             	sub    $0xc,%esp
    4476:	ff 75 dc             	pushl  -0x24(%ebp)
    4479:	e8 80 ee ff ff       	call   32fe <lodepng_free>
    447e:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    4481:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    4488:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    448f:	e9 9d 01 00 00       	jmp    4631 <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    4494:	8b 45 08             	mov    0x8(%ebp),%eax
    4497:	8b 40 04             	mov    0x4(%eax),%eax
    449a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    449d:	c1 e2 02             	shl    $0x2,%edx
    44a0:	01 d0                	add    %edx,%eax
    44a2:	8b 00                	mov    (%eax),%eax
    44a4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    44a7:	8b 45 08             	mov    0x8(%ebp),%eax
    44aa:	8b 00                	mov    (%eax),%eax
    44ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
    44af:	c1 e2 02             	shl    $0x2,%edx
    44b2:	01 d0                	add    %edx,%eax
    44b4:	8b 00                	mov    (%eax),%eax
    44b6:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    44b9:	83 ec 08             	sub    $0x8,%esp
    44bc:	ff 75 c4             	pushl  -0x3c(%ebp)
    44bf:	ff 75 c0             	pushl  -0x40(%ebp)
    44c2:	e8 c0 fc ff ff       	call   4187 <reverseBits>
    44c7:	83 c4 10             	add    $0x10,%esp
    44ca:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    44cd:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    44d1:	0f 84 55 01 00 00    	je     462c <HuffmanTree_makeTable+0x3de>
    numpresent++;
    44d7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    44db:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    44df:	0f 87 81 00 00 00    	ja     4566 <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    44e5:	b8 09 00 00 00       	mov    $0x9,%eax
    44ea:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    44ed:	ba 01 00 00 00       	mov    $0x1,%edx
    44f2:	89 c1                	mov    %eax,%ecx
    44f4:	d3 e2                	shl    %cl,%edx
    44f6:	89 d0                	mov    %edx,%eax
    44f8:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    44fb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    4502:	eb 55                	jmp    4559 <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    4504:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4507:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    450a:	89 c1                	mov    %eax,%ecx
    450c:	d3 e2                	shl    %cl,%edx
    450e:	89 d0                	mov    %edx,%eax
    4510:	0b 45 bc             	or     -0x44(%ebp),%eax
    4513:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    4516:	8b 45 08             	mov    0x8(%ebp),%eax
    4519:	8b 50 10             	mov    0x10(%eax),%edx
    451c:	8b 45 98             	mov    -0x68(%ebp),%eax
    451f:	01 d0                	add    %edx,%eax
    4521:	0f b6 00             	movzbl (%eax),%eax
    4524:	3c 10                	cmp    $0x10,%al
    4526:	74 0a                	je     4532 <HuffmanTree_makeTable+0x2e4>
    4528:	b8 37 00 00 00       	mov    $0x37,%eax
    452d:	e9 aa 01 00 00       	jmp    46dc <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    4532:	8b 45 08             	mov    0x8(%ebp),%eax
    4535:	8b 50 10             	mov    0x10(%eax),%edx
    4538:	8b 45 98             	mov    -0x68(%ebp),%eax
    453b:	01 d0                	add    %edx,%eax
    453d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4540:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    4542:	8b 45 08             	mov    0x8(%ebp),%eax
    4545:	8b 40 14             	mov    0x14(%eax),%eax
    4548:	8b 55 98             	mov    -0x68(%ebp),%edx
    454b:	01 d2                	add    %edx,%edx
    454d:	01 d0                	add    %edx,%eax
    454f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4552:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    4555:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    4559:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    455c:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    455f:	72 a3                	jb     4504 <HuffmanTree_makeTable+0x2b6>
    4561:	e9 c7 00 00 00       	jmp    462d <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    4566:	a1 6c b5 01 00       	mov    0x1b56c,%eax
    456b:	23 45 bc             	and    -0x44(%ebp),%eax
    456e:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    4571:	8b 45 08             	mov    0x8(%ebp),%eax
    4574:	8b 50 10             	mov    0x10(%eax),%edx
    4577:	8b 45 b8             	mov    -0x48(%ebp),%eax
    457a:	01 d0                	add    %edx,%eax
    457c:	0f b6 00             	movzbl (%eax),%eax
    457f:	0f b6 c0             	movzbl %al,%eax
    4582:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    4585:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    4588:	83 e8 09             	sub    $0x9,%eax
    458b:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    458e:	8b 45 08             	mov    0x8(%ebp),%eax
    4591:	8b 40 14             	mov    0x14(%eax),%eax
    4594:	8b 55 b8             	mov    -0x48(%ebp),%edx
    4597:	01 d2                	add    %edx,%edx
    4599:	01 d0                	add    %edx,%eax
    459b:	0f b7 00             	movzwl (%eax),%eax
    459e:	0f b7 c0             	movzwl %ax,%eax
    45a1:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    45a4:	8b 45 b0             	mov    -0x50(%ebp),%eax
    45a7:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    45aa:	83 c0 09             	add    $0x9,%eax
    45ad:	ba 01 00 00 00       	mov    $0x1,%edx
    45b2:	89 c1                	mov    %eax,%ecx
    45b4:	d3 e2                	shl    %cl,%edx
    45b6:	89 d0                	mov    %edx,%eax
    45b8:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    45bb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    45be:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    45c1:	73 0a                	jae    45cd <HuffmanTree_makeTable+0x37f>
    45c3:	b8 37 00 00 00       	mov    $0x37,%eax
    45c8:	e9 0f 01 00 00       	jmp    46dc <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    45cd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    45d4:	eb 4c                	jmp    4622 <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    45d6:	8b 45 bc             	mov    -0x44(%ebp),%eax
    45d9:	c1 e8 09             	shr    $0x9,%eax
    45dc:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    45df:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    45e2:	83 e8 09             	sub    $0x9,%eax
    45e5:	8b 55 e0             	mov    -0x20(%ebp),%edx
    45e8:	89 c1                	mov    %eax,%ecx
    45ea:	d3 e2                	shl    %cl,%edx
    45ec:	89 d0                	mov    %edx,%eax
    45ee:	0b 45 a4             	or     -0x5c(%ebp),%eax
    45f1:	89 c2                	mov    %eax,%edx
    45f3:	8b 45 ac             	mov    -0x54(%ebp),%eax
    45f6:	01 d0                	add    %edx,%eax
    45f8:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    45fb:	8b 45 08             	mov    0x8(%ebp),%eax
    45fe:	8b 50 10             	mov    0x10(%eax),%edx
    4601:	8b 45 a0             	mov    -0x60(%ebp),%eax
    4604:	01 d0                	add    %edx,%eax
    4606:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4609:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    460b:	8b 45 08             	mov    0x8(%ebp),%eax
    460e:	8b 40 14             	mov    0x14(%eax),%eax
    4611:	8b 55 a0             	mov    -0x60(%ebp),%edx
    4614:	01 d2                	add    %edx,%edx
    4616:	01 d0                	add    %edx,%eax
    4618:	8b 55 f4             	mov    -0xc(%ebp),%edx
    461b:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    461e:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4622:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4625:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    4628:	72 ac                	jb     45d6 <HuffmanTree_makeTable+0x388>
    462a:	eb 01                	jmp    462d <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    462c:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    462d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4631:	8b 45 08             	mov    0x8(%ebp),%eax
    4634:	8b 50 0c             	mov    0xc(%eax),%edx
    4637:	8b 45 f4             	mov    -0xc(%ebp),%eax
    463a:	39 c2                	cmp    %eax,%edx
    463c:	0f 87 52 fe ff ff    	ja     4494 <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    4642:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    4646:	7f 61                	jg     46a9 <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    4648:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    464f:	eb 4e                	jmp    469f <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    4651:	8b 45 08             	mov    0x8(%ebp),%eax
    4654:	8b 50 10             	mov    0x10(%eax),%edx
    4657:	8b 45 f4             	mov    -0xc(%ebp),%eax
    465a:	01 d0                	add    %edx,%eax
    465c:	0f b6 00             	movzbl (%eax),%eax
    465f:	3c 10                	cmp    $0x10,%al
    4661:	75 38                	jne    469b <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    4663:	8b 45 08             	mov    0x8(%ebp),%eax
    4666:	8b 50 10             	mov    0x10(%eax),%edx
    4669:	8b 45 f4             	mov    -0xc(%ebp),%eax
    466c:	01 d0                	add    %edx,%eax
    466e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    4671:	8b 15 68 b5 01 00    	mov    0x1b568,%edx
    4677:	39 d1                	cmp    %edx,%ecx
    4679:	73 07                	jae    4682 <HuffmanTree_makeTable+0x434>
    467b:	ba 01 00 00 00       	mov    $0x1,%edx
    4680:	eb 05                	jmp    4687 <HuffmanTree_makeTable+0x439>
    4682:	ba 0a 00 00 00       	mov    $0xa,%edx
    4687:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    4689:	8b 45 08             	mov    0x8(%ebp),%eax
    468c:	8b 40 14             	mov    0x14(%eax),%eax
    468f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4692:	01 d2                	add    %edx,%edx
    4694:	01 d0                	add    %edx,%eax
    4696:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    469b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    469f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46a2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    46a5:	7c aa                	jl     4651 <HuffmanTree_makeTable+0x403>
    46a7:	eb 2e                	jmp    46d7 <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    46a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    46b0:	eb 1d                	jmp    46cf <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    46b2:	8b 45 08             	mov    0x8(%ebp),%eax
    46b5:	8b 50 10             	mov    0x10(%eax),%edx
    46b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46bb:	01 d0                	add    %edx,%eax
    46bd:	0f b6 00             	movzbl (%eax),%eax
    46c0:	3c 10                	cmp    $0x10,%al
    46c2:	75 07                	jne    46cb <HuffmanTree_makeTable+0x47d>
    46c4:	b8 37 00 00 00       	mov    $0x37,%eax
    46c9:	eb 11                	jmp    46dc <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    46cb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    46cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46d2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    46d5:	7c db                	jl     46b2 <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    46d7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    46dc:	c9                   	leave  
    46dd:	c3                   	ret    

000046de <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    46de:	55                   	push   %ebp
    46df:	89 e5                	mov    %esp,%ebp
    46e1:	56                   	push   %esi
    46e2:	53                   	push   %ebx
    46e3:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    46e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    46ed:	8b 45 08             	mov    0x8(%ebp),%eax
    46f0:	8b 40 0c             	mov    0xc(%eax),%eax
    46f3:	c1 e0 02             	shl    $0x2,%eax
    46f6:	83 ec 0c             	sub    $0xc,%esp
    46f9:	50                   	push   %eax
    46fa:	e8 de eb ff ff       	call   32dd <lodepng_malloc>
    46ff:	83 c4 10             	add    $0x10,%esp
    4702:	89 c2                	mov    %eax,%edx
    4704:	8b 45 08             	mov    0x8(%ebp),%eax
    4707:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4709:	8b 45 08             	mov    0x8(%ebp),%eax
    470c:	8b 40 08             	mov    0x8(%eax),%eax
    470f:	83 c0 01             	add    $0x1,%eax
    4712:	c1 e0 02             	shl    $0x2,%eax
    4715:	83 ec 0c             	sub    $0xc,%esp
    4718:	50                   	push   %eax
    4719:	e8 bf eb ff ff       	call   32dd <lodepng_malloc>
    471e:	83 c4 10             	add    $0x10,%esp
    4721:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4724:	8b 45 08             	mov    0x8(%ebp),%eax
    4727:	8b 40 08             	mov    0x8(%eax),%eax
    472a:	83 c0 01             	add    $0x1,%eax
    472d:	c1 e0 02             	shl    $0x2,%eax
    4730:	83 ec 0c             	sub    $0xc,%esp
    4733:	50                   	push   %eax
    4734:	e8 a4 eb ff ff       	call   32dd <lodepng_malloc>
    4739:	83 c4 10             	add    $0x10,%esp
    473c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    473f:	8b 45 08             	mov    0x8(%ebp),%eax
    4742:	8b 00                	mov    (%eax),%eax
    4744:	85 c0                	test   %eax,%eax
    4746:	74 0c                	je     4754 <HuffmanTree_makeFromLengths2+0x76>
    4748:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    474c:	74 06                	je     4754 <HuffmanTree_makeFromLengths2+0x76>
    474e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4752:	75 07                	jne    475b <HuffmanTree_makeFromLengths2+0x7d>
    4754:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    475b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    475f:	0f 85 7d 01 00 00    	jne    48e2 <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    4765:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    476c:	eb 2c                	jmp    479a <HuffmanTree_makeFromLengths2+0xbc>
    476e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4771:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4778:	8b 45 e8             	mov    -0x18(%ebp),%eax
    477b:	01 c2                	add    %eax,%edx
    477d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4780:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4787:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    478a:	01 c8                	add    %ecx,%eax
    478c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    4792:	8b 00                	mov    (%eax),%eax
    4794:	89 02                	mov    %eax,(%edx)
    4796:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    479a:	8b 45 08             	mov    0x8(%ebp),%eax
    479d:	8b 40 08             	mov    0x8(%eax),%eax
    47a0:	83 c0 01             	add    $0x1,%eax
    47a3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    47a6:	75 c6                	jne    476e <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    47a8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    47af:	eb 27                	jmp    47d8 <HuffmanTree_makeFromLengths2+0xfa>
    47b1:	8b 45 08             	mov    0x8(%ebp),%eax
    47b4:	8b 40 04             	mov    0x4(%eax),%eax
    47b7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    47ba:	c1 e2 02             	shl    $0x2,%edx
    47bd:	01 d0                	add    %edx,%eax
    47bf:	8b 00                	mov    (%eax),%eax
    47c1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    47c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    47cb:	01 d0                	add    %edx,%eax
    47cd:	8b 10                	mov    (%eax),%edx
    47cf:	83 c2 01             	add    $0x1,%edx
    47d2:	89 10                	mov    %edx,(%eax)
    47d4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    47d8:	8b 45 08             	mov    0x8(%ebp),%eax
    47db:	8b 40 0c             	mov    0xc(%eax),%eax
    47de:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    47e1:	75 ce                	jne    47b1 <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    47e3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    47ea:	eb 47                	jmp    4833 <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    47ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
    47ef:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    47f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    47f9:	01 d0                	add    %edx,%eax
    47fb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    47fe:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4804:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    480b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    480e:	01 ca                	add    %ecx,%edx
    4810:	8b 0a                	mov    (%edx),%ecx
    4812:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4815:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    481b:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    4822:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4825:	01 da                	add    %ebx,%edx
    4827:	8b 12                	mov    (%edx),%edx
    4829:	01 ca                	add    %ecx,%edx
    482b:	01 d2                	add    %edx,%edx
    482d:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    482f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4833:	8b 45 08             	mov    0x8(%ebp),%eax
    4836:	8b 40 08             	mov    0x8(%eax),%eax
    4839:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    483c:	73 ae                	jae    47ec <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    483e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4845:	e9 89 00 00 00       	jmp    48d3 <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    484a:	8b 45 08             	mov    0x8(%ebp),%eax
    484d:	8b 40 04             	mov    0x4(%eax),%eax
    4850:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4853:	c1 e2 02             	shl    $0x2,%edx
    4856:	01 d0                	add    %edx,%eax
    4858:	8b 00                	mov    (%eax),%eax
    485a:	85 c0                	test   %eax,%eax
    485c:	74 71                	je     48cf <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    485e:	8b 45 08             	mov    0x8(%ebp),%eax
    4861:	8b 00                	mov    (%eax),%eax
    4863:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4866:	c1 e2 02             	shl    $0x2,%edx
    4869:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    486c:	8b 45 08             	mov    0x8(%ebp),%eax
    486f:	8b 40 04             	mov    0x4(%eax),%eax
    4872:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4875:	c1 e2 02             	shl    $0x2,%edx
    4878:	01 d0                	add    %edx,%eax
    487a:	8b 00                	mov    (%eax),%eax
    487c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4883:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4886:	01 c2                	add    %eax,%edx
    4888:	8b 02                	mov    (%edx),%eax
    488a:	8d 48 01             	lea    0x1(%eax),%ecx
    488d:	89 0a                	mov    %ecx,(%edx)
    488f:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    4891:	8b 45 08             	mov    0x8(%ebp),%eax
    4894:	8b 00                	mov    (%eax),%eax
    4896:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4899:	c1 e2 02             	shl    $0x2,%edx
    489c:	01 c2                	add    %eax,%edx
    489e:	8b 45 08             	mov    0x8(%ebp),%eax
    48a1:	8b 00                	mov    (%eax),%eax
    48a3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    48a6:	c1 e1 02             	shl    $0x2,%ecx
    48a9:	01 c8                	add    %ecx,%eax
    48ab:	8b 18                	mov    (%eax),%ebx
    48ad:	8b 45 08             	mov    0x8(%ebp),%eax
    48b0:	8b 40 04             	mov    0x4(%eax),%eax
    48b3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    48b6:	c1 e1 02             	shl    $0x2,%ecx
    48b9:	01 c8                	add    %ecx,%eax
    48bb:	8b 00                	mov    (%eax),%eax
    48bd:	be 01 00 00 00       	mov    $0x1,%esi
    48c2:	89 c1                	mov    %eax,%ecx
    48c4:	d3 e6                	shl    %cl,%esi
    48c6:	89 f0                	mov    %esi,%eax
    48c8:	83 e8 01             	sub    $0x1,%eax
    48cb:	21 d8                	and    %ebx,%eax
    48cd:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    48cf:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    48d3:	8b 45 08             	mov    0x8(%ebp),%eax
    48d6:	8b 40 0c             	mov    0xc(%eax),%eax
    48d9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    48dc:	0f 85 68 ff ff ff    	jne    484a <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    48e2:	83 ec 0c             	sub    $0xc,%esp
    48e5:	ff 75 e8             	pushl  -0x18(%ebp)
    48e8:	e8 11 ea ff ff       	call   32fe <lodepng_free>
    48ed:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    48f0:	83 ec 0c             	sub    $0xc,%esp
    48f3:	ff 75 e4             	pushl  -0x1c(%ebp)
    48f6:	e8 03 ea ff ff       	call   32fe <lodepng_free>
    48fb:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    48fe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4902:	75 11                	jne    4915 <HuffmanTree_makeFromLengths2+0x237>
    4904:	83 ec 0c             	sub    $0xc,%esp
    4907:	ff 75 08             	pushl  0x8(%ebp)
    490a:	e8 3f f9 ff ff       	call   424e <HuffmanTree_makeTable>
    490f:	83 c4 10             	add    $0x10,%esp
    4912:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    4915:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    4918:	8d 65 f8             	lea    -0x8(%ebp),%esp
    491b:	5b                   	pop    %ebx
    491c:	5e                   	pop    %esi
    491d:	5d                   	pop    %ebp
    491e:	c3                   	ret    

0000491f <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    491f:	55                   	push   %ebp
    4920:	89 e5                	mov    %esp,%ebp
    4922:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    4925:	8b 45 10             	mov    0x10(%ebp),%eax
    4928:	c1 e0 02             	shl    $0x2,%eax
    492b:	83 ec 0c             	sub    $0xc,%esp
    492e:	50                   	push   %eax
    492f:	e8 a9 e9 ff ff       	call   32dd <lodepng_malloc>
    4934:	83 c4 10             	add    $0x10,%esp
    4937:	89 c2                	mov    %eax,%edx
    4939:	8b 45 08             	mov    0x8(%ebp),%eax
    493c:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    493f:	8b 45 08             	mov    0x8(%ebp),%eax
    4942:	8b 40 04             	mov    0x4(%eax),%eax
    4945:	85 c0                	test   %eax,%eax
    4947:	75 07                	jne    4950 <HuffmanTree_makeFromLengths+0x31>
    4949:	b8 53 00 00 00       	mov    $0x53,%eax
    494e:	eb 56                	jmp    49a6 <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    4950:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4957:	eb 25                	jmp    497e <HuffmanTree_makeFromLengths+0x5f>
    4959:	8b 45 08             	mov    0x8(%ebp),%eax
    495c:	8b 40 04             	mov    0x4(%eax),%eax
    495f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4962:	c1 e2 02             	shl    $0x2,%edx
    4965:	01 c2                	add    %eax,%edx
    4967:	8b 45 f4             	mov    -0xc(%ebp),%eax
    496a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4971:	8b 45 0c             	mov    0xc(%ebp),%eax
    4974:	01 c8                	add    %ecx,%eax
    4976:	8b 00                	mov    (%eax),%eax
    4978:	89 02                	mov    %eax,(%edx)
    497a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    497e:	8b 45 10             	mov    0x10(%ebp),%eax
    4981:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4984:	75 d3                	jne    4959 <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    4986:	8b 55 10             	mov    0x10(%ebp),%edx
    4989:	8b 45 08             	mov    0x8(%ebp),%eax
    498c:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    498f:	8b 45 08             	mov    0x8(%ebp),%eax
    4992:	8b 55 14             	mov    0x14(%ebp),%edx
    4995:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    4998:	83 ec 0c             	sub    $0xc,%esp
    499b:	ff 75 08             	pushl  0x8(%ebp)
    499e:	e8 3b fd ff ff       	call   46de <HuffmanTree_makeFromLengths2>
    49a3:	83 c4 10             	add    $0x10,%esp
}
    49a6:	c9                   	leave  
    49a7:	c3                   	ret    

000049a8 <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    49a8:	55                   	push   %ebp
    49a9:	89 e5                	mov    %esp,%ebp
    49ab:	53                   	push   %ebx
    49ac:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    49af:	8b 45 08             	mov    0x8(%ebp),%eax
    49b2:	8b 50 0c             	mov    0xc(%eax),%edx
    49b5:	8b 45 08             	mov    0x8(%ebp),%eax
    49b8:	8b 40 08             	mov    0x8(%eax),%eax
    49bb:	39 c2                	cmp    %eax,%edx
    49bd:	0f 82 0b 01 00 00    	jb     4ace <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    49c3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    49ca:	eb 19                	jmp    49e5 <bpmnode_create+0x3d>
    49cc:	8b 45 08             	mov    0x8(%ebp),%eax
    49cf:	8b 40 04             	mov    0x4(%eax),%eax
    49d2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    49d5:	c1 e2 04             	shl    $0x4,%edx
    49d8:	01 d0                	add    %edx,%eax
    49da:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    49e1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    49e5:	8b 45 08             	mov    0x8(%ebp),%eax
    49e8:	8b 00                	mov    (%eax),%eax
    49ea:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    49ed:	75 dd                	jne    49cc <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    49ef:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    49f6:	eb 60                	jmp    4a58 <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    49f8:	8b 45 08             	mov    0x8(%ebp),%eax
    49fb:	8b 40 18             	mov    0x18(%eax),%eax
    49fe:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a01:	c1 e2 02             	shl    $0x2,%edx
    4a04:	01 d0                	add    %edx,%eax
    4a06:	8b 00                	mov    (%eax),%eax
    4a08:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a0b:	eb 13                	jmp    4a20 <bpmnode_create+0x78>
    4a0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a10:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4a17:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a1a:	8b 40 08             	mov    0x8(%eax),%eax
    4a1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a20:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4a24:	75 e7                	jne    4a0d <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    4a26:	8b 45 08             	mov    0x8(%ebp),%eax
    4a29:	8b 40 1c             	mov    0x1c(%eax),%eax
    4a2c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a2f:	c1 e2 02             	shl    $0x2,%edx
    4a32:	01 d0                	add    %edx,%eax
    4a34:	8b 00                	mov    (%eax),%eax
    4a36:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a39:	eb 13                	jmp    4a4e <bpmnode_create+0xa6>
    4a3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a3e:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4a45:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a48:	8b 40 08             	mov    0x8(%eax),%eax
    4a4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a4e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4a52:	75 e7                	jne    4a3b <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    4a54:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4a58:	8b 45 08             	mov    0x8(%ebp),%eax
    4a5b:	8b 40 14             	mov    0x14(%eax),%eax
    4a5e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4a61:	75 95                	jne    49f8 <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    4a63:	8b 45 08             	mov    0x8(%ebp),%eax
    4a66:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    4a6d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4a74:	eb 44                	jmp    4aba <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    4a76:	8b 45 08             	mov    0x8(%ebp),%eax
    4a79:	8b 40 04             	mov    0x4(%eax),%eax
    4a7c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a7f:	c1 e2 04             	shl    $0x4,%edx
    4a82:	01 d0                	add    %edx,%eax
    4a84:	8b 40 0c             	mov    0xc(%eax),%eax
    4a87:	85 c0                	test   %eax,%eax
    4a89:	75 2b                	jne    4ab6 <bpmnode_create+0x10e>
    4a8b:	8b 45 08             	mov    0x8(%ebp),%eax
    4a8e:	8b 58 10             	mov    0x10(%eax),%ebx
    4a91:	8b 45 08             	mov    0x8(%ebp),%eax
    4a94:	8b 40 08             	mov    0x8(%eax),%eax
    4a97:	8d 48 01             	lea    0x1(%eax),%ecx
    4a9a:	8b 55 08             	mov    0x8(%ebp),%edx
    4a9d:	89 4a 08             	mov    %ecx,0x8(%edx)
    4aa0:	c1 e0 02             	shl    $0x2,%eax
    4aa3:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    4aa6:	8b 45 08             	mov    0x8(%ebp),%eax
    4aa9:	8b 40 04             	mov    0x4(%eax),%eax
    4aac:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4aaf:	c1 e1 04             	shl    $0x4,%ecx
    4ab2:	01 c8                	add    %ecx,%eax
    4ab4:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    4ab6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4aba:	8b 45 08             	mov    0x8(%ebp),%eax
    4abd:	8b 00                	mov    (%eax),%eax
    4abf:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4ac2:	75 b2                	jne    4a76 <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    4ac4:	8b 45 08             	mov    0x8(%ebp),%eax
    4ac7:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    4ace:	8b 45 08             	mov    0x8(%ebp),%eax
    4ad1:	8b 58 10             	mov    0x10(%eax),%ebx
    4ad4:	8b 45 08             	mov    0x8(%ebp),%eax
    4ad7:	8b 40 0c             	mov    0xc(%eax),%eax
    4ada:	8d 48 01             	lea    0x1(%eax),%ecx
    4add:	8b 55 08             	mov    0x8(%ebp),%edx
    4ae0:	89 4a 0c             	mov    %ecx,0xc(%edx)
    4ae3:	c1 e0 02             	shl    $0x2,%eax
    4ae6:	01 d8                	add    %ebx,%eax
    4ae8:	8b 00                	mov    (%eax),%eax
    4aea:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    4aed:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4af0:	8b 55 0c             	mov    0xc(%ebp),%edx
    4af3:	89 10                	mov    %edx,(%eax)
  result->index = index;
    4af5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4af8:	8b 55 10             	mov    0x10(%ebp),%edx
    4afb:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    4afe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b01:	8b 55 14             	mov    0x14(%ebp),%edx
    4b04:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    4b07:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    4b0a:	83 c4 10             	add    $0x10,%esp
    4b0d:	5b                   	pop    %ebx
    4b0e:	5d                   	pop    %ebp
    4b0f:	c3                   	ret    

00004b10 <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    4b10:	55                   	push   %ebp
    4b11:	89 e5                	mov    %esp,%ebp
    4b13:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    4b16:	8b 45 0c             	mov    0xc(%ebp),%eax
    4b19:	c1 e0 04             	shl    $0x4,%eax
    4b1c:	83 ec 0c             	sub    $0xc,%esp
    4b1f:	50                   	push   %eax
    4b20:	e8 b8 e7 ff ff       	call   32dd <lodepng_malloc>
    4b25:	83 c4 10             	add    $0x10,%esp
    4b28:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    4b2b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    4b32:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    4b39:	e9 41 01 00 00       	jmp    4c7f <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    4b3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b41:	83 e0 01             	and    $0x1,%eax
    4b44:	85 c0                	test   %eax,%eax
    4b46:	74 05                	je     4b4d <bpmnode_sort+0x3d>
    4b48:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4b4b:	eb 03                	jmp    4b50 <bpmnode_sort+0x40>
    4b4d:	8b 45 08             	mov    0x8(%ebp),%eax
    4b50:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    4b53:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b56:	83 e0 01             	and    $0x1,%eax
    4b59:	85 c0                	test   %eax,%eax
    4b5b:	74 05                	je     4b62 <bpmnode_sort+0x52>
    4b5d:	8b 45 08             	mov    0x8(%ebp),%eax
    4b60:	eb 03                	jmp    4b65 <bpmnode_sort+0x55>
    4b62:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4b65:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4b68:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4b6f:	e9 f8 00 00 00       	jmp    4c6c <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    4b74:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4b77:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b7a:	01 c2                	add    %eax,%edx
    4b7c:	8b 45 0c             	mov    0xc(%ebp),%eax
    4b7f:	39 c2                	cmp    %eax,%edx
    4b81:	0f 4e c2             	cmovle %edx,%eax
    4b84:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    4b87:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4b8a:	8d 14 00             	lea    (%eax,%eax,1),%edx
    4b8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4b90:	01 c2                	add    %eax,%edx
    4b92:	8b 45 0c             	mov    0xc(%ebp),%eax
    4b95:	39 c2                	cmp    %eax,%edx
    4b97:	0f 4e c2             	cmovle %edx,%eax
    4b9a:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    4b9d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4ba0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    4ba3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4ba6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    4ba9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4bac:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4baf:	e9 a4 00 00 00       	jmp    4c58 <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    4bb4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4bb7:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    4bba:	7d 62                	jge    4c1e <bpmnode_sort+0x10e>
    4bbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4bbf:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4bc2:	7d 22                	jge    4be6 <bpmnode_sort+0xd6>
    4bc4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4bc7:	c1 e0 04             	shl    $0x4,%eax
    4bca:	89 c2                	mov    %eax,%edx
    4bcc:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4bcf:	01 d0                	add    %edx,%eax
    4bd1:	8b 10                	mov    (%eax),%edx
    4bd3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4bd6:	c1 e0 04             	shl    $0x4,%eax
    4bd9:	89 c1                	mov    %eax,%ecx
    4bdb:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4bde:	01 c8                	add    %ecx,%eax
    4be0:	8b 00                	mov    (%eax),%eax
    4be2:	39 c2                	cmp    %eax,%edx
    4be4:	7f 38                	jg     4c1e <bpmnode_sort+0x10e>
    4be6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4be9:	c1 e0 04             	shl    $0x4,%eax
    4bec:	89 c2                	mov    %eax,%edx
    4bee:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4bf1:	01 d0                	add    %edx,%eax
    4bf3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4bf6:	8d 4a 01             	lea    0x1(%edx),%ecx
    4bf9:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    4bfc:	89 d1                	mov    %edx,%ecx
    4bfe:	c1 e1 04             	shl    $0x4,%ecx
    4c01:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4c04:	01 ca                	add    %ecx,%edx
    4c06:	8b 0a                	mov    (%edx),%ecx
    4c08:	89 08                	mov    %ecx,(%eax)
    4c0a:	8b 4a 04             	mov    0x4(%edx),%ecx
    4c0d:	89 48 04             	mov    %ecx,0x4(%eax)
    4c10:	8b 4a 08             	mov    0x8(%edx),%ecx
    4c13:	89 48 08             	mov    %ecx,0x8(%eax)
    4c16:	8b 52 0c             	mov    0xc(%edx),%edx
    4c19:	89 50 0c             	mov    %edx,0xc(%eax)
    4c1c:	eb 36                	jmp    4c54 <bpmnode_sort+0x144>
        else b[k] = a[j++];
    4c1e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4c21:	c1 e0 04             	shl    $0x4,%eax
    4c24:	89 c2                	mov    %eax,%edx
    4c26:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4c29:	01 d0                	add    %edx,%eax
    4c2b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4c2e:	8d 4a 01             	lea    0x1(%edx),%ecx
    4c31:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    4c34:	89 d1                	mov    %edx,%ecx
    4c36:	c1 e1 04             	shl    $0x4,%ecx
    4c39:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4c3c:	01 ca                	add    %ecx,%edx
    4c3e:	8b 0a                	mov    (%edx),%ecx
    4c40:	89 08                	mov    %ecx,(%eax)
    4c42:	8b 4a 04             	mov    0x4(%edx),%ecx
    4c45:	89 48 04             	mov    %ecx,0x4(%eax)
    4c48:	8b 4a 08             	mov    0x8(%edx),%ecx
    4c4b:	89 48 08             	mov    %ecx,0x8(%eax)
    4c4e:	8b 52 0c             	mov    0xc(%edx),%edx
    4c51:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    4c54:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4c58:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4c5b:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4c5e:	0f 8c 50 ff ff ff    	jl     4bb4 <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4c64:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c67:	01 c0                	add    %eax,%eax
    4c69:	01 45 ec             	add    %eax,-0x14(%ebp)
    4c6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4c6f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4c72:	0f 8c fc fe ff ff    	jl     4b74 <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    4c78:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    4c7c:	d1 65 f4             	shll   -0xc(%ebp)
    4c7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c82:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4c85:	0f 8c b3 fe ff ff    	jl     4b3e <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    4c8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c8e:	83 e0 01             	and    $0x1,%eax
    4c91:	85 c0                	test   %eax,%eax
    4c93:	74 18                	je     4cad <bpmnode_sort+0x19d>
    4c95:	8b 45 0c             	mov    0xc(%ebp),%eax
    4c98:	c1 e0 04             	shl    $0x4,%eax
    4c9b:	83 ec 04             	sub    $0x4,%esp
    4c9e:	50                   	push   %eax
    4c9f:	ff 75 dc             	pushl  -0x24(%ebp)
    4ca2:	ff 75 08             	pushl  0x8(%ebp)
    4ca5:	e8 71 e6 ff ff       	call   331b <lodepng_memcpy>
    4caa:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    4cad:	83 ec 0c             	sub    $0xc,%esp
    4cb0:	ff 75 dc             	pushl  -0x24(%ebp)
    4cb3:	e8 46 e6 ff ff       	call   32fe <lodepng_free>
    4cb8:	83 c4 10             	add    $0x10,%esp
}
    4cbb:	90                   	nop
    4cbc:	c9                   	leave  
    4cbd:	c3                   	ret    

00004cbe <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    4cbe:	55                   	push   %ebp
    4cbf:	89 e5                	mov    %esp,%ebp
    4cc1:	56                   	push   %esi
    4cc2:	53                   	push   %ebx
    4cc3:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    4cc6:	8b 45 08             	mov    0x8(%ebp),%eax
    4cc9:	8b 40 1c             	mov    0x1c(%eax),%eax
    4ccc:	8b 55 14             	mov    0x14(%ebp),%edx
    4ccf:	c1 e2 02             	shl    $0x2,%edx
    4cd2:	01 d0                	add    %edx,%eax
    4cd4:	8b 00                	mov    (%eax),%eax
    4cd6:	8b 40 04             	mov    0x4(%eax),%eax
    4cd9:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    4cdc:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    4ce0:	75 66                	jne    4d48 <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    4ce2:	8b 45 10             	mov    0x10(%ebp),%eax
    4ce5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4ce8:	0f 83 a0 01 00 00    	jae    4e8e <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    4cee:	8b 45 08             	mov    0x8(%ebp),%eax
    4cf1:	8b 40 18             	mov    0x18(%eax),%eax
    4cf4:	8b 55 14             	mov    0x14(%ebp),%edx
    4cf7:	c1 e2 02             	shl    $0x2,%edx
    4cfa:	01 c2                	add    %eax,%edx
    4cfc:	8b 45 08             	mov    0x8(%ebp),%eax
    4cff:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d02:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4d05:	c1 e1 02             	shl    $0x2,%ecx
    4d08:	01 c8                	add    %ecx,%eax
    4d0a:	8b 00                	mov    (%eax),%eax
    4d0c:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    4d0e:	8b 45 08             	mov    0x8(%ebp),%eax
    4d11:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d14:	8b 55 14             	mov    0x14(%ebp),%edx
    4d17:	c1 e2 02             	shl    $0x2,%edx
    4d1a:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4d1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d20:	8d 50 01             	lea    0x1(%eax),%edx
    4d23:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d26:	c1 e0 04             	shl    $0x4,%eax
    4d29:	89 c1                	mov    %eax,%ecx
    4d2b:	8b 45 0c             	mov    0xc(%ebp),%eax
    4d2e:	01 c8                	add    %ecx,%eax
    4d30:	8b 00                	mov    (%eax),%eax
    4d32:	6a 00                	push   $0x0
    4d34:	52                   	push   %edx
    4d35:	50                   	push   %eax
    4d36:	ff 75 08             	pushl  0x8(%ebp)
    4d39:	e8 6a fc ff ff       	call   49a8 <bpmnode_create>
    4d3e:	83 c4 10             	add    $0x10,%esp
    4d41:	89 03                	mov    %eax,(%ebx)
    4d43:	e9 47 01 00 00       	jmp    4e8f <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    4d48:	8b 45 08             	mov    0x8(%ebp),%eax
    4d4b:	8b 40 18             	mov    0x18(%eax),%eax
    4d4e:	8b 55 14             	mov    0x14(%ebp),%edx
    4d51:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4d57:	c1 e2 02             	shl    $0x2,%edx
    4d5a:	01 d0                	add    %edx,%eax
    4d5c:	8b 00                	mov    (%eax),%eax
    4d5e:	8b 10                	mov    (%eax),%edx
    4d60:	8b 45 08             	mov    0x8(%ebp),%eax
    4d63:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d66:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4d69:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    4d6f:	c1 e1 02             	shl    $0x2,%ecx
    4d72:	01 c8                	add    %ecx,%eax
    4d74:	8b 00                	mov    (%eax),%eax
    4d76:	8b 00                	mov    (%eax),%eax
    4d78:	01 d0                	add    %edx,%eax
    4d7a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    4d7d:	8b 45 08             	mov    0x8(%ebp),%eax
    4d80:	8b 40 18             	mov    0x18(%eax),%eax
    4d83:	8b 55 14             	mov    0x14(%ebp),%edx
    4d86:	c1 e2 02             	shl    $0x2,%edx
    4d89:	01 c2                	add    %eax,%edx
    4d8b:	8b 45 08             	mov    0x8(%ebp),%eax
    4d8e:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d91:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4d94:	c1 e1 02             	shl    $0x2,%ecx
    4d97:	01 c8                	add    %ecx,%eax
    4d99:	8b 00                	mov    (%eax),%eax
    4d9b:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    4d9d:	8b 45 10             	mov    0x10(%ebp),%eax
    4da0:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4da3:	73 60                	jae    4e05 <boundaryPM+0x147>
    4da5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4da8:	c1 e0 04             	shl    $0x4,%eax
    4dab:	89 c2                	mov    %eax,%edx
    4dad:	8b 45 0c             	mov    0xc(%ebp),%eax
    4db0:	01 d0                	add    %edx,%eax
    4db2:	8b 00                	mov    (%eax),%eax
    4db4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4db7:	7d 4c                	jge    4e05 <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    4db9:	8b 45 08             	mov    0x8(%ebp),%eax
    4dbc:	8b 40 1c             	mov    0x1c(%eax),%eax
    4dbf:	8b 55 14             	mov    0x14(%ebp),%edx
    4dc2:	c1 e2 02             	shl    $0x2,%edx
    4dc5:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4dc8:	8b 45 08             	mov    0x8(%ebp),%eax
    4dcb:	8b 40 1c             	mov    0x1c(%eax),%eax
    4dce:	8b 55 14             	mov    0x14(%ebp),%edx
    4dd1:	c1 e2 02             	shl    $0x2,%edx
    4dd4:	01 d0                	add    %edx,%eax
    4dd6:	8b 00                	mov    (%eax),%eax
    4dd8:	8b 50 08             	mov    0x8(%eax),%edx
    4ddb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4dde:	8d 48 01             	lea    0x1(%eax),%ecx
    4de1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4de4:	c1 e0 04             	shl    $0x4,%eax
    4de7:	89 c6                	mov    %eax,%esi
    4de9:	8b 45 0c             	mov    0xc(%ebp),%eax
    4dec:	01 f0                	add    %esi,%eax
    4dee:	8b 00                	mov    (%eax),%eax
    4df0:	52                   	push   %edx
    4df1:	51                   	push   %ecx
    4df2:	50                   	push   %eax
    4df3:	ff 75 08             	pushl  0x8(%ebp)
    4df6:	e8 ad fb ff ff       	call   49a8 <bpmnode_create>
    4dfb:	83 c4 10             	add    $0x10,%esp
    4dfe:	89 03                	mov    %eax,(%ebx)
      return;
    4e00:	e9 8a 00 00 00       	jmp    4e8f <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    4e05:	8b 45 08             	mov    0x8(%ebp),%eax
    4e08:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e0b:	8b 55 14             	mov    0x14(%ebp),%edx
    4e0e:	c1 e2 02             	shl    $0x2,%edx
    4e11:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4e14:	8b 45 08             	mov    0x8(%ebp),%eax
    4e17:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e1a:	8b 55 14             	mov    0x14(%ebp),%edx
    4e1d:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4e23:	c1 e2 02             	shl    $0x2,%edx
    4e26:	01 d0                	add    %edx,%eax
    4e28:	8b 00                	mov    (%eax),%eax
    4e2a:	50                   	push   %eax
    4e2b:	ff 75 f4             	pushl  -0xc(%ebp)
    4e2e:	ff 75 f0             	pushl  -0x10(%ebp)
    4e31:	ff 75 08             	pushl  0x8(%ebp)
    4e34:	e8 6f fb ff ff       	call   49a8 <bpmnode_create>
    4e39:	83 c4 10             	add    $0x10,%esp
    4e3c:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    4e3e:	8b 45 18             	mov    0x18(%ebp),%eax
    4e41:	8d 50 01             	lea    0x1(%eax),%edx
    4e44:	8b 45 10             	mov    0x10(%ebp),%eax
    4e47:	83 e8 01             	sub    $0x1,%eax
    4e4a:	01 c0                	add    %eax,%eax
    4e4c:	39 c2                	cmp    %eax,%edx
    4e4e:	7d 3f                	jge    4e8f <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4e50:	8b 45 14             	mov    0x14(%ebp),%eax
    4e53:	83 e8 01             	sub    $0x1,%eax
    4e56:	83 ec 0c             	sub    $0xc,%esp
    4e59:	ff 75 18             	pushl  0x18(%ebp)
    4e5c:	50                   	push   %eax
    4e5d:	ff 75 10             	pushl  0x10(%ebp)
    4e60:	ff 75 0c             	pushl  0xc(%ebp)
    4e63:	ff 75 08             	pushl  0x8(%ebp)
    4e66:	e8 53 fe ff ff       	call   4cbe <boundaryPM>
    4e6b:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4e6e:	8b 45 14             	mov    0x14(%ebp),%eax
    4e71:	83 e8 01             	sub    $0x1,%eax
    4e74:	83 ec 0c             	sub    $0xc,%esp
    4e77:	ff 75 18             	pushl  0x18(%ebp)
    4e7a:	50                   	push   %eax
    4e7b:	ff 75 10             	pushl  0x10(%ebp)
    4e7e:	ff 75 0c             	pushl  0xc(%ebp)
    4e81:	ff 75 08             	pushl  0x8(%ebp)
    4e84:	e8 35 fe ff ff       	call   4cbe <boundaryPM>
    4e89:	83 c4 20             	add    $0x20,%esp
    4e8c:	eb 01                	jmp    4e8f <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    4e8e:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    4e8f:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4e92:	5b                   	pop    %ebx
    4e93:	5e                   	pop    %esi
    4e94:	5d                   	pop    %ebp
    4e95:	c3                   	ret    

00004e96 <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    4e96:	55                   	push   %ebp
    4e97:	89 e5                	mov    %esp,%ebp
    4e99:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    4e9c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    4ea3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    4eaa:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    4eae:	75 0a                	jne    4eba <lodepng_huffman_code_lengths+0x24>
    4eb0:	b8 50 00 00 00       	mov    $0x50,%eax
    4eb5:	e9 4d 03 00 00       	jmp    5207 <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    4eba:	8b 45 14             	mov    0x14(%ebp),%eax
    4ebd:	ba 01 00 00 00       	mov    $0x1,%edx
    4ec2:	89 c1                	mov    %eax,%ecx
    4ec4:	d3 e2                	shl    %cl,%edx
    4ec6:	8b 45 10             	mov    0x10(%ebp),%eax
    4ec9:	39 c2                	cmp    %eax,%edx
    4ecb:	73 0a                	jae    4ed7 <lodepng_huffman_code_lengths+0x41>
    4ecd:	b8 50 00 00 00       	mov    $0x50,%eax
    4ed2:	e9 30 03 00 00       	jmp    5207 <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    4ed7:	8b 45 10             	mov    0x10(%ebp),%eax
    4eda:	c1 e0 04             	shl    $0x4,%eax
    4edd:	83 ec 0c             	sub    $0xc,%esp
    4ee0:	50                   	push   %eax
    4ee1:	e8 f7 e3 ff ff       	call   32dd <lodepng_malloc>
    4ee6:	83 c4 10             	add    $0x10,%esp
    4ee9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    4eec:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4ef0:	75 0a                	jne    4efc <lodepng_huffman_code_lengths+0x66>
    4ef2:	b8 53 00 00 00       	mov    $0x53,%eax
    4ef7:	e9 0b 03 00 00       	jmp    5207 <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    4efc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4f03:	eb 50                	jmp    4f55 <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    4f05:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4f08:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4f0f:	8b 45 0c             	mov    0xc(%ebp),%eax
    4f12:	01 d0                	add    %edx,%eax
    4f14:	8b 00                	mov    (%eax),%eax
    4f16:	85 c0                	test   %eax,%eax
    4f18:	74 37                	je     4f51 <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    4f1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f1d:	c1 e0 04             	shl    $0x4,%eax
    4f20:	89 c2                	mov    %eax,%edx
    4f22:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4f25:	01 d0                	add    %edx,%eax
    4f27:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4f2a:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    4f31:	8b 55 0c             	mov    0xc(%ebp),%edx
    4f34:	01 ca                	add    %ecx,%edx
    4f36:	8b 12                	mov    (%edx),%edx
    4f38:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    4f3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f3d:	c1 e0 04             	shl    $0x4,%eax
    4f40:	89 c2                	mov    %eax,%edx
    4f42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4f45:	01 c2                	add    %eax,%edx
    4f47:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4f4a:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    4f4d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    4f51:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4f55:	8b 45 10             	mov    0x10(%ebp),%eax
    4f58:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    4f5b:	75 a8                	jne    4f05 <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    4f5d:	8b 45 10             	mov    0x10(%ebp),%eax
    4f60:	c1 e0 02             	shl    $0x2,%eax
    4f63:	83 ec 04             	sub    $0x4,%esp
    4f66:	50                   	push   %eax
    4f67:	6a 00                	push   $0x0
    4f69:	ff 75 08             	pushl  0x8(%ebp)
    4f6c:	e8 dd e3 ff ff       	call   334e <lodepng_memset>
    4f71:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    4f74:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    4f78:	75 18                	jne    4f92 <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    4f7a:	8b 45 08             	mov    0x8(%ebp),%eax
    4f7d:	83 c0 04             	add    $0x4,%eax
    4f80:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    4f86:	8b 10                	mov    (%eax),%edx
    4f88:	8b 45 08             	mov    0x8(%ebp),%eax
    4f8b:	89 10                	mov    %edx,(%eax)
    4f8d:	e9 64 02 00 00       	jmp    51f6 <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    4f92:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    4f96:	75 3e                	jne    4fd6 <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    4f98:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4f9b:	8b 40 04             	mov    0x4(%eax),%eax
    4f9e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4fa5:	8b 45 08             	mov    0x8(%ebp),%eax
    4fa8:	01 d0                	add    %edx,%eax
    4faa:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    4fb0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4fb3:	8b 40 04             	mov    0x4(%eax),%eax
    4fb6:	85 c0                	test   %eax,%eax
    4fb8:	75 07                	jne    4fc1 <lodepng_huffman_code_lengths+0x12b>
    4fba:	ba 04 00 00 00       	mov    $0x4,%edx
    4fbf:	eb 05                	jmp    4fc6 <lodepng_huffman_code_lengths+0x130>
    4fc1:	ba 00 00 00 00       	mov    $0x0,%edx
    4fc6:	8b 45 08             	mov    0x8(%ebp),%eax
    4fc9:	01 d0                	add    %edx,%eax
    4fcb:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    4fd1:	e9 20 02 00 00       	jmp    51f6 <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    4fd6:	83 ec 08             	sub    $0x8,%esp
    4fd9:	ff 75 ec             	pushl  -0x14(%ebp)
    4fdc:	ff 75 e4             	pushl  -0x1c(%ebp)
    4fdf:	e8 2c fb ff ff       	call   4b10 <bpmnode_sort>
    4fe4:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    4fe7:	8b 45 14             	mov    0x14(%ebp),%eax
    4fea:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    4fed:	8b 45 14             	mov    0x14(%ebp),%eax
    4ff0:	83 c0 01             	add    $0x1,%eax
    4ff3:	0f af 45 14          	imul   0x14(%ebp),%eax
    4ff7:	01 c0                	add    %eax,%eax
    4ff9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    4ffc:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    5003:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5006:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    5009:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    500c:	c1 e0 04             	shl    $0x4,%eax
    500f:	83 ec 0c             	sub    $0xc,%esp
    5012:	50                   	push   %eax
    5013:	e8 c5 e2 ff ff       	call   32dd <lodepng_malloc>
    5018:	83 c4 10             	add    $0x10,%esp
    501b:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    501e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5021:	c1 e0 02             	shl    $0x2,%eax
    5024:	83 ec 0c             	sub    $0xc,%esp
    5027:	50                   	push   %eax
    5028:	e8 b0 e2 ff ff       	call   32dd <lodepng_malloc>
    502d:	83 c4 10             	add    $0x10,%esp
    5030:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5033:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5036:	c1 e0 02             	shl    $0x2,%eax
    5039:	83 ec 0c             	sub    $0xc,%esp
    503c:	50                   	push   %eax
    503d:	e8 9b e2 ff ff       	call   32dd <lodepng_malloc>
    5042:	83 c4 10             	add    $0x10,%esp
    5045:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5048:	8b 45 d8             	mov    -0x28(%ebp),%eax
    504b:	c1 e0 02             	shl    $0x2,%eax
    504e:	83 ec 0c             	sub    $0xc,%esp
    5051:	50                   	push   %eax
    5052:	e8 86 e2 ff ff       	call   32dd <lodepng_malloc>
    5057:	83 c4 10             	add    $0x10,%esp
    505a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    505d:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5060:	85 c0                	test   %eax,%eax
    5062:	74 15                	je     5079 <lodepng_huffman_code_lengths+0x1e3>
    5064:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5067:	85 c0                	test   %eax,%eax
    5069:	74 0e                	je     5079 <lodepng_huffman_code_lengths+0x1e3>
    506b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    506e:	85 c0                	test   %eax,%eax
    5070:	74 07                	je     5079 <lodepng_huffman_code_lengths+0x1e3>
    5072:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5075:	85 c0                	test   %eax,%eax
    5077:	75 07                	jne    5080 <lodepng_huffman_code_lengths+0x1ea>
    5079:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    5080:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5084:	0f 85 30 01 00 00    	jne    51ba <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    508a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5091:	eb 1c                	jmp    50af <lodepng_huffman_code_lengths+0x219>
    5093:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5096:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5099:	c1 e2 02             	shl    $0x2,%edx
    509c:	01 d0                	add    %edx,%eax
    509e:	8b 55 c8             	mov    -0x38(%ebp),%edx
    50a1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    50a4:	c1 e1 04             	shl    $0x4,%ecx
    50a7:	01 ca                	add    %ecx,%edx
    50a9:	89 10                	mov    %edx,(%eax)
    50ab:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    50af:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    50b2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    50b5:	75 dc                	jne    5093 <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    50b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    50ba:	8b 00                	mov    (%eax),%eax
    50bc:	6a 00                	push   $0x0
    50be:	6a 01                	push   $0x1
    50c0:	50                   	push   %eax
    50c1:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    50c4:	50                   	push   %eax
    50c5:	e8 de f8 ff ff       	call   49a8 <bpmnode_create>
    50ca:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    50cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    50d0:	83 c0 10             	add    $0x10,%eax
    50d3:	8b 00                	mov    (%eax),%eax
    50d5:	6a 00                	push   $0x0
    50d7:	6a 02                	push   $0x2
    50d9:	50                   	push   %eax
    50da:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    50dd:	50                   	push   %eax
    50de:	e8 c5 f8 ff ff       	call   49a8 <bpmnode_create>
    50e3:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    50e6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    50ed:	eb 27                	jmp    5116 <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    50ef:	8b 45 dc             	mov    -0x24(%ebp),%eax
    50f2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    50f5:	c1 e2 02             	shl    $0x2,%edx
    50f8:	01 c2                	add    %eax,%edx
    50fa:	8b 45 c8             	mov    -0x38(%ebp),%eax
    50fd:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    50ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5102:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5105:	c1 e2 02             	shl    $0x2,%edx
    5108:	01 d0                	add    %edx,%eax
    510a:	8b 55 c8             	mov    -0x38(%ebp),%edx
    510d:	83 c2 10             	add    $0x10,%edx
    5110:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    5112:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5116:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5119:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    511c:	75 d1                	jne    50ef <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    511e:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    5125:	eb 24                	jmp    514b <lodepng_huffman_code_lengths+0x2b5>
    5127:	8b 45 f0             	mov    -0x10(%ebp),%eax
    512a:	8b 55 14             	mov    0x14(%ebp),%edx
    512d:	83 ea 01             	sub    $0x1,%edx
    5130:	83 ec 0c             	sub    $0xc,%esp
    5133:	50                   	push   %eax
    5134:	52                   	push   %edx
    5135:	ff 75 ec             	pushl  -0x14(%ebp)
    5138:	ff 75 e4             	pushl  -0x1c(%ebp)
    513b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    513e:	50                   	push   %eax
    513f:	e8 7a fb ff ff       	call   4cbe <boundaryPM>
    5144:	83 c4 20             	add    $0x20,%esp
    5147:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    514b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    514e:	83 e8 01             	sub    $0x1,%eax
    5151:	01 c0                	add    %eax,%eax
    5153:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5156:	75 cf                	jne    5127 <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    5158:	8b 45 e0             	mov    -0x20(%ebp),%eax
    515b:	8b 55 14             	mov    0x14(%ebp),%edx
    515e:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    5164:	c1 e2 02             	shl    $0x2,%edx
    5167:	01 d0                	add    %edx,%eax
    5169:	8b 00                	mov    (%eax),%eax
    516b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    516e:	eb 44                	jmp    51b4 <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    5170:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5177:	eb 27                	jmp    51a0 <lodepng_huffman_code_lengths+0x30a>
    5179:	8b 45 f0             	mov    -0x10(%ebp),%eax
    517c:	c1 e0 04             	shl    $0x4,%eax
    517f:	89 c2                	mov    %eax,%edx
    5181:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5184:	01 d0                	add    %edx,%eax
    5186:	8b 40 04             	mov    0x4(%eax),%eax
    5189:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5190:	8b 45 08             	mov    0x8(%ebp),%eax
    5193:	01 d0                	add    %edx,%eax
    5195:	8b 10                	mov    (%eax),%edx
    5197:	83 c2 01             	add    $0x1,%edx
    519a:	89 10                	mov    %edx,(%eax)
    519c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    51a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    51a3:	8b 40 04             	mov    0x4(%eax),%eax
    51a6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    51a9:	75 ce                	jne    5179 <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    51ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    51ae:	8b 40 08             	mov    0x8(%eax),%eax
    51b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    51b4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    51b8:	75 b6                	jne    5170 <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    51ba:	8b 45 c8             	mov    -0x38(%ebp),%eax
    51bd:	83 ec 0c             	sub    $0xc,%esp
    51c0:	50                   	push   %eax
    51c1:	e8 38 e1 ff ff       	call   32fe <lodepng_free>
    51c6:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    51c9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    51cc:	83 ec 0c             	sub    $0xc,%esp
    51cf:	50                   	push   %eax
    51d0:	e8 29 e1 ff ff       	call   32fe <lodepng_free>
    51d5:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    51d8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    51db:	83 ec 0c             	sub    $0xc,%esp
    51de:	50                   	push   %eax
    51df:	e8 1a e1 ff ff       	call   32fe <lodepng_free>
    51e4:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    51e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    51ea:	83 ec 0c             	sub    $0xc,%esp
    51ed:	50                   	push   %eax
    51ee:	e8 0b e1 ff ff       	call   32fe <lodepng_free>
    51f3:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    51f6:	83 ec 0c             	sub    $0xc,%esp
    51f9:	ff 75 e4             	pushl  -0x1c(%ebp)
    51fc:	e8 fd e0 ff ff       	call   32fe <lodepng_free>
    5201:	83 c4 10             	add    $0x10,%esp
  return error;
    5204:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5207:	c9                   	leave  
    5208:	c3                   	ret    

00005209 <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    5209:	55                   	push   %ebp
    520a:	89 e5                	mov    %esp,%ebp
    520c:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    520f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    5216:	eb 04                	jmp    521c <HuffmanTree_makeFromFrequencies+0x13>
    5218:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    521c:	8b 45 14             	mov    0x14(%ebp),%eax
    521f:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5224:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    522b:	8b 45 0c             	mov    0xc(%ebp),%eax
    522e:	01 d0                	add    %edx,%eax
    5230:	8b 00                	mov    (%eax),%eax
    5232:	85 c0                	test   %eax,%eax
    5234:	75 08                	jne    523e <HuffmanTree_makeFromFrequencies+0x35>
    5236:	8b 45 14             	mov    0x14(%ebp),%eax
    5239:	3b 45 10             	cmp    0x10(%ebp),%eax
    523c:	7f da                	jg     5218 <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    523e:	8b 45 14             	mov    0x14(%ebp),%eax
    5241:	c1 e0 02             	shl    $0x2,%eax
    5244:	83 ec 0c             	sub    $0xc,%esp
    5247:	50                   	push   %eax
    5248:	e8 90 e0 ff ff       	call   32dd <lodepng_malloc>
    524d:	83 c4 10             	add    $0x10,%esp
    5250:	89 c2                	mov    %eax,%edx
    5252:	8b 45 08             	mov    0x8(%ebp),%eax
    5255:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    5258:	8b 45 08             	mov    0x8(%ebp),%eax
    525b:	8b 40 04             	mov    0x4(%eax),%eax
    525e:	85 c0                	test   %eax,%eax
    5260:	75 07                	jne    5269 <HuffmanTree_makeFromFrequencies+0x60>
    5262:	b8 53 00 00 00       	mov    $0x53,%eax
    5267:	eb 47                	jmp    52b0 <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    5269:	8b 45 08             	mov    0x8(%ebp),%eax
    526c:	8b 55 18             	mov    0x18(%ebp),%edx
    526f:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    5272:	8b 55 14             	mov    0x14(%ebp),%edx
    5275:	8b 45 08             	mov    0x8(%ebp),%eax
    5278:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    527b:	8b 45 08             	mov    0x8(%ebp),%eax
    527e:	8b 40 04             	mov    0x4(%eax),%eax
    5281:	ff 75 18             	pushl  0x18(%ebp)
    5284:	ff 75 14             	pushl  0x14(%ebp)
    5287:	ff 75 0c             	pushl  0xc(%ebp)
    528a:	50                   	push   %eax
    528b:	e8 06 fc ff ff       	call   4e96 <lodepng_huffman_code_lengths>
    5290:	83 c4 10             	add    $0x10,%esp
    5293:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    5296:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    529a:	75 11                	jne    52ad <HuffmanTree_makeFromFrequencies+0xa4>
    529c:	83 ec 0c             	sub    $0xc,%esp
    529f:	ff 75 08             	pushl  0x8(%ebp)
    52a2:	e8 37 f4 ff ff       	call   46de <HuffmanTree_makeFromLengths2>
    52a7:	83 c4 10             	add    $0x10,%esp
    52aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    52ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    52b0:	c9                   	leave  
    52b1:	c3                   	ret    

000052b2 <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    52b2:	55                   	push   %ebp
    52b3:	89 e5                	mov    %esp,%ebp
    52b5:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    52b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    52bf:	83 ec 0c             	sub    $0xc,%esp
    52c2:	68 80 04 00 00       	push   $0x480
    52c7:	e8 11 e0 ff ff       	call   32dd <lodepng_malloc>
    52cc:	83 c4 10             	add    $0x10,%esp
    52cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    52d2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    52d6:	75 0a                	jne    52e2 <generateFixedLitLenTree+0x30>
    52d8:	b8 53 00 00 00       	mov    $0x53,%eax
    52dd:	e9 d5 00 00 00       	jmp    53b7 <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    52e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    52e9:	eb 19                	jmp    5304 <generateFixedLitLenTree+0x52>
    52eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    52ee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    52f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    52f8:	01 d0                	add    %edx,%eax
    52fa:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5300:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5304:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    530b:	76 de                	jbe    52eb <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    530d:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    5314:	eb 19                	jmp    532f <generateFixedLitLenTree+0x7d>
    5316:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5319:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5320:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5323:	01 d0                	add    %edx,%eax
    5325:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    532b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    532f:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    5336:	76 de                	jbe    5316 <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    5338:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    533f:	eb 19                	jmp    535a <generateFixedLitLenTree+0xa8>
    5341:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5344:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    534b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    534e:	01 d0                	add    %edx,%eax
    5350:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    5356:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    535a:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    5361:	76 de                	jbe    5341 <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    5363:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    536a:	eb 19                	jmp    5385 <generateFixedLitLenTree+0xd3>
    536c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    536f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5376:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5379:	01 d0                	add    %edx,%eax
    537b:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5381:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5385:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    538c:	76 de                	jbe    536c <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    538e:	6a 0f                	push   $0xf
    5390:	68 20 01 00 00       	push   $0x120
    5395:	ff 75 ec             	pushl  -0x14(%ebp)
    5398:	ff 75 08             	pushl  0x8(%ebp)
    539b:	e8 7f f5 ff ff       	call   491f <HuffmanTree_makeFromLengths>
    53a0:	83 c4 10             	add    $0x10,%esp
    53a3:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    53a6:	83 ec 0c             	sub    $0xc,%esp
    53a9:	ff 75 ec             	pushl  -0x14(%ebp)
    53ac:	e8 4d df ff ff       	call   32fe <lodepng_free>
    53b1:	83 c4 10             	add    $0x10,%esp
  return error;
    53b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    53b7:	c9                   	leave  
    53b8:	c3                   	ret    

000053b9 <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    53b9:	55                   	push   %ebp
    53ba:	89 e5                	mov    %esp,%ebp
    53bc:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    53bf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    53c6:	83 ec 0c             	sub    $0xc,%esp
    53c9:	68 80 00 00 00       	push   $0x80
    53ce:	e8 0a df ff ff       	call   32dd <lodepng_malloc>
    53d3:	83 c4 10             	add    $0x10,%esp
    53d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    53d9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    53dd:	75 07                	jne    53e6 <generateFixedDistanceTree+0x2d>
    53df:	b8 53 00 00 00       	mov    $0x53,%eax
    53e4:	eb 4e                	jmp    5434 <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    53e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    53ed:	eb 19                	jmp    5408 <generateFixedDistanceTree+0x4f>
    53ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    53f2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    53f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    53fc:	01 d0                	add    %edx,%eax
    53fe:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    5404:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5408:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    540c:	75 e1                	jne    53ef <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    540e:	6a 0f                	push   $0xf
    5410:	6a 20                	push   $0x20
    5412:	ff 75 ec             	pushl  -0x14(%ebp)
    5415:	ff 75 08             	pushl  0x8(%ebp)
    5418:	e8 02 f5 ff ff       	call   491f <HuffmanTree_makeFromLengths>
    541d:	83 c4 10             	add    $0x10,%esp
    5420:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    5423:	83 ec 0c             	sub    $0xc,%esp
    5426:	ff 75 ec             	pushl  -0x14(%ebp)
    5429:	e8 d0 de ff ff       	call   32fe <lodepng_free>
    542e:	83 c4 10             	add    $0x10,%esp
  return error;
    5431:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    5434:	c9                   	leave  
    5435:	c3                   	ret    

00005436 <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    5436:	55                   	push   %ebp
    5437:	89 e5                	mov    %esp,%ebp
    5439:	53                   	push   %ebx
    543a:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    543d:	6a 09                	push   $0x9
    543f:	ff 75 08             	pushl  0x8(%ebp)
    5442:	e8 d8 eb ff ff       	call   401f <peekBits>
    5447:	83 c4 08             	add    $0x8,%esp
    544a:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    544e:	8b 45 0c             	mov    0xc(%ebp),%eax
    5451:	8b 50 10             	mov    0x10(%eax),%edx
    5454:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    5458:	01 d0                	add    %edx,%eax
    545a:	0f b6 00             	movzbl (%eax),%eax
    545d:	0f b6 c0             	movzbl %al,%eax
    5460:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    5464:	8b 45 0c             	mov    0xc(%ebp),%eax
    5467:	8b 40 14             	mov    0x14(%eax),%eax
    546a:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    546e:	01 d2                	add    %edx,%edx
    5470:	01 d0                	add    %edx,%eax
    5472:	0f b7 00             	movzwl (%eax),%eax
    5475:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    5479:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    547e:	77 16                	ja     5496 <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    5480:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    5484:	50                   	push   %eax
    5485:	ff 75 08             	pushl  0x8(%ebp)
    5488:	e8 b2 eb ff ff       	call   403f <advanceBits>
    548d:	83 c4 08             	add    $0x8,%esp
    return value;
    5490:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    5494:	eb 5c                	jmp    54f2 <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    5496:	6a 09                	push   $0x9
    5498:	ff 75 08             	pushl  0x8(%ebp)
    549b:	e8 9f eb ff ff       	call   403f <advanceBits>
    54a0:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    54a3:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    54a7:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    54ab:	83 e8 09             	sub    $0x9,%eax
    54ae:	50                   	push   %eax
    54af:	ff 75 08             	pushl  0x8(%ebp)
    54b2:	e8 68 eb ff ff       	call   401f <peekBits>
    54b7:	83 c4 08             	add    $0x8,%esp
    54ba:	01 d8                	add    %ebx,%eax
    54bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    54bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    54c2:	8b 50 10             	mov    0x10(%eax),%edx
    54c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    54c8:	01 d0                	add    %edx,%eax
    54ca:	0f b6 00             	movzbl (%eax),%eax
    54cd:	0f b6 c0             	movzbl %al,%eax
    54d0:	83 e8 09             	sub    $0x9,%eax
    54d3:	50                   	push   %eax
    54d4:	ff 75 08             	pushl  0x8(%ebp)
    54d7:	e8 63 eb ff ff       	call   403f <advanceBits>
    54dc:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    54df:	8b 45 0c             	mov    0xc(%ebp),%eax
    54e2:	8b 40 14             	mov    0x14(%eax),%eax
    54e5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    54e8:	01 d2                	add    %edx,%edx
    54ea:	01 d0                	add    %edx,%eax
    54ec:	0f b7 00             	movzwl (%eax),%eax
    54ef:	0f b7 c0             	movzwl %ax,%eax
  }
}
    54f2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    54f5:	c9                   	leave  
    54f6:	c3                   	ret    

000054f7 <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    54f7:	55                   	push   %ebp
    54f8:	89 e5                	mov    %esp,%ebp
    54fa:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    54fd:	83 ec 0c             	sub    $0xc,%esp
    5500:	ff 75 08             	pushl  0x8(%ebp)
    5503:	e8 aa fd ff ff       	call   52b2 <generateFixedLitLenTree>
    5508:	83 c4 10             	add    $0x10,%esp
    550b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    550e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5512:	74 05                	je     5519 <getTreeInflateFixed+0x22>
    5514:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5517:	eb 0e                	jmp    5527 <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    5519:	83 ec 0c             	sub    $0xc,%esp
    551c:	ff 75 0c             	pushl  0xc(%ebp)
    551f:	e8 95 fe ff ff       	call   53b9 <generateFixedDistanceTree>
    5524:	83 c4 10             	add    $0x10,%esp
}
    5527:	c9                   	leave  
    5528:	c3                   	ret    

00005529 <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    5529:	55                   	push   %ebp
    552a:	89 e5                	mov    %esp,%ebp
    552c:	53                   	push   %ebx
    552d:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    5530:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    5537:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    553e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    5545:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    554c:	6a 0e                	push   $0xe
    554e:	ff 75 10             	pushl  0x10(%ebp)
    5551:	e8 37 e6 ff ff       	call   3b8d <ensureBits17>
    5556:	83 c4 08             	add    $0x8,%esp
    5559:	85 c0                	test   %eax,%eax
    555b:	75 0a                	jne    5567 <getTreeInflateDynamic+0x3e>
    555d:	b8 31 00 00 00       	mov    $0x31,%eax
    5562:	e9 ec 04 00 00       	jmp    5a53 <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    5567:	6a 05                	push   $0x5
    5569:	ff 75 10             	pushl  0x10(%ebp)
    556c:	e8 f8 ea ff ff       	call   4069 <readBits>
    5571:	83 c4 08             	add    $0x8,%esp
    5574:	05 01 01 00 00       	add    $0x101,%eax
    5579:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    557c:	6a 05                	push   $0x5
    557e:	ff 75 10             	pushl  0x10(%ebp)
    5581:	e8 e3 ea ff ff       	call   4069 <readBits>
    5586:	83 c4 08             	add    $0x8,%esp
    5589:	83 c0 01             	add    $0x1,%eax
    558c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    558f:	6a 04                	push   $0x4
    5591:	ff 75 10             	pushl  0x10(%ebp)
    5594:	e8 d0 ea ff ff       	call   4069 <readBits>
    5599:	83 c4 08             	add    $0x8,%esp
    559c:	83 c0 04             	add    $0x4,%eax
    559f:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    55a2:	83 ec 0c             	sub    $0xc,%esp
    55a5:	6a 4c                	push   $0x4c
    55a7:	e8 31 dd ff ff       	call   32dd <lodepng_malloc>
    55ac:	83 c4 10             	add    $0x10,%esp
    55af:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    55b2:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    55b6:	75 0a                	jne    55c2 <getTreeInflateDynamic+0x99>
    55b8:	b8 53 00 00 00       	mov    $0x53,%eax
    55bd:	e9 91 04 00 00       	jmp    5a53 <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    55c2:	83 ec 0c             	sub    $0xc,%esp
    55c5:	8d 45 a8             	lea    -0x58(%ebp),%eax
    55c8:	50                   	push   %eax
    55c9:	e8 03 ec ff ff       	call   41d1 <HuffmanTree_init>
    55ce:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    55d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    55d5:	0f 85 3c 04 00 00    	jne    5a17 <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    55db:	8b 45 10             	mov    0x10(%ebp),%eax
    55de:	8b 48 08             	mov    0x8(%eax),%ecx
    55e1:	8b 55 d0             	mov    -0x30(%ebp),%edx
    55e4:	89 d0                	mov    %edx,%eax
    55e6:	01 c0                	add    %eax,%eax
    55e8:	01 d0                	add    %edx,%eax
    55ea:	89 c2                	mov    %eax,%edx
    55ec:	8b 45 10             	mov    0x10(%ebp),%eax
    55ef:	8b 40 0c             	mov    0xc(%eax),%eax
    55f2:	83 ec 04             	sub    $0x4,%esp
    55f5:	51                   	push   %ecx
    55f6:	52                   	push   %edx
    55f7:	50                   	push   %eax
    55f8:	e8 f7 dd ff ff       	call   33f4 <lodepng_gtofl>
    55fd:	83 c4 10             	add    $0x10,%esp
    5600:	85 c0                	test   %eax,%eax
    5602:	74 0c                	je     5610 <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    5604:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    560b:	e9 07 04 00 00       	jmp    5a17 <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    5610:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    5617:	eb 3d                	jmp    5656 <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    5619:	83 ec 08             	sub    $0x8,%esp
    561c:	6a 03                	push   $0x3
    561e:	ff 75 10             	pushl  0x10(%ebp)
    5621:	e8 8b e4 ff ff       	call   3ab1 <ensureBits9>
    5626:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    5629:	8b 45 ec             	mov    -0x14(%ebp),%eax
    562c:	8b 04 85 e0 9e 01 00 	mov    0x19ee0(,%eax,4),%eax
    5633:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    563a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    563d:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    5640:	83 ec 08             	sub    $0x8,%esp
    5643:	6a 03                	push   $0x3
    5645:	ff 75 10             	pushl  0x10(%ebp)
    5648:	e8 1c ea ff ff       	call   4069 <readBits>
    564d:	83 c4 10             	add    $0x10,%esp
    5650:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    5652:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5656:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5659:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    565c:	75 bb                	jne    5619 <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    565e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5661:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5664:	eb 20                	jmp    5686 <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    5666:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5669:	8b 04 85 e0 9e 01 00 	mov    0x19ee0(,%eax,4),%eax
    5670:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5677:	8b 45 dc             	mov    -0x24(%ebp),%eax
    567a:	01 d0                	add    %edx,%eax
    567c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5682:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5686:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    568a:	75 da                	jne    5666 <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    568c:	6a 07                	push   $0x7
    568e:	6a 13                	push   $0x13
    5690:	ff 75 dc             	pushl  -0x24(%ebp)
    5693:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5696:	50                   	push   %eax
    5697:	e8 83 f2 ff ff       	call   491f <HuffmanTree_makeFromLengths>
    569c:	83 c4 10             	add    $0x10,%esp
    569f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    56a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    56a6:	0f 85 64 03 00 00    	jne    5a10 <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    56ac:	83 ec 0c             	sub    $0xc,%esp
    56af:	68 80 04 00 00       	push   $0x480
    56b4:	e8 24 dc ff ff       	call   32dd <lodepng_malloc>
    56b9:	83 c4 10             	add    $0x10,%esp
    56bc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    56bf:	83 ec 0c             	sub    $0xc,%esp
    56c2:	68 80 00 00 00       	push   $0x80
    56c7:	e8 11 dc ff ff       	call   32dd <lodepng_malloc>
    56cc:	83 c4 10             	add    $0x10,%esp
    56cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    56d2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    56d6:	74 06                	je     56de <getTreeInflateDynamic+0x1b5>
    56d8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    56dc:	75 0c                	jne    56ea <getTreeInflateDynamic+0x1c1>
    56de:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    56e5:	e9 2d 03 00 00       	jmp    5a17 <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    56ea:	83 ec 04             	sub    $0x4,%esp
    56ed:	68 80 04 00 00       	push   $0x480
    56f2:	6a 00                	push   $0x0
    56f4:	ff 75 e8             	pushl  -0x18(%ebp)
    56f7:	e8 52 dc ff ff       	call   334e <lodepng_memset>
    56fc:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    56ff:	83 ec 04             	sub    $0x4,%esp
    5702:	68 80 00 00 00       	push   $0x80
    5707:	6a 00                	push   $0x0
    5709:	ff 75 e4             	pushl  -0x1c(%ebp)
    570c:	e8 3d dc ff ff       	call   334e <lodepng_memset>
    5711:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    5714:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    571b:	e9 8d 02 00 00       	jmp    59ad <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    5720:	83 ec 08             	sub    $0x8,%esp
    5723:	6a 16                	push   $0x16
    5725:	ff 75 10             	pushl  0x10(%ebp)
    5728:	e8 8c e5 ff ff       	call   3cb9 <ensureBits25>
    572d:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    5730:	83 ec 08             	sub    $0x8,%esp
    5733:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5736:	50                   	push   %eax
    5737:	ff 75 10             	pushl  0x10(%ebp)
    573a:	e8 f7 fc ff ff       	call   5436 <huffmanDecodeSymbol>
    573f:	83 c4 10             	add    $0x10,%esp
    5742:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    5745:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    5749:	77 3e                	ja     5789 <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    574b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    574e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5751:	73 16                	jae    5769 <getTreeInflateDynamic+0x240>
    5753:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5756:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    575d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5760:	01 c2                	add    %eax,%edx
    5762:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5765:	89 02                	mov    %eax,(%edx)
    5767:	eb 17                	jmp    5780 <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    5769:	8b 45 ec             	mov    -0x14(%ebp),%eax
    576c:	2b 45 d8             	sub    -0x28(%ebp),%eax
    576f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5776:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5779:	01 c2                	add    %eax,%edx
    577b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    577e:	89 02                	mov    %eax,(%edx)
        ++i;
    5780:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5784:	e9 0b 02 00 00       	jmp    5994 <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    5789:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    578d:	0f 85 da 00 00 00    	jne    586d <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    5793:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    579a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    579e:	75 0c                	jne    57ac <getTreeInflateDynamic+0x283>
    57a0:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    57a7:	e9 12 02 00 00       	jmp    59be <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    57ac:	83 ec 08             	sub    $0x8,%esp
    57af:	6a 02                	push   $0x2
    57b1:	ff 75 10             	pushl  0x10(%ebp)
    57b4:	e8 b0 e8 ff ff       	call   4069 <readBits>
    57b9:	83 c4 10             	add    $0x10,%esp
    57bc:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    57bf:	8b 45 d8             	mov    -0x28(%ebp),%eax
    57c2:	83 c0 01             	add    $0x1,%eax
    57c5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    57c8:	76 1b                	jbe    57e5 <getTreeInflateDynamic+0x2bc>
    57ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
    57cd:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    57d2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    57d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    57dc:	01 d0                	add    %edx,%eax
    57de:	8b 00                	mov    (%eax),%eax
    57e0:	89 45 e0             	mov    %eax,-0x20(%ebp)
    57e3:	eb 1c                	jmp    5801 <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    57e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    57e8:	2b 45 d8             	sub    -0x28(%ebp),%eax
    57eb:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    57f0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    57f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    57fa:	01 d0                	add    %edx,%eax
    57fc:	8b 00                	mov    (%eax),%eax
    57fe:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5801:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5808:	eb 56                	jmp    5860 <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    580a:	8b 55 d8             	mov    -0x28(%ebp),%edx
    580d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5810:	01 d0                	add    %edx,%eax
    5812:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5815:	77 0c                	ja     5823 <getTreeInflateDynamic+0x2fa>
    5817:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    581e:	e9 71 01 00 00       	jmp    5994 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    5823:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5826:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5829:	73 16                	jae    5841 <getTreeInflateDynamic+0x318>
    582b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    582e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5835:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5838:	01 c2                	add    %eax,%edx
    583a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    583d:	89 02                	mov    %eax,(%edx)
    583f:	eb 17                	jmp    5858 <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    5841:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5844:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5847:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    584e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5851:	01 c2                	add    %eax,%edx
    5853:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5856:	89 02                	mov    %eax,(%edx)
          ++i;
    5858:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    585c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5860:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5863:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    5866:	72 a2                	jb     580a <getTreeInflateDynamic+0x2e1>
    5868:	e9 27 01 00 00       	jmp    5994 <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    586d:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    5871:	0f 85 88 00 00 00    	jne    58ff <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    5877:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    587e:	83 ec 08             	sub    $0x8,%esp
    5881:	6a 03                	push   $0x3
    5883:	ff 75 10             	pushl  0x10(%ebp)
    5886:	e8 de e7 ff ff       	call   4069 <readBits>
    588b:	83 c4 10             	add    $0x10,%esp
    588e:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5891:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5898:	eb 58                	jmp    58f2 <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    589a:	8b 55 d8             	mov    -0x28(%ebp),%edx
    589d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    58a0:	01 d0                	add    %edx,%eax
    58a2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    58a5:	77 0c                	ja     58b3 <getTreeInflateDynamic+0x38a>
    58a7:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    58ae:	e9 e1 00 00 00       	jmp    5994 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    58b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58b6:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    58b9:	73 17                	jae    58d2 <getTreeInflateDynamic+0x3a9>
    58bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58be:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    58c8:	01 d0                	add    %edx,%eax
    58ca:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    58d0:	eb 18                	jmp    58ea <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    58d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58d5:	2b 45 d8             	sub    -0x28(%ebp),%eax
    58d8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    58e2:	01 d0                	add    %edx,%eax
    58e4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    58ea:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    58ee:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    58f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    58f5:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    58f8:	72 a0                	jb     589a <getTreeInflateDynamic+0x371>
    58fa:	e9 95 00 00 00       	jmp    5994 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    58ff:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    5903:	0f 85 82 00 00 00    	jne    598b <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    5909:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    5910:	83 ec 08             	sub    $0x8,%esp
    5913:	6a 07                	push   $0x7
    5915:	ff 75 10             	pushl  0x10(%ebp)
    5918:	e8 4c e7 ff ff       	call   4069 <readBits>
    591d:	83 c4 10             	add    $0x10,%esp
    5920:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5923:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    592a:	eb 55                	jmp    5981 <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    592c:	8b 55 d8             	mov    -0x28(%ebp),%edx
    592f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5932:	01 d0                	add    %edx,%eax
    5934:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5937:	77 09                	ja     5942 <getTreeInflateDynamic+0x419>
    5939:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    5940:	eb 52                	jmp    5994 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5942:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5945:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5948:	73 17                	jae    5961 <getTreeInflateDynamic+0x438>
    594a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    594d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5954:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5957:	01 d0                	add    %edx,%eax
    5959:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    595f:	eb 18                	jmp    5979 <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    5961:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5964:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5967:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    596e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5971:	01 d0                	add    %edx,%eax
    5973:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5979:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    597d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5981:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5984:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    5987:	72 a3                	jb     592c <getTreeInflateDynamic+0x403>
    5989:	eb 09                	jmp    5994 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    598b:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5992:	eb 2a                	jmp    59be <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    5994:	8b 45 10             	mov    0x10(%ebp),%eax
    5997:	8b 50 0c             	mov    0xc(%eax),%edx
    599a:	8b 45 10             	mov    0x10(%ebp),%eax
    599d:	8b 40 08             	mov    0x8(%eax),%eax
    59a0:	39 c2                	cmp    %eax,%edx
    59a2:	7e 09                	jle    59ad <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    59a4:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    59ab:	eb 11                	jmp    59be <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    59ad:	8b 55 d8             	mov    -0x28(%ebp),%edx
    59b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    59b3:	01 d0                	add    %edx,%eax
    59b5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    59b8:	0f 87 62 fd ff ff    	ja     5720 <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    59be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    59c2:	75 4f                	jne    5a13 <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    59c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    59c7:	05 00 04 00 00       	add    $0x400,%eax
    59cc:	8b 00                	mov    (%eax),%eax
    59ce:	85 c0                	test   %eax,%eax
    59d0:	75 09                	jne    59db <getTreeInflateDynamic+0x4b2>
    59d2:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    59d9:	eb 3c                	jmp    5a17 <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    59db:	6a 0f                	push   $0xf
    59dd:	68 20 01 00 00       	push   $0x120
    59e2:	ff 75 e8             	pushl  -0x18(%ebp)
    59e5:	ff 75 08             	pushl  0x8(%ebp)
    59e8:	e8 32 ef ff ff       	call   491f <HuffmanTree_makeFromLengths>
    59ed:	83 c4 10             	add    $0x10,%esp
    59f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    59f3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    59f7:	75 1d                	jne    5a16 <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    59f9:	6a 0f                	push   $0xf
    59fb:	6a 20                	push   $0x20
    59fd:	ff 75 e4             	pushl  -0x1c(%ebp)
    5a00:	ff 75 0c             	pushl  0xc(%ebp)
    5a03:	e8 17 ef ff ff       	call   491f <HuffmanTree_makeFromLengths>
    5a08:	83 c4 10             	add    $0x10,%esp
    5a0b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    5a0e:	eb 07                	jmp    5a17 <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    5a10:	90                   	nop
    5a11:	eb 04                	jmp    5a17 <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5a13:	90                   	nop
    5a14:	eb 01                	jmp    5a17 <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    5a16:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    5a17:	83 ec 0c             	sub    $0xc,%esp
    5a1a:	ff 75 dc             	pushl  -0x24(%ebp)
    5a1d:	e8 dc d8 ff ff       	call   32fe <lodepng_free>
    5a22:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    5a25:	83 ec 0c             	sub    $0xc,%esp
    5a28:	ff 75 e8             	pushl  -0x18(%ebp)
    5a2b:	e8 ce d8 ff ff       	call   32fe <lodepng_free>
    5a30:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    5a33:	83 ec 0c             	sub    $0xc,%esp
    5a36:	ff 75 e4             	pushl  -0x1c(%ebp)
    5a39:	e8 c0 d8 ff ff       	call   32fe <lodepng_free>
    5a3e:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    5a41:	83 ec 0c             	sub    $0xc,%esp
    5a44:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5a47:	50                   	push   %eax
    5a48:	e8 b1 e7 ff ff       	call   41fe <HuffmanTree_cleanup>
    5a4d:	83 c4 10             	add    $0x10,%esp

  return error;
    5a50:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5a53:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5a56:	c9                   	leave  
    5a57:	c3                   	ret    

00005a58 <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    5a58:	55                   	push   %ebp
    5a59:	89 e5                	mov    %esp,%ebp
    5a5b:	53                   	push   %ebx
    5a5c:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    5a5f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    5a66:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5a69:	50                   	push   %eax
    5a6a:	e8 62 e7 ff ff       	call   41d1 <HuffmanTree_init>
    5a6f:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    5a72:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5a75:	50                   	push   %eax
    5a76:	e8 56 e7 ff ff       	call   41d1 <HuffmanTree_init>
    5a7b:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    5a7e:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    5a82:	75 1b                	jne    5a9f <inflateHuffmanBlock+0x47>
    5a84:	83 ec 08             	sub    $0x8,%esp
    5a87:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5a8a:	50                   	push   %eax
    5a8b:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5a8e:	50                   	push   %eax
    5a8f:	e8 63 fa ff ff       	call   54f7 <getTreeInflateFixed>
    5a94:	83 c4 10             	add    $0x10,%esp
    5a97:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5a9a:	e9 9a 02 00 00       	jmp    5d39 <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    5a9f:	83 ec 04             	sub    $0x4,%esp
    5aa2:	ff 75 0c             	pushl  0xc(%ebp)
    5aa5:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5aa8:	50                   	push   %eax
    5aa9:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5aac:	50                   	push   %eax
    5aad:	e8 77 fa ff ff       	call   5529 <getTreeInflateDynamic>
    5ab2:	83 c4 10             	add    $0x10,%esp
    5ab5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5ab8:	e9 7c 02 00 00       	jmp    5d39 <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    5abd:	83 ec 08             	sub    $0x8,%esp
    5ac0:	6a 14                	push   $0x14
    5ac2:	ff 75 0c             	pushl  0xc(%ebp)
    5ac5:	e8 ef e1 ff ff       	call   3cb9 <ensureBits25>
    5aca:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    5acd:	83 ec 08             	sub    $0x8,%esp
    5ad0:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5ad3:	50                   	push   %eax
    5ad4:	ff 75 0c             	pushl  0xc(%ebp)
    5ad7:	e8 5a f9 ff ff       	call   5436 <huffmanDecodeSymbol>
    5adc:	83 c4 10             	add    $0x10,%esp
    5adf:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    5ae2:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    5ae9:	77 42                	ja     5b2d <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    5aeb:	8b 45 08             	mov    0x8(%ebp),%eax
    5aee:	8b 40 04             	mov    0x4(%eax),%eax
    5af1:	83 c0 01             	add    $0x1,%eax
    5af4:	83 ec 08             	sub    $0x8,%esp
    5af7:	50                   	push   %eax
    5af8:	ff 75 08             	pushl  0x8(%ebp)
    5afb:	e8 37 da ff ff       	call   3537 <ucvector_resize>
    5b00:	83 c4 10             	add    $0x10,%esp
    5b03:	85 c0                	test   %eax,%eax
    5b05:	75 0c                	jne    5b13 <inflateHuffmanBlock+0xbb>
    5b07:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5b0e:	e9 33 02 00 00       	jmp    5d46 <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    5b13:	8b 45 08             	mov    0x8(%ebp),%eax
    5b16:	8b 10                	mov    (%eax),%edx
    5b18:	8b 45 08             	mov    0x8(%ebp),%eax
    5b1b:	8b 40 04             	mov    0x4(%eax),%eax
    5b1e:	83 e8 01             	sub    $0x1,%eax
    5b21:	01 d0                	add    %edx,%eax
    5b23:	8b 55 dc             	mov    -0x24(%ebp),%edx
    5b26:	88 10                	mov    %dl,(%eax)
    5b28:	e9 d9 01 00 00       	jmp    5d06 <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5b2d:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5b34:	0f 86 ba 01 00 00    	jbe    5cf4 <inflateHuffmanBlock+0x29c>
    5b3a:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    5b41:	0f 87 ad 01 00 00    	ja     5cf4 <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    5b47:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5b4a:	2d 01 01 00 00       	sub    $0x101,%eax
    5b4f:	8b 04 85 e0 9c 01 00 	mov    0x19ce0(,%eax,4),%eax
    5b56:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    5b59:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5b5c:	2d 01 01 00 00       	sub    $0x101,%eax
    5b61:	8b 04 85 60 9d 01 00 	mov    0x19d60(,%eax,4),%eax
    5b68:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    5b6b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    5b6f:	74 1c                	je     5b8d <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    5b71:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5b74:	83 ec 08             	sub    $0x8,%esp
    5b77:	50                   	push   %eax
    5b78:	ff 75 0c             	pushl  0xc(%ebp)
    5b7b:	e8 e9 e4 ff ff       	call   4069 <readBits>
    5b80:	83 c4 10             	add    $0x10,%esp
    5b83:	89 c2                	mov    %eax,%edx
    5b85:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5b88:	01 d0                	add    %edx,%eax
    5b8a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    5b8d:	83 ec 08             	sub    $0x8,%esp
    5b90:	6a 1c                	push   $0x1c
    5b92:	ff 75 0c             	pushl  0xc(%ebp)
    5b95:	e8 98 e2 ff ff       	call   3e32 <ensureBits32>
    5b9a:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    5b9d:	83 ec 08             	sub    $0x8,%esp
    5ba0:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5ba3:	50                   	push   %eax
    5ba4:	ff 75 0c             	pushl  0xc(%ebp)
    5ba7:	e8 8a f8 ff ff       	call   5436 <huffmanDecodeSymbol>
    5bac:	83 c4 10             	add    $0x10,%esp
    5baf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    5bb2:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    5bb6:	76 1e                	jbe    5bd6 <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    5bb8:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    5bbc:	77 0c                	ja     5bca <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    5bbe:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    5bc5:	e9 7c 01 00 00       	jmp    5d46 <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5bca:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5bd1:	e9 70 01 00 00       	jmp    5d46 <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    5bd6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5bd9:	8b 04 85 e0 9d 01 00 	mov    0x19de0(,%eax,4),%eax
    5be0:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    5be3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5be6:	8b 04 85 60 9e 01 00 	mov    0x19e60(,%eax,4),%eax
    5bed:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    5bf0:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    5bf4:	74 15                	je     5c0b <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    5bf6:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5bf9:	83 ec 08             	sub    $0x8,%esp
    5bfc:	50                   	push   %eax
    5bfd:	ff 75 0c             	pushl  0xc(%ebp)
    5c00:	e8 64 e4 ff ff       	call   4069 <readBits>
    5c05:	83 c4 10             	add    $0x10,%esp
    5c08:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    5c0b:	8b 45 08             	mov    0x8(%ebp),%eax
    5c0e:	8b 40 04             	mov    0x4(%eax),%eax
    5c11:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    5c14:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c17:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5c1a:	76 0c                	jbe    5c28 <inflateHuffmanBlock+0x1d0>
    5c1c:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    5c23:	e9 1e 01 00 00       	jmp    5d46 <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    5c28:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c2b:	2b 45 f0             	sub    -0x10(%ebp),%eax
    5c2e:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    5c31:	8b 45 08             	mov    0x8(%ebp),%eax
    5c34:	8b 50 04             	mov    0x4(%eax),%edx
    5c37:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c3a:	01 d0                	add    %edx,%eax
    5c3c:	83 ec 08             	sub    $0x8,%esp
    5c3f:	50                   	push   %eax
    5c40:	ff 75 08             	pushl  0x8(%ebp)
    5c43:	e8 ef d8 ff ff       	call   3537 <ucvector_resize>
    5c48:	83 c4 10             	add    $0x10,%esp
    5c4b:	85 c0                	test   %eax,%eax
    5c4d:	75 0c                	jne    5c5b <inflateHuffmanBlock+0x203>
    5c4f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5c56:	e9 eb 00 00 00       	jmp    5d46 <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    5c5b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c5e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5c61:	73 6b                	jae    5cce <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    5c63:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c66:	8b 55 08             	mov    0x8(%ebp),%edx
    5c69:	8b 0a                	mov    (%edx),%ecx
    5c6b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5c6e:	01 d1                	add    %edx,%ecx
    5c70:	8b 55 08             	mov    0x8(%ebp),%edx
    5c73:	8b 1a                	mov    (%edx),%ebx
    5c75:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5c78:	01 da                	add    %ebx,%edx
    5c7a:	83 ec 04             	sub    $0x4,%esp
    5c7d:	50                   	push   %eax
    5c7e:	51                   	push   %ecx
    5c7f:	52                   	push   %edx
    5c80:	e8 96 d6 ff ff       	call   331b <lodepng_memcpy>
    5c85:	83 c4 10             	add    $0x10,%esp
        start += distance;
    5c88:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5c8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c8e:	01 d0                	add    %edx,%eax
    5c90:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    5c93:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c96:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5c99:	eb 29                	jmp    5cc4 <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    5c9b:	8b 45 08             	mov    0x8(%ebp),%eax
    5c9e:	8b 08                	mov    (%eax),%ecx
    5ca0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ca3:	8d 50 01             	lea    0x1(%eax),%edx
    5ca6:	89 55 ec             	mov    %edx,-0x14(%ebp)
    5ca9:	01 c1                	add    %eax,%ecx
    5cab:	8b 45 08             	mov    0x8(%ebp),%eax
    5cae:	8b 18                	mov    (%eax),%ebx
    5cb0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5cb3:	8d 50 01             	lea    0x1(%eax),%edx
    5cb6:	89 55 e8             	mov    %edx,-0x18(%ebp)
    5cb9:	01 d8                	add    %ebx,%eax
    5cbb:	0f b6 00             	movzbl (%eax),%eax
    5cbe:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    5cc0:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5cc4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5cc7:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    5cca:	7c cf                	jl     5c9b <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5ccc:	eb 38                	jmp    5d06 <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    5cce:	8b 45 08             	mov    0x8(%ebp),%eax
    5cd1:	8b 10                	mov    (%eax),%edx
    5cd3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5cd6:	01 c2                	add    %eax,%edx
    5cd8:	8b 45 08             	mov    0x8(%ebp),%eax
    5cdb:	8b 08                	mov    (%eax),%ecx
    5cdd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ce0:	01 c8                	add    %ecx,%eax
    5ce2:	83 ec 04             	sub    $0x4,%esp
    5ce5:	ff 75 e4             	pushl  -0x1c(%ebp)
    5ce8:	52                   	push   %edx
    5ce9:	50                   	push   %eax
    5cea:	e8 2c d6 ff ff       	call   331b <lodepng_memcpy>
    5cef:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5cf2:	eb 12                	jmp    5d06 <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    5cf4:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5cfb:	74 48                	je     5d45 <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5cfd:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5d04:	eb 40                	jmp    5d46 <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    5d06:	8b 45 0c             	mov    0xc(%ebp),%eax
    5d09:	8b 50 0c             	mov    0xc(%eax),%edx
    5d0c:	8b 45 0c             	mov    0xc(%ebp),%eax
    5d0f:	8b 40 08             	mov    0x8(%eax),%eax
    5d12:	39 c2                	cmp    %eax,%edx
    5d14:	7e 09                	jle    5d1f <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    5d16:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    5d1d:	eb 27                	jmp    5d46 <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    5d1f:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    5d23:	74 14                	je     5d39 <inflateHuffmanBlock+0x2e1>
    5d25:	8b 45 08             	mov    0x8(%ebp),%eax
    5d28:	8b 40 04             	mov    0x4(%eax),%eax
    5d2b:	3b 45 14             	cmp    0x14(%ebp),%eax
    5d2e:	7e 09                	jle    5d39 <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    5d30:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    5d37:	eb 0d                	jmp    5d46 <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5d39:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5d3d:	0f 84 7a fd ff ff    	je     5abd <inflateHuffmanBlock+0x65>
    5d43:	eb 01                	jmp    5d46 <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    5d45:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    5d46:	83 ec 0c             	sub    $0xc,%esp
    5d49:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5d4c:	50                   	push   %eax
    5d4d:	e8 ac e4 ff ff       	call   41fe <HuffmanTree_cleanup>
    5d52:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    5d55:	83 ec 0c             	sub    $0xc,%esp
    5d58:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5d5b:	50                   	push   %eax
    5d5c:	e8 9d e4 ff ff       	call   41fe <HuffmanTree_cleanup>
    5d61:	83 c4 10             	add    $0x10,%esp

  return error;
    5d64:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5d67:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5d6a:	c9                   	leave  
    5d6b:	c3                   	ret    

00005d6c <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    5d6c:	55                   	push   %ebp
    5d6d:	89 e5                	mov    %esp,%ebp
    5d6f:	53                   	push   %ebx
    5d70:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    5d73:	8b 45 0c             	mov    0xc(%ebp),%eax
    5d76:	8b 40 04             	mov    0x4(%eax),%eax
    5d79:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    5d7c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    5d83:	8b 45 0c             	mov    0xc(%ebp),%eax
    5d86:	8b 40 0c             	mov    0xc(%eax),%eax
    5d89:	83 c0 07             	add    $0x7,%eax
    5d8c:	c1 e8 03             	shr    $0x3,%eax
    5d8f:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    5d92:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5d95:	83 c0 04             	add    $0x4,%eax
    5d98:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5d9b:	7c 0a                	jl     5da7 <inflateNoCompression+0x3b>
    5d9d:	b8 34 00 00 00       	mov    $0x34,%eax
    5da2:	e9 01 01 00 00       	jmp    5ea8 <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5da7:	8b 45 0c             	mov    0xc(%ebp),%eax
    5daa:	8b 10                	mov    (%eax),%edx
    5dac:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5daf:	01 d0                	add    %edx,%eax
    5db1:	0f b6 00             	movzbl (%eax),%eax
    5db4:	0f b6 d0             	movzbl %al,%edx
    5db7:	8b 45 0c             	mov    0xc(%ebp),%eax
    5dba:	8b 00                	mov    (%eax),%eax
    5dbc:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5dbf:	83 c1 01             	add    $0x1,%ecx
    5dc2:	01 c8                	add    %ecx,%eax
    5dc4:	0f b6 00             	movzbl (%eax),%eax
    5dc7:	0f b6 c0             	movzbl %al,%eax
    5dca:	c1 e0 08             	shl    $0x8,%eax
    5dcd:	01 d0                	add    %edx,%eax
    5dcf:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5dd2:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5dd6:	8b 45 0c             	mov    0xc(%ebp),%eax
    5dd9:	8b 10                	mov    (%eax),%edx
    5ddb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5dde:	01 d0                	add    %edx,%eax
    5de0:	0f b6 00             	movzbl (%eax),%eax
    5de3:	0f b6 d0             	movzbl %al,%edx
    5de6:	8b 45 0c             	mov    0xc(%ebp),%eax
    5de9:	8b 00                	mov    (%eax),%eax
    5deb:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5dee:	83 c1 01             	add    $0x1,%ecx
    5df1:	01 c8                	add    %ecx,%eax
    5df3:	0f b6 00             	movzbl (%eax),%eax
    5df6:	0f b6 c0             	movzbl %al,%eax
    5df9:	c1 e0 08             	shl    $0x8,%eax
    5dfc:	01 d0                	add    %edx,%eax
    5dfe:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5e01:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    5e05:	8b 45 10             	mov    0x10(%ebp),%eax
    5e08:	8b 40 04             	mov    0x4(%eax),%eax
    5e0b:	85 c0                	test   %eax,%eax
    5e0d:	75 19                	jne    5e28 <inflateNoCompression+0xbc>
    5e0f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5e12:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5e15:	01 d0                	add    %edx,%eax
    5e17:	3d ff ff 00 00       	cmp    $0xffff,%eax
    5e1c:	74 0a                	je     5e28 <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    5e1e:	b8 15 00 00 00       	mov    $0x15,%eax
    5e23:	e9 80 00 00 00       	jmp    5ea8 <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    5e28:	8b 45 08             	mov    0x8(%ebp),%eax
    5e2b:	8b 40 04             	mov    0x4(%eax),%eax
    5e2e:	89 c2                	mov    %eax,%edx
    5e30:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e33:	01 d0                	add    %edx,%eax
    5e35:	50                   	push   %eax
    5e36:	ff 75 08             	pushl  0x8(%ebp)
    5e39:	e8 f9 d6 ff ff       	call   3537 <ucvector_resize>
    5e3e:	83 c4 08             	add    $0x8,%esp
    5e41:	85 c0                	test   %eax,%eax
    5e43:	75 07                	jne    5e4c <inflateNoCompression+0xe0>
    5e45:	b8 53 00 00 00       	mov    $0x53,%eax
    5e4a:	eb 5c                	jmp    5ea8 <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    5e4c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5e4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e52:	01 c2                	add    %eax,%edx
    5e54:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5e57:	39 c2                	cmp    %eax,%edx
    5e59:	76 07                	jbe    5e62 <inflateNoCompression+0xf6>
    5e5b:	b8 17 00 00 00       	mov    $0x17,%eax
    5e60:	eb 46                	jmp    5ea8 <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    5e62:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e65:	8b 55 0c             	mov    0xc(%ebp),%edx
    5e68:	8b 0a                	mov    (%edx),%ecx
    5e6a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5e6d:	01 d1                	add    %edx,%ecx
    5e6f:	8b 55 08             	mov    0x8(%ebp),%edx
    5e72:	8b 1a                	mov    (%edx),%ebx
    5e74:	8b 55 08             	mov    0x8(%ebp),%edx
    5e77:	8b 52 04             	mov    0x4(%edx),%edx
    5e7a:	2b 55 ec             	sub    -0x14(%ebp),%edx
    5e7d:	01 da                	add    %ebx,%edx
    5e7f:	50                   	push   %eax
    5e80:	51                   	push   %ecx
    5e81:	52                   	push   %edx
    5e82:	e8 94 d4 ff ff       	call   331b <lodepng_memcpy>
    5e87:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    5e8a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5e8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e90:	01 d0                	add    %edx,%eax
    5e92:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    5e95:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5e98:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    5e9f:	8b 45 0c             	mov    0xc(%ebp),%eax
    5ea2:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    5ea5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5ea8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5eab:	c9                   	leave  
    5eac:	c3                   	ret    

00005ead <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    5ead:	55                   	push   %ebp
    5eae:	89 e5                	mov    %esp,%ebp
    5eb0:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    5eb3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    5eba:	ff 75 10             	pushl  0x10(%ebp)
    5ebd:	ff 75 0c             	pushl  0xc(%ebp)
    5ec0:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5ec3:	50                   	push   %eax
    5ec4:	e8 77 db ff ff       	call   3a40 <LodePNGBitReader_init>
    5ec9:	83 c4 0c             	add    $0xc,%esp
    5ecc:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    5ecf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5ed3:	0f 84 b9 00 00 00    	je     5f92 <lodepng_inflatev+0xe5>
    5ed9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5edc:	e9 c1 00 00 00       	jmp    5fa2 <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    5ee1:	6a 03                	push   $0x3
    5ee3:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5ee6:	50                   	push   %eax
    5ee7:	e8 c5 db ff ff       	call   3ab1 <ensureBits9>
    5eec:	83 c4 08             	add    $0x8,%esp
    5eef:	85 c0                	test   %eax,%eax
    5ef1:	75 0a                	jne    5efd <lodepng_inflatev+0x50>
    5ef3:	b8 34 00 00 00       	mov    $0x34,%eax
    5ef8:	e9 a5 00 00 00       	jmp    5fa2 <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    5efd:	6a 01                	push   $0x1
    5eff:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f02:	50                   	push   %eax
    5f03:	e8 61 e1 ff ff       	call   4069 <readBits>
    5f08:	83 c4 08             	add    $0x8,%esp
    5f0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    5f0e:	6a 02                	push   $0x2
    5f10:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f13:	50                   	push   %eax
    5f14:	e8 50 e1 ff ff       	call   4069 <readBits>
    5f19:	83 c4 08             	add    $0x8,%esp
    5f1c:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    5f1f:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    5f23:	75 07                	jne    5f2c <lodepng_inflatev+0x7f>
    5f25:	b8 14 00 00 00       	mov    $0x14,%eax
    5f2a:	eb 76                	jmp    5fa2 <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    5f2c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5f30:	75 17                	jne    5f49 <lodepng_inflatev+0x9c>
    5f32:	ff 75 14             	pushl  0x14(%ebp)
    5f35:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f38:	50                   	push   %eax
    5f39:	ff 75 08             	pushl  0x8(%ebp)
    5f3c:	e8 2b fe ff ff       	call   5d6c <inflateNoCompression>
    5f41:	83 c4 0c             	add    $0xc,%esp
    5f44:	89 45 f0             	mov    %eax,-0x10(%ebp)
    5f47:	eb 1c                	jmp    5f65 <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    5f49:	8b 45 14             	mov    0x14(%ebp),%eax
    5f4c:	8b 40 08             	mov    0x8(%eax),%eax
    5f4f:	50                   	push   %eax
    5f50:	ff 75 ec             	pushl  -0x14(%ebp)
    5f53:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f56:	50                   	push   %eax
    5f57:	ff 75 08             	pushl  0x8(%ebp)
    5f5a:	e8 f9 fa ff ff       	call   5a58 <inflateHuffmanBlock>
    5f5f:	83 c4 10             	add    $0x10,%esp
    5f62:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    5f65:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5f69:	75 21                	jne    5f8c <lodepng_inflatev+0xdf>
    5f6b:	8b 45 14             	mov    0x14(%ebp),%eax
    5f6e:	8b 40 08             	mov    0x8(%eax),%eax
    5f71:	85 c0                	test   %eax,%eax
    5f73:	74 17                	je     5f8c <lodepng_inflatev+0xdf>
    5f75:	8b 45 08             	mov    0x8(%ebp),%eax
    5f78:	8b 50 04             	mov    0x4(%eax),%edx
    5f7b:	8b 45 14             	mov    0x14(%ebp),%eax
    5f7e:	8b 40 08             	mov    0x8(%eax),%eax
    5f81:	39 c2                	cmp    %eax,%edx
    5f83:	7e 07                	jle    5f8c <lodepng_inflatev+0xdf>
    5f85:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    5f8c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5f90:	75 0c                	jne    5f9e <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    5f92:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5f96:	0f 84 45 ff ff ff    	je     5ee1 <lodepng_inflatev+0x34>
    5f9c:	eb 01                	jmp    5f9f <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    5f9e:	90                   	nop
  }

  return error;
    5f9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    5fa2:	c9                   	leave  
    5fa3:	c3                   	ret    

00005fa4 <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    5fa4:	55                   	push   %ebp
    5fa5:	89 e5                	mov    %esp,%ebp
    5fa7:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    5faa:	8b 45 0c             	mov    0xc(%ebp),%eax
    5fad:	8b 08                	mov    (%eax),%ecx
    5faf:	8b 45 08             	mov    0x8(%ebp),%eax
    5fb2:	8b 10                	mov    (%eax),%edx
    5fb4:	8d 45 e8             	lea    -0x18(%ebp),%eax
    5fb7:	51                   	push   %ecx
    5fb8:	52                   	push   %edx
    5fb9:	50                   	push   %eax
    5fba:	e8 df d5 ff ff       	call   359e <ucvector_init>
    5fbf:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    5fc2:	ff 75 18             	pushl  0x18(%ebp)
    5fc5:	ff 75 14             	pushl  0x14(%ebp)
    5fc8:	ff 75 10             	pushl  0x10(%ebp)
    5fcb:	8d 45 e8             	lea    -0x18(%ebp),%eax
    5fce:	50                   	push   %eax
    5fcf:	e8 d9 fe ff ff       	call   5ead <lodepng_inflatev>
    5fd4:	83 c4 10             	add    $0x10,%esp
    5fd7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    5fda:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5fdd:	8b 45 08             	mov    0x8(%ebp),%eax
    5fe0:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    5fe2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5fe5:	8b 45 0c             	mov    0xc(%ebp),%eax
    5fe8:	89 10                	mov    %edx,(%eax)
  return error;
    5fea:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5fed:	c9                   	leave  
    5fee:	c3                   	ret    

00005fef <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    5fef:	55                   	push   %ebp
    5ff0:	89 e5                	mov    %esp,%ebp
    5ff2:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    5ff5:	8b 45 14             	mov    0x14(%ebp),%eax
    5ff8:	8b 40 10             	mov    0x10(%eax),%eax
    5ffb:	85 c0                	test   %eax,%eax
    5ffd:	74 64                	je     6063 <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    5fff:	8b 45 14             	mov    0x14(%ebp),%eax
    6002:	8b 40 10             	mov    0x10(%eax),%eax
    6005:	8b 55 08             	mov    0x8(%ebp),%edx
    6008:	8d 4a 04             	lea    0x4(%edx),%ecx
    600b:	8b 55 08             	mov    0x8(%ebp),%edx
    600e:	83 ec 0c             	sub    $0xc,%esp
    6011:	ff 75 14             	pushl  0x14(%ebp)
    6014:	ff 75 10             	pushl  0x10(%ebp)
    6017:	ff 75 0c             	pushl  0xc(%ebp)
    601a:	51                   	push   %ecx
    601b:	52                   	push   %edx
    601c:	ff d0                	call   *%eax
    601e:	83 c4 20             	add    $0x20,%esp
    6021:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    6024:	8b 45 08             	mov    0x8(%ebp),%eax
    6027:	8b 50 04             	mov    0x4(%eax),%edx
    602a:	8b 45 08             	mov    0x8(%ebp),%eax
    602d:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    6030:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6034:	74 28                	je     605e <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    6036:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    603d:	8b 45 14             	mov    0x14(%ebp),%eax
    6040:	8b 40 08             	mov    0x8(%eax),%eax
    6043:	85 c0                	test   %eax,%eax
    6045:	74 17                	je     605e <inflatev+0x6f>
    6047:	8b 45 08             	mov    0x8(%ebp),%eax
    604a:	8b 50 04             	mov    0x4(%eax),%edx
    604d:	8b 45 14             	mov    0x14(%ebp),%eax
    6050:	8b 40 08             	mov    0x8(%eax),%eax
    6053:	39 c2                	cmp    %eax,%edx
    6055:	7e 07                	jle    605e <inflatev+0x6f>
    6057:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    605e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6061:	eb 14                	jmp    6077 <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    6063:	ff 75 14             	pushl  0x14(%ebp)
    6066:	ff 75 10             	pushl  0x10(%ebp)
    6069:	ff 75 0c             	pushl  0xc(%ebp)
    606c:	ff 75 08             	pushl  0x8(%ebp)
    606f:	e8 39 fe ff ff       	call   5ead <lodepng_inflatev>
    6074:	83 c4 10             	add    $0x10,%esp
  }
}
    6077:	c9                   	leave  
    6078:	c3                   	ret    

00006079 <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    6079:	55                   	push   %ebp
    607a:	89 e5                	mov    %esp,%ebp
    607c:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    607f:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    6086:	8b 45 0c             	mov    0xc(%ebp),%eax
    6089:	83 e8 01             	sub    $0x1,%eax
    608c:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    608f:	eb 39                	jmp    60ca <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    6091:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6094:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6097:	01 d0                	add    %edx,%eax
    6099:	d1 f8                	sar    %eax
    609b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    609e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    60a1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    60a8:	8b 45 08             	mov    0x8(%ebp),%eax
    60ab:	01 d0                	add    %edx,%eax
    60ad:	8b 10                	mov    (%eax),%edx
    60af:	8b 45 10             	mov    0x10(%ebp),%eax
    60b2:	39 c2                	cmp    %eax,%edx
    60b4:	72 0b                	jb     60c1 <searchCodeIndex+0x48>
    60b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    60b9:	83 e8 01             	sub    $0x1,%eax
    60bc:	89 45 f8             	mov    %eax,-0x8(%ebp)
    60bf:	eb 09                	jmp    60ca <searchCodeIndex+0x51>
    else left = mid + 1;
    60c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    60c4:	83 c0 01             	add    $0x1,%eax
    60c7:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    60ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
    60cd:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    60d0:	7e bf                	jle    6091 <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    60d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    60d5:	3b 45 0c             	cmp    0xc(%ebp),%eax
    60d8:	7d 18                	jge    60f2 <searchCodeIndex+0x79>
    60da:	8b 45 fc             	mov    -0x4(%ebp),%eax
    60dd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    60e4:	8b 45 08             	mov    0x8(%ebp),%eax
    60e7:	01 d0                	add    %edx,%eax
    60e9:	8b 10                	mov    (%eax),%edx
    60eb:	8b 45 10             	mov    0x10(%ebp),%eax
    60ee:	39 c2                	cmp    %eax,%edx
    60f0:	76 04                	jbe    60f6 <searchCodeIndex+0x7d>
    60f2:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    60f6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    60f9:	c9                   	leave  
    60fa:	c3                   	ret    

000060fb <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    60fb:	55                   	push   %ebp
    60fc:	89 e5                	mov    %esp,%ebp
    60fe:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    6101:	ff 75 0c             	pushl  0xc(%ebp)
    6104:	6a 1d                	push   $0x1d
    6106:	68 e0 9c 01 00       	push   $0x19ce0
    610b:	e8 69 ff ff ff       	call   6079 <searchCodeIndex>
    6110:	83 c4 0c             	add    $0xc,%esp
    6113:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    6116:	8b 55 0c             	mov    0xc(%ebp),%edx
    6119:	8b 45 fc             	mov    -0x4(%ebp),%eax
    611c:	8b 04 85 e0 9c 01 00 	mov    0x19ce0(,%eax,4),%eax
    6123:	29 c2                	sub    %eax,%edx
    6125:	89 d0                	mov    %edx,%eax
    6127:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    612a:	ff 75 10             	pushl  0x10(%ebp)
    612d:	6a 1e                	push   $0x1e
    612f:	68 e0 9d 01 00       	push   $0x19de0
    6134:	e8 40 ff ff ff       	call   6079 <searchCodeIndex>
    6139:	83 c4 0c             	add    $0xc,%esp
    613c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    613f:	8b 55 10             	mov    0x10(%ebp),%edx
    6142:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6145:	8b 04 85 e0 9d 01 00 	mov    0x19de0(,%eax,4),%eax
    614c:	29 c2                	sub    %eax,%edx
    614e:	89 d0                	mov    %edx,%eax
    6150:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    6153:	8b 45 08             	mov    0x8(%ebp),%eax
    6156:	8b 40 04             	mov    0x4(%eax),%eax
    6159:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    615c:	8b 45 08             	mov    0x8(%ebp),%eax
    615f:	8b 40 04             	mov    0x4(%eax),%eax
    6162:	83 c0 04             	add    $0x4,%eax
    6165:	50                   	push   %eax
    6166:	ff 75 08             	pushl  0x8(%ebp)
    6169:	e8 f0 d2 ff ff       	call   345e <uivector_resize>
    616e:	83 c4 08             	add    $0x8,%esp
    6171:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    6174:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    6178:	74 57                	je     61d1 <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    617a:	8b 45 08             	mov    0x8(%ebp),%eax
    617d:	8b 00                	mov    (%eax),%eax
    617f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6182:	c1 e2 02             	shl    $0x2,%edx
    6185:	01 d0                	add    %edx,%eax
    6187:	8b 55 fc             	mov    -0x4(%ebp),%edx
    618a:	81 c2 01 01 00 00    	add    $0x101,%edx
    6190:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    6192:	8b 45 08             	mov    0x8(%ebp),%eax
    6195:	8b 00                	mov    (%eax),%eax
    6197:	8b 55 ec             	mov    -0x14(%ebp),%edx
    619a:	83 c2 01             	add    $0x1,%edx
    619d:	c1 e2 02             	shl    $0x2,%edx
    61a0:	01 c2                	add    %eax,%edx
    61a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    61a5:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    61a7:	8b 45 08             	mov    0x8(%ebp),%eax
    61aa:	8b 00                	mov    (%eax),%eax
    61ac:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61af:	83 c2 02             	add    $0x2,%edx
    61b2:	c1 e2 02             	shl    $0x2,%edx
    61b5:	01 c2                	add    %eax,%edx
    61b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    61ba:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    61bc:	8b 45 08             	mov    0x8(%ebp),%eax
    61bf:	8b 00                	mov    (%eax),%eax
    61c1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61c4:	83 c2 03             	add    $0x3,%edx
    61c7:	c1 e2 02             	shl    $0x2,%edx
    61ca:	01 c2                	add    %eax,%edx
    61cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    61cf:	89 02                	mov    %eax,(%edx)
  }
}
    61d1:	90                   	nop
    61d2:	c9                   	leave  
    61d3:	c3                   	ret    

000061d4 <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    61d4:	55                   	push   %ebp
    61d5:	89 e5                	mov    %esp,%ebp
    61d7:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    61da:	b8 00 00 01 00       	mov    $0x10000,%eax
    61df:	c1 e0 02             	shl    $0x2,%eax
    61e2:	83 ec 0c             	sub    $0xc,%esp
    61e5:	50                   	push   %eax
    61e6:	e8 f2 d0 ff ff       	call   32dd <lodepng_malloc>
    61eb:	83 c4 10             	add    $0x10,%esp
    61ee:	89 c2                	mov    %eax,%edx
    61f0:	8b 45 08             	mov    0x8(%ebp),%eax
    61f3:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    61f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    61f8:	c1 e0 02             	shl    $0x2,%eax
    61fb:	83 ec 0c             	sub    $0xc,%esp
    61fe:	50                   	push   %eax
    61ff:	e8 d9 d0 ff ff       	call   32dd <lodepng_malloc>
    6204:	83 c4 10             	add    $0x10,%esp
    6207:	89 c2                	mov    %eax,%edx
    6209:	8b 45 08             	mov    0x8(%ebp),%eax
    620c:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    620f:	8b 45 0c             	mov    0xc(%ebp),%eax
    6212:	01 c0                	add    %eax,%eax
    6214:	83 ec 0c             	sub    $0xc,%esp
    6217:	50                   	push   %eax
    6218:	e8 c0 d0 ff ff       	call   32dd <lodepng_malloc>
    621d:	83 c4 10             	add    $0x10,%esp
    6220:	89 c2                	mov    %eax,%edx
    6222:	8b 45 08             	mov    0x8(%ebp),%eax
    6225:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6228:	8b 45 0c             	mov    0xc(%ebp),%eax
    622b:	01 c0                	add    %eax,%eax
    622d:	83 ec 0c             	sub    $0xc,%esp
    6230:	50                   	push   %eax
    6231:	e8 a7 d0 ff ff       	call   32dd <lodepng_malloc>
    6236:	83 c4 10             	add    $0x10,%esp
    6239:	89 c2                	mov    %eax,%edx
    623b:	8b 45 08             	mov    0x8(%ebp),%eax
    623e:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    6241:	b8 02 01 00 00       	mov    $0x102,%eax
    6246:	83 c0 01             	add    $0x1,%eax
    6249:	c1 e0 02             	shl    $0x2,%eax
    624c:	83 ec 0c             	sub    $0xc,%esp
    624f:	50                   	push   %eax
    6250:	e8 88 d0 ff ff       	call   32dd <lodepng_malloc>
    6255:	83 c4 10             	add    $0x10,%esp
    6258:	89 c2                	mov    %eax,%edx
    625a:	8b 45 08             	mov    0x8(%ebp),%eax
    625d:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6260:	8b 45 0c             	mov    0xc(%ebp),%eax
    6263:	01 c0                	add    %eax,%eax
    6265:	83 ec 0c             	sub    $0xc,%esp
    6268:	50                   	push   %eax
    6269:	e8 6f d0 ff ff       	call   32dd <lodepng_malloc>
    626e:	83 c4 10             	add    $0x10,%esp
    6271:	89 c2                	mov    %eax,%edx
    6273:	8b 45 08             	mov    0x8(%ebp),%eax
    6276:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    6279:	8b 45 08             	mov    0x8(%ebp),%eax
    627c:	8b 00                	mov    (%eax),%eax
    627e:	85 c0                	test   %eax,%eax
    6280:	74 32                	je     62b4 <hash_init+0xe0>
    6282:	8b 45 08             	mov    0x8(%ebp),%eax
    6285:	8b 40 04             	mov    0x4(%eax),%eax
    6288:	85 c0                	test   %eax,%eax
    628a:	74 28                	je     62b4 <hash_init+0xe0>
    628c:	8b 45 08             	mov    0x8(%ebp),%eax
    628f:	8b 40 08             	mov    0x8(%eax),%eax
    6292:	85 c0                	test   %eax,%eax
    6294:	74 1e                	je     62b4 <hash_init+0xe0>
    6296:	8b 45 08             	mov    0x8(%ebp),%eax
    6299:	8b 40 0c             	mov    0xc(%eax),%eax
    629c:	85 c0                	test   %eax,%eax
    629e:	74 14                	je     62b4 <hash_init+0xe0>
    62a0:	8b 45 08             	mov    0x8(%ebp),%eax
    62a3:	8b 40 10             	mov    0x10(%eax),%eax
    62a6:	85 c0                	test   %eax,%eax
    62a8:	74 0a                	je     62b4 <hash_init+0xe0>
    62aa:	8b 45 08             	mov    0x8(%ebp),%eax
    62ad:	8b 40 14             	mov    0x14(%eax),%eax
    62b0:	85 c0                	test   %eax,%eax
    62b2:	75 0a                	jne    62be <hash_init+0xea>
    return 83; /*alloc fail*/
    62b4:	b8 53 00 00 00       	mov    $0x53,%eax
    62b9:	e9 d3 00 00 00       	jmp    6391 <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    62be:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    62c5:	eb 17                	jmp    62de <hash_init+0x10a>
    62c7:	8b 45 08             	mov    0x8(%ebp),%eax
    62ca:	8b 00                	mov    (%eax),%eax
    62cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    62cf:	c1 e2 02             	shl    $0x2,%edx
    62d2:	01 d0                	add    %edx,%eax
    62d4:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    62da:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    62de:	b8 00 00 01 00       	mov    $0x10000,%eax
    62e3:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    62e6:	75 df                	jne    62c7 <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    62e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    62ef:	eb 18                	jmp    6309 <hash_init+0x135>
    62f1:	8b 45 08             	mov    0x8(%ebp),%eax
    62f4:	8b 40 08             	mov    0x8(%eax),%eax
    62f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    62fa:	c1 e2 02             	shl    $0x2,%edx
    62fd:	01 d0                	add    %edx,%eax
    62ff:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6305:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6309:	8b 45 f4             	mov    -0xc(%ebp),%eax
    630c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    630f:	75 e0                	jne    62f1 <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    6311:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6318:	eb 17                	jmp    6331 <hash_init+0x15d>
    631a:	8b 45 08             	mov    0x8(%ebp),%eax
    631d:	8b 40 04             	mov    0x4(%eax),%eax
    6320:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6323:	01 d2                	add    %edx,%edx
    6325:	01 d0                	add    %edx,%eax
    6327:	8b 55 f4             	mov    -0xc(%ebp),%edx
    632a:	66 89 10             	mov    %dx,(%eax)
    632d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6331:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6334:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6337:	75 e1                	jne    631a <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    6339:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6340:	eb 18                	jmp    635a <hash_init+0x186>
    6342:	8b 45 08             	mov    0x8(%ebp),%eax
    6345:	8b 40 0c             	mov    0xc(%eax),%eax
    6348:	8b 55 f4             	mov    -0xc(%ebp),%edx
    634b:	c1 e2 02             	shl    $0x2,%edx
    634e:	01 d0                	add    %edx,%eax
    6350:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6356:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    635a:	b8 02 01 00 00       	mov    $0x102,%eax
    635f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    6362:	76 de                	jbe    6342 <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    6364:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    636b:	eb 17                	jmp    6384 <hash_init+0x1b0>
    636d:	8b 45 08             	mov    0x8(%ebp),%eax
    6370:	8b 40 10             	mov    0x10(%eax),%eax
    6373:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6376:	01 d2                	add    %edx,%edx
    6378:	01 d0                	add    %edx,%eax
    637a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    637d:	66 89 10             	mov    %dx,(%eax)
    6380:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6384:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6387:	3b 45 0c             	cmp    0xc(%ebp),%eax
    638a:	75 e1                	jne    636d <hash_init+0x199>

  return 0;
    638c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6391:	c9                   	leave  
    6392:	c3                   	ret    

00006393 <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    6393:	55                   	push   %ebp
    6394:	89 e5                	mov    %esp,%ebp
    6396:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    6399:	8b 45 08             	mov    0x8(%ebp),%eax
    639c:	8b 00                	mov    (%eax),%eax
    639e:	83 ec 0c             	sub    $0xc,%esp
    63a1:	50                   	push   %eax
    63a2:	e8 57 cf ff ff       	call   32fe <lodepng_free>
    63a7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    63aa:	8b 45 08             	mov    0x8(%ebp),%eax
    63ad:	8b 40 08             	mov    0x8(%eax),%eax
    63b0:	83 ec 0c             	sub    $0xc,%esp
    63b3:	50                   	push   %eax
    63b4:	e8 45 cf ff ff       	call   32fe <lodepng_free>
    63b9:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    63bc:	8b 45 08             	mov    0x8(%ebp),%eax
    63bf:	8b 40 04             	mov    0x4(%eax),%eax
    63c2:	83 ec 0c             	sub    $0xc,%esp
    63c5:	50                   	push   %eax
    63c6:	e8 33 cf ff ff       	call   32fe <lodepng_free>
    63cb:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    63ce:	8b 45 08             	mov    0x8(%ebp),%eax
    63d1:	8b 40 14             	mov    0x14(%eax),%eax
    63d4:	83 ec 0c             	sub    $0xc,%esp
    63d7:	50                   	push   %eax
    63d8:	e8 21 cf ff ff       	call   32fe <lodepng_free>
    63dd:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    63e0:	8b 45 08             	mov    0x8(%ebp),%eax
    63e3:	8b 40 0c             	mov    0xc(%eax),%eax
    63e6:	83 ec 0c             	sub    $0xc,%esp
    63e9:	50                   	push   %eax
    63ea:	e8 0f cf ff ff       	call   32fe <lodepng_free>
    63ef:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    63f2:	8b 45 08             	mov    0x8(%ebp),%eax
    63f5:	8b 40 10             	mov    0x10(%eax),%eax
    63f8:	83 ec 0c             	sub    $0xc,%esp
    63fb:	50                   	push   %eax
    63fc:	e8 fd ce ff ff       	call   32fe <lodepng_free>
    6401:	83 c4 10             	add    $0x10,%esp
}
    6404:	90                   	nop
    6405:	c9                   	leave  
    6406:	c3                   	ret    

00006407 <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    6407:	55                   	push   %ebp
    6408:	89 e5                	mov    %esp,%ebp
    640a:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    640d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    6414:	8b 45 10             	mov    0x10(%ebp),%eax
    6417:	83 c0 02             	add    $0x2,%eax
    641a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    641d:	7d 41                	jge    6460 <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    641f:	8b 55 10             	mov    0x10(%ebp),%edx
    6422:	8b 45 08             	mov    0x8(%ebp),%eax
    6425:	01 d0                	add    %edx,%eax
    6427:	0f b6 00             	movzbl (%eax),%eax
    642a:	0f b6 c0             	movzbl %al,%eax
    642d:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    6430:	8b 45 10             	mov    0x10(%ebp),%eax
    6433:	8d 50 01             	lea    0x1(%eax),%edx
    6436:	8b 45 08             	mov    0x8(%ebp),%eax
    6439:	01 d0                	add    %edx,%eax
    643b:	0f b6 00             	movzbl (%eax),%eax
    643e:	0f b6 c0             	movzbl %al,%eax
    6441:	c1 e0 04             	shl    $0x4,%eax
    6444:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    6447:	8b 45 10             	mov    0x10(%ebp),%eax
    644a:	8d 50 02             	lea    0x2(%eax),%edx
    644d:	8b 45 08             	mov    0x8(%ebp),%eax
    6450:	01 d0                	add    %edx,%eax
    6452:	0f b6 00             	movzbl (%eax),%eax
    6455:	0f b6 c0             	movzbl %al,%eax
    6458:	c1 e0 08             	shl    $0x8,%eax
    645b:	31 45 fc             	xor    %eax,-0x4(%ebp)
    645e:	eb 51                	jmp    64b1 <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    6460:	8b 45 10             	mov    0x10(%ebp),%eax
    6463:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6466:	7c 07                	jl     646f <getHash+0x68>
    6468:	b8 00 00 00 00       	mov    $0x0,%eax
    646d:	eb 4a                	jmp    64b9 <getHash+0xb2>
    amount = size - pos;
    646f:	8b 45 0c             	mov    0xc(%ebp),%eax
    6472:	2b 45 10             	sub    0x10(%ebp),%eax
    6475:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    6478:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    647f:	eb 28                	jmp    64a9 <getHash+0xa2>
    6481:	8b 55 10             	mov    0x10(%ebp),%edx
    6484:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6487:	01 d0                	add    %edx,%eax
    6489:	89 c2                	mov    %eax,%edx
    648b:	8b 45 08             	mov    0x8(%ebp),%eax
    648e:	01 d0                	add    %edx,%eax
    6490:	0f b6 00             	movzbl (%eax),%eax
    6493:	0f b6 d0             	movzbl %al,%edx
    6496:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6499:	c1 e0 03             	shl    $0x3,%eax
    649c:	89 c1                	mov    %eax,%ecx
    649e:	d3 e2                	shl    %cl,%edx
    64a0:	89 d0                	mov    %edx,%eax
    64a2:	31 45 fc             	xor    %eax,-0x4(%ebp)
    64a5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    64a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64ac:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    64af:	75 d0                	jne    6481 <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    64b1:	b8 ff ff 00 00       	mov    $0xffff,%eax
    64b6:	23 45 fc             	and    -0x4(%ebp),%eax
}
    64b9:	c9                   	leave  
    64ba:	c3                   	ret    

000064bb <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    64bb:	55                   	push   %ebp
    64bc:	89 e5                	mov    %esp,%ebp
    64be:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    64c1:	8b 55 10             	mov    0x10(%ebp),%edx
    64c4:	8b 45 08             	mov    0x8(%ebp),%eax
    64c7:	01 d0                	add    %edx,%eax
    64c9:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    64cc:	b8 02 01 00 00       	mov    $0x102,%eax
    64d1:	89 c2                	mov    %eax,%edx
    64d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64d6:	01 d0                	add    %edx,%eax
    64d8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    64db:	8b 55 0c             	mov    0xc(%ebp),%edx
    64de:	8b 45 08             	mov    0x8(%ebp),%eax
    64e1:	01 d0                	add    %edx,%eax
    64e3:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    64e6:	73 0b                	jae    64f3 <countZeros+0x38>
    64e8:	8b 55 0c             	mov    0xc(%ebp),%edx
    64eb:	8b 45 08             	mov    0x8(%ebp),%eax
    64ee:	01 d0                	add    %edx,%eax
    64f0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    64f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64f6:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    64f9:	eb 04                	jmp    64ff <countZeros+0x44>
    64fb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    64ff:	8b 45 08             	mov    0x8(%ebp),%eax
    6502:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6505:	74 0a                	je     6511 <countZeros+0x56>
    6507:	8b 45 08             	mov    0x8(%ebp),%eax
    650a:	0f b6 00             	movzbl (%eax),%eax
    650d:	84 c0                	test   %al,%al
    650f:	74 ea                	je     64fb <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    6511:	8b 55 08             	mov    0x8(%ebp),%edx
    6514:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6517:	29 c2                	sub    %eax,%edx
    6519:	89 d0                	mov    %edx,%eax
}
    651b:	c9                   	leave  
    651c:	c3                   	ret    

0000651d <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    651d:	55                   	push   %ebp
    651e:	89 e5                	mov    %esp,%ebp
    6520:	83 ec 04             	sub    $0x4,%esp
    6523:	8b 45 14             	mov    0x14(%ebp),%eax
    6526:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    652a:	8b 45 08             	mov    0x8(%ebp),%eax
    652d:	8b 40 08             	mov    0x8(%eax),%eax
    6530:	8b 55 0c             	mov    0xc(%ebp),%edx
    6533:	c1 e2 02             	shl    $0x2,%edx
    6536:	01 c2                	add    %eax,%edx
    6538:	8b 45 10             	mov    0x10(%ebp),%eax
    653b:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    653d:	8b 45 08             	mov    0x8(%ebp),%eax
    6540:	8b 00                	mov    (%eax),%eax
    6542:	8b 55 10             	mov    0x10(%ebp),%edx
    6545:	c1 e2 02             	shl    $0x2,%edx
    6548:	01 d0                	add    %edx,%eax
    654a:	8b 00                	mov    (%eax),%eax
    654c:	83 f8 ff             	cmp    $0xffffffff,%eax
    654f:	74 1f                	je     6570 <updateHashChain+0x53>
    6551:	8b 45 08             	mov    0x8(%ebp),%eax
    6554:	8b 40 04             	mov    0x4(%eax),%eax
    6557:	8b 55 0c             	mov    0xc(%ebp),%edx
    655a:	01 d2                	add    %edx,%edx
    655c:	01 c2                	add    %eax,%edx
    655e:	8b 45 08             	mov    0x8(%ebp),%eax
    6561:	8b 00                	mov    (%eax),%eax
    6563:	8b 4d 10             	mov    0x10(%ebp),%ecx
    6566:	c1 e1 02             	shl    $0x2,%ecx
    6569:	01 c8                	add    %ecx,%eax
    656b:	8b 00                	mov    (%eax),%eax
    656d:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    6570:	8b 45 08             	mov    0x8(%ebp),%eax
    6573:	8b 00                	mov    (%eax),%eax
    6575:	8b 55 10             	mov    0x10(%ebp),%edx
    6578:	c1 e2 02             	shl    $0x2,%edx
    657b:	01 c2                	add    %eax,%edx
    657d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6580:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    6582:	8b 45 08             	mov    0x8(%ebp),%eax
    6585:	8b 40 14             	mov    0x14(%eax),%eax
    6588:	8b 55 0c             	mov    0xc(%ebp),%edx
    658b:	01 d2                	add    %edx,%edx
    658d:	01 c2                	add    %eax,%edx
    658f:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    6593:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    6596:	8b 45 08             	mov    0x8(%ebp),%eax
    6599:	8b 40 0c             	mov    0xc(%eax),%eax
    659c:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    65a0:	c1 e2 02             	shl    $0x2,%edx
    65a3:	01 d0                	add    %edx,%eax
    65a5:	8b 00                	mov    (%eax),%eax
    65a7:	83 f8 ff             	cmp    $0xffffffff,%eax
    65aa:	74 21                	je     65cd <updateHashChain+0xb0>
    65ac:	8b 45 08             	mov    0x8(%ebp),%eax
    65af:	8b 40 10             	mov    0x10(%eax),%eax
    65b2:	8b 55 0c             	mov    0xc(%ebp),%edx
    65b5:	01 d2                	add    %edx,%edx
    65b7:	01 c2                	add    %eax,%edx
    65b9:	8b 45 08             	mov    0x8(%ebp),%eax
    65bc:	8b 40 0c             	mov    0xc(%eax),%eax
    65bf:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    65c3:	c1 e1 02             	shl    $0x2,%ecx
    65c6:	01 c8                	add    %ecx,%eax
    65c8:	8b 00                	mov    (%eax),%eax
    65ca:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    65cd:	8b 45 08             	mov    0x8(%ebp),%eax
    65d0:	8b 40 0c             	mov    0xc(%eax),%eax
    65d3:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    65d7:	c1 e2 02             	shl    $0x2,%edx
    65da:	01 c2                	add    %eax,%edx
    65dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    65df:	89 02                	mov    %eax,(%edx)
}
    65e1:	90                   	nop
    65e2:	c9                   	leave  
    65e3:	c3                   	ret    

000065e4 <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    65e4:	55                   	push   %ebp
    65e5:	89 e5                	mov    %esp,%ebp
    65e7:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    65ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    65f1:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    65f8:	77 08                	ja     6602 <encodeLZ77+0x1e>
    65fa:	8b 45 1c             	mov    0x1c(%ebp),%eax
    65fd:	c1 e8 03             	shr    $0x3,%eax
    6600:	eb 03                	jmp    6605 <encodeLZ77+0x21>
    6602:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6605:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    6608:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    660f:	76 07                	jbe    6618 <encodeLZ77+0x34>
    6611:	b8 02 01 00 00       	mov    $0x102,%eax
    6616:	eb 05                	jmp    661d <encodeLZ77+0x39>
    6618:	b8 40 00 00 00       	mov    $0x40,%eax
    661d:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    6620:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    6627:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    662e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    6635:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    663c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    6643:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    6647:	74 09                	je     6652 <encodeLZ77+0x6e>
    6649:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    6650:	76 0a                	jbe    665c <encodeLZ77+0x78>
    6652:	b8 3c 00 00 00       	mov    $0x3c,%eax
    6657:	e9 e3 04 00 00       	jmp    6b3f <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    665c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    665f:	83 e8 01             	sub    $0x1,%eax
    6662:	23 45 1c             	and    0x1c(%ebp),%eax
    6665:	85 c0                	test   %eax,%eax
    6667:	74 0a                	je     6673 <encodeLZ77+0x8f>
    6669:	b8 5a 00 00 00       	mov    $0x5a,%eax
    666e:	e9 cc 04 00 00       	jmp    6b3f <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    6673:	b8 02 01 00 00       	mov    $0x102,%eax
    6678:	39 45 24             	cmp    %eax,0x24(%ebp)
    667b:	76 08                	jbe    6685 <encodeLZ77+0xa1>
    667d:	b8 02 01 00 00       	mov    $0x102,%eax
    6682:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    6685:	8b 45 14             	mov    0x14(%ebp),%eax
    6688:	89 45 fc             	mov    %eax,-0x4(%ebp)
    668b:	e9 a0 04 00 00       	jmp    6b30 <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    6690:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6693:	8d 50 ff             	lea    -0x1(%eax),%edx
    6696:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6699:	21 d0                	and    %edx,%eax
    669b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    669e:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    66a5:	ff 75 fc             	pushl  -0x4(%ebp)
    66a8:	ff 75 18             	pushl  0x18(%ebp)
    66ab:	ff 75 10             	pushl  0x10(%ebp)
    66ae:	e8 54 fd ff ff       	call   6407 <getHash>
    66b3:	83 c4 0c             	add    $0xc,%esp
    66b6:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    66b9:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    66bd:	74 4e                	je     670d <encodeLZ77+0x129>
    66bf:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    66c3:	75 48                	jne    670d <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    66c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    66c9:	75 16                	jne    66e1 <encodeLZ77+0xfd>
    66cb:	ff 75 fc             	pushl  -0x4(%ebp)
    66ce:	ff 75 18             	pushl  0x18(%ebp)
    66d1:	ff 75 10             	pushl  0x10(%ebp)
    66d4:	e8 e2 fd ff ff       	call   64bb <countZeros>
    66d9:	83 c4 0c             	add    $0xc,%esp
    66dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    66df:	eb 35                	jmp    6716 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    66e1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    66e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    66e7:	01 c2                	add    %eax,%edx
    66e9:	8b 45 18             	mov    0x18(%ebp),%eax
    66ec:	39 c2                	cmp    %eax,%edx
    66ee:	77 17                	ja     6707 <encodeLZ77+0x123>
    66f0:	8b 55 fc             	mov    -0x4(%ebp),%edx
    66f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    66f6:	01 d0                	add    %edx,%eax
    66f8:	8d 50 ff             	lea    -0x1(%eax),%edx
    66fb:	8b 45 10             	mov    0x10(%ebp),%eax
    66fe:	01 d0                	add    %edx,%eax
    6700:	0f b6 00             	movzbl (%eax),%eax
    6703:	84 c0                	test   %al,%al
    6705:	74 0f                	je     6716 <encodeLZ77+0x132>
    6707:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    670b:	eb 09                	jmp    6716 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    670d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6714:	eb 01                	jmp    6717 <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6716:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    6717:	8b 45 f0             	mov    -0x10(%ebp),%eax
    671a:	0f b7 c0             	movzwl %ax,%eax
    671d:	50                   	push   %eax
    671e:	ff 75 b0             	pushl  -0x50(%ebp)
    6721:	ff 75 b4             	pushl  -0x4c(%ebp)
    6724:	ff 75 0c             	pushl  0xc(%ebp)
    6727:	e8 f1 fd ff ff       	call   651d <updateHashChain>
    672c:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    672f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    6736:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    673d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6740:	8b 40 04             	mov    0x4(%eax),%eax
    6743:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    6746:	01 d2                	add    %edx,%edx
    6748:	01 d0                	add    %edx,%eax
    674a:	0f b7 00             	movzwl (%eax),%eax
    674d:	0f b7 c0             	movzwl %ax,%eax
    6750:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    6753:	ba 02 01 00 00       	mov    $0x102,%edx
    6758:	8b 45 fc             	mov    -0x4(%ebp),%eax
    675b:	01 c2                	add    %eax,%edx
    675d:	8b 45 18             	mov    0x18(%ebp),%eax
    6760:	39 c2                	cmp    %eax,%edx
    6762:	0f 4e c2             	cmovle %edx,%eax
    6765:	89 c2                	mov    %eax,%edx
    6767:	8b 45 10             	mov    0x10(%ebp),%eax
    676a:	01 d0                	add    %edx,%eax
    676c:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    676f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6776:	8b 45 c8             	mov    -0x38(%ebp),%eax
    6779:	8d 50 01             	lea    0x1(%eax),%edx
    677c:	89 55 c8             	mov    %edx,-0x38(%ebp)
    677f:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    6782:	0f 83 67 01 00 00    	jae    68ef <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    6788:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    678b:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    678e:	77 08                	ja     6798 <encodeLZ77+0x1b4>
    6790:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6793:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6796:	eb 0d                	jmp    67a5 <encodeLZ77+0x1c1>
    6798:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    679b:	2b 45 cc             	sub    -0x34(%ebp),%eax
    679e:	89 c2                	mov    %eax,%edx
    67a0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    67a3:	01 d0                	add    %edx,%eax
    67a5:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    67a8:	8b 45 a8             	mov    -0x58(%ebp),%eax
    67ab:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    67ae:	0f 82 3e 01 00 00    	jb     68f2 <encodeLZ77+0x30e>
      prev_offset = current_offset;
    67b4:	8b 45 a8             	mov    -0x58(%ebp),%eax
    67b7:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    67ba:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    67be:	0f 84 a3 00 00 00    	je     6867 <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    67c4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    67c7:	8b 45 10             	mov    0x10(%ebp),%eax
    67ca:	01 d0                	add    %edx,%eax
    67cc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    67cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    67d2:	2b 45 a8             	sub    -0x58(%ebp),%eax
    67d5:	89 c2                	mov    %eax,%edx
    67d7:	8b 45 10             	mov    0x10(%ebp),%eax
    67da:	01 d0                	add    %edx,%eax
    67dc:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    67df:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    67e3:	76 3a                	jbe    681f <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    67e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    67e8:	8b 40 14             	mov    0x14(%eax),%eax
    67eb:	8b 55 cc             	mov    -0x34(%ebp),%edx
    67ee:	01 d2                	add    %edx,%edx
    67f0:	01 d0                	add    %edx,%eax
    67f2:	0f b7 00             	movzwl (%eax),%eax
    67f5:	0f b7 c0             	movzwl %ax,%eax
    67f8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    67fb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    67fe:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6801:	76 06                	jbe    6809 <encodeLZ77+0x225>
    6803:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6806:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    6809:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    680c:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    680f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6812:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6815:	eb 08                	jmp    681f <encodeLZ77+0x23b>
          ++backptr;
    6817:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    681b:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    681f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6822:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    6825:	74 10                	je     6837 <encodeLZ77+0x253>
    6827:	8b 45 d0             	mov    -0x30(%ebp),%eax
    682a:	0f b6 10             	movzbl (%eax),%edx
    682d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6830:	0f b6 00             	movzbl (%eax),%eax
    6833:	38 c2                	cmp    %al,%dl
    6835:	74 e0                	je     6817 <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    6837:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    683a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    683d:	8b 55 10             	mov    0x10(%ebp),%edx
    6840:	01 ca                	add    %ecx,%edx
    6842:	29 d0                	sub    %edx,%eax
    6844:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    6847:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    684a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    684d:	76 18                	jbe    6867 <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    684f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6852:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    6855:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6858:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    685b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    685e:	3b 45 24             	cmp    0x24(%ebp),%eax
    6861:	0f 83 8e 00 00 00    	jae    68f5 <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    6867:	8b 45 0c             	mov    0xc(%ebp),%eax
    686a:	8b 40 04             	mov    0x4(%eax),%eax
    686d:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6870:	01 d2                	add    %edx,%edx
    6872:	01 d0                	add    %edx,%eax
    6874:	0f b7 00             	movzwl (%eax),%eax
    6877:	0f b7 c0             	movzwl %ax,%eax
    687a:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    687d:	74 79                	je     68f8 <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    687f:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6883:	76 38                	jbe    68bd <encodeLZ77+0x2d9>
    6885:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6888:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    688b:	76 30                	jbe    68bd <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    688d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6890:	8b 40 10             	mov    0x10(%eax),%eax
    6893:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6896:	01 d2                	add    %edx,%edx
    6898:	01 d0                	add    %edx,%eax
    689a:	0f b7 00             	movzwl (%eax),%eax
    689d:	0f b7 c0             	movzwl %ax,%eax
    68a0:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    68a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    68a6:	8b 40 14             	mov    0x14(%eax),%eax
    68a9:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68ac:	01 d2                	add    %edx,%edx
    68ae:	01 d0                	add    %edx,%eax
    68b0:	0f b7 00             	movzwl (%eax),%eax
    68b3:	0f b7 c0             	movzwl %ax,%eax
    68b6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    68b9:	74 2f                	je     68ea <encodeLZ77+0x306>
    68bb:	eb 3f                	jmp    68fc <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    68bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    68c0:	8b 40 04             	mov    0x4(%eax),%eax
    68c3:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68c6:	01 d2                	add    %edx,%edx
    68c8:	01 d0                	add    %edx,%eax
    68ca:	0f b7 00             	movzwl (%eax),%eax
    68cd:	0f b7 c0             	movzwl %ax,%eax
    68d0:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    68d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    68d6:	8b 40 08             	mov    0x8(%eax),%eax
    68d9:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68dc:	c1 e2 02             	shl    $0x2,%edx
    68df:	01 d0                	add    %edx,%eax
    68e1:	8b 10                	mov    (%eax),%edx
    68e3:	8b 45 b0             	mov    -0x50(%ebp),%eax
    68e6:	39 c2                	cmp    %eax,%edx
    68e8:	75 11                	jne    68fb <encodeLZ77+0x317>
      }
    }
    68ea:	e9 87 fe ff ff       	jmp    6776 <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    68ef:	90                   	nop
    68f0:	eb 0a                	jmp    68fc <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    68f2:	90                   	nop
    68f3:	eb 07                	jmp    68fc <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    68f5:	90                   	nop
    68f6:	eb 04                	jmp    68fc <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    68f8:	90                   	nop
    68f9:	eb 01                	jmp    68fc <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    68fb:	90                   	nop
      }
    }

    if(lazymatching) {
    68fc:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    6900:	0f 84 c8 00 00 00    	je     69ce <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    6906:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    690a:	75 30                	jne    693c <encodeLZ77+0x358>
    690c:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6910:	76 2a                	jbe    693c <encodeLZ77+0x358>
    6912:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6915:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    6918:	77 22                	ja     693c <encodeLZ77+0x358>
    691a:	b8 02 01 00 00       	mov    $0x102,%eax
    691f:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6922:	73 18                	jae    693c <encodeLZ77+0x358>
        lazy = 1;
    6924:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    692b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    692e:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    6931:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6934:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    6937:	e9 f0 01 00 00       	jmp    6b2c <encodeLZ77+0x548>
      }
      if(lazy) {
    693c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6940:	0f 84 88 00 00 00    	je     69ce <encodeLZ77+0x3ea>
        lazy = 0;
    6946:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    694d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    6951:	75 0c                	jne    695f <encodeLZ77+0x37b>
    6953:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    695a:	e9 dd 01 00 00       	jmp    6b3c <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    695f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6962:	83 c0 01             	add    $0x1,%eax
    6965:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6968:	73 2d                	jae    6997 <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    696a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    696d:	8d 50 ff             	lea    -0x1(%eax),%edx
    6970:	8b 45 10             	mov    0x10(%ebp),%eax
    6973:	01 d0                	add    %edx,%eax
    6975:	0f b6 00             	movzbl (%eax),%eax
    6978:	0f b6 c0             	movzbl %al,%eax
    697b:	50                   	push   %eax
    697c:	ff 75 08             	pushl  0x8(%ebp)
    697f:	e8 6f cb ff ff       	call   34f3 <uivector_push_back>
    6984:	83 c4 08             	add    $0x8,%esp
    6987:	85 c0                	test   %eax,%eax
    6989:	75 43                	jne    69ce <encodeLZ77+0x3ea>
    698b:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6992:	e9 a5 01 00 00       	jmp    6b3c <encodeLZ77+0x558>
        } else {
          length = lazylength;
    6997:	8b 45 e0             	mov    -0x20(%ebp),%eax
    699a:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    699d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    69a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    69a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    69a6:	8b 00                	mov    (%eax),%eax
    69a8:	8b 55 b0             	mov    -0x50(%ebp),%edx
    69ab:	c1 e2 02             	shl    $0x2,%edx
    69ae:	01 d0                	add    %edx,%eax
    69b0:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    69b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    69b9:	8b 40 0c             	mov    0xc(%eax),%eax
    69bc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    69bf:	c1 e2 02             	shl    $0x2,%edx
    69c2:	01 d0                	add    %edx,%eax
    69c4:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    69ca:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    69ce:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    69d2:	76 14                	jbe    69e8 <encodeLZ77+0x404>
    69d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    69d7:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    69da:	76 0c                	jbe    69e8 <encodeLZ77+0x404>
    69dc:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    69e3:	e9 54 01 00 00       	jmp    6b3c <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    69e8:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    69ec:	77 2e                	ja     6a1c <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    69ee:	8b 55 fc             	mov    -0x4(%ebp),%edx
    69f1:	8b 45 10             	mov    0x10(%ebp),%eax
    69f4:	01 d0                	add    %edx,%eax
    69f6:	0f b6 00             	movzbl (%eax),%eax
    69f9:	0f b6 c0             	movzbl %al,%eax
    69fc:	50                   	push   %eax
    69fd:	ff 75 08             	pushl  0x8(%ebp)
    6a00:	e8 ee ca ff ff       	call   34f3 <uivector_push_back>
    6a05:	83 c4 08             	add    $0x8,%esp
    6a08:	85 c0                	test   %eax,%eax
    6a0a:	0f 85 1c 01 00 00    	jne    6b2c <encodeLZ77+0x548>
    6a10:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6a17:	e9 20 01 00 00       	jmp    6b3c <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    6a1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6a1f:	3b 45 20             	cmp    0x20(%ebp),%eax
    6a22:	72 0f                	jb     6a33 <encodeLZ77+0x44f>
    6a24:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    6a28:	75 37                	jne    6a61 <encodeLZ77+0x47d>
    6a2a:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    6a31:	76 2e                	jbe    6a61 <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6a33:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6a36:	8b 45 10             	mov    0x10(%ebp),%eax
    6a39:	01 d0                	add    %edx,%eax
    6a3b:	0f b6 00             	movzbl (%eax),%eax
    6a3e:	0f b6 c0             	movzbl %al,%eax
    6a41:	50                   	push   %eax
    6a42:	ff 75 08             	pushl  0x8(%ebp)
    6a45:	e8 a9 ca ff ff       	call   34f3 <uivector_push_back>
    6a4a:	83 c4 08             	add    $0x8,%esp
    6a4d:	85 c0                	test   %eax,%eax
    6a4f:	0f 85 d7 00 00 00    	jne    6b2c <encodeLZ77+0x548>
    6a55:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6a5c:	e9 db 00 00 00       	jmp    6b3c <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    6a61:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6a64:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6a67:	52                   	push   %edx
    6a68:	50                   	push   %eax
    6a69:	ff 75 08             	pushl  0x8(%ebp)
    6a6c:	e8 8a f6 ff ff       	call   60fb <addLengthDistance>
    6a71:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    6a74:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    6a7b:	e9 a0 00 00 00       	jmp    6b20 <encodeLZ77+0x53c>
        ++pos;
    6a80:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    6a84:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6a87:	8d 50 ff             	lea    -0x1(%eax),%edx
    6a8a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6a8d:	21 d0                	and    %edx,%eax
    6a8f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    6a92:	ff 75 fc             	pushl  -0x4(%ebp)
    6a95:	ff 75 18             	pushl  0x18(%ebp)
    6a98:	ff 75 10             	pushl  0x10(%ebp)
    6a9b:	e8 67 f9 ff ff       	call   6407 <getHash>
    6aa0:	83 c4 0c             	add    $0xc,%esp
    6aa3:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    6aa6:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6aaa:	74 4e                	je     6afa <encodeLZ77+0x516>
    6aac:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6ab0:	75 48                	jne    6afa <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6ab2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6ab6:	75 16                	jne    6ace <encodeLZ77+0x4ea>
    6ab8:	ff 75 fc             	pushl  -0x4(%ebp)
    6abb:	ff 75 18             	pushl  0x18(%ebp)
    6abe:	ff 75 10             	pushl  0x10(%ebp)
    6ac1:	e8 f5 f9 ff ff       	call   64bb <countZeros>
    6ac6:	83 c4 0c             	add    $0xc,%esp
    6ac9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6acc:	eb 35                	jmp    6b03 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6ace:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6ad1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ad4:	01 c2                	add    %eax,%edx
    6ad6:	8b 45 18             	mov    0x18(%ebp),%eax
    6ad9:	39 c2                	cmp    %eax,%edx
    6adb:	77 17                	ja     6af4 <encodeLZ77+0x510>
    6add:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6ae0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ae3:	01 d0                	add    %edx,%eax
    6ae5:	8d 50 ff             	lea    -0x1(%eax),%edx
    6ae8:	8b 45 10             	mov    0x10(%ebp),%eax
    6aeb:	01 d0                	add    %edx,%eax
    6aed:	0f b6 00             	movzbl (%eax),%eax
    6af0:	84 c0                	test   %al,%al
    6af2:	74 0f                	je     6b03 <encodeLZ77+0x51f>
    6af4:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6af8:	eb 09                	jmp    6b03 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    6afa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6b01:	eb 01                	jmp    6b04 <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6b03:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    6b04:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b07:	0f b7 c0             	movzwl %ax,%eax
    6b0a:	50                   	push   %eax
    6b0b:	ff 75 b0             	pushl  -0x50(%ebp)
    6b0e:	ff 75 b4             	pushl  -0x4c(%ebp)
    6b11:	ff 75 0c             	pushl  0xc(%ebp)
    6b14:	e8 04 fa ff ff       	call   651d <updateHashChain>
    6b19:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    6b1c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6b20:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6b23:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6b26:	0f 82 54 ff ff ff    	jb     6a80 <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    6b2c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6b30:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6b33:	3b 45 18             	cmp    0x18(%ebp),%eax
    6b36:	0f 8c 54 fb ff ff    	jl     6690 <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    6b3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6b3f:	c9                   	leave  
    6b40:	c3                   	ret    

00006b41 <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    6b41:	55                   	push   %ebp
    6b42:	89 e5                	mov    %esp,%ebp
    6b44:	53                   	push   %ebx
    6b45:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    6b48:	8b 45 10             	mov    0x10(%ebp),%eax
    6b4b:	05 fe ff 00 00       	add    $0xfffe,%eax
    6b50:	ba 01 80 00 80       	mov    $0x80008001,%edx
    6b55:	f7 e2                	mul    %edx
    6b57:	89 d0                	mov    %edx,%eax
    6b59:	c1 e8 0f             	shr    $0xf,%eax
    6b5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    6b5f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    6b66:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6b6d:	e9 1b 01 00 00       	jmp    6c8d <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    6b72:	8b 45 08             	mov    0x8(%ebp),%eax
    6b75:	8b 40 04             	mov    0x4(%eax),%eax
    6b78:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    6b7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6b7e:	83 e8 01             	sub    $0x1,%eax
    6b81:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6b84:	0f 94 c0             	sete   %al
    6b87:	0f b6 c0             	movzbl %al,%eax
    6b8a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    6b8d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    6b94:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    6b9b:	8b 45 10             	mov    0x10(%ebp),%eax
    6b9e:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6ba1:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    6ba6:	77 09                	ja     6bb1 <deflateNoCompression+0x70>
    6ba8:	8b 45 10             	mov    0x10(%ebp),%eax
    6bab:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6bae:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    6bb1:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6bb6:	2b 45 f0             	sub    -0x10(%ebp),%eax
    6bb9:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    6bbc:	8b 45 08             	mov    0x8(%ebp),%eax
    6bbf:	8b 40 04             	mov    0x4(%eax),%eax
    6bc2:	89 c2                	mov    %eax,%edx
    6bc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6bc7:	01 d0                	add    %edx,%eax
    6bc9:	83 c0 05             	add    $0x5,%eax
    6bcc:	50                   	push   %eax
    6bcd:	ff 75 08             	pushl  0x8(%ebp)
    6bd0:	e8 62 c9 ff ff       	call   3537 <ucvector_resize>
    6bd5:	83 c4 08             	add    $0x8,%esp
    6bd8:	85 c0                	test   %eax,%eax
    6bda:	75 0a                	jne    6be6 <deflateNoCompression+0xa5>
    6bdc:	b8 53 00 00 00       	mov    $0x53,%eax
    6be1:	e9 b8 00 00 00       	jmp    6c9e <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    6be6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6be9:	89 c2                	mov    %eax,%edx
    6beb:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6bee:	83 e0 01             	and    $0x1,%eax
    6bf1:	01 c0                	add    %eax,%eax
    6bf3:	01 c2                	add    %eax,%edx
    6bf5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6bf8:	83 e0 02             	and    $0x2,%eax
    6bfb:	01 c0                	add    %eax,%eax
    6bfd:	01 d0                	add    %edx,%eax
    6bff:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    6c02:	8b 45 08             	mov    0x8(%ebp),%eax
    6c05:	8b 10                	mov    (%eax),%edx
    6c07:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6c0a:	01 c2                	add    %eax,%edx
    6c0c:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    6c10:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    6c12:	8b 45 08             	mov    0x8(%ebp),%eax
    6c15:	8b 00                	mov    (%eax),%eax
    6c17:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c1a:	83 c2 01             	add    $0x1,%edx
    6c1d:	01 d0                	add    %edx,%eax
    6c1f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6c22:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    6c24:	8b 45 08             	mov    0x8(%ebp),%eax
    6c27:	8b 00                	mov    (%eax),%eax
    6c29:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c2c:	83 c2 02             	add    $0x2,%edx
    6c2f:	01 d0                	add    %edx,%eax
    6c31:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6c34:	c1 ea 08             	shr    $0x8,%edx
    6c37:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    6c39:	8b 45 08             	mov    0x8(%ebp),%eax
    6c3c:	8b 00                	mov    (%eax),%eax
    6c3e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c41:	83 c2 03             	add    $0x3,%edx
    6c44:	01 d0                	add    %edx,%eax
    6c46:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6c49:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    6c4b:	8b 45 08             	mov    0x8(%ebp),%eax
    6c4e:	8b 00                	mov    (%eax),%eax
    6c50:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c53:	83 c2 04             	add    $0x4,%edx
    6c56:	01 d0                	add    %edx,%eax
    6c58:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6c5b:	c1 ea 08             	shr    $0x8,%edx
    6c5e:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    6c60:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c63:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    6c66:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6c69:	01 d1                	add    %edx,%ecx
    6c6b:	8b 55 08             	mov    0x8(%ebp),%edx
    6c6e:	8b 12                	mov    (%edx),%edx
    6c70:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6c73:	83 c3 05             	add    $0x5,%ebx
    6c76:	01 da                	add    %ebx,%edx
    6c78:	50                   	push   %eax
    6c79:	51                   	push   %ecx
    6c7a:	52                   	push   %edx
    6c7b:	e8 9b c6 ff ff       	call   331b <lodepng_memcpy>
    6c80:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    6c83:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c86:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    6c89:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6c8d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6c90:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6c93:	0f 85 d9 fe ff ff    	jne    6b72 <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    6c99:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6c9e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6ca1:	c9                   	leave  
    6ca2:	c3                   	ret    

00006ca3 <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    6ca3:	55                   	push   %ebp
    6ca4:	89 e5                	mov    %esp,%ebp
    6ca6:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    6ca9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    6cb0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    6cb7:	e9 10 01 00 00       	jmp    6dcc <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    6cbc:	8b 45 0c             	mov    0xc(%ebp),%eax
    6cbf:	8b 00                	mov    (%eax),%eax
    6cc1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6cc4:	c1 e2 02             	shl    $0x2,%edx
    6cc7:	01 d0                	add    %edx,%eax
    6cc9:	8b 00                	mov    (%eax),%eax
    6ccb:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    6cce:	8b 45 10             	mov    0x10(%ebp),%eax
    6cd1:	8b 40 04             	mov    0x4(%eax),%eax
    6cd4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6cd7:	c1 e2 02             	shl    $0x2,%edx
    6cda:	01 d0                	add    %edx,%eax
    6cdc:	8b 00                	mov    (%eax),%eax
    6cde:	89 c1                	mov    %eax,%ecx
    6ce0:	8b 45 10             	mov    0x10(%ebp),%eax
    6ce3:	8b 00                	mov    (%eax),%eax
    6ce5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6ce8:	c1 e2 02             	shl    $0x2,%edx
    6ceb:	01 d0                	add    %edx,%eax
    6ced:	8b 00                	mov    (%eax),%eax
    6cef:	51                   	push   %ecx
    6cf0:	50                   	push   %eax
    6cf1:	ff 75 08             	pushl  0x8(%ebp)
    6cf4:	e8 60 cc ff ff       	call   3959 <writeBitsReversed>
    6cf9:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    6cfc:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    6d03:	0f 86 bf 00 00 00    	jbe    6dc8 <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    6d09:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6d0c:	2d 01 01 00 00       	sub    $0x101,%eax
    6d11:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    6d14:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6d17:	8b 04 85 60 9d 01 00 	mov    0x19d60(,%eax,4),%eax
    6d1e:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    6d21:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d24:	8b 00                	mov    (%eax),%eax
    6d26:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6d2a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d2d:	c1 e2 02             	shl    $0x2,%edx
    6d30:	01 d0                	add    %edx,%eax
    6d32:	8b 00                	mov    (%eax),%eax
    6d34:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    6d37:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d3a:	8b 00                	mov    (%eax),%eax
    6d3c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6d40:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d43:	c1 e2 02             	shl    $0x2,%edx
    6d46:	01 d0                	add    %edx,%eax
    6d48:	8b 00                	mov    (%eax),%eax
    6d4a:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    6d4d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6d50:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    6d53:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6d56:	8b 04 85 60 9e 01 00 	mov    0x19e60(,%eax,4),%eax
    6d5d:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    6d60:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d63:	8b 00                	mov    (%eax),%eax
    6d65:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6d69:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d6c:	c1 e2 02             	shl    $0x2,%edx
    6d6f:	01 d0                	add    %edx,%eax
    6d71:	8b 00                	mov    (%eax),%eax
    6d73:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    6d76:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6d79:	50                   	push   %eax
    6d7a:	ff 75 ec             	pushl  -0x14(%ebp)
    6d7d:	ff 75 08             	pushl  0x8(%ebp)
    6d80:	e8 40 ca ff ff       	call   37c5 <writeBits>
    6d85:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    6d88:	8b 45 14             	mov    0x14(%ebp),%eax
    6d8b:	8b 40 04             	mov    0x4(%eax),%eax
    6d8e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6d91:	c1 e2 02             	shl    $0x2,%edx
    6d94:	01 d0                	add    %edx,%eax
    6d96:	8b 00                	mov    (%eax),%eax
    6d98:	89 c1                	mov    %eax,%ecx
    6d9a:	8b 45 14             	mov    0x14(%ebp),%eax
    6d9d:	8b 00                	mov    (%eax),%eax
    6d9f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6da2:	c1 e2 02             	shl    $0x2,%edx
    6da5:	01 d0                	add    %edx,%eax
    6da7:	8b 00                	mov    (%eax),%eax
    6da9:	51                   	push   %ecx
    6daa:	50                   	push   %eax
    6dab:	ff 75 08             	pushl  0x8(%ebp)
    6dae:	e8 a6 cb ff ff       	call   3959 <writeBitsReversed>
    6db3:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    6db6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6db9:	50                   	push   %eax
    6dba:	ff 75 dc             	pushl  -0x24(%ebp)
    6dbd:	ff 75 08             	pushl  0x8(%ebp)
    6dc0:	e8 00 ca ff ff       	call   37c5 <writeBits>
    6dc5:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    6dc8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6dcc:	8b 45 0c             	mov    0xc(%ebp),%eax
    6dcf:	8b 40 04             	mov    0x4(%eax),%eax
    6dd2:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6dd5:	0f 85 e1 fe ff ff    	jne    6cbc <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    6ddb:	90                   	nop
    6ddc:	c9                   	leave  
    6ddd:	c3                   	ret    

00006dde <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    6dde:	55                   	push   %ebp
    6ddf:	89 e5                	mov    %esp,%ebp
    6de1:	53                   	push   %ebx
    6de2:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    6de8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    6def:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    6df6:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    6dfd:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    6e04:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    6e0b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    6e12:	8b 45 18             	mov    0x18(%ebp),%eax
    6e15:	2b 45 14             	sub    0x14(%ebp),%eax
    6e18:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    6e1b:	8b 45 20             	mov    0x20(%ebp),%eax
    6e1e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    6e21:	8d 45 90             	lea    -0x70(%ebp),%eax
    6e24:	50                   	push   %eax
    6e25:	e8 a4 c6 ff ff       	call   34ce <uivector_init>
    6e2a:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    6e2d:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    6e33:	50                   	push   %eax
    6e34:	e8 98 d3 ff ff       	call   41d1 <HuffmanTree_init>
    6e39:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    6e3c:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    6e42:	50                   	push   %eax
    6e43:	e8 89 d3 ff ff       	call   41d1 <HuffmanTree_init>
    6e48:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    6e4b:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    6e51:	50                   	push   %eax
    6e52:	e8 7a d3 ff ff       	call   41d1 <HuffmanTree_init>
    6e57:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    6e5a:	83 ec 0c             	sub    $0xc,%esp
    6e5d:	68 78 04 00 00       	push   $0x478
    6e62:	e8 76 c4 ff ff       	call   32dd <lodepng_malloc>
    6e67:	83 c4 10             	add    $0x10,%esp
    6e6a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    6e6d:	83 ec 0c             	sub    $0xc,%esp
    6e70:	6a 78                	push   $0x78
    6e72:	e8 66 c4 ff ff       	call   32dd <lodepng_malloc>
    6e77:	83 c4 10             	add    $0x10,%esp
    6e7a:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6e7d:	83 ec 0c             	sub    $0xc,%esp
    6e80:	6a 4c                	push   $0x4c
    6e82:	e8 56 c4 ff ff       	call   32dd <lodepng_malloc>
    6e87:	83 c4 10             	add    $0x10,%esp
    6e8a:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    6e8d:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    6e91:	74 0c                	je     6e9f <deflateDynamic+0xc1>
    6e93:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    6e97:	74 06                	je     6e9f <deflateDynamic+0xc1>
    6e99:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    6e9d:	75 07                	jne    6ea6 <deflateDynamic+0xc8>
    6e9f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    6ea6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6eaa:	0f 85 f6 07 00 00    	jne    76a6 <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    6eb0:	83 ec 04             	sub    $0x4,%esp
    6eb3:	68 78 04 00 00       	push   $0x478
    6eb8:	6a 00                	push   $0x0
    6eba:	ff 75 d4             	pushl  -0x2c(%ebp)
    6ebd:	e8 8c c4 ff ff       	call   334e <lodepng_memset>
    6ec2:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    6ec5:	83 ec 04             	sub    $0x4,%esp
    6ec8:	6a 78                	push   $0x78
    6eca:	6a 00                	push   $0x0
    6ecc:	ff 75 d0             	pushl  -0x30(%ebp)
    6ecf:	e8 7a c4 ff ff       	call   334e <lodepng_memset>
    6ed4:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6ed7:	83 ec 04             	sub    $0x4,%esp
    6eda:	6a 4c                	push   $0x4c
    6edc:	6a 00                	push   $0x0
    6ede:	ff 75 cc             	pushl  -0x34(%ebp)
    6ee1:	e8 68 c4 ff ff       	call   334e <lodepng_memset>
    6ee6:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    6ee9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6eec:	8b 40 04             	mov    0x4(%eax),%eax
    6eef:	85 c0                	test   %eax,%eax
    6ef1:	74 45                	je     6f38 <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    6ef3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6ef6:	8b 58 14             	mov    0x14(%eax),%ebx
    6ef9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6efc:	8b 48 10             	mov    0x10(%eax),%ecx
    6eff:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f02:	8b 50 0c             	mov    0xc(%eax),%edx
    6f05:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f08:	8b 40 08             	mov    0x8(%eax),%eax
    6f0b:	83 ec 0c             	sub    $0xc,%esp
    6f0e:	53                   	push   %ebx
    6f0f:	51                   	push   %ecx
    6f10:	52                   	push   %edx
    6f11:	50                   	push   %eax
    6f12:	ff 75 18             	pushl  0x18(%ebp)
    6f15:	ff 75 14             	pushl  0x14(%ebp)
    6f18:	ff 75 10             	pushl  0x10(%ebp)
    6f1b:	ff 75 0c             	pushl  0xc(%ebp)
    6f1e:	8d 45 90             	lea    -0x70(%ebp),%eax
    6f21:	50                   	push   %eax
    6f22:	e8 bd f6 ff ff       	call   65e4 <encodeLZ77>
    6f27:	83 c4 30             	add    $0x30,%esp
    6f2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    6f2d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6f31:	74 59                	je     6f8c <deflateDynamic+0x1ae>
    6f33:	e9 6e 07 00 00       	jmp    76a6 <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    6f38:	83 ec 08             	sub    $0x8,%esp
    6f3b:	ff 75 c8             	pushl  -0x38(%ebp)
    6f3e:	8d 45 90             	lea    -0x70(%ebp),%eax
    6f41:	50                   	push   %eax
    6f42:	e8 17 c5 ff ff       	call   345e <uivector_resize>
    6f47:	83 c4 10             	add    $0x10,%esp
    6f4a:	85 c0                	test   %eax,%eax
    6f4c:	75 0c                	jne    6f5a <deflateDynamic+0x17c>
    6f4e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6f55:	e9 4c 07 00 00       	jmp    76a6 <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    6f5a:	8b 45 14             	mov    0x14(%ebp),%eax
    6f5d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    6f60:	eb 22                	jmp    6f84 <deflateDynamic+0x1a6>
    6f62:	8b 55 90             	mov    -0x70(%ebp),%edx
    6f65:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6f68:	2b 45 14             	sub    0x14(%ebp),%eax
    6f6b:	c1 e0 02             	shl    $0x2,%eax
    6f6e:	01 c2                	add    %eax,%edx
    6f70:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    6f73:	8b 45 10             	mov    0x10(%ebp),%eax
    6f76:	01 c8                	add    %ecx,%eax
    6f78:	0f b6 00             	movzbl (%eax),%eax
    6f7b:	0f b6 c0             	movzbl %al,%eax
    6f7e:	89 02                	mov    %eax,(%edx)
    6f80:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    6f84:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6f87:	3b 45 18             	cmp    0x18(%ebp),%eax
    6f8a:	7c d6                	jl     6f62 <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    6f8c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    6f93:	eb 60                	jmp    6ff5 <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    6f95:	8b 45 90             	mov    -0x70(%ebp),%eax
    6f98:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6f9b:	c1 e2 02             	shl    $0x2,%edx
    6f9e:	01 d0                	add    %edx,%eax
    6fa0:	8b 00                	mov    (%eax),%eax
    6fa2:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    6fa5:	8b 45 c0             	mov    -0x40(%ebp),%eax
    6fa8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6faf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6fb2:	01 d0                	add    %edx,%eax
    6fb4:	8b 10                	mov    (%eax),%edx
    6fb6:	83 c2 01             	add    $0x1,%edx
    6fb9:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    6fbb:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    6fc2:	76 2d                	jbe    6ff1 <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    6fc4:	8b 45 90             	mov    -0x70(%ebp),%eax
    6fc7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6fca:	83 c2 02             	add    $0x2,%edx
    6fcd:	c1 e2 02             	shl    $0x2,%edx
    6fd0:	01 d0                	add    %edx,%eax
    6fd2:	8b 00                	mov    (%eax),%eax
    6fd4:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    6fd7:	8b 45 bc             	mov    -0x44(%ebp),%eax
    6fda:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6fe1:	8b 45 d0             	mov    -0x30(%ebp),%eax
    6fe4:	01 d0                	add    %edx,%eax
    6fe6:	8b 10                	mov    (%eax),%edx
    6fe8:	83 c2 01             	add    $0x1,%edx
    6feb:	89 10                	mov    %edx,(%eax)
        i += 3;
    6fed:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    6ff1:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    6ff5:	8b 45 94             	mov    -0x6c(%ebp),%eax
    6ff8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6ffb:	75 98                	jne    6f95 <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    6ffd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7000:	05 00 04 00 00       	add    $0x400,%eax
    7005:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    700b:	83 ec 0c             	sub    $0xc,%esp
    700e:	6a 0f                	push   $0xf
    7010:	68 1e 01 00 00       	push   $0x11e
    7015:	68 01 01 00 00       	push   $0x101
    701a:	ff 75 d4             	pushl  -0x2c(%ebp)
    701d:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7023:	50                   	push   %eax
    7024:	e8 e0 e1 ff ff       	call   5209 <HuffmanTree_makeFromFrequencies>
    7029:	83 c4 20             	add    $0x20,%esp
    702c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    702f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7033:	0f 85 66 06 00 00    	jne    769f <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    7039:	83 ec 0c             	sub    $0xc,%esp
    703c:	6a 0f                	push   $0xf
    703e:	6a 1e                	push   $0x1e
    7040:	6a 02                	push   $0x2
    7042:	ff 75 d0             	pushl  -0x30(%ebp)
    7045:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    704b:	50                   	push   %eax
    704c:	e8 b8 e1 ff ff       	call   5209 <HuffmanTree_makeFromFrequencies>
    7051:	83 c4 20             	add    $0x20,%esp
    7054:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7057:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    705b:	0f 85 41 06 00 00    	jne    76a2 <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    7061:	8b 45 84             	mov    -0x7c(%ebp),%eax
    7064:	ba 1e 01 00 00       	mov    $0x11e,%edx
    7069:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    706e:	0f 47 c2             	cmova  %edx,%eax
    7071:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    7074:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    707a:	ba 1e 00 00 00       	mov    $0x1e,%edx
    707f:	83 f8 1e             	cmp    $0x1e,%eax
    7082:	0f 47 c2             	cmova  %edx,%eax
    7085:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    7088:	8b 55 b8             	mov    -0x48(%ebp),%edx
    708b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    708e:	01 d0                	add    %edx,%eax
    7090:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    7093:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7096:	c1 e0 02             	shl    $0x2,%eax
    7099:	83 ec 0c             	sub    $0xc,%esp
    709c:	50                   	push   %eax
    709d:	e8 3b c2 ff ff       	call   32dd <lodepng_malloc>
    70a2:	83 c4 10             	add    $0x10,%esp
    70a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    70a8:	8b 45 b0             	mov    -0x50(%ebp),%eax
    70ab:	c1 e0 02             	shl    $0x2,%eax
    70ae:	83 ec 0c             	sub    $0xc,%esp
    70b1:	50                   	push   %eax
    70b2:	e8 26 c2 ff ff       	call   32dd <lodepng_malloc>
    70b7:	83 c4 10             	add    $0x10,%esp
    70ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    70bd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    70c1:	74 06                	je     70c9 <deflateDynamic+0x2eb>
    70c3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    70c7:	75 0c                	jne    70d5 <deflateDynamic+0x2f7>
    70c9:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    70d0:	e9 d1 05 00 00       	jmp    76a6 <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    70d5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    70dc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    70e3:	eb 25                	jmp    710a <deflateDynamic+0x32c>
    70e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    70e8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    70ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
    70f2:	01 c2                	add    %eax,%edx
    70f4:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    70fa:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    70fd:	c1 e1 02             	shl    $0x2,%ecx
    7100:	01 c8                	add    %ecx,%eax
    7102:	8b 00                	mov    (%eax),%eax
    7104:	89 02                	mov    %eax,(%edx)
    7106:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    710a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    710d:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    7110:	75 d3                	jne    70e5 <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    7112:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7119:	eb 2a                	jmp    7145 <deflateDynamic+0x367>
    711b:	8b 55 b8             	mov    -0x48(%ebp),%edx
    711e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7121:	01 d0                	add    %edx,%eax
    7123:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    712a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    712d:	01 c2                	add    %eax,%edx
    712f:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    7135:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7138:	c1 e1 02             	shl    $0x2,%ecx
    713b:	01 c8                	add    %ecx,%eax
    713d:	8b 00                	mov    (%eax),%eax
    713f:	89 02                	mov    %eax,(%edx)
    7141:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7145:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7148:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    714b:	75 ce                	jne    711b <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    714d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7154:	e9 3b 02 00 00       	jmp    7394 <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    7159:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    7160:	eb 04                	jmp    7166 <deflateDynamic+0x388>
    7162:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    7166:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7169:	8b 45 dc             	mov    -0x24(%ebp),%eax
    716c:	01 d0                	add    %edx,%eax
    716e:	8d 50 01             	lea    0x1(%eax),%edx
    7171:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7174:	39 c2                	cmp    %eax,%edx
    7176:	73 2e                	jae    71a6 <deflateDynamic+0x3c8>
    7178:	8b 55 e8             	mov    -0x18(%ebp),%edx
    717b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    717e:	01 d0                	add    %edx,%eax
    7180:	83 c0 01             	add    $0x1,%eax
    7183:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    718a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    718d:	01 d0                	add    %edx,%eax
    718f:	8b 10                	mov    (%eax),%edx
    7191:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7194:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    719b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    719e:	01 c8                	add    %ecx,%eax
    71a0:	8b 00                	mov    (%eax),%eax
    71a2:	39 c2                	cmp    %eax,%edx
    71a4:	74 bc                	je     7162 <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    71a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71a9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    71b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    71b3:	01 d0                	add    %edx,%eax
    71b5:	8b 00                	mov    (%eax),%eax
    71b7:	85 c0                	test   %eax,%eax
    71b9:	0f 85 a9 00 00 00    	jne    7268 <deflateDynamic+0x48a>
    71bf:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    71c3:	0f 86 9f 00 00 00    	jbe    7268 <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    71c9:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    71cd:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    71d1:	77 3a                	ja     720d <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    71d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    71d6:	8d 50 01             	lea    0x1(%eax),%edx
    71d9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    71dc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    71e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    71e6:	01 d0                	add    %edx,%eax
    71e8:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    71ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    71f1:	8d 50 01             	lea    0x1(%eax),%edx
    71f4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    71f7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    71fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7201:	01 d0                	add    %edx,%eax
    7203:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7206:	83 ea 03             	sub    $0x3,%edx
    7209:	89 10                	mov    %edx,(%eax)
    720b:	eb 48                	jmp    7255 <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    720d:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    7214:	76 07                	jbe    721d <deflateDynamic+0x43f>
    7216:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    721d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7220:	8d 50 01             	lea    0x1(%eax),%edx
    7223:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7226:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    722d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7230:	01 d0                	add    %edx,%eax
    7232:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    7238:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    723b:	8d 50 01             	lea    0x1(%eax),%edx
    723e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7241:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7248:	8b 45 ec             	mov    -0x14(%ebp),%eax
    724b:	01 d0                	add    %edx,%eax
    724d:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7250:	83 ea 0b             	sub    $0xb,%edx
    7253:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    7255:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7258:	8b 45 dc             	mov    -0x24(%ebp),%eax
    725b:	01 d0                	add    %edx,%eax
    725d:	83 e8 01             	sub    $0x1,%eax
    7260:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7263:	e9 28 01 00 00       	jmp    7390 <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    7268:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    726c:	0f 86 f6 00 00 00    	jbe    7368 <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    7272:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7275:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    727a:	f7 e2                	mul    %edx
    727c:	89 d0                	mov    %edx,%eax
    727e:	c1 e8 02             	shr    $0x2,%eax
    7281:	89 45 ac             	mov    %eax,-0x54(%ebp)
    7284:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7287:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    728c:	89 c8                	mov    %ecx,%eax
    728e:	f7 e2                	mul    %edx
    7290:	c1 ea 02             	shr    $0x2,%edx
    7293:	89 d0                	mov    %edx,%eax
    7295:	01 c0                	add    %eax,%eax
    7297:	01 d0                	add    %edx,%eax
    7299:	01 c0                	add    %eax,%eax
    729b:	29 c1                	sub    %eax,%ecx
    729d:	89 c8                	mov    %ecx,%eax
    729f:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    72a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72a5:	8d 50 01             	lea    0x1(%eax),%edx
    72a8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    72ab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    72b5:	01 c2                	add    %eax,%edx
    72b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    72ba:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    72c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    72c4:	01 c8                	add    %ecx,%eax
    72c6:	8b 00                	mov    (%eax),%eax
    72c8:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    72ca:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    72d1:	eb 3a                	jmp    730d <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    72d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72d6:	8d 50 01             	lea    0x1(%eax),%edx
    72d9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    72dc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    72e6:	01 d0                	add    %edx,%eax
    72e8:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    72ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72f1:	8d 50 01             	lea    0x1(%eax),%edx
    72f4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    72f7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7301:	01 d0                	add    %edx,%eax
    7303:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    7309:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    730d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7310:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    7313:	72 be                	jb     72d3 <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    7315:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    7319:	76 3a                	jbe    7355 <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    731b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    731e:	8d 50 01             	lea    0x1(%eax),%edx
    7321:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7324:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    732b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    732e:	01 d0                	add    %edx,%eax
    7330:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    7336:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7339:	8d 50 01             	lea    0x1(%eax),%edx
    733c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    733f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7346:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7349:	01 d0                	add    %edx,%eax
    734b:	8b 55 a8             	mov    -0x58(%ebp),%edx
    734e:	83 ea 03             	sub    $0x3,%edx
    7351:	89 10                	mov    %edx,(%eax)
    7353:	eb 06                	jmp    735b <deflateDynamic+0x57d>
        }
        else j -= rest;
    7355:	8b 45 a8             	mov    -0x58(%ebp),%eax
    7358:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    735b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    735e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7361:	01 d0                	add    %edx,%eax
    7363:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7366:	eb 28                	jmp    7390 <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    7368:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    736b:	8d 50 01             	lea    0x1(%eax),%edx
    736e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7371:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7378:	8b 45 ec             	mov    -0x14(%ebp),%eax
    737b:	01 c2                	add    %eax,%edx
    737d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7380:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7387:	8b 45 f0             	mov    -0x10(%ebp),%eax
    738a:	01 c8                	add    %ecx,%eax
    738c:	8b 00                	mov    (%eax),%eax
    738e:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7390:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7394:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7397:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    739a:	0f 85 b9 fd ff ff    	jne    7159 <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    73a0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    73a7:	eb 42                	jmp    73eb <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    73a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73ac:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73b6:	01 d0                	add    %edx,%eax
    73b8:	8b 00                	mov    (%eax),%eax
    73ba:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73c1:	8b 45 cc             	mov    -0x34(%ebp),%eax
    73c4:	01 d0                	add    %edx,%eax
    73c6:	8b 10                	mov    (%eax),%edx
    73c8:	83 c2 01             	add    $0x1,%edx
    73cb:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    73cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73d0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73da:	01 d0                	add    %edx,%eax
    73dc:	8b 00                	mov    (%eax),%eax
    73de:	83 f8 0f             	cmp    $0xf,%eax
    73e1:	76 04                	jbe    73e7 <deflateDynamic+0x609>
    73e3:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    73e7:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    73eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73ee:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    73f1:	75 b6                	jne    73a9 <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    73f3:	83 ec 0c             	sub    $0xc,%esp
    73f6:	6a 07                	push   $0x7
    73f8:	6a 13                	push   $0x13
    73fa:	6a 13                	push   $0x13
    73fc:	ff 75 cc             	pushl  -0x34(%ebp)
    73ff:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7405:	50                   	push   %eax
    7406:	e8 fe dd ff ff       	call   5209 <HuffmanTree_makeFromFrequencies>
    740b:	83 c4 20             	add    $0x20,%esp
    740e:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    7411:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7415:	0f 85 8a 02 00 00    	jne    76a5 <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    741b:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7422:	eb 04                	jmp    7428 <deflateDynamic+0x64a>
      numcodes_cl--;
    7424:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7428:	8b 45 e0             	mov    -0x20(%ebp),%eax
    742b:	83 f8 04             	cmp    $0x4,%eax
    742e:	76 1e                	jbe    744e <deflateDynamic+0x670>
    7430:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7436:	8b 55 e0             	mov    -0x20(%ebp),%edx
    7439:	83 ea 01             	sub    $0x1,%edx
    743c:	8b 14 95 e0 9e 01 00 	mov    0x19ee0(,%edx,4),%edx
    7443:	c1 e2 02             	shl    $0x2,%edx
    7446:	01 d0                	add    %edx,%eax
    7448:	8b 00                	mov    (%eax),%eax
    744a:	85 c0                	test   %eax,%eax
    744c:	74 d6                	je     7424 <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    744e:	83 ec 04             	sub    $0x4,%esp
    7451:	6a 01                	push   $0x1
    7453:	ff 75 c4             	pushl  -0x3c(%ebp)
    7456:	ff 75 08             	pushl  0x8(%ebp)
    7459:	e8 67 c3 ff ff       	call   37c5 <writeBits>
    745e:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    7461:	83 ec 04             	sub    $0x4,%esp
    7464:	6a 01                	push   $0x1
    7466:	6a 00                	push   $0x0
    7468:	ff 75 08             	pushl  0x8(%ebp)
    746b:	e8 55 c3 ff ff       	call   37c5 <writeBits>
    7470:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    7473:	83 ec 04             	sub    $0x4,%esp
    7476:	6a 01                	push   $0x1
    7478:	6a 01                	push   $0x1
    747a:	ff 75 08             	pushl  0x8(%ebp)
    747d:	e8 43 c3 ff ff       	call   37c5 <writeBits>
    7482:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    7485:	8b 45 b8             	mov    -0x48(%ebp),%eax
    7488:	2d 01 01 00 00       	sub    $0x101,%eax
    748d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    7490:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7493:	83 e8 01             	sub    $0x1,%eax
    7496:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    7499:	8b 45 e0             	mov    -0x20(%ebp),%eax
    749c:	83 e8 04             	sub    $0x4,%eax
    749f:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    74a2:	83 ec 04             	sub    $0x4,%esp
    74a5:	6a 05                	push   $0x5
    74a7:	ff 75 a4             	pushl  -0x5c(%ebp)
    74aa:	ff 75 08             	pushl  0x8(%ebp)
    74ad:	e8 13 c3 ff ff       	call   37c5 <writeBits>
    74b2:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    74b5:	83 ec 04             	sub    $0x4,%esp
    74b8:	6a 05                	push   $0x5
    74ba:	ff 75 a0             	pushl  -0x60(%ebp)
    74bd:	ff 75 08             	pushl  0x8(%ebp)
    74c0:	e8 00 c3 ff ff       	call   37c5 <writeBits>
    74c5:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    74c8:	83 ec 04             	sub    $0x4,%esp
    74cb:	6a 04                	push   $0x4
    74cd:	ff 75 9c             	pushl  -0x64(%ebp)
    74d0:	ff 75 08             	pushl  0x8(%ebp)
    74d3:	e8 ed c2 ff ff       	call   37c5 <writeBits>
    74d8:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    74db:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    74e2:	eb 2c                	jmp    7510 <deflateDynamic+0x732>
    74e4:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    74ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74ed:	8b 04 85 e0 9e 01 00 	mov    0x19ee0(,%eax,4),%eax
    74f4:	c1 e0 02             	shl    $0x2,%eax
    74f7:	01 d0                	add    %edx,%eax
    74f9:	8b 00                	mov    (%eax),%eax
    74fb:	83 ec 04             	sub    $0x4,%esp
    74fe:	6a 03                	push   $0x3
    7500:	50                   	push   %eax
    7501:	ff 75 08             	pushl  0x8(%ebp)
    7504:	e8 bc c2 ff ff       	call   37c5 <writeBits>
    7509:	83 c4 10             	add    $0x10,%esp
    750c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7510:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7513:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    7516:	75 cc                	jne    74e4 <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7518:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    751f:	e9 0a 01 00 00       	jmp    762e <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    7524:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    752a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    752d:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    7534:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7537:	01 ca                	add    %ecx,%edx
    7539:	8b 12                	mov    (%edx),%edx
    753b:	c1 e2 02             	shl    $0x2,%edx
    753e:	01 d0                	add    %edx,%eax
    7540:	8b 00                	mov    (%eax),%eax
    7542:	89 c3                	mov    %eax,%ebx
    7544:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    754a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    754d:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    7554:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7557:	01 ca                	add    %ecx,%edx
    7559:	8b 12                	mov    (%edx),%edx
    755b:	c1 e2 02             	shl    $0x2,%edx
    755e:	01 d0                	add    %edx,%eax
    7560:	8b 00                	mov    (%eax),%eax
    7562:	83 ec 04             	sub    $0x4,%esp
    7565:	53                   	push   %ebx
    7566:	50                   	push   %eax
    7567:	ff 75 08             	pushl  0x8(%ebp)
    756a:	e8 ea c3 ff ff       	call   3959 <writeBitsReversed>
    756f:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    7572:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7575:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    757c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    757f:	01 d0                	add    %edx,%eax
    7581:	8b 00                	mov    (%eax),%eax
    7583:	83 f8 10             	cmp    $0x10,%eax
    7586:	75 28                	jne    75b0 <deflateDynamic+0x7d2>
    7588:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    758c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    758f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7596:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7599:	01 d0                	add    %edx,%eax
    759b:	8b 00                	mov    (%eax),%eax
    759d:	83 ec 04             	sub    $0x4,%esp
    75a0:	6a 02                	push   $0x2
    75a2:	50                   	push   %eax
    75a3:	ff 75 08             	pushl  0x8(%ebp)
    75a6:	e8 1a c2 ff ff       	call   37c5 <writeBits>
    75ab:	83 c4 10             	add    $0x10,%esp
    75ae:	eb 7a                	jmp    762a <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    75b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75bd:	01 d0                	add    %edx,%eax
    75bf:	8b 00                	mov    (%eax),%eax
    75c1:	83 f8 11             	cmp    $0x11,%eax
    75c4:	75 28                	jne    75ee <deflateDynamic+0x810>
    75c6:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    75ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75cd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75d7:	01 d0                	add    %edx,%eax
    75d9:	8b 00                	mov    (%eax),%eax
    75db:	83 ec 04             	sub    $0x4,%esp
    75de:	6a 03                	push   $0x3
    75e0:	50                   	push   %eax
    75e1:	ff 75 08             	pushl  0x8(%ebp)
    75e4:	e8 dc c1 ff ff       	call   37c5 <writeBits>
    75e9:	83 c4 10             	add    $0x10,%esp
    75ec:	eb 3c                	jmp    762a <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    75ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75f1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75fb:	01 d0                	add    %edx,%eax
    75fd:	8b 00                	mov    (%eax),%eax
    75ff:	83 f8 12             	cmp    $0x12,%eax
    7602:	75 26                	jne    762a <deflateDynamic+0x84c>
    7604:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7608:	8b 45 e8             	mov    -0x18(%ebp),%eax
    760b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7612:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7615:	01 d0                	add    %edx,%eax
    7617:	8b 00                	mov    (%eax),%eax
    7619:	83 ec 04             	sub    $0x4,%esp
    761c:	6a 07                	push   $0x7
    761e:	50                   	push   %eax
    761f:	ff 75 08             	pushl  0x8(%ebp)
    7622:	e8 9e c1 ff ff       	call   37c5 <writeBits>
    7627:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    762a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    762e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7631:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7634:	0f 85 ea fe ff ff    	jne    7524 <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    763a:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7640:	50                   	push   %eax
    7641:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7647:	50                   	push   %eax
    7648:	8d 45 90             	lea    -0x70(%ebp),%eax
    764b:	50                   	push   %eax
    764c:	ff 75 08             	pushl  0x8(%ebp)
    764f:	e8 4f f6 ff ff       	call   6ca3 <writeLZ77data>
    7654:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    7657:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    765d:	05 00 04 00 00       	add    $0x400,%eax
    7662:	8b 00                	mov    (%eax),%eax
    7664:	85 c0                	test   %eax,%eax
    7666:	75 09                	jne    7671 <deflateDynamic+0x893>
    7668:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    766f:	eb 35                	jmp    76a6 <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    7671:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7677:	05 00 04 00 00       	add    $0x400,%eax
    767c:	8b 00                	mov    (%eax),%eax
    767e:	89 c2                	mov    %eax,%edx
    7680:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    7686:	05 00 04 00 00       	add    $0x400,%eax
    768b:	8b 00                	mov    (%eax),%eax
    768d:	83 ec 04             	sub    $0x4,%esp
    7690:	52                   	push   %edx
    7691:	50                   	push   %eax
    7692:	ff 75 08             	pushl  0x8(%ebp)
    7695:	e8 bf c2 ff ff       	call   3959 <writeBitsReversed>
    769a:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    769d:	eb 07                	jmp    76a6 <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    769f:	90                   	nop
    76a0:	eb 04                	jmp    76a6 <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    76a2:	90                   	nop
    76a3:	eb 01                	jmp    76a6 <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    76a5:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    76a6:	83 ec 0c             	sub    $0xc,%esp
    76a9:	8d 45 90             	lea    -0x70(%ebp),%eax
    76ac:	50                   	push   %eax
    76ad:	e8 73 bd ff ff       	call   3425 <uivector_cleanup>
    76b2:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    76b5:	83 ec 0c             	sub    $0xc,%esp
    76b8:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    76be:	50                   	push   %eax
    76bf:	e8 3a cb ff ff       	call   41fe <HuffmanTree_cleanup>
    76c4:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    76c7:	83 ec 0c             	sub    $0xc,%esp
    76ca:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    76d0:	50                   	push   %eax
    76d1:	e8 28 cb ff ff       	call   41fe <HuffmanTree_cleanup>
    76d6:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    76d9:	83 ec 0c             	sub    $0xc,%esp
    76dc:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    76e2:	50                   	push   %eax
    76e3:	e8 16 cb ff ff       	call   41fe <HuffmanTree_cleanup>
    76e8:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    76eb:	83 ec 0c             	sub    $0xc,%esp
    76ee:	ff 75 d4             	pushl  -0x2c(%ebp)
    76f1:	e8 08 bc ff ff       	call   32fe <lodepng_free>
    76f6:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    76f9:	83 ec 0c             	sub    $0xc,%esp
    76fc:	ff 75 d0             	pushl  -0x30(%ebp)
    76ff:	e8 fa bb ff ff       	call   32fe <lodepng_free>
    7704:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    7707:	83 ec 0c             	sub    $0xc,%esp
    770a:	ff 75 cc             	pushl  -0x34(%ebp)
    770d:	e8 ec bb ff ff       	call   32fe <lodepng_free>
    7712:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    7715:	83 ec 0c             	sub    $0xc,%esp
    7718:	ff 75 f0             	pushl  -0x10(%ebp)
    771b:	e8 de bb ff ff       	call   32fe <lodepng_free>
    7720:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    7723:	83 ec 0c             	sub    $0xc,%esp
    7726:	ff 75 ec             	pushl  -0x14(%ebp)
    7729:	e8 d0 bb ff ff       	call   32fe <lodepng_free>
    772e:	83 c4 10             	add    $0x10,%esp

  return error;
    7731:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7734:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7737:	c9                   	leave  
    7738:	c3                   	ret    

00007739 <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    7739:	55                   	push   %ebp
    773a:	89 e5                	mov    %esp,%ebp
    773c:	53                   	push   %ebx
    773d:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    7740:	8b 45 20             	mov    0x20(%ebp),%eax
    7743:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    7746:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    774d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7750:	50                   	push   %eax
    7751:	e8 7b ca ff ff       	call   41d1 <HuffmanTree_init>
    7756:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    7759:	8d 45 bc             	lea    -0x44(%ebp),%eax
    775c:	50                   	push   %eax
    775d:	e8 6f ca ff ff       	call   41d1 <HuffmanTree_init>
    7762:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    7765:	83 ec 0c             	sub    $0xc,%esp
    7768:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    776b:	50                   	push   %eax
    776c:	e8 41 db ff ff       	call   52b2 <generateFixedLitLenTree>
    7771:	83 c4 10             	add    $0x10,%esp
    7774:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    7777:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    777b:	75 12                	jne    778f <deflateFixed+0x56>
    777d:	83 ec 0c             	sub    $0xc,%esp
    7780:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7783:	50                   	push   %eax
    7784:	e8 30 dc ff ff       	call   53b9 <generateFixedDistanceTree>
    7789:	83 c4 10             	add    $0x10,%esp
    778c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    778f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7793:	0f 85 3a 01 00 00    	jne    78d3 <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    7799:	83 ec 04             	sub    $0x4,%esp
    779c:	6a 01                	push   $0x1
    779e:	ff 75 ec             	pushl  -0x14(%ebp)
    77a1:	ff 75 08             	pushl  0x8(%ebp)
    77a4:	e8 1c c0 ff ff       	call   37c5 <writeBits>
    77a9:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    77ac:	83 ec 04             	sub    $0x4,%esp
    77af:	6a 01                	push   $0x1
    77b1:	6a 01                	push   $0x1
    77b3:	ff 75 08             	pushl  0x8(%ebp)
    77b6:	e8 0a c0 ff ff       	call   37c5 <writeBits>
    77bb:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    77be:	83 ec 04             	sub    $0x4,%esp
    77c1:	6a 01                	push   $0x1
    77c3:	6a 00                	push   $0x0
    77c5:	ff 75 08             	pushl  0x8(%ebp)
    77c8:	e8 f8 bf ff ff       	call   37c5 <writeBits>
    77cd:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    77d0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    77d3:	8b 40 04             	mov    0x4(%eax),%eax
    77d6:	85 c0                	test   %eax,%eax
    77d8:	74 77                	je     7851 <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    77da:	83 ec 0c             	sub    $0xc,%esp
    77dd:	8d 45 b0             	lea    -0x50(%ebp),%eax
    77e0:	50                   	push   %eax
    77e1:	e8 e8 bc ff ff       	call   34ce <uivector_init>
    77e6:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    77e9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    77ec:	8b 58 14             	mov    0x14(%eax),%ebx
    77ef:	8b 45 1c             	mov    0x1c(%ebp),%eax
    77f2:	8b 48 10             	mov    0x10(%eax),%ecx
    77f5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    77f8:	8b 50 0c             	mov    0xc(%eax),%edx
    77fb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    77fe:	8b 40 08             	mov    0x8(%eax),%eax
    7801:	83 ec 0c             	sub    $0xc,%esp
    7804:	53                   	push   %ebx
    7805:	51                   	push   %ecx
    7806:	52                   	push   %edx
    7807:	50                   	push   %eax
    7808:	ff 75 18             	pushl  0x18(%ebp)
    780b:	ff 75 14             	pushl  0x14(%ebp)
    780e:	ff 75 10             	pushl  0x10(%ebp)
    7811:	ff 75 0c             	pushl  0xc(%ebp)
    7814:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7817:	50                   	push   %eax
    7818:	e8 c7 ed ff ff       	call   65e4 <encodeLZ77>
    781d:	83 c4 30             	add    $0x30,%esp
    7820:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7823:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7827:	75 17                	jne    7840 <deflateFixed+0x107>
    7829:	8d 45 bc             	lea    -0x44(%ebp),%eax
    782c:	50                   	push   %eax
    782d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7830:	50                   	push   %eax
    7831:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7834:	50                   	push   %eax
    7835:	ff 75 08             	pushl  0x8(%ebp)
    7838:	e8 66 f4 ff ff       	call   6ca3 <writeLZ77data>
    783d:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    7840:	83 ec 0c             	sub    $0xc,%esp
    7843:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7846:	50                   	push   %eax
    7847:	e8 d9 bb ff ff       	call   3425 <uivector_cleanup>
    784c:	83 c4 10             	add    $0x10,%esp
    784f:	eb 56                	jmp    78a7 <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7851:	8b 45 14             	mov    0x14(%ebp),%eax
    7854:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7857:	eb 46                	jmp    789f <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    7859:	8b 45 d8             	mov    -0x28(%ebp),%eax
    785c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    785f:	8b 55 10             	mov    0x10(%ebp),%edx
    7862:	01 ca                	add    %ecx,%edx
    7864:	0f b6 12             	movzbl (%edx),%edx
    7867:	0f b6 d2             	movzbl %dl,%edx
    786a:	c1 e2 02             	shl    $0x2,%edx
    786d:	01 d0                	add    %edx,%eax
    786f:	8b 00                	mov    (%eax),%eax
    7871:	89 c3                	mov    %eax,%ebx
    7873:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7876:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7879:	8b 55 10             	mov    0x10(%ebp),%edx
    787c:	01 ca                	add    %ecx,%edx
    787e:	0f b6 12             	movzbl (%edx),%edx
    7881:	0f b6 d2             	movzbl %dl,%edx
    7884:	c1 e2 02             	shl    $0x2,%edx
    7887:	01 d0                	add    %edx,%eax
    7889:	8b 00                	mov    (%eax),%eax
    788b:	83 ec 04             	sub    $0x4,%esp
    788e:	53                   	push   %ebx
    788f:	50                   	push   %eax
    7890:	ff 75 08             	pushl  0x8(%ebp)
    7893:	e8 c1 c0 ff ff       	call   3959 <writeBitsReversed>
    7898:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    789b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    789f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    78a2:	3b 45 18             	cmp    0x18(%ebp),%eax
    78a5:	7c b2                	jl     7859 <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    78a7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    78ab:	75 26                	jne    78d3 <deflateFixed+0x19a>
    78ad:	8b 45 d8             	mov    -0x28(%ebp),%eax
    78b0:	05 00 04 00 00       	add    $0x400,%eax
    78b5:	8b 00                	mov    (%eax),%eax
    78b7:	89 c2                	mov    %eax,%edx
    78b9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    78bc:	05 00 04 00 00       	add    $0x400,%eax
    78c1:	8b 00                	mov    (%eax),%eax
    78c3:	83 ec 04             	sub    $0x4,%esp
    78c6:	52                   	push   %edx
    78c7:	50                   	push   %eax
    78c8:	ff 75 08             	pushl  0x8(%ebp)
    78cb:	e8 89 c0 ff ff       	call   3959 <writeBitsReversed>
    78d0:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    78d3:	83 ec 0c             	sub    $0xc,%esp
    78d6:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    78d9:	50                   	push   %eax
    78da:	e8 1f c9 ff ff       	call   41fe <HuffmanTree_cleanup>
    78df:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    78e2:	83 ec 0c             	sub    $0xc,%esp
    78e5:	8d 45 bc             	lea    -0x44(%ebp),%eax
    78e8:	50                   	push   %eax
    78e9:	e8 10 c9 ff ff       	call   41fe <HuffmanTree_cleanup>
    78ee:	83 c4 10             	add    $0x10,%esp

  return error;
    78f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    78f4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    78f7:	c9                   	leave  
    78f8:	c3                   	ret    

000078f9 <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    78f9:	55                   	push   %ebp
    78fa:	89 e5                	mov    %esp,%ebp
    78fc:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    78ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    7906:	ff 75 08             	pushl  0x8(%ebp)
    7909:	8d 45 bc             	lea    -0x44(%ebp),%eax
    790c:	50                   	push   %eax
    790d:	e8 9e be ff ff       	call   37b0 <LodePNGBitWriter_init>
    7912:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    7915:	8b 45 14             	mov    0x14(%ebp),%eax
    7918:	8b 00                	mov    (%eax),%eax
    791a:	83 f8 02             	cmp    $0x2,%eax
    791d:	76 0a                	jbe    7929 <lodepng_deflatev+0x30>
    791f:	b8 3d 00 00 00       	mov    $0x3d,%eax
    7924:	e9 68 01 00 00       	jmp    7a91 <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    7929:	8b 45 14             	mov    0x14(%ebp),%eax
    792c:	8b 00                	mov    (%eax),%eax
    792e:	85 c0                	test   %eax,%eax
    7930:	75 16                	jne    7948 <lodepng_deflatev+0x4f>
    7932:	ff 75 10             	pushl  0x10(%ebp)
    7935:	ff 75 0c             	pushl  0xc(%ebp)
    7938:	ff 75 08             	pushl  0x8(%ebp)
    793b:	e8 01 f2 ff ff       	call   6b41 <deflateNoCompression>
    7940:	83 c4 0c             	add    $0xc,%esp
    7943:	e9 49 01 00 00       	jmp    7a91 <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    7948:	8b 45 14             	mov    0x14(%ebp),%eax
    794b:	8b 00                	mov    (%eax),%eax
    794d:	83 f8 01             	cmp    $0x1,%eax
    7950:	75 08                	jne    795a <lodepng_deflatev+0x61>
    7952:	8b 45 10             	mov    0x10(%ebp),%eax
    7955:	89 45 ec             	mov    %eax,-0x14(%ebp)
    7958:	eb 2c                	jmp    7986 <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    795a:	8b 45 10             	mov    0x10(%ebp),%eax
    795d:	c1 e8 03             	shr    $0x3,%eax
    7960:	83 c0 08             	add    $0x8,%eax
    7963:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    7966:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    796d:	7f 07                	jg     7976 <lodepng_deflatev+0x7d>
    796f:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    7976:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    797d:	7e 07                	jle    7986 <lodepng_deflatev+0x8d>
    797f:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    7986:	8b 55 10             	mov    0x10(%ebp),%edx
    7989:	8b 45 ec             	mov    -0x14(%ebp),%eax
    798c:	01 d0                	add    %edx,%eax
    798e:	83 e8 01             	sub    $0x1,%eax
    7991:	99                   	cltd   
    7992:	f7 7d ec             	idivl  -0x14(%ebp)
    7995:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    7998:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    799c:	75 07                	jne    79a5 <lodepng_deflatev+0xac>
    799e:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    79a5:	8b 45 14             	mov    0x14(%ebp),%eax
    79a8:	8b 40 08             	mov    0x8(%eax),%eax
    79ab:	83 ec 08             	sub    $0x8,%esp
    79ae:	50                   	push   %eax
    79af:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    79b2:	50                   	push   %eax
    79b3:	e8 1c e8 ff ff       	call   61d4 <hash_init>
    79b8:	83 c4 10             	add    $0x10,%esp
    79bb:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    79be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    79c2:	0f 85 b7 00 00 00    	jne    7a7f <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    79c8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    79cf:	e9 99 00 00 00       	jmp    7a6d <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    79d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    79d7:	83 e8 01             	sub    $0x1,%eax
    79da:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    79dd:	0f 94 c0             	sete   %al
    79e0:	0f b6 c0             	movzbl %al,%eax
    79e3:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    79e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    79e9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    79ed:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    79f0:	8b 55 dc             	mov    -0x24(%ebp),%edx
    79f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    79f6:	01 d0                	add    %edx,%eax
    79f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    79fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    79fe:	3b 45 10             	cmp    0x10(%ebp),%eax
    7a01:	7e 06                	jle    7a09 <lodepng_deflatev+0x110>
    7a03:	8b 45 10             	mov    0x10(%ebp),%eax
    7a06:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    7a09:	8b 45 14             	mov    0x14(%ebp),%eax
    7a0c:	8b 00                	mov    (%eax),%eax
    7a0e:	83 f8 01             	cmp    $0x1,%eax
    7a11:	75 27                	jne    7a3a <lodepng_deflatev+0x141>
    7a13:	83 ec 04             	sub    $0x4,%esp
    7a16:	ff 75 e0             	pushl  -0x20(%ebp)
    7a19:	ff 75 14             	pushl  0x14(%ebp)
    7a1c:	ff 75 e4             	pushl  -0x1c(%ebp)
    7a1f:	ff 75 dc             	pushl  -0x24(%ebp)
    7a22:	ff 75 0c             	pushl  0xc(%ebp)
    7a25:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7a28:	50                   	push   %eax
    7a29:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a2c:	50                   	push   %eax
    7a2d:	e8 07 fd ff ff       	call   7739 <deflateFixed>
    7a32:	83 c4 20             	add    $0x20,%esp
    7a35:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7a38:	eb 2f                	jmp    7a69 <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    7a3a:	8b 45 14             	mov    0x14(%ebp),%eax
    7a3d:	8b 00                	mov    (%eax),%eax
    7a3f:	83 f8 02             	cmp    $0x2,%eax
    7a42:	75 25                	jne    7a69 <lodepng_deflatev+0x170>
    7a44:	83 ec 04             	sub    $0x4,%esp
    7a47:	ff 75 e0             	pushl  -0x20(%ebp)
    7a4a:	ff 75 14             	pushl  0x14(%ebp)
    7a4d:	ff 75 e4             	pushl  -0x1c(%ebp)
    7a50:	ff 75 dc             	pushl  -0x24(%ebp)
    7a53:	ff 75 0c             	pushl  0xc(%ebp)
    7a56:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7a59:	50                   	push   %eax
    7a5a:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a5d:	50                   	push   %eax
    7a5e:	e8 7b f3 ff ff       	call   6dde <deflateDynamic>
    7a63:	83 c4 20             	add    $0x20,%esp
    7a66:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7a69:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7a6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7a70:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7a73:	74 0a                	je     7a7f <lodepng_deflatev+0x186>
    7a75:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7a79:	0f 84 55 ff ff ff    	je     79d4 <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    7a7f:	83 ec 0c             	sub    $0xc,%esp
    7a82:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7a85:	50                   	push   %eax
    7a86:	e8 08 e9 ff ff       	call   6393 <hash_cleanup>
    7a8b:	83 c4 10             	add    $0x10,%esp

  return error;
    7a8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7a91:	c9                   	leave  
    7a92:	c3                   	ret    

00007a93 <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    7a93:	55                   	push   %ebp
    7a94:	89 e5                	mov    %esp,%ebp
    7a96:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7a99:	8b 45 0c             	mov    0xc(%ebp),%eax
    7a9c:	8b 08                	mov    (%eax),%ecx
    7a9e:	8b 45 08             	mov    0x8(%ebp),%eax
    7aa1:	8b 10                	mov    (%eax),%edx
    7aa3:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7aa6:	51                   	push   %ecx
    7aa7:	52                   	push   %edx
    7aa8:	50                   	push   %eax
    7aa9:	e8 f0 ba ff ff       	call   359e <ucvector_init>
    7aae:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    7ab1:	ff 75 18             	pushl  0x18(%ebp)
    7ab4:	ff 75 14             	pushl  0x14(%ebp)
    7ab7:	ff 75 10             	pushl  0x10(%ebp)
    7aba:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7abd:	50                   	push   %eax
    7abe:	e8 36 fe ff ff       	call   78f9 <lodepng_deflatev>
    7ac3:	83 c4 10             	add    $0x10,%esp
    7ac6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7ac9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7acc:	8b 45 08             	mov    0x8(%ebp),%eax
    7acf:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7ad1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7ad4:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ad7:	89 10                	mov    %edx,(%eax)
  return error;
    7ad9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7adc:	c9                   	leave  
    7add:	c3                   	ret    

00007ade <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    7ade:	55                   	push   %ebp
    7adf:	89 e5                	mov    %esp,%ebp
    7ae1:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    7ae4:	8b 45 18             	mov    0x18(%ebp),%eax
    7ae7:	8b 40 1c             	mov    0x1c(%eax),%eax
    7aea:	85 c0                	test   %eax,%eax
    7aec:	74 34                	je     7b22 <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    7aee:	8b 45 18             	mov    0x18(%ebp),%eax
    7af1:	8b 40 1c             	mov    0x1c(%eax),%eax
    7af4:	83 ec 0c             	sub    $0xc,%esp
    7af7:	ff 75 18             	pushl  0x18(%ebp)
    7afa:	ff 75 14             	pushl  0x14(%ebp)
    7afd:	ff 75 10             	pushl  0x10(%ebp)
    7b00:	ff 75 0c             	pushl  0xc(%ebp)
    7b03:	ff 75 08             	pushl  0x8(%ebp)
    7b06:	ff d0                	call   *%eax
    7b08:	83 c4 20             	add    $0x20,%esp
    7b0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    7b0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7b12:	74 07                	je     7b1b <deflate+0x3d>
    7b14:	b8 6f 00 00 00       	mov    $0x6f,%eax
    7b19:	eb 21                	jmp    7b3c <deflate+0x5e>
    7b1b:	b8 00 00 00 00       	mov    $0x0,%eax
    7b20:	eb 1a                	jmp    7b3c <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    7b22:	83 ec 0c             	sub    $0xc,%esp
    7b25:	ff 75 18             	pushl  0x18(%ebp)
    7b28:	ff 75 14             	pushl  0x14(%ebp)
    7b2b:	ff 75 10             	pushl  0x10(%ebp)
    7b2e:	ff 75 0c             	pushl  0xc(%ebp)
    7b31:	ff 75 08             	pushl  0x8(%ebp)
    7b34:	e8 5a ff ff ff       	call   7a93 <lodepng_deflate>
    7b39:	83 c4 20             	add    $0x20,%esp
  }
}
    7b3c:	c9                   	leave  
    7b3d:	c3                   	ret    

00007b3e <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    7b3e:	55                   	push   %ebp
    7b3f:	89 e5                	mov    %esp,%ebp
    7b41:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    7b44:	8b 45 08             	mov    0x8(%ebp),%eax
    7b47:	0f b7 c0             	movzwl %ax,%eax
    7b4a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    7b4d:	8b 45 08             	mov    0x8(%ebp),%eax
    7b50:	c1 e8 10             	shr    $0x10,%eax
    7b53:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    7b56:	e9 82 00 00 00       	jmp    7bdd <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    7b5b:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    7b60:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    7b67:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    7b6b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    7b6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7b71:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    7b74:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7b7b:	eb 1c                	jmp    7b99 <update_adler32+0x5b>
      s1 += (*data++);
    7b7d:	8b 45 0c             	mov    0xc(%ebp),%eax
    7b80:	8d 50 01             	lea    0x1(%eax),%edx
    7b83:	89 55 0c             	mov    %edx,0xc(%ebp)
    7b86:	0f b6 00             	movzbl (%eax),%eax
    7b89:	0f b6 c0             	movzbl %al,%eax
    7b8c:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    7b8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7b92:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    7b95:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7b99:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7b9c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7b9f:	75 dc                	jne    7b7d <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    7ba1:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7ba4:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7ba9:	89 c8                	mov    %ecx,%eax
    7bab:	f7 e2                	mul    %edx
    7bad:	89 d0                	mov    %edx,%eax
    7baf:	c1 e8 0f             	shr    $0xf,%eax
    7bb2:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7bb8:	29 c1                	sub    %eax,%ecx
    7bba:	89 c8                	mov    %ecx,%eax
    7bbc:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    7bbf:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7bc2:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7bc7:	89 c8                	mov    %ecx,%eax
    7bc9:	f7 e2                	mul    %edx
    7bcb:	89 d0                	mov    %edx,%eax
    7bcd:	c1 e8 0f             	shr    $0xf,%eax
    7bd0:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7bd6:	29 c1                	sub    %eax,%ecx
    7bd8:	89 c8                	mov    %ecx,%eax
    7bda:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    7bdd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7be1:	0f 85 74 ff ff ff    	jne    7b5b <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    7be7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7bea:	c1 e0 10             	shl    $0x10,%eax
    7bed:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    7bf0:	c9                   	leave  
    7bf1:	c3                   	ret    

00007bf2 <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    7bf2:	55                   	push   %ebp
    7bf3:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    7bf5:	ff 75 0c             	pushl  0xc(%ebp)
    7bf8:	ff 75 08             	pushl  0x8(%ebp)
    7bfb:	6a 01                	push   $0x1
    7bfd:	e8 3c ff ff ff       	call   7b3e <update_adler32>
    7c02:	83 c4 0c             	add    $0xc,%esp
}
    7c05:	c9                   	leave  
    7c06:	c3                   	ret    

00007c07 <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    7c07:	55                   	push   %ebp
    7c08:	89 e5                	mov    %esp,%ebp
    7c0a:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    7c0d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    7c14:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    7c18:	7f 0a                	jg     7c24 <lodepng_zlib_decompressv+0x1d>
    7c1a:	b8 35 00 00 00       	mov    $0x35,%eax
    7c1f:	e9 27 01 00 00       	jmp    7d4b <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    7c24:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c27:	0f b6 00             	movzbl (%eax),%eax
    7c2a:	0f b6 c0             	movzbl %al,%eax
    7c2d:	c1 e0 08             	shl    $0x8,%eax
    7c30:	89 c2                	mov    %eax,%edx
    7c32:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c35:	83 c0 01             	add    $0x1,%eax
    7c38:	0f b6 00             	movzbl (%eax),%eax
    7c3b:	0f b6 c0             	movzbl %al,%eax
    7c3e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    7c41:	ba 43 08 21 84       	mov    $0x84210843,%edx
    7c46:	89 c8                	mov    %ecx,%eax
    7c48:	f7 ea                	imul   %edx
    7c4a:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    7c4d:	c1 f8 04             	sar    $0x4,%eax
    7c50:	89 c2                	mov    %eax,%edx
    7c52:	89 c8                	mov    %ecx,%eax
    7c54:	c1 f8 1f             	sar    $0x1f,%eax
    7c57:	29 c2                	sub    %eax,%edx
    7c59:	89 d0                	mov    %edx,%eax
    7c5b:	89 c2                	mov    %eax,%edx
    7c5d:	c1 e2 05             	shl    $0x5,%edx
    7c60:	29 c2                	sub    %eax,%edx
    7c62:	89 c8                	mov    %ecx,%eax
    7c64:	29 d0                	sub    %edx,%eax
    7c66:	85 c0                	test   %eax,%eax
    7c68:	74 0a                	je     7c74 <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    7c6a:	b8 18 00 00 00       	mov    $0x18,%eax
    7c6f:	e9 d7 00 00 00       	jmp    7d4b <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    7c74:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c77:	0f b6 00             	movzbl (%eax),%eax
    7c7a:	0f b6 c0             	movzbl %al,%eax
    7c7d:	83 e0 0f             	and    $0xf,%eax
    7c80:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    7c83:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c86:	0f b6 00             	movzbl (%eax),%eax
    7c89:	c0 e8 04             	shr    $0x4,%al
    7c8c:	0f b6 c0             	movzbl %al,%eax
    7c8f:	83 e0 0f             	and    $0xf,%eax
    7c92:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    7c95:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c98:	83 c0 01             	add    $0x1,%eax
    7c9b:	0f b6 00             	movzbl (%eax),%eax
    7c9e:	c0 e8 05             	shr    $0x5,%al
    7ca1:	0f b6 c0             	movzbl %al,%eax
    7ca4:	83 e0 01             	and    $0x1,%eax
    7ca7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    7caa:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    7cae:	75 06                	jne    7cb6 <lodepng_zlib_decompressv+0xaf>
    7cb0:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    7cb4:	76 0a                	jbe    7cc0 <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    7cb6:	b8 19 00 00 00       	mov    $0x19,%eax
    7cbb:	e9 8b 00 00 00       	jmp    7d4b <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    7cc0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7cc4:	74 07                	je     7ccd <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    7cc6:	b8 1a 00 00 00       	mov    $0x1a,%eax
    7ccb:	eb 7e                	jmp    7d4b <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    7ccd:	8b 45 10             	mov    0x10(%ebp),%eax
    7cd0:	8d 50 fe             	lea    -0x2(%eax),%edx
    7cd3:	8b 45 0c             	mov    0xc(%ebp),%eax
    7cd6:	83 c0 02             	add    $0x2,%eax
    7cd9:	ff 75 14             	pushl  0x14(%ebp)
    7cdc:	52                   	push   %edx
    7cdd:	50                   	push   %eax
    7cde:	ff 75 08             	pushl  0x8(%ebp)
    7ce1:	e8 09 e3 ff ff       	call   5fef <inflatev>
    7ce6:	83 c4 10             	add    $0x10,%esp
    7ce9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    7cec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7cf0:	74 05                	je     7cf7 <lodepng_zlib_decompressv+0xf0>
    7cf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7cf5:	eb 54                	jmp    7d4b <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    7cf7:	8b 45 14             	mov    0x14(%ebp),%eax
    7cfa:	8b 00                	mov    (%eax),%eax
    7cfc:	85 c0                	test   %eax,%eax
    7cfe:	75 46                	jne    7d46 <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    7d00:	8b 45 10             	mov    0x10(%ebp),%eax
    7d03:	8d 50 fc             	lea    -0x4(%eax),%edx
    7d06:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d09:	01 d0                	add    %edx,%eax
    7d0b:	83 ec 0c             	sub    $0xc,%esp
    7d0e:	50                   	push   %eax
    7d0f:	e8 47 b9 ff ff       	call   365b <lodepng_read32bitInt>
    7d14:	83 c4 10             	add    $0x10,%esp
    7d17:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    7d1a:	8b 45 08             	mov    0x8(%ebp),%eax
    7d1d:	8b 40 04             	mov    0x4(%eax),%eax
    7d20:	89 c2                	mov    %eax,%edx
    7d22:	8b 45 08             	mov    0x8(%ebp),%eax
    7d25:	8b 00                	mov    (%eax),%eax
    7d27:	83 ec 08             	sub    $0x8,%esp
    7d2a:	52                   	push   %edx
    7d2b:	50                   	push   %eax
    7d2c:	e8 c1 fe ff ff       	call   7bf2 <adler32>
    7d31:	83 c4 10             	add    $0x10,%esp
    7d34:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    7d37:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7d3a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7d3d:	74 07                	je     7d46 <lodepng_zlib_decompressv+0x13f>
    7d3f:	b8 3a 00 00 00       	mov    $0x3a,%eax
    7d44:	eb 05                	jmp    7d4b <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    7d46:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7d4b:	c9                   	leave  
    7d4c:	c3                   	ret    

00007d4d <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    7d4d:	55                   	push   %ebp
    7d4e:	89 e5                	mov    %esp,%ebp
    7d50:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7d53:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d56:	8b 08                	mov    (%eax),%ecx
    7d58:	8b 45 08             	mov    0x8(%ebp),%eax
    7d5b:	8b 10                	mov    (%eax),%edx
    7d5d:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7d60:	51                   	push   %ecx
    7d61:	52                   	push   %edx
    7d62:	50                   	push   %eax
    7d63:	e8 36 b8 ff ff       	call   359e <ucvector_init>
    7d68:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7d6b:	ff 75 18             	pushl  0x18(%ebp)
    7d6e:	ff 75 14             	pushl  0x14(%ebp)
    7d71:	ff 75 10             	pushl  0x10(%ebp)
    7d74:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7d77:	50                   	push   %eax
    7d78:	e8 8a fe ff ff       	call   7c07 <lodepng_zlib_decompressv>
    7d7d:	83 c4 10             	add    $0x10,%esp
    7d80:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7d83:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7d86:	8b 45 08             	mov    0x8(%ebp),%eax
    7d89:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7d8b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7d8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d91:	89 10                	mov    %edx,(%eax)
  return error;
    7d93:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7d96:	c9                   	leave  
    7d97:	c3                   	ret    

00007d98 <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    7d98:	55                   	push   %ebp
    7d99:	89 e5                	mov    %esp,%ebp
    7d9b:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    7d9e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7da1:	8b 40 0c             	mov    0xc(%eax),%eax
    7da4:	85 c0                	test   %eax,%eax
    7da6:	74 57                	je     7dff <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    7da8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7dab:	8b 40 0c             	mov    0xc(%eax),%eax
    7dae:	83 ec 0c             	sub    $0xc,%esp
    7db1:	ff 75 1c             	pushl  0x1c(%ebp)
    7db4:	ff 75 18             	pushl  0x18(%ebp)
    7db7:	ff 75 14             	pushl  0x14(%ebp)
    7dba:	ff 75 0c             	pushl  0xc(%ebp)
    7dbd:	ff 75 08             	pushl  0x8(%ebp)
    7dc0:	ff d0                	call   *%eax
    7dc2:	83 c4 20             	add    $0x20,%esp
    7dc5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    7dc8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7dcc:	0f 84 98 00 00 00    	je     7e6a <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    7dd2:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    7dd9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7ddc:	8b 40 08             	mov    0x8(%eax),%eax
    7ddf:	85 c0                	test   %eax,%eax
    7de1:	0f 84 83 00 00 00    	je     7e6a <zlib_decompress+0xd2>
    7de7:	8b 45 0c             	mov    0xc(%ebp),%eax
    7dea:	8b 10                	mov    (%eax),%edx
    7dec:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7def:	8b 40 08             	mov    0x8(%eax),%eax
    7df2:	39 c2                	cmp    %eax,%edx
    7df4:	7e 74                	jle    7e6a <zlib_decompress+0xd2>
    7df6:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    7dfd:	eb 6b                	jmp    7e6a <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    7dff:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e02:	8b 08                	mov    (%eax),%ecx
    7e04:	8b 45 08             	mov    0x8(%ebp),%eax
    7e07:	8b 10                	mov    (%eax),%edx
    7e09:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e0c:	83 ec 04             	sub    $0x4,%esp
    7e0f:	51                   	push   %ecx
    7e10:	52                   	push   %edx
    7e11:	50                   	push   %eax
    7e12:	e8 87 b7 ff ff       	call   359e <ucvector_init>
    7e17:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    7e1a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7e1e:	74 22                	je     7e42 <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    7e20:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e23:	8b 10                	mov    (%eax),%edx
    7e25:	8b 45 10             	mov    0x10(%ebp),%eax
    7e28:	01 d0                	add    %edx,%eax
    7e2a:	83 ec 08             	sub    $0x8,%esp
    7e2d:	50                   	push   %eax
    7e2e:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e31:	50                   	push   %eax
    7e32:	e8 00 b7 ff ff       	call   3537 <ucvector_resize>
    7e37:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    7e3a:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e3d:	8b 00                	mov    (%eax),%eax
    7e3f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7e42:	ff 75 1c             	pushl  0x1c(%ebp)
    7e45:	ff 75 18             	pushl  0x18(%ebp)
    7e48:	ff 75 14             	pushl  0x14(%ebp)
    7e4b:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e4e:	50                   	push   %eax
    7e4f:	e8 b3 fd ff ff       	call   7c07 <lodepng_zlib_decompressv>
    7e54:	83 c4 10             	add    $0x10,%esp
    7e57:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    7e5a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7e5d:	8b 45 08             	mov    0x8(%ebp),%eax
    7e60:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    7e62:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7e65:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e68:	89 10                	mov    %edx,(%eax)
  }
  return error;
    7e6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7e6d:	c9                   	leave  
    7e6e:	c3                   	ret    

00007e6f <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    7e6f:	55                   	push   %ebp
    7e70:	89 e5                	mov    %esp,%ebp
    7e72:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    7e75:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    7e7c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    7e83:	83 ec 0c             	sub    $0xc,%esp
    7e86:	ff 75 18             	pushl  0x18(%ebp)
    7e89:	ff 75 14             	pushl  0x14(%ebp)
    7e8c:	ff 75 10             	pushl  0x10(%ebp)
    7e8f:	8d 45 d0             	lea    -0x30(%ebp),%eax
    7e92:	50                   	push   %eax
    7e93:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7e96:	50                   	push   %eax
    7e97:	e8 42 fc ff ff       	call   7ade <deflate>
    7e9c:	83 c4 20             	add    $0x20,%esp
    7e9f:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    7ea2:	8b 45 08             	mov    0x8(%ebp),%eax
    7ea5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    7eab:	8b 45 0c             	mov    0xc(%ebp),%eax
    7eae:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    7eb4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7eb8:	75 33                	jne    7eed <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    7eba:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7ebd:	8d 50 06             	lea    0x6(%eax),%edx
    7ec0:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ec3:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    7ec5:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ec8:	8b 00                	mov    (%eax),%eax
    7eca:	83 ec 0c             	sub    $0xc,%esp
    7ecd:	50                   	push   %eax
    7ece:	e8 0a b4 ff ff       	call   32dd <lodepng_malloc>
    7ed3:	83 c4 10             	add    $0x10,%esp
    7ed6:	89 c2                	mov    %eax,%edx
    7ed8:	8b 45 08             	mov    0x8(%ebp),%eax
    7edb:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    7edd:	8b 45 08             	mov    0x8(%ebp),%eax
    7ee0:	8b 00                	mov    (%eax),%eax
    7ee2:	85 c0                	test   %eax,%eax
    7ee4:	75 07                	jne    7eed <lodepng_zlib_compress+0x7e>
    7ee6:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    7eed:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7ef1:	0f 85 e2 00 00 00    	jne    7fd9 <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    7ef7:	8b 45 14             	mov    0x14(%ebp),%eax
    7efa:	83 ec 08             	sub    $0x8,%esp
    7efd:	50                   	push   %eax
    7efe:	ff 75 10             	pushl  0x10(%ebp)
    7f01:	e8 ec fc ff ff       	call   7bf2 <adler32>
    7f06:	83 c4 10             	add    $0x10,%esp
    7f09:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    7f0c:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    7f13:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    7f1a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    7f21:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7f24:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7f2b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7f2e:	01 d0                	add    %edx,%eax
    7f30:	8d 14 00             	lea    (%eax,%eax,1),%edx
    7f33:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7f36:	01 d0                	add    %edx,%eax
    7f38:	c1 e0 05             	shl    $0x5,%eax
    7f3b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    7f3e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7f41:	ba 85 10 42 08       	mov    $0x8421085,%edx
    7f46:	89 c8                	mov    %ecx,%eax
    7f48:	f7 e2                	mul    %edx
    7f4a:	89 c8                	mov    %ecx,%eax
    7f4c:	29 d0                	sub    %edx,%eax
    7f4e:	d1 e8                	shr    %eax
    7f50:	01 d0                	add    %edx,%eax
    7f52:	c1 e8 04             	shr    $0x4,%eax
    7f55:	89 c2                	mov    %eax,%edx
    7f57:	c1 e2 05             	shl    $0x5,%edx
    7f5a:	29 c2                	sub    %eax,%edx
    7f5c:	89 c8                	mov    %ecx,%eax
    7f5e:	29 d0                	sub    %edx,%eax
    7f60:	ba 1f 00 00 00       	mov    $0x1f,%edx
    7f65:	29 c2                	sub    %eax,%edx
    7f67:	89 d0                	mov    %edx,%eax
    7f69:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    7f6c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7f6f:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    7f72:	8b 45 08             	mov    0x8(%ebp),%eax
    7f75:	8b 00                	mov    (%eax),%eax
    7f77:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7f7a:	c1 ea 08             	shr    $0x8,%edx
    7f7d:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    7f7f:	8b 45 08             	mov    0x8(%ebp),%eax
    7f82:	8b 00                	mov    (%eax),%eax
    7f84:	83 c0 01             	add    $0x1,%eax
    7f87:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7f8a:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    7f8c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7f93:	eb 1e                	jmp    7fb3 <lodepng_zlib_compress+0x144>
    7f95:	8b 45 08             	mov    0x8(%ebp),%eax
    7f98:	8b 00                	mov    (%eax),%eax
    7f9a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7f9d:	83 c2 02             	add    $0x2,%edx
    7fa0:	01 c2                	add    %eax,%edx
    7fa2:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    7fa5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7fa8:	01 c8                	add    %ecx,%eax
    7faa:	0f b6 00             	movzbl (%eax),%eax
    7fad:	88 02                	mov    %al,(%edx)
    7faf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7fb3:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7fb6:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    7fb9:	75 da                	jne    7f95 <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    7fbb:	8b 45 08             	mov    0x8(%ebp),%eax
    7fbe:	8b 10                	mov    (%eax),%edx
    7fc0:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fc3:	8b 00                	mov    (%eax),%eax
    7fc5:	83 e8 04             	sub    $0x4,%eax
    7fc8:	01 d0                	add    %edx,%eax
    7fca:	83 ec 08             	sub    $0x8,%esp
    7fcd:	ff 75 ec             	pushl  -0x14(%ebp)
    7fd0:	50                   	push   %eax
    7fd1:	e8 c8 b6 ff ff       	call   369e <lodepng_set32bitInt>
    7fd6:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    7fd9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7fdc:	83 ec 0c             	sub    $0xc,%esp
    7fdf:	50                   	push   %eax
    7fe0:	e8 19 b3 ff ff       	call   32fe <lodepng_free>
    7fe5:	83 c4 10             	add    $0x10,%esp
  return error;
    7fe8:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    7feb:	c9                   	leave  
    7fec:	c3                   	ret    

00007fed <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    7fed:	55                   	push   %ebp
    7fee:	89 e5                	mov    %esp,%ebp
    7ff0:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    7ff3:	8b 45 18             	mov    0x18(%ebp),%eax
    7ff6:	8b 40 18             	mov    0x18(%eax),%eax
    7ff9:	85 c0                	test   %eax,%eax
    7ffb:	74 34                	je     8031 <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    7ffd:	8b 45 18             	mov    0x18(%ebp),%eax
    8000:	8b 40 18             	mov    0x18(%eax),%eax
    8003:	83 ec 0c             	sub    $0xc,%esp
    8006:	ff 75 18             	pushl  0x18(%ebp)
    8009:	ff 75 14             	pushl  0x14(%ebp)
    800c:	ff 75 10             	pushl  0x10(%ebp)
    800f:	ff 75 0c             	pushl  0xc(%ebp)
    8012:	ff 75 08             	pushl  0x8(%ebp)
    8015:	ff d0                	call   *%eax
    8017:	83 c4 20             	add    $0x20,%esp
    801a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    801d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8021:	74 07                	je     802a <zlib_compress+0x3d>
    8023:	b8 6f 00 00 00       	mov    $0x6f,%eax
    8028:	eb 21                	jmp    804b <zlib_compress+0x5e>
    802a:	b8 00 00 00 00       	mov    $0x0,%eax
    802f:	eb 1a                	jmp    804b <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    8031:	83 ec 0c             	sub    $0xc,%esp
    8034:	ff 75 18             	pushl  0x18(%ebp)
    8037:	ff 75 14             	pushl  0x14(%ebp)
    803a:	ff 75 10             	pushl  0x10(%ebp)
    803d:	ff 75 0c             	pushl  0xc(%ebp)
    8040:	ff 75 08             	pushl  0x8(%ebp)
    8043:	e8 27 fe ff ff       	call   7e6f <lodepng_zlib_compress>
    8048:	83 c4 20             	add    $0x20,%esp
  }
}
    804b:	c9                   	leave  
    804c:	c3                   	ret    

0000804d <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    804d:	55                   	push   %ebp
    804e:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    8050:	8b 45 08             	mov    0x8(%ebp),%eax
    8053:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    8059:	8b 45 08             	mov    0x8(%ebp),%eax
    805c:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    8063:	8b 45 08             	mov    0x8(%ebp),%eax
    8066:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    806d:	8b 45 08             	mov    0x8(%ebp),%eax
    8070:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    8077:	8b 45 08             	mov    0x8(%ebp),%eax
    807a:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    8081:	8b 45 08             	mov    0x8(%ebp),%eax
    8084:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    808b:	8b 45 08             	mov    0x8(%ebp),%eax
    808e:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    8095:	8b 45 08             	mov    0x8(%ebp),%eax
    8098:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    809f:	8b 45 08             	mov    0x8(%ebp),%eax
    80a2:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    80a9:	90                   	nop
    80aa:	5d                   	pop    %ebp
    80ab:	c3                   	ret    

000080ac <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    80ac:	55                   	push   %ebp
    80ad:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    80af:	8b 45 08             	mov    0x8(%ebp),%eax
    80b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    80b8:	8b 45 08             	mov    0x8(%ebp),%eax
    80bb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    80c2:	8b 45 08             	mov    0x8(%ebp),%eax
    80c5:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    80cc:	8b 45 08             	mov    0x8(%ebp),%eax
    80cf:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    80d6:	8b 45 08             	mov    0x8(%ebp),%eax
    80d9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    80e0:	8b 45 08             	mov    0x8(%ebp),%eax
    80e3:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    80ea:	90                   	nop
    80eb:	5d                   	pop    %ebp
    80ec:	c3                   	ret    

000080ed <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    80ed:	55                   	push   %ebp
    80ee:	89 e5                	mov    %esp,%ebp
    80f0:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    80f3:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    80fa:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8101:	eb 2a                	jmp    812d <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    8103:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8106:	8b 45 08             	mov    0x8(%ebp),%eax
    8109:	01 d0                	add    %edx,%eax
    810b:	0f b6 00             	movzbl (%eax),%eax
    810e:	0f b6 c0             	movzbl %al,%eax
    8111:	33 45 fc             	xor    -0x4(%ebp),%eax
    8114:	0f b6 c0             	movzbl %al,%eax
    8117:	8b 04 85 c0 e0 01 00 	mov    0x1e0c0(,%eax,4),%eax
    811e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8121:	c1 ea 08             	shr    $0x8,%edx
    8124:	31 d0                	xor    %edx,%eax
    8126:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    8129:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    812d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8130:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8133:	7c ce                	jl     8103 <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    8135:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8138:	f7 d0                	not    %eax
}
    813a:	c9                   	leave  
    813b:	c3                   	ret    

0000813c <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    813c:	55                   	push   %ebp
    813d:	89 e5                	mov    %esp,%ebp
    813f:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    8142:	8b 45 08             	mov    0x8(%ebp),%eax
    8145:	8b 00                	mov    (%eax),%eax
    8147:	c1 f8 03             	sar    $0x3,%eax
    814a:	89 c2                	mov    %eax,%edx
    814c:	8b 45 0c             	mov    0xc(%ebp),%eax
    814f:	01 d0                	add    %edx,%eax
    8151:	0f b6 00             	movzbl (%eax),%eax
    8154:	0f b6 d0             	movzbl %al,%edx
    8157:	8b 45 08             	mov    0x8(%ebp),%eax
    815a:	8b 00                	mov    (%eax),%eax
    815c:	f7 d0                	not    %eax
    815e:	83 e0 07             	and    $0x7,%eax
    8161:	89 c1                	mov    %eax,%ecx
    8163:	d3 fa                	sar    %cl,%edx
    8165:	89 d0                	mov    %edx,%eax
    8167:	83 e0 01             	and    $0x1,%eax
    816a:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    816d:	8b 45 08             	mov    0x8(%ebp),%eax
    8170:	8b 00                	mov    (%eax),%eax
    8172:	8d 50 01             	lea    0x1(%eax),%edx
    8175:	8b 45 08             	mov    0x8(%ebp),%eax
    8178:	89 10                	mov    %edx,(%eax)
  return result;
    817a:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    817e:	c9                   	leave  
    817f:	c3                   	ret    

00008180 <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    8180:	55                   	push   %ebp
    8181:	89 e5                	mov    %esp,%ebp
    8183:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    8186:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    818d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8194:	eb 1b                	jmp    81b1 <readBitsFromReversedStream+0x31>
    result <<= 1u;
    8196:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    8199:	ff 75 0c             	pushl  0xc(%ebp)
    819c:	ff 75 08             	pushl  0x8(%ebp)
    819f:	e8 98 ff ff ff       	call   813c <readBitFromReversedStream>
    81a4:	83 c4 08             	add    $0x8,%esp
    81a7:	0f b6 c0             	movzbl %al,%eax
    81aa:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    81ad:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    81b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    81b4:	3b 45 10             	cmp    0x10(%ebp),%eax
    81b7:	7c dd                	jl     8196 <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    81b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    81bc:	c9                   	leave  
    81bd:	c3                   	ret    

000081be <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    81be:	55                   	push   %ebp
    81bf:	89 e5                	mov    %esp,%ebp
    81c1:	56                   	push   %esi
    81c2:	53                   	push   %ebx
    81c3:	83 ec 04             	sub    $0x4,%esp
    81c6:	8b 45 10             	mov    0x10(%ebp),%eax
    81c9:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    81cc:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    81d0:	75 3e                	jne    8210 <setBitOfReversedStream+0x52>
    81d2:	8b 45 08             	mov    0x8(%ebp),%eax
    81d5:	8b 00                	mov    (%eax),%eax
    81d7:	c1 f8 03             	sar    $0x3,%eax
    81da:	89 c2                	mov    %eax,%edx
    81dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    81df:	01 c2                	add    %eax,%edx
    81e1:	8b 45 08             	mov    0x8(%ebp),%eax
    81e4:	8b 00                	mov    (%eax),%eax
    81e6:	c1 f8 03             	sar    $0x3,%eax
    81e9:	89 c1                	mov    %eax,%ecx
    81eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    81ee:	01 c8                	add    %ecx,%eax
    81f0:	0f b6 18             	movzbl (%eax),%ebx
    81f3:	8b 45 08             	mov    0x8(%ebp),%eax
    81f6:	8b 00                	mov    (%eax),%eax
    81f8:	f7 d0                	not    %eax
    81fa:	83 e0 07             	and    $0x7,%eax
    81fd:	be 01 00 00 00       	mov    $0x1,%esi
    8202:	89 c1                	mov    %eax,%ecx
    8204:	d3 e6                	shl    %cl,%esi
    8206:	89 f0                	mov    %esi,%eax
    8208:	f7 d0                	not    %eax
    820a:	21 d8                	and    %ebx,%eax
    820c:	88 02                	mov    %al,(%edx)
    820e:	eb 3a                	jmp    824a <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    8210:	8b 45 08             	mov    0x8(%ebp),%eax
    8213:	8b 00                	mov    (%eax),%eax
    8215:	c1 f8 03             	sar    $0x3,%eax
    8218:	89 c2                	mov    %eax,%edx
    821a:	8b 45 0c             	mov    0xc(%ebp),%eax
    821d:	01 c2                	add    %eax,%edx
    821f:	8b 45 08             	mov    0x8(%ebp),%eax
    8222:	8b 00                	mov    (%eax),%eax
    8224:	c1 f8 03             	sar    $0x3,%eax
    8227:	89 c1                	mov    %eax,%ecx
    8229:	8b 45 0c             	mov    0xc(%ebp),%eax
    822c:	01 c8                	add    %ecx,%eax
    822e:	0f b6 18             	movzbl (%eax),%ebx
    8231:	8b 45 08             	mov    0x8(%ebp),%eax
    8234:	8b 00                	mov    (%eax),%eax
    8236:	f7 d0                	not    %eax
    8238:	83 e0 07             	and    $0x7,%eax
    823b:	be 01 00 00 00       	mov    $0x1,%esi
    8240:	89 c1                	mov    %eax,%ecx
    8242:	d3 e6                	shl    %cl,%esi
    8244:	89 f0                	mov    %esi,%eax
    8246:	09 d8                	or     %ebx,%eax
    8248:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    824a:	8b 45 08             	mov    0x8(%ebp),%eax
    824d:	8b 00                	mov    (%eax),%eax
    824f:	8d 50 01             	lea    0x1(%eax),%edx
    8252:	8b 45 08             	mov    0x8(%ebp),%eax
    8255:	89 10                	mov    %edx,(%eax)
}
    8257:	90                   	nop
    8258:	83 c4 04             	add    $0x4,%esp
    825b:	5b                   	pop    %ebx
    825c:	5e                   	pop    %esi
    825d:	5d                   	pop    %ebp
    825e:	c3                   	ret    

0000825f <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    825f:	55                   	push   %ebp
    8260:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    8262:	ff 75 08             	pushl  0x8(%ebp)
    8265:	e8 f1 b3 ff ff       	call   365b <lodepng_read32bitInt>
    826a:	83 c4 04             	add    $0x4,%esp
}
    826d:	c9                   	leave  
    826e:	c3                   	ret    

0000826f <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    826f:	55                   	push   %ebp
    8270:	89 e5                	mov    %esp,%ebp
    8272:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    8275:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    827c:	eb 1c                	jmp    829a <lodepng_chunk_type+0x2b>
    827e:	8b 55 08             	mov    0x8(%ebp),%edx
    8281:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8284:	01 d0                	add    %edx,%eax
    8286:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8289:	8d 4a 04             	lea    0x4(%edx),%ecx
    828c:	8b 55 0c             	mov    0xc(%ebp),%edx
    828f:	01 ca                	add    %ecx,%edx
    8291:	0f b6 12             	movzbl (%edx),%edx
    8294:	88 10                	mov    %dl,(%eax)
    8296:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    829a:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    829e:	75 de                	jne    827e <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    82a0:	8b 45 08             	mov    0x8(%ebp),%eax
    82a3:	83 c0 04             	add    $0x4,%eax
    82a6:	c6 00 00             	movb   $0x0,(%eax)
}
    82a9:	90                   	nop
    82aa:	c9                   	leave  
    82ab:	c3                   	ret    

000082ac <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    82ac:	55                   	push   %ebp
    82ad:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    82af:	ff 75 0c             	pushl  0xc(%ebp)
    82b2:	e8 c2 b0 ff ff       	call   3379 <lodepng_strlen>
    82b7:	83 c4 04             	add    $0x4,%esp
    82ba:	83 f8 04             	cmp    $0x4,%eax
    82bd:	74 07                	je     82c6 <lodepng_chunk_type_equals+0x1a>
    82bf:	b8 00 00 00 00       	mov    $0x0,%eax
    82c4:	eb 79                	jmp    833f <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    82c6:	8b 45 08             	mov    0x8(%ebp),%eax
    82c9:	83 c0 04             	add    $0x4,%eax
    82cc:	0f b6 00             	movzbl (%eax),%eax
    82cf:	0f b6 d0             	movzbl %al,%edx
    82d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    82d5:	0f b6 00             	movzbl (%eax),%eax
    82d8:	0f be c0             	movsbl %al,%eax
    82db:	39 c2                	cmp    %eax,%edx
    82dd:	75 5b                	jne    833a <lodepng_chunk_type_equals+0x8e>
    82df:	8b 45 08             	mov    0x8(%ebp),%eax
    82e2:	83 c0 05             	add    $0x5,%eax
    82e5:	0f b6 00             	movzbl (%eax),%eax
    82e8:	0f b6 d0             	movzbl %al,%edx
    82eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    82ee:	83 c0 01             	add    $0x1,%eax
    82f1:	0f b6 00             	movzbl (%eax),%eax
    82f4:	0f be c0             	movsbl %al,%eax
    82f7:	39 c2                	cmp    %eax,%edx
    82f9:	75 3f                	jne    833a <lodepng_chunk_type_equals+0x8e>
    82fb:	8b 45 08             	mov    0x8(%ebp),%eax
    82fe:	83 c0 06             	add    $0x6,%eax
    8301:	0f b6 00             	movzbl (%eax),%eax
    8304:	0f b6 d0             	movzbl %al,%edx
    8307:	8b 45 0c             	mov    0xc(%ebp),%eax
    830a:	83 c0 02             	add    $0x2,%eax
    830d:	0f b6 00             	movzbl (%eax),%eax
    8310:	0f be c0             	movsbl %al,%eax
    8313:	39 c2                	cmp    %eax,%edx
    8315:	75 23                	jne    833a <lodepng_chunk_type_equals+0x8e>
    8317:	8b 45 08             	mov    0x8(%ebp),%eax
    831a:	83 c0 07             	add    $0x7,%eax
    831d:	0f b6 00             	movzbl (%eax),%eax
    8320:	0f b6 d0             	movzbl %al,%edx
    8323:	8b 45 0c             	mov    0xc(%ebp),%eax
    8326:	83 c0 03             	add    $0x3,%eax
    8329:	0f b6 00             	movzbl (%eax),%eax
    832c:	0f be c0             	movsbl %al,%eax
    832f:	39 c2                	cmp    %eax,%edx
    8331:	75 07                	jne    833a <lodepng_chunk_type_equals+0x8e>
    8333:	b8 01 00 00 00       	mov    $0x1,%eax
    8338:	eb 05                	jmp    833f <lodepng_chunk_type_equals+0x93>
    833a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    833f:	c9                   	leave  
    8340:	c3                   	ret    

00008341 <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    8341:	55                   	push   %ebp
    8342:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    8344:	8b 45 08             	mov    0x8(%ebp),%eax
    8347:	83 c0 04             	add    $0x4,%eax
    834a:	0f b6 00             	movzbl (%eax),%eax
    834d:	0f b6 c0             	movzbl %al,%eax
    8350:	83 e0 20             	and    $0x20,%eax
    8353:	85 c0                	test   %eax,%eax
    8355:	0f 95 c0             	setne  %al
}
    8358:	5d                   	pop    %ebp
    8359:	c3                   	ret    

0000835a <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    835a:	55                   	push   %ebp
    835b:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    835d:	8b 45 08             	mov    0x8(%ebp),%eax
    8360:	83 c0 06             	add    $0x6,%eax
    8363:	0f b6 00             	movzbl (%eax),%eax
    8366:	0f b6 c0             	movzbl %al,%eax
    8369:	83 e0 20             	and    $0x20,%eax
    836c:	85 c0                	test   %eax,%eax
    836e:	0f 95 c0             	setne  %al
}
    8371:	5d                   	pop    %ebp
    8372:	c3                   	ret    

00008373 <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    8373:	55                   	push   %ebp
    8374:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    8376:	8b 45 08             	mov    0x8(%ebp),%eax
    8379:	83 c0 07             	add    $0x7,%eax
    837c:	0f b6 00             	movzbl (%eax),%eax
    837f:	0f b6 c0             	movzbl %al,%eax
    8382:	83 e0 20             	and    $0x20,%eax
    8385:	85 c0                	test   %eax,%eax
    8387:	0f 95 c0             	setne  %al
}
    838a:	5d                   	pop    %ebp
    838b:	c3                   	ret    

0000838c <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    838c:	55                   	push   %ebp
    838d:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    838f:	8b 45 08             	mov    0x8(%ebp),%eax
    8392:	83 c0 08             	add    $0x8,%eax
}
    8395:	5d                   	pop    %ebp
    8396:	c3                   	ret    

00008397 <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    8397:	55                   	push   %ebp
    8398:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    839a:	8b 45 08             	mov    0x8(%ebp),%eax
    839d:	83 c0 08             	add    $0x8,%eax
}
    83a0:	5d                   	pop    %ebp
    83a1:	c3                   	ret    

000083a2 <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    83a2:	55                   	push   %ebp
    83a3:	89 e5                	mov    %esp,%ebp
    83a5:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    83a8:	ff 75 08             	pushl  0x8(%ebp)
    83ab:	e8 af fe ff ff       	call   825f <lodepng_chunk_length>
    83b0:	83 c4 04             	add    $0x4,%esp
    83b3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    83b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    83b9:	8d 50 08             	lea    0x8(%eax),%edx
    83bc:	8b 45 08             	mov    0x8(%ebp),%eax
    83bf:	01 d0                	add    %edx,%eax
    83c1:	50                   	push   %eax
    83c2:	e8 94 b2 ff ff       	call   365b <lodepng_read32bitInt>
    83c7:	83 c4 04             	add    $0x4,%esp
    83ca:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    83cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    83d0:	83 c0 04             	add    $0x4,%eax
    83d3:	89 c2                	mov    %eax,%edx
    83d5:	8b 45 08             	mov    0x8(%ebp),%eax
    83d8:	83 c0 04             	add    $0x4,%eax
    83db:	52                   	push   %edx
    83dc:	50                   	push   %eax
    83dd:	e8 0b fd ff ff       	call   80ed <lodepng_crc32>
    83e2:	83 c4 08             	add    $0x8,%esp
    83e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    83e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    83eb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    83ee:	74 07                	je     83f7 <lodepng_chunk_check_crc+0x55>
    83f0:	b8 01 00 00 00       	mov    $0x1,%eax
    83f5:	eb 05                	jmp    83fc <lodepng_chunk_check_crc+0x5a>
  else return 0;
    83f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    83fc:	c9                   	leave  
    83fd:	c3                   	ret    

000083fe <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    83fe:	55                   	push   %ebp
    83ff:	89 e5                	mov    %esp,%ebp
    8401:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    8404:	ff 75 08             	pushl  0x8(%ebp)
    8407:	e8 53 fe ff ff       	call   825f <lodepng_chunk_length>
    840c:	83 c4 04             	add    $0x4,%esp
    840f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    8412:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8415:	83 c0 04             	add    $0x4,%eax
    8418:	89 c2                	mov    %eax,%edx
    841a:	8b 45 08             	mov    0x8(%ebp),%eax
    841d:	83 c0 04             	add    $0x4,%eax
    8420:	52                   	push   %edx
    8421:	50                   	push   %eax
    8422:	e8 c6 fc ff ff       	call   80ed <lodepng_crc32>
    8427:	83 c4 08             	add    $0x8,%esp
    842a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    842d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8430:	8d 50 08             	lea    0x8(%eax),%edx
    8433:	8b 45 08             	mov    0x8(%ebp),%eax
    8436:	01 d0                	add    %edx,%eax
    8438:	ff 75 f8             	pushl  -0x8(%ebp)
    843b:	50                   	push   %eax
    843c:	e8 5d b2 ff ff       	call   369e <lodepng_set32bitInt>
    8441:	83 c4 08             	add    $0x8,%esp
}
    8444:	90                   	nop
    8445:	c9                   	leave  
    8446:	c3                   	ret    

00008447 <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    8447:	55                   	push   %ebp
    8448:	89 e5                	mov    %esp,%ebp
    844a:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    844d:	8b 45 08             	mov    0x8(%ebp),%eax
    8450:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8453:	73 0f                	jae    8464 <lodepng_chunk_next+0x1d>
    8455:	8b 55 0c             	mov    0xc(%ebp),%edx
    8458:	8b 45 08             	mov    0x8(%ebp),%eax
    845b:	29 c2                	sub    %eax,%edx
    845d:	89 d0                	mov    %edx,%eax
    845f:	83 f8 0b             	cmp    $0xb,%eax
    8462:	7f 08                	jg     846c <lodepng_chunk_next+0x25>
    8464:	8b 45 0c             	mov    0xc(%ebp),%eax
    8467:	e9 af 00 00 00       	jmp    851b <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    846c:	8b 45 08             	mov    0x8(%ebp),%eax
    846f:	0f b6 00             	movzbl (%eax),%eax
    8472:	3c 89                	cmp    $0x89,%al
    8474:	75 63                	jne    84d9 <lodepng_chunk_next+0x92>
    8476:	8b 45 08             	mov    0x8(%ebp),%eax
    8479:	83 c0 01             	add    $0x1,%eax
    847c:	0f b6 00             	movzbl (%eax),%eax
    847f:	3c 50                	cmp    $0x50,%al
    8481:	75 56                	jne    84d9 <lodepng_chunk_next+0x92>
    8483:	8b 45 08             	mov    0x8(%ebp),%eax
    8486:	83 c0 02             	add    $0x2,%eax
    8489:	0f b6 00             	movzbl (%eax),%eax
    848c:	3c 4e                	cmp    $0x4e,%al
    848e:	75 49                	jne    84d9 <lodepng_chunk_next+0x92>
    8490:	8b 45 08             	mov    0x8(%ebp),%eax
    8493:	83 c0 03             	add    $0x3,%eax
    8496:	0f b6 00             	movzbl (%eax),%eax
    8499:	3c 47                	cmp    $0x47,%al
    849b:	75 3c                	jne    84d9 <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    849d:	8b 45 08             	mov    0x8(%ebp),%eax
    84a0:	83 c0 04             	add    $0x4,%eax
    84a3:	0f b6 00             	movzbl (%eax),%eax
    84a6:	3c 0d                	cmp    $0xd,%al
    84a8:	75 2f                	jne    84d9 <lodepng_chunk_next+0x92>
    84aa:	8b 45 08             	mov    0x8(%ebp),%eax
    84ad:	83 c0 05             	add    $0x5,%eax
    84b0:	0f b6 00             	movzbl (%eax),%eax
    84b3:	3c 0a                	cmp    $0xa,%al
    84b5:	75 22                	jne    84d9 <lodepng_chunk_next+0x92>
    84b7:	8b 45 08             	mov    0x8(%ebp),%eax
    84ba:	83 c0 06             	add    $0x6,%eax
    84bd:	0f b6 00             	movzbl (%eax),%eax
    84c0:	3c 1a                	cmp    $0x1a,%al
    84c2:	75 15                	jne    84d9 <lodepng_chunk_next+0x92>
    84c4:	8b 45 08             	mov    0x8(%ebp),%eax
    84c7:	83 c0 07             	add    $0x7,%eax
    84ca:	0f b6 00             	movzbl (%eax),%eax
    84cd:	3c 0a                	cmp    $0xa,%al
    84cf:	75 08                	jne    84d9 <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    84d1:	8b 45 08             	mov    0x8(%ebp),%eax
    84d4:	83 c0 08             	add    $0x8,%eax
    84d7:	eb 42                	jmp    851b <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    84d9:	ff 75 08             	pushl  0x8(%ebp)
    84dc:	e8 7e fd ff ff       	call   825f <lodepng_chunk_length>
    84e1:	83 c4 04             	add    $0x4,%esp
    84e4:	89 c2                	mov    %eax,%edx
    84e6:	8d 45 f8             	lea    -0x8(%ebp),%eax
    84e9:	50                   	push   %eax
    84ea:	6a 0c                	push   $0xc
    84ec:	52                   	push   %edx
    84ed:	e8 af ae ff ff       	call   33a1 <lodepng_addofl>
    84f2:	83 c4 0c             	add    $0xc,%esp
    84f5:	85 c0                	test   %eax,%eax
    84f7:	74 05                	je     84fe <lodepng_chunk_next+0xb7>
    84f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    84fc:	eb 1d                	jmp    851b <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    84fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8501:	89 c2                	mov    %eax,%edx
    8503:	8b 45 08             	mov    0x8(%ebp),%eax
    8506:	01 d0                	add    %edx,%eax
    8508:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    850b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    850e:	3b 45 08             	cmp    0x8(%ebp),%eax
    8511:	73 05                	jae    8518 <lodepng_chunk_next+0xd1>
    8513:	8b 45 0c             	mov    0xc(%ebp),%eax
    8516:	eb 03                	jmp    851b <lodepng_chunk_next+0xd4>
    return result;
    8518:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    851b:	c9                   	leave  
    851c:	c3                   	ret    

0000851d <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    851d:	55                   	push   %ebp
    851e:	89 e5                	mov    %esp,%ebp
    8520:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8523:	8b 45 08             	mov    0x8(%ebp),%eax
    8526:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8529:	73 0f                	jae    853a <lodepng_chunk_next_const+0x1d>
    852b:	8b 55 0c             	mov    0xc(%ebp),%edx
    852e:	8b 45 08             	mov    0x8(%ebp),%eax
    8531:	29 c2                	sub    %eax,%edx
    8533:	89 d0                	mov    %edx,%eax
    8535:	83 f8 0b             	cmp    $0xb,%eax
    8538:	7f 08                	jg     8542 <lodepng_chunk_next_const+0x25>
    853a:	8b 45 0c             	mov    0xc(%ebp),%eax
    853d:	e9 af 00 00 00       	jmp    85f1 <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    8542:	8b 45 08             	mov    0x8(%ebp),%eax
    8545:	0f b6 00             	movzbl (%eax),%eax
    8548:	3c 89                	cmp    $0x89,%al
    854a:	75 63                	jne    85af <lodepng_chunk_next_const+0x92>
    854c:	8b 45 08             	mov    0x8(%ebp),%eax
    854f:	83 c0 01             	add    $0x1,%eax
    8552:	0f b6 00             	movzbl (%eax),%eax
    8555:	3c 50                	cmp    $0x50,%al
    8557:	75 56                	jne    85af <lodepng_chunk_next_const+0x92>
    8559:	8b 45 08             	mov    0x8(%ebp),%eax
    855c:	83 c0 02             	add    $0x2,%eax
    855f:	0f b6 00             	movzbl (%eax),%eax
    8562:	3c 4e                	cmp    $0x4e,%al
    8564:	75 49                	jne    85af <lodepng_chunk_next_const+0x92>
    8566:	8b 45 08             	mov    0x8(%ebp),%eax
    8569:	83 c0 03             	add    $0x3,%eax
    856c:	0f b6 00             	movzbl (%eax),%eax
    856f:	3c 47                	cmp    $0x47,%al
    8571:	75 3c                	jne    85af <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    8573:	8b 45 08             	mov    0x8(%ebp),%eax
    8576:	83 c0 04             	add    $0x4,%eax
    8579:	0f b6 00             	movzbl (%eax),%eax
    857c:	3c 0d                	cmp    $0xd,%al
    857e:	75 2f                	jne    85af <lodepng_chunk_next_const+0x92>
    8580:	8b 45 08             	mov    0x8(%ebp),%eax
    8583:	83 c0 05             	add    $0x5,%eax
    8586:	0f b6 00             	movzbl (%eax),%eax
    8589:	3c 0a                	cmp    $0xa,%al
    858b:	75 22                	jne    85af <lodepng_chunk_next_const+0x92>
    858d:	8b 45 08             	mov    0x8(%ebp),%eax
    8590:	83 c0 06             	add    $0x6,%eax
    8593:	0f b6 00             	movzbl (%eax),%eax
    8596:	3c 1a                	cmp    $0x1a,%al
    8598:	75 15                	jne    85af <lodepng_chunk_next_const+0x92>
    859a:	8b 45 08             	mov    0x8(%ebp),%eax
    859d:	83 c0 07             	add    $0x7,%eax
    85a0:	0f b6 00             	movzbl (%eax),%eax
    85a3:	3c 0a                	cmp    $0xa,%al
    85a5:	75 08                	jne    85af <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    85a7:	8b 45 08             	mov    0x8(%ebp),%eax
    85aa:	83 c0 08             	add    $0x8,%eax
    85ad:	eb 42                	jmp    85f1 <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    85af:	ff 75 08             	pushl  0x8(%ebp)
    85b2:	e8 a8 fc ff ff       	call   825f <lodepng_chunk_length>
    85b7:	83 c4 04             	add    $0x4,%esp
    85ba:	89 c2                	mov    %eax,%edx
    85bc:	8d 45 f8             	lea    -0x8(%ebp),%eax
    85bf:	50                   	push   %eax
    85c0:	6a 0c                	push   $0xc
    85c2:	52                   	push   %edx
    85c3:	e8 d9 ad ff ff       	call   33a1 <lodepng_addofl>
    85c8:	83 c4 0c             	add    $0xc,%esp
    85cb:	85 c0                	test   %eax,%eax
    85cd:	74 05                	je     85d4 <lodepng_chunk_next_const+0xb7>
    85cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    85d2:	eb 1d                	jmp    85f1 <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    85d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    85d7:	89 c2                	mov    %eax,%edx
    85d9:	8b 45 08             	mov    0x8(%ebp),%eax
    85dc:	01 d0                	add    %edx,%eax
    85de:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    85e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    85e4:	3b 45 08             	cmp    0x8(%ebp),%eax
    85e7:	73 05                	jae    85ee <lodepng_chunk_next_const+0xd1>
    85e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    85ec:	eb 03                	jmp    85f1 <lodepng_chunk_next_const+0xd4>
    return result;
    85ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    85f1:	c9                   	leave  
    85f2:	c3                   	ret    

000085f3 <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    85f3:	55                   	push   %ebp
    85f4:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    85f6:	8b 45 08             	mov    0x8(%ebp),%eax
    85f9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    85fc:	73 0f                	jae    860d <lodepng_chunk_find+0x1a>
    85fe:	8b 55 0c             	mov    0xc(%ebp),%edx
    8601:	8b 45 08             	mov    0x8(%ebp),%eax
    8604:	29 c2                	sub    %eax,%edx
    8606:	89 d0                	mov    %edx,%eax
    8608:	83 f8 0b             	cmp    $0xb,%eax
    860b:	7f 07                	jg     8614 <lodepng_chunk_find+0x21>
    860d:	b8 00 00 00 00       	mov    $0x0,%eax
    8612:	eb 2a                	jmp    863e <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    8614:	ff 75 10             	pushl  0x10(%ebp)
    8617:	ff 75 08             	pushl  0x8(%ebp)
    861a:	e8 8d fc ff ff       	call   82ac <lodepng_chunk_type_equals>
    861f:	83 c4 08             	add    $0x8,%esp
    8622:	84 c0                	test   %al,%al
    8624:	74 05                	je     862b <lodepng_chunk_find+0x38>
    8626:	8b 45 08             	mov    0x8(%ebp),%eax
    8629:	eb 13                	jmp    863e <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    862b:	ff 75 0c             	pushl  0xc(%ebp)
    862e:	ff 75 08             	pushl  0x8(%ebp)
    8631:	e8 11 fe ff ff       	call   8447 <lodepng_chunk_next>
    8636:	83 c4 08             	add    $0x8,%esp
    8639:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    863c:	eb b8                	jmp    85f6 <lodepng_chunk_find+0x3>
}
    863e:	c9                   	leave  
    863f:	c3                   	ret    

00008640 <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    8640:	55                   	push   %ebp
    8641:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    8643:	8b 45 08             	mov    0x8(%ebp),%eax
    8646:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8649:	73 0f                	jae    865a <lodepng_chunk_find_const+0x1a>
    864b:	8b 55 0c             	mov    0xc(%ebp),%edx
    864e:	8b 45 08             	mov    0x8(%ebp),%eax
    8651:	29 c2                	sub    %eax,%edx
    8653:	89 d0                	mov    %edx,%eax
    8655:	83 f8 0b             	cmp    $0xb,%eax
    8658:	7f 07                	jg     8661 <lodepng_chunk_find_const+0x21>
    865a:	b8 00 00 00 00       	mov    $0x0,%eax
    865f:	eb 2a                	jmp    868b <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    8661:	ff 75 10             	pushl  0x10(%ebp)
    8664:	ff 75 08             	pushl  0x8(%ebp)
    8667:	e8 40 fc ff ff       	call   82ac <lodepng_chunk_type_equals>
    866c:	83 c4 08             	add    $0x8,%esp
    866f:	84 c0                	test   %al,%al
    8671:	74 05                	je     8678 <lodepng_chunk_find_const+0x38>
    8673:	8b 45 08             	mov    0x8(%ebp),%eax
    8676:	eb 13                	jmp    868b <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    8678:	ff 75 0c             	pushl  0xc(%ebp)
    867b:	ff 75 08             	pushl  0x8(%ebp)
    867e:	e8 9a fe ff ff       	call   851d <lodepng_chunk_next_const>
    8683:	83 c4 08             	add    $0x8,%esp
    8686:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8689:	eb b8                	jmp    8643 <lodepng_chunk_find_const+0x3>
}
    868b:	c9                   	leave  
    868c:	c3                   	ret    

0000868d <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    868d:	55                   	push   %ebp
    868e:	89 e5                	mov    %esp,%ebp
    8690:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    8693:	ff 75 10             	pushl  0x10(%ebp)
    8696:	e8 c4 fb ff ff       	call   825f <lodepng_chunk_length>
    869b:	83 c4 04             	add    $0x4,%esp
    869e:	89 c2                	mov    %eax,%edx
    86a0:	8d 45 f0             	lea    -0x10(%ebp),%eax
    86a3:	50                   	push   %eax
    86a4:	6a 0c                	push   $0xc
    86a6:	52                   	push   %edx
    86a7:	e8 f5 ac ff ff       	call   33a1 <lodepng_addofl>
    86ac:	83 c4 0c             	add    $0xc,%esp
    86af:	85 c0                	test   %eax,%eax
    86b1:	74 0a                	je     86bd <lodepng_chunk_append+0x30>
    86b3:	b8 4d 00 00 00       	mov    $0x4d,%eax
    86b8:	e9 96 00 00 00       	jmp    8753 <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    86bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    86c0:	8b 45 0c             	mov    0xc(%ebp),%eax
    86c3:	8b 00                	mov    (%eax),%eax
    86c5:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    86c8:	51                   	push   %ecx
    86c9:	52                   	push   %edx
    86ca:	50                   	push   %eax
    86cb:	e8 d1 ac ff ff       	call   33a1 <lodepng_addofl>
    86d0:	83 c4 0c             	add    $0xc,%esp
    86d3:	85 c0                	test   %eax,%eax
    86d5:	74 07                	je     86de <lodepng_chunk_append+0x51>
    86d7:	b8 4d 00 00 00       	mov    $0x4d,%eax
    86dc:	eb 75                	jmp    8753 <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    86de:	8b 55 ec             	mov    -0x14(%ebp),%edx
    86e1:	8b 45 08             	mov    0x8(%ebp),%eax
    86e4:	8b 00                	mov    (%eax),%eax
    86e6:	52                   	push   %edx
    86e7:	50                   	push   %eax
    86e8:	e8 07 ac ff ff       	call   32f4 <lodepng_realloc>
    86ed:	83 c4 08             	add    $0x8,%esp
    86f0:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    86f3:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    86f7:	75 07                	jne    8700 <lodepng_chunk_append+0x73>
    86f9:	b8 53 00 00 00       	mov    $0x53,%eax
    86fe:	eb 53                	jmp    8753 <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    8700:	8b 45 08             	mov    0x8(%ebp),%eax
    8703:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8706:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    8708:	8b 55 ec             	mov    -0x14(%ebp),%edx
    870b:	8b 45 0c             	mov    0xc(%ebp),%eax
    870e:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    8710:	8b 45 08             	mov    0x8(%ebp),%eax
    8713:	8b 00                	mov    (%eax),%eax
    8715:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    8718:	8b 55 f0             	mov    -0x10(%ebp),%edx
    871b:	29 d1                	sub    %edx,%ecx
    871d:	89 ca                	mov    %ecx,%edx
    871f:	01 d0                	add    %edx,%eax
    8721:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    8724:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    872b:	eb 19                	jmp    8746 <lodepng_chunk_append+0xb9>
    872d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8730:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8733:	01 c2                	add    %eax,%edx
    8735:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8738:	8b 45 fc             	mov    -0x4(%ebp),%eax
    873b:	01 c8                	add    %ecx,%eax
    873d:	0f b6 00             	movzbl (%eax),%eax
    8740:	88 02                	mov    %al,(%edx)
    8742:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8746:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8749:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    874c:	75 df                	jne    872d <lodepng_chunk_append+0xa0>

  return 0;
    874e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8753:	c9                   	leave  
    8754:	c3                   	ret    

00008755 <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    8755:	55                   	push   %ebp
    8756:	89 e5                	mov    %esp,%ebp
    8758:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    875b:	8b 45 0c             	mov    0xc(%ebp),%eax
    875e:	8b 40 04             	mov    0x4(%eax),%eax
    8761:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    8764:	8b 55 10             	mov    0x10(%ebp),%edx
    8767:	8b 45 fc             	mov    -0x4(%ebp),%eax
    876a:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    876d:	51                   	push   %ecx
    876e:	52                   	push   %edx
    876f:	50                   	push   %eax
    8770:	e8 2c ac ff ff       	call   33a1 <lodepng_addofl>
    8775:	83 c4 0c             	add    $0xc,%esp
    8778:	85 c0                	test   %eax,%eax
    877a:	74 07                	je     8783 <lodepng_chunk_init+0x2e>
    877c:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8781:	eb 78                	jmp    87fb <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    8783:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8786:	8d 55 fc             	lea    -0x4(%ebp),%edx
    8789:	52                   	push   %edx
    878a:	6a 0c                	push   $0xc
    878c:	50                   	push   %eax
    878d:	e8 0f ac ff ff       	call   33a1 <lodepng_addofl>
    8792:	83 c4 0c             	add    $0xc,%esp
    8795:	85 c0                	test   %eax,%eax
    8797:	74 07                	je     87a0 <lodepng_chunk_init+0x4b>
    8799:	b8 4d 00 00 00       	mov    $0x4d,%eax
    879e:	eb 5b                	jmp    87fb <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    87a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87a3:	50                   	push   %eax
    87a4:	ff 75 0c             	pushl  0xc(%ebp)
    87a7:	e8 8b ad ff ff       	call   3537 <ucvector_resize>
    87ac:	83 c4 08             	add    $0x8,%esp
    87af:	85 c0                	test   %eax,%eax
    87b1:	75 07                	jne    87ba <lodepng_chunk_init+0x65>
    87b3:	b8 53 00 00 00       	mov    $0x53,%eax
    87b8:	eb 41                	jmp    87fb <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    87ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    87bd:	8b 00                	mov    (%eax),%eax
    87bf:	8b 55 fc             	mov    -0x4(%ebp),%edx
    87c2:	2b 55 10             	sub    0x10(%ebp),%edx
    87c5:	83 ea 0c             	sub    $0xc,%edx
    87c8:	01 c2                	add    %eax,%edx
    87ca:	8b 45 08             	mov    0x8(%ebp),%eax
    87cd:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    87cf:	8b 45 08             	mov    0x8(%ebp),%eax
    87d2:	8b 00                	mov    (%eax),%eax
    87d4:	ff 75 10             	pushl  0x10(%ebp)
    87d7:	50                   	push   %eax
    87d8:	e8 c1 ae ff ff       	call   369e <lodepng_set32bitInt>
    87dd:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    87e0:	8b 45 08             	mov    0x8(%ebp),%eax
    87e3:	8b 00                	mov    (%eax),%eax
    87e5:	83 c0 04             	add    $0x4,%eax
    87e8:	6a 04                	push   $0x4
    87ea:	ff 75 14             	pushl  0x14(%ebp)
    87ed:	50                   	push   %eax
    87ee:	e8 28 ab ff ff       	call   331b <lodepng_memcpy>
    87f3:	83 c4 0c             	add    $0xc,%esp

  return 0;
    87f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    87fb:	c9                   	leave  
    87fc:	c3                   	ret    

000087fd <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    87fd:	55                   	push   %ebp
    87fe:	89 e5                	mov    %esp,%ebp
    8800:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    8803:	ff 75 10             	pushl  0x10(%ebp)
    8806:	ff 75 0c             	pushl  0xc(%ebp)
    8809:	ff 75 08             	pushl  0x8(%ebp)
    880c:	8d 45 f8             	lea    -0x8(%ebp),%eax
    880f:	50                   	push   %eax
    8810:	e8 40 ff ff ff       	call   8755 <lodepng_chunk_init>
    8815:	83 c4 10             	add    $0x10,%esp
    8818:	89 45 fc             	mov    %eax,-0x4(%ebp)
    881b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    881f:	74 05                	je     8826 <lodepng_chunk_createv+0x29>
    8821:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8824:	eb 27                	jmp    884d <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    8826:	8b 45 0c             	mov    0xc(%ebp),%eax
    8829:	8b 55 f8             	mov    -0x8(%ebp),%edx
    882c:	83 c2 08             	add    $0x8,%edx
    882f:	50                   	push   %eax
    8830:	ff 75 14             	pushl  0x14(%ebp)
    8833:	52                   	push   %edx
    8834:	e8 e2 aa ff ff       	call   331b <lodepng_memcpy>
    8839:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    883c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    883f:	50                   	push   %eax
    8840:	e8 b9 fb ff ff       	call   83fe <lodepng_chunk_generate_crc>
    8845:	83 c4 04             	add    $0x4,%esp

  return 0;
    8848:	b8 00 00 00 00       	mov    $0x0,%eax
}
    884d:	c9                   	leave  
    884e:	c3                   	ret    

0000884f <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    884f:	55                   	push   %ebp
    8850:	89 e5                	mov    %esp,%ebp
    8852:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    8855:	8b 45 0c             	mov    0xc(%ebp),%eax
    8858:	8b 08                	mov    (%eax),%ecx
    885a:	8b 45 08             	mov    0x8(%ebp),%eax
    885d:	8b 10                	mov    (%eax),%edx
    885f:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8862:	51                   	push   %ecx
    8863:	52                   	push   %edx
    8864:	50                   	push   %eax
    8865:	e8 34 ad ff ff       	call   359e <ucvector_init>
    886a:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    886d:	ff 75 18             	pushl  0x18(%ebp)
    8870:	ff 75 14             	pushl  0x14(%ebp)
    8873:	ff 75 10             	pushl  0x10(%ebp)
    8876:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8879:	50                   	push   %eax
    887a:	e8 7e ff ff ff       	call   87fd <lodepng_chunk_createv>
    887f:	83 c4 10             	add    $0x10,%esp
    8882:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    8885:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8888:	8b 45 08             	mov    0x8(%ebp),%eax
    888b:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    888d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8890:	8b 45 0c             	mov    0xc(%ebp),%eax
    8893:	89 10                	mov    %edx,(%eax)
  return error;
    8895:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    8898:	c9                   	leave  
    8899:	c3                   	ret    

0000889a <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    889a:	55                   	push   %ebp
    889b:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    889d:	8b 45 08             	mov    0x8(%ebp),%eax
    88a0:	83 f8 03             	cmp    $0x3,%eax
    88a3:	74 6d                	je     8912 <checkColorValidity+0x78>
    88a5:	83 f8 03             	cmp    $0x3,%eax
    88a8:	77 0e                	ja     88b8 <checkColorValidity+0x1e>
    88aa:	85 c0                	test   %eax,%eax
    88ac:	74 28                	je     88d6 <checkColorValidity+0x3c>
    88ae:	83 f8 02             	cmp    $0x2,%eax
    88b1:	74 4c                	je     88ff <checkColorValidity+0x65>
    88b3:	e9 a6 00 00 00       	jmp    895e <checkColorValidity+0xc4>
    88b8:	83 f8 06             	cmp    $0x6,%eax
    88bb:	0f 84 83 00 00 00    	je     8944 <checkColorValidity+0xaa>
    88c1:	3d ff 00 00 00       	cmp    $0xff,%eax
    88c6:	0f 84 8b 00 00 00    	je     8957 <checkColorValidity+0xbd>
    88cc:	83 f8 04             	cmp    $0x4,%eax
    88cf:	74 60                	je     8931 <checkColorValidity+0x97>
    88d1:	e9 88 00 00 00       	jmp    895e <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    88d6:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    88da:	0f 84 85 00 00 00    	je     8965 <checkColorValidity+0xcb>
    88e0:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    88e4:	74 7f                	je     8965 <checkColorValidity+0xcb>
    88e6:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    88ea:	74 79                	je     8965 <checkColorValidity+0xcb>
    88ec:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    88f0:	74 73                	je     8965 <checkColorValidity+0xcb>
    88f2:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    88f6:	74 6d                	je     8965 <checkColorValidity+0xcb>
    88f8:	b8 25 00 00 00       	mov    $0x25,%eax
    88fd:	eb 78                	jmp    8977 <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    88ff:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8903:	74 63                	je     8968 <checkColorValidity+0xce>
    8905:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8909:	74 5d                	je     8968 <checkColorValidity+0xce>
    890b:	b8 25 00 00 00       	mov    $0x25,%eax
    8910:	eb 65                	jmp    8977 <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8912:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8916:	74 53                	je     896b <checkColorValidity+0xd1>
    8918:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    891c:	74 4d                	je     896b <checkColorValidity+0xd1>
    891e:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8922:	74 47                	je     896b <checkColorValidity+0xd1>
    8924:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8928:	74 41                	je     896b <checkColorValidity+0xd1>
    892a:	b8 25 00 00 00       	mov    $0x25,%eax
    892f:	eb 46                	jmp    8977 <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8931:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8935:	74 37                	je     896e <checkColorValidity+0xd4>
    8937:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    893b:	74 31                	je     896e <checkColorValidity+0xd4>
    893d:	b8 25 00 00 00       	mov    $0x25,%eax
    8942:	eb 33                	jmp    8977 <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8944:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8948:	74 27                	je     8971 <checkColorValidity+0xd7>
    894a:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    894e:	74 21                	je     8971 <checkColorValidity+0xd7>
    8950:	b8 25 00 00 00       	mov    $0x25,%eax
    8955:	eb 20                	jmp    8977 <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    8957:	b8 1f 00 00 00       	mov    $0x1f,%eax
    895c:	eb 19                	jmp    8977 <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    895e:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8963:	eb 12                	jmp    8977 <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    8965:	90                   	nop
    8966:	eb 0a                	jmp    8972 <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8968:	90                   	nop
    8969:	eb 07                	jmp    8972 <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    896b:	90                   	nop
    896c:	eb 04                	jmp    8972 <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    896e:	90                   	nop
    896f:	eb 01                	jmp    8972 <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8971:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    8972:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8977:	5d                   	pop    %ebp
    8978:	c3                   	ret    

00008979 <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    8979:	55                   	push   %ebp
    897a:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    897c:	8b 45 08             	mov    0x8(%ebp),%eax
    897f:	83 f8 03             	cmp    $0x3,%eax
    8982:	74 31                	je     89b5 <getNumColorChannels+0x3c>
    8984:	83 f8 03             	cmp    $0x3,%eax
    8987:	77 0b                	ja     8994 <getNumColorChannels+0x1b>
    8989:	85 c0                	test   %eax,%eax
    898b:	74 1a                	je     89a7 <getNumColorChannels+0x2e>
    898d:	83 f8 02             	cmp    $0x2,%eax
    8990:	74 1c                	je     89ae <getNumColorChannels+0x35>
    8992:	eb 3d                	jmp    89d1 <getNumColorChannels+0x58>
    8994:	83 f8 06             	cmp    $0x6,%eax
    8997:	74 2a                	je     89c3 <getNumColorChannels+0x4a>
    8999:	3d ff 00 00 00       	cmp    $0xff,%eax
    899e:	74 2a                	je     89ca <getNumColorChannels+0x51>
    89a0:	83 f8 04             	cmp    $0x4,%eax
    89a3:	74 17                	je     89bc <getNumColorChannels+0x43>
    89a5:	eb 2a                	jmp    89d1 <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    89a7:	b8 01 00 00 00       	mov    $0x1,%eax
    89ac:	eb 28                	jmp    89d6 <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    89ae:	b8 03 00 00 00       	mov    $0x3,%eax
    89b3:	eb 21                	jmp    89d6 <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    89b5:	b8 01 00 00 00       	mov    $0x1,%eax
    89ba:	eb 1a                	jmp    89d6 <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    89bc:	b8 02 00 00 00       	mov    $0x2,%eax
    89c1:	eb 13                	jmp    89d6 <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    89c3:	b8 04 00 00 00       	mov    $0x4,%eax
    89c8:	eb 0c                	jmp    89d6 <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    89ca:	b8 00 00 00 00       	mov    $0x0,%eax
    89cf:	eb 05                	jmp    89d6 <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    89d1:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    89d6:	5d                   	pop    %ebp
    89d7:	c3                   	ret    

000089d8 <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    89d8:	55                   	push   %ebp
    89d9:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    89db:	ff 75 08             	pushl  0x8(%ebp)
    89de:	e8 96 ff ff ff       	call   8979 <getNumColorChannels>
    89e3:	83 c4 04             	add    $0x4,%esp
    89e6:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    89ea:	c9                   	leave  
    89eb:	c3                   	ret    

000089ec <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    89ec:	55                   	push   %ebp
    89ed:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    89ef:	8b 45 08             	mov    0x8(%ebp),%eax
    89f2:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    89f9:	8b 45 08             	mov    0x8(%ebp),%eax
    89fc:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    8a03:	8b 45 08             	mov    0x8(%ebp),%eax
    8a06:	8b 50 1c             	mov    0x1c(%eax),%edx
    8a09:	8b 45 08             	mov    0x8(%ebp),%eax
    8a0c:	89 50 18             	mov    %edx,0x18(%eax)
    8a0f:	8b 45 08             	mov    0x8(%ebp),%eax
    8a12:	8b 50 18             	mov    0x18(%eax),%edx
    8a15:	8b 45 08             	mov    0x8(%ebp),%eax
    8a18:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    8a1b:	8b 45 08             	mov    0x8(%ebp),%eax
    8a1e:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    8a24:	8b 45 08             	mov    0x8(%ebp),%eax
    8a27:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    8a2e:	8b 45 08             	mov    0x8(%ebp),%eax
    8a31:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8a38:	8b 45 08             	mov    0x8(%ebp),%eax
    8a3b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8a42:	90                   	nop
    8a43:	5d                   	pop    %ebp
    8a44:	c3                   	ret    

00008a45 <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    8a45:	55                   	push   %ebp
    8a46:	89 e5                	mov    %esp,%ebp
    8a48:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    8a4b:	8b 45 08             	mov    0x8(%ebp),%eax
    8a4e:	8b 40 08             	mov    0x8(%eax),%eax
    8a51:	85 c0                	test   %eax,%eax
    8a53:	75 18                	jne    8a6d <lodepng_color_mode_alloc_palette+0x28>
    8a55:	83 ec 0c             	sub    $0xc,%esp
    8a58:	68 00 04 00 00       	push   $0x400
    8a5d:	e8 7b a8 ff ff       	call   32dd <lodepng_malloc>
    8a62:	83 c4 10             	add    $0x10,%esp
    8a65:	89 c2                	mov    %eax,%edx
    8a67:	8b 45 08             	mov    0x8(%ebp),%eax
    8a6a:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    8a6d:	8b 45 08             	mov    0x8(%ebp),%eax
    8a70:	8b 40 08             	mov    0x8(%eax),%eax
    8a73:	85 c0                	test   %eax,%eax
    8a75:	74 65                	je     8adc <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    8a77:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8a7e:	eb 51                	jmp    8ad1 <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    8a80:	8b 45 08             	mov    0x8(%ebp),%eax
    8a83:	8b 40 08             	mov    0x8(%eax),%eax
    8a86:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8a89:	c1 e2 02             	shl    $0x2,%edx
    8a8c:	01 d0                	add    %edx,%eax
    8a8e:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    8a91:	8b 45 08             	mov    0x8(%ebp),%eax
    8a94:	8b 40 08             	mov    0x8(%eax),%eax
    8a97:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8a9a:	c1 e2 02             	shl    $0x2,%edx
    8a9d:	83 c2 01             	add    $0x1,%edx
    8aa0:	01 d0                	add    %edx,%eax
    8aa2:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    8aa5:	8b 45 08             	mov    0x8(%ebp),%eax
    8aa8:	8b 40 08             	mov    0x8(%eax),%eax
    8aab:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8aae:	c1 e2 02             	shl    $0x2,%edx
    8ab1:	83 c2 02             	add    $0x2,%edx
    8ab4:	01 d0                	add    %edx,%eax
    8ab6:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    8ab9:	8b 45 08             	mov    0x8(%ebp),%eax
    8abc:	8b 40 08             	mov    0x8(%eax),%eax
    8abf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8ac2:	c1 e2 02             	shl    $0x2,%edx
    8ac5:	83 c2 03             	add    $0x3,%edx
    8ac8:	01 d0                	add    %edx,%eax
    8aca:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    8acd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8ad1:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    8ad8:	75 a6                	jne    8a80 <lodepng_color_mode_alloc_palette+0x3b>
    8ada:	eb 01                	jmp    8add <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    8adc:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    8add:	c9                   	leave  
    8ade:	c3                   	ret    

00008adf <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    8adf:	55                   	push   %ebp
    8ae0:	89 e5                	mov    %esp,%ebp
    8ae2:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    8ae5:	83 ec 0c             	sub    $0xc,%esp
    8ae8:	ff 75 08             	pushl  0x8(%ebp)
    8aeb:	e8 f3 01 00 00       	call   8ce3 <lodepng_palette_clear>
    8af0:	83 c4 10             	add    $0x10,%esp
}
    8af3:	90                   	nop
    8af4:	c9                   	leave  
    8af5:	c3                   	ret    

00008af6 <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    8af6:	55                   	push   %ebp
    8af7:	89 e5                	mov    %esp,%ebp
    8af9:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    8afc:	83 ec 0c             	sub    $0xc,%esp
    8aff:	ff 75 08             	pushl  0x8(%ebp)
    8b02:	e8 d8 ff ff ff       	call   8adf <lodepng_color_mode_cleanup>
    8b07:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    8b0a:	83 ec 04             	sub    $0x4,%esp
    8b0d:	6a 20                	push   $0x20
    8b0f:	ff 75 0c             	pushl  0xc(%ebp)
    8b12:	ff 75 08             	pushl  0x8(%ebp)
    8b15:	e8 01 a8 ff ff       	call   331b <lodepng_memcpy>
    8b1a:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    8b1d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b20:	8b 40 08             	mov    0x8(%eax),%eax
    8b23:	85 c0                	test   %eax,%eax
    8b25:	74 5a                	je     8b81 <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    8b27:	83 ec 0c             	sub    $0xc,%esp
    8b2a:	68 00 04 00 00       	push   $0x400
    8b2f:	e8 a9 a7 ff ff       	call   32dd <lodepng_malloc>
    8b34:	83 c4 10             	add    $0x10,%esp
    8b37:	89 c2                	mov    %eax,%edx
    8b39:	8b 45 08             	mov    0x8(%ebp),%eax
    8b3c:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    8b3f:	8b 45 08             	mov    0x8(%ebp),%eax
    8b42:	8b 40 08             	mov    0x8(%eax),%eax
    8b45:	85 c0                	test   %eax,%eax
    8b47:	75 11                	jne    8b5a <lodepng_color_mode_copy+0x64>
    8b49:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b4c:	8b 40 0c             	mov    0xc(%eax),%eax
    8b4f:	85 c0                	test   %eax,%eax
    8b51:	74 07                	je     8b5a <lodepng_color_mode_copy+0x64>
    8b53:	b8 53 00 00 00       	mov    $0x53,%eax
    8b58:	eb 2c                	jmp    8b86 <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    8b5a:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b5d:	8b 40 0c             	mov    0xc(%eax),%eax
    8b60:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    8b67:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b6a:	8b 50 08             	mov    0x8(%eax),%edx
    8b6d:	8b 45 08             	mov    0x8(%ebp),%eax
    8b70:	8b 40 08             	mov    0x8(%eax),%eax
    8b73:	83 ec 04             	sub    $0x4,%esp
    8b76:	51                   	push   %ecx
    8b77:	52                   	push   %edx
    8b78:	50                   	push   %eax
    8b79:	e8 9d a7 ff ff       	call   331b <lodepng_memcpy>
    8b7e:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    8b81:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8b86:	c9                   	leave  
    8b87:	c3                   	ret    

00008b88 <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    8b88:	55                   	push   %ebp
    8b89:	89 e5                	mov    %esp,%ebp
    8b8b:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    8b8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
    8b91:	50                   	push   %eax
    8b92:	e8 55 fe ff ff       	call   89ec <lodepng_color_mode_init>
    8b97:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    8b9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b9d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    8ba0:	8b 45 10             	mov    0x10(%ebp),%eax
    8ba3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    8ba6:	8b 45 08             	mov    0x8(%ebp),%eax
    8ba9:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8bac:	89 10                	mov    %edx,(%eax)
    8bae:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8bb1:	89 50 04             	mov    %edx,0x4(%eax)
    8bb4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8bb7:	89 50 08             	mov    %edx,0x8(%eax)
    8bba:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8bbd:	89 50 0c             	mov    %edx,0xc(%eax)
    8bc0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8bc3:	89 50 10             	mov    %edx,0x10(%eax)
    8bc6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8bc9:	89 50 14             	mov    %edx,0x14(%eax)
    8bcc:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8bcf:	89 50 18             	mov    %edx,0x18(%eax)
    8bd2:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8bd5:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    8bd8:	8b 45 08             	mov    0x8(%ebp),%eax
    8bdb:	c9                   	leave  
    8bdc:	c2 04 00             	ret    $0x4

00008bdf <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    8bdf:	55                   	push   %ebp
    8be0:	89 e5                	mov    %esp,%ebp
    8be2:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    8be5:	8b 45 08             	mov    0x8(%ebp),%eax
    8be8:	8b 10                	mov    (%eax),%edx
    8bea:	8b 45 0c             	mov    0xc(%ebp),%eax
    8bed:	8b 00                	mov    (%eax),%eax
    8bef:	39 c2                	cmp    %eax,%edx
    8bf1:	74 0a                	je     8bfd <lodepng_color_mode_equal+0x1e>
    8bf3:	b8 00 00 00 00       	mov    $0x0,%eax
    8bf8:	e9 e4 00 00 00       	jmp    8ce1 <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    8bfd:	8b 45 08             	mov    0x8(%ebp),%eax
    8c00:	8b 50 04             	mov    0x4(%eax),%edx
    8c03:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c06:	8b 40 04             	mov    0x4(%eax),%eax
    8c09:	39 c2                	cmp    %eax,%edx
    8c0b:	74 0a                	je     8c17 <lodepng_color_mode_equal+0x38>
    8c0d:	b8 00 00 00 00       	mov    $0x0,%eax
    8c12:	e9 ca 00 00 00       	jmp    8ce1 <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    8c17:	8b 45 08             	mov    0x8(%ebp),%eax
    8c1a:	8b 50 10             	mov    0x10(%eax),%edx
    8c1d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c20:	8b 40 10             	mov    0x10(%eax),%eax
    8c23:	39 c2                	cmp    %eax,%edx
    8c25:	74 0a                	je     8c31 <lodepng_color_mode_equal+0x52>
    8c27:	b8 00 00 00 00       	mov    $0x0,%eax
    8c2c:	e9 b0 00 00 00       	jmp    8ce1 <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    8c31:	8b 45 08             	mov    0x8(%ebp),%eax
    8c34:	8b 40 10             	mov    0x10(%eax),%eax
    8c37:	85 c0                	test   %eax,%eax
    8c39:	74 48                	je     8c83 <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    8c3b:	8b 45 08             	mov    0x8(%ebp),%eax
    8c3e:	8b 50 14             	mov    0x14(%eax),%edx
    8c41:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c44:	8b 40 14             	mov    0x14(%eax),%eax
    8c47:	39 c2                	cmp    %eax,%edx
    8c49:	74 0a                	je     8c55 <lodepng_color_mode_equal+0x76>
    8c4b:	b8 00 00 00 00       	mov    $0x0,%eax
    8c50:	e9 8c 00 00 00       	jmp    8ce1 <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    8c55:	8b 45 08             	mov    0x8(%ebp),%eax
    8c58:	8b 50 18             	mov    0x18(%eax),%edx
    8c5b:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c5e:	8b 40 18             	mov    0x18(%eax),%eax
    8c61:	39 c2                	cmp    %eax,%edx
    8c63:	74 07                	je     8c6c <lodepng_color_mode_equal+0x8d>
    8c65:	b8 00 00 00 00       	mov    $0x0,%eax
    8c6a:	eb 75                	jmp    8ce1 <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    8c6c:	8b 45 08             	mov    0x8(%ebp),%eax
    8c6f:	8b 50 1c             	mov    0x1c(%eax),%edx
    8c72:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c75:	8b 40 1c             	mov    0x1c(%eax),%eax
    8c78:	39 c2                	cmp    %eax,%edx
    8c7a:	74 07                	je     8c83 <lodepng_color_mode_equal+0xa4>
    8c7c:	b8 00 00 00 00       	mov    $0x0,%eax
    8c81:	eb 5e                	jmp    8ce1 <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    8c83:	8b 45 08             	mov    0x8(%ebp),%eax
    8c86:	8b 50 0c             	mov    0xc(%eax),%edx
    8c89:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c8c:	8b 40 0c             	mov    0xc(%eax),%eax
    8c8f:	39 c2                	cmp    %eax,%edx
    8c91:	74 07                	je     8c9a <lodepng_color_mode_equal+0xbb>
    8c93:	b8 00 00 00 00       	mov    $0x0,%eax
    8c98:	eb 47                	jmp    8ce1 <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    8c9a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8ca1:	eb 2b                	jmp    8cce <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    8ca3:	8b 45 08             	mov    0x8(%ebp),%eax
    8ca6:	8b 50 08             	mov    0x8(%eax),%edx
    8ca9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8cac:	01 d0                	add    %edx,%eax
    8cae:	0f b6 10             	movzbl (%eax),%edx
    8cb1:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cb4:	8b 48 08             	mov    0x8(%eax),%ecx
    8cb7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8cba:	01 c8                	add    %ecx,%eax
    8cbc:	0f b6 00             	movzbl (%eax),%eax
    8cbf:	38 c2                	cmp    %al,%dl
    8cc1:	74 07                	je     8cca <lodepng_color_mode_equal+0xeb>
    8cc3:	b8 00 00 00 00       	mov    $0x0,%eax
    8cc8:	eb 17                	jmp    8ce1 <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    8cca:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8cce:	8b 45 08             	mov    0x8(%ebp),%eax
    8cd1:	8b 40 0c             	mov    0xc(%eax),%eax
    8cd4:	c1 e0 02             	shl    $0x2,%eax
    8cd7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8cda:	75 c7                	jne    8ca3 <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    8cdc:	b8 01 00 00 00       	mov    $0x1,%eax
}
    8ce1:	c9                   	leave  
    8ce2:	c3                   	ret    

00008ce3 <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    8ce3:	55                   	push   %ebp
    8ce4:	89 e5                	mov    %esp,%ebp
    8ce6:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    8ce9:	8b 45 08             	mov    0x8(%ebp),%eax
    8cec:	8b 40 08             	mov    0x8(%eax),%eax
    8cef:	85 c0                	test   %eax,%eax
    8cf1:	74 12                	je     8d05 <lodepng_palette_clear+0x22>
    8cf3:	8b 45 08             	mov    0x8(%ebp),%eax
    8cf6:	8b 40 08             	mov    0x8(%eax),%eax
    8cf9:	83 ec 0c             	sub    $0xc,%esp
    8cfc:	50                   	push   %eax
    8cfd:	e8 fc a5 ff ff       	call   32fe <lodepng_free>
    8d02:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    8d05:	8b 45 08             	mov    0x8(%ebp),%eax
    8d08:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8d0f:	8b 45 08             	mov    0x8(%ebp),%eax
    8d12:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8d19:	90                   	nop
    8d1a:	c9                   	leave  
    8d1b:	c3                   	ret    

00008d1c <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    8d1c:	55                   	push   %ebp
    8d1d:	89 e5                	mov    %esp,%ebp
    8d1f:	53                   	push   %ebx
    8d20:	83 ec 14             	sub    $0x14,%esp
    8d23:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    8d26:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8d29:	8b 55 14             	mov    0x14(%ebp),%edx
    8d2c:	8b 45 18             	mov    0x18(%ebp),%eax
    8d2f:	88 5d f4             	mov    %bl,-0xc(%ebp)
    8d32:	88 4d f0             	mov    %cl,-0x10(%ebp)
    8d35:	88 55 ec             	mov    %dl,-0x14(%ebp)
    8d38:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    8d3b:	8b 45 08             	mov    0x8(%ebp),%eax
    8d3e:	8b 40 08             	mov    0x8(%eax),%eax
    8d41:	85 c0                	test   %eax,%eax
    8d43:	75 22                	jne    8d67 <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    8d45:	83 ec 0c             	sub    $0xc,%esp
    8d48:	ff 75 08             	pushl  0x8(%ebp)
    8d4b:	e8 f5 fc ff ff       	call   8a45 <lodepng_color_mode_alloc_palette>
    8d50:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    8d53:	8b 45 08             	mov    0x8(%ebp),%eax
    8d56:	8b 40 08             	mov    0x8(%eax),%eax
    8d59:	85 c0                	test   %eax,%eax
    8d5b:	75 0a                	jne    8d67 <lodepng_palette_add+0x4b>
    8d5d:	b8 53 00 00 00       	mov    $0x53,%eax
    8d62:	e9 8d 00 00 00       	jmp    8df4 <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    8d67:	8b 45 08             	mov    0x8(%ebp),%eax
    8d6a:	8b 40 0c             	mov    0xc(%eax),%eax
    8d6d:	3d ff 00 00 00       	cmp    $0xff,%eax
    8d72:	7e 07                	jle    8d7b <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    8d74:	b8 6c 00 00 00       	mov    $0x6c,%eax
    8d79:	eb 79                	jmp    8df4 <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    8d7b:	8b 45 08             	mov    0x8(%ebp),%eax
    8d7e:	8b 50 08             	mov    0x8(%eax),%edx
    8d81:	8b 45 08             	mov    0x8(%ebp),%eax
    8d84:	8b 40 0c             	mov    0xc(%eax),%eax
    8d87:	c1 e0 02             	shl    $0x2,%eax
    8d8a:	01 c2                	add    %eax,%edx
    8d8c:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    8d90:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    8d92:	8b 45 08             	mov    0x8(%ebp),%eax
    8d95:	8b 50 08             	mov    0x8(%eax),%edx
    8d98:	8b 45 08             	mov    0x8(%ebp),%eax
    8d9b:	8b 40 0c             	mov    0xc(%eax),%eax
    8d9e:	c1 e0 02             	shl    $0x2,%eax
    8da1:	83 c0 01             	add    $0x1,%eax
    8da4:	01 c2                	add    %eax,%edx
    8da6:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    8daa:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    8dac:	8b 45 08             	mov    0x8(%ebp),%eax
    8daf:	8b 50 08             	mov    0x8(%eax),%edx
    8db2:	8b 45 08             	mov    0x8(%ebp),%eax
    8db5:	8b 40 0c             	mov    0xc(%eax),%eax
    8db8:	c1 e0 02             	shl    $0x2,%eax
    8dbb:	83 c0 02             	add    $0x2,%eax
    8dbe:	01 c2                	add    %eax,%edx
    8dc0:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    8dc4:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    8dc6:	8b 45 08             	mov    0x8(%ebp),%eax
    8dc9:	8b 50 08             	mov    0x8(%eax),%edx
    8dcc:	8b 45 08             	mov    0x8(%ebp),%eax
    8dcf:	8b 40 0c             	mov    0xc(%eax),%eax
    8dd2:	c1 e0 02             	shl    $0x2,%eax
    8dd5:	83 c0 03             	add    $0x3,%eax
    8dd8:	01 c2                	add    %eax,%edx
    8dda:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    8dde:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    8de0:	8b 45 08             	mov    0x8(%ebp),%eax
    8de3:	8b 40 0c             	mov    0xc(%eax),%eax
    8de6:	8d 50 01             	lea    0x1(%eax),%edx
    8de9:	8b 45 08             	mov    0x8(%ebp),%eax
    8dec:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    8def:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8df4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8df7:	c9                   	leave  
    8df8:	c3                   	ret    

00008df9 <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    8df9:	55                   	push   %ebp
    8dfa:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    8dfc:	8b 45 08             	mov    0x8(%ebp),%eax
    8dff:	8b 50 04             	mov    0x4(%eax),%edx
    8e02:	8b 45 08             	mov    0x8(%ebp),%eax
    8e05:	8b 00                	mov    (%eax),%eax
    8e07:	52                   	push   %edx
    8e08:	50                   	push   %eax
    8e09:	e8 ca fb ff ff       	call   89d8 <lodepng_get_bpp_lct>
    8e0e:	83 c4 08             	add    $0x8,%esp
}
    8e11:	c9                   	leave  
    8e12:	c3                   	ret    

00008e13 <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    8e13:	55                   	push   %ebp
    8e14:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    8e16:	8b 45 08             	mov    0x8(%ebp),%eax
    8e19:	8b 00                	mov    (%eax),%eax
    8e1b:	50                   	push   %eax
    8e1c:	e8 58 fb ff ff       	call   8979 <getNumColorChannels>
    8e21:	83 c4 04             	add    $0x4,%esp
}
    8e24:	c9                   	leave  
    8e25:	c3                   	ret    

00008e26 <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    8e26:	55                   	push   %ebp
    8e27:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    8e29:	8b 45 08             	mov    0x8(%ebp),%eax
    8e2c:	8b 00                	mov    (%eax),%eax
    8e2e:	85 c0                	test   %eax,%eax
    8e30:	74 0a                	je     8e3c <lodepng_is_greyscale_type+0x16>
    8e32:	8b 45 08             	mov    0x8(%ebp),%eax
    8e35:	8b 00                	mov    (%eax),%eax
    8e37:	83 f8 04             	cmp    $0x4,%eax
    8e3a:	75 07                	jne    8e43 <lodepng_is_greyscale_type+0x1d>
    8e3c:	b8 01 00 00 00       	mov    $0x1,%eax
    8e41:	eb 05                	jmp    8e48 <lodepng_is_greyscale_type+0x22>
    8e43:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8e48:	5d                   	pop    %ebp
    8e49:	c3                   	ret    

00008e4a <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    8e4a:	55                   	push   %ebp
    8e4b:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    8e4d:	8b 45 08             	mov    0x8(%ebp),%eax
    8e50:	8b 00                	mov    (%eax),%eax
    8e52:	83 e0 04             	and    $0x4,%eax
    8e55:	85 c0                	test   %eax,%eax
    8e57:	0f 95 c0             	setne  %al
    8e5a:	0f b6 c0             	movzbl %al,%eax
}
    8e5d:	5d                   	pop    %ebp
    8e5e:	c3                   	ret    

00008e5f <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    8e5f:	55                   	push   %ebp
    8e60:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    8e62:	8b 45 08             	mov    0x8(%ebp),%eax
    8e65:	8b 00                	mov    (%eax),%eax
    8e67:	83 f8 03             	cmp    $0x3,%eax
    8e6a:	0f 94 c0             	sete   %al
    8e6d:	0f b6 c0             	movzbl %al,%eax
}
    8e70:	5d                   	pop    %ebp
    8e71:	c3                   	ret    

00008e72 <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    8e72:	55                   	push   %ebp
    8e73:	89 e5                	mov    %esp,%ebp
    8e75:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8e78:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8e7f:	eb 23                	jmp    8ea4 <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    8e81:	8b 45 08             	mov    0x8(%ebp),%eax
    8e84:	8b 40 08             	mov    0x8(%eax),%eax
    8e87:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8e8a:	c1 e2 02             	shl    $0x2,%edx
    8e8d:	83 c2 03             	add    $0x3,%edx
    8e90:	01 d0                	add    %edx,%eax
    8e92:	0f b6 00             	movzbl (%eax),%eax
    8e95:	3c ff                	cmp    $0xff,%al
    8e97:	74 07                	je     8ea0 <lodepng_has_palette_alpha+0x2e>
    8e99:	b8 01 00 00 00       	mov    $0x1,%eax
    8e9e:	eb 14                	jmp    8eb4 <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8ea0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8ea4:	8b 45 08             	mov    0x8(%ebp),%eax
    8ea7:	8b 40 0c             	mov    0xc(%eax),%eax
    8eaa:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8ead:	75 d2                	jne    8e81 <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    8eaf:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8eb4:	c9                   	leave  
    8eb5:	c3                   	ret    

00008eb6 <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    8eb6:	55                   	push   %ebp
    8eb7:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    8eb9:	8b 45 08             	mov    0x8(%ebp),%eax
    8ebc:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    8ebf:	85 c0                	test   %eax,%eax
    8ec1:	75 1e                	jne    8ee1 <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    8ec3:	ff 75 08             	pushl  0x8(%ebp)
    8ec6:	e8 7f ff ff ff       	call   8e4a <lodepng_is_alpha_type>
    8ecb:	83 c4 04             	add    $0x4,%esp
    8ece:	85 c0                	test   %eax,%eax
    8ed0:	75 0f                	jne    8ee1 <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    8ed2:	ff 75 08             	pushl  0x8(%ebp)
    8ed5:	e8 98 ff ff ff       	call   8e72 <lodepng_has_palette_alpha>
    8eda:	83 c4 04             	add    $0x4,%esp
    8edd:	85 c0                	test   %eax,%eax
    8edf:	74 07                	je     8ee8 <lodepng_can_have_alpha+0x32>
    8ee1:	b8 01 00 00 00       	mov    $0x1,%eax
    8ee6:	eb 05                	jmp    8eed <lodepng_can_have_alpha+0x37>
    8ee8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8eed:	c9                   	leave  
    8eee:	c3                   	ret    

00008eef <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    8eef:	55                   	push   %ebp
    8ef0:	89 e5                	mov    %esp,%ebp
    8ef2:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    8ef5:	ff 75 14             	pushl  0x14(%ebp)
    8ef8:	ff 75 10             	pushl  0x10(%ebp)
    8efb:	e8 d8 fa ff ff       	call   89d8 <lodepng_get_bpp_lct>
    8f00:	83 c4 08             	add    $0x8,%esp
    8f03:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    8f06:	8b 55 08             	mov    0x8(%ebp),%edx
    8f09:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f0c:	0f af c2             	imul   %edx,%eax
    8f0f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    8f12:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8f15:	c1 e8 03             	shr    $0x3,%eax
    8f18:	89 c2                	mov    %eax,%edx
    8f1a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8f1d:	0f af c2             	imul   %edx,%eax
    8f20:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8f23:	89 d1                	mov    %edx,%ecx
    8f25:	83 e1 07             	and    $0x7,%ecx
    8f28:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8f2b:	0f af d1             	imul   %ecx,%edx
    8f2e:	83 c2 07             	add    $0x7,%edx
    8f31:	c1 ea 03             	shr    $0x3,%edx
    8f34:	01 d0                	add    %edx,%eax
}
    8f36:	c9                   	leave  
    8f37:	c3                   	ret    

00008f38 <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    8f38:	55                   	push   %ebp
    8f39:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    8f3b:	8b 45 10             	mov    0x10(%ebp),%eax
    8f3e:	8b 50 04             	mov    0x4(%eax),%edx
    8f41:	8b 45 10             	mov    0x10(%ebp),%eax
    8f44:	8b 00                	mov    (%eax),%eax
    8f46:	52                   	push   %edx
    8f47:	50                   	push   %eax
    8f48:	ff 75 0c             	pushl  0xc(%ebp)
    8f4b:	ff 75 08             	pushl  0x8(%ebp)
    8f4e:	e8 9c ff ff ff       	call   8eef <lodepng_get_raw_size_lct>
    8f53:	83 c4 10             	add    $0x10,%esp
}
    8f56:	c9                   	leave  
    8f57:	c3                   	ret    

00008f58 <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    8f58:	55                   	push   %ebp
    8f59:	89 e5                	mov    %esp,%ebp
    8f5b:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    8f5e:	8b 45 08             	mov    0x8(%ebp),%eax
    8f61:	c1 e8 03             	shr    $0x3,%eax
    8f64:	0f af 45 10          	imul   0x10(%ebp),%eax
    8f68:	8b 55 08             	mov    0x8(%ebp),%edx
    8f6b:	83 e2 07             	and    $0x7,%edx
    8f6e:	0f af 55 10          	imul   0x10(%ebp),%edx
    8f72:	83 c2 07             	add    $0x7,%edx
    8f75:	c1 ea 03             	shr    $0x3,%edx
    8f78:	01 d0                	add    %edx,%eax
    8f7a:	83 c0 01             	add    $0x1,%eax
    8f7d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    8f80:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f83:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    8f87:	c9                   	leave  
    8f88:	c3                   	ret    

00008f89 <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    8f89:	55                   	push   %ebp
    8f8a:	89 e5                	mov    %esp,%ebp
    8f8c:	53                   	push   %ebx
    8f8d:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    8f90:	ff 75 10             	pushl  0x10(%ebp)
    8f93:	e8 61 fe ff ff       	call   8df9 <lodepng_get_bpp>
    8f98:	83 c4 04             	add    $0x4,%esp
    8f9b:	89 c3                	mov    %eax,%ebx
    8f9d:	ff 75 14             	pushl  0x14(%ebp)
    8fa0:	e8 54 fe ff ff       	call   8df9 <lodepng_get_bpp>
    8fa5:	83 c4 04             	add    $0x4,%esp
    8fa8:	39 c3                	cmp    %eax,%ebx
    8faa:	76 0d                	jbe    8fb9 <lodepng_pixel_overflow+0x30>
    8fac:	ff 75 10             	pushl  0x10(%ebp)
    8faf:	e8 45 fe ff ff       	call   8df9 <lodepng_get_bpp>
    8fb4:	83 c4 04             	add    $0x4,%esp
    8fb7:	eb 0b                	jmp    8fc4 <lodepng_pixel_overflow+0x3b>
    8fb9:	ff 75 14             	pushl  0x14(%ebp)
    8fbc:	e8 38 fe ff ff       	call   8df9 <lodepng_get_bpp>
    8fc1:	83 c4 04             	add    $0x4,%esp
    8fc4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    8fc7:	8b 55 0c             	mov    0xc(%ebp),%edx
    8fca:	8b 45 08             	mov    0x8(%ebp),%eax
    8fcd:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    8fd0:	51                   	push   %ecx
    8fd1:	52                   	push   %edx
    8fd2:	50                   	push   %eax
    8fd3:	e8 e9 a3 ff ff       	call   33c1 <lodepng_mulofl>
    8fd8:	83 c4 0c             	add    $0xc,%esp
    8fdb:	85 c0                	test   %eax,%eax
    8fdd:	74 0a                	je     8fe9 <lodepng_pixel_overflow+0x60>
    8fdf:	b8 01 00 00 00       	mov    $0x1,%eax
    8fe4:	e9 b6 00 00 00       	jmp    909f <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    8fe9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8fec:	8d 55 f0             	lea    -0x10(%ebp),%edx
    8fef:	52                   	push   %edx
    8ff0:	6a 08                	push   $0x8
    8ff2:	50                   	push   %eax
    8ff3:	e8 c9 a3 ff ff       	call   33c1 <lodepng_mulofl>
    8ff8:	83 c4 0c             	add    $0xc,%esp
    8ffb:	85 c0                	test   %eax,%eax
    8ffd:	74 0a                	je     9009 <lodepng_pixel_overflow+0x80>
    8fff:	b8 01 00 00 00       	mov    $0x1,%eax
    9004:	e9 96 00 00 00       	jmp    909f <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    9009:	8b 45 08             	mov    0x8(%ebp),%eax
    900c:	c1 e8 03             	shr    $0x3,%eax
    900f:	89 c2                	mov    %eax,%edx
    9011:	8d 45 ec             	lea    -0x14(%ebp),%eax
    9014:	50                   	push   %eax
    9015:	ff 75 f8             	pushl  -0x8(%ebp)
    9018:	52                   	push   %edx
    9019:	e8 a3 a3 ff ff       	call   33c1 <lodepng_mulofl>
    901e:	83 c4 0c             	add    $0xc,%esp
    9021:	85 c0                	test   %eax,%eax
    9023:	74 07                	je     902c <lodepng_pixel_overflow+0xa3>
    9025:	b8 01 00 00 00       	mov    $0x1,%eax
    902a:	eb 73                	jmp    909f <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    902c:	8b 45 08             	mov    0x8(%ebp),%eax
    902f:	83 e0 07             	and    $0x7,%eax
    9032:	89 c2                	mov    %eax,%edx
    9034:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9037:	0f af c2             	imul   %edx,%eax
    903a:	83 c0 07             	add    $0x7,%eax
    903d:	c1 e8 03             	shr    $0x3,%eax
    9040:	89 c1                	mov    %eax,%ecx
    9042:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9045:	8d 55 ec             	lea    -0x14(%ebp),%edx
    9048:	52                   	push   %edx
    9049:	51                   	push   %ecx
    904a:	50                   	push   %eax
    904b:	e8 51 a3 ff ff       	call   33a1 <lodepng_addofl>
    9050:	83 c4 0c             	add    $0xc,%esp
    9053:	85 c0                	test   %eax,%eax
    9055:	74 07                	je     905e <lodepng_pixel_overflow+0xd5>
    9057:	b8 01 00 00 00       	mov    $0x1,%eax
    905c:	eb 41                	jmp    909f <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    905e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9061:	8d 55 ec             	lea    -0x14(%ebp),%edx
    9064:	52                   	push   %edx
    9065:	6a 05                	push   $0x5
    9067:	50                   	push   %eax
    9068:	e8 34 a3 ff ff       	call   33a1 <lodepng_addofl>
    906d:	83 c4 0c             	add    $0xc,%esp
    9070:	85 c0                	test   %eax,%eax
    9072:	74 07                	je     907b <lodepng_pixel_overflow+0xf2>
    9074:	b8 01 00 00 00       	mov    $0x1,%eax
    9079:	eb 24                	jmp    909f <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    907b:	8b 55 0c             	mov    0xc(%ebp),%edx
    907e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9081:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    9084:	51                   	push   %ecx
    9085:	52                   	push   %edx
    9086:	50                   	push   %eax
    9087:	e8 35 a3 ff ff       	call   33c1 <lodepng_mulofl>
    908c:	83 c4 0c             	add    $0xc,%esp
    908f:	85 c0                	test   %eax,%eax
    9091:	74 07                	je     909a <lodepng_pixel_overflow+0x111>
    9093:	b8 01 00 00 00       	mov    $0x1,%eax
    9098:	eb 05                	jmp    909f <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    909a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    909f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    90a2:	c9                   	leave  
    90a3:	c3                   	ret    

000090a4 <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    90a4:	55                   	push   %ebp
    90a5:	89 e5                	mov    %esp,%ebp
    90a7:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    90aa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    90b1:	eb 15                	jmp    90c8 <LodePNGUnknownChunks_init+0x24>
    90b3:	8b 45 08             	mov    0x8(%ebp),%eax
    90b6:	8b 55 fc             	mov    -0x4(%ebp),%edx
    90b9:	83 c2 30             	add    $0x30,%edx
    90bc:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    90c3:	00 
    90c4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    90c8:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    90cc:	75 e5                	jne    90b3 <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    90ce:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    90d5:	eb 15                	jmp    90ec <LodePNGUnknownChunks_init+0x48>
    90d7:	8b 45 08             	mov    0x8(%ebp),%eax
    90da:	8b 55 fc             	mov    -0x4(%ebp),%edx
    90dd:	83 c2 34             	add    $0x34,%edx
    90e0:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    90e7:	00 
    90e8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    90ec:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    90f0:	75 e5                	jne    90d7 <LodePNGUnknownChunks_init+0x33>
}
    90f2:	90                   	nop
    90f3:	c9                   	leave  
    90f4:	c3                   	ret    

000090f5 <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    90f5:	55                   	push   %ebp
    90f6:	89 e5                	mov    %esp,%ebp
    90f8:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    90fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9102:	eb 1d                	jmp    9121 <LodePNGUnknownChunks_cleanup+0x2c>
    9104:	8b 45 08             	mov    0x8(%ebp),%eax
    9107:	8b 55 f4             	mov    -0xc(%ebp),%edx
    910a:	83 c2 30             	add    $0x30,%edx
    910d:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    9111:	83 ec 0c             	sub    $0xc,%esp
    9114:	50                   	push   %eax
    9115:	e8 e4 a1 ff ff       	call   32fe <lodepng_free>
    911a:	83 c4 10             	add    $0x10,%esp
    911d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9121:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    9125:	75 dd                	jne    9104 <LodePNGUnknownChunks_cleanup+0xf>
}
    9127:	90                   	nop
    9128:	c9                   	leave  
    9129:	c3                   	ret    

0000912a <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    912a:	55                   	push   %ebp
    912b:	89 e5                	mov    %esp,%ebp
    912d:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    9130:	83 ec 0c             	sub    $0xc,%esp
    9133:	ff 75 08             	pushl  0x8(%ebp)
    9136:	e8 ba ff ff ff       	call   90f5 <LodePNGUnknownChunks_cleanup>
    913b:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    913e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9145:	e9 b7 00 00 00       	jmp    9201 <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    914a:	8b 45 0c             	mov    0xc(%ebp),%eax
    914d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9150:	83 c2 34             	add    $0x34,%edx
    9153:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    9157:	8b 45 08             	mov    0x8(%ebp),%eax
    915a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    915d:	83 c1 34             	add    $0x34,%ecx
    9160:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    9164:	8b 45 0c             	mov    0xc(%ebp),%eax
    9167:	8b 55 f4             	mov    -0xc(%ebp),%edx
    916a:	83 c2 34             	add    $0x34,%edx
    916d:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9171:	83 ec 0c             	sub    $0xc,%esp
    9174:	50                   	push   %eax
    9175:	e8 63 a1 ff ff       	call   32dd <lodepng_malloc>
    917a:	83 c4 10             	add    $0x10,%esp
    917d:	89 c1                	mov    %eax,%ecx
    917f:	8b 45 08             	mov    0x8(%ebp),%eax
    9182:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9185:	83 c2 30             	add    $0x30,%edx
    9188:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    918c:	8b 45 08             	mov    0x8(%ebp),%eax
    918f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9192:	83 c2 30             	add    $0x30,%edx
    9195:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    9199:	85 c0                	test   %eax,%eax
    919b:	75 18                	jne    91b5 <LodePNGUnknownChunks_copy+0x8b>
    919d:	8b 45 08             	mov    0x8(%ebp),%eax
    91a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91a3:	83 c2 34             	add    $0x34,%edx
    91a6:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    91aa:	85 c0                	test   %eax,%eax
    91ac:	74 07                	je     91b5 <LodePNGUnknownChunks_copy+0x8b>
    91ae:	b8 53 00 00 00       	mov    $0x53,%eax
    91b3:	eb 5b                	jmp    9210 <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    91b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    91bc:	eb 2d                	jmp    91eb <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    91be:	8b 45 08             	mov    0x8(%ebp),%eax
    91c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91c4:	83 c2 30             	add    $0x30,%edx
    91c7:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    91cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    91ce:	01 c2                	add    %eax,%edx
    91d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    91d3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    91d6:	83 c1 30             	add    $0x30,%ecx
    91d9:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    91dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    91e0:	01 c8                	add    %ecx,%eax
    91e2:	0f b6 00             	movzbl (%eax),%eax
    91e5:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    91e7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    91eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    91ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91f1:	83 c2 34             	add    $0x34,%edx
    91f4:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    91f8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    91fb:	7f c1                	jg     91be <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    91fd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9201:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    9205:	0f 85 3f ff ff ff    	jne    914a <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    920b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9210:	c9                   	leave  
    9211:	c3                   	ret    

00009212 <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    9212:	55                   	push   %ebp
    9213:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    9215:	8b 45 08             	mov    0x8(%ebp),%eax
    9218:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    921f:	8b 45 08             	mov    0x8(%ebp),%eax
    9222:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    9229:	8b 45 08             	mov    0x8(%ebp),%eax
    922c:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    9233:	90                   	nop
    9234:	5d                   	pop    %ebp
    9235:	c3                   	ret    

00009236 <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    9236:	55                   	push   %ebp
    9237:	89 e5                	mov    %esp,%ebp
    9239:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    923c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9243:	eb 38                	jmp    927d <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    9245:	8b 45 08             	mov    0x8(%ebp),%eax
    9248:	8b 40 40             	mov    0x40(%eax),%eax
    924b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    924e:	c1 e2 02             	shl    $0x2,%edx
    9251:	01 d0                	add    %edx,%eax
    9253:	83 ec 0c             	sub    $0xc,%esp
    9256:	50                   	push   %eax
    9257:	e8 75 a3 ff ff       	call   35d1 <string_cleanup>
    925c:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    925f:	8b 45 08             	mov    0x8(%ebp),%eax
    9262:	8b 40 44             	mov    0x44(%eax),%eax
    9265:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9268:	c1 e2 02             	shl    $0x2,%edx
    926b:	01 d0                	add    %edx,%eax
    926d:	83 ec 0c             	sub    $0xc,%esp
    9270:	50                   	push   %eax
    9271:	e8 5b a3 ff ff       	call   35d1 <string_cleanup>
    9276:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9279:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    927d:	8b 45 08             	mov    0x8(%ebp),%eax
    9280:	8b 40 3c             	mov    0x3c(%eax),%eax
    9283:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9286:	75 bd                	jne    9245 <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    9288:	8b 45 08             	mov    0x8(%ebp),%eax
    928b:	8b 40 40             	mov    0x40(%eax),%eax
    928e:	83 ec 0c             	sub    $0xc,%esp
    9291:	50                   	push   %eax
    9292:	e8 67 a0 ff ff       	call   32fe <lodepng_free>
    9297:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    929a:	8b 45 08             	mov    0x8(%ebp),%eax
    929d:	8b 40 44             	mov    0x44(%eax),%eax
    92a0:	83 ec 0c             	sub    $0xc,%esp
    92a3:	50                   	push   %eax
    92a4:	e8 55 a0 ff ff       	call   32fe <lodepng_free>
    92a9:	83 c4 10             	add    $0x10,%esp
}
    92ac:	90                   	nop
    92ad:	c9                   	leave  
    92ae:	c3                   	ret    

000092af <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    92af:	55                   	push   %ebp
    92b0:	89 e5                	mov    %esp,%ebp
    92b2:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    92b5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    92bc:	8b 45 08             	mov    0x8(%ebp),%eax
    92bf:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    92c6:	8b 45 08             	mov    0x8(%ebp),%eax
    92c9:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    92d0:	8b 45 08             	mov    0x8(%ebp),%eax
    92d3:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    92da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    92e1:	eb 42                	jmp    9325 <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    92e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    92e6:	8b 40 44             	mov    0x44(%eax),%eax
    92e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92ec:	c1 e2 02             	shl    $0x2,%edx
    92ef:	01 d0                	add    %edx,%eax
    92f1:	8b 10                	mov    (%eax),%edx
    92f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    92f6:	8b 40 40             	mov    0x40(%eax),%eax
    92f9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    92fc:	c1 e1 02             	shl    $0x2,%ecx
    92ff:	01 c8                	add    %ecx,%eax
    9301:	8b 00                	mov    (%eax),%eax
    9303:	83 ec 04             	sub    $0x4,%esp
    9306:	52                   	push   %edx
    9307:	50                   	push   %eax
    9308:	ff 75 08             	pushl  0x8(%ebp)
    930b:	e8 4d 01 00 00       	call   945d <lodepng_add_text>
    9310:	83 c4 10             	add    $0x10,%esp
    9313:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9316:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    931a:	74 05                	je     9321 <LodePNGText_copy+0x72>
    931c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    931f:	eb 14                	jmp    9335 <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    9321:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9325:	8b 45 0c             	mov    0xc(%ebp),%eax
    9328:	8b 40 3c             	mov    0x3c(%eax),%eax
    932b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    932e:	75 b3                	jne    92e3 <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    9330:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9335:	c9                   	leave  
    9336:	c3                   	ret    

00009337 <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    9337:	55                   	push   %ebp
    9338:	89 e5                	mov    %esp,%ebp
    933a:	53                   	push   %ebx
    933b:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    933e:	8b 45 08             	mov    0x8(%ebp),%eax
    9341:	8b 40 3c             	mov    0x3c(%eax),%eax
    9344:	83 c0 01             	add    $0x1,%eax
    9347:	c1 e0 02             	shl    $0x2,%eax
    934a:	89 c2                	mov    %eax,%edx
    934c:	8b 45 08             	mov    0x8(%ebp),%eax
    934f:	8b 40 40             	mov    0x40(%eax),%eax
    9352:	52                   	push   %edx
    9353:	50                   	push   %eax
    9354:	e8 9b 9f ff ff       	call   32f4 <lodepng_realloc>
    9359:	83 c4 08             	add    $0x8,%esp
    935c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    935f:	8b 45 08             	mov    0x8(%ebp),%eax
    9362:	8b 40 3c             	mov    0x3c(%eax),%eax
    9365:	83 c0 01             	add    $0x1,%eax
    9368:	c1 e0 02             	shl    $0x2,%eax
    936b:	89 c2                	mov    %eax,%edx
    936d:	8b 45 08             	mov    0x8(%ebp),%eax
    9370:	8b 40 44             	mov    0x44(%eax),%eax
    9373:	52                   	push   %edx
    9374:	50                   	push   %eax
    9375:	e8 7a 9f ff ff       	call   32f4 <lodepng_realloc>
    937a:	83 c4 08             	add    $0x8,%esp
    937d:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    9380:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9384:	74 09                	je     938f <lodepng_add_text_sized+0x58>
    9386:	8b 45 08             	mov    0x8(%ebp),%eax
    9389:	8b 55 f4             	mov    -0xc(%ebp),%edx
    938c:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    938f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9393:	74 09                	je     939e <lodepng_add_text_sized+0x67>
    9395:	8b 45 08             	mov    0x8(%ebp),%eax
    9398:	8b 55 f0             	mov    -0x10(%ebp),%edx
    939b:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    939e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    93a2:	74 06                	je     93aa <lodepng_add_text_sized+0x73>
    93a4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    93a8:	75 0a                	jne    93b4 <lodepng_add_text_sized+0x7d>
    93aa:	b8 53 00 00 00       	mov    $0x53,%eax
    93af:	e9 a4 00 00 00       	jmp    9458 <lodepng_add_text_sized+0x121>

  ++info->text_num;
    93b4:	8b 45 08             	mov    0x8(%ebp),%eax
    93b7:	8b 40 3c             	mov    0x3c(%eax),%eax
    93ba:	8d 50 01             	lea    0x1(%eax),%edx
    93bd:	8b 45 08             	mov    0x8(%ebp),%eax
    93c0:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    93c3:	8b 45 08             	mov    0x8(%ebp),%eax
    93c6:	8b 50 40             	mov    0x40(%eax),%edx
    93c9:	8b 45 08             	mov    0x8(%ebp),%eax
    93cc:	8b 40 3c             	mov    0x3c(%eax),%eax
    93cf:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    93d4:	c1 e0 02             	shl    $0x2,%eax
    93d7:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    93da:	83 ec 0c             	sub    $0xc,%esp
    93dd:	ff 75 0c             	pushl  0xc(%ebp)
    93e0:	e8 54 a2 ff ff       	call   3639 <alloc_string>
    93e5:	83 c4 10             	add    $0x10,%esp
    93e8:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    93ea:	8b 45 08             	mov    0x8(%ebp),%eax
    93ed:	8b 50 44             	mov    0x44(%eax),%edx
    93f0:	8b 45 08             	mov    0x8(%ebp),%eax
    93f3:	8b 40 3c             	mov    0x3c(%eax),%eax
    93f6:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    93fb:	c1 e0 02             	shl    $0x2,%eax
    93fe:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9401:	83 ec 08             	sub    $0x8,%esp
    9404:	ff 75 14             	pushl  0x14(%ebp)
    9407:	ff 75 10             	pushl  0x10(%ebp)
    940a:	e8 e5 a1 ff ff       	call   35f4 <alloc_string_sized>
    940f:	83 c4 10             	add    $0x10,%esp
    9412:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    9414:	8b 45 08             	mov    0x8(%ebp),%eax
    9417:	8b 50 40             	mov    0x40(%eax),%edx
    941a:	8b 45 08             	mov    0x8(%ebp),%eax
    941d:	8b 40 3c             	mov    0x3c(%eax),%eax
    9420:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9425:	c1 e0 02             	shl    $0x2,%eax
    9428:	01 d0                	add    %edx,%eax
    942a:	8b 00                	mov    (%eax),%eax
    942c:	85 c0                	test   %eax,%eax
    942e:	74 1c                	je     944c <lodepng_add_text_sized+0x115>
    9430:	8b 45 08             	mov    0x8(%ebp),%eax
    9433:	8b 50 44             	mov    0x44(%eax),%edx
    9436:	8b 45 08             	mov    0x8(%ebp),%eax
    9439:	8b 40 3c             	mov    0x3c(%eax),%eax
    943c:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9441:	c1 e0 02             	shl    $0x2,%eax
    9444:	01 d0                	add    %edx,%eax
    9446:	8b 00                	mov    (%eax),%eax
    9448:	85 c0                	test   %eax,%eax
    944a:	75 07                	jne    9453 <lodepng_add_text_sized+0x11c>
    944c:	b8 53 00 00 00       	mov    $0x53,%eax
    9451:	eb 05                	jmp    9458 <lodepng_add_text_sized+0x121>

  return 0;
    9453:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9458:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    945b:	c9                   	leave  
    945c:	c3                   	ret    

0000945d <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    945d:	55                   	push   %ebp
    945e:	89 e5                	mov    %esp,%ebp
    9460:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    9463:	ff 75 10             	pushl  0x10(%ebp)
    9466:	e8 0e 9f ff ff       	call   3379 <lodepng_strlen>
    946b:	83 c4 04             	add    $0x4,%esp
    946e:	50                   	push   %eax
    946f:	ff 75 10             	pushl  0x10(%ebp)
    9472:	ff 75 0c             	pushl  0xc(%ebp)
    9475:	ff 75 08             	pushl  0x8(%ebp)
    9478:	e8 ba fe ff ff       	call   9337 <lodepng_add_text_sized>
    947d:	83 c4 10             	add    $0x10,%esp
}
    9480:	c9                   	leave  
    9481:	c3                   	ret    

00009482 <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    9482:	55                   	push   %ebp
    9483:	89 e5                	mov    %esp,%ebp
    9485:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    9488:	83 ec 0c             	sub    $0xc,%esp
    948b:	ff 75 08             	pushl  0x8(%ebp)
    948e:	e8 a3 fd ff ff       	call   9236 <LodePNGText_cleanup>
    9493:	83 c4 10             	add    $0x10,%esp
}
    9496:	90                   	nop
    9497:	c9                   	leave  
    9498:	c3                   	ret    

00009499 <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    9499:	55                   	push   %ebp
    949a:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    949c:	8b 45 08             	mov    0x8(%ebp),%eax
    949f:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    94a6:	8b 45 08             	mov    0x8(%ebp),%eax
    94a9:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    94b0:	8b 45 08             	mov    0x8(%ebp),%eax
    94b3:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    94ba:	8b 45 08             	mov    0x8(%ebp),%eax
    94bd:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    94c4:	8b 45 08             	mov    0x8(%ebp),%eax
    94c7:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    94ce:	90                   	nop
    94cf:	5d                   	pop    %ebp
    94d0:	c3                   	ret    

000094d1 <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    94d1:	55                   	push   %ebp
    94d2:	89 e5                	mov    %esp,%ebp
    94d4:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    94d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    94de:	eb 6c                	jmp    954c <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    94e0:	8b 45 08             	mov    0x8(%ebp),%eax
    94e3:	8b 40 4c             	mov    0x4c(%eax),%eax
    94e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    94e9:	c1 e2 02             	shl    $0x2,%edx
    94ec:	01 d0                	add    %edx,%eax
    94ee:	83 ec 0c             	sub    $0xc,%esp
    94f1:	50                   	push   %eax
    94f2:	e8 da a0 ff ff       	call   35d1 <string_cleanup>
    94f7:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    94fa:	8b 45 08             	mov    0x8(%ebp),%eax
    94fd:	8b 40 50             	mov    0x50(%eax),%eax
    9500:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9503:	c1 e2 02             	shl    $0x2,%edx
    9506:	01 d0                	add    %edx,%eax
    9508:	83 ec 0c             	sub    $0xc,%esp
    950b:	50                   	push   %eax
    950c:	e8 c0 a0 ff ff       	call   35d1 <string_cleanup>
    9511:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    9514:	8b 45 08             	mov    0x8(%ebp),%eax
    9517:	8b 40 54             	mov    0x54(%eax),%eax
    951a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    951d:	c1 e2 02             	shl    $0x2,%edx
    9520:	01 d0                	add    %edx,%eax
    9522:	83 ec 0c             	sub    $0xc,%esp
    9525:	50                   	push   %eax
    9526:	e8 a6 a0 ff ff       	call   35d1 <string_cleanup>
    952b:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    952e:	8b 45 08             	mov    0x8(%ebp),%eax
    9531:	8b 40 58             	mov    0x58(%eax),%eax
    9534:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9537:	c1 e2 02             	shl    $0x2,%edx
    953a:	01 d0                	add    %edx,%eax
    953c:	83 ec 0c             	sub    $0xc,%esp
    953f:	50                   	push   %eax
    9540:	e8 8c a0 ff ff       	call   35d1 <string_cleanup>
    9545:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    9548:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    954c:	8b 45 08             	mov    0x8(%ebp),%eax
    954f:	8b 40 48             	mov    0x48(%eax),%eax
    9552:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9555:	75 89                	jne    94e0 <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    9557:	8b 45 08             	mov    0x8(%ebp),%eax
    955a:	8b 40 4c             	mov    0x4c(%eax),%eax
    955d:	83 ec 0c             	sub    $0xc,%esp
    9560:	50                   	push   %eax
    9561:	e8 98 9d ff ff       	call   32fe <lodepng_free>
    9566:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    9569:	8b 45 08             	mov    0x8(%ebp),%eax
    956c:	8b 40 50             	mov    0x50(%eax),%eax
    956f:	83 ec 0c             	sub    $0xc,%esp
    9572:	50                   	push   %eax
    9573:	e8 86 9d ff ff       	call   32fe <lodepng_free>
    9578:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    957b:	8b 45 08             	mov    0x8(%ebp),%eax
    957e:	8b 40 54             	mov    0x54(%eax),%eax
    9581:	83 ec 0c             	sub    $0xc,%esp
    9584:	50                   	push   %eax
    9585:	e8 74 9d ff ff       	call   32fe <lodepng_free>
    958a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    958d:	8b 45 08             	mov    0x8(%ebp),%eax
    9590:	8b 40 58             	mov    0x58(%eax),%eax
    9593:	83 ec 0c             	sub    $0xc,%esp
    9596:	50                   	push   %eax
    9597:	e8 62 9d ff ff       	call   32fe <lodepng_free>
    959c:	83 c4 10             	add    $0x10,%esp
}
    959f:	90                   	nop
    95a0:	c9                   	leave  
    95a1:	c3                   	ret    

000095a2 <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    95a2:	55                   	push   %ebp
    95a3:	89 e5                	mov    %esp,%ebp
    95a5:	56                   	push   %esi
    95a6:	53                   	push   %ebx
    95a7:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    95aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    95b1:	8b 45 08             	mov    0x8(%ebp),%eax
    95b4:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    95bb:	8b 45 08             	mov    0x8(%ebp),%eax
    95be:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    95c5:	8b 45 08             	mov    0x8(%ebp),%eax
    95c8:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    95cf:	8b 45 08             	mov    0x8(%ebp),%eax
    95d2:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    95d9:	8b 45 08             	mov    0x8(%ebp),%eax
    95dc:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    95e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    95ea:	eb 64                	jmp    9650 <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    95ec:	8b 45 0c             	mov    0xc(%ebp),%eax
    95ef:	8b 40 58             	mov    0x58(%eax),%eax
    95f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    95f5:	c1 e2 02             	shl    $0x2,%edx
    95f8:	01 d0                	add    %edx,%eax
    95fa:	8b 18                	mov    (%eax),%ebx
    95fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    95ff:	8b 40 54             	mov    0x54(%eax),%eax
    9602:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9605:	c1 e2 02             	shl    $0x2,%edx
    9608:	01 d0                	add    %edx,%eax
    960a:	8b 08                	mov    (%eax),%ecx
    960c:	8b 45 0c             	mov    0xc(%ebp),%eax
    960f:	8b 40 50             	mov    0x50(%eax),%eax
    9612:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9615:	c1 e2 02             	shl    $0x2,%edx
    9618:	01 d0                	add    %edx,%eax
    961a:	8b 10                	mov    (%eax),%edx
    961c:	8b 45 0c             	mov    0xc(%ebp),%eax
    961f:	8b 40 4c             	mov    0x4c(%eax),%eax
    9622:	8b 75 f4             	mov    -0xc(%ebp),%esi
    9625:	c1 e6 02             	shl    $0x2,%esi
    9628:	01 f0                	add    %esi,%eax
    962a:	8b 00                	mov    (%eax),%eax
    962c:	83 ec 0c             	sub    $0xc,%esp
    962f:	53                   	push   %ebx
    9630:	51                   	push   %ecx
    9631:	52                   	push   %edx
    9632:	50                   	push   %eax
    9633:	ff 75 08             	pushl  0x8(%ebp)
    9636:	e8 e4 01 00 00       	call   981f <lodepng_add_itext>
    963b:	83 c4 20             	add    $0x20,%esp
    963e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9641:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9645:	74 05                	je     964c <LodePNGIText_copy+0xaa>
    9647:	8b 45 f0             	mov    -0x10(%ebp),%eax
    964a:	eb 14                	jmp    9660 <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    964c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9650:	8b 45 0c             	mov    0xc(%ebp),%eax
    9653:	8b 40 48             	mov    0x48(%eax),%eax
    9656:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9659:	75 91                	jne    95ec <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    965b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9660:	8d 65 f8             	lea    -0x8(%ebp),%esp
    9663:	5b                   	pop    %ebx
    9664:	5e                   	pop    %esi
    9665:	5d                   	pop    %ebp
    9666:	c3                   	ret    

00009667 <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    9667:	55                   	push   %ebp
    9668:	89 e5                	mov    %esp,%ebp
    966a:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    966d:	83 ec 0c             	sub    $0xc,%esp
    9670:	ff 75 08             	pushl  0x8(%ebp)
    9673:	e8 59 fe ff ff       	call   94d1 <LodePNGIText_cleanup>
    9678:	83 c4 10             	add    $0x10,%esp
}
    967b:	90                   	nop
    967c:	c9                   	leave  
    967d:	c3                   	ret    

0000967e <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    967e:	55                   	push   %ebp
    967f:	89 e5                	mov    %esp,%ebp
    9681:	53                   	push   %ebx
    9682:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    9685:	8b 45 08             	mov    0x8(%ebp),%eax
    9688:	8b 40 48             	mov    0x48(%eax),%eax
    968b:	83 c0 01             	add    $0x1,%eax
    968e:	c1 e0 02             	shl    $0x2,%eax
    9691:	89 c2                	mov    %eax,%edx
    9693:	8b 45 08             	mov    0x8(%ebp),%eax
    9696:	8b 40 4c             	mov    0x4c(%eax),%eax
    9699:	52                   	push   %edx
    969a:	50                   	push   %eax
    969b:	e8 54 9c ff ff       	call   32f4 <lodepng_realloc>
    96a0:	83 c4 08             	add    $0x8,%esp
    96a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    96a6:	8b 45 08             	mov    0x8(%ebp),%eax
    96a9:	8b 40 48             	mov    0x48(%eax),%eax
    96ac:	83 c0 01             	add    $0x1,%eax
    96af:	c1 e0 02             	shl    $0x2,%eax
    96b2:	89 c2                	mov    %eax,%edx
    96b4:	8b 45 08             	mov    0x8(%ebp),%eax
    96b7:	8b 40 50             	mov    0x50(%eax),%eax
    96ba:	52                   	push   %edx
    96bb:	50                   	push   %eax
    96bc:	e8 33 9c ff ff       	call   32f4 <lodepng_realloc>
    96c1:	83 c4 08             	add    $0x8,%esp
    96c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    96c7:	8b 45 08             	mov    0x8(%ebp),%eax
    96ca:	8b 40 48             	mov    0x48(%eax),%eax
    96cd:	83 c0 01             	add    $0x1,%eax
    96d0:	c1 e0 02             	shl    $0x2,%eax
    96d3:	89 c2                	mov    %eax,%edx
    96d5:	8b 45 08             	mov    0x8(%ebp),%eax
    96d8:	8b 40 54             	mov    0x54(%eax),%eax
    96db:	52                   	push   %edx
    96dc:	50                   	push   %eax
    96dd:	e8 12 9c ff ff       	call   32f4 <lodepng_realloc>
    96e2:	83 c4 08             	add    $0x8,%esp
    96e5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    96e8:	8b 45 08             	mov    0x8(%ebp),%eax
    96eb:	8b 40 48             	mov    0x48(%eax),%eax
    96ee:	83 c0 01             	add    $0x1,%eax
    96f1:	c1 e0 02             	shl    $0x2,%eax
    96f4:	89 c2                	mov    %eax,%edx
    96f6:	8b 45 08             	mov    0x8(%ebp),%eax
    96f9:	8b 40 58             	mov    0x58(%eax),%eax
    96fc:	52                   	push   %edx
    96fd:	50                   	push   %eax
    96fe:	e8 f1 9b ff ff       	call   32f4 <lodepng_realloc>
    9703:	83 c4 08             	add    $0x8,%esp
    9706:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    9709:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    970d:	74 09                	je     9718 <lodepng_add_itext_sized+0x9a>
    970f:	8b 45 08             	mov    0x8(%ebp),%eax
    9712:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9715:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    9718:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    971c:	74 09                	je     9727 <lodepng_add_itext_sized+0xa9>
    971e:	8b 45 08             	mov    0x8(%ebp),%eax
    9721:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9724:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    9727:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    972b:	74 09                	je     9736 <lodepng_add_itext_sized+0xb8>
    972d:	8b 45 08             	mov    0x8(%ebp),%eax
    9730:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9733:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    9736:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    973a:	74 09                	je     9745 <lodepng_add_itext_sized+0xc7>
    973c:	8b 45 08             	mov    0x8(%ebp),%eax
    973f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9742:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    9745:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9749:	74 12                	je     975d <lodepng_add_itext_sized+0xdf>
    974b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    974f:	74 0c                	je     975d <lodepng_add_itext_sized+0xdf>
    9751:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9755:	74 06                	je     975d <lodepng_add_itext_sized+0xdf>
    9757:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    975b:	75 0a                	jne    9767 <lodepng_add_itext_sized+0xe9>
    975d:	b8 53 00 00 00       	mov    $0x53,%eax
    9762:	e9 b3 00 00 00       	jmp    981a <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    9767:	8b 45 08             	mov    0x8(%ebp),%eax
    976a:	8b 40 48             	mov    0x48(%eax),%eax
    976d:	8d 50 01             	lea    0x1(%eax),%edx
    9770:	8b 45 08             	mov    0x8(%ebp),%eax
    9773:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    9776:	8b 45 08             	mov    0x8(%ebp),%eax
    9779:	8b 50 4c             	mov    0x4c(%eax),%edx
    977c:	8b 45 08             	mov    0x8(%ebp),%eax
    977f:	8b 40 48             	mov    0x48(%eax),%eax
    9782:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9787:	c1 e0 02             	shl    $0x2,%eax
    978a:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    978d:	83 ec 0c             	sub    $0xc,%esp
    9790:	ff 75 0c             	pushl  0xc(%ebp)
    9793:	e8 a1 9e ff ff       	call   3639 <alloc_string>
    9798:	83 c4 10             	add    $0x10,%esp
    979b:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    979d:	8b 45 08             	mov    0x8(%ebp),%eax
    97a0:	8b 50 50             	mov    0x50(%eax),%edx
    97a3:	8b 45 08             	mov    0x8(%ebp),%eax
    97a6:	8b 40 48             	mov    0x48(%eax),%eax
    97a9:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    97ae:	c1 e0 02             	shl    $0x2,%eax
    97b1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    97b4:	83 ec 0c             	sub    $0xc,%esp
    97b7:	ff 75 10             	pushl  0x10(%ebp)
    97ba:	e8 7a 9e ff ff       	call   3639 <alloc_string>
    97bf:	83 c4 10             	add    $0x10,%esp
    97c2:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    97c4:	8b 45 08             	mov    0x8(%ebp),%eax
    97c7:	8b 50 54             	mov    0x54(%eax),%edx
    97ca:	8b 45 08             	mov    0x8(%ebp),%eax
    97cd:	8b 40 48             	mov    0x48(%eax),%eax
    97d0:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    97d5:	c1 e0 02             	shl    $0x2,%eax
    97d8:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    97db:	83 ec 0c             	sub    $0xc,%esp
    97de:	ff 75 14             	pushl  0x14(%ebp)
    97e1:	e8 53 9e ff ff       	call   3639 <alloc_string>
    97e6:	83 c4 10             	add    $0x10,%esp
    97e9:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    97eb:	8b 45 08             	mov    0x8(%ebp),%eax
    97ee:	8b 50 58             	mov    0x58(%eax),%edx
    97f1:	8b 45 08             	mov    0x8(%ebp),%eax
    97f4:	8b 40 48             	mov    0x48(%eax),%eax
    97f7:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    97fc:	c1 e0 02             	shl    $0x2,%eax
    97ff:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9802:	83 ec 08             	sub    $0x8,%esp
    9805:	ff 75 1c             	pushl  0x1c(%ebp)
    9808:	ff 75 18             	pushl  0x18(%ebp)
    980b:	e8 e4 9d ff ff       	call   35f4 <alloc_string_sized>
    9810:	83 c4 10             	add    $0x10,%esp
    9813:	89 03                	mov    %eax,(%ebx)

  return 0;
    9815:	b8 00 00 00 00       	mov    $0x0,%eax
}
    981a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    981d:	c9                   	leave  
    981e:	c3                   	ret    

0000981f <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    981f:	55                   	push   %ebp
    9820:	89 e5                	mov    %esp,%ebp
    9822:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    9825:	ff 75 18             	pushl  0x18(%ebp)
    9828:	e8 4c 9b ff ff       	call   3379 <lodepng_strlen>
    982d:	83 c4 04             	add    $0x4,%esp
    9830:	83 ec 08             	sub    $0x8,%esp
    9833:	50                   	push   %eax
    9834:	ff 75 18             	pushl  0x18(%ebp)
    9837:	ff 75 14             	pushl  0x14(%ebp)
    983a:	ff 75 10             	pushl  0x10(%ebp)
    983d:	ff 75 0c             	pushl  0xc(%ebp)
    9840:	ff 75 08             	pushl  0x8(%ebp)
    9843:	e8 36 fe ff ff       	call   967e <lodepng_add_itext_sized>
    9848:	83 c4 20             	add    $0x20,%esp
}
    984b:	c9                   	leave  
    984c:	c3                   	ret    

0000984d <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    984d:	55                   	push   %ebp
    984e:	89 e5                	mov    %esp,%ebp
    9850:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    9853:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    9857:	75 0a                	jne    9863 <lodepng_assign_icc+0x16>
    9859:	b8 64 00 00 00       	mov    $0x64,%eax
    985e:	e9 81 00 00 00       	jmp    98e4 <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    9863:	83 ec 0c             	sub    $0xc,%esp
    9866:	ff 75 0c             	pushl  0xc(%ebp)
    9869:	e8 cb 9d ff ff       	call   3639 <alloc_string>
    986e:	83 c4 10             	add    $0x10,%esp
    9871:	89 c2                	mov    %eax,%edx
    9873:	8b 45 08             	mov    0x8(%ebp),%eax
    9876:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    987c:	8b 45 14             	mov    0x14(%ebp),%eax
    987f:	83 ec 0c             	sub    $0xc,%esp
    9882:	50                   	push   %eax
    9883:	e8 55 9a ff ff       	call   32dd <lodepng_malloc>
    9888:	83 c4 10             	add    $0x10,%esp
    988b:	89 c2                	mov    %eax,%edx
    988d:	8b 45 08             	mov    0x8(%ebp),%eax
    9890:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    9896:	8b 45 08             	mov    0x8(%ebp),%eax
    9899:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    989f:	85 c0                	test   %eax,%eax
    98a1:	74 0d                	je     98b0 <lodepng_assign_icc+0x63>
    98a3:	8b 45 08             	mov    0x8(%ebp),%eax
    98a6:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    98ac:	85 c0                	test   %eax,%eax
    98ae:	75 07                	jne    98b7 <lodepng_assign_icc+0x6a>
    98b0:	b8 53 00 00 00       	mov    $0x53,%eax
    98b5:	eb 2d                	jmp    98e4 <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    98b7:	8b 55 14             	mov    0x14(%ebp),%edx
    98ba:	8b 45 08             	mov    0x8(%ebp),%eax
    98bd:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    98c3:	83 ec 04             	sub    $0x4,%esp
    98c6:	52                   	push   %edx
    98c7:	ff 75 10             	pushl  0x10(%ebp)
    98ca:	50                   	push   %eax
    98cb:	e8 4b 9a ff ff       	call   331b <lodepng_memcpy>
    98d0:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    98d3:	8b 45 08             	mov    0x8(%ebp),%eax
    98d6:	8b 55 14             	mov    0x14(%ebp),%edx
    98d9:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    98df:	b8 00 00 00 00       	mov    $0x0,%eax
}
    98e4:	c9                   	leave  
    98e5:	c3                   	ret    

000098e6 <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    98e6:	55                   	push   %ebp
    98e7:	89 e5                	mov    %esp,%ebp
    98e9:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    98ec:	8b 45 08             	mov    0x8(%ebp),%eax
    98ef:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    98f5:	85 c0                	test   %eax,%eax
    98f7:	74 0e                	je     9907 <lodepng_set_icc+0x21>
    98f9:	83 ec 0c             	sub    $0xc,%esp
    98fc:	ff 75 08             	pushl  0x8(%ebp)
    98ff:	e8 26 00 00 00       	call   992a <lodepng_clear_icc>
    9904:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    9907:	8b 45 08             	mov    0x8(%ebp),%eax
    990a:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    9911:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    9914:	ff 75 14             	pushl  0x14(%ebp)
    9917:	ff 75 10             	pushl  0x10(%ebp)
    991a:	ff 75 0c             	pushl  0xc(%ebp)
    991d:	ff 75 08             	pushl  0x8(%ebp)
    9920:	e8 28 ff ff ff       	call   984d <lodepng_assign_icc>
    9925:	83 c4 10             	add    $0x10,%esp
}
    9928:	c9                   	leave  
    9929:	c3                   	ret    

0000992a <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    992a:	55                   	push   %ebp
    992b:	89 e5                	mov    %esp,%ebp
    992d:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    9930:	8b 45 08             	mov    0x8(%ebp),%eax
    9933:	05 c0 00 00 00       	add    $0xc0,%eax
    9938:	83 ec 0c             	sub    $0xc,%esp
    993b:	50                   	push   %eax
    993c:	e8 90 9c ff ff       	call   35d1 <string_cleanup>
    9941:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    9944:	8b 45 08             	mov    0x8(%ebp),%eax
    9947:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    994d:	83 ec 0c             	sub    $0xc,%esp
    9950:	50                   	push   %eax
    9951:	e8 a8 99 ff ff       	call   32fe <lodepng_free>
    9956:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    9959:	8b 45 08             	mov    0x8(%ebp),%eax
    995c:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9963:	00 00 00 
  info->iccp_profile_size = 0;
    9966:	8b 45 08             	mov    0x8(%ebp),%eax
    9969:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    9970:	00 00 00 
  info->iccp_defined = 0;
    9973:	8b 45 08             	mov    0x8(%ebp),%eax
    9976:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    997d:	00 00 00 
}
    9980:	90                   	nop
    9981:	c9                   	leave  
    9982:	c3                   	ret    

00009983 <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    9983:	55                   	push   %ebp
    9984:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    9986:	8b 45 08             	mov    0x8(%ebp),%eax
    9989:	83 c0 0c             	add    $0xc,%eax
    998c:	50                   	push   %eax
    998d:	e8 5a f0 ff ff       	call   89ec <lodepng_color_mode_init>
    9992:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    9995:	8b 45 08             	mov    0x8(%ebp),%eax
    9998:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    999f:	8b 45 08             	mov    0x8(%ebp),%eax
    99a2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    99a8:	8b 45 08             	mov    0x8(%ebp),%eax
    99ab:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    99b2:	8b 45 08             	mov    0x8(%ebp),%eax
    99b5:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    99bc:	8b 45 08             	mov    0x8(%ebp),%eax
    99bf:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    99c6:	8b 45 08             	mov    0x8(%ebp),%eax
    99c9:	8b 50 38             	mov    0x38(%eax),%edx
    99cc:	8b 45 08             	mov    0x8(%ebp),%eax
    99cf:	89 50 34             	mov    %edx,0x34(%eax)
    99d2:	8b 45 08             	mov    0x8(%ebp),%eax
    99d5:	8b 50 34             	mov    0x34(%eax),%edx
    99d8:	8b 45 08             	mov    0x8(%ebp),%eax
    99db:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    99de:	ff 75 08             	pushl  0x8(%ebp)
    99e1:	e8 2c f8 ff ff       	call   9212 <LodePNGText_init>
    99e6:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    99e9:	ff 75 08             	pushl  0x8(%ebp)
    99ec:	e8 a8 fa ff ff       	call   9499 <LodePNGIText_init>
    99f1:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    99f4:	8b 45 08             	mov    0x8(%ebp),%eax
    99f7:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    99fe:	8b 45 08             	mov    0x8(%ebp),%eax
    9a01:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    9a08:	8b 45 08             	mov    0x8(%ebp),%eax
    9a0b:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    9a12:	00 00 00 
  info->chrm_defined = 0;
    9a15:	8b 45 08             	mov    0x8(%ebp),%eax
    9a18:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    9a1f:	00 00 00 
  info->srgb_defined = 0;
    9a22:	8b 45 08             	mov    0x8(%ebp),%eax
    9a25:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    9a2c:	00 00 00 
  info->iccp_defined = 0;
    9a2f:	8b 45 08             	mov    0x8(%ebp),%eax
    9a32:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9a39:	00 00 00 
  info->iccp_name = NULL;
    9a3c:	8b 45 08             	mov    0x8(%ebp),%eax
    9a3f:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    9a46:	00 00 00 
  info->iccp_profile = NULL;
    9a49:	8b 45 08             	mov    0x8(%ebp),%eax
    9a4c:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9a53:	00 00 00 

  LodePNGUnknownChunks_init(info);
    9a56:	ff 75 08             	pushl  0x8(%ebp)
    9a59:	e8 46 f6 ff ff       	call   90a4 <LodePNGUnknownChunks_init>
    9a5e:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9a61:	90                   	nop
    9a62:	c9                   	leave  
    9a63:	c3                   	ret    

00009a64 <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    9a64:	55                   	push   %ebp
    9a65:	89 e5                	mov    %esp,%ebp
    9a67:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    9a6a:	8b 45 08             	mov    0x8(%ebp),%eax
    9a6d:	83 c0 0c             	add    $0xc,%eax
    9a70:	83 ec 0c             	sub    $0xc,%esp
    9a73:	50                   	push   %eax
    9a74:	e8 66 f0 ff ff       	call   8adf <lodepng_color_mode_cleanup>
    9a79:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    9a7c:	83 ec 0c             	sub    $0xc,%esp
    9a7f:	ff 75 08             	pushl  0x8(%ebp)
    9a82:	e8 af f7 ff ff       	call   9236 <LodePNGText_cleanup>
    9a87:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    9a8a:	83 ec 0c             	sub    $0xc,%esp
    9a8d:	ff 75 08             	pushl  0x8(%ebp)
    9a90:	e8 3c fa ff ff       	call   94d1 <LodePNGIText_cleanup>
    9a95:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    9a98:	83 ec 0c             	sub    $0xc,%esp
    9a9b:	ff 75 08             	pushl  0x8(%ebp)
    9a9e:	e8 87 fe ff ff       	call   992a <lodepng_clear_icc>
    9aa3:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    9aa6:	83 ec 0c             	sub    $0xc,%esp
    9aa9:	ff 75 08             	pushl  0x8(%ebp)
    9aac:	e8 44 f6 ff ff       	call   90f5 <LodePNGUnknownChunks_cleanup>
    9ab1:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9ab4:	90                   	nop
    9ab5:	c9                   	leave  
    9ab6:	c3                   	ret    

00009ab7 <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9ab7:	55                   	push   %ebp
    9ab8:	89 e5                	mov    %esp,%ebp
    9aba:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    9abd:	83 ec 0c             	sub    $0xc,%esp
    9ac0:	ff 75 08             	pushl  0x8(%ebp)
    9ac3:	e8 9c ff ff ff       	call   9a64 <lodepng_info_cleanup>
    9ac8:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    9acb:	83 ec 04             	sub    $0x4,%esp
    9ace:	68 e4 00 00 00       	push   $0xe4
    9ad3:	ff 75 0c             	pushl  0xc(%ebp)
    9ad6:	ff 75 08             	pushl  0x8(%ebp)
    9ad9:	e8 3d 98 ff ff       	call   331b <lodepng_memcpy>
    9ade:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    9ae1:	8b 45 08             	mov    0x8(%ebp),%eax
    9ae4:	83 c0 0c             	add    $0xc,%eax
    9ae7:	83 ec 0c             	sub    $0xc,%esp
    9aea:	50                   	push   %eax
    9aeb:	e8 fc ee ff ff       	call   89ec <lodepng_color_mode_init>
    9af0:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    9af3:	8b 45 0c             	mov    0xc(%ebp),%eax
    9af6:	8d 50 0c             	lea    0xc(%eax),%edx
    9af9:	8b 45 08             	mov    0x8(%ebp),%eax
    9afc:	83 c0 0c             	add    $0xc,%eax
    9aff:	83 ec 08             	sub    $0x8,%esp
    9b02:	52                   	push   %edx
    9b03:	50                   	push   %eax
    9b04:	e8 ed ef ff ff       	call   8af6 <lodepng_color_mode_copy>
    9b09:	83 c4 10             	add    $0x10,%esp
    9b0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    9b0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9b13:	74 08                	je     9b1d <lodepng_info_copy+0x66>
    9b15:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9b18:	e9 b7 00 00 00       	jmp    9bd4 <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    9b1d:	83 ec 08             	sub    $0x8,%esp
    9b20:	ff 75 0c             	pushl  0xc(%ebp)
    9b23:	ff 75 08             	pushl  0x8(%ebp)
    9b26:	e8 84 f7 ff ff       	call   92af <LodePNGText_copy>
    9b2b:	83 c4 10             	add    $0x10,%esp
    9b2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9b31:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9b35:	74 08                	je     9b3f <lodepng_info_copy+0x88>
    9b37:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9b3a:	e9 95 00 00 00       	jmp    9bd4 <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    9b3f:	83 ec 08             	sub    $0x8,%esp
    9b42:	ff 75 0c             	pushl  0xc(%ebp)
    9b45:	ff 75 08             	pushl  0x8(%ebp)
    9b48:	e8 55 fa ff ff       	call   95a2 <LodePNGIText_copy>
    9b4d:	83 c4 10             	add    $0x10,%esp
    9b50:	89 45 ec             	mov    %eax,-0x14(%ebp)
    9b53:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9b57:	74 05                	je     9b5e <lodepng_info_copy+0xa7>
    9b59:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9b5c:	eb 76                	jmp    9bd4 <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    9b5e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9b61:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    9b67:	85 c0                	test   %eax,%eax
    9b69:	74 37                	je     9ba2 <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    9b6b:	8b 45 0c             	mov    0xc(%ebp),%eax
    9b6e:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    9b74:	8b 45 0c             	mov    0xc(%ebp),%eax
    9b77:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    9b7d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9b80:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9b86:	51                   	push   %ecx
    9b87:	52                   	push   %edx
    9b88:	50                   	push   %eax
    9b89:	ff 75 08             	pushl  0x8(%ebp)
    9b8c:	e8 bc fc ff ff       	call   984d <lodepng_assign_icc>
    9b91:	83 c4 10             	add    $0x10,%esp
    9b94:	89 45 e8             	mov    %eax,-0x18(%ebp)
    9b97:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9b9b:	74 05                	je     9ba2 <lodepng_info_copy+0xeb>
    9b9d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9ba0:	eb 32                	jmp    9bd4 <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    9ba2:	83 ec 0c             	sub    $0xc,%esp
    9ba5:	ff 75 08             	pushl  0x8(%ebp)
    9ba8:	e8 f7 f4 ff ff       	call   90a4 <LodePNGUnknownChunks_init>
    9bad:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    9bb0:	83 ec 08             	sub    $0x8,%esp
    9bb3:	ff 75 0c             	pushl  0xc(%ebp)
    9bb6:	ff 75 08             	pushl  0x8(%ebp)
    9bb9:	e8 6c f5 ff ff       	call   912a <LodePNGUnknownChunks_copy>
    9bbe:	83 c4 10             	add    $0x10,%esp
    9bc1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9bc4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    9bc8:	74 05                	je     9bcf <lodepng_info_copy+0x118>
    9bca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9bcd:	eb 05                	jmp    9bd4 <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    9bcf:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9bd4:	c9                   	leave  
    9bd5:	c3                   	ret    

00009bd6 <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    9bd6:	55                   	push   %ebp
    9bd7:	89 e5                	mov    %esp,%ebp
    9bd9:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    9bdc:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    9be0:	74 14                	je     9bf6 <addColorBits+0x20>
    9be2:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    9be6:	75 07                	jne    9bef <addColorBits+0x19>
    9be8:	b8 03 00 00 00       	mov    $0x3,%eax
    9bed:	eb 0c                	jmp    9bfb <addColorBits+0x25>
    9bef:	b8 01 00 00 00       	mov    $0x1,%eax
    9bf4:	eb 05                	jmp    9bfb <addColorBits+0x25>
    9bf6:	b8 07 00 00 00       	mov    $0x7,%eax
    9bfb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    9bfe:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c01:	23 45 fc             	and    -0x4(%ebp),%eax
    9c04:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    9c07:	8b 45 10             	mov    0x10(%ebp),%eax
    9c0a:	ba 01 00 00 00       	mov    $0x1,%edx
    9c0f:	89 c1                	mov    %eax,%ecx
    9c11:	d3 e2                	shl    %cl,%edx
    9c13:	89 d0                	mov    %edx,%eax
    9c15:	83 e8 01             	sub    $0x1,%eax
    9c18:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    9c1b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9c1e:	2b 45 f8             	sub    -0x8(%ebp),%eax
    9c21:	0f af 45 10          	imul   0x10(%ebp),%eax
    9c25:	89 c1                	mov    %eax,%ecx
    9c27:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    9c2a:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    9c2e:	75 18                	jne    9c48 <addColorBits+0x72>
    9c30:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c33:	0f af 45 10          	imul   0x10(%ebp),%eax
    9c37:	c1 e8 03             	shr    $0x3,%eax
    9c3a:	89 c2                	mov    %eax,%edx
    9c3c:	8b 45 08             	mov    0x8(%ebp),%eax
    9c3f:	01 d0                	add    %edx,%eax
    9c41:	8b 55 14             	mov    0x14(%ebp),%edx
    9c44:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    9c46:	eb 1e                	jmp    9c66 <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    9c48:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c4b:	0f af 45 10          	imul   0x10(%ebp),%eax
    9c4f:	c1 e8 03             	shr    $0x3,%eax
    9c52:	8b 55 08             	mov    0x8(%ebp),%edx
    9c55:	01 c2                	add    %eax,%edx
    9c57:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9c5a:	01 c8                	add    %ecx,%eax
    9c5c:	0f b6 08             	movzbl (%eax),%ecx
    9c5f:	8b 45 14             	mov    0x14(%ebp),%eax
    9c62:	09 c8                	or     %ecx,%eax
    9c64:	88 02                	mov    %al,(%edx)
}
    9c66:	90                   	nop
    9c67:	c9                   	leave  
    9c68:	c3                   	ret    

00009c69 <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    9c69:	55                   	push   %ebp
    9c6a:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    9c6c:	8b 45 08             	mov    0x8(%ebp),%eax
    9c6f:	6a 40                	push   $0x40
    9c71:	6a 00                	push   $0x0
    9c73:	50                   	push   %eax
    9c74:	e8 d5 96 ff ff       	call   334e <lodepng_memset>
    9c79:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    9c7c:	8b 45 08             	mov    0x8(%ebp),%eax
    9c7f:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    9c86:	90                   	nop
    9c87:	c9                   	leave  
    9c88:	c3                   	ret    

00009c89 <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    9c89:	55                   	push   %ebp
    9c8a:	89 e5                	mov    %esp,%ebp
    9c8c:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    9c8f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9c96:	eb 3b                	jmp    9cd3 <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    9c98:	8b 45 08             	mov    0x8(%ebp),%eax
    9c9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9c9e:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9ca1:	85 c0                	test   %eax,%eax
    9ca3:	74 2a                	je     9ccf <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    9ca5:	8b 45 08             	mov    0x8(%ebp),%eax
    9ca8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9cab:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9cae:	83 ec 0c             	sub    $0xc,%esp
    9cb1:	50                   	push   %eax
    9cb2:	e8 d2 ff ff ff       	call   9c89 <color_tree_cleanup>
    9cb7:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    9cba:	8b 45 08             	mov    0x8(%ebp),%eax
    9cbd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9cc0:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9cc3:	83 ec 0c             	sub    $0xc,%esp
    9cc6:	50                   	push   %eax
    9cc7:	e8 32 96 ff ff       	call   32fe <lodepng_free>
    9ccc:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    9ccf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9cd3:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    9cd7:	75 bf                	jne    9c98 <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    9cd9:	90                   	nop
    9cda:	c9                   	leave  
    9cdb:	c3                   	ret    

00009cdc <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9cdc:	55                   	push   %ebp
    9cdd:	89 e5                	mov    %esp,%ebp
    9cdf:	53                   	push   %ebx
    9ce0:	83 ec 20             	sub    $0x20,%esp
    9ce3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9ce6:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9ce9:	8b 55 14             	mov    0x14(%ebp),%edx
    9cec:	8b 45 18             	mov    0x18(%ebp),%eax
    9cef:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9cf2:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9cf5:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9cf8:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    9cfb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    9d02:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    9d09:	eb 76                	jmp    9d81 <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9d0b:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    9d0f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d12:	89 c1                	mov    %eax,%ecx
    9d14:	d3 fa                	sar    %cl,%edx
    9d16:	89 d0                	mov    %edx,%eax
    9d18:	83 e0 01             	and    $0x1,%eax
    9d1b:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9d1e:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9d22:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d25:	89 c1                	mov    %eax,%ecx
    9d27:	d3 fa                	sar    %cl,%edx
    9d29:	89 d0                	mov    %edx,%eax
    9d2b:	83 e0 01             	and    $0x1,%eax
    9d2e:	01 d8                	add    %ebx,%eax
    9d30:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9d33:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9d37:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d3a:	89 c1                	mov    %eax,%ecx
    9d3c:	d3 fa                	sar    %cl,%edx
    9d3e:	89 d0                	mov    %edx,%eax
    9d40:	83 e0 01             	and    $0x1,%eax
    9d43:	01 d8                	add    %ebx,%eax
    9d45:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9d48:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9d4c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d4f:	89 c1                	mov    %eax,%ecx
    9d51:	d3 fa                	sar    %cl,%edx
    9d53:	89 d0                	mov    %edx,%eax
    9d55:	83 e0 01             	and    $0x1,%eax
    9d58:	01 d8                	add    %ebx,%eax
    9d5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    9d5d:	8b 45 08             	mov    0x8(%ebp),%eax
    9d60:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d63:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9d66:	85 c0                	test   %eax,%eax
    9d68:	75 07                	jne    9d71 <color_tree_get+0x95>
    9d6a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9d6f:	eb 2a                	jmp    9d9b <color_tree_get+0xbf>
    else tree = tree->children[i];
    9d71:	8b 45 08             	mov    0x8(%ebp),%eax
    9d74:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d77:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9d7a:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    9d7d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    9d81:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    9d85:	7e 84                	jle    9d0b <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    9d87:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    9d8b:	74 08                	je     9d95 <color_tree_get+0xb9>
    9d8d:	8b 45 08             	mov    0x8(%ebp),%eax
    9d90:	8b 40 40             	mov    0x40(%eax),%eax
    9d93:	eb 05                	jmp    9d9a <color_tree_get+0xbe>
    9d95:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9d9a:	90                   	nop
}
    9d9b:	83 c4 20             	add    $0x20,%esp
    9d9e:	5b                   	pop    %ebx
    9d9f:	5d                   	pop    %ebp
    9da0:	c3                   	ret    

00009da1 <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9da1:	55                   	push   %ebp
    9da2:	89 e5                	mov    %esp,%ebp
    9da4:	53                   	push   %ebx
    9da5:	83 ec 10             	sub    $0x10,%esp
    9da8:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9dab:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9dae:	8b 55 14             	mov    0x14(%ebp),%edx
    9db1:	8b 45 18             	mov    0x18(%ebp),%eax
    9db4:	88 5d f8             	mov    %bl,-0x8(%ebp)
    9db7:	88 4d f4             	mov    %cl,-0xc(%ebp)
    9dba:	88 55 f0             	mov    %dl,-0x10(%ebp)
    9dbd:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    9dc0:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    9dc4:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    9dc8:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    9dcc:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    9dd0:	53                   	push   %ebx
    9dd1:	51                   	push   %ecx
    9dd2:	52                   	push   %edx
    9dd3:	50                   	push   %eax
    9dd4:	ff 75 08             	pushl  0x8(%ebp)
    9dd7:	e8 00 ff ff ff       	call   9cdc <color_tree_get>
    9ddc:	83 c4 14             	add    $0x14,%esp
    9ddf:	f7 d0                	not    %eax
    9de1:	c1 e8 1f             	shr    $0x1f,%eax
    9de4:	0f b6 c0             	movzbl %al,%eax
}
    9de7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9dea:	c9                   	leave  
    9deb:	c3                   	ret    

00009dec <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    9dec:	55                   	push   %ebp
    9ded:	89 e5                	mov    %esp,%ebp
    9def:	53                   	push   %ebx
    9df0:	83 ec 24             	sub    $0x24,%esp
    9df3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9df6:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9df9:	8b 55 14             	mov    0x14(%ebp),%edx
    9dfc:	8b 45 18             	mov    0x18(%ebp),%eax
    9dff:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    9e02:	88 4d e0             	mov    %cl,-0x20(%ebp)
    9e05:	88 55 dc             	mov    %dl,-0x24(%ebp)
    9e08:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9e0b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9e12:	e9 b0 00 00 00       	jmp    9ec7 <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9e17:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9e1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e1e:	89 c1                	mov    %eax,%ecx
    9e20:	d3 fa                	sar    %cl,%edx
    9e22:	89 d0                	mov    %edx,%eax
    9e24:	83 e0 01             	and    $0x1,%eax
    9e27:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e2a:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9e2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e31:	89 c1                	mov    %eax,%ecx
    9e33:	d3 fa                	sar    %cl,%edx
    9e35:	89 d0                	mov    %edx,%eax
    9e37:	83 e0 01             	and    $0x1,%eax
    9e3a:	01 d8                	add    %ebx,%eax
    9e3c:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e3f:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9e43:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e46:	89 c1                	mov    %eax,%ecx
    9e48:	d3 fa                	sar    %cl,%edx
    9e4a:	89 d0                	mov    %edx,%eax
    9e4c:	83 e0 01             	and    $0x1,%eax
    9e4f:	01 d8                	add    %ebx,%eax
    9e51:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e54:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    9e58:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e5b:	89 c1                	mov    %eax,%ecx
    9e5d:	d3 fa                	sar    %cl,%edx
    9e5f:	89 d0                	mov    %edx,%eax
    9e61:	83 e0 01             	and    $0x1,%eax
    9e64:	01 d8                	add    %ebx,%eax
    9e66:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    9e69:	8b 45 08             	mov    0x8(%ebp),%eax
    9e6c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9e6f:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9e72:	85 c0                	test   %eax,%eax
    9e74:	75 41                	jne    9eb7 <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    9e76:	83 ec 0c             	sub    $0xc,%esp
    9e79:	6a 44                	push   $0x44
    9e7b:	e8 5d 94 ff ff       	call   32dd <lodepng_malloc>
    9e80:	83 c4 10             	add    $0x10,%esp
    9e83:	89 c1                	mov    %eax,%ecx
    9e85:	8b 45 08             	mov    0x8(%ebp),%eax
    9e88:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9e8b:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    9e8e:	8b 45 08             	mov    0x8(%ebp),%eax
    9e91:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9e94:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9e97:	85 c0                	test   %eax,%eax
    9e99:	75 07                	jne    9ea2 <color_tree_add+0xb6>
    9e9b:	b8 53 00 00 00       	mov    $0x53,%eax
    9ea0:	eb 3d                	jmp    9edf <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    9ea2:	8b 45 08             	mov    0x8(%ebp),%eax
    9ea5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ea8:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9eab:	83 ec 0c             	sub    $0xc,%esp
    9eae:	50                   	push   %eax
    9eaf:	e8 b5 fd ff ff       	call   9c69 <color_tree_init>
    9eb4:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    9eb7:	8b 45 08             	mov    0x8(%ebp),%eax
    9eba:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ebd:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9ec0:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9ec3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9ec7:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    9ecb:	0f 8e 46 ff ff ff    	jle    9e17 <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    9ed1:	8b 55 1c             	mov    0x1c(%ebp),%edx
    9ed4:	8b 45 08             	mov    0x8(%ebp),%eax
    9ed7:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    9eda:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9edf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9ee2:	c9                   	leave  
    9ee3:	c3                   	ret    

00009ee4 <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9ee4:	55                   	push   %ebp
    9ee5:	89 e5                	mov    %esp,%ebp
    9ee7:	53                   	push   %ebx
    9ee8:	83 ec 20             	sub    $0x20,%esp
    9eeb:	8b 5d 18             	mov    0x18(%ebp),%ebx
    9eee:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    9ef1:	8b 55 20             	mov    0x20(%ebp),%edx
    9ef4:	8b 45 24             	mov    0x24(%ebp),%eax
    9ef7:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9efa:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9efd:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9f00:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    9f03:	8b 45 10             	mov    0x10(%ebp),%eax
    9f06:	8b 00                	mov    (%eax),%eax
    9f08:	85 c0                	test   %eax,%eax
    9f0a:	0f 85 ad 00 00 00    	jne    9fbd <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    9f10:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    9f14:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    9f17:	8b 45 10             	mov    0x10(%ebp),%eax
    9f1a:	8b 40 04             	mov    0x4(%eax),%eax
    9f1d:	83 f8 08             	cmp    $0x8,%eax
    9f20:	75 13                	jne    9f35 <rgba8ToPixel+0x51>
    9f22:	8b 55 0c             	mov    0xc(%ebp),%edx
    9f25:	8b 45 08             	mov    0x8(%ebp),%eax
    9f28:	01 c2                	add    %eax,%edx
    9f2a:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    9f2e:	88 02                	mov    %al,(%edx)
    9f30:	e9 b4 03 00 00       	jmp    a2e9 <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    9f35:	8b 45 10             	mov    0x10(%ebp),%eax
    9f38:	8b 40 04             	mov    0x4(%eax),%eax
    9f3b:	83 f8 10             	cmp    $0x10,%eax
    9f3e:	75 2a                	jne    9f6a <rgba8ToPixel+0x86>
    9f40:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f43:	01 c0                	add    %eax,%eax
    9f45:	89 c2                	mov    %eax,%edx
    9f47:	8b 45 08             	mov    0x8(%ebp),%eax
    9f4a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    9f4d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f50:	01 c0                	add    %eax,%eax
    9f52:	8d 50 01             	lea    0x1(%eax),%edx
    9f55:	8b 45 08             	mov    0x8(%ebp),%eax
    9f58:	01 d0                	add    %edx,%eax
    9f5a:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    9f5e:	88 10                	mov    %dl,(%eax)
    9f60:	0f b6 00             	movzbl (%eax),%eax
    9f63:	88 01                	mov    %al,(%ecx)
    9f65:	e9 7f 03 00 00       	jmp    a2e9 <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    9f6a:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    9f6e:	8b 45 10             	mov    0x10(%ebp),%eax
    9f71:	8b 40 04             	mov    0x4(%eax),%eax
    9f74:	b9 08 00 00 00       	mov    $0x8,%ecx
    9f79:	29 c1                	sub    %eax,%ecx
    9f7b:	89 c8                	mov    %ecx,%eax
    9f7d:	89 c1                	mov    %eax,%ecx
    9f7f:	d3 ea                	shr    %cl,%edx
    9f81:	89 d0                	mov    %edx,%eax
    9f83:	89 c2                	mov    %eax,%edx
    9f85:	8b 45 10             	mov    0x10(%ebp),%eax
    9f88:	8b 40 04             	mov    0x4(%eax),%eax
    9f8b:	bb 01 00 00 00       	mov    $0x1,%ebx
    9f90:	89 c1                	mov    %eax,%ecx
    9f92:	d3 e3                	shl    %cl,%ebx
    9f94:	89 d8                	mov    %ebx,%eax
    9f96:	83 e8 01             	sub    $0x1,%eax
    9f99:	21 d0                	and    %edx,%eax
    9f9b:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    9f9e:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    9fa2:	8b 45 10             	mov    0x10(%ebp),%eax
    9fa5:	8b 40 04             	mov    0x4(%eax),%eax
    9fa8:	52                   	push   %edx
    9fa9:	50                   	push   %eax
    9faa:	ff 75 0c             	pushl  0xc(%ebp)
    9fad:	ff 75 08             	pushl  0x8(%ebp)
    9fb0:	e8 21 fc ff ff       	call   9bd6 <addColorBits>
    9fb5:	83 c4 10             	add    $0x10,%esp
    9fb8:	e9 2c 03 00 00       	jmp    a2e9 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    9fbd:	8b 45 10             	mov    0x10(%ebp),%eax
    9fc0:	8b 00                	mov    (%eax),%eax
    9fc2:	83 f8 02             	cmp    $0x2,%eax
    9fc5:	0f 85 ee 00 00 00    	jne    a0b9 <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    9fcb:	8b 45 10             	mov    0x10(%ebp),%eax
    9fce:	8b 40 04             	mov    0x4(%eax),%eax
    9fd1:	83 f8 08             	cmp    $0x8,%eax
    9fd4:	75 49                	jne    a01f <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    9fd6:	8b 55 0c             	mov    0xc(%ebp),%edx
    9fd9:	89 d0                	mov    %edx,%eax
    9fdb:	01 c0                	add    %eax,%eax
    9fdd:	01 d0                	add    %edx,%eax
    9fdf:	89 c2                	mov    %eax,%edx
    9fe1:	8b 45 08             	mov    0x8(%ebp),%eax
    9fe4:	01 c2                	add    %eax,%edx
    9fe6:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    9fea:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    9fec:	8b 55 0c             	mov    0xc(%ebp),%edx
    9fef:	89 d0                	mov    %edx,%eax
    9ff1:	01 c0                	add    %eax,%eax
    9ff3:	01 d0                	add    %edx,%eax
    9ff5:	8d 50 01             	lea    0x1(%eax),%edx
    9ff8:	8b 45 08             	mov    0x8(%ebp),%eax
    9ffb:	01 c2                	add    %eax,%edx
    9ffd:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a001:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    a003:	8b 55 0c             	mov    0xc(%ebp),%edx
    a006:	89 d0                	mov    %edx,%eax
    a008:	01 c0                	add    %eax,%eax
    a00a:	01 d0                	add    %edx,%eax
    a00c:	8d 50 02             	lea    0x2(%eax),%edx
    a00f:	8b 45 08             	mov    0x8(%ebp),%eax
    a012:	01 c2                	add    %eax,%edx
    a014:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a018:	88 02                	mov    %al,(%edx)
    a01a:	e9 ca 02 00 00       	jmp    a2e9 <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    a01f:	8b 55 0c             	mov    0xc(%ebp),%edx
    a022:	89 d0                	mov    %edx,%eax
    a024:	01 c0                	add    %eax,%eax
    a026:	01 d0                	add    %edx,%eax
    a028:	01 c0                	add    %eax,%eax
    a02a:	89 c2                	mov    %eax,%edx
    a02c:	8b 45 08             	mov    0x8(%ebp),%eax
    a02f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a032:	8b 55 0c             	mov    0xc(%ebp),%edx
    a035:	89 d0                	mov    %edx,%eax
    a037:	01 c0                	add    %eax,%eax
    a039:	01 d0                	add    %edx,%eax
    a03b:	01 c0                	add    %eax,%eax
    a03d:	8d 50 01             	lea    0x1(%eax),%edx
    a040:	8b 45 08             	mov    0x8(%ebp),%eax
    a043:	01 d0                	add    %edx,%eax
    a045:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a049:	88 10                	mov    %dl,(%eax)
    a04b:	0f b6 00             	movzbl (%eax),%eax
    a04e:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    a050:	8b 55 0c             	mov    0xc(%ebp),%edx
    a053:	89 d0                	mov    %edx,%eax
    a055:	01 c0                	add    %eax,%eax
    a057:	01 d0                	add    %edx,%eax
    a059:	01 c0                	add    %eax,%eax
    a05b:	8d 50 02             	lea    0x2(%eax),%edx
    a05e:	8b 45 08             	mov    0x8(%ebp),%eax
    a061:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a064:	8b 55 0c             	mov    0xc(%ebp),%edx
    a067:	89 d0                	mov    %edx,%eax
    a069:	01 c0                	add    %eax,%eax
    a06b:	01 d0                	add    %edx,%eax
    a06d:	01 c0                	add    %eax,%eax
    a06f:	8d 50 03             	lea    0x3(%eax),%edx
    a072:	8b 45 08             	mov    0x8(%ebp),%eax
    a075:	01 d0                	add    %edx,%eax
    a077:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a07b:	88 10                	mov    %dl,(%eax)
    a07d:	0f b6 00             	movzbl (%eax),%eax
    a080:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    a082:	8b 55 0c             	mov    0xc(%ebp),%edx
    a085:	89 d0                	mov    %edx,%eax
    a087:	01 c0                	add    %eax,%eax
    a089:	01 d0                	add    %edx,%eax
    a08b:	01 c0                	add    %eax,%eax
    a08d:	8d 50 04             	lea    0x4(%eax),%edx
    a090:	8b 45 08             	mov    0x8(%ebp),%eax
    a093:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a096:	8b 55 0c             	mov    0xc(%ebp),%edx
    a099:	89 d0                	mov    %edx,%eax
    a09b:	01 c0                	add    %eax,%eax
    a09d:	01 d0                	add    %edx,%eax
    a09f:	01 c0                	add    %eax,%eax
    a0a1:	8d 50 05             	lea    0x5(%eax),%edx
    a0a4:	8b 45 08             	mov    0x8(%ebp),%eax
    a0a7:	01 d0                	add    %edx,%eax
    a0a9:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a0ad:	88 10                	mov    %dl,(%eax)
    a0af:	0f b6 00             	movzbl (%eax),%eax
    a0b2:	88 01                	mov    %al,(%ecx)
    a0b4:	e9 30 02 00 00       	jmp    a2e9 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a0b9:	8b 45 10             	mov    0x10(%ebp),%eax
    a0bc:	8b 00                	mov    (%eax),%eax
    a0be:	83 f8 03             	cmp    $0x3,%eax
    a0c1:	75 6d                	jne    a130 <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    a0c3:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    a0c7:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    a0cb:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a0cf:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a0d3:	53                   	push   %ebx
    a0d4:	51                   	push   %ecx
    a0d5:	52                   	push   %edx
    a0d6:	50                   	push   %eax
    a0d7:	ff 75 14             	pushl  0x14(%ebp)
    a0da:	e8 fd fb ff ff       	call   9cdc <color_tree_get>
    a0df:	83 c4 14             	add    $0x14,%esp
    a0e2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    a0e5:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a0e9:	79 0a                	jns    a0f5 <rgba8ToPixel+0x211>
    a0eb:	b8 52 00 00 00       	mov    $0x52,%eax
    a0f0:	e9 f9 01 00 00       	jmp    a2ee <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    a0f5:	8b 45 10             	mov    0x10(%ebp),%eax
    a0f8:	8b 40 04             	mov    0x4(%eax),%eax
    a0fb:	83 f8 08             	cmp    $0x8,%eax
    a0fe:	75 12                	jne    a112 <rgba8ToPixel+0x22e>
    a100:	8b 55 0c             	mov    0xc(%ebp),%edx
    a103:	8b 45 08             	mov    0x8(%ebp),%eax
    a106:	01 d0                	add    %edx,%eax
    a108:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a10b:	88 10                	mov    %dl,(%eax)
    a10d:	e9 d7 01 00 00       	jmp    a2e9 <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    a112:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a115:	8b 45 10             	mov    0x10(%ebp),%eax
    a118:	8b 40 04             	mov    0x4(%eax),%eax
    a11b:	52                   	push   %edx
    a11c:	50                   	push   %eax
    a11d:	ff 75 0c             	pushl  0xc(%ebp)
    a120:	ff 75 08             	pushl  0x8(%ebp)
    a123:	e8 ae fa ff ff       	call   9bd6 <addColorBits>
    a128:	83 c4 10             	add    $0x10,%esp
    a12b:	e9 b9 01 00 00       	jmp    a2e9 <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a130:	8b 45 10             	mov    0x10(%ebp),%eax
    a133:	8b 00                	mov    (%eax),%eax
    a135:	83 f8 04             	cmp    $0x4,%eax
    a138:	0f 85 9f 00 00 00    	jne    a1dd <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a13e:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a142:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    a145:	8b 45 10             	mov    0x10(%ebp),%eax
    a148:	8b 40 04             	mov    0x4(%eax),%eax
    a14b:	83 f8 08             	cmp    $0x8,%eax
    a14e:	75 2a                	jne    a17a <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    a150:	8b 45 0c             	mov    0xc(%ebp),%eax
    a153:	01 c0                	add    %eax,%eax
    a155:	89 c2                	mov    %eax,%edx
    a157:	8b 45 08             	mov    0x8(%ebp),%eax
    a15a:	01 c2                	add    %eax,%edx
    a15c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    a160:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    a162:	8b 45 0c             	mov    0xc(%ebp),%eax
    a165:	01 c0                	add    %eax,%eax
    a167:	8d 50 01             	lea    0x1(%eax),%edx
    a16a:	8b 45 08             	mov    0x8(%ebp),%eax
    a16d:	01 c2                	add    %eax,%edx
    a16f:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a173:	88 02                	mov    %al,(%edx)
    a175:	e9 6f 01 00 00       	jmp    a2e9 <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    a17a:	8b 45 10             	mov    0x10(%ebp),%eax
    a17d:	8b 40 04             	mov    0x4(%eax),%eax
    a180:	83 f8 10             	cmp    $0x10,%eax
    a183:	0f 85 60 01 00 00    	jne    a2e9 <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    a189:	8b 45 0c             	mov    0xc(%ebp),%eax
    a18c:	c1 e0 02             	shl    $0x2,%eax
    a18f:	89 c2                	mov    %eax,%edx
    a191:	8b 45 08             	mov    0x8(%ebp),%eax
    a194:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a197:	8b 45 0c             	mov    0xc(%ebp),%eax
    a19a:	c1 e0 02             	shl    $0x2,%eax
    a19d:	8d 50 01             	lea    0x1(%eax),%edx
    a1a0:	8b 45 08             	mov    0x8(%ebp),%eax
    a1a3:	01 d0                	add    %edx,%eax
    a1a5:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    a1a9:	88 10                	mov    %dl,(%eax)
    a1ab:	0f b6 00             	movzbl (%eax),%eax
    a1ae:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    a1b0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1b3:	c1 e0 02             	shl    $0x2,%eax
    a1b6:	8d 50 02             	lea    0x2(%eax),%edx
    a1b9:	8b 45 08             	mov    0x8(%ebp),%eax
    a1bc:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a1bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1c2:	c1 e0 02             	shl    $0x2,%eax
    a1c5:	8d 50 03             	lea    0x3(%eax),%edx
    a1c8:	8b 45 08             	mov    0x8(%ebp),%eax
    a1cb:	01 d0                	add    %edx,%eax
    a1cd:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a1d1:	88 10                	mov    %dl,(%eax)
    a1d3:	0f b6 00             	movzbl (%eax),%eax
    a1d6:	88 01                	mov    %al,(%ecx)
    a1d8:	e9 0c 01 00 00       	jmp    a2e9 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    a1dd:	8b 45 10             	mov    0x10(%ebp),%eax
    a1e0:	8b 00                	mov    (%eax),%eax
    a1e2:	83 f8 06             	cmp    $0x6,%eax
    a1e5:	0f 85 fe 00 00 00    	jne    a2e9 <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    a1eb:	8b 45 10             	mov    0x10(%ebp),%eax
    a1ee:	8b 40 04             	mov    0x4(%eax),%eax
    a1f1:	83 f8 08             	cmp    $0x8,%eax
    a1f4:	75 54                	jne    a24a <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    a1f6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1f9:	c1 e0 02             	shl    $0x2,%eax
    a1fc:	89 c2                	mov    %eax,%edx
    a1fe:	8b 45 08             	mov    0x8(%ebp),%eax
    a201:	01 c2                	add    %eax,%edx
    a203:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a207:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    a209:	8b 45 0c             	mov    0xc(%ebp),%eax
    a20c:	c1 e0 02             	shl    $0x2,%eax
    a20f:	8d 50 01             	lea    0x1(%eax),%edx
    a212:	8b 45 08             	mov    0x8(%ebp),%eax
    a215:	01 c2                	add    %eax,%edx
    a217:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a21b:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    a21d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a220:	c1 e0 02             	shl    $0x2,%eax
    a223:	8d 50 02             	lea    0x2(%eax),%edx
    a226:	8b 45 08             	mov    0x8(%ebp),%eax
    a229:	01 c2                	add    %eax,%edx
    a22b:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a22f:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    a231:	8b 45 0c             	mov    0xc(%ebp),%eax
    a234:	c1 e0 02             	shl    $0x2,%eax
    a237:	8d 50 03             	lea    0x3(%eax),%edx
    a23a:	8b 45 08             	mov    0x8(%ebp),%eax
    a23d:	01 c2                	add    %eax,%edx
    a23f:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a243:	88 02                	mov    %al,(%edx)
    a245:	e9 9f 00 00 00       	jmp    a2e9 <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    a24a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a24d:	c1 e0 03             	shl    $0x3,%eax
    a250:	89 c2                	mov    %eax,%edx
    a252:	8b 45 08             	mov    0x8(%ebp),%eax
    a255:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a258:	8b 45 0c             	mov    0xc(%ebp),%eax
    a25b:	c1 e0 03             	shl    $0x3,%eax
    a25e:	8d 50 01             	lea    0x1(%eax),%edx
    a261:	8b 45 08             	mov    0x8(%ebp),%eax
    a264:	01 d0                	add    %edx,%eax
    a266:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a26a:	88 10                	mov    %dl,(%eax)
    a26c:	0f b6 00             	movzbl (%eax),%eax
    a26f:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    a271:	8b 45 0c             	mov    0xc(%ebp),%eax
    a274:	c1 e0 03             	shl    $0x3,%eax
    a277:	8d 50 02             	lea    0x2(%eax),%edx
    a27a:	8b 45 08             	mov    0x8(%ebp),%eax
    a27d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a280:	8b 45 0c             	mov    0xc(%ebp),%eax
    a283:	c1 e0 03             	shl    $0x3,%eax
    a286:	8d 50 03             	lea    0x3(%eax),%edx
    a289:	8b 45 08             	mov    0x8(%ebp),%eax
    a28c:	01 d0                	add    %edx,%eax
    a28e:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a292:	88 10                	mov    %dl,(%eax)
    a294:	0f b6 00             	movzbl (%eax),%eax
    a297:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    a299:	8b 45 0c             	mov    0xc(%ebp),%eax
    a29c:	c1 e0 03             	shl    $0x3,%eax
    a29f:	8d 50 04             	lea    0x4(%eax),%edx
    a2a2:	8b 45 08             	mov    0x8(%ebp),%eax
    a2a5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a2a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2ab:	c1 e0 03             	shl    $0x3,%eax
    a2ae:	8d 50 05             	lea    0x5(%eax),%edx
    a2b1:	8b 45 08             	mov    0x8(%ebp),%eax
    a2b4:	01 d0                	add    %edx,%eax
    a2b6:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a2ba:	88 10                	mov    %dl,(%eax)
    a2bc:	0f b6 00             	movzbl (%eax),%eax
    a2bf:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    a2c1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2c4:	c1 e0 03             	shl    $0x3,%eax
    a2c7:	8d 50 06             	lea    0x6(%eax),%edx
    a2ca:	8b 45 08             	mov    0x8(%ebp),%eax
    a2cd:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a2d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2d3:	c1 e0 03             	shl    $0x3,%eax
    a2d6:	8d 50 07             	lea    0x7(%eax),%edx
    a2d9:	8b 45 08             	mov    0x8(%ebp),%eax
    a2dc:	01 d0                	add    %edx,%eax
    a2de:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a2e2:	88 10                	mov    %dl,(%eax)
    a2e4:	0f b6 00             	movzbl (%eax),%eax
    a2e7:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    a2e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a2ee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a2f1:	c9                   	leave  
    a2f2:	c3                   	ret    

0000a2f3 <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    a2f3:	55                   	push   %ebp
    a2f4:	89 e5                	mov    %esp,%ebp
    a2f6:	53                   	push   %ebx
    a2f7:	83 ec 20             	sub    $0x20,%esp
    a2fa:	8b 5d 14             	mov    0x14(%ebp),%ebx
    a2fd:	8b 4d 18             	mov    0x18(%ebp),%ecx
    a300:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a303:	8b 45 20             	mov    0x20(%ebp),%eax
    a306:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    a30a:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    a30e:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    a312:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a316:	8b 45 10             	mov    0x10(%ebp),%eax
    a319:	8b 00                	mov    (%eax),%eax
    a31b:	85 c0                	test   %eax,%eax
    a31d:	75 36                	jne    a355 <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a31f:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a323:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    a327:	8b 45 0c             	mov    0xc(%ebp),%eax
    a32a:	01 c0                	add    %eax,%eax
    a32c:	89 c2                	mov    %eax,%edx
    a32e:	8b 45 08             	mov    0x8(%ebp),%eax
    a331:	01 d0                	add    %edx,%eax
    a333:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a337:	66 c1 ea 08          	shr    $0x8,%dx
    a33b:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    a33d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a340:	01 c0                	add    %eax,%eax
    a342:	8d 50 01             	lea    0x1(%eax),%edx
    a345:	8b 45 08             	mov    0x8(%ebp),%eax
    a348:	01 d0                	add    %edx,%eax
    a34a:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a34e:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a350:	e9 df 01 00 00       	jmp    a534 <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    a355:	8b 45 10             	mov    0x10(%ebp),%eax
    a358:	8b 00                	mov    (%eax),%eax
    a35a:	83 f8 02             	cmp    $0x2,%eax
    a35d:	0f 85 a6 00 00 00    	jne    a409 <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    a363:	8b 55 0c             	mov    0xc(%ebp),%edx
    a366:	89 d0                	mov    %edx,%eax
    a368:	01 c0                	add    %eax,%eax
    a36a:	01 d0                	add    %edx,%eax
    a36c:	01 c0                	add    %eax,%eax
    a36e:	89 c2                	mov    %eax,%edx
    a370:	8b 45 08             	mov    0x8(%ebp),%eax
    a373:	01 d0                	add    %edx,%eax
    a375:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a379:	66 c1 ea 08          	shr    $0x8,%dx
    a37d:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    a37f:	8b 55 0c             	mov    0xc(%ebp),%edx
    a382:	89 d0                	mov    %edx,%eax
    a384:	01 c0                	add    %eax,%eax
    a386:	01 d0                	add    %edx,%eax
    a388:	01 c0                	add    %eax,%eax
    a38a:	8d 50 01             	lea    0x1(%eax),%edx
    a38d:	8b 45 08             	mov    0x8(%ebp),%eax
    a390:	01 d0                	add    %edx,%eax
    a392:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a396:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    a398:	8b 55 0c             	mov    0xc(%ebp),%edx
    a39b:	89 d0                	mov    %edx,%eax
    a39d:	01 c0                	add    %eax,%eax
    a39f:	01 d0                	add    %edx,%eax
    a3a1:	01 c0                	add    %eax,%eax
    a3a3:	8d 50 02             	lea    0x2(%eax),%edx
    a3a6:	8b 45 08             	mov    0x8(%ebp),%eax
    a3a9:	01 d0                	add    %edx,%eax
    a3ab:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a3af:	66 c1 ea 08          	shr    $0x8,%dx
    a3b3:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    a3b5:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3b8:	89 d0                	mov    %edx,%eax
    a3ba:	01 c0                	add    %eax,%eax
    a3bc:	01 d0                	add    %edx,%eax
    a3be:	01 c0                	add    %eax,%eax
    a3c0:	8d 50 03             	lea    0x3(%eax),%edx
    a3c3:	8b 45 08             	mov    0x8(%ebp),%eax
    a3c6:	01 d0                	add    %edx,%eax
    a3c8:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a3cc:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    a3ce:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3d1:	89 d0                	mov    %edx,%eax
    a3d3:	01 c0                	add    %eax,%eax
    a3d5:	01 d0                	add    %edx,%eax
    a3d7:	01 c0                	add    %eax,%eax
    a3d9:	8d 50 04             	lea    0x4(%eax),%edx
    a3dc:	8b 45 08             	mov    0x8(%ebp),%eax
    a3df:	01 d0                	add    %edx,%eax
    a3e1:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a3e5:	66 c1 ea 08          	shr    $0x8,%dx
    a3e9:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    a3eb:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3ee:	89 d0                	mov    %edx,%eax
    a3f0:	01 c0                	add    %eax,%eax
    a3f2:	01 d0                	add    %edx,%eax
    a3f4:	01 c0                	add    %eax,%eax
    a3f6:	8d 50 05             	lea    0x5(%eax),%edx
    a3f9:	8b 45 08             	mov    0x8(%ebp),%eax
    a3fc:	01 d0                	add    %edx,%eax
    a3fe:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a402:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a404:	e9 2b 01 00 00       	jmp    a534 <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a409:	8b 45 10             	mov    0x10(%ebp),%eax
    a40c:	8b 00                	mov    (%eax),%eax
    a40e:	83 f8 04             	cmp    $0x4,%eax
    a411:	75 64                	jne    a477 <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a413:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a417:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    a41b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a41e:	c1 e0 02             	shl    $0x2,%eax
    a421:	89 c2                	mov    %eax,%edx
    a423:	8b 45 08             	mov    0x8(%ebp),%eax
    a426:	01 d0                	add    %edx,%eax
    a428:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a42c:	66 c1 ea 08          	shr    $0x8,%dx
    a430:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    a432:	8b 45 0c             	mov    0xc(%ebp),%eax
    a435:	c1 e0 02             	shl    $0x2,%eax
    a438:	8d 50 01             	lea    0x1(%eax),%edx
    a43b:	8b 45 08             	mov    0x8(%ebp),%eax
    a43e:	01 d0                	add    %edx,%eax
    a440:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a444:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    a446:	8b 45 0c             	mov    0xc(%ebp),%eax
    a449:	c1 e0 02             	shl    $0x2,%eax
    a44c:	8d 50 02             	lea    0x2(%eax),%edx
    a44f:	8b 45 08             	mov    0x8(%ebp),%eax
    a452:	01 d0                	add    %edx,%eax
    a454:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a458:	66 c1 ea 08          	shr    $0x8,%dx
    a45c:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    a45e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a461:	c1 e0 02             	shl    $0x2,%eax
    a464:	8d 50 03             	lea    0x3(%eax),%edx
    a467:	8b 45 08             	mov    0x8(%ebp),%eax
    a46a:	01 d0                	add    %edx,%eax
    a46c:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a470:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a472:	e9 bd 00 00 00       	jmp    a534 <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    a477:	8b 45 10             	mov    0x10(%ebp),%eax
    a47a:	8b 00                	mov    (%eax),%eax
    a47c:	83 f8 06             	cmp    $0x6,%eax
    a47f:	0f 85 af 00 00 00    	jne    a534 <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    a485:	8b 45 0c             	mov    0xc(%ebp),%eax
    a488:	c1 e0 03             	shl    $0x3,%eax
    a48b:	89 c2                	mov    %eax,%edx
    a48d:	8b 45 08             	mov    0x8(%ebp),%eax
    a490:	01 d0                	add    %edx,%eax
    a492:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a496:	66 c1 ea 08          	shr    $0x8,%dx
    a49a:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    a49c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a49f:	c1 e0 03             	shl    $0x3,%eax
    a4a2:	8d 50 01             	lea    0x1(%eax),%edx
    a4a5:	8b 45 08             	mov    0x8(%ebp),%eax
    a4a8:	01 d0                	add    %edx,%eax
    a4aa:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a4ae:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    a4b0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4b3:	c1 e0 03             	shl    $0x3,%eax
    a4b6:	8d 50 02             	lea    0x2(%eax),%edx
    a4b9:	8b 45 08             	mov    0x8(%ebp),%eax
    a4bc:	01 d0                	add    %edx,%eax
    a4be:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a4c2:	66 c1 ea 08          	shr    $0x8,%dx
    a4c6:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    a4c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4cb:	c1 e0 03             	shl    $0x3,%eax
    a4ce:	8d 50 03             	lea    0x3(%eax),%edx
    a4d1:	8b 45 08             	mov    0x8(%ebp),%eax
    a4d4:	01 d0                	add    %edx,%eax
    a4d6:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a4da:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    a4dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4df:	c1 e0 03             	shl    $0x3,%eax
    a4e2:	8d 50 04             	lea    0x4(%eax),%edx
    a4e5:	8b 45 08             	mov    0x8(%ebp),%eax
    a4e8:	01 d0                	add    %edx,%eax
    a4ea:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a4ee:	66 c1 ea 08          	shr    $0x8,%dx
    a4f2:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    a4f4:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4f7:	c1 e0 03             	shl    $0x3,%eax
    a4fa:	8d 50 05             	lea    0x5(%eax),%edx
    a4fd:	8b 45 08             	mov    0x8(%ebp),%eax
    a500:	01 d0                	add    %edx,%eax
    a502:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a506:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    a508:	8b 45 0c             	mov    0xc(%ebp),%eax
    a50b:	c1 e0 03             	shl    $0x3,%eax
    a50e:	8d 50 06             	lea    0x6(%eax),%edx
    a511:	8b 45 08             	mov    0x8(%ebp),%eax
    a514:	01 d0                	add    %edx,%eax
    a516:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a51a:	66 c1 ea 08          	shr    $0x8,%dx
    a51e:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    a520:	8b 45 0c             	mov    0xc(%ebp),%eax
    a523:	c1 e0 03             	shl    $0x3,%eax
    a526:	8d 50 07             	lea    0x7(%eax),%edx
    a529:	8b 45 08             	mov    0x8(%ebp),%eax
    a52c:	01 d0                	add    %edx,%eax
    a52e:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a532:	88 10                	mov    %dl,(%eax)
  }
}
    a534:	90                   	nop
    a535:	83 c4 20             	add    $0x20,%esp
    a538:	5b                   	pop    %ebx
    a539:	5d                   	pop    %ebp
    a53a:	c3                   	ret    

0000a53b <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    a53b:	55                   	push   %ebp
    a53c:	89 e5                	mov    %esp,%ebp
    a53e:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    a541:	8b 45 20             	mov    0x20(%ebp),%eax
    a544:	8b 00                	mov    (%eax),%eax
    a546:	85 c0                	test   %eax,%eax
    a548:	0f 85 8c 01 00 00    	jne    a6da <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    a54e:	8b 45 20             	mov    0x20(%ebp),%eax
    a551:	8b 40 04             	mov    0x4(%eax),%eax
    a554:	83 f8 08             	cmp    $0x8,%eax
    a557:	75 59                	jne    a5b2 <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    a559:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a55c:	8b 45 18             	mov    0x18(%ebp),%eax
    a55f:	01 d0                	add    %edx,%eax
    a561:	0f b6 10             	movzbl (%eax),%edx
    a564:	8b 45 10             	mov    0x10(%ebp),%eax
    a567:	88 10                	mov    %dl,(%eax)
    a569:	8b 45 10             	mov    0x10(%ebp),%eax
    a56c:	0f b6 10             	movzbl (%eax),%edx
    a56f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a572:	88 10                	mov    %dl,(%eax)
    a574:	8b 45 0c             	mov    0xc(%ebp),%eax
    a577:	0f b6 10             	movzbl (%eax),%edx
    a57a:	8b 45 08             	mov    0x8(%ebp),%eax
    a57d:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    a57f:	8b 45 20             	mov    0x20(%ebp),%eax
    a582:	8b 40 10             	mov    0x10(%eax),%eax
    a585:	85 c0                	test   %eax,%eax
    a587:	74 1e                	je     a5a7 <getPixelColorRGBA8+0x6c>
    a589:	8b 45 08             	mov    0x8(%ebp),%eax
    a58c:	0f b6 00             	movzbl (%eax),%eax
    a58f:	0f b6 d0             	movzbl %al,%edx
    a592:	8b 45 20             	mov    0x20(%ebp),%eax
    a595:	8b 40 14             	mov    0x14(%eax),%eax
    a598:	39 c2                	cmp    %eax,%edx
    a59a:	75 0b                	jne    a5a7 <getPixelColorRGBA8+0x6c>
    a59c:	8b 45 14             	mov    0x14(%ebp),%eax
    a59f:	c6 00 00             	movb   $0x0,(%eax)
    a5a2:	e9 5e 05 00 00       	jmp    ab05 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a5a7:	8b 45 14             	mov    0x14(%ebp),%eax
    a5aa:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a5ad:	e9 53 05 00 00       	jmp    ab05 <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    a5b2:	8b 45 20             	mov    0x20(%ebp),%eax
    a5b5:	8b 40 04             	mov    0x4(%eax),%eax
    a5b8:	83 f8 10             	cmp    $0x10,%eax
    a5bb:	0f 85 80 00 00 00    	jne    a641 <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    a5c1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a5c4:	01 c0                	add    %eax,%eax
    a5c6:	89 c2                	mov    %eax,%edx
    a5c8:	8b 45 18             	mov    0x18(%ebp),%eax
    a5cb:	01 d0                	add    %edx,%eax
    a5cd:	0f b6 10             	movzbl (%eax),%edx
    a5d0:	8b 45 10             	mov    0x10(%ebp),%eax
    a5d3:	88 10                	mov    %dl,(%eax)
    a5d5:	8b 45 10             	mov    0x10(%ebp),%eax
    a5d8:	0f b6 10             	movzbl (%eax),%edx
    a5db:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5de:	88 10                	mov    %dl,(%eax)
    a5e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5e3:	0f b6 10             	movzbl (%eax),%edx
    a5e6:	8b 45 08             	mov    0x8(%ebp),%eax
    a5e9:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    a5eb:	8b 45 20             	mov    0x20(%ebp),%eax
    a5ee:	8b 40 10             	mov    0x10(%eax),%eax
    a5f1:	85 c0                	test   %eax,%eax
    a5f3:	74 41                	je     a636 <getPixelColorRGBA8+0xfb>
    a5f5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a5f8:	01 c0                	add    %eax,%eax
    a5fa:	89 c2                	mov    %eax,%edx
    a5fc:	8b 45 18             	mov    0x18(%ebp),%eax
    a5ff:	01 d0                	add    %edx,%eax
    a601:	0f b6 00             	movzbl (%eax),%eax
    a604:	0f b6 c0             	movzbl %al,%eax
    a607:	c1 e0 08             	shl    $0x8,%eax
    a60a:	89 c2                	mov    %eax,%edx
    a60c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a60f:	01 c0                	add    %eax,%eax
    a611:	8d 48 01             	lea    0x1(%eax),%ecx
    a614:	8b 45 18             	mov    0x18(%ebp),%eax
    a617:	01 c8                	add    %ecx,%eax
    a619:	0f b6 00             	movzbl (%eax),%eax
    a61c:	0f b6 c0             	movzbl %al,%eax
    a61f:	01 c2                	add    %eax,%edx
    a621:	8b 45 20             	mov    0x20(%ebp),%eax
    a624:	8b 40 14             	mov    0x14(%eax),%eax
    a627:	39 c2                	cmp    %eax,%edx
    a629:	75 0b                	jne    a636 <getPixelColorRGBA8+0xfb>
    a62b:	8b 45 14             	mov    0x14(%ebp),%eax
    a62e:	c6 00 00             	movb   $0x0,(%eax)
    a631:	e9 cf 04 00 00       	jmp    ab05 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a636:	8b 45 14             	mov    0x14(%ebp),%eax
    a639:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a63c:	e9 c4 04 00 00       	jmp    ab05 <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    a641:	8b 45 20             	mov    0x20(%ebp),%eax
    a644:	8b 40 04             	mov    0x4(%eax),%eax
    a647:	ba 01 00 00 00       	mov    $0x1,%edx
    a64c:	89 c1                	mov    %eax,%ecx
    a64e:	d3 e2                	shl    %cl,%edx
    a650:	89 d0                	mov    %edx,%eax
    a652:	83 e8 01             	sub    $0x1,%eax
    a655:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    a658:	8b 45 20             	mov    0x20(%ebp),%eax
    a65b:	8b 50 04             	mov    0x4(%eax),%edx
    a65e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a661:	0f af c2             	imul   %edx,%eax
    a664:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a667:	8b 45 20             	mov    0x20(%ebp),%eax
    a66a:	8b 40 04             	mov    0x4(%eax),%eax
    a66d:	50                   	push   %eax
    a66e:	ff 75 18             	pushl  0x18(%ebp)
    a671:	8d 45 f0             	lea    -0x10(%ebp),%eax
    a674:	50                   	push   %eax
    a675:	e8 06 db ff ff       	call   8180 <readBitsFromReversedStream>
    a67a:	83 c4 0c             	add    $0xc,%esp
    a67d:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    a680:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a683:	89 d0                	mov    %edx,%eax
    a685:	c1 e0 08             	shl    $0x8,%eax
    a688:	29 d0                	sub    %edx,%eax
    a68a:	ba 00 00 00 00       	mov    $0x0,%edx
    a68f:	f7 75 f8             	divl   -0x8(%ebp)
    a692:	89 c2                	mov    %eax,%edx
    a694:	8b 45 10             	mov    0x10(%ebp),%eax
    a697:	88 10                	mov    %dl,(%eax)
    a699:	8b 45 10             	mov    0x10(%ebp),%eax
    a69c:	0f b6 10             	movzbl (%eax),%edx
    a69f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6a2:	88 10                	mov    %dl,(%eax)
    a6a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6a7:	0f b6 10             	movzbl (%eax),%edx
    a6aa:	8b 45 08             	mov    0x8(%ebp),%eax
    a6ad:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    a6af:	8b 45 20             	mov    0x20(%ebp),%eax
    a6b2:	8b 40 10             	mov    0x10(%eax),%eax
    a6b5:	85 c0                	test   %eax,%eax
    a6b7:	74 16                	je     a6cf <getPixelColorRGBA8+0x194>
    a6b9:	8b 45 20             	mov    0x20(%ebp),%eax
    a6bc:	8b 40 14             	mov    0x14(%eax),%eax
    a6bf:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a6c2:	75 0b                	jne    a6cf <getPixelColorRGBA8+0x194>
    a6c4:	8b 45 14             	mov    0x14(%ebp),%eax
    a6c7:	c6 00 00             	movb   $0x0,(%eax)
    a6ca:	e9 36 04 00 00       	jmp    ab05 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a6cf:	8b 45 14             	mov    0x14(%ebp),%eax
    a6d2:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a6d5:	e9 2b 04 00 00       	jmp    ab05 <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    a6da:	8b 45 20             	mov    0x20(%ebp),%eax
    a6dd:	8b 00                	mov    (%eax),%eax
    a6df:	83 f8 02             	cmp    $0x2,%eax
    a6e2:	0f 85 f5 01 00 00    	jne    a8dd <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    a6e8:	8b 45 20             	mov    0x20(%ebp),%eax
    a6eb:	8b 40 04             	mov    0x4(%eax),%eax
    a6ee:	83 f8 08             	cmp    $0x8,%eax
    a6f1:	0f 85 a3 00 00 00    	jne    a79a <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    a6f7:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a6fa:	89 d0                	mov    %edx,%eax
    a6fc:	01 c0                	add    %eax,%eax
    a6fe:	01 d0                	add    %edx,%eax
    a700:	89 c2                	mov    %eax,%edx
    a702:	8b 45 18             	mov    0x18(%ebp),%eax
    a705:	01 d0                	add    %edx,%eax
    a707:	0f b6 10             	movzbl (%eax),%edx
    a70a:	8b 45 08             	mov    0x8(%ebp),%eax
    a70d:	88 10                	mov    %dl,(%eax)
    a70f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a712:	89 d0                	mov    %edx,%eax
    a714:	01 c0                	add    %eax,%eax
    a716:	01 d0                	add    %edx,%eax
    a718:	8d 50 01             	lea    0x1(%eax),%edx
    a71b:	8b 45 18             	mov    0x18(%ebp),%eax
    a71e:	01 d0                	add    %edx,%eax
    a720:	0f b6 10             	movzbl (%eax),%edx
    a723:	8b 45 0c             	mov    0xc(%ebp),%eax
    a726:	88 10                	mov    %dl,(%eax)
    a728:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a72b:	89 d0                	mov    %edx,%eax
    a72d:	01 c0                	add    %eax,%eax
    a72f:	01 d0                	add    %edx,%eax
    a731:	8d 50 02             	lea    0x2(%eax),%edx
    a734:	8b 45 18             	mov    0x18(%ebp),%eax
    a737:	01 d0                	add    %edx,%eax
    a739:	0f b6 10             	movzbl (%eax),%edx
    a73c:	8b 45 10             	mov    0x10(%ebp),%eax
    a73f:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    a741:	8b 45 20             	mov    0x20(%ebp),%eax
    a744:	8b 40 10             	mov    0x10(%eax),%eax
    a747:	85 c0                	test   %eax,%eax
    a749:	74 44                	je     a78f <getPixelColorRGBA8+0x254>
    a74b:	8b 45 08             	mov    0x8(%ebp),%eax
    a74e:	0f b6 00             	movzbl (%eax),%eax
    a751:	0f b6 d0             	movzbl %al,%edx
    a754:	8b 45 20             	mov    0x20(%ebp),%eax
    a757:	8b 40 14             	mov    0x14(%eax),%eax
    a75a:	39 c2                	cmp    %eax,%edx
    a75c:	75 31                	jne    a78f <getPixelColorRGBA8+0x254>
    a75e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a761:	0f b6 00             	movzbl (%eax),%eax
    a764:	0f b6 d0             	movzbl %al,%edx
    a767:	8b 45 20             	mov    0x20(%ebp),%eax
    a76a:	8b 40 18             	mov    0x18(%eax),%eax
    a76d:	39 c2                	cmp    %eax,%edx
    a76f:	75 1e                	jne    a78f <getPixelColorRGBA8+0x254>
    a771:	8b 45 10             	mov    0x10(%ebp),%eax
    a774:	0f b6 00             	movzbl (%eax),%eax
    a777:	0f b6 d0             	movzbl %al,%edx
    a77a:	8b 45 20             	mov    0x20(%ebp),%eax
    a77d:	8b 40 1c             	mov    0x1c(%eax),%eax
    a780:	39 c2                	cmp    %eax,%edx
    a782:	75 0b                	jne    a78f <getPixelColorRGBA8+0x254>
    a784:	8b 45 14             	mov    0x14(%ebp),%eax
    a787:	c6 00 00             	movb   $0x0,(%eax)
    a78a:	e9 76 03 00 00       	jmp    ab05 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a78f:	8b 45 14             	mov    0x14(%ebp),%eax
    a792:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a795:	e9 6b 03 00 00       	jmp    ab05 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    a79a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a79d:	89 d0                	mov    %edx,%eax
    a79f:	01 c0                	add    %eax,%eax
    a7a1:	01 d0                	add    %edx,%eax
    a7a3:	01 c0                	add    %eax,%eax
    a7a5:	89 c2                	mov    %eax,%edx
    a7a7:	8b 45 18             	mov    0x18(%ebp),%eax
    a7aa:	01 d0                	add    %edx,%eax
    a7ac:	0f b6 10             	movzbl (%eax),%edx
    a7af:	8b 45 08             	mov    0x8(%ebp),%eax
    a7b2:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    a7b4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a7b7:	89 d0                	mov    %edx,%eax
    a7b9:	01 c0                	add    %eax,%eax
    a7bb:	01 d0                	add    %edx,%eax
    a7bd:	01 c0                	add    %eax,%eax
    a7bf:	8d 50 02             	lea    0x2(%eax),%edx
    a7c2:	8b 45 18             	mov    0x18(%ebp),%eax
    a7c5:	01 d0                	add    %edx,%eax
    a7c7:	0f b6 10             	movzbl (%eax),%edx
    a7ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7cd:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    a7cf:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a7d2:	89 d0                	mov    %edx,%eax
    a7d4:	01 c0                	add    %eax,%eax
    a7d6:	01 d0                	add    %edx,%eax
    a7d8:	01 c0                	add    %eax,%eax
    a7da:	8d 50 04             	lea    0x4(%eax),%edx
    a7dd:	8b 45 18             	mov    0x18(%ebp),%eax
    a7e0:	01 d0                	add    %edx,%eax
    a7e2:	0f b6 10             	movzbl (%eax),%edx
    a7e5:	8b 45 10             	mov    0x10(%ebp),%eax
    a7e8:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    a7ea:	8b 45 20             	mov    0x20(%ebp),%eax
    a7ed:	8b 40 10             	mov    0x10(%eax),%eax
    a7f0:	85 c0                	test   %eax,%eax
    a7f2:	0f 84 da 00 00 00    	je     a8d2 <getPixelColorRGBA8+0x397>
    a7f8:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a7fb:	89 d0                	mov    %edx,%eax
    a7fd:	01 c0                	add    %eax,%eax
    a7ff:	01 d0                	add    %edx,%eax
    a801:	01 c0                	add    %eax,%eax
    a803:	89 c2                	mov    %eax,%edx
    a805:	8b 45 18             	mov    0x18(%ebp),%eax
    a808:	01 d0                	add    %edx,%eax
    a80a:	0f b6 00             	movzbl (%eax),%eax
    a80d:	0f b6 c0             	movzbl %al,%eax
    a810:	c1 e0 08             	shl    $0x8,%eax
    a813:	89 c1                	mov    %eax,%ecx
    a815:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a818:	89 d0                	mov    %edx,%eax
    a81a:	01 c0                	add    %eax,%eax
    a81c:	01 d0                	add    %edx,%eax
    a81e:	01 c0                	add    %eax,%eax
    a820:	8d 50 01             	lea    0x1(%eax),%edx
    a823:	8b 45 18             	mov    0x18(%ebp),%eax
    a826:	01 d0                	add    %edx,%eax
    a828:	0f b6 00             	movzbl (%eax),%eax
    a82b:	0f b6 c0             	movzbl %al,%eax
    a82e:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a831:	8b 45 20             	mov    0x20(%ebp),%eax
    a834:	8b 40 14             	mov    0x14(%eax),%eax
    a837:	39 c2                	cmp    %eax,%edx
    a839:	0f 85 93 00 00 00    	jne    a8d2 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    a83f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a842:	89 d0                	mov    %edx,%eax
    a844:	01 c0                	add    %eax,%eax
    a846:	01 d0                	add    %edx,%eax
    a848:	01 c0                	add    %eax,%eax
    a84a:	8d 50 02             	lea    0x2(%eax),%edx
    a84d:	8b 45 18             	mov    0x18(%ebp),%eax
    a850:	01 d0                	add    %edx,%eax
    a852:	0f b6 00             	movzbl (%eax),%eax
    a855:	0f b6 c0             	movzbl %al,%eax
    a858:	c1 e0 08             	shl    $0x8,%eax
    a85b:	89 c1                	mov    %eax,%ecx
    a85d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a860:	89 d0                	mov    %edx,%eax
    a862:	01 c0                	add    %eax,%eax
    a864:	01 d0                	add    %edx,%eax
    a866:	01 c0                	add    %eax,%eax
    a868:	8d 50 03             	lea    0x3(%eax),%edx
    a86b:	8b 45 18             	mov    0x18(%ebp),%eax
    a86e:	01 d0                	add    %edx,%eax
    a870:	0f b6 00             	movzbl (%eax),%eax
    a873:	0f b6 c0             	movzbl %al,%eax
    a876:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a879:	8b 45 20             	mov    0x20(%ebp),%eax
    a87c:	8b 40 18             	mov    0x18(%eax),%eax
    a87f:	39 c2                	cmp    %eax,%edx
    a881:	75 4f                	jne    a8d2 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    a883:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a886:	89 d0                	mov    %edx,%eax
    a888:	01 c0                	add    %eax,%eax
    a88a:	01 d0                	add    %edx,%eax
    a88c:	01 c0                	add    %eax,%eax
    a88e:	8d 50 04             	lea    0x4(%eax),%edx
    a891:	8b 45 18             	mov    0x18(%ebp),%eax
    a894:	01 d0                	add    %edx,%eax
    a896:	0f b6 00             	movzbl (%eax),%eax
    a899:	0f b6 c0             	movzbl %al,%eax
    a89c:	c1 e0 08             	shl    $0x8,%eax
    a89f:	89 c1                	mov    %eax,%ecx
    a8a1:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8a4:	89 d0                	mov    %edx,%eax
    a8a6:	01 c0                	add    %eax,%eax
    a8a8:	01 d0                	add    %edx,%eax
    a8aa:	01 c0                	add    %eax,%eax
    a8ac:	8d 50 05             	lea    0x5(%eax),%edx
    a8af:	8b 45 18             	mov    0x18(%ebp),%eax
    a8b2:	01 d0                	add    %edx,%eax
    a8b4:	0f b6 00             	movzbl (%eax),%eax
    a8b7:	0f b6 c0             	movzbl %al,%eax
    a8ba:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a8bd:	8b 45 20             	mov    0x20(%ebp),%eax
    a8c0:	8b 40 1c             	mov    0x1c(%eax),%eax
    a8c3:	39 c2                	cmp    %eax,%edx
    a8c5:	75 0b                	jne    a8d2 <getPixelColorRGBA8+0x397>
    a8c7:	8b 45 14             	mov    0x14(%ebp),%eax
    a8ca:	c6 00 00             	movb   $0x0,(%eax)
    a8cd:	e9 33 02 00 00       	jmp    ab05 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a8d2:	8b 45 14             	mov    0x14(%ebp),%eax
    a8d5:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a8d8:	e9 28 02 00 00       	jmp    ab05 <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a8dd:	8b 45 20             	mov    0x20(%ebp),%eax
    a8e0:	8b 00                	mov    (%eax),%eax
    a8e2:	83 f8 03             	cmp    $0x3,%eax
    a8e5:	0f 85 ac 00 00 00    	jne    a997 <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    a8eb:	8b 45 20             	mov    0x20(%ebp),%eax
    a8ee:	8b 40 04             	mov    0x4(%eax),%eax
    a8f1:	83 f8 08             	cmp    $0x8,%eax
    a8f4:	75 13                	jne    a909 <getPixelColorRGBA8+0x3ce>
    a8f6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8f9:	8b 45 18             	mov    0x18(%ebp),%eax
    a8fc:	01 d0                	add    %edx,%eax
    a8fe:	0f b6 00             	movzbl (%eax),%eax
    a901:	0f b6 c0             	movzbl %al,%eax
    a904:	89 45 fc             	mov    %eax,-0x4(%ebp)
    a907:	eb 28                	jmp    a931 <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    a909:	8b 45 20             	mov    0x20(%ebp),%eax
    a90c:	8b 50 04             	mov    0x4(%eax),%edx
    a90f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a912:	0f af c2             	imul   %edx,%eax
    a915:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a918:	8b 45 20             	mov    0x20(%ebp),%eax
    a91b:	8b 40 04             	mov    0x4(%eax),%eax
    a91e:	50                   	push   %eax
    a91f:	ff 75 18             	pushl  0x18(%ebp)
    a922:	8d 45 ec             	lea    -0x14(%ebp),%eax
    a925:	50                   	push   %eax
    a926:	e8 55 d8 ff ff       	call   8180 <readBitsFromReversedStream>
    a92b:	83 c4 0c             	add    $0xc,%esp
    a92e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    a931:	8b 45 20             	mov    0x20(%ebp),%eax
    a934:	8b 40 08             	mov    0x8(%eax),%eax
    a937:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a93a:	c1 e2 02             	shl    $0x2,%edx
    a93d:	01 d0                	add    %edx,%eax
    a93f:	0f b6 10             	movzbl (%eax),%edx
    a942:	8b 45 08             	mov    0x8(%ebp),%eax
    a945:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    a947:	8b 45 20             	mov    0x20(%ebp),%eax
    a94a:	8b 40 08             	mov    0x8(%eax),%eax
    a94d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a950:	c1 e2 02             	shl    $0x2,%edx
    a953:	83 c2 01             	add    $0x1,%edx
    a956:	01 d0                	add    %edx,%eax
    a958:	0f b6 10             	movzbl (%eax),%edx
    a95b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a95e:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    a960:	8b 45 20             	mov    0x20(%ebp),%eax
    a963:	8b 40 08             	mov    0x8(%eax),%eax
    a966:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a969:	c1 e2 02             	shl    $0x2,%edx
    a96c:	83 c2 02             	add    $0x2,%edx
    a96f:	01 d0                	add    %edx,%eax
    a971:	0f b6 10             	movzbl (%eax),%edx
    a974:	8b 45 10             	mov    0x10(%ebp),%eax
    a977:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    a979:	8b 45 20             	mov    0x20(%ebp),%eax
    a97c:	8b 40 08             	mov    0x8(%eax),%eax
    a97f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a982:	c1 e2 02             	shl    $0x2,%edx
    a985:	83 c2 03             	add    $0x3,%edx
    a988:	01 d0                	add    %edx,%eax
    a98a:	0f b6 10             	movzbl (%eax),%edx
    a98d:	8b 45 14             	mov    0x14(%ebp),%eax
    a990:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a992:	e9 6e 01 00 00       	jmp    ab05 <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a997:	8b 45 20             	mov    0x20(%ebp),%eax
    a99a:	8b 00                	mov    (%eax),%eax
    a99c:	83 f8 04             	cmp    $0x4,%eax
    a99f:	0f 85 95 00 00 00    	jne    aa3a <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    a9a5:	8b 45 20             	mov    0x20(%ebp),%eax
    a9a8:	8b 40 04             	mov    0x4(%eax),%eax
    a9ab:	83 f8 08             	cmp    $0x8,%eax
    a9ae:	75 44                	jne    a9f4 <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    a9b0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a9b3:	01 c0                	add    %eax,%eax
    a9b5:	89 c2                	mov    %eax,%edx
    a9b7:	8b 45 18             	mov    0x18(%ebp),%eax
    a9ba:	01 d0                	add    %edx,%eax
    a9bc:	0f b6 10             	movzbl (%eax),%edx
    a9bf:	8b 45 10             	mov    0x10(%ebp),%eax
    a9c2:	88 10                	mov    %dl,(%eax)
    a9c4:	8b 45 10             	mov    0x10(%ebp),%eax
    a9c7:	0f b6 10             	movzbl (%eax),%edx
    a9ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9cd:	88 10                	mov    %dl,(%eax)
    a9cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9d2:	0f b6 10             	movzbl (%eax),%edx
    a9d5:	8b 45 08             	mov    0x8(%ebp),%eax
    a9d8:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    a9da:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a9dd:	01 c0                	add    %eax,%eax
    a9df:	8d 50 01             	lea    0x1(%eax),%edx
    a9e2:	8b 45 18             	mov    0x18(%ebp),%eax
    a9e5:	01 d0                	add    %edx,%eax
    a9e7:	0f b6 10             	movzbl (%eax),%edx
    a9ea:	8b 45 14             	mov    0x14(%ebp),%eax
    a9ed:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a9ef:	e9 11 01 00 00       	jmp    ab05 <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    a9f4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a9f7:	c1 e0 02             	shl    $0x2,%eax
    a9fa:	89 c2                	mov    %eax,%edx
    a9fc:	8b 45 18             	mov    0x18(%ebp),%eax
    a9ff:	01 d0                	add    %edx,%eax
    aa01:	0f b6 10             	movzbl (%eax),%edx
    aa04:	8b 45 10             	mov    0x10(%ebp),%eax
    aa07:	88 10                	mov    %dl,(%eax)
    aa09:	8b 45 10             	mov    0x10(%ebp),%eax
    aa0c:	0f b6 10             	movzbl (%eax),%edx
    aa0f:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa12:	88 10                	mov    %dl,(%eax)
    aa14:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa17:	0f b6 10             	movzbl (%eax),%edx
    aa1a:	8b 45 08             	mov    0x8(%ebp),%eax
    aa1d:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    aa1f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa22:	c1 e0 02             	shl    $0x2,%eax
    aa25:	8d 50 02             	lea    0x2(%eax),%edx
    aa28:	8b 45 18             	mov    0x18(%ebp),%eax
    aa2b:	01 d0                	add    %edx,%eax
    aa2d:	0f b6 10             	movzbl (%eax),%edx
    aa30:	8b 45 14             	mov    0x14(%ebp),%eax
    aa33:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aa35:	e9 cb 00 00 00       	jmp    ab05 <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    aa3a:	8b 45 20             	mov    0x20(%ebp),%eax
    aa3d:	8b 00                	mov    (%eax),%eax
    aa3f:	83 f8 06             	cmp    $0x6,%eax
    aa42:	0f 85 bd 00 00 00    	jne    ab05 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    aa48:	8b 45 20             	mov    0x20(%ebp),%eax
    aa4b:	8b 40 04             	mov    0x4(%eax),%eax
    aa4e:	83 f8 08             	cmp    $0x8,%eax
    aa51:	75 59                	jne    aaac <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    aa53:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa56:	c1 e0 02             	shl    $0x2,%eax
    aa59:	89 c2                	mov    %eax,%edx
    aa5b:	8b 45 18             	mov    0x18(%ebp),%eax
    aa5e:	01 d0                	add    %edx,%eax
    aa60:	0f b6 10             	movzbl (%eax),%edx
    aa63:	8b 45 08             	mov    0x8(%ebp),%eax
    aa66:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    aa68:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa6b:	c1 e0 02             	shl    $0x2,%eax
    aa6e:	8d 50 01             	lea    0x1(%eax),%edx
    aa71:	8b 45 18             	mov    0x18(%ebp),%eax
    aa74:	01 d0                	add    %edx,%eax
    aa76:	0f b6 10             	movzbl (%eax),%edx
    aa79:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa7c:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    aa7e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa81:	c1 e0 02             	shl    $0x2,%eax
    aa84:	8d 50 02             	lea    0x2(%eax),%edx
    aa87:	8b 45 18             	mov    0x18(%ebp),%eax
    aa8a:	01 d0                	add    %edx,%eax
    aa8c:	0f b6 10             	movzbl (%eax),%edx
    aa8f:	8b 45 10             	mov    0x10(%ebp),%eax
    aa92:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    aa94:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa97:	c1 e0 02             	shl    $0x2,%eax
    aa9a:	8d 50 03             	lea    0x3(%eax),%edx
    aa9d:	8b 45 18             	mov    0x18(%ebp),%eax
    aaa0:	01 d0                	add    %edx,%eax
    aaa2:	0f b6 10             	movzbl (%eax),%edx
    aaa5:	8b 45 14             	mov    0x14(%ebp),%eax
    aaa8:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aaaa:	eb 59                	jmp    ab05 <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    aaac:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aaaf:	c1 e0 03             	shl    $0x3,%eax
    aab2:	89 c2                	mov    %eax,%edx
    aab4:	8b 45 18             	mov    0x18(%ebp),%eax
    aab7:	01 d0                	add    %edx,%eax
    aab9:	0f b6 10             	movzbl (%eax),%edx
    aabc:	8b 45 08             	mov    0x8(%ebp),%eax
    aabf:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    aac1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aac4:	c1 e0 03             	shl    $0x3,%eax
    aac7:	8d 50 02             	lea    0x2(%eax),%edx
    aaca:	8b 45 18             	mov    0x18(%ebp),%eax
    aacd:	01 d0                	add    %edx,%eax
    aacf:	0f b6 10             	movzbl (%eax),%edx
    aad2:	8b 45 0c             	mov    0xc(%ebp),%eax
    aad5:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    aad7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aada:	c1 e0 03             	shl    $0x3,%eax
    aadd:	8d 50 04             	lea    0x4(%eax),%edx
    aae0:	8b 45 18             	mov    0x18(%ebp),%eax
    aae3:	01 d0                	add    %edx,%eax
    aae5:	0f b6 10             	movzbl (%eax),%edx
    aae8:	8b 45 10             	mov    0x10(%ebp),%eax
    aaeb:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    aaed:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aaf0:	c1 e0 03             	shl    $0x3,%eax
    aaf3:	8d 50 06             	lea    0x6(%eax),%edx
    aaf6:	8b 45 18             	mov    0x18(%ebp),%eax
    aaf9:	01 d0                	add    %edx,%eax
    aafb:	0f b6 10             	movzbl (%eax),%edx
    aafe:	8b 45 14             	mov    0x14(%ebp),%eax
    ab01:	88 10                	mov    %dl,(%eax)
    }
  }
}
    ab03:	eb 00                	jmp    ab05 <getPixelColorRGBA8+0x5ca>
    ab05:	90                   	nop
    ab06:	c9                   	leave  
    ab07:	c3                   	ret    

0000ab08 <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    ab08:	55                   	push   %ebp
    ab09:	89 e5                	mov    %esp,%ebp
    ab0b:	53                   	push   %ebx
    ab0c:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    ab0f:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    ab16:	8b 45 14             	mov    0x14(%ebp),%eax
    ab19:	8b 00                	mov    (%eax),%eax
    ab1b:	85 c0                	test   %eax,%eax
    ab1d:	0f 85 14 02 00 00    	jne    ad37 <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    ab23:	8b 45 14             	mov    0x14(%ebp),%eax
    ab26:	8b 40 04             	mov    0x4(%eax),%eax
    ab29:	83 f8 08             	cmp    $0x8,%eax
    ab2c:	0f 85 a0 00 00 00    	jne    abd2 <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ab32:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ab39:	eb 39                	jmp    ab74 <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    ab3b:	8b 45 08             	mov    0x8(%ebp),%eax
    ab3e:	83 c0 01             	add    $0x1,%eax
    ab41:	8b 55 08             	mov    0x8(%ebp),%edx
    ab44:	83 c2 02             	add    $0x2,%edx
    ab47:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    ab4a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ab4d:	01 d9                	add    %ebx,%ecx
    ab4f:	0f b6 09             	movzbl (%ecx),%ecx
    ab52:	88 0a                	mov    %cl,(%edx)
    ab54:	0f b6 12             	movzbl (%edx),%edx
    ab57:	88 10                	mov    %dl,(%eax)
    ab59:	0f b6 10             	movzbl (%eax),%edx
    ab5c:	8b 45 08             	mov    0x8(%ebp),%eax
    ab5f:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    ab61:	8b 45 08             	mov    0x8(%ebp),%eax
    ab64:	83 c0 03             	add    $0x3,%eax
    ab67:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ab6a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ab6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ab71:	01 45 08             	add    %eax,0x8(%ebp)
    ab74:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ab77:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ab7a:	75 bf                	jne    ab3b <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    ab7c:	8b 45 14             	mov    0x14(%ebp),%eax
    ab7f:	8b 40 10             	mov    0x10(%eax),%eax
    ab82:	85 c0                	test   %eax,%eax
    ab84:	0f 84 48 06 00 00    	je     b1d2 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    ab8a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab8d:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    ab91:	f7 d8                	neg    %eax
    ab93:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ab96:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ab9d:	eb 26                	jmp    abc5 <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    ab9f:	8b 45 08             	mov    0x8(%ebp),%eax
    aba2:	0f b6 00             	movzbl (%eax),%eax
    aba5:	0f b6 d0             	movzbl %al,%edx
    aba8:	8b 45 14             	mov    0x14(%ebp),%eax
    abab:	8b 40 14             	mov    0x14(%eax),%eax
    abae:	39 c2                	cmp    %eax,%edx
    abb0:	75 09                	jne    abbb <getPixelColorsRGBA8+0xb3>
    abb2:	8b 45 08             	mov    0x8(%ebp),%eax
    abb5:	83 c0 03             	add    $0x3,%eax
    abb8:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    abbb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    abbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    abc2:	01 45 08             	add    %eax,0x8(%ebp)
    abc5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    abc8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    abcb:	75 d2                	jne    ab9f <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    abcd:	e9 00 06 00 00       	jmp    b1d2 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    abd2:	8b 45 14             	mov    0x14(%ebp),%eax
    abd5:	8b 40 04             	mov    0x4(%eax),%eax
    abd8:	83 f8 10             	cmp    $0x10,%eax
    abdb:	0f 85 a5 00 00 00    	jne    ac86 <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    abe1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    abe8:	e9 88 00 00 00       	jmp    ac75 <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    abed:	8b 45 08             	mov    0x8(%ebp),%eax
    abf0:	83 c0 01             	add    $0x1,%eax
    abf3:	8b 55 08             	mov    0x8(%ebp),%edx
    abf6:	83 c2 02             	add    $0x2,%edx
    abf9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    abfc:	01 c9                	add    %ecx,%ecx
    abfe:	89 cb                	mov    %ecx,%ebx
    ac00:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ac03:	01 d9                	add    %ebx,%ecx
    ac05:	0f b6 09             	movzbl (%ecx),%ecx
    ac08:	88 0a                	mov    %cl,(%edx)
    ac0a:	0f b6 12             	movzbl (%edx),%edx
    ac0d:	88 10                	mov    %dl,(%eax)
    ac0f:	0f b6 10             	movzbl (%eax),%edx
    ac12:	8b 45 08             	mov    0x8(%ebp),%eax
    ac15:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    ac17:	8b 45 08             	mov    0x8(%ebp),%eax
    ac1a:	8d 50 03             	lea    0x3(%eax),%edx
    ac1d:	8b 45 14             	mov    0x14(%ebp),%eax
    ac20:	8b 40 10             	mov    0x10(%eax),%eax
    ac23:	85 c0                	test   %eax,%eax
    ac25:	74 3d                	je     ac64 <getPixelColorsRGBA8+0x15c>
    ac27:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac2a:	01 c0                	add    %eax,%eax
    ac2c:	89 c1                	mov    %eax,%ecx
    ac2e:	8b 45 10             	mov    0x10(%ebp),%eax
    ac31:	01 c8                	add    %ecx,%eax
    ac33:	0f b6 00             	movzbl (%eax),%eax
    ac36:	0f b6 c0             	movzbl %al,%eax
    ac39:	c1 e0 08             	shl    $0x8,%eax
    ac3c:	89 c1                	mov    %eax,%ecx
    ac3e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac41:	01 c0                	add    %eax,%eax
    ac43:	8d 58 01             	lea    0x1(%eax),%ebx
    ac46:	8b 45 10             	mov    0x10(%ebp),%eax
    ac49:	01 d8                	add    %ebx,%eax
    ac4b:	0f b6 00             	movzbl (%eax),%eax
    ac4e:	0f b6 c0             	movzbl %al,%eax
    ac51:	01 c1                	add    %eax,%ecx
    ac53:	8b 45 14             	mov    0x14(%ebp),%eax
    ac56:	8b 40 14             	mov    0x14(%eax),%eax
    ac59:	39 c1                	cmp    %eax,%ecx
    ac5b:	75 07                	jne    ac64 <getPixelColorsRGBA8+0x15c>
    ac5d:	b8 00 00 00 00       	mov    $0x0,%eax
    ac62:	eb 05                	jmp    ac69 <getPixelColorsRGBA8+0x161>
    ac64:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    ac69:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac6b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ac6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ac72:	01 45 08             	add    %eax,0x8(%ebp)
    ac75:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac78:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ac7b:	0f 85 6c ff ff ff    	jne    abed <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ac81:	e9 4c 05 00 00       	jmp    b1d2 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    ac86:	8b 45 14             	mov    0x14(%ebp),%eax
    ac89:	8b 40 04             	mov    0x4(%eax),%eax
    ac8c:	ba 01 00 00 00       	mov    $0x1,%edx
    ac91:	89 c1                	mov    %eax,%ecx
    ac93:	d3 e2                	shl    %cl,%edx
    ac95:	89 d0                	mov    %edx,%eax
    ac97:	83 e8 01             	sub    $0x1,%eax
    ac9a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    ac9d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aca4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    acab:	eb 79                	jmp    ad26 <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    acad:	8b 45 14             	mov    0x14(%ebp),%eax
    acb0:	8b 40 04             	mov    0x4(%eax),%eax
    acb3:	50                   	push   %eax
    acb4:	ff 75 10             	pushl  0x10(%ebp)
    acb7:	8d 45 e0             	lea    -0x20(%ebp),%eax
    acba:	50                   	push   %eax
    acbb:	e8 c0 d4 ff ff       	call   8180 <readBitsFromReversedStream>
    acc0:	83 c4 0c             	add    $0xc,%esp
    acc3:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    acc6:	8b 45 08             	mov    0x8(%ebp),%eax
    acc9:	8d 48 01             	lea    0x1(%eax),%ecx
    accc:	8b 45 08             	mov    0x8(%ebp),%eax
    accf:	8d 58 02             	lea    0x2(%eax),%ebx
    acd2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    acd5:	89 d0                	mov    %edx,%eax
    acd7:	c1 e0 08             	shl    $0x8,%eax
    acda:	29 d0                	sub    %edx,%eax
    acdc:	ba 00 00 00 00       	mov    $0x0,%edx
    ace1:	f7 75 f0             	divl   -0x10(%ebp)
    ace4:	88 03                	mov    %al,(%ebx)
    ace6:	0f b6 03             	movzbl (%ebx),%eax
    ace9:	88 01                	mov    %al,(%ecx)
    aceb:	0f b6 11             	movzbl (%ecx),%edx
    acee:	8b 45 08             	mov    0x8(%ebp),%eax
    acf1:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    acf3:	8b 45 08             	mov    0x8(%ebp),%eax
    acf6:	8d 50 03             	lea    0x3(%eax),%edx
    acf9:	8b 45 14             	mov    0x14(%ebp),%eax
    acfc:	8b 40 10             	mov    0x10(%eax),%eax
    acff:	85 c0                	test   %eax,%eax
    ad01:	74 12                	je     ad15 <getPixelColorsRGBA8+0x20d>
    ad03:	8b 45 14             	mov    0x14(%ebp),%eax
    ad06:	8b 40 14             	mov    0x14(%eax),%eax
    ad09:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    ad0c:	75 07                	jne    ad15 <getPixelColorsRGBA8+0x20d>
    ad0e:	b8 00 00 00 00       	mov    $0x0,%eax
    ad13:	eb 05                	jmp    ad1a <getPixelColorsRGBA8+0x212>
    ad15:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    ad1a:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad1c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ad20:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ad23:	01 45 08             	add    %eax,0x8(%ebp)
    ad26:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad29:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ad2c:	0f 85 7b ff ff ff    	jne    acad <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ad32:	e9 9b 04 00 00       	jmp    b1d2 <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    ad37:	8b 45 14             	mov    0x14(%ebp),%eax
    ad3a:	8b 00                	mov    (%eax),%eax
    ad3c:	83 f8 02             	cmp    $0x2,%eax
    ad3f:	0f 85 41 02 00 00    	jne    af86 <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    ad45:	8b 45 14             	mov    0x14(%ebp),%eax
    ad48:	8b 40 04             	mov    0x4(%eax),%eax
    ad4b:	83 f8 08             	cmp    $0x8,%eax
    ad4e:	0f 85 c4 00 00 00    	jne    ae18 <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad54:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ad5b:	eb 31                	jmp    ad8e <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    ad5d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ad60:	89 d0                	mov    %edx,%eax
    ad62:	01 c0                	add    %eax,%eax
    ad64:	01 d0                	add    %edx,%eax
    ad66:	89 c2                	mov    %eax,%edx
    ad68:	8b 45 10             	mov    0x10(%ebp),%eax
    ad6b:	01 d0                	add    %edx,%eax
    ad6d:	6a 03                	push   $0x3
    ad6f:	50                   	push   %eax
    ad70:	ff 75 08             	pushl  0x8(%ebp)
    ad73:	e8 a3 85 ff ff       	call   331b <lodepng_memcpy>
    ad78:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    ad7b:	8b 45 08             	mov    0x8(%ebp),%eax
    ad7e:	83 c0 03             	add    $0x3,%eax
    ad81:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad84:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ad88:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ad8b:	01 45 08             	add    %eax,0x8(%ebp)
    ad8e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad91:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ad94:	75 c7                	jne    ad5d <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    ad96:	8b 45 14             	mov    0x14(%ebp),%eax
    ad99:	8b 40 10             	mov    0x10(%eax),%eax
    ad9c:	85 c0                	test   %eax,%eax
    ad9e:	0f 84 2e 04 00 00    	je     b1d2 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    ada4:	8b 45 0c             	mov    0xc(%ebp),%eax
    ada7:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    adab:	f7 d8                	neg    %eax
    adad:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    adb0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    adb7:	eb 52                	jmp    ae0b <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    adb9:	8b 45 08             	mov    0x8(%ebp),%eax
    adbc:	0f b6 00             	movzbl (%eax),%eax
    adbf:	0f b6 d0             	movzbl %al,%edx
    adc2:	8b 45 14             	mov    0x14(%ebp),%eax
    adc5:	8b 40 14             	mov    0x14(%eax),%eax
    adc8:	39 c2                	cmp    %eax,%edx
    adca:	75 35                	jne    ae01 <getPixelColorsRGBA8+0x2f9>
    adcc:	8b 45 08             	mov    0x8(%ebp),%eax
    adcf:	83 c0 01             	add    $0x1,%eax
    add2:	0f b6 00             	movzbl (%eax),%eax
    add5:	0f b6 d0             	movzbl %al,%edx
    add8:	8b 45 14             	mov    0x14(%ebp),%eax
    addb:	8b 40 18             	mov    0x18(%eax),%eax
    adde:	39 c2                	cmp    %eax,%edx
    ade0:	75 1f                	jne    ae01 <getPixelColorsRGBA8+0x2f9>
    ade2:	8b 45 08             	mov    0x8(%ebp),%eax
    ade5:	83 c0 02             	add    $0x2,%eax
    ade8:	0f b6 00             	movzbl (%eax),%eax
    adeb:	0f b6 d0             	movzbl %al,%edx
    adee:	8b 45 14             	mov    0x14(%ebp),%eax
    adf1:	8b 40 1c             	mov    0x1c(%eax),%eax
    adf4:	39 c2                	cmp    %eax,%edx
    adf6:	75 09                	jne    ae01 <getPixelColorsRGBA8+0x2f9>
    adf8:	8b 45 08             	mov    0x8(%ebp),%eax
    adfb:	83 c0 03             	add    $0x3,%eax
    adfe:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae01:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ae05:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ae08:	01 45 08             	add    %eax,0x8(%ebp)
    ae0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae0e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ae11:	75 a6                	jne    adb9 <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ae13:	e9 ba 03 00 00       	jmp    b1d2 <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae18:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae1f:	e9 51 01 00 00       	jmp    af75 <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    ae24:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae27:	89 d0                	mov    %edx,%eax
    ae29:	01 c0                	add    %eax,%eax
    ae2b:	01 d0                	add    %edx,%eax
    ae2d:	01 c0                	add    %eax,%eax
    ae2f:	89 c2                	mov    %eax,%edx
    ae31:	8b 45 10             	mov    0x10(%ebp),%eax
    ae34:	01 d0                	add    %edx,%eax
    ae36:	0f b6 10             	movzbl (%eax),%edx
    ae39:	8b 45 08             	mov    0x8(%ebp),%eax
    ae3c:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    ae3e:	8b 45 08             	mov    0x8(%ebp),%eax
    ae41:	8d 48 01             	lea    0x1(%eax),%ecx
    ae44:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae47:	89 d0                	mov    %edx,%eax
    ae49:	01 c0                	add    %eax,%eax
    ae4b:	01 d0                	add    %edx,%eax
    ae4d:	01 c0                	add    %eax,%eax
    ae4f:	8d 50 02             	lea    0x2(%eax),%edx
    ae52:	8b 45 10             	mov    0x10(%ebp),%eax
    ae55:	01 d0                	add    %edx,%eax
    ae57:	0f b6 00             	movzbl (%eax),%eax
    ae5a:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    ae5c:	8b 45 08             	mov    0x8(%ebp),%eax
    ae5f:	8d 48 02             	lea    0x2(%eax),%ecx
    ae62:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae65:	89 d0                	mov    %edx,%eax
    ae67:	01 c0                	add    %eax,%eax
    ae69:	01 d0                	add    %edx,%eax
    ae6b:	01 c0                	add    %eax,%eax
    ae6d:	8d 50 04             	lea    0x4(%eax),%edx
    ae70:	8b 45 10             	mov    0x10(%ebp),%eax
    ae73:	01 d0                	add    %edx,%eax
    ae75:	0f b6 00             	movzbl (%eax),%eax
    ae78:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    ae7a:	8b 45 08             	mov    0x8(%ebp),%eax
    ae7d:	8d 48 03             	lea    0x3(%eax),%ecx
    ae80:	8b 45 14             	mov    0x14(%ebp),%eax
    ae83:	8b 40 10             	mov    0x10(%eax),%eax
    ae86:	85 c0                	test   %eax,%eax
    ae88:	0f 84 d6 00 00 00    	je     af64 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    ae8e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae91:	89 d0                	mov    %edx,%eax
    ae93:	01 c0                	add    %eax,%eax
    ae95:	01 d0                	add    %edx,%eax
    ae97:	01 c0                	add    %eax,%eax
    ae99:	89 c2                	mov    %eax,%edx
    ae9b:	8b 45 10             	mov    0x10(%ebp),%eax
    ae9e:	01 d0                	add    %edx,%eax
    aea0:	0f b6 00             	movzbl (%eax),%eax
    aea3:	0f b6 c0             	movzbl %al,%eax
    aea6:	c1 e0 08             	shl    $0x8,%eax
    aea9:	89 c3                	mov    %eax,%ebx
    aeab:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aeae:	89 d0                	mov    %edx,%eax
    aeb0:	01 c0                	add    %eax,%eax
    aeb2:	01 d0                	add    %edx,%eax
    aeb4:	01 c0                	add    %eax,%eax
    aeb6:	8d 50 01             	lea    0x1(%eax),%edx
    aeb9:	8b 45 10             	mov    0x10(%ebp),%eax
    aebc:	01 d0                	add    %edx,%eax
    aebe:	0f b6 00             	movzbl (%eax),%eax
    aec1:	0f b6 c0             	movzbl %al,%eax
    aec4:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    aec7:	8b 45 14             	mov    0x14(%ebp),%eax
    aeca:	8b 40 14             	mov    0x14(%eax),%eax
    aecd:	39 c2                	cmp    %eax,%edx
    aecf:	0f 85 8f 00 00 00    	jne    af64 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    aed5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aed8:	89 d0                	mov    %edx,%eax
    aeda:	01 c0                	add    %eax,%eax
    aedc:	01 d0                	add    %edx,%eax
    aede:	01 c0                	add    %eax,%eax
    aee0:	8d 50 02             	lea    0x2(%eax),%edx
    aee3:	8b 45 10             	mov    0x10(%ebp),%eax
    aee6:	01 d0                	add    %edx,%eax
    aee8:	0f b6 00             	movzbl (%eax),%eax
    aeeb:	0f b6 c0             	movzbl %al,%eax
    aeee:	c1 e0 08             	shl    $0x8,%eax
    aef1:	89 c3                	mov    %eax,%ebx
    aef3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aef6:	89 d0                	mov    %edx,%eax
    aef8:	01 c0                	add    %eax,%eax
    aefa:	01 d0                	add    %edx,%eax
    aefc:	01 c0                	add    %eax,%eax
    aefe:	8d 50 03             	lea    0x3(%eax),%edx
    af01:	8b 45 10             	mov    0x10(%ebp),%eax
    af04:	01 d0                	add    %edx,%eax
    af06:	0f b6 00             	movzbl (%eax),%eax
    af09:	0f b6 c0             	movzbl %al,%eax
    af0c:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    af0f:	8b 45 14             	mov    0x14(%ebp),%eax
    af12:	8b 40 18             	mov    0x18(%eax),%eax
    af15:	39 c2                	cmp    %eax,%edx
    af17:	75 4b                	jne    af64 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    af19:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af1c:	89 d0                	mov    %edx,%eax
    af1e:	01 c0                	add    %eax,%eax
    af20:	01 d0                	add    %edx,%eax
    af22:	01 c0                	add    %eax,%eax
    af24:	8d 50 04             	lea    0x4(%eax),%edx
    af27:	8b 45 10             	mov    0x10(%ebp),%eax
    af2a:	01 d0                	add    %edx,%eax
    af2c:	0f b6 00             	movzbl (%eax),%eax
    af2f:	0f b6 c0             	movzbl %al,%eax
    af32:	c1 e0 08             	shl    $0x8,%eax
    af35:	89 c3                	mov    %eax,%ebx
    af37:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af3a:	89 d0                	mov    %edx,%eax
    af3c:	01 c0                	add    %eax,%eax
    af3e:	01 d0                	add    %edx,%eax
    af40:	01 c0                	add    %eax,%eax
    af42:	8d 50 05             	lea    0x5(%eax),%edx
    af45:	8b 45 10             	mov    0x10(%ebp),%eax
    af48:	01 d0                	add    %edx,%eax
    af4a:	0f b6 00             	movzbl (%eax),%eax
    af4d:	0f b6 c0             	movzbl %al,%eax
    af50:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    af53:	8b 45 14             	mov    0x14(%ebp),%eax
    af56:	8b 40 1c             	mov    0x1c(%eax),%eax
    af59:	39 c2                	cmp    %eax,%edx
    af5b:	75 07                	jne    af64 <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    af5d:	b8 00 00 00 00       	mov    $0x0,%eax
    af62:	eb 05                	jmp    af69 <getPixelColorsRGBA8+0x461>
    af64:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    af69:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    af6b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    af6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    af72:	01 45 08             	add    %eax,0x8(%ebp)
    af75:	8b 45 f8             	mov    -0x8(%ebp),%eax
    af78:	3b 45 0c             	cmp    0xc(%ebp),%eax
    af7b:	0f 85 a3 fe ff ff    	jne    ae24 <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    af81:	e9 4c 02 00 00       	jmp    b1d2 <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    af86:	8b 45 14             	mov    0x14(%ebp),%eax
    af89:	8b 00                	mov    (%eax),%eax
    af8b:	83 f8 03             	cmp    $0x3,%eax
    af8e:	0f 85 b4 00 00 00    	jne    b048 <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    af94:	8b 45 14             	mov    0x14(%ebp),%eax
    af97:	8b 40 04             	mov    0x4(%eax),%eax
    af9a:	83 f8 08             	cmp    $0x8,%eax
    af9d:	75 4d                	jne    afec <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    af9f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    afa6:	eb 37                	jmp    afdf <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    afa8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    afab:	8b 45 10             	mov    0x10(%ebp),%eax
    afae:	01 d0                	add    %edx,%eax
    afb0:	0f b6 00             	movzbl (%eax),%eax
    afb3:	0f b6 c0             	movzbl %al,%eax
    afb6:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    afb9:	8b 45 14             	mov    0x14(%ebp),%eax
    afbc:	8b 40 08             	mov    0x8(%eax),%eax
    afbf:	8b 55 e8             	mov    -0x18(%ebp),%edx
    afc2:	c1 e2 02             	shl    $0x2,%edx
    afc5:	01 d0                	add    %edx,%eax
    afc7:	6a 04                	push   $0x4
    afc9:	50                   	push   %eax
    afca:	ff 75 08             	pushl  0x8(%ebp)
    afcd:	e8 49 83 ff ff       	call   331b <lodepng_memcpy>
    afd2:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    afd5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    afd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    afdc:	01 45 08             	add    %eax,0x8(%ebp)
    afdf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    afe2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    afe5:	75 c1                	jne    afa8 <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    afe7:	e9 e6 01 00 00       	jmp    b1d2 <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    afec:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aff3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    affa:	eb 3f                	jmp    b03b <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    affc:	8b 45 14             	mov    0x14(%ebp),%eax
    afff:	8b 40 04             	mov    0x4(%eax),%eax
    b002:	50                   	push   %eax
    b003:	ff 75 10             	pushl  0x10(%ebp)
    b006:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b009:	50                   	push   %eax
    b00a:	e8 71 d1 ff ff       	call   8180 <readBitsFromReversedStream>
    b00f:	83 c4 0c             	add    $0xc,%esp
    b012:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b015:	8b 45 14             	mov    0x14(%ebp),%eax
    b018:	8b 40 08             	mov    0x8(%eax),%eax
    b01b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b01e:	c1 e2 02             	shl    $0x2,%edx
    b021:	01 d0                	add    %edx,%eax
    b023:	6a 04                	push   $0x4
    b025:	50                   	push   %eax
    b026:	ff 75 08             	pushl  0x8(%ebp)
    b029:	e8 ed 82 ff ff       	call   331b <lodepng_memcpy>
    b02e:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b031:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b035:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b038:	01 45 08             	add    %eax,0x8(%ebp)
    b03b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b03e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b041:	75 b9                	jne    affc <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b043:	e9 8a 01 00 00       	jmp    b1d2 <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b048:	8b 45 14             	mov    0x14(%ebp),%eax
    b04b:	8b 00                	mov    (%eax),%eax
    b04d:	83 f8 04             	cmp    $0x4,%eax
    b050:	0f 85 d1 00 00 00    	jne    b127 <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    b056:	8b 45 14             	mov    0x14(%ebp),%eax
    b059:	8b 40 04             	mov    0x4(%eax),%eax
    b05c:	83 f8 08             	cmp    $0x8,%eax
    b05f:	75 62                	jne    b0c3 <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b061:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b068:	eb 4c                	jmp    b0b6 <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b06a:	8b 45 08             	mov    0x8(%ebp),%eax
    b06d:	83 c0 01             	add    $0x1,%eax
    b070:	8b 55 08             	mov    0x8(%ebp),%edx
    b073:	83 c2 02             	add    $0x2,%edx
    b076:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b079:	01 c9                	add    %ecx,%ecx
    b07b:	89 cb                	mov    %ecx,%ebx
    b07d:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b080:	01 d9                	add    %ebx,%ecx
    b082:	0f b6 09             	movzbl (%ecx),%ecx
    b085:	88 0a                	mov    %cl,(%edx)
    b087:	0f b6 12             	movzbl (%edx),%edx
    b08a:	88 10                	mov    %dl,(%eax)
    b08c:	0f b6 10             	movzbl (%eax),%edx
    b08f:	8b 45 08             	mov    0x8(%ebp),%eax
    b092:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    b094:	8b 45 08             	mov    0x8(%ebp),%eax
    b097:	8d 50 03             	lea    0x3(%eax),%edx
    b09a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b09d:	01 c0                	add    %eax,%eax
    b09f:	8d 48 01             	lea    0x1(%eax),%ecx
    b0a2:	8b 45 10             	mov    0x10(%ebp),%eax
    b0a5:	01 c8                	add    %ecx,%eax
    b0a7:	0f b6 00             	movzbl (%eax),%eax
    b0aa:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0ac:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b0b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b0b3:	01 45 08             	add    %eax,0x8(%ebp)
    b0b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b0b9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b0bc:	75 ac                	jne    b06a <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b0be:	e9 0f 01 00 00       	jmp    b1d2 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0c3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b0ca:	eb 4e                	jmp    b11a <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b0cc:	8b 45 08             	mov    0x8(%ebp),%eax
    b0cf:	83 c0 01             	add    $0x1,%eax
    b0d2:	8b 55 08             	mov    0x8(%ebp),%edx
    b0d5:	83 c2 02             	add    $0x2,%edx
    b0d8:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b0db:	c1 e1 02             	shl    $0x2,%ecx
    b0de:	89 cb                	mov    %ecx,%ebx
    b0e0:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b0e3:	01 d9                	add    %ebx,%ecx
    b0e5:	0f b6 09             	movzbl (%ecx),%ecx
    b0e8:	88 0a                	mov    %cl,(%edx)
    b0ea:	0f b6 12             	movzbl (%edx),%edx
    b0ed:	88 10                	mov    %dl,(%eax)
    b0ef:	0f b6 10             	movzbl (%eax),%edx
    b0f2:	8b 45 08             	mov    0x8(%ebp),%eax
    b0f5:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    b0f7:	8b 45 08             	mov    0x8(%ebp),%eax
    b0fa:	8d 50 03             	lea    0x3(%eax),%edx
    b0fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b100:	c1 e0 02             	shl    $0x2,%eax
    b103:	8d 48 02             	lea    0x2(%eax),%ecx
    b106:	8b 45 10             	mov    0x10(%ebp),%eax
    b109:	01 c8                	add    %ecx,%eax
    b10b:	0f b6 00             	movzbl (%eax),%eax
    b10e:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b110:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b114:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b117:	01 45 08             	add    %eax,0x8(%ebp)
    b11a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b11d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b120:	75 aa                	jne    b0cc <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b122:	e9 ab 00 00 00       	jmp    b1d2 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b127:	8b 45 14             	mov    0x14(%ebp),%eax
    b12a:	8b 00                	mov    (%eax),%eax
    b12c:	83 f8 06             	cmp    $0x6,%eax
    b12f:	0f 85 9d 00 00 00    	jne    b1d2 <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    b135:	8b 45 14             	mov    0x14(%ebp),%eax
    b138:	8b 40 04             	mov    0x4(%eax),%eax
    b13b:	83 f8 08             	cmp    $0x8,%eax
    b13e:	75 17                	jne    b157 <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    b140:	8b 45 0c             	mov    0xc(%ebp),%eax
    b143:	c1 e0 02             	shl    $0x2,%eax
    b146:	50                   	push   %eax
    b147:	ff 75 10             	pushl  0x10(%ebp)
    b14a:	ff 75 08             	pushl  0x8(%ebp)
    b14d:	e8 c9 81 ff ff       	call   331b <lodepng_memcpy>
    b152:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b155:	eb 7b                	jmp    b1d2 <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b157:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b15e:	eb 6a                	jmp    b1ca <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    b160:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b163:	c1 e0 03             	shl    $0x3,%eax
    b166:	89 c2                	mov    %eax,%edx
    b168:	8b 45 10             	mov    0x10(%ebp),%eax
    b16b:	01 d0                	add    %edx,%eax
    b16d:	0f b6 10             	movzbl (%eax),%edx
    b170:	8b 45 08             	mov    0x8(%ebp),%eax
    b173:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b175:	8b 45 08             	mov    0x8(%ebp),%eax
    b178:	8d 50 01             	lea    0x1(%eax),%edx
    b17b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b17e:	c1 e0 03             	shl    $0x3,%eax
    b181:	8d 48 02             	lea    0x2(%eax),%ecx
    b184:	8b 45 10             	mov    0x10(%ebp),%eax
    b187:	01 c8                	add    %ecx,%eax
    b189:	0f b6 00             	movzbl (%eax),%eax
    b18c:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b18e:	8b 45 08             	mov    0x8(%ebp),%eax
    b191:	8d 50 02             	lea    0x2(%eax),%edx
    b194:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b197:	c1 e0 03             	shl    $0x3,%eax
    b19a:	8d 48 04             	lea    0x4(%eax),%ecx
    b19d:	8b 45 10             	mov    0x10(%ebp),%eax
    b1a0:	01 c8                	add    %ecx,%eax
    b1a2:	0f b6 00             	movzbl (%eax),%eax
    b1a5:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    b1a7:	8b 45 08             	mov    0x8(%ebp),%eax
    b1aa:	8d 50 03             	lea    0x3(%eax),%edx
    b1ad:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1b0:	c1 e0 03             	shl    $0x3,%eax
    b1b3:	8d 48 06             	lea    0x6(%eax),%ecx
    b1b6:	8b 45 10             	mov    0x10(%ebp),%eax
    b1b9:	01 c8                	add    %ecx,%eax
    b1bb:	0f b6 00             	movzbl (%eax),%eax
    b1be:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b1c0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b1c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b1c7:	01 45 08             	add    %eax,0x8(%ebp)
    b1ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1cd:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b1d0:	75 8e                	jne    b160 <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b1d2:	90                   	nop
    b1d3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b1d6:	c9                   	leave  
    b1d7:	c3                   	ret    

0000b1d8 <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    b1d8:	55                   	push   %ebp
    b1d9:	89 e5                	mov    %esp,%ebp
    b1db:	53                   	push   %ebx
    b1dc:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    b1df:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b1e6:	8b 45 14             	mov    0x14(%ebp),%eax
    b1e9:	8b 00                	mov    (%eax),%eax
    b1eb:	85 c0                	test   %eax,%eax
    b1ed:	0f 85 2a 01 00 00    	jne    b31d <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    b1f3:	8b 45 14             	mov    0x14(%ebp),%eax
    b1f6:	8b 40 04             	mov    0x4(%eax),%eax
    b1f9:	83 f8 08             	cmp    $0x8,%eax
    b1fc:	75 46                	jne    b244 <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b1fe:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b205:	eb 30                	jmp    b237 <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b207:	8b 45 08             	mov    0x8(%ebp),%eax
    b20a:	83 c0 01             	add    $0x1,%eax
    b20d:	8b 55 08             	mov    0x8(%ebp),%edx
    b210:	83 c2 02             	add    $0x2,%edx
    b213:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b216:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b219:	01 d9                	add    %ebx,%ecx
    b21b:	0f b6 09             	movzbl (%ecx),%ecx
    b21e:	88 0a                	mov    %cl,(%edx)
    b220:	0f b6 12             	movzbl (%edx),%edx
    b223:	88 10                	mov    %dl,(%eax)
    b225:	0f b6 10             	movzbl (%eax),%edx
    b228:	8b 45 08             	mov    0x8(%ebp),%eax
    b22b:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b22d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b231:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b234:	01 45 08             	add    %eax,0x8(%ebp)
    b237:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b23a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b23d:	75 c8                	jne    b207 <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b23f:	e9 a8 03 00 00       	jmp    b5ec <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    b244:	8b 45 14             	mov    0x14(%ebp),%eax
    b247:	8b 40 04             	mov    0x4(%eax),%eax
    b24a:	83 f8 10             	cmp    $0x10,%eax
    b24d:	75 4a                	jne    b299 <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b24f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b256:	eb 34                	jmp    b28c <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b258:	8b 45 08             	mov    0x8(%ebp),%eax
    b25b:	83 c0 01             	add    $0x1,%eax
    b25e:	8b 55 08             	mov    0x8(%ebp),%edx
    b261:	83 c2 02             	add    $0x2,%edx
    b264:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b267:	01 c9                	add    %ecx,%ecx
    b269:	89 cb                	mov    %ecx,%ebx
    b26b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b26e:	01 d9                	add    %ebx,%ecx
    b270:	0f b6 09             	movzbl (%ecx),%ecx
    b273:	88 0a                	mov    %cl,(%edx)
    b275:	0f b6 12             	movzbl (%edx),%edx
    b278:	88 10                	mov    %dl,(%eax)
    b27a:	0f b6 10             	movzbl (%eax),%edx
    b27d:	8b 45 08             	mov    0x8(%ebp),%eax
    b280:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b282:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b286:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b289:	01 45 08             	add    %eax,0x8(%ebp)
    b28c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b28f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b292:	75 c4                	jne    b258 <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b294:	e9 53 03 00 00       	jmp    b5ec <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b299:	8b 45 14             	mov    0x14(%ebp),%eax
    b29c:	8b 40 04             	mov    0x4(%eax),%eax
    b29f:	ba 01 00 00 00       	mov    $0x1,%edx
    b2a4:	89 c1                	mov    %eax,%ecx
    b2a6:	d3 e2                	shl    %cl,%edx
    b2a8:	89 d0                	mov    %edx,%eax
    b2aa:	83 e8 01             	sub    $0x1,%eax
    b2ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b2b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2b7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b2be:	eb 50                	jmp    b310 <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b2c0:	8b 45 14             	mov    0x14(%ebp),%eax
    b2c3:	8b 40 04             	mov    0x4(%eax),%eax
    b2c6:	50                   	push   %eax
    b2c7:	ff 75 10             	pushl  0x10(%ebp)
    b2ca:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b2cd:	50                   	push   %eax
    b2ce:	e8 ad ce ff ff       	call   8180 <readBitsFromReversedStream>
    b2d3:	83 c4 0c             	add    $0xc,%esp
    b2d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b2d9:	8b 45 08             	mov    0x8(%ebp),%eax
    b2dc:	8d 48 01             	lea    0x1(%eax),%ecx
    b2df:	8b 45 08             	mov    0x8(%ebp),%eax
    b2e2:	8d 58 02             	lea    0x2(%eax),%ebx
    b2e5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b2e8:	89 d0                	mov    %edx,%eax
    b2ea:	c1 e0 08             	shl    $0x8,%eax
    b2ed:	29 d0                	sub    %edx,%eax
    b2ef:	ba 00 00 00 00       	mov    $0x0,%edx
    b2f4:	f7 75 f0             	divl   -0x10(%ebp)
    b2f7:	88 03                	mov    %al,(%ebx)
    b2f9:	0f b6 03             	movzbl (%ebx),%eax
    b2fc:	88 01                	mov    %al,(%ecx)
    b2fe:	0f b6 11             	movzbl (%ecx),%edx
    b301:	8b 45 08             	mov    0x8(%ebp),%eax
    b304:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b306:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b30a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b30d:	01 45 08             	add    %eax,0x8(%ebp)
    b310:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b313:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b316:	75 a8                	jne    b2c0 <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b318:	e9 cf 02 00 00       	jmp    b5ec <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b31d:	8b 45 14             	mov    0x14(%ebp),%eax
    b320:	8b 00                	mov    (%eax),%eax
    b322:	83 f8 02             	cmp    $0x2,%eax
    b325:	0f 85 9e 00 00 00    	jne    b3c9 <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    b32b:	8b 45 14             	mov    0x14(%ebp),%eax
    b32e:	8b 40 04             	mov    0x4(%eax),%eax
    b331:	83 f8 08             	cmp    $0x8,%eax
    b334:	75 1d                	jne    b353 <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    b336:	8b 55 0c             	mov    0xc(%ebp),%edx
    b339:	89 d0                	mov    %edx,%eax
    b33b:	01 c0                	add    %eax,%eax
    b33d:	01 d0                	add    %edx,%eax
    b33f:	50                   	push   %eax
    b340:	ff 75 10             	pushl  0x10(%ebp)
    b343:	ff 75 08             	pushl  0x8(%ebp)
    b346:	e8 d0 7f ff ff       	call   331b <lodepng_memcpy>
    b34b:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b34e:	e9 99 02 00 00       	jmp    b5ec <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b353:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b35a:	eb 60                	jmp    b3bc <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    b35c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b35f:	89 d0                	mov    %edx,%eax
    b361:	01 c0                	add    %eax,%eax
    b363:	01 d0                	add    %edx,%eax
    b365:	01 c0                	add    %eax,%eax
    b367:	89 c2                	mov    %eax,%edx
    b369:	8b 45 10             	mov    0x10(%ebp),%eax
    b36c:	01 d0                	add    %edx,%eax
    b36e:	0f b6 10             	movzbl (%eax),%edx
    b371:	8b 45 08             	mov    0x8(%ebp),%eax
    b374:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b376:	8b 45 08             	mov    0x8(%ebp),%eax
    b379:	8d 48 01             	lea    0x1(%eax),%ecx
    b37c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b37f:	89 d0                	mov    %edx,%eax
    b381:	01 c0                	add    %eax,%eax
    b383:	01 d0                	add    %edx,%eax
    b385:	01 c0                	add    %eax,%eax
    b387:	8d 50 02             	lea    0x2(%eax),%edx
    b38a:	8b 45 10             	mov    0x10(%ebp),%eax
    b38d:	01 d0                	add    %edx,%eax
    b38f:	0f b6 00             	movzbl (%eax),%eax
    b392:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b394:	8b 45 08             	mov    0x8(%ebp),%eax
    b397:	8d 48 02             	lea    0x2(%eax),%ecx
    b39a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b39d:	89 d0                	mov    %edx,%eax
    b39f:	01 c0                	add    %eax,%eax
    b3a1:	01 d0                	add    %edx,%eax
    b3a3:	01 c0                	add    %eax,%eax
    b3a5:	8d 50 04             	lea    0x4(%eax),%edx
    b3a8:	8b 45 10             	mov    0x10(%ebp),%eax
    b3ab:	01 d0                	add    %edx,%eax
    b3ad:	0f b6 00             	movzbl (%eax),%eax
    b3b0:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3b2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b3b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3b9:	01 45 08             	add    %eax,0x8(%ebp)
    b3bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b3bf:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b3c2:	75 98                	jne    b35c <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b3c4:	e9 23 02 00 00       	jmp    b5ec <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b3c9:	8b 45 14             	mov    0x14(%ebp),%eax
    b3cc:	8b 00                	mov    (%eax),%eax
    b3ce:	83 f8 03             	cmp    $0x3,%eax
    b3d1:	0f 85 b4 00 00 00    	jne    b48b <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    b3d7:	8b 45 14             	mov    0x14(%ebp),%eax
    b3da:	8b 40 04             	mov    0x4(%eax),%eax
    b3dd:	83 f8 08             	cmp    $0x8,%eax
    b3e0:	75 4d                	jne    b42f <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3e2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b3e9:	eb 37                	jmp    b422 <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    b3eb:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3ee:	8b 45 10             	mov    0x10(%ebp),%eax
    b3f1:	01 d0                	add    %edx,%eax
    b3f3:	0f b6 00             	movzbl (%eax),%eax
    b3f6:	0f b6 c0             	movzbl %al,%eax
    b3f9:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b3fc:	8b 45 14             	mov    0x14(%ebp),%eax
    b3ff:	8b 40 08             	mov    0x8(%eax),%eax
    b402:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b405:	c1 e2 02             	shl    $0x2,%edx
    b408:	01 d0                	add    %edx,%eax
    b40a:	6a 03                	push   $0x3
    b40c:	50                   	push   %eax
    b40d:	ff 75 08             	pushl  0x8(%ebp)
    b410:	e8 06 7f ff ff       	call   331b <lodepng_memcpy>
    b415:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b418:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b41c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b41f:	01 45 08             	add    %eax,0x8(%ebp)
    b422:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b425:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b428:	75 c1                	jne    b3eb <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b42a:	e9 bd 01 00 00       	jmp    b5ec <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    b42f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b436:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b43d:	eb 3f                	jmp    b47e <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b43f:	8b 45 14             	mov    0x14(%ebp),%eax
    b442:	8b 40 04             	mov    0x4(%eax),%eax
    b445:	50                   	push   %eax
    b446:	ff 75 10             	pushl  0x10(%ebp)
    b449:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b44c:	50                   	push   %eax
    b44d:	e8 2e cd ff ff       	call   8180 <readBitsFromReversedStream>
    b452:	83 c4 0c             	add    $0xc,%esp
    b455:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b458:	8b 45 14             	mov    0x14(%ebp),%eax
    b45b:	8b 40 08             	mov    0x8(%eax),%eax
    b45e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b461:	c1 e2 02             	shl    $0x2,%edx
    b464:	01 d0                	add    %edx,%eax
    b466:	6a 03                	push   $0x3
    b468:	50                   	push   %eax
    b469:	ff 75 08             	pushl  0x8(%ebp)
    b46c:	e8 aa 7e ff ff       	call   331b <lodepng_memcpy>
    b471:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b474:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b478:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b47b:	01 45 08             	add    %eax,0x8(%ebp)
    b47e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b481:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b484:	75 b9                	jne    b43f <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b486:	e9 61 01 00 00       	jmp    b5ec <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b48b:	8b 45 14             	mov    0x14(%ebp),%eax
    b48e:	8b 00                	mov    (%eax),%eax
    b490:	83 f8 04             	cmp    $0x4,%eax
    b493:	0f 85 a0 00 00 00    	jne    b539 <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    b499:	8b 45 14             	mov    0x14(%ebp),%eax
    b49c:	8b 40 04             	mov    0x4(%eax),%eax
    b49f:	83 f8 08             	cmp    $0x8,%eax
    b4a2:	75 4a                	jne    b4ee <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4a4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b4ab:	eb 34                	jmp    b4e1 <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b4ad:	8b 45 08             	mov    0x8(%ebp),%eax
    b4b0:	83 c0 01             	add    $0x1,%eax
    b4b3:	8b 55 08             	mov    0x8(%ebp),%edx
    b4b6:	83 c2 02             	add    $0x2,%edx
    b4b9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b4bc:	01 c9                	add    %ecx,%ecx
    b4be:	89 cb                	mov    %ecx,%ebx
    b4c0:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b4c3:	01 d9                	add    %ebx,%ecx
    b4c5:	0f b6 09             	movzbl (%ecx),%ecx
    b4c8:	88 0a                	mov    %cl,(%edx)
    b4ca:	0f b6 12             	movzbl (%edx),%edx
    b4cd:	88 10                	mov    %dl,(%eax)
    b4cf:	0f b6 10             	movzbl (%eax),%edx
    b4d2:	8b 45 08             	mov    0x8(%ebp),%eax
    b4d5:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4d7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b4db:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b4de:	01 45 08             	add    %eax,0x8(%ebp)
    b4e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4e4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b4e7:	75 c4                	jne    b4ad <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b4e9:	e9 fe 00 00 00       	jmp    b5ec <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4ee:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b4f5:	eb 35                	jmp    b52c <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b4f7:	8b 45 08             	mov    0x8(%ebp),%eax
    b4fa:	83 c0 01             	add    $0x1,%eax
    b4fd:	8b 55 08             	mov    0x8(%ebp),%edx
    b500:	83 c2 02             	add    $0x2,%edx
    b503:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b506:	c1 e1 02             	shl    $0x2,%ecx
    b509:	89 cb                	mov    %ecx,%ebx
    b50b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b50e:	01 d9                	add    %ebx,%ecx
    b510:	0f b6 09             	movzbl (%ecx),%ecx
    b513:	88 0a                	mov    %cl,(%edx)
    b515:	0f b6 12             	movzbl (%edx),%edx
    b518:	88 10                	mov    %dl,(%eax)
    b51a:	0f b6 10             	movzbl (%eax),%edx
    b51d:	8b 45 08             	mov    0x8(%ebp),%eax
    b520:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b522:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b526:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b529:	01 45 08             	add    %eax,0x8(%ebp)
    b52c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b52f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b532:	75 c3                	jne    b4f7 <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b534:	e9 b3 00 00 00       	jmp    b5ec <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b539:	8b 45 14             	mov    0x14(%ebp),%eax
    b53c:	8b 00                	mov    (%eax),%eax
    b53e:	83 f8 06             	cmp    $0x6,%eax
    b541:	0f 85 a5 00 00 00    	jne    b5ec <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    b547:	8b 45 14             	mov    0x14(%ebp),%eax
    b54a:	8b 40 04             	mov    0x4(%eax),%eax
    b54d:	83 f8 08             	cmp    $0x8,%eax
    b550:	75 38                	jne    b58a <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b552:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b559:	eb 25                	jmp    b580 <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    b55b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b55e:	c1 e0 02             	shl    $0x2,%eax
    b561:	89 c2                	mov    %eax,%edx
    b563:	8b 45 10             	mov    0x10(%ebp),%eax
    b566:	01 d0                	add    %edx,%eax
    b568:	6a 03                	push   $0x3
    b56a:	50                   	push   %eax
    b56b:	ff 75 08             	pushl  0x8(%ebp)
    b56e:	e8 a8 7d ff ff       	call   331b <lodepng_memcpy>
    b573:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b576:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b57a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b57d:	01 45 08             	add    %eax,0x8(%ebp)
    b580:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b583:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b586:	75 d3                	jne    b55b <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b588:	eb 62                	jmp    b5ec <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b58a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b591:	eb 51                	jmp    b5e4 <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    b593:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b596:	c1 e0 03             	shl    $0x3,%eax
    b599:	89 c2                	mov    %eax,%edx
    b59b:	8b 45 10             	mov    0x10(%ebp),%eax
    b59e:	01 d0                	add    %edx,%eax
    b5a0:	0f b6 10             	movzbl (%eax),%edx
    b5a3:	8b 45 08             	mov    0x8(%ebp),%eax
    b5a6:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b5a8:	8b 45 08             	mov    0x8(%ebp),%eax
    b5ab:	8d 50 01             	lea    0x1(%eax),%edx
    b5ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5b1:	c1 e0 03             	shl    $0x3,%eax
    b5b4:	8d 48 02             	lea    0x2(%eax),%ecx
    b5b7:	8b 45 10             	mov    0x10(%ebp),%eax
    b5ba:	01 c8                	add    %ecx,%eax
    b5bc:	0f b6 00             	movzbl (%eax),%eax
    b5bf:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b5c1:	8b 45 08             	mov    0x8(%ebp),%eax
    b5c4:	8d 50 02             	lea    0x2(%eax),%edx
    b5c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5ca:	c1 e0 03             	shl    $0x3,%eax
    b5cd:	8d 48 04             	lea    0x4(%eax),%ecx
    b5d0:	8b 45 10             	mov    0x10(%ebp),%eax
    b5d3:	01 c8                	add    %ecx,%eax
    b5d5:	0f b6 00             	movzbl (%eax),%eax
    b5d8:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5da:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b5de:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b5e1:	01 45 08             	add    %eax,0x8(%ebp)
    b5e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5e7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b5ea:	75 a7                	jne    b593 <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b5ec:	90                   	nop
    b5ed:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b5f0:	c9                   	leave  
    b5f1:	c3                   	ret    

0000b5f2 <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    b5f2:	55                   	push   %ebp
    b5f3:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    b5f5:	8b 45 20             	mov    0x20(%ebp),%eax
    b5f8:	8b 00                	mov    (%eax),%eax
    b5fa:	85 c0                	test   %eax,%eax
    b5fc:	0f 85 a4 00 00 00    	jne    b6a6 <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    b602:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b605:	01 c0                	add    %eax,%eax
    b607:	89 c2                	mov    %eax,%edx
    b609:	8b 45 18             	mov    0x18(%ebp),%eax
    b60c:	01 d0                	add    %edx,%eax
    b60e:	0f b6 00             	movzbl (%eax),%eax
    b611:	0f b6 c0             	movzbl %al,%eax
    b614:	c1 e0 08             	shl    $0x8,%eax
    b617:	89 c2                	mov    %eax,%edx
    b619:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b61c:	01 c0                	add    %eax,%eax
    b61e:	8d 48 01             	lea    0x1(%eax),%ecx
    b621:	8b 45 18             	mov    0x18(%ebp),%eax
    b624:	01 c8                	add    %ecx,%eax
    b626:	0f b6 00             	movzbl (%eax),%eax
    b629:	0f b6 c0             	movzbl %al,%eax
    b62c:	01 c2                	add    %eax,%edx
    b62e:	8b 45 10             	mov    0x10(%ebp),%eax
    b631:	66 89 10             	mov    %dx,(%eax)
    b634:	8b 45 10             	mov    0x10(%ebp),%eax
    b637:	0f b7 10             	movzwl (%eax),%edx
    b63a:	8b 45 0c             	mov    0xc(%ebp),%eax
    b63d:	66 89 10             	mov    %dx,(%eax)
    b640:	8b 45 0c             	mov    0xc(%ebp),%eax
    b643:	0f b7 10             	movzwl (%eax),%edx
    b646:	8b 45 08             	mov    0x8(%ebp),%eax
    b649:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    b64c:	8b 45 20             	mov    0x20(%ebp),%eax
    b64f:	8b 40 10             	mov    0x10(%eax),%eax
    b652:	85 c0                	test   %eax,%eax
    b654:	74 43                	je     b699 <getPixelColorRGBA16+0xa7>
    b656:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b659:	01 c0                	add    %eax,%eax
    b65b:	89 c2                	mov    %eax,%edx
    b65d:	8b 45 18             	mov    0x18(%ebp),%eax
    b660:	01 d0                	add    %edx,%eax
    b662:	0f b6 00             	movzbl (%eax),%eax
    b665:	0f b6 c0             	movzbl %al,%eax
    b668:	c1 e0 08             	shl    $0x8,%eax
    b66b:	89 c2                	mov    %eax,%edx
    b66d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b670:	01 c0                	add    %eax,%eax
    b672:	8d 48 01             	lea    0x1(%eax),%ecx
    b675:	8b 45 18             	mov    0x18(%ebp),%eax
    b678:	01 c8                	add    %ecx,%eax
    b67a:	0f b6 00             	movzbl (%eax),%eax
    b67d:	0f b6 c0             	movzbl %al,%eax
    b680:	01 c2                	add    %eax,%edx
    b682:	8b 45 20             	mov    0x20(%ebp),%eax
    b685:	8b 40 14             	mov    0x14(%eax),%eax
    b688:	39 c2                	cmp    %eax,%edx
    b68a:	75 0d                	jne    b699 <getPixelColorRGBA16+0xa7>
    b68c:	8b 45 14             	mov    0x14(%ebp),%eax
    b68f:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b694:	e9 48 03 00 00       	jmp    b9e1 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b699:	8b 45 14             	mov    0x14(%ebp),%eax
    b69c:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b6a1:	e9 3b 03 00 00       	jmp    b9e1 <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    b6a6:	8b 45 20             	mov    0x20(%ebp),%eax
    b6a9:	8b 00                	mov    (%eax),%eax
    b6ab:	83 f8 02             	cmp    $0x2,%eax
    b6ae:	0f 85 b6 01 00 00    	jne    b86a <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    b6b4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b6b7:	89 d0                	mov    %edx,%eax
    b6b9:	01 c0                	add    %eax,%eax
    b6bb:	01 d0                	add    %edx,%eax
    b6bd:	01 c0                	add    %eax,%eax
    b6bf:	89 c2                	mov    %eax,%edx
    b6c1:	8b 45 18             	mov    0x18(%ebp),%eax
    b6c4:	01 d0                	add    %edx,%eax
    b6c6:	0f b6 00             	movzbl (%eax),%eax
    b6c9:	0f b6 c0             	movzbl %al,%eax
    b6cc:	c1 e0 08             	shl    $0x8,%eax
    b6cf:	89 c1                	mov    %eax,%ecx
    b6d1:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b6d4:	89 d0                	mov    %edx,%eax
    b6d6:	01 c0                	add    %eax,%eax
    b6d8:	01 d0                	add    %edx,%eax
    b6da:	01 c0                	add    %eax,%eax
    b6dc:	8d 50 01             	lea    0x1(%eax),%edx
    b6df:	8b 45 18             	mov    0x18(%ebp),%eax
    b6e2:	01 d0                	add    %edx,%eax
    b6e4:	0f b6 00             	movzbl (%eax),%eax
    b6e7:	0f b6 c0             	movzbl %al,%eax
    b6ea:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b6ed:	8b 45 08             	mov    0x8(%ebp),%eax
    b6f0:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    b6f3:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b6f6:	89 d0                	mov    %edx,%eax
    b6f8:	01 c0                	add    %eax,%eax
    b6fa:	01 d0                	add    %edx,%eax
    b6fc:	01 c0                	add    %eax,%eax
    b6fe:	8d 50 02             	lea    0x2(%eax),%edx
    b701:	8b 45 18             	mov    0x18(%ebp),%eax
    b704:	01 d0                	add    %edx,%eax
    b706:	0f b6 00             	movzbl (%eax),%eax
    b709:	0f b6 c0             	movzbl %al,%eax
    b70c:	c1 e0 08             	shl    $0x8,%eax
    b70f:	89 c1                	mov    %eax,%ecx
    b711:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b714:	89 d0                	mov    %edx,%eax
    b716:	01 c0                	add    %eax,%eax
    b718:	01 d0                	add    %edx,%eax
    b71a:	01 c0                	add    %eax,%eax
    b71c:	8d 50 03             	lea    0x3(%eax),%edx
    b71f:	8b 45 18             	mov    0x18(%ebp),%eax
    b722:	01 d0                	add    %edx,%eax
    b724:	0f b6 00             	movzbl (%eax),%eax
    b727:	0f b6 c0             	movzbl %al,%eax
    b72a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b72d:	8b 45 0c             	mov    0xc(%ebp),%eax
    b730:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    b733:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b736:	89 d0                	mov    %edx,%eax
    b738:	01 c0                	add    %eax,%eax
    b73a:	01 d0                	add    %edx,%eax
    b73c:	01 c0                	add    %eax,%eax
    b73e:	8d 50 04             	lea    0x4(%eax),%edx
    b741:	8b 45 18             	mov    0x18(%ebp),%eax
    b744:	01 d0                	add    %edx,%eax
    b746:	0f b6 00             	movzbl (%eax),%eax
    b749:	0f b6 c0             	movzbl %al,%eax
    b74c:	c1 e0 08             	shl    $0x8,%eax
    b74f:	89 c1                	mov    %eax,%ecx
    b751:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b754:	89 d0                	mov    %edx,%eax
    b756:	01 c0                	add    %eax,%eax
    b758:	01 d0                	add    %edx,%eax
    b75a:	01 c0                	add    %eax,%eax
    b75c:	8d 50 05             	lea    0x5(%eax),%edx
    b75f:	8b 45 18             	mov    0x18(%ebp),%eax
    b762:	01 d0                	add    %edx,%eax
    b764:	0f b6 00             	movzbl (%eax),%eax
    b767:	0f b6 c0             	movzbl %al,%eax
    b76a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b76d:	8b 45 10             	mov    0x10(%ebp),%eax
    b770:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    b773:	8b 45 20             	mov    0x20(%ebp),%eax
    b776:	8b 40 10             	mov    0x10(%eax),%eax
    b779:	85 c0                	test   %eax,%eax
    b77b:	0f 84 dc 00 00 00    	je     b85d <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b781:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b784:	89 d0                	mov    %edx,%eax
    b786:	01 c0                	add    %eax,%eax
    b788:	01 d0                	add    %edx,%eax
    b78a:	01 c0                	add    %eax,%eax
    b78c:	89 c2                	mov    %eax,%edx
    b78e:	8b 45 18             	mov    0x18(%ebp),%eax
    b791:	01 d0                	add    %edx,%eax
    b793:	0f b6 00             	movzbl (%eax),%eax
    b796:	0f b6 c0             	movzbl %al,%eax
    b799:	c1 e0 08             	shl    $0x8,%eax
    b79c:	89 c1                	mov    %eax,%ecx
    b79e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7a1:	89 d0                	mov    %edx,%eax
    b7a3:	01 c0                	add    %eax,%eax
    b7a5:	01 d0                	add    %edx,%eax
    b7a7:	01 c0                	add    %eax,%eax
    b7a9:	8d 50 01             	lea    0x1(%eax),%edx
    b7ac:	8b 45 18             	mov    0x18(%ebp),%eax
    b7af:	01 d0                	add    %edx,%eax
    b7b1:	0f b6 00             	movzbl (%eax),%eax
    b7b4:	0f b6 c0             	movzbl %al,%eax
    b7b7:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b7ba:	8b 45 20             	mov    0x20(%ebp),%eax
    b7bd:	8b 40 14             	mov    0x14(%eax),%eax
    b7c0:	39 c2                	cmp    %eax,%edx
    b7c2:	0f 85 95 00 00 00    	jne    b85d <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b7c8:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7cb:	89 d0                	mov    %edx,%eax
    b7cd:	01 c0                	add    %eax,%eax
    b7cf:	01 d0                	add    %edx,%eax
    b7d1:	01 c0                	add    %eax,%eax
    b7d3:	8d 50 02             	lea    0x2(%eax),%edx
    b7d6:	8b 45 18             	mov    0x18(%ebp),%eax
    b7d9:	01 d0                	add    %edx,%eax
    b7db:	0f b6 00             	movzbl (%eax),%eax
    b7de:	0f b6 c0             	movzbl %al,%eax
    b7e1:	c1 e0 08             	shl    $0x8,%eax
    b7e4:	89 c1                	mov    %eax,%ecx
    b7e6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7e9:	89 d0                	mov    %edx,%eax
    b7eb:	01 c0                	add    %eax,%eax
    b7ed:	01 d0                	add    %edx,%eax
    b7ef:	01 c0                	add    %eax,%eax
    b7f1:	8d 50 03             	lea    0x3(%eax),%edx
    b7f4:	8b 45 18             	mov    0x18(%ebp),%eax
    b7f7:	01 d0                	add    %edx,%eax
    b7f9:	0f b6 00             	movzbl (%eax),%eax
    b7fc:	0f b6 c0             	movzbl %al,%eax
    b7ff:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b802:	8b 45 20             	mov    0x20(%ebp),%eax
    b805:	8b 40 18             	mov    0x18(%eax),%eax
    b808:	39 c2                	cmp    %eax,%edx
    b80a:	75 51                	jne    b85d <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    b80c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b80f:	89 d0                	mov    %edx,%eax
    b811:	01 c0                	add    %eax,%eax
    b813:	01 d0                	add    %edx,%eax
    b815:	01 c0                	add    %eax,%eax
    b817:	8d 50 04             	lea    0x4(%eax),%edx
    b81a:	8b 45 18             	mov    0x18(%ebp),%eax
    b81d:	01 d0                	add    %edx,%eax
    b81f:	0f b6 00             	movzbl (%eax),%eax
    b822:	0f b6 c0             	movzbl %al,%eax
    b825:	c1 e0 08             	shl    $0x8,%eax
    b828:	89 c1                	mov    %eax,%ecx
    b82a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b82d:	89 d0                	mov    %edx,%eax
    b82f:	01 c0                	add    %eax,%eax
    b831:	01 d0                	add    %edx,%eax
    b833:	01 c0                	add    %eax,%eax
    b835:	8d 50 05             	lea    0x5(%eax),%edx
    b838:	8b 45 18             	mov    0x18(%ebp),%eax
    b83b:	01 d0                	add    %edx,%eax
    b83d:	0f b6 00             	movzbl (%eax),%eax
    b840:	0f b6 c0             	movzbl %al,%eax
    b843:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b846:	8b 45 20             	mov    0x20(%ebp),%eax
    b849:	8b 40 1c             	mov    0x1c(%eax),%eax
    b84c:	39 c2                	cmp    %eax,%edx
    b84e:	75 0d                	jne    b85d <getPixelColorRGBA16+0x26b>
    b850:	8b 45 14             	mov    0x14(%ebp),%eax
    b853:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b858:	e9 84 01 00 00       	jmp    b9e1 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b85d:	8b 45 14             	mov    0x14(%ebp),%eax
    b860:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b865:	e9 77 01 00 00       	jmp    b9e1 <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b86a:	8b 45 20             	mov    0x20(%ebp),%eax
    b86d:	8b 00                	mov    (%eax),%eax
    b86f:	83 f8 04             	cmp    $0x4,%eax
    b872:	0f 85 86 00 00 00    	jne    b8fe <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    b878:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b87b:	c1 e0 02             	shl    $0x2,%eax
    b87e:	89 c2                	mov    %eax,%edx
    b880:	8b 45 18             	mov    0x18(%ebp),%eax
    b883:	01 d0                	add    %edx,%eax
    b885:	0f b6 00             	movzbl (%eax),%eax
    b888:	0f b6 c0             	movzbl %al,%eax
    b88b:	c1 e0 08             	shl    $0x8,%eax
    b88e:	89 c2                	mov    %eax,%edx
    b890:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b893:	c1 e0 02             	shl    $0x2,%eax
    b896:	8d 48 01             	lea    0x1(%eax),%ecx
    b899:	8b 45 18             	mov    0x18(%ebp),%eax
    b89c:	01 c8                	add    %ecx,%eax
    b89e:	0f b6 00             	movzbl (%eax),%eax
    b8a1:	0f b6 c0             	movzbl %al,%eax
    b8a4:	01 c2                	add    %eax,%edx
    b8a6:	8b 45 10             	mov    0x10(%ebp),%eax
    b8a9:	66 89 10             	mov    %dx,(%eax)
    b8ac:	8b 45 10             	mov    0x10(%ebp),%eax
    b8af:	0f b7 10             	movzwl (%eax),%edx
    b8b2:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8b5:	66 89 10             	mov    %dx,(%eax)
    b8b8:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8bb:	0f b7 10             	movzwl (%eax),%edx
    b8be:	8b 45 08             	mov    0x8(%ebp),%eax
    b8c1:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    b8c4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b8c7:	c1 e0 02             	shl    $0x2,%eax
    b8ca:	8d 50 02             	lea    0x2(%eax),%edx
    b8cd:	8b 45 18             	mov    0x18(%ebp),%eax
    b8d0:	01 d0                	add    %edx,%eax
    b8d2:	0f b6 00             	movzbl (%eax),%eax
    b8d5:	0f b6 c0             	movzbl %al,%eax
    b8d8:	c1 e0 08             	shl    $0x8,%eax
    b8db:	89 c2                	mov    %eax,%edx
    b8dd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b8e0:	c1 e0 02             	shl    $0x2,%eax
    b8e3:	8d 48 03             	lea    0x3(%eax),%ecx
    b8e6:	8b 45 18             	mov    0x18(%ebp),%eax
    b8e9:	01 c8                	add    %ecx,%eax
    b8eb:	0f b6 00             	movzbl (%eax),%eax
    b8ee:	0f b6 c0             	movzbl %al,%eax
    b8f1:	01 c2                	add    %eax,%edx
    b8f3:	8b 45 14             	mov    0x14(%ebp),%eax
    b8f6:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b8f9:	e9 e3 00 00 00       	jmp    b9e1 <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    b8fe:	8b 45 20             	mov    0x20(%ebp),%eax
    b901:	8b 00                	mov    (%eax),%eax
    b903:	83 f8 06             	cmp    $0x6,%eax
    b906:	0f 85 d5 00 00 00    	jne    b9e1 <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    b90c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b90f:	c1 e0 03             	shl    $0x3,%eax
    b912:	89 c2                	mov    %eax,%edx
    b914:	8b 45 18             	mov    0x18(%ebp),%eax
    b917:	01 d0                	add    %edx,%eax
    b919:	0f b6 00             	movzbl (%eax),%eax
    b91c:	0f b6 c0             	movzbl %al,%eax
    b91f:	c1 e0 08             	shl    $0x8,%eax
    b922:	89 c2                	mov    %eax,%edx
    b924:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b927:	c1 e0 03             	shl    $0x3,%eax
    b92a:	8d 48 01             	lea    0x1(%eax),%ecx
    b92d:	8b 45 18             	mov    0x18(%ebp),%eax
    b930:	01 c8                	add    %ecx,%eax
    b932:	0f b6 00             	movzbl (%eax),%eax
    b935:	0f b6 c0             	movzbl %al,%eax
    b938:	01 c2                	add    %eax,%edx
    b93a:	8b 45 08             	mov    0x8(%ebp),%eax
    b93d:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    b940:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b943:	c1 e0 03             	shl    $0x3,%eax
    b946:	8d 50 02             	lea    0x2(%eax),%edx
    b949:	8b 45 18             	mov    0x18(%ebp),%eax
    b94c:	01 d0                	add    %edx,%eax
    b94e:	0f b6 00             	movzbl (%eax),%eax
    b951:	0f b6 c0             	movzbl %al,%eax
    b954:	c1 e0 08             	shl    $0x8,%eax
    b957:	89 c2                	mov    %eax,%edx
    b959:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b95c:	c1 e0 03             	shl    $0x3,%eax
    b95f:	8d 48 03             	lea    0x3(%eax),%ecx
    b962:	8b 45 18             	mov    0x18(%ebp),%eax
    b965:	01 c8                	add    %ecx,%eax
    b967:	0f b6 00             	movzbl (%eax),%eax
    b96a:	0f b6 c0             	movzbl %al,%eax
    b96d:	01 c2                	add    %eax,%edx
    b96f:	8b 45 0c             	mov    0xc(%ebp),%eax
    b972:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    b975:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b978:	c1 e0 03             	shl    $0x3,%eax
    b97b:	8d 50 04             	lea    0x4(%eax),%edx
    b97e:	8b 45 18             	mov    0x18(%ebp),%eax
    b981:	01 d0                	add    %edx,%eax
    b983:	0f b6 00             	movzbl (%eax),%eax
    b986:	0f b6 c0             	movzbl %al,%eax
    b989:	c1 e0 08             	shl    $0x8,%eax
    b98c:	89 c2                	mov    %eax,%edx
    b98e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b991:	c1 e0 03             	shl    $0x3,%eax
    b994:	8d 48 05             	lea    0x5(%eax),%ecx
    b997:	8b 45 18             	mov    0x18(%ebp),%eax
    b99a:	01 c8                	add    %ecx,%eax
    b99c:	0f b6 00             	movzbl (%eax),%eax
    b99f:	0f b6 c0             	movzbl %al,%eax
    b9a2:	01 c2                	add    %eax,%edx
    b9a4:	8b 45 10             	mov    0x10(%ebp),%eax
    b9a7:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    b9aa:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9ad:	c1 e0 03             	shl    $0x3,%eax
    b9b0:	8d 50 06             	lea    0x6(%eax),%edx
    b9b3:	8b 45 18             	mov    0x18(%ebp),%eax
    b9b6:	01 d0                	add    %edx,%eax
    b9b8:	0f b6 00             	movzbl (%eax),%eax
    b9bb:	0f b6 c0             	movzbl %al,%eax
    b9be:	c1 e0 08             	shl    $0x8,%eax
    b9c1:	89 c2                	mov    %eax,%edx
    b9c3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9c6:	c1 e0 03             	shl    $0x3,%eax
    b9c9:	8d 48 07             	lea    0x7(%eax),%ecx
    b9cc:	8b 45 18             	mov    0x18(%ebp),%eax
    b9cf:	01 c8                	add    %ecx,%eax
    b9d1:	0f b6 00             	movzbl (%eax),%eax
    b9d4:	0f b6 c0             	movzbl %al,%eax
    b9d7:	01 c2                	add    %eax,%edx
    b9d9:	8b 45 14             	mov    0x14(%ebp),%eax
    b9dc:	66 89 10             	mov    %dx,(%eax)
  }
}
    b9df:	eb 00                	jmp    b9e1 <getPixelColorRGBA16+0x3ef>
    b9e1:	90                   	nop
    b9e2:	5d                   	pop    %ebp
    b9e3:	c3                   	ret    

0000b9e4 <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    b9e4:	55                   	push   %ebp
    b9e5:	89 e5                	mov    %esp,%ebp
    b9e7:	56                   	push   %esi
    b9e8:	53                   	push   %ebx
    b9e9:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    b9ec:	8b 55 18             	mov    0x18(%ebp),%edx
    b9ef:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9f2:	0f af c2             	imul   %edx,%eax
    b9f5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    b9f8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    b9ff:	8b 45 14             	mov    0x14(%ebp),%eax
    ba02:	8b 00                	mov    (%eax),%eax
    ba04:	83 f8 03             	cmp    $0x3,%eax
    ba07:	75 14                	jne    ba1d <lodepng_convert+0x39>
    ba09:	8b 45 14             	mov    0x14(%ebp),%eax
    ba0c:	8b 40 08             	mov    0x8(%eax),%eax
    ba0f:	85 c0                	test   %eax,%eax
    ba11:	75 0a                	jne    ba1d <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    ba13:	b8 6b 00 00 00       	mov    $0x6b,%eax
    ba18:	e9 19 03 00 00       	jmp    bd36 <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    ba1d:	ff 75 14             	pushl  0x14(%ebp)
    ba20:	ff 75 10             	pushl  0x10(%ebp)
    ba23:	e8 b7 d1 ff ff       	call   8bdf <lodepng_color_mode_equal>
    ba28:	83 c4 08             	add    $0x8,%esp
    ba2b:	85 c0                	test   %eax,%eax
    ba2d:	74 2f                	je     ba5e <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    ba2f:	ff 75 14             	pushl  0x14(%ebp)
    ba32:	ff 75 1c             	pushl  0x1c(%ebp)
    ba35:	ff 75 18             	pushl  0x18(%ebp)
    ba38:	e8 fb d4 ff ff       	call   8f38 <lodepng_get_raw_size>
    ba3d:	83 c4 0c             	add    $0xc,%esp
    ba40:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    ba43:	ff 75 dc             	pushl  -0x24(%ebp)
    ba46:	ff 75 0c             	pushl  0xc(%ebp)
    ba49:	ff 75 08             	pushl  0x8(%ebp)
    ba4c:	e8 ca 78 ff ff       	call   331b <lodepng_memcpy>
    ba51:	83 c4 0c             	add    $0xc,%esp
    return 0;
    ba54:	b8 00 00 00 00       	mov    $0x0,%eax
    ba59:	e9 d8 02 00 00       	jmp    bd36 <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    ba5e:	8b 45 10             	mov    0x10(%ebp),%eax
    ba61:	8b 00                	mov    (%eax),%eax
    ba63:	83 f8 03             	cmp    $0x3,%eax
    ba66:	0f 85 16 01 00 00    	jne    bb82 <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    ba6c:	8b 45 10             	mov    0x10(%ebp),%eax
    ba6f:	8b 40 0c             	mov    0xc(%eax),%eax
    ba72:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    ba75:	8b 45 10             	mov    0x10(%ebp),%eax
    ba78:	8b 40 08             	mov    0x8(%eax),%eax
    ba7b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    ba7e:	8b 45 10             	mov    0x10(%ebp),%eax
    ba81:	8b 40 04             	mov    0x4(%eax),%eax
    ba84:	ba 01 00 00 00       	mov    $0x1,%edx
    ba89:	89 c1                	mov    %eax,%ecx
    ba8b:	d3 e2                	shl    %cl,%edx
    ba8d:	89 d0                	mov    %edx,%eax
    ba8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    ba92:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ba96:	75 5b                	jne    baf3 <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    ba98:	8b 45 14             	mov    0x14(%ebp),%eax
    ba9b:	8b 40 0c             	mov    0xc(%eax),%eax
    ba9e:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    baa1:	8b 45 14             	mov    0x14(%ebp),%eax
    baa4:	8b 40 08             	mov    0x8(%eax),%eax
    baa7:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    baaa:	8b 45 14             	mov    0x14(%ebp),%eax
    baad:	8b 00                	mov    (%eax),%eax
    baaf:	83 f8 03             	cmp    $0x3,%eax
    bab2:	75 3f                	jne    baf3 <lodepng_convert+0x10f>
    bab4:	8b 45 14             	mov    0x14(%ebp),%eax
    bab7:	8b 50 04             	mov    0x4(%eax),%edx
    baba:	8b 45 10             	mov    0x10(%ebp),%eax
    babd:	8b 40 04             	mov    0x4(%eax),%eax
    bac0:	39 c2                	cmp    %eax,%edx
    bac2:	75 2f                	jne    baf3 <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bac4:	ff 75 14             	pushl  0x14(%ebp)
    bac7:	ff 75 1c             	pushl  0x1c(%ebp)
    baca:	ff 75 18             	pushl  0x18(%ebp)
    bacd:	e8 66 d4 ff ff       	call   8f38 <lodepng_get_raw_size>
    bad2:	83 c4 0c             	add    $0xc,%esp
    bad5:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    bad8:	ff 75 d8             	pushl  -0x28(%ebp)
    badb:	ff 75 0c             	pushl  0xc(%ebp)
    bade:	ff 75 08             	pushl  0x8(%ebp)
    bae1:	e8 35 78 ff ff       	call   331b <lodepng_memcpy>
    bae6:	83 c4 0c             	add    $0xc,%esp
        return 0;
    bae9:	b8 00 00 00 00       	mov    $0x0,%eax
    baee:	e9 43 02 00 00       	jmp    bd36 <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    baf3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    baf6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    baf9:	7d 06                	jge    bb01 <lodepng_convert+0x11d>
    bafb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bafe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    bb01:	8d 45 90             	lea    -0x70(%ebp),%eax
    bb04:	50                   	push   %eax
    bb05:	e8 5f e1 ff ff       	call   9c69 <color_tree_init>
    bb0a:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    bb0d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bb14:	eb 61                	jmp    bb77 <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    bb16:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bb19:	c1 e0 02             	shl    $0x2,%eax
    bb1c:	89 c2                	mov    %eax,%edx
    bb1e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bb21:	01 d0                	add    %edx,%eax
    bb23:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    bb26:	8b 75 f4             	mov    -0xc(%ebp),%esi
    bb29:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb2c:	83 c0 03             	add    $0x3,%eax
    bb2f:	0f b6 00             	movzbl (%eax),%eax
    bb32:	0f b6 d8             	movzbl %al,%ebx
    bb35:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb38:	83 c0 02             	add    $0x2,%eax
    bb3b:	0f b6 00             	movzbl (%eax),%eax
    bb3e:	0f b6 c8             	movzbl %al,%ecx
    bb41:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb44:	83 c0 01             	add    $0x1,%eax
    bb47:	0f b6 00             	movzbl (%eax),%eax
    bb4a:	0f b6 d0             	movzbl %al,%edx
    bb4d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb50:	0f b6 00             	movzbl (%eax),%eax
    bb53:	0f b6 c0             	movzbl %al,%eax
    bb56:	83 ec 08             	sub    $0x8,%esp
    bb59:	56                   	push   %esi
    bb5a:	53                   	push   %ebx
    bb5b:	51                   	push   %ecx
    bb5c:	52                   	push   %edx
    bb5d:	50                   	push   %eax
    bb5e:	8d 45 90             	lea    -0x70(%ebp),%eax
    bb61:	50                   	push   %eax
    bb62:	e8 85 e2 ff ff       	call   9dec <color_tree_add>
    bb67:	83 c4 20             	add    $0x20,%esp
    bb6a:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    bb6d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bb71:	75 0e                	jne    bb81 <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    bb73:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bb77:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bb7a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bb7d:	75 97                	jne    bb16 <lodepng_convert+0x132>
    bb7f:	eb 01                	jmp    bb82 <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    bb81:	90                   	nop
    }
  }

  if(!error) {
    bb82:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bb86:	0f 85 8e 01 00 00    	jne    bd1a <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bb8c:	8b 45 14             	mov    0x14(%ebp),%eax
    bb8f:	8b 40 04             	mov    0x4(%eax),%eax
    bb92:	83 f8 10             	cmp    $0x10,%eax
    bb95:	0f 85 99 00 00 00    	jne    bc34 <lodepng_convert+0x250>
    bb9b:	8b 45 10             	mov    0x10(%ebp),%eax
    bb9e:	8b 40 04             	mov    0x4(%eax),%eax
    bba1:	83 f8 10             	cmp    $0x10,%eax
    bba4:	0f 85 8a 00 00 00    	jne    bc34 <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    bbaa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bbb1:	eb 74                	jmp    bc27 <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    bbb3:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    bbb9:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    bbbf:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    bbc5:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    bbcb:	83 ec 04             	sub    $0x4,%esp
    bbce:	ff 75 14             	pushl  0x14(%ebp)
    bbd1:	ff 75 f4             	pushl  -0xc(%ebp)
    bbd4:	ff 75 0c             	pushl  0xc(%ebp)
    bbd7:	8d 45 88             	lea    -0x78(%ebp),%eax
    bbda:	50                   	push   %eax
    bbdb:	8d 45 8a             	lea    -0x76(%ebp),%eax
    bbde:	50                   	push   %eax
    bbdf:	8d 45 8c             	lea    -0x74(%ebp),%eax
    bbe2:	50                   	push   %eax
    bbe3:	8d 45 8e             	lea    -0x72(%ebp),%eax
    bbe6:	50                   	push   %eax
    bbe7:	e8 06 fa ff ff       	call   b5f2 <getPixelColorRGBA16>
    bbec:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    bbef:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    bbf3:	0f b7 d8             	movzwl %ax,%ebx
    bbf6:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    bbfa:	0f b7 c8             	movzwl %ax,%ecx
    bbfd:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    bc01:	0f b7 d0             	movzwl %ax,%edx
    bc04:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    bc08:	0f b7 c0             	movzwl %ax,%eax
    bc0b:	83 ec 04             	sub    $0x4,%esp
    bc0e:	53                   	push   %ebx
    bc0f:	51                   	push   %ecx
    bc10:	52                   	push   %edx
    bc11:	50                   	push   %eax
    bc12:	ff 75 10             	pushl  0x10(%ebp)
    bc15:	ff 75 f4             	pushl  -0xc(%ebp)
    bc18:	ff 75 08             	pushl  0x8(%ebp)
    bc1b:	e8 d3 e6 ff ff       	call   a2f3 <rgba16ToPixel>
    bc20:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    bc23:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bc27:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bc2a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bc2d:	75 84                	jne    bbb3 <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bc2f:	e9 e6 00 00 00       	jmp    bd1a <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    bc34:	8b 45 10             	mov    0x10(%ebp),%eax
    bc37:	8b 40 04             	mov    0x4(%eax),%eax
    bc3a:	83 f8 08             	cmp    $0x8,%eax
    bc3d:	75 23                	jne    bc62 <lodepng_convert+0x27e>
    bc3f:	8b 45 10             	mov    0x10(%ebp),%eax
    bc42:	8b 00                	mov    (%eax),%eax
    bc44:	83 f8 06             	cmp    $0x6,%eax
    bc47:	75 19                	jne    bc62 <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    bc49:	ff 75 14             	pushl  0x14(%ebp)
    bc4c:	ff 75 0c             	pushl  0xc(%ebp)
    bc4f:	ff 75 e0             	pushl  -0x20(%ebp)
    bc52:	ff 75 08             	pushl  0x8(%ebp)
    bc55:	e8 ae ee ff ff       	call   ab08 <getPixelColorsRGBA8>
    bc5a:	83 c4 10             	add    $0x10,%esp
    bc5d:	e9 b8 00 00 00       	jmp    bd1a <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    bc62:	8b 45 10             	mov    0x10(%ebp),%eax
    bc65:	8b 40 04             	mov    0x4(%eax),%eax
    bc68:	83 f8 08             	cmp    $0x8,%eax
    bc6b:	75 23                	jne    bc90 <lodepng_convert+0x2ac>
    bc6d:	8b 45 10             	mov    0x10(%ebp),%eax
    bc70:	8b 00                	mov    (%eax),%eax
    bc72:	83 f8 02             	cmp    $0x2,%eax
    bc75:	75 19                	jne    bc90 <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    bc77:	ff 75 14             	pushl  0x14(%ebp)
    bc7a:	ff 75 0c             	pushl  0xc(%ebp)
    bc7d:	ff 75 e0             	pushl  -0x20(%ebp)
    bc80:	ff 75 08             	pushl  0x8(%ebp)
    bc83:	e8 50 f5 ff ff       	call   b1d8 <getPixelColorsRGB8>
    bc88:	83 c4 10             	add    $0x10,%esp
    bc8b:	e9 8a 00 00 00       	jmp    bd1a <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    bc90:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    bc94:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    bc98:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    bc9c:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    bca0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bca7:	eb 66                	jmp    bd0f <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    bca9:	83 ec 04             	sub    $0x4,%esp
    bcac:	ff 75 14             	pushl  0x14(%ebp)
    bcaf:	ff 75 f4             	pushl  -0xc(%ebp)
    bcb2:	ff 75 0c             	pushl  0xc(%ebp)
    bcb5:	8d 45 84             	lea    -0x7c(%ebp),%eax
    bcb8:	50                   	push   %eax
    bcb9:	8d 45 85             	lea    -0x7b(%ebp),%eax
    bcbc:	50                   	push   %eax
    bcbd:	8d 45 86             	lea    -0x7a(%ebp),%eax
    bcc0:	50                   	push   %eax
    bcc1:	8d 45 87             	lea    -0x79(%ebp),%eax
    bcc4:	50                   	push   %eax
    bcc5:	e8 71 e8 ff ff       	call   a53b <getPixelColorRGBA8>
    bcca:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    bccd:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    bcd1:	0f b6 d8             	movzbl %al,%ebx
    bcd4:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    bcd8:	0f b6 c8             	movzbl %al,%ecx
    bcdb:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    bcdf:	0f b6 d0             	movzbl %al,%edx
    bce2:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    bce6:	0f b6 c0             	movzbl %al,%eax
    bce9:	53                   	push   %ebx
    bcea:	51                   	push   %ecx
    bceb:	52                   	push   %edx
    bcec:	50                   	push   %eax
    bced:	8d 45 90             	lea    -0x70(%ebp),%eax
    bcf0:	50                   	push   %eax
    bcf1:	ff 75 10             	pushl  0x10(%ebp)
    bcf4:	ff 75 f4             	pushl  -0xc(%ebp)
    bcf7:	ff 75 08             	pushl  0x8(%ebp)
    bcfa:	e8 e5 e1 ff ff       	call   9ee4 <rgba8ToPixel>
    bcff:	83 c4 20             	add    $0x20,%esp
    bd02:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    bd05:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bd09:	75 0e                	jne    bd19 <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    bd0b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bd0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bd12:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bd15:	75 92                	jne    bca9 <lodepng_convert+0x2c5>
    bd17:	eb 01                	jmp    bd1a <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    bd19:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    bd1a:	8b 45 10             	mov    0x10(%ebp),%eax
    bd1d:	8b 00                	mov    (%eax),%eax
    bd1f:	83 f8 03             	cmp    $0x3,%eax
    bd22:	75 0f                	jne    bd33 <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    bd24:	83 ec 0c             	sub    $0xc,%esp
    bd27:	8d 45 90             	lea    -0x70(%ebp),%eax
    bd2a:	50                   	push   %eax
    bd2b:	e8 59 df ff ff       	call   9c89 <color_tree_cleanup>
    bd30:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    bd33:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    bd36:	8d 65 f8             	lea    -0x8(%ebp),%esp
    bd39:	5b                   	pop    %ebx
    bd3a:	5e                   	pop    %esi
    bd3b:	5d                   	pop    %ebp
    bd3c:	c3                   	ret    

0000bd3d <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    bd3d:	55                   	push   %ebp
    bd3e:	89 e5                	mov    %esp,%ebp
    bd40:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    bd43:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    bd4a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bd51:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    bd58:	8b 45 24             	mov    0x24(%ebp),%eax
    bd5b:	8b 40 04             	mov    0x4(%eax),%eax
    bd5e:	ba 01 00 00 00       	mov    $0x1,%edx
    bd63:	89 c1                	mov    %eax,%ecx
    bd65:	d3 e2                	shl    %cl,%edx
    bd67:	89 d0                	mov    %edx,%eax
    bd69:	8d 48 ff             	lea    -0x1(%eax),%ecx
    bd6c:	b8 ff ff 00 00       	mov    $0xffff,%eax
    bd71:	ba 00 00 00 00       	mov    $0x0,%edx
    bd76:	f7 f1                	div    %ecx
    bd78:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    bd7b:	8b 45 20             	mov    0x20(%ebp),%eax
    bd7e:	8b 40 04             	mov    0x4(%eax),%eax
    bd81:	ba 10 00 00 00       	mov    $0x10,%edx
    bd86:	29 c2                	sub    %eax,%edx
    bd88:	89 d0                	mov    %edx,%eax
    bd8a:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    bd8d:	8b 45 24             	mov    0x24(%ebp),%eax
    bd90:	8b 00                	mov    (%eax),%eax
    bd92:	85 c0                	test   %eax,%eax
    bd94:	74 0a                	je     bda0 <lodepng_convert_rgb+0x63>
    bd96:	8b 45 24             	mov    0x24(%ebp),%eax
    bd99:	8b 00                	mov    (%eax),%eax
    bd9b:	83 f8 04             	cmp    $0x4,%eax
    bd9e:	75 1b                	jne    bdbb <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    bda0:	8b 45 14             	mov    0x14(%ebp),%eax
    bda3:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bda7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bdaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bdad:	89 45 f8             	mov    %eax,-0x8(%ebp)
    bdb0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bdb3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    bdb6:	e9 c2 00 00 00       	jmp    be7d <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    bdbb:	8b 45 24             	mov    0x24(%ebp),%eax
    bdbe:	8b 00                	mov    (%eax),%eax
    bdc0:	83 f8 02             	cmp    $0x2,%eax
    bdc3:	74 0a                	je     bdcf <lodepng_convert_rgb+0x92>
    bdc5:	8b 45 24             	mov    0x24(%ebp),%eax
    bdc8:	8b 00                	mov    (%eax),%eax
    bdca:	83 f8 06             	cmp    $0x6,%eax
    bdcd:	75 23                	jne    bdf2 <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    bdcf:	8b 45 14             	mov    0x14(%ebp),%eax
    bdd2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bdd6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    bdd9:	8b 45 18             	mov    0x18(%ebp),%eax
    bddc:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bde0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    bde3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bde6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bdea:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bded:	e9 8b 00 00 00       	jmp    be7d <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    bdf2:	8b 45 24             	mov    0x24(%ebp),%eax
    bdf5:	8b 00                	mov    (%eax),%eax
    bdf7:	83 f8 03             	cmp    $0x3,%eax
    bdfa:	75 77                	jne    be73 <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    bdfc:	8b 45 24             	mov    0x24(%ebp),%eax
    bdff:	8b 40 0c             	mov    0xc(%eax),%eax
    be02:	3b 45 14             	cmp    0x14(%ebp),%eax
    be05:	77 0a                	ja     be11 <lodepng_convert_rgb+0xd4>
    be07:	b8 52 00 00 00       	mov    $0x52,%eax
    be0c:	e9 cb 01 00 00       	jmp    bfdc <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    be11:	8b 45 24             	mov    0x24(%ebp),%eax
    be14:	8b 40 08             	mov    0x8(%eax),%eax
    be17:	8b 55 14             	mov    0x14(%ebp),%edx
    be1a:	c1 e2 02             	shl    $0x2,%edx
    be1d:	01 d0                	add    %edx,%eax
    be1f:	0f b6 00             	movzbl (%eax),%eax
    be22:	0f b6 d0             	movzbl %al,%edx
    be25:	89 d0                	mov    %edx,%eax
    be27:	c1 e0 08             	shl    $0x8,%eax
    be2a:	01 d0                	add    %edx,%eax
    be2c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    be2f:	8b 45 24             	mov    0x24(%ebp),%eax
    be32:	8b 40 08             	mov    0x8(%eax),%eax
    be35:	8b 55 14             	mov    0x14(%ebp),%edx
    be38:	c1 e2 02             	shl    $0x2,%edx
    be3b:	83 c2 01             	add    $0x1,%edx
    be3e:	01 d0                	add    %edx,%eax
    be40:	0f b6 00             	movzbl (%eax),%eax
    be43:	0f b6 d0             	movzbl %al,%edx
    be46:	89 d0                	mov    %edx,%eax
    be48:	c1 e0 08             	shl    $0x8,%eax
    be4b:	01 d0                	add    %edx,%eax
    be4d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    be50:	8b 45 24             	mov    0x24(%ebp),%eax
    be53:	8b 40 08             	mov    0x8(%eax),%eax
    be56:	8b 55 14             	mov    0x14(%ebp),%edx
    be59:	c1 e2 02             	shl    $0x2,%edx
    be5c:	83 c2 02             	add    $0x2,%edx
    be5f:	01 d0                	add    %edx,%eax
    be61:	0f b6 00             	movzbl (%eax),%eax
    be64:	0f b6 d0             	movzbl %al,%edx
    be67:	89 d0                	mov    %edx,%eax
    be69:	c1 e0 08             	shl    $0x8,%eax
    be6c:	01 d0                	add    %edx,%eax
    be6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    be71:	eb 0a                	jmp    be7d <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    be73:	b8 1f 00 00 00       	mov    $0x1f,%eax
    be78:	e9 5f 01 00 00       	jmp    bfdc <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    be7d:	8b 45 20             	mov    0x20(%ebp),%eax
    be80:	8b 00                	mov    (%eax),%eax
    be82:	85 c0                	test   %eax,%eax
    be84:	74 0a                	je     be90 <lodepng_convert_rgb+0x153>
    be86:	8b 45 20             	mov    0x20(%ebp),%eax
    be89:	8b 00                	mov    (%eax),%eax
    be8b:	83 f8 04             	cmp    $0x4,%eax
    be8e:	75 14                	jne    bea4 <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    be90:	8b 45 e8             	mov    -0x18(%ebp),%eax
    be93:	8b 55 fc             	mov    -0x4(%ebp),%edx
    be96:	89 c1                	mov    %eax,%ecx
    be98:	d3 ea                	shr    %cl,%edx
    be9a:	8b 45 08             	mov    0x8(%ebp),%eax
    be9d:	89 10                	mov    %edx,(%eax)
    be9f:	e9 33 01 00 00       	jmp    bfd7 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    bea4:	8b 45 20             	mov    0x20(%ebp),%eax
    bea7:	8b 00                	mov    (%eax),%eax
    bea9:	83 f8 02             	cmp    $0x2,%eax
    beac:	74 0a                	je     beb8 <lodepng_convert_rgb+0x17b>
    beae:	8b 45 20             	mov    0x20(%ebp),%eax
    beb1:	8b 00                	mov    (%eax),%eax
    beb3:	83 f8 06             	cmp    $0x6,%eax
    beb6:	75 32                	jne    beea <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    beb8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bebb:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bebe:	89 c1                	mov    %eax,%ecx
    bec0:	d3 ea                	shr    %cl,%edx
    bec2:	8b 45 08             	mov    0x8(%ebp),%eax
    bec5:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    bec7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    beca:	8b 55 f8             	mov    -0x8(%ebp),%edx
    becd:	89 c1                	mov    %eax,%ecx
    becf:	d3 ea                	shr    %cl,%edx
    bed1:	8b 45 0c             	mov    0xc(%ebp),%eax
    bed4:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    bed6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bed9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    bedc:	89 c1                	mov    %eax,%ecx
    bede:	d3 ea                	shr    %cl,%edx
    bee0:	8b 45 10             	mov    0x10(%ebp),%eax
    bee3:	89 10                	mov    %edx,(%eax)
    bee5:	e9 ed 00 00 00       	jmp    bfd7 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    beea:	8b 45 20             	mov    0x20(%ebp),%eax
    beed:	8b 00                	mov    (%eax),%eax
    beef:	83 f8 03             	cmp    $0x3,%eax
    bef2:	0f 85 d8 00 00 00    	jne    bfd0 <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    bef8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    befb:	c1 e8 08             	shr    $0x8,%eax
    befe:	89 c2                	mov    %eax,%edx
    bf00:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bf03:	0f b6 c0             	movzbl %al,%eax
    bf06:	39 c2                	cmp    %eax,%edx
    bf08:	75 24                	jne    bf2e <lodepng_convert_rgb+0x1f1>
    bf0a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bf0d:	c1 e8 08             	shr    $0x8,%eax
    bf10:	89 c2                	mov    %eax,%edx
    bf12:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bf15:	0f b6 c0             	movzbl %al,%eax
    bf18:	39 c2                	cmp    %eax,%edx
    bf1a:	75 12                	jne    bf2e <lodepng_convert_rgb+0x1f1>
    bf1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf1f:	c1 e8 08             	shr    $0x8,%eax
    bf22:	89 c2                	mov    %eax,%edx
    bf24:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf27:	0f b6 c0             	movzbl %al,%eax
    bf2a:	39 c2                	cmp    %eax,%edx
    bf2c:	74 0a                	je     bf38 <lodepng_convert_rgb+0x1fb>
    bf2e:	b8 52 00 00 00       	mov    $0x52,%eax
    bf33:	e9 a4 00 00 00       	jmp    bfdc <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    bf38:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    bf3f:	eb 79                	jmp    bfba <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    bf41:	8b 45 f0             	mov    -0x10(%ebp),%eax
    bf44:	c1 e0 02             	shl    $0x2,%eax
    bf47:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    bf4a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bf4d:	c1 e8 08             	shr    $0x8,%eax
    bf50:	89 c1                	mov    %eax,%ecx
    bf52:	8b 45 20             	mov    0x20(%ebp),%eax
    bf55:	8b 50 08             	mov    0x8(%eax),%edx
    bf58:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    bf5b:	01 d0                	add    %edx,%eax
    bf5d:	0f b6 00             	movzbl (%eax),%eax
    bf60:	0f b6 c0             	movzbl %al,%eax
    bf63:	39 c1                	cmp    %eax,%ecx
    bf65:	75 4f                	jne    bfb6 <lodepng_convert_rgb+0x279>
    bf67:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bf6a:	c1 e8 08             	shr    $0x8,%eax
    bf6d:	89 c1                	mov    %eax,%ecx
    bf6f:	8b 45 20             	mov    0x20(%ebp),%eax
    bf72:	8b 40 08             	mov    0x8(%eax),%eax
    bf75:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    bf78:	83 c2 01             	add    $0x1,%edx
    bf7b:	01 d0                	add    %edx,%eax
    bf7d:	0f b6 00             	movzbl (%eax),%eax
    bf80:	0f b6 c0             	movzbl %al,%eax
    bf83:	39 c1                	cmp    %eax,%ecx
    bf85:	75 2f                	jne    bfb6 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    bf87:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf8a:	c1 e8 08             	shr    $0x8,%eax
    bf8d:	89 c1                	mov    %eax,%ecx
    bf8f:	8b 45 20             	mov    0x20(%ebp),%eax
    bf92:	8b 40 08             	mov    0x8(%eax),%eax
    bf95:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    bf98:	83 c2 02             	add    $0x2,%edx
    bf9b:	01 d0                	add    %edx,%eax
    bf9d:	0f b6 00             	movzbl (%eax),%eax
    bfa0:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    bfa3:	39 c1                	cmp    %eax,%ecx
    bfa5:	75 0f                	jne    bfb6 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    bfa7:	8b 45 08             	mov    0x8(%ebp),%eax
    bfaa:	8b 55 f0             	mov    -0x10(%ebp),%edx
    bfad:	89 10                	mov    %edx,(%eax)
        return 0;
    bfaf:	b8 00 00 00 00       	mov    $0x0,%eax
    bfb4:	eb 26                	jmp    bfdc <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    bfb6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    bfba:	8b 45 20             	mov    0x20(%ebp),%eax
    bfbd:	8b 40 0c             	mov    0xc(%eax),%eax
    bfc0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    bfc3:	0f 87 78 ff ff ff    	ja     bf41 <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    bfc9:	b8 52 00 00 00       	mov    $0x52,%eax
    bfce:	eb 0c                	jmp    bfdc <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    bfd0:	b8 1f 00 00 00       	mov    $0x1f,%eax
    bfd5:	eb 05                	jmp    bfdc <lodepng_convert_rgb+0x29f>
  }

  return 0;
    bfd7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    bfdc:	c9                   	leave  
    bfdd:	c3                   	ret    

0000bfde <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    bfde:	55                   	push   %ebp
    bfdf:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    bfe1:	8b 45 08             	mov    0x8(%ebp),%eax
    bfe4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    bfea:	8b 45 08             	mov    0x8(%ebp),%eax
    bfed:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    bff4:	8b 45 08             	mov    0x8(%ebp),%eax
    bff7:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    bffd:	8b 45 08             	mov    0x8(%ebp),%eax
    c000:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c004:	8b 45 08             	mov    0x8(%ebp),%eax
    c007:	66 89 50 0a          	mov    %dx,0xa(%eax)
    c00b:	8b 45 08             	mov    0x8(%ebp),%eax
    c00e:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c012:	8b 45 08             	mov    0x8(%ebp),%eax
    c015:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    c019:	8b 45 08             	mov    0x8(%ebp),%eax
    c01c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    c023:	8b 45 08             	mov    0x8(%ebp),%eax
    c026:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    c02d:	8b 45 08             	mov    0x8(%ebp),%eax
    c030:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    c037:	00 00 00 
  stats->numpixels = 0;
    c03a:	8b 45 08             	mov    0x8(%ebp),%eax
    c03d:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    c044:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    c047:	8b 45 08             	mov    0x8(%ebp),%eax
    c04a:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    c051:	00 00 00 
  stats->allow_greyscale = 1;
    c054:	8b 45 08             	mov    0x8(%ebp),%eax
    c057:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    c05e:	00 00 00 
}
    c061:	90                   	nop
    c062:	5d                   	pop    %ebp
    c063:	c3                   	ret    

0000c064 <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    c064:	55                   	push   %ebp
    c065:	89 e5                	mov    %esp,%ebp
    c067:	53                   	push   %ebx
    c068:	83 ec 04             	sub    $0x4,%esp
    c06b:	8b 45 08             	mov    0x8(%ebp),%eax
    c06e:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    c071:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    c075:	74 06                	je     c07d <getValueRequiredBits+0x19>
    c077:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    c07b:	75 07                	jne    c084 <getValueRequiredBits+0x20>
    c07d:	b8 01 00 00 00       	mov    $0x1,%eax
    c082:	eb 6b                	jmp    c0ef <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    c084:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c088:	0f b6 d9             	movzbl %cl,%ebx
    c08b:	89 da                	mov    %ebx,%edx
    c08d:	89 d0                	mov    %edx,%eax
    c08f:	c1 e0 04             	shl    $0x4,%eax
    c092:	89 c2                	mov    %eax,%edx
    c094:	89 d0                	mov    %edx,%eax
    c096:	c1 e0 04             	shl    $0x4,%eax
    c099:	29 d0                	sub    %edx,%eax
    c09b:	01 d8                	add    %ebx,%eax
    c09d:	66 c1 e8 08          	shr    $0x8,%ax
    c0a1:	c0 e8 04             	shr    $0x4,%al
    c0a4:	89 c2                	mov    %eax,%edx
    c0a6:	c1 e2 04             	shl    $0x4,%edx
    c0a9:	01 c2                	add    %eax,%edx
    c0ab:	89 c8                	mov    %ecx,%eax
    c0ad:	29 d0                	sub    %edx,%eax
    c0af:	84 c0                	test   %al,%al
    c0b1:	75 37                	jne    c0ea <getValueRequiredBits+0x86>
    c0b3:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c0b7:	0f b6 d1             	movzbl %cl,%edx
    c0ba:	89 d0                	mov    %edx,%eax
    c0bc:	01 c0                	add    %eax,%eax
    c0be:	01 d0                	add    %edx,%eax
    c0c0:	c1 e0 06             	shl    $0x6,%eax
    c0c3:	01 d0                	add    %edx,%eax
    c0c5:	66 c1 e8 08          	shr    $0x8,%ax
    c0c9:	c0 e8 06             	shr    $0x6,%al
    c0cc:	ba 55 00 00 00       	mov    $0x55,%edx
    c0d1:	0f af c2             	imul   %edx,%eax
    c0d4:	29 c1                	sub    %eax,%ecx
    c0d6:	89 c8                	mov    %ecx,%eax
    c0d8:	84 c0                	test   %al,%al
    c0da:	75 07                	jne    c0e3 <getValueRequiredBits+0x7f>
    c0dc:	b8 02 00 00 00       	mov    $0x2,%eax
    c0e1:	eb 0c                	jmp    c0ef <getValueRequiredBits+0x8b>
    c0e3:	b8 04 00 00 00       	mov    $0x4,%eax
    c0e8:	eb 05                	jmp    c0ef <getValueRequiredBits+0x8b>
  return 8;
    c0ea:	b8 08 00 00 00       	mov    $0x8,%eax
}
    c0ef:	83 c4 04             	add    $0x4,%esp
    c0f2:	5b                   	pop    %ebx
    c0f3:	5d                   	pop    %ebp
    c0f4:	c3                   	ret    

0000c0f5 <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    c0f5:	55                   	push   %ebp
    c0f6:	89 e5                	mov    %esp,%ebp
    c0f8:	56                   	push   %esi
    c0f9:	53                   	push   %ebx
    c0fa:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c100:	8b 55 10             	mov    0x10(%ebp),%edx
    c103:	8b 45 14             	mov    0x14(%ebp),%eax
    c106:	0f af c2             	imul   %edx,%eax
    c109:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    c10c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    c113:	ff 75 18             	pushl  0x18(%ebp)
    c116:	e8 0b cd ff ff       	call   8e26 <lodepng_is_greyscale_type>
    c11b:	83 c4 04             	add    $0x4,%esp
    c11e:	85 c0                	test   %eax,%eax
    c120:	0f 95 c0             	setne  %al
    c123:	0f b6 c0             	movzbl %al,%eax
    c126:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    c129:	ff 75 18             	pushl  0x18(%ebp)
    c12c:	e8 85 cd ff ff       	call   8eb6 <lodepng_can_have_alpha>
    c131:	83 c4 04             	add    $0x4,%esp
    c134:	85 c0                	test   %eax,%eax
    c136:	0f 94 c0             	sete   %al
    c139:	0f b6 c0             	movzbl %al,%eax
    c13c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    c13f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    c146:	ff 75 18             	pushl  0x18(%ebp)
    c149:	e8 ab cc ff ff       	call   8df9 <lodepng_get_bpp>
    c14e:	83 c4 04             	add    $0x4,%esp
    c151:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    c154:	8b 45 08             	mov    0x8(%ebp),%eax
    c157:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c15d:	83 f8 01             	cmp    $0x1,%eax
    c160:	75 0d                	jne    c16f <lodepng_compute_color_stats+0x7a>
    c162:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    c166:	75 07                	jne    c16f <lodepng_compute_color_stats+0x7a>
    c168:	b8 01 00 00 00       	mov    $0x1,%eax
    c16d:	eb 05                	jmp    c174 <lodepng_compute_color_stats+0x7f>
    c16f:	b8 00 00 00 00       	mov    $0x0,%eax
    c174:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    c177:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    c17e:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    c185:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    c189:	77 26                	ja     c1b1 <lodepng_compute_color_stats+0xbc>
    c18b:	8b 45 08             	mov    0x8(%ebp),%eax
    c18e:	8b 50 14             	mov    0x14(%eax),%edx
    c191:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c194:	bb 01 00 00 00       	mov    $0x1,%ebx
    c199:	89 c1                	mov    %eax,%ecx
    c19b:	d3 e3                	shl    %cl,%ebx
    c19d:	89 d8                	mov    %ebx,%eax
    c19f:	01 d0                	add    %edx,%eax
    c1a1:	ba 01 01 00 00       	mov    $0x101,%edx
    c1a6:	3d 01 01 00 00       	cmp    $0x101,%eax
    c1ab:	0f 47 c2             	cmova  %edx,%eax
    c1ae:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    c1b1:	8b 45 08             	mov    0x8(%ebp),%eax
    c1b4:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    c1ba:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c1bd:	01 c2                	add    %eax,%edx
    c1bf:	8b 45 08             	mov    0x8(%ebp),%eax
    c1c2:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    c1c8:	8b 45 08             	mov    0x8(%ebp),%eax
    c1cb:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    c1d1:	85 c0                	test   %eax,%eax
    c1d3:	75 07                	jne    c1dc <lodepng_compute_color_stats+0xe7>
    c1d5:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    c1dc:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c1e2:	50                   	push   %eax
    c1e3:	e8 81 da ff ff       	call   9c69 <color_tree_init>
    c1e8:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    c1eb:	8b 45 08             	mov    0x8(%ebp),%eax
    c1ee:	8b 40 10             	mov    0x10(%eax),%eax
    c1f1:	85 c0                	test   %eax,%eax
    c1f3:	74 07                	je     c1fc <lodepng_compute_color_stats+0x107>
    c1f5:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    c1fc:	8b 45 08             	mov    0x8(%ebp),%eax
    c1ff:	8b 00                	mov    (%eax),%eax
    c201:	85 c0                	test   %eax,%eax
    c203:	74 07                	je     c20c <lodepng_compute_color_stats+0x117>
    c205:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    c20c:	8b 45 08             	mov    0x8(%ebp),%eax
    c20f:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c215:	83 f8 10             	cmp    $0x10,%eax
    c218:	75 07                	jne    c221 <lodepng_compute_color_stats+0x12c>
    c21a:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    c221:	8b 45 08             	mov    0x8(%ebp),%eax
    c224:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c22a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c22d:	72 07                	jb     c236 <lodepng_compute_color_stats+0x141>
    c22f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    c236:	8b 45 08             	mov    0x8(%ebp),%eax
    c239:	8b 40 14             	mov    0x14(%eax),%eax
    c23c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c23f:	72 07                	jb     c248 <lodepng_compute_color_stats+0x153>
    c241:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    c248:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c24c:	0f 85 82 00 00 00    	jne    c2d4 <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    c252:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c259:	eb 6c                	jmp    c2c7 <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    c25b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c25e:	c1 e0 02             	shl    $0x2,%eax
    c261:	8d 50 10             	lea    0x10(%eax),%edx
    c264:	8b 45 08             	mov    0x8(%ebp),%eax
    c267:	01 d0                	add    %edx,%eax
    c269:	83 c0 08             	add    $0x8,%eax
    c26c:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    c26f:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c272:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c275:	83 c0 03             	add    $0x3,%eax
    c278:	0f b6 00             	movzbl (%eax),%eax
    c27b:	0f b6 d8             	movzbl %al,%ebx
    c27e:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c281:	83 c0 02             	add    $0x2,%eax
    c284:	0f b6 00             	movzbl (%eax),%eax
    c287:	0f b6 c8             	movzbl %al,%ecx
    c28a:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c28d:	83 c0 01             	add    $0x1,%eax
    c290:	0f b6 00             	movzbl (%eax),%eax
    c293:	0f b6 d0             	movzbl %al,%edx
    c296:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c299:	0f b6 00             	movzbl (%eax),%eax
    c29c:	0f b6 c0             	movzbl %al,%eax
    c29f:	83 ec 08             	sub    $0x8,%esp
    c2a2:	56                   	push   %esi
    c2a3:	53                   	push   %ebx
    c2a4:	51                   	push   %ecx
    c2a5:	52                   	push   %edx
    c2a6:	50                   	push   %eax
    c2a7:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c2ad:	50                   	push   %eax
    c2ae:	e8 39 db ff ff       	call   9dec <color_tree_add>
    c2b3:	83 c4 20             	add    $0x20,%esp
    c2b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    c2b9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c2bd:	0f 85 22 09 00 00    	jne    cbe5 <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    c2c3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c2c7:	8b 45 08             	mov    0x8(%ebp),%eax
    c2ca:	8b 50 14             	mov    0x14(%eax),%edx
    c2cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c2d0:	39 c2                	cmp    %eax,%edx
    c2d2:	77 87                	ja     c25b <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    c2d4:	8b 45 18             	mov    0x18(%ebp),%eax
    c2d7:	8b 40 04             	mov    0x4(%eax),%eax
    c2da:	83 f8 10             	cmp    $0x10,%eax
    c2dd:	0f 85 1e 01 00 00    	jne    c401 <lodepng_compute_color_stats+0x30c>
    c2e3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c2e7:	0f 85 14 01 00 00    	jne    c401 <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c2ed:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    c2f4:	00 00 
    c2f6:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    c2fd:	00 00 
    c2ff:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    c306:	00 00 
    c308:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    c30f:	00 00 
    for(i = 0; i != numpixels; ++i) {
    c311:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c318:	e9 d8 00 00 00       	jmp    c3f5 <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c31d:	83 ec 04             	sub    $0x4,%esp
    c320:	ff 75 18             	pushl  0x18(%ebp)
    c323:	ff 75 f4             	pushl  -0xc(%ebp)
    c326:	ff 75 0c             	pushl  0xc(%ebp)
    c329:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    c32f:	50                   	push   %eax
    c330:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    c336:	50                   	push   %eax
    c337:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    c33d:	50                   	push   %eax
    c33e:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    c344:	50                   	push   %eax
    c345:	e8 a8 f2 ff ff       	call   b5f2 <getPixelColorRGBA16>
    c34a:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c34d:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c354:	66 c1 e8 08          	shr    $0x8,%ax
    c358:	89 c2                	mov    %eax,%edx
    c35a:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c361:	31 d0                	xor    %edx,%eax
    c363:	0f b7 c0             	movzwl %ax,%eax
    c366:	0f b6 c0             	movzbl %al,%eax
    c369:	85 c0                	test   %eax,%eax
    c36b:	75 60                	jne    c3cd <lodepng_compute_color_stats+0x2d8>
    c36d:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c374:	66 c1 e8 08          	shr    $0x8,%ax
    c378:	89 c2                	mov    %eax,%edx
    c37a:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c381:	31 d0                	xor    %edx,%eax
    c383:	0f b7 c0             	movzwl %ax,%eax
    c386:	0f b6 c0             	movzbl %al,%eax
    c389:	85 c0                	test   %eax,%eax
    c38b:	75 40                	jne    c3cd <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c38d:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c394:	66 c1 e8 08          	shr    $0x8,%ax
    c398:	89 c2                	mov    %eax,%edx
    c39a:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c3a1:	31 d0                	xor    %edx,%eax
    c3a3:	0f b7 c0             	movzwl %ax,%eax
    c3a6:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c3a9:	85 c0                	test   %eax,%eax
    c3ab:	75 20                	jne    c3cd <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c3ad:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c3b4:	66 c1 e8 08          	shr    $0x8,%ax
    c3b8:	89 c2                	mov    %eax,%edx
    c3ba:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c3c1:	31 d0                	xor    %edx,%eax
    c3c3:	0f b7 c0             	movzwl %ax,%eax
    c3c6:	0f b6 c0             	movzbl %al,%eax
    c3c9:	85 c0                	test   %eax,%eax
    c3cb:	74 24                	je     c3f1 <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    c3cd:	8b 45 08             	mov    0x8(%ebp),%eax
    c3d0:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    c3d7:	00 00 00 
        sixteen = 1;
    c3da:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    c3e1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    c3e8:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    c3ef:	eb 10                	jmp    c401 <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    c3f1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c3f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c3f8:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c3fb:	0f 85 1c ff ff ff    	jne    c31d <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    c401:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c405:	0f 84 bd 02 00 00    	je     c6c8 <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c40b:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    c412:	00 00 
    c414:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    c41b:	00 00 
    c41d:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    c424:	00 00 
    c426:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    c42d:	00 00 

    for(i = 0; i != numpixels; ++i) {
    c42f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c436:	e9 b1 01 00 00       	jmp    c5ec <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c43b:	83 ec 04             	sub    $0x4,%esp
    c43e:	ff 75 18             	pushl  0x18(%ebp)
    c441:	ff 75 f4             	pushl  -0xc(%ebp)
    c444:	ff 75 0c             	pushl  0xc(%ebp)
    c447:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c44d:	50                   	push   %eax
    c44e:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c454:	50                   	push   %eax
    c455:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c45b:	50                   	push   %eax
    c45c:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c462:	50                   	push   %eax
    c463:	e8 8a f1 ff ff       	call   b5f2 <getPixelColorRGBA16>
    c468:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    c46b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c46f:	75 36                	jne    c4a7 <lodepng_compute_color_stats+0x3b2>
    c471:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c478:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c47f:	66 39 c2             	cmp    %ax,%dx
    c482:	75 13                	jne    c497 <lodepng_compute_color_stats+0x3a2>
    c484:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c48b:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c492:	66 39 c2             	cmp    %ax,%dx
    c495:	74 10                	je     c4a7 <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    c497:	8b 45 08             	mov    0x8(%ebp),%eax
    c49a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c4a0:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    c4a7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c4ab:	0f 85 1f 01 00 00    	jne    c5d0 <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c4b1:	8b 45 08             	mov    0x8(%ebp),%eax
    c4b4:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c4b8:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c4bf:	66 39 c2             	cmp    %ax,%dx
    c4c2:	75 2d                	jne    c4f1 <lodepng_compute_color_stats+0x3fc>
    c4c4:	8b 45 08             	mov    0x8(%ebp),%eax
    c4c7:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c4cb:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c4d2:	66 39 c2             	cmp    %ax,%dx
    c4d5:	75 1a                	jne    c4f1 <lodepng_compute_color_stats+0x3fc>
    c4d7:	8b 45 08             	mov    0x8(%ebp),%eax
    c4da:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c4de:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c4e5:	66 39 c2             	cmp    %ax,%dx
    c4e8:	75 07                	jne    c4f1 <lodepng_compute_color_stats+0x3fc>
    c4ea:	b8 01 00 00 00       	mov    $0x1,%eax
    c4ef:	eb 05                	jmp    c4f6 <lodepng_compute_color_stats+0x401>
    c4f1:	b8 00 00 00 00       	mov    $0x0,%eax
    c4f6:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    c4f9:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c500:	66 83 f8 ff          	cmp    $0xffff,%ax
    c504:	74 3c                	je     c542 <lodepng_compute_color_stats+0x44d>
    c506:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c50d:	66 85 c0             	test   %ax,%ax
    c510:	75 10                	jne    c522 <lodepng_compute_color_stats+0x42d>
    c512:	8b 45 08             	mov    0x8(%ebp),%eax
    c515:	8b 40 04             	mov    0x4(%eax),%eax
    c518:	85 c0                	test   %eax,%eax
    c51a:	74 26                	je     c542 <lodepng_compute_color_stats+0x44d>
    c51c:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c520:	75 20                	jne    c542 <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    c522:	8b 45 08             	mov    0x8(%ebp),%eax
    c525:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c52c:	8b 45 08             	mov    0x8(%ebp),%eax
    c52f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c536:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    c53d:	e9 8e 00 00 00       	jmp    c5d0 <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c542:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c549:	66 85 c0             	test   %ax,%ax
    c54c:	75 4a                	jne    c598 <lodepng_compute_color_stats+0x4a3>
    c54e:	8b 45 08             	mov    0x8(%ebp),%eax
    c551:	8b 40 10             	mov    0x10(%eax),%eax
    c554:	85 c0                	test   %eax,%eax
    c556:	75 40                	jne    c598 <lodepng_compute_color_stats+0x4a3>
    c558:	8b 45 08             	mov    0x8(%ebp),%eax
    c55b:	8b 40 04             	mov    0x4(%eax),%eax
    c55e:	85 c0                	test   %eax,%eax
    c560:	75 36                	jne    c598 <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    c562:	8b 45 08             	mov    0x8(%ebp),%eax
    c565:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c56c:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c573:	8b 45 08             	mov    0x8(%ebp),%eax
    c576:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c57a:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    c581:	8b 45 08             	mov    0x8(%ebp),%eax
    c584:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c588:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    c58f:	8b 45 08             	mov    0x8(%ebp),%eax
    c592:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c596:	eb 38                	jmp    c5d0 <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    c598:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c59f:	66 83 f8 ff          	cmp    $0xffff,%ax
    c5a3:	75 2b                	jne    c5d0 <lodepng_compute_color_stats+0x4db>
    c5a5:	8b 45 08             	mov    0x8(%ebp),%eax
    c5a8:	8b 40 04             	mov    0x4(%eax),%eax
    c5ab:	85 c0                	test   %eax,%eax
    c5ad:	74 21                	je     c5d0 <lodepng_compute_color_stats+0x4db>
    c5af:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c5b3:	74 1b                	je     c5d0 <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c5b5:	8b 45 08             	mov    0x8(%ebp),%eax
    c5b8:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c5bf:	8b 45 08             	mov    0x8(%ebp),%eax
    c5c2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c5c9:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c5d0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c5d4:	74 12                	je     c5e8 <lodepng_compute_color_stats+0x4f3>
    c5d6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c5da:	74 0c                	je     c5e8 <lodepng_compute_color_stats+0x4f3>
    c5dc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c5e0:	74 06                	je     c5e8 <lodepng_compute_color_stats+0x4f3>
    c5e2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c5e6:	75 12                	jne    c5fa <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    c5e8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c5ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c5ef:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c5f2:	0f 85 43 fe ff ff    	jne    c43b <lodepng_compute_color_stats+0x346>
    c5f8:	eb 01                	jmp    c5fb <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c5fa:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    c5fb:	8b 45 08             	mov    0x8(%ebp),%eax
    c5fe:	8b 40 04             	mov    0x4(%eax),%eax
    c601:	85 c0                	test   %eax,%eax
    c603:	0f 84 e0 05 00 00    	je     cbe9 <lodepng_compute_color_stats+0xaf4>
    c609:	8b 45 08             	mov    0x8(%ebp),%eax
    c60c:	8b 40 10             	mov    0x10(%eax),%eax
    c60f:	85 c0                	test   %eax,%eax
    c611:	0f 85 d2 05 00 00    	jne    cbe9 <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    c617:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c61e:	e9 94 00 00 00       	jmp    c6b7 <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c623:	83 ec 04             	sub    $0x4,%esp
    c626:	ff 75 18             	pushl  0x18(%ebp)
    c629:	ff 75 f4             	pushl  -0xc(%ebp)
    c62c:	ff 75 0c             	pushl  0xc(%ebp)
    c62f:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c635:	50                   	push   %eax
    c636:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c63c:	50                   	push   %eax
    c63d:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c643:	50                   	push   %eax
    c644:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c64a:	50                   	push   %eax
    c64b:	e8 a2 ef ff ff       	call   b5f2 <getPixelColorRGBA16>
    c650:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    c653:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c65a:	66 85 c0             	test   %ax,%ax
    c65d:	74 54                	je     c6b3 <lodepng_compute_color_stats+0x5be>
    c65f:	8b 45 08             	mov    0x8(%ebp),%eax
    c662:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c666:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c66d:	66 39 c2             	cmp    %ax,%dx
    c670:	75 41                	jne    c6b3 <lodepng_compute_color_stats+0x5be>
    c672:	8b 45 08             	mov    0x8(%ebp),%eax
    c675:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c679:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c680:	66 39 c2             	cmp    %ax,%dx
    c683:	75 2e                	jne    c6b3 <lodepng_compute_color_stats+0x5be>
    c685:	8b 45 08             	mov    0x8(%ebp),%eax
    c688:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c68c:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c693:	66 39 c2             	cmp    %ax,%dx
    c696:	75 1b                	jne    c6b3 <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c698:	8b 45 08             	mov    0x8(%ebp),%eax
    c69b:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c6a2:	8b 45 08             	mov    0x8(%ebp),%eax
    c6a5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c6ac:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    c6b3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c6b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c6ba:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c6bd:	0f 85 60 ff ff ff    	jne    c623 <lodepng_compute_color_stats+0x52e>
    c6c3:	e9 21 05 00 00       	jmp    cbe9 <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    c6c8:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    c6cf:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    c6d6:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    c6dd:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    c6e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c6eb:	e9 ab 03 00 00       	jmp    ca9b <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    c6f0:	83 ec 04             	sub    $0x4,%esp
    c6f3:	ff 75 18             	pushl  0x18(%ebp)
    c6f6:	ff 75 f4             	pushl  -0xc(%ebp)
    c6f9:	ff 75 0c             	pushl  0xc(%ebp)
    c6fc:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    c702:	50                   	push   %eax
    c703:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    c709:	50                   	push   %eax
    c70a:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    c710:	50                   	push   %eax
    c711:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    c717:	50                   	push   %eax
    c718:	e8 1e de ff ff       	call   a53b <getPixelColorRGBA8>
    c71d:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    c720:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c724:	75 41                	jne    c767 <lodepng_compute_color_stats+0x672>
    c726:	8b 45 08             	mov    0x8(%ebp),%eax
    c729:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c72f:	83 f8 07             	cmp    $0x7,%eax
    c732:	77 33                	ja     c767 <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    c734:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c73b:	0f b6 c0             	movzbl %al,%eax
    c73e:	83 ec 0c             	sub    $0xc,%esp
    c741:	50                   	push   %eax
    c742:	e8 1d f9 ff ff       	call   c064 <getValueRequiredBits>
    c747:	83 c4 10             	add    $0x10,%esp
    c74a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    c74d:	8b 45 08             	mov    0x8(%ebp),%eax
    c750:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c756:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    c759:	73 0c                	jae    c767 <lodepng_compute_color_stats+0x672>
    c75b:	8b 45 08             	mov    0x8(%ebp),%eax
    c75e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    c761:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    c767:	8b 45 08             	mov    0x8(%ebp),%eax
    c76a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c770:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c773:	0f 93 c0             	setae  %al
    c776:	0f b6 c0             	movzbl %al,%eax
    c779:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    c77c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c780:	75 4f                	jne    c7d1 <lodepng_compute_color_stats+0x6dc>
    c782:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c789:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c790:	38 c2                	cmp    %al,%dl
    c792:	75 12                	jne    c7a6 <lodepng_compute_color_stats+0x6b1>
    c794:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c79b:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c7a2:	38 c2                	cmp    %al,%dl
    c7a4:	74 2b                	je     c7d1 <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    c7a6:	8b 45 08             	mov    0x8(%ebp),%eax
    c7a9:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c7af:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    c7b6:	8b 45 08             	mov    0x8(%ebp),%eax
    c7b9:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c7bf:	83 f8 07             	cmp    $0x7,%eax
    c7c2:	77 0d                	ja     c7d1 <lodepng_compute_color_stats+0x6dc>
    c7c4:	8b 45 08             	mov    0x8(%ebp),%eax
    c7c7:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c7ce:	00 00 00 
      }

      if(!alpha_done) {
    c7d1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c7d5:	0f 85 65 01 00 00    	jne    c940 <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c7db:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c7e2:	0f b6 d0             	movzbl %al,%edx
    c7e5:	8b 45 08             	mov    0x8(%ebp),%eax
    c7e8:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c7ec:	66 39 c2             	cmp    %ax,%dx
    c7ef:	75 33                	jne    c824 <lodepng_compute_color_stats+0x72f>
    c7f1:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c7f8:	0f b6 d0             	movzbl %al,%edx
    c7fb:	8b 45 08             	mov    0x8(%ebp),%eax
    c7fe:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    c802:	66 39 c2             	cmp    %ax,%dx
    c805:	75 1d                	jne    c824 <lodepng_compute_color_stats+0x72f>
    c807:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c80e:	0f b6 d0             	movzbl %al,%edx
    c811:	8b 45 08             	mov    0x8(%ebp),%eax
    c814:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    c818:	66 39 c2             	cmp    %ax,%dx
    c81b:	75 07                	jne    c824 <lodepng_compute_color_stats+0x72f>
    c81d:	b8 01 00 00 00       	mov    $0x1,%eax
    c822:	eb 05                	jmp    c829 <lodepng_compute_color_stats+0x734>
    c824:	b8 00 00 00 00       	mov    $0x0,%eax
    c829:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    c82c:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c833:	3c ff                	cmp    $0xff,%al
    c835:	74 5a                	je     c891 <lodepng_compute_color_stats+0x79c>
    c837:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c83e:	84 c0                	test   %al,%al
    c840:	75 10                	jne    c852 <lodepng_compute_color_stats+0x75d>
    c842:	8b 45 08             	mov    0x8(%ebp),%eax
    c845:	8b 40 04             	mov    0x4(%eax),%eax
    c848:	85 c0                	test   %eax,%eax
    c84a:	74 45                	je     c891 <lodepng_compute_color_stats+0x79c>
    c84c:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c850:	75 3f                	jne    c891 <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    c852:	8b 45 08             	mov    0x8(%ebp),%eax
    c855:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c85c:	8b 45 08             	mov    0x8(%ebp),%eax
    c85f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c866:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c86d:	8b 45 08             	mov    0x8(%ebp),%eax
    c870:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c876:	83 f8 07             	cmp    $0x7,%eax
    c879:	0f 87 c1 00 00 00    	ja     c940 <lodepng_compute_color_stats+0x84b>
    c87f:	8b 45 08             	mov    0x8(%ebp),%eax
    c882:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c889:	00 00 00 
    c88c:	e9 af 00 00 00       	jmp    c940 <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c891:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c898:	84 c0                	test   %al,%al
    c89a:	75 53                	jne    c8ef <lodepng_compute_color_stats+0x7fa>
    c89c:	8b 45 08             	mov    0x8(%ebp),%eax
    c89f:	8b 40 10             	mov    0x10(%eax),%eax
    c8a2:	85 c0                	test   %eax,%eax
    c8a4:	75 49                	jne    c8ef <lodepng_compute_color_stats+0x7fa>
    c8a6:	8b 45 08             	mov    0x8(%ebp),%eax
    c8a9:	8b 40 04             	mov    0x4(%eax),%eax
    c8ac:	85 c0                	test   %eax,%eax
    c8ae:	75 3f                	jne    c8ef <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    c8b0:	8b 45 08             	mov    0x8(%ebp),%eax
    c8b3:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c8ba:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c8c1:	0f b6 d0             	movzbl %al,%edx
    c8c4:	8b 45 08             	mov    0x8(%ebp),%eax
    c8c7:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c8cb:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c8d2:	0f b6 d0             	movzbl %al,%edx
    c8d5:	8b 45 08             	mov    0x8(%ebp),%eax
    c8d8:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c8dc:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c8e3:	0f b6 d0             	movzbl %al,%edx
    c8e6:	8b 45 08             	mov    0x8(%ebp),%eax
    c8e9:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c8ed:	eb 51                	jmp    c940 <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    c8ef:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c8f6:	3c ff                	cmp    $0xff,%al
    c8f8:	75 46                	jne    c940 <lodepng_compute_color_stats+0x84b>
    c8fa:	8b 45 08             	mov    0x8(%ebp),%eax
    c8fd:	8b 40 04             	mov    0x4(%eax),%eax
    c900:	85 c0                	test   %eax,%eax
    c902:	74 3c                	je     c940 <lodepng_compute_color_stats+0x84b>
    c904:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c908:	74 36                	je     c940 <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c90a:	8b 45 08             	mov    0x8(%ebp),%eax
    c90d:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c914:	8b 45 08             	mov    0x8(%ebp),%eax
    c917:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c91e:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c925:	8b 45 08             	mov    0x8(%ebp),%eax
    c928:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c92e:	83 f8 07             	cmp    $0x7,%eax
    c931:	77 0d                	ja     c940 <lodepng_compute_color_stats+0x84b>
    c933:	8b 45 08             	mov    0x8(%ebp),%eax
    c936:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c93d:	00 00 00 
        }
      }

      if(!numcolors_done) {
    c940:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c944:	0f 85 35 01 00 00    	jne    ca7f <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    c94a:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c951:	0f b6 d8             	movzbl %al,%ebx
    c954:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c95b:	0f b6 c8             	movzbl %al,%ecx
    c95e:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c965:	0f b6 d0             	movzbl %al,%edx
    c968:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c96f:	0f b6 c0             	movzbl %al,%eax
    c972:	83 ec 0c             	sub    $0xc,%esp
    c975:	53                   	push   %ebx
    c976:	51                   	push   %ecx
    c977:	52                   	push   %edx
    c978:	50                   	push   %eax
    c979:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c97f:	50                   	push   %eax
    c980:	e8 1c d4 ff ff       	call   9da1 <color_tree_has>
    c985:	83 c4 20             	add    $0x20,%esp
    c988:	85 c0                	test   %eax,%eax
    c98a:	0f 85 ef 00 00 00    	jne    ca7f <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    c990:	8b 45 08             	mov    0x8(%ebp),%eax
    c993:	8b 70 14             	mov    0x14(%eax),%esi
    c996:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c99d:	0f b6 d8             	movzbl %al,%ebx
    c9a0:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c9a7:	0f b6 c8             	movzbl %al,%ecx
    c9aa:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c9b1:	0f b6 d0             	movzbl %al,%edx
    c9b4:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c9bb:	0f b6 c0             	movzbl %al,%eax
    c9be:	83 ec 08             	sub    $0x8,%esp
    c9c1:	56                   	push   %esi
    c9c2:	53                   	push   %ebx
    c9c3:	51                   	push   %ecx
    c9c4:	52                   	push   %edx
    c9c5:	50                   	push   %eax
    c9c6:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c9cc:	50                   	push   %eax
    c9cd:	e8 1a d4 ff ff       	call   9dec <color_tree_add>
    c9d2:	83 c4 20             	add    $0x20,%esp
    c9d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    c9d8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c9dc:	0f 85 06 02 00 00    	jne    cbe8 <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    c9e2:	8b 45 08             	mov    0x8(%ebp),%eax
    c9e5:	8b 40 14             	mov    0x14(%eax),%eax
    c9e8:	3d ff 00 00 00       	cmp    $0xff,%eax
    c9ed:	77 6f                	ja     ca5e <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    c9ef:	8b 45 08             	mov    0x8(%ebp),%eax
    c9f2:	83 c0 18             	add    $0x18,%eax
    c9f5:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    c9f8:	8b 45 08             	mov    0x8(%ebp),%eax
    c9fb:	8b 40 14             	mov    0x14(%eax),%eax
    c9fe:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    ca01:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca04:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ca0b:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca0e:	01 c2                	add    %eax,%edx
    ca10:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca17:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    ca19:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca1c:	c1 e0 02             	shl    $0x2,%eax
    ca1f:	8d 50 01             	lea    0x1(%eax),%edx
    ca22:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca25:	01 c2                	add    %eax,%edx
    ca27:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ca2e:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    ca30:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca33:	c1 e0 02             	shl    $0x2,%eax
    ca36:	8d 50 02             	lea    0x2(%eax),%edx
    ca39:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca3c:	01 c2                	add    %eax,%edx
    ca3e:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ca45:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    ca47:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca4a:	c1 e0 02             	shl    $0x2,%eax
    ca4d:	8d 50 03             	lea    0x3(%eax),%edx
    ca50:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca53:	01 c2                	add    %eax,%edx
    ca55:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ca5c:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    ca5e:	8b 45 08             	mov    0x8(%ebp),%eax
    ca61:	8b 40 14             	mov    0x14(%eax),%eax
    ca64:	8d 50 01             	lea    0x1(%eax),%edx
    ca67:	8b 45 08             	mov    0x8(%ebp),%eax
    ca6a:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    ca6d:	8b 45 08             	mov    0x8(%ebp),%eax
    ca70:	8b 40 14             	mov    0x14(%eax),%eax
    ca73:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ca76:	0f 93 c0             	setae  %al
    ca79:	0f b6 c0             	movzbl %al,%eax
    ca7c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    ca7f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ca83:	74 12                	je     ca97 <lodepng_compute_color_stats+0x9a2>
    ca85:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ca89:	74 0c                	je     ca97 <lodepng_compute_color_stats+0x9a2>
    ca8b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ca8f:	74 06                	je     ca97 <lodepng_compute_color_stats+0x9a2>
    ca91:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ca95:	75 12                	jne    caa9 <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    ca97:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ca9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ca9e:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    caa1:	0f 85 49 fc ff ff    	jne    c6f0 <lodepng_compute_color_stats+0x5fb>
    caa7:	eb 01                	jmp    caaa <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    caa9:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    caaa:	8b 45 08             	mov    0x8(%ebp),%eax
    caad:	8b 40 04             	mov    0x4(%eax),%eax
    cab0:	85 c0                	test   %eax,%eax
    cab2:	0f 84 dd 00 00 00    	je     cb95 <lodepng_compute_color_stats+0xaa0>
    cab8:	8b 45 08             	mov    0x8(%ebp),%eax
    cabb:	8b 40 10             	mov    0x10(%eax),%eax
    cabe:	85 c0                	test   %eax,%eax
    cac0:	0f 85 cf 00 00 00    	jne    cb95 <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    cac6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cacd:	e9 b7 00 00 00       	jmp    cb89 <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    cad2:	83 ec 04             	sub    $0x4,%esp
    cad5:	ff 75 18             	pushl  0x18(%ebp)
    cad8:	ff 75 f4             	pushl  -0xc(%ebp)
    cadb:	ff 75 0c             	pushl  0xc(%ebp)
    cade:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    cae4:	50                   	push   %eax
    cae5:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    caeb:	50                   	push   %eax
    caec:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    caf2:	50                   	push   %eax
    caf3:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    caf9:	50                   	push   %eax
    cafa:	e8 3c da ff ff       	call   a53b <getPixelColorRGBA8>
    caff:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    cb02:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cb09:	84 c0                	test   %al,%al
    cb0b:	74 78                	je     cb85 <lodepng_compute_color_stats+0xa90>
    cb0d:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cb14:	0f b6 d0             	movzbl %al,%edx
    cb17:	8b 45 08             	mov    0x8(%ebp),%eax
    cb1a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cb1e:	66 39 c2             	cmp    %ax,%dx
    cb21:	75 62                	jne    cb85 <lodepng_compute_color_stats+0xa90>
    cb23:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cb2a:	0f b6 d0             	movzbl %al,%edx
    cb2d:	8b 45 08             	mov    0x8(%ebp),%eax
    cb30:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cb34:	66 39 c2             	cmp    %ax,%dx
    cb37:	75 4c                	jne    cb85 <lodepng_compute_color_stats+0xa90>
    cb39:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cb40:	0f b6 d0             	movzbl %al,%edx
    cb43:	8b 45 08             	mov    0x8(%ebp),%eax
    cb46:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cb4a:	66 39 c2             	cmp    %ax,%dx
    cb4d:	75 36                	jne    cb85 <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cb4f:	8b 45 08             	mov    0x8(%ebp),%eax
    cb52:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cb59:	8b 45 08             	mov    0x8(%ebp),%eax
    cb5c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cb63:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cb6a:	8b 45 08             	mov    0x8(%ebp),%eax
    cb6d:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cb73:	83 f8 07             	cmp    $0x7,%eax
    cb76:	77 0d                	ja     cb85 <lodepng_compute_color_stats+0xa90>
    cb78:	8b 45 08             	mov    0x8(%ebp),%eax
    cb7b:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cb82:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    cb85:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cb89:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cb8c:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cb8f:	0f 85 3d ff ff ff    	jne    cad2 <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    cb95:	8b 45 08             	mov    0x8(%ebp),%eax
    cb98:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    cb9c:	8b 45 08             	mov    0x8(%ebp),%eax
    cb9f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cba3:	c1 e0 08             	shl    $0x8,%eax
    cba6:	01 c2                	add    %eax,%edx
    cba8:	8b 45 08             	mov    0x8(%ebp),%eax
    cbab:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    cbaf:	8b 45 08             	mov    0x8(%ebp),%eax
    cbb2:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    cbb6:	8b 45 08             	mov    0x8(%ebp),%eax
    cbb9:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cbbd:	c1 e0 08             	shl    $0x8,%eax
    cbc0:	01 c2                	add    %eax,%edx
    cbc2:	8b 45 08             	mov    0x8(%ebp),%eax
    cbc5:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    cbc9:	8b 45 08             	mov    0x8(%ebp),%eax
    cbcc:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    cbd0:	8b 45 08             	mov    0x8(%ebp),%eax
    cbd3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cbd7:	c1 e0 08             	shl    $0x8,%eax
    cbda:	01 c2                	add    %eax,%edx
    cbdc:	8b 45 08             	mov    0x8(%ebp),%eax
    cbdf:	66 89 50 0c          	mov    %dx,0xc(%eax)
    cbe3:	eb 04                	jmp    cbe9 <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    cbe5:	90                   	nop
    cbe6:	eb 01                	jmp    cbe9 <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    cbe8:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    cbe9:	83 ec 0c             	sub    $0xc,%esp
    cbec:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cbf2:	50                   	push   %eax
    cbf3:	e8 91 d0 ff ff       	call   9c89 <color_tree_cleanup>
    cbf8:	83 c4 10             	add    $0x10,%esp
  return error;
    cbfb:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    cbfe:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cc01:	5b                   	pop    %ebx
    cc02:	5e                   	pop    %esi
    cc03:	5d                   	pop    %ebp
    cc04:	c3                   	ret    

0000cc05 <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    cc05:	55                   	push   %ebp
    cc06:	89 e5                	mov    %esp,%ebp
    cc08:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    cc0b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    cc12:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cc15:	50                   	push   %eax
    cc16:	e8 d1 bd ff ff       	call   89ec <lodepng_color_mode_init>
    cc1b:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    cc1e:	8b 45 0c             	mov    0xc(%ebp),%eax
    cc21:	c1 e8 08             	shr    $0x8,%eax
    cc24:	88 45 ec             	mov    %al,-0x14(%ebp)
    cc27:	8b 45 0c             	mov    0xc(%ebp),%eax
    cc2a:	88 45 ed             	mov    %al,-0x13(%ebp)
    cc2d:	8b 45 10             	mov    0x10(%ebp),%eax
    cc30:	c1 e8 08             	shr    $0x8,%eax
    cc33:	88 45 ee             	mov    %al,-0x12(%ebp)
    cc36:	8b 45 10             	mov    0x10(%ebp),%eax
    cc39:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    cc3c:	8b 45 14             	mov    0x14(%ebp),%eax
    cc3f:	c1 e8 08             	shr    $0x8,%eax
    cc42:	88 45 f0             	mov    %al,-0x10(%ebp)
    cc45:	8b 45 14             	mov    0x14(%ebp),%eax
    cc48:	88 45 f1             	mov    %al,-0xf(%ebp)
    cc4b:	8b 45 18             	mov    0x18(%ebp),%eax
    cc4e:	c1 e8 08             	shr    $0x8,%eax
    cc51:	88 45 f2             	mov    %al,-0xe(%ebp)
    cc54:	8b 45 18             	mov    0x18(%ebp),%eax
    cc57:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    cc5a:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    cc61:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    cc68:	83 ec 0c             	sub    $0xc,%esp
    cc6b:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cc6e:	50                   	push   %eax
    cc6f:	6a 01                	push   $0x1
    cc71:	6a 01                	push   $0x1
    cc73:	8d 45 ec             	lea    -0x14(%ebp),%eax
    cc76:	50                   	push   %eax
    cc77:	ff 75 08             	pushl  0x8(%ebp)
    cc7a:	e8 76 f4 ff ff       	call   c0f5 <lodepng_compute_color_stats>
    cc7f:	83 c4 20             	add    $0x20,%esp
    cc82:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    cc85:	83 ec 0c             	sub    $0xc,%esp
    cc88:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cc8b:	50                   	push   %eax
    cc8c:	e8 4e be ff ff       	call   8adf <lodepng_color_mode_cleanup>
    cc91:	83 c4 10             	add    $0x10,%esp
  return error;
    cc94:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    cc97:	c9                   	leave  
    cc98:	c3                   	ret    

0000cc99 <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    cc99:	55                   	push   %ebp
    cc9a:	89 e5                	mov    %esp,%ebp
    cc9c:	56                   	push   %esi
    cc9d:	53                   	push   %ebx
    cc9e:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    cca1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    cca8:	8b 45 10             	mov    0x10(%ebp),%eax
    ccab:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    ccb1:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    ccb4:	8b 45 10             	mov    0x10(%ebp),%eax
    ccb7:	8b 40 10             	mov    0x10(%eax),%eax
    ccba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    ccbd:	8b 45 10             	mov    0x10(%ebp),%eax
    ccc0:	8b 40 04             	mov    0x4(%eax),%eax
    ccc3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    ccc6:	8b 45 10             	mov    0x10(%ebp),%eax
    ccc9:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cccf:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    ccd2:	8b 45 08             	mov    0x8(%ebp),%eax
    ccd5:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    ccdc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cce0:	74 21                	je     cd03 <auto_choose_color+0x6a>
    cce2:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    cce6:	7f 1b                	jg     cd03 <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    cce8:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    ccef:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    ccf6:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    ccfa:	77 07                	ja     cd03 <auto_choose_color+0x6a>
    ccfc:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    cd03:	8b 45 10             	mov    0x10(%ebp),%eax
    cd06:	8b 00                	mov    (%eax),%eax
    cd08:	85 c0                	test   %eax,%eax
    cd0a:	0f 94 c0             	sete   %al
    cd0d:	0f b6 c0             	movzbl %al,%eax
    cd10:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    cd13:	8b 45 10             	mov    0x10(%ebp),%eax
    cd16:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    cd1c:	85 c0                	test   %eax,%eax
    cd1e:	75 07                	jne    cd27 <auto_choose_color+0x8e>
    cd20:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    cd27:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cd2b:	75 0d                	jne    cd3a <auto_choose_color+0xa1>
    cd2d:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    cd31:	77 07                	ja     cd3a <auto_choose_color+0xa1>
    cd33:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    cd3a:	8b 45 10             	mov    0x10(%ebp),%eax
    cd3d:	8b 40 14             	mov    0x14(%eax),%eax
    cd40:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    cd43:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    cd47:	7e 21                	jle    cd6a <auto_choose_color+0xd1>
    cd49:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    cd4d:	7e 14                	jle    cd63 <auto_choose_color+0xca>
    cd4f:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    cd53:	7f 07                	jg     cd5c <auto_choose_color+0xc3>
    cd55:	b8 04 00 00 00       	mov    $0x4,%eax
    cd5a:	eb 13                	jmp    cd6f <auto_choose_color+0xd6>
    cd5c:	b8 08 00 00 00       	mov    $0x8,%eax
    cd61:	eb 0c                	jmp    cd6f <auto_choose_color+0xd6>
    cd63:	b8 02 00 00 00       	mov    $0x2,%eax
    cd68:	eb 05                	jmp    cd6f <auto_choose_color+0xd6>
    cd6a:	b8 01 00 00 00       	mov    $0x1,%eax
    cd6f:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    cd72:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    cd79:	7f 13                	jg     cd8e <auto_choose_color+0xf5>
    cd7b:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    cd7f:	77 0d                	ja     cd8e <auto_choose_color+0xf5>
    cd81:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    cd85:	74 07                	je     cd8e <auto_choose_color+0xf5>
    cd87:	b8 01 00 00 00       	mov    $0x1,%eax
    cd8c:	eb 05                	jmp    cd93 <auto_choose_color+0xfa>
    cd8e:	b8 00 00 00 00       	mov    $0x0,%eax
    cd93:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    cd96:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cd99:	01 c0                	add    %eax,%eax
    cd9b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cd9e:	7e 07                	jle    cda7 <auto_choose_color+0x10e>
    cda0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    cda7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cdab:	74 15                	je     cdc2 <auto_choose_color+0x129>
    cdad:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cdb1:	75 0f                	jne    cdc2 <auto_choose_color+0x129>
    cdb3:	8b 45 dc             	mov    -0x24(%ebp),%eax
    cdb6:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    cdb9:	77 07                	ja     cdc2 <auto_choose_color+0x129>
    cdbb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    cdc2:	8b 45 10             	mov    0x10(%ebp),%eax
    cdc5:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    cdcb:	85 c0                	test   %eax,%eax
    cdcd:	75 07                	jne    cdd6 <auto_choose_color+0x13d>
    cdcf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    cdd6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cdda:	0f 84 0a 01 00 00    	je     ceea <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    cde0:	8b 45 10             	mov    0x10(%ebp),%eax
    cde3:	83 c0 18             	add    $0x18,%eax
    cde6:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    cde9:	83 ec 0c             	sub    $0xc,%esp
    cdec:	ff 75 08             	pushl  0x8(%ebp)
    cdef:	e8 ef be ff ff       	call   8ce3 <lodepng_palette_clear>
    cdf4:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    cdf7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    cdfe:	eb 6e                	jmp    ce6e <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    ce00:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce03:	c1 e0 02             	shl    $0x2,%eax
    ce06:	8d 50 03             	lea    0x3(%eax),%edx
    ce09:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce0c:	01 d0                	add    %edx,%eax
    ce0e:	0f b6 00             	movzbl (%eax),%eax
    ce11:	0f b6 d8             	movzbl %al,%ebx
    ce14:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce17:	c1 e0 02             	shl    $0x2,%eax
    ce1a:	8d 50 02             	lea    0x2(%eax),%edx
    ce1d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce20:	01 d0                	add    %edx,%eax
    ce22:	0f b6 00             	movzbl (%eax),%eax
    ce25:	0f b6 c8             	movzbl %al,%ecx
    ce28:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce2b:	c1 e0 02             	shl    $0x2,%eax
    ce2e:	8d 50 01             	lea    0x1(%eax),%edx
    ce31:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce34:	01 d0                	add    %edx,%eax
    ce36:	0f b6 00             	movzbl (%eax),%eax
    ce39:	0f b6 d0             	movzbl %al,%edx
    ce3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce3f:	c1 e0 02             	shl    $0x2,%eax
    ce42:	89 c6                	mov    %eax,%esi
    ce44:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce47:	01 f0                	add    %esi,%eax
    ce49:	0f b6 00             	movzbl (%eax),%eax
    ce4c:	0f b6 c0             	movzbl %al,%eax
    ce4f:	83 ec 0c             	sub    $0xc,%esp
    ce52:	53                   	push   %ebx
    ce53:	51                   	push   %ecx
    ce54:	52                   	push   %edx
    ce55:	50                   	push   %eax
    ce56:	ff 75 08             	pushl  0x8(%ebp)
    ce59:	e8 be be ff ff       	call   8d1c <lodepng_palette_add>
    ce5e:	83 c4 20             	add    $0x20,%esp
    ce61:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    ce64:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ce68:	75 13                	jne    ce7d <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    ce6a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ce6e:	8b 45 10             	mov    0x10(%ebp),%eax
    ce71:	8b 50 14             	mov    0x14(%eax),%edx
    ce74:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce77:	39 c2                	cmp    %eax,%edx
    ce79:	75 85                	jne    ce00 <auto_choose_color+0x167>
    ce7b:	eb 01                	jmp    ce7e <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    ce7d:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    ce7e:	8b 45 08             	mov    0x8(%ebp),%eax
    ce81:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    ce87:	8b 45 08             	mov    0x8(%ebp),%eax
    ce8a:	8b 55 d0             	mov    -0x30(%ebp),%edx
    ce8d:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    ce90:	8b 45 0c             	mov    0xc(%ebp),%eax
    ce93:	8b 00                	mov    (%eax),%eax
    ce95:	83 f8 03             	cmp    $0x3,%eax
    ce98:	0f 85 ec 00 00 00    	jne    cf8a <auto_choose_color+0x2f1>
    ce9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    cea1:	8b 50 0c             	mov    0xc(%eax),%edx
    cea4:	8b 45 08             	mov    0x8(%ebp),%eax
    cea7:	8b 40 0c             	mov    0xc(%eax),%eax
    ceaa:	39 c2                	cmp    %eax,%edx
    ceac:	0f 8c d8 00 00 00    	jl     cf8a <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    ceb2:	8b 45 0c             	mov    0xc(%ebp),%eax
    ceb5:	8b 50 04             	mov    0x4(%eax),%edx
    ceb8:	8b 45 08             	mov    0x8(%ebp),%eax
    cebb:	8b 40 04             	mov    0x4(%eax),%eax
    cebe:	39 c2                	cmp    %eax,%edx
    cec0:	0f 85 c4 00 00 00    	jne    cf8a <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    cec6:	83 ec 0c             	sub    $0xc,%esp
    cec9:	ff 75 08             	pushl  0x8(%ebp)
    cecc:	e8 0e bc ff ff       	call   8adf <lodepng_color_mode_cleanup>
    ced1:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    ced4:	83 ec 08             	sub    $0x8,%esp
    ced7:	ff 75 0c             	pushl  0xc(%ebp)
    ceda:	ff 75 08             	pushl  0x8(%ebp)
    cedd:	e8 14 bc ff ff       	call   8af6 <lodepng_color_mode_copy>
    cee2:	83 c4 10             	add    $0x10,%esp
    cee5:	e9 a0 00 00 00       	jmp    cf8a <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    ceea:	8b 45 08             	mov    0x8(%ebp),%eax
    ceed:	8b 55 dc             	mov    -0x24(%ebp),%edx
    cef0:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    cef3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cef7:	74 14                	je     cf0d <auto_choose_color+0x274>
    cef9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cefd:	74 07                	je     cf06 <auto_choose_color+0x26d>
    ceff:	b8 04 00 00 00       	mov    $0x4,%eax
    cf04:	eb 19                	jmp    cf1f <auto_choose_color+0x286>
    cf06:	b8 06 00 00 00       	mov    $0x6,%eax
    cf0b:	eb 12                	jmp    cf1f <auto_choose_color+0x286>
    cf0d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cf11:	74 07                	je     cf1a <auto_choose_color+0x281>
    cf13:	b8 00 00 00 00       	mov    $0x0,%eax
    cf18:	eb 05                	jmp    cf1f <auto_choose_color+0x286>
    cf1a:	b8 02 00 00 00       	mov    $0x2,%eax
    cf1f:	8b 55 08             	mov    0x8(%ebp),%edx
    cf22:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    cf24:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cf28:	74 60                	je     cf8a <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    cf2a:	8b 45 08             	mov    0x8(%ebp),%eax
    cf2d:	8b 40 04             	mov    0x4(%eax),%eax
    cf30:	ba 01 00 00 00       	mov    $0x1,%edx
    cf35:	89 c1                	mov    %eax,%ecx
    cf37:	d3 e2                	shl    %cl,%edx
    cf39:	89 d0                	mov    %edx,%eax
    cf3b:	83 e8 01             	sub    $0x1,%eax
    cf3e:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    cf41:	8b 45 10             	mov    0x10(%ebp),%eax
    cf44:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cf48:	0f b7 c0             	movzwl %ax,%eax
    cf4b:	23 45 c8             	and    -0x38(%ebp),%eax
    cf4e:	89 c2                	mov    %eax,%edx
    cf50:	8b 45 08             	mov    0x8(%ebp),%eax
    cf53:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    cf56:	8b 45 10             	mov    0x10(%ebp),%eax
    cf59:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cf5d:	0f b7 c0             	movzwl %ax,%eax
    cf60:	23 45 c8             	and    -0x38(%ebp),%eax
    cf63:	89 c2                	mov    %eax,%edx
    cf65:	8b 45 08             	mov    0x8(%ebp),%eax
    cf68:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    cf6b:	8b 45 10             	mov    0x10(%ebp),%eax
    cf6e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cf72:	0f b7 c0             	movzwl %ax,%eax
    cf75:	23 45 c8             	and    -0x38(%ebp),%eax
    cf78:	89 c2                	mov    %eax,%edx
    cf7a:	8b 45 08             	mov    0x8(%ebp),%eax
    cf7d:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    cf80:	8b 45 08             	mov    0x8(%ebp),%eax
    cf83:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    cf8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    cf8d:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cf90:	5b                   	pop    %ebx
    cf91:	5e                   	pop    %esi
    cf92:	5d                   	pop    %ebp
    cf93:	c3                   	ret    

0000cf94 <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    cf94:	55                   	push   %ebp
    cf95:	89 e5                	mov    %esp,%ebp
    cf97:	83 ec 1c             	sub    $0x1c,%esp
    cf9a:	8b 4d 08             	mov    0x8(%ebp),%ecx
    cf9d:	8b 55 0c             	mov    0xc(%ebp),%edx
    cfa0:	8b 45 10             	mov    0x10(%ebp),%eax
    cfa3:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    cfa7:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    cfab:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    cfaf:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    cfb3:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    cfb7:	29 c2                	sub    %eax,%edx
    cfb9:	89 d0                	mov    %edx,%eax
    cfbb:	99                   	cltd   
    cfbc:	31 d0                	xor    %edx,%eax
    cfbe:	29 d0                	sub    %edx,%eax
    cfc0:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    cfc4:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    cfc8:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    cfcc:	29 c2                	sub    %eax,%edx
    cfce:	89 d0                	mov    %edx,%eax
    cfd0:	99                   	cltd   
    cfd1:	31 d0                	xor    %edx,%eax
    cfd3:	29 d0                	sub    %edx,%eax
    cfd5:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    cfd9:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    cfdd:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    cfe1:	01 c2                	add    %eax,%edx
    cfe3:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    cfe7:	29 c2                	sub    %eax,%edx
    cfe9:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    cfed:	29 c2                	sub    %eax,%edx
    cfef:	89 d0                	mov    %edx,%eax
    cff1:	99                   	cltd   
    cff2:	31 d0                	xor    %edx,%eax
    cff4:	29 d0                	sub    %edx,%eax
    cff6:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    cffa:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    cffe:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d002:	7d 10                	jge    d014 <paethPredictor+0x80>
    d004:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    d008:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    d00c:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d010:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    d014:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    d018:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d01c:	7d 06                	jge    d024 <paethPredictor+0x90>
    d01e:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    d022:	eb 04                	jmp    d028 <paethPredictor+0x94>
    d024:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    d028:	c9                   	leave  
    d029:	c3                   	ret    

0000d02a <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    d02a:	55                   	push   %ebp
    d02b:	89 e5                	mov    %esp,%ebp
    d02d:	56                   	push   %esi
    d02e:	53                   	push   %ebx
    d02f:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d032:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d039:	e9 e2 00 00 00       	jmp    d120 <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    d03e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d041:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d048:	8b 45 08             	mov    0x8(%ebp),%eax
    d04b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d04e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d051:	8b 14 85 b4 9f 01 00 	mov    0x19fb4(,%eax,4),%edx
    d058:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d05b:	01 c2                	add    %eax,%edx
    d05d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d060:	8b 04 85 7c 9f 01 00 	mov    0x19f7c(,%eax,4),%eax
    d067:	29 c2                	sub    %eax,%edx
    d069:	89 d0                	mov    %edx,%eax
    d06b:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d06e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d071:	8b 34 85 b4 9f 01 00 	mov    0x19fb4(,%eax,4),%esi
    d078:	89 d8                	mov    %ebx,%eax
    d07a:	ba 00 00 00 00       	mov    $0x0,%edx
    d07f:	f7 f6                	div    %esi
    d081:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    d083:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d086:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d08d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d090:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d093:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d096:	8b 14 85 d0 9f 01 00 	mov    0x19fd0(,%eax,4),%edx
    d09d:	8b 45 20             	mov    0x20(%ebp),%eax
    d0a0:	01 c2                	add    %eax,%edx
    d0a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0a5:	8b 04 85 98 9f 01 00 	mov    0x19f98(,%eax,4),%eax
    d0ac:	29 c2                	sub    %eax,%edx
    d0ae:	89 d0                	mov    %edx,%eax
    d0b0:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d0b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0b6:	8b 34 85 d0 9f 01 00 	mov    0x19fd0(,%eax,4),%esi
    d0bd:	89 d8                	mov    %ebx,%eax
    d0bf:	ba 00 00 00 00       	mov    $0x0,%edx
    d0c4:	f7 f6                	div    %esi
    d0c6:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    d0c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0cb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d0d2:	8b 45 08             	mov    0x8(%ebp),%eax
    d0d5:	01 d0                	add    %edx,%eax
    d0d7:	8b 00                	mov    (%eax),%eax
    d0d9:	85 c0                	test   %eax,%eax
    d0db:	75 15                	jne    d0f2 <Adam7_getpassvalues+0xc8>
    d0dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0e0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d0e7:	8b 45 0c             	mov    0xc(%ebp),%eax
    d0ea:	01 d0                	add    %edx,%eax
    d0ec:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    d0f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0f5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d0fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    d0ff:	01 d0                	add    %edx,%eax
    d101:	8b 00                	mov    (%eax),%eax
    d103:	85 c0                	test   %eax,%eax
    d105:	75 15                	jne    d11c <Adam7_getpassvalues+0xf2>
    d107:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d10a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d111:	8b 45 08             	mov    0x8(%ebp),%eax
    d114:	01 d0                	add    %edx,%eax
    d116:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d11c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d120:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d124:	0f 85 14 ff ff ff    	jne    d03e <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    d12a:	8b 45 18             	mov    0x18(%ebp),%eax
    d12d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d133:	8b 45 18             	mov    0x18(%ebp),%eax
    d136:	8b 10                	mov    (%eax),%edx
    d138:	8b 45 14             	mov    0x14(%ebp),%eax
    d13b:	89 10                	mov    %edx,(%eax)
    d13d:	8b 45 14             	mov    0x14(%ebp),%eax
    d140:	8b 10                	mov    (%eax),%edx
    d142:	8b 45 10             	mov    0x10(%ebp),%eax
    d145:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    d147:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d14e:	e9 40 01 00 00       	jmp    d293 <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d153:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d156:	83 c0 01             	add    $0x1,%eax
    d159:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d160:	8b 45 10             	mov    0x10(%ebp),%eax
    d163:	01 c2                	add    %eax,%edx
    d165:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d168:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d16f:	8b 45 10             	mov    0x10(%ebp),%eax
    d172:	01 c8                	add    %ecx,%eax
    d174:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    d176:	89 c6                	mov    %eax,%esi
    d178:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d17b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d182:	8b 45 08             	mov    0x8(%ebp),%eax
    d185:	01 c8                	add    %ecx,%eax
    d187:	8b 00                	mov    (%eax),%eax
    d189:	85 c0                	test   %eax,%eax
    d18b:	74 49                	je     d1d6 <Adam7_getpassvalues+0x1ac>
    d18d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d190:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d197:	8b 45 0c             	mov    0xc(%ebp),%eax
    d19a:	01 c8                	add    %ecx,%eax
    d19c:	8b 00                	mov    (%eax),%eax
    d19e:	85 c0                	test   %eax,%eax
    d1a0:	74 34                	je     d1d6 <Adam7_getpassvalues+0x1ac>
    d1a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1a5:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1af:	01 c8                	add    %ecx,%eax
    d1b1:	8b 08                	mov    (%eax),%ecx
    d1b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1b6:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d1bd:	8b 45 08             	mov    0x8(%ebp),%eax
    d1c0:	01 d8                	add    %ebx,%eax
    d1c2:	8b 00                	mov    (%eax),%eax
    d1c4:	0f af 45 24          	imul   0x24(%ebp),%eax
    d1c8:	83 c0 07             	add    $0x7,%eax
    d1cb:	c1 e8 03             	shr    $0x3,%eax
    d1ce:	83 c0 01             	add    $0x1,%eax
    d1d1:	0f af c1             	imul   %ecx,%eax
    d1d4:	eb 05                	jmp    d1db <Adam7_getpassvalues+0x1b1>
    d1d6:	b8 00 00 00 00       	mov    $0x0,%eax
    d1db:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d1dd:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    d1df:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1e2:	83 c0 01             	add    $0x1,%eax
    d1e5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1ec:	8b 45 14             	mov    0x14(%ebp),%eax
    d1ef:	01 c2                	add    %eax,%edx
    d1f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1f4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1fb:	8b 45 14             	mov    0x14(%ebp),%eax
    d1fe:	01 c8                	add    %ecx,%eax
    d200:	8b 00                	mov    (%eax),%eax
    d202:	89 c6                	mov    %eax,%esi
    d204:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d207:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d20e:	8b 45 0c             	mov    0xc(%ebp),%eax
    d211:	01 c8                	add    %ecx,%eax
    d213:	8b 08                	mov    (%eax),%ecx
    d215:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d218:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d21f:	8b 45 08             	mov    0x8(%ebp),%eax
    d222:	01 d8                	add    %ebx,%eax
    d224:	8b 00                	mov    (%eax),%eax
    d226:	0f af 45 24          	imul   0x24(%ebp),%eax
    d22a:	83 c0 07             	add    $0x7,%eax
    d22d:	c1 e8 03             	shr    $0x3,%eax
    d230:	0f af c1             	imul   %ecx,%eax
    d233:	01 f0                	add    %esi,%eax
    d235:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    d237:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d23a:	83 c0 01             	add    $0x1,%eax
    d23d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d244:	8b 45 18             	mov    0x18(%ebp),%eax
    d247:	01 c2                	add    %eax,%edx
    d249:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d24c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d253:	8b 45 18             	mov    0x18(%ebp),%eax
    d256:	01 c8                	add    %ecx,%eax
    d258:	8b 00                	mov    (%eax),%eax
    d25a:	89 c6                	mov    %eax,%esi
    d25c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d25f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d266:	8b 45 0c             	mov    0xc(%ebp),%eax
    d269:	01 c8                	add    %ecx,%eax
    d26b:	8b 08                	mov    (%eax),%ecx
    d26d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d270:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d277:	8b 45 08             	mov    0x8(%ebp),%eax
    d27a:	01 d8                	add    %ebx,%eax
    d27c:	8b 00                	mov    (%eax),%eax
    d27e:	0f af c1             	imul   %ecx,%eax
    d281:	0f af 45 24          	imul   0x24(%ebp),%eax
    d285:	83 c0 07             	add    $0x7,%eax
    d288:	c1 e8 03             	shr    $0x3,%eax
    d28b:	01 f0                	add    %esi,%eax
    d28d:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    d28f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d293:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d297:	0f 85 b6 fe ff ff    	jne    d153 <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    d29d:	90                   	nop
    d29e:	83 c4 10             	add    $0x10,%esp
    d2a1:	5b                   	pop    %ebx
    d2a2:	5e                   	pop    %esi
    d2a3:	5d                   	pop    %ebp
    d2a4:	c3                   	ret    

0000d2a5 <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    d2a5:	55                   	push   %ebp
    d2a6:	89 e5                	mov    %esp,%ebp
    d2a8:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    d2ab:	8b 45 10             	mov    0x10(%ebp),%eax
    d2ae:	05 98 00 00 00       	add    $0x98,%eax
    d2b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    d2b6:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    d2ba:	74 06                	je     d2c2 <lodepng_inspect+0x1d>
    d2bc:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d2c0:	75 17                	jne    d2d9 <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    d2c2:	8b 45 10             	mov    0x10(%ebp),%eax
    d2c5:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    d2cc:	00 00 00 
    d2cf:	b8 30 00 00 00       	mov    $0x30,%eax
    d2d4:	e9 ce 02 00 00       	jmp    d5a7 <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    d2d9:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    d2dd:	7f 17                	jg     d2f6 <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    d2df:	8b 45 10             	mov    0x10(%ebp),%eax
    d2e2:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    d2e9:	00 00 00 
    d2ec:	b8 1b 00 00 00       	mov    $0x1b,%eax
    d2f1:	e9 b1 02 00 00       	jmp    d5a7 <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    d2f6:	83 ec 0c             	sub    $0xc,%esp
    d2f9:	ff 75 f4             	pushl  -0xc(%ebp)
    d2fc:	e8 63 c7 ff ff       	call   9a64 <lodepng_info_cleanup>
    d301:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    d304:	83 ec 0c             	sub    $0xc,%esp
    d307:	ff 75 f4             	pushl  -0xc(%ebp)
    d30a:	e8 74 c6 ff ff       	call   9983 <lodepng_info_init>
    d30f:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    d312:	8b 45 14             	mov    0x14(%ebp),%eax
    d315:	0f b6 00             	movzbl (%eax),%eax
    d318:	3c 89                	cmp    $0x89,%al
    d31a:	75 5b                	jne    d377 <lodepng_inspect+0xd2>
    d31c:	8b 45 14             	mov    0x14(%ebp),%eax
    d31f:	83 c0 01             	add    $0x1,%eax
    d322:	0f b6 00             	movzbl (%eax),%eax
    d325:	3c 50                	cmp    $0x50,%al
    d327:	75 4e                	jne    d377 <lodepng_inspect+0xd2>
    d329:	8b 45 14             	mov    0x14(%ebp),%eax
    d32c:	83 c0 02             	add    $0x2,%eax
    d32f:	0f b6 00             	movzbl (%eax),%eax
    d332:	3c 4e                	cmp    $0x4e,%al
    d334:	75 41                	jne    d377 <lodepng_inspect+0xd2>
    d336:	8b 45 14             	mov    0x14(%ebp),%eax
    d339:	83 c0 03             	add    $0x3,%eax
    d33c:	0f b6 00             	movzbl (%eax),%eax
    d33f:	3c 47                	cmp    $0x47,%al
    d341:	75 34                	jne    d377 <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    d343:	8b 45 14             	mov    0x14(%ebp),%eax
    d346:	83 c0 04             	add    $0x4,%eax
    d349:	0f b6 00             	movzbl (%eax),%eax
    d34c:	3c 0d                	cmp    $0xd,%al
    d34e:	75 27                	jne    d377 <lodepng_inspect+0xd2>
    d350:	8b 45 14             	mov    0x14(%ebp),%eax
    d353:	83 c0 05             	add    $0x5,%eax
    d356:	0f b6 00             	movzbl (%eax),%eax
    d359:	3c 0a                	cmp    $0xa,%al
    d35b:	75 1a                	jne    d377 <lodepng_inspect+0xd2>
    d35d:	8b 45 14             	mov    0x14(%ebp),%eax
    d360:	83 c0 06             	add    $0x6,%eax
    d363:	0f b6 00             	movzbl (%eax),%eax
    d366:	3c 1a                	cmp    $0x1a,%al
    d368:	75 0d                	jne    d377 <lodepng_inspect+0xd2>
    d36a:	8b 45 14             	mov    0x14(%ebp),%eax
    d36d:	83 c0 07             	add    $0x7,%eax
    d370:	0f b6 00             	movzbl (%eax),%eax
    d373:	3c 0a                	cmp    $0xa,%al
    d375:	74 17                	je     d38e <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    d377:	8b 45 10             	mov    0x10(%ebp),%eax
    d37a:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    d381:	00 00 00 
    d384:	b8 1c 00 00 00       	mov    $0x1c,%eax
    d389:	e9 19 02 00 00       	jmp    d5a7 <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    d38e:	8b 45 14             	mov    0x14(%ebp),%eax
    d391:	83 c0 08             	add    $0x8,%eax
    d394:	83 ec 0c             	sub    $0xc,%esp
    d397:	50                   	push   %eax
    d398:	e8 c2 ae ff ff       	call   825f <lodepng_chunk_length>
    d39d:	83 c4 10             	add    $0x10,%esp
    d3a0:	83 f8 0d             	cmp    $0xd,%eax
    d3a3:	74 17                	je     d3bc <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    d3a5:	8b 45 10             	mov    0x10(%ebp),%eax
    d3a8:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    d3af:	00 00 00 
    d3b2:	b8 5e 00 00 00       	mov    $0x5e,%eax
    d3b7:	e9 eb 01 00 00       	jmp    d5a7 <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    d3bc:	8b 45 14             	mov    0x14(%ebp),%eax
    d3bf:	83 c0 08             	add    $0x8,%eax
    d3c2:	83 ec 08             	sub    $0x8,%esp
    d3c5:	68 ec 9f 01 00       	push   $0x19fec
    d3ca:	50                   	push   %eax
    d3cb:	e8 dc ae ff ff       	call   82ac <lodepng_chunk_type_equals>
    d3d0:	83 c4 10             	add    $0x10,%esp
    d3d3:	84 c0                	test   %al,%al
    d3d5:	75 17                	jne    d3ee <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    d3d7:	8b 45 10             	mov    0x10(%ebp),%eax
    d3da:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    d3e1:	00 00 00 
    d3e4:	b8 1d 00 00 00       	mov    $0x1d,%eax
    d3e9:	e9 b9 01 00 00       	jmp    d5a7 <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    d3ee:	8b 45 14             	mov    0x14(%ebp),%eax
    d3f1:	83 c0 10             	add    $0x10,%eax
    d3f4:	83 ec 0c             	sub    $0xc,%esp
    d3f7:	50                   	push   %eax
    d3f8:	e8 5e 62 ff ff       	call   365b <lodepng_read32bitInt>
    d3fd:	83 c4 10             	add    $0x10,%esp
    d400:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    d403:	8b 45 14             	mov    0x14(%ebp),%eax
    d406:	83 c0 14             	add    $0x14,%eax
    d409:	83 ec 0c             	sub    $0xc,%esp
    d40c:	50                   	push   %eax
    d40d:	e8 49 62 ff ff       	call   365b <lodepng_read32bitInt>
    d412:	83 c4 10             	add    $0x10,%esp
    d415:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    d418:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    d41c:	74 08                	je     d426 <lodepng_inspect+0x181>
    d41e:	8b 45 08             	mov    0x8(%ebp),%eax
    d421:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d424:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    d426:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    d42a:	74 08                	je     d434 <lodepng_inspect+0x18f>
    d42c:	8b 45 0c             	mov    0xc(%ebp),%eax
    d42f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d432:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    d434:	8b 45 14             	mov    0x14(%ebp),%eax
    d437:	83 c0 18             	add    $0x18,%eax
    d43a:	0f b6 00             	movzbl (%eax),%eax
    d43d:	0f b6 d0             	movzbl %al,%edx
    d440:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d443:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    d446:	8b 45 14             	mov    0x14(%ebp),%eax
    d449:	83 c0 19             	add    $0x19,%eax
    d44c:	0f b6 00             	movzbl (%eax),%eax
    d44f:	0f b6 d0             	movzbl %al,%edx
    d452:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d455:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    d458:	8b 45 14             	mov    0x14(%ebp),%eax
    d45b:	83 c0 1a             	add    $0x1a,%eax
    d45e:	0f b6 00             	movzbl (%eax),%eax
    d461:	0f b6 d0             	movzbl %al,%edx
    d464:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d467:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    d469:	8b 45 14             	mov    0x14(%ebp),%eax
    d46c:	83 c0 1b             	add    $0x1b,%eax
    d46f:	0f b6 00             	movzbl (%eax),%eax
    d472:	0f b6 d0             	movzbl %al,%edx
    d475:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d478:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    d47b:	8b 45 14             	mov    0x14(%ebp),%eax
    d47e:	83 c0 1c             	add    $0x1c,%eax
    d481:	0f b6 00             	movzbl (%eax),%eax
    d484:	0f b6 d0             	movzbl %al,%edx
    d487:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d48a:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    d48d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d491:	74 06                	je     d499 <lodepng_inspect+0x1f4>
    d493:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d497:	75 17                	jne    d4b0 <lodepng_inspect+0x20b>
    d499:	8b 45 10             	mov    0x10(%ebp),%eax
    d49c:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    d4a3:	00 00 00 
    d4a6:	b8 5d 00 00 00       	mov    $0x5d,%eax
    d4ab:	e9 f7 00 00 00       	jmp    d5a7 <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    d4b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4b3:	8b 50 10             	mov    0x10(%eax),%edx
    d4b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4b9:	8b 40 0c             	mov    0xc(%eax),%eax
    d4bc:	83 ec 08             	sub    $0x8,%esp
    d4bf:	52                   	push   %edx
    d4c0:	50                   	push   %eax
    d4c1:	e8 d4 b3 ff ff       	call   889a <checkColorValidity>
    d4c6:	83 c4 10             	add    $0x10,%esp
    d4c9:	89 c2                	mov    %eax,%edx
    d4cb:	8b 45 10             	mov    0x10(%ebp),%eax
    d4ce:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    d4d4:	8b 45 10             	mov    0x10(%ebp),%eax
    d4d7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d4dd:	85 c0                	test   %eax,%eax
    d4df:	74 0e                	je     d4ef <lodepng_inspect+0x24a>
    d4e1:	8b 45 10             	mov    0x10(%ebp),%eax
    d4e4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d4ea:	e9 b8 00 00 00       	jmp    d5a7 <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    d4ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4f2:	8b 00                	mov    (%eax),%eax
    d4f4:	85 c0                	test   %eax,%eax
    d4f6:	74 17                	je     d50f <lodepng_inspect+0x26a>
    d4f8:	8b 45 10             	mov    0x10(%ebp),%eax
    d4fb:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    d502:	00 00 00 
    d505:	b8 20 00 00 00       	mov    $0x20,%eax
    d50a:	e9 98 00 00 00       	jmp    d5a7 <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    d50f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d512:	8b 40 04             	mov    0x4(%eax),%eax
    d515:	85 c0                	test   %eax,%eax
    d517:	74 14                	je     d52d <lodepng_inspect+0x288>
    d519:	8b 45 10             	mov    0x10(%ebp),%eax
    d51c:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    d523:	00 00 00 
    d526:	b8 21 00 00 00       	mov    $0x21,%eax
    d52b:	eb 7a                	jmp    d5a7 <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    d52d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d530:	8b 40 08             	mov    0x8(%eax),%eax
    d533:	83 f8 01             	cmp    $0x1,%eax
    d536:	76 14                	jbe    d54c <lodepng_inspect+0x2a7>
    d538:	8b 45 10             	mov    0x10(%ebp),%eax
    d53b:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    d542:	00 00 00 
    d545:	b8 22 00 00 00       	mov    $0x22,%eax
    d54a:	eb 5b                	jmp    d5a7 <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    d54c:	8b 45 10             	mov    0x10(%ebp),%eax
    d54f:	8b 40 18             	mov    0x18(%eax),%eax
    d552:	85 c0                	test   %eax,%eax
    d554:	75 48                	jne    d59e <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    d556:	8b 45 14             	mov    0x14(%ebp),%eax
    d559:	83 c0 1d             	add    $0x1d,%eax
    d55c:	83 ec 0c             	sub    $0xc,%esp
    d55f:	50                   	push   %eax
    d560:	e8 f6 60 ff ff       	call   365b <lodepng_read32bitInt>
    d565:	83 c4 10             	add    $0x10,%esp
    d568:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    d56b:	8b 45 14             	mov    0x14(%ebp),%eax
    d56e:	83 c0 0c             	add    $0xc,%eax
    d571:	83 ec 08             	sub    $0x8,%esp
    d574:	6a 11                	push   $0x11
    d576:	50                   	push   %eax
    d577:	e8 71 ab ff ff       	call   80ed <lodepng_crc32>
    d57c:	83 c4 10             	add    $0x10,%esp
    d57f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    d582:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d585:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    d588:	74 14                	je     d59e <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    d58a:	8b 45 10             	mov    0x10(%ebp),%eax
    d58d:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    d594:	00 00 00 
    d597:	b8 39 00 00 00       	mov    $0x39,%eax
    d59c:	eb 09                	jmp    d5a7 <lodepng_inspect+0x302>
    }
  }

  return state->error;
    d59e:	8b 45 10             	mov    0x10(%ebp),%eax
    d5a1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    d5a7:	c9                   	leave  
    d5a8:	c3                   	ret    

0000d5a9 <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    d5a9:	55                   	push   %ebp
    d5aa:	89 e5                	mov    %esp,%ebp
    d5ac:	56                   	push   %esi
    d5ad:	53                   	push   %ebx
    d5ae:	83 ec 44             	sub    $0x44,%esp
    d5b1:	8b 45 18             	mov    0x18(%ebp),%eax
    d5b4:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    d5b7:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    d5bb:	83 f8 04             	cmp    $0x4,%eax
    d5be:	0f 87 81 07 00 00    	ja     dd45 <unfilterScanline+0x79c>
    d5c4:	8b 04 85 f4 9f 01 00 	mov    0x19ff4(,%eax,4),%eax
    d5cb:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d5cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d5d4:	eb 19                	jmp    d5ef <unfilterScanline+0x46>
    d5d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d5d9:	8b 45 08             	mov    0x8(%ebp),%eax
    d5dc:	01 c2                	add    %eax,%edx
    d5de:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d5e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    d5e4:	01 c8                	add    %ecx,%eax
    d5e6:	0f b6 00             	movzbl (%eax),%eax
    d5e9:	88 02                	mov    %al,(%edx)
    d5eb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d5ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5f2:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d5f5:	75 df                	jne    d5d6 <unfilterScanline+0x2d>
      break;
    d5f7:	e9 50 07 00 00       	jmp    dd4c <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d5fc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d603:	eb 19                	jmp    d61e <unfilterScanline+0x75>
    d605:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d608:	8b 45 08             	mov    0x8(%ebp),%eax
    d60b:	01 c2                	add    %eax,%edx
    d60d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d610:	8b 45 0c             	mov    0xc(%ebp),%eax
    d613:	01 c8                	add    %ecx,%eax
    d615:	0f b6 00             	movzbl (%eax),%eax
    d618:	88 02                	mov    %al,(%edx)
    d61a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d61e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d621:	3b 45 14             	cmp    0x14(%ebp),%eax
    d624:	75 df                	jne    d605 <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    d626:	8b 45 14             	mov    0x14(%ebp),%eax
    d629:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d62c:	eb 2b                	jmp    d659 <unfilterScanline+0xb0>
    d62e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d631:	8b 45 08             	mov    0x8(%ebp),%eax
    d634:	01 c2                	add    %eax,%edx
    d636:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d639:	8b 45 0c             	mov    0xc(%ebp),%eax
    d63c:	01 c8                	add    %ecx,%eax
    d63e:	0f b6 08             	movzbl (%eax),%ecx
    d641:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d644:	2b 45 14             	sub    0x14(%ebp),%eax
    d647:	89 c3                	mov    %eax,%ebx
    d649:	8b 45 08             	mov    0x8(%ebp),%eax
    d64c:	01 d8                	add    %ebx,%eax
    d64e:	0f b6 00             	movzbl (%eax),%eax
    d651:	01 c8                	add    %ecx,%eax
    d653:	88 02                	mov    %al,(%edx)
    d655:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d659:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d65c:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d65f:	7c cd                	jl     d62e <unfilterScanline+0x85>
      break;
    d661:	e9 e6 06 00 00       	jmp    dd4c <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    d666:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d66a:	74 3c                	je     d6a8 <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    d66c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d673:	eb 26                	jmp    d69b <unfilterScanline+0xf2>
    d675:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d678:	8b 45 08             	mov    0x8(%ebp),%eax
    d67b:	01 d0                	add    %edx,%eax
    d67d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d680:	8b 55 0c             	mov    0xc(%ebp),%edx
    d683:	01 ca                	add    %ecx,%edx
    d685:	0f b6 0a             	movzbl (%edx),%ecx
    d688:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d68b:	8b 55 10             	mov    0x10(%ebp),%edx
    d68e:	01 da                	add    %ebx,%edx
    d690:	0f b6 12             	movzbl (%edx),%edx
    d693:	01 ca                	add    %ecx,%edx
    d695:	88 10                	mov    %dl,(%eax)
    d697:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d69b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d69e:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d6a1:	75 d2                	jne    d675 <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    d6a3:	e9 a4 06 00 00       	jmp    dd4c <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d6a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d6af:	eb 19                	jmp    d6ca <unfilterScanline+0x121>
    d6b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d6b4:	8b 45 08             	mov    0x8(%ebp),%eax
    d6b7:	01 c2                	add    %eax,%edx
    d6b9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d6bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    d6bf:	01 c8                	add    %ecx,%eax
    d6c1:	0f b6 00             	movzbl (%eax),%eax
    d6c4:	88 02                	mov    %al,(%edx)
    d6c6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d6ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6cd:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d6d0:	75 df                	jne    d6b1 <unfilterScanline+0x108>
      }
      break;
    d6d2:	e9 75 06 00 00       	jmp    dd4c <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    d6d7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d6db:	0f 84 8e 00 00 00    	je     d76f <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    d6e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d6e8:	eb 28                	jmp    d712 <unfilterScanline+0x169>
    d6ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d6ed:	8b 45 08             	mov    0x8(%ebp),%eax
    d6f0:	01 d0                	add    %edx,%eax
    d6f2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d6f5:	8b 55 0c             	mov    0xc(%ebp),%edx
    d6f8:	01 ca                	add    %ecx,%edx
    d6fa:	0f b6 12             	movzbl (%edx),%edx
    d6fd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d700:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d703:	01 d9                	add    %ebx,%ecx
    d705:	0f b6 09             	movzbl (%ecx),%ecx
    d708:	d0 e9                	shr    %cl
    d70a:	01 ca                	add    %ecx,%edx
    d70c:	88 10                	mov    %dl,(%eax)
    d70e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d712:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d715:	3b 45 14             	cmp    0x14(%ebp),%eax
    d718:	75 d0                	jne    d6ea <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    d71a:	8b 45 14             	mov    0x14(%ebp),%eax
    d71d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d720:	eb 40                	jmp    d762 <unfilterScanline+0x1b9>
    d722:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d725:	8b 45 08             	mov    0x8(%ebp),%eax
    d728:	01 c2                	add    %eax,%edx
    d72a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d72d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d730:	01 c8                	add    %ecx,%eax
    d732:	0f b6 08             	movzbl (%eax),%ecx
    d735:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d738:	2b 45 14             	sub    0x14(%ebp),%eax
    d73b:	89 c3                	mov    %eax,%ebx
    d73d:	8b 45 08             	mov    0x8(%ebp),%eax
    d740:	01 d8                	add    %ebx,%eax
    d742:	0f b6 00             	movzbl (%eax),%eax
    d745:	0f b6 d8             	movzbl %al,%ebx
    d748:	8b 75 f4             	mov    -0xc(%ebp),%esi
    d74b:	8b 45 10             	mov    0x10(%ebp),%eax
    d74e:	01 f0                	add    %esi,%eax
    d750:	0f b6 00             	movzbl (%eax),%eax
    d753:	0f b6 c0             	movzbl %al,%eax
    d756:	01 d8                	add    %ebx,%eax
    d758:	d1 f8                	sar    %eax
    d75a:	01 c8                	add    %ecx,%eax
    d75c:	88 02                	mov    %al,(%edx)
    d75e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d762:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d765:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d768:	7c b8                	jl     d722 <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    d76a:	e9 dd 05 00 00       	jmp    dd4c <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d76f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d776:	eb 19                	jmp    d791 <unfilterScanline+0x1e8>
    d778:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d77b:	8b 45 08             	mov    0x8(%ebp),%eax
    d77e:	01 c2                	add    %eax,%edx
    d780:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d783:	8b 45 0c             	mov    0xc(%ebp),%eax
    d786:	01 c8                	add    %ecx,%eax
    d788:	0f b6 00             	movzbl (%eax),%eax
    d78b:	88 02                	mov    %al,(%edx)
    d78d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d791:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d794:	3b 45 14             	cmp    0x14(%ebp),%eax
    d797:	75 df                	jne    d778 <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    d799:	8b 45 14             	mov    0x14(%ebp),%eax
    d79c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d79f:	eb 2d                	jmp    d7ce <unfilterScanline+0x225>
    d7a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d7a4:	8b 45 08             	mov    0x8(%ebp),%eax
    d7a7:	01 c2                	add    %eax,%edx
    d7a9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7af:	01 c8                	add    %ecx,%eax
    d7b1:	0f b6 08             	movzbl (%eax),%ecx
    d7b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7b7:	2b 45 14             	sub    0x14(%ebp),%eax
    d7ba:	89 c3                	mov    %eax,%ebx
    d7bc:	8b 45 08             	mov    0x8(%ebp),%eax
    d7bf:	01 d8                	add    %ebx,%eax
    d7c1:	0f b6 00             	movzbl (%eax),%eax
    d7c4:	d0 e8                	shr    %al
    d7c6:	01 c8                	add    %ecx,%eax
    d7c8:	88 02                	mov    %al,(%edx)
    d7ca:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7d1:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d7d4:	7c cb                	jl     d7a1 <unfilterScanline+0x1f8>
      }
      break;
    d7d6:	e9 71 05 00 00       	jmp    dd4c <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    d7db:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d7df:	0f 84 f9 04 00 00    	je     dcde <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    d7e5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d7ec:	eb 26                	jmp    d814 <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    d7ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d7f1:	8b 45 08             	mov    0x8(%ebp),%eax
    d7f4:	01 d0                	add    %edx,%eax
    d7f6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7f9:	8b 55 0c             	mov    0xc(%ebp),%edx
    d7fc:	01 ca                	add    %ecx,%edx
    d7fe:	0f b6 0a             	movzbl (%edx),%ecx
    d801:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d804:	8b 55 10             	mov    0x10(%ebp),%edx
    d807:	01 da                	add    %ebx,%edx
    d809:	0f b6 12             	movzbl (%edx),%edx
    d80c:	01 ca                	add    %ecx,%edx
    d80e:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    d810:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d814:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d817:	3b 45 14             	cmp    0x14(%ebp),%eax
    d81a:	75 d2                	jne    d7ee <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    d81c:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    d820:	0f 8e db 01 00 00    	jle    da01 <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    d826:	e9 c2 01 00 00       	jmp    d9ed <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    d82b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d82e:	2b 45 14             	sub    0x14(%ebp),%eax
    d831:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    d834:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d837:	8b 45 0c             	mov    0xc(%ebp),%eax
    d83a:	01 d0                	add    %edx,%eax
    d83c:	0f b6 00             	movzbl (%eax),%eax
    d83f:	88 45 ef             	mov    %al,-0x11(%ebp)
    d842:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d845:	8d 50 01             	lea    0x1(%eax),%edx
    d848:	8b 45 0c             	mov    0xc(%ebp),%eax
    d84b:	01 d0                	add    %edx,%eax
    d84d:	0f b6 00             	movzbl (%eax),%eax
    d850:	88 45 ee             	mov    %al,-0x12(%ebp)
    d853:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d856:	8d 50 02             	lea    0x2(%eax),%edx
    d859:	8b 45 0c             	mov    0xc(%ebp),%eax
    d85c:	01 d0                	add    %edx,%eax
    d85e:	0f b6 00             	movzbl (%eax),%eax
    d861:	88 45 ed             	mov    %al,-0x13(%ebp)
    d864:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d867:	8d 50 03             	lea    0x3(%eax),%edx
    d86a:	8b 45 0c             	mov    0xc(%ebp),%eax
    d86d:	01 d0                	add    %edx,%eax
    d86f:	0f b6 00             	movzbl (%eax),%eax
    d872:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    d875:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d878:	8b 45 08             	mov    0x8(%ebp),%eax
    d87b:	01 d0                	add    %edx,%eax
    d87d:	0f b6 00             	movzbl (%eax),%eax
    d880:	88 45 eb             	mov    %al,-0x15(%ebp)
    d883:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d886:	8d 50 01             	lea    0x1(%eax),%edx
    d889:	8b 45 08             	mov    0x8(%ebp),%eax
    d88c:	01 d0                	add    %edx,%eax
    d88e:	0f b6 00             	movzbl (%eax),%eax
    d891:	88 45 ea             	mov    %al,-0x16(%ebp)
    d894:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d897:	8d 50 02             	lea    0x2(%eax),%edx
    d89a:	8b 45 08             	mov    0x8(%ebp),%eax
    d89d:	01 d0                	add    %edx,%eax
    d89f:	0f b6 00             	movzbl (%eax),%eax
    d8a2:	88 45 e9             	mov    %al,-0x17(%ebp)
    d8a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d8a8:	8d 50 03             	lea    0x3(%eax),%edx
    d8ab:	8b 45 08             	mov    0x8(%ebp),%eax
    d8ae:	01 d0                	add    %edx,%eax
    d8b0:	0f b6 00             	movzbl (%eax),%eax
    d8b3:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    d8b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d8b9:	8b 45 10             	mov    0x10(%ebp),%eax
    d8bc:	01 d0                	add    %edx,%eax
    d8be:	0f b6 00             	movzbl (%eax),%eax
    d8c1:	88 45 e7             	mov    %al,-0x19(%ebp)
    d8c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8c7:	8d 50 01             	lea    0x1(%eax),%edx
    d8ca:	8b 45 10             	mov    0x10(%ebp),%eax
    d8cd:	01 d0                	add    %edx,%eax
    d8cf:	0f b6 00             	movzbl (%eax),%eax
    d8d2:	88 45 e6             	mov    %al,-0x1a(%ebp)
    d8d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8d8:	8d 50 02             	lea    0x2(%eax),%edx
    d8db:	8b 45 10             	mov    0x10(%ebp),%eax
    d8de:	01 d0                	add    %edx,%eax
    d8e0:	0f b6 00             	movzbl (%eax),%eax
    d8e3:	88 45 e5             	mov    %al,-0x1b(%ebp)
    d8e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8e9:	8d 50 03             	lea    0x3(%eax),%edx
    d8ec:	8b 45 10             	mov    0x10(%ebp),%eax
    d8ef:	01 d0                	add    %edx,%eax
    d8f1:	0f b6 00             	movzbl (%eax),%eax
    d8f4:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    d8f7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d8fa:	8b 45 10             	mov    0x10(%ebp),%eax
    d8fd:	01 d0                	add    %edx,%eax
    d8ff:	0f b6 00             	movzbl (%eax),%eax
    d902:	88 45 e3             	mov    %al,-0x1d(%ebp)
    d905:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d908:	8d 50 01             	lea    0x1(%eax),%edx
    d90b:	8b 45 10             	mov    0x10(%ebp),%eax
    d90e:	01 d0                	add    %edx,%eax
    d910:	0f b6 00             	movzbl (%eax),%eax
    d913:	88 45 e2             	mov    %al,-0x1e(%ebp)
    d916:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d919:	8d 50 02             	lea    0x2(%eax),%edx
    d91c:	8b 45 10             	mov    0x10(%ebp),%eax
    d91f:	01 d0                	add    %edx,%eax
    d921:	0f b6 00             	movzbl (%eax),%eax
    d924:	88 45 e1             	mov    %al,-0x1f(%ebp)
    d927:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d92a:	8d 50 03             	lea    0x3(%eax),%edx
    d92d:	8b 45 10             	mov    0x10(%ebp),%eax
    d930:	01 d0                	add    %edx,%eax
    d932:	0f b6 00             	movzbl (%eax),%eax
    d935:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    d938:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d93b:	8b 45 08             	mov    0x8(%ebp),%eax
    d93e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d941:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    d945:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    d949:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    d94d:	51                   	push   %ecx
    d94e:	52                   	push   %edx
    d94f:	50                   	push   %eax
    d950:	e8 3f f6 ff ff       	call   cf94 <paethPredictor>
    d955:	83 c4 0c             	add    $0xc,%esp
    d958:	89 c2                	mov    %eax,%edx
    d95a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    d95e:	01 d0                	add    %edx,%eax
    d960:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    d962:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d965:	8d 50 01             	lea    0x1(%eax),%edx
    d968:	8b 45 08             	mov    0x8(%ebp),%eax
    d96b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d96e:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    d972:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    d976:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    d97a:	51                   	push   %ecx
    d97b:	52                   	push   %edx
    d97c:	50                   	push   %eax
    d97d:	e8 12 f6 ff ff       	call   cf94 <paethPredictor>
    d982:	83 c4 0c             	add    $0xc,%esp
    d985:	89 c2                	mov    %eax,%edx
    d987:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    d98b:	01 d0                	add    %edx,%eax
    d98d:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    d98f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d992:	8d 50 02             	lea    0x2(%eax),%edx
    d995:	8b 45 08             	mov    0x8(%ebp),%eax
    d998:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d99b:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    d99f:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    d9a3:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    d9a7:	51                   	push   %ecx
    d9a8:	52                   	push   %edx
    d9a9:	50                   	push   %eax
    d9aa:	e8 e5 f5 ff ff       	call   cf94 <paethPredictor>
    d9af:	83 c4 0c             	add    $0xc,%esp
    d9b2:	89 c2                	mov    %eax,%edx
    d9b4:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    d9b8:	01 d0                	add    %edx,%eax
    d9ba:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    d9bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9bf:	8d 50 03             	lea    0x3(%eax),%edx
    d9c2:	8b 45 08             	mov    0x8(%ebp),%eax
    d9c5:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d9c8:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    d9cc:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    d9d0:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    d9d4:	51                   	push   %ecx
    d9d5:	52                   	push   %edx
    d9d6:	50                   	push   %eax
    d9d7:	e8 b8 f5 ff ff       	call   cf94 <paethPredictor>
    d9dc:	83 c4 0c             	add    $0xc,%esp
    d9df:	89 c2                	mov    %eax,%edx
    d9e1:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    d9e5:	01 d0                	add    %edx,%eax
    d9e7:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    d9e9:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    d9ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9f0:	83 c0 03             	add    $0x3,%eax
    d9f3:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d9f6:	0f 8c 2f fe ff ff    	jl     d82b <unfilterScanline+0x282>
    d9fc:	e9 d3 02 00 00       	jmp    dcd4 <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    da01:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    da05:	0f 8e 6a 01 00 00    	jle    db75 <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    da0b:	e9 51 01 00 00       	jmp    db61 <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    da10:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da13:	2b 45 14             	sub    0x14(%ebp),%eax
    da16:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    da19:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da1c:	8b 45 0c             	mov    0xc(%ebp),%eax
    da1f:	01 d0                	add    %edx,%eax
    da21:	0f b6 00             	movzbl (%eax),%eax
    da24:	88 45 db             	mov    %al,-0x25(%ebp)
    da27:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da2a:	8d 50 01             	lea    0x1(%eax),%edx
    da2d:	8b 45 0c             	mov    0xc(%ebp),%eax
    da30:	01 d0                	add    %edx,%eax
    da32:	0f b6 00             	movzbl (%eax),%eax
    da35:	88 45 da             	mov    %al,-0x26(%ebp)
    da38:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da3b:	8d 50 02             	lea    0x2(%eax),%edx
    da3e:	8b 45 0c             	mov    0xc(%ebp),%eax
    da41:	01 d0                	add    %edx,%eax
    da43:	0f b6 00             	movzbl (%eax),%eax
    da46:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    da49:	8b 55 dc             	mov    -0x24(%ebp),%edx
    da4c:	8b 45 08             	mov    0x8(%ebp),%eax
    da4f:	01 d0                	add    %edx,%eax
    da51:	0f b6 00             	movzbl (%eax),%eax
    da54:	88 45 d8             	mov    %al,-0x28(%ebp)
    da57:	8b 45 dc             	mov    -0x24(%ebp),%eax
    da5a:	8d 50 01             	lea    0x1(%eax),%edx
    da5d:	8b 45 08             	mov    0x8(%ebp),%eax
    da60:	01 d0                	add    %edx,%eax
    da62:	0f b6 00             	movzbl (%eax),%eax
    da65:	88 45 d7             	mov    %al,-0x29(%ebp)
    da68:	8b 45 dc             	mov    -0x24(%ebp),%eax
    da6b:	8d 50 02             	lea    0x2(%eax),%edx
    da6e:	8b 45 08             	mov    0x8(%ebp),%eax
    da71:	01 d0                	add    %edx,%eax
    da73:	0f b6 00             	movzbl (%eax),%eax
    da76:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    da79:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da7c:	8b 45 10             	mov    0x10(%ebp),%eax
    da7f:	01 d0                	add    %edx,%eax
    da81:	0f b6 00             	movzbl (%eax),%eax
    da84:	88 45 d5             	mov    %al,-0x2b(%ebp)
    da87:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da8a:	8d 50 01             	lea    0x1(%eax),%edx
    da8d:	8b 45 10             	mov    0x10(%ebp),%eax
    da90:	01 d0                	add    %edx,%eax
    da92:	0f b6 00             	movzbl (%eax),%eax
    da95:	88 45 d4             	mov    %al,-0x2c(%ebp)
    da98:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da9b:	8d 50 02             	lea    0x2(%eax),%edx
    da9e:	8b 45 10             	mov    0x10(%ebp),%eax
    daa1:	01 d0                	add    %edx,%eax
    daa3:	0f b6 00             	movzbl (%eax),%eax
    daa6:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    daa9:	8b 55 dc             	mov    -0x24(%ebp),%edx
    daac:	8b 45 10             	mov    0x10(%ebp),%eax
    daaf:	01 d0                	add    %edx,%eax
    dab1:	0f b6 00             	movzbl (%eax),%eax
    dab4:	88 45 d2             	mov    %al,-0x2e(%ebp)
    dab7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    daba:	8d 50 01             	lea    0x1(%eax),%edx
    dabd:	8b 45 10             	mov    0x10(%ebp),%eax
    dac0:	01 d0                	add    %edx,%eax
    dac2:	0f b6 00             	movzbl (%eax),%eax
    dac5:	88 45 d1             	mov    %al,-0x2f(%ebp)
    dac8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dacb:	8d 50 02             	lea    0x2(%eax),%edx
    dace:	8b 45 10             	mov    0x10(%ebp),%eax
    dad1:	01 d0                	add    %edx,%eax
    dad3:	0f b6 00             	movzbl (%eax),%eax
    dad6:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dad9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dadc:	8b 45 08             	mov    0x8(%ebp),%eax
    dadf:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dae2:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    dae6:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    daea:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    daee:	51                   	push   %ecx
    daef:	52                   	push   %edx
    daf0:	50                   	push   %eax
    daf1:	e8 9e f4 ff ff       	call   cf94 <paethPredictor>
    daf6:	83 c4 0c             	add    $0xc,%esp
    daf9:	89 c2                	mov    %eax,%edx
    dafb:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    daff:	01 d0                	add    %edx,%eax
    db01:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    db03:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db06:	8d 50 01             	lea    0x1(%eax),%edx
    db09:	8b 45 08             	mov    0x8(%ebp),%eax
    db0c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db0f:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    db13:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    db17:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    db1b:	51                   	push   %ecx
    db1c:	52                   	push   %edx
    db1d:	50                   	push   %eax
    db1e:	e8 71 f4 ff ff       	call   cf94 <paethPredictor>
    db23:	83 c4 0c             	add    $0xc,%esp
    db26:	89 c2                	mov    %eax,%edx
    db28:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    db2c:	01 d0                	add    %edx,%eax
    db2e:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    db30:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db33:	8d 50 02             	lea    0x2(%eax),%edx
    db36:	8b 45 08             	mov    0x8(%ebp),%eax
    db39:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db3c:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    db40:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    db44:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    db48:	51                   	push   %ecx
    db49:	52                   	push   %edx
    db4a:	50                   	push   %eax
    db4b:	e8 44 f4 ff ff       	call   cf94 <paethPredictor>
    db50:	83 c4 0c             	add    $0xc,%esp
    db53:	89 c2                	mov    %eax,%edx
    db55:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    db59:	01 d0                	add    %edx,%eax
    db5b:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    db5d:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    db61:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db64:	83 c0 02             	add    $0x2,%eax
    db67:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    db6a:	0f 8c a0 fe ff ff    	jl     da10 <unfilterScanline+0x467>
    db70:	e9 5f 01 00 00       	jmp    dcd4 <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    db75:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    db79:	0f 8e 55 01 00 00    	jle    dcd4 <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    db7f:	e9 e0 00 00 00       	jmp    dc64 <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    db84:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db87:	2b 45 14             	sub    0x14(%ebp),%eax
    db8a:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    db8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    db90:	8b 45 0c             	mov    0xc(%ebp),%eax
    db93:	01 d0                	add    %edx,%eax
    db95:	0f b6 00             	movzbl (%eax),%eax
    db98:	88 45 cb             	mov    %al,-0x35(%ebp)
    db9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db9e:	8d 50 01             	lea    0x1(%eax),%edx
    dba1:	8b 45 0c             	mov    0xc(%ebp),%eax
    dba4:	01 d0                	add    %edx,%eax
    dba6:	0f b6 00             	movzbl (%eax),%eax
    dba9:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    dbac:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dbaf:	8b 45 08             	mov    0x8(%ebp),%eax
    dbb2:	01 d0                	add    %edx,%eax
    dbb4:	0f b6 00             	movzbl (%eax),%eax
    dbb7:	88 45 c9             	mov    %al,-0x37(%ebp)
    dbba:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dbbd:	8d 50 01             	lea    0x1(%eax),%edx
    dbc0:	8b 45 08             	mov    0x8(%ebp),%eax
    dbc3:	01 d0                	add    %edx,%eax
    dbc5:	0f b6 00             	movzbl (%eax),%eax
    dbc8:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    dbcb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dbce:	8b 45 10             	mov    0x10(%ebp),%eax
    dbd1:	01 d0                	add    %edx,%eax
    dbd3:	0f b6 00             	movzbl (%eax),%eax
    dbd6:	88 45 c7             	mov    %al,-0x39(%ebp)
    dbd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbdc:	8d 50 01             	lea    0x1(%eax),%edx
    dbdf:	8b 45 10             	mov    0x10(%ebp),%eax
    dbe2:	01 d0                	add    %edx,%eax
    dbe4:	0f b6 00             	movzbl (%eax),%eax
    dbe7:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    dbea:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dbed:	8b 45 10             	mov    0x10(%ebp),%eax
    dbf0:	01 d0                	add    %edx,%eax
    dbf2:	0f b6 00             	movzbl (%eax),%eax
    dbf5:	88 45 c5             	mov    %al,-0x3b(%ebp)
    dbf8:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dbfb:	8d 50 01             	lea    0x1(%eax),%edx
    dbfe:	8b 45 10             	mov    0x10(%ebp),%eax
    dc01:	01 d0                	add    %edx,%eax
    dc03:	0f b6 00             	movzbl (%eax),%eax
    dc06:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dc09:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc0c:	8b 45 08             	mov    0x8(%ebp),%eax
    dc0f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc12:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    dc16:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    dc1a:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    dc1e:	51                   	push   %ecx
    dc1f:	52                   	push   %edx
    dc20:	50                   	push   %eax
    dc21:	e8 6e f3 ff ff       	call   cf94 <paethPredictor>
    dc26:	83 c4 0c             	add    $0xc,%esp
    dc29:	89 c2                	mov    %eax,%edx
    dc2b:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    dc2f:	01 d0                	add    %edx,%eax
    dc31:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dc33:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc36:	8d 50 01             	lea    0x1(%eax),%edx
    dc39:	8b 45 08             	mov    0x8(%ebp),%eax
    dc3c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc3f:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    dc43:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    dc47:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    dc4b:	51                   	push   %ecx
    dc4c:	52                   	push   %edx
    dc4d:	50                   	push   %eax
    dc4e:	e8 41 f3 ff ff       	call   cf94 <paethPredictor>
    dc53:	83 c4 0c             	add    $0xc,%esp
    dc56:	89 c2                	mov    %eax,%edx
    dc58:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    dc5c:	01 d0                	add    %edx,%eax
    dc5e:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    dc60:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    dc64:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc67:	83 c0 01             	add    $0x1,%eax
    dc6a:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dc6d:	0f 8c 11 ff ff ff    	jl     db84 <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dc73:	eb 5f                	jmp    dcd4 <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    dc75:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc78:	8b 45 08             	mov    0x8(%ebp),%eax
    dc7b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc7e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc81:	8b 45 0c             	mov    0xc(%ebp),%eax
    dc84:	01 d0                	add    %edx,%eax
    dc86:	0f b6 00             	movzbl (%eax),%eax
    dc89:	88 45 b7             	mov    %al,-0x49(%ebp)
    dc8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc8f:	2b 45 14             	sub    0x14(%ebp),%eax
    dc92:	89 c2                	mov    %eax,%edx
    dc94:	8b 45 10             	mov    0x10(%ebp),%eax
    dc97:	01 d0                	add    %edx,%eax
    dc99:	0f b6 00             	movzbl (%eax),%eax
    dc9c:	0f b6 c8             	movzbl %al,%ecx
    dc9f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dca2:	8b 45 10             	mov    0x10(%ebp),%eax
    dca5:	01 d0                	add    %edx,%eax
    dca7:	0f b6 00             	movzbl (%eax),%eax
    dcaa:	0f b6 d0             	movzbl %al,%edx
    dcad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcb0:	2b 45 14             	sub    0x14(%ebp),%eax
    dcb3:	89 c6                	mov    %eax,%esi
    dcb5:	8b 45 08             	mov    0x8(%ebp),%eax
    dcb8:	01 f0                	add    %esi,%eax
    dcba:	0f b6 00             	movzbl (%eax),%eax
    dcbd:	0f b6 c0             	movzbl %al,%eax
    dcc0:	51                   	push   %ecx
    dcc1:	52                   	push   %edx
    dcc2:	50                   	push   %eax
    dcc3:	e8 cc f2 ff ff       	call   cf94 <paethPredictor>
    dcc8:	83 c4 0c             	add    $0xc,%esp
    dccb:	02 45 b7             	add    -0x49(%ebp),%al
    dcce:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dcd0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dcd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcd7:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dcda:	75 99                	jne    dc75 <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    dcdc:	eb 6e                	jmp    dd4c <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    dcde:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dce5:	eb 19                	jmp    dd00 <unfilterScanline+0x757>
          recon[i] = scanline[i];
    dce7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcea:	8b 45 08             	mov    0x8(%ebp),%eax
    dced:	01 c2                	add    %eax,%edx
    dcef:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dcf2:	8b 45 0c             	mov    0xc(%ebp),%eax
    dcf5:	01 c8                	add    %ecx,%eax
    dcf7:	0f b6 00             	movzbl (%eax),%eax
    dcfa:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    dcfc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd00:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd03:	3b 45 14             	cmp    0x14(%ebp),%eax
    dd06:	75 df                	jne    dce7 <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    dd08:	8b 45 14             	mov    0x14(%ebp),%eax
    dd0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    dd0e:	eb 2b                	jmp    dd3b <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    dd10:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd13:	8b 45 08             	mov    0x8(%ebp),%eax
    dd16:	01 c2                	add    %eax,%edx
    dd18:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dd1b:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd1e:	01 c8                	add    %ecx,%eax
    dd20:	0f b6 08             	movzbl (%eax),%ecx
    dd23:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd26:	2b 45 14             	sub    0x14(%ebp),%eax
    dd29:	89 c3                	mov    %eax,%ebx
    dd2b:	8b 45 08             	mov    0x8(%ebp),%eax
    dd2e:	01 d8                	add    %ebx,%eax
    dd30:	0f b6 00             	movzbl (%eax),%eax
    dd33:	01 c8                	add    %ecx,%eax
    dd35:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    dd37:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd3e:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd41:	7c cd                	jl     dd10 <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    dd43:	eb 07                	jmp    dd4c <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    dd45:	b8 24 00 00 00       	mov    $0x24,%eax
    dd4a:	eb 05                	jmp    dd51 <unfilterScanline+0x7a8>
  }
  return 0;
    dd4c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    dd51:	8d 65 f8             	lea    -0x8(%ebp),%esp
    dd54:	5b                   	pop    %ebx
    dd55:	5e                   	pop    %esi
    dd56:	5d                   	pop    %ebp
    dd57:	c3                   	ret    

0000dd58 <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    dd58:	55                   	push   %ebp
    dd59:	89 e5                	mov    %esp,%ebp
    dd5b:	53                   	push   %ebx
    dd5c:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    dd5f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    dd66:	8b 45 18             	mov    0x18(%ebp),%eax
    dd69:	83 c0 07             	add    $0x7,%eax
    dd6c:	c1 e8 03             	shr    $0x3,%eax
    dd6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    dd72:	ff 75 18             	pushl  0x18(%ebp)
    dd75:	6a 01                	push   $0x1
    dd77:	ff 75 10             	pushl  0x10(%ebp)
    dd7a:	e8 d9 b1 ff ff       	call   8f58 <lodepng_get_raw_size_idat>
    dd7f:	83 c4 0c             	add    $0xc,%esp
    dd82:	83 e8 01             	sub    $0x1,%eax
    dd85:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    dd88:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    dd8f:	eb 6d                	jmp    ddfe <unfilter+0xa6>
    size_t outindex = linebytes * y;
    dd91:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dd94:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    dd98:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    dd9b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dd9e:	83 c0 01             	add    $0x1,%eax
    dda1:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    dda5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    dda8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ddab:	8b 45 0c             	mov    0xc(%ebp),%eax
    ddae:	01 d0                	add    %edx,%eax
    ddb0:	0f b6 00             	movzbl (%eax),%eax
    ddb3:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    ddb6:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    ddba:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ddbd:	8d 4a 01             	lea    0x1(%edx),%ecx
    ddc0:	8b 55 0c             	mov    0xc(%ebp),%edx
    ddc3:	01 d1                	add    %edx,%ecx
    ddc5:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    ddc8:	8b 55 08             	mov    0x8(%ebp),%edx
    ddcb:	01 da                	add    %ebx,%edx
    ddcd:	ff 75 ec             	pushl  -0x14(%ebp)
    ddd0:	50                   	push   %eax
    ddd1:	ff 75 f0             	pushl  -0x10(%ebp)
    ddd4:	ff 75 f4             	pushl  -0xc(%ebp)
    ddd7:	51                   	push   %ecx
    ddd8:	52                   	push   %edx
    ddd9:	e8 cb f7 ff ff       	call   d5a9 <unfilterScanline>
    ddde:	83 c4 18             	add    $0x18,%esp
    dde1:	89 45 dc             	mov    %eax,-0x24(%ebp)
    dde4:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    dde8:	74 05                	je     ddef <unfilter+0x97>
    ddea:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dded:	eb 1c                	jmp    de0b <unfilter+0xb3>

    prevline = &out[outindex];
    ddef:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ddf2:	8b 45 08             	mov    0x8(%ebp),%eax
    ddf5:	01 d0                	add    %edx,%eax
    ddf7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    ddfa:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ddfe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    de01:	3b 45 14             	cmp    0x14(%ebp),%eax
    de04:	72 8b                	jb     dd91 <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    de06:	b8 00 00 00 00       	mov    $0x0,%eax
}
    de0b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    de0e:	c9                   	leave  
    de0f:	c3                   	ret    

0000de10 <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    de10:	55                   	push   %ebp
    de11:	89 e5                	mov    %esp,%ebp
    de13:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    de19:	ff 75 18             	pushl  0x18(%ebp)
    de1c:	ff 75 14             	pushl  0x14(%ebp)
    de1f:	ff 75 10             	pushl  0x10(%ebp)
    de22:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    de28:	50                   	push   %eax
    de29:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    de2f:	50                   	push   %eax
    de30:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    de36:	50                   	push   %eax
    de37:	8d 45 94             	lea    -0x6c(%ebp),%eax
    de3a:	50                   	push   %eax
    de3b:	8d 45 b0             	lea    -0x50(%ebp),%eax
    de3e:	50                   	push   %eax
    de3f:	e8 e6 f1 ff ff       	call   d02a <Adam7_getpassvalues>
    de44:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    de47:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    de4b:	0f 86 0a 01 00 00    	jbe    df5b <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    de51:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    de58:	e9 ef 00 00 00       	jmp    df4c <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    de5d:	8b 45 18             	mov    0x18(%ebp),%eax
    de60:	c1 e8 03             	shr    $0x3,%eax
    de63:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    de66:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    de6d:	e9 c6 00 00 00       	jmp    df38 <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    de72:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    de79:	e9 a6 00 00 00       	jmp    df24 <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    de7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    de81:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    de88:	89 c1                	mov    %eax,%ecx
    de8a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    de8d:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    de91:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    de95:	89 c2                	mov    %eax,%edx
    de97:	8b 45 f8             	mov    -0x8(%ebp),%eax
    de9a:	01 c2                	add    %eax,%edx
    de9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    de9f:	0f af c2             	imul   %edx,%eax
    dea2:	01 c8                	add    %ecx,%eax
    dea4:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    dea7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    deaa:	8b 14 85 98 9f 01 00 	mov    0x19f98(,%eax,4),%edx
    deb1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    deb4:	8b 04 85 d0 9f 01 00 	mov    0x19fd0(,%eax,4),%eax
    debb:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    debf:	01 d0                	add    %edx,%eax
    dec1:	0f af 45 10          	imul   0x10(%ebp),%eax
    dec5:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    dec7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    deca:	8b 04 85 b4 9f 01 00 	mov    0x19fb4(,%eax,4),%eax
    ded1:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    ded5:	01 c2                	add    %eax,%edx
    ded7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    deda:	8b 04 85 7c 9f 01 00 	mov    0x19f7c(,%eax,4),%eax
    dee1:	01 c2                	add    %eax,%edx
    dee3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    dee6:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    dee9:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    deec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    def3:	eb 23                	jmp    df18 <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    def5:	8b 55 d8             	mov    -0x28(%ebp),%edx
    def8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    defb:	01 c2                	add    %eax,%edx
    defd:	8b 45 08             	mov    0x8(%ebp),%eax
    df00:	01 c2                	add    %eax,%edx
    df02:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    df05:	8b 45 f0             	mov    -0x10(%ebp),%eax
    df08:	01 c1                	add    %eax,%ecx
    df0a:	8b 45 0c             	mov    0xc(%ebp),%eax
    df0d:	01 c8                	add    %ecx,%eax
    df0f:	0f b6 00             	movzbl (%eax),%eax
    df12:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    df14:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    df18:	8b 45 e0             	mov    -0x20(%ebp),%eax
    df1b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    df1e:	72 d5                	jb     def5 <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    df20:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    df24:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df27:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    df2b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    df2e:	0f 87 4a ff ff ff    	ja     de7e <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    df34:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    df38:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df3b:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    df3f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    df42:	0f 87 2a ff ff ff    	ja     de72 <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    df48:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    df4c:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    df50:	0f 85 07 ff ff ff    	jne    de5d <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    df56:	e9 22 01 00 00       	jmp    e07d <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    df5b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    df62:	e9 0c 01 00 00       	jmp    e073 <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    df67:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df6a:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    df6e:	0f af 45 18          	imul   0x18(%ebp),%eax
    df72:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    df75:	8b 45 18             	mov    0x18(%ebp),%eax
    df78:	0f af 45 10          	imul   0x10(%ebp),%eax
    df7c:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    df7f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    df86:	e9 d4 00 00 00       	jmp    e05f <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    df8b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    df92:	e9 b4 00 00 00       	jmp    e04b <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    df97:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df9a:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    dfa1:	c1 e0 03             	shl    $0x3,%eax
    dfa4:	89 c1                	mov    %eax,%ecx
    dfa6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dfa9:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    dfad:	89 c2                	mov    %eax,%edx
    dfaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dfb2:	0f af 45 18          	imul   0x18(%ebp),%eax
    dfb6:	01 d0                	add    %edx,%eax
    dfb8:	01 c8                	add    %ecx,%eax
    dfba:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    dfc0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfc3:	8b 14 85 98 9f 01 00 	mov    0x19f98(,%eax,4),%edx
    dfca:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfcd:	8b 04 85 d0 9f 01 00 	mov    0x19fd0(,%eax,4),%eax
    dfd4:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    dfd8:	01 d0                	add    %edx,%eax
    dfda:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    dfde:	89 c2                	mov    %eax,%edx
    dfe0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfe3:	8b 0c 85 7c 9f 01 00 	mov    0x19f7c(,%eax,4),%ecx
    dfea:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfed:	8b 04 85 b4 9f 01 00 	mov    0x19fb4(,%eax,4),%eax
    dff4:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    dff8:	01 c8                	add    %ecx,%eax
    dffa:	0f af 45 18          	imul   0x18(%ebp),%eax
    dffe:	01 d0                	add    %edx,%eax
    e000:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    e006:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e00d:	eb 30                	jmp    e03f <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    e00f:	ff 75 0c             	pushl  0xc(%ebp)
    e012:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    e018:	50                   	push   %eax
    e019:	e8 1e a1 ff ff       	call   813c <readBitFromReversedStream>
    e01e:	83 c4 08             	add    $0x8,%esp
    e021:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    e024:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    e028:	50                   	push   %eax
    e029:	ff 75 08             	pushl  0x8(%ebp)
    e02c:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    e032:	50                   	push   %eax
    e033:	e8 86 a1 ff ff       	call   81be <setBitOfReversedStream>
    e038:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    e03b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    e03f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e042:	3b 45 18             	cmp    0x18(%ebp),%eax
    e045:	72 c8                	jb     e00f <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e047:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    e04b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e04e:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e052:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e055:	0f 87 3c ff ff ff    	ja     df97 <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e05b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e05f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e062:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e066:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e069:	0f 87 1c ff ff ff    	ja     df8b <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e06f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e073:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e077:	0f 85 ea fe ff ff    	jne    df67 <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e07d:	90                   	nop
    e07e:	c9                   	leave  
    e07f:	c3                   	ret    

0000e080 <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    e080:	55                   	push   %ebp
    e081:	89 e5                	mov    %esp,%ebp
    e083:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    e086:	8b 45 14             	mov    0x14(%ebp),%eax
    e089:	2b 45 10             	sub    0x10(%ebp),%eax
    e08c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    e08f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e096:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    e09d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e0a4:	eb 4a                	jmp    e0f0 <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e0a6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e0ad:	eb 2a                	jmp    e0d9 <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    e0af:	ff 75 0c             	pushl  0xc(%ebp)
    e0b2:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e0b5:	50                   	push   %eax
    e0b6:	e8 81 a0 ff ff       	call   813c <readBitFromReversedStream>
    e0bb:	83 c4 08             	add    $0x8,%esp
    e0be:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    e0c1:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e0c5:	50                   	push   %eax
    e0c6:	ff 75 08             	pushl  0x8(%ebp)
    e0c9:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e0cc:	50                   	push   %eax
    e0cd:	e8 ec a0 ff ff       	call   81be <setBitOfReversedStream>
    e0d2:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e0d5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e0d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e0dc:	3b 45 10             	cmp    0x10(%ebp),%eax
    e0df:	7c ce                	jl     e0af <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    e0e1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e0e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e0e7:	01 d0                	add    %edx,%eax
    e0e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    e0ec:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e0f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0f3:	3b 45 18             	cmp    0x18(%ebp),%eax
    e0f6:	72 ae                	jb     e0a6 <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    e0f8:	90                   	nop
    e0f9:	c9                   	leave  
    e0fa:	c3                   	ret    

0000e0fb <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    e0fb:	55                   	push   %ebp
    e0fc:	89 e5                	mov    %esp,%ebp
    e0fe:	57                   	push   %edi
    e0ff:	56                   	push   %esi
    e100:	53                   	push   %ebx
    e101:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    e107:	8b 45 18             	mov    0x18(%ebp),%eax
    e10a:	83 c0 0c             	add    $0xc,%eax
    e10d:	50                   	push   %eax
    e10e:	e8 e6 ac ff ff       	call   8df9 <lodepng_get_bpp>
    e113:	83 c4 04             	add    $0x4,%esp
    e116:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    e119:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e11d:	75 0a                	jne    e129 <postProcessScanlines+0x2e>
    e11f:	b8 1f 00 00 00       	mov    $0x1f,%eax
    e124:	e9 c3 01 00 00       	jmp    e2ec <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    e129:	8b 45 18             	mov    0x18(%ebp),%eax
    e12c:	8b 40 08             	mov    0x8(%eax),%eax
    e12f:	85 c0                	test   %eax,%eax
    e131:	0f 85 a8 00 00 00    	jne    e1df <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    e137:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e13b:	77 76                	ja     e1b3 <postProcessScanlines+0xb8>
    e13d:	8b 45 10             	mov    0x10(%ebp),%eax
    e140:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e144:	89 c2                	mov    %eax,%edx
    e146:	8b 45 10             	mov    0x10(%ebp),%eax
    e149:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e14d:	83 c0 07             	add    $0x7,%eax
    e150:	c1 e8 03             	shr    $0x3,%eax
    e153:	c1 e0 03             	shl    $0x3,%eax
    e156:	39 c2                	cmp    %eax,%edx
    e158:	74 59                	je     e1b3 <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    e15a:	ff 75 ec             	pushl  -0x14(%ebp)
    e15d:	ff 75 14             	pushl  0x14(%ebp)
    e160:	ff 75 10             	pushl  0x10(%ebp)
    e163:	ff 75 0c             	pushl  0xc(%ebp)
    e166:	ff 75 0c             	pushl  0xc(%ebp)
    e169:	e8 ea fb ff ff       	call   dd58 <unfilter>
    e16e:	83 c4 14             	add    $0x14,%esp
    e171:	89 45 e8             	mov    %eax,-0x18(%ebp)
    e174:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e178:	74 08                	je     e182 <postProcessScanlines+0x87>
    e17a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e17d:	e9 6a 01 00 00       	jmp    e2ec <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    e182:	8b 45 10             	mov    0x10(%ebp),%eax
    e185:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e189:	83 c0 07             	add    $0x7,%eax
    e18c:	c1 e8 03             	shr    $0x3,%eax
    e18f:	c1 e0 03             	shl    $0x3,%eax
    e192:	89 c2                	mov    %eax,%edx
    e194:	8b 45 10             	mov    0x10(%ebp),%eax
    e197:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e19b:	ff 75 14             	pushl  0x14(%ebp)
    e19e:	52                   	push   %edx
    e19f:	50                   	push   %eax
    e1a0:	ff 75 0c             	pushl  0xc(%ebp)
    e1a3:	ff 75 08             	pushl  0x8(%ebp)
    e1a6:	e8 d5 fe ff ff       	call   e080 <removePaddingBits>
    e1ab:	83 c4 14             	add    $0x14,%esp
    e1ae:	e9 34 01 00 00       	jmp    e2e7 <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    e1b3:	ff 75 ec             	pushl  -0x14(%ebp)
    e1b6:	ff 75 14             	pushl  0x14(%ebp)
    e1b9:	ff 75 10             	pushl  0x10(%ebp)
    e1bc:	ff 75 0c             	pushl  0xc(%ebp)
    e1bf:	ff 75 08             	pushl  0x8(%ebp)
    e1c2:	e8 91 fb ff ff       	call   dd58 <unfilter>
    e1c7:	83 c4 14             	add    $0x14,%esp
    e1ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e1cd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e1d1:	0f 84 10 01 00 00    	je     e2e7 <postProcessScanlines+0x1ec>
    e1d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e1da:	e9 0d 01 00 00       	jmp    e2ec <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e1df:	ff 75 ec             	pushl  -0x14(%ebp)
    e1e2:	ff 75 14             	pushl  0x14(%ebp)
    e1e5:	ff 75 10             	pushl  0x10(%ebp)
    e1e8:	8d 45 88             	lea    -0x78(%ebp),%eax
    e1eb:	50                   	push   %eax
    e1ec:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    e1f2:	50                   	push   %eax
    e1f3:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e1f9:	50                   	push   %eax
    e1fa:	8d 45 a8             	lea    -0x58(%ebp),%eax
    e1fd:	50                   	push   %eax
    e1fe:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e201:	50                   	push   %eax
    e202:	e8 23 ee ff ff       	call   d02a <Adam7_getpassvalues>
    e207:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    e20a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e211:	e9 b0 00 00 00       	jmp    e2c6 <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    e216:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e219:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    e21d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e220:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    e224:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e227:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    e22e:	89 cb                	mov    %ecx,%ebx
    e230:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e233:	01 cb                	add    %ecx,%ebx
    e235:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e238:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    e23f:	89 ce                	mov    %ecx,%esi
    e241:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e244:	01 f1                	add    %esi,%ecx
    e246:	ff 75 ec             	pushl  -0x14(%ebp)
    e249:	52                   	push   %edx
    e24a:	50                   	push   %eax
    e24b:	53                   	push   %ebx
    e24c:	51                   	push   %ecx
    e24d:	e8 06 fb ff ff       	call   dd58 <unfilter>
    e252:	83 c4 14             	add    $0x14,%esp
    e255:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e258:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e25c:	74 08                	je     e266 <postProcessScanlines+0x16b>
    e25e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e261:	e9 86 00 00 00       	jmp    e2ec <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    e266:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e26a:	77 56                	ja     e2c2 <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e26c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e26f:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    e273:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e276:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e27a:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e27e:	83 c2 07             	add    $0x7,%edx
    e281:	c1 ea 03             	shr    $0x3,%edx
    e284:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e287:	89 d6                	mov    %edx,%esi
    e289:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e28c:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e290:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e294:	89 d3                	mov    %edx,%ebx
    e296:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e299:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    e2a0:	89 d1                	mov    %edx,%ecx
    e2a2:	8b 55 0c             	mov    0xc(%ebp),%edx
    e2a5:	01 d1                	add    %edx,%ecx
    e2a7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2aa:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    e2ae:	89 d7                	mov    %edx,%edi
    e2b0:	8b 55 0c             	mov    0xc(%ebp),%edx
    e2b3:	01 fa                	add    %edi,%edx
    e2b5:	50                   	push   %eax
    e2b6:	56                   	push   %esi
    e2b7:	53                   	push   %ebx
    e2b8:	51                   	push   %ecx
    e2b9:	52                   	push   %edx
    e2ba:	e8 c1 fd ff ff       	call   e080 <removePaddingBits>
    e2bf:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    e2c2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e2c6:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    e2ca:	0f 85 46 ff ff ff    	jne    e216 <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    e2d0:	ff 75 ec             	pushl  -0x14(%ebp)
    e2d3:	ff 75 14             	pushl  0x14(%ebp)
    e2d6:	ff 75 10             	pushl  0x10(%ebp)
    e2d9:	ff 75 0c             	pushl  0xc(%ebp)
    e2dc:	ff 75 08             	pushl  0x8(%ebp)
    e2df:	e8 2c fb ff ff       	call   de10 <Adam7_deinterlace>
    e2e4:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    e2e7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e2ec:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e2ef:	5b                   	pop    %ebx
    e2f0:	5e                   	pop    %esi
    e2f1:	5f                   	pop    %edi
    e2f2:	5d                   	pop    %ebp
    e2f3:	c3                   	ret    

0000e2f4 <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e2f4:	55                   	push   %ebp
    e2f5:	89 e5                	mov    %esp,%ebp
    e2f7:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    e2fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    e301:	8b 45 10             	mov    0x10(%ebp),%eax
    e304:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    e309:	f7 e2                	mul    %edx
    e30b:	89 d0                	mov    %edx,%eax
    e30d:	d1 e8                	shr    %eax
    e30f:	89 c2                	mov    %eax,%edx
    e311:	8b 45 08             	mov    0x8(%ebp),%eax
    e314:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    e317:	8b 45 08             	mov    0x8(%ebp),%eax
    e31a:	8b 40 0c             	mov    0xc(%eax),%eax
    e31d:	85 c0                	test   %eax,%eax
    e31f:	74 0d                	je     e32e <readChunk_PLTE+0x3a>
    e321:	8b 45 08             	mov    0x8(%ebp),%eax
    e324:	8b 40 0c             	mov    0xc(%eax),%eax
    e327:	3d 00 01 00 00       	cmp    $0x100,%eax
    e32c:	7e 0a                	jle    e338 <readChunk_PLTE+0x44>
    e32e:	b8 26 00 00 00       	mov    $0x26,%eax
    e333:	e9 da 00 00 00       	jmp    e412 <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    e338:	83 ec 0c             	sub    $0xc,%esp
    e33b:	ff 75 08             	pushl  0x8(%ebp)
    e33e:	e8 02 a7 ff ff       	call   8a45 <lodepng_color_mode_alloc_palette>
    e343:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    e346:	8b 45 08             	mov    0x8(%ebp),%eax
    e349:	8b 40 08             	mov    0x8(%eax),%eax
    e34c:	85 c0                	test   %eax,%eax
    e34e:	75 1e                	jne    e36e <readChunk_PLTE+0x7a>
    e350:	8b 45 08             	mov    0x8(%ebp),%eax
    e353:	8b 40 0c             	mov    0xc(%eax),%eax
    e356:	85 c0                	test   %eax,%eax
    e358:	74 14                	je     e36e <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    e35a:	8b 45 08             	mov    0x8(%ebp),%eax
    e35d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    e364:	b8 53 00 00 00       	mov    $0x53,%eax
    e369:	e9 a4 00 00 00       	jmp    e412 <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    e36e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e375:	e9 84 00 00 00       	jmp    e3fe <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    e37a:	8b 45 08             	mov    0x8(%ebp),%eax
    e37d:	8b 40 08             	mov    0x8(%eax),%eax
    e380:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e383:	c1 e2 02             	shl    $0x2,%edx
    e386:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e389:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e38c:	8d 50 01             	lea    0x1(%eax),%edx
    e38f:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e392:	8b 55 0c             	mov    0xc(%ebp),%edx
    e395:	01 d0                	add    %edx,%eax
    e397:	0f b6 00             	movzbl (%eax),%eax
    e39a:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    e39c:	8b 45 08             	mov    0x8(%ebp),%eax
    e39f:	8b 40 08             	mov    0x8(%eax),%eax
    e3a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e3a5:	c1 e2 02             	shl    $0x2,%edx
    e3a8:	83 c2 01             	add    $0x1,%edx
    e3ab:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e3ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3b1:	8d 50 01             	lea    0x1(%eax),%edx
    e3b4:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e3b7:	8b 55 0c             	mov    0xc(%ebp),%edx
    e3ba:	01 d0                	add    %edx,%eax
    e3bc:	0f b6 00             	movzbl (%eax),%eax
    e3bf:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    e3c1:	8b 45 08             	mov    0x8(%ebp),%eax
    e3c4:	8b 40 08             	mov    0x8(%eax),%eax
    e3c7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e3ca:	c1 e2 02             	shl    $0x2,%edx
    e3cd:	83 c2 02             	add    $0x2,%edx
    e3d0:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e3d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3d6:	8d 50 01             	lea    0x1(%eax),%edx
    e3d9:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e3dc:	8b 55 0c             	mov    0xc(%ebp),%edx
    e3df:	01 d0                	add    %edx,%eax
    e3e1:	0f b6 00             	movzbl (%eax),%eax
    e3e4:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    e3e6:	8b 45 08             	mov    0x8(%ebp),%eax
    e3e9:	8b 40 08             	mov    0x8(%eax),%eax
    e3ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e3ef:	c1 e2 02             	shl    $0x2,%edx
    e3f2:	83 c2 03             	add    $0x3,%edx
    e3f5:	01 d0                	add    %edx,%eax
    e3f7:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    e3fa:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e3fe:	8b 45 08             	mov    0x8(%ebp),%eax
    e401:	8b 40 0c             	mov    0xc(%eax),%eax
    e404:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e407:	0f 85 6d ff ff ff    	jne    e37a <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    e40d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e412:	c9                   	leave  
    e413:	c3                   	ret    

0000e414 <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e414:	55                   	push   %ebp
    e415:	89 e5                	mov    %esp,%ebp
    e417:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    e41a:	8b 45 08             	mov    0x8(%ebp),%eax
    e41d:	8b 00                	mov    (%eax),%eax
    e41f:	83 f8 03             	cmp    $0x3,%eax
    e422:	75 4d                	jne    e471 <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    e424:	8b 45 08             	mov    0x8(%ebp),%eax
    e427:	8b 40 0c             	mov    0xc(%eax),%eax
    e42a:	3b 45 10             	cmp    0x10(%ebp),%eax
    e42d:	7d 0a                	jge    e439 <readChunk_tRNS+0x25>
    e42f:	b8 27 00 00 00       	mov    $0x27,%eax
    e434:	e9 3c 01 00 00       	jmp    e575 <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    e439:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e440:	eb 22                	jmp    e464 <readChunk_tRNS+0x50>
    e442:	8b 45 08             	mov    0x8(%ebp),%eax
    e445:	8b 40 08             	mov    0x8(%eax),%eax
    e448:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e44b:	c1 e2 02             	shl    $0x2,%edx
    e44e:	83 c2 03             	add    $0x3,%edx
    e451:	01 c2                	add    %eax,%edx
    e453:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e456:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e459:	01 c8                	add    %ecx,%eax
    e45b:	0f b6 00             	movzbl (%eax),%eax
    e45e:	88 02                	mov    %al,(%edx)
    e460:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e464:	8b 45 10             	mov    0x10(%ebp),%eax
    e467:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    e46a:	75 d6                	jne    e442 <readChunk_tRNS+0x2e>
    e46c:	e9 ff 00 00 00       	jmp    e570 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    e471:	8b 45 08             	mov    0x8(%ebp),%eax
    e474:	8b 00                	mov    (%eax),%eax
    e476:	85 c0                	test   %eax,%eax
    e478:	75 59                	jne    e4d3 <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    e47a:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e47e:	74 0a                	je     e48a <readChunk_tRNS+0x76>
    e480:	b8 1e 00 00 00       	mov    $0x1e,%eax
    e485:	e9 eb 00 00 00       	jmp    e575 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e48a:	8b 45 08             	mov    0x8(%ebp),%eax
    e48d:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    e494:	8b 45 0c             	mov    0xc(%ebp),%eax
    e497:	0f b6 00             	movzbl (%eax),%eax
    e49a:	0f b6 c0             	movzbl %al,%eax
    e49d:	c1 e0 08             	shl    $0x8,%eax
    e4a0:	89 c2                	mov    %eax,%edx
    e4a2:	8b 45 0c             	mov    0xc(%ebp),%eax
    e4a5:	83 c0 01             	add    $0x1,%eax
    e4a8:	0f b6 00             	movzbl (%eax),%eax
    e4ab:	0f b6 c0             	movzbl %al,%eax
    e4ae:	01 c2                	add    %eax,%edx
    e4b0:	8b 45 08             	mov    0x8(%ebp),%eax
    e4b3:	89 50 1c             	mov    %edx,0x1c(%eax)
    e4b6:	8b 45 08             	mov    0x8(%ebp),%eax
    e4b9:	8b 50 1c             	mov    0x1c(%eax),%edx
    e4bc:	8b 45 08             	mov    0x8(%ebp),%eax
    e4bf:	89 50 18             	mov    %edx,0x18(%eax)
    e4c2:	8b 45 08             	mov    0x8(%ebp),%eax
    e4c5:	8b 50 18             	mov    0x18(%eax),%edx
    e4c8:	8b 45 08             	mov    0x8(%ebp),%eax
    e4cb:	89 50 14             	mov    %edx,0x14(%eax)
    e4ce:	e9 9d 00 00 00       	jmp    e570 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    e4d3:	8b 45 08             	mov    0x8(%ebp),%eax
    e4d6:	8b 00                	mov    (%eax),%eax
    e4d8:	83 f8 02             	cmp    $0x2,%eax
    e4db:	0f 85 88 00 00 00    	jne    e569 <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    e4e1:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e4e5:	74 0a                	je     e4f1 <readChunk_tRNS+0xdd>
    e4e7:	b8 29 00 00 00       	mov    $0x29,%eax
    e4ec:	e9 84 00 00 00       	jmp    e575 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e4f1:	8b 45 08             	mov    0x8(%ebp),%eax
    e4f4:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    e4fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    e4fe:	0f b6 00             	movzbl (%eax),%eax
    e501:	0f b6 c0             	movzbl %al,%eax
    e504:	c1 e0 08             	shl    $0x8,%eax
    e507:	89 c2                	mov    %eax,%edx
    e509:	8b 45 0c             	mov    0xc(%ebp),%eax
    e50c:	83 c0 01             	add    $0x1,%eax
    e50f:	0f b6 00             	movzbl (%eax),%eax
    e512:	0f b6 c0             	movzbl %al,%eax
    e515:	01 c2                	add    %eax,%edx
    e517:	8b 45 08             	mov    0x8(%ebp),%eax
    e51a:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    e51d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e520:	83 c0 02             	add    $0x2,%eax
    e523:	0f b6 00             	movzbl (%eax),%eax
    e526:	0f b6 c0             	movzbl %al,%eax
    e529:	c1 e0 08             	shl    $0x8,%eax
    e52c:	89 c2                	mov    %eax,%edx
    e52e:	8b 45 0c             	mov    0xc(%ebp),%eax
    e531:	83 c0 03             	add    $0x3,%eax
    e534:	0f b6 00             	movzbl (%eax),%eax
    e537:	0f b6 c0             	movzbl %al,%eax
    e53a:	01 c2                	add    %eax,%edx
    e53c:	8b 45 08             	mov    0x8(%ebp),%eax
    e53f:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    e542:	8b 45 0c             	mov    0xc(%ebp),%eax
    e545:	83 c0 04             	add    $0x4,%eax
    e548:	0f b6 00             	movzbl (%eax),%eax
    e54b:	0f b6 c0             	movzbl %al,%eax
    e54e:	c1 e0 08             	shl    $0x8,%eax
    e551:	89 c2                	mov    %eax,%edx
    e553:	8b 45 0c             	mov    0xc(%ebp),%eax
    e556:	83 c0 05             	add    $0x5,%eax
    e559:	0f b6 00             	movzbl (%eax),%eax
    e55c:	0f b6 c0             	movzbl %al,%eax
    e55f:	01 c2                	add    %eax,%edx
    e561:	8b 45 08             	mov    0x8(%ebp),%eax
    e564:	89 50 1c             	mov    %edx,0x1c(%eax)
    e567:	eb 07                	jmp    e570 <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    e569:	b8 2a 00 00 00       	mov    $0x2a,%eax
    e56e:	eb 05                	jmp    e575 <readChunk_tRNS+0x161>

  return 0; /* OK */
    e570:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e575:	c9                   	leave  
    e576:	c3                   	ret    

0000e577 <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e577:	55                   	push   %ebp
    e578:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    e57a:	8b 45 08             	mov    0x8(%ebp),%eax
    e57d:	8b 40 0c             	mov    0xc(%eax),%eax
    e580:	83 f8 03             	cmp    $0x3,%eax
    e583:	75 63                	jne    e5e8 <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    e585:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    e589:	74 0a                	je     e595 <readChunk_bKGD+0x1e>
    e58b:	b8 2b 00 00 00       	mov    $0x2b,%eax
    e590:	e9 63 01 00 00       	jmp    e6f8 <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    e595:	8b 45 0c             	mov    0xc(%ebp),%eax
    e598:	0f b6 00             	movzbl (%eax),%eax
    e59b:	0f b6 d0             	movzbl %al,%edx
    e59e:	8b 45 08             	mov    0x8(%ebp),%eax
    e5a1:	8b 40 18             	mov    0x18(%eax),%eax
    e5a4:	39 c2                	cmp    %eax,%edx
    e5a6:	7c 0a                	jl     e5b2 <readChunk_bKGD+0x3b>
    e5a8:	b8 67 00 00 00       	mov    $0x67,%eax
    e5ad:	e9 46 01 00 00       	jmp    e6f8 <readChunk_bKGD+0x181>

    info->background_defined = 1;
    e5b2:	8b 45 08             	mov    0x8(%ebp),%eax
    e5b5:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    e5bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5bf:	0f b6 00             	movzbl (%eax),%eax
    e5c2:	0f b6 d0             	movzbl %al,%edx
    e5c5:	8b 45 08             	mov    0x8(%ebp),%eax
    e5c8:	89 50 38             	mov    %edx,0x38(%eax)
    e5cb:	8b 45 08             	mov    0x8(%ebp),%eax
    e5ce:	8b 50 38             	mov    0x38(%eax),%edx
    e5d1:	8b 45 08             	mov    0x8(%ebp),%eax
    e5d4:	89 50 34             	mov    %edx,0x34(%eax)
    e5d7:	8b 45 08             	mov    0x8(%ebp),%eax
    e5da:	8b 50 34             	mov    0x34(%eax),%edx
    e5dd:	8b 45 08             	mov    0x8(%ebp),%eax
    e5e0:	89 50 30             	mov    %edx,0x30(%eax)
    e5e3:	e9 0b 01 00 00       	jmp    e6f3 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    e5e8:	8b 45 08             	mov    0x8(%ebp),%eax
    e5eb:	8b 40 0c             	mov    0xc(%eax),%eax
    e5ee:	85 c0                	test   %eax,%eax
    e5f0:	74 0b                	je     e5fd <readChunk_bKGD+0x86>
    e5f2:	8b 45 08             	mov    0x8(%ebp),%eax
    e5f5:	8b 40 0c             	mov    0xc(%eax),%eax
    e5f8:	83 f8 04             	cmp    $0x4,%eax
    e5fb:	75 59                	jne    e656 <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    e5fd:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e601:	74 0a                	je     e60d <readChunk_bKGD+0x96>
    e603:	b8 2c 00 00 00       	mov    $0x2c,%eax
    e608:	e9 eb 00 00 00       	jmp    e6f8 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e60d:	8b 45 08             	mov    0x8(%ebp),%eax
    e610:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    e617:	8b 45 0c             	mov    0xc(%ebp),%eax
    e61a:	0f b6 00             	movzbl (%eax),%eax
    e61d:	0f b6 c0             	movzbl %al,%eax
    e620:	c1 e0 08             	shl    $0x8,%eax
    e623:	89 c2                	mov    %eax,%edx
    e625:	8b 45 0c             	mov    0xc(%ebp),%eax
    e628:	83 c0 01             	add    $0x1,%eax
    e62b:	0f b6 00             	movzbl (%eax),%eax
    e62e:	0f b6 c0             	movzbl %al,%eax
    e631:	01 c2                	add    %eax,%edx
    e633:	8b 45 08             	mov    0x8(%ebp),%eax
    e636:	89 50 38             	mov    %edx,0x38(%eax)
    e639:	8b 45 08             	mov    0x8(%ebp),%eax
    e63c:	8b 50 38             	mov    0x38(%eax),%edx
    e63f:	8b 45 08             	mov    0x8(%ebp),%eax
    e642:	89 50 34             	mov    %edx,0x34(%eax)
    e645:	8b 45 08             	mov    0x8(%ebp),%eax
    e648:	8b 50 34             	mov    0x34(%eax),%edx
    e64b:	8b 45 08             	mov    0x8(%ebp),%eax
    e64e:	89 50 30             	mov    %edx,0x30(%eax)
    e651:	e9 9d 00 00 00       	jmp    e6f3 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    e656:	8b 45 08             	mov    0x8(%ebp),%eax
    e659:	8b 40 0c             	mov    0xc(%eax),%eax
    e65c:	83 f8 02             	cmp    $0x2,%eax
    e65f:	74 0f                	je     e670 <readChunk_bKGD+0xf9>
    e661:	8b 45 08             	mov    0x8(%ebp),%eax
    e664:	8b 40 0c             	mov    0xc(%eax),%eax
    e667:	83 f8 06             	cmp    $0x6,%eax
    e66a:	0f 85 83 00 00 00    	jne    e6f3 <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    e670:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e674:	74 07                	je     e67d <readChunk_bKGD+0x106>
    e676:	b8 2d 00 00 00       	mov    $0x2d,%eax
    e67b:	eb 7b                	jmp    e6f8 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e67d:	8b 45 08             	mov    0x8(%ebp),%eax
    e680:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    e687:	8b 45 0c             	mov    0xc(%ebp),%eax
    e68a:	0f b6 00             	movzbl (%eax),%eax
    e68d:	0f b6 c0             	movzbl %al,%eax
    e690:	c1 e0 08             	shl    $0x8,%eax
    e693:	89 c2                	mov    %eax,%edx
    e695:	8b 45 0c             	mov    0xc(%ebp),%eax
    e698:	83 c0 01             	add    $0x1,%eax
    e69b:	0f b6 00             	movzbl (%eax),%eax
    e69e:	0f b6 c0             	movzbl %al,%eax
    e6a1:	01 c2                	add    %eax,%edx
    e6a3:	8b 45 08             	mov    0x8(%ebp),%eax
    e6a6:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    e6a9:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6ac:	83 c0 02             	add    $0x2,%eax
    e6af:	0f b6 00             	movzbl (%eax),%eax
    e6b2:	0f b6 c0             	movzbl %al,%eax
    e6b5:	c1 e0 08             	shl    $0x8,%eax
    e6b8:	89 c2                	mov    %eax,%edx
    e6ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6bd:	83 c0 03             	add    $0x3,%eax
    e6c0:	0f b6 00             	movzbl (%eax),%eax
    e6c3:	0f b6 c0             	movzbl %al,%eax
    e6c6:	01 c2                	add    %eax,%edx
    e6c8:	8b 45 08             	mov    0x8(%ebp),%eax
    e6cb:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    e6ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6d1:	83 c0 04             	add    $0x4,%eax
    e6d4:	0f b6 00             	movzbl (%eax),%eax
    e6d7:	0f b6 c0             	movzbl %al,%eax
    e6da:	c1 e0 08             	shl    $0x8,%eax
    e6dd:	89 c2                	mov    %eax,%edx
    e6df:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6e2:	83 c0 05             	add    $0x5,%eax
    e6e5:	0f b6 00             	movzbl (%eax),%eax
    e6e8:	0f b6 c0             	movzbl %al,%eax
    e6eb:	01 c2                	add    %eax,%edx
    e6ed:	8b 45 08             	mov    0x8(%ebp),%eax
    e6f0:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    e6f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e6f8:	5d                   	pop    %ebp
    e6f9:	c3                   	ret    

0000e6fa <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e6fa:	55                   	push   %ebp
    e6fb:	89 e5                	mov    %esp,%ebp
    e6fd:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    e700:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    e707:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e70e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e715:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e719:	0f 85 06 01 00 00    	jne    e825 <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    e71f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    e726:	eb 04                	jmp    e72c <readChunk_tEXt+0x32>
    e728:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e72c:	8b 45 10             	mov    0x10(%ebp),%eax
    e72f:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e732:	73 0f                	jae    e743 <readChunk_tEXt+0x49>
    e734:	8b 55 0c             	mov    0xc(%ebp),%edx
    e737:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e73a:	01 d0                	add    %edx,%eax
    e73c:	0f b6 00             	movzbl (%eax),%eax
    e73f:	84 c0                	test   %al,%al
    e741:	75 e5                	jne    e728 <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e743:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e747:	74 06                	je     e74f <readChunk_tEXt+0x55>
    e749:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    e74d:	76 0c                	jbe    e75b <readChunk_tEXt+0x61>
    e74f:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e756:	e9 ca 00 00 00       	jmp    e825 <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    e75b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e75e:	83 c0 01             	add    $0x1,%eax
    e761:	83 ec 0c             	sub    $0xc,%esp
    e764:	50                   	push   %eax
    e765:	e8 73 4b ff ff       	call   32dd <lodepng_malloc>
    e76a:	83 c4 10             	add    $0x10,%esp
    e76d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e770:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e774:	75 0c                	jne    e782 <readChunk_tEXt+0x88>
    e776:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e77d:	e9 a3 00 00 00       	jmp    e825 <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    e782:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e785:	83 ec 04             	sub    $0x4,%esp
    e788:	50                   	push   %eax
    e789:	ff 75 0c             	pushl  0xc(%ebp)
    e78c:	ff 75 f0             	pushl  -0x10(%ebp)
    e78f:	e8 87 4b ff ff       	call   331b <lodepng_memcpy>
    e794:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e797:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e79a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e79d:	01 d0                	add    %edx,%eax
    e79f:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    e7a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7a5:	83 c0 01             	add    $0x1,%eax
    e7a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    e7ab:	8b 45 10             	mov    0x10(%ebp),%eax
    e7ae:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    e7b1:	72 08                	jb     e7bb <readChunk_tEXt+0xc1>
    e7b3:	8b 45 10             	mov    0x10(%ebp),%eax
    e7b6:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    e7b9:	eb 05                	jmp    e7c0 <readChunk_tEXt+0xc6>
    e7bb:	b8 00 00 00 00       	mov    $0x0,%eax
    e7c0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    e7c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7c6:	83 c0 01             	add    $0x1,%eax
    e7c9:	83 ec 0c             	sub    $0xc,%esp
    e7cc:	50                   	push   %eax
    e7cd:	e8 0b 4b ff ff       	call   32dd <lodepng_malloc>
    e7d2:	83 c4 10             	add    $0x10,%esp
    e7d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    e7d8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e7dc:	75 09                	jne    e7e7 <readChunk_tEXt+0xed>
    e7de:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e7e5:	eb 3e                	jmp    e825 <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    e7e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7ea:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e7ed:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e7f0:	01 ca                	add    %ecx,%edx
    e7f2:	83 ec 04             	sub    $0x4,%esp
    e7f5:	50                   	push   %eax
    e7f6:	52                   	push   %edx
    e7f7:	ff 75 ec             	pushl  -0x14(%ebp)
    e7fa:	e8 1c 4b ff ff       	call   331b <lodepng_memcpy>
    e7ff:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    e802:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e805:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e808:	01 d0                	add    %edx,%eax
    e80a:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    e80d:	83 ec 04             	sub    $0x4,%esp
    e810:	ff 75 ec             	pushl  -0x14(%ebp)
    e813:	ff 75 f0             	pushl  -0x10(%ebp)
    e816:	ff 75 08             	pushl  0x8(%ebp)
    e819:	e8 3f ac ff ff       	call   945d <lodepng_add_text>
    e81e:	83 c4 10             	add    $0x10,%esp
    e821:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    e824:	90                   	nop
  }

  lodepng_free(key);
    e825:	83 ec 0c             	sub    $0xc,%esp
    e828:	ff 75 f0             	pushl  -0x10(%ebp)
    e82b:	e8 ce 4a ff ff       	call   32fe <lodepng_free>
    e830:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    e833:	83 ec 0c             	sub    $0xc,%esp
    e836:	ff 75 ec             	pushl  -0x14(%ebp)
    e839:	e8 c0 4a ff ff       	call   32fe <lodepng_free>
    e83e:	83 c4 10             	add    $0x10,%esp

  return error;
    e841:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e844:	c9                   	leave  
    e845:	c3                   	ret    

0000e846 <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    e846:	55                   	push   %ebp
    e847:	89 e5                	mov    %esp,%ebp
    e849:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    e84c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    e853:	8b 45 0c             	mov    0xc(%ebp),%eax
    e856:	8b 10                	mov    (%eax),%edx
    e858:	89 55 d0             	mov    %edx,-0x30(%ebp)
    e85b:	8b 50 04             	mov    0x4(%eax),%edx
    e85e:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    e861:	8b 50 08             	mov    0x8(%eax),%edx
    e864:	89 55 d8             	mov    %edx,-0x28(%ebp)
    e867:	8b 50 0c             	mov    0xc(%eax),%edx
    e86a:	89 55 dc             	mov    %edx,-0x24(%ebp)
    e86d:	8b 50 10             	mov    0x10(%eax),%edx
    e870:	89 55 e0             	mov    %edx,-0x20(%ebp)
    e873:	8b 40 14             	mov    0x14(%eax),%eax
    e876:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    e879:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    e880:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    e887:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e88e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e892:	0f 85 48 01 00 00    	jne    e9e0 <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    e898:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e89f:	eb 04                	jmp    e8a5 <readChunk_zTXt+0x5f>
    e8a1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e8a5:	8b 45 14             	mov    0x14(%ebp),%eax
    e8a8:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e8ab:	73 0f                	jae    e8bc <readChunk_zTXt+0x76>
    e8ad:	8b 55 10             	mov    0x10(%ebp),%edx
    e8b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e8b3:	01 d0                	add    %edx,%eax
    e8b5:	0f b6 00             	movzbl (%eax),%eax
    e8b8:	84 c0                	test   %al,%al
    e8ba:	75 e5                	jne    e8a1 <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    e8bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e8bf:	8d 50 02             	lea    0x2(%eax),%edx
    e8c2:	8b 45 14             	mov    0x14(%ebp),%eax
    e8c5:	39 c2                	cmp    %eax,%edx
    e8c7:	72 0c                	jb     e8d5 <readChunk_zTXt+0x8f>
    e8c9:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    e8d0:	e9 0b 01 00 00       	jmp    e9e0 <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e8d5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e8d9:	74 06                	je     e8e1 <readChunk_zTXt+0x9b>
    e8db:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    e8df:	76 0c                	jbe    e8ed <readChunk_zTXt+0xa7>
    e8e1:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e8e8:	e9 f3 00 00 00       	jmp    e9e0 <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    e8ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e8f0:	83 c0 01             	add    $0x1,%eax
    e8f3:	83 ec 0c             	sub    $0xc,%esp
    e8f6:	50                   	push   %eax
    e8f7:	e8 e1 49 ff ff       	call   32dd <lodepng_malloc>
    e8fc:	83 c4 10             	add    $0x10,%esp
    e8ff:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e902:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e906:	75 0c                	jne    e914 <readChunk_zTXt+0xce>
    e908:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e90f:	e9 cc 00 00 00       	jmp    e9e0 <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    e914:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e917:	83 ec 04             	sub    $0x4,%esp
    e91a:	50                   	push   %eax
    e91b:	ff 75 10             	pushl  0x10(%ebp)
    e91e:	ff 75 ec             	pushl  -0x14(%ebp)
    e921:	e8 f5 49 ff ff       	call   331b <lodepng_memcpy>
    e926:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e929:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e92c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e92f:	01 d0                	add    %edx,%eax
    e931:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    e934:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e937:	8d 50 01             	lea    0x1(%eax),%edx
    e93a:	8b 45 10             	mov    0x10(%ebp),%eax
    e93d:	01 d0                	add    %edx,%eax
    e93f:	0f b6 00             	movzbl (%eax),%eax
    e942:	84 c0                	test   %al,%al
    e944:	74 0c                	je     e952 <readChunk_zTXt+0x10c>
    e946:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    e94d:	e9 8e 00 00 00       	jmp    e9e0 <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    e952:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e955:	83 c0 02             	add    $0x2,%eax
    e958:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    e95b:	8b 45 14             	mov    0x14(%ebp),%eax
    e95e:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e961:	76 09                	jbe    e96c <readChunk_zTXt+0x126>
    e963:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    e96a:	eb 74                	jmp    e9e0 <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    e96c:	8b 45 14             	mov    0x14(%ebp),%eax
    e96f:	2b 45 e8             	sub    -0x18(%ebp),%eax
    e972:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    e975:	8b 45 0c             	mov    0xc(%ebp),%eax
    e978:	8b 40 30             	mov    0x30(%eax),%eax
    e97b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    e97e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e981:	8b 4d 10             	mov    0x10(%ebp),%ecx
    e984:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e987:	01 d1                	add    %edx,%ecx
    e989:	83 ec 08             	sub    $0x8,%esp
    e98c:	8d 55 d0             	lea    -0x30(%ebp),%edx
    e98f:	52                   	push   %edx
    e990:	50                   	push   %eax
    e991:	51                   	push   %ecx
    e992:	6a 00                	push   $0x0
    e994:	8d 45 c8             	lea    -0x38(%ebp),%eax
    e997:	50                   	push   %eax
    e998:	8d 45 cc             	lea    -0x34(%ebp),%eax
    e99b:	50                   	push   %eax
    e99c:	e8 f7 93 ff ff       	call   7d98 <zlib_decompress>
    e9a1:	83 c4 20             	add    $0x20,%esp
    e9a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    e9a7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e9ab:	74 11                	je     e9be <readChunk_zTXt+0x178>
    e9ad:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e9b0:	8b 45 c8             	mov    -0x38(%ebp),%eax
    e9b3:	39 c2                	cmp    %eax,%edx
    e9b5:	7d 07                	jge    e9be <readChunk_zTXt+0x178>
    e9b7:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    e9be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e9c2:	75 1b                	jne    e9df <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    e9c4:	8b 55 c8             	mov    -0x38(%ebp),%edx
    e9c7:	8b 45 cc             	mov    -0x34(%ebp),%eax
    e9ca:	52                   	push   %edx
    e9cb:	50                   	push   %eax
    e9cc:	ff 75 ec             	pushl  -0x14(%ebp)
    e9cf:	ff 75 08             	pushl  0x8(%ebp)
    e9d2:	e8 60 a9 ff ff       	call   9337 <lodepng_add_text_sized>
    e9d7:	83 c4 10             	add    $0x10,%esp
    e9da:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    e9dd:	eb 01                	jmp    e9e0 <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    e9df:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    e9e0:	83 ec 0c             	sub    $0xc,%esp
    e9e3:	ff 75 ec             	pushl  -0x14(%ebp)
    e9e6:	e8 13 49 ff ff       	call   32fe <lodepng_free>
    e9eb:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    e9ee:	8b 45 cc             	mov    -0x34(%ebp),%eax
    e9f1:	83 ec 0c             	sub    $0xc,%esp
    e9f4:	50                   	push   %eax
    e9f5:	e8 04 49 ff ff       	call   32fe <lodepng_free>
    e9fa:	83 c4 10             	add    $0x10,%esp

  return error;
    e9fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ea00:	c9                   	leave  
    ea01:	c3                   	ret    

0000ea02 <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    ea02:	55                   	push   %ebp
    ea03:	89 e5                	mov    %esp,%ebp
    ea05:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    ea08:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    ea0f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea12:	8b 10                	mov    (%eax),%edx
    ea14:	89 55 c0             	mov    %edx,-0x40(%ebp)
    ea17:	8b 50 04             	mov    0x4(%eax),%edx
    ea1a:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    ea1d:	8b 50 08             	mov    0x8(%eax),%edx
    ea20:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ea23:	8b 50 0c             	mov    0xc(%eax),%edx
    ea26:	89 55 cc             	mov    %edx,-0x34(%ebp)
    ea29:	8b 50 10             	mov    0x10(%eax),%edx
    ea2c:	89 55 d0             	mov    %edx,-0x30(%ebp)
    ea2f:	8b 40 14             	mov    0x14(%eax),%eax
    ea32:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    ea35:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ea3c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    ea43:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ea4a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ea4e:	0f 85 d5 02 00 00    	jne    ed29 <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    ea54:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    ea58:	7f 0c                	jg     ea66 <readChunk_iTXt+0x64>
    ea5a:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    ea61:	e9 c3 02 00 00       	jmp    ed29 <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    ea66:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    ea6d:	eb 04                	jmp    ea73 <readChunk_iTXt+0x71>
    ea6f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ea73:	8b 45 14             	mov    0x14(%ebp),%eax
    ea76:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    ea79:	73 0f                	jae    ea8a <readChunk_iTXt+0x88>
    ea7b:	8b 55 10             	mov    0x10(%ebp),%edx
    ea7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ea81:	01 d0                	add    %edx,%eax
    ea83:	0f b6 00             	movzbl (%eax),%eax
    ea86:	84 c0                	test   %al,%al
    ea88:	75 e5                	jne    ea6f <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    ea8a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ea8d:	8d 50 03             	lea    0x3(%eax),%edx
    ea90:	8b 45 14             	mov    0x14(%ebp),%eax
    ea93:	39 c2                	cmp    %eax,%edx
    ea95:	72 0c                	jb     eaa3 <readChunk_iTXt+0xa1>
    ea97:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ea9e:	e9 86 02 00 00       	jmp    ed29 <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    eaa3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    eaa7:	74 06                	je     eaaf <readChunk_iTXt+0xad>
    eaa9:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    eaad:	76 0c                	jbe    eabb <readChunk_iTXt+0xb9>
    eaaf:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    eab6:	e9 6e 02 00 00       	jmp    ed29 <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    eabb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eabe:	83 c0 01             	add    $0x1,%eax
    eac1:	83 ec 0c             	sub    $0xc,%esp
    eac4:	50                   	push   %eax
    eac5:	e8 13 48 ff ff       	call   32dd <lodepng_malloc>
    eaca:	83 c4 10             	add    $0x10,%esp
    eacd:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    ead0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ead4:	75 0c                	jne    eae2 <readChunk_iTXt+0xe0>
    ead6:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eadd:	e9 47 02 00 00       	jmp    ed29 <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    eae2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eae5:	83 ec 04             	sub    $0x4,%esp
    eae8:	50                   	push   %eax
    eae9:	ff 75 10             	pushl  0x10(%ebp)
    eaec:	ff 75 e8             	pushl  -0x18(%ebp)
    eaef:	e8 27 48 ff ff       	call   331b <lodepng_memcpy>
    eaf4:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    eaf7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    eafa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eafd:	01 d0                	add    %edx,%eax
    eaff:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    eb02:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb05:	8d 50 01             	lea    0x1(%eax),%edx
    eb08:	8b 45 10             	mov    0x10(%ebp),%eax
    eb0b:	01 d0                	add    %edx,%eax
    eb0d:	0f b6 00             	movzbl (%eax),%eax
    eb10:	0f b6 c0             	movzbl %al,%eax
    eb13:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    eb16:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb19:	8d 50 02             	lea    0x2(%eax),%edx
    eb1c:	8b 45 10             	mov    0x10(%ebp),%eax
    eb1f:	01 d0                	add    %edx,%eax
    eb21:	0f b6 00             	movzbl (%eax),%eax
    eb24:	84 c0                	test   %al,%al
    eb26:	74 0c                	je     eb34 <readChunk_iTXt+0x132>
    eb28:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    eb2f:	e9 f5 01 00 00       	jmp    ed29 <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    eb34:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb37:	83 c0 03             	add    $0x3,%eax
    eb3a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    eb3d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    eb44:	8b 45 d8             	mov    -0x28(%ebp),%eax
    eb47:	89 45 f0             	mov    %eax,-0x10(%ebp)
    eb4a:	eb 08                	jmp    eb54 <readChunk_iTXt+0x152>
    eb4c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    eb50:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    eb54:	8b 45 14             	mov    0x14(%ebp),%eax
    eb57:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    eb5a:	73 0f                	jae    eb6b <readChunk_iTXt+0x169>
    eb5c:	8b 55 10             	mov    0x10(%ebp),%edx
    eb5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eb62:	01 d0                	add    %edx,%eax
    eb64:	0f b6 00             	movzbl (%eax),%eax
    eb67:	84 c0                	test   %al,%al
    eb69:	75 e1                	jne    eb4c <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    eb6b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb6e:	83 c0 01             	add    $0x1,%eax
    eb71:	83 ec 0c             	sub    $0xc,%esp
    eb74:	50                   	push   %eax
    eb75:	e8 63 47 ff ff       	call   32dd <lodepng_malloc>
    eb7a:	83 c4 10             	add    $0x10,%esp
    eb7d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    eb80:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    eb84:	75 0c                	jne    eb92 <readChunk_iTXt+0x190>
    eb86:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eb8d:	e9 97 01 00 00       	jmp    ed29 <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    eb92:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb95:	8b 4d 10             	mov    0x10(%ebp),%ecx
    eb98:	8b 55 d8             	mov    -0x28(%ebp),%edx
    eb9b:	01 ca                	add    %ecx,%edx
    eb9d:	83 ec 04             	sub    $0x4,%esp
    eba0:	50                   	push   %eax
    eba1:	52                   	push   %edx
    eba2:	ff 75 e4             	pushl  -0x1c(%ebp)
    eba5:	e8 71 47 ff ff       	call   331b <lodepng_memcpy>
    ebaa:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    ebad:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ebb0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebb3:	01 d0                	add    %edx,%eax
    ebb5:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    ebb8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ebbb:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ebbe:	01 d0                	add    %edx,%eax
    ebc0:	83 c0 01             	add    $0x1,%eax
    ebc3:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ebc6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ebcd:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ebd0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ebd3:	eb 08                	jmp    ebdd <readChunk_iTXt+0x1db>
    ebd5:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ebd9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ebdd:	8b 45 14             	mov    0x14(%ebp),%eax
    ebe0:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ebe3:	73 0f                	jae    ebf4 <readChunk_iTXt+0x1f2>
    ebe5:	8b 55 10             	mov    0x10(%ebp),%edx
    ebe8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ebeb:	01 d0                	add    %edx,%eax
    ebed:	0f b6 00             	movzbl (%eax),%eax
    ebf0:	84 c0                	test   %al,%al
    ebf2:	75 e1                	jne    ebd5 <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    ebf4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebf7:	83 c0 01             	add    $0x1,%eax
    ebfa:	83 ec 0c             	sub    $0xc,%esp
    ebfd:	50                   	push   %eax
    ebfe:	e8 da 46 ff ff       	call   32dd <lodepng_malloc>
    ec03:	83 c4 10             	add    $0x10,%esp
    ec06:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    ec09:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ec0d:	75 0c                	jne    ec1b <readChunk_iTXt+0x219>
    ec0f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ec16:	e9 0e 01 00 00       	jmp    ed29 <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    ec1b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec1e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ec21:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ec24:	01 ca                	add    %ecx,%edx
    ec26:	83 ec 04             	sub    $0x4,%esp
    ec29:	50                   	push   %eax
    ec2a:	52                   	push   %edx
    ec2b:	ff 75 e0             	pushl  -0x20(%ebp)
    ec2e:	e8 e8 46 ff ff       	call   331b <lodepng_memcpy>
    ec33:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    ec36:	8b 55 e0             	mov    -0x20(%ebp),%edx
    ec39:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec3c:	01 d0                	add    %edx,%eax
    ec3e:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    ec41:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ec44:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec47:	01 d0                	add    %edx,%eax
    ec49:	83 c0 01             	add    $0x1,%eax
    ec4c:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    ec4f:	8b 45 14             	mov    0x14(%ebp),%eax
    ec52:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ec55:	72 08                	jb     ec5f <readChunk_iTXt+0x25d>
    ec57:	8b 45 14             	mov    0x14(%ebp),%eax
    ec5a:	2b 45 d8             	sub    -0x28(%ebp),%eax
    ec5d:	eb 05                	jmp    ec64 <readChunk_iTXt+0x262>
    ec5f:	b8 00 00 00 00       	mov    $0x0,%eax
    ec64:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    ec67:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    ec6b:	0f 84 90 00 00 00    	je     ed01 <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    ec71:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    ec78:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    ec7f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec82:	8b 40 30             	mov    0x30(%eax),%eax
    ec85:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    ec88:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec8b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ec8e:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ec91:	01 d1                	add    %edx,%ecx
    ec93:	83 ec 08             	sub    $0x8,%esp
    ec96:	8d 55 c0             	lea    -0x40(%ebp),%edx
    ec99:	52                   	push   %edx
    ec9a:	50                   	push   %eax
    ec9b:	51                   	push   %ecx
    ec9c:	6a 00                	push   $0x0
    ec9e:	8d 45 b8             	lea    -0x48(%ebp),%eax
    eca1:	50                   	push   %eax
    eca2:	8d 45 bc             	lea    -0x44(%ebp),%eax
    eca5:	50                   	push   %eax
    eca6:	e8 ed 90 ff ff       	call   7d98 <zlib_decompress>
    ecab:	83 c4 20             	add    $0x20,%esp
    ecae:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    ecb1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ecb5:	74 11                	je     ecc8 <readChunk_iTXt+0x2c6>
    ecb7:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ecba:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ecbd:	39 c2                	cmp    %eax,%edx
    ecbf:	7d 07                	jge    ecc8 <readChunk_iTXt+0x2c6>
    ecc1:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    ecc8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eccc:	75 22                	jne    ecf0 <readChunk_iTXt+0x2ee>
    ecce:	8b 55 b8             	mov    -0x48(%ebp),%edx
    ecd1:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ecd4:	83 ec 08             	sub    $0x8,%esp
    ecd7:	52                   	push   %edx
    ecd8:	50                   	push   %eax
    ecd9:	ff 75 e0             	pushl  -0x20(%ebp)
    ecdc:	ff 75 e4             	pushl  -0x1c(%ebp)
    ecdf:	ff 75 e8             	pushl  -0x18(%ebp)
    ece2:	ff 75 08             	pushl  0x8(%ebp)
    ece5:	e8 94 a9 ff ff       	call   967e <lodepng_add_itext_sized>
    ecea:	83 c4 20             	add    $0x20,%esp
    eced:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    ecf0:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ecf3:	83 ec 0c             	sub    $0xc,%esp
    ecf6:	50                   	push   %eax
    ecf7:	e8 02 46 ff ff       	call   32fe <lodepng_free>
    ecfc:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    ecff:	eb 27                	jmp    ed28 <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    ed01:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed04:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ed07:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ed0a:	01 ca                	add    %ecx,%edx
    ed0c:	83 ec 08             	sub    $0x8,%esp
    ed0f:	50                   	push   %eax
    ed10:	52                   	push   %edx
    ed11:	ff 75 e0             	pushl  -0x20(%ebp)
    ed14:	ff 75 e4             	pushl  -0x1c(%ebp)
    ed17:	ff 75 e8             	pushl  -0x18(%ebp)
    ed1a:	ff 75 08             	pushl  0x8(%ebp)
    ed1d:	e8 5c a9 ff ff       	call   967e <lodepng_add_itext_sized>
    ed22:	83 c4 20             	add    $0x20,%esp
    ed25:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    ed28:	90                   	nop
  }

  lodepng_free(key);
    ed29:	83 ec 0c             	sub    $0xc,%esp
    ed2c:	ff 75 e8             	pushl  -0x18(%ebp)
    ed2f:	e8 ca 45 ff ff       	call   32fe <lodepng_free>
    ed34:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    ed37:	83 ec 0c             	sub    $0xc,%esp
    ed3a:	ff 75 e4             	pushl  -0x1c(%ebp)
    ed3d:	e8 bc 45 ff ff       	call   32fe <lodepng_free>
    ed42:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    ed45:	83 ec 0c             	sub    $0xc,%esp
    ed48:	ff 75 e0             	pushl  -0x20(%ebp)
    ed4b:	e8 ae 45 ff ff       	call   32fe <lodepng_free>
    ed50:	83 c4 10             	add    $0x10,%esp

  return error;
    ed53:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ed56:	c9                   	leave  
    ed57:	c3                   	ret    

0000ed58 <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ed58:	55                   	push   %ebp
    ed59:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    ed5b:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    ed5f:	74 0a                	je     ed6b <readChunk_tIME+0x13>
    ed61:	b8 49 00 00 00       	mov    $0x49,%eax
    ed66:	e9 8b 00 00 00       	jmp    edf6 <readChunk_tIME+0x9e>

  info->time_defined = 1;
    ed6b:	8b 45 08             	mov    0x8(%ebp),%eax
    ed6e:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    ed75:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed78:	0f b6 00             	movzbl (%eax),%eax
    ed7b:	0f b6 c0             	movzbl %al,%eax
    ed7e:	c1 e0 08             	shl    $0x8,%eax
    ed81:	89 c2                	mov    %eax,%edx
    ed83:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed86:	83 c0 01             	add    $0x1,%eax
    ed89:	0f b6 00             	movzbl (%eax),%eax
    ed8c:	0f b6 c0             	movzbl %al,%eax
    ed8f:	01 c2                	add    %eax,%edx
    ed91:	8b 45 08             	mov    0x8(%ebp),%eax
    ed94:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    ed97:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed9a:	83 c0 02             	add    $0x2,%eax
    ed9d:	0f b6 00             	movzbl (%eax),%eax
    eda0:	0f b6 d0             	movzbl %al,%edx
    eda3:	8b 45 08             	mov    0x8(%ebp),%eax
    eda6:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    eda9:	8b 45 0c             	mov    0xc(%ebp),%eax
    edac:	83 c0 03             	add    $0x3,%eax
    edaf:	0f b6 00             	movzbl (%eax),%eax
    edb2:	0f b6 d0             	movzbl %al,%edx
    edb5:	8b 45 08             	mov    0x8(%ebp),%eax
    edb8:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    edbb:	8b 45 0c             	mov    0xc(%ebp),%eax
    edbe:	83 c0 04             	add    $0x4,%eax
    edc1:	0f b6 00             	movzbl (%eax),%eax
    edc4:	0f b6 d0             	movzbl %al,%edx
    edc7:	8b 45 08             	mov    0x8(%ebp),%eax
    edca:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    edcd:	8b 45 0c             	mov    0xc(%ebp),%eax
    edd0:	83 c0 05             	add    $0x5,%eax
    edd3:	0f b6 00             	movzbl (%eax),%eax
    edd6:	0f b6 d0             	movzbl %al,%edx
    edd9:	8b 45 08             	mov    0x8(%ebp),%eax
    eddc:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    eddf:	8b 45 0c             	mov    0xc(%ebp),%eax
    ede2:	83 c0 06             	add    $0x6,%eax
    ede5:	0f b6 00             	movzbl (%eax),%eax
    ede8:	0f b6 d0             	movzbl %al,%edx
    edeb:	8b 45 08             	mov    0x8(%ebp),%eax
    edee:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    edf1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    edf6:	5d                   	pop    %ebp
    edf7:	c3                   	ret    

0000edf8 <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    edf8:	55                   	push   %ebp
    edf9:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    edfb:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    edff:	74 0a                	je     ee0b <readChunk_pHYs+0x13>
    ee01:	b8 4a 00 00 00       	mov    $0x4a,%eax
    ee06:	e9 ba 00 00 00       	jmp    eec5 <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    ee0b:	8b 45 08             	mov    0x8(%ebp),%eax
    ee0e:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    ee15:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee18:	0f b6 00             	movzbl (%eax),%eax
    ee1b:	0f b6 c0             	movzbl %al,%eax
    ee1e:	c1 e0 08             	shl    $0x8,%eax
    ee21:	89 c2                	mov    %eax,%edx
    ee23:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee26:	83 c0 01             	add    $0x1,%eax
    ee29:	0f b6 00             	movzbl (%eax),%eax
    ee2c:	0f b6 c0             	movzbl %al,%eax
    ee2f:	01 d0                	add    %edx,%eax
    ee31:	c1 e0 08             	shl    $0x8,%eax
    ee34:	89 c2                	mov    %eax,%edx
    ee36:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee39:	83 c0 02             	add    $0x2,%eax
    ee3c:	0f b6 00             	movzbl (%eax),%eax
    ee3f:	0f b6 c0             	movzbl %al,%eax
    ee42:	01 d0                	add    %edx,%eax
    ee44:	c1 e0 08             	shl    $0x8,%eax
    ee47:	89 c2                	mov    %eax,%edx
    ee49:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee4c:	83 c0 03             	add    $0x3,%eax
    ee4f:	0f b6 00             	movzbl (%eax),%eax
    ee52:	0f b6 c0             	movzbl %al,%eax
    ee55:	01 c2                	add    %eax,%edx
    ee57:	8b 45 08             	mov    0x8(%ebp),%eax
    ee5a:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    ee5d:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee60:	83 c0 04             	add    $0x4,%eax
    ee63:	0f b6 00             	movzbl (%eax),%eax
    ee66:	0f b6 c0             	movzbl %al,%eax
    ee69:	c1 e0 08             	shl    $0x8,%eax
    ee6c:	89 c2                	mov    %eax,%edx
    ee6e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee71:	83 c0 05             	add    $0x5,%eax
    ee74:	0f b6 00             	movzbl (%eax),%eax
    ee77:	0f b6 c0             	movzbl %al,%eax
    ee7a:	01 d0                	add    %edx,%eax
    ee7c:	c1 e0 08             	shl    $0x8,%eax
    ee7f:	89 c2                	mov    %eax,%edx
    ee81:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee84:	83 c0 06             	add    $0x6,%eax
    ee87:	0f b6 00             	movzbl (%eax),%eax
    ee8a:	0f b6 c0             	movzbl %al,%eax
    ee8d:	01 d0                	add    %edx,%eax
    ee8f:	c1 e0 08             	shl    $0x8,%eax
    ee92:	89 c2                	mov    %eax,%edx
    ee94:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee97:	83 c0 07             	add    $0x7,%eax
    ee9a:	0f b6 00             	movzbl (%eax),%eax
    ee9d:	0f b6 c0             	movzbl %al,%eax
    eea0:	01 c2                	add    %eax,%edx
    eea2:	8b 45 08             	mov    0x8(%ebp),%eax
    eea5:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    eeab:	8b 45 0c             	mov    0xc(%ebp),%eax
    eeae:	83 c0 08             	add    $0x8,%eax
    eeb1:	0f b6 00             	movzbl (%eax),%eax
    eeb4:	0f b6 d0             	movzbl %al,%edx
    eeb7:	8b 45 08             	mov    0x8(%ebp),%eax
    eeba:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    eec0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    eec5:	5d                   	pop    %ebp
    eec6:	c3                   	ret    

0000eec7 <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    eec7:	55                   	push   %ebp
    eec8:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    eeca:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    eece:	74 07                	je     eed7 <readChunk_gAMA+0x10>
    eed0:	b8 60 00 00 00       	mov    $0x60,%eax
    eed5:	eb 5d                	jmp    ef34 <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    eed7:	8b 45 08             	mov    0x8(%ebp),%eax
    eeda:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    eee1:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    eee4:	8b 45 0c             	mov    0xc(%ebp),%eax
    eee7:	0f b6 00             	movzbl (%eax),%eax
    eeea:	0f b6 c0             	movzbl %al,%eax
    eeed:	c1 e0 08             	shl    $0x8,%eax
    eef0:	89 c2                	mov    %eax,%edx
    eef2:	8b 45 0c             	mov    0xc(%ebp),%eax
    eef5:	83 c0 01             	add    $0x1,%eax
    eef8:	0f b6 00             	movzbl (%eax),%eax
    eefb:	0f b6 c0             	movzbl %al,%eax
    eefe:	01 d0                	add    %edx,%eax
    ef00:	c1 e0 08             	shl    $0x8,%eax
    ef03:	89 c2                	mov    %eax,%edx
    ef05:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef08:	83 c0 02             	add    $0x2,%eax
    ef0b:	0f b6 00             	movzbl (%eax),%eax
    ef0e:	0f b6 c0             	movzbl %al,%eax
    ef11:	01 d0                	add    %edx,%eax
    ef13:	c1 e0 08             	shl    $0x8,%eax
    ef16:	89 c2                	mov    %eax,%edx
    ef18:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef1b:	83 c0 03             	add    $0x3,%eax
    ef1e:	0f b6 00             	movzbl (%eax),%eax
    ef21:	0f b6 c0             	movzbl %al,%eax
    ef24:	01 c2                	add    %eax,%edx
    ef26:	8b 45 08             	mov    0x8(%ebp),%eax
    ef29:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    ef2f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ef34:	5d                   	pop    %ebp
    ef35:	c3                   	ret    

0000ef36 <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ef36:	55                   	push   %ebp
    ef37:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    ef39:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    ef3d:	74 0a                	je     ef49 <readChunk_cHRM+0x13>
    ef3f:	b8 61 00 00 00       	mov    $0x61,%eax
    ef44:	e9 7f 02 00 00       	jmp    f1c8 <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    ef49:	8b 45 08             	mov    0x8(%ebp),%eax
    ef4c:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    ef53:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    ef56:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef59:	0f b6 00             	movzbl (%eax),%eax
    ef5c:	0f b6 c0             	movzbl %al,%eax
    ef5f:	c1 e0 08             	shl    $0x8,%eax
    ef62:	89 c2                	mov    %eax,%edx
    ef64:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef67:	83 c0 01             	add    $0x1,%eax
    ef6a:	0f b6 00             	movzbl (%eax),%eax
    ef6d:	0f b6 c0             	movzbl %al,%eax
    ef70:	01 d0                	add    %edx,%eax
    ef72:	c1 e0 08             	shl    $0x8,%eax
    ef75:	89 c2                	mov    %eax,%edx
    ef77:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef7a:	83 c0 02             	add    $0x2,%eax
    ef7d:	0f b6 00             	movzbl (%eax),%eax
    ef80:	0f b6 c0             	movzbl %al,%eax
    ef83:	01 d0                	add    %edx,%eax
    ef85:	c1 e0 08             	shl    $0x8,%eax
    ef88:	89 c2                	mov    %eax,%edx
    ef8a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef8d:	83 c0 03             	add    $0x3,%eax
    ef90:	0f b6 00             	movzbl (%eax),%eax
    ef93:	0f b6 c0             	movzbl %al,%eax
    ef96:	01 c2                	add    %eax,%edx
    ef98:	8b 45 08             	mov    0x8(%ebp),%eax
    ef9b:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    efa1:	8b 45 0c             	mov    0xc(%ebp),%eax
    efa4:	83 c0 04             	add    $0x4,%eax
    efa7:	0f b6 00             	movzbl (%eax),%eax
    efaa:	0f b6 c0             	movzbl %al,%eax
    efad:	c1 e0 08             	shl    $0x8,%eax
    efb0:	89 c2                	mov    %eax,%edx
    efb2:	8b 45 0c             	mov    0xc(%ebp),%eax
    efb5:	83 c0 05             	add    $0x5,%eax
    efb8:	0f b6 00             	movzbl (%eax),%eax
    efbb:	0f b6 c0             	movzbl %al,%eax
    efbe:	01 d0                	add    %edx,%eax
    efc0:	c1 e0 08             	shl    $0x8,%eax
    efc3:	89 c2                	mov    %eax,%edx
    efc5:	8b 45 0c             	mov    0xc(%ebp),%eax
    efc8:	83 c0 06             	add    $0x6,%eax
    efcb:	0f b6 00             	movzbl (%eax),%eax
    efce:	0f b6 c0             	movzbl %al,%eax
    efd1:	01 d0                	add    %edx,%eax
    efd3:	c1 e0 08             	shl    $0x8,%eax
    efd6:	89 c2                	mov    %eax,%edx
    efd8:	8b 45 0c             	mov    0xc(%ebp),%eax
    efdb:	83 c0 07             	add    $0x7,%eax
    efde:	0f b6 00             	movzbl (%eax),%eax
    efe1:	0f b6 c0             	movzbl %al,%eax
    efe4:	01 c2                	add    %eax,%edx
    efe6:	8b 45 08             	mov    0x8(%ebp),%eax
    efe9:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    efef:	8b 45 0c             	mov    0xc(%ebp),%eax
    eff2:	83 c0 08             	add    $0x8,%eax
    eff5:	0f b6 00             	movzbl (%eax),%eax
    eff8:	0f b6 c0             	movzbl %al,%eax
    effb:	c1 e0 08             	shl    $0x8,%eax
    effe:	89 c2                	mov    %eax,%edx
    f000:	8b 45 0c             	mov    0xc(%ebp),%eax
    f003:	83 c0 09             	add    $0x9,%eax
    f006:	0f b6 00             	movzbl (%eax),%eax
    f009:	0f b6 c0             	movzbl %al,%eax
    f00c:	01 d0                	add    %edx,%eax
    f00e:	c1 e0 08             	shl    $0x8,%eax
    f011:	89 c2                	mov    %eax,%edx
    f013:	8b 45 0c             	mov    0xc(%ebp),%eax
    f016:	83 c0 0a             	add    $0xa,%eax
    f019:	0f b6 00             	movzbl (%eax),%eax
    f01c:	0f b6 c0             	movzbl %al,%eax
    f01f:	01 d0                	add    %edx,%eax
    f021:	c1 e0 08             	shl    $0x8,%eax
    f024:	89 c2                	mov    %eax,%edx
    f026:	8b 45 0c             	mov    0xc(%ebp),%eax
    f029:	83 c0 0b             	add    $0xb,%eax
    f02c:	0f b6 00             	movzbl (%eax),%eax
    f02f:	0f b6 c0             	movzbl %al,%eax
    f032:	01 c2                	add    %eax,%edx
    f034:	8b 45 08             	mov    0x8(%ebp),%eax
    f037:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    f03d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f040:	83 c0 0c             	add    $0xc,%eax
    f043:	0f b6 00             	movzbl (%eax),%eax
    f046:	0f b6 c0             	movzbl %al,%eax
    f049:	c1 e0 08             	shl    $0x8,%eax
    f04c:	89 c2                	mov    %eax,%edx
    f04e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f051:	83 c0 0d             	add    $0xd,%eax
    f054:	0f b6 00             	movzbl (%eax),%eax
    f057:	0f b6 c0             	movzbl %al,%eax
    f05a:	01 d0                	add    %edx,%eax
    f05c:	c1 e0 08             	shl    $0x8,%eax
    f05f:	89 c2                	mov    %eax,%edx
    f061:	8b 45 0c             	mov    0xc(%ebp),%eax
    f064:	83 c0 0e             	add    $0xe,%eax
    f067:	0f b6 00             	movzbl (%eax),%eax
    f06a:	0f b6 c0             	movzbl %al,%eax
    f06d:	01 d0                	add    %edx,%eax
    f06f:	c1 e0 08             	shl    $0x8,%eax
    f072:	89 c2                	mov    %eax,%edx
    f074:	8b 45 0c             	mov    0xc(%ebp),%eax
    f077:	83 c0 0f             	add    $0xf,%eax
    f07a:	0f b6 00             	movzbl (%eax),%eax
    f07d:	0f b6 c0             	movzbl %al,%eax
    f080:	01 c2                	add    %eax,%edx
    f082:	8b 45 08             	mov    0x8(%ebp),%eax
    f085:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    f08b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f08e:	83 c0 10             	add    $0x10,%eax
    f091:	0f b6 00             	movzbl (%eax),%eax
    f094:	0f b6 c0             	movzbl %al,%eax
    f097:	c1 e0 08             	shl    $0x8,%eax
    f09a:	89 c2                	mov    %eax,%edx
    f09c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f09f:	83 c0 11             	add    $0x11,%eax
    f0a2:	0f b6 00             	movzbl (%eax),%eax
    f0a5:	0f b6 c0             	movzbl %al,%eax
    f0a8:	01 d0                	add    %edx,%eax
    f0aa:	c1 e0 08             	shl    $0x8,%eax
    f0ad:	89 c2                	mov    %eax,%edx
    f0af:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0b2:	83 c0 12             	add    $0x12,%eax
    f0b5:	0f b6 00             	movzbl (%eax),%eax
    f0b8:	0f b6 c0             	movzbl %al,%eax
    f0bb:	01 d0                	add    %edx,%eax
    f0bd:	c1 e0 08             	shl    $0x8,%eax
    f0c0:	89 c2                	mov    %eax,%edx
    f0c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0c5:	83 c0 13             	add    $0x13,%eax
    f0c8:	0f b6 00             	movzbl (%eax),%eax
    f0cb:	0f b6 c0             	movzbl %al,%eax
    f0ce:	01 c2                	add    %eax,%edx
    f0d0:	8b 45 08             	mov    0x8(%ebp),%eax
    f0d3:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    f0d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0dc:	83 c0 14             	add    $0x14,%eax
    f0df:	0f b6 00             	movzbl (%eax),%eax
    f0e2:	0f b6 c0             	movzbl %al,%eax
    f0e5:	c1 e0 08             	shl    $0x8,%eax
    f0e8:	89 c2                	mov    %eax,%edx
    f0ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0ed:	83 c0 15             	add    $0x15,%eax
    f0f0:	0f b6 00             	movzbl (%eax),%eax
    f0f3:	0f b6 c0             	movzbl %al,%eax
    f0f6:	01 d0                	add    %edx,%eax
    f0f8:	c1 e0 08             	shl    $0x8,%eax
    f0fb:	89 c2                	mov    %eax,%edx
    f0fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    f100:	83 c0 16             	add    $0x16,%eax
    f103:	0f b6 00             	movzbl (%eax),%eax
    f106:	0f b6 c0             	movzbl %al,%eax
    f109:	01 d0                	add    %edx,%eax
    f10b:	c1 e0 08             	shl    $0x8,%eax
    f10e:	89 c2                	mov    %eax,%edx
    f110:	8b 45 0c             	mov    0xc(%ebp),%eax
    f113:	83 c0 17             	add    $0x17,%eax
    f116:	0f b6 00             	movzbl (%eax),%eax
    f119:	0f b6 c0             	movzbl %al,%eax
    f11c:	01 c2                	add    %eax,%edx
    f11e:	8b 45 08             	mov    0x8(%ebp),%eax
    f121:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    f127:	8b 45 0c             	mov    0xc(%ebp),%eax
    f12a:	83 c0 18             	add    $0x18,%eax
    f12d:	0f b6 00             	movzbl (%eax),%eax
    f130:	0f b6 c0             	movzbl %al,%eax
    f133:	c1 e0 08             	shl    $0x8,%eax
    f136:	89 c2                	mov    %eax,%edx
    f138:	8b 45 0c             	mov    0xc(%ebp),%eax
    f13b:	83 c0 19             	add    $0x19,%eax
    f13e:	0f b6 00             	movzbl (%eax),%eax
    f141:	0f b6 c0             	movzbl %al,%eax
    f144:	01 d0                	add    %edx,%eax
    f146:	c1 e0 08             	shl    $0x8,%eax
    f149:	89 c2                	mov    %eax,%edx
    f14b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f14e:	83 c0 1a             	add    $0x1a,%eax
    f151:	0f b6 00             	movzbl (%eax),%eax
    f154:	0f b6 c0             	movzbl %al,%eax
    f157:	01 d0                	add    %edx,%eax
    f159:	c1 e0 08             	shl    $0x8,%eax
    f15c:	89 c2                	mov    %eax,%edx
    f15e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f161:	83 c0 1b             	add    $0x1b,%eax
    f164:	0f b6 00             	movzbl (%eax),%eax
    f167:	0f b6 c0             	movzbl %al,%eax
    f16a:	01 c2                	add    %eax,%edx
    f16c:	8b 45 08             	mov    0x8(%ebp),%eax
    f16f:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    f175:	8b 45 0c             	mov    0xc(%ebp),%eax
    f178:	83 c0 1c             	add    $0x1c,%eax
    f17b:	0f b6 00             	movzbl (%eax),%eax
    f17e:	0f b6 c0             	movzbl %al,%eax
    f181:	c1 e0 08             	shl    $0x8,%eax
    f184:	89 c2                	mov    %eax,%edx
    f186:	8b 45 0c             	mov    0xc(%ebp),%eax
    f189:	83 c0 1d             	add    $0x1d,%eax
    f18c:	0f b6 00             	movzbl (%eax),%eax
    f18f:	0f b6 c0             	movzbl %al,%eax
    f192:	01 d0                	add    %edx,%eax
    f194:	c1 e0 08             	shl    $0x8,%eax
    f197:	89 c2                	mov    %eax,%edx
    f199:	8b 45 0c             	mov    0xc(%ebp),%eax
    f19c:	83 c0 1e             	add    $0x1e,%eax
    f19f:	0f b6 00             	movzbl (%eax),%eax
    f1a2:	0f b6 c0             	movzbl %al,%eax
    f1a5:	01 d0                	add    %edx,%eax
    f1a7:	c1 e0 08             	shl    $0x8,%eax
    f1aa:	89 c2                	mov    %eax,%edx
    f1ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1af:	83 c0 1f             	add    $0x1f,%eax
    f1b2:	0f b6 00             	movzbl (%eax),%eax
    f1b5:	0f b6 c0             	movzbl %al,%eax
    f1b8:	01 c2                	add    %eax,%edx
    f1ba:	8b 45 08             	mov    0x8(%ebp),%eax
    f1bd:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    f1c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f1c8:	5d                   	pop    %ebp
    f1c9:	c3                   	ret    

0000f1ca <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f1ca:	55                   	push   %ebp
    f1cb:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    f1cd:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f1d1:	74 07                	je     f1da <readChunk_sRGB+0x10>
    f1d3:	b8 62 00 00 00       	mov    $0x62,%eax
    f1d8:	eb 24                	jmp    f1fe <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    f1da:	8b 45 08             	mov    0x8(%ebp),%eax
    f1dd:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    f1e4:	00 00 00 
  info->srgb_intent = data[0];
    f1e7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1ea:	0f b6 00             	movzbl (%eax),%eax
    f1ed:	0f b6 d0             	movzbl %al,%edx
    f1f0:	8b 45 08             	mov    0x8(%ebp),%eax
    f1f3:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    f1f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f1fe:	5d                   	pop    %ebp
    f1ff:	c3                   	ret    

0000f200 <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f200:	55                   	push   %ebp
    f201:	89 e5                	mov    %esp,%ebp
    f203:	53                   	push   %ebx
    f204:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    f207:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    f20e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f215:	8b 45 0c             	mov    0xc(%ebp),%eax
    f218:	8b 10                	mov    (%eax),%edx
    f21a:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f21d:	8b 50 04             	mov    0x4(%eax),%edx
    f220:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f223:	8b 50 08             	mov    0x8(%eax),%edx
    f226:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f229:	8b 50 0c             	mov    0xc(%eax),%edx
    f22c:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f22f:	8b 50 10             	mov    0x10(%eax),%edx
    f232:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f235:	8b 40 14             	mov    0x14(%eax),%eax
    f238:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    f23b:	8b 45 08             	mov    0x8(%ebp),%eax
    f23e:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    f245:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    f248:	8b 45 08             	mov    0x8(%ebp),%eax
    f24b:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f251:	85 c0                	test   %eax,%eax
    f253:	74 0e                	je     f263 <readChunk_iCCP+0x63>
    f255:	83 ec 0c             	sub    $0xc,%esp
    f258:	ff 75 08             	pushl  0x8(%ebp)
    f25b:	e8 ca a6 ff ff       	call   992a <lodepng_clear_icc>
    f260:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f263:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f26a:	eb 04                	jmp    f270 <readChunk_iCCP+0x70>
    f26c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f270:	8b 45 14             	mov    0x14(%ebp),%eax
    f273:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f276:	73 0f                	jae    f287 <readChunk_iCCP+0x87>
    f278:	8b 55 10             	mov    0x10(%ebp),%edx
    f27b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f27e:	01 d0                	add    %edx,%eax
    f280:	0f b6 00             	movzbl (%eax),%eax
    f283:	84 c0                	test   %al,%al
    f285:	75 e5                	jne    f26c <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    f287:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f28a:	8d 50 02             	lea    0x2(%eax),%edx
    f28d:	8b 45 14             	mov    0x14(%ebp),%eax
    f290:	39 c2                	cmp    %eax,%edx
    f292:	72 0a                	jb     f29e <readChunk_iCCP+0x9e>
    f294:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f299:	e9 46 01 00 00       	jmp    f3e4 <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    f29e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f2a2:	74 06                	je     f2aa <readChunk_iCCP+0xaa>
    f2a4:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f2a8:	76 0a                	jbe    f2b4 <readChunk_iCCP+0xb4>
    f2aa:	b8 59 00 00 00       	mov    $0x59,%eax
    f2af:	e9 30 01 00 00       	jmp    f3e4 <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    f2b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2b7:	83 c0 01             	add    $0x1,%eax
    f2ba:	83 ec 0c             	sub    $0xc,%esp
    f2bd:	50                   	push   %eax
    f2be:	e8 1a 40 ff ff       	call   32dd <lodepng_malloc>
    f2c3:	83 c4 10             	add    $0x10,%esp
    f2c6:	89 c2                	mov    %eax,%edx
    f2c8:	8b 45 08             	mov    0x8(%ebp),%eax
    f2cb:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    f2d1:	8b 45 08             	mov    0x8(%ebp),%eax
    f2d4:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f2da:	85 c0                	test   %eax,%eax
    f2dc:	75 0a                	jne    f2e8 <readChunk_iCCP+0xe8>
    f2de:	b8 53 00 00 00       	mov    $0x53,%eax
    f2e3:	e9 fc 00 00 00       	jmp    f3e4 <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    f2e8:	8b 45 08             	mov    0x8(%ebp),%eax
    f2eb:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f2f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2f4:	01 d0                	add    %edx,%eax
    f2f6:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    f2f9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f300:	eb 1f                	jmp    f321 <readChunk_iCCP+0x121>
    f302:	8b 45 08             	mov    0x8(%ebp),%eax
    f305:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f30b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f30e:	01 d0                	add    %edx,%eax
    f310:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f313:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f316:	01 ca                	add    %ecx,%edx
    f318:	0f b6 12             	movzbl (%edx),%edx
    f31b:	88 10                	mov    %dl,(%eax)
    f31d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f321:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f324:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f327:	75 d9                	jne    f302 <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    f329:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f32c:	8d 50 01             	lea    0x1(%eax),%edx
    f32f:	8b 45 10             	mov    0x10(%ebp),%eax
    f332:	01 d0                	add    %edx,%eax
    f334:	0f b6 00             	movzbl (%eax),%eax
    f337:	84 c0                	test   %al,%al
    f339:	74 0a                	je     f345 <readChunk_iCCP+0x145>
    f33b:	b8 48 00 00 00       	mov    $0x48,%eax
    f340:	e9 9f 00 00 00       	jmp    f3e4 <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    f345:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f348:	83 c0 02             	add    $0x2,%eax
    f34b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    f34e:	8b 45 14             	mov    0x14(%ebp),%eax
    f351:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f354:	76 0a                	jbe    f360 <readChunk_iCCP+0x160>
    f356:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f35b:	e9 84 00 00 00       	jmp    f3e4 <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    f360:	8b 45 14             	mov    0x14(%ebp),%eax
    f363:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f366:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    f369:	8b 45 0c             	mov    0xc(%ebp),%eax
    f36c:	8b 40 34             	mov    0x34(%eax),%eax
    f36f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    f372:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f375:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f378:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f37b:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    f37e:	8b 55 08             	mov    0x8(%ebp),%edx
    f381:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    f387:	83 ec 08             	sub    $0x8,%esp
    f38a:	8d 55 cc             	lea    -0x34(%ebp),%edx
    f38d:	52                   	push   %edx
    f38e:	50                   	push   %eax
    f38f:	53                   	push   %ebx
    f390:	6a 00                	push   $0x0
    f392:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    f395:	50                   	push   %eax
    f396:	51                   	push   %ecx
    f397:	e8 fc 89 ff ff       	call   7d98 <zlib_decompress>
    f39c:	83 c4 20             	add    $0x20,%esp
    f39f:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    f3a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f3a6:	74 11                	je     f3b9 <readChunk_iCCP+0x1b9>
    f3a8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    f3ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f3ae:	39 c2                	cmp    %eax,%edx
    f3b0:	7d 07                	jge    f3b9 <readChunk_iCCP+0x1b9>
    f3b2:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    f3b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f3bc:	89 c2                	mov    %eax,%edx
    f3be:	8b 45 08             	mov    0x8(%ebp),%eax
    f3c1:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    f3c7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f3cb:	75 14                	jne    f3e1 <readChunk_iCCP+0x1e1>
    f3cd:	8b 45 08             	mov    0x8(%ebp),%eax
    f3d0:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    f3d6:	85 c0                	test   %eax,%eax
    f3d8:	75 07                	jne    f3e1 <readChunk_iCCP+0x1e1>
    f3da:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    f3e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f3e4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f3e7:	c9                   	leave  
    f3e8:	c3                   	ret    

0000f3e9 <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    f3e9:	55                   	push   %ebp
    f3ea:	89 e5                	mov    %esp,%ebp
    f3ec:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    f3ef:	8b 55 0c             	mov    0xc(%ebp),%edx
    f3f2:	8b 45 10             	mov    0x10(%ebp),%eax
    f3f5:	01 d0                	add    %edx,%eax
    f3f7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    f3fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    f401:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    f408:	8b 45 0c             	mov    0xc(%ebp),%eax
    f40b:	83 c0 04             	add    $0x4,%eax
    f40e:	3b 45 14             	cmp    0x14(%ebp),%eax
    f411:	7e 0a                	jle    f41d <lodepng_inspect_chunk+0x34>
    f413:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f418:	e9 43 03 00 00       	jmp    f760 <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    f41d:	ff 75 ec             	pushl  -0x14(%ebp)
    f420:	e8 3a 8e ff ff       	call   825f <lodepng_chunk_length>
    f425:	83 c4 04             	add    $0x4,%esp
    f428:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    f42b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f42e:	85 c0                	test   %eax,%eax
    f430:	79 0a                	jns    f43c <lodepng_inspect_chunk+0x53>
    f432:	b8 3f 00 00 00       	mov    $0x3f,%eax
    f437:	e9 24 03 00 00       	jmp    f760 <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
    f43c:	ff 75 ec             	pushl  -0x14(%ebp)
    f43f:	e8 53 8f ff ff       	call   8397 <lodepng_chunk_data_const>
    f444:	83 c4 04             	add    $0x4,%esp
    f447:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
    f44a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f44d:	8d 50 04             	lea    0x4(%eax),%edx
    f450:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f453:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    f456:	8b 55 14             	mov    0x14(%ebp),%edx
    f459:	8b 45 10             	mov    0x10(%ebp),%eax
    f45c:	01 d0                	add    %edx,%eax
    f45e:	39 c1                	cmp    %eax,%ecx
    f460:	76 0a                	jbe    f46c <lodepng_inspect_chunk+0x83>
    f462:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f467:	e9 f4 02 00 00       	jmp    f760 <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    f46c:	68 08 a0 01 00       	push   $0x1a008
    f471:	ff 75 ec             	pushl  -0x14(%ebp)
    f474:	e8 33 8e ff ff       	call   82ac <lodepng_chunk_type_equals>
    f479:	83 c4 08             	add    $0x8,%esp
    f47c:	84 c0                	test   %al,%al
    f47e:	74 24                	je     f4a4 <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    f480:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f483:	8b 55 08             	mov    0x8(%ebp),%edx
    f486:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f48c:	83 ec 04             	sub    $0x4,%esp
    f48f:	50                   	push   %eax
    f490:	ff 75 e4             	pushl  -0x1c(%ebp)
    f493:	52                   	push   %edx
    f494:	e8 5b ee ff ff       	call   e2f4 <readChunk_PLTE>
    f499:	83 c4 10             	add    $0x10,%esp
    f49c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f49f:	e9 8a 02 00 00       	jmp    f72e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    f4a4:	83 ec 08             	sub    $0x8,%esp
    f4a7:	68 0d a0 01 00       	push   $0x1a00d
    f4ac:	ff 75 ec             	pushl  -0x14(%ebp)
    f4af:	e8 f8 8d ff ff       	call   82ac <lodepng_chunk_type_equals>
    f4b4:	83 c4 10             	add    $0x10,%esp
    f4b7:	84 c0                	test   %al,%al
    f4b9:	74 24                	je     f4df <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    f4bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f4be:	8b 55 08             	mov    0x8(%ebp),%edx
    f4c1:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f4c7:	83 ec 04             	sub    $0x4,%esp
    f4ca:	50                   	push   %eax
    f4cb:	ff 75 e4             	pushl  -0x1c(%ebp)
    f4ce:	52                   	push   %edx
    f4cf:	e8 40 ef ff ff       	call   e414 <readChunk_tRNS>
    f4d4:	83 c4 10             	add    $0x10,%esp
    f4d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f4da:	e9 4f 02 00 00       	jmp    f72e <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    f4df:	83 ec 08             	sub    $0x8,%esp
    f4e2:	68 12 a0 01 00       	push   $0x1a012
    f4e7:	ff 75 ec             	pushl  -0x14(%ebp)
    f4ea:	e8 bd 8d ff ff       	call   82ac <lodepng_chunk_type_equals>
    f4ef:	83 c4 10             	add    $0x10,%esp
    f4f2:	84 c0                	test   %al,%al
    f4f4:	74 24                	je     f51a <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
    f4f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f4f9:	8b 55 08             	mov    0x8(%ebp),%edx
    f4fc:	81 c2 98 00 00 00    	add    $0x98,%edx
    f502:	83 ec 04             	sub    $0x4,%esp
    f505:	50                   	push   %eax
    f506:	ff 75 e4             	pushl  -0x1c(%ebp)
    f509:	52                   	push   %edx
    f50a:	e8 68 f0 ff ff       	call   e577 <readChunk_bKGD>
    f50f:	83 c4 10             	add    $0x10,%esp
    f512:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f515:	e9 14 02 00 00       	jmp    f72e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    f51a:	83 ec 08             	sub    $0x8,%esp
    f51d:	68 17 a0 01 00       	push   $0x1a017
    f522:	ff 75 ec             	pushl  -0x14(%ebp)
    f525:	e8 82 8d ff ff       	call   82ac <lodepng_chunk_type_equals>
    f52a:	83 c4 10             	add    $0x10,%esp
    f52d:	84 c0                	test   %al,%al
    f52f:	74 24                	je     f555 <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
    f531:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f534:	8b 55 08             	mov    0x8(%ebp),%edx
    f537:	81 c2 98 00 00 00    	add    $0x98,%edx
    f53d:	83 ec 04             	sub    $0x4,%esp
    f540:	50                   	push   %eax
    f541:	ff 75 e4             	pushl  -0x1c(%ebp)
    f544:	52                   	push   %edx
    f545:	e8 b0 f1 ff ff       	call   e6fa <readChunk_tEXt>
    f54a:	83 c4 10             	add    $0x10,%esp
    f54d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f550:	e9 d9 01 00 00       	jmp    f72e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    f555:	83 ec 08             	sub    $0x8,%esp
    f558:	68 1c a0 01 00       	push   $0x1a01c
    f55d:	ff 75 ec             	pushl  -0x14(%ebp)
    f560:	e8 47 8d ff ff       	call   82ac <lodepng_chunk_type_equals>
    f565:	83 c4 10             	add    $0x10,%esp
    f568:	84 c0                	test   %al,%al
    f56a:	74 25                	je     f591 <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    f56c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f56f:	8b 45 08             	mov    0x8(%ebp),%eax
    f572:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f575:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f57b:	52                   	push   %edx
    f57c:	ff 75 e4             	pushl  -0x1c(%ebp)
    f57f:	50                   	push   %eax
    f580:	51                   	push   %ecx
    f581:	e8 c0 f2 ff ff       	call   e846 <readChunk_zTXt>
    f586:	83 c4 10             	add    $0x10,%esp
    f589:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f58c:	e9 9d 01 00 00       	jmp    f72e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    f591:	83 ec 08             	sub    $0x8,%esp
    f594:	68 21 a0 01 00       	push   $0x1a021
    f599:	ff 75 ec             	pushl  -0x14(%ebp)
    f59c:	e8 0b 8d ff ff       	call   82ac <lodepng_chunk_type_equals>
    f5a1:	83 c4 10             	add    $0x10,%esp
    f5a4:	84 c0                	test   %al,%al
    f5a6:	74 25                	je     f5cd <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    f5a8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f5ab:	8b 45 08             	mov    0x8(%ebp),%eax
    f5ae:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f5b1:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f5b7:	52                   	push   %edx
    f5b8:	ff 75 e4             	pushl  -0x1c(%ebp)
    f5bb:	50                   	push   %eax
    f5bc:	51                   	push   %ecx
    f5bd:	e8 40 f4 ff ff       	call   ea02 <readChunk_iTXt>
    f5c2:	83 c4 10             	add    $0x10,%esp
    f5c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f5c8:	e9 61 01 00 00       	jmp    f72e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    f5cd:	83 ec 08             	sub    $0x8,%esp
    f5d0:	68 26 a0 01 00       	push   $0x1a026
    f5d5:	ff 75 ec             	pushl  -0x14(%ebp)
    f5d8:	e8 cf 8c ff ff       	call   82ac <lodepng_chunk_type_equals>
    f5dd:	83 c4 10             	add    $0x10,%esp
    f5e0:	84 c0                	test   %al,%al
    f5e2:	74 24                	je     f608 <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
    f5e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f5e7:	8b 55 08             	mov    0x8(%ebp),%edx
    f5ea:	81 c2 98 00 00 00    	add    $0x98,%edx
    f5f0:	83 ec 04             	sub    $0x4,%esp
    f5f3:	50                   	push   %eax
    f5f4:	ff 75 e4             	pushl  -0x1c(%ebp)
    f5f7:	52                   	push   %edx
    f5f8:	e8 5b f7 ff ff       	call   ed58 <readChunk_tIME>
    f5fd:	83 c4 10             	add    $0x10,%esp
    f600:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f603:	e9 26 01 00 00       	jmp    f72e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    f608:	83 ec 08             	sub    $0x8,%esp
    f60b:	68 2b a0 01 00       	push   $0x1a02b
    f610:	ff 75 ec             	pushl  -0x14(%ebp)
    f613:	e8 94 8c ff ff       	call   82ac <lodepng_chunk_type_equals>
    f618:	83 c4 10             	add    $0x10,%esp
    f61b:	84 c0                	test   %al,%al
    f61d:	74 24                	je     f643 <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
    f61f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f622:	8b 55 08             	mov    0x8(%ebp),%edx
    f625:	81 c2 98 00 00 00    	add    $0x98,%edx
    f62b:	83 ec 04             	sub    $0x4,%esp
    f62e:	50                   	push   %eax
    f62f:	ff 75 e4             	pushl  -0x1c(%ebp)
    f632:	52                   	push   %edx
    f633:	e8 c0 f7 ff ff       	call   edf8 <readChunk_pHYs>
    f638:	83 c4 10             	add    $0x10,%esp
    f63b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f63e:	e9 eb 00 00 00       	jmp    f72e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    f643:	83 ec 08             	sub    $0x8,%esp
    f646:	68 30 a0 01 00       	push   $0x1a030
    f64b:	ff 75 ec             	pushl  -0x14(%ebp)
    f64e:	e8 59 8c ff ff       	call   82ac <lodepng_chunk_type_equals>
    f653:	83 c4 10             	add    $0x10,%esp
    f656:	84 c0                	test   %al,%al
    f658:	74 24                	je     f67e <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
    f65a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f65d:	8b 55 08             	mov    0x8(%ebp),%edx
    f660:	81 c2 98 00 00 00    	add    $0x98,%edx
    f666:	83 ec 04             	sub    $0x4,%esp
    f669:	50                   	push   %eax
    f66a:	ff 75 e4             	pushl  -0x1c(%ebp)
    f66d:	52                   	push   %edx
    f66e:	e8 54 f8 ff ff       	call   eec7 <readChunk_gAMA>
    f673:	83 c4 10             	add    $0x10,%esp
    f676:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f679:	e9 b0 00 00 00       	jmp    f72e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    f67e:	83 ec 08             	sub    $0x8,%esp
    f681:	68 35 a0 01 00       	push   $0x1a035
    f686:	ff 75 ec             	pushl  -0x14(%ebp)
    f689:	e8 1e 8c ff ff       	call   82ac <lodepng_chunk_type_equals>
    f68e:	83 c4 10             	add    $0x10,%esp
    f691:	84 c0                	test   %al,%al
    f693:	74 21                	je     f6b6 <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
    f695:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f698:	8b 55 08             	mov    0x8(%ebp),%edx
    f69b:	81 c2 98 00 00 00    	add    $0x98,%edx
    f6a1:	83 ec 04             	sub    $0x4,%esp
    f6a4:	50                   	push   %eax
    f6a5:	ff 75 e4             	pushl  -0x1c(%ebp)
    f6a8:	52                   	push   %edx
    f6a9:	e8 88 f8 ff ff       	call   ef36 <readChunk_cHRM>
    f6ae:	83 c4 10             	add    $0x10,%esp
    f6b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6b4:	eb 78                	jmp    f72e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    f6b6:	83 ec 08             	sub    $0x8,%esp
    f6b9:	68 3a a0 01 00       	push   $0x1a03a
    f6be:	ff 75 ec             	pushl  -0x14(%ebp)
    f6c1:	e8 e6 8b ff ff       	call   82ac <lodepng_chunk_type_equals>
    f6c6:	83 c4 10             	add    $0x10,%esp
    f6c9:	84 c0                	test   %al,%al
    f6cb:	74 21                	je     f6ee <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
    f6cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f6d0:	8b 55 08             	mov    0x8(%ebp),%edx
    f6d3:	81 c2 98 00 00 00    	add    $0x98,%edx
    f6d9:	83 ec 04             	sub    $0x4,%esp
    f6dc:	50                   	push   %eax
    f6dd:	ff 75 e4             	pushl  -0x1c(%ebp)
    f6e0:	52                   	push   %edx
    f6e1:	e8 e4 fa ff ff       	call   f1ca <readChunk_sRGB>
    f6e6:	83 c4 10             	add    $0x10,%esp
    f6e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6ec:	eb 40                	jmp    f72e <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    f6ee:	83 ec 08             	sub    $0x8,%esp
    f6f1:	68 3f a0 01 00       	push   $0x1a03f
    f6f6:	ff 75 ec             	pushl  -0x14(%ebp)
    f6f9:	e8 ae 8b ff ff       	call   82ac <lodepng_chunk_type_equals>
    f6fe:	83 c4 10             	add    $0x10,%esp
    f701:	84 c0                	test   %al,%al
    f703:	74 22                	je     f727 <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    f705:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f708:	8b 45 08             	mov    0x8(%ebp),%eax
    f70b:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f70e:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f714:	52                   	push   %edx
    f715:	ff 75 e4             	pushl  -0x1c(%ebp)
    f718:	50                   	push   %eax
    f719:	51                   	push   %ecx
    f71a:	e8 e1 fa ff ff       	call   f200 <readChunk_iCCP>
    f71f:	83 c4 10             	add    $0x10,%esp
    f722:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f725:	eb 07                	jmp    f72e <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
    f727:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
    f72e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f732:	75 29                	jne    f75d <lodepng_inspect_chunk+0x374>
    f734:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f738:	75 23                	jne    f75d <lodepng_inspect_chunk+0x374>
    f73a:	8b 45 08             	mov    0x8(%ebp),%eax
    f73d:	8b 40 18             	mov    0x18(%eax),%eax
    f740:	85 c0                	test   %eax,%eax
    f742:	75 19                	jne    f75d <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
    f744:	83 ec 0c             	sub    $0xc,%esp
    f747:	ff 75 ec             	pushl  -0x14(%ebp)
    f74a:	e8 53 8c ff ff       	call   83a2 <lodepng_chunk_check_crc>
    f74f:	83 c4 10             	add    $0x10,%esp
    f752:	85 c0                	test   %eax,%eax
    f754:	74 07                	je     f75d <lodepng_inspect_chunk+0x374>
    f756:	b8 39 00 00 00       	mov    $0x39,%eax
    f75b:	eb 03                	jmp    f760 <lodepng_inspect_chunk+0x377>
  }

  return error;
    f75d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    f760:	c9                   	leave  
    f761:	c3                   	ret    

0000f762 <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
    f762:	55                   	push   %ebp
    f763:	89 e5                	mov    %esp,%ebp
    f765:	56                   	push   %esi
    f766:	53                   	push   %ebx
    f767:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
    f76a:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
    f76e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
    f775:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
    f77c:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    f783:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
    f78a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
    f791:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
    f798:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
    f79f:	8b 45 08             	mov    0x8(%ebp),%eax
    f7a2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
    f7a8:	8b 45 10             	mov    0x10(%ebp),%eax
    f7ab:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    f7b1:	8b 45 10             	mov    0x10(%ebp),%eax
    f7b4:	8b 10                	mov    (%eax),%edx
    f7b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7b9:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
    f7bb:	83 ec 0c             	sub    $0xc,%esp
    f7be:	ff 75 1c             	pushl  0x1c(%ebp)
    f7c1:	ff 75 18             	pushl  0x18(%ebp)
    f7c4:	ff 75 14             	pushl  0x14(%ebp)
    f7c7:	ff 75 10             	pushl  0x10(%ebp)
    f7ca:	ff 75 0c             	pushl  0xc(%ebp)
    f7cd:	e8 d3 da ff ff       	call   d2a5 <lodepng_inspect>
    f7d2:	83 c4 20             	add    $0x20,%esp
    f7d5:	89 c2                	mov    %eax,%edx
    f7d7:	8b 45 14             	mov    0x14(%ebp),%eax
    f7da:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
    f7e0:	8b 45 14             	mov    0x14(%ebp),%eax
    f7e3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    f7e9:	85 c0                	test   %eax,%eax
    f7eb:	0f 85 24 0a 00 00    	jne    10215 <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
    f7f1:	8b 45 14             	mov    0x14(%ebp),%eax
    f7f4:	8d 58 78             	lea    0x78(%eax),%ebx
    f7f7:	8b 45 14             	mov    0x14(%ebp),%eax
    f7fa:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
    f800:	8b 45 10             	mov    0x10(%ebp),%eax
    f803:	8b 10                	mov    (%eax),%edx
    f805:	8b 45 0c             	mov    0xc(%ebp),%eax
    f808:	8b 00                	mov    (%eax),%eax
    f80a:	53                   	push   %ebx
    f80b:	51                   	push   %ecx
    f80c:	52                   	push   %edx
    f80d:	50                   	push   %eax
    f80e:	e8 76 97 ff ff       	call   8f89 <lodepng_pixel_overflow>
    f813:	83 c4 10             	add    $0x10,%esp
    f816:	85 c0                	test   %eax,%eax
    f818:	74 12                	je     f82c <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
    f81a:	8b 45 14             	mov    0x14(%ebp),%eax
    f81d:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
    f824:	00 00 00 
    f827:	e9 ea 09 00 00       	jmp    10216 <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
    f82c:	83 ec 0c             	sub    $0xc,%esp
    f82f:	ff 75 1c             	pushl  0x1c(%ebp)
    f832:	e8 a6 3a ff ff       	call   32dd <lodepng_malloc>
    f837:	83 c4 10             	add    $0x10,%esp
    f83a:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
    f83d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    f841:	75 12                	jne    f855 <decodeGeneric+0xf3>
    f843:	8b 45 14             	mov    0x14(%ebp),%eax
    f846:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
    f84d:	00 00 00 
    f850:	e9 c1 09 00 00       	jmp    10216 <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
    f855:	8b 45 18             	mov    0x18(%ebp),%eax
    f858:	83 c0 21             	add    $0x21,%eax
    f85b:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    f85e:	e9 81 06 00 00       	jmp    fee4 <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
    f863:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f866:	8b 45 18             	mov    0x18(%ebp),%eax
    f869:	29 c2                	sub    %eax,%edx
    f86b:	89 d0                	mov    %edx,%eax
    f86d:	83 c0 0c             	add    $0xc,%eax
    f870:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f873:	7f 08                	jg     f87d <decodeGeneric+0x11b>
    f875:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f878:	3b 45 18             	cmp    0x18(%ebp),%eax
    f87b:	73 20                	jae    f89d <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f87d:	8b 45 14             	mov    0x14(%ebp),%eax
    f880:	8b 40 20             	mov    0x20(%eax),%eax
    f883:	85 c0                	test   %eax,%eax
    f885:	0f 85 72 06 00 00    	jne    fefd <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
    f88b:	8b 45 14             	mov    0x14(%ebp),%eax
    f88e:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
    f895:	00 00 00 
    f898:	e9 6a 06 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    f89d:	83 ec 0c             	sub    $0xc,%esp
    f8a0:	ff 75 f0             	pushl  -0x10(%ebp)
    f8a3:	e8 b7 89 ff ff       	call   825f <lodepng_chunk_length>
    f8a8:	83 c4 10             	add    $0x10,%esp
    f8ab:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
    f8ae:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f8b1:	85 c0                	test   %eax,%eax
    f8b3:	79 20                	jns    f8d5 <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f8b5:	8b 45 14             	mov    0x14(%ebp),%eax
    f8b8:	8b 40 20             	mov    0x20(%eax),%eax
    f8bb:	85 c0                	test   %eax,%eax
    f8bd:	0f 85 3d 06 00 00    	jne    ff00 <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
    f8c3:	8b 45 14             	mov    0x14(%ebp),%eax
    f8c6:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
    f8cd:	00 00 00 
    f8d0:	e9 32 06 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
    f8d5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f8d8:	8b 45 18             	mov    0x18(%ebp),%eax
    f8db:	29 c2                	sub    %eax,%edx
    f8dd:	89 d0                	mov    %edx,%eax
    f8df:	89 c2                	mov    %eax,%edx
    f8e1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f8e4:	01 d0                	add    %edx,%eax
    f8e6:	83 c0 0c             	add    $0xc,%eax
    f8e9:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f8ec:	7f 10                	jg     f8fe <decodeGeneric+0x19c>
    f8ee:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f8f1:	8d 50 0c             	lea    0xc(%eax),%edx
    f8f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f8f7:	01 d0                	add    %edx,%eax
    f8f9:	3b 45 18             	cmp    0x18(%ebp),%eax
    f8fc:	73 12                	jae    f910 <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    f8fe:	8b 45 14             	mov    0x14(%ebp),%eax
    f901:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
    f908:	00 00 00 
    f90b:	e9 f7 05 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
    f910:	83 ec 0c             	sub    $0xc,%esp
    f913:	ff 75 f0             	pushl  -0x10(%ebp)
    f916:	e8 7c 8a ff ff       	call   8397 <lodepng_chunk_data_const>
    f91b:	83 c4 10             	add    $0x10,%esp
    f91e:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
    f921:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
    f928:	83 ec 08             	sub    $0x8,%esp
    f92b:	68 44 a0 01 00       	push   $0x1a044
    f930:	ff 75 f0             	pushl  -0x10(%ebp)
    f933:	e8 74 89 ff ff       	call   82ac <lodepng_chunk_type_equals>
    f938:	83 c4 10             	add    $0x10,%esp
    f93b:	84 c0                	test   %al,%al
    f93d:	74 79                	je     f9b8 <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
    f93f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f942:	83 ec 04             	sub    $0x4,%esp
    f945:	8d 55 bc             	lea    -0x44(%ebp),%edx
    f948:	52                   	push   %edx
    f949:	50                   	push   %eax
    f94a:	ff 75 ec             	pushl  -0x14(%ebp)
    f94d:	e8 4f 3a ff ff       	call   33a1 <lodepng_addofl>
    f952:	83 c4 10             	add    $0x10,%esp
    f955:	85 c0                	test   %eax,%eax
    f957:	74 12                	je     f96b <decodeGeneric+0x209>
    f959:	8b 45 14             	mov    0x14(%ebp),%eax
    f95c:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    f963:	00 00 00 
    f966:	e9 9c 05 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
    f96b:	8b 45 bc             	mov    -0x44(%ebp),%eax
    f96e:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f971:	7e 13                	jle    f986 <decodeGeneric+0x224>
    f973:	8b 45 14             	mov    0x14(%ebp),%eax
    f976:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    f97d:	00 00 00 
    f980:	90                   	nop
    f981:	e9 81 05 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
    f986:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f989:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    f98c:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f98f:	01 ca                	add    %ecx,%edx
    f991:	83 ec 04             	sub    $0x4,%esp
    f994:	50                   	push   %eax
    f995:	ff 75 d0             	pushl  -0x30(%ebp)
    f998:	52                   	push   %edx
    f999:	e8 7d 39 ff ff       	call   331b <lodepng_memcpy>
    f99e:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
    f9a1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f9a4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9a7:	01 d0                	add    %edx,%eax
    f9a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
    f9ac:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
    f9b3:	e9 db 04 00 00       	jmp    fe93 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
    f9b8:	83 ec 08             	sub    $0x8,%esp
    f9bb:	68 49 a0 01 00       	push   $0x1a049
    f9c0:	ff 75 f0             	pushl  -0x10(%ebp)
    f9c3:	e8 e4 88 ff ff       	call   82ac <lodepng_chunk_type_equals>
    f9c8:	83 c4 10             	add    $0x10,%esp
    f9cb:	84 c0                	test   %al,%al
    f9cd:	74 09                	je     f9d8 <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
    f9cf:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
    f9d3:	e9 bb 04 00 00       	jmp    fe93 <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    f9d8:	83 ec 08             	sub    $0x8,%esp
    f9db:	68 08 a0 01 00       	push   $0x1a008
    f9e0:	ff 75 f0             	pushl  -0x10(%ebp)
    f9e3:	e8 c4 88 ff ff       	call   82ac <lodepng_chunk_type_equals>
    f9e8:	83 c4 10             	add    $0x10,%esp
    f9eb:	84 c0                	test   %al,%al
    f9ed:	74 44                	je     fa33 <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    f9ef:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9f2:	8b 55 14             	mov    0x14(%ebp),%edx
    f9f5:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f9fb:	83 ec 04             	sub    $0x4,%esp
    f9fe:	50                   	push   %eax
    f9ff:	ff 75 d0             	pushl  -0x30(%ebp)
    fa02:	52                   	push   %edx
    fa03:	e8 ec e8 ff ff       	call   e2f4 <readChunk_PLTE>
    fa08:	83 c4 10             	add    $0x10,%esp
    fa0b:	89 c2                	mov    %eax,%edx
    fa0d:	8b 45 14             	mov    0x14(%ebp),%eax
    fa10:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fa16:	8b 45 14             	mov    0x14(%ebp),%eax
    fa19:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fa1f:	85 c0                	test   %eax,%eax
    fa21:	0f 85 dc 04 00 00    	jne    ff03 <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
    fa27:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
    fa2e:	e9 60 04 00 00       	jmp    fe93 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fa33:	83 ec 08             	sub    $0x8,%esp
    fa36:	68 0d a0 01 00       	push   $0x1a00d
    fa3b:	ff 75 f0             	pushl  -0x10(%ebp)
    fa3e:	e8 69 88 ff ff       	call   82ac <lodepng_chunk_type_equals>
    fa43:	83 c4 10             	add    $0x10,%esp
    fa46:	84 c0                	test   %al,%al
    fa48:	74 3d                	je     fa87 <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    fa4a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa4d:	8b 55 14             	mov    0x14(%ebp),%edx
    fa50:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fa56:	83 ec 04             	sub    $0x4,%esp
    fa59:	50                   	push   %eax
    fa5a:	ff 75 d0             	pushl  -0x30(%ebp)
    fa5d:	52                   	push   %edx
    fa5e:	e8 b1 e9 ff ff       	call   e414 <readChunk_tRNS>
    fa63:	83 c4 10             	add    $0x10,%esp
    fa66:	89 c2                	mov    %eax,%edx
    fa68:	8b 45 14             	mov    0x14(%ebp),%eax
    fa6b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fa71:	8b 45 14             	mov    0x14(%ebp),%eax
    fa74:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fa7a:	85 c0                	test   %eax,%eax
    fa7c:	0f 84 11 04 00 00    	je     fe93 <decodeGeneric+0x731>
    fa82:	e9 80 04 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    fa87:	83 ec 08             	sub    $0x8,%esp
    fa8a:	68 12 a0 01 00       	push   $0x1a012
    fa8f:	ff 75 f0             	pushl  -0x10(%ebp)
    fa92:	e8 15 88 ff ff       	call   82ac <lodepng_chunk_type_equals>
    fa97:	83 c4 10             	add    $0x10,%esp
    fa9a:	84 c0                	test   %al,%al
    fa9c:	74 3d                	je     fadb <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
    fa9e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    faa1:	8b 55 14             	mov    0x14(%ebp),%edx
    faa4:	81 c2 98 00 00 00    	add    $0x98,%edx
    faaa:	83 ec 04             	sub    $0x4,%esp
    faad:	50                   	push   %eax
    faae:	ff 75 d0             	pushl  -0x30(%ebp)
    fab1:	52                   	push   %edx
    fab2:	e8 c0 ea ff ff       	call   e577 <readChunk_bKGD>
    fab7:	83 c4 10             	add    $0x10,%esp
    faba:	89 c2                	mov    %eax,%edx
    fabc:	8b 45 14             	mov    0x14(%ebp),%eax
    fabf:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fac5:	8b 45 14             	mov    0x14(%ebp),%eax
    fac8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    face:	85 c0                	test   %eax,%eax
    fad0:	0f 84 bd 03 00 00    	je     fe93 <decodeGeneric+0x731>
    fad6:	e9 2c 04 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    fadb:	83 ec 08             	sub    $0x8,%esp
    fade:	68 17 a0 01 00       	push   $0x1a017
    fae3:	ff 75 f0             	pushl  -0x10(%ebp)
    fae6:	e8 c1 87 ff ff       	call   82ac <lodepng_chunk_type_equals>
    faeb:	83 c4 10             	add    $0x10,%esp
    faee:	84 c0                	test   %al,%al
    faf0:	74 4b                	je     fb3d <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
    faf2:	8b 45 14             	mov    0x14(%ebp),%eax
    faf5:	8b 40 28             	mov    0x28(%eax),%eax
    faf8:	85 c0                	test   %eax,%eax
    fafa:	0f 84 93 03 00 00    	je     fe93 <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
    fb00:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb03:	8b 55 14             	mov    0x14(%ebp),%edx
    fb06:	81 c2 98 00 00 00    	add    $0x98,%edx
    fb0c:	83 ec 04             	sub    $0x4,%esp
    fb0f:	50                   	push   %eax
    fb10:	ff 75 d0             	pushl  -0x30(%ebp)
    fb13:	52                   	push   %edx
    fb14:	e8 e1 eb ff ff       	call   e6fa <readChunk_tEXt>
    fb19:	83 c4 10             	add    $0x10,%esp
    fb1c:	89 c2                	mov    %eax,%edx
    fb1e:	8b 45 14             	mov    0x14(%ebp),%eax
    fb21:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fb27:	8b 45 14             	mov    0x14(%ebp),%eax
    fb2a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb30:	85 c0                	test   %eax,%eax
    fb32:	0f 84 5b 03 00 00    	je     fe93 <decodeGeneric+0x731>
    fb38:	e9 ca 03 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    fb3d:	83 ec 08             	sub    $0x8,%esp
    fb40:	68 1c a0 01 00       	push   $0x1a01c
    fb45:	ff 75 f0             	pushl  -0x10(%ebp)
    fb48:	e8 5f 87 ff ff       	call   82ac <lodepng_chunk_type_equals>
    fb4d:	83 c4 10             	add    $0x10,%esp
    fb50:	84 c0                	test   %al,%al
    fb52:	74 4c                	je     fba0 <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
    fb54:	8b 45 14             	mov    0x14(%ebp),%eax
    fb57:	8b 40 28             	mov    0x28(%eax),%eax
    fb5a:	85 c0                	test   %eax,%eax
    fb5c:	0f 84 31 03 00 00    	je     fe93 <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    fb62:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fb65:	8b 45 14             	mov    0x14(%ebp),%eax
    fb68:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fb6b:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fb71:	52                   	push   %edx
    fb72:	ff 75 d0             	pushl  -0x30(%ebp)
    fb75:	50                   	push   %eax
    fb76:	51                   	push   %ecx
    fb77:	e8 ca ec ff ff       	call   e846 <readChunk_zTXt>
    fb7c:	83 c4 10             	add    $0x10,%esp
    fb7f:	89 c2                	mov    %eax,%edx
    fb81:	8b 45 14             	mov    0x14(%ebp),%eax
    fb84:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fb8a:	8b 45 14             	mov    0x14(%ebp),%eax
    fb8d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb93:	85 c0                	test   %eax,%eax
    fb95:	0f 84 f8 02 00 00    	je     fe93 <decodeGeneric+0x731>
    fb9b:	e9 67 03 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    fba0:	83 ec 08             	sub    $0x8,%esp
    fba3:	68 21 a0 01 00       	push   $0x1a021
    fba8:	ff 75 f0             	pushl  -0x10(%ebp)
    fbab:	e8 fc 86 ff ff       	call   82ac <lodepng_chunk_type_equals>
    fbb0:	83 c4 10             	add    $0x10,%esp
    fbb3:	84 c0                	test   %al,%al
    fbb5:	74 4c                	je     fc03 <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
    fbb7:	8b 45 14             	mov    0x14(%ebp),%eax
    fbba:	8b 40 28             	mov    0x28(%eax),%eax
    fbbd:	85 c0                	test   %eax,%eax
    fbbf:	0f 84 ce 02 00 00    	je     fe93 <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    fbc5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fbc8:	8b 45 14             	mov    0x14(%ebp),%eax
    fbcb:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fbce:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fbd4:	52                   	push   %edx
    fbd5:	ff 75 d0             	pushl  -0x30(%ebp)
    fbd8:	50                   	push   %eax
    fbd9:	51                   	push   %ecx
    fbda:	e8 23 ee ff ff       	call   ea02 <readChunk_iTXt>
    fbdf:	83 c4 10             	add    $0x10,%esp
    fbe2:	89 c2                	mov    %eax,%edx
    fbe4:	8b 45 14             	mov    0x14(%ebp),%eax
    fbe7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fbed:	8b 45 14             	mov    0x14(%ebp),%eax
    fbf0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fbf6:	85 c0                	test   %eax,%eax
    fbf8:	0f 84 95 02 00 00    	je     fe93 <decodeGeneric+0x731>
    fbfe:	e9 04 03 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    fc03:	83 ec 08             	sub    $0x8,%esp
    fc06:	68 26 a0 01 00       	push   $0x1a026
    fc0b:	ff 75 f0             	pushl  -0x10(%ebp)
    fc0e:	e8 99 86 ff ff       	call   82ac <lodepng_chunk_type_equals>
    fc13:	83 c4 10             	add    $0x10,%esp
    fc16:	84 c0                	test   %al,%al
    fc18:	74 3d                	je     fc57 <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
    fc1a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fc1d:	8b 55 14             	mov    0x14(%ebp),%edx
    fc20:	81 c2 98 00 00 00    	add    $0x98,%edx
    fc26:	83 ec 04             	sub    $0x4,%esp
    fc29:	50                   	push   %eax
    fc2a:	ff 75 d0             	pushl  -0x30(%ebp)
    fc2d:	52                   	push   %edx
    fc2e:	e8 25 f1 ff ff       	call   ed58 <readChunk_tIME>
    fc33:	83 c4 10             	add    $0x10,%esp
    fc36:	89 c2                	mov    %eax,%edx
    fc38:	8b 45 14             	mov    0x14(%ebp),%eax
    fc3b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fc41:	8b 45 14             	mov    0x14(%ebp),%eax
    fc44:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc4a:	85 c0                	test   %eax,%eax
    fc4c:	0f 84 41 02 00 00    	je     fe93 <decodeGeneric+0x731>
    fc52:	e9 b0 02 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    fc57:	83 ec 08             	sub    $0x8,%esp
    fc5a:	68 2b a0 01 00       	push   $0x1a02b
    fc5f:	ff 75 f0             	pushl  -0x10(%ebp)
    fc62:	e8 45 86 ff ff       	call   82ac <lodepng_chunk_type_equals>
    fc67:	83 c4 10             	add    $0x10,%esp
    fc6a:	84 c0                	test   %al,%al
    fc6c:	74 3d                	je     fcab <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
    fc6e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fc71:	8b 55 14             	mov    0x14(%ebp),%edx
    fc74:	81 c2 98 00 00 00    	add    $0x98,%edx
    fc7a:	83 ec 04             	sub    $0x4,%esp
    fc7d:	50                   	push   %eax
    fc7e:	ff 75 d0             	pushl  -0x30(%ebp)
    fc81:	52                   	push   %edx
    fc82:	e8 71 f1 ff ff       	call   edf8 <readChunk_pHYs>
    fc87:	83 c4 10             	add    $0x10,%esp
    fc8a:	89 c2                	mov    %eax,%edx
    fc8c:	8b 45 14             	mov    0x14(%ebp),%eax
    fc8f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fc95:	8b 45 14             	mov    0x14(%ebp),%eax
    fc98:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc9e:	85 c0                	test   %eax,%eax
    fca0:	0f 84 ed 01 00 00    	je     fe93 <decodeGeneric+0x731>
    fca6:	e9 5c 02 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    fcab:	83 ec 08             	sub    $0x8,%esp
    fcae:	68 30 a0 01 00       	push   $0x1a030
    fcb3:	ff 75 f0             	pushl  -0x10(%ebp)
    fcb6:	e8 f1 85 ff ff       	call   82ac <lodepng_chunk_type_equals>
    fcbb:	83 c4 10             	add    $0x10,%esp
    fcbe:	84 c0                	test   %al,%al
    fcc0:	74 3d                	je     fcff <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
    fcc2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fcc5:	8b 55 14             	mov    0x14(%ebp),%edx
    fcc8:	81 c2 98 00 00 00    	add    $0x98,%edx
    fcce:	83 ec 04             	sub    $0x4,%esp
    fcd1:	50                   	push   %eax
    fcd2:	ff 75 d0             	pushl  -0x30(%ebp)
    fcd5:	52                   	push   %edx
    fcd6:	e8 ec f1 ff ff       	call   eec7 <readChunk_gAMA>
    fcdb:	83 c4 10             	add    $0x10,%esp
    fcde:	89 c2                	mov    %eax,%edx
    fce0:	8b 45 14             	mov    0x14(%ebp),%eax
    fce3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fce9:	8b 45 14             	mov    0x14(%ebp),%eax
    fcec:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fcf2:	85 c0                	test   %eax,%eax
    fcf4:	0f 84 99 01 00 00    	je     fe93 <decodeGeneric+0x731>
    fcfa:	e9 08 02 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    fcff:	83 ec 08             	sub    $0x8,%esp
    fd02:	68 35 a0 01 00       	push   $0x1a035
    fd07:	ff 75 f0             	pushl  -0x10(%ebp)
    fd0a:	e8 9d 85 ff ff       	call   82ac <lodepng_chunk_type_equals>
    fd0f:	83 c4 10             	add    $0x10,%esp
    fd12:	84 c0                	test   %al,%al
    fd14:	74 3d                	je     fd53 <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
    fd16:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd19:	8b 55 14             	mov    0x14(%ebp),%edx
    fd1c:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd22:	83 ec 04             	sub    $0x4,%esp
    fd25:	50                   	push   %eax
    fd26:	ff 75 d0             	pushl  -0x30(%ebp)
    fd29:	52                   	push   %edx
    fd2a:	e8 07 f2 ff ff       	call   ef36 <readChunk_cHRM>
    fd2f:	83 c4 10             	add    $0x10,%esp
    fd32:	89 c2                	mov    %eax,%edx
    fd34:	8b 45 14             	mov    0x14(%ebp),%eax
    fd37:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd3d:	8b 45 14             	mov    0x14(%ebp),%eax
    fd40:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd46:	85 c0                	test   %eax,%eax
    fd48:	0f 84 45 01 00 00    	je     fe93 <decodeGeneric+0x731>
    fd4e:	e9 b4 01 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    fd53:	83 ec 08             	sub    $0x8,%esp
    fd56:	68 3a a0 01 00       	push   $0x1a03a
    fd5b:	ff 75 f0             	pushl  -0x10(%ebp)
    fd5e:	e8 49 85 ff ff       	call   82ac <lodepng_chunk_type_equals>
    fd63:	83 c4 10             	add    $0x10,%esp
    fd66:	84 c0                	test   %al,%al
    fd68:	74 3d                	je     fda7 <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
    fd6a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd6d:	8b 55 14             	mov    0x14(%ebp),%edx
    fd70:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd76:	83 ec 04             	sub    $0x4,%esp
    fd79:	50                   	push   %eax
    fd7a:	ff 75 d0             	pushl  -0x30(%ebp)
    fd7d:	52                   	push   %edx
    fd7e:	e8 47 f4 ff ff       	call   f1ca <readChunk_sRGB>
    fd83:	83 c4 10             	add    $0x10,%esp
    fd86:	89 c2                	mov    %eax,%edx
    fd88:	8b 45 14             	mov    0x14(%ebp),%eax
    fd8b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd91:	8b 45 14             	mov    0x14(%ebp),%eax
    fd94:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd9a:	85 c0                	test   %eax,%eax
    fd9c:	0f 84 f1 00 00 00    	je     fe93 <decodeGeneric+0x731>
    fda2:	e9 60 01 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    fda7:	83 ec 08             	sub    $0x8,%esp
    fdaa:	68 3f a0 01 00       	push   $0x1a03f
    fdaf:	ff 75 f0             	pushl  -0x10(%ebp)
    fdb2:	e8 f5 84 ff ff       	call   82ac <lodepng_chunk_type_equals>
    fdb7:	83 c4 10             	add    $0x10,%esp
    fdba:	84 c0                	test   %al,%al
    fdbc:	74 3e                	je     fdfc <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    fdbe:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fdc1:	8b 45 14             	mov    0x14(%ebp),%eax
    fdc4:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fdc7:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fdcd:	52                   	push   %edx
    fdce:	ff 75 d0             	pushl  -0x30(%ebp)
    fdd1:	50                   	push   %eax
    fdd2:	51                   	push   %ecx
    fdd3:	e8 28 f4 ff ff       	call   f200 <readChunk_iCCP>
    fdd8:	83 c4 10             	add    $0x10,%esp
    fddb:	89 c2                	mov    %eax,%edx
    fddd:	8b 45 14             	mov    0x14(%ebp),%eax
    fde0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fde6:	8b 45 14             	mov    0x14(%ebp),%eax
    fde9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fdef:	85 c0                	test   %eax,%eax
    fdf1:	0f 84 9c 00 00 00    	je     fe93 <decodeGeneric+0x731>
    fdf7:	e9 0b 01 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
    fdfc:	8b 45 14             	mov    0x14(%ebp),%eax
    fdff:	8b 40 1c             	mov    0x1c(%eax),%eax
    fe02:	85 c0                	test   %eax,%eax
    fe04:	75 24                	jne    fe2a <decodeGeneric+0x6c8>
    fe06:	83 ec 0c             	sub    $0xc,%esp
    fe09:	ff 75 f0             	pushl  -0x10(%ebp)
    fe0c:	e8 30 85 ff ff       	call   8341 <lodepng_chunk_ancillary>
    fe11:	83 c4 10             	add    $0x10,%esp
    fe14:	84 c0                	test   %al,%al
    fe16:	75 12                	jne    fe2a <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
    fe18:	8b 45 14             	mov    0x14(%ebp),%eax
    fe1b:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
    fe22:	00 00 00 
    fe25:	e9 dd 00 00 00       	jmp    ff07 <decodeGeneric+0x7a5>
      }

      unknown = 1;
    fe2a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
    fe31:	8b 45 14             	mov    0x14(%ebp),%eax
    fe34:	8b 40 2c             	mov    0x2c(%eax),%eax
    fe37:	85 c0                	test   %eax,%eax
    fe39:	74 58                	je     fe93 <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
    fe3b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    fe3e:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
    fe41:	83 c0 58             	add    $0x58,%eax
    fe44:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    fe4b:	8b 45 14             	mov    0x14(%ebp),%eax
    fe4e:	01 d0                	add    %edx,%eax
    fe50:	8d 50 10             	lea    0x10(%eax),%edx
    fe53:	8b 45 dc             	mov    -0x24(%ebp),%eax
    fe56:	83 e8 01             	sub    $0x1,%eax
    fe59:	83 c0 54             	add    $0x54,%eax
    fe5c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    fe63:	8b 45 14             	mov    0x14(%ebp),%eax
    fe66:	01 c8                	add    %ecx,%eax
    fe68:	83 c0 14             	add    $0x14,%eax
    fe6b:	83 ec 04             	sub    $0x4,%esp
    fe6e:	ff 75 f0             	pushl  -0x10(%ebp)
    fe71:	52                   	push   %edx
    fe72:	50                   	push   %eax
    fe73:	e8 15 88 ff ff       	call   868d <lodepng_chunk_append>
    fe78:	83 c4 10             	add    $0x10,%esp
    fe7b:	89 c2                	mov    %eax,%edx
    fe7d:	8b 45 14             	mov    0x14(%ebp),%eax
    fe80:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    fe86:	8b 45 14             	mov    0x14(%ebp),%eax
    fe89:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe8f:	85 c0                	test   %eax,%eax
    fe91:	75 73                	jne    ff06 <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
    fe93:	8b 45 14             	mov    0x14(%ebp),%eax
    fe96:	8b 40 18             	mov    0x18(%eax),%eax
    fe99:	85 c0                	test   %eax,%eax
    fe9b:	75 27                	jne    fec4 <decodeGeneric+0x762>
    fe9d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    fea1:	75 21                	jne    fec4 <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
    fea3:	83 ec 0c             	sub    $0xc,%esp
    fea6:	ff 75 f0             	pushl  -0x10(%ebp)
    fea9:	e8 f4 84 ff ff       	call   83a2 <lodepng_chunk_check_crc>
    feae:	83 c4 10             	add    $0x10,%esp
    feb1:	85 c0                	test   %eax,%eax
    feb3:	74 0f                	je     fec4 <decodeGeneric+0x762>
    feb5:	8b 45 14             	mov    0x14(%ebp),%eax
    feb8:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    febf:	00 00 00 
    fec2:	eb 43                	jmp    ff07 <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
    fec4:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    fec8:	75 1a                	jne    fee4 <decodeGeneric+0x782>
    feca:	8b 55 1c             	mov    0x1c(%ebp),%edx
    fecd:	8b 45 18             	mov    0x18(%ebp),%eax
    fed0:	01 d0                	add    %edx,%eax
    fed2:	83 ec 08             	sub    $0x8,%esp
    fed5:	50                   	push   %eax
    fed6:	ff 75 f0             	pushl  -0x10(%ebp)
    fed9:	e8 3f 86 ff ff       	call   851d <lodepng_chunk_next_const>
    fede:	83 c4 10             	add    $0x10,%esp
    fee1:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    fee4:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    fee8:	75 1d                	jne    ff07 <decodeGeneric+0x7a5>
    feea:	8b 45 14             	mov    0x14(%ebp),%eax
    feed:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fef3:	85 c0                	test   %eax,%eax
    fef5:	0f 84 68 f9 ff ff    	je     f863 <decodeGeneric+0x101>
    fefb:	eb 0a                	jmp    ff07 <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    fefd:	90                   	nop
    fefe:	eb 07                	jmp    ff07 <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    ff00:	90                   	nop
    ff01:	eb 04                	jmp    ff07 <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
    ff03:	90                   	nop
    ff04:	eb 01                	jmp    ff07 <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    ff06:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
    ff07:	8b 45 14             	mov    0x14(%ebp),%eax
    ff0a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff10:	85 c0                	test   %eax,%eax
    ff12:	75 28                	jne    ff3c <decodeGeneric+0x7da>
    ff14:	8b 45 14             	mov    0x14(%ebp),%eax
    ff17:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
    ff1d:	83 f8 03             	cmp    $0x3,%eax
    ff20:	75 1a                	jne    ff3c <decodeGeneric+0x7da>
    ff22:	8b 45 14             	mov    0x14(%ebp),%eax
    ff25:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ff2b:	85 c0                	test   %eax,%eax
    ff2d:	75 0d                	jne    ff3c <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
    ff2f:	8b 45 14             	mov    0x14(%ebp),%eax
    ff32:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
    ff39:	00 00 00 
  }

  if(!state->error) {
    ff3c:	8b 45 14             	mov    0x14(%ebp),%eax
    ff3f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff45:	85 c0                	test   %eax,%eax
    ff47:	0f 85 d2 01 00 00    	jne    1011f <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
    ff4d:	8b 45 14             	mov    0x14(%ebp),%eax
    ff50:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    ff56:	85 c0                	test   %eax,%eax
    ff58:	75 3a                	jne    ff94 <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
    ff5a:	8b 45 14             	mov    0x14(%ebp),%eax
    ff5d:	05 a4 00 00 00       	add    $0xa4,%eax
    ff62:	83 ec 0c             	sub    $0xc,%esp
    ff65:	50                   	push   %eax
    ff66:	e8 8e 8e ff ff       	call   8df9 <lodepng_get_bpp>
    ff6b:	83 c4 10             	add    $0x10,%esp
    ff6e:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
    ff71:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    ff74:	8b 45 10             	mov    0x10(%ebp),%eax
    ff77:	8b 10                	mov    (%eax),%edx
    ff79:	8b 45 0c             	mov    0xc(%ebp),%eax
    ff7c:	8b 00                	mov    (%eax),%eax
    ff7e:	83 ec 04             	sub    $0x4,%esp
    ff81:	51                   	push   %ecx
    ff82:	52                   	push   %edx
    ff83:	50                   	push   %eax
    ff84:	e8 cf 8f ff ff       	call   8f58 <lodepng_get_raw_size_idat>
    ff89:	83 c4 10             	add    $0x10,%esp
    ff8c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    ff8f:	e9 60 01 00 00       	jmp    100f4 <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
    ff94:	8b 45 14             	mov    0x14(%ebp),%eax
    ff97:	05 a4 00 00 00       	add    $0xa4,%eax
    ff9c:	83 ec 0c             	sub    $0xc,%esp
    ff9f:	50                   	push   %eax
    ffa0:	e8 54 8e ff ff       	call   8df9 <lodepng_get_bpp>
    ffa5:	83 c4 10             	add    $0x10,%esp
    ffa8:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
    ffab:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
    ffb2:	8b 45 c8             	mov    -0x38(%ebp),%eax
    ffb5:	8b 55 10             	mov    0x10(%ebp),%edx
    ffb8:	8b 12                	mov    (%edx),%edx
    ffba:	83 c2 07             	add    $0x7,%edx
    ffbd:	89 d1                	mov    %edx,%ecx
    ffbf:	c1 e9 03             	shr    $0x3,%ecx
    ffc2:	8b 55 0c             	mov    0xc(%ebp),%edx
    ffc5:	8b 12                	mov    (%edx),%edx
    ffc7:	83 c2 07             	add    $0x7,%edx
    ffca:	c1 ea 03             	shr    $0x3,%edx
    ffcd:	83 ec 04             	sub    $0x4,%esp
    ffd0:	50                   	push   %eax
    ffd1:	51                   	push   %ecx
    ffd2:	52                   	push   %edx
    ffd3:	e8 80 8f ff ff       	call   8f58 <lodepng_get_raw_size_idat>
    ffd8:	83 c4 10             	add    $0x10,%esp
    ffdb:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
    ffde:	8b 45 0c             	mov    0xc(%ebp),%eax
    ffe1:	8b 00                	mov    (%eax),%eax
    ffe3:	83 f8 04             	cmp    $0x4,%eax
    ffe6:	76 2c                	jbe    10014 <decodeGeneric+0x8b2>
    ffe8:	8b 45 c8             	mov    -0x38(%ebp),%eax
    ffeb:	8b 55 10             	mov    0x10(%ebp),%edx
    ffee:	8b 12                	mov    (%edx),%edx
    fff0:	83 c2 07             	add    $0x7,%edx
    fff3:	89 d1                	mov    %edx,%ecx
    fff5:	c1 e9 03             	shr    $0x3,%ecx
    fff8:	8b 55 0c             	mov    0xc(%ebp),%edx
    fffb:	8b 12                	mov    (%edx),%edx
    fffd:	83 c2 03             	add    $0x3,%edx
   10000:	c1 ea 03             	shr    $0x3,%edx
   10003:	83 ec 04             	sub    $0x4,%esp
   10006:	50                   	push   %eax
   10007:	51                   	push   %ecx
   10008:	52                   	push   %edx
   10009:	e8 4a 8f ff ff       	call   8f58 <lodepng_get_raw_size_idat>
   1000e:	83 c4 10             	add    $0x10,%esp
   10011:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   10014:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10017:	8b 55 10             	mov    0x10(%ebp),%edx
   1001a:	8b 12                	mov    (%edx),%edx
   1001c:	83 c2 03             	add    $0x3,%edx
   1001f:	89 d1                	mov    %edx,%ecx
   10021:	c1 e9 03             	shr    $0x3,%ecx
   10024:	8b 55 0c             	mov    0xc(%ebp),%edx
   10027:	8b 12                	mov    (%edx),%edx
   10029:	83 c2 03             	add    $0x3,%edx
   1002c:	c1 ea 02             	shr    $0x2,%edx
   1002f:	83 ec 04             	sub    $0x4,%esp
   10032:	50                   	push   %eax
   10033:	51                   	push   %ecx
   10034:	52                   	push   %edx
   10035:	e8 1e 8f ff ff       	call   8f58 <lodepng_get_raw_size_idat>
   1003a:	83 c4 10             	add    $0x10,%esp
   1003d:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   10040:	8b 45 0c             	mov    0xc(%ebp),%eax
   10043:	8b 00                	mov    (%eax),%eax
   10045:	83 f8 02             	cmp    $0x2,%eax
   10048:	76 2c                	jbe    10076 <decodeGeneric+0x914>
   1004a:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1004d:	8b 55 10             	mov    0x10(%ebp),%edx
   10050:	8b 12                	mov    (%edx),%edx
   10052:	83 c2 03             	add    $0x3,%edx
   10055:	89 d1                	mov    %edx,%ecx
   10057:	c1 e9 02             	shr    $0x2,%ecx
   1005a:	8b 55 0c             	mov    0xc(%ebp),%edx
   1005d:	8b 12                	mov    (%edx),%edx
   1005f:	83 c2 01             	add    $0x1,%edx
   10062:	c1 ea 02             	shr    $0x2,%edx
   10065:	83 ec 04             	sub    $0x4,%esp
   10068:	50                   	push   %eax
   10069:	51                   	push   %ecx
   1006a:	52                   	push   %edx
   1006b:	e8 e8 8e ff ff       	call   8f58 <lodepng_get_raw_size_idat>
   10070:	83 c4 10             	add    $0x10,%esp
   10073:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   10076:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10079:	8b 55 10             	mov    0x10(%ebp),%edx
   1007c:	8b 12                	mov    (%edx),%edx
   1007e:	83 c2 01             	add    $0x1,%edx
   10081:	89 d1                	mov    %edx,%ecx
   10083:	c1 e9 02             	shr    $0x2,%ecx
   10086:	8b 55 0c             	mov    0xc(%ebp),%edx
   10089:	8b 12                	mov    (%edx),%edx
   1008b:	83 c2 01             	add    $0x1,%edx
   1008e:	d1 ea                	shr    %edx
   10090:	83 ec 04             	sub    $0x4,%esp
   10093:	50                   	push   %eax
   10094:	51                   	push   %ecx
   10095:	52                   	push   %edx
   10096:	e8 bd 8e ff ff       	call   8f58 <lodepng_get_raw_size_idat>
   1009b:	83 c4 10             	add    $0x10,%esp
   1009e:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   100a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   100a4:	8b 00                	mov    (%eax),%eax
   100a6:	83 f8 01             	cmp    $0x1,%eax
   100a9:	76 27                	jbe    100d2 <decodeGeneric+0x970>
   100ab:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100ae:	8b 55 10             	mov    0x10(%ebp),%edx
   100b1:	8b 12                	mov    (%edx),%edx
   100b3:	83 c2 01             	add    $0x1,%edx
   100b6:	89 d1                	mov    %edx,%ecx
   100b8:	d1 e9                	shr    %ecx
   100ba:	8b 55 0c             	mov    0xc(%ebp),%edx
   100bd:	8b 12                	mov    (%edx),%edx
   100bf:	d1 ea                	shr    %edx
   100c1:	83 ec 04             	sub    $0x4,%esp
   100c4:	50                   	push   %eax
   100c5:	51                   	push   %ecx
   100c6:	52                   	push   %edx
   100c7:	e8 8c 8e ff ff       	call   8f58 <lodepng_get_raw_size_idat>
   100cc:	83 c4 10             	add    $0x10,%esp
   100cf:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   100d2:	8b 55 c8             	mov    -0x38(%ebp),%edx
   100d5:	8b 45 10             	mov    0x10(%ebp),%eax
   100d8:	8b 00                	mov    (%eax),%eax
   100da:	d1 e8                	shr    %eax
   100dc:	89 c1                	mov    %eax,%ecx
   100de:	8b 45 0c             	mov    0xc(%ebp),%eax
   100e1:	8b 00                	mov    (%eax),%eax
   100e3:	83 ec 04             	sub    $0x4,%esp
   100e6:	52                   	push   %edx
   100e7:	51                   	push   %ecx
   100e8:	50                   	push   %eax
   100e9:	e8 6a 8e ff ff       	call   8f58 <lodepng_get_raw_size_idat>
   100ee:	83 c4 10             	add    $0x10,%esp
   100f1:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   100f4:	8b 45 14             	mov    0x14(%ebp),%eax
   100f7:	83 ec 08             	sub    $0x8,%esp
   100fa:	50                   	push   %eax
   100fb:	ff 75 ec             	pushl  -0x14(%ebp)
   100fe:	ff 75 d8             	pushl  -0x28(%ebp)
   10101:	ff 75 e8             	pushl  -0x18(%ebp)
   10104:	8d 45 c0             	lea    -0x40(%ebp),%eax
   10107:	50                   	push   %eax
   10108:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   1010b:	50                   	push   %eax
   1010c:	e8 87 7c ff ff       	call   7d98 <zlib_decompress>
   10111:	83 c4 20             	add    $0x20,%esp
   10114:	89 c2                	mov    %eax,%edx
   10116:	8b 45 14             	mov    0x14(%ebp),%eax
   10119:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   1011f:	8b 45 14             	mov    0x14(%ebp),%eax
   10122:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10128:	85 c0                	test   %eax,%eax
   1012a:	75 15                	jne    10141 <decodeGeneric+0x9df>
   1012c:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1012f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   10132:	74 0d                	je     10141 <decodeGeneric+0x9df>
   10134:	8b 45 14             	mov    0x14(%ebp),%eax
   10137:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   1013e:	00 00 00 
  lodepng_free(idat);
   10141:	83 ec 0c             	sub    $0xc,%esp
   10144:	ff 75 d8             	pushl  -0x28(%ebp)
   10147:	e8 b2 31 ff ff       	call   32fe <lodepng_free>
   1014c:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   1014f:	8b 45 14             	mov    0x14(%ebp),%eax
   10152:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10158:	85 c0                	test   %eax,%eax
   1015a:	75 4f                	jne    101ab <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   1015c:	8b 45 14             	mov    0x14(%ebp),%eax
   1015f:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   10165:	8b 45 10             	mov    0x10(%ebp),%eax
   10168:	8b 10                	mov    (%eax),%edx
   1016a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1016d:	8b 00                	mov    (%eax),%eax
   1016f:	83 ec 04             	sub    $0x4,%esp
   10172:	51                   	push   %ecx
   10173:	52                   	push   %edx
   10174:	50                   	push   %eax
   10175:	e8 be 8d ff ff       	call   8f38 <lodepng_get_raw_size>
   1017a:	83 c4 10             	add    $0x10,%esp
   1017d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   10180:	83 ec 0c             	sub    $0xc,%esp
   10183:	ff 75 e4             	pushl  -0x1c(%ebp)
   10186:	e8 52 31 ff ff       	call   32dd <lodepng_malloc>
   1018b:	83 c4 10             	add    $0x10,%esp
   1018e:	89 c2                	mov    %eax,%edx
   10190:	8b 45 08             	mov    0x8(%ebp),%eax
   10193:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   10195:	8b 45 08             	mov    0x8(%ebp),%eax
   10198:	8b 00                	mov    (%eax),%eax
   1019a:	85 c0                	test   %eax,%eax
   1019c:	75 0d                	jne    101ab <decodeGeneric+0xa49>
   1019e:	8b 45 14             	mov    0x14(%ebp),%eax
   101a1:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   101a8:	00 00 00 
  }
  if(!state->error) {
   101ab:	8b 45 14             	mov    0x14(%ebp),%eax
   101ae:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   101b4:	85 c0                	test   %eax,%eax
   101b6:	75 4c                	jne    10204 <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   101b8:	8b 45 08             	mov    0x8(%ebp),%eax
   101bb:	8b 00                	mov    (%eax),%eax
   101bd:	83 ec 04             	sub    $0x4,%esp
   101c0:	ff 75 e4             	pushl  -0x1c(%ebp)
   101c3:	6a 00                	push   $0x0
   101c5:	50                   	push   %eax
   101c6:	e8 83 31 ff ff       	call   334e <lodepng_memset>
   101cb:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   101ce:	8b 45 14             	mov    0x14(%ebp),%eax
   101d1:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   101d7:	8b 45 10             	mov    0x10(%ebp),%eax
   101da:	8b 18                	mov    (%eax),%ebx
   101dc:	8b 45 0c             	mov    0xc(%ebp),%eax
   101df:	8b 08                	mov    (%eax),%ecx
   101e1:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   101e4:	8b 45 08             	mov    0x8(%ebp),%eax
   101e7:	8b 00                	mov    (%eax),%eax
   101e9:	83 ec 0c             	sub    $0xc,%esp
   101ec:	56                   	push   %esi
   101ed:	53                   	push   %ebx
   101ee:	51                   	push   %ecx
   101ef:	52                   	push   %edx
   101f0:	50                   	push   %eax
   101f1:	e8 05 df ff ff       	call   e0fb <postProcessScanlines>
   101f6:	83 c4 20             	add    $0x20,%esp
   101f9:	89 c2                	mov    %eax,%edx
   101fb:	8b 45 14             	mov    0x14(%ebp),%eax
   101fe:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   10204:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10207:	83 ec 0c             	sub    $0xc,%esp
   1020a:	50                   	push   %eax
   1020b:	e8 ee 30 ff ff       	call   32fe <lodepng_free>
   10210:	83 c4 10             	add    $0x10,%esp
   10213:	eb 01                	jmp    10216 <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   10215:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   10216:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10219:	5b                   	pop    %ebx
   1021a:	5e                   	pop    %esi
   1021b:	5d                   	pop    %ebp
   1021c:	c3                   	ret    

0001021d <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   1021d:	55                   	push   %ebp
   1021e:	89 e5                	mov    %esp,%ebp
   10220:	56                   	push   %esi
   10221:	53                   	push   %ebx
   10222:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   10225:	8b 45 08             	mov    0x8(%ebp),%eax
   10228:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   1022e:	83 ec 08             	sub    $0x8,%esp
   10231:	ff 75 1c             	pushl  0x1c(%ebp)
   10234:	ff 75 18             	pushl  0x18(%ebp)
   10237:	ff 75 14             	pushl  0x14(%ebp)
   1023a:	ff 75 10             	pushl  0x10(%ebp)
   1023d:	ff 75 0c             	pushl  0xc(%ebp)
   10240:	ff 75 08             	pushl  0x8(%ebp)
   10243:	e8 1a f5 ff ff       	call   f762 <decodeGeneric>
   10248:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   1024b:	8b 45 14             	mov    0x14(%ebp),%eax
   1024e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10254:	85 c0                	test   %eax,%eax
   10256:	74 0e                	je     10266 <lodepng_decode+0x49>
   10258:	8b 45 14             	mov    0x14(%ebp),%eax
   1025b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10261:	e9 55 01 00 00       	jmp    103bb <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   10266:	8b 45 14             	mov    0x14(%ebp),%eax
   10269:	8b 40 24             	mov    0x24(%eax),%eax
   1026c:	85 c0                	test   %eax,%eax
   1026e:	74 20                	je     10290 <lodepng_decode+0x73>
   10270:	8b 45 14             	mov    0x14(%ebp),%eax
   10273:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   10279:	8b 45 14             	mov    0x14(%ebp),%eax
   1027c:	83 c0 78             	add    $0x78,%eax
   1027f:	83 ec 08             	sub    $0x8,%esp
   10282:	52                   	push   %edx
   10283:	50                   	push   %eax
   10284:	e8 56 89 ff ff       	call   8bdf <lodepng_color_mode_equal>
   10289:	83 c4 10             	add    $0x10,%esp
   1028c:	85 c0                	test   %eax,%eax
   1028e:	74 54                	je     102e4 <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   10290:	8b 45 14             	mov    0x14(%ebp),%eax
   10293:	8b 40 24             	mov    0x24(%eax),%eax
   10296:	85 c0                	test   %eax,%eax
   10298:	0f 85 13 01 00 00    	jne    103b1 <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   1029e:	8b 45 14             	mov    0x14(%ebp),%eax
   102a1:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   102a7:	8b 45 14             	mov    0x14(%ebp),%eax
   102aa:	83 c0 78             	add    $0x78,%eax
   102ad:	83 ec 08             	sub    $0x8,%esp
   102b0:	52                   	push   %edx
   102b1:	50                   	push   %eax
   102b2:	e8 3f 88 ff ff       	call   8af6 <lodepng_color_mode_copy>
   102b7:	83 c4 10             	add    $0x10,%esp
   102ba:	89 c2                	mov    %eax,%edx
   102bc:	8b 45 14             	mov    0x14(%ebp),%eax
   102bf:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   102c5:	8b 45 14             	mov    0x14(%ebp),%eax
   102c8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   102ce:	85 c0                	test   %eax,%eax
   102d0:	0f 84 db 00 00 00    	je     103b1 <lodepng_decode+0x194>
   102d6:	8b 45 14             	mov    0x14(%ebp),%eax
   102d9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   102df:	e9 d7 00 00 00       	jmp    103bb <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   102e4:	8b 45 08             	mov    0x8(%ebp),%eax
   102e7:	8b 00                	mov    (%eax),%eax
   102e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   102ec:	8b 45 14             	mov    0x14(%ebp),%eax
   102ef:	8b 40 78             	mov    0x78(%eax),%eax
   102f2:	83 f8 02             	cmp    $0x2,%eax
   102f5:	74 20                	je     10317 <lodepng_decode+0xfa>
   102f7:	8b 45 14             	mov    0x14(%ebp),%eax
   102fa:	8b 40 78             	mov    0x78(%eax),%eax
   102fd:	83 f8 06             	cmp    $0x6,%eax
   10300:	74 15                	je     10317 <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   10302:	8b 45 14             	mov    0x14(%ebp),%eax
   10305:	8b 40 7c             	mov    0x7c(%eax),%eax
   10308:	83 f8 08             	cmp    $0x8,%eax
   1030b:	74 0a                	je     10317 <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   1030d:	b8 38 00 00 00       	mov    $0x38,%eax
   10312:	e9 a4 00 00 00       	jmp    103bb <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   10317:	8b 45 14             	mov    0x14(%ebp),%eax
   1031a:	8d 48 78             	lea    0x78(%eax),%ecx
   1031d:	8b 45 10             	mov    0x10(%ebp),%eax
   10320:	8b 10                	mov    (%eax),%edx
   10322:	8b 45 0c             	mov    0xc(%ebp),%eax
   10325:	8b 00                	mov    (%eax),%eax
   10327:	83 ec 04             	sub    $0x4,%esp
   1032a:	51                   	push   %ecx
   1032b:	52                   	push   %edx
   1032c:	50                   	push   %eax
   1032d:	e8 06 8c ff ff       	call   8f38 <lodepng_get_raw_size>
   10332:	83 c4 10             	add    $0x10,%esp
   10335:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   10338:	83 ec 0c             	sub    $0xc,%esp
   1033b:	ff 75 f0             	pushl  -0x10(%ebp)
   1033e:	e8 9a 2f ff ff       	call   32dd <lodepng_malloc>
   10343:	83 c4 10             	add    $0x10,%esp
   10346:	89 c2                	mov    %eax,%edx
   10348:	8b 45 08             	mov    0x8(%ebp),%eax
   1034b:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   1034d:	8b 45 08             	mov    0x8(%ebp),%eax
   10350:	8b 00                	mov    (%eax),%eax
   10352:	85 c0                	test   %eax,%eax
   10354:	75 0f                	jne    10365 <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   10356:	8b 45 14             	mov    0x14(%ebp),%eax
   10359:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   10360:	00 00 00 
   10363:	eb 3c                	jmp    103a1 <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   10365:	8b 45 10             	mov    0x10(%ebp),%eax
   10368:	8b 08                	mov    (%eax),%ecx
   1036a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1036d:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   1036f:	8b 45 14             	mov    0x14(%ebp),%eax
   10372:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   10378:	8b 45 14             	mov    0x14(%ebp),%eax
   1037b:	8d 58 78             	lea    0x78(%eax),%ebx
   1037e:	8b 45 08             	mov    0x8(%ebp),%eax
   10381:	8b 00                	mov    (%eax),%eax
   10383:	83 ec 08             	sub    $0x8,%esp
   10386:	51                   	push   %ecx
   10387:	52                   	push   %edx
   10388:	56                   	push   %esi
   10389:	53                   	push   %ebx
   1038a:	ff 75 f4             	pushl  -0xc(%ebp)
   1038d:	50                   	push   %eax
   1038e:	e8 51 b6 ff ff       	call   b9e4 <lodepng_convert>
   10393:	83 c4 20             	add    $0x20,%esp
   10396:	89 c2                	mov    %eax,%edx
   10398:	8b 45 14             	mov    0x14(%ebp),%eax
   1039b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   103a1:	83 ec 0c             	sub    $0xc,%esp
   103a4:	ff 75 f4             	pushl  -0xc(%ebp)
   103a7:	e8 52 2f ff ff       	call   32fe <lodepng_free>
   103ac:	83 c4 10             	add    $0x10,%esp
   103af:	eb 01                	jmp    103b2 <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   103b1:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   103b2:	8b 45 14             	mov    0x14(%ebp),%eax
   103b5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   103bb:	8d 65 f8             	lea    -0x8(%ebp),%esp
   103be:	5b                   	pop    %ebx
   103bf:	5e                   	pop    %esi
   103c0:	5d                   	pop    %ebp
   103c1:	c3                   	ret    

000103c2 <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   103c2:	55                   	push   %ebp
   103c3:	89 e5                	mov    %esp,%ebp
   103c5:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   103cb:	83 ec 0c             	sub    $0xc,%esp
   103ce:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   103d4:	50                   	push   %eax
   103d5:	e8 d9 01 00 00       	call   105b3 <lodepng_state_init>
   103da:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   103dd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   103e0:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   103e6:	8b 45 20             	mov    0x20(%ebp),%eax
   103e9:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   103ef:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   103f6:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   103f9:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   10400:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   10403:	83 ec 08             	sub    $0x8,%esp
   10406:	ff 75 18             	pushl  0x18(%ebp)
   10409:	ff 75 14             	pushl  0x14(%ebp)
   1040c:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10412:	50                   	push   %eax
   10413:	ff 75 10             	pushl  0x10(%ebp)
   10416:	ff 75 0c             	pushl  0xc(%ebp)
   10419:	ff 75 08             	pushl  0x8(%ebp)
   1041c:	e8 fc fd ff ff       	call   1021d <lodepng_decode>
   10421:	83 c4 20             	add    $0x20,%esp
   10424:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   10427:	83 ec 0c             	sub    $0xc,%esp
   1042a:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10430:	50                   	push   %eax
   10431:	e8 d7 01 00 00       	call   1060d <lodepng_state_cleanup>
   10436:	83 c4 10             	add    $0x10,%esp
  return error;
   10439:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1043c:	c9                   	leave  
   1043d:	c3                   	ret    

0001043e <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   1043e:	55                   	push   %ebp
   1043f:	89 e5                	mov    %esp,%ebp
   10441:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   10444:	83 ec 04             	sub    $0x4,%esp
   10447:	6a 08                	push   $0x8
   10449:	6a 06                	push   $0x6
   1044b:	ff 75 18             	pushl  0x18(%ebp)
   1044e:	ff 75 14             	pushl  0x14(%ebp)
   10451:	ff 75 10             	pushl  0x10(%ebp)
   10454:	ff 75 0c             	pushl  0xc(%ebp)
   10457:	ff 75 08             	pushl  0x8(%ebp)
   1045a:	e8 63 ff ff ff       	call   103c2 <lodepng_decode_memory>
   1045f:	83 c4 20             	add    $0x20,%esp
}
   10462:	c9                   	leave  
   10463:	c3                   	ret    

00010464 <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10464:	55                   	push   %ebp
   10465:	89 e5                	mov    %esp,%ebp
   10467:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   1046a:	83 ec 04             	sub    $0x4,%esp
   1046d:	6a 08                	push   $0x8
   1046f:	6a 02                	push   $0x2
   10471:	ff 75 18             	pushl  0x18(%ebp)
   10474:	ff 75 14             	pushl  0x14(%ebp)
   10477:	ff 75 10             	pushl  0x10(%ebp)
   1047a:	ff 75 0c             	pushl  0xc(%ebp)
   1047d:	ff 75 08             	pushl  0x8(%ebp)
   10480:	e8 3d ff ff ff       	call   103c2 <lodepng_decode_memory>
   10485:	83 c4 20             	add    $0x20,%esp
}
   10488:	c9                   	leave  
   10489:	c3                   	ret    

0001048a <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   1048a:	55                   	push   %ebp
   1048b:	89 e5                	mov    %esp,%ebp
   1048d:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   10490:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   10497:	8b 45 08             	mov    0x8(%ebp),%eax
   1049a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   104a0:	8b 45 10             	mov    0x10(%ebp),%eax
   104a3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   104a9:	8b 45 10             	mov    0x10(%ebp),%eax
   104ac:	8b 10                	mov    (%eax),%edx
   104ae:	8b 45 0c             	mov    0xc(%ebp),%eax
   104b1:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   104b3:	83 ec 04             	sub    $0x4,%esp
   104b6:	ff 75 14             	pushl  0x14(%ebp)
   104b9:	8d 45 ec             	lea    -0x14(%ebp),%eax
   104bc:	50                   	push   %eax
   104bd:	8d 45 f0             	lea    -0x10(%ebp),%eax
   104c0:	50                   	push   %eax
   104c1:	e8 70 32 ff ff       	call   3736 <lodepng_load_file>
   104c6:	83 c4 10             	add    $0x10,%esp
   104c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   104cc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   104d0:	75 25                	jne    104f7 <lodepng_decode_file+0x6d>
   104d2:	8b 55 ec             	mov    -0x14(%ebp),%edx
   104d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   104d8:	83 ec 04             	sub    $0x4,%esp
   104db:	ff 75 1c             	pushl  0x1c(%ebp)
   104de:	ff 75 18             	pushl  0x18(%ebp)
   104e1:	52                   	push   %edx
   104e2:	50                   	push   %eax
   104e3:	ff 75 10             	pushl  0x10(%ebp)
   104e6:	ff 75 0c             	pushl  0xc(%ebp)
   104e9:	ff 75 08             	pushl  0x8(%ebp)
   104ec:	e8 d1 fe ff ff       	call   103c2 <lodepng_decode_memory>
   104f1:	83 c4 20             	add    $0x20,%esp
   104f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   104f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   104fa:	83 ec 0c             	sub    $0xc,%esp
   104fd:	50                   	push   %eax
   104fe:	e8 fb 2d ff ff       	call   32fe <lodepng_free>
   10503:	83 c4 10             	add    $0x10,%esp
  return error;
   10506:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10509:	c9                   	leave  
   1050a:	c3                   	ret    

0001050b <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   1050b:	55                   	push   %ebp
   1050c:	89 e5                	mov    %esp,%ebp
   1050e:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   10511:	83 ec 08             	sub    $0x8,%esp
   10514:	6a 08                	push   $0x8
   10516:	6a 06                	push   $0x6
   10518:	ff 75 14             	pushl  0x14(%ebp)
   1051b:	ff 75 10             	pushl  0x10(%ebp)
   1051e:	ff 75 0c             	pushl  0xc(%ebp)
   10521:	ff 75 08             	pushl  0x8(%ebp)
   10524:	e8 61 ff ff ff       	call   1048a <lodepng_decode_file>
   10529:	83 c4 20             	add    $0x20,%esp
}
   1052c:	c9                   	leave  
   1052d:	c3                   	ret    

0001052e <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   1052e:	55                   	push   %ebp
   1052f:	89 e5                	mov    %esp,%ebp
   10531:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   10534:	83 ec 08             	sub    $0x8,%esp
   10537:	6a 08                	push   $0x8
   10539:	6a 02                	push   $0x2
   1053b:	ff 75 14             	pushl  0x14(%ebp)
   1053e:	ff 75 10             	pushl  0x10(%ebp)
   10541:	ff 75 0c             	pushl  0xc(%ebp)
   10544:	ff 75 08             	pushl  0x8(%ebp)
   10547:	e8 3e ff ff ff       	call   1048a <lodepng_decode_file>
   1054c:	83 c4 20             	add    $0x20,%esp
}
   1054f:	c9                   	leave  
   10550:	c3                   	ret    

00010551 <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   10551:	55                   	push   %ebp
   10552:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   10554:	8b 45 08             	mov    0x8(%ebp),%eax
   10557:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   1055e:	8b 45 08             	mov    0x8(%ebp),%eax
   10561:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   10568:	8b 45 08             	mov    0x8(%ebp),%eax
   1056b:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   10572:	8b 45 08             	mov    0x8(%ebp),%eax
   10575:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   1057c:	8b 45 08             	mov    0x8(%ebp),%eax
   1057f:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   10586:	8b 45 08             	mov    0x8(%ebp),%eax
   10589:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   10590:	8b 45 08             	mov    0x8(%ebp),%eax
   10593:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   1059a:	8b 45 08             	mov    0x8(%ebp),%eax
   1059d:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   105a4:	8b 45 08             	mov    0x8(%ebp),%eax
   105a7:	50                   	push   %eax
   105a8:	e8 ff 7a ff ff       	call   80ac <lodepng_decompress_settings_init>
   105ad:	83 c4 04             	add    $0x4,%esp
}
   105b0:	90                   	nop
   105b1:	c9                   	leave  
   105b2:	c3                   	ret    

000105b3 <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   105b3:	55                   	push   %ebp
   105b4:	89 e5                	mov    %esp,%ebp
   105b6:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   105b9:	8b 45 08             	mov    0x8(%ebp),%eax
   105bc:	50                   	push   %eax
   105bd:	e8 8f ff ff ff       	call   10551 <lodepng_decoder_settings_init>
   105c2:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   105c5:	8b 45 08             	mov    0x8(%ebp),%eax
   105c8:	83 c0 38             	add    $0x38,%eax
   105cb:	83 ec 0c             	sub    $0xc,%esp
   105ce:	50                   	push   %eax
   105cf:	e8 fc 30 00 00       	call   136d0 <lodepng_encoder_settings_init>
   105d4:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   105d7:	8b 45 08             	mov    0x8(%ebp),%eax
   105da:	83 c0 78             	add    $0x78,%eax
   105dd:	83 ec 0c             	sub    $0xc,%esp
   105e0:	50                   	push   %eax
   105e1:	e8 06 84 ff ff       	call   89ec <lodepng_color_mode_init>
   105e6:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   105e9:	8b 45 08             	mov    0x8(%ebp),%eax
   105ec:	05 98 00 00 00       	add    $0x98,%eax
   105f1:	83 ec 0c             	sub    $0xc,%esp
   105f4:	50                   	push   %eax
   105f5:	e8 89 93 ff ff       	call   9983 <lodepng_info_init>
   105fa:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   105fd:	8b 45 08             	mov    0x8(%ebp),%eax
   10600:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   10607:	00 00 00 
}
   1060a:	90                   	nop
   1060b:	c9                   	leave  
   1060c:	c3                   	ret    

0001060d <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   1060d:	55                   	push   %ebp
   1060e:	89 e5                	mov    %esp,%ebp
   10610:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   10613:	8b 45 08             	mov    0x8(%ebp),%eax
   10616:	83 c0 78             	add    $0x78,%eax
   10619:	83 ec 0c             	sub    $0xc,%esp
   1061c:	50                   	push   %eax
   1061d:	e8 bd 84 ff ff       	call   8adf <lodepng_color_mode_cleanup>
   10622:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   10625:	8b 45 08             	mov    0x8(%ebp),%eax
   10628:	05 98 00 00 00       	add    $0x98,%eax
   1062d:	83 ec 0c             	sub    $0xc,%esp
   10630:	50                   	push   %eax
   10631:	e8 2e 94 ff ff       	call   9a64 <lodepng_info_cleanup>
   10636:	83 c4 10             	add    $0x10,%esp
}
   10639:	90                   	nop
   1063a:	c9                   	leave  
   1063b:	c3                   	ret    

0001063c <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   1063c:	55                   	push   %ebp
   1063d:	89 e5                	mov    %esp,%ebp
   1063f:	57                   	push   %edi
   10640:	56                   	push   %esi
   10641:	53                   	push   %ebx
   10642:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   10645:	83 ec 0c             	sub    $0xc,%esp
   10648:	ff 75 08             	pushl  0x8(%ebp)
   1064b:	e8 bd ff ff ff       	call   1060d <lodepng_state_cleanup>
   10650:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   10653:	8b 55 08             	mov    0x8(%ebp),%edx
   10656:	8b 45 0c             	mov    0xc(%ebp),%eax
   10659:	89 c3                	mov    %eax,%ebx
   1065b:	b8 60 00 00 00       	mov    $0x60,%eax
   10660:	89 d7                	mov    %edx,%edi
   10662:	89 de                	mov    %ebx,%esi
   10664:	89 c1                	mov    %eax,%ecx
   10666:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   10668:	8b 45 08             	mov    0x8(%ebp),%eax
   1066b:	83 c0 78             	add    $0x78,%eax
   1066e:	83 ec 0c             	sub    $0xc,%esp
   10671:	50                   	push   %eax
   10672:	e8 75 83 ff ff       	call   89ec <lodepng_color_mode_init>
   10677:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   1067a:	8b 45 08             	mov    0x8(%ebp),%eax
   1067d:	05 98 00 00 00       	add    $0x98,%eax
   10682:	83 ec 0c             	sub    $0xc,%esp
   10685:	50                   	push   %eax
   10686:	e8 f8 92 ff ff       	call   9983 <lodepng_info_init>
   1068b:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   1068e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10691:	8d 50 78             	lea    0x78(%eax),%edx
   10694:	8b 45 08             	mov    0x8(%ebp),%eax
   10697:	83 c0 78             	add    $0x78,%eax
   1069a:	83 ec 08             	sub    $0x8,%esp
   1069d:	52                   	push   %edx
   1069e:	50                   	push   %eax
   1069f:	e8 52 84 ff ff       	call   8af6 <lodepng_color_mode_copy>
   106a4:	83 c4 10             	add    $0x10,%esp
   106a7:	89 c2                	mov    %eax,%edx
   106a9:	8b 45 08             	mov    0x8(%ebp),%eax
   106ac:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   106b2:	8b 45 08             	mov    0x8(%ebp),%eax
   106b5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   106bb:	85 c0                	test   %eax,%eax
   106bd:	75 36                	jne    106f5 <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   106bf:	8b 45 0c             	mov    0xc(%ebp),%eax
   106c2:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   106c8:	8b 45 08             	mov    0x8(%ebp),%eax
   106cb:	05 98 00 00 00       	add    $0x98,%eax
   106d0:	83 ec 08             	sub    $0x8,%esp
   106d3:	52                   	push   %edx
   106d4:	50                   	push   %eax
   106d5:	e8 dd 93 ff ff       	call   9ab7 <lodepng_info_copy>
   106da:	83 c4 10             	add    $0x10,%esp
   106dd:	89 c2                	mov    %eax,%edx
   106df:	8b 45 08             	mov    0x8(%ebp),%eax
   106e2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   106e8:	8b 45 08             	mov    0x8(%ebp),%eax
   106eb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   106f1:	85 c0                	test   %eax,%eax
   106f3:	eb 01                	jmp    106f6 <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   106f5:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   106f6:	8d 65 f4             	lea    -0xc(%ebp),%esp
   106f9:	5b                   	pop    %ebx
   106fa:	5e                   	pop    %esi
   106fb:	5f                   	pop    %edi
   106fc:	5d                   	pop    %ebp
   106fd:	c3                   	ret    

000106fe <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   106fe:	55                   	push   %ebp
   106ff:	89 e5                	mov    %esp,%ebp
   10701:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   10704:	8b 45 08             	mov    0x8(%ebp),%eax
   10707:	8b 40 04             	mov    0x4(%eax),%eax
   1070a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   1070d:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   10711:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   10715:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   10719:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   1071d:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   10721:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   10725:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   10729:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   1072d:	8b 45 08             	mov    0x8(%ebp),%eax
   10730:	8b 40 04             	mov    0x4(%eax),%eax
   10733:	83 c0 08             	add    $0x8,%eax
   10736:	50                   	push   %eax
   10737:	ff 75 08             	pushl  0x8(%ebp)
   1073a:	e8 f8 2d ff ff       	call   3537 <ucvector_resize>
   1073f:	83 c4 08             	add    $0x8,%esp
   10742:	85 c0                	test   %eax,%eax
   10744:	75 07                	jne    1074d <writeSignature+0x4f>
   10746:	b8 53 00 00 00       	mov    $0x53,%eax
   1074b:	eb 1e                	jmp    1076b <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   1074d:	8b 45 08             	mov    0x8(%ebp),%eax
   10750:	8b 10                	mov    (%eax),%edx
   10752:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10755:	01 c2                	add    %eax,%edx
   10757:	6a 08                	push   $0x8
   10759:	8d 45 f4             	lea    -0xc(%ebp),%eax
   1075c:	50                   	push   %eax
   1075d:	52                   	push   %edx
   1075e:	e8 b8 2b ff ff       	call   331b <lodepng_memcpy>
   10763:	83 c4 0c             	add    $0xc,%esp
  return 0;
   10766:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1076b:	c9                   	leave  
   1076c:	c3                   	ret    

0001076d <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   1076d:	55                   	push   %ebp
   1076e:	89 e5                	mov    %esp,%ebp
   10770:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   10773:	68 ec 9f 01 00       	push   $0x19fec
   10778:	6a 0d                	push   $0xd
   1077a:	ff 75 08             	pushl  0x8(%ebp)
   1077d:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10780:	50                   	push   %eax
   10781:	e8 cf 7f ff ff       	call   8755 <lodepng_chunk_init>
   10786:	83 c4 10             	add    $0x10,%esp
   10789:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1078c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10790:	74 05                	je     10797 <addChunk_IHDR+0x2a>
   10792:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10795:	eb 6d                	jmp    10804 <addChunk_IHDR+0x97>
  data = chunk + 8;
   10797:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1079a:	83 c0 08             	add    $0x8,%eax
   1079d:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   107a0:	ff 75 0c             	pushl  0xc(%ebp)
   107a3:	ff 75 f8             	pushl  -0x8(%ebp)
   107a6:	e8 f3 2e ff ff       	call   369e <lodepng_set32bitInt>
   107ab:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   107ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
   107b1:	83 c0 04             	add    $0x4,%eax
   107b4:	ff 75 10             	pushl  0x10(%ebp)
   107b7:	50                   	push   %eax
   107b8:	e8 e1 2e ff ff       	call   369e <lodepng_set32bitInt>
   107bd:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   107c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   107c3:	83 c0 08             	add    $0x8,%eax
   107c6:	8b 55 18             	mov    0x18(%ebp),%edx
   107c9:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   107cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   107ce:	83 c0 09             	add    $0x9,%eax
   107d1:	8b 55 14             	mov    0x14(%ebp),%edx
   107d4:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   107d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   107d9:	83 c0 0a             	add    $0xa,%eax
   107dc:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   107df:	8b 45 f8             	mov    -0x8(%ebp),%eax
   107e2:	83 c0 0b             	add    $0xb,%eax
   107e5:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   107e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   107eb:	83 c0 0c             	add    $0xc,%eax
   107ee:	8b 55 1c             	mov    0x1c(%ebp),%edx
   107f1:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   107f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   107f6:	50                   	push   %eax
   107f7:	e8 02 7c ff ff       	call   83fe <lodepng_chunk_generate_crc>
   107fc:	83 c4 04             	add    $0x4,%esp
  return 0;
   107ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10804:	c9                   	leave  
   10805:	c3                   	ret    

00010806 <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   10806:	55                   	push   %ebp
   10807:	89 e5                	mov    %esp,%ebp
   10809:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   1080c:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   10813:	8b 45 0c             	mov    0xc(%ebp),%eax
   10816:	8b 50 0c             	mov    0xc(%eax),%edx
   10819:	89 d0                	mov    %edx,%eax
   1081b:	01 c0                	add    %eax,%eax
   1081d:	01 d0                	add    %edx,%eax
   1081f:	68 08 a0 01 00       	push   $0x1a008
   10824:	50                   	push   %eax
   10825:	ff 75 08             	pushl  0x8(%ebp)
   10828:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1082b:	50                   	push   %eax
   1082c:	e8 24 7f ff ff       	call   8755 <lodepng_chunk_init>
   10831:	83 c4 10             	add    $0x10,%esp
   10834:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10837:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1083b:	74 08                	je     10845 <addChunk_PLTE+0x3f>
   1083d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10840:	e9 95 00 00 00       	jmp    108da <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   10845:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1084c:	eb 70                	jmp    108be <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   1084e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10851:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10854:	8d 50 01             	lea    0x1(%eax),%edx
   10857:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1085a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   1085d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10860:	8b 40 08             	mov    0x8(%eax),%eax
   10863:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10866:	c1 e1 02             	shl    $0x2,%ecx
   10869:	01 c8                	add    %ecx,%eax
   1086b:	0f b6 00             	movzbl (%eax),%eax
   1086e:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   10870:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10873:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10876:	8d 50 01             	lea    0x1(%eax),%edx
   10879:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1087c:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   1087f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10882:	8b 40 08             	mov    0x8(%eax),%eax
   10885:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10888:	c1 e1 02             	shl    $0x2,%ecx
   1088b:	83 c1 01             	add    $0x1,%ecx
   1088e:	01 c8                	add    %ecx,%eax
   10890:	0f b6 00             	movzbl (%eax),%eax
   10893:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   10895:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10898:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1089b:	8d 50 01             	lea    0x1(%eax),%edx
   1089e:	89 55 f8             	mov    %edx,-0x8(%ebp)
   108a1:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   108a4:	8b 45 0c             	mov    0xc(%ebp),%eax
   108a7:	8b 40 08             	mov    0x8(%eax),%eax
   108aa:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   108ad:	c1 e1 02             	shl    $0x2,%ecx
   108b0:	83 c1 02             	add    $0x2,%ecx
   108b3:	01 c8                	add    %ecx,%eax
   108b5:	0f b6 00             	movzbl (%eax),%eax
   108b8:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   108ba:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   108be:	8b 45 0c             	mov    0xc(%ebp),%eax
   108c1:	8b 40 0c             	mov    0xc(%eax),%eax
   108c4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   108c7:	75 85                	jne    1084e <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   108c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   108cc:	50                   	push   %eax
   108cd:	e8 2c 7b ff ff       	call   83fe <lodepng_chunk_generate_crc>
   108d2:	83 c4 04             	add    $0x4,%esp
  return 0;
   108d5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   108da:	c9                   	leave  
   108db:	c3                   	ret    

000108dc <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   108dc:	55                   	push   %ebp
   108dd:	89 e5                	mov    %esp,%ebp
   108df:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   108e2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   108e9:	8b 45 0c             	mov    0xc(%ebp),%eax
   108ec:	8b 00                	mov    (%eax),%eax
   108ee:	83 f8 03             	cmp    $0x3,%eax
   108f1:	0f 85 ae 00 00 00    	jne    109a5 <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   108f7:	8b 45 0c             	mov    0xc(%ebp),%eax
   108fa:	8b 40 0c             	mov    0xc(%eax),%eax
   108fd:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10900:	8b 45 0c             	mov    0xc(%ebp),%eax
   10903:	8b 40 0c             	mov    0xc(%eax),%eax
   10906:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10909:	eb 23                	jmp    1092e <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   1090b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1090e:	8b 40 08             	mov    0x8(%eax),%eax
   10911:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10914:	83 ea 01             	sub    $0x1,%edx
   10917:	c1 e2 02             	shl    $0x2,%edx
   1091a:	83 c2 03             	add    $0x3,%edx
   1091d:	01 d0                	add    %edx,%eax
   1091f:	0f b6 00             	movzbl (%eax),%eax
   10922:	3c ff                	cmp    $0xff,%al
   10924:	75 10                	jne    10936 <addChunk_tRNS+0x5a>
      --amount;
   10926:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   1092a:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   1092e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10932:	75 d7                	jne    1090b <addChunk_tRNS+0x2f>
   10934:	eb 01                	jmp    10937 <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10936:	90                   	nop
      --amount;
    }
    if(amount) {
   10937:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   1093b:	0f 84 63 01 00 00    	je     10aa4 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   10941:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10944:	68 0d a0 01 00       	push   $0x1a00d
   10949:	50                   	push   %eax
   1094a:	ff 75 08             	pushl  0x8(%ebp)
   1094d:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10950:	50                   	push   %eax
   10951:	e8 ff 7d ff ff       	call   8755 <lodepng_chunk_init>
   10956:	83 c4 10             	add    $0x10,%esp
   10959:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1095c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10960:	74 08                	je     1096a <addChunk_tRNS+0x8e>
   10962:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10965:	e9 52 01 00 00       	jmp    10abc <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   1096a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10971:	eb 25                	jmp    10998 <addChunk_tRNS+0xbc>
   10973:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10976:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10979:	83 c2 08             	add    $0x8,%edx
   1097c:	01 c2                	add    %eax,%edx
   1097e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10981:	8b 40 08             	mov    0x8(%eax),%eax
   10984:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10987:	c1 e1 02             	shl    $0x2,%ecx
   1098a:	83 c1 03             	add    $0x3,%ecx
   1098d:	01 c8                	add    %ecx,%eax
   1098f:	0f b6 00             	movzbl (%eax),%eax
   10992:	88 02                	mov    %al,(%edx)
   10994:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10998:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1099b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   1099e:	75 d3                	jne    10973 <addChunk_tRNS+0x97>
   109a0:	e9 ff 00 00 00       	jmp    10aa4 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   109a5:	8b 45 0c             	mov    0xc(%ebp),%eax
   109a8:	8b 00                	mov    (%eax),%eax
   109aa:	85 c0                	test   %eax,%eax
   109ac:	75 59                	jne    10a07 <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   109ae:	8b 45 0c             	mov    0xc(%ebp),%eax
   109b1:	8b 40 10             	mov    0x10(%eax),%eax
   109b4:	85 c0                	test   %eax,%eax
   109b6:	0f 84 e8 00 00 00    	je     10aa4 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   109bc:	68 0d a0 01 00       	push   $0x1a00d
   109c1:	6a 02                	push   $0x2
   109c3:	ff 75 08             	pushl  0x8(%ebp)
   109c6:	8d 45 e8             	lea    -0x18(%ebp),%eax
   109c9:	50                   	push   %eax
   109ca:	e8 86 7d ff ff       	call   8755 <lodepng_chunk_init>
   109cf:	83 c4 10             	add    $0x10,%esp
   109d2:	89 45 f0             	mov    %eax,-0x10(%ebp)
   109d5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   109d9:	74 08                	je     109e3 <addChunk_tRNS+0x107>
   109db:	8b 45 f0             	mov    -0x10(%ebp),%eax
   109de:	e9 d9 00 00 00       	jmp    10abc <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   109e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   109e6:	8d 50 08             	lea    0x8(%eax),%edx
   109e9:	8b 45 0c             	mov    0xc(%ebp),%eax
   109ec:	8b 40 14             	mov    0x14(%eax),%eax
   109ef:	c1 e8 08             	shr    $0x8,%eax
   109f2:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   109f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   109f7:	8d 50 09             	lea    0x9(%eax),%edx
   109fa:	8b 45 0c             	mov    0xc(%ebp),%eax
   109fd:	8b 40 14             	mov    0x14(%eax),%eax
   10a00:	88 02                	mov    %al,(%edx)
   10a02:	e9 9d 00 00 00       	jmp    10aa4 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   10a07:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a0a:	8b 00                	mov    (%eax),%eax
   10a0c:	83 f8 02             	cmp    $0x2,%eax
   10a0f:	0f 85 8f 00 00 00    	jne    10aa4 <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   10a15:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a18:	8b 40 10             	mov    0x10(%eax),%eax
   10a1b:	85 c0                	test   %eax,%eax
   10a1d:	0f 84 81 00 00 00    	je     10aa4 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   10a23:	68 0d a0 01 00       	push   $0x1a00d
   10a28:	6a 06                	push   $0x6
   10a2a:	ff 75 08             	pushl  0x8(%ebp)
   10a2d:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10a30:	50                   	push   %eax
   10a31:	e8 1f 7d ff ff       	call   8755 <lodepng_chunk_init>
   10a36:	83 c4 10             	add    $0x10,%esp
   10a39:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10a3c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10a40:	74 05                	je     10a47 <addChunk_tRNS+0x16b>
   10a42:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10a45:	eb 75                	jmp    10abc <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10a47:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a4a:	8d 50 08             	lea    0x8(%eax),%edx
   10a4d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a50:	8b 40 14             	mov    0x14(%eax),%eax
   10a53:	c1 e8 08             	shr    $0x8,%eax
   10a56:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10a58:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a5b:	8d 50 09             	lea    0x9(%eax),%edx
   10a5e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a61:	8b 40 14             	mov    0x14(%eax),%eax
   10a64:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   10a66:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a69:	8d 50 0a             	lea    0xa(%eax),%edx
   10a6c:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a6f:	8b 40 18             	mov    0x18(%eax),%eax
   10a72:	c1 e8 08             	shr    $0x8,%eax
   10a75:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   10a77:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a7a:	8d 50 0b             	lea    0xb(%eax),%edx
   10a7d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a80:	8b 40 18             	mov    0x18(%eax),%eax
   10a83:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   10a85:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a88:	8d 50 0c             	lea    0xc(%eax),%edx
   10a8b:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a8e:	8b 40 1c             	mov    0x1c(%eax),%eax
   10a91:	c1 e8 08             	shr    $0x8,%eax
   10a94:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   10a96:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a99:	8d 50 0d             	lea    0xd(%eax),%edx
   10a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a9f:	8b 40 1c             	mov    0x1c(%eax),%eax
   10aa2:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   10aa4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10aa7:	85 c0                	test   %eax,%eax
   10aa9:	74 0c                	je     10ab7 <addChunk_tRNS+0x1db>
   10aab:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10aae:	50                   	push   %eax
   10aaf:	e8 4a 79 ff ff       	call   83fe <lodepng_chunk_generate_crc>
   10ab4:	83 c4 04             	add    $0x4,%esp
  return 0;
   10ab7:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10abc:	c9                   	leave  
   10abd:	c3                   	ret    

00010abe <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   10abe:	55                   	push   %ebp
   10abf:	89 e5                	mov    %esp,%ebp
   10ac1:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   10ac4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   10acb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   10ad2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   10ad9:	83 ec 0c             	sub    $0xc,%esp
   10adc:	ff 75 14             	pushl  0x14(%ebp)
   10adf:	ff 75 10             	pushl  0x10(%ebp)
   10ae2:	ff 75 0c             	pushl  0xc(%ebp)
   10ae5:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10ae8:	50                   	push   %eax
   10ae9:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10aec:	50                   	push   %eax
   10aed:	e8 fb 74 ff ff       	call   7fed <zlib_compress>
   10af2:	83 c4 20             	add    $0x20,%esp
   10af5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   10af8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10afc:	75 1b                	jne    10b19 <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   10afe:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b01:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10b04:	50                   	push   %eax
   10b05:	68 44 a0 01 00       	push   $0x1a044
   10b0a:	52                   	push   %edx
   10b0b:	ff 75 08             	pushl  0x8(%ebp)
   10b0e:	e8 ea 7c ff ff       	call   87fd <lodepng_chunk_createv>
   10b13:	83 c4 10             	add    $0x10,%esp
   10b16:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   10b19:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b1c:	83 ec 0c             	sub    $0xc,%esp
   10b1f:	50                   	push   %eax
   10b20:	e8 d9 27 ff ff       	call   32fe <lodepng_free>
   10b25:	83 c4 10             	add    $0x10,%esp
  return error;
   10b28:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10b2b:	c9                   	leave  
   10b2c:	c3                   	ret    

00010b2d <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   10b2d:	55                   	push   %ebp
   10b2e:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   10b30:	6a 00                	push   $0x0
   10b32:	68 49 a0 01 00       	push   $0x1a049
   10b37:	6a 00                	push   $0x0
   10b39:	ff 75 08             	pushl  0x8(%ebp)
   10b3c:	e8 bc 7c ff ff       	call   87fd <lodepng_chunk_createv>
   10b41:	83 c4 10             	add    $0x10,%esp
}
   10b44:	c9                   	leave  
   10b45:	c3                   	ret    

00010b46 <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   10b46:	55                   	push   %ebp
   10b47:	89 e5                	mov    %esp,%ebp
   10b49:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10b4c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   10b53:	ff 75 0c             	pushl  0xc(%ebp)
   10b56:	e8 1e 28 ff ff       	call   3379 <lodepng_strlen>
   10b5b:	83 c4 04             	add    $0x4,%esp
   10b5e:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10b61:	ff 75 10             	pushl  0x10(%ebp)
   10b64:	e8 10 28 ff ff       	call   3379 <lodepng_strlen>
   10b69:	83 c4 04             	add    $0x4,%esp
   10b6c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   10b6f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10b72:	8d 50 01             	lea    0x1(%eax),%edx
   10b75:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10b78:	01 d0                	add    %edx,%eax
   10b7a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10b7d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10b81:	7e 06                	jle    10b89 <addChunk_tEXt+0x43>
   10b83:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   10b87:	7e 07                	jle    10b90 <addChunk_tEXt+0x4a>
   10b89:	b8 59 00 00 00       	mov    $0x59,%eax
   10b8e:	eb 74                	jmp    10c04 <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   10b90:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b93:	68 17 a0 01 00       	push   $0x1a017
   10b98:	50                   	push   %eax
   10b99:	ff 75 08             	pushl  0x8(%ebp)
   10b9c:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10b9f:	50                   	push   %eax
   10ba0:	e8 b0 7b ff ff       	call   8755 <lodepng_chunk_init>
   10ba5:	83 c4 10             	add    $0x10,%esp
   10ba8:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10bab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10baf:	74 05                	je     10bb6 <addChunk_tEXt+0x70>
   10bb1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10bb4:	eb 4e                	jmp    10c04 <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   10bb6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10bb9:	83 c0 08             	add    $0x8,%eax
   10bbc:	ff 75 fc             	pushl  -0x4(%ebp)
   10bbf:	ff 75 0c             	pushl  0xc(%ebp)
   10bc2:	50                   	push   %eax
   10bc3:	e8 53 27 ff ff       	call   331b <lodepng_memcpy>
   10bc8:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   10bcb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10bce:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10bd1:	83 c2 08             	add    $0x8,%edx
   10bd4:	01 d0                	add    %edx,%eax
   10bd6:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   10bd9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10bdc:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10bdf:	83 c2 09             	add    $0x9,%edx
   10be2:	01 d0                	add    %edx,%eax
   10be4:	ff 75 f8             	pushl  -0x8(%ebp)
   10be7:	ff 75 10             	pushl  0x10(%ebp)
   10bea:	50                   	push   %eax
   10beb:	e8 2b 27 ff ff       	call   331b <lodepng_memcpy>
   10bf0:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   10bf3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10bf6:	50                   	push   %eax
   10bf7:	e8 02 78 ff ff       	call   83fe <lodepng_chunk_generate_crc>
   10bfc:	83 c4 04             	add    $0x4,%esp
  return 0;
   10bff:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10c04:	c9                   	leave  
   10c05:	c3                   	ret    

00010c06 <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   10c06:	55                   	push   %ebp
   10c07:	89 e5                	mov    %esp,%ebp
   10c09:	53                   	push   %ebx
   10c0a:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   10c0d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10c14:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   10c1b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   10c22:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10c29:	ff 75 10             	pushl  0x10(%ebp)
   10c2c:	e8 48 27 ff ff       	call   3379 <lodepng_strlen>
   10c31:	83 c4 04             	add    $0x4,%esp
   10c34:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   10c37:	ff 75 0c             	pushl  0xc(%ebp)
   10c3a:	e8 3a 27 ff ff       	call   3379 <lodepng_strlen>
   10c3f:	83 c4 04             	add    $0x4,%esp
   10c42:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10c45:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10c49:	7e 06                	jle    10c51 <addChunk_zTXt+0x4b>
   10c4b:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10c4f:	7e 0a                	jle    10c5b <addChunk_zTXt+0x55>
   10c51:	b8 59 00 00 00       	mov    $0x59,%eax
   10c56:	e9 c8 00 00 00       	jmp    10d23 <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   10c5b:	83 ec 0c             	sub    $0xc,%esp
   10c5e:	ff 75 14             	pushl  0x14(%ebp)
   10c61:	ff 75 f0             	pushl  -0x10(%ebp)
   10c64:	ff 75 10             	pushl  0x10(%ebp)
   10c67:	8d 45 dc             	lea    -0x24(%ebp),%eax
   10c6a:	50                   	push   %eax
   10c6b:	8d 45 e0             	lea    -0x20(%ebp),%eax
   10c6e:	50                   	push   %eax
   10c6f:	e8 79 73 ff ff       	call   7fed <zlib_compress>
   10c74:	83 c4 20             	add    $0x20,%esp
   10c77:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   10c7a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10c7e:	75 29                	jne    10ca9 <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   10c80:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c83:	8d 50 02             	lea    0x2(%eax),%edx
   10c86:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10c89:	01 d0                	add    %edx,%eax
   10c8b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   10c8e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10c91:	68 1c a0 01 00       	push   $0x1a01c
   10c96:	50                   	push   %eax
   10c97:	ff 75 08             	pushl  0x8(%ebp)
   10c9a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   10c9d:	50                   	push   %eax
   10c9e:	e8 b2 7a ff ff       	call   8755 <lodepng_chunk_init>
   10ca3:	83 c4 10             	add    $0x10,%esp
   10ca6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10ca9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10cad:	75 62                	jne    10d11 <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   10caf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10cb2:	83 c0 08             	add    $0x8,%eax
   10cb5:	83 ec 04             	sub    $0x4,%esp
   10cb8:	ff 75 ec             	pushl  -0x14(%ebp)
   10cbb:	ff 75 0c             	pushl  0xc(%ebp)
   10cbe:	50                   	push   %eax
   10cbf:	e8 57 26 ff ff       	call   331b <lodepng_memcpy>
   10cc4:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   10cc7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10cca:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10ccd:	83 c2 08             	add    $0x8,%edx
   10cd0:	01 d0                	add    %edx,%eax
   10cd2:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   10cd5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10cd8:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10cdb:	83 c2 09             	add    $0x9,%edx
   10cde:	01 d0                	add    %edx,%eax
   10ce0:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   10ce3:	8b 55 dc             	mov    -0x24(%ebp),%edx
   10ce6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10ce9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   10cec:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   10cef:	83 c3 0a             	add    $0xa,%ebx
   10cf2:	01 d9                	add    %ebx,%ecx
   10cf4:	83 ec 04             	sub    $0x4,%esp
   10cf7:	52                   	push   %edx
   10cf8:	50                   	push   %eax
   10cf9:	51                   	push   %ecx
   10cfa:	e8 1c 26 ff ff       	call   331b <lodepng_memcpy>
   10cff:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   10d02:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d05:	83 ec 0c             	sub    $0xc,%esp
   10d08:	50                   	push   %eax
   10d09:	e8 f0 76 ff ff       	call   83fe <lodepng_chunk_generate_crc>
   10d0e:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10d11:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10d14:	83 ec 0c             	sub    $0xc,%esp
   10d17:	50                   	push   %eax
   10d18:	e8 e1 25 ff ff       	call   32fe <lodepng_free>
   10d1d:	83 c4 10             	add    $0x10,%esp
  return error;
   10d20:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10d23:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10d26:	c9                   	leave  
   10d27:	c3                   	ret    

00010d28 <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   10d28:	55                   	push   %ebp
   10d29:	89 e5                	mov    %esp,%ebp
   10d2b:	53                   	push   %ebx
   10d2c:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   10d2f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10d36:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   10d3d:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   10d44:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10d4b:	ff 75 1c             	pushl  0x1c(%ebp)
   10d4e:	e8 26 26 ff ff       	call   3379 <lodepng_strlen>
   10d53:	83 c4 04             	add    $0x4,%esp
   10d56:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   10d59:	ff 75 10             	pushl  0x10(%ebp)
   10d5c:	e8 18 26 ff ff       	call   3379 <lodepng_strlen>
   10d61:	83 c4 04             	add    $0x4,%esp
   10d64:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10d67:	ff 75 14             	pushl  0x14(%ebp)
   10d6a:	e8 0a 26 ff ff       	call   3379 <lodepng_strlen>
   10d6f:	83 c4 04             	add    $0x4,%esp
   10d72:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10d75:	ff 75 18             	pushl  0x18(%ebp)
   10d78:	e8 fc 25 ff ff       	call   3379 <lodepng_strlen>
   10d7d:	83 c4 04             	add    $0x4,%esp
   10d80:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10d83:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10d87:	7e 06                	jle    10d8f <addChunk_iTXt+0x67>
   10d89:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10d8d:	7e 0a                	jle    10d99 <addChunk_iTXt+0x71>
   10d8f:	b8 59 00 00 00       	mov    $0x59,%eax
   10d94:	e9 9a 01 00 00       	jmp    10f33 <addChunk_iTXt+0x20b>

  if(compress) {
   10d99:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10d9d:	74 1f                	je     10dbe <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   10d9f:	83 ec 0c             	sub    $0xc,%esp
   10da2:	ff 75 20             	pushl  0x20(%ebp)
   10da5:	ff 75 f0             	pushl  -0x10(%ebp)
   10da8:	ff 75 1c             	pushl  0x1c(%ebp)
   10dab:	8d 45 d0             	lea    -0x30(%ebp),%eax
   10dae:	50                   	push   %eax
   10daf:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   10db2:	50                   	push   %eax
   10db3:	e8 35 72 ff ff       	call   7fed <zlib_compress>
   10db8:	83 c4 20             	add    $0x20,%esp
   10dbb:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   10dbe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10dc2:	75 44                	jne    10e08 <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   10dc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10dc7:	8d 50 03             	lea    0x3(%eax),%edx
   10dca:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10dcd:	01 d0                	add    %edx,%eax
   10dcf:	8d 50 01             	lea    0x1(%eax),%edx
   10dd2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10dd5:	01 d0                	add    %edx,%eax
   10dd7:	8d 50 01             	lea    0x1(%eax),%edx
   10dda:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10dde:	74 05                	je     10de5 <addChunk_iTXt+0xbd>
   10de0:	8b 45 d0             	mov    -0x30(%ebp),%eax
   10de3:	eb 03                	jmp    10de8 <addChunk_iTXt+0xc0>
   10de5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10de8:	01 d0                	add    %edx,%eax
   10dea:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   10ded:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10df0:	68 21 a0 01 00       	push   $0x1a021
   10df5:	50                   	push   %eax
   10df6:	ff 75 08             	pushl  0x8(%ebp)
   10df9:	8d 45 d8             	lea    -0x28(%ebp),%eax
   10dfc:	50                   	push   %eax
   10dfd:	e8 53 79 ff ff       	call   8755 <lodepng_chunk_init>
   10e02:	83 c4 10             	add    $0x10,%esp
   10e05:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10e08:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e0c:	0f 85 0f 01 00 00    	jne    10f21 <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   10e12:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   10e19:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10e1c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e1f:	01 d0                	add    %edx,%eax
   10e21:	83 ec 04             	sub    $0x4,%esp
   10e24:	ff 75 ec             	pushl  -0x14(%ebp)
   10e27:	ff 75 10             	pushl  0x10(%ebp)
   10e2a:	50                   	push   %eax
   10e2b:	e8 eb 24 ff ff       	call   331b <lodepng_memcpy>
   10e30:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   10e33:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e36:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10e39:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10e3c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e3f:	8d 50 01             	lea    0x1(%eax),%edx
   10e42:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10e45:	01 c8                	add    %ecx,%eax
   10e47:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   10e4a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10e4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e50:	8d 50 01             	lea    0x1(%eax),%edx
   10e53:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10e56:	01 c8                	add    %ecx,%eax
   10e58:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10e5c:	0f 95 c2             	setne  %dl
   10e5f:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   10e61:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10e64:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e67:	8d 50 01             	lea    0x1(%eax),%edx
   10e6a:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10e6d:	01 c8                	add    %ecx,%eax
   10e6f:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   10e72:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10e75:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e78:	01 d0                	add    %edx,%eax
   10e7a:	83 ec 04             	sub    $0x4,%esp
   10e7d:	ff 75 e8             	pushl  -0x18(%ebp)
   10e80:	ff 75 14             	pushl  0x14(%ebp)
   10e83:	50                   	push   %eax
   10e84:	e8 92 24 ff ff       	call   331b <lodepng_memcpy>
   10e89:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   10e8c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e8f:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10e92:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10e95:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e98:	8d 50 01             	lea    0x1(%eax),%edx
   10e9b:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10e9e:	01 c8                	add    %ecx,%eax
   10ea0:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   10ea3:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10ea6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ea9:	01 d0                	add    %edx,%eax
   10eab:	83 ec 04             	sub    $0x4,%esp
   10eae:	ff 75 e4             	pushl  -0x1c(%ebp)
   10eb1:	ff 75 18             	pushl  0x18(%ebp)
   10eb4:	50                   	push   %eax
   10eb5:	e8 61 24 ff ff       	call   331b <lodepng_memcpy>
   10eba:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   10ebd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10ec0:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10ec3:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10ec6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ec9:	8d 50 01             	lea    0x1(%eax),%edx
   10ecc:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10ecf:	01 c8                	add    %ecx,%eax
   10ed1:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   10ed4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10ed8:	74 1e                	je     10ef8 <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   10eda:	8b 55 d0             	mov    -0x30(%ebp),%edx
   10edd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10ee0:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   10ee3:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   10ee6:	01 d9                	add    %ebx,%ecx
   10ee8:	83 ec 04             	sub    $0x4,%esp
   10eeb:	52                   	push   %edx
   10eec:	50                   	push   %eax
   10eed:	51                   	push   %ecx
   10eee:	e8 28 24 ff ff       	call   331b <lodepng_memcpy>
   10ef3:	83 c4 10             	add    $0x10,%esp
   10ef6:	eb 1a                	jmp    10f12 <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   10ef8:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10efb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10efe:	01 d0                	add    %edx,%eax
   10f00:	83 ec 04             	sub    $0x4,%esp
   10f03:	ff 75 f0             	pushl  -0x10(%ebp)
   10f06:	ff 75 1c             	pushl  0x1c(%ebp)
   10f09:	50                   	push   %eax
   10f0a:	e8 0c 24 ff ff       	call   331b <lodepng_memcpy>
   10f0f:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   10f12:	8b 45 d8             	mov    -0x28(%ebp),%eax
   10f15:	83 ec 0c             	sub    $0xc,%esp
   10f18:	50                   	push   %eax
   10f19:	e8 e0 74 ff ff       	call   83fe <lodepng_chunk_generate_crc>
   10f1e:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10f21:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10f24:	83 ec 0c             	sub    $0xc,%esp
   10f27:	50                   	push   %eax
   10f28:	e8 d1 23 ff ff       	call   32fe <lodepng_free>
   10f2d:	83 c4 10             	add    $0x10,%esp
  return error;
   10f30:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10f33:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10f36:	c9                   	leave  
   10f37:	c3                   	ret    

00010f38 <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   10f38:	55                   	push   %ebp
   10f39:	89 e5                	mov    %esp,%ebp
   10f3b:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   10f3e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   10f45:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f48:	8b 40 0c             	mov    0xc(%eax),%eax
   10f4b:	85 c0                	test   %eax,%eax
   10f4d:	74 0b                	je     10f5a <addChunk_bKGD+0x22>
   10f4f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f52:	8b 40 0c             	mov    0xc(%eax),%eax
   10f55:	83 f8 04             	cmp    $0x4,%eax
   10f58:	75 4b                	jne    10fa5 <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   10f5a:	68 12 a0 01 00       	push   $0x1a012
   10f5f:	6a 02                	push   $0x2
   10f61:	ff 75 08             	pushl  0x8(%ebp)
   10f64:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10f67:	50                   	push   %eax
   10f68:	e8 e8 77 ff ff       	call   8755 <lodepng_chunk_init>
   10f6d:	83 c4 10             	add    $0x10,%esp
   10f70:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10f73:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10f77:	74 08                	je     10f81 <addChunk_bKGD+0x49>
   10f79:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10f7c:	e9 19 01 00 00       	jmp    1109a <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   10f81:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10f84:	8d 50 08             	lea    0x8(%eax),%edx
   10f87:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f8a:	8b 40 30             	mov    0x30(%eax),%eax
   10f8d:	c1 e8 08             	shr    $0x8,%eax
   10f90:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   10f92:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10f95:	8d 50 09             	lea    0x9(%eax),%edx
   10f98:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f9b:	8b 40 30             	mov    0x30(%eax),%eax
   10f9e:	88 02                	mov    %al,(%edx)
   10fa0:	e9 dd 00 00 00       	jmp    11082 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   10fa5:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fa8:	8b 40 0c             	mov    0xc(%eax),%eax
   10fab:	83 f8 02             	cmp    $0x2,%eax
   10fae:	74 0f                	je     10fbf <addChunk_bKGD+0x87>
   10fb0:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fb3:	8b 40 0c             	mov    0xc(%eax),%eax
   10fb6:	83 f8 06             	cmp    $0x6,%eax
   10fb9:	0f 85 86 00 00 00    	jne    11045 <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   10fbf:	68 12 a0 01 00       	push   $0x1a012
   10fc4:	6a 06                	push   $0x6
   10fc6:	ff 75 08             	pushl  0x8(%ebp)
   10fc9:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10fcc:	50                   	push   %eax
   10fcd:	e8 83 77 ff ff       	call   8755 <lodepng_chunk_init>
   10fd2:	83 c4 10             	add    $0x10,%esp
   10fd5:	89 45 f8             	mov    %eax,-0x8(%ebp)
   10fd8:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   10fdc:	74 08                	je     10fe6 <addChunk_bKGD+0xae>
   10fde:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10fe1:	e9 b4 00 00 00       	jmp    1109a <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   10fe6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10fe9:	8d 50 08             	lea    0x8(%eax),%edx
   10fec:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fef:	8b 40 30             	mov    0x30(%eax),%eax
   10ff2:	c1 e8 08             	shr    $0x8,%eax
   10ff5:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   10ff7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ffa:	8d 50 09             	lea    0x9(%eax),%edx
   10ffd:	8b 45 0c             	mov    0xc(%ebp),%eax
   11000:	8b 40 30             	mov    0x30(%eax),%eax
   11003:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   11005:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11008:	8d 50 0a             	lea    0xa(%eax),%edx
   1100b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1100e:	8b 40 34             	mov    0x34(%eax),%eax
   11011:	c1 e8 08             	shr    $0x8,%eax
   11014:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   11016:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11019:	8d 50 0b             	lea    0xb(%eax),%edx
   1101c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1101f:	8b 40 34             	mov    0x34(%eax),%eax
   11022:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   11024:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11027:	8d 50 0c             	lea    0xc(%eax),%edx
   1102a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1102d:	8b 40 38             	mov    0x38(%eax),%eax
   11030:	c1 e8 08             	shr    $0x8,%eax
   11033:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   11035:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11038:	8d 50 0d             	lea    0xd(%eax),%edx
   1103b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1103e:	8b 40 38             	mov    0x38(%eax),%eax
   11041:	88 02                	mov    %al,(%edx)
   11043:	eb 3d                	jmp    11082 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   11045:	8b 45 0c             	mov    0xc(%ebp),%eax
   11048:	8b 40 0c             	mov    0xc(%eax),%eax
   1104b:	83 f8 03             	cmp    $0x3,%eax
   1104e:	75 32                	jne    11082 <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   11050:	68 12 a0 01 00       	push   $0x1a012
   11055:	6a 01                	push   $0x1
   11057:	ff 75 08             	pushl  0x8(%ebp)
   1105a:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1105d:	50                   	push   %eax
   1105e:	e8 f2 76 ff ff       	call   8755 <lodepng_chunk_init>
   11063:	83 c4 10             	add    $0x10,%esp
   11066:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11069:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1106d:	74 05                	je     11074 <addChunk_bKGD+0x13c>
   1106f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11072:	eb 26                	jmp    1109a <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   11074:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11077:	8d 50 08             	lea    0x8(%eax),%edx
   1107a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1107d:	8b 40 30             	mov    0x30(%eax),%eax
   11080:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   11082:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11085:	85 c0                	test   %eax,%eax
   11087:	74 0c                	je     11095 <addChunk_bKGD+0x15d>
   11089:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1108c:	50                   	push   %eax
   1108d:	e8 6c 73 ff ff       	call   83fe <lodepng_chunk_generate_crc>
   11092:	83 c4 04             	add    $0x4,%esp
  return 0;
   11095:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1109a:	c9                   	leave  
   1109b:	c3                   	ret    

0001109c <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   1109c:	55                   	push   %ebp
   1109d:	89 e5                	mov    %esp,%ebp
   1109f:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   110a2:	68 26 a0 01 00       	push   $0x1a026
   110a7:	6a 07                	push   $0x7
   110a9:	ff 75 08             	pushl  0x8(%ebp)
   110ac:	8d 45 f8             	lea    -0x8(%ebp),%eax
   110af:	50                   	push   %eax
   110b0:	e8 a0 76 ff ff       	call   8755 <lodepng_chunk_init>
   110b5:	83 c4 10             	add    $0x10,%esp
   110b8:	89 45 fc             	mov    %eax,-0x4(%ebp)
   110bb:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   110bf:	74 05                	je     110c6 <addChunk_tIME+0x2a>
   110c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   110c4:	eb 74                	jmp    1113a <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   110c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   110c9:	8d 50 08             	lea    0x8(%eax),%edx
   110cc:	8b 45 0c             	mov    0xc(%ebp),%eax
   110cf:	8b 00                	mov    (%eax),%eax
   110d1:	c1 e8 08             	shr    $0x8,%eax
   110d4:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   110d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   110d9:	8d 50 09             	lea    0x9(%eax),%edx
   110dc:	8b 45 0c             	mov    0xc(%ebp),%eax
   110df:	8b 00                	mov    (%eax),%eax
   110e1:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   110e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   110e6:	8d 50 0a             	lea    0xa(%eax),%edx
   110e9:	8b 45 0c             	mov    0xc(%ebp),%eax
   110ec:	8b 40 04             	mov    0x4(%eax),%eax
   110ef:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   110f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
   110f4:	8d 50 0b             	lea    0xb(%eax),%edx
   110f7:	8b 45 0c             	mov    0xc(%ebp),%eax
   110fa:	8b 40 08             	mov    0x8(%eax),%eax
   110fd:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   110ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11102:	8d 50 0c             	lea    0xc(%eax),%edx
   11105:	8b 45 0c             	mov    0xc(%ebp),%eax
   11108:	8b 40 0c             	mov    0xc(%eax),%eax
   1110b:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   1110d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11110:	8d 50 0d             	lea    0xd(%eax),%edx
   11113:	8b 45 0c             	mov    0xc(%ebp),%eax
   11116:	8b 40 10             	mov    0x10(%eax),%eax
   11119:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   1111b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1111e:	8d 50 0e             	lea    0xe(%eax),%edx
   11121:	8b 45 0c             	mov    0xc(%ebp),%eax
   11124:	8b 40 14             	mov    0x14(%eax),%eax
   11127:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   11129:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1112c:	50                   	push   %eax
   1112d:	e8 cc 72 ff ff       	call   83fe <lodepng_chunk_generate_crc>
   11132:	83 c4 04             	add    $0x4,%esp
  return 0;
   11135:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1113a:	c9                   	leave  
   1113b:	c3                   	ret    

0001113c <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   1113c:	55                   	push   %ebp
   1113d:	89 e5                	mov    %esp,%ebp
   1113f:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   11142:	68 2b a0 01 00       	push   $0x1a02b
   11147:	6a 09                	push   $0x9
   11149:	ff 75 08             	pushl  0x8(%ebp)
   1114c:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1114f:	50                   	push   %eax
   11150:	e8 00 76 ff ff       	call   8755 <lodepng_chunk_init>
   11155:	83 c4 10             	add    $0x10,%esp
   11158:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1115b:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1115f:	74 05                	je     11166 <addChunk_pHYs+0x2a>
   11161:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11164:	eb 51                	jmp    111b7 <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   11166:	8b 45 0c             	mov    0xc(%ebp),%eax
   11169:	8b 40 7c             	mov    0x7c(%eax),%eax
   1116c:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1116f:	83 c2 08             	add    $0x8,%edx
   11172:	50                   	push   %eax
   11173:	52                   	push   %edx
   11174:	e8 25 25 ff ff       	call   369e <lodepng_set32bitInt>
   11179:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   1117c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1117f:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   11185:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11188:	83 c2 0c             	add    $0xc,%edx
   1118b:	50                   	push   %eax
   1118c:	52                   	push   %edx
   1118d:	e8 0c 25 ff ff       	call   369e <lodepng_set32bitInt>
   11192:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   11195:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11198:	8d 50 10             	lea    0x10(%eax),%edx
   1119b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1119e:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   111a4:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   111a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111a9:	50                   	push   %eax
   111aa:	e8 4f 72 ff ff       	call   83fe <lodepng_chunk_generate_crc>
   111af:	83 c4 04             	add    $0x4,%esp
  return 0;
   111b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
   111b7:	c9                   	leave  
   111b8:	c3                   	ret    

000111b9 <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   111b9:	55                   	push   %ebp
   111ba:	89 e5                	mov    %esp,%ebp
   111bc:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   111bf:	68 30 a0 01 00       	push   $0x1a030
   111c4:	6a 04                	push   $0x4
   111c6:	ff 75 08             	pushl  0x8(%ebp)
   111c9:	8d 45 f8             	lea    -0x8(%ebp),%eax
   111cc:	50                   	push   %eax
   111cd:	e8 83 75 ff ff       	call   8755 <lodepng_chunk_init>
   111d2:	83 c4 10             	add    $0x10,%esp
   111d5:	89 45 fc             	mov    %eax,-0x4(%ebp)
   111d8:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   111dc:	74 05                	je     111e3 <addChunk_gAMA+0x2a>
   111de:	8b 45 fc             	mov    -0x4(%ebp),%eax
   111e1:	eb 2a                	jmp    1120d <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   111e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   111e6:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   111ec:	8b 55 f8             	mov    -0x8(%ebp),%edx
   111ef:	83 c2 08             	add    $0x8,%edx
   111f2:	50                   	push   %eax
   111f3:	52                   	push   %edx
   111f4:	e8 a5 24 ff ff       	call   369e <lodepng_set32bitInt>
   111f9:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   111fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111ff:	50                   	push   %eax
   11200:	e8 f9 71 ff ff       	call   83fe <lodepng_chunk_generate_crc>
   11205:	83 c4 04             	add    $0x4,%esp
  return 0;
   11208:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1120d:	c9                   	leave  
   1120e:	c3                   	ret    

0001120f <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   1120f:	55                   	push   %ebp
   11210:	89 e5                	mov    %esp,%ebp
   11212:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   11215:	68 35 a0 01 00       	push   $0x1a035
   1121a:	6a 20                	push   $0x20
   1121c:	ff 75 08             	pushl  0x8(%ebp)
   1121f:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11222:	50                   	push   %eax
   11223:	e8 2d 75 ff ff       	call   8755 <lodepng_chunk_init>
   11228:	83 c4 10             	add    $0x10,%esp
   1122b:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1122e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11232:	74 08                	je     1123c <addChunk_cHRM+0x2d>
   11234:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11237:	e9 d9 00 00 00       	jmp    11315 <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   1123c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1123f:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   11245:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11248:	83 c2 08             	add    $0x8,%edx
   1124b:	50                   	push   %eax
   1124c:	52                   	push   %edx
   1124d:	e8 4c 24 ff ff       	call   369e <lodepng_set32bitInt>
   11252:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   11255:	8b 45 0c             	mov    0xc(%ebp),%eax
   11258:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   1125e:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11261:	83 c2 0c             	add    $0xc,%edx
   11264:	50                   	push   %eax
   11265:	52                   	push   %edx
   11266:	e8 33 24 ff ff       	call   369e <lodepng_set32bitInt>
   1126b:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   1126e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11271:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   11277:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1127a:	83 c2 10             	add    $0x10,%edx
   1127d:	50                   	push   %eax
   1127e:	52                   	push   %edx
   1127f:	e8 1a 24 ff ff       	call   369e <lodepng_set32bitInt>
   11284:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   11287:	8b 45 0c             	mov    0xc(%ebp),%eax
   1128a:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11290:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11293:	83 c2 14             	add    $0x14,%edx
   11296:	50                   	push   %eax
   11297:	52                   	push   %edx
   11298:	e8 01 24 ff ff       	call   369e <lodepng_set32bitInt>
   1129d:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   112a0:	8b 45 0c             	mov    0xc(%ebp),%eax
   112a3:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   112a9:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112ac:	83 c2 18             	add    $0x18,%edx
   112af:	50                   	push   %eax
   112b0:	52                   	push   %edx
   112b1:	e8 e8 23 ff ff       	call   369e <lodepng_set32bitInt>
   112b6:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   112b9:	8b 45 0c             	mov    0xc(%ebp),%eax
   112bc:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   112c2:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112c5:	83 c2 1c             	add    $0x1c,%edx
   112c8:	50                   	push   %eax
   112c9:	52                   	push   %edx
   112ca:	e8 cf 23 ff ff       	call   369e <lodepng_set32bitInt>
   112cf:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   112d2:	8b 45 0c             	mov    0xc(%ebp),%eax
   112d5:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   112db:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112de:	83 c2 20             	add    $0x20,%edx
   112e1:	50                   	push   %eax
   112e2:	52                   	push   %edx
   112e3:	e8 b6 23 ff ff       	call   369e <lodepng_set32bitInt>
   112e8:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   112eb:	8b 45 0c             	mov    0xc(%ebp),%eax
   112ee:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   112f4:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112f7:	83 c2 24             	add    $0x24,%edx
   112fa:	50                   	push   %eax
   112fb:	52                   	push   %edx
   112fc:	e8 9d 23 ff ff       	call   369e <lodepng_set32bitInt>
   11301:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   11304:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11307:	50                   	push   %eax
   11308:	e8 f1 70 ff ff       	call   83fe <lodepng_chunk_generate_crc>
   1130d:	83 c4 04             	add    $0x4,%esp
  return 0;
   11310:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11315:	c9                   	leave  
   11316:	c3                   	ret    

00011317 <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   11317:	55                   	push   %ebp
   11318:	89 e5                	mov    %esp,%ebp
   1131a:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   1131d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11320:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   11326:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   11329:	8d 45 ff             	lea    -0x1(%ebp),%eax
   1132c:	50                   	push   %eax
   1132d:	68 3a a0 01 00       	push   $0x1a03a
   11332:	6a 01                	push   $0x1
   11334:	ff 75 08             	pushl  0x8(%ebp)
   11337:	e8 c1 74 ff ff       	call   87fd <lodepng_chunk_createv>
   1133c:	83 c4 10             	add    $0x10,%esp
}
   1133f:	c9                   	leave  
   11340:	c3                   	ret    

00011341 <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   11341:	55                   	push   %ebp
   11342:	89 e5                	mov    %esp,%ebp
   11344:	53                   	push   %ebx
   11345:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   11348:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   1134f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   11356:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   1135d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   11364:	8b 45 0c             	mov    0xc(%ebp),%eax
   11367:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   1136d:	50                   	push   %eax
   1136e:	e8 06 20 ff ff       	call   3379 <lodepng_strlen>
   11373:	83 c4 04             	add    $0x4,%esp
   11376:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   11379:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1137d:	7e 06                	jle    11385 <addChunk_iCCP+0x44>
   1137f:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   11383:	7e 0a                	jle    1138f <addChunk_iCCP+0x4e>
   11385:	b8 59 00 00 00       	mov    $0x59,%eax
   1138a:	e9 df 00 00 00       	jmp    1146e <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   1138f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11392:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   11398:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   1139a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1139d:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   113a3:	83 ec 0c             	sub    $0xc,%esp
   113a6:	ff 75 10             	pushl  0x10(%ebp)
   113a9:	52                   	push   %edx
   113aa:	50                   	push   %eax
   113ab:	8d 45 e0             	lea    -0x20(%ebp),%eax
   113ae:	50                   	push   %eax
   113af:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   113b2:	50                   	push   %eax
   113b3:	e8 35 6c ff ff       	call   7fed <zlib_compress>
   113b8:	83 c4 20             	add    $0x20,%esp
   113bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   113be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   113c2:	75 29                	jne    113ed <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   113c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   113c7:	8d 50 02             	lea    0x2(%eax),%edx
   113ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
   113cd:	01 d0                	add    %edx,%eax
   113cf:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   113d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   113d5:	68 3f a0 01 00       	push   $0x1a03f
   113da:	50                   	push   %eax
   113db:	ff 75 08             	pushl  0x8(%ebp)
   113de:	8d 45 e8             	lea    -0x18(%ebp),%eax
   113e1:	50                   	push   %eax
   113e2:	e8 6e 73 ff ff       	call   8755 <lodepng_chunk_init>
   113e7:	83 c4 10             	add    $0x10,%esp
   113ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   113ed:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   113f1:	75 69                	jne    1145c <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   113f3:	8b 45 0c             	mov    0xc(%ebp),%eax
   113f6:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   113fc:	8b 55 e8             	mov    -0x18(%ebp),%edx
   113ff:	83 c2 08             	add    $0x8,%edx
   11402:	83 ec 04             	sub    $0x4,%esp
   11405:	ff 75 f0             	pushl  -0x10(%ebp)
   11408:	50                   	push   %eax
   11409:	52                   	push   %edx
   1140a:	e8 0c 1f ff ff       	call   331b <lodepng_memcpy>
   1140f:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   11412:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11415:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11418:	83 c2 08             	add    $0x8,%edx
   1141b:	01 d0                	add    %edx,%eax
   1141d:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   11420:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11423:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11426:	83 c2 09             	add    $0x9,%edx
   11429:	01 d0                	add    %edx,%eax
   1142b:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   1142e:	8b 55 e0             	mov    -0x20(%ebp),%edx
   11431:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11434:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   11437:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   1143a:	83 c3 0a             	add    $0xa,%ebx
   1143d:	01 d9                	add    %ebx,%ecx
   1143f:	83 ec 04             	sub    $0x4,%esp
   11442:	52                   	push   %edx
   11443:	50                   	push   %eax
   11444:	51                   	push   %ecx
   11445:	e8 d1 1e ff ff       	call   331b <lodepng_memcpy>
   1144a:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   1144d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11450:	83 ec 0c             	sub    $0xc,%esp
   11453:	50                   	push   %eax
   11454:	e8 a5 6f ff ff       	call   83fe <lodepng_chunk_generate_crc>
   11459:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   1145c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1145f:	83 ec 0c             	sub    $0xc,%esp
   11462:	50                   	push   %eax
   11463:	e8 96 1e ff ff       	call   32fe <lodepng_free>
   11468:	83 c4 10             	add    $0x10,%esp
  return error;
   1146b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1146e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11471:	c9                   	leave  
   11472:	c3                   	ret    

00011473 <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   11473:	55                   	push   %ebp
   11474:	89 e5                	mov    %esp,%ebp
   11476:	56                   	push   %esi
   11477:	53                   	push   %ebx
   11478:	83 ec 14             	sub    $0x14,%esp
   1147b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1147e:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   11481:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   11485:	83 f8 04             	cmp    $0x4,%eax
   11488:	0f 87 41 03 00 00    	ja     117cf <filterScanline+0x35c>
   1148e:	8b 04 85 50 a0 01 00 	mov    0x1a050(,%eax,4),%eax
   11495:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   11497:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1149e:	eb 19                	jmp    114b9 <filterScanline+0x46>
   114a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   114a3:	8b 45 08             	mov    0x8(%ebp),%eax
   114a6:	01 c2                	add    %eax,%edx
   114a8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   114ab:	8b 45 0c             	mov    0xc(%ebp),%eax
   114ae:	01 c8                	add    %ecx,%eax
   114b0:	0f b6 00             	movzbl (%eax),%eax
   114b3:	88 02                	mov    %al,(%edx)
   114b5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   114b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   114bc:	3b 45 14             	cmp    0x14(%ebp),%eax
   114bf:	75 df                	jne    114a0 <filterScanline+0x2d>
      break;
   114c1:	e9 0a 03 00 00       	jmp    117d0 <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   114c6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   114cd:	eb 19                	jmp    114e8 <filterScanline+0x75>
   114cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
   114d2:	8b 45 08             	mov    0x8(%ebp),%eax
   114d5:	01 c2                	add    %eax,%edx
   114d7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   114da:	8b 45 0c             	mov    0xc(%ebp),%eax
   114dd:	01 c8                	add    %ecx,%eax
   114df:	0f b6 00             	movzbl (%eax),%eax
   114e2:	88 02                	mov    %al,(%edx)
   114e4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   114e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   114eb:	3b 45 18             	cmp    0x18(%ebp),%eax
   114ee:	75 df                	jne    114cf <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   114f0:	8b 45 18             	mov    0x18(%ebp),%eax
   114f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
   114f6:	eb 2d                	jmp    11525 <filterScanline+0xb2>
   114f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   114fb:	8b 45 08             	mov    0x8(%ebp),%eax
   114fe:	01 c2                	add    %eax,%edx
   11500:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11503:	8b 45 0c             	mov    0xc(%ebp),%eax
   11506:	01 c8                	add    %ecx,%eax
   11508:	0f b6 08             	movzbl (%eax),%ecx
   1150b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1150e:	2b 45 18             	sub    0x18(%ebp),%eax
   11511:	89 c3                	mov    %eax,%ebx
   11513:	8b 45 0c             	mov    0xc(%ebp),%eax
   11516:	01 d8                	add    %ebx,%eax
   11518:	0f b6 00             	movzbl (%eax),%eax
   1151b:	29 c1                	sub    %eax,%ecx
   1151d:	89 c8                	mov    %ecx,%eax
   1151f:	88 02                	mov    %al,(%edx)
   11521:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11525:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11528:	3b 45 14             	cmp    0x14(%ebp),%eax
   1152b:	7c cb                	jl     114f8 <filterScanline+0x85>
      break;
   1152d:	e9 9e 02 00 00       	jmp    117d0 <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   11532:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11536:	74 3e                	je     11576 <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   11538:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1153f:	eb 28                	jmp    11569 <filterScanline+0xf6>
   11541:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11544:	8b 45 08             	mov    0x8(%ebp),%eax
   11547:	01 d0                	add    %edx,%eax
   11549:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1154c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1154f:	01 ca                	add    %ecx,%edx
   11551:	0f b6 0a             	movzbl (%edx),%ecx
   11554:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11557:	8b 55 10             	mov    0x10(%ebp),%edx
   1155a:	01 da                	add    %ebx,%edx
   1155c:	0f b6 12             	movzbl (%edx),%edx
   1155f:	29 d1                	sub    %edx,%ecx
   11561:	89 ca                	mov    %ecx,%edx
   11563:	88 10                	mov    %dl,(%eax)
   11565:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11569:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1156c:	3b 45 14             	cmp    0x14(%ebp),%eax
   1156f:	75 d0                	jne    11541 <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   11571:	e9 5a 02 00 00       	jmp    117d0 <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   11576:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1157d:	eb 19                	jmp    11598 <filterScanline+0x125>
   1157f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11582:	8b 45 08             	mov    0x8(%ebp),%eax
   11585:	01 c2                	add    %eax,%edx
   11587:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1158a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1158d:	01 c8                	add    %ecx,%eax
   1158f:	0f b6 00             	movzbl (%eax),%eax
   11592:	88 02                	mov    %al,(%edx)
   11594:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11598:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1159b:	3b 45 14             	cmp    0x14(%ebp),%eax
   1159e:	75 df                	jne    1157f <filterScanline+0x10c>
      }
      break;
   115a0:	e9 2b 02 00 00       	jmp    117d0 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   115a5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   115a9:	0f 84 90 00 00 00    	je     1163f <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   115af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   115b6:	eb 28                	jmp    115e0 <filterScanline+0x16d>
   115b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   115bb:	8b 45 08             	mov    0x8(%ebp),%eax
   115be:	01 d0                	add    %edx,%eax
   115c0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   115c3:	8b 55 0c             	mov    0xc(%ebp),%edx
   115c6:	01 ca                	add    %ecx,%edx
   115c8:	0f b6 12             	movzbl (%edx),%edx
   115cb:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   115ce:	8b 4d 10             	mov    0x10(%ebp),%ecx
   115d1:	01 d9                	add    %ebx,%ecx
   115d3:	0f b6 09             	movzbl (%ecx),%ecx
   115d6:	d0 e9                	shr    %cl
   115d8:	29 ca                	sub    %ecx,%edx
   115da:	88 10                	mov    %dl,(%eax)
   115dc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   115e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115e3:	3b 45 18             	cmp    0x18(%ebp),%eax
   115e6:	75 d0                	jne    115b8 <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   115e8:	8b 45 18             	mov    0x18(%ebp),%eax
   115eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
   115ee:	eb 42                	jmp    11632 <filterScanline+0x1bf>
   115f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   115f3:	8b 45 08             	mov    0x8(%ebp),%eax
   115f6:	01 c2                	add    %eax,%edx
   115f8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   115fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   115fe:	01 c8                	add    %ecx,%eax
   11600:	0f b6 08             	movzbl (%eax),%ecx
   11603:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11606:	2b 45 18             	sub    0x18(%ebp),%eax
   11609:	89 c3                	mov    %eax,%ebx
   1160b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1160e:	01 d8                	add    %ebx,%eax
   11610:	0f b6 00             	movzbl (%eax),%eax
   11613:	0f b6 d8             	movzbl %al,%ebx
   11616:	8b 75 f4             	mov    -0xc(%ebp),%esi
   11619:	8b 45 10             	mov    0x10(%ebp),%eax
   1161c:	01 f0                	add    %esi,%eax
   1161e:	0f b6 00             	movzbl (%eax),%eax
   11621:	0f b6 c0             	movzbl %al,%eax
   11624:	01 d8                	add    %ebx,%eax
   11626:	d1 f8                	sar    %eax
   11628:	29 c1                	sub    %eax,%ecx
   1162a:	89 c8                	mov    %ecx,%eax
   1162c:	88 02                	mov    %al,(%edx)
   1162e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11632:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11635:	3b 45 14             	cmp    0x14(%ebp),%eax
   11638:	7c b6                	jl     115f0 <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   1163a:	e9 91 01 00 00       	jmp    117d0 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   1163f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11646:	eb 19                	jmp    11661 <filterScanline+0x1ee>
   11648:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1164b:	8b 45 08             	mov    0x8(%ebp),%eax
   1164e:	01 c2                	add    %eax,%edx
   11650:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11653:	8b 45 0c             	mov    0xc(%ebp),%eax
   11656:	01 c8                	add    %ecx,%eax
   11658:	0f b6 00             	movzbl (%eax),%eax
   1165b:	88 02                	mov    %al,(%edx)
   1165d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11661:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11664:	3b 45 18             	cmp    0x18(%ebp),%eax
   11667:	75 df                	jne    11648 <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   11669:	8b 45 18             	mov    0x18(%ebp),%eax
   1166c:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1166f:	eb 2f                	jmp    116a0 <filterScanline+0x22d>
   11671:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11674:	8b 45 08             	mov    0x8(%ebp),%eax
   11677:	01 c2                	add    %eax,%edx
   11679:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1167c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1167f:	01 c8                	add    %ecx,%eax
   11681:	0f b6 08             	movzbl (%eax),%ecx
   11684:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11687:	2b 45 18             	sub    0x18(%ebp),%eax
   1168a:	89 c3                	mov    %eax,%ebx
   1168c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1168f:	01 d8                	add    %ebx,%eax
   11691:	0f b6 00             	movzbl (%eax),%eax
   11694:	d0 e8                	shr    %al
   11696:	29 c1                	sub    %eax,%ecx
   11698:	89 c8                	mov    %ecx,%eax
   1169a:	88 02                	mov    %al,(%edx)
   1169c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   116a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116a3:	3b 45 14             	cmp    0x14(%ebp),%eax
   116a6:	7c c9                	jl     11671 <filterScanline+0x1fe>
      }
      break;
   116a8:	e9 23 01 00 00       	jmp    117d0 <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   116ad:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   116b1:	0f 84 af 00 00 00    	je     11766 <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   116b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   116be:	eb 28                	jmp    116e8 <filterScanline+0x275>
   116c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116c3:	8b 45 08             	mov    0x8(%ebp),%eax
   116c6:	01 d0                	add    %edx,%eax
   116c8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   116cb:	8b 55 0c             	mov    0xc(%ebp),%edx
   116ce:	01 ca                	add    %ecx,%edx
   116d0:	0f b6 0a             	movzbl (%edx),%ecx
   116d3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   116d6:	8b 55 10             	mov    0x10(%ebp),%edx
   116d9:	01 da                	add    %ebx,%edx
   116db:	0f b6 12             	movzbl (%edx),%edx
   116de:	29 d1                	sub    %edx,%ecx
   116e0:	89 ca                	mov    %ecx,%edx
   116e2:	88 10                	mov    %dl,(%eax)
   116e4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   116e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116eb:	3b 45 18             	cmp    0x18(%ebp),%eax
   116ee:	75 d0                	jne    116c0 <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   116f0:	8b 45 18             	mov    0x18(%ebp),%eax
   116f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
   116f6:	eb 64                	jmp    1175c <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   116f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116fb:	8b 45 08             	mov    0x8(%ebp),%eax
   116fe:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   11701:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11704:	8b 45 0c             	mov    0xc(%ebp),%eax
   11707:	01 d0                	add    %edx,%eax
   11709:	0f b6 00             	movzbl (%eax),%eax
   1170c:	88 45 e7             	mov    %al,-0x19(%ebp)
   1170f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11712:	2b 45 18             	sub    0x18(%ebp),%eax
   11715:	89 c2                	mov    %eax,%edx
   11717:	8b 45 10             	mov    0x10(%ebp),%eax
   1171a:	01 d0                	add    %edx,%eax
   1171c:	0f b6 00             	movzbl (%eax),%eax
   1171f:	0f b6 c8             	movzbl %al,%ecx
   11722:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11725:	8b 45 10             	mov    0x10(%ebp),%eax
   11728:	01 d0                	add    %edx,%eax
   1172a:	0f b6 00             	movzbl (%eax),%eax
   1172d:	0f b6 d0             	movzbl %al,%edx
   11730:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11733:	2b 45 18             	sub    0x18(%ebp),%eax
   11736:	89 c6                	mov    %eax,%esi
   11738:	8b 45 0c             	mov    0xc(%ebp),%eax
   1173b:	01 f0                	add    %esi,%eax
   1173d:	0f b6 00             	movzbl (%eax),%eax
   11740:	0f b6 c0             	movzbl %al,%eax
   11743:	51                   	push   %ecx
   11744:	52                   	push   %edx
   11745:	50                   	push   %eax
   11746:	e8 49 b8 ff ff       	call   cf94 <paethPredictor>
   1174b:	83 c4 0c             	add    $0xc,%esp
   1174e:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   11752:	29 c1                	sub    %eax,%ecx
   11754:	89 c8                	mov    %ecx,%eax
   11756:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   11758:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1175c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1175f:	3b 45 14             	cmp    0x14(%ebp),%eax
   11762:	7c 94                	jl     116f8 <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   11764:	eb 6a                	jmp    117d0 <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11766:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1176d:	eb 19                	jmp    11788 <filterScanline+0x315>
   1176f:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11772:	8b 45 08             	mov    0x8(%ebp),%eax
   11775:	01 c2                	add    %eax,%edx
   11777:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1177a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1177d:	01 c8                	add    %ecx,%eax
   1177f:	0f b6 00             	movzbl (%eax),%eax
   11782:	88 02                	mov    %al,(%edx)
   11784:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11788:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1178b:	3b 45 18             	cmp    0x18(%ebp),%eax
   1178e:	75 df                	jne    1176f <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   11790:	8b 45 18             	mov    0x18(%ebp),%eax
   11793:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11796:	eb 2d                	jmp    117c5 <filterScanline+0x352>
   11798:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1179b:	8b 45 08             	mov    0x8(%ebp),%eax
   1179e:	01 c2                	add    %eax,%edx
   117a0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117a3:	8b 45 0c             	mov    0xc(%ebp),%eax
   117a6:	01 c8                	add    %ecx,%eax
   117a8:	0f b6 08             	movzbl (%eax),%ecx
   117ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117ae:	2b 45 18             	sub    0x18(%ebp),%eax
   117b1:	89 c3                	mov    %eax,%ebx
   117b3:	8b 45 0c             	mov    0xc(%ebp),%eax
   117b6:	01 d8                	add    %ebx,%eax
   117b8:	0f b6 00             	movzbl (%eax),%eax
   117bb:	29 c1                	sub    %eax,%ecx
   117bd:	89 c8                	mov    %ecx,%eax
   117bf:	88 02                	mov    %al,(%edx)
   117c1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117c8:	3b 45 14             	cmp    0x14(%ebp),%eax
   117cb:	7c cb                	jl     11798 <filterScanline+0x325>
      }
      break;
   117cd:	eb 01                	jmp    117d0 <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   117cf:	90                   	nop
  }
}
   117d0:	8d 65 f8             	lea    -0x8(%ebp),%esp
   117d3:	5b                   	pop    %ebx
   117d4:	5e                   	pop    %esi
   117d5:	5d                   	pop    %ebp
   117d6:	c3                   	ret    

000117d7 <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   117d7:	55                   	push   %ebp
   117d8:	89 e5                	mov    %esp,%ebp
   117da:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   117dd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   117e4:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   117eb:	7e 08                	jle    117f5 <ilog2+0x1e>
   117ed:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   117f1:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   117f5:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   117fc:	7e 08                	jle    11806 <ilog2+0x2f>
   117fe:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   11802:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   11806:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   1180a:	7e 08                	jle    11814 <ilog2+0x3d>
   1180c:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   11810:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   11814:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   11818:	7e 08                	jle    11822 <ilog2+0x4b>
   1181a:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   1181e:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   11822:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   11826:	7e 04                	jle    1182c <ilog2+0x55>
   11828:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   1182c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1182f:	c9                   	leave  
   11830:	c3                   	ret    

00011831 <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   11831:	55                   	push   %ebp
   11832:	89 e5                	mov    %esp,%ebp
   11834:	56                   	push   %esi
   11835:	53                   	push   %ebx
   11836:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   11839:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1183d:	75 07                	jne    11846 <ilog2i+0x15>
   1183f:	b8 00 00 00 00       	mov    $0x0,%eax
   11844:	eb 30                	jmp    11876 <ilog2i+0x45>
  l = ilog2(i);
   11846:	ff 75 08             	pushl  0x8(%ebp)
   11849:	e8 89 ff ff ff       	call   117d7 <ilog2>
   1184e:	83 c4 04             	add    $0x4,%esp
   11851:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   11854:	8b 45 08             	mov    0x8(%ebp),%eax
   11857:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   1185b:	89 c3                	mov    %eax,%ebx
   1185d:	8b 55 08             	mov    0x8(%ebp),%edx
   11860:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11863:	be 01 00 00 00       	mov    $0x1,%esi
   11868:	89 c1                	mov    %eax,%ecx
   1186a:	d3 e6                	shl    %cl,%esi
   1186c:	89 f0                	mov    %esi,%eax
   1186e:	29 c2                	sub    %eax,%edx
   11870:	89 d0                	mov    %edx,%eax
   11872:	01 c0                	add    %eax,%eax
   11874:	01 d8                	add    %ebx,%eax
}
   11876:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11879:	5b                   	pop    %ebx
   1187a:	5e                   	pop    %esi
   1187b:	5d                   	pop    %ebp
   1187c:	c3                   	ret    

0001187d <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   1187d:	55                   	push   %ebp
   1187e:	89 e5                	mov    %esp,%ebp
   11880:	53                   	push   %ebx
   11881:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   11887:	ff 75 18             	pushl  0x18(%ebp)
   1188a:	e8 6a 75 ff ff       	call   8df9 <lodepng_get_bpp>
   1188f:	83 c4 04             	add    $0x4,%esp
   11892:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   11895:	ff 75 b8             	pushl  -0x48(%ebp)
   11898:	6a 01                	push   $0x1
   1189a:	ff 75 10             	pushl  0x10(%ebp)
   1189d:	e8 b6 76 ff ff       	call   8f58 <lodepng_get_raw_size_idat>
   118a2:	83 c4 0c             	add    $0xc,%esp
   118a5:	83 e8 01             	sub    $0x1,%eax
   118a8:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   118ab:	8b 45 b8             	mov    -0x48(%ebp),%eax
   118ae:	83 c0 07             	add    $0x7,%eax
   118b1:	c1 e8 03             	shr    $0x3,%eax
   118b4:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   118b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   118be:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   118c5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   118c8:	8b 40 2c             	mov    0x2c(%eax),%eax
   118cb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   118ce:	8b 45 1c             	mov    0x1c(%ebp),%eax
   118d1:	8b 40 28             	mov    0x28(%eax),%eax
   118d4:	85 c0                	test   %eax,%eax
   118d6:	74 1c                	je     118f4 <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   118d8:	8b 45 18             	mov    0x18(%ebp),%eax
   118db:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   118dd:	83 f8 03             	cmp    $0x3,%eax
   118e0:	74 0b                	je     118ed <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   118e2:	8b 45 18             	mov    0x18(%ebp),%eax
   118e5:	8b 40 04             	mov    0x4(%eax),%eax
   118e8:	83 f8 07             	cmp    $0x7,%eax
   118eb:	77 07                	ja     118f4 <filter+0x77>
   118ed:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   118f4:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   118f8:	75 0a                	jne    11904 <filter+0x87>
   118fa:	b8 1f 00 00 00       	mov    $0x1f,%eax
   118ff:	e9 5b 07 00 00       	jmp    1205f <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   11904:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   11908:	77 7b                	ja     11985 <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   1190a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1190d:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   11910:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11917:	eb 5f                	jmp    11978 <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11919:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1191c:	83 c0 01             	add    $0x1,%eax
   1191f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11923:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   11926:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11929:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1192d:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   11930:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11933:	8b 45 08             	mov    0x8(%ebp),%eax
   11936:	01 c2                	add    %eax,%edx
   11938:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   1193c:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   1193e:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11942:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   11945:	8b 55 0c             	mov    0xc(%ebp),%edx
   11948:	01 d1                	add    %edx,%ecx
   1194a:	8b 55 9c             	mov    -0x64(%ebp),%edx
   1194d:	8d 5a 01             	lea    0x1(%edx),%ebx
   11950:	8b 55 08             	mov    0x8(%ebp),%edx
   11953:	01 da                	add    %ebx,%edx
   11955:	50                   	push   %eax
   11956:	ff 75 b0             	pushl  -0x50(%ebp)
   11959:	ff 75 b4             	pushl  -0x4c(%ebp)
   1195c:	ff 75 f4             	pushl  -0xc(%ebp)
   1195f:	51                   	push   %ecx
   11960:	52                   	push   %edx
   11961:	e8 0d fb ff ff       	call   11473 <filterScanline>
   11966:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   11969:	8b 55 98             	mov    -0x68(%ebp),%edx
   1196c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1196f:	01 d0                	add    %edx,%eax
   11971:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   11974:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11978:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1197b:	3b 45 14             	cmp    0x14(%ebp),%eax
   1197e:	75 99                	jne    11919 <filter+0x9c>
   11980:	e9 d7 06 00 00       	jmp    1205c <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   11985:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   11989:	0f 85 e3 01 00 00    	jne    11b72 <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   1198f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   11996:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   1199a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   1199e:	eb 2d                	jmp    119cd <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   119a0:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   119a4:	83 ec 0c             	sub    $0xc,%esp
   119a7:	ff 75 b4             	pushl  -0x4c(%ebp)
   119aa:	e8 2e 19 ff ff       	call   32dd <lodepng_malloc>
   119af:	83 c4 10             	add    $0x10,%esp
   119b2:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   119b6:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   119ba:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   119be:	85 c0                	test   %eax,%eax
   119c0:	75 07                	jne    119c9 <filter+0x14c>
   119c2:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   119c9:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   119cd:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   119d1:	75 cd                	jne    119a0 <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   119d3:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   119d7:	0f 85 6c 01 00 00    	jne    11b49 <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   119dd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   119e4:	e9 54 01 00 00       	jmp    11b3d <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   119e9:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   119ed:	e9 d5 00 00 00       	jmp    11ac7 <filter+0x24a>
          size_t sum = 0;
   119f2:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   119f9:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   119fd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11a00:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11a04:	89 c1                	mov    %eax,%ecx
   11a06:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a09:	01 c1                	add    %eax,%ecx
   11a0b:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a0f:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11a13:	83 ec 08             	sub    $0x8,%esp
   11a16:	52                   	push   %edx
   11a17:	ff 75 b0             	pushl  -0x50(%ebp)
   11a1a:	ff 75 b4             	pushl  -0x4c(%ebp)
   11a1d:	ff 75 f4             	pushl  -0xc(%ebp)
   11a20:	51                   	push   %ecx
   11a21:	50                   	push   %eax
   11a22:	e8 4c fa ff ff       	call   11473 <filterScanline>
   11a27:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   11a2a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11a2e:	75 2d                	jne    11a5d <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   11a30:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11a37:	eb 1a                	jmp    11a53 <filter+0x1d6>
   11a39:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a3d:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11a41:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a44:	01 d0                	add    %edx,%eax
   11a46:	0f b6 00             	movzbl (%eax),%eax
   11a49:	0f b6 c0             	movzbl %al,%eax
   11a4c:	01 45 d8             	add    %eax,-0x28(%ebp)
   11a4f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11a53:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11a56:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11a59:	75 de                	jne    11a39 <filter+0x1bc>
   11a5b:	eb 4b                	jmp    11aa8 <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   11a5d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11a64:	eb 3a                	jmp    11aa0 <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   11a66:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a6a:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11a6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a71:	01 d0                	add    %edx,%eax
   11a73:	0f b6 00             	movzbl (%eax),%eax
   11a76:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   11a79:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11a7d:	84 c0                	test   %al,%al
   11a7f:	78 06                	js     11a87 <filter+0x20a>
   11a81:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11a85:	eb 0d                	jmp    11a94 <filter+0x217>
   11a87:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11a8b:	ba ff 00 00 00       	mov    $0xff,%edx
   11a90:	29 c2                	sub    %eax,%edx
   11a92:	89 d0                	mov    %edx,%eax
   11a94:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11a97:	01 d0                	add    %edx,%eax
   11a99:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   11a9c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11aa0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11aa3:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11aa6:	75 be                	jne    11a66 <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   11aa8:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11aac:	74 08                	je     11ab6 <filter+0x239>
   11aae:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11ab1:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   11ab4:	7d 0d                	jge    11ac3 <filter+0x246>
            bestType = type;
   11ab6:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11aba:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   11abd:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11ac0:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11ac3:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11ac7:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11acb:	0f 85 21 ff ff ff    	jne    119f2 <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   11ad1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ad4:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ad8:	89 c2                	mov    %eax,%edx
   11ada:	8b 45 0c             	mov    0xc(%ebp),%eax
   11add:	01 d0                	add    %edx,%eax
   11adf:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11ae2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ae5:	83 c0 01             	add    $0x1,%eax
   11ae8:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11aec:	89 c2                	mov    %eax,%edx
   11aee:	8b 45 08             	mov    0x8(%ebp),%eax
   11af1:	01 c2                	add    %eax,%edx
   11af3:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11af7:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11af9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11b00:	eb 2f                	jmp    11b31 <filter+0x2b4>
   11b02:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b05:	83 c0 01             	add    $0x1,%eax
   11b08:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b0c:	89 c2                	mov    %eax,%edx
   11b0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b11:	01 d0                	add    %edx,%eax
   11b13:	8d 50 01             	lea    0x1(%eax),%edx
   11b16:	8b 45 08             	mov    0x8(%ebp),%eax
   11b19:	01 c2                	add    %eax,%edx
   11b1b:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11b1f:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   11b23:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b26:	01 c8                	add    %ecx,%eax
   11b28:	0f b6 00             	movzbl (%eax),%eax
   11b2b:	88 02                	mov    %al,(%edx)
   11b2d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11b31:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b34:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11b37:	75 c9                	jne    11b02 <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11b39:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11b3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b40:	3b 45 14             	cmp    0x14(%ebp),%eax
   11b43:	0f 85 a0 fe ff ff    	jne    119e9 <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11b49:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11b4d:	eb 18                	jmp    11b67 <filter+0x2ea>
   11b4f:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b53:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11b57:	83 ec 0c             	sub    $0xc,%esp
   11b5a:	50                   	push   %eax
   11b5b:	e8 9e 17 ff ff       	call   32fe <lodepng_free>
   11b60:	83 c4 10             	add    $0x10,%esp
   11b63:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11b67:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11b6b:	75 e2                	jne    11b4f <filter+0x2d2>
   11b6d:	e9 ea 04 00 00       	jmp    1205c <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   11b72:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   11b76:	0f 85 17 02 00 00    	jne    11d93 <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   11b7c:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   11b83:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11b8a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11b91:	eb 33                	jmp    11bc6 <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11b93:	83 ec 0c             	sub    $0xc,%esp
   11b96:	ff 75 b4             	pushl  -0x4c(%ebp)
   11b99:	e8 3f 17 ff ff       	call   32dd <lodepng_malloc>
   11b9e:	83 c4 10             	add    $0x10,%esp
   11ba1:	89 c2                	mov    %eax,%edx
   11ba3:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11ba6:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11bad:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11bb0:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11bb7:	85 c0                	test   %eax,%eax
   11bb9:	75 07                	jne    11bc2 <filter+0x345>
   11bbb:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11bc2:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11bc6:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11bca:	75 c7                	jne    11b93 <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11bcc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11bd0:	0f 85 8f 01 00 00    	jne    11d65 <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   11bd6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11bdd:	e9 77 01 00 00       	jmp    11d59 <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11be2:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11be9:	e9 f4 00 00 00       	jmp    11ce2 <filter+0x465>
          size_t sum = 0;
   11bee:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11bf5:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11bf8:	0f b6 d0             	movzbl %al,%edx
   11bfb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11bfe:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c02:	89 c1                	mov    %eax,%ecx
   11c04:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c07:	01 c1                	add    %eax,%ecx
   11c09:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c0c:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11c13:	83 ec 08             	sub    $0x8,%esp
   11c16:	52                   	push   %edx
   11c17:	ff 75 b0             	pushl  -0x50(%ebp)
   11c1a:	ff 75 b4             	pushl  -0x4c(%ebp)
   11c1d:	ff 75 f4             	pushl  -0xc(%ebp)
   11c20:	51                   	push   %ecx
   11c21:	50                   	push   %eax
   11c22:	e8 4c f8 ff ff       	call   11473 <filterScanline>
   11c27:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   11c2a:	83 ec 04             	sub    $0x4,%esp
   11c2d:	68 00 04 00 00       	push   $0x400
   11c32:	6a 00                	push   $0x0
   11c34:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11c3a:	50                   	push   %eax
   11c3b:	e8 0e 17 ff ff       	call   334e <lodepng_memset>
   11c40:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   11c43:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11c4a:	eb 2a                	jmp    11c76 <filter+0x3f9>
   11c4c:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c4f:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   11c56:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c59:	01 d0                	add    %edx,%eax
   11c5b:	0f b6 00             	movzbl (%eax),%eax
   11c5e:	0f b6 c0             	movzbl %al,%eax
   11c61:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   11c68:	83 c2 01             	add    $0x1,%edx
   11c6b:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   11c72:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11c76:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c79:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11c7c:	75 ce                	jne    11c4c <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   11c7e:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c81:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11c88:	8d 50 01             	lea    0x1(%eax),%edx
   11c8b:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c8e:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   11c95:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11c9c:	eb 1d                	jmp    11cbb <filter+0x43e>
            sum += ilog2i(count[x]);
   11c9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ca1:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11ca8:	83 ec 0c             	sub    $0xc,%esp
   11cab:	50                   	push   %eax
   11cac:	e8 80 fb ff ff       	call   11831 <ilog2i>
   11cb1:	83 c4 10             	add    $0x10,%esp
   11cb4:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   11cb7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11cbb:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   11cc2:	75 da                	jne    11c9e <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   11cc4:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   11cc8:	74 08                	je     11cd2 <filter+0x455>
   11cca:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11ccd:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   11cd0:	7e 0c                	jle    11cde <filter+0x461>
            bestType = type;
   11cd2:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11cd5:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   11cd8:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11cdb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11cde:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11ce2:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11ce6:	0f 85 02 ff ff ff    	jne    11bee <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   11cec:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11cef:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11cf3:	89 c2                	mov    %eax,%edx
   11cf5:	8b 45 0c             	mov    0xc(%ebp),%eax
   11cf8:	01 d0                	add    %edx,%eax
   11cfa:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11cfd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d00:	83 c0 01             	add    $0x1,%eax
   11d03:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d07:	89 c2                	mov    %eax,%edx
   11d09:	8b 45 08             	mov    0x8(%ebp),%eax
   11d0c:	01 d0                	add    %edx,%eax
   11d0e:	8b 55 cc             	mov    -0x34(%ebp),%edx
   11d11:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11d13:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d1a:	eb 31                	jmp    11d4d <filter+0x4d0>
   11d1c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d1f:	83 c0 01             	add    $0x1,%eax
   11d22:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d26:	89 c2                	mov    %eax,%edx
   11d28:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d2b:	01 d0                	add    %edx,%eax
   11d2d:	8d 50 01             	lea    0x1(%eax),%edx
   11d30:	8b 45 08             	mov    0x8(%ebp),%eax
   11d33:	01 c2                	add    %eax,%edx
   11d35:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11d38:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   11d3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d42:	01 c8                	add    %ecx,%eax
   11d44:	0f b6 00             	movzbl (%eax),%eax
   11d47:	88 02                	mov    %al,(%edx)
   11d49:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d4d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d50:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11d53:	75 c7                	jne    11d1c <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11d55:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11d59:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11d5c:	3b 45 14             	cmp    0x14(%ebp),%eax
   11d5f:	0f 85 7d fe ff ff    	jne    11be2 <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11d65:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11d6c:	eb 1a                	jmp    11d88 <filter+0x50b>
   11d6e:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d71:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11d78:	83 ec 0c             	sub    $0xc,%esp
   11d7b:	50                   	push   %eax
   11d7c:	e8 7d 15 ff ff       	call   32fe <lodepng_free>
   11d81:	83 c4 10             	add    $0x10,%esp
   11d84:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11d88:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11d8c:	75 e0                	jne    11d6e <filter+0x4f1>
   11d8e:	e9 c9 02 00 00       	jmp    1205c <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   11d93:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   11d97:	0f 85 89 00 00 00    	jne    11e26 <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   11d9d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11da4:	eb 73                	jmp    11e19 <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11da6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11da9:	83 c0 01             	add    $0x1,%eax
   11dac:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11db0:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   11db3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11db6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11dba:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   11dbd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11dc0:	8b 50 30             	mov    0x30(%eax),%edx
   11dc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11dc6:	01 d0                	add    %edx,%eax
   11dc8:	0f b6 00             	movzbl (%eax),%eax
   11dcb:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   11dce:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11dd1:	8b 45 08             	mov    0x8(%ebp),%eax
   11dd4:	01 c2                	add    %eax,%edx
   11dd6:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11dda:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11ddc:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11de0:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   11de3:	8b 55 0c             	mov    0xc(%ebp),%edx
   11de6:	01 d1                	add    %edx,%ecx
   11de8:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11deb:	8d 5a 01             	lea    0x1(%edx),%ebx
   11dee:	8b 55 08             	mov    0x8(%ebp),%edx
   11df1:	01 da                	add    %ebx,%edx
   11df3:	83 ec 08             	sub    $0x8,%esp
   11df6:	50                   	push   %eax
   11df7:	ff 75 b0             	pushl  -0x50(%ebp)
   11dfa:	ff 75 b4             	pushl  -0x4c(%ebp)
   11dfd:	ff 75 f4             	pushl  -0xc(%ebp)
   11e00:	51                   	push   %ecx
   11e01:	52                   	push   %edx
   11e02:	e8 6c f6 ff ff       	call   11473 <filterScanline>
   11e07:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   11e0a:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   11e0d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e10:	01 d0                	add    %edx,%eax
   11e12:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   11e15:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11e19:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e1c:	3b 45 14             	cmp    0x14(%ebp),%eax
   11e1f:	75 85                	jne    11da6 <filter+0x529>
   11e21:	e9 36 02 00 00       	jmp    1205c <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   11e26:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   11e2a:	0f 85 25 02 00 00    	jne    12055 <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11e30:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   11e37:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11e3e:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   11e45:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11e48:	83 ec 04             	sub    $0x4,%esp
   11e4b:	6a 24                	push   $0x24
   11e4d:	50                   	push   %eax
   11e4e:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11e54:	50                   	push   %eax
   11e55:	e8 c1 14 ff ff       	call   331b <lodepng_memcpy>
   11e5a:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   11e5d:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   11e64:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   11e67:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   11e6e:	00 00 00 
    zlibsettings.custom_deflate = 0;
   11e71:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   11e78:	00 00 00 
    for(type = 0; type != 5; ++type) {
   11e7b:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11e82:	eb 33                	jmp    11eb7 <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11e84:	83 ec 0c             	sub    $0xc,%esp
   11e87:	ff 75 b4             	pushl  -0x4c(%ebp)
   11e8a:	e8 4e 14 ff ff       	call   32dd <lodepng_malloc>
   11e8f:	83 c4 10             	add    $0x10,%esp
   11e92:	89 c2                	mov    %eax,%edx
   11e94:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11e97:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11e9e:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11ea1:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11ea8:	85 c0                	test   %eax,%eax
   11eaa:	75 07                	jne    11eb3 <filter+0x636>
   11eac:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   11eb3:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   11eb7:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   11ebb:	75 c7                	jne    11e84 <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   11ebd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11ec1:	0f 85 63 01 00 00    	jne    1202a <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   11ec7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11ece:	e9 4b 01 00 00       	jmp    1201e <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   11ed3:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11eda:	e9 c8 00 00 00       	jmp    11fa7 <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   11edf:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ee2:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11ee5:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11ee8:	0f b6 d0             	movzbl %al,%edx
   11eeb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11eee:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ef2:	89 c1                	mov    %eax,%ecx
   11ef4:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ef7:	01 c1                	add    %eax,%ecx
   11ef9:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11efc:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11f03:	83 ec 08             	sub    $0x8,%esp
   11f06:	52                   	push   %edx
   11f07:	ff 75 b0             	pushl  -0x50(%ebp)
   11f0a:	ff 75 b4             	pushl  -0x4c(%ebp)
   11f0d:	ff 75 f4             	pushl  -0xc(%ebp)
   11f10:	51                   	push   %ecx
   11f11:	50                   	push   %eax
   11f12:	e8 5c f5 ff ff       	call   11473 <filterScanline>
   11f17:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   11f1a:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f1d:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   11f24:	00 00 00 00 
          dummy = 0;
   11f28:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   11f2f:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   11f32:	8b 55 ac             	mov    -0x54(%ebp),%edx
   11f35:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f38:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11f3f:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   11f45:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   11f48:	c1 e3 02             	shl    $0x2,%ebx
   11f4b:	01 cb                	add    %ecx,%ebx
   11f4d:	83 ec 0c             	sub    $0xc,%esp
   11f50:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   11f56:	51                   	push   %ecx
   11f57:	52                   	push   %edx
   11f58:	50                   	push   %eax
   11f59:	53                   	push   %ebx
   11f5a:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   11f60:	50                   	push   %eax
   11f61:	e8 87 60 ff ff       	call   7fed <zlib_compress>
   11f66:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   11f69:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   11f6f:	83 ec 0c             	sub    $0xc,%esp
   11f72:	50                   	push   %eax
   11f73:	e8 86 13 ff ff       	call   32fe <lodepng_free>
   11f78:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   11f7b:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   11f7f:	74 0f                	je     11f90 <filter+0x713>
   11f81:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f84:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   11f8b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   11f8e:	7d 13                	jge    11fa3 <filter+0x726>
            bestType = type;
   11f90:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f93:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   11f96:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f99:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   11fa0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   11fa3:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   11fa7:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   11fab:	0f 85 2e ff ff ff    	jne    11edf <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   11fb1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11fb4:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11fb8:	89 c2                	mov    %eax,%edx
   11fba:	8b 45 0c             	mov    0xc(%ebp),%eax
   11fbd:	01 d0                	add    %edx,%eax
   11fbf:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11fc2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11fc5:	83 c0 01             	add    $0x1,%eax
   11fc8:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11fcc:	89 c2                	mov    %eax,%edx
   11fce:	8b 45 08             	mov    0x8(%ebp),%eax
   11fd1:	01 d0                	add    %edx,%eax
   11fd3:	8b 55 bc             	mov    -0x44(%ebp),%edx
   11fd6:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11fd8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11fdf:	eb 31                	jmp    12012 <filter+0x795>
   11fe1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11fe4:	83 c0 01             	add    $0x1,%eax
   11fe7:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11feb:	89 c2                	mov    %eax,%edx
   11fed:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ff0:	01 d0                	add    %edx,%eax
   11ff2:	8d 50 01             	lea    0x1(%eax),%edx
   11ff5:	8b 45 08             	mov    0x8(%ebp),%eax
   11ff8:	01 c2                	add    %eax,%edx
   11ffa:	8b 45 bc             	mov    -0x44(%ebp),%eax
   11ffd:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   12004:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12007:	01 c8                	add    %ecx,%eax
   12009:	0f b6 00             	movzbl (%eax),%eax
   1200c:	88 02                	mov    %al,(%edx)
   1200e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12012:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12015:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12018:	75 c7                	jne    11fe1 <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   1201a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1201e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12021:	3b 45 14             	cmp    0x14(%ebp),%eax
   12024:	0f 85 a9 fe ff ff    	jne    11ed3 <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   1202a:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12031:	eb 1a                	jmp    1204d <filter+0x7d0>
   12033:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12036:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   1203d:	83 ec 0c             	sub    $0xc,%esp
   12040:	50                   	push   %eax
   12041:	e8 b8 12 ff ff       	call   32fe <lodepng_free>
   12046:	83 c4 10             	add    $0x10,%esp
   12049:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   1204d:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   12051:	75 e0                	jne    12033 <filter+0x7b6>
   12053:	eb 07                	jmp    1205c <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   12055:	b8 58 00 00 00       	mov    $0x58,%eax
   1205a:	eb 03                	jmp    1205f <filter+0x7e2>

  return error;
   1205c:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   1205f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12062:	c9                   	leave  
   12063:	c3                   	ret    

00012064 <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   12064:	55                   	push   %ebp
   12065:	89 e5                	mov    %esp,%ebp
   12067:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   1206a:	8b 45 10             	mov    0x10(%ebp),%eax
   1206d:	2b 45 14             	sub    0x14(%ebp),%eax
   12070:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   12073:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1207a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   12081:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12088:	eb 65                	jmp    120ef <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   1208a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12091:	eb 2a                	jmp    120bd <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   12093:	ff 75 0c             	pushl  0xc(%ebp)
   12096:	8d 45 e8             	lea    -0x18(%ebp),%eax
   12099:	50                   	push   %eax
   1209a:	e8 9d 60 ff ff       	call   813c <readBitFromReversedStream>
   1209f:	83 c4 08             	add    $0x8,%esp
   120a2:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   120a5:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   120a9:	50                   	push   %eax
   120aa:	ff 75 08             	pushl  0x8(%ebp)
   120ad:	8d 45 ec             	lea    -0x14(%ebp),%eax
   120b0:	50                   	push   %eax
   120b1:	e8 08 61 ff ff       	call   81be <setBitOfReversedStream>
   120b6:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   120b9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   120bd:	8b 45 f8             	mov    -0x8(%ebp),%eax
   120c0:	3b 45 14             	cmp    0x14(%ebp),%eax
   120c3:	7c ce                	jl     12093 <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   120c5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   120cc:	eb 15                	jmp    120e3 <addPaddingBits+0x7f>
   120ce:	6a 00                	push   $0x0
   120d0:	ff 75 08             	pushl  0x8(%ebp)
   120d3:	8d 45 ec             	lea    -0x14(%ebp),%eax
   120d6:	50                   	push   %eax
   120d7:	e8 e2 60 ff ff       	call   81be <setBitOfReversedStream>
   120dc:	83 c4 0c             	add    $0xc,%esp
   120df:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   120e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   120e6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   120e9:	75 e3                	jne    120ce <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   120eb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   120ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
   120f2:	3b 45 18             	cmp    0x18(%ebp),%eax
   120f5:	75 93                	jne    1208a <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   120f7:	90                   	nop
   120f8:	c9                   	leave  
   120f9:	c3                   	ret    

000120fa <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   120fa:	55                   	push   %ebp
   120fb:	89 e5                	mov    %esp,%ebp
   120fd:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   12103:	ff 75 18             	pushl  0x18(%ebp)
   12106:	ff 75 14             	pushl  0x14(%ebp)
   12109:	ff 75 10             	pushl  0x10(%ebp)
   1210c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   12112:	50                   	push   %eax
   12113:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   12119:	50                   	push   %eax
   1211a:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   12120:	50                   	push   %eax
   12121:	8d 45 94             	lea    -0x6c(%ebp),%eax
   12124:	50                   	push   %eax
   12125:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12128:	50                   	push   %eax
   12129:	e8 fc ae ff ff       	call   d02a <Adam7_getpassvalues>
   1212e:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   12131:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   12135:	0f 86 0a 01 00 00    	jbe    12245 <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   1213b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12142:	e9 ef 00 00 00       	jmp    12236 <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   12147:	8b 45 18             	mov    0x18(%ebp),%eax
   1214a:	c1 e8 03             	shr    $0x3,%eax
   1214d:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   12150:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12157:	e9 c6 00 00 00       	jmp    12222 <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   1215c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12163:	e9 a6 00 00 00       	jmp    1220e <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   12168:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1216b:	8b 14 85 98 9f 01 00 	mov    0x19f98(,%eax,4),%edx
   12172:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12175:	8b 04 85 d0 9f 01 00 	mov    0x19fd0(,%eax,4),%eax
   1217c:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   12180:	01 d0                	add    %edx,%eax
   12182:	0f af 45 10          	imul   0x10(%ebp),%eax
   12186:	89 c2                	mov    %eax,%edx
   12188:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1218b:	8b 04 85 b4 9f 01 00 	mov    0x19fb4(,%eax,4),%eax
   12192:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   12196:	01 c2                	add    %eax,%edx
   12198:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1219b:	8b 04 85 7c 9f 01 00 	mov    0x19f7c(,%eax,4),%eax
   121a2:	01 c2                	add    %eax,%edx
   121a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   121a7:	0f af c2             	imul   %edx,%eax
   121aa:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   121ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121b0:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   121b7:	89 c1                	mov    %eax,%ecx
   121b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121bc:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   121c0:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   121c4:	89 c2                	mov    %eax,%edx
   121c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   121c9:	01 c2                	add    %eax,%edx
   121cb:	8b 45 e0             	mov    -0x20(%ebp),%eax
   121ce:	0f af c2             	imul   %edx,%eax
   121d1:	01 c8                	add    %ecx,%eax
   121d3:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   121d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   121dd:	eb 23                	jmp    12202 <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   121df:	8b 55 d8             	mov    -0x28(%ebp),%edx
   121e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   121e5:	01 c2                	add    %eax,%edx
   121e7:	8b 45 08             	mov    0x8(%ebp),%eax
   121ea:	01 c2                	add    %eax,%edx
   121ec:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   121ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
   121f2:	01 c1                	add    %eax,%ecx
   121f4:	8b 45 0c             	mov    0xc(%ebp),%eax
   121f7:	01 c8                	add    %ecx,%eax
   121f9:	0f b6 00             	movzbl (%eax),%eax
   121fc:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   121fe:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12202:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12205:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12208:	72 d5                	jb     121df <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   1220a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1220e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12211:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12215:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   12218:	0f 87 4a ff ff ff    	ja     12168 <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   1221e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12222:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12225:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12229:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1222c:	0f 87 2a ff ff ff    	ja     1215c <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   12232:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12236:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   1223a:	0f 85 07 ff ff ff    	jne    12147 <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12240:	e9 22 01 00 00       	jmp    12367 <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   12245:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1224c:	e9 0c 01 00 00       	jmp    1235d <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   12251:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12254:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12258:	0f af 45 18          	imul   0x18(%ebp),%eax
   1225c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   1225f:	8b 45 18             	mov    0x18(%ebp),%eax
   12262:	0f af 45 10          	imul   0x10(%ebp),%eax
   12266:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   12269:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   12270:	e9 d4 00 00 00       	jmp    12349 <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   12275:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1227c:	e9 b4 00 00 00       	jmp    12335 <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   12281:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12284:	8b 14 85 98 9f 01 00 	mov    0x19f98(,%eax,4),%edx
   1228b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1228e:	8b 04 85 d0 9f 01 00 	mov    0x19fd0(,%eax,4),%eax
   12295:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   12299:	01 d0                	add    %edx,%eax
   1229b:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   1229f:	89 c2                	mov    %eax,%edx
   122a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122a4:	8b 0c 85 7c 9f 01 00 	mov    0x19f7c(,%eax,4),%ecx
   122ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122ae:	8b 04 85 b4 9f 01 00 	mov    0x19fb4(,%eax,4),%eax
   122b5:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   122b9:	01 c8                	add    %ecx,%eax
   122bb:	0f af 45 18          	imul   0x18(%ebp),%eax
   122bf:	01 d0                	add    %edx,%eax
   122c1:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   122c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122ca:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   122d1:	c1 e0 03             	shl    $0x3,%eax
   122d4:	89 c1                	mov    %eax,%ecx
   122d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   122d9:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   122dd:	89 c2                	mov    %eax,%edx
   122df:	8b 45 ec             	mov    -0x14(%ebp),%eax
   122e2:	0f af 45 18          	imul   0x18(%ebp),%eax
   122e6:	01 d0                	add    %edx,%eax
   122e8:	01 c8                	add    %ecx,%eax
   122ea:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   122f0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   122f7:	eb 30                	jmp    12329 <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   122f9:	ff 75 0c             	pushl  0xc(%ebp)
   122fc:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   12302:	50                   	push   %eax
   12303:	e8 34 5e ff ff       	call   813c <readBitFromReversedStream>
   12308:	83 c4 08             	add    $0x8,%esp
   1230b:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   1230e:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   12312:	50                   	push   %eax
   12313:	ff 75 08             	pushl  0x8(%ebp)
   12316:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   1231c:	50                   	push   %eax
   1231d:	e8 9c 5e ff ff       	call   81be <setBitOfReversedStream>
   12322:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   12325:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   12329:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1232c:	3b 45 18             	cmp    0x18(%ebp),%eax
   1232f:	72 c8                	jb     122f9 <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12331:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12335:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12338:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1233c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1233f:	0f 87 3c ff ff ff    	ja     12281 <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   12345:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   12349:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1234c:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12350:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   12353:	0f 87 1c ff ff ff    	ja     12275 <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   12359:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1235d:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12361:	0f 85 ea fe ff ff    	jne    12251 <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12367:	90                   	nop
   12368:	c9                   	leave  
   12369:	c3                   	ret    

0001236a <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   1236a:	55                   	push   %ebp
   1236b:	89 e5                	mov    %esp,%ebp
   1236d:	57                   	push   %edi
   1236e:	56                   	push   %esi
   1236f:	53                   	push   %ebx
   12370:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   12376:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12379:	83 c0 0c             	add    $0xc,%eax
   1237c:	50                   	push   %eax
   1237d:	e8 77 6a ff ff       	call   8df9 <lodepng_get_bpp>
   12382:	83 c4 04             	add    $0x4,%esp
   12385:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   12388:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   1238f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12392:	8b 40 08             	mov    0x8(%eax),%eax
   12395:	85 c0                	test   %eax,%eax
   12397:	0f 85 49 01 00 00    	jne    124e6 <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   1239d:	8b 45 14             	mov    0x14(%ebp),%eax
   123a0:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   123a4:	83 c0 07             	add    $0x7,%eax
   123a7:	c1 e8 03             	shr    $0x3,%eax
   123aa:	83 c0 01             	add    $0x1,%eax
   123ad:	0f af 45 18          	imul   0x18(%ebp),%eax
   123b1:	89 c2                	mov    %eax,%edx
   123b3:	8b 45 0c             	mov    0xc(%ebp),%eax
   123b6:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   123b8:	8b 45 0c             	mov    0xc(%ebp),%eax
   123bb:	8b 00                	mov    (%eax),%eax
   123bd:	83 ec 0c             	sub    $0xc,%esp
   123c0:	50                   	push   %eax
   123c1:	e8 17 0f ff ff       	call   32dd <lodepng_malloc>
   123c6:	83 c4 10             	add    $0x10,%esp
   123c9:	89 c2                	mov    %eax,%edx
   123cb:	8b 45 08             	mov    0x8(%ebp),%eax
   123ce:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   123d0:	8b 45 08             	mov    0x8(%ebp),%eax
   123d3:	8b 00                	mov    (%eax),%eax
   123d5:	85 c0                	test   %eax,%eax
   123d7:	75 10                	jne    123e9 <preProcessScanlines+0x7f>
   123d9:	8b 45 0c             	mov    0xc(%ebp),%eax
   123dc:	8b 00                	mov    (%eax),%eax
   123de:	85 c0                	test   %eax,%eax
   123e0:	74 07                	je     123e9 <preProcessScanlines+0x7f>
   123e2:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   123e9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   123ed:	0f 85 fb 02 00 00    	jne    126ee <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   123f3:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   123f7:	0f 87 bd 00 00 00    	ja     124ba <preProcessScanlines+0x150>
   123fd:	8b 45 14             	mov    0x14(%ebp),%eax
   12400:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12404:	89 c2                	mov    %eax,%edx
   12406:	8b 45 14             	mov    0x14(%ebp),%eax
   12409:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1240d:	83 c0 07             	add    $0x7,%eax
   12410:	c1 e8 03             	shr    $0x3,%eax
   12413:	c1 e0 03             	shl    $0x3,%eax
   12416:	39 c2                	cmp    %eax,%edx
   12418:	0f 84 9c 00 00 00    	je     124ba <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   1241e:	8b 45 14             	mov    0x14(%ebp),%eax
   12421:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12425:	83 c0 07             	add    $0x7,%eax
   12428:	c1 e8 03             	shr    $0x3,%eax
   1242b:	0f af 45 18          	imul   0x18(%ebp),%eax
   1242f:	83 ec 0c             	sub    $0xc,%esp
   12432:	50                   	push   %eax
   12433:	e8 a5 0e ff ff       	call   32dd <lodepng_malloc>
   12438:	83 c4 10             	add    $0x10,%esp
   1243b:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   1243e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12442:	75 07                	jne    1244b <preProcessScanlines+0xe1>
   12444:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   1244b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1244f:	75 56                	jne    124a7 <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   12451:	8b 45 14             	mov    0x14(%ebp),%eax
   12454:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12458:	89 c2                	mov    %eax,%edx
   1245a:	8b 45 14             	mov    0x14(%ebp),%eax
   1245d:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12461:	83 c0 07             	add    $0x7,%eax
   12464:	c1 e8 03             	shr    $0x3,%eax
   12467:	c1 e0 03             	shl    $0x3,%eax
   1246a:	83 ec 0c             	sub    $0xc,%esp
   1246d:	ff 75 18             	pushl  0x18(%ebp)
   12470:	52                   	push   %edx
   12471:	50                   	push   %eax
   12472:	ff 75 10             	pushl  0x10(%ebp)
   12475:	ff 75 d8             	pushl  -0x28(%ebp)
   12478:	e8 e7 fb ff ff       	call   12064 <addPaddingBits>
   1247d:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   12480:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12483:	8d 50 0c             	lea    0xc(%eax),%edx
   12486:	8b 45 08             	mov    0x8(%ebp),%eax
   12489:	8b 00                	mov    (%eax),%eax
   1248b:	83 ec 08             	sub    $0x8,%esp
   1248e:	ff 75 20             	pushl  0x20(%ebp)
   12491:	52                   	push   %edx
   12492:	ff 75 18             	pushl  0x18(%ebp)
   12495:	ff 75 14             	pushl  0x14(%ebp)
   12498:	ff 75 d8             	pushl  -0x28(%ebp)
   1249b:	50                   	push   %eax
   1249c:	e8 dc f3 ff ff       	call   1187d <filter>
   124a1:	83 c4 20             	add    $0x20,%esp
   124a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   124a7:	83 ec 0c             	sub    $0xc,%esp
   124aa:	ff 75 d8             	pushl  -0x28(%ebp)
   124ad:	e8 4c 0e ff ff       	call   32fe <lodepng_free>
   124b2:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   124b5:	e9 34 02 00 00       	jmp    126ee <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   124ba:	8b 45 1c             	mov    0x1c(%ebp),%eax
   124bd:	8d 50 0c             	lea    0xc(%eax),%edx
   124c0:	8b 45 08             	mov    0x8(%ebp),%eax
   124c3:	8b 00                	mov    (%eax),%eax
   124c5:	83 ec 08             	sub    $0x8,%esp
   124c8:	ff 75 20             	pushl  0x20(%ebp)
   124cb:	52                   	push   %edx
   124cc:	ff 75 18             	pushl  0x18(%ebp)
   124cf:	ff 75 14             	pushl  0x14(%ebp)
   124d2:	ff 75 10             	pushl  0x10(%ebp)
   124d5:	50                   	push   %eax
   124d6:	e8 a2 f3 ff ff       	call   1187d <filter>
   124db:	83 c4 20             	add    $0x20,%esp
   124de:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   124e1:	e9 08 02 00 00       	jmp    126ee <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   124e6:	ff 75 dc             	pushl  -0x24(%ebp)
   124e9:	ff 75 18             	pushl  0x18(%ebp)
   124ec:	ff 75 14             	pushl  0x14(%ebp)
   124ef:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   124f5:	50                   	push   %eax
   124f6:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   124fc:	50                   	push   %eax
   124fd:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   12503:	50                   	push   %eax
   12504:	8d 45 98             	lea    -0x68(%ebp),%eax
   12507:	50                   	push   %eax
   12508:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   1250b:	50                   	push   %eax
   1250c:	e8 19 ab ff ff       	call   d02a <Adam7_getpassvalues>
   12511:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   12514:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   1251a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1251d:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   1251f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12522:	8b 00                	mov    (%eax),%eax
   12524:	83 ec 0c             	sub    $0xc,%esp
   12527:	50                   	push   %eax
   12528:	e8 b0 0d ff ff       	call   32dd <lodepng_malloc>
   1252d:	83 c4 10             	add    $0x10,%esp
   12530:	89 c2                	mov    %eax,%edx
   12532:	8b 45 08             	mov    0x8(%ebp),%eax
   12535:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   12537:	8b 45 08             	mov    0x8(%ebp),%eax
   1253a:	8b 00                	mov    (%eax),%eax
   1253c:	85 c0                	test   %eax,%eax
   1253e:	75 07                	jne    12547 <preProcessScanlines+0x1dd>
   12540:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   12547:	8b 45 94             	mov    -0x6c(%ebp),%eax
   1254a:	83 ec 0c             	sub    $0xc,%esp
   1254d:	50                   	push   %eax
   1254e:	e8 8a 0d ff ff       	call   32dd <lodepng_malloc>
   12553:	83 c4 10             	add    $0x10,%esp
   12556:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   12559:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   1255d:	75 0e                	jne    1256d <preProcessScanlines+0x203>
   1255f:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12562:	85 c0                	test   %eax,%eax
   12564:	74 07                	je     1256d <preProcessScanlines+0x203>
   12566:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   1256d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12571:	0f 85 69 01 00 00    	jne    126e0 <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   12577:	83 ec 0c             	sub    $0xc,%esp
   1257a:	ff 75 dc             	pushl  -0x24(%ebp)
   1257d:	ff 75 18             	pushl  0x18(%ebp)
   12580:	ff 75 14             	pushl  0x14(%ebp)
   12583:	ff 75 10             	pushl  0x10(%ebp)
   12586:	ff 75 d4             	pushl  -0x2c(%ebp)
   12589:	e8 6c fb ff ff       	call   120fa <Adam7_interlace>
   1258e:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   12591:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   12598:	e9 36 01 00 00       	jmp    126d3 <preProcessScanlines+0x369>
        if(bpp < 8) {
   1259d:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   125a1:	0f 87 d6 00 00 00    	ja     1267d <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   125a7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   125aa:	83 c0 01             	add    $0x1,%eax
   125ad:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   125b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   125b7:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   125be:	29 c2                	sub    %eax,%edx
   125c0:	89 d0                	mov    %edx,%eax
   125c2:	83 ec 0c             	sub    $0xc,%esp
   125c5:	50                   	push   %eax
   125c6:	e8 12 0d ff ff       	call   32dd <lodepng_malloc>
   125cb:	83 c4 10             	add    $0x10,%esp
   125ce:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   125d1:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   125d5:	75 0c                	jne    125e3 <preProcessScanlines+0x279>
   125d7:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   125de:	e9 fd 00 00 00       	jmp    126e0 <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   125e3:	8b 45 e0             	mov    -0x20(%ebp),%eax
   125e6:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   125ea:	8b 55 e0             	mov    -0x20(%ebp),%edx
   125ed:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   125f1:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   125f5:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   125f7:	8b 55 e0             	mov    -0x20(%ebp),%edx
   125fa:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   125fe:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   12602:	83 c2 07             	add    $0x7,%edx
   12605:	c1 ea 03             	shr    $0x3,%edx
   12608:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   1260b:	89 d1                	mov    %edx,%ecx
   1260d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12610:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   12617:	89 d6                	mov    %edx,%esi
   12619:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   1261c:	01 f2                	add    %esi,%edx
   1261e:	83 ec 0c             	sub    $0xc,%esp
   12621:	50                   	push   %eax
   12622:	53                   	push   %ebx
   12623:	51                   	push   %ecx
   12624:	52                   	push   %edx
   12625:	ff 75 d0             	pushl  -0x30(%ebp)
   12628:	e8 37 fa ff ff       	call   12064 <addPaddingBits>
   1262d:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   12630:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12633:	8d 58 0c             	lea    0xc(%eax),%ebx
   12636:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12639:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   1263d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12640:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   12644:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12647:	8b 31                	mov    (%ecx),%esi
   12649:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   1264c:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12653:	01 f1                	add    %esi,%ecx
   12655:	83 ec 08             	sub    $0x8,%esp
   12658:	ff 75 20             	pushl  0x20(%ebp)
   1265b:	53                   	push   %ebx
   1265c:	52                   	push   %edx
   1265d:	50                   	push   %eax
   1265e:	ff 75 d0             	pushl  -0x30(%ebp)
   12661:	51                   	push   %ecx
   12662:	e8 16 f2 ff ff       	call   1187d <filter>
   12667:	83 c4 20             	add    $0x20,%esp
   1266a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   1266d:	83 ec 0c             	sub    $0xc,%esp
   12670:	ff 75 d0             	pushl  -0x30(%ebp)
   12673:	e8 86 0c ff ff       	call   32fe <lodepng_free>
   12678:	83 c4 10             	add    $0x10,%esp
   1267b:	eb 4c                	jmp    126c9 <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   1267d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12680:	8d 70 0c             	lea    0xc(%eax),%esi
   12683:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12686:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   1268a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1268d:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   12691:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12694:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   1269b:	89 cb                	mov    %ecx,%ebx
   1269d:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   126a0:	01 cb                	add    %ecx,%ebx
   126a2:	8b 4d 08             	mov    0x8(%ebp),%ecx
   126a5:	8b 39                	mov    (%ecx),%edi
   126a7:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   126aa:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   126b1:	01 f9                	add    %edi,%ecx
   126b3:	83 ec 08             	sub    $0x8,%esp
   126b6:	ff 75 20             	pushl  0x20(%ebp)
   126b9:	56                   	push   %esi
   126ba:	52                   	push   %edx
   126bb:	50                   	push   %eax
   126bc:	53                   	push   %ebx
   126bd:	51                   	push   %ecx
   126be:	e8 ba f1 ff ff       	call   1187d <filter>
   126c3:	83 c4 20             	add    $0x20,%esp
   126c6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   126c9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   126cd:	75 10                	jne    126df <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   126cf:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   126d3:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   126d7:	0f 85 c0 fe ff ff    	jne    1259d <preProcessScanlines+0x233>
   126dd:	eb 01                	jmp    126e0 <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   126df:	90                   	nop
      }
    }

    lodepng_free(adam7);
   126e0:	83 ec 0c             	sub    $0xc,%esp
   126e3:	ff 75 d4             	pushl  -0x2c(%ebp)
   126e6:	e8 13 0c ff ff       	call   32fe <lodepng_free>
   126eb:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   126ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   126f1:	8d 65 f4             	lea    -0xc(%ebp),%esp
   126f4:	5b                   	pop    %ebx
   126f5:	5e                   	pop    %esi
   126f6:	5f                   	pop    %edi
   126f7:	5d                   	pop    %ebp
   126f8:	c3                   	ret    

000126f9 <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   126f9:	55                   	push   %ebp
   126fa:	89 e5                	mov    %esp,%ebp
   126fc:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   126ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   12702:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   12705:	eb 47                	jmp    1274e <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   12707:	8b 45 08             	mov    0x8(%ebp),%eax
   1270a:	8d 50 04             	lea    0x4(%eax),%edx
   1270d:	8b 45 08             	mov    0x8(%ebp),%eax
   12710:	ff 75 fc             	pushl  -0x4(%ebp)
   12713:	52                   	push   %edx
   12714:	50                   	push   %eax
   12715:	e8 73 5f ff ff       	call   868d <lodepng_chunk_append>
   1271a:	83 c4 0c             	add    $0xc,%esp
   1271d:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12720:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   12724:	74 05                	je     1272b <addUnknownChunks+0x32>
   12726:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12729:	eb 37                	jmp    12762 <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   1272b:	8b 45 08             	mov    0x8(%ebp),%eax
   1272e:	8b 50 04             	mov    0x4(%eax),%edx
   12731:	8b 45 08             	mov    0x8(%ebp),%eax
   12734:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   12737:	8b 55 10             	mov    0x10(%ebp),%edx
   1273a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1273d:	01 d0                	add    %edx,%eax
   1273f:	50                   	push   %eax
   12740:	ff 75 fc             	pushl  -0x4(%ebp)
   12743:	e8 ff 5c ff ff       	call   8447 <lodepng_chunk_next>
   12748:	83 c4 08             	add    $0x8,%esp
   1274b:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   1274e:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12751:	8b 45 0c             	mov    0xc(%ebp),%eax
   12754:	29 c2                	sub    %eax,%edx
   12756:	89 d0                	mov    %edx,%eax
   12758:	3b 45 10             	cmp    0x10(%ebp),%eax
   1275b:	7c aa                	jl     12707 <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   1275d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12762:	c9                   	leave  
   12763:	c3                   	ret    

00012764 <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   12764:	55                   	push   %ebp
   12765:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   12767:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   1276b:	77 07                	ja     12774 <isGrayICCProfile+0x10>
   1276d:	b8 00 00 00 00       	mov    $0x0,%eax
   12772:	eb 40                	jmp    127b4 <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   12774:	8b 45 08             	mov    0x8(%ebp),%eax
   12777:	83 c0 10             	add    $0x10,%eax
   1277a:	0f b6 00             	movzbl (%eax),%eax
   1277d:	3c 47                	cmp    $0x47,%al
   1277f:	75 2e                	jne    127af <isGrayICCProfile+0x4b>
   12781:	8b 45 08             	mov    0x8(%ebp),%eax
   12784:	83 c0 11             	add    $0x11,%eax
   12787:	0f b6 00             	movzbl (%eax),%eax
   1278a:	3c 52                	cmp    $0x52,%al
   1278c:	75 21                	jne    127af <isGrayICCProfile+0x4b>
   1278e:	8b 45 08             	mov    0x8(%ebp),%eax
   12791:	83 c0 12             	add    $0x12,%eax
   12794:	0f b6 00             	movzbl (%eax),%eax
   12797:	3c 41                	cmp    $0x41,%al
   12799:	75 14                	jne    127af <isGrayICCProfile+0x4b>
   1279b:	8b 45 08             	mov    0x8(%ebp),%eax
   1279e:	83 c0 13             	add    $0x13,%eax
   127a1:	0f b6 00             	movzbl (%eax),%eax
   127a4:	3c 59                	cmp    $0x59,%al
   127a6:	75 07                	jne    127af <isGrayICCProfile+0x4b>
   127a8:	b8 01 00 00 00       	mov    $0x1,%eax
   127ad:	eb 05                	jmp    127b4 <isGrayICCProfile+0x50>
   127af:	b8 00 00 00 00       	mov    $0x0,%eax
}
   127b4:	5d                   	pop    %ebp
   127b5:	c3                   	ret    

000127b6 <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   127b6:	55                   	push   %ebp
   127b7:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   127b9:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   127bd:	77 07                	ja     127c6 <isRGBICCProfile+0x10>
   127bf:	b8 00 00 00 00       	mov    $0x0,%eax
   127c4:	eb 40                	jmp    12806 <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   127c6:	8b 45 08             	mov    0x8(%ebp),%eax
   127c9:	83 c0 10             	add    $0x10,%eax
   127cc:	0f b6 00             	movzbl (%eax),%eax
   127cf:	3c 52                	cmp    $0x52,%al
   127d1:	75 2e                	jne    12801 <isRGBICCProfile+0x4b>
   127d3:	8b 45 08             	mov    0x8(%ebp),%eax
   127d6:	83 c0 11             	add    $0x11,%eax
   127d9:	0f b6 00             	movzbl (%eax),%eax
   127dc:	3c 47                	cmp    $0x47,%al
   127de:	75 21                	jne    12801 <isRGBICCProfile+0x4b>
   127e0:	8b 45 08             	mov    0x8(%ebp),%eax
   127e3:	83 c0 12             	add    $0x12,%eax
   127e6:	0f b6 00             	movzbl (%eax),%eax
   127e9:	3c 42                	cmp    $0x42,%al
   127eb:	75 14                	jne    12801 <isRGBICCProfile+0x4b>
   127ed:	8b 45 08             	mov    0x8(%ebp),%eax
   127f0:	83 c0 13             	add    $0x13,%eax
   127f3:	0f b6 00             	movzbl (%eax),%eax
   127f6:	3c 20                	cmp    $0x20,%al
   127f8:	75 07                	jne    12801 <isRGBICCProfile+0x4b>
   127fa:	b8 01 00 00 00       	mov    $0x1,%eax
   127ff:	eb 05                	jmp    12806 <isRGBICCProfile+0x50>
   12801:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12806:	5d                   	pop    %ebp
   12807:	c3                   	ret    

00012808 <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   12808:	55                   	push   %ebp
   12809:	89 e5                	mov    %esp,%ebp
   1280b:	57                   	push   %edi
   1280c:	56                   	push   %esi
   1280d:	53                   	push   %ebx
   1280e:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   12814:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   1281b:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   12822:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12825:	6a 00                	push   $0x0
   12827:	6a 00                	push   $0x0
   12829:	50                   	push   %eax
   1282a:	e8 6f 0d ff ff       	call   359e <ucvector_init>
   1282f:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   12832:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12835:	05 98 00 00 00       	add    $0x98,%eax
   1283a:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   1283d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12843:	50                   	push   %eax
   12844:	e8 3a 71 ff ff       	call   9983 <lodepng_info_init>
   12849:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   1284c:	8b 45 08             	mov    0x8(%ebp),%eax
   1284f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   12855:	8b 45 0c             	mov    0xc(%ebp),%eax
   12858:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   1285e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12861:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   12868:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   1286b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1286e:	8b 40 0c             	mov    0xc(%eax),%eax
   12871:	83 f8 03             	cmp    $0x3,%eax
   12874:	74 0a                	je     12880 <lodepng_encode+0x78>
   12876:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12879:	8b 40 6c             	mov    0x6c(%eax),%eax
   1287c:	85 c0                	test   %eax,%eax
   1287e:	74 29                	je     128a9 <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   12880:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12883:	8b 40 18             	mov    0x18(%eax),%eax
   12886:	85 c0                	test   %eax,%eax
   12888:	74 0d                	je     12897 <lodepng_encode+0x8f>
   1288a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1288d:	8b 40 18             	mov    0x18(%eax),%eax
   12890:	3d 00 01 00 00       	cmp    $0x100,%eax
   12895:	7e 12                	jle    128a9 <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   12897:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1289a:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   128a1:	00 00 00 
    goto cleanup;
   128a4:	e9 78 0c 00 00       	jmp    13521 <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   128a9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128ac:	8b 40 38             	mov    0x38(%eax),%eax
   128af:	83 f8 02             	cmp    $0x2,%eax
   128b2:	76 12                	jbe    128c6 <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   128b4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128b7:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   128be:	00 00 00 
    goto cleanup;
   128c1:	e9 5b 0c 00 00       	jmp    13521 <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   128c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128c9:	8b 40 08             	mov    0x8(%eax),%eax
   128cc:	83 f8 01             	cmp    $0x1,%eax
   128cf:	76 12                	jbe    128e3 <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   128d1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128d4:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   128db:	00 00 00 
    goto cleanup;
   128de:	e9 3e 0c 00 00       	jmp    13521 <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   128e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128e6:	8b 50 10             	mov    0x10(%eax),%edx
   128e9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128ec:	8b 40 0c             	mov    0xc(%eax),%eax
   128ef:	52                   	push   %edx
   128f0:	50                   	push   %eax
   128f1:	e8 a4 5f ff ff       	call   889a <checkColorValidity>
   128f6:	83 c4 08             	add    $0x8,%esp
   128f9:	89 c2                	mov    %eax,%edx
   128fb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128fe:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12904:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12907:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1290d:	85 c0                	test   %eax,%eax
   1290f:	0f 85 c6 0b 00 00    	jne    134db <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   12915:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12918:	8b 50 7c             	mov    0x7c(%eax),%edx
   1291b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1291e:	8b 40 78             	mov    0x78(%eax),%eax
   12921:	52                   	push   %edx
   12922:	50                   	push   %eax
   12923:	e8 72 5f ff ff       	call   889a <checkColorValidity>
   12928:	83 c4 08             	add    $0x8,%esp
   1292b:	89 c2                	mov    %eax,%edx
   1292d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12930:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12936:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12939:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1293f:	85 c0                	test   %eax,%eax
   12941:	0f 85 97 0b 00 00    	jne    134de <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   12947:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1294a:	05 98 00 00 00       	add    $0x98,%eax
   1294f:	83 ec 08             	sub    $0x8,%esp
   12952:	50                   	push   %eax
   12953:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12959:	50                   	push   %eax
   1295a:	e8 58 71 ff ff       	call   9ab7 <lodepng_info_copy>
   1295f:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   12962:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12965:	8b 40 5c             	mov    0x5c(%eax),%eax
   12968:	85 c0                	test   %eax,%eax
   1296a:	0f 84 3c 02 00 00    	je     12bac <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   12970:	83 ec 0c             	sub    $0xc,%esp
   12973:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12979:	50                   	push   %eax
   1297a:	e8 5f 96 ff ff       	call   bfde <lodepng_color_stats_init>
   1297f:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12982:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12985:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   1298b:	85 c0                	test   %eax,%eax
   1298d:	74 2d                	je     129bc <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   1298f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12992:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12998:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1299b:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   129a1:	83 ec 08             	sub    $0x8,%esp
   129a4:	52                   	push   %edx
   129a5:	50                   	push   %eax
   129a6:	e8 b9 fd ff ff       	call   12764 <isGrayICCProfile>
   129ab:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   129ae:	85 c0                	test   %eax,%eax
   129b0:	74 0a                	je     129bc <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   129b2:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   129b9:	00 00 00 
    }
    if(info_png->iccp_defined &&
   129bc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129bf:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   129c5:	85 c0                	test   %eax,%eax
   129c7:	74 2d                	je     129f6 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   129c9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129cc:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   129d2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129d5:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   129db:	83 ec 08             	sub    $0x8,%esp
   129de:	52                   	push   %edx
   129df:	50                   	push   %eax
   129e0:	e8 d1 fd ff ff       	call   127b6 <isRGBICCProfile>
   129e5:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   129e8:	85 c0                	test   %eax,%eax
   129ea:	74 0a                	je     129f6 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   129ec:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   129f3:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   129f6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129f9:	83 c0 78             	add    $0x78,%eax
   129fc:	83 ec 0c             	sub    $0xc,%esp
   129ff:	50                   	push   %eax
   12a00:	ff 75 18             	pushl  0x18(%ebp)
   12a03:	ff 75 14             	pushl  0x14(%ebp)
   12a06:	ff 75 10             	pushl  0x10(%ebp)
   12a09:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12a0f:	50                   	push   %eax
   12a10:	e8 e0 96 ff ff       	call   c0f5 <lodepng_compute_color_stats>
   12a15:	83 c4 20             	add    $0x20,%esp
   12a18:	89 c2                	mov    %eax,%edx
   12a1a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a1d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12a23:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a26:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12a2c:	85 c0                	test   %eax,%eax
   12a2e:	0f 85 ad 0a 00 00    	jne    134e1 <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   12a34:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a37:	8b 40 2c             	mov    0x2c(%eax),%eax
   12a3a:	85 c0                	test   %eax,%eax
   12a3c:	0f 84 be 00 00 00    	je     12b00 <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   12a42:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   12a49:	00 00 00 
   12a4c:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   12a53:	00 00 00 
   12a56:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   12a5d:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   12a60:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   12a66:	83 ec 04             	sub    $0x4,%esp
   12a69:	6a 10                	push   $0x10
   12a6b:	6a 02                	push   $0x2
   12a6d:	50                   	push   %eax
   12a6e:	e8 15 61 ff ff       	call   8b88 <lodepng_color_mode_make>
   12a73:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   12a76:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a79:	8d 58 0c             	lea    0xc(%eax),%ebx
   12a7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a7f:	8b 48 38             	mov    0x38(%eax),%ecx
   12a82:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a85:	8b 50 34             	mov    0x34(%eax),%edx
   12a88:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a8b:	8b 40 30             	mov    0x30(%eax),%eax
   12a8e:	53                   	push   %ebx
   12a8f:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   12a95:	53                   	push   %ebx
   12a96:	51                   	push   %ecx
   12a97:	52                   	push   %edx
   12a98:	50                   	push   %eax
   12a99:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   12a9f:	50                   	push   %eax
   12aa0:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   12aa6:	50                   	push   %eax
   12aa7:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   12aad:	50                   	push   %eax
   12aae:	e8 8a 92 ff ff       	call   bd3d <lodepng_convert_rgb>
   12ab3:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   12ab6:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   12abc:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   12ac2:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   12ac8:	83 ec 0c             	sub    $0xc,%esp
   12acb:	68 ff ff 00 00       	push   $0xffff
   12ad0:	51                   	push   %ecx
   12ad1:	52                   	push   %edx
   12ad2:	50                   	push   %eax
   12ad3:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12ad9:	50                   	push   %eax
   12ada:	e8 26 a1 ff ff       	call   cc05 <lodepng_color_stats_add>
   12adf:	83 c4 20             	add    $0x20,%esp
   12ae2:	89 c2                	mov    %eax,%edx
   12ae4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ae7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12aed:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12af0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12af6:	85 c0                	test   %eax,%eax
   12af8:	74 06                	je     12b00 <lodepng_encode+0x2f8>
   12afa:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   12afb:	e9 e1 09 00 00       	jmp    134e1 <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   12b00:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b03:	8d 50 78             	lea    0x78(%eax),%edx
   12b06:	83 ec 04             	sub    $0x4,%esp
   12b09:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12b0f:	50                   	push   %eax
   12b10:	52                   	push   %edx
   12b11:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12b17:	83 c0 0c             	add    $0xc,%eax
   12b1a:	50                   	push   %eax
   12b1b:	e8 79 a1 ff ff       	call   cc99 <auto_choose_color>
   12b20:	83 c4 10             	add    $0x10,%esp
   12b23:	89 c2                	mov    %eax,%edx
   12b25:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b28:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12b2e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b31:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12b37:	85 c0                	test   %eax,%eax
   12b39:	0f 85 a5 09 00 00    	jne    134e4 <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   12b3f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b42:	8b 40 2c             	mov    0x2c(%eax),%eax
   12b45:	85 c0                	test   %eax,%eax
   12b47:	74 63                	je     12bac <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   12b49:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b4c:	8d 58 0c             	lea    0xc(%eax),%ebx
   12b4f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b52:	8b 48 38             	mov    0x38(%eax),%ecx
   12b55:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b58:	8b 50 34             	mov    0x34(%eax),%edx
   12b5b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b5e:	8b 40 30             	mov    0x30(%eax),%eax
   12b61:	53                   	push   %ebx
   12b62:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   12b68:	83 c3 0c             	add    $0xc,%ebx
   12b6b:	53                   	push   %ebx
   12b6c:	51                   	push   %ecx
   12b6d:	52                   	push   %edx
   12b6e:	50                   	push   %eax
   12b6f:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12b75:	83 c0 38             	add    $0x38,%eax
   12b78:	50                   	push   %eax
   12b79:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12b7f:	83 c0 34             	add    $0x34,%eax
   12b82:	50                   	push   %eax
   12b83:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12b89:	83 c0 30             	add    $0x30,%eax
   12b8c:	50                   	push   %eax
   12b8d:	e8 ab 91 ff ff       	call   bd3d <lodepng_convert_rgb>
   12b92:	83 c4 20             	add    $0x20,%esp
   12b95:	85 c0                	test   %eax,%eax
   12b97:	74 13                	je     12bac <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   12b99:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b9c:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   12ba3:	00 00 00 
        goto cleanup;
   12ba6:	90                   	nop
   12ba7:	e9 75 09 00 00       	jmp    13521 <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   12bac:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12baf:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12bb5:	85 c0                	test   %eax,%eax
   12bb7:	0f 84 b2 00 00 00    	je     12c6f <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12bbd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bc0:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12bc6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bc9:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12bcf:	83 ec 08             	sub    $0x8,%esp
   12bd2:	52                   	push   %edx
   12bd3:	50                   	push   %eax
   12bd4:	e8 8b fb ff ff       	call   12764 <isGrayICCProfile>
   12bd9:	83 c4 10             	add    $0x10,%esp
   12bdc:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12bdf:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12be2:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12be8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12beb:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12bf1:	83 ec 08             	sub    $0x8,%esp
   12bf4:	52                   	push   %edx
   12bf5:	50                   	push   %eax
   12bf6:	e8 bb fb ff ff       	call   127b6 <isRGBICCProfile>
   12bfb:	83 c4 10             	add    $0x10,%esp
   12bfe:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   12c01:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12c07:	85 c0                	test   %eax,%eax
   12c09:	74 0b                	je     12c16 <lodepng_encode+0x40e>
   12c0b:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12c11:	83 f8 04             	cmp    $0x4,%eax
   12c14:	75 07                	jne    12c1d <lodepng_encode+0x415>
   12c16:	b8 01 00 00 00       	mov    $0x1,%eax
   12c1b:	eb 05                	jmp    12c22 <lodepng_encode+0x41a>
   12c1d:	b8 00 00 00 00       	mov    $0x0,%eax
   12c22:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   12c25:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12c29:	75 18                	jne    12c43 <lodepng_encode+0x43b>
   12c2b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12c2f:	75 12                	jne    12c43 <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   12c31:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c34:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   12c3b:	00 00 00 
      goto cleanup;
   12c3e:	e9 de 08 00 00       	jmp    13521 <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   12c43:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12c46:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   12c49:	74 24                	je     12c6f <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   12c4b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c4e:	8b 40 5c             	mov    0x5c(%eax),%eax
   12c51:	85 c0                	test   %eax,%eax
   12c53:	74 07                	je     12c5c <lodepng_encode+0x454>
   12c55:	ba 66 00 00 00       	mov    $0x66,%edx
   12c5a:	eb 05                	jmp    12c61 <lodepng_encode+0x459>
   12c5c:	ba 65 00 00 00       	mov    $0x65,%edx
   12c61:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c64:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   12c6a:	e9 b2 08 00 00       	jmp    13521 <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   12c6f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c72:	83 c0 78             	add    $0x78,%eax
   12c75:	83 ec 08             	sub    $0x8,%esp
   12c78:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   12c7e:	83 c2 0c             	add    $0xc,%edx
   12c81:	52                   	push   %edx
   12c82:	50                   	push   %eax
   12c83:	e8 57 5f ff ff       	call   8bdf <lodepng_color_mode_equal>
   12c88:	83 c4 10             	add    $0x10,%esp
   12c8b:	85 c0                	test   %eax,%eax
   12c8d:	0f 85 f8 00 00 00    	jne    12d8b <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   12c93:	8b 55 14             	mov    0x14(%ebp),%edx
   12c96:	8b 45 18             	mov    0x18(%ebp),%eax
   12c99:	89 d3                	mov    %edx,%ebx
   12c9b:	0f af d8             	imul   %eax,%ebx
   12c9e:	83 ec 0c             	sub    $0xc,%esp
   12ca1:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12ca7:	83 c0 0c             	add    $0xc,%eax
   12caa:	50                   	push   %eax
   12cab:	e8 49 61 ff ff       	call   8df9 <lodepng_get_bpp>
   12cb0:	83 c4 10             	add    $0x10,%esp
   12cb3:	0f af c3             	imul   %ebx,%eax
   12cb6:	83 c0 07             	add    $0x7,%eax
   12cb9:	c1 e8 03             	shr    $0x3,%eax
   12cbc:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   12cbf:	83 ec 0c             	sub    $0xc,%esp
   12cc2:	ff 75 cc             	pushl  -0x34(%ebp)
   12cc5:	e8 13 06 ff ff       	call   32dd <lodepng_malloc>
   12cca:	83 c4 10             	add    $0x10,%esp
   12ccd:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   12cd0:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   12cd4:	75 13                	jne    12ce9 <lodepng_encode+0x4e1>
   12cd6:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   12cda:	74 0d                	je     12ce9 <lodepng_encode+0x4e1>
   12cdc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cdf:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   12ce6:	00 00 00 
    if(!state->error) {
   12ce9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cec:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12cf2:	85 c0                	test   %eax,%eax
   12cf4:	75 33                	jne    12d29 <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   12cf6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cf9:	83 c0 78             	add    $0x78,%eax
   12cfc:	83 ec 08             	sub    $0x8,%esp
   12cff:	ff 75 18             	pushl  0x18(%ebp)
   12d02:	ff 75 14             	pushl  0x14(%ebp)
   12d05:	50                   	push   %eax
   12d06:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d0c:	83 c0 0c             	add    $0xc,%eax
   12d0f:	50                   	push   %eax
   12d10:	ff 75 10             	pushl  0x10(%ebp)
   12d13:	ff 75 c8             	pushl  -0x38(%ebp)
   12d16:	e8 c9 8c ff ff       	call   b9e4 <lodepng_convert>
   12d1b:	83 c4 20             	add    $0x20,%esp
   12d1e:	89 c2                	mov    %eax,%edx
   12d20:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d23:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   12d29:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d2c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12d32:	85 c0                	test   %eax,%eax
   12d34:	75 35                	jne    12d6b <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   12d36:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d39:	83 c0 38             	add    $0x38,%eax
   12d3c:	83 ec 04             	sub    $0x4,%esp
   12d3f:	50                   	push   %eax
   12d40:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d46:	50                   	push   %eax
   12d47:	ff 75 18             	pushl  0x18(%ebp)
   12d4a:	ff 75 14             	pushl  0x14(%ebp)
   12d4d:	ff 75 c8             	pushl  -0x38(%ebp)
   12d50:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12d53:	50                   	push   %eax
   12d54:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12d57:	50                   	push   %eax
   12d58:	e8 0d f6 ff ff       	call   1236a <preProcessScanlines>
   12d5d:	83 c4 20             	add    $0x20,%esp
   12d60:	89 c2                	mov    %eax,%edx
   12d62:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d65:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   12d6b:	83 ec 0c             	sub    $0xc,%esp
   12d6e:	ff 75 c8             	pushl  -0x38(%ebp)
   12d71:	e8 88 05 ff ff       	call   32fe <lodepng_free>
   12d76:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   12d79:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d7c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12d82:	85 c0                	test   %eax,%eax
   12d84:	74 4b                	je     12dd1 <lodepng_encode+0x5c9>
   12d86:	e9 96 07 00 00       	jmp    13521 <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   12d8b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d8e:	83 c0 38             	add    $0x38,%eax
   12d91:	83 ec 04             	sub    $0x4,%esp
   12d94:	50                   	push   %eax
   12d95:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d9b:	50                   	push   %eax
   12d9c:	ff 75 18             	pushl  0x18(%ebp)
   12d9f:	ff 75 14             	pushl  0x14(%ebp)
   12da2:	ff 75 10             	pushl  0x10(%ebp)
   12da5:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12da8:	50                   	push   %eax
   12da9:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12dac:	50                   	push   %eax
   12dad:	e8 b8 f5 ff ff       	call   1236a <preProcessScanlines>
   12db2:	83 c4 20             	add    $0x20,%esp
   12db5:	89 c2                	mov    %eax,%edx
   12db7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dba:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12dc0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dc3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12dc9:	85 c0                	test   %eax,%eax
   12dcb:	0f 85 16 07 00 00    	jne    134e7 <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   12dd1:	83 ec 0c             	sub    $0xc,%esp
   12dd4:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12dd7:	50                   	push   %eax
   12dd8:	e8 21 d9 ff ff       	call   106fe <writeSignature>
   12ddd:	83 c4 10             	add    $0x10,%esp
   12de0:	89 c2                	mov    %eax,%edx
   12de2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12de5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12deb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dee:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12df4:	85 c0                	test   %eax,%eax
   12df6:	0f 85 ee 06 00 00    	jne    134ea <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   12dfc:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   12e02:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   12e08:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12e0e:	83 ec 08             	sub    $0x8,%esp
   12e11:	51                   	push   %ecx
   12e12:	52                   	push   %edx
   12e13:	50                   	push   %eax
   12e14:	ff 75 18             	pushl  0x18(%ebp)
   12e17:	ff 75 14             	pushl  0x14(%ebp)
   12e1a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12e1d:	50                   	push   %eax
   12e1e:	e8 4a d9 ff ff       	call   1076d <addChunk_IHDR>
   12e23:	83 c4 20             	add    $0x20,%esp
   12e26:	89 c2                	mov    %eax,%edx
   12e28:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e2b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e31:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e34:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e3a:	85 c0                	test   %eax,%eax
   12e3c:	0f 85 ab 06 00 00    	jne    134ed <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   12e42:	8b 45 98             	mov    -0x68(%ebp),%eax
   12e45:	85 c0                	test   %eax,%eax
   12e47:	74 33                	je     12e7c <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   12e49:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   12e4c:	8b 45 98             	mov    -0x68(%ebp),%eax
   12e4f:	83 ec 04             	sub    $0x4,%esp
   12e52:	52                   	push   %edx
   12e53:	50                   	push   %eax
   12e54:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12e57:	50                   	push   %eax
   12e58:	e8 9c f8 ff ff       	call   126f9 <addUnknownChunks>
   12e5d:	83 c4 10             	add    $0x10,%esp
   12e60:	89 c2                	mov    %eax,%edx
   12e62:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e65:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12e6b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e6e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e74:	85 c0                	test   %eax,%eax
   12e76:	0f 85 74 06 00 00    	jne    134f0 <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   12e7c:	8b 45 88             	mov    -0x78(%ebp),%eax
   12e7f:	85 c0                	test   %eax,%eax
   12e81:	74 39                	je     12ebc <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   12e83:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e86:	83 c0 38             	add    $0x38,%eax
   12e89:	83 ec 04             	sub    $0x4,%esp
   12e8c:	50                   	push   %eax
   12e8d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e93:	50                   	push   %eax
   12e94:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12e97:	50                   	push   %eax
   12e98:	e8 a4 e4 ff ff       	call   11341 <addChunk_iCCP>
   12e9d:	83 c4 10             	add    $0x10,%esp
   12ea0:	89 c2                	mov    %eax,%edx
   12ea2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ea5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12eab:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12eae:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12eb4:	85 c0                	test   %eax,%eax
   12eb6:	0f 85 37 06 00 00    	jne    134f3 <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   12ebc:	8b 45 80             	mov    -0x80(%ebp),%eax
   12ebf:	85 c0                	test   %eax,%eax
   12ec1:	74 32                	je     12ef5 <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   12ec3:	83 ec 08             	sub    $0x8,%esp
   12ec6:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12ecc:	50                   	push   %eax
   12ecd:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12ed0:	50                   	push   %eax
   12ed1:	e8 41 e4 ff ff       	call   11317 <addChunk_sRGB>
   12ed6:	83 c4 10             	add    $0x10,%esp
   12ed9:	89 c2                	mov    %eax,%edx
   12edb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ede:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12ee4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ee7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12eed:	85 c0                	test   %eax,%eax
   12eef:	0f 85 01 06 00 00    	jne    134f6 <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   12ef5:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   12efb:	85 c0                	test   %eax,%eax
   12efd:	74 32                	je     12f31 <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   12eff:	83 ec 08             	sub    $0x8,%esp
   12f02:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f08:	50                   	push   %eax
   12f09:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f0c:	50                   	push   %eax
   12f0d:	e8 a7 e2 ff ff       	call   111b9 <addChunk_gAMA>
   12f12:	83 c4 10             	add    $0x10,%esp
   12f15:	89 c2                	mov    %eax,%edx
   12f17:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f1a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f20:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f23:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f29:	85 c0                	test   %eax,%eax
   12f2b:	0f 85 c8 05 00 00    	jne    134f9 <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   12f31:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   12f37:	85 c0                	test   %eax,%eax
   12f39:	74 32                	je     12f6d <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   12f3b:	83 ec 08             	sub    $0x8,%esp
   12f3e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f44:	50                   	push   %eax
   12f45:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f48:	50                   	push   %eax
   12f49:	e8 c1 e2 ff ff       	call   1120f <addChunk_cHRM>
   12f4e:	83 c4 10             	add    $0x10,%esp
   12f51:	89 c2                	mov    %eax,%edx
   12f53:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f56:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f5c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f5f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f65:	85 c0                	test   %eax,%eax
   12f67:	0f 85 8f 05 00 00    	jne    134fc <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   12f6d:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12f73:	83 f8 03             	cmp    $0x3,%eax
   12f76:	75 35                	jne    12fad <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   12f78:	83 ec 08             	sub    $0x8,%esp
   12f7b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f81:	83 c0 0c             	add    $0xc,%eax
   12f84:	50                   	push   %eax
   12f85:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f88:	50                   	push   %eax
   12f89:	e8 78 d8 ff ff       	call   10806 <addChunk_PLTE>
   12f8e:	83 c4 10             	add    $0x10,%esp
   12f91:	89 c2                	mov    %eax,%edx
   12f93:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f96:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f9c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f9f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12fa5:	85 c0                	test   %eax,%eax
   12fa7:	0f 85 52 05 00 00    	jne    134ff <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   12fad:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fb0:	8b 40 6c             	mov    0x6c(%eax),%eax
   12fb3:	85 c0                	test   %eax,%eax
   12fb5:	74 4b                	je     13002 <lodepng_encode+0x7fa>
   12fb7:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12fbd:	83 f8 02             	cmp    $0x2,%eax
   12fc0:	74 0b                	je     12fcd <lodepng_encode+0x7c5>
   12fc2:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12fc8:	83 f8 06             	cmp    $0x6,%eax
   12fcb:	75 35                	jne    13002 <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   12fcd:	83 ec 08             	sub    $0x8,%esp
   12fd0:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12fd6:	83 c0 0c             	add    $0xc,%eax
   12fd9:	50                   	push   %eax
   12fda:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12fdd:	50                   	push   %eax
   12fde:	e8 23 d8 ff ff       	call   10806 <addChunk_PLTE>
   12fe3:	83 c4 10             	add    $0x10,%esp
   12fe6:	89 c2                	mov    %eax,%edx
   12fe8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12feb:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12ff1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ff4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12ffa:	85 c0                	test   %eax,%eax
   12ffc:	0f 85 00 05 00 00    	jne    13502 <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   13002:	83 ec 08             	sub    $0x8,%esp
   13005:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1300b:	83 c0 0c             	add    $0xc,%eax
   1300e:	50                   	push   %eax
   1300f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13012:	50                   	push   %eax
   13013:	e8 c4 d8 ff ff       	call   108dc <addChunk_tRNS>
   13018:	83 c4 10             	add    $0x10,%esp
   1301b:	89 c2                	mov    %eax,%edx
   1301d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13020:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13026:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13029:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1302f:	85 c0                	test   %eax,%eax
   13031:	0f 85 ce 04 00 00    	jne    13505 <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   13037:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   1303d:	85 c0                	test   %eax,%eax
   1303f:	74 32                	je     13073 <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   13041:	83 ec 08             	sub    $0x8,%esp
   13044:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1304a:	50                   	push   %eax
   1304b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1304e:	50                   	push   %eax
   1304f:	e8 e4 de ff ff       	call   10f38 <addChunk_bKGD>
   13054:	83 c4 10             	add    $0x10,%esp
   13057:	89 c2                	mov    %eax,%edx
   13059:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1305c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13062:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13065:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1306b:	85 c0                	test   %eax,%eax
   1306d:	0f 85 95 04 00 00    	jne    13508 <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   13073:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   13079:	85 c0                	test   %eax,%eax
   1307b:	74 32                	je     130af <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   1307d:	83 ec 08             	sub    $0x8,%esp
   13080:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13086:	50                   	push   %eax
   13087:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1308a:	50                   	push   %eax
   1308b:	e8 ac e0 ff ff       	call   1113c <addChunk_pHYs>
   13090:	83 c4 10             	add    $0x10,%esp
   13093:	89 c2                	mov    %eax,%edx
   13095:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13098:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1309e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130a1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130a7:	85 c0                	test   %eax,%eax
   130a9:	0f 85 5c 04 00 00    	jne    1350b <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   130af:	8b 45 9c             	mov    -0x64(%ebp),%eax
   130b2:	85 c0                	test   %eax,%eax
   130b4:	74 33                	je     130e9 <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   130b6:	8b 55 a8             	mov    -0x58(%ebp),%edx
   130b9:	8b 45 9c             	mov    -0x64(%ebp),%eax
   130bc:	83 ec 04             	sub    $0x4,%esp
   130bf:	52                   	push   %edx
   130c0:	50                   	push   %eax
   130c1:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130c4:	50                   	push   %eax
   130c5:	e8 2f f6 ff ff       	call   126f9 <addUnknownChunks>
   130ca:	83 c4 10             	add    $0x10,%esp
   130cd:	89 c2                	mov    %eax,%edx
   130cf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130d2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   130d8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130db:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130e1:	85 c0                	test   %eax,%eax
   130e3:	0f 85 25 04 00 00    	jne    1350e <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   130e9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130ec:	8d 48 38             	lea    0x38(%eax),%ecx
   130ef:	8b 55 bc             	mov    -0x44(%ebp),%edx
   130f2:	8b 45 c0             	mov    -0x40(%ebp),%eax
   130f5:	51                   	push   %ecx
   130f6:	52                   	push   %edx
   130f7:	50                   	push   %eax
   130f8:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130fb:	50                   	push   %eax
   130fc:	e8 bd d9 ff ff       	call   10abe <addChunk_IDAT>
   13101:	83 c4 10             	add    $0x10,%esp
   13104:	89 c2                	mov    %eax,%edx
   13106:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13109:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1310f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13112:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13118:	85 c0                	test   %eax,%eax
   1311a:	0f 85 f1 03 00 00    	jne    13511 <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   13120:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   13126:	85 c0                	test   %eax,%eax
   13128:	74 35                	je     1315f <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   1312a:	83 ec 08             	sub    $0x8,%esp
   1312d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13133:	83 c0 60             	add    $0x60,%eax
   13136:	50                   	push   %eax
   13137:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1313a:	50                   	push   %eax
   1313b:	e8 5c df ff ff       	call   1109c <addChunk_tIME>
   13140:	83 c4 10             	add    $0x10,%esp
   13143:	89 c2                	mov    %eax,%edx
   13145:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13148:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1314e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13151:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13157:	85 c0                	test   %eax,%eax
   13159:	0f 85 b5 03 00 00    	jne    13514 <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   1315f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13166:	e9 12 01 00 00       	jmp    1327d <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   1316b:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13171:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13174:	c1 e2 02             	shl    $0x2,%edx
   13177:	01 d0                	add    %edx,%eax
   13179:	8b 00                	mov    (%eax),%eax
   1317b:	83 ec 0c             	sub    $0xc,%esp
   1317e:	50                   	push   %eax
   1317f:	e8 f5 01 ff ff       	call   3379 <lodepng_strlen>
   13184:	83 c4 10             	add    $0x10,%esp
   13187:	83 f8 4f             	cmp    $0x4f,%eax
   1318a:	7e 12                	jle    1319e <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   1318c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1318f:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   13196:	00 00 00 
        goto cleanup;
   13199:	e9 83 03 00 00       	jmp    13521 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   1319e:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   131a4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   131a7:	c1 e2 02             	shl    $0x2,%edx
   131aa:	01 d0                	add    %edx,%eax
   131ac:	8b 00                	mov    (%eax),%eax
   131ae:	83 ec 0c             	sub    $0xc,%esp
   131b1:	50                   	push   %eax
   131b2:	e8 c2 01 ff ff       	call   3379 <lodepng_strlen>
   131b7:	83 c4 10             	add    $0x10,%esp
   131ba:	85 c0                	test   %eax,%eax
   131bc:	7f 12                	jg     131d0 <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   131be:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131c1:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   131c8:	00 00 00 
        goto cleanup;
   131cb:	e9 51 03 00 00       	jmp    13521 <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   131d0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131d3:	8b 40 74             	mov    0x74(%eax),%eax
   131d6:	85 c0                	test   %eax,%eax
   131d8:	74 52                	je     1322c <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   131da:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131dd:	8d 48 38             	lea    0x38(%eax),%ecx
   131e0:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   131e6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   131e9:	c1 e2 02             	shl    $0x2,%edx
   131ec:	01 d0                	add    %edx,%eax
   131ee:	8b 10                	mov    (%eax),%edx
   131f0:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   131f6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   131f9:	c1 e3 02             	shl    $0x2,%ebx
   131fc:	01 d8                	add    %ebx,%eax
   131fe:	8b 00                	mov    (%eax),%eax
   13200:	51                   	push   %ecx
   13201:	52                   	push   %edx
   13202:	50                   	push   %eax
   13203:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13206:	50                   	push   %eax
   13207:	e8 fa d9 ff ff       	call   10c06 <addChunk_zTXt>
   1320c:	83 c4 10             	add    $0x10,%esp
   1320f:	89 c2                	mov    %eax,%edx
   13211:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13214:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   1321a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1321d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13223:	85 c0                	test   %eax,%eax
   13225:	74 52                	je     13279 <lodepng_encode+0xa71>
   13227:	e9 f5 02 00 00       	jmp    13521 <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   1322c:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   13232:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13235:	c1 e2 02             	shl    $0x2,%edx
   13238:	01 d0                	add    %edx,%eax
   1323a:	8b 10                	mov    (%eax),%edx
   1323c:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13242:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   13245:	c1 e1 02             	shl    $0x2,%ecx
   13248:	01 c8                	add    %ecx,%eax
   1324a:	8b 00                	mov    (%eax),%eax
   1324c:	83 ec 04             	sub    $0x4,%esp
   1324f:	52                   	push   %edx
   13250:	50                   	push   %eax
   13251:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13254:	50                   	push   %eax
   13255:	e8 ec d8 ff ff       	call   10b46 <addChunk_tEXt>
   1325a:	83 c4 10             	add    $0x10,%esp
   1325d:	89 c2                	mov    %eax,%edx
   1325f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13262:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13268:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1326b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13271:	85 c0                	test   %eax,%eax
   13273:	0f 85 9e 02 00 00    	jne    13517 <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   13279:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1327d:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   13283:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13286:	0f 85 df fe ff ff    	jne    1316b <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   1328c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1328f:	8b 40 70             	mov    0x70(%eax),%eax
   13292:	85 c0                	test   %eax,%eax
   13294:	0f 84 e3 00 00 00    	je     1337d <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   1329a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   132a1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   132a8:	e9 85 00 00 00       	jmp    13332 <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   132ad:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   132b3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   132b6:	c1 e2 02             	shl    $0x2,%edx
   132b9:	01 d0                	add    %edx,%eax
   132bb:	8b 00                	mov    (%eax),%eax
   132bd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   132c0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   132c3:	0f b6 00             	movzbl (%eax),%eax
   132c6:	3c 4c                	cmp    $0x4c,%al
   132c8:	75 64                	jne    1332e <lodepng_encode+0xb26>
   132ca:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   132cd:	83 c0 01             	add    $0x1,%eax
   132d0:	0f b6 00             	movzbl (%eax),%eax
   132d3:	3c 6f                	cmp    $0x6f,%al
   132d5:	75 57                	jne    1332e <lodepng_encode+0xb26>
   132d7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   132da:	83 c0 02             	add    $0x2,%eax
   132dd:	0f b6 00             	movzbl (%eax),%eax
   132e0:	3c 64                	cmp    $0x64,%al
   132e2:	75 4a                	jne    1332e <lodepng_encode+0xb26>
   132e4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   132e7:	83 c0 03             	add    $0x3,%eax
   132ea:	0f b6 00             	movzbl (%eax),%eax
   132ed:	3c 65                	cmp    $0x65,%al
   132ef:	75 3d                	jne    1332e <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   132f1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   132f4:	83 c0 04             	add    $0x4,%eax
   132f7:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   132fa:	3c 50                	cmp    $0x50,%al
   132fc:	75 30                	jne    1332e <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   132fe:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13301:	83 c0 05             	add    $0x5,%eax
   13304:	0f b6 00             	movzbl (%eax),%eax
   13307:	3c 4e                	cmp    $0x4e,%al
   13309:	75 23                	jne    1332e <lodepng_encode+0xb26>
   1330b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1330e:	83 c0 06             	add    $0x6,%eax
   13311:	0f b6 00             	movzbl (%eax),%eax
   13314:	3c 47                	cmp    $0x47,%al
   13316:	75 16                	jne    1332e <lodepng_encode+0xb26>
   13318:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1331b:	83 c0 07             	add    $0x7,%eax
   1331e:	0f b6 00             	movzbl (%eax),%eax
   13321:	84 c0                	test   %al,%al
   13323:	75 09                	jne    1332e <lodepng_encode+0xb26>
          already_added_id_text = 1;
   13325:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   1332c:	eb 13                	jmp    13341 <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   1332e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13332:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   13338:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1333b:	0f 85 6c ff ff ff    	jne    132ad <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   13341:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   13345:	75 36                	jne    1337d <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   13347:	a1 a0 e0 01 00       	mov    0x1e0a0,%eax
   1334c:	83 ec 04             	sub    $0x4,%esp
   1334f:	50                   	push   %eax
   13350:	68 64 a0 01 00       	push   $0x1a064
   13355:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13358:	50                   	push   %eax
   13359:	e8 e8 d7 ff ff       	call   10b46 <addChunk_tEXt>
   1335e:	83 c4 10             	add    $0x10,%esp
   13361:	89 c2                	mov    %eax,%edx
   13363:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13366:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   1336c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1336f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13375:	85 c0                	test   %eax,%eax
   13377:	0f 85 9d 01 00 00    	jne    1351a <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   1337d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13384:	e9 e6 00 00 00       	jmp    1346f <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   13389:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   1338f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13392:	c1 e2 02             	shl    $0x2,%edx
   13395:	01 d0                	add    %edx,%eax
   13397:	8b 00                	mov    (%eax),%eax
   13399:	83 ec 0c             	sub    $0xc,%esp
   1339c:	50                   	push   %eax
   1339d:	e8 d7 ff fe ff       	call   3379 <lodepng_strlen>
   133a2:	83 c4 10             	add    $0x10,%esp
   133a5:	83 f8 4f             	cmp    $0x4f,%eax
   133a8:	7e 12                	jle    133bc <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   133aa:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133ad:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   133b4:	00 00 00 
        goto cleanup;
   133b7:	e9 65 01 00 00       	jmp    13521 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   133bc:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   133c2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   133c5:	c1 e2 02             	shl    $0x2,%edx
   133c8:	01 d0                	add    %edx,%eax
   133ca:	8b 00                	mov    (%eax),%eax
   133cc:	83 ec 0c             	sub    $0xc,%esp
   133cf:	50                   	push   %eax
   133d0:	e8 a4 ff fe ff       	call   3379 <lodepng_strlen>
   133d5:	83 c4 10             	add    $0x10,%esp
   133d8:	85 c0                	test   %eax,%eax
   133da:	7f 12                	jg     133ee <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   133dc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133df:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   133e6:	00 00 00 
        goto cleanup;
   133e9:	e9 33 01 00 00       	jmp    13521 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   133ee:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133f1:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   133f4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   133fa:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   133fd:	c1 e2 02             	shl    $0x2,%edx
   13400:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13402:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13404:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   1340a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1340d:	c1 e2 02             	shl    $0x2,%edx
   13410:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13412:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13414:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   1341a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1341d:	c1 e2 02             	shl    $0x2,%edx
   13420:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13422:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13424:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   1342a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1342d:	c1 e2 02             	shl    $0x2,%edx
   13430:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13432:	8b 10                	mov    (%eax),%edx
   13434:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13437:	8b 40 74             	mov    0x74(%eax),%eax
   1343a:	83 ec 04             	sub    $0x4,%esp
   1343d:	57                   	push   %edi
   1343e:	56                   	push   %esi
   1343f:	53                   	push   %ebx
   13440:	51                   	push   %ecx
   13441:	52                   	push   %edx
   13442:	50                   	push   %eax
   13443:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13446:	50                   	push   %eax
   13447:	e8 dc d8 ff ff       	call   10d28 <addChunk_iTXt>
   1344c:	83 c4 20             	add    $0x20,%esp
   1344f:	89 c2                	mov    %eax,%edx
   13451:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13454:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   1345a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1345d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13463:	85 c0                	test   %eax,%eax
   13465:	0f 85 b2 00 00 00    	jne    1351d <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   1346b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1346f:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   13475:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13478:	0f 85 0b ff ff ff    	jne    13389 <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   1347e:	8b 45 a0             	mov    -0x60(%ebp),%eax
   13481:	85 c0                	test   %eax,%eax
   13483:	74 2f                	je     134b4 <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   13485:	8b 55 ac             	mov    -0x54(%ebp),%edx
   13488:	8b 45 a0             	mov    -0x60(%ebp),%eax
   1348b:	83 ec 04             	sub    $0x4,%esp
   1348e:	52                   	push   %edx
   1348f:	50                   	push   %eax
   13490:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13493:	50                   	push   %eax
   13494:	e8 60 f2 ff ff       	call   126f9 <addUnknownChunks>
   13499:	83 c4 10             	add    $0x10,%esp
   1349c:	89 c2                	mov    %eax,%edx
   1349e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134a1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   134a7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134aa:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   134b0:	85 c0                	test   %eax,%eax
   134b2:	75 6c                	jne    13520 <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   134b4:	83 ec 0c             	sub    $0xc,%esp
   134b7:	8d 45 b0             	lea    -0x50(%ebp),%eax
   134ba:	50                   	push   %eax
   134bb:	e8 6d d6 ff ff       	call   10b2d <addChunk_IEND>
   134c0:	83 c4 10             	add    $0x10,%esp
   134c3:	89 c2                	mov    %eax,%edx
   134c5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134c8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   134ce:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134d1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   134d7:	85 c0                	test   %eax,%eax
   134d9:	eb 46                	jmp    13521 <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   134db:	90                   	nop
   134dc:	eb 43                	jmp    13521 <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   134de:	90                   	nop
   134df:	eb 40                	jmp    13521 <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   134e1:	90                   	nop
   134e2:	eb 3d                	jmp    13521 <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   134e4:	90                   	nop
   134e5:	eb 3a                	jmp    13521 <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   134e7:	90                   	nop
   134e8:	eb 37                	jmp    13521 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   134ea:	90                   	nop
   134eb:	eb 34                	jmp    13521 <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   134ed:	90                   	nop
   134ee:	eb 31                	jmp    13521 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   134f0:	90                   	nop
   134f1:	eb 2e                	jmp    13521 <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   134f3:	90                   	nop
   134f4:	eb 2b                	jmp    13521 <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   134f6:	90                   	nop
   134f7:	eb 28                	jmp    13521 <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   134f9:	90                   	nop
   134fa:	eb 25                	jmp    13521 <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   134fc:	90                   	nop
   134fd:	eb 22                	jmp    13521 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   134ff:	90                   	nop
   13500:	eb 1f                	jmp    13521 <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13502:	90                   	nop
   13503:	eb 1c                	jmp    13521 <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   13505:	90                   	nop
   13506:	eb 19                	jmp    13521 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   13508:	90                   	nop
   13509:	eb 16                	jmp    13521 <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   1350b:	90                   	nop
   1350c:	eb 13                	jmp    13521 <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   1350e:	90                   	nop
   1350f:	eb 10                	jmp    13521 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   13511:	90                   	nop
   13512:	eb 0d                	jmp    13521 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   13514:	90                   	nop
   13515:	eb 0a                	jmp    13521 <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   13517:	90                   	nop
   13518:	eb 07                	jmp    13521 <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   1351a:	90                   	nop
   1351b:	eb 04                	jmp    13521 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   1351d:	90                   	nop
   1351e:	eb 01                	jmp    13521 <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   13520:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   13521:	83 ec 0c             	sub    $0xc,%esp
   13524:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1352a:	50                   	push   %eax
   1352b:	e8 34 65 ff ff       	call   9a64 <lodepng_info_cleanup>
   13530:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   13533:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13536:	83 ec 0c             	sub    $0xc,%esp
   13539:	50                   	push   %eax
   1353a:	e8 bf fd fe ff       	call   32fe <lodepng_free>
   1353f:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   13542:	8b 55 b0             	mov    -0x50(%ebp),%edx
   13545:	8b 45 08             	mov    0x8(%ebp),%eax
   13548:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   1354a:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   1354d:	8b 45 0c             	mov    0xc(%ebp),%eax
   13550:	89 10                	mov    %edx,(%eax)

  return state->error;
   13552:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13555:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   1355b:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1355e:	5b                   	pop    %ebx
   1355f:	5e                   	pop    %esi
   13560:	5f                   	pop    %edi
   13561:	5d                   	pop    %ebp
   13562:	c3                   	ret    

00013563 <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   13563:	55                   	push   %ebp
   13564:	89 e5                	mov    %esp,%ebp
   13566:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   1356c:	83 ec 0c             	sub    $0xc,%esp
   1356f:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   13575:	50                   	push   %eax
   13576:	e8 38 d0 ff ff       	call   105b3 <lodepng_state_init>
   1357b:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   1357e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13581:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   13587:	8b 45 20             	mov    0x20(%ebp),%eax
   1358a:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   13590:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13593:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   13599:	8b 45 20             	mov    0x20(%ebp),%eax
   1359c:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   135a2:	83 ec 08             	sub    $0x8,%esp
   135a5:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   135ab:	50                   	push   %eax
   135ac:	ff 75 18             	pushl  0x18(%ebp)
   135af:	ff 75 14             	pushl  0x14(%ebp)
   135b2:	ff 75 10             	pushl  0x10(%ebp)
   135b5:	ff 75 0c             	pushl  0xc(%ebp)
   135b8:	ff 75 08             	pushl  0x8(%ebp)
   135bb:	e8 48 f2 ff ff       	call   12808 <lodepng_encode>
   135c0:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   135c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   135c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   135c9:	83 ec 0c             	sub    $0xc,%esp
   135cc:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   135d2:	50                   	push   %eax
   135d3:	e8 35 d0 ff ff       	call   1060d <lodepng_state_cleanup>
   135d8:	83 c4 10             	add    $0x10,%esp
  return error;
   135db:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   135de:	c9                   	leave  
   135df:	c3                   	ret    

000135e0 <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   135e0:	55                   	push   %ebp
   135e1:	89 e5                	mov    %esp,%ebp
   135e3:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   135e6:	83 ec 04             	sub    $0x4,%esp
   135e9:	6a 08                	push   $0x8
   135eb:	6a 06                	push   $0x6
   135ed:	ff 75 18             	pushl  0x18(%ebp)
   135f0:	ff 75 14             	pushl  0x14(%ebp)
   135f3:	ff 75 10             	pushl  0x10(%ebp)
   135f6:	ff 75 0c             	pushl  0xc(%ebp)
   135f9:	ff 75 08             	pushl  0x8(%ebp)
   135fc:	e8 62 ff ff ff       	call   13563 <lodepng_encode_memory>
   13601:	83 c4 20             	add    $0x20,%esp
}
   13604:	c9                   	leave  
   13605:	c3                   	ret    

00013606 <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13606:	55                   	push   %ebp
   13607:	89 e5                	mov    %esp,%ebp
   13609:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   1360c:	83 ec 04             	sub    $0x4,%esp
   1360f:	6a 08                	push   $0x8
   13611:	6a 02                	push   $0x2
   13613:	ff 75 18             	pushl  0x18(%ebp)
   13616:	ff 75 14             	pushl  0x14(%ebp)
   13619:	ff 75 10             	pushl  0x10(%ebp)
   1361c:	ff 75 0c             	pushl  0xc(%ebp)
   1361f:	ff 75 08             	pushl  0x8(%ebp)
   13622:	e8 3c ff ff ff       	call   13563 <lodepng_encode_memory>
   13627:	83 c4 20             	add    $0x20,%esp
}
   1362a:	c9                   	leave  
   1362b:	c3                   	ret    

0001362c <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   1362c:	55                   	push   %ebp
   1362d:	89 e5                	mov    %esp,%ebp
   1362f:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   13632:	83 ec 04             	sub    $0x4,%esp
   13635:	ff 75 1c             	pushl  0x1c(%ebp)
   13638:	ff 75 18             	pushl  0x18(%ebp)
   1363b:	ff 75 14             	pushl  0x14(%ebp)
   1363e:	ff 75 10             	pushl  0x10(%ebp)
   13641:	ff 75 0c             	pushl  0xc(%ebp)
   13644:	8d 45 ec             	lea    -0x14(%ebp),%eax
   13647:	50                   	push   %eax
   13648:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1364b:	50                   	push   %eax
   1364c:	e8 12 ff ff ff       	call   13563 <lodepng_encode_memory>
   13651:	83 c4 20             	add    $0x20,%esp
   13654:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   13657:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1365b:	75 19                	jne    13676 <lodepng_encode_file+0x4a>
   1365d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   13660:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13663:	83 ec 04             	sub    $0x4,%esp
   13666:	ff 75 08             	pushl  0x8(%ebp)
   13669:	52                   	push   %edx
   1366a:	50                   	push   %eax
   1366b:	e8 36 01 ff ff       	call   37a6 <lodepng_save_file>
   13670:	83 c4 10             	add    $0x10,%esp
   13673:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   13676:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13679:	83 ec 0c             	sub    $0xc,%esp
   1367c:	50                   	push   %eax
   1367d:	e8 7c fc fe ff       	call   32fe <lodepng_free>
   13682:	83 c4 10             	add    $0x10,%esp
  return error;
   13685:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13688:	c9                   	leave  
   13689:	c3                   	ret    

0001368a <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   1368a:	55                   	push   %ebp
   1368b:	89 e5                	mov    %esp,%ebp
   1368d:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   13690:	83 ec 08             	sub    $0x8,%esp
   13693:	6a 08                	push   $0x8
   13695:	6a 06                	push   $0x6
   13697:	ff 75 14             	pushl  0x14(%ebp)
   1369a:	ff 75 10             	pushl  0x10(%ebp)
   1369d:	ff 75 0c             	pushl  0xc(%ebp)
   136a0:	ff 75 08             	pushl  0x8(%ebp)
   136a3:	e8 84 ff ff ff       	call   1362c <lodepng_encode_file>
   136a8:	83 c4 20             	add    $0x20,%esp
}
   136ab:	c9                   	leave  
   136ac:	c3                   	ret    

000136ad <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   136ad:	55                   	push   %ebp
   136ae:	89 e5                	mov    %esp,%ebp
   136b0:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   136b3:	83 ec 08             	sub    $0x8,%esp
   136b6:	6a 08                	push   $0x8
   136b8:	6a 02                	push   $0x2
   136ba:	ff 75 14             	pushl  0x14(%ebp)
   136bd:	ff 75 10             	pushl  0x10(%ebp)
   136c0:	ff 75 0c             	pushl  0xc(%ebp)
   136c3:	ff 75 08             	pushl  0x8(%ebp)
   136c6:	e8 61 ff ff ff       	call   1362c <lodepng_encode_file>
   136cb:	83 c4 20             	add    $0x20,%esp
}
   136ce:	c9                   	leave  
   136cf:	c3                   	ret    

000136d0 <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   136d0:	55                   	push   %ebp
   136d1:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   136d3:	8b 45 08             	mov    0x8(%ebp),%eax
   136d6:	50                   	push   %eax
   136d7:	e8 71 49 ff ff       	call   804d <lodepng_compress_settings_init>
   136dc:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   136df:	8b 45 08             	mov    0x8(%ebp),%eax
   136e2:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   136e9:	8b 45 08             	mov    0x8(%ebp),%eax
   136ec:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   136f3:	8b 45 08             	mov    0x8(%ebp),%eax
   136f6:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   136fd:	8b 45 08             	mov    0x8(%ebp),%eax
   13700:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   13707:	8b 45 08             	mov    0x8(%ebp),%eax
   1370a:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   13711:	8b 45 08             	mov    0x8(%ebp),%eax
   13714:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   1371b:	8b 45 08             	mov    0x8(%ebp),%eax
   1371e:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   13725:	90                   	nop
   13726:	c9                   	leave  
   13727:	c3                   	ret    

00013728 <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   13728:	55                   	push   %ebp
   13729:	89 e5                	mov    %esp,%ebp
  switch(code) {
   1372b:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   1372f:	0f 87 c1 03 00 00    	ja     13af6 <lodepng_error_text+0x3ce>
   13735:	8b 45 08             	mov    0x8(%ebp),%eax
   13738:	c1 e0 02             	shl    $0x2,%eax
   1373b:	05 a0 b3 01 00       	add    $0x1b3a0,%eax
   13740:	8b 00                	mov    (%eax),%eax
   13742:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   13744:	b8 6c a0 01 00       	mov    $0x1a06c,%eax
   13749:	e9 ad 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   1374e:	b8 89 a0 01 00       	mov    $0x1a089,%eax
   13753:	e9 a3 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   13758:	b8 9c a0 01 00       	mov    $0x1a09c,%eax
   1375d:	e9 99 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   13762:	b8 d4 a0 01 00       	mov    $0x1a0d4,%eax
   13767:	e9 8f 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   1376c:	b8 0c a1 01 00       	mov    $0x1a10c,%eax
   13771:	e9 85 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   13776:	b8 0c a1 01 00       	mov    $0x1a10c,%eax
   1377b:	e9 7b 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   13780:	b8 0c a1 01 00       	mov    $0x1a10c,%eax
   13785:	e9 71 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   1378a:	b8 3c a1 01 00       	mov    $0x1a13c,%eax
   1378f:	e9 67 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   13794:	b8 70 a1 01 00       	mov    $0x1a170,%eax
   13799:	e9 5d 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   1379e:	b8 a4 a1 01 00       	mov    $0x1a1a4,%eax
   137a3:	e9 53 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   137a8:	b8 70 a1 01 00       	mov    $0x1a170,%eax
   137ad:	e9 49 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   137b2:	b8 cc a1 01 00       	mov    $0x1a1cc,%eax
   137b7:	e9 3f 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   137bc:	b8 04 a2 01 00       	mov    $0x1a204,%eax
   137c1:	e9 35 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   137c6:	b8 70 a1 01 00       	mov    $0x1a170,%eax
   137cb:	e9 2b 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   137d0:	b8 3c a2 01 00       	mov    $0x1a23c,%eax
   137d5:	e9 21 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   137da:	b8 6c a2 01 00       	mov    $0x1a26c,%eax
   137df:	e9 17 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   137e4:	b8 8c a2 01 00       	mov    $0x1a28c,%eax
   137e9:	e9 0d 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   137ee:	b8 b8 a2 01 00       	mov    $0x1a2b8,%eax
   137f3:	e9 03 03 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   137f8:	b8 f8 a2 01 00       	mov    $0x1a2f8,%eax
   137fd:	e9 f9 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   13802:	b8 20 a3 01 00       	mov    $0x1a320,%eax
   13807:	e9 ef 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   1380c:	b8 54 a3 01 00       	mov    $0x1a354,%eax
   13811:	e9 e5 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   13816:	b8 78 a3 01 00       	mov    $0x1a378,%eax
   1381b:	e9 db 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   13820:	b8 b0 a3 01 00       	mov    $0x1a3b0,%eax
   13825:	e9 d1 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   1382a:	b8 d0 a3 01 00       	mov    $0x1a3d0,%eax
   1382f:	e9 c7 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   13834:	b8 ef a3 01 00       	mov    $0x1a3ef,%eax
   13839:	e9 bd 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   1383e:	b8 09 a4 01 00       	mov    $0x1a409,%eax
   13843:	e9 b3 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   13848:	b8 28 a4 01 00       	mov    $0x1a428,%eax
   1384d:	e9 a9 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   13852:	b8 64 a4 01 00       	mov    $0x1a464,%eax
   13857:	e9 9f 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   1385c:	b8 88 a4 01 00       	mov    $0x1a488,%eax
   13861:	e9 95 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   13866:	b8 b4 a4 01 00       	mov    $0x1a4b4,%eax
   1386b:	e9 8b 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   13870:	b8 d8 a4 01 00       	mov    $0x1a4d8,%eax
   13875:	e9 81 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   1387a:	b8 18 a5 01 00       	mov    $0x1a518,%eax
   1387f:	e9 77 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   13884:	b8 48 a5 01 00       	mov    $0x1a548,%eax
   13889:	e9 6d 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   1388e:	b8 70 a5 01 00       	mov    $0x1a570,%eax
   13893:	e9 63 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   13898:	b8 b4 a5 01 00       	mov    $0x1a5b4,%eax
   1389d:	e9 59 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   138a2:	b8 e0 a5 01 00       	mov    $0x1a5e0,%eax
   138a7:	e9 4f 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   138ac:	b8 10 a6 01 00       	mov    $0x1a610,%eax
   138b1:	e9 45 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   138b6:	b8 38 a6 01 00       	mov    $0x1a638,%eax
   138bb:	e9 3b 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   138c0:	b8 80 a6 01 00       	mov    $0x1a680,%eax
   138c5:	e9 31 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   138ca:	b8 80 a6 01 00       	mov    $0x1a680,%eax
   138cf:	e9 27 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   138d4:	b8 bc a6 01 00       	mov    $0x1a6bc,%eax
   138d9:	e9 1d 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   138de:	b8 f0 a6 01 00       	mov    $0x1a6f0,%eax
   138e3:	e9 13 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   138e8:	b8 13 a7 01 00       	mov    $0x1a713,%eax
   138ed:	e9 09 02 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   138f2:	b8 30 a7 01 00       	mov    $0x1a730,%eax
   138f7:	e9 ff 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   138fc:	b8 6c a7 01 00       	mov    $0x1a76c,%eax
   13901:	e9 f5 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   13906:	b8 9c a7 01 00       	mov    $0x1a79c,%eax
   1390b:	e9 eb 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   13910:	b8 e8 a7 01 00       	mov    $0x1a7e8,%eax
   13915:	e9 e1 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   1391a:	b8 20 a8 01 00       	mov    $0x1a820,%eax
   1391f:	e9 d7 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   13924:	b8 60 a8 01 00       	mov    $0x1a860,%eax
   13929:	e9 cd 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   1392e:	b8 8c a8 01 00       	mov    $0x1a88c,%eax
   13933:	e9 c3 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   13938:	b8 d8 a8 01 00       	mov    $0x1a8d8,%eax
   1393d:	e9 b9 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   13942:	b8 2c a9 01 00       	mov    $0x1a92c,%eax
   13947:	e9 af 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   1394c:	b8 60 a9 01 00       	mov    $0x1a960,%eax
   13951:	e9 a5 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   13956:	b8 b0 a9 01 00       	mov    $0x1a9b0,%eax
   1395b:	e9 9b 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   13960:	b8 ec a9 01 00       	mov    $0x1a9ec,%eax
   13965:	e9 91 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   1396a:	b8 4c aa 01 00       	mov    $0x1aa4c,%eax
   1396f:	e9 87 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   13974:	b8 ac aa 01 00       	mov    $0x1aaac,%eax
   13979:	e9 7d 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   1397e:	b8 08 ab 01 00       	mov    $0x1ab08,%eax
   13983:	e9 73 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   13988:	b8 4c ab 01 00       	mov    $0x1ab4c,%eax
   1398d:	e9 69 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   13992:	b8 88 ab 01 00       	mov    $0x1ab88,%eax
   13997:	e9 5f 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   1399c:	b8 e5 ab 01 00       	mov    $0x1abe5,%eax
   139a1:	e9 55 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   139a6:	b8 fd ab 01 00       	mov    $0x1abfd,%eax
   139ab:	e9 4b 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   139b0:	b8 18 ac 01 00       	mov    $0x1ac18,%eax
   139b5:	e9 41 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   139ba:	b8 54 ac 01 00       	mov    $0x1ac54,%eax
   139bf:	e9 37 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   139c4:	b8 84 ac 01 00       	mov    $0x1ac84,%eax
   139c9:	e9 2d 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   139ce:	b8 a4 ac 01 00       	mov    $0x1aca4,%eax
   139d3:	e9 23 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   139d8:	b8 c4 ac 01 00       	mov    $0x1acc4,%eax
   139dd:	e9 19 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   139e2:	b8 e4 ac 01 00       	mov    $0x1ace4,%eax
   139e7:	e9 0f 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   139ec:	b8 08 ad 01 00       	mov    $0x1ad08,%eax
   139f1:	e9 05 01 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   139f6:	b8 30 ad 01 00       	mov    $0x1ad30,%eax
   139fb:	e9 fb 00 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   13a00:	b8 8d ad 01 00       	mov    $0x1ad8d,%eax
   13a05:	e9 f1 00 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   13a0a:	b8 a8 ad 01 00       	mov    $0x1ada8,%eax
   13a0f:	e9 e7 00 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   13a14:	b8 e4 ad 01 00       	mov    $0x1ade4,%eax
   13a19:	e9 dd 00 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   13a1e:	b8 18 ae 01 00       	mov    $0x1ae18,%eax
   13a23:	e9 d3 00 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   13a28:	b8 6c ae 01 00       	mov    $0x1ae6c,%eax
   13a2d:	e9 c9 00 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   13a32:	b8 b8 ae 01 00       	mov    $0x1aeb8,%eax
   13a37:	e9 bf 00 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   13a3c:	b8 f4 ae 01 00       	mov    $0x1aef4,%eax
   13a41:	e9 b5 00 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   13a46:	b8 18 af 01 00       	mov    $0x1af18,%eax
   13a4b:	e9 ab 00 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   13a50:	b8 38 af 01 00       	mov    $0x1af38,%eax
   13a55:	e9 a1 00 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   13a5a:	b8 60 af 01 00       	mov    $0x1af60,%eax
   13a5f:	e9 97 00 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   13a64:	b8 80 af 01 00       	mov    $0x1af80,%eax
   13a69:	e9 8d 00 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   13a6e:	b8 ac af 01 00       	mov    $0x1afac,%eax
   13a73:	e9 83 00 00 00       	jmp    13afb <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   13a78:	b8 db af 01 00       	mov    $0x1afdb,%eax
   13a7d:	eb 7c                	jmp    13afb <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   13a7f:	b8 f3 af 01 00       	mov    $0x1aff3,%eax
   13a84:	eb 75                	jmp    13afb <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   13a86:	b8 0b b0 01 00       	mov    $0x1b00b,%eax
   13a8b:	eb 6e                	jmp    13afb <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   13a8d:	b8 23 b0 01 00       	mov    $0x1b023,%eax
   13a92:	eb 67                	jmp    13afb <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   13a94:	b8 44 b0 01 00       	mov    $0x1b044,%eax
   13a99:	eb 60                	jmp    13afb <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   13a9b:	b8 94 b0 01 00       	mov    $0x1b094,%eax
   13aa0:	eb 59                	jmp    13afb <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   13aa2:	b8 e8 b0 01 00       	mov    $0x1b0e8,%eax
   13aa7:	eb 52                	jmp    13afb <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   13aa9:	b8 3c b1 01 00       	mov    $0x1b13c,%eax
   13aae:	eb 4b                	jmp    13afb <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   13ab0:	b8 84 b1 01 00       	mov    $0x1b184,%eax
   13ab5:	eb 44                	jmp    13afb <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   13ab7:	b8 c8 b1 01 00       	mov    $0x1b1c8,%eax
   13abc:	eb 3d                	jmp    13afb <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   13abe:	b8 e4 b1 01 00       	mov    $0x1b1e4,%eax
   13ac3:	eb 36                	jmp    13afb <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   13ac5:	b8 1c b2 01 00       	mov    $0x1b21c,%eax
   13aca:	eb 2f                	jmp    13afb <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   13acc:	b8 70 b2 01 00       	mov    $0x1b270,%eax
   13ad1:	eb 28                	jmp    13afb <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   13ad3:	b8 a0 b2 01 00       	mov    $0x1b2a0,%eax
   13ad8:	eb 21                	jmp    13afb <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   13ada:	b8 f0 b2 01 00       	mov    $0x1b2f0,%eax
   13adf:	eb 1a                	jmp    13afb <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   13ae1:	b8 1c b3 01 00       	mov    $0x1b31c,%eax
   13ae6:	eb 13                	jmp    13afb <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   13ae8:	b8 48 b3 01 00       	mov    $0x1b348,%eax
   13aed:	eb 0c                	jmp    13afb <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   13aef:	b8 6c b3 01 00       	mov    $0x1b36c,%eax
   13af4:	eb 05                	jmp    13afb <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   13af6:	b8 8b b3 01 00       	mov    $0x1b38b,%eax
}
   13afb:	5d                   	pop    %ebp
   13afc:	c3                   	ret    

00013afd <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   13afd:	55                   	push   %ebp
   13afe:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   13b00:	8b 45 08             	mov    0x8(%ebp),%eax
   13b03:	8b 40 28             	mov    0x28(%eax),%eax
   13b06:	83 f8 01             	cmp    $0x1,%eax
   13b09:	75 08                	jne    13b13 <GetImage+0x16>
   13b0b:	8b 45 08             	mov    0x8(%ebp),%eax
   13b0e:	8b 40 54             	mov    0x54(%eax),%eax
   13b11:	eb 09                	jmp    13b1c <GetImage+0x1f>
   13b13:	8b 45 08             	mov    0x8(%ebp),%eax
   13b16:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   13b1c:	5d                   	pop    %ebp
   13b1d:	c3                   	ret    

00013b1e <GetWidth>:

int GetWidth(Context* ctx){
   13b1e:	55                   	push   %ebp
   13b1f:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   13b21:	8b 45 08             	mov    0x8(%ebp),%eax
   13b24:	8b 40 10             	mov    0x10(%eax),%eax
}
   13b27:	5d                   	pop    %ebp
   13b28:	c3                   	ret    

00013b29 <GetHeight>:

int GetHeight(Context* ctx){
   13b29:	55                   	push   %ebp
   13b2a:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   13b2c:	8b 45 08             	mov    0x8(%ebp),%eax
   13b2f:	8b 40 14             	mov    0x14(%eax),%eax
}
   13b32:	5d                   	pop    %ebp
   13b33:	c3                   	ret    

00013b34 <GetImageSize>:

uint GetImageSize(Context* ctx){
   13b34:	55                   	push   %ebp
   13b35:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   13b37:	8b 45 08             	mov    0x8(%ebp),%eax
   13b3a:	8b 50 10             	mov    0x10(%eax),%edx
   13b3d:	8b 45 08             	mov    0x8(%ebp),%eax
   13b40:	8b 40 14             	mov    0x14(%eax),%eax
   13b43:	0f af d0             	imul   %eax,%edx
   13b46:	8b 45 08             	mov    0x8(%ebp),%eax
   13b49:	8b 40 28             	mov    0x28(%eax),%eax
   13b4c:	0f af c2             	imul   %edx,%eax
}
   13b4f:	5d                   	pop    %ebp
   13b50:	c3                   	ret    

00013b51 <_Clip>:

uchar _Clip(const int x){
   13b51:	55                   	push   %ebp
   13b52:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   13b54:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13b58:	78 15                	js     13b6f <_Clip+0x1e>
   13b5a:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   13b61:	7f 05                	jg     13b68 <_Clip+0x17>
   13b63:	8b 45 08             	mov    0x8(%ebp),%eax
   13b66:	eb 0c                	jmp    13b74 <_Clip+0x23>
   13b68:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13b6d:	eb 05                	jmp    13b74 <_Clip+0x23>
   13b6f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13b74:	5d                   	pop    %ebp
   13b75:	c3                   	ret    

00013b76 <_Skip>:

void _Skip(Context* ctx, int c){
   13b76:	55                   	push   %ebp
   13b77:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   13b79:	8b 45 08             	mov    0x8(%ebp),%eax
   13b7c:	8b 50 04             	mov    0x4(%eax),%edx
   13b7f:	8b 45 0c             	mov    0xc(%ebp),%eax
   13b82:	01 c2                	add    %eax,%edx
   13b84:	8b 45 08             	mov    0x8(%ebp),%eax
   13b87:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   13b8a:	8b 45 08             	mov    0x8(%ebp),%eax
   13b8d:	8b 40 08             	mov    0x8(%eax),%eax
   13b90:	2b 45 0c             	sub    0xc(%ebp),%eax
   13b93:	89 c2                	mov    %eax,%edx
   13b95:	8b 45 08             	mov    0x8(%ebp),%eax
   13b98:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   13b9b:	8b 45 08             	mov    0x8(%ebp),%eax
   13b9e:	8b 40 0c             	mov    0xc(%eax),%eax
   13ba1:	2b 45 0c             	sub    0xc(%ebp),%eax
   13ba4:	89 c2                	mov    %eax,%edx
   13ba6:	8b 45 08             	mov    0x8(%ebp),%eax
   13ba9:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   13bac:	8b 45 08             	mov    0x8(%ebp),%eax
   13baf:	8b 40 08             	mov    0x8(%eax),%eax
   13bb2:	85 c0                	test   %eax,%eax
   13bb4:	79 09                	jns    13bbf <_Skip+0x49>
   13bb6:	8b 45 08             	mov    0x8(%ebp),%eax
   13bb9:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   13bbf:	90                   	nop
   13bc0:	5d                   	pop    %ebp
   13bc1:	c3                   	ret    

00013bc2 <_DecodeLength>:

void _DecodeLength(Context* ctx){
   13bc2:	55                   	push   %ebp
   13bc3:	89 e5                	mov    %esp,%ebp
   13bc5:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   13bc8:	8b 45 08             	mov    0x8(%ebp),%eax
   13bcb:	8b 40 08             	mov    0x8(%eax),%eax
   13bce:	83 f8 01             	cmp    $0x1,%eax
   13bd1:	7f 0b                	jg     13bde <_DecodeLength+0x1c>
   13bd3:	8b 45 08             	mov    0x8(%ebp),%eax
   13bd6:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13bdc:	eb 45                	jmp    13c23 <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   13bde:	8b 45 08             	mov    0x8(%ebp),%eax
   13be1:	8b 40 04             	mov    0x4(%eax),%eax
   13be4:	83 ec 0c             	sub    $0xc,%esp
   13be7:	50                   	push   %eax
   13be8:	e8 38 00 00 00       	call   13c25 <_Decode2Bytes>
   13bed:	83 c4 10             	add    $0x10,%esp
   13bf0:	89 c2                	mov    %eax,%edx
   13bf2:	8b 45 08             	mov    0x8(%ebp),%eax
   13bf5:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   13bf8:	8b 45 08             	mov    0x8(%ebp),%eax
   13bfb:	8b 50 0c             	mov    0xc(%eax),%edx
   13bfe:	8b 45 08             	mov    0x8(%ebp),%eax
   13c01:	8b 40 08             	mov    0x8(%eax),%eax
   13c04:	39 c2                	cmp    %eax,%edx
   13c06:	7e 0b                	jle    13c13 <_DecodeLength+0x51>
   13c08:	8b 45 08             	mov    0x8(%ebp),%eax
   13c0b:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13c11:	eb 10                	jmp    13c23 <_DecodeLength+0x61>
    _Skip(ctx, 2);
   13c13:	83 ec 08             	sub    $0x8,%esp
   13c16:	6a 02                	push   $0x2
   13c18:	ff 75 08             	pushl  0x8(%ebp)
   13c1b:	e8 56 ff ff ff       	call   13b76 <_Skip>
   13c20:	83 c4 10             	add    $0x10,%esp
}
   13c23:	c9                   	leave  
   13c24:	c3                   	ret    

00013c25 <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   13c25:	55                   	push   %ebp
   13c26:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   13c28:	8b 45 08             	mov    0x8(%ebp),%eax
   13c2b:	0f b6 00             	movzbl (%eax),%eax
   13c2e:	0f b6 c0             	movzbl %al,%eax
   13c31:	c1 e0 08             	shl    $0x8,%eax
   13c34:	89 c2                	mov    %eax,%edx
   13c36:	8b 45 08             	mov    0x8(%ebp),%eax
   13c39:	83 c0 01             	add    $0x1,%eax
   13c3c:	0f b6 00             	movzbl (%eax),%eax
   13c3f:	0f b6 c0             	movzbl %al,%eax
   13c42:	09 d0                	or     %edx,%eax
}
   13c44:	5d                   	pop    %ebp
   13c45:	c3                   	ret    

00013c46 <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   13c46:	55                   	push   %ebp
   13c47:	89 e5                	mov    %esp,%ebp
   13c49:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   13c4c:	8b 45 08             	mov    0x8(%ebp),%eax
   13c4f:	8b 55 10             	mov    0x10(%ebp),%edx
   13c52:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   13c55:	8b 45 14             	mov    0x14(%ebp),%eax
   13c58:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   13c5d:	89 c2                	mov    %eax,%edx
   13c5f:	8b 45 08             	mov    0x8(%ebp),%eax
   13c62:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   13c65:	8b 45 08             	mov    0x8(%ebp),%eax
   13c68:	8b 40 08             	mov    0x8(%eax),%eax
   13c6b:	83 f8 01             	cmp    $0x1,%eax
   13c6e:	7e 1d                	jle    13c8d <_DecodeJPEG+0x47>
   13c70:	8b 45 08             	mov    0x8(%ebp),%eax
   13c73:	8b 40 04             	mov    0x4(%eax),%eax
   13c76:	0f b6 00             	movzbl (%eax),%eax
   13c79:	3c ff                	cmp    $0xff,%al
   13c7b:	75 10                	jne    13c8d <_DecodeJPEG+0x47>
   13c7d:	8b 45 08             	mov    0x8(%ebp),%eax
   13c80:	8b 40 04             	mov    0x4(%eax),%eax
   13c83:	83 c0 01             	add    $0x1,%eax
   13c86:	0f b6 00             	movzbl (%eax),%eax
   13c89:	3c d8                	cmp    $0xd8,%al
   13c8b:	74 0a                	je     13c97 <_DecodeJPEG+0x51>
   13c8d:	b8 01 00 00 00       	mov    $0x1,%eax
   13c92:	e9 56 01 00 00       	jmp    13ded <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   13c97:	6a 02                	push   $0x2
   13c99:	ff 75 08             	pushl  0x8(%ebp)
   13c9c:	e8 d5 fe ff ff       	call   13b76 <_Skip>
   13ca1:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   13ca4:	e9 0a 01 00 00       	jmp    13db3 <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   13ca9:	8b 45 08             	mov    0x8(%ebp),%eax
   13cac:	8b 40 08             	mov    0x8(%eax),%eax
   13caf:	85 c0                	test   %eax,%eax
   13cb1:	78 0d                	js     13cc0 <_DecodeJPEG+0x7a>
   13cb3:	8b 45 08             	mov    0x8(%ebp),%eax
   13cb6:	8b 40 04             	mov    0x4(%eax),%eax
   13cb9:	0f b6 00             	movzbl (%eax),%eax
   13cbc:	3c ff                	cmp    $0xff,%al
   13cbe:	74 0a                	je     13cca <_DecodeJPEG+0x84>
   13cc0:	b8 05 00 00 00       	mov    $0x5,%eax
   13cc5:	e9 23 01 00 00       	jmp    13ded <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   13cca:	6a 02                	push   $0x2
   13ccc:	ff 75 08             	pushl  0x8(%ebp)
   13ccf:	e8 a2 fe ff ff       	call   13b76 <_Skip>
   13cd4:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   13cd7:	8b 45 08             	mov    0x8(%ebp),%eax
   13cda:	8b 40 04             	mov    0x4(%eax),%eax
   13cdd:	83 e8 01             	sub    $0x1,%eax
   13ce0:	0f b6 00             	movzbl (%eax),%eax
   13ce3:	0f b6 c0             	movzbl %al,%eax
   13ce6:	3d da 00 00 00       	cmp    $0xda,%eax
   13ceb:	74 71                	je     13d5e <_DecodeJPEG+0x118>
   13ced:	3d da 00 00 00       	cmp    $0xda,%eax
   13cf2:	7f 10                	jg     13d04 <_DecodeJPEG+0xbe>
   13cf4:	3d c0 00 00 00       	cmp    $0xc0,%eax
   13cf9:	74 20                	je     13d1b <_DecodeJPEG+0xd5>
   13cfb:	3d c4 00 00 00       	cmp    $0xc4,%eax
   13d00:	74 2c                	je     13d2e <_DecodeJPEG+0xe8>
   13d02:	eb 7d                	jmp    13d81 <_DecodeJPEG+0x13b>
   13d04:	3d dd 00 00 00       	cmp    $0xdd,%eax
   13d09:	74 43                	je     13d4e <_DecodeJPEG+0x108>
   13d0b:	3d fe 00 00 00       	cmp    $0xfe,%eax
   13d10:	74 5f                	je     13d71 <_DecodeJPEG+0x12b>
   13d12:	3d db 00 00 00       	cmp    $0xdb,%eax
   13d17:	74 25                	je     13d3e <_DecodeJPEG+0xf8>
   13d19:	eb 66                	jmp    13d81 <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   13d1b:	83 ec 0c             	sub    $0xc,%esp
   13d1e:	ff 75 08             	pushl  0x8(%ebp)
   13d21:	e8 c9 00 00 00       	call   13def <_DecodeSOF>
   13d26:	83 c4 10             	add    $0x10,%esp
   13d29:	e9 85 00 00 00       	jmp    13db3 <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   13d2e:	83 ec 0c             	sub    $0xc,%esp
   13d31:	ff 75 08             	pushl  0x8(%ebp)
   13d34:	e8 28 05 00 00       	call   14261 <_DecodeDHT>
   13d39:	83 c4 10             	add    $0x10,%esp
   13d3c:	eb 75                	jmp    13db3 <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   13d3e:	83 ec 0c             	sub    $0xc,%esp
   13d41:	ff 75 08             	pushl  0x8(%ebp)
   13d44:	e8 05 07 00 00       	call   1444e <_DecodeDQT>
   13d49:	83 c4 10             	add    $0x10,%esp
   13d4c:	eb 65                	jmp    13db3 <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   13d4e:	83 ec 0c             	sub    $0xc,%esp
   13d51:	ff 75 08             	pushl  0x8(%ebp)
   13d54:	e8 ff 07 00 00       	call   14558 <_DecodeDRI>
   13d59:	83 c4 10             	add    $0x10,%esp
   13d5c:	eb 55                	jmp    13db3 <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   13d5e:	83 ec 08             	sub    $0x8,%esp
   13d61:	ff 75 0c             	pushl  0xc(%ebp)
   13d64:	ff 75 08             	pushl  0x8(%ebp)
   13d67:	e8 56 08 00 00       	call   145c2 <_DecodeSOS>
   13d6c:	83 c4 10             	add    $0x10,%esp
   13d6f:	eb 42                	jmp    13db3 <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   13d71:	83 ec 0c             	sub    $0xc,%esp
   13d74:	ff 75 08             	pushl  0x8(%ebp)
   13d77:	e8 a8 15 00 00       	call   15324 <_SkipMarker>
   13d7c:	83 c4 10             	add    $0x10,%esp
   13d7f:	eb 32                	jmp    13db3 <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   13d81:	8b 45 08             	mov    0x8(%ebp),%eax
   13d84:	8b 40 04             	mov    0x4(%eax),%eax
   13d87:	83 e8 01             	sub    $0x1,%eax
   13d8a:	0f b6 00             	movzbl (%eax),%eax
   13d8d:	0f b6 c0             	movzbl %al,%eax
   13d90:	25 f0 00 00 00       	and    $0xf0,%eax
   13d95:	3d e0 00 00 00       	cmp    $0xe0,%eax
   13d9a:	75 10                	jne    13dac <_DecodeJPEG+0x166>
   13d9c:	83 ec 0c             	sub    $0xc,%esp
   13d9f:	ff 75 08             	pushl  0x8(%ebp)
   13da2:	e8 7d 15 00 00       	call   15324 <_SkipMarker>
   13da7:	83 c4 10             	add    $0x10,%esp
   13daa:	eb 07                	jmp    13db3 <_DecodeJPEG+0x16d>
                else return Unsupported;
   13dac:	b8 02 00 00 00       	mov    $0x2,%eax
   13db1:	eb 3a                	jmp    13ded <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   13db3:	8b 45 08             	mov    0x8(%ebp),%eax
   13db6:	8b 00                	mov    (%eax),%eax
   13db8:	85 c0                	test   %eax,%eax
   13dba:	0f 84 e9 fe ff ff    	je     13ca9 <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   13dc0:	8b 45 08             	mov    0x8(%ebp),%eax
   13dc3:	8b 00                	mov    (%eax),%eax
   13dc5:	83 f8 06             	cmp    $0x6,%eax
   13dc8:	74 07                	je     13dd1 <_DecodeJPEG+0x18b>
   13dca:	8b 45 08             	mov    0x8(%ebp),%eax
   13dcd:	8b 00                	mov    (%eax),%eax
   13dcf:	eb 1c                	jmp    13ded <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   13dd1:	8b 45 08             	mov    0x8(%ebp),%eax
   13dd4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   13dda:	83 ec 0c             	sub    $0xc,%esp
   13ddd:	ff 75 08             	pushl  0x8(%ebp)
   13de0:	e8 6b 15 00 00       	call   15350 <_Convert>
   13de5:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   13de8:	8b 45 08             	mov    0x8(%ebp),%eax
   13deb:	8b 00                	mov    (%eax),%eax
 }
   13ded:	c9                   	leave  
   13dee:	c3                   	ret    

00013def <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   13def:	55                   	push   %ebp
   13df0:	89 e5                	mov    %esp,%ebp
   13df2:	53                   	push   %ebx
   13df3:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   13df6:	83 ec 0c             	sub    $0xc,%esp
   13df9:	ff 75 08             	pushl  0x8(%ebp)
   13dfc:	e8 c1 fd ff ff       	call   13bc2 <_DecodeLength>
   13e01:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   13e04:	8b 45 08             	mov    0x8(%ebp),%eax
   13e07:	8b 00                	mov    (%eax),%eax
   13e09:	85 c0                	test   %eax,%eax
   13e0b:	0f 85 4a 04 00 00    	jne    1425b <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   13e11:	8b 45 08             	mov    0x8(%ebp),%eax
   13e14:	8b 40 0c             	mov    0xc(%eax),%eax
   13e17:	83 f8 08             	cmp    $0x8,%eax
   13e1a:	7f 0e                	jg     13e2a <_DecodeSOF+0x3b>
   13e1c:	8b 45 08             	mov    0x8(%ebp),%eax
   13e1f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13e25:	e9 32 04 00 00       	jmp    1425c <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   13e2a:	8b 45 08             	mov    0x8(%ebp),%eax
   13e2d:	8b 40 04             	mov    0x4(%eax),%eax
   13e30:	0f b6 00             	movzbl (%eax),%eax
   13e33:	3c 08                	cmp    $0x8,%al
   13e35:	74 0e                	je     13e45 <_DecodeSOF+0x56>
   13e37:	8b 45 08             	mov    0x8(%ebp),%eax
   13e3a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13e40:	e9 17 04 00 00       	jmp    1425c <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   13e45:	8b 45 08             	mov    0x8(%ebp),%eax
   13e48:	8b 40 04             	mov    0x4(%eax),%eax
   13e4b:	83 c0 01             	add    $0x1,%eax
   13e4e:	83 ec 0c             	sub    $0xc,%esp
   13e51:	50                   	push   %eax
   13e52:	e8 ce fd ff ff       	call   13c25 <_Decode2Bytes>
   13e57:	83 c4 10             	add    $0x10,%esp
   13e5a:	89 c2                	mov    %eax,%edx
   13e5c:	8b 45 08             	mov    0x8(%ebp),%eax
   13e5f:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   13e62:	8b 45 08             	mov    0x8(%ebp),%eax
   13e65:	8b 40 04             	mov    0x4(%eax),%eax
   13e68:	83 c0 03             	add    $0x3,%eax
   13e6b:	83 ec 0c             	sub    $0xc,%esp
   13e6e:	50                   	push   %eax
   13e6f:	e8 b1 fd ff ff       	call   13c25 <_Decode2Bytes>
   13e74:	83 c4 10             	add    $0x10,%esp
   13e77:	89 c2                	mov    %eax,%edx
   13e79:	8b 45 08             	mov    0x8(%ebp),%eax
   13e7c:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   13e7f:	8b 45 08             	mov    0x8(%ebp),%eax
   13e82:	8b 40 04             	mov    0x4(%eax),%eax
   13e85:	83 c0 05             	add    $0x5,%eax
   13e88:	0f b6 00             	movzbl (%eax),%eax
   13e8b:	0f b6 d0             	movzbl %al,%edx
   13e8e:	8b 45 08             	mov    0x8(%ebp),%eax
   13e91:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   13e94:	83 ec 08             	sub    $0x8,%esp
   13e97:	6a 06                	push   $0x6
   13e99:	ff 75 08             	pushl  0x8(%ebp)
   13e9c:	e8 d5 fc ff ff       	call   13b76 <_Skip>
   13ea1:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   13ea4:	8b 45 08             	mov    0x8(%ebp),%eax
   13ea7:	8b 40 28             	mov    0x28(%eax),%eax
   13eaa:	83 f8 01             	cmp    $0x1,%eax
   13ead:	74 13                	je     13ec2 <_DecodeSOF+0xd3>
   13eaf:	83 f8 03             	cmp    $0x3,%eax
   13eb2:	74 0e                	je     13ec2 <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   13eb4:	8b 45 08             	mov    0x8(%ebp),%eax
   13eb7:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13ebd:	e9 9a 03 00 00       	jmp    1425c <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   13ec2:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   13ec3:	8b 45 08             	mov    0x8(%ebp),%eax
   13ec6:	8b 48 0c             	mov    0xc(%eax),%ecx
   13ec9:	8b 45 08             	mov    0x8(%ebp),%eax
   13ecc:	8b 50 28             	mov    0x28(%eax),%edx
   13ecf:	89 d0                	mov    %edx,%eax
   13ed1:	01 c0                	add    %eax,%eax
   13ed3:	01 d0                	add    %edx,%eax
   13ed5:	39 c1                	cmp    %eax,%ecx
   13ed7:	7d 0e                	jge    13ee7 <_DecodeSOF+0xf8>
   13ed9:	8b 45 08             	mov    0x8(%ebp),%eax
   13edc:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13ee2:	e9 75 03 00 00       	jmp    1425c <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   13ee7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13eee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   13ef5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   13efc:	8b 45 08             	mov    0x8(%ebp),%eax
   13eff:	83 c0 2c             	add    $0x2c,%eax
   13f02:	89 45 e8             	mov    %eax,-0x18(%ebp)
   13f05:	e9 50 01 00 00       	jmp    1405a <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   13f0a:	8b 45 08             	mov    0x8(%ebp),%eax
   13f0d:	8b 40 04             	mov    0x4(%eax),%eax
   13f10:	0f b6 00             	movzbl (%eax),%eax
   13f13:	0f b6 d0             	movzbl %al,%edx
   13f16:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f19:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   13f1b:	8b 45 08             	mov    0x8(%ebp),%eax
   13f1e:	8b 40 04             	mov    0x4(%eax),%eax
   13f21:	83 c0 01             	add    $0x1,%eax
   13f24:	0f b6 00             	movzbl (%eax),%eax
   13f27:	c0 e8 04             	shr    $0x4,%al
   13f2a:	0f b6 d0             	movzbl %al,%edx
   13f2d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f30:	89 50 04             	mov    %edx,0x4(%eax)
   13f33:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f36:	8b 40 04             	mov    0x4(%eax),%eax
   13f39:	85 c0                	test   %eax,%eax
   13f3b:	75 0e                	jne    13f4b <_DecodeSOF+0x15c>
   13f3d:	8b 45 08             	mov    0x8(%ebp),%eax
   13f40:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13f46:	e9 11 03 00 00       	jmp    1425c <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   13f4b:	8b 45 08             	mov    0x8(%ebp),%eax
   13f4e:	8b 40 04             	mov    0x4(%eax),%eax
   13f51:	83 c0 01             	add    $0x1,%eax
   13f54:	0f b6 00             	movzbl (%eax),%eax
   13f57:	0f b6 c0             	movzbl %al,%eax
   13f5a:	83 e0 0f             	and    $0xf,%eax
   13f5d:	89 c2                	mov    %eax,%edx
   13f5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f62:	89 50 08             	mov    %edx,0x8(%eax)
   13f65:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f68:	8b 40 08             	mov    0x8(%eax),%eax
   13f6b:	85 c0                	test   %eax,%eax
   13f6d:	75 0e                	jne    13f7d <_DecodeSOF+0x18e>
   13f6f:	8b 45 08             	mov    0x8(%ebp),%eax
   13f72:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13f78:	e9 df 02 00 00       	jmp    1425c <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   13f7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f80:	8b 50 04             	mov    0x4(%eax),%edx
   13f83:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f86:	8b 40 04             	mov    0x4(%eax),%eax
   13f89:	83 e8 01             	sub    $0x1,%eax
   13f8c:	21 d0                	and    %edx,%eax
   13f8e:	85 c0                	test   %eax,%eax
   13f90:	74 0e                	je     13fa0 <_DecodeSOF+0x1b1>
   13f92:	8b 45 08             	mov    0x8(%ebp),%eax
   13f95:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13f9b:	e9 bc 02 00 00       	jmp    1425c <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   13fa0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fa3:	8b 50 08             	mov    0x8(%eax),%edx
   13fa6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fa9:	8b 40 08             	mov    0x8(%eax),%eax
   13fac:	83 e8 01             	sub    $0x1,%eax
   13faf:	21 d0                	and    %edx,%eax
   13fb1:	85 c0                	test   %eax,%eax
   13fb3:	74 0e                	je     13fc3 <_DecodeSOF+0x1d4>
   13fb5:	8b 45 08             	mov    0x8(%ebp),%eax
   13fb8:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13fbe:	e9 99 02 00 00       	jmp    1425c <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   13fc3:	8b 45 08             	mov    0x8(%ebp),%eax
   13fc6:	8b 40 04             	mov    0x4(%eax),%eax
   13fc9:	83 c0 02             	add    $0x2,%eax
   13fcc:	0f b6 00             	movzbl (%eax),%eax
   13fcf:	0f b6 d0             	movzbl %al,%edx
   13fd2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fd5:	89 50 18             	mov    %edx,0x18(%eax)
   13fd8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fdb:	8b 40 18             	mov    0x18(%eax),%eax
   13fde:	25 fc 00 00 00       	and    $0xfc,%eax
   13fe3:	85 c0                	test   %eax,%eax
   13fe5:	74 0e                	je     13ff5 <_DecodeSOF+0x206>
   13fe7:	8b 45 08             	mov    0x8(%ebp),%eax
   13fea:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13ff0:	e9 67 02 00 00       	jmp    1425c <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   13ff5:	83 ec 08             	sub    $0x8,%esp
   13ff8:	6a 03                	push   $0x3
   13ffa:	ff 75 08             	pushl  0x8(%ebp)
   13ffd:	e8 74 fb ff ff       	call   13b76 <_Skip>
   14002:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   14005:	8b 45 08             	mov    0x8(%ebp),%eax
   14008:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   1400e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14011:	8b 40 18             	mov    0x18(%eax),%eax
   14014:	bb 01 00 00 00       	mov    $0x1,%ebx
   14019:	89 c1                	mov    %eax,%ecx
   1401b:	d3 e3                	shl    %cl,%ebx
   1401d:	89 d8                	mov    %ebx,%eax
   1401f:	09 c2                	or     %eax,%edx
   14021:	8b 45 08             	mov    0x8(%ebp),%eax
   14024:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   1402a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1402d:	8b 40 04             	mov    0x4(%eax),%eax
   14030:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14033:	7e 09                	jle    1403e <_DecodeSOF+0x24f>
   14035:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14038:	8b 40 04             	mov    0x4(%eax),%eax
   1403b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   1403e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14041:	8b 40 08             	mov    0x8(%eax),%eax
   14044:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14047:	7e 09                	jle    14052 <_DecodeSOF+0x263>
   14049:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1404c:	8b 40 08             	mov    0x8(%eax),%eax
   1404f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14052:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14056:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   1405a:	8b 45 08             	mov    0x8(%ebp),%eax
   1405d:	8b 40 28             	mov    0x28(%eax),%eax
   14060:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14063:	0f 8f a1 fe ff ff    	jg     13f0a <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   14069:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1406c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   14073:	8b 45 08             	mov    0x8(%ebp),%eax
   14076:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   14079:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1407c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   14083:	8b 45 08             	mov    0x8(%ebp),%eax
   14086:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   14089:	8b 45 08             	mov    0x8(%ebp),%eax
   1408c:	8b 50 10             	mov    0x10(%eax),%edx
   1408f:	8b 45 08             	mov    0x8(%ebp),%eax
   14092:	8b 40 20             	mov    0x20(%eax),%eax
   14095:	01 d0                	add    %edx,%eax
   14097:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1409a:	8b 45 08             	mov    0x8(%ebp),%eax
   1409d:	8b 58 20             	mov    0x20(%eax),%ebx
   140a0:	89 c8                	mov    %ecx,%eax
   140a2:	99                   	cltd   
   140a3:	f7 fb                	idiv   %ebx
   140a5:	89 c2                	mov    %eax,%edx
   140a7:	8b 45 08             	mov    0x8(%ebp),%eax
   140aa:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   140ad:	8b 45 08             	mov    0x8(%ebp),%eax
   140b0:	8b 50 14             	mov    0x14(%eax),%edx
   140b3:	8b 45 08             	mov    0x8(%ebp),%eax
   140b6:	8b 40 24             	mov    0x24(%eax),%eax
   140b9:	01 d0                	add    %edx,%eax
   140bb:	8d 48 ff             	lea    -0x1(%eax),%ecx
   140be:	8b 45 08             	mov    0x8(%ebp),%eax
   140c1:	8b 58 24             	mov    0x24(%eax),%ebx
   140c4:	89 c8                	mov    %ecx,%eax
   140c6:	99                   	cltd   
   140c7:	f7 fb                	idiv   %ebx
   140c9:	89 c2                	mov    %eax,%edx
   140cb:	8b 45 08             	mov    0x8(%ebp),%eax
   140ce:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   140d1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   140d8:	8b 45 08             	mov    0x8(%ebp),%eax
   140db:	83 c0 2c             	add    $0x2c,%eax
   140de:	89 45 e8             	mov    %eax,-0x18(%ebp)
   140e1:	e9 fd 00 00 00       	jmp    141e3 <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   140e6:	8b 45 08             	mov    0x8(%ebp),%eax
   140e9:	8b 50 10             	mov    0x10(%eax),%edx
   140ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140ef:	8b 40 04             	mov    0x4(%eax),%eax
   140f2:	0f af d0             	imul   %eax,%edx
   140f5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   140f8:	01 d0                	add    %edx,%eax
   140fa:	83 e8 01             	sub    $0x1,%eax
   140fd:	99                   	cltd   
   140fe:	f7 7d ec             	idivl  -0x14(%ebp)
   14101:	89 c2                	mov    %eax,%edx
   14103:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14106:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   14109:	8b 45 08             	mov    0x8(%ebp),%eax
   1410c:	8b 50 14             	mov    0x14(%eax),%edx
   1410f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14112:	8b 40 08             	mov    0x8(%eax),%eax
   14115:	0f af d0             	imul   %eax,%edx
   14118:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1411b:	01 d0                	add    %edx,%eax
   1411d:	83 e8 01             	sub    $0x1,%eax
   14120:	99                   	cltd   
   14121:	f7 7d f0             	idivl  -0x10(%ebp)
   14124:	89 c2                	mov    %eax,%edx
   14126:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14129:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   1412c:	8b 45 08             	mov    0x8(%ebp),%eax
   1412f:	8b 50 18             	mov    0x18(%eax),%edx
   14132:	8b 45 08             	mov    0x8(%ebp),%eax
   14135:	8b 40 20             	mov    0x20(%eax),%eax
   14138:	0f af d0             	imul   %eax,%edx
   1413b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1413e:	8b 40 04             	mov    0x4(%eax),%eax
   14141:	0f af c2             	imul   %edx,%eax
   14144:	99                   	cltd   
   14145:	f7 7d ec             	idivl  -0x14(%ebp)
   14148:	89 c2                	mov    %eax,%edx
   1414a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1414d:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   14150:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14153:	8b 40 0c             	mov    0xc(%eax),%eax
   14156:	83 f8 02             	cmp    $0x2,%eax
   14159:	7f 0b                	jg     14166 <_DecodeSOF+0x377>
   1415b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1415e:	8b 40 04             	mov    0x4(%eax),%eax
   14161:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14164:	75 16                	jne    1417c <_DecodeSOF+0x38d>
   14166:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14169:	8b 40 10             	mov    0x10(%eax),%eax
   1416c:	83 f8 02             	cmp    $0x2,%eax
   1416f:	7f 19                	jg     1418a <_DecodeSOF+0x39b>
   14171:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14174:	8b 40 08             	mov    0x8(%eax),%eax
   14177:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1417a:	74 0e                	je     1418a <_DecodeSOF+0x39b>
   1417c:	8b 45 08             	mov    0x8(%ebp),%eax
   1417f:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14185:	e9 d2 00 00 00       	jmp    1425c <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   1418a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1418d:	8b 48 14             	mov    0x14(%eax),%ecx
   14190:	8b 45 08             	mov    0x8(%ebp),%eax
   14193:	8b 50 1c             	mov    0x1c(%eax),%edx
   14196:	8b 45 08             	mov    0x8(%ebp),%eax
   14199:	8b 40 24             	mov    0x24(%eax),%eax
   1419c:	0f af d0             	imul   %eax,%edx
   1419f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141a2:	8b 40 08             	mov    0x8(%eax),%eax
   141a5:	0f af c2             	imul   %edx,%eax
   141a8:	99                   	cltd   
   141a9:	f7 7d f0             	idivl  -0x10(%ebp)
   141ac:	0f af c1             	imul   %ecx,%eax
   141af:	83 ec 0c             	sub    $0xc,%esp
   141b2:	50                   	push   %eax
   141b3:	e8 45 c5 fe ff       	call   6fd <malloc>
   141b8:	83 c4 10             	add    $0x10,%esp
   141bb:	89 c2                	mov    %eax,%edx
   141bd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141c0:	89 50 28             	mov    %edx,0x28(%eax)
   141c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141c6:	8b 40 28             	mov    0x28(%eax),%eax
   141c9:	85 c0                	test   %eax,%eax
   141cb:	75 0e                	jne    141db <_DecodeSOF+0x3ec>
   141cd:	8b 45 08             	mov    0x8(%ebp),%eax
   141d0:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   141d6:	e9 81 00 00 00       	jmp    1425c <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   141db:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   141df:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   141e3:	8b 45 08             	mov    0x8(%ebp),%eax
   141e6:	8b 40 28             	mov    0x28(%eax),%eax
   141e9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   141ec:	0f 8f f4 fe ff ff    	jg     140e6 <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   141f2:	8b 45 08             	mov    0x8(%ebp),%eax
   141f5:	8b 40 28             	mov    0x28(%eax),%eax
   141f8:	83 f8 03             	cmp    $0x3,%eax
   141fb:	75 47                	jne    14244 <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   141fd:	8b 45 08             	mov    0x8(%ebp),%eax
   14200:	8b 50 10             	mov    0x10(%eax),%edx
   14203:	8b 45 08             	mov    0x8(%ebp),%eax
   14206:	8b 40 14             	mov    0x14(%eax),%eax
   14209:	0f af d0             	imul   %eax,%edx
   1420c:	8b 45 08             	mov    0x8(%ebp),%eax
   1420f:	8b 40 28             	mov    0x28(%eax),%eax
   14212:	0f af c2             	imul   %edx,%eax
   14215:	83 ec 0c             	sub    $0xc,%esp
   14218:	50                   	push   %eax
   14219:	e8 df c4 fe ff       	call   6fd <malloc>
   1421e:	83 c4 10             	add    $0x10,%esp
   14221:	89 c2                	mov    %eax,%edx
   14223:	8b 45 08             	mov    0x8(%ebp),%eax
   14226:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   1422c:	8b 45 08             	mov    0x8(%ebp),%eax
   1422f:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   14235:	85 c0                	test   %eax,%eax
   14237:	75 0b                	jne    14244 <_DecodeSOF+0x455>
   14239:	8b 45 08             	mov    0x8(%ebp),%eax
   1423c:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   14242:	eb 18                	jmp    1425c <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   14244:	8b 45 08             	mov    0x8(%ebp),%eax
   14247:	8b 40 0c             	mov    0xc(%eax),%eax
   1424a:	83 ec 08             	sub    $0x8,%esp
   1424d:	50                   	push   %eax
   1424e:	ff 75 08             	pushl  0x8(%ebp)
   14251:	e8 20 f9 ff ff       	call   13b76 <_Skip>
   14256:	83 c4 10             	add    $0x10,%esp
   14259:	eb 01                	jmp    1425c <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   1425b:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   1425c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1425f:	c9                   	leave  
   14260:	c3                   	ret    

00014261 <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   14261:	55                   	push   %ebp
   14262:	89 e5                	mov    %esp,%ebp
   14264:	53                   	push   %ebx
   14265:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   14268:	83 ec 0c             	sub    $0xc,%esp
   1426b:	ff 75 08             	pushl  0x8(%ebp)
   1426e:	e8 4f f9 ff ff       	call   13bc2 <_DecodeLength>
   14273:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14276:	8b 45 08             	mov    0x8(%ebp),%eax
   14279:	8b 00                	mov    (%eax),%eax
   1427b:	85 c0                	test   %eax,%eax
   1427d:	0f 85 c5 01 00 00    	jne    14448 <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   14283:	e9 9c 01 00 00       	jmp    14424 <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   14288:	8b 45 08             	mov    0x8(%ebp),%eax
   1428b:	8b 40 04             	mov    0x4(%eax),%eax
   1428e:	0f b6 00             	movzbl (%eax),%eax
   14291:	0f b6 c0             	movzbl %al,%eax
   14294:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   14297:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1429a:	25 ec 00 00 00       	and    $0xec,%eax
   1429f:	85 c0                	test   %eax,%eax
   142a1:	74 0e                	je     142b1 <_DecodeDHT+0x50>
   142a3:	8b 45 08             	mov    0x8(%ebp),%eax
   142a6:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   142ac:	e9 98 01 00 00       	jmp    14449 <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   142b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   142b4:	83 e0 02             	and    $0x2,%eax
   142b7:	85 c0                	test   %eax,%eax
   142b9:	74 0e                	je     142c9 <_DecodeDHT+0x68>
   142bb:	8b 45 08             	mov    0x8(%ebp),%eax
   142be:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   142c4:	e9 80 01 00 00       	jmp    14449 <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   142c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   142cc:	c1 f8 03             	sar    $0x3,%eax
   142cf:	0b 45 f4             	or     -0xc(%ebp),%eax
   142d2:	83 e0 03             	and    $0x3,%eax
   142d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   142d8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   142df:	eb 1c                	jmp    142fd <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   142e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   142e4:	8d 50 ff             	lea    -0x1(%eax),%edx
   142e7:	8b 45 08             	mov    0x8(%ebp),%eax
   142ea:	8b 48 04             	mov    0x4(%eax),%ecx
   142ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
   142f0:	01 c8                	add    %ecx,%eax
   142f2:	0f b6 00             	movzbl (%eax),%eax
   142f5:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   142f9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   142fd:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   14301:	7e de                	jle    142e1 <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   14303:	83 ec 08             	sub    $0x8,%esp
   14306:	6a 11                	push   $0x11
   14308:	ff 75 08             	pushl  0x8(%ebp)
   1430b:	e8 66 f8 ff ff       	call   13b76 <_Skip>
   14310:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   14313:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14316:	c1 e0 11             	shl    $0x11,%eax
   14319:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   1431f:	8b 45 08             	mov    0x8(%ebp),%eax
   14322:	01 d0                	add    %edx,%eax
   14324:	83 c0 08             	add    $0x8,%eax
   14327:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   1432a:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   14331:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14334:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   14337:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   1433e:	e9 be 00 00 00       	jmp    14401 <_DecodeDHT+0x1a0>
            spread >>= 1;
   14343:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   14346:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14349:	83 e8 01             	sub    $0x1,%eax
   1434c:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   14351:	0f b6 c0             	movzbl %al,%eax
   14354:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   14357:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1435b:	0f 84 9b 00 00 00    	je     143fc <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   14361:	8b 45 08             	mov    0x8(%ebp),%eax
   14364:	8b 40 0c             	mov    0xc(%eax),%eax
   14367:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   1436a:	7d 0e                	jge    1437a <_DecodeDHT+0x119>
   1436c:	8b 45 08             	mov    0x8(%ebp),%eax
   1436f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14375:	e9 cf 00 00 00       	jmp    14449 <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   1437a:	b8 10 00 00 00       	mov    $0x10,%eax
   1437f:	2b 45 f0             	sub    -0x10(%ebp),%eax
   14382:	8b 55 e0             	mov    -0x20(%ebp),%edx
   14385:	89 c1                	mov    %eax,%ecx
   14387:	d3 e2                	shl    %cl,%edx
   14389:	89 d0                	mov    %edx,%eax
   1438b:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   1438e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14392:	79 0e                	jns    143a2 <_DecodeDHT+0x141>
   14394:	8b 45 08             	mov    0x8(%ebp),%eax
   14397:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1439d:	e9 a7 00 00 00       	jmp    14449 <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   143a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   143a9:	eb 36                	jmp    143e1 <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   143ab:	8b 45 08             	mov    0x8(%ebp),%eax
   143ae:	8b 50 04             	mov    0x4(%eax),%edx
   143b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143b4:	01 d0                	add    %edx,%eax
   143b6:	0f b6 00             	movzbl (%eax),%eax
   143b9:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   143bb:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   143be:	eb 14                	jmp    143d4 <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   143c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   143c3:	89 c2                	mov    %eax,%edx
   143c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   143c8:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   143ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   143cd:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   143d0:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   143d4:	89 d8                	mov    %ebx,%eax
   143d6:	8d 58 ff             	lea    -0x1(%eax),%ebx
   143d9:	85 c0                	test   %eax,%eax
   143db:	75 e3                	jne    143c0 <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   143dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   143e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143e4:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   143e7:	7c c2                	jl     143ab <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   143e9:	83 ec 08             	sub    $0x8,%esp
   143ec:	ff 75 e0             	pushl  -0x20(%ebp)
   143ef:	ff 75 08             	pushl  0x8(%ebp)
   143f2:	e8 7f f7 ff ff       	call   13b76 <_Skip>
   143f7:	83 c4 10             	add    $0x10,%esp
   143fa:	eb 01                	jmp    143fd <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   143fc:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   143fd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14401:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   14405:	0f 8e 38 ff ff ff    	jle    14343 <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   1440b:	eb 0a                	jmp    14417 <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   1440d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14410:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   14413:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14417:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1441a:	8d 50 ff             	lea    -0x1(%eax),%edx
   1441d:	89 55 ec             	mov    %edx,-0x14(%ebp)
   14420:	85 c0                	test   %eax,%eax
   14422:	75 e9                	jne    1440d <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   14424:	8b 45 08             	mov    0x8(%ebp),%eax
   14427:	8b 40 0c             	mov    0xc(%eax),%eax
   1442a:	83 f8 10             	cmp    $0x10,%eax
   1442d:	0f 8f 55 fe ff ff    	jg     14288 <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14433:	8b 45 08             	mov    0x8(%ebp),%eax
   14436:	8b 40 0c             	mov    0xc(%eax),%eax
   14439:	85 c0                	test   %eax,%eax
   1443b:	74 0c                	je     14449 <_DecodeDHT+0x1e8>
   1443d:	8b 45 08             	mov    0x8(%ebp),%eax
   14440:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14446:	eb 01                	jmp    14449 <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   14448:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14449:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1444c:	c9                   	leave  
   1444d:	c3                   	ret    

0001444e <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   1444e:	55                   	push   %ebp
   1444f:	89 e5                	mov    %esp,%ebp
   14451:	53                   	push   %ebx
   14452:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   14455:	83 ec 0c             	sub    $0xc,%esp
   14458:	ff 75 08             	pushl  0x8(%ebp)
   1445b:	e8 62 f7 ff ff       	call   13bc2 <_DecodeLength>
   14460:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14463:	8b 45 08             	mov    0x8(%ebp),%eax
   14466:	8b 00                	mov    (%eax),%eax
   14468:	85 c0                	test   %eax,%eax
   1446a:	0f 85 e2 00 00 00    	jne    14552 <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   14470:	e9 b8 00 00 00       	jmp    1452d <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   14475:	8b 45 08             	mov    0x8(%ebp),%eax
   14478:	8b 40 04             	mov    0x4(%eax),%eax
   1447b:	0f b6 00             	movzbl (%eax),%eax
   1447e:	0f b6 c0             	movzbl %al,%eax
   14481:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   14484:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14487:	25 ec 00 00 00       	and    $0xec,%eax
   1448c:	85 c0                	test   %eax,%eax
   1448e:	74 0e                	je     1449e <_DecodeDQT+0x50>
   14490:	8b 45 08             	mov    0x8(%ebp),%eax
   14493:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14499:	e9 b5 00 00 00       	jmp    14553 <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   1449e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144a1:	83 e0 10             	and    $0x10,%eax
   144a4:	85 c0                	test   %eax,%eax
   144a6:	74 0e                	je     144b6 <_DecodeDQT+0x68>
   144a8:	8b 45 08             	mov    0x8(%ebp),%eax
   144ab:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   144b1:	e9 9d 00 00 00       	jmp    14553 <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   144b6:	8b 45 08             	mov    0x8(%ebp),%eax
   144b9:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   144bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144c2:	bb 01 00 00 00       	mov    $0x1,%ebx
   144c7:	89 c1                	mov    %eax,%ecx
   144c9:	d3 e3                	shl    %cl,%ebx
   144cb:	89 d8                	mov    %ebx,%eax
   144cd:	09 c2                	or     %eax,%edx
   144cf:	8b 45 08             	mov    0x8(%ebp),%eax
   144d2:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   144d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144db:	c1 e0 06             	shl    $0x6,%eax
   144de:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   144e4:	8b 45 08             	mov    0x8(%ebp),%eax
   144e7:	01 d0                	add    %edx,%eax
   144e9:	83 c0 08             	add    $0x8,%eax
   144ec:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   144ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   144f6:	eb 1f                	jmp    14517 <_DecodeDQT+0xc9>
   144f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   144fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   144fe:	01 c2                	add    %eax,%edx
   14500:	8b 45 08             	mov    0x8(%ebp),%eax
   14503:	8b 40 04             	mov    0x4(%eax),%eax
   14506:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14509:	83 c1 01             	add    $0x1,%ecx
   1450c:	01 c8                	add    %ecx,%eax
   1450e:	0f b6 00             	movzbl (%eax),%eax
   14511:	88 02                	mov    %al,(%edx)
   14513:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14517:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   1451b:	7e db                	jle    144f8 <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   1451d:	83 ec 08             	sub    $0x8,%esp
   14520:	6a 41                	push   $0x41
   14522:	ff 75 08             	pushl  0x8(%ebp)
   14525:	e8 4c f6 ff ff       	call   13b76 <_Skip>
   1452a:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   1452d:	8b 45 08             	mov    0x8(%ebp),%eax
   14530:	8b 40 0c             	mov    0xc(%eax),%eax
   14533:	83 f8 40             	cmp    $0x40,%eax
   14536:	0f 8f 39 ff ff ff    	jg     14475 <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   1453c:	8b 45 08             	mov    0x8(%ebp),%eax
   1453f:	8b 40 0c             	mov    0xc(%eax),%eax
   14542:	85 c0                	test   %eax,%eax
   14544:	74 0d                	je     14553 <_DecodeDQT+0x105>
   14546:	8b 45 08             	mov    0x8(%ebp),%eax
   14549:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1454f:	90                   	nop
   14550:	eb 01                	jmp    14553 <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   14552:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14553:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14556:	c9                   	leave  
   14557:	c3                   	ret    

00014558 <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   14558:	55                   	push   %ebp
   14559:	89 e5                	mov    %esp,%ebp
   1455b:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   1455e:	83 ec 0c             	sub    $0xc,%esp
   14561:	ff 75 08             	pushl  0x8(%ebp)
   14564:	e8 59 f6 ff ff       	call   13bc2 <_DecodeLength>
   14569:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1456c:	8b 45 08             	mov    0x8(%ebp),%eax
   1456f:	8b 00                	mov    (%eax),%eax
   14571:	85 c0                	test   %eax,%eax
   14573:	75 4a                	jne    145bf <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   14575:	8b 45 08             	mov    0x8(%ebp),%eax
   14578:	8b 40 0c             	mov    0xc(%eax),%eax
   1457b:	83 f8 01             	cmp    $0x1,%eax
   1457e:	7f 0b                	jg     1458b <_DecodeDRI+0x33>
   14580:	8b 45 08             	mov    0x8(%ebp),%eax
   14583:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14589:	eb 35                	jmp    145c0 <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   1458b:	8b 45 08             	mov    0x8(%ebp),%eax
   1458e:	8b 40 04             	mov    0x4(%eax),%eax
   14591:	83 ec 0c             	sub    $0xc,%esp
   14594:	50                   	push   %eax
   14595:	e8 8b f6 ff ff       	call   13c25 <_Decode2Bytes>
   1459a:	83 c4 10             	add    $0x10,%esp
   1459d:	89 c2                	mov    %eax,%edx
   1459f:	8b 45 08             	mov    0x8(%ebp),%eax
   145a2:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   145a8:	8b 45 08             	mov    0x8(%ebp),%eax
   145ab:	8b 40 0c             	mov    0xc(%eax),%eax
   145ae:	83 ec 08             	sub    $0x8,%esp
   145b1:	50                   	push   %eax
   145b2:	ff 75 08             	pushl  0x8(%ebp)
   145b5:	e8 bc f5 ff ff       	call   13b76 <_Skip>
   145ba:	83 c4 10             	add    $0x10,%esp
   145bd:	eb 01                	jmp    145c0 <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   145bf:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   145c0:	c9                   	leave  
   145c1:	c3                   	ret    

000145c2 <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   145c2:	55                   	push   %ebp
   145c3:	89 e5                	mov    %esp,%ebp
   145c5:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   145c8:	8b 45 08             	mov    0x8(%ebp),%eax
   145cb:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   145d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
   145d4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   145db:	83 ec 0c             	sub    $0xc,%esp
   145de:	ff 75 08             	pushl  0x8(%ebp)
   145e1:	e8 dc f5 ff ff       	call   13bc2 <_DecodeLength>
   145e6:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   145e9:	8b 45 08             	mov    0x8(%ebp),%eax
   145ec:	8b 00                	mov    (%eax),%eax
   145ee:	85 c0                	test   %eax,%eax
   145f0:	0f 85 c2 02 00 00    	jne    148b8 <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   145f6:	8b 45 08             	mov    0x8(%ebp),%eax
   145f9:	8b 50 0c             	mov    0xc(%eax),%edx
   145fc:	8b 45 08             	mov    0x8(%ebp),%eax
   145ff:	8b 40 28             	mov    0x28(%eax),%eax
   14602:	83 c0 02             	add    $0x2,%eax
   14605:	01 c0                	add    %eax,%eax
   14607:	39 c2                	cmp    %eax,%edx
   14609:	7c 16                	jl     14621 <_DecodeSOS+0x5f>
   1460b:	8b 45 08             	mov    0x8(%ebp),%eax
   1460e:	8b 40 04             	mov    0x4(%eax),%eax
   14611:	0f b6 00             	movzbl (%eax),%eax
   14614:	0f b6 d0             	movzbl %al,%edx
   14617:	8b 45 08             	mov    0x8(%ebp),%eax
   1461a:	8b 40 28             	mov    0x28(%eax),%eax
   1461d:	39 c2                	cmp    %eax,%edx
   1461f:	74 0e                	je     1462f <_DecodeSOS+0x6d>
   14621:	8b 45 08             	mov    0x8(%ebp),%eax
   14624:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1462a:	e9 8d 02 00 00       	jmp    148bc <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   1462f:	83 ec 08             	sub    $0x8,%esp
   14632:	6a 01                	push   $0x1
   14634:	ff 75 08             	pushl  0x8(%ebp)
   14637:	e8 3a f5 ff ff       	call   13b76 <_Skip>
   1463c:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1463f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14646:	8b 45 08             	mov    0x8(%ebp),%eax
   14649:	83 c0 2c             	add    $0x2c,%eax
   1464c:	89 45 dc             	mov    %eax,-0x24(%ebp)
   1464f:	e9 ba 00 00 00       	jmp    1470e <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   14654:	8b 45 08             	mov    0x8(%ebp),%eax
   14657:	8b 40 04             	mov    0x4(%eax),%eax
   1465a:	0f b6 00             	movzbl (%eax),%eax
   1465d:	0f b6 d0             	movzbl %al,%edx
   14660:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14663:	8b 00                	mov    (%eax),%eax
   14665:	39 c2                	cmp    %eax,%edx
   14667:	74 0e                	je     14677 <_DecodeSOS+0xb5>
   14669:	8b 45 08             	mov    0x8(%ebp),%eax
   1466c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14672:	e9 45 02 00 00       	jmp    148bc <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   14677:	8b 45 08             	mov    0x8(%ebp),%eax
   1467a:	8b 40 04             	mov    0x4(%eax),%eax
   1467d:	83 c0 01             	add    $0x1,%eax
   14680:	0f b6 00             	movzbl (%eax),%eax
   14683:	0f b6 c0             	movzbl %al,%eax
   14686:	25 ec 00 00 00       	and    $0xec,%eax
   1468b:	85 c0                	test   %eax,%eax
   1468d:	74 0e                	je     1469d <_DecodeSOS+0xdb>
   1468f:	8b 45 08             	mov    0x8(%ebp),%eax
   14692:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14698:	e9 1f 02 00 00       	jmp    148bc <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   1469d:	8b 45 08             	mov    0x8(%ebp),%eax
   146a0:	8b 40 04             	mov    0x4(%eax),%eax
   146a3:	83 c0 01             	add    $0x1,%eax
   146a6:	0f b6 00             	movzbl (%eax),%eax
   146a9:	0f b6 c0             	movzbl %al,%eax
   146ac:	83 e0 02             	and    $0x2,%eax
   146af:	85 c0                	test   %eax,%eax
   146b1:	74 0e                	je     146c1 <_DecodeSOS+0xff>
   146b3:	8b 45 08             	mov    0x8(%ebp),%eax
   146b6:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   146bc:	e9 fb 01 00 00       	jmp    148bc <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   146c1:	8b 45 08             	mov    0x8(%ebp),%eax
   146c4:	8b 40 04             	mov    0x4(%eax),%eax
   146c7:	83 c0 01             	add    $0x1,%eax
   146ca:	0f b6 00             	movzbl (%eax),%eax
   146cd:	c0 e8 04             	shr    $0x4,%al
   146d0:	0f b6 d0             	movzbl %al,%edx
   146d3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   146d6:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   146d9:	8b 45 08             	mov    0x8(%ebp),%eax
   146dc:	8b 40 04             	mov    0x4(%eax),%eax
   146df:	83 c0 01             	add    $0x1,%eax
   146e2:	0f b6 00             	movzbl (%eax),%eax
   146e5:	0f b6 c0             	movzbl %al,%eax
   146e8:	83 e0 01             	and    $0x1,%eax
   146eb:	83 c8 02             	or     $0x2,%eax
   146ee:	89 c2                	mov    %eax,%edx
   146f0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   146f3:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   146f6:	83 ec 08             	sub    $0x8,%esp
   146f9:	6a 02                	push   $0x2
   146fb:	ff 75 08             	pushl  0x8(%ebp)
   146fe:	e8 73 f4 ff ff       	call   13b76 <_Skip>
   14703:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14706:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1470a:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   1470e:	8b 45 08             	mov    0x8(%ebp),%eax
   14711:	8b 40 28             	mov    0x28(%eax),%eax
   14714:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14717:	0f 8f 37 ff ff ff    	jg     14654 <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   1471d:	8b 45 08             	mov    0x8(%ebp),%eax
   14720:	8b 40 04             	mov    0x4(%eax),%eax
   14723:	0f b6 00             	movzbl (%eax),%eax
   14726:	84 c0                	test   %al,%al
   14728:	75 10                	jne    1473a <_DecodeSOS+0x178>
   1472a:	8b 45 08             	mov    0x8(%ebp),%eax
   1472d:	8b 40 04             	mov    0x4(%eax),%eax
   14730:	83 c0 01             	add    $0x1,%eax
   14733:	0f b6 00             	movzbl (%eax),%eax
   14736:	3c 3f                	cmp    $0x3f,%al
   14738:	74 0e                	je     14748 <_DecodeSOS+0x186>
   1473a:	8b 45 08             	mov    0x8(%ebp),%eax
   1473d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14743:	e9 74 01 00 00       	jmp    148bc <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   14748:	8b 45 08             	mov    0x8(%ebp),%eax
   1474b:	8b 40 04             	mov    0x4(%eax),%eax
   1474e:	83 c0 02             	add    $0x2,%eax
   14751:	0f b6 00             	movzbl (%eax),%eax
   14754:	84 c0                	test   %al,%al
   14756:	74 0e                	je     14766 <_DecodeSOS+0x1a4>
   14758:	8b 45 08             	mov    0x8(%ebp),%eax
   1475b:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14761:	e9 56 01 00 00       	jmp    148bc <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   14766:	8b 45 08             	mov    0x8(%ebp),%eax
   14769:	8b 40 0c             	mov    0xc(%eax),%eax
   1476c:	83 ec 08             	sub    $0x8,%esp
   1476f:	50                   	push   %eax
   14770:	ff 75 08             	pushl  0x8(%ebp)
   14773:	e8 fe f3 ff ff       	call   13b76 <_Skip>
   14778:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   1477b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   14782:	e9 17 01 00 00       	jmp    1489e <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   14787:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1478e:	e9 f8 00 00 00       	jmp    1488b <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14793:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1479a:	8b 45 08             	mov    0x8(%ebp),%eax
   1479d:	83 c0 2c             	add    $0x2c,%eax
   147a0:	89 45 dc             	mov    %eax,-0x24(%ebp)
   147a3:	e9 8d 00 00 00       	jmp    14835 <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   147a8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   147af:	eb 71                	jmp    14822 <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   147b1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   147b8:	eb 59                	jmp    14813 <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   147ba:	8b 45 dc             	mov    -0x24(%ebp),%eax
   147bd:	8b 50 28             	mov    0x28(%eax),%edx
   147c0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   147c3:	8b 40 08             	mov    0x8(%eax),%eax
   147c6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   147ca:	89 c1                	mov    %eax,%ecx
   147cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   147cf:	01 c1                	add    %eax,%ecx
   147d1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   147d4:	8b 40 14             	mov    0x14(%eax),%eax
   147d7:	0f af c8             	imul   %eax,%ecx
   147da:	8b 45 dc             	mov    -0x24(%ebp),%eax
   147dd:	8b 40 04             	mov    0x4(%eax),%eax
   147e0:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   147e4:	01 c1                	add    %eax,%ecx
   147e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   147e9:	01 c8                	add    %ecx,%eax
   147eb:	c1 e0 03             	shl    $0x3,%eax
   147ee:	01 d0                	add    %edx,%eax
   147f0:	50                   	push   %eax
   147f1:	ff 75 dc             	pushl  -0x24(%ebp)
   147f4:	ff 75 0c             	pushl  0xc(%ebp)
   147f7:	ff 75 08             	pushl  0x8(%ebp)
   147fa:	e8 bf 00 00 00       	call   148be <_DecodeBlock>
   147ff:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   14802:	8b 45 08             	mov    0x8(%ebp),%eax
   14805:	8b 00                	mov    (%eax),%eax
   14807:	85 c0                	test   %eax,%eax
   14809:	0f 85 ac 00 00 00    	jne    148bb <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   1480f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   14813:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14816:	8b 40 04             	mov    0x4(%eax),%eax
   14819:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1481c:	7f 9c                	jg     147ba <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   1481e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   14822:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14825:	8b 40 08             	mov    0x8(%eax),%eax
   14828:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1482b:	7f 84                	jg     147b1 <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   1482d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14831:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14835:	8b 45 08             	mov    0x8(%ebp),%eax
   14838:	8b 40 28             	mov    0x28(%eax),%eax
   1483b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1483e:	0f 8f 64 ff ff ff    	jg     147a8 <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   14844:	8b 45 08             	mov    0x8(%ebp),%eax
   14847:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   1484d:	85 c0                	test   %eax,%eax
   1484f:	74 36                	je     14887 <_DecodeSOS+0x2c5>
   14851:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   14855:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14859:	75 2c                	jne    14887 <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   1485b:	83 ec 0c             	sub    $0xc,%esp
   1485e:	ff 75 08             	pushl  0x8(%ebp)
   14861:	e8 9f 0a 00 00       	call   15305 <_ByteAlign>
   14866:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   14869:	83 ec 08             	sub    $0x8,%esp
   1486c:	6a 10                	push   $0x10
   1486e:	ff 75 08             	pushl  0x8(%ebp)
   14871:	e8 ce 04 00 00       	call   14d44 <_GetBits>
   14876:	83 c4 10             	add    $0x10,%esp
   14879:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   1487c:	8b 45 08             	mov    0x8(%ebp),%eax
   1487f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14885:	eb 35                	jmp    148bc <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   14887:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1488b:	8b 45 08             	mov    0x8(%ebp),%eax
   1488e:	8b 40 18             	mov    0x18(%eax),%eax
   14891:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14894:	0f 8f f9 fe ff ff    	jg     14793 <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   1489a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1489e:	8b 45 08             	mov    0x8(%ebp),%eax
   148a1:	8b 40 1c             	mov    0x1c(%eax),%eax
   148a4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   148a7:	0f 8f da fe ff ff    	jg     14787 <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   148ad:	8b 45 08             	mov    0x8(%ebp),%eax
   148b0:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   148b6:	eb 04                	jmp    148bc <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   148b8:	90                   	nop
   148b9:	eb 01                	jmp    148bc <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   148bb:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   148bc:	c9                   	leave  
   148bd:	c3                   	ret    

000148be <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   148be:	55                   	push   %ebp
   148bf:	89 e5                	mov    %esp,%ebp
   148c1:	53                   	push   %ebx
   148c2:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   148c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   148cc:	8b 45 08             	mov    0x8(%ebp),%eax
   148cf:	05 c0 01 08 00       	add    $0x801c0,%eax
   148d4:	83 ec 04             	sub    $0x4,%esp
   148d7:	68 00 01 00 00       	push   $0x100
   148dc:	6a 00                	push   $0x0
   148de:	50                   	push   %eax
   148df:	e8 04 b8 fe ff       	call   e8 <memset>
   148e4:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   148e7:	8b 45 10             	mov    0x10(%ebp),%eax
   148ea:	8b 40 20             	mov    0x20(%eax),%eax
   148ed:	c1 e0 11             	shl    $0x11,%eax
   148f0:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   148f6:	8b 45 08             	mov    0x8(%ebp),%eax
   148f9:	01 d0                	add    %edx,%eax
   148fb:	83 c0 08             	add    $0x8,%eax
   148fe:	83 ec 04             	sub    $0x4,%esp
   14901:	6a 00                	push   $0x0
   14903:	50                   	push   %eax
   14904:	ff 75 08             	pushl  0x8(%ebp)
   14907:	e8 86 01 00 00       	call   14a92 <_GetVLC>
   1490c:	83 c4 10             	add    $0x10,%esp
   1490f:	89 c2                	mov    %eax,%edx
   14911:	8b 45 10             	mov    0x10(%ebp),%eax
   14914:	8b 40 24             	mov    0x24(%eax),%eax
   14917:	01 c2                	add    %eax,%edx
   14919:	8b 45 10             	mov    0x10(%ebp),%eax
   1491c:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   1491f:	8b 45 10             	mov    0x10(%ebp),%eax
   14922:	8b 50 24             	mov    0x24(%eax),%edx
   14925:	8b 45 10             	mov    0x10(%ebp),%eax
   14928:	8b 48 18             	mov    0x18(%eax),%ecx
   1492b:	8b 45 08             	mov    0x8(%ebp),%eax
   1492e:	c1 e1 06             	shl    $0x6,%ecx
   14931:	01 c8                	add    %ecx,%eax
   14933:	05 b8 00 00 00       	add    $0xb8,%eax
   14938:	0f b6 00             	movzbl (%eax),%eax
   1493b:	0f b6 c0             	movzbl %al,%eax
   1493e:	0f af d0             	imul   %eax,%edx
   14941:	8b 45 08             	mov    0x8(%ebp),%eax
   14944:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   1494a:	8b 45 10             	mov    0x10(%ebp),%eax
   1494d:	8b 40 1c             	mov    0x1c(%eax),%eax
   14950:	c1 e0 11             	shl    $0x11,%eax
   14953:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14959:	8b 45 08             	mov    0x8(%ebp),%eax
   1495c:	01 d0                	add    %edx,%eax
   1495e:	8d 50 08             	lea    0x8(%eax),%edx
   14961:	83 ec 04             	sub    $0x4,%esp
   14964:	8d 45 ef             	lea    -0x11(%ebp),%eax
   14967:	50                   	push   %eax
   14968:	52                   	push   %edx
   14969:	ff 75 08             	pushl  0x8(%ebp)
   1496c:	e8 21 01 00 00       	call   14a92 <_GetVLC>
   14971:	83 c4 10             	add    $0x10,%esp
   14974:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   14977:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   1497b:	84 c0                	test   %al,%al
   1497d:	0f 84 92 00 00 00    	je     14a15 <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   14983:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14987:	0f b6 c0             	movzbl %al,%eax
   1498a:	83 e0 0f             	and    $0xf,%eax
   1498d:	85 c0                	test   %eax,%eax
   1498f:	75 16                	jne    149a7 <_DecodeBlock+0xe9>
   14991:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14995:	3c f0                	cmp    $0xf0,%al
   14997:	74 0e                	je     149a7 <_DecodeBlock+0xe9>
   14999:	8b 45 08             	mov    0x8(%ebp),%eax
   1499c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   149a2:	e9 e6 00 00 00       	jmp    14a8d <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   149a7:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149ab:	c0 e8 04             	shr    $0x4,%al
   149ae:	0f b6 c0             	movzbl %al,%eax
   149b1:	83 c0 01             	add    $0x1,%eax
   149b4:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   149b7:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   149bb:	7e 0e                	jle    149cb <_DecodeBlock+0x10d>
   149bd:	8b 45 08             	mov    0x8(%ebp),%eax
   149c0:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   149c6:	e9 c2 00 00 00       	jmp    14a8d <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   149cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
   149ce:	8b 45 0c             	mov    0xc(%ebp),%eax
   149d1:	01 d0                	add    %edx,%eax
   149d3:	0f b6 00             	movzbl (%eax),%eax
   149d6:	0f be c8             	movsbl %al,%ecx
   149d9:	8b 45 10             	mov    0x10(%ebp),%eax
   149dc:	8b 50 18             	mov    0x18(%eax),%edx
   149df:	8b 45 08             	mov    0x8(%ebp),%eax
   149e2:	c1 e2 06             	shl    $0x6,%edx
   149e5:	01 c2                	add    %eax,%edx
   149e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   149ea:	01 d0                	add    %edx,%eax
   149ec:	05 b8 00 00 00       	add    $0xb8,%eax
   149f1:	0f b6 00             	movzbl (%eax),%eax
   149f4:	0f b6 c0             	movzbl %al,%eax
   149f7:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   149fb:	89 c2                	mov    %eax,%edx
   149fd:	8b 45 08             	mov    0x8(%ebp),%eax
   14a00:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   14a06:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   14a09:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   14a0d:	0f 8e 37 ff ff ff    	jle    1494a <_DecodeBlock+0x8c>
   14a13:	eb 01                	jmp    14a16 <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   14a15:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   14a16:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14a1d:	eb 24                	jmp    14a43 <_DecodeBlock+0x185>
   14a1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a22:	05 70 00 02 00       	add    $0x20070,%eax
   14a27:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14a2e:	8b 45 08             	mov    0x8(%ebp),%eax
   14a31:	01 d0                	add    %edx,%eax
   14a33:	83 ec 0c             	sub    $0xc,%esp
   14a36:	50                   	push   %eax
   14a37:	e8 32 03 00 00       	call   14d6e <_RowIDCT>
   14a3c:	83 c4 10             	add    $0x10,%esp
   14a3f:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   14a43:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14a47:	7e d6                	jle    14a1f <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   14a49:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14a50:	eb 35                	jmp    14a87 <_DecodeBlock+0x1c9>
   14a52:	8b 45 10             	mov    0x10(%ebp),%eax
   14a55:	8b 40 14             	mov    0x14(%eax),%eax
   14a58:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14a5b:	8b 55 14             	mov    0x14(%ebp),%edx
   14a5e:	01 d1                	add    %edx,%ecx
   14a60:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14a63:	81 c2 70 00 02 00    	add    $0x20070,%edx
   14a69:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   14a70:	8b 55 08             	mov    0x8(%ebp),%edx
   14a73:	01 da                	add    %ebx,%edx
   14a75:	83 ec 04             	sub    $0x4,%esp
   14a78:	50                   	push   %eax
   14a79:	51                   	push   %ecx
   14a7a:	52                   	push   %edx
   14a7b:	e8 7b 05 00 00       	call   14ffb <_ColIDCT>
   14a80:	83 c4 10             	add    $0x10,%esp
   14a83:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14a87:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14a8b:	7e c5                	jle    14a52 <_DecodeBlock+0x194>
}
   14a8d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14a90:	c9                   	leave  
   14a91:	c3                   	ret    

00014a92 <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   14a92:	55                   	push   %ebp
   14a93:	89 e5                	mov    %esp,%ebp
   14a95:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   14a98:	83 ec 08             	sub    $0x8,%esp
   14a9b:	6a 10                	push   $0x10
   14a9d:	ff 75 08             	pushl  0x8(%ebp)
   14aa0:	e8 c2 00 00 00       	call   14b67 <_ShowBits>
   14aa5:	83 c4 10             	add    $0x10,%esp
   14aa8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   14aab:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14aae:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14ab1:	8b 45 0c             	mov    0xc(%ebp),%eax
   14ab4:	01 d0                	add    %edx,%eax
   14ab6:	0f b6 00             	movzbl (%eax),%eax
   14ab9:	0f b6 c0             	movzbl %al,%eax
   14abc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   14abf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14ac3:	75 13                	jne    14ad8 <_GetVLC+0x46>
   14ac5:	8b 45 08             	mov    0x8(%ebp),%eax
   14ac8:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14ace:	b8 00 00 00 00       	mov    $0x0,%eax
   14ad3:	e9 8d 00 00 00       	jmp    14b65 <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   14ad8:	83 ec 08             	sub    $0x8,%esp
   14adb:	ff 75 f0             	pushl  -0x10(%ebp)
   14ade:	ff 75 08             	pushl  0x8(%ebp)
   14ae1:	e8 25 02 00 00       	call   14d0b <_SkipBits>
   14ae6:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   14ae9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14aec:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14aef:	8b 45 0c             	mov    0xc(%ebp),%eax
   14af2:	01 d0                	add    %edx,%eax
   14af4:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   14af8:	0f b6 c0             	movzbl %al,%eax
   14afb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   14afe:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14b02:	74 0a                	je     14b0e <_GetVLC+0x7c>
   14b04:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b07:	89 c2                	mov    %eax,%edx
   14b09:	8b 45 10             	mov    0x10(%ebp),%eax
   14b0c:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   14b0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b11:	83 e0 0f             	and    $0xf,%eax
   14b14:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   14b17:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14b1b:	75 07                	jne    14b24 <_GetVLC+0x92>
   14b1d:	b8 00 00 00 00       	mov    $0x0,%eax
   14b22:	eb 41                	jmp    14b65 <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   14b24:	83 ec 08             	sub    $0x8,%esp
   14b27:	ff 75 f0             	pushl  -0x10(%ebp)
   14b2a:	ff 75 08             	pushl  0x8(%ebp)
   14b2d:	e8 12 02 00 00       	call   14d44 <_GetBits>
   14b32:	83 c4 10             	add    $0x10,%esp
   14b35:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   14b38:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14b3b:	83 e8 01             	sub    $0x1,%eax
   14b3e:	ba 01 00 00 00       	mov    $0x1,%edx
   14b43:	89 c1                	mov    %eax,%ecx
   14b45:	d3 e2                	shl    %cl,%edx
   14b47:	89 d0                	mov    %edx,%eax
   14b49:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14b4c:	7e 14                	jle    14b62 <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   14b4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14b51:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   14b56:	89 c1                	mov    %eax,%ecx
   14b58:	d3 e2                	shl    %cl,%edx
   14b5a:	89 d0                	mov    %edx,%eax
   14b5c:	83 c0 01             	add    $0x1,%eax
   14b5f:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   14b62:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14b65:	c9                   	leave  
   14b66:	c3                   	ret    

00014b67 <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   14b67:	55                   	push   %ebp
   14b68:	89 e5                	mov    %esp,%ebp
   14b6a:	53                   	push   %ebx
   14b6b:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   14b6e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14b72:	0f 85 4f 01 00 00    	jne    14cc7 <_ShowBits+0x160>
   14b78:	b8 00 00 00 00       	mov    $0x0,%eax
   14b7d:	e9 83 01 00 00       	jmp    14d05 <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   14b82:	8b 45 08             	mov    0x8(%ebp),%eax
   14b85:	8b 40 08             	mov    0x8(%eax),%eax
   14b88:	85 c0                	test   %eax,%eax
   14b8a:	7f 33                	jg     14bbf <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   14b8c:	8b 45 08             	mov    0x8(%ebp),%eax
   14b8f:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14b95:	c1 e0 08             	shl    $0x8,%eax
   14b98:	0c ff                	or     $0xff,%al
   14b9a:	89 c2                	mov    %eax,%edx
   14b9c:	8b 45 08             	mov    0x8(%ebp),%eax
   14b9f:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   14ba5:	8b 45 08             	mov    0x8(%ebp),%eax
   14ba8:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14bae:	8d 50 08             	lea    0x8(%eax),%edx
   14bb1:	8b 45 08             	mov    0x8(%ebp),%eax
   14bb4:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   14bba:	e9 08 01 00 00       	jmp    14cc7 <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   14bbf:	8b 45 08             	mov    0x8(%ebp),%eax
   14bc2:	8b 40 04             	mov    0x4(%eax),%eax
   14bc5:	8d 48 01             	lea    0x1(%eax),%ecx
   14bc8:	8b 55 08             	mov    0x8(%ebp),%edx
   14bcb:	89 4a 04             	mov    %ecx,0x4(%edx)
   14bce:	0f b6 00             	movzbl (%eax),%eax
   14bd1:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   14bd4:	8b 45 08             	mov    0x8(%ebp),%eax
   14bd7:	8b 40 08             	mov    0x8(%eax),%eax
   14bda:	8d 50 ff             	lea    -0x1(%eax),%edx
   14bdd:	8b 45 08             	mov    0x8(%ebp),%eax
   14be0:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   14be3:	8b 45 08             	mov    0x8(%ebp),%eax
   14be6:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14bec:	8d 50 08             	lea    0x8(%eax),%edx
   14bef:	8b 45 08             	mov    0x8(%ebp),%eax
   14bf2:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   14bf8:	8b 45 08             	mov    0x8(%ebp),%eax
   14bfb:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14c01:	c1 e0 08             	shl    $0x8,%eax
   14c04:	89 c2                	mov    %eax,%edx
   14c06:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   14c0a:	09 c2                	or     %eax,%edx
   14c0c:	8b 45 08             	mov    0x8(%ebp),%eax
   14c0f:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   14c15:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   14c19:	0f 85 a8 00 00 00    	jne    14cc7 <_ShowBits+0x160>
            if(ctx->size){
   14c1f:	8b 45 08             	mov    0x8(%ebp),%eax
   14c22:	8b 40 08             	mov    0x8(%eax),%eax
   14c25:	85 c0                	test   %eax,%eax
   14c27:	0f 84 91 00 00 00    	je     14cbe <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   14c2d:	8b 45 08             	mov    0x8(%ebp),%eax
   14c30:	8b 40 04             	mov    0x4(%eax),%eax
   14c33:	8d 48 01             	lea    0x1(%eax),%ecx
   14c36:	8b 55 08             	mov    0x8(%ebp),%edx
   14c39:	89 4a 04             	mov    %ecx,0x4(%edx)
   14c3c:	0f b6 00             	movzbl (%eax),%eax
   14c3f:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   14c42:	8b 45 08             	mov    0x8(%ebp),%eax
   14c45:	8b 40 08             	mov    0x8(%eax),%eax
   14c48:	8d 50 ff             	lea    -0x1(%eax),%edx
   14c4b:	8b 45 08             	mov    0x8(%ebp),%eax
   14c4e:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   14c51:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14c55:	85 c0                	test   %eax,%eax
   14c57:	74 62                	je     14cbb <_ShowBits+0x154>
   14c59:	3d d9 00 00 00       	cmp    $0xd9,%eax
   14c5e:	75 0c                	jne    14c6c <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   14c60:	8b 45 08             	mov    0x8(%ebp),%eax
   14c63:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   14c6a:	eb 5b                	jmp    14cc7 <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   14c6c:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14c70:	25 f8 00 00 00       	and    $0xf8,%eax
   14c75:	3d d0 00 00 00       	cmp    $0xd0,%eax
   14c7a:	74 0b                	je     14c87 <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   14c7c:	8b 45 08             	mov    0x8(%ebp),%eax
   14c7f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14c85:	eb 40                	jmp    14cc7 <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   14c87:	8b 45 08             	mov    0x8(%ebp),%eax
   14c8a:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14c90:	c1 e0 08             	shl    $0x8,%eax
   14c93:	89 c2                	mov    %eax,%edx
   14c95:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14c99:	09 c2                	or     %eax,%edx
   14c9b:	8b 45 08             	mov    0x8(%ebp),%eax
   14c9e:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   14ca4:	8b 45 08             	mov    0x8(%ebp),%eax
   14ca7:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14cad:	8d 50 08             	lea    0x8(%eax),%edx
   14cb0:	8b 45 08             	mov    0x8(%ebp),%eax
   14cb3:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   14cb9:	eb 0c                	jmp    14cc7 <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   14cbb:	90                   	nop
   14cbc:	eb 09                	jmp    14cc7 <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   14cbe:	8b 45 08             	mov    0x8(%ebp),%eax
   14cc1:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   14cc7:	8b 45 08             	mov    0x8(%ebp),%eax
   14cca:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14cd0:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14cd3:	0f 8c a9 fe ff ff    	jl     14b82 <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   14cd9:	8b 45 08             	mov    0x8(%ebp),%eax
   14cdc:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   14ce2:	8b 45 08             	mov    0x8(%ebp),%eax
   14ce5:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14ceb:	2b 45 0c             	sub    0xc(%ebp),%eax
   14cee:	89 c1                	mov    %eax,%ecx
   14cf0:	d3 fa                	sar    %cl,%edx
   14cf2:	8b 45 0c             	mov    0xc(%ebp),%eax
   14cf5:	bb 01 00 00 00       	mov    $0x1,%ebx
   14cfa:	89 c1                	mov    %eax,%ecx
   14cfc:	d3 e3                	shl    %cl,%ebx
   14cfe:	89 d8                	mov    %ebx,%eax
   14d00:	83 e8 01             	sub    $0x1,%eax
   14d03:	21 d0                	and    %edx,%eax
}
   14d05:	83 c4 10             	add    $0x10,%esp
   14d08:	5b                   	pop    %ebx
   14d09:	5d                   	pop    %ebp
   14d0a:	c3                   	ret    

00014d0b <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   14d0b:	55                   	push   %ebp
   14d0c:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   14d0e:	8b 45 08             	mov    0x8(%ebp),%eax
   14d11:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d17:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14d1a:	7d 0e                	jge    14d2a <_SkipBits+0x1f>
   14d1c:	ff 75 0c             	pushl  0xc(%ebp)
   14d1f:	ff 75 08             	pushl  0x8(%ebp)
   14d22:	e8 40 fe ff ff       	call   14b67 <_ShowBits>
   14d27:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   14d2a:	8b 45 08             	mov    0x8(%ebp),%eax
   14d2d:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d33:	2b 45 0c             	sub    0xc(%ebp),%eax
   14d36:	89 c2                	mov    %eax,%edx
   14d38:	8b 45 08             	mov    0x8(%ebp),%eax
   14d3b:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   14d41:	90                   	nop
   14d42:	c9                   	leave  
   14d43:	c3                   	ret    

00014d44 <_GetBits>:

int _GetBits(Context* ctx, int bits){
   14d44:	55                   	push   %ebp
   14d45:	89 e5                	mov    %esp,%ebp
   14d47:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   14d4a:	ff 75 0c             	pushl  0xc(%ebp)
   14d4d:	ff 75 08             	pushl  0x8(%ebp)
   14d50:	e8 12 fe ff ff       	call   14b67 <_ShowBits>
   14d55:	83 c4 08             	add    $0x8,%esp
   14d58:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   14d5b:	ff 75 0c             	pushl  0xc(%ebp)
   14d5e:	ff 75 08             	pushl  0x8(%ebp)
   14d61:	e8 a5 ff ff ff       	call   14d0b <_SkipBits>
   14d66:	83 c4 08             	add    $0x8,%esp
    return res;
   14d69:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   14d6c:	c9                   	leave  
   14d6d:	c3                   	ret    

00014d6e <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   14d6e:	55                   	push   %ebp
   14d6f:	89 e5                	mov    %esp,%ebp
   14d71:	57                   	push   %edi
   14d72:	56                   	push   %esi
   14d73:	53                   	push   %ebx
   14d74:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14d77:	8b 45 08             	mov    0x8(%ebp),%eax
   14d7a:	83 c0 10             	add    $0x10,%eax
   14d7d:	8b 00                	mov    (%eax),%eax
   14d7f:	c1 e0 0b             	shl    $0xb,%eax
   14d82:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   14d85:	8b 45 08             	mov    0x8(%ebp),%eax
   14d88:	8b 40 18             	mov    0x18(%eax),%eax
   14d8b:	89 45 ec             	mov    %eax,-0x14(%ebp)
   14d8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14d91:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   14d94:	8b 55 08             	mov    0x8(%ebp),%edx
   14d97:	8b 52 08             	mov    0x8(%edx),%edx
   14d9a:	89 55 e8             	mov    %edx,-0x18(%ebp)
   14d9d:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   14da0:	8b 55 08             	mov    0x8(%ebp),%edx
   14da3:	8b 52 04             	mov    0x4(%edx),%edx
   14da6:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   14da9:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   14dac:	8b 55 08             	mov    0x8(%ebp),%edx
   14daf:	8b 52 1c             	mov    0x1c(%edx),%edx
   14db2:	89 55 e0             	mov    %edx,-0x20(%ebp)
   14db5:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   14db8:	8b 55 08             	mov    0x8(%ebp),%edx
   14dbb:	8b 52 14             	mov    0x14(%edx),%edx
   14dbe:	89 55 dc             	mov    %edx,-0x24(%ebp)
   14dc1:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   14dc4:	8b 55 08             	mov    0x8(%ebp),%edx
   14dc7:	8b 52 0c             	mov    0xc(%edx),%edx
   14dca:	89 55 d8             	mov    %edx,-0x28(%ebp)
   14dcd:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14dd0:	85 c0                	test   %eax,%eax
   14dd2:	75 68                	jne    14e3c <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   14dd4:	8b 45 08             	mov    0x8(%ebp),%eax
   14dd7:	8d 48 04             	lea    0x4(%eax),%ecx
   14dda:	8b 45 08             	mov    0x8(%ebp),%eax
   14ddd:	8d 58 08             	lea    0x8(%eax),%ebx
   14de0:	8b 45 08             	mov    0x8(%ebp),%eax
   14de3:	8d 70 0c             	lea    0xc(%eax),%esi
   14de6:	8b 45 08             	mov    0x8(%ebp),%eax
   14de9:	8d 78 10             	lea    0x10(%eax),%edi
   14dec:	8b 45 08             	mov    0x8(%ebp),%eax
   14def:	83 c0 14             	add    $0x14,%eax
   14df2:	89 45 c0             	mov    %eax,-0x40(%ebp)
   14df5:	8b 45 08             	mov    0x8(%ebp),%eax
   14df8:	83 c0 18             	add    $0x18,%eax
   14dfb:	89 45 bc             	mov    %eax,-0x44(%ebp)
   14dfe:	8b 45 08             	mov    0x8(%ebp),%eax
   14e01:	8d 50 1c             	lea    0x1c(%eax),%edx
   14e04:	8b 45 08             	mov    0x8(%ebp),%eax
   14e07:	8b 00                	mov    (%eax),%eax
   14e09:	c1 e0 03             	shl    $0x3,%eax
   14e0c:	89 02                	mov    %eax,(%edx)
   14e0e:	8b 02                	mov    (%edx),%eax
   14e10:	8b 55 bc             	mov    -0x44(%ebp),%edx
   14e13:	89 02                	mov    %eax,(%edx)
   14e15:	89 d0                	mov    %edx,%eax
   14e17:	8b 00                	mov    (%eax),%eax
   14e19:	8b 55 c0             	mov    -0x40(%ebp),%edx
   14e1c:	89 02                	mov    %eax,(%edx)
   14e1e:	89 d0                	mov    %edx,%eax
   14e20:	8b 00                	mov    (%eax),%eax
   14e22:	89 07                	mov    %eax,(%edi)
   14e24:	8b 07                	mov    (%edi),%eax
   14e26:	89 06                	mov    %eax,(%esi)
   14e28:	8b 06                	mov    (%esi),%eax
   14e2a:	89 03                	mov    %eax,(%ebx)
   14e2c:	8b 03                	mov    (%ebx),%eax
   14e2e:	89 01                	mov    %eax,(%ecx)
   14e30:	8b 11                	mov    (%ecx),%edx
   14e32:	8b 45 08             	mov    0x8(%ebp),%eax
   14e35:	89 10                	mov    %edx,(%eax)
        return;
   14e37:	e9 b7 01 00 00       	jmp    14ff3 <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   14e3c:	8b 45 08             	mov    0x8(%ebp),%eax
   14e3f:	8b 00                	mov    (%eax),%eax
   14e41:	c1 e0 0b             	shl    $0xb,%eax
   14e44:	83 e8 80             	sub    $0xffffff80,%eax
   14e47:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   14e4a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14e4d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14e50:	01 d0                	add    %edx,%eax
   14e52:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   14e58:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   14e5b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14e5e:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   14e64:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14e67:	01 d0                	add    %edx,%eax
   14e69:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   14e6c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14e6f:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   14e75:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14e78:	01 d0                	add    %edx,%eax
   14e7a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   14e7d:	8b 55 dc             	mov    -0x24(%ebp),%edx
   14e80:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14e83:	01 d0                	add    %edx,%eax
   14e85:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   14e8b:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   14e8e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14e91:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   14e97:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14e9a:	01 d0                	add    %edx,%eax
   14e9c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   14e9f:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14ea2:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   14ea8:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14eab:	01 d0                	add    %edx,%eax
   14ead:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   14eb0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   14eb3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14eb6:	01 d0                	add    %edx,%eax
   14eb8:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   14ebb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ebe:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   14ec1:	8b 55 e8             	mov    -0x18(%ebp),%edx
   14ec4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14ec7:	01 d0                	add    %edx,%eax
   14ec9:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14ecf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   14ed2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14ed5:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   14edb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ede:	01 d0                	add    %edx,%eax
   14ee0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   14ee3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14ee6:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   14eec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14eef:	01 d0                	add    %edx,%eax
   14ef1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   14ef4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14ef7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14efa:	01 d0                	add    %edx,%eax
   14efc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   14eff:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f02:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   14f05:	8b 55 e0             	mov    -0x20(%ebp),%edx
   14f08:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f0b:	01 d0                	add    %edx,%eax
   14f0d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   14f10:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f13:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   14f16:	8b 55 d0             	mov    -0x30(%ebp),%edx
   14f19:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f1c:	01 d0                	add    %edx,%eax
   14f1e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   14f21:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f24:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   14f27:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   14f2a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f2d:	01 d0                	add    %edx,%eax
   14f2f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   14f32:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f35:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   14f38:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14f3b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14f3e:	01 d0                	add    %edx,%eax
   14f40:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   14f46:	83 e8 80             	sub    $0xffffff80,%eax
   14f49:	c1 f8 08             	sar    $0x8,%eax
   14f4c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   14f4f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14f52:	2b 45 e0             	sub    -0x20(%ebp),%eax
   14f55:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   14f5b:	83 e8 80             	sub    $0xffffff80,%eax
   14f5e:	c1 f8 08             	sar    $0x8,%eax
   14f61:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   14f64:	8b 55 d8             	mov    -0x28(%ebp),%edx
   14f67:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f6a:	01 d0                	add    %edx,%eax
   14f6c:	c1 f8 08             	sar    $0x8,%eax
   14f6f:	89 c2                	mov    %eax,%edx
   14f71:	8b 45 08             	mov    0x8(%ebp),%eax
   14f74:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   14f76:	8b 45 08             	mov    0x8(%ebp),%eax
   14f79:	83 c0 04             	add    $0x4,%eax
   14f7c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   14f7f:	8b 55 ec             	mov    -0x14(%ebp),%edx
   14f82:	01 ca                	add    %ecx,%edx
   14f84:	c1 fa 08             	sar    $0x8,%edx
   14f87:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   14f89:	8b 45 08             	mov    0x8(%ebp),%eax
   14f8c:	83 c0 08             	add    $0x8,%eax
   14f8f:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   14f92:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14f95:	01 ca                	add    %ecx,%edx
   14f97:	c1 fa 08             	sar    $0x8,%edx
   14f9a:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   14f9c:	8b 45 08             	mov    0x8(%ebp),%eax
   14f9f:	83 c0 0c             	add    $0xc,%eax
   14fa2:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   14fa5:	8b 55 dc             	mov    -0x24(%ebp),%edx
   14fa8:	01 ca                	add    %ecx,%edx
   14faa:	c1 fa 08             	sar    $0x8,%edx
   14fad:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   14faf:	8b 45 08             	mov    0x8(%ebp),%eax
   14fb2:	8d 50 10             	lea    0x10(%eax),%edx
   14fb5:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14fb8:	2b 45 dc             	sub    -0x24(%ebp),%eax
   14fbb:	c1 f8 08             	sar    $0x8,%eax
   14fbe:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   14fc0:	8b 45 08             	mov    0x8(%ebp),%eax
   14fc3:	8d 50 14             	lea    0x14(%eax),%edx
   14fc6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   14fc9:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   14fcc:	c1 f8 08             	sar    $0x8,%eax
   14fcf:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   14fd1:	8b 45 08             	mov    0x8(%ebp),%eax
   14fd4:	8d 50 18             	lea    0x18(%eax),%edx
   14fd7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14fda:	2b 45 ec             	sub    -0x14(%ebp),%eax
   14fdd:	c1 f8 08             	sar    $0x8,%eax
   14fe0:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   14fe2:	8b 45 08             	mov    0x8(%ebp),%eax
   14fe5:	8d 50 1c             	lea    0x1c(%eax),%edx
   14fe8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14feb:	2b 45 f0             	sub    -0x10(%ebp),%eax
   14fee:	c1 f8 08             	sar    $0x8,%eax
   14ff1:	89 02                	mov    %eax,(%edx)
}
   14ff3:	83 c4 38             	add    $0x38,%esp
   14ff6:	5b                   	pop    %ebx
   14ff7:	5e                   	pop    %esi
   14ff8:	5f                   	pop    %edi
   14ff9:	5d                   	pop    %ebp
   14ffa:	c3                   	ret    

00014ffb <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   14ffb:	55                   	push   %ebp
   14ffc:	89 e5                	mov    %esp,%ebp
   14ffe:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   15001:	8b 45 08             	mov    0x8(%ebp),%eax
   15004:	83 e8 80             	sub    $0xffffff80,%eax
   15007:	8b 00                	mov    (%eax),%eax
   15009:	c1 e0 08             	shl    $0x8,%eax
   1500c:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   1500f:	8b 45 08             	mov    0x8(%ebp),%eax
   15012:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   15018:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1501b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1501e:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   15021:	8b 55 08             	mov    0x8(%ebp),%edx
   15024:	8b 52 40             	mov    0x40(%edx),%edx
   15027:	89 55 f0             	mov    %edx,-0x10(%ebp)
   1502a:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   1502d:	8b 55 08             	mov    0x8(%ebp),%edx
   15030:	8b 52 20             	mov    0x20(%edx),%edx
   15033:	89 55 ec             	mov    %edx,-0x14(%ebp)
   15036:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   15039:	8b 55 08             	mov    0x8(%ebp),%edx
   1503c:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   15042:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15045:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   15048:	8b 55 08             	mov    0x8(%ebp),%edx
   1504b:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   15051:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   15054:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   15057:	8b 55 08             	mov    0x8(%ebp),%edx
   1505a:	8b 52 60             	mov    0x60(%edx),%edx
   1505d:	89 55 e0             	mov    %edx,-0x20(%ebp)
   15060:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   15063:	85 c0                	test   %eax,%eax
   15065:	75 45                	jne    150ac <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   15067:	8b 45 08             	mov    0x8(%ebp),%eax
   1506a:	8b 00                	mov    (%eax),%eax
   1506c:	83 c0 20             	add    $0x20,%eax
   1506f:	c1 f8 06             	sar    $0x6,%eax
   15072:	83 e8 80             	sub    $0xffffff80,%eax
   15075:	50                   	push   %eax
   15076:	e8 d6 ea ff ff       	call   13b51 <_Clip>
   1507b:	83 c4 04             	add    $0x4,%esp
   1507e:	0f b6 c0             	movzbl %al,%eax
   15081:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   15084:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   1508b:	eb 14                	jmp    150a1 <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   1508d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15090:	89 c2                	mov    %eax,%edx
   15092:	8b 45 0c             	mov    0xc(%ebp),%eax
   15095:	88 10                	mov    %dl,(%eax)
            out += stride;
   15097:	8b 45 10             	mov    0x10(%ebp),%eax
   1509a:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   1509d:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   150a1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   150a5:	75 e6                	jne    1508d <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   150a7:	e9 57 02 00 00       	jmp    15303 <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   150ac:	8b 45 08             	mov    0x8(%ebp),%eax
   150af:	8b 00                	mov    (%eax),%eax
   150b1:	c1 e0 08             	shl    $0x8,%eax
   150b4:	05 00 20 00 00       	add    $0x2000,%eax
   150b9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   150bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
   150bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
   150c2:	01 d0                	add    %edx,%eax
   150c4:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   150ca:	83 c0 04             	add    $0x4,%eax
   150cd:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   150d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   150d3:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   150d9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   150dc:	01 d0                	add    %edx,%eax
   150de:	c1 f8 03             	sar    $0x3,%eax
   150e1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   150e4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   150e7:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   150ed:	8b 45 dc             	mov    -0x24(%ebp),%eax
   150f0:	01 d0                	add    %edx,%eax
   150f2:	c1 f8 03             	sar    $0x3,%eax
   150f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   150f8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   150fb:	8b 45 e0             	mov    -0x20(%ebp),%eax
   150fe:	01 d0                	add    %edx,%eax
   15100:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   15106:	83 c0 04             	add    $0x4,%eax
   15109:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   1510c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1510f:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   15115:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15118:	01 d0                	add    %edx,%eax
   1511a:	c1 f8 03             	sar    $0x3,%eax
   1511d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   15120:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15123:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   15129:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1512c:	01 d0                	add    %edx,%eax
   1512e:	c1 f8 03             	sar    $0x3,%eax
   15131:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   15134:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15137:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1513a:	01 d0                	add    %edx,%eax
   1513c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   1513f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15142:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   15145:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15148:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1514b:	01 d0                	add    %edx,%eax
   1514d:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   15153:	83 c0 04             	add    $0x4,%eax
   15156:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   15159:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1515c:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   15162:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15165:	01 d0                	add    %edx,%eax
   15167:	c1 f8 03             	sar    $0x3,%eax
   1516a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   1516d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15170:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   15176:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15179:	01 d0                	add    %edx,%eax
   1517b:	c1 f8 03             	sar    $0x3,%eax
   1517e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   15181:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15184:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15187:	01 d0                	add    %edx,%eax
   15189:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   1518c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1518f:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   15192:	8b 55 e8             	mov    -0x18(%ebp),%edx
   15195:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15198:	01 d0                	add    %edx,%eax
   1519a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   1519d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   151a0:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   151a3:	8b 55 dc             	mov    -0x24(%ebp),%edx
   151a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151a9:	01 d0                	add    %edx,%eax
   151ab:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   151ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151b1:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   151b4:	8b 55 fc             	mov    -0x4(%ebp),%edx
   151b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151ba:	01 d0                	add    %edx,%eax
   151bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   151bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151c2:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   151c5:	8b 55 ec             	mov    -0x14(%ebp),%edx
   151c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   151cb:	01 d0                	add    %edx,%eax
   151cd:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   151d3:	83 e8 80             	sub    $0xffffff80,%eax
   151d6:	c1 f8 08             	sar    $0x8,%eax
   151d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   151dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   151df:	2b 45 e8             	sub    -0x18(%ebp),%eax
   151e2:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   151e8:	83 e8 80             	sub    $0xffffff80,%eax
   151eb:	c1 f8 08             	sar    $0x8,%eax
   151ee:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   151f1:	8b 55 e0             	mov    -0x20(%ebp),%edx
   151f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   151f7:	01 d0                	add    %edx,%eax
   151f9:	c1 f8 0e             	sar    $0xe,%eax
   151fc:	83 e8 80             	sub    $0xffffff80,%eax
   151ff:	50                   	push   %eax
   15200:	e8 4c e9 ff ff       	call   13b51 <_Clip>
   15205:	83 c4 04             	add    $0x4,%esp
   15208:	89 c2                	mov    %eax,%edx
   1520a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1520d:	88 10                	mov    %dl,(%eax)
   1520f:	8b 45 10             	mov    0x10(%ebp),%eax
   15212:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   15215:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15218:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1521b:	01 d0                	add    %edx,%eax
   1521d:	c1 f8 0e             	sar    $0xe,%eax
   15220:	83 e8 80             	sub    $0xffffff80,%eax
   15223:	50                   	push   %eax
   15224:	e8 28 e9 ff ff       	call   13b51 <_Clip>
   15229:	83 c4 04             	add    $0x4,%esp
   1522c:	89 c2                	mov    %eax,%edx
   1522e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15231:	88 10                	mov    %dl,(%eax)
   15233:	8b 45 10             	mov    0x10(%ebp),%eax
   15236:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   15239:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1523c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1523f:	01 d0                	add    %edx,%eax
   15241:	c1 f8 0e             	sar    $0xe,%eax
   15244:	83 e8 80             	sub    $0xffffff80,%eax
   15247:	50                   	push   %eax
   15248:	e8 04 e9 ff ff       	call   13b51 <_Clip>
   1524d:	83 c4 04             	add    $0x4,%esp
   15250:	89 c2                	mov    %eax,%edx
   15252:	8b 45 0c             	mov    0xc(%ebp),%eax
   15255:	88 10                	mov    %dl,(%eax)
   15257:	8b 45 10             	mov    0x10(%ebp),%eax
   1525a:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   1525d:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15260:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15263:	01 d0                	add    %edx,%eax
   15265:	c1 f8 0e             	sar    $0xe,%eax
   15268:	83 e8 80             	sub    $0xffffff80,%eax
   1526b:	50                   	push   %eax
   1526c:	e8 e0 e8 ff ff       	call   13b51 <_Clip>
   15271:	83 c4 04             	add    $0x4,%esp
   15274:	89 c2                	mov    %eax,%edx
   15276:	8b 45 0c             	mov    0xc(%ebp),%eax
   15279:	88 10                	mov    %dl,(%eax)
   1527b:	8b 45 10             	mov    0x10(%ebp),%eax
   1527e:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   15281:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15284:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   15287:	c1 f8 0e             	sar    $0xe,%eax
   1528a:	83 e8 80             	sub    $0xffffff80,%eax
   1528d:	50                   	push   %eax
   1528e:	e8 be e8 ff ff       	call   13b51 <_Clip>
   15293:	83 c4 04             	add    $0x4,%esp
   15296:	89 c2                	mov    %eax,%edx
   15298:	8b 45 0c             	mov    0xc(%ebp),%eax
   1529b:	88 10                	mov    %dl,(%eax)
   1529d:	8b 45 10             	mov    0x10(%ebp),%eax
   152a0:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   152a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   152a6:	2b 45 ec             	sub    -0x14(%ebp),%eax
   152a9:	c1 f8 0e             	sar    $0xe,%eax
   152ac:	83 e8 80             	sub    $0xffffff80,%eax
   152af:	50                   	push   %eax
   152b0:	e8 9c e8 ff ff       	call   13b51 <_Clip>
   152b5:	83 c4 04             	add    $0x4,%esp
   152b8:	89 c2                	mov    %eax,%edx
   152ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   152bd:	88 10                	mov    %dl,(%eax)
   152bf:	8b 45 10             	mov    0x10(%ebp),%eax
   152c2:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   152c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   152c8:	2b 45 f4             	sub    -0xc(%ebp),%eax
   152cb:	c1 f8 0e             	sar    $0xe,%eax
   152ce:	83 e8 80             	sub    $0xffffff80,%eax
   152d1:	50                   	push   %eax
   152d2:	e8 7a e8 ff ff       	call   13b51 <_Clip>
   152d7:	83 c4 04             	add    $0x4,%esp
   152da:	89 c2                	mov    %eax,%edx
   152dc:	8b 45 0c             	mov    0xc(%ebp),%eax
   152df:	88 10                	mov    %dl,(%eax)
   152e1:	8b 45 10             	mov    0x10(%ebp),%eax
   152e4:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   152e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   152ea:	2b 45 f8             	sub    -0x8(%ebp),%eax
   152ed:	c1 f8 0e             	sar    $0xe,%eax
   152f0:	83 e8 80             	sub    $0xffffff80,%eax
   152f3:	50                   	push   %eax
   152f4:	e8 58 e8 ff ff       	call   13b51 <_Clip>
   152f9:	83 c4 04             	add    $0x4,%esp
   152fc:	89 c2                	mov    %eax,%edx
   152fe:	8b 45 0c             	mov    0xc(%ebp),%eax
   15301:	88 10                	mov    %dl,(%eax)
}
   15303:	c9                   	leave  
   15304:	c3                   	ret    

00015305 <_ByteAlign>:

void _ByteAlign(Context* ctx){
   15305:	55                   	push   %ebp
   15306:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   15308:	8b 45 08             	mov    0x8(%ebp),%eax
   1530b:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15311:	25 f8 00 00 00       	and    $0xf8,%eax
   15316:	89 c2                	mov    %eax,%edx
   15318:	8b 45 08             	mov    0x8(%ebp),%eax
   1531b:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   15321:	90                   	nop
   15322:	5d                   	pop    %ebp
   15323:	c3                   	ret    

00015324 <_SkipMarker>:

void _SkipMarker(Context* ctx){
   15324:	55                   	push   %ebp
   15325:	89 e5                	mov    %esp,%ebp
   15327:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   1532a:	83 ec 0c             	sub    $0xc,%esp
   1532d:	ff 75 08             	pushl  0x8(%ebp)
   15330:	e8 8d e8 ff ff       	call   13bc2 <_DecodeLength>
   15335:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   15338:	8b 45 08             	mov    0x8(%ebp),%eax
   1533b:	8b 40 0c             	mov    0xc(%eax),%eax
   1533e:	83 ec 08             	sub    $0x8,%esp
   15341:	50                   	push   %eax
   15342:	ff 75 08             	pushl  0x8(%ebp)
   15345:	e8 2c e8 ff ff       	call   13b76 <_Skip>
   1534a:	83 c4 10             	add    $0x10,%esp
}
   1534d:	90                   	nop
   1534e:	c9                   	leave  
   1534f:	c3                   	ret    

00015350 <_Convert>:

void _Convert(Context* ctx){
   15350:	55                   	push   %ebp
   15351:	89 e5                	mov    %esp,%ebp
   15353:	57                   	push   %edi
   15354:	56                   	push   %esi
   15355:	53                   	push   %ebx
   15356:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15359:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   15360:	8b 45 08             	mov    0x8(%ebp),%eax
   15363:	83 c0 2c             	add    $0x2c,%eax
   15366:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15369:	e9 b2 00 00 00       	jmp    15420 <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   1536e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15371:	8b 50 0c             	mov    0xc(%eax),%edx
   15374:	8b 45 08             	mov    0x8(%ebp),%eax
   15377:	8b 40 10             	mov    0x10(%eax),%eax
   1537a:	39 c2                	cmp    %eax,%edx
   1537c:	7d 11                	jge    1538f <_Convert+0x3f>
   1537e:	83 ec 08             	sub    $0x8,%esp
   15381:	ff 75 e0             	pushl  -0x20(%ebp)
   15384:	ff 75 08             	pushl  0x8(%ebp)
   15387:	e8 79 02 00 00       	call   15605 <_UpsampleH>
   1538c:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   1538f:	8b 45 08             	mov    0x8(%ebp),%eax
   15392:	8b 00                	mov    (%eax),%eax
   15394:	85 c0                	test   %eax,%eax
   15396:	0f 85 5d 02 00 00    	jne    155f9 <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   1539c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1539f:	8b 50 10             	mov    0x10(%eax),%edx
   153a2:	8b 45 08             	mov    0x8(%ebp),%eax
   153a5:	8b 40 14             	mov    0x14(%eax),%eax
   153a8:	39 c2                	cmp    %eax,%edx
   153aa:	7d 11                	jge    153bd <_Convert+0x6d>
   153ac:	83 ec 08             	sub    $0x8,%esp
   153af:	ff 75 e0             	pushl  -0x20(%ebp)
   153b2:	ff 75 08             	pushl  0x8(%ebp)
   153b5:	e8 db 05 00 00       	call   15995 <_UpsampleV>
   153ba:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   153bd:	8b 45 08             	mov    0x8(%ebp),%eax
   153c0:	8b 00                	mov    (%eax),%eax
   153c2:	85 c0                	test   %eax,%eax
   153c4:	0f 85 32 02 00 00    	jne    155fc <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   153ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
   153cd:	8b 50 0c             	mov    0xc(%eax),%edx
   153d0:	8b 45 08             	mov    0x8(%ebp),%eax
   153d3:	8b 40 10             	mov    0x10(%eax),%eax
   153d6:	39 c2                	cmp    %eax,%edx
   153d8:	7c 94                	jl     1536e <_Convert+0x1e>
   153da:	8b 45 e0             	mov    -0x20(%ebp),%eax
   153dd:	8b 50 10             	mov    0x10(%eax),%edx
   153e0:	8b 45 08             	mov    0x8(%ebp),%eax
   153e3:	8b 40 14             	mov    0x14(%eax),%eax
   153e6:	39 c2                	cmp    %eax,%edx
   153e8:	7c 84                	jl     1536e <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   153ea:	8b 45 e0             	mov    -0x20(%ebp),%eax
   153ed:	8b 50 0c             	mov    0xc(%eax),%edx
   153f0:	8b 45 08             	mov    0x8(%ebp),%eax
   153f3:	8b 40 10             	mov    0x10(%eax),%eax
   153f6:	39 c2                	cmp    %eax,%edx
   153f8:	7c 10                	jl     1540a <_Convert+0xba>
   153fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
   153fd:	8b 50 10             	mov    0x10(%eax),%edx
   15400:	8b 45 08             	mov    0x8(%ebp),%eax
   15403:	8b 40 14             	mov    0x14(%eax),%eax
   15406:	39 c2                	cmp    %eax,%edx
   15408:	7d 0e                	jge    15418 <_Convert+0xc8>
   1540a:	8b 45 08             	mov    0x8(%ebp),%eax
   1540d:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   15413:	e9 e5 01 00 00       	jmp    155fd <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15418:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1541c:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   15420:	8b 45 08             	mov    0x8(%ebp),%eax
   15423:	8b 40 28             	mov    0x28(%eax),%eax
   15426:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15429:	7f 9f                	jg     153ca <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   1542b:	8b 45 08             	mov    0x8(%ebp),%eax
   1542e:	8b 40 28             	mov    0x28(%eax),%eax
   15431:	83 f8 03             	cmp    $0x3,%eax
   15434:	0f 85 3d 01 00 00    	jne    15577 <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   1543a:	8b 45 08             	mov    0x8(%ebp),%eax
   1543d:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   15443:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   15446:	8b 45 08             	mov    0x8(%ebp),%eax
   15449:	8b 40 54             	mov    0x54(%eax),%eax
   1544c:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   1544f:	8b 45 08             	mov    0x8(%ebp),%eax
   15452:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   15458:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   1545b:	8b 45 08             	mov    0x8(%ebp),%eax
   1545e:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   15464:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   15467:	8b 45 08             	mov    0x8(%ebp),%eax
   1546a:	8b 40 14             	mov    0x14(%eax),%eax
   1546d:	89 45 d8             	mov    %eax,-0x28(%ebp)
   15470:	e9 f3 00 00 00       	jmp    15568 <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   15475:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   1547c:	e9 b6 00 00 00       	jmp    15537 <_Convert+0x1e7>
                register int y = py[x] << 8;
   15481:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15484:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15487:	01 d0                	add    %edx,%eax
   15489:	0f b6 00             	movzbl (%eax),%eax
   1548c:	0f b6 c0             	movzbl %al,%eax
   1548f:	c1 e0 08             	shl    $0x8,%eax
   15492:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   15494:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15497:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1549a:	01 d0                	add    %edx,%eax
   1549c:	0f b6 00             	movzbl (%eax),%eax
   1549f:	0f b6 c0             	movzbl %al,%eax
   154a2:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   154a5:	8b 55 dc             	mov    -0x24(%ebp),%edx
   154a8:	8b 45 c8             	mov    -0x38(%ebp),%eax
   154ab:	01 d0                	add    %edx,%eax
   154ad:	0f b6 00             	movzbl (%eax),%eax
   154b0:	0f b6 c0             	movzbl %al,%eax
   154b3:	83 c0 80             	add    $0xffffff80,%eax
   154b6:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   154b8:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   154bb:	8d 46 01             	lea    0x1(%esi),%eax
   154be:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   154c1:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   154c4:	89 c8                	mov    %ecx,%eax
   154c6:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   154cc:	01 d8                	add    %ebx,%eax
   154ce:	83 e8 80             	sub    $0xffffff80,%eax
   154d1:	c1 f8 08             	sar    $0x8,%eax
   154d4:	83 ec 0c             	sub    $0xc,%esp
   154d7:	50                   	push   %eax
   154d8:	e8 74 e6 ff ff       	call   13b51 <_Clip>
   154dd:	83 c4 10             	add    $0x10,%esp
   154e0:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   154e2:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   154e5:	8d 46 01             	lea    0x1(%esi),%eax
   154e8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   154eb:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   154ee:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   154f1:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   154f8:	01 d0                	add    %edx,%eax
   154fa:	83 e8 80             	sub    $0xffffff80,%eax
   154fd:	c1 f8 08             	sar    $0x8,%eax
   15500:	83 ec 0c             	sub    $0xc,%esp
   15503:	50                   	push   %eax
   15504:	e8 48 e6 ff ff       	call   13b51 <_Clip>
   15509:	83 c4 10             	add    $0x10,%esp
   1550c:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   1550e:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15511:	8d 46 01             	lea    0x1(%esi),%eax
   15514:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15517:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   1551d:	01 d8                	add    %ebx,%eax
   1551f:	83 e8 80             	sub    $0xffffff80,%eax
   15522:	c1 f8 08             	sar    $0x8,%eax
   15525:	83 ec 0c             	sub    $0xc,%esp
   15528:	50                   	push   %eax
   15529:	e8 23 e6 ff ff       	call   13b51 <_Clip>
   1552e:	83 c4 10             	add    $0x10,%esp
   15531:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   15533:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   15537:	8b 45 08             	mov    0x8(%ebp),%eax
   1553a:	8b 40 10             	mov    0x10(%eax),%eax
   1553d:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   15540:	0f 8f 3b ff ff ff    	jg     15481 <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   15546:	8b 45 08             	mov    0x8(%ebp),%eax
   15549:	8b 40 40             	mov    0x40(%eax),%eax
   1554c:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   1554f:	8b 45 08             	mov    0x8(%ebp),%eax
   15552:	8b 40 6c             	mov    0x6c(%eax),%eax
   15555:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   15558:	8b 45 08             	mov    0x8(%ebp),%eax
   1555b:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   15561:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   15564:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   15568:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1556c:	0f 85 03 ff ff ff    	jne    15475 <_Convert+0x125>
   15572:	e9 86 00 00 00       	jmp    155fd <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   15577:	8b 45 08             	mov    0x8(%ebp),%eax
   1557a:	8b 50 38             	mov    0x38(%eax),%edx
   1557d:	8b 45 08             	mov    0x8(%ebp),%eax
   15580:	8b 40 40             	mov    0x40(%eax),%eax
   15583:	39 c2                	cmp    %eax,%edx
   15585:	74 76                	je     155fd <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   15587:	8b 45 08             	mov    0x8(%ebp),%eax
   1558a:	8b 50 54             	mov    0x54(%eax),%edx
   1558d:	8b 45 08             	mov    0x8(%ebp),%eax
   15590:	8b 40 40             	mov    0x40(%eax),%eax
   15593:	01 d0                	add    %edx,%eax
   15595:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   15598:	8b 45 08             	mov    0x8(%ebp),%eax
   1559b:	8b 50 54             	mov    0x54(%eax),%edx
   1559e:	8b 45 08             	mov    0x8(%ebp),%eax
   155a1:	8b 40 38             	mov    0x38(%eax),%eax
   155a4:	01 d0                	add    %edx,%eax
   155a6:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   155a9:	8b 45 08             	mov    0x8(%ebp),%eax
   155ac:	8b 40 3c             	mov    0x3c(%eax),%eax
   155af:	83 e8 01             	sub    $0x1,%eax
   155b2:	89 45 bc             	mov    %eax,-0x44(%ebp)
   155b5:	eb 2e                	jmp    155e5 <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   155b7:	8b 45 08             	mov    0x8(%ebp),%eax
   155ba:	8b 40 38             	mov    0x38(%eax),%eax
   155bd:	83 ec 04             	sub    $0x4,%esp
   155c0:	50                   	push   %eax
   155c1:	ff 75 c4             	pushl  -0x3c(%ebp)
   155c4:	ff 75 c0             	pushl  -0x40(%ebp)
   155c7:	e8 72 ac fe ff       	call   23e <memmove>
   155cc:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   155cf:	8b 45 08             	mov    0x8(%ebp),%eax
   155d2:	8b 40 40             	mov    0x40(%eax),%eax
   155d5:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   155d8:	8b 45 08             	mov    0x8(%ebp),%eax
   155db:	8b 40 38             	mov    0x38(%eax),%eax
   155de:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   155e1:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   155e5:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   155e9:	75 cc                	jne    155b7 <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   155eb:	8b 45 08             	mov    0x8(%ebp),%eax
   155ee:	8b 50 38             	mov    0x38(%eax),%edx
   155f1:	8b 45 08             	mov    0x8(%ebp),%eax
   155f4:	89 50 40             	mov    %edx,0x40(%eax)
   155f7:	eb 04                	jmp    155fd <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   155f9:	90                   	nop
   155fa:	eb 01                	jmp    155fd <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   155fc:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   155fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
   15600:	5b                   	pop    %ebx
   15601:	5e                   	pop    %esi
   15602:	5f                   	pop    %edi
   15603:	5d                   	pop    %ebp
   15604:	c3                   	ret    

00015605 <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   15605:	55                   	push   %ebp
   15606:	89 e5                	mov    %esp,%ebp
   15608:	53                   	push   %ebx
   15609:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   1560c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1560f:	8b 40 0c             	mov    0xc(%eax),%eax
   15612:	83 e8 03             	sub    $0x3,%eax
   15615:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15618:	8b 45 0c             	mov    0xc(%ebp),%eax
   1561b:	8b 50 0c             	mov    0xc(%eax),%edx
   1561e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15621:	8b 40 10             	mov    0x10(%eax),%eax
   15624:	0f af c2             	imul   %edx,%eax
   15627:	01 c0                	add    %eax,%eax
   15629:	83 ec 0c             	sub    $0xc,%esp
   1562c:	50                   	push   %eax
   1562d:	e8 cb b0 fe ff       	call   6fd <malloc>
   15632:	83 c4 10             	add    $0x10,%esp
   15635:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15638:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1563c:	75 0e                	jne    1564c <_UpsampleH+0x47>
   1563e:	8b 45 08             	mov    0x8(%ebp),%eax
   15641:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15647:	e9 44 03 00 00       	jmp    15990 <_UpsampleH+0x38b>
    lin = c->pixels;
   1564c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1564f:	8b 40 28             	mov    0x28(%eax),%eax
   15652:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   15655:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15658:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   1565b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1565e:	8b 40 10             	mov    0x10(%eax),%eax
   15661:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   15664:	e9 e0 02 00 00       	jmp    15949 <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   15669:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1566c:	0f b6 00             	movzbl (%eax),%eax
   1566f:	0f b6 c0             	movzbl %al,%eax
   15672:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15678:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1567b:	83 c0 01             	add    $0x1,%eax
   1567e:	0f b6 00             	movzbl (%eax),%eax
   15681:	0f b6 c0             	movzbl %al,%eax
   15684:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15687:	01 d0                	add    %edx,%eax
   15689:	83 ec 0c             	sub    $0xc,%esp
   1568c:	50                   	push   %eax
   1568d:	e8 c4 06 00 00       	call   15d56 <CF>
   15692:	83 c4 10             	add    $0x10,%esp
   15695:	89 c2                	mov    %eax,%edx
   15697:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1569a:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   1569c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1569f:	8d 58 01             	lea    0x1(%eax),%ebx
   156a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156a5:	0f b6 00             	movzbl (%eax),%eax
   156a8:	0f b6 c0             	movzbl %al,%eax
   156ab:	6b c8 68             	imul   $0x68,%eax,%ecx
   156ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156b1:	83 c0 01             	add    $0x1,%eax
   156b4:	0f b6 00             	movzbl (%eax),%eax
   156b7:	0f b6 d0             	movzbl %al,%edx
   156ba:	89 d0                	mov    %edx,%eax
   156bc:	01 c0                	add    %eax,%eax
   156be:	01 d0                	add    %edx,%eax
   156c0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   156c7:	01 d0                	add    %edx,%eax
   156c9:	01 c1                	add    %eax,%ecx
   156cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156ce:	83 c0 02             	add    $0x2,%eax
   156d1:	0f b6 00             	movzbl (%eax),%eax
   156d4:	0f b6 d0             	movzbl %al,%edx
   156d7:	89 d0                	mov    %edx,%eax
   156d9:	01 c0                	add    %eax,%eax
   156db:	01 d0                	add    %edx,%eax
   156dd:	f7 d8                	neg    %eax
   156df:	01 c8                	add    %ecx,%eax
   156e1:	83 ec 0c             	sub    $0xc,%esp
   156e4:	50                   	push   %eax
   156e5:	e8 6c 06 00 00       	call   15d56 <CF>
   156ea:	83 c4 10             	add    $0x10,%esp
   156ed:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   156ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
   156f2:	8d 58 02             	lea    0x2(%eax),%ebx
   156f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156f8:	0f b6 00             	movzbl (%eax),%eax
   156fb:	0f b6 c0             	movzbl %al,%eax
   156fe:	c1 e0 02             	shl    $0x2,%eax
   15701:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15708:	29 c2                	sub    %eax,%edx
   1570a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1570d:	83 c0 01             	add    $0x1,%eax
   15710:	0f b6 00             	movzbl (%eax),%eax
   15713:	0f b6 c0             	movzbl %al,%eax
   15716:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15719:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1571c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1571f:	83 c0 02             	add    $0x2,%eax
   15722:	0f b6 00             	movzbl (%eax),%eax
   15725:	0f b6 d0             	movzbl %al,%edx
   15728:	89 d0                	mov    %edx,%eax
   1572a:	c1 e0 03             	shl    $0x3,%eax
   1572d:	01 d0                	add    %edx,%eax
   1572f:	f7 d8                	neg    %eax
   15731:	01 c8                	add    %ecx,%eax
   15733:	83 ec 0c             	sub    $0xc,%esp
   15736:	50                   	push   %eax
   15737:	e8 1a 06 00 00       	call   15d56 <CF>
   1573c:	83 c4 10             	add    $0x10,%esp
   1573f:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   15741:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15748:	e9 fa 00 00 00       	jmp    15847 <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   1574d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15750:	01 c0                	add    %eax,%eax
   15752:	8d 50 03             	lea    0x3(%eax),%edx
   15755:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15758:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1575b:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1575e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15761:	01 d0                	add    %edx,%eax
   15763:	0f b6 00             	movzbl (%eax),%eax
   15766:	0f b6 d0             	movzbl %al,%edx
   15769:	89 d0                	mov    %edx,%eax
   1576b:	c1 e0 03             	shl    $0x3,%eax
   1576e:	01 d0                	add    %edx,%eax
   15770:	f7 d8                	neg    %eax
   15772:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15775:	8d 4a 01             	lea    0x1(%edx),%ecx
   15778:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1577b:	01 ca                	add    %ecx,%edx
   1577d:	0f b6 12             	movzbl (%edx),%edx
   15780:	0f b6 d2             	movzbl %dl,%edx
   15783:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15786:	01 c2                	add    %eax,%edx
   15788:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1578b:	8d 48 02             	lea    0x2(%eax),%ecx
   1578e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15791:	01 c8                	add    %ecx,%eax
   15793:	0f b6 00             	movzbl (%eax),%eax
   15796:	0f b6 c0             	movzbl %al,%eax
   15799:	6b c0 1d             	imul   $0x1d,%eax,%eax
   1579c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1579f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   157a2:	8d 50 03             	lea    0x3(%eax),%edx
   157a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157a8:	01 d0                	add    %edx,%eax
   157aa:	0f b6 00             	movzbl (%eax),%eax
   157ad:	0f b6 d0             	movzbl %al,%edx
   157b0:	89 d0                	mov    %edx,%eax
   157b2:	01 c0                	add    %eax,%eax
   157b4:	01 d0                	add    %edx,%eax
   157b6:	f7 d8                	neg    %eax
   157b8:	01 c8                	add    %ecx,%eax
   157ba:	83 ec 0c             	sub    $0xc,%esp
   157bd:	50                   	push   %eax
   157be:	e8 93 05 00 00       	call   15d56 <CF>
   157c3:	83 c4 10             	add    $0x10,%esp
   157c6:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   157c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   157cb:	01 c0                	add    %eax,%eax
   157cd:	8d 50 04             	lea    0x4(%eax),%edx
   157d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   157d3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   157d6:	8b 55 ec             	mov    -0x14(%ebp),%edx
   157d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157dc:	01 d0                	add    %edx,%eax
   157de:	0f b6 00             	movzbl (%eax),%eax
   157e1:	0f b6 d0             	movzbl %al,%edx
   157e4:	89 d0                	mov    %edx,%eax
   157e6:	01 c0                	add    %eax,%eax
   157e8:	01 d0                	add    %edx,%eax
   157ea:	f7 d8                	neg    %eax
   157ec:	8b 55 ec             	mov    -0x14(%ebp),%edx
   157ef:	8d 4a 01             	lea    0x1(%edx),%ecx
   157f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   157f5:	01 ca                	add    %ecx,%edx
   157f7:	0f b6 12             	movzbl (%edx),%edx
   157fa:	0f b6 d2             	movzbl %dl,%edx
   157fd:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15800:	01 c2                	add    %eax,%edx
   15802:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15805:	8d 48 02             	lea    0x2(%eax),%ecx
   15808:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1580b:	01 c8                	add    %ecx,%eax
   1580d:	0f b6 00             	movzbl (%eax),%eax
   15810:	0f b6 c0             	movzbl %al,%eax
   15813:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15816:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15819:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1581c:	8d 50 03             	lea    0x3(%eax),%edx
   1581f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15822:	01 d0                	add    %edx,%eax
   15824:	0f b6 00             	movzbl (%eax),%eax
   15827:	0f b6 d0             	movzbl %al,%edx
   1582a:	89 d0                	mov    %edx,%eax
   1582c:	c1 e0 03             	shl    $0x3,%eax
   1582f:	01 d0                	add    %edx,%eax
   15831:	f7 d8                	neg    %eax
   15833:	01 c8                	add    %ecx,%eax
   15835:	83 ec 0c             	sub    $0xc,%esp
   15838:	50                   	push   %eax
   15839:	e8 18 05 00 00       	call   15d56 <CF>
   1583e:	83 c4 10             	add    $0x10,%esp
   15841:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   15843:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15847:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1584a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1584d:	0f 8c fa fe ff ff    	jl     1574d <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   15853:	8b 45 0c             	mov    0xc(%ebp),%eax
   15856:	8b 40 14             	mov    0x14(%eax),%eax
   15859:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   1585c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1585f:	8b 40 0c             	mov    0xc(%eax),%eax
   15862:	01 c0                	add    %eax,%eax
   15864:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   15867:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1586a:	8d 58 fd             	lea    -0x3(%eax),%ebx
   1586d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15870:	83 e8 01             	sub    $0x1,%eax
   15873:	0f b6 00             	movzbl (%eax),%eax
   15876:	0f b6 c0             	movzbl %al,%eax
   15879:	c1 e0 02             	shl    $0x2,%eax
   1587c:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15883:	29 c2                	sub    %eax,%edx
   15885:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15888:	83 e8 02             	sub    $0x2,%eax
   1588b:	0f b6 00             	movzbl (%eax),%eax
   1588e:	0f b6 c0             	movzbl %al,%eax
   15891:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15894:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15897:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1589a:	83 e8 03             	sub    $0x3,%eax
   1589d:	0f b6 00             	movzbl (%eax),%eax
   158a0:	0f b6 d0             	movzbl %al,%edx
   158a3:	89 d0                	mov    %edx,%eax
   158a5:	c1 e0 03             	shl    $0x3,%eax
   158a8:	01 d0                	add    %edx,%eax
   158aa:	f7 d8                	neg    %eax
   158ac:	01 c8                	add    %ecx,%eax
   158ae:	83 ec 0c             	sub    $0xc,%esp
   158b1:	50                   	push   %eax
   158b2:	e8 9f 04 00 00       	call   15d56 <CF>
   158b7:	83 c4 10             	add    $0x10,%esp
   158ba:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   158bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158bf:	8d 58 fe             	lea    -0x2(%eax),%ebx
   158c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158c5:	83 e8 01             	sub    $0x1,%eax
   158c8:	0f b6 00             	movzbl (%eax),%eax
   158cb:	0f b6 c0             	movzbl %al,%eax
   158ce:	6b c8 68             	imul   $0x68,%eax,%ecx
   158d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158d4:	83 e8 02             	sub    $0x2,%eax
   158d7:	0f b6 00             	movzbl (%eax),%eax
   158da:	0f b6 d0             	movzbl %al,%edx
   158dd:	89 d0                	mov    %edx,%eax
   158df:	01 c0                	add    %eax,%eax
   158e1:	01 d0                	add    %edx,%eax
   158e3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   158ea:	01 d0                	add    %edx,%eax
   158ec:	01 c1                	add    %eax,%ecx
   158ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158f1:	83 e8 03             	sub    $0x3,%eax
   158f4:	0f b6 00             	movzbl (%eax),%eax
   158f7:	0f b6 d0             	movzbl %al,%edx
   158fa:	89 d0                	mov    %edx,%eax
   158fc:	01 c0                	add    %eax,%eax
   158fe:	01 d0                	add    %edx,%eax
   15900:	f7 d8                	neg    %eax
   15902:	01 c8                	add    %ecx,%eax
   15904:	83 ec 0c             	sub    $0xc,%esp
   15907:	50                   	push   %eax
   15908:	e8 49 04 00 00       	call   15d56 <CF>
   1590d:	83 c4 10             	add    $0x10,%esp
   15910:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   15912:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15915:	8d 58 ff             	lea    -0x1(%eax),%ebx
   15918:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1591b:	83 e8 01             	sub    $0x1,%eax
   1591e:	0f b6 00             	movzbl (%eax),%eax
   15921:	0f b6 c0             	movzbl %al,%eax
   15924:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   1592a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1592d:	83 e8 02             	sub    $0x2,%eax
   15930:	0f b6 00             	movzbl (%eax),%eax
   15933:	0f b6 c0             	movzbl %al,%eax
   15936:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15939:	01 d0                	add    %edx,%eax
   1593b:	83 ec 0c             	sub    $0xc,%esp
   1593e:	50                   	push   %eax
   1593f:	e8 12 04 00 00       	call   15d56 <CF>
   15944:	83 c4 10             	add    $0x10,%esp
   15947:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   15949:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1594c:	8d 50 ff             	lea    -0x1(%eax),%edx
   1594f:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15952:	85 c0                	test   %eax,%eax
   15954:	0f 85 0f fd ff ff    	jne    15669 <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   1595a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1595d:	8b 40 0c             	mov    0xc(%eax),%eax
   15960:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15963:	8b 45 0c             	mov    0xc(%ebp),%eax
   15966:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   15969:	8b 45 0c             	mov    0xc(%ebp),%eax
   1596c:	8b 50 0c             	mov    0xc(%eax),%edx
   1596f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15972:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15975:	8b 45 0c             	mov    0xc(%ebp),%eax
   15978:	8b 40 28             	mov    0x28(%eax),%eax
   1597b:	83 ec 0c             	sub    $0xc,%esp
   1597e:	50                   	push   %eax
   1597f:	e8 37 ac fe ff       	call   5bb <free>
   15984:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15987:	8b 45 0c             	mov    0xc(%ebp),%eax
   1598a:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1598d:	89 50 28             	mov    %edx,0x28(%eax)
}
   15990:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15993:	c9                   	leave  
   15994:	c3                   	ret    

00015995 <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   15995:	55                   	push   %ebp
   15996:	89 e5                	mov    %esp,%ebp
   15998:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   1599b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1599e:	8b 40 0c             	mov    0xc(%eax),%eax
   159a1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   159a4:	8b 45 0c             	mov    0xc(%ebp),%eax
   159a7:	8b 40 14             	mov    0x14(%eax),%eax
   159aa:	89 45 e0             	mov    %eax,-0x20(%ebp)
   159ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
   159b0:	01 c0                	add    %eax,%eax
   159b2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   159b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   159b8:	8b 50 0c             	mov    0xc(%eax),%edx
   159bb:	8b 45 0c             	mov    0xc(%ebp),%eax
   159be:	8b 40 10             	mov    0x10(%eax),%eax
   159c1:	0f af c2             	imul   %edx,%eax
   159c4:	01 c0                	add    %eax,%eax
   159c6:	83 ec 0c             	sub    $0xc,%esp
   159c9:	50                   	push   %eax
   159ca:	e8 2e ad fe ff       	call   6fd <malloc>
   159cf:	83 c4 10             	add    $0x10,%esp
   159d2:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   159d5:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   159d9:	75 0e                	jne    159e9 <_UpsampleV+0x54>
   159db:	8b 45 08             	mov    0x8(%ebp),%eax
   159de:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   159e4:	e9 6b 03 00 00       	jmp    15d54 <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   159e9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   159f0:	e9 1d 03 00 00       	jmp    15d12 <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   159f5:	8b 45 0c             	mov    0xc(%ebp),%eax
   159f8:	8b 50 28             	mov    0x28(%eax),%edx
   159fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   159fe:	01 d0                	add    %edx,%eax
   15a00:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   15a03:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15a06:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15a09:	01 d0                	add    %edx,%eax
   15a0b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   15a0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a11:	0f b6 00             	movzbl (%eax),%eax
   15a14:	0f b6 c0             	movzbl %al,%eax
   15a17:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15a1d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   15a20:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a23:	01 c8                	add    %ecx,%eax
   15a25:	0f b6 00             	movzbl (%eax),%eax
   15a28:	0f b6 c0             	movzbl %al,%eax
   15a2b:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15a2e:	01 d0                	add    %edx,%eax
   15a30:	83 ec 0c             	sub    $0xc,%esp
   15a33:	50                   	push   %eax
   15a34:	e8 1d 03 00 00       	call   15d56 <CF>
   15a39:	83 c4 10             	add    $0x10,%esp
   15a3c:	89 c2                	mov    %eax,%edx
   15a3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a41:	88 10                	mov    %dl,(%eax)
   15a43:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15a46:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   15a49:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a4c:	0f b6 00             	movzbl (%eax),%eax
   15a4f:	0f b6 c0             	movzbl %al,%eax
   15a52:	6b c8 68             	imul   $0x68,%eax,%ecx
   15a55:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15a58:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a5b:	01 d0                	add    %edx,%eax
   15a5d:	0f b6 00             	movzbl (%eax),%eax
   15a60:	0f b6 d0             	movzbl %al,%edx
   15a63:	89 d0                	mov    %edx,%eax
   15a65:	01 c0                	add    %eax,%eax
   15a67:	01 d0                	add    %edx,%eax
   15a69:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15a70:	01 d0                	add    %edx,%eax
   15a72:	01 c1                	add    %eax,%ecx
   15a74:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15a77:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a7a:	01 d0                	add    %edx,%eax
   15a7c:	0f b6 00             	movzbl (%eax),%eax
   15a7f:	0f b6 d0             	movzbl %al,%edx
   15a82:	89 d0                	mov    %edx,%eax
   15a84:	01 c0                	add    %eax,%eax
   15a86:	01 d0                	add    %edx,%eax
   15a88:	f7 d8                	neg    %eax
   15a8a:	01 c8                	add    %ecx,%eax
   15a8c:	83 ec 0c             	sub    $0xc,%esp
   15a8f:	50                   	push   %eax
   15a90:	e8 c1 02 00 00       	call   15d56 <CF>
   15a95:	83 c4 10             	add    $0x10,%esp
   15a98:	89 c2                	mov    %eax,%edx
   15a9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a9d:	88 10                	mov    %dl,(%eax)
   15a9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15aa2:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   15aa5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15aa8:	0f b6 00             	movzbl (%eax),%eax
   15aab:	0f b6 c0             	movzbl %al,%eax
   15aae:	c1 e0 02             	shl    $0x2,%eax
   15ab1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15ab8:	89 d1                	mov    %edx,%ecx
   15aba:	29 c1                	sub    %eax,%ecx
   15abc:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15abf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ac2:	01 d0                	add    %edx,%eax
   15ac4:	0f b6 00             	movzbl (%eax),%eax
   15ac7:	0f b6 c0             	movzbl %al,%eax
   15aca:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15acd:	01 c1                	add    %eax,%ecx
   15acf:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15ad2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ad5:	01 d0                	add    %edx,%eax
   15ad7:	0f b6 00             	movzbl (%eax),%eax
   15ada:	0f b6 d0             	movzbl %al,%edx
   15add:	89 d0                	mov    %edx,%eax
   15adf:	c1 e0 03             	shl    $0x3,%eax
   15ae2:	01 d0                	add    %edx,%eax
   15ae4:	f7 d8                	neg    %eax
   15ae6:	01 c8                	add    %ecx,%eax
   15ae8:	83 ec 0c             	sub    $0xc,%esp
   15aeb:	50                   	push   %eax
   15aec:	e8 65 02 00 00       	call   15d56 <CF>
   15af1:	83 c4 10             	add    $0x10,%esp
   15af4:	89 c2                	mov    %eax,%edx
   15af6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15af9:	88 10                	mov    %dl,(%eax)
   15afb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15afe:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   15b01:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b04:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   15b07:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b0a:	8b 40 10             	mov    0x10(%eax),%eax
   15b0d:	83 e8 03             	sub    $0x3,%eax
   15b10:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15b13:	e9 e6 00 00 00       	jmp    15bfe <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   15b18:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b1b:	f7 d8                	neg    %eax
   15b1d:	89 c2                	mov    %eax,%edx
   15b1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b22:	01 d0                	add    %edx,%eax
   15b24:	0f b6 00             	movzbl (%eax),%eax
   15b27:	0f b6 d0             	movzbl %al,%edx
   15b2a:	89 d0                	mov    %edx,%eax
   15b2c:	c1 e0 03             	shl    $0x3,%eax
   15b2f:	01 d0                	add    %edx,%eax
   15b31:	f7 d8                	neg    %eax
   15b33:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15b36:	0f b6 12             	movzbl (%edx),%edx
   15b39:	0f b6 d2             	movzbl %dl,%edx
   15b3c:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15b3f:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15b42:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15b45:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b48:	01 d0                	add    %edx,%eax
   15b4a:	0f b6 00             	movzbl (%eax),%eax
   15b4d:	0f b6 c0             	movzbl %al,%eax
   15b50:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15b53:	01 c1                	add    %eax,%ecx
   15b55:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15b58:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b5b:	01 d0                	add    %edx,%eax
   15b5d:	0f b6 00             	movzbl (%eax),%eax
   15b60:	0f b6 d0             	movzbl %al,%edx
   15b63:	89 d0                	mov    %edx,%eax
   15b65:	01 c0                	add    %eax,%eax
   15b67:	01 d0                	add    %edx,%eax
   15b69:	f7 d8                	neg    %eax
   15b6b:	01 c8                	add    %ecx,%eax
   15b6d:	83 ec 0c             	sub    $0xc,%esp
   15b70:	50                   	push   %eax
   15b71:	e8 e0 01 00 00       	call   15d56 <CF>
   15b76:	83 c4 10             	add    $0x10,%esp
   15b79:	89 c2                	mov    %eax,%edx
   15b7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b7e:	88 10                	mov    %dl,(%eax)
   15b80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b83:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   15b86:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b89:	f7 d8                	neg    %eax
   15b8b:	89 c2                	mov    %eax,%edx
   15b8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b90:	01 d0                	add    %edx,%eax
   15b92:	0f b6 00             	movzbl (%eax),%eax
   15b95:	0f b6 d0             	movzbl %al,%edx
   15b98:	89 d0                	mov    %edx,%eax
   15b9a:	01 c0                	add    %eax,%eax
   15b9c:	01 d0                	add    %edx,%eax
   15b9e:	f7 d8                	neg    %eax
   15ba0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15ba3:	0f b6 12             	movzbl (%edx),%edx
   15ba6:	0f b6 d2             	movzbl %dl,%edx
   15ba9:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15bac:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15baf:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15bb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bb5:	01 d0                	add    %edx,%eax
   15bb7:	0f b6 00             	movzbl (%eax),%eax
   15bba:	0f b6 c0             	movzbl %al,%eax
   15bbd:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15bc0:	01 c1                	add    %eax,%ecx
   15bc2:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15bc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bc8:	01 d0                	add    %edx,%eax
   15bca:	0f b6 00             	movzbl (%eax),%eax
   15bcd:	0f b6 d0             	movzbl %al,%edx
   15bd0:	89 d0                	mov    %edx,%eax
   15bd2:	c1 e0 03             	shl    $0x3,%eax
   15bd5:	01 d0                	add    %edx,%eax
   15bd7:	f7 d8                	neg    %eax
   15bd9:	01 c8                	add    %ecx,%eax
   15bdb:	83 ec 0c             	sub    $0xc,%esp
   15bde:	50                   	push   %eax
   15bdf:	e8 72 01 00 00       	call   15d56 <CF>
   15be4:	83 c4 10             	add    $0x10,%esp
   15be7:	89 c2                	mov    %eax,%edx
   15be9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15bec:	88 10                	mov    %dl,(%eax)
   15bee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15bf1:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   15bf4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15bf7:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   15bfa:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   15bfe:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15c02:	0f 85 10 ff ff ff    	jne    15b18 <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   15c08:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c0b:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   15c0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c11:	0f b6 00             	movzbl (%eax),%eax
   15c14:	0f b6 c0             	movzbl %al,%eax
   15c17:	c1 e0 02             	shl    $0x2,%eax
   15c1a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15c21:	29 c2                	sub    %eax,%edx
   15c23:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c26:	f7 d8                	neg    %eax
   15c28:	89 c1                	mov    %eax,%ecx
   15c2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c2d:	01 c8                	add    %ecx,%eax
   15c2f:	0f b6 00             	movzbl (%eax),%eax
   15c32:	0f b6 c0             	movzbl %al,%eax
   15c35:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15c38:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15c3b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15c3e:	f7 d8                	neg    %eax
   15c40:	89 c2                	mov    %eax,%edx
   15c42:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c45:	01 d0                	add    %edx,%eax
   15c47:	0f b6 00             	movzbl (%eax),%eax
   15c4a:	0f b6 d0             	movzbl %al,%edx
   15c4d:	89 d0                	mov    %edx,%eax
   15c4f:	c1 e0 03             	shl    $0x3,%eax
   15c52:	01 d0                	add    %edx,%eax
   15c54:	f7 d8                	neg    %eax
   15c56:	01 c8                	add    %ecx,%eax
   15c58:	83 ec 0c             	sub    $0xc,%esp
   15c5b:	50                   	push   %eax
   15c5c:	e8 f5 00 00 00       	call   15d56 <CF>
   15c61:	83 c4 10             	add    $0x10,%esp
   15c64:	89 c2                	mov    %eax,%edx
   15c66:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c69:	88 10                	mov    %dl,(%eax)
   15c6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15c6e:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   15c71:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c74:	0f b6 00             	movzbl (%eax),%eax
   15c77:	0f b6 c0             	movzbl %al,%eax
   15c7a:	6b c8 68             	imul   $0x68,%eax,%ecx
   15c7d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c80:	f7 d8                	neg    %eax
   15c82:	89 c2                	mov    %eax,%edx
   15c84:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c87:	01 d0                	add    %edx,%eax
   15c89:	0f b6 00             	movzbl (%eax),%eax
   15c8c:	0f b6 d0             	movzbl %al,%edx
   15c8f:	89 d0                	mov    %edx,%eax
   15c91:	01 c0                	add    %eax,%eax
   15c93:	01 d0                	add    %edx,%eax
   15c95:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15c9c:	01 d0                	add    %edx,%eax
   15c9e:	01 c1                	add    %eax,%ecx
   15ca0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15ca3:	f7 d8                	neg    %eax
   15ca5:	89 c2                	mov    %eax,%edx
   15ca7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15caa:	01 d0                	add    %edx,%eax
   15cac:	0f b6 00             	movzbl (%eax),%eax
   15caf:	0f b6 d0             	movzbl %al,%edx
   15cb2:	89 d0                	mov    %edx,%eax
   15cb4:	01 c0                	add    %eax,%eax
   15cb6:	01 d0                	add    %edx,%eax
   15cb8:	f7 d8                	neg    %eax
   15cba:	01 c8                	add    %ecx,%eax
   15cbc:	83 ec 0c             	sub    $0xc,%esp
   15cbf:	50                   	push   %eax
   15cc0:	e8 91 00 00 00       	call   15d56 <CF>
   15cc5:	83 c4 10             	add    $0x10,%esp
   15cc8:	89 c2                	mov    %eax,%edx
   15cca:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15ccd:	88 10                	mov    %dl,(%eax)
   15ccf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15cd2:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   15cd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cd8:	0f b6 00             	movzbl (%eax),%eax
   15cdb:	0f b6 c0             	movzbl %al,%eax
   15cde:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15ce4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15ce7:	f7 d8                	neg    %eax
   15ce9:	89 c1                	mov    %eax,%ecx
   15ceb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cee:	01 c8                	add    %ecx,%eax
   15cf0:	0f b6 00             	movzbl (%eax),%eax
   15cf3:	0f b6 c0             	movzbl %al,%eax
   15cf6:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15cf9:	01 d0                	add    %edx,%eax
   15cfb:	83 ec 0c             	sub    $0xc,%esp
   15cfe:	50                   	push   %eax
   15cff:	e8 52 00 00 00       	call   15d56 <CF>
   15d04:	83 c4 10             	add    $0x10,%esp
   15d07:	89 c2                	mov    %eax,%edx
   15d09:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d0c:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   15d0e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15d12:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15d15:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15d18:	0f 8c d7 fc ff ff    	jl     159f5 <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   15d1e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d21:	8b 40 10             	mov    0x10(%eax),%eax
   15d24:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15d27:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d2a:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   15d2d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d30:	8b 50 0c             	mov    0xc(%eax),%edx
   15d33:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d36:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15d39:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d3c:	8b 40 28             	mov    0x28(%eax),%eax
   15d3f:	83 ec 0c             	sub    $0xc,%esp
   15d42:	50                   	push   %eax
   15d43:	e8 73 a8 fe ff       	call   5bb <free>
   15d48:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15d4b:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d4e:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15d51:	89 50 28             	mov    %edx,0x28(%eax)
}
   15d54:	c9                   	leave  
   15d55:	c3                   	ret    

00015d56 <CF>:

uchar CF(const int x){
   15d56:	55                   	push   %ebp
   15d57:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   15d59:	8b 45 08             	mov    0x8(%ebp),%eax
   15d5c:	83 c0 40             	add    $0x40,%eax
   15d5f:	c1 f8 07             	sar    $0x7,%eax
   15d62:	50                   	push   %eax
   15d63:	e8 e9 dd ff ff       	call   13b51 <_Clip>
   15d68:	83 c4 04             	add    $0x4,%esp
}
   15d6b:	c9                   	leave  
   15d6c:	c3                   	ret    
