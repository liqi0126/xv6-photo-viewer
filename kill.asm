
_kill：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <main>:
#include "stat.h"
#include "user.h"

int
main(int argc, char **argv)
{
       0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
       4:	83 e4 f0             	and    $0xfffffff0,%esp
       7:	ff 71 fc             	pushl  -0x4(%ecx)
       a:	55                   	push   %ebp
       b:	89 e5                	mov    %esp,%ebp
       d:	53                   	push   %ebx
       e:	51                   	push   %ecx
       f:	83 ec 10             	sub    $0x10,%esp
      12:	89 cb                	mov    %ecx,%ebx
  int i;

  if(argc < 2){
      14:	83 3b 01             	cmpl   $0x1,(%ebx)
      17:	7f 17                	jg     30 <main+0x30>
    printf(2, "usage: kill pid...\n");
      19:	83 ec 08             	sub    $0x8,%esp
      1c:	68 c0 5d 01 00       	push   $0x15dc0
      21:	6a 02                	push   $0x2
      23:	e8 48 04 00 00       	call   470 <printf>
      28:	83 c4 10             	add    $0x10,%esp
    exit();
      2b:	e8 99 02 00 00       	call   2c9 <exit>
  }
  for(i=1; i<argc; i++)
      30:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
      37:	eb 2d                	jmp    66 <main+0x66>
    kill(atoi(argv[i]));
      39:	8b 45 f4             	mov    -0xc(%ebp),%eax
      3c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
      43:	8b 43 04             	mov    0x4(%ebx),%eax
      46:	01 d0                	add    %edx,%eax
      48:	8b 00                	mov    (%eax),%eax
      4a:	83 ec 0c             	sub    $0xc,%esp
      4d:	50                   	push   %eax
      4e:	e8 e4 01 00 00       	call   237 <atoi>
      53:	83 c4 10             	add    $0x10,%esp
      56:	83 ec 0c             	sub    $0xc,%esp
      59:	50                   	push   %eax
      5a:	e8 9a 02 00 00       	call   2f9 <kill>
      5f:	83 c4 10             	add    $0x10,%esp

  if(argc < 2){
    printf(2, "usage: kill pid...\n");
    exit();
  }
  for(i=1; i<argc; i++)
      62:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      66:	8b 45 f4             	mov    -0xc(%ebp),%eax
      69:	3b 03                	cmp    (%ebx),%eax
      6b:	7c cc                	jl     39 <main+0x39>
    kill(atoi(argv[i]));
  exit();
      6d:	e8 57 02 00 00       	call   2c9 <exit>

00000072 <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
      72:	55                   	push   %ebp
      73:	89 e5                	mov    %esp,%ebp
      75:	57                   	push   %edi
      76:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
      77:	8b 4d 08             	mov    0x8(%ebp),%ecx
      7a:	8b 55 10             	mov    0x10(%ebp),%edx
      7d:	8b 45 0c             	mov    0xc(%ebp),%eax
      80:	89 cb                	mov    %ecx,%ebx
      82:	89 df                	mov    %ebx,%edi
      84:	89 d1                	mov    %edx,%ecx
      86:	fc                   	cld    
      87:	f3 aa                	rep stos %al,%es:(%edi)
      89:	89 ca                	mov    %ecx,%edx
      8b:	89 fb                	mov    %edi,%ebx
      8d:	89 5d 08             	mov    %ebx,0x8(%ebp)
      90:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
      93:	90                   	nop
      94:	5b                   	pop    %ebx
      95:	5f                   	pop    %edi
      96:	5d                   	pop    %ebp
      97:	c3                   	ret    

00000098 <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
      98:	55                   	push   %ebp
      99:	89 e5                	mov    %esp,%ebp
      9b:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
      9e:	8b 45 08             	mov    0x8(%ebp),%eax
      a1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
      a4:	90                   	nop
      a5:	8b 45 08             	mov    0x8(%ebp),%eax
      a8:	8d 50 01             	lea    0x1(%eax),%edx
      ab:	89 55 08             	mov    %edx,0x8(%ebp)
      ae:	8b 55 0c             	mov    0xc(%ebp),%edx
      b1:	8d 4a 01             	lea    0x1(%edx),%ecx
      b4:	89 4d 0c             	mov    %ecx,0xc(%ebp)
      b7:	0f b6 12             	movzbl (%edx),%edx
      ba:	88 10                	mov    %dl,(%eax)
      bc:	0f b6 00             	movzbl (%eax),%eax
      bf:	84 c0                	test   %al,%al
      c1:	75 e2                	jne    a5 <strcpy+0xd>
    ;
  return os;
      c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
      c6:	c9                   	leave  
      c7:	c3                   	ret    

000000c8 <strcmp>:

int
strcmp(const char *p, const char *q)
{
      c8:	55                   	push   %ebp
      c9:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
      cb:	eb 08                	jmp    d5 <strcmp+0xd>
    p++, q++;
      cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      d1:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
      d5:	8b 45 08             	mov    0x8(%ebp),%eax
      d8:	0f b6 00             	movzbl (%eax),%eax
      db:	84 c0                	test   %al,%al
      dd:	74 10                	je     ef <strcmp+0x27>
      df:	8b 45 08             	mov    0x8(%ebp),%eax
      e2:	0f b6 10             	movzbl (%eax),%edx
      e5:	8b 45 0c             	mov    0xc(%ebp),%eax
      e8:	0f b6 00             	movzbl (%eax),%eax
      eb:	38 c2                	cmp    %al,%dl
      ed:	74 de                	je     cd <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
      ef:	8b 45 08             	mov    0x8(%ebp),%eax
      f2:	0f b6 00             	movzbl (%eax),%eax
      f5:	0f b6 d0             	movzbl %al,%edx
      f8:	8b 45 0c             	mov    0xc(%ebp),%eax
      fb:	0f b6 00             	movzbl (%eax),%eax
      fe:	0f b6 c0             	movzbl %al,%eax
     101:	29 c2                	sub    %eax,%edx
     103:	89 d0                	mov    %edx,%eax
}
     105:	5d                   	pop    %ebp
     106:	c3                   	ret    

00000107 <strlen>:

uint
strlen(char *s)
{
     107:	55                   	push   %ebp
     108:	89 e5                	mov    %esp,%ebp
     10a:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
     10d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     114:	eb 04                	jmp    11a <strlen+0x13>
     116:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
     11a:	8b 55 fc             	mov    -0x4(%ebp),%edx
     11d:	8b 45 08             	mov    0x8(%ebp),%eax
     120:	01 d0                	add    %edx,%eax
     122:	0f b6 00             	movzbl (%eax),%eax
     125:	84 c0                	test   %al,%al
     127:	75 ed                	jne    116 <strlen+0xf>
    ;
  return n;
     129:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     12c:	c9                   	leave  
     12d:	c3                   	ret    

0000012e <memset>:

void*
memset(void *dst, int c, uint n)
{
     12e:	55                   	push   %ebp
     12f:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
     131:	8b 45 10             	mov    0x10(%ebp),%eax
     134:	50                   	push   %eax
     135:	ff 75 0c             	pushl  0xc(%ebp)
     138:	ff 75 08             	pushl  0x8(%ebp)
     13b:	e8 32 ff ff ff       	call   72 <stosb>
     140:	83 c4 0c             	add    $0xc,%esp
  return dst;
     143:	8b 45 08             	mov    0x8(%ebp),%eax
}
     146:	c9                   	leave  
     147:	c3                   	ret    

00000148 <strchr>:

char*
strchr(const char *s, char c)
{
     148:	55                   	push   %ebp
     149:	89 e5                	mov    %esp,%ebp
     14b:	83 ec 04             	sub    $0x4,%esp
     14e:	8b 45 0c             	mov    0xc(%ebp),%eax
     151:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     154:	eb 14                	jmp    16a <strchr+0x22>
    if(*s == c)
     156:	8b 45 08             	mov    0x8(%ebp),%eax
     159:	0f b6 00             	movzbl (%eax),%eax
     15c:	3a 45 fc             	cmp    -0x4(%ebp),%al
     15f:	75 05                	jne    166 <strchr+0x1e>
      return (char*)s;
     161:	8b 45 08             	mov    0x8(%ebp),%eax
     164:	eb 13                	jmp    179 <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     166:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     16a:	8b 45 08             	mov    0x8(%ebp),%eax
     16d:	0f b6 00             	movzbl (%eax),%eax
     170:	84 c0                	test   %al,%al
     172:	75 e2                	jne    156 <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     174:	b8 00 00 00 00       	mov    $0x0,%eax
}
     179:	c9                   	leave  
     17a:	c3                   	ret    

0000017b <gets>:

char*
gets(char *buf, int max)
{
     17b:	55                   	push   %ebp
     17c:	89 e5                	mov    %esp,%ebp
     17e:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     181:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     188:	eb 42                	jmp    1cc <gets+0x51>
    cc = read(0, &c, 1);
     18a:	83 ec 04             	sub    $0x4,%esp
     18d:	6a 01                	push   $0x1
     18f:	8d 45 ef             	lea    -0x11(%ebp),%eax
     192:	50                   	push   %eax
     193:	6a 00                	push   $0x0
     195:	e8 47 01 00 00       	call   2e1 <read>
     19a:	83 c4 10             	add    $0x10,%esp
     19d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     1a0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     1a4:	7e 33                	jle    1d9 <gets+0x5e>
      break;
    buf[i++] = c;
     1a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
     1a9:	8d 50 01             	lea    0x1(%eax),%edx
     1ac:	89 55 f4             	mov    %edx,-0xc(%ebp)
     1af:	89 c2                	mov    %eax,%edx
     1b1:	8b 45 08             	mov    0x8(%ebp),%eax
     1b4:	01 c2                	add    %eax,%edx
     1b6:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     1ba:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     1bc:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     1c0:	3c 0a                	cmp    $0xa,%al
     1c2:	74 16                	je     1da <gets+0x5f>
     1c4:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     1c8:	3c 0d                	cmp    $0xd,%al
     1ca:	74 0e                	je     1da <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     1cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
     1cf:	83 c0 01             	add    $0x1,%eax
     1d2:	3b 45 0c             	cmp    0xc(%ebp),%eax
     1d5:	7c b3                	jl     18a <gets+0xf>
     1d7:	eb 01                	jmp    1da <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     1d9:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     1da:	8b 55 f4             	mov    -0xc(%ebp),%edx
     1dd:	8b 45 08             	mov    0x8(%ebp),%eax
     1e0:	01 d0                	add    %edx,%eax
     1e2:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     1e5:	8b 45 08             	mov    0x8(%ebp),%eax
}
     1e8:	c9                   	leave  
     1e9:	c3                   	ret    

000001ea <stat>:

int
stat(char *n, struct stat *st)
{
     1ea:	55                   	push   %ebp
     1eb:	89 e5                	mov    %esp,%ebp
     1ed:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     1f0:	83 ec 08             	sub    $0x8,%esp
     1f3:	6a 00                	push   $0x0
     1f5:	ff 75 08             	pushl  0x8(%ebp)
     1f8:	e8 0c 01 00 00       	call   309 <open>
     1fd:	83 c4 10             	add    $0x10,%esp
     200:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     203:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     207:	79 07                	jns    210 <stat+0x26>
    return -1;
     209:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     20e:	eb 25                	jmp    235 <stat+0x4b>
  r = fstat(fd, st);
     210:	83 ec 08             	sub    $0x8,%esp
     213:	ff 75 0c             	pushl  0xc(%ebp)
     216:	ff 75 f4             	pushl  -0xc(%ebp)
     219:	e8 03 01 00 00       	call   321 <fstat>
     21e:	83 c4 10             	add    $0x10,%esp
     221:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     224:	83 ec 0c             	sub    $0xc,%esp
     227:	ff 75 f4             	pushl  -0xc(%ebp)
     22a:	e8 c2 00 00 00       	call   2f1 <close>
     22f:	83 c4 10             	add    $0x10,%esp
  return r;
     232:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     235:	c9                   	leave  
     236:	c3                   	ret    

00000237 <atoi>:

int
atoi(const char *s)
{
     237:	55                   	push   %ebp
     238:	89 e5                	mov    %esp,%ebp
     23a:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     23d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     244:	eb 25                	jmp    26b <atoi+0x34>
    n = n*10 + *s++ - '0';
     246:	8b 55 fc             	mov    -0x4(%ebp),%edx
     249:	89 d0                	mov    %edx,%eax
     24b:	c1 e0 02             	shl    $0x2,%eax
     24e:	01 d0                	add    %edx,%eax
     250:	01 c0                	add    %eax,%eax
     252:	89 c1                	mov    %eax,%ecx
     254:	8b 45 08             	mov    0x8(%ebp),%eax
     257:	8d 50 01             	lea    0x1(%eax),%edx
     25a:	89 55 08             	mov    %edx,0x8(%ebp)
     25d:	0f b6 00             	movzbl (%eax),%eax
     260:	0f be c0             	movsbl %al,%eax
     263:	01 c8                	add    %ecx,%eax
     265:	83 e8 30             	sub    $0x30,%eax
     268:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     26b:	8b 45 08             	mov    0x8(%ebp),%eax
     26e:	0f b6 00             	movzbl (%eax),%eax
     271:	3c 2f                	cmp    $0x2f,%al
     273:	7e 0a                	jle    27f <atoi+0x48>
     275:	8b 45 08             	mov    0x8(%ebp),%eax
     278:	0f b6 00             	movzbl (%eax),%eax
     27b:	3c 39                	cmp    $0x39,%al
     27d:	7e c7                	jle    246 <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     27f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     282:	c9                   	leave  
     283:	c3                   	ret    

00000284 <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     284:	55                   	push   %ebp
     285:	89 e5                	mov    %esp,%ebp
     287:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     28a:	8b 45 08             	mov    0x8(%ebp),%eax
     28d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     290:	8b 45 0c             	mov    0xc(%ebp),%eax
     293:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     296:	eb 17                	jmp    2af <memmove+0x2b>
    *dst++ = *src++;
     298:	8b 45 fc             	mov    -0x4(%ebp),%eax
     29b:	8d 50 01             	lea    0x1(%eax),%edx
     29e:	89 55 fc             	mov    %edx,-0x4(%ebp)
     2a1:	8b 55 f8             	mov    -0x8(%ebp),%edx
     2a4:	8d 4a 01             	lea    0x1(%edx),%ecx
     2a7:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     2aa:	0f b6 12             	movzbl (%edx),%edx
     2ad:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     2af:	8b 45 10             	mov    0x10(%ebp),%eax
     2b2:	8d 50 ff             	lea    -0x1(%eax),%edx
     2b5:	89 55 10             	mov    %edx,0x10(%ebp)
     2b8:	85 c0                	test   %eax,%eax
     2ba:	7f dc                	jg     298 <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     2bc:	8b 45 08             	mov    0x8(%ebp),%eax
}
     2bf:	c9                   	leave  
     2c0:	c3                   	ret    

000002c1 <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     2c1:	b8 01 00 00 00       	mov    $0x1,%eax
     2c6:	cd 40                	int    $0x40
     2c8:	c3                   	ret    

000002c9 <exit>:
SYSCALL(exit)
     2c9:	b8 02 00 00 00       	mov    $0x2,%eax
     2ce:	cd 40                	int    $0x40
     2d0:	c3                   	ret    

000002d1 <wait>:
SYSCALL(wait)
     2d1:	b8 03 00 00 00       	mov    $0x3,%eax
     2d6:	cd 40                	int    $0x40
     2d8:	c3                   	ret    

000002d9 <pipe>:
SYSCALL(pipe)
     2d9:	b8 04 00 00 00       	mov    $0x4,%eax
     2de:	cd 40                	int    $0x40
     2e0:	c3                   	ret    

000002e1 <read>:
SYSCALL(read)
     2e1:	b8 05 00 00 00       	mov    $0x5,%eax
     2e6:	cd 40                	int    $0x40
     2e8:	c3                   	ret    

000002e9 <write>:
SYSCALL(write)
     2e9:	b8 10 00 00 00       	mov    $0x10,%eax
     2ee:	cd 40                	int    $0x40
     2f0:	c3                   	ret    

000002f1 <close>:
SYSCALL(close)
     2f1:	b8 15 00 00 00       	mov    $0x15,%eax
     2f6:	cd 40                	int    $0x40
     2f8:	c3                   	ret    

000002f9 <kill>:
SYSCALL(kill)
     2f9:	b8 06 00 00 00       	mov    $0x6,%eax
     2fe:	cd 40                	int    $0x40
     300:	c3                   	ret    

00000301 <exec>:
SYSCALL(exec)
     301:	b8 07 00 00 00       	mov    $0x7,%eax
     306:	cd 40                	int    $0x40
     308:	c3                   	ret    

00000309 <open>:
SYSCALL(open)
     309:	b8 0f 00 00 00       	mov    $0xf,%eax
     30e:	cd 40                	int    $0x40
     310:	c3                   	ret    

00000311 <mknod>:
SYSCALL(mknod)
     311:	b8 11 00 00 00       	mov    $0x11,%eax
     316:	cd 40                	int    $0x40
     318:	c3                   	ret    

00000319 <unlink>:
SYSCALL(unlink)
     319:	b8 12 00 00 00       	mov    $0x12,%eax
     31e:	cd 40                	int    $0x40
     320:	c3                   	ret    

00000321 <fstat>:
SYSCALL(fstat)
     321:	b8 08 00 00 00       	mov    $0x8,%eax
     326:	cd 40                	int    $0x40
     328:	c3                   	ret    

00000329 <link>:
SYSCALL(link)
     329:	b8 13 00 00 00       	mov    $0x13,%eax
     32e:	cd 40                	int    $0x40
     330:	c3                   	ret    

00000331 <mkdir>:
SYSCALL(mkdir)
     331:	b8 14 00 00 00       	mov    $0x14,%eax
     336:	cd 40                	int    $0x40
     338:	c3                   	ret    

00000339 <chdir>:
SYSCALL(chdir)
     339:	b8 09 00 00 00       	mov    $0x9,%eax
     33e:	cd 40                	int    $0x40
     340:	c3                   	ret    

00000341 <dup>:
SYSCALL(dup)
     341:	b8 0a 00 00 00       	mov    $0xa,%eax
     346:	cd 40                	int    $0x40
     348:	c3                   	ret    

00000349 <getpid>:
SYSCALL(getpid)
     349:	b8 0b 00 00 00       	mov    $0xb,%eax
     34e:	cd 40                	int    $0x40
     350:	c3                   	ret    

00000351 <sbrk>:
SYSCALL(sbrk)
     351:	b8 0c 00 00 00       	mov    $0xc,%eax
     356:	cd 40                	int    $0x40
     358:	c3                   	ret    

00000359 <sleep>:
SYSCALL(sleep)
     359:	b8 0d 00 00 00       	mov    $0xd,%eax
     35e:	cd 40                	int    $0x40
     360:	c3                   	ret    

00000361 <uptime>:
SYSCALL(uptime)
     361:	b8 0e 00 00 00       	mov    $0xe,%eax
     366:	cd 40                	int    $0x40
     368:	c3                   	ret    

00000369 <createwindow>:
SYSCALL(createwindow)
     369:	b8 16 00 00 00       	mov    $0x16,%eax
     36e:	cd 40                	int    $0x40
     370:	c3                   	ret    

00000371 <repaintwindow>:
SYSCALL(repaintwindow)
     371:	b8 17 00 00 00       	mov    $0x17,%eax
     376:	cd 40                	int    $0x40
     378:	c3                   	ret    

00000379 <getmessage>:
SYSCALL(getmessage)
     379:	b8 18 00 00 00       	mov    $0x18,%eax
     37e:	cd 40                	int    $0x40
     380:	c3                   	ret    

00000381 <settimer>:
SYSCALL(settimer)
     381:	b8 19 00 00 00       	mov    $0x19,%eax
     386:	cd 40                	int    $0x40
     388:	c3                   	ret    

00000389 <updatewindow>:
SYSCALL(updatewindow)
     389:	b8 1a 00 00 00       	mov    $0x1a,%eax
     38e:	cd 40                	int    $0x40
     390:	c3                   	ret    

00000391 <destroywindow>:
SYSCALL(destroywindow)
     391:	b8 1b 00 00 00       	mov    $0x1b,%eax
     396:	cd 40                	int    $0x40
     398:	c3                   	ret    

00000399 <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     399:	55                   	push   %ebp
     39a:	89 e5                	mov    %esp,%ebp
     39c:	83 ec 18             	sub    $0x18,%esp
     39f:	8b 45 0c             	mov    0xc(%ebp),%eax
     3a2:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     3a5:	83 ec 04             	sub    $0x4,%esp
     3a8:	6a 01                	push   $0x1
     3aa:	8d 45 f4             	lea    -0xc(%ebp),%eax
     3ad:	50                   	push   %eax
     3ae:	ff 75 08             	pushl  0x8(%ebp)
     3b1:	e8 33 ff ff ff       	call   2e9 <write>
     3b6:	83 c4 10             	add    $0x10,%esp
}
     3b9:	90                   	nop
     3ba:	c9                   	leave  
     3bb:	c3                   	ret    

000003bc <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     3bc:	55                   	push   %ebp
     3bd:	89 e5                	mov    %esp,%ebp
     3bf:	53                   	push   %ebx
     3c0:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     3c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     3ca:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     3ce:	74 17                	je     3e7 <printint+0x2b>
     3d0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     3d4:	79 11                	jns    3e7 <printint+0x2b>
    neg = 1;
     3d6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     3dd:	8b 45 0c             	mov    0xc(%ebp),%eax
     3e0:	f7 d8                	neg    %eax
     3e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
     3e5:	eb 06                	jmp    3ed <printint+0x31>
  } else {
    x = xx;
     3e7:	8b 45 0c             	mov    0xc(%ebp),%eax
     3ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     3ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     3f4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     3f7:	8d 41 01             	lea    0x1(%ecx),%eax
     3fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
     3fd:	8b 5d 10             	mov    0x10(%ebp),%ebx
     400:	8b 45 ec             	mov    -0x14(%ebp),%eax
     403:	ba 00 00 00 00       	mov    $0x0,%edx
     408:	f7 f3                	div    %ebx
     40a:	89 d0                	mov    %edx,%eax
     40c:	0f b6 80 c0 e0 01 00 	movzbl 0x1e0c0(%eax),%eax
     413:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     417:	8b 5d 10             	mov    0x10(%ebp),%ebx
     41a:	8b 45 ec             	mov    -0x14(%ebp),%eax
     41d:	ba 00 00 00 00       	mov    $0x0,%edx
     422:	f7 f3                	div    %ebx
     424:	89 45 ec             	mov    %eax,-0x14(%ebp)
     427:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     42b:	75 c7                	jne    3f4 <printint+0x38>
  if(neg)
     42d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     431:	74 2d                	je     460 <printint+0xa4>
    buf[i++] = '-';
     433:	8b 45 f4             	mov    -0xc(%ebp),%eax
     436:	8d 50 01             	lea    0x1(%eax),%edx
     439:	89 55 f4             	mov    %edx,-0xc(%ebp)
     43c:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     441:	eb 1d                	jmp    460 <printint+0xa4>
    putc(fd, buf[i]);
     443:	8d 55 dc             	lea    -0x24(%ebp),%edx
     446:	8b 45 f4             	mov    -0xc(%ebp),%eax
     449:	01 d0                	add    %edx,%eax
     44b:	0f b6 00             	movzbl (%eax),%eax
     44e:	0f be c0             	movsbl %al,%eax
     451:	83 ec 08             	sub    $0x8,%esp
     454:	50                   	push   %eax
     455:	ff 75 08             	pushl  0x8(%ebp)
     458:	e8 3c ff ff ff       	call   399 <putc>
     45d:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     460:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     464:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     468:	79 d9                	jns    443 <printint+0x87>
    putc(fd, buf[i]);
}
     46a:	90                   	nop
     46b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     46e:	c9                   	leave  
     46f:	c3                   	ret    

00000470 <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     470:	55                   	push   %ebp
     471:	89 e5                	mov    %esp,%ebp
     473:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     476:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
     47d:	8d 45 0c             	lea    0xc(%ebp),%eax
     480:	83 c0 04             	add    $0x4,%eax
     483:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
     486:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     48d:	e9 59 01 00 00       	jmp    5eb <printf+0x17b>
    c = fmt[i] & 0xff;
     492:	8b 55 0c             	mov    0xc(%ebp),%edx
     495:	8b 45 f0             	mov    -0x10(%ebp),%eax
     498:	01 d0                	add    %edx,%eax
     49a:	0f b6 00             	movzbl (%eax),%eax
     49d:	0f be c0             	movsbl %al,%eax
     4a0:	25 ff 00 00 00       	and    $0xff,%eax
     4a5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
     4a8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     4ac:	75 2c                	jne    4da <printf+0x6a>
      if(c == '%'){
     4ae:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     4b2:	75 0c                	jne    4c0 <printf+0x50>
        state = '%';
     4b4:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
     4bb:	e9 27 01 00 00       	jmp    5e7 <printf+0x177>
      } else {
        putc(fd, c);
     4c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     4c3:	0f be c0             	movsbl %al,%eax
     4c6:	83 ec 08             	sub    $0x8,%esp
     4c9:	50                   	push   %eax
     4ca:	ff 75 08             	pushl  0x8(%ebp)
     4cd:	e8 c7 fe ff ff       	call   399 <putc>
     4d2:	83 c4 10             	add    $0x10,%esp
     4d5:	e9 0d 01 00 00       	jmp    5e7 <printf+0x177>
      }
    } else if(state == '%'){
     4da:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
     4de:	0f 85 03 01 00 00    	jne    5e7 <printf+0x177>
      if(c == 'd'){
     4e4:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
     4e8:	75 1e                	jne    508 <printf+0x98>
        printint(fd, *ap, 10, 1);
     4ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
     4ed:	8b 00                	mov    (%eax),%eax
     4ef:	6a 01                	push   $0x1
     4f1:	6a 0a                	push   $0xa
     4f3:	50                   	push   %eax
     4f4:	ff 75 08             	pushl  0x8(%ebp)
     4f7:	e8 c0 fe ff ff       	call   3bc <printint>
     4fc:	83 c4 10             	add    $0x10,%esp
        ap++;
     4ff:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     503:	e9 d8 00 00 00       	jmp    5e0 <printf+0x170>
      } else if(c == 'x' || c == 'p'){
     508:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
     50c:	74 06                	je     514 <printf+0xa4>
     50e:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
     512:	75 1e                	jne    532 <printf+0xc2>
        printint(fd, *ap, 16, 0);
     514:	8b 45 e8             	mov    -0x18(%ebp),%eax
     517:	8b 00                	mov    (%eax),%eax
     519:	6a 00                	push   $0x0
     51b:	6a 10                	push   $0x10
     51d:	50                   	push   %eax
     51e:	ff 75 08             	pushl  0x8(%ebp)
     521:	e8 96 fe ff ff       	call   3bc <printint>
     526:	83 c4 10             	add    $0x10,%esp
        ap++;
     529:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     52d:	e9 ae 00 00 00       	jmp    5e0 <printf+0x170>
      } else if(c == 's'){
     532:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
     536:	75 43                	jne    57b <printf+0x10b>
        s = (char*)*ap;
     538:	8b 45 e8             	mov    -0x18(%ebp),%eax
     53b:	8b 00                	mov    (%eax),%eax
     53d:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
     540:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
     544:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     548:	75 25                	jne    56f <printf+0xff>
          s = "(null)";
     54a:	c7 45 f4 d4 5d 01 00 	movl   $0x15dd4,-0xc(%ebp)
        while(*s != 0){
     551:	eb 1c                	jmp    56f <printf+0xff>
          putc(fd, *s);
     553:	8b 45 f4             	mov    -0xc(%ebp),%eax
     556:	0f b6 00             	movzbl (%eax),%eax
     559:	0f be c0             	movsbl %al,%eax
     55c:	83 ec 08             	sub    $0x8,%esp
     55f:	50                   	push   %eax
     560:	ff 75 08             	pushl  0x8(%ebp)
     563:	e8 31 fe ff ff       	call   399 <putc>
     568:	83 c4 10             	add    $0x10,%esp
          s++;
     56b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
     56f:	8b 45 f4             	mov    -0xc(%ebp),%eax
     572:	0f b6 00             	movzbl (%eax),%eax
     575:	84 c0                	test   %al,%al
     577:	75 da                	jne    553 <printf+0xe3>
     579:	eb 65                	jmp    5e0 <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
     57b:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
     57f:	75 1d                	jne    59e <printf+0x12e>
        putc(fd, *ap);
     581:	8b 45 e8             	mov    -0x18(%ebp),%eax
     584:	8b 00                	mov    (%eax),%eax
     586:	0f be c0             	movsbl %al,%eax
     589:	83 ec 08             	sub    $0x8,%esp
     58c:	50                   	push   %eax
     58d:	ff 75 08             	pushl  0x8(%ebp)
     590:	e8 04 fe ff ff       	call   399 <putc>
     595:	83 c4 10             	add    $0x10,%esp
        ap++;
     598:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     59c:	eb 42                	jmp    5e0 <printf+0x170>
      } else if(c == '%'){
     59e:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     5a2:	75 17                	jne    5bb <printf+0x14b>
        putc(fd, c);
     5a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     5a7:	0f be c0             	movsbl %al,%eax
     5aa:	83 ec 08             	sub    $0x8,%esp
     5ad:	50                   	push   %eax
     5ae:	ff 75 08             	pushl  0x8(%ebp)
     5b1:	e8 e3 fd ff ff       	call   399 <putc>
     5b6:	83 c4 10             	add    $0x10,%esp
     5b9:	eb 25                	jmp    5e0 <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
     5bb:	83 ec 08             	sub    $0x8,%esp
     5be:	6a 25                	push   $0x25
     5c0:	ff 75 08             	pushl  0x8(%ebp)
     5c3:	e8 d1 fd ff ff       	call   399 <putc>
     5c8:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
     5cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     5ce:	0f be c0             	movsbl %al,%eax
     5d1:	83 ec 08             	sub    $0x8,%esp
     5d4:	50                   	push   %eax
     5d5:	ff 75 08             	pushl  0x8(%ebp)
     5d8:	e8 bc fd ff ff       	call   399 <putc>
     5dd:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
     5e0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
     5e7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     5eb:	8b 55 0c             	mov    0xc(%ebp),%edx
     5ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
     5f1:	01 d0                	add    %edx,%eax
     5f3:	0f b6 00             	movzbl (%eax),%eax
     5f6:	84 c0                	test   %al,%al
     5f8:	0f 85 94 fe ff ff    	jne    492 <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
     5fe:	90                   	nop
     5ff:	c9                   	leave  
     600:	c3                   	ret    

00000601 <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
     601:	55                   	push   %ebp
     602:	89 e5                	mov    %esp,%ebp
     604:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
     607:	8b 45 08             	mov    0x8(%ebp),%eax
     60a:	83 e8 08             	sub    $0x8,%eax
     60d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     610:	a1 08 e5 01 00       	mov    0x1e508,%eax
     615:	89 45 fc             	mov    %eax,-0x4(%ebp)
     618:	eb 24                	jmp    63e <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
     61a:	8b 45 fc             	mov    -0x4(%ebp),%eax
     61d:	8b 00                	mov    (%eax),%eax
     61f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     622:	77 12                	ja     636 <free+0x35>
     624:	8b 45 f8             	mov    -0x8(%ebp),%eax
     627:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     62a:	77 24                	ja     650 <free+0x4f>
     62c:	8b 45 fc             	mov    -0x4(%ebp),%eax
     62f:	8b 00                	mov    (%eax),%eax
     631:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     634:	77 1a                	ja     650 <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     636:	8b 45 fc             	mov    -0x4(%ebp),%eax
     639:	8b 00                	mov    (%eax),%eax
     63b:	89 45 fc             	mov    %eax,-0x4(%ebp)
     63e:	8b 45 f8             	mov    -0x8(%ebp),%eax
     641:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     644:	76 d4                	jbe    61a <free+0x19>
     646:	8b 45 fc             	mov    -0x4(%ebp),%eax
     649:	8b 00                	mov    (%eax),%eax
     64b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     64e:	76 ca                	jbe    61a <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
     650:	8b 45 f8             	mov    -0x8(%ebp),%eax
     653:	8b 40 04             	mov    0x4(%eax),%eax
     656:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     65d:	8b 45 f8             	mov    -0x8(%ebp),%eax
     660:	01 c2                	add    %eax,%edx
     662:	8b 45 fc             	mov    -0x4(%ebp),%eax
     665:	8b 00                	mov    (%eax),%eax
     667:	39 c2                	cmp    %eax,%edx
     669:	75 24                	jne    68f <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
     66b:	8b 45 f8             	mov    -0x8(%ebp),%eax
     66e:	8b 50 04             	mov    0x4(%eax),%edx
     671:	8b 45 fc             	mov    -0x4(%ebp),%eax
     674:	8b 00                	mov    (%eax),%eax
     676:	8b 40 04             	mov    0x4(%eax),%eax
     679:	01 c2                	add    %eax,%edx
     67b:	8b 45 f8             	mov    -0x8(%ebp),%eax
     67e:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
     681:	8b 45 fc             	mov    -0x4(%ebp),%eax
     684:	8b 00                	mov    (%eax),%eax
     686:	8b 10                	mov    (%eax),%edx
     688:	8b 45 f8             	mov    -0x8(%ebp),%eax
     68b:	89 10                	mov    %edx,(%eax)
     68d:	eb 0a                	jmp    699 <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
     68f:	8b 45 fc             	mov    -0x4(%ebp),%eax
     692:	8b 10                	mov    (%eax),%edx
     694:	8b 45 f8             	mov    -0x8(%ebp),%eax
     697:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
     699:	8b 45 fc             	mov    -0x4(%ebp),%eax
     69c:	8b 40 04             	mov    0x4(%eax),%eax
     69f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     6a6:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6a9:	01 d0                	add    %edx,%eax
     6ab:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     6ae:	75 20                	jne    6d0 <free+0xcf>
    p->s.size += bp->s.size;
     6b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6b3:	8b 50 04             	mov    0x4(%eax),%edx
     6b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6b9:	8b 40 04             	mov    0x4(%eax),%eax
     6bc:	01 c2                	add    %eax,%edx
     6be:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6c1:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
     6c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6c7:	8b 10                	mov    (%eax),%edx
     6c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6cc:	89 10                	mov    %edx,(%eax)
     6ce:	eb 08                	jmp    6d8 <free+0xd7>
  } else
    p->s.ptr = bp;
     6d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6d3:	8b 55 f8             	mov    -0x8(%ebp),%edx
     6d6:	89 10                	mov    %edx,(%eax)
  freep = p;
     6d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6db:	a3 08 e5 01 00       	mov    %eax,0x1e508
}
     6e0:	90                   	nop
     6e1:	c9                   	leave  
     6e2:	c3                   	ret    

000006e3 <morecore>:

static Header*
morecore(uint nu)
{
     6e3:	55                   	push   %ebp
     6e4:	89 e5                	mov    %esp,%ebp
     6e6:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
     6e9:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
     6f0:	77 07                	ja     6f9 <morecore+0x16>
    nu = 4096;
     6f2:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
     6f9:	8b 45 08             	mov    0x8(%ebp),%eax
     6fc:	c1 e0 03             	shl    $0x3,%eax
     6ff:	83 ec 0c             	sub    $0xc,%esp
     702:	50                   	push   %eax
     703:	e8 49 fc ff ff       	call   351 <sbrk>
     708:	83 c4 10             	add    $0x10,%esp
     70b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
     70e:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     712:	75 07                	jne    71b <morecore+0x38>
    return 0;
     714:	b8 00 00 00 00       	mov    $0x0,%eax
     719:	eb 26                	jmp    741 <morecore+0x5e>
  hp = (Header*)p;
     71b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     71e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
     721:	8b 45 f0             	mov    -0x10(%ebp),%eax
     724:	8b 55 08             	mov    0x8(%ebp),%edx
     727:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
     72a:	8b 45 f0             	mov    -0x10(%ebp),%eax
     72d:	83 c0 08             	add    $0x8,%eax
     730:	83 ec 0c             	sub    $0xc,%esp
     733:	50                   	push   %eax
     734:	e8 c8 fe ff ff       	call   601 <free>
     739:	83 c4 10             	add    $0x10,%esp
  return freep;
     73c:	a1 08 e5 01 00       	mov    0x1e508,%eax
}
     741:	c9                   	leave  
     742:	c3                   	ret    

00000743 <malloc>:

void*
malloc(uint nbytes)
{
     743:	55                   	push   %ebp
     744:	89 e5                	mov    %esp,%ebp
     746:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
     749:	8b 45 08             	mov    0x8(%ebp),%eax
     74c:	83 c0 07             	add    $0x7,%eax
     74f:	c1 e8 03             	shr    $0x3,%eax
     752:	83 c0 01             	add    $0x1,%eax
     755:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
     758:	a1 08 e5 01 00       	mov    0x1e508,%eax
     75d:	89 45 f0             	mov    %eax,-0x10(%ebp)
     760:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     764:	75 23                	jne    789 <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
     766:	c7 45 f0 00 e5 01 00 	movl   $0x1e500,-0x10(%ebp)
     76d:	8b 45 f0             	mov    -0x10(%ebp),%eax
     770:	a3 08 e5 01 00       	mov    %eax,0x1e508
     775:	a1 08 e5 01 00       	mov    0x1e508,%eax
     77a:	a3 00 e5 01 00       	mov    %eax,0x1e500
    base.s.size = 0;
     77f:	c7 05 04 e5 01 00 00 	movl   $0x0,0x1e504
     786:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     789:	8b 45 f0             	mov    -0x10(%ebp),%eax
     78c:	8b 00                	mov    (%eax),%eax
     78e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
     791:	8b 45 f4             	mov    -0xc(%ebp),%eax
     794:	8b 40 04             	mov    0x4(%eax),%eax
     797:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     79a:	72 4d                	jb     7e9 <malloc+0xa6>
      if(p->s.size == nunits)
     79c:	8b 45 f4             	mov    -0xc(%ebp),%eax
     79f:	8b 40 04             	mov    0x4(%eax),%eax
     7a2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     7a5:	75 0c                	jne    7b3 <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
     7a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7aa:	8b 10                	mov    (%eax),%edx
     7ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
     7af:	89 10                	mov    %edx,(%eax)
     7b1:	eb 26                	jmp    7d9 <malloc+0x96>
      else {
        p->s.size -= nunits;
     7b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7b6:	8b 40 04             	mov    0x4(%eax),%eax
     7b9:	2b 45 ec             	sub    -0x14(%ebp),%eax
     7bc:	89 c2                	mov    %eax,%edx
     7be:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7c1:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
     7c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7c7:	8b 40 04             	mov    0x4(%eax),%eax
     7ca:	c1 e0 03             	shl    $0x3,%eax
     7cd:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
     7d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7d3:	8b 55 ec             	mov    -0x14(%ebp),%edx
     7d6:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
     7d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
     7dc:	a3 08 e5 01 00       	mov    %eax,0x1e508
      return (void*)(p + 1);
     7e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7e4:	83 c0 08             	add    $0x8,%eax
     7e7:	eb 3b                	jmp    824 <malloc+0xe1>
    }
    if(p == freep)
     7e9:	a1 08 e5 01 00       	mov    0x1e508,%eax
     7ee:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     7f1:	75 1e                	jne    811 <malloc+0xce>
      if((p = morecore(nunits)) == 0)
     7f3:	83 ec 0c             	sub    $0xc,%esp
     7f6:	ff 75 ec             	pushl  -0x14(%ebp)
     7f9:	e8 e5 fe ff ff       	call   6e3 <morecore>
     7fe:	83 c4 10             	add    $0x10,%esp
     801:	89 45 f4             	mov    %eax,-0xc(%ebp)
     804:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     808:	75 07                	jne    811 <malloc+0xce>
        return 0;
     80a:	b8 00 00 00 00       	mov    $0x0,%eax
     80f:	eb 13                	jmp    824 <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     811:	8b 45 f4             	mov    -0xc(%ebp),%eax
     814:	89 45 f0             	mov    %eax,-0x10(%ebp)
     817:	8b 45 f4             	mov    -0xc(%ebp),%eax
     81a:	8b 00                	mov    (%eax),%eax
     81c:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
     81f:	e9 6d ff ff ff       	jmp    791 <malloc+0x4e>
}
     824:	c9                   	leave  
     825:	c3                   	ret    

00000826 <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
     826:	55                   	push   %ebp
     827:	89 e5                	mov    %esp,%ebp
    ++g_seed;
     829:	a1 0c e5 01 00       	mov    0x1e50c,%eax
     82e:	83 c0 01             	add    $0x1,%eax
     831:	a3 0c e5 01 00       	mov    %eax,0x1e50c
    g_seed = (214013*g_seed+2531011);
     836:	a1 0c e5 01 00       	mov    0x1e50c,%eax
     83b:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
     841:	05 c3 9e 26 00       	add    $0x269ec3,%eax
     846:	a3 0c e5 01 00       	mov    %eax,0x1e50c
    return (g_seed>>16)&0x7FFF;
     84b:	a1 0c e5 01 00       	mov    0x1e50c,%eax
     850:	c1 e8 10             	shr    $0x10,%eax
     853:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
     858:	5d                   	pop    %ebp
     859:	c3                   	ret    

0000085a <abs>:

#define PI 3.1415926536

float abs(float x) 
{
     85a:	55                   	push   %ebp
     85b:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
     85d:	d9 45 08             	flds   0x8(%ebp)
     860:	d9 ee                	fldz   
     862:	d9 c9                	fxch   %st(1)
     864:	df e9                	fucomip %st(1),%st
     866:	dd d8                	fstp   %st(0)
     868:	76 05                	jbe    86f <abs+0x15>
     86a:	d9 45 08             	flds   0x8(%ebp)
     86d:	eb 05                	jmp    874 <abs+0x1a>
	return -x;
     86f:	d9 45 08             	flds   0x8(%ebp)
     872:	d9 e0                	fchs   
}
     874:	5d                   	pop    %ebp
     875:	c3                   	ret    

00000876 <pow>:

float pow(float a, int b)
{
     876:	55                   	push   %ebp
     877:	89 e5                	mov    %esp,%ebp
     879:	83 ec 10             	sub    $0x10,%esp
	float r = a;
     87c:	d9 45 08             	flds   0x8(%ebp)
     87f:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
     882:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     886:	7e 17                	jle    89f <pow+0x29>
		while (--b)
     888:	eb 09                	jmp    893 <pow+0x1d>
			r *= a;
     88a:	d9 45 fc             	flds   -0x4(%ebp)
     88d:	d8 4d 08             	fmuls  0x8(%ebp)
     890:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
     893:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
     897:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     89b:	75 ed                	jne    88a <pow+0x14>
     89d:	eb 2a                	jmp    8c9 <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
     89f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     8a3:	79 1f                	jns    8c4 <pow+0x4e>
		while (++b)
     8a5:	eb 09                	jmp    8b0 <pow+0x3a>
			r *= a;
     8a7:	d9 45 fc             	flds   -0x4(%ebp)
     8aa:	d8 4d 08             	fmuls  0x8(%ebp)
     8ad:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
     8b0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
     8b4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     8b8:	75 ed                	jne    8a7 <pow+0x31>
			r *= a;
		r = 1.0 / r;
     8ba:	d9 e8                	fld1   
     8bc:	d8 75 fc             	fdivs  -0x4(%ebp)
     8bf:	d9 5d fc             	fstps  -0x4(%ebp)
     8c2:	eb 05                	jmp    8c9 <pow+0x53>
	}
	else r = 0;
     8c4:	d9 ee                	fldz   
     8c6:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
     8c9:	d9 45 fc             	flds   -0x4(%ebp)
}
     8cc:	c9                   	leave  
     8cd:	c3                   	ret    

000008ce <sqrt>:

float sqrt(float number) {
     8ce:	55                   	push   %ebp
     8cf:	89 e5                	mov    %esp,%ebp
     8d1:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
     8d4:	d9 ee                	fldz   
     8d6:	d9 45 08             	flds   0x8(%ebp)
     8d9:	d9 c9                	fxch   %st(1)
     8db:	df e9                	fucomip %st(1),%st
     8dd:	dd d8                	fstp   %st(0)
     8df:	76 06                	jbe    8e7 <sqrt+0x19>
		return -1;
     8e1:	d9 e8                	fld1   
     8e3:	d9 e0                	fchs   
     8e5:	eb 3a                	jmp    921 <sqrt+0x53>
	}

	new_guess = 1;
     8e7:	d9 e8                	fld1   
     8e9:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
     8ec:	d9 45 fc             	flds   -0x4(%ebp)
     8ef:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
     8f2:	d9 45 08             	flds   0x8(%ebp)
     8f5:	d8 75 f8             	fdivs  -0x8(%ebp)
     8f8:	d8 45 f8             	fadds  -0x8(%ebp)
     8fb:	d9 05 e0 5d 01 00    	flds   0x15de0
     901:	de f9                	fdivrp %st,%st(1)
     903:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
     906:	d9 45 fc             	flds   -0x4(%ebp)
     909:	d9 45 f8             	flds   -0x8(%ebp)
     90c:	df e9                	fucomip %st(1),%st
     90e:	dd d8                	fstp   %st(0)
     910:	7a da                	jp     8ec <sqrt+0x1e>
     912:	d9 45 fc             	flds   -0x4(%ebp)
     915:	d9 45 f8             	flds   -0x8(%ebp)
     918:	df e9                	fucomip %st(1),%st
     91a:	dd d8                	fstp   %st(0)
     91c:	75 ce                	jne    8ec <sqrt+0x1e>

	return new_guess;
     91e:	d9 45 fc             	flds   -0x4(%ebp)
}
     921:	c9                   	leave  
     922:	c3                   	ret    

00000923 <cos>:

float cos(float x)
{
     923:	55                   	push   %ebp
     924:	89 e5                	mov    %esp,%ebp
     926:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     929:	d9 e8                	fld1   
     92b:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     92e:	d9 45 08             	flds   0x8(%ebp)
     931:	dd 05 e8 5d 01 00    	fldl   0x15de8
     937:	d9 c9                	fxch   %st(1)
     939:	df e9                	fucomip %st(1),%st
     93b:	dd d8                	fstp   %st(0)
     93d:	77 0f                	ja     94e <cos+0x2b>
     93f:	d9 45 08             	flds   0x8(%ebp)
     942:	dd 05 f0 5d 01 00    	fldl   0x15df0
     948:	df e9                	fucomip %st(1),%st
     94a:	dd d8                	fstp   %st(0)
     94c:	76 3c                	jbe    98a <cos+0x67>
     94e:	d9 45 08             	flds   0x8(%ebp)
     951:	d9 45 08             	flds   0x8(%ebp)
     954:	dd 05 e8 5d 01 00    	fldl   0x15de8
     95a:	de f9                	fdivrp %st,%st(1)
     95c:	d9 7d e2             	fnstcw -0x1e(%ebp)
     95f:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     963:	b4 0c                	mov    $0xc,%ah
     965:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     969:	d9 6d e0             	fldcw  -0x20(%ebp)
     96c:	db 5d dc             	fistpl -0x24(%ebp)
     96f:	d9 6d e2             	fldcw  -0x1e(%ebp)
     972:	8b 45 dc             	mov    -0x24(%ebp),%eax
     975:	01 c0                	add    %eax,%eax
     977:	89 45 d8             	mov    %eax,-0x28(%ebp)
     97a:	db 45 d8             	fildl  -0x28(%ebp)
     97d:	dd 05 f8 5d 01 00    	fldl   0x15df8
     983:	de c9                	fmulp  %st,%st(1)
     985:	de e9                	fsubrp %st,%st(1)
     987:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     98a:	d9 45 08             	flds   0x8(%ebp)
     98d:	dd 05 f8 5d 01 00    	fldl   0x15df8
     993:	d9 c9                	fxch   %st(1)
     995:	df e9                	fucomip %st(1),%st
     997:	dd d8                	fstp   %st(0)
     999:	76 0e                	jbe    9a9 <cos+0x86>
     99b:	d9 45 08             	flds   0x8(%ebp)
     99e:	dd 05 e8 5d 01 00    	fldl   0x15de8
     9a4:	de e9                	fsubrp %st,%st(1)
     9a6:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     9a9:	d9 45 08             	flds   0x8(%ebp)
     9ac:	dd 05 00 5e 01 00    	fldl   0x15e00
     9b2:	df e9                	fucomip %st(1),%st
     9b4:	dd d8                	fstp   %st(0)
     9b6:	76 0e                	jbe    9c6 <cos+0xa3>
     9b8:	d9 45 08             	flds   0x8(%ebp)
     9bb:	dd 05 e8 5d 01 00    	fldl   0x15de8
     9c1:	de c1                	faddp  %st,%st(1)
     9c3:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     9c6:	d9 45 08             	flds   0x8(%ebp)
     9c9:	dd 05 08 5e 01 00    	fldl   0x15e08
     9cf:	d9 c9                	fxch   %st(1)
     9d1:	df e9                	fucomip %st(1),%st
     9d3:	dd d8                	fstp   %st(0)
     9d5:	76 16                	jbe    9ed <cos+0xca>
    {
        x -= PI;
     9d7:	d9 45 08             	flds   0x8(%ebp)
     9da:	dd 05 f8 5d 01 00    	fldl   0x15df8
     9e0:	de e9                	fsubrp %st,%st(1)
     9e2:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     9e5:	d9 45 f4             	flds   -0xc(%ebp)
     9e8:	d9 e0                	fchs   
     9ea:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     9ed:	d9 45 08             	flds   0x8(%ebp)
     9f0:	dd 05 10 5e 01 00    	fldl   0x15e10
     9f6:	df e9                	fucomip %st(1),%st
     9f8:	dd d8                	fstp   %st(0)
     9fa:	76 16                	jbe    a12 <cos+0xef>
    {
        x += PI;
     9fc:	d9 45 08             	flds   0x8(%ebp)
     9ff:	dd 05 f8 5d 01 00    	fldl   0x15df8
     a05:	de c1                	faddp  %st,%st(1)
     a07:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     a0a:	d9 45 f4             	flds   -0xc(%ebp)
     a0d:	d9 e0                	fchs   
     a0f:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
     a12:	d9 45 08             	flds   0x8(%ebp)
     a15:	dd 05 18 5e 01 00    	fldl   0x15e18
     a1b:	d9 c9                	fxch   %st(1)
     a1d:	df e9                	fucomip %st(1),%st
     a1f:	dd d8                	fstp   %st(0)
     a21:	76 28                	jbe    a4b <cos+0x128>
     a23:	d9 45 08             	flds   0x8(%ebp)
     a26:	dd 05 08 5e 01 00    	fldl   0x15e08
     a2c:	de e1                	fsubp  %st,%st(1)
     a2e:	d9 5d e4             	fstps  -0x1c(%ebp)
     a31:	d9 45 e4             	flds   -0x1c(%ebp)
     a34:	83 ec 0c             	sub    $0xc,%esp
     a37:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     a3b:	d9 1c 24             	fstps  (%esp)
     a3e:	e8 83 00 00 00       	call   ac6 <sin>
     a43:	83 c4 10             	add    $0x10,%esp
     a46:	d8 4d f4             	fmuls  -0xc(%ebp)
     a49:	eb 79                	jmp    ac4 <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
     a4b:	83 ec 08             	sub    $0x8,%esp
     a4e:	6a 02                	push   $0x2
     a50:	ff 75 08             	pushl  0x8(%ebp)
     a53:	e8 1e fe ff ff       	call   876 <pow>
     a58:	83 c4 10             	add    $0x10,%esp
     a5b:	d9 05 e0 5d 01 00    	flds   0x15de0
     a61:	de f9                	fdivrp %st,%st(1)
     a63:	d9 e8                	fld1   
     a65:	de e1                	fsubp  %st,%st(1)
     a67:	d9 5d d8             	fstps  -0x28(%ebp)
     a6a:	83 ec 08             	sub    $0x8,%esp
     a6d:	6a 04                	push   $0x4
     a6f:	ff 75 08             	pushl  0x8(%ebp)
     a72:	e8 ff fd ff ff       	call   876 <pow>
     a77:	83 c4 10             	add    $0x10,%esp
     a7a:	d9 05 20 5e 01 00    	flds   0x15e20
     a80:	de f9                	fdivrp %st,%st(1)
     a82:	d8 45 d8             	fadds  -0x28(%ebp)
     a85:	d9 5d d8             	fstps  -0x28(%ebp)
     a88:	83 ec 08             	sub    $0x8,%esp
     a8b:	6a 06                	push   $0x6
     a8d:	ff 75 08             	pushl  0x8(%ebp)
     a90:	e8 e1 fd ff ff       	call   876 <pow>
     a95:	83 c4 10             	add    $0x10,%esp
     a98:	d9 05 24 5e 01 00    	flds   0x15e24
     a9e:	de f9                	fdivrp %st,%st(1)
     aa0:	d8 6d d8             	fsubrs -0x28(%ebp)
     aa3:	d9 5d d8             	fstps  -0x28(%ebp)
     aa6:	83 ec 08             	sub    $0x8,%esp
     aa9:	6a 08                	push   $0x8
     aab:	ff 75 08             	pushl  0x8(%ebp)
     aae:	e8 c3 fd ff ff       	call   876 <pow>
     ab3:	83 c4 10             	add    $0x10,%esp
     ab6:	d9 05 28 5e 01 00    	flds   0x15e28
     abc:	de f9                	fdivrp %st,%st(1)
     abe:	d8 45 d8             	fadds  -0x28(%ebp)
     ac1:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     ac4:	c9                   	leave  
     ac5:	c3                   	ret    

00000ac6 <sin>:

float sin(float x)
{
     ac6:	55                   	push   %ebp
     ac7:	89 e5                	mov    %esp,%ebp
     ac9:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     acc:	d9 e8                	fld1   
     ace:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     ad1:	d9 45 08             	flds   0x8(%ebp)
     ad4:	dd 05 e8 5d 01 00    	fldl   0x15de8
     ada:	d9 c9                	fxch   %st(1)
     adc:	df e9                	fucomip %st(1),%st
     ade:	dd d8                	fstp   %st(0)
     ae0:	77 0f                	ja     af1 <sin+0x2b>
     ae2:	d9 45 08             	flds   0x8(%ebp)
     ae5:	dd 05 f0 5d 01 00    	fldl   0x15df0
     aeb:	df e9                	fucomip %st(1),%st
     aed:	dd d8                	fstp   %st(0)
     aef:	76 3c                	jbe    b2d <sin+0x67>
     af1:	d9 45 08             	flds   0x8(%ebp)
     af4:	d9 45 08             	flds   0x8(%ebp)
     af7:	dd 05 e8 5d 01 00    	fldl   0x15de8
     afd:	de f9                	fdivrp %st,%st(1)
     aff:	d9 7d e2             	fnstcw -0x1e(%ebp)
     b02:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     b06:	b4 0c                	mov    $0xc,%ah
     b08:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     b0c:	d9 6d e0             	fldcw  -0x20(%ebp)
     b0f:	db 5d dc             	fistpl -0x24(%ebp)
     b12:	d9 6d e2             	fldcw  -0x1e(%ebp)
     b15:	8b 45 dc             	mov    -0x24(%ebp),%eax
     b18:	01 c0                	add    %eax,%eax
     b1a:	89 45 d8             	mov    %eax,-0x28(%ebp)
     b1d:	db 45 d8             	fildl  -0x28(%ebp)
     b20:	dd 05 f8 5d 01 00    	fldl   0x15df8
     b26:	de c9                	fmulp  %st,%st(1)
     b28:	de e9                	fsubrp %st,%st(1)
     b2a:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     b2d:	d9 45 08             	flds   0x8(%ebp)
     b30:	dd 05 f8 5d 01 00    	fldl   0x15df8
     b36:	d9 c9                	fxch   %st(1)
     b38:	df e9                	fucomip %st(1),%st
     b3a:	dd d8                	fstp   %st(0)
     b3c:	76 0e                	jbe    b4c <sin+0x86>
     b3e:	d9 45 08             	flds   0x8(%ebp)
     b41:	dd 05 e8 5d 01 00    	fldl   0x15de8
     b47:	de e9                	fsubrp %st,%st(1)
     b49:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     b4c:	d9 45 08             	flds   0x8(%ebp)
     b4f:	dd 05 00 5e 01 00    	fldl   0x15e00
     b55:	df e9                	fucomip %st(1),%st
     b57:	dd d8                	fstp   %st(0)
     b59:	76 0e                	jbe    b69 <sin+0xa3>
     b5b:	d9 45 08             	flds   0x8(%ebp)
     b5e:	dd 05 e8 5d 01 00    	fldl   0x15de8
     b64:	de c1                	faddp  %st,%st(1)
     b66:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     b69:	d9 45 08             	flds   0x8(%ebp)
     b6c:	dd 05 08 5e 01 00    	fldl   0x15e08
     b72:	d9 c9                	fxch   %st(1)
     b74:	df e9                	fucomip %st(1),%st
     b76:	dd d8                	fstp   %st(0)
     b78:	76 16                	jbe    b90 <sin+0xca>
    {
        x -= PI;
     b7a:	d9 45 08             	flds   0x8(%ebp)
     b7d:	dd 05 f8 5d 01 00    	fldl   0x15df8
     b83:	de e9                	fsubrp %st,%st(1)
     b85:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     b88:	d9 45 f4             	flds   -0xc(%ebp)
     b8b:	d9 e0                	fchs   
     b8d:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     b90:	d9 45 08             	flds   0x8(%ebp)
     b93:	dd 05 10 5e 01 00    	fldl   0x15e10
     b99:	df e9                	fucomip %st(1),%st
     b9b:	dd d8                	fstp   %st(0)
     b9d:	76 16                	jbe    bb5 <sin+0xef>
    {
        x += PI;
     b9f:	d9 45 08             	flds   0x8(%ebp)
     ba2:	dd 05 f8 5d 01 00    	fldl   0x15df8
     ba8:	de c1                	faddp  %st,%st(1)
     baa:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     bad:	d9 45 f4             	flds   -0xc(%ebp)
     bb0:	d9 e0                	fchs   
     bb2:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
     bb5:	d9 ee                	fldz   
     bb7:	d9 45 08             	flds   0x8(%ebp)
     bba:	d9 c9                	fxch   %st(1)
     bbc:	df e9                	fucomip %st(1),%st
     bbe:	dd d8                	fstp   %st(0)
     bc0:	76 10                	jbe    bd2 <sin+0x10c>
    {
        x *= -1;
     bc2:	d9 45 08             	flds   0x8(%ebp)
     bc5:	d9 e0                	fchs   
     bc7:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     bca:	d9 45 f4             	flds   -0xc(%ebp)
     bcd:	d9 e0                	fchs   
     bcf:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
     bd2:	d9 45 08             	flds   0x8(%ebp)
     bd5:	dd 05 18 5e 01 00    	fldl   0x15e18
     bdb:	d9 c9                	fxch   %st(1)
     bdd:	df e9                	fucomip %st(1),%st
     bdf:	dd d8                	fstp   %st(0)
     be1:	76 28                	jbe    c0b <sin+0x145>
     be3:	d9 45 08             	flds   0x8(%ebp)
     be6:	dd 05 08 5e 01 00    	fldl   0x15e08
     bec:	de e1                	fsubp  %st,%st(1)
     bee:	d9 5d e4             	fstps  -0x1c(%ebp)
     bf1:	d9 45 e4             	flds   -0x1c(%ebp)
     bf4:	83 ec 0c             	sub    $0xc,%esp
     bf7:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     bfb:	d9 1c 24             	fstps  (%esp)
     bfe:	e8 20 fd ff ff       	call   923 <cos>
     c03:	83 c4 10             	add    $0x10,%esp
     c06:	d8 4d f4             	fmuls  -0xc(%ebp)
     c09:	eb 7a                	jmp    c85 <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
     c0b:	83 ec 08             	sub    $0x8,%esp
     c0e:	6a 03                	push   $0x3
     c10:	ff 75 08             	pushl  0x8(%ebp)
     c13:	e8 5e fc ff ff       	call   876 <pow>
     c18:	83 c4 10             	add    $0x10,%esp
     c1b:	d9 05 2c 5e 01 00    	flds   0x15e2c
     c21:	de f9                	fdivrp %st,%st(1)
     c23:	d9 45 08             	flds   0x8(%ebp)
     c26:	de e1                	fsubp  %st,%st(1)
     c28:	d9 5d d8             	fstps  -0x28(%ebp)
     c2b:	83 ec 08             	sub    $0x8,%esp
     c2e:	6a 05                	push   $0x5
     c30:	ff 75 08             	pushl  0x8(%ebp)
     c33:	e8 3e fc ff ff       	call   876 <pow>
     c38:	83 c4 10             	add    $0x10,%esp
     c3b:	d9 05 30 5e 01 00    	flds   0x15e30
     c41:	de f9                	fdivrp %st,%st(1)
     c43:	d8 45 d8             	fadds  -0x28(%ebp)
     c46:	d9 5d d8             	fstps  -0x28(%ebp)
     c49:	83 ec 08             	sub    $0x8,%esp
     c4c:	6a 07                	push   $0x7
     c4e:	ff 75 08             	pushl  0x8(%ebp)
     c51:	e8 20 fc ff ff       	call   876 <pow>
     c56:	83 c4 10             	add    $0x10,%esp
     c59:	d9 05 34 5e 01 00    	flds   0x15e34
     c5f:	de f9                	fdivrp %st,%st(1)
     c61:	d8 6d d8             	fsubrs -0x28(%ebp)
     c64:	d9 5d d8             	fstps  -0x28(%ebp)
     c67:	83 ec 08             	sub    $0x8,%esp
     c6a:	6a 09                	push   $0x9
     c6c:	ff 75 08             	pushl  0x8(%ebp)
     c6f:	e8 02 fc ff ff       	call   876 <pow>
     c74:	83 c4 10             	add    $0x10,%esp
     c77:	d9 05 38 5e 01 00    	flds   0x15e38
     c7d:	de f9                	fdivrp %st,%st(1)
     c7f:	d8 45 d8             	fadds  -0x28(%ebp)
     c82:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     c85:	c9                   	leave  
     c86:	c3                   	ret    

00000c87 <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
     c87:	55                   	push   %ebp
     c88:	89 e5                	mov    %esp,%ebp
     c8a:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
     c8d:	83 ec 04             	sub    $0x4,%esp
     c90:	6a 0e                	push   $0xe
     c92:	ff 75 0c             	pushl  0xc(%ebp)
     c95:	ff 75 08             	pushl  0x8(%ebp)
     c98:	e8 44 f6 ff ff       	call   2e1 <read>
     c9d:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
     ca0:	83 ec 04             	sub    $0x4,%esp
     ca3:	6a 28                	push   $0x28
     ca5:	ff 75 10             	pushl  0x10(%ebp)
     ca8:	ff 75 08             	pushl  0x8(%ebp)
     cab:	e8 31 f6 ff ff       	call   2e1 <read>
     cb0:	83 c4 10             	add    $0x10,%esp
}
     cb3:	90                   	nop
     cb4:	c9                   	leave  
     cb5:	c3                   	ret    

00000cb6 <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
     cb6:	55                   	push   %ebp
     cb7:	89 e5                	mov    %esp,%ebp
     cb9:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     cbf:	83 ec 08             	sub    $0x8,%esp
     cc2:	6a 00                	push   $0x0
     cc4:	ff 75 08             	pushl  0x8(%ebp)
     cc7:	e8 3d f6 ff ff       	call   309 <open>
     ccc:	83 c4 10             	add    $0x10,%esp
     ccf:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     cd2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     cd6:	79 0a                	jns    ce2 <readBitmapFile+0x2c>
        return -1;
     cd8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     cdd:	e9 6e 01 00 00       	jmp    e50 <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     ce2:	83 ec 04             	sub    $0x4,%esp
     ce5:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     ce8:	50                   	push   %eax
     ce9:	8d 45 ca             	lea    -0x36(%ebp),%eax
     cec:	50                   	push   %eax
     ced:	ff 75 ec             	pushl  -0x14(%ebp)
     cf0:	e8 92 ff ff ff       	call   c87 <readBitmapHeader>
     cf5:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     cf8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     cfb:	83 e8 36             	sub    $0x36,%eax
     cfe:	83 ec 04             	sub    $0x4,%esp
     d01:	50                   	push   %eax
     d02:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     d08:	50                   	push   %eax
     d09:	ff 75 ec             	pushl  -0x14(%ebp)
     d0c:	e8 d0 f5 ff ff       	call   2e1 <read>
     d11:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     d14:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     d17:	8b 45 14             	mov    0x14(%ebp),%eax
     d1a:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     d1c:	8b 55 aa             	mov    -0x56(%ebp),%edx
     d1f:	8b 45 10             	mov    0x10(%ebp),%eax
     d22:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     d24:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     d27:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     d2a:	8b 45 aa             	mov    -0x56(%ebp),%eax
     d2d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     d30:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     d34:	0f b7 c0             	movzwl %ax,%eax
     d37:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
     d3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
     d3d:	0f af 45 e0          	imul   -0x20(%ebp),%eax
     d41:	8d 50 07             	lea    0x7(%eax),%edx
     d44:	85 c0                	test   %eax,%eax
     d46:	0f 48 c2             	cmovs  %edx,%eax
     d49:	c1 f8 03             	sar    $0x3,%eax
     d4c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     d4f:	8b 45 0c             	mov    0xc(%ebp),%eax
     d52:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     d55:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     d58:	83 e8 01             	sub    $0x1,%eax
     d5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
     d5e:	e9 d0 00 00 00       	jmp    e33 <readBitmapFile+0x17d>
        if (bits == 32) {
     d63:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
     d67:	75 22                	jne    d8b <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     d69:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d6c:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     d70:	89 c2                	mov    %eax,%edx
     d72:	8b 45 d8             	mov    -0x28(%ebp),%eax
     d75:	01 d0                	add    %edx,%eax
     d77:	83 ec 04             	sub    $0x4,%esp
     d7a:	ff 75 dc             	pushl  -0x24(%ebp)
     d7d:	50                   	push   %eax
     d7e:	ff 75 ec             	pushl  -0x14(%ebp)
     d81:	e8 5b f5 ff ff       	call   2e1 <read>
     d86:	83 c4 10             	add    $0x10,%esp
     d89:	eb 65                	jmp    df0 <readBitmapFile+0x13a>
        } else {
            int j = 0;
     d8b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     d92:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     d99:	eb 4d                	jmp    de8 <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
     d9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d9e:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     da2:	c1 e0 02             	shl    $0x2,%eax
     da5:	89 c2                	mov    %eax,%edx
     da7:	8b 45 f0             	mov    -0x10(%ebp),%eax
     daa:	c1 e0 02             	shl    $0x2,%eax
     dad:	01 c2                	add    %eax,%edx
     daf:	8b 45 d8             	mov    -0x28(%ebp),%eax
     db2:	01 d0                	add    %edx,%eax
     db4:	83 ec 04             	sub    $0x4,%esp
     db7:	6a 03                	push   $0x3
     db9:	50                   	push   %eax
     dba:	ff 75 ec             	pushl  -0x14(%ebp)
     dbd:	e8 1f f5 ff ff       	call   2e1 <read>
     dc2:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
     dc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
     dc8:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     dcc:	c1 e0 02             	shl    $0x2,%eax
     dcf:	89 c2                	mov    %eax,%edx
     dd1:	8b 45 f0             	mov    -0x10(%ebp),%eax
     dd4:	c1 e0 02             	shl    $0x2,%eax
     dd7:	01 d0                	add    %edx,%eax
     dd9:	8d 50 03             	lea    0x3(%eax),%edx
     ddc:	8b 45 d8             	mov    -0x28(%ebp),%eax
     ddf:	01 d0                	add    %edx,%eax
     de1:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
     de4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     de8:	8b 45 f0             	mov    -0x10(%ebp),%eax
     deb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     dee:	7c ab                	jl     d9b <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
     df0:	8b 45 dc             	mov    -0x24(%ebp),%eax
     df3:	99                   	cltd   
     df4:	c1 ea 1e             	shr    $0x1e,%edx
     df7:	01 d0                	add    %edx,%eax
     df9:	83 e0 03             	and    $0x3,%eax
     dfc:	29 d0                	sub    %edx,%eax
     dfe:	85 c0                	test   %eax,%eax
     e00:	7e 2d                	jle    e2f <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
     e02:	8b 45 dc             	mov    -0x24(%ebp),%eax
     e05:	99                   	cltd   
     e06:	c1 ea 1e             	shr    $0x1e,%edx
     e09:	01 d0                	add    %edx,%eax
     e0b:	83 e0 03             	and    $0x3,%eax
     e0e:	29 d0                	sub    %edx,%eax
     e10:	ba 04 00 00 00       	mov    $0x4,%edx
     e15:	29 c2                	sub    %eax,%edx
     e17:	89 d0                	mov    %edx,%eax
     e19:	83 ec 04             	sub    $0x4,%esp
     e1c:	50                   	push   %eax
     e1d:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     e23:	50                   	push   %eax
     e24:	ff 75 ec             	pushl  -0x14(%ebp)
     e27:	e8 b5 f4 ff ff       	call   2e1 <read>
     e2c:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
     e2f:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     e33:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     e37:	0f 89 26 ff ff ff    	jns    d63 <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
     e3d:	83 ec 0c             	sub    $0xc,%esp
     e40:	ff 75 ec             	pushl  -0x14(%ebp)
     e43:	e8 a9 f4 ff ff       	call   2f1 <close>
     e48:	83 c4 10             	add    $0x10,%esp
    return 0;
     e4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
     e50:	c9                   	leave  
     e51:	c3                   	ret    

00000e52 <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
     e52:	55                   	push   %ebp
     e53:	89 e5                	mov    %esp,%ebp
     e55:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     e5b:	83 ec 08             	sub    $0x8,%esp
     e5e:	6a 00                	push   $0x0
     e60:	ff 75 08             	pushl  0x8(%ebp)
     e63:	e8 a1 f4 ff ff       	call   309 <open>
     e68:	83 c4 10             	add    $0x10,%esp
     e6b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     e6e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     e72:	79 0a                	jns    e7e <read24BitmapFile+0x2c>
        return -1;
     e74:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     e79:	e9 66 01 00 00       	jmp    fe4 <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     e7e:	83 ec 04             	sub    $0x4,%esp
     e81:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     e84:	50                   	push   %eax
     e85:	8d 45 ca             	lea    -0x36(%ebp),%eax
     e88:	50                   	push   %eax
     e89:	ff 75 ec             	pushl  -0x14(%ebp)
     e8c:	e8 f6 fd ff ff       	call   c87 <readBitmapHeader>
     e91:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     e94:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     e97:	83 e8 36             	sub    $0x36,%eax
     e9a:	83 ec 04             	sub    $0x4,%esp
     e9d:	50                   	push   %eax
     e9e:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     ea4:	50                   	push   %eax
     ea5:	ff 75 ec             	pushl  -0x14(%ebp)
     ea8:	e8 34 f4 ff ff       	call   2e1 <read>
     ead:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     eb0:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     eb3:	8b 45 14             	mov    0x14(%ebp),%eax
     eb6:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     eb8:	8b 55 aa             	mov    -0x56(%ebp),%edx
     ebb:	8b 45 10             	mov    0x10(%ebp),%eax
     ebe:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     ec0:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     ec3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     ec6:	8b 45 aa             	mov    -0x56(%ebp),%eax
     ec9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     ecc:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     ed0:	0f b7 c0             	movzwl %ax,%eax
     ed3:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
     ed6:	8b 55 e8             	mov    -0x18(%ebp),%edx
     ed9:	89 d0                	mov    %edx,%eax
     edb:	01 c0                	add    %eax,%eax
     edd:	01 d0                	add    %edx,%eax
     edf:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     ee2:	8b 45 0c             	mov    0xc(%ebp),%eax
     ee5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     ee8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     eeb:	83 e8 01             	sub    $0x1,%eax
     eee:	89 45 f4             	mov    %eax,-0xc(%ebp)
     ef1:	e9 d1 00 00 00       	jmp    fc7 <read24BitmapFile+0x175>
        if (bits == 24) {
     ef6:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
     efa:	75 22                	jne    f1e <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     efc:	8b 45 f4             	mov    -0xc(%ebp),%eax
     eff:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     f03:	89 c2                	mov    %eax,%edx
     f05:	8b 45 d8             	mov    -0x28(%ebp),%eax
     f08:	01 d0                	add    %edx,%eax
     f0a:	83 ec 04             	sub    $0x4,%esp
     f0d:	ff 75 dc             	pushl  -0x24(%ebp)
     f10:	50                   	push   %eax
     f11:	ff 75 ec             	pushl  -0x14(%ebp)
     f14:	e8 c8 f3 ff ff       	call   2e1 <read>
     f19:	83 c4 10             	add    $0x10,%esp
     f1c:	eb 66                	jmp    f84 <read24BitmapFile+0x132>
        } else {
            int j = 0;
     f1e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     f25:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     f2c:	eb 4e                	jmp    f7c <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
     f2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     f31:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     f35:	89 c2                	mov    %eax,%edx
     f37:	89 d0                	mov    %edx,%eax
     f39:	01 c0                	add    %eax,%eax
     f3b:	01 d0                	add    %edx,%eax
     f3d:	89 c1                	mov    %eax,%ecx
     f3f:	8b 55 f0             	mov    -0x10(%ebp),%edx
     f42:	89 d0                	mov    %edx,%eax
     f44:	01 c0                	add    %eax,%eax
     f46:	01 d0                	add    %edx,%eax
     f48:	8d 14 01             	lea    (%ecx,%eax,1),%edx
     f4b:	8b 45 d8             	mov    -0x28(%ebp),%eax
     f4e:	01 d0                	add    %edx,%eax
     f50:	83 ec 04             	sub    $0x4,%esp
     f53:	6a 03                	push   $0x3
     f55:	50                   	push   %eax
     f56:	ff 75 ec             	pushl  -0x14(%ebp)
     f59:	e8 83 f3 ff ff       	call   2e1 <read>
     f5e:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
     f61:	83 ec 04             	sub    $0x4,%esp
     f64:	6a 01                	push   $0x1
     f66:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     f6c:	50                   	push   %eax
     f6d:	ff 75 ec             	pushl  -0x14(%ebp)
     f70:	e8 6c f3 ff ff       	call   2e1 <read>
     f75:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
     f78:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     f7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
     f7f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     f82:	7c aa                	jl     f2e <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
     f84:	8b 45 dc             	mov    -0x24(%ebp),%eax
     f87:	99                   	cltd   
     f88:	c1 ea 1e             	shr    $0x1e,%edx
     f8b:	01 d0                	add    %edx,%eax
     f8d:	83 e0 03             	and    $0x3,%eax
     f90:	29 d0                	sub    %edx,%eax
     f92:	85 c0                	test   %eax,%eax
     f94:	7e 2d                	jle    fc3 <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
     f96:	8b 45 dc             	mov    -0x24(%ebp),%eax
     f99:	99                   	cltd   
     f9a:	c1 ea 1e             	shr    $0x1e,%edx
     f9d:	01 d0                	add    %edx,%eax
     f9f:	83 e0 03             	and    $0x3,%eax
     fa2:	29 d0                	sub    %edx,%eax
     fa4:	ba 04 00 00 00       	mov    $0x4,%edx
     fa9:	29 c2                	sub    %eax,%edx
     fab:	89 d0                	mov    %edx,%eax
     fad:	83 ec 04             	sub    $0x4,%esp
     fb0:	50                   	push   %eax
     fb1:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     fb7:	50                   	push   %eax
     fb8:	ff 75 ec             	pushl  -0x14(%ebp)
     fbb:	e8 21 f3 ff ff       	call   2e1 <read>
     fc0:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
     fc3:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     fc7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     fcb:	0f 89 25 ff ff ff    	jns    ef6 <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
     fd1:	83 ec 0c             	sub    $0xc,%esp
     fd4:	ff 75 ec             	pushl  -0x14(%ebp)
     fd7:	e8 15 f3 ff ff       	call   2f1 <close>
     fdc:	83 c4 10             	add    $0x10,%esp
    return 0;
     fdf:	b8 00 00 00 00       	mov    $0x0,%eax
}
     fe4:	c9                   	leave  
     fe5:	c3                   	ret    

00000fe6 <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
     fe6:	55                   	push   %ebp
     fe7:	89 e5                	mov    %esp,%ebp
     fe9:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
     fec:	8b 55 10             	mov    0x10(%ebp),%edx
     fef:	89 d0                	mov    %edx,%eax
     ff1:	01 c0                	add    %eax,%eax
     ff3:	01 d0                	add    %edx,%eax
     ff5:	c1 e0 03             	shl    $0x3,%eax
     ff8:	83 c0 1f             	add    $0x1f,%eax
     ffb:	8d 50 1f             	lea    0x1f(%eax),%edx
     ffe:	85 c0                	test   %eax,%eax
    1000:	0f 48 c2             	cmovs  %edx,%eax
    1003:	c1 f8 05             	sar    $0x5,%eax
    1006:	c1 e0 02             	shl    $0x2,%eax
    1009:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    100c:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    1012:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1015:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1019:	83 c0 36             	add    $0x36,%eax
    101c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    101f:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    1025:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    102b:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    1032:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    1039:	8b 45 10             	mov    0x10(%ebp),%eax
    103c:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    103f:	8b 45 0c             	mov    0xc(%ebp),%eax
    1042:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    1045:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    104b:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    1051:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    1058:	8b 45 f4             	mov    -0xc(%ebp),%eax
    105b:	0f af 45 0c          	imul   0xc(%ebp),%eax
    105f:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    1062:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    1069:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    1070:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    1077:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    107e:	83 ec 04             	sub    $0x4,%esp
    1081:	6a 0e                	push   $0xe
    1083:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    1086:	50                   	push   %eax
    1087:	ff 75 08             	pushl  0x8(%ebp)
    108a:	e8 5a f2 ff ff       	call   2e9 <write>
    108f:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    1092:	83 ec 04             	sub    $0x4,%esp
    1095:	6a 28                	push   $0x28
    1097:	8d 45 be             	lea    -0x42(%ebp),%eax
    109a:	50                   	push   %eax
    109b:	ff 75 08             	pushl  0x8(%ebp)
    109e:	e8 46 f2 ff ff       	call   2e9 <write>
    10a3:	83 c4 10             	add    $0x10,%esp
}
    10a6:	90                   	nop
    10a7:	c9                   	leave  
    10a8:	c3                   	ret    

000010a9 <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    10a9:	55                   	push   %ebp
    10aa:	89 e5                	mov    %esp,%ebp
    10ac:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    10af:	83 ec 08             	sub    $0x8,%esp
    10b2:	68 02 02 00 00       	push   $0x202
    10b7:	ff 75 08             	pushl  0x8(%ebp)
    10ba:	e8 4a f2 ff ff       	call   309 <open>
    10bf:	83 c4 10             	add    $0x10,%esp
    10c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    10c5:	8b 55 14             	mov    0x14(%ebp),%edx
    10c8:	89 d0                	mov    %edx,%eax
    10ca:	01 c0                	add    %eax,%eax
    10cc:	01 d0                	add    %edx,%eax
    10ce:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    10d1:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    10d5:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    10d9:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    10dd:	83 ec 04             	sub    $0x4,%esp
    10e0:	ff 75 14             	pushl  0x14(%ebp)
    10e3:	ff 75 10             	pushl  0x10(%ebp)
    10e6:	ff 75 f0             	pushl  -0x10(%ebp)
    10e9:	e8 f8 fe ff ff       	call   fe6 <write24BitmapFileHeader>
    10ee:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    10f1:	8b 45 10             	mov    0x10(%ebp),%eax
    10f4:	83 e8 01             	sub    $0x1,%eax
    10f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    10fa:	eb 66                	jmp    1162 <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    10fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    10ff:	0f af 45 14          	imul   0x14(%ebp),%eax
    1103:	89 c2                	mov    %eax,%edx
    1105:	89 d0                	mov    %edx,%eax
    1107:	01 c0                	add    %eax,%eax
    1109:	01 c2                	add    %eax,%edx
    110b:	8b 45 0c             	mov    0xc(%ebp),%eax
    110e:	01 d0                	add    %edx,%eax
    1110:	83 ec 04             	sub    $0x4,%esp
    1113:	ff 75 ec             	pushl  -0x14(%ebp)
    1116:	50                   	push   %eax
    1117:	ff 75 f0             	pushl  -0x10(%ebp)
    111a:	e8 ca f1 ff ff       	call   2e9 <write>
    111f:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    1122:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1125:	99                   	cltd   
    1126:	c1 ea 1e             	shr    $0x1e,%edx
    1129:	01 d0                	add    %edx,%eax
    112b:	83 e0 03             	and    $0x3,%eax
    112e:	29 d0                	sub    %edx,%eax
    1130:	85 c0                	test   %eax,%eax
    1132:	7e 2a                	jle    115e <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    1134:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1137:	99                   	cltd   
    1138:	c1 ea 1e             	shr    $0x1e,%edx
    113b:	01 d0                	add    %edx,%eax
    113d:	83 e0 03             	and    $0x3,%eax
    1140:	29 d0                	sub    %edx,%eax
    1142:	ba 04 00 00 00       	mov    $0x4,%edx
    1147:	29 c2                	sub    %eax,%edx
    1149:	89 d0                	mov    %edx,%eax
    114b:	83 ec 04             	sub    $0x4,%esp
    114e:	50                   	push   %eax
    114f:	8d 45 e9             	lea    -0x17(%ebp),%eax
    1152:	50                   	push   %eax
    1153:	ff 75 f0             	pushl  -0x10(%ebp)
    1156:	e8 8e f1 ff ff       	call   2e9 <write>
    115b:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    115e:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1162:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1166:	79 94                	jns    10fc <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1168:	83 ec 0c             	sub    $0xc,%esp
    116b:	ff 75 f0             	pushl  -0x10(%ebp)
    116e:	e8 7e f1 ff ff       	call   2f1 <close>
    1173:	83 c4 10             	add    $0x10,%esp
    return 0;
    1176:	b8 00 00 00 00       	mov    $0x0,%eax
    117b:	c9                   	leave  
    117c:	c3                   	ret    

0000117d <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    117d:	55                   	push   %ebp
    117e:	89 e5                	mov    %esp,%ebp
    1180:	57                   	push   %edi
    1181:	56                   	push   %esi
    1182:	53                   	push   %ebx
    1183:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    1186:	8b 45 08             	mov    0x8(%ebp),%eax
    1189:	8b 50 10             	mov    0x10(%eax),%edx
    118c:	8b 40 0c             	mov    0xc(%eax),%eax
    118f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1192:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    1195:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1198:	8b 55 e0             	mov    -0x20(%ebp),%edx
    119b:	83 c2 1e             	add    $0x1e,%edx
    119e:	0f af d0             	imul   %eax,%edx
    11a1:	89 d0                	mov    %edx,%eax
    11a3:	01 c0                	add    %eax,%eax
    11a5:	01 d0                	add    %edx,%eax
    11a7:	83 ec 0c             	sub    $0xc,%esp
    11aa:	50                   	push   %eax
    11ab:	e8 93 f5 ff ff       	call   743 <malloc>
    11b0:	83 c4 10             	add    $0x10,%esp
    11b3:	89 c2                	mov    %eax,%edx
    11b5:	8b 45 08             	mov    0x8(%ebp),%eax
    11b8:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    11bb:	8b 45 08             	mov    0x8(%ebp),%eax
    11be:	8b 40 1c             	mov    0x1c(%eax),%eax
    11c1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    11c4:	6b d2 5a             	imul   $0x5a,%edx,%edx
    11c7:	01 c2                	add    %eax,%edx
    11c9:	8b 45 08             	mov    0x8(%ebp),%eax
    11cc:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    11cf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    11d2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    11d5:	0f af d0             	imul   %eax,%edx
    11d8:	89 d0                	mov    %edx,%eax
    11da:	01 c0                	add    %eax,%eax
    11dc:	01 d0                	add    %edx,%eax
    11de:	89 c2                	mov    %eax,%edx
    11e0:	8b 45 08             	mov    0x8(%ebp),%eax
    11e3:	8b 40 18             	mov    0x18(%eax),%eax
    11e6:	83 ec 04             	sub    $0x4,%esp
    11e9:	52                   	push   %edx
    11ea:	68 ff 00 00 00       	push   $0xff
    11ef:	50                   	push   %eax
    11f0:	e8 39 ef ff ff       	call   12e <memset>
    11f5:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    11f8:	8b 45 08             	mov    0x8(%ebp),%eax
    11fb:	8b 78 1c             	mov    0x1c(%eax),%edi
    11fe:	8b 45 08             	mov    0x8(%ebp),%eax
    1201:	8b 70 14             	mov    0x14(%eax),%esi
    1204:	8b 45 08             	mov    0x8(%ebp),%eax
    1207:	8b 58 0c             	mov    0xc(%eax),%ebx
    120a:	8b 45 08             	mov    0x8(%ebp),%eax
    120d:	8b 48 10             	mov    0x10(%eax),%ecx
    1210:	8b 45 08             	mov    0x8(%ebp),%eax
    1213:	8b 50 08             	mov    0x8(%eax),%edx
    1216:	8b 45 08             	mov    0x8(%ebp),%eax
    1219:	8b 40 04             	mov    0x4(%eax),%eax
    121c:	83 ec 08             	sub    $0x8,%esp
    121f:	57                   	push   %edi
    1220:	56                   	push   %esi
    1221:	53                   	push   %ebx
    1222:	51                   	push   %ecx
    1223:	52                   	push   %edx
    1224:	50                   	push   %eax
    1225:	e8 3f f1 ff ff       	call   369 <createwindow>
    122a:	83 c4 20             	add    $0x20,%esp
    122d:	89 c2                	mov    %eax,%edx
    122f:	8b 45 08             	mov    0x8(%ebp),%eax
    1232:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    1234:	8b 45 08             	mov    0x8(%ebp),%eax
    1237:	8b 00                	mov    (%eax),%eax
}
    1239:	8d 65 f4             	lea    -0xc(%ebp),%esp
    123c:	5b                   	pop    %ebx
    123d:	5e                   	pop    %esi
    123e:	5f                   	pop    %edi
    123f:	5d                   	pop    %ebp
    1240:	c3                   	ret    

00001241 <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    1241:	55                   	push   %ebp
    1242:	89 e5                	mov    %esp,%ebp
    1244:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    1247:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    124e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1255:	8b 45 08             	mov    0x8(%ebp),%eax
    1258:	8b 40 18             	mov    0x18(%eax),%eax
    125b:	ff 75 1c             	pushl  0x1c(%ebp)
    125e:	ff 75 18             	pushl  0x18(%ebp)
    1261:	ff 75 1c             	pushl  0x1c(%ebp)
    1264:	ff 75 18             	pushl  0x18(%ebp)
    1267:	8b 55 08             	mov    0x8(%ebp),%edx
    126a:	ff 72 10             	pushl  0x10(%edx)
    126d:	ff 72 0c             	pushl  0xc(%edx)
    1270:	ff 75 f4             	pushl  -0xc(%ebp)
    1273:	ff 75 f0             	pushl  -0x10(%ebp)
    1276:	ff 75 14             	pushl  0x14(%ebp)
    1279:	ff 75 10             	pushl  0x10(%ebp)
    127c:	ff 75 0c             	pushl  0xc(%ebp)
    127f:	50                   	push   %eax
    1280:	e8 d5 07 00 00       	call   1a5a <drawBitmap>
    1285:	83 c4 30             	add    $0x30,%esp
    return 0;
    1288:	b8 00 00 00 00       	mov    $0x0,%eax
}
    128d:	c9                   	leave  
    128e:	c3                   	ret    

0000128f <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    128f:	55                   	push   %ebp
    1290:	89 e5                	mov    %esp,%ebp
    1292:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1295:	8b 45 08             	mov    0x8(%ebp),%eax
    1298:	8b 40 18             	mov    0x18(%eax),%eax
    129b:	ff 75 2c             	pushl  0x2c(%ebp)
    129e:	ff 75 28             	pushl  0x28(%ebp)
    12a1:	ff 75 24             	pushl  0x24(%ebp)
    12a4:	ff 75 20             	pushl  0x20(%ebp)
    12a7:	8b 55 08             	mov    0x8(%ebp),%edx
    12aa:	ff 72 10             	pushl  0x10(%edx)
    12ad:	ff 72 0c             	pushl  0xc(%edx)
    12b0:	ff 75 1c             	pushl  0x1c(%ebp)
    12b3:	ff 75 18             	pushl  0x18(%ebp)
    12b6:	ff 75 14             	pushl  0x14(%ebp)
    12b9:	ff 75 10             	pushl  0x10(%ebp)
    12bc:	ff 75 0c             	pushl  0xc(%ebp)
    12bf:	50                   	push   %eax
    12c0:	e8 95 07 00 00       	call   1a5a <drawBitmap>
    12c5:	83 c4 30             	add    $0x30,%esp
    return 0;
    12c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    12cd:	c9                   	leave  
    12ce:	c3                   	ret    

000012cf <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    12cf:	55                   	push   %ebp
    12d0:	89 e5                	mov    %esp,%ebp
    12d2:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    12d5:	8b 45 08             	mov    0x8(%ebp),%eax
    12d8:	8b 40 18             	mov    0x18(%eax),%eax
    12db:	ff 75 2c             	pushl  0x2c(%ebp)
    12de:	ff 75 28             	pushl  0x28(%ebp)
    12e1:	ff 75 24             	pushl  0x24(%ebp)
    12e4:	ff 75 20             	pushl  0x20(%ebp)
    12e7:	8b 55 08             	mov    0x8(%ebp),%edx
    12ea:	ff 72 10             	pushl  0x10(%edx)
    12ed:	ff 72 0c             	pushl  0xc(%edx)
    12f0:	ff 75 1c             	pushl  0x1c(%ebp)
    12f3:	ff 75 18             	pushl  0x18(%ebp)
    12f6:	ff 75 14             	pushl  0x14(%ebp)
    12f9:	ff 75 10             	pushl  0x10(%ebp)
    12fc:	ff 75 0c             	pushl  0xc(%ebp)
    12ff:	50                   	push   %eax
    1300:	e8 75 08 00 00       	call   1b7a <drawTransparentBitmap>
    1305:	83 c4 30             	add    $0x30,%esp
    return 0;
    1308:	b8 00 00 00 00       	mov    $0x0,%eax
}
    130d:	c9                   	leave  
    130e:	c3                   	ret    

0000130f <api_repaint>:

int api_repaint(Window* wnd)
{
    130f:	55                   	push   %ebp
    1310:	89 e5                	mov    %esp,%ebp
    1312:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    1315:	8b 45 08             	mov    0x8(%ebp),%eax
    1318:	8b 00                	mov    (%eax),%eax
    131a:	83 ec 0c             	sub    $0xc,%esp
    131d:	50                   	push   %eax
    131e:	e8 4e f0 ff ff       	call   371 <repaintwindow>
    1323:	83 c4 10             	add    $0x10,%esp
    return 0;
    1326:	b8 00 00 00 00       	mov    $0x0,%eax
}
    132b:	c9                   	leave  
    132c:	c3                   	ret    

0000132d <api_update>:

int api_update(Window* wnd, Rect rect)
{
    132d:	55                   	push   %ebp
    132e:	89 e5                	mov    %esp,%ebp
    1330:	56                   	push   %esi
    1331:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    1332:	8b 75 18             	mov    0x18(%ebp),%esi
    1335:	8b 5d 14             	mov    0x14(%ebp),%ebx
    1338:	8b 4d 10             	mov    0x10(%ebp),%ecx
    133b:	8b 55 0c             	mov    0xc(%ebp),%edx
    133e:	8b 45 08             	mov    0x8(%ebp),%eax
    1341:	8b 00                	mov    (%eax),%eax
    1343:	83 ec 0c             	sub    $0xc,%esp
    1346:	56                   	push   %esi
    1347:	53                   	push   %ebx
    1348:	51                   	push   %ecx
    1349:	52                   	push   %edx
    134a:	50                   	push   %eax
    134b:	e8 39 f0 ff ff       	call   389 <updatewindow>
    1350:	83 c4 20             	add    $0x20,%esp
    return 0;
    1353:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1358:	8d 65 f8             	lea    -0x8(%ebp),%esp
    135b:	5b                   	pop    %ebx
    135c:	5e                   	pop    %esi
    135d:	5d                   	pop    %ebp
    135e:	c3                   	ret    

0000135f <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    135f:	55                   	push   %ebp
    1360:	89 e5                	mov    %esp,%ebp
    1362:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    1365:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    136c:	8b 45 08             	mov    0x8(%ebp),%eax
    136f:	8b 00                	mov    (%eax),%eax
    1371:	83 ec 08             	sub    $0x8,%esp
    1374:	8d 55 c8             	lea    -0x38(%ebp),%edx
    1377:	52                   	push   %edx
    1378:	50                   	push   %eax
    1379:	e8 fb ef ff ff       	call   379 <getmessage>
    137e:	83 c4 10             	add    $0x10,%esp
    1381:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    1384:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1388:	74 e2                	je     136c <api_exec+0xd>
        {
            pf(&msg);
    138a:	83 ec 0c             	sub    $0xc,%esp
    138d:	8d 45 c8             	lea    -0x38(%ebp),%eax
    1390:	50                   	push   %eax
    1391:	8b 45 0c             	mov    0xc(%ebp),%eax
    1394:	ff d0                	call   *%eax
    1396:	83 c4 10             	add    $0x10,%esp
        }
    }
    1399:	eb d1                	jmp    136c <api_exec+0xd>

0000139b <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    139b:	55                   	push   %ebp
    139c:	89 e5                	mov    %esp,%ebp
    139e:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    13a1:	8b 45 08             	mov    0x8(%ebp),%eax
    13a4:	8b 00                	mov    (%eax),%eax
    13a6:	83 ec 08             	sub    $0x8,%esp
    13a9:	ff 75 0c             	pushl  0xc(%ebp)
    13ac:	50                   	push   %eax
    13ad:	e8 cf ef ff ff       	call   381 <settimer>
    13b2:	83 c4 10             	add    $0x10,%esp
    return 0;
    13b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13ba:	c9                   	leave  
    13bb:	c3                   	ret    

000013bc <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    13bc:	55                   	push   %ebp
    13bd:	89 e5                	mov    %esp,%ebp
    13bf:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    13c2:	8b 45 08             	mov    0x8(%ebp),%eax
    13c5:	8b 50 18             	mov    0x18(%eax),%edx
    13c8:	ff 75 18             	pushl  0x18(%ebp)
    13cb:	ff 75 14             	pushl  0x14(%ebp)
    13ce:	83 ec 04             	sub    $0x4,%esp
    13d1:	89 e0                	mov    %esp,%eax
    13d3:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    13d7:	66 89 08             	mov    %cx,(%eax)
    13da:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    13de:	88 48 02             	mov    %cl,0x2(%eax)
    13e1:	8b 45 08             	mov    0x8(%ebp),%eax
    13e4:	ff 70 10             	pushl  0x10(%eax)
    13e7:	ff 70 0c             	pushl  0xc(%eax)
    13ea:	ff 75 10             	pushl  0x10(%ebp)
    13ed:	ff 75 0c             	pushl  0xc(%ebp)
    13f0:	52                   	push   %edx
    13f1:	e8 6f 04 00 00       	call   1865 <drawRect>
    13f6:	83 c4 20             	add    $0x20,%esp
    return 0;
    13f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13fe:	c9                   	leave  
    13ff:	c3                   	ret    

00001400 <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    1400:	55                   	push   %ebp
    1401:	89 e5                	mov    %esp,%ebp
    1403:	83 ec 28             	sub    $0x28,%esp
    1406:	8b 45 14             	mov    0x14(%ebp),%eax
    1409:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    140c:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    1410:	8b 45 0c             	mov    0xc(%ebp),%eax
    1413:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1416:	8b 45 10             	mov    0x10(%ebp),%eax
    1419:	89 45 f4             	mov    %eax,-0xc(%ebp)
    141c:	8b 45 08             	mov    0x8(%ebp),%eax
    141f:	8b 40 18             	mov    0x18(%eax),%eax
    1422:	83 ec 04             	sub    $0x4,%esp
    1425:	ff 75 18             	pushl  0x18(%ebp)
    1428:	52                   	push   %edx
    1429:	8b 55 08             	mov    0x8(%ebp),%edx
    142c:	ff 72 10             	pushl  0x10(%edx)
    142f:	ff 72 0c             	pushl  0xc(%edx)
    1432:	ff 75 f4             	pushl  -0xc(%ebp)
    1435:	ff 75 f0             	pushl  -0x10(%ebp)
    1438:	50                   	push   %eax
    1439:	e8 d4 02 00 00       	call   1712 <drawCharacter>
    143e:	83 c4 20             	add    $0x20,%esp
    return 0;
    1441:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1446:	c9                   	leave  
    1447:	c3                   	ret    

00001448 <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    1448:	55                   	push   %ebp
    1449:	89 e5                	mov    %esp,%ebp
    144b:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    144e:	8b 45 0c             	mov    0xc(%ebp),%eax
    1451:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1454:	8b 45 10             	mov    0x10(%ebp),%eax
    1457:	89 45 f4             	mov    %eax,-0xc(%ebp)
    145a:	8b 45 08             	mov    0x8(%ebp),%eax
    145d:	8b 40 18             	mov    0x18(%eax),%eax
    1460:	83 ec 04             	sub    $0x4,%esp
    1463:	ff 75 18             	pushl  0x18(%ebp)
    1466:	ff 75 14             	pushl  0x14(%ebp)
    1469:	8b 55 08             	mov    0x8(%ebp),%edx
    146c:	ff 72 10             	pushl  0x10(%edx)
    146f:	ff 72 0c             	pushl  0xc(%edx)
    1472:	ff 75 f4             	pushl  -0xc(%ebp)
    1475:	ff 75 f0             	pushl  -0x10(%ebp)
    1478:	50                   	push   %eax
    1479:	e8 8e 03 00 00       	call   180c <drawString>
    147e:	83 c4 20             	add    $0x20,%esp
    return 0;
    1481:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1486:	c9                   	leave  
    1487:	c3                   	ret    

00001488 <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    1488:	55                   	push   %ebp
    1489:	89 e5                	mov    %esp,%ebp
    148b:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    148e:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    1492:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    1496:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    149a:	83 ec 08             	sub    $0x8,%esp
    149d:	83 ec 04             	sub    $0x4,%esp
    14a0:	89 e0                	mov    %esp,%eax
    14a2:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    14a6:	66 89 10             	mov    %dx,(%eax)
    14a9:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    14ad:	88 50 02             	mov    %dl,0x2(%eax)
    14b0:	ff 75 18             	pushl  0x18(%ebp)
    14b3:	ff 75 14             	pushl  0x14(%ebp)
    14b6:	ff 75 10             	pushl  0x10(%ebp)
    14b9:	ff 75 0c             	pushl  0xc(%ebp)
    14bc:	ff 75 08             	pushl  0x8(%ebp)
    14bf:	e8 f8 fe ff ff       	call   13bc <api_drawRect>
    14c4:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    14c7:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    14cb:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    14cf:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    14d3:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    14d7:	8b 45 10             	mov    0x10(%ebp),%eax
    14da:	8d 50 0a             	lea    0xa(%eax),%edx
    14dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    14e0:	83 c0 0a             	add    $0xa,%eax
    14e3:	83 ec 0c             	sub    $0xc,%esp
    14e6:	ff 75 f4             	pushl  -0xc(%ebp)
    14e9:	ff 75 1c             	pushl  0x1c(%ebp)
    14ec:	52                   	push   %edx
    14ed:	50                   	push   %eax
    14ee:	ff 75 08             	pushl  0x8(%ebp)
    14f1:	e8 52 ff ff ff       	call   1448 <api_drawString>
    14f6:	83 c4 20             	add    $0x20,%esp
    return 0;
    14f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    14fe:	c9                   	leave  
    14ff:	c3                   	ret    

00001500 <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    1500:	55                   	push   %ebp
    1501:	89 e5                	mov    %esp,%ebp
    1503:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    1506:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    150d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1514:	8b 45 08             	mov    0x8(%ebp),%eax
    1517:	8b 40 18             	mov    0x18(%eax),%eax
    151a:	ff 75 1c             	pushl  0x1c(%ebp)
    151d:	ff 75 18             	pushl  0x18(%ebp)
    1520:	ff 75 1c             	pushl  0x1c(%ebp)
    1523:	ff 75 18             	pushl  0x18(%ebp)
    1526:	8b 55 08             	mov    0x8(%ebp),%edx
    1529:	ff 72 10             	pushl  0x10(%edx)
    152c:	ff 72 0c             	pushl  0xc(%edx)
    152f:	ff 75 f4             	pushl  -0xc(%ebp)
    1532:	ff 75 f0             	pushl  -0x10(%ebp)
    1535:	ff 75 14             	pushl  0x14(%ebp)
    1538:	ff 75 10             	pushl  0x10(%ebp)
    153b:	ff 75 0c             	pushl  0xc(%ebp)
    153e:	50                   	push   %eax
    153f:	e8 16 05 00 00       	call   1a5a <drawBitmap>
    1544:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    1547:	8b 45 08             	mov    0x8(%ebp),%eax
    154a:	8b 40 18             	mov    0x18(%eax),%eax
    154d:	ff 75 28             	pushl  0x28(%ebp)
    1550:	ff 75 1c             	pushl  0x1c(%ebp)
    1553:	ff 75 18             	pushl  0x18(%ebp)
    1556:	8b 55 08             	mov    0x8(%ebp),%edx
    1559:	ff 72 10             	pushl  0x10(%edx)
    155c:	ff 72 0c             	pushl  0xc(%edx)
    155f:	ff 75 14             	pushl  0x14(%ebp)
    1562:	ff 75 10             	pushl  0x10(%ebp)
    1565:	50                   	push   %eax
    1566:	e8 99 07 00 00       	call   1d04 <colorShift>
    156b:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    156e:	8b 45 08             	mov    0x8(%ebp),%eax
    1571:	8b 50 18             	mov    0x18(%eax),%edx
    1574:	83 ec 0c             	sub    $0xc,%esp
    1577:	ff 75 20             	pushl  0x20(%ebp)
    157a:	ff 75 1c             	pushl  0x1c(%ebp)
    157d:	ff 75 18             	pushl  0x18(%ebp)
    1580:	83 ec 04             	sub    $0x4,%esp
    1583:	89 e0                	mov    %esp,%eax
    1585:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    1589:	66 89 08             	mov    %cx,(%eax)
    158c:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    1590:	88 48 02             	mov    %cl,0x2(%eax)
    1593:	8b 45 08             	mov    0x8(%ebp),%eax
    1596:	ff 70 10             	pushl  0x10(%eax)
    1599:	ff 70 0c             	pushl  0xc(%eax)
    159c:	ff 75 14             	pushl  0x14(%ebp)
    159f:	ff 75 10             	pushl  0x10(%ebp)
    15a2:	52                   	push   %edx
    15a3:	e8 6d 03 00 00       	call   1915 <drawBorder>
    15a8:	83 c4 30             	add    $0x30,%esp
    return 0;
    15ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
    15b0:	c9                   	leave  
    15b1:	c3                   	ret    

000015b2 <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    15b2:	55                   	push   %ebp
    15b3:	89 e5                	mov    %esp,%ebp
    15b5:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    15b8:	8b 45 08             	mov    0x8(%ebp),%eax
    15bb:	8b 00                	mov    (%eax),%eax
    15bd:	83 ec 0c             	sub    $0xc,%esp
    15c0:	50                   	push   %eax
    15c1:	e8 cb ed ff ff       	call   391 <destroywindow>
    15c6:	83 c4 10             	add    $0x10,%esp
    return 0;
    15c9:	b8 00 00 00 00       	mov    $0x0,%eax
    15ce:	c9                   	leave  
    15cf:	c3                   	ret    

000015d0 <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    15d0:	55                   	push   %ebp
    15d1:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    15d3:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    15d7:	8b 45 08             	mov    0x8(%ebp),%eax
    15da:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    15dd:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    15e1:	8b 45 08             	mov    0x8(%ebp),%eax
    15e4:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    15e7:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    15eb:	8b 45 08             	mov    0x8(%ebp),%eax
    15ee:	88 10                	mov    %dl,(%eax)
}
    15f0:	90                   	nop
    15f1:	5d                   	pop    %ebp
    15f2:	c3                   	ret    

000015f3 <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    15f3:	55                   	push   %ebp
    15f4:	89 e5                	mov    %esp,%ebp
    15f6:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    15f9:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    15fd:	3c ff                	cmp    $0xff,%al
    15ff:	75 22                	jne    1623 <drawPointAlpha+0x30>
        color->R = origin.R;
    1601:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    1605:	8b 45 08             	mov    0x8(%ebp),%eax
    1608:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    160b:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    160f:	8b 45 08             	mov    0x8(%ebp),%eax
    1612:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    1615:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    1619:	8b 45 08             	mov    0x8(%ebp),%eax
    161c:	88 10                	mov    %dl,(%eax)
        return;
    161e:	e9 ed 00 00 00       	jmp    1710 <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    1623:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1627:	84 c0                	test   %al,%al
    1629:	0f 84 e0 00 00 00    	je     170f <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    162f:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1633:	0f b6 c0             	movzbl %al,%eax
    1636:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    163a:	df 45 e4             	fild   -0x1c(%ebp)
    163d:	d9 05 80 9c 01 00    	flds   0x19c80
    1643:	de f9                	fdivrp %st,%st(1)
    1645:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    1648:	8b 45 08             	mov    0x8(%ebp),%eax
    164b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    164f:	0f b6 c0             	movzbl %al,%eax
    1652:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1655:	db 45 e4             	fildl  -0x1c(%ebp)
    1658:	d9 e8                	fld1   
    165a:	d8 65 fc             	fsubs  -0x4(%ebp)
    165d:	de c9                	fmulp  %st,%st(1)
    165f:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    1663:	0f b6 c0             	movzbl %al,%eax
    1666:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1669:	db 45 e4             	fildl  -0x1c(%ebp)
    166c:	d8 4d fc             	fmuls  -0x4(%ebp)
    166f:	de c1                	faddp  %st,%st(1)
    1671:	d9 7d ee             	fnstcw -0x12(%ebp)
    1674:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    1678:	b4 0c                	mov    $0xc,%ah
    167a:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    167e:	d9 6d ec             	fldcw  -0x14(%ebp)
    1681:	df 5d ea             	fistp  -0x16(%ebp)
    1684:	d9 6d ee             	fldcw  -0x12(%ebp)
    1687:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    168b:	89 c2                	mov    %eax,%edx
    168d:	8b 45 08             	mov    0x8(%ebp),%eax
    1690:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    1693:	8b 45 08             	mov    0x8(%ebp),%eax
    1696:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    169a:	0f b6 c0             	movzbl %al,%eax
    169d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16a0:	db 45 e4             	fildl  -0x1c(%ebp)
    16a3:	d9 e8                	fld1   
    16a5:	d8 65 fc             	fsubs  -0x4(%ebp)
    16a8:	de c9                	fmulp  %st,%st(1)
    16aa:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    16ae:	0f b6 c0             	movzbl %al,%eax
    16b1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16b4:	db 45 e4             	fildl  -0x1c(%ebp)
    16b7:	d8 4d fc             	fmuls  -0x4(%ebp)
    16ba:	de c1                	faddp  %st,%st(1)
    16bc:	d9 6d ec             	fldcw  -0x14(%ebp)
    16bf:	df 5d ea             	fistp  -0x16(%ebp)
    16c2:	d9 6d ee             	fldcw  -0x12(%ebp)
    16c5:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    16c9:	89 c2                	mov    %eax,%edx
    16cb:	8b 45 08             	mov    0x8(%ebp),%eax
    16ce:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    16d1:	8b 45 08             	mov    0x8(%ebp),%eax
    16d4:	0f b6 00             	movzbl (%eax),%eax
    16d7:	0f b6 c0             	movzbl %al,%eax
    16da:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16dd:	db 45 e4             	fildl  -0x1c(%ebp)
    16e0:	d9 e8                	fld1   
    16e2:	d8 65 fc             	fsubs  -0x4(%ebp)
    16e5:	de c9                	fmulp  %st,%st(1)
    16e7:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    16eb:	0f b6 c0             	movzbl %al,%eax
    16ee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16f1:	db 45 e4             	fildl  -0x1c(%ebp)
    16f4:	d8 4d fc             	fmuls  -0x4(%ebp)
    16f7:	de c1                	faddp  %st,%st(1)
    16f9:	d9 6d ec             	fldcw  -0x14(%ebp)
    16fc:	df 5d ea             	fistp  -0x16(%ebp)
    16ff:	d9 6d ee             	fldcw  -0x12(%ebp)
    1702:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1706:	89 c2                	mov    %eax,%edx
    1708:	8b 45 08             	mov    0x8(%ebp),%eax
    170b:	88 10                	mov    %dl,(%eax)
    170d:	eb 01                	jmp    1710 <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    170f:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    1710:	c9                   	leave  
    1711:	c3                   	ret    

00001712 <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    1712:	55                   	push   %ebp
    1713:	89 e5                	mov    %esp,%ebp
    1715:	83 ec 14             	sub    $0x14,%esp
    1718:	8b 45 1c             	mov    0x1c(%ebp),%eax
    171b:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    171e:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    1722:	83 e8 20             	sub    $0x20,%eax
    1725:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    1728:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    172c:	0f 88 d7 00 00 00    	js     1809 <drawCharacter+0xf7>
    1732:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    1736:	0f 8f cd 00 00 00    	jg     1809 <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    173c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1743:	e9 b5 00 00 00       	jmp    17fd <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    1748:	8b 55 10             	mov    0x10(%ebp),%edx
    174b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    174e:	01 c2                	add    %eax,%edx
    1750:	8b 45 14             	mov    0x14(%ebp),%eax
    1753:	39 c2                	cmp    %eax,%edx
    1755:	0f 8f af 00 00 00    	jg     180a <drawCharacter+0xf8>
    175b:	8b 55 10             	mov    0x10(%ebp),%edx
    175e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1761:	01 d0                	add    %edx,%eax
    1763:	85 c0                	test   %eax,%eax
    1765:	0f 88 9f 00 00 00    	js     180a <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    176b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1772:	eb 7b                	jmp    17ef <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    1774:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1777:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    177a:	89 d0                	mov    %edx,%eax
    177c:	c1 e0 03             	shl    $0x3,%eax
    177f:	01 d0                	add    %edx,%eax
    1781:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    1787:	01 c2                	add    %eax,%edx
    1789:	8b 45 f8             	mov    -0x8(%ebp),%eax
    178c:	01 d0                	add    %edx,%eax
    178e:	05 60 60 01 00       	add    $0x16060,%eax
    1793:	0f b6 00             	movzbl (%eax),%eax
    1796:	3c 01                	cmp    $0x1,%al
    1798:	75 51                	jne    17eb <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    179a:	8b 55 0c             	mov    0xc(%ebp),%edx
    179d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    17a0:	01 c2                	add    %eax,%edx
    17a2:	8b 45 18             	mov    0x18(%ebp),%eax
    17a5:	39 c2                	cmp    %eax,%edx
    17a7:	7f 50                	jg     17f9 <drawCharacter+0xe7>
    17a9:	8b 55 0c             	mov    0xc(%ebp),%edx
    17ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
    17af:	01 d0                	add    %edx,%eax
    17b1:	85 c0                	test   %eax,%eax
    17b3:	78 44                	js     17f9 <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    17b5:	8b 55 10             	mov    0x10(%ebp),%edx
    17b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    17bb:	01 c2                	add    %eax,%edx
    17bd:	8b 45 18             	mov    0x18(%ebp),%eax
    17c0:	0f af c2             	imul   %edx,%eax
    17c3:	89 c2                	mov    %eax,%edx
    17c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    17c8:	01 c2                	add    %eax,%edx
    17ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
    17cd:	01 c2                	add    %eax,%edx
    17cf:	89 d0                	mov    %edx,%eax
    17d1:	01 c0                	add    %eax,%eax
    17d3:	01 c2                	add    %eax,%edx
    17d5:	8b 45 08             	mov    0x8(%ebp),%eax
    17d8:	01 d0                	add    %edx,%eax
    17da:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    17dd:	ff 75 20             	pushl  0x20(%ebp)
    17e0:	ff 75 f0             	pushl  -0x10(%ebp)
    17e3:	e8 0b fe ff ff       	call   15f3 <drawPointAlpha>
    17e8:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    17eb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    17ef:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    17f3:	0f 8e 7b ff ff ff    	jle    1774 <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    17f9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    17fd:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    1801:	0f 8e 41 ff ff ff    	jle    1748 <drawCharacter+0x36>
    1807:	eb 01                	jmp    180a <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    1809:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    180a:	c9                   	leave  
    180b:	c3                   	ret    

0000180c <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    180c:	55                   	push   %ebp
    180d:	89 e5                	mov    %esp,%ebp
    180f:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    1812:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    1819:	eb 3d                	jmp    1858 <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    181b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    181e:	0f b6 00             	movzbl (%eax),%eax
    1821:	0f be c0             	movsbl %al,%eax
    1824:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1827:	8b 55 fc             	mov    -0x4(%ebp),%edx
    182a:	01 ca                	add    %ecx,%edx
    182c:	89 55 f4             	mov    %edx,-0xc(%ebp)
    182f:	8b 55 10             	mov    0x10(%ebp),%edx
    1832:	89 55 f8             	mov    %edx,-0x8(%ebp)
    1835:	ff 75 20             	pushl  0x20(%ebp)
    1838:	50                   	push   %eax
    1839:	ff 75 18             	pushl  0x18(%ebp)
    183c:	ff 75 14             	pushl  0x14(%ebp)
    183f:	ff 75 f8             	pushl  -0x8(%ebp)
    1842:	ff 75 f4             	pushl  -0xc(%ebp)
    1845:	ff 75 08             	pushl  0x8(%ebp)
    1848:	e8 c5 fe ff ff       	call   1712 <drawCharacter>
    184d:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    1850:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    1854:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    1858:	8b 45 1c             	mov    0x1c(%ebp),%eax
    185b:	0f b6 00             	movzbl (%eax),%eax
    185e:	84 c0                	test   %al,%al
    1860:	75 b9                	jne    181b <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    1862:	90                   	nop
    1863:	c9                   	leave  
    1864:	c3                   	ret    

00001865 <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    1865:	55                   	push   %ebp
    1866:	89 e5                	mov    %esp,%ebp
    1868:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    186b:	8b 45 20             	mov    0x20(%ebp),%eax
    186e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1871:	8b 45 24             	mov    0x24(%ebp),%eax
    1874:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1877:	8b 55 14             	mov    0x14(%ebp),%edx
    187a:	8b 45 10             	mov    0x10(%ebp),%eax
    187d:	29 c2                	sub    %eax,%edx
    187f:	89 d0                	mov    %edx,%eax
    1881:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1884:	7d 0d                	jge    1893 <drawRect+0x2e>
        draw_h = s.h - p.y;
    1886:	8b 55 14             	mov    0x14(%ebp),%edx
    1889:	8b 45 10             	mov    0x10(%ebp),%eax
    188c:	29 c2                	sub    %eax,%edx
    188e:	89 d0                	mov    %edx,%eax
    1890:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1893:	8b 55 18             	mov    0x18(%ebp),%edx
    1896:	8b 45 0c             	mov    0xc(%ebp),%eax
    1899:	29 c2                	sub    %eax,%edx
    189b:	89 d0                	mov    %edx,%eax
    189d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    18a0:	7d 0d                	jge    18af <drawRect+0x4a>
        draw_w = s.w - p.x;
    18a2:	8b 55 18             	mov    0x18(%ebp),%edx
    18a5:	8b 45 0c             	mov    0xc(%ebp),%eax
    18a8:	29 c2                	sub    %eax,%edx
    18aa:	89 d0                	mov    %edx,%eax
    18ac:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    18af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    18b6:	eb 52                	jmp    190a <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    18b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    18bf:	eb 3d                	jmp    18fe <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    18c1:	8b 55 10             	mov    0x10(%ebp),%edx
    18c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    18c7:	01 c2                	add    %eax,%edx
    18c9:	8b 45 18             	mov    0x18(%ebp),%eax
    18cc:	0f af c2             	imul   %edx,%eax
    18cf:	89 c2                	mov    %eax,%edx
    18d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    18d4:	01 c2                	add    %eax,%edx
    18d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    18d9:	01 c2                	add    %eax,%edx
    18db:	89 d0                	mov    %edx,%eax
    18dd:	01 c0                	add    %eax,%eax
    18df:	01 c2                	add    %eax,%edx
    18e1:	8b 45 08             	mov    0x8(%ebp),%eax
    18e4:	01 d0                	add    %edx,%eax
    18e6:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    18e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    18ec:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    18f0:	66 89 10             	mov    %dx,(%eax)
    18f3:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    18f7:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    18fa:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    18fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1901:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1904:	7c bb                	jl     18c1 <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1906:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    190a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    190d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1910:	7c a6                	jl     18b8 <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    1912:	90                   	nop
    1913:	c9                   	leave  
    1914:	c3                   	ret    

00001915 <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    1915:	55                   	push   %ebp
    1916:	89 e5                	mov    %esp,%ebp
    1918:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    191b:	8b 45 28             	mov    0x28(%ebp),%eax
    191e:	89 45 c8             	mov    %eax,-0x38(%ebp)
    1921:	8b 45 24             	mov    0x24(%ebp),%eax
    1924:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1927:	ff 75 cc             	pushl  -0x34(%ebp)
    192a:	ff 75 c8             	pushl  -0x38(%ebp)
    192d:	83 ec 04             	sub    $0x4,%esp
    1930:	89 e0                	mov    %esp,%eax
    1932:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1936:	66 89 10             	mov    %dx,(%eax)
    1939:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    193d:	88 50 02             	mov    %dl,0x2(%eax)
    1940:	ff 75 18             	pushl  0x18(%ebp)
    1943:	ff 75 14             	pushl  0x14(%ebp)
    1946:	ff 75 10             	pushl  0x10(%ebp)
    1949:	ff 75 0c             	pushl  0xc(%ebp)
    194c:	ff 75 08             	pushl  0x8(%ebp)
    194f:	e8 11 ff ff ff       	call   1865 <drawRect>
    1954:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    1957:	8b 45 28             	mov    0x28(%ebp),%eax
    195a:	89 45 d0             	mov    %eax,-0x30(%ebp)
    195d:	8b 45 24             	mov    0x24(%ebp),%eax
    1960:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1963:	8b 45 0c             	mov    0xc(%ebp),%eax
    1966:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1969:	8b 55 10             	mov    0x10(%ebp),%edx
    196c:	8b 45 20             	mov    0x20(%ebp),%eax
    196f:	01 d0                	add    %edx,%eax
    1971:	2b 45 28             	sub    0x28(%ebp),%eax
    1974:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1977:	ff 75 d4             	pushl  -0x2c(%ebp)
    197a:	ff 75 d0             	pushl  -0x30(%ebp)
    197d:	83 ec 04             	sub    $0x4,%esp
    1980:	89 e0                	mov    %esp,%eax
    1982:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1986:	66 89 10             	mov    %dx,(%eax)
    1989:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    198d:	88 50 02             	mov    %dl,0x2(%eax)
    1990:	ff 75 18             	pushl  0x18(%ebp)
    1993:	ff 75 14             	pushl  0x14(%ebp)
    1996:	ff 75 dc             	pushl  -0x24(%ebp)
    1999:	ff 75 d8             	pushl  -0x28(%ebp)
    199c:	ff 75 08             	pushl  0x8(%ebp)
    199f:	e8 c1 fe ff ff       	call   1865 <drawRect>
    19a4:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    19a7:	8b 45 20             	mov    0x20(%ebp),%eax
    19aa:	8b 55 28             	mov    0x28(%ebp),%edx
    19ad:	01 d2                	add    %edx,%edx
    19af:	29 d0                	sub    %edx,%eax
    19b1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    19b4:	8b 45 28             	mov    0x28(%ebp),%eax
    19b7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    19ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    19bd:	89 45 e8             	mov    %eax,-0x18(%ebp)
    19c0:	8b 55 10             	mov    0x10(%ebp),%edx
    19c3:	8b 45 28             	mov    0x28(%ebp),%eax
    19c6:	01 d0                	add    %edx,%eax
    19c8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    19cb:	ff 75 e4             	pushl  -0x1c(%ebp)
    19ce:	ff 75 e0             	pushl  -0x20(%ebp)
    19d1:	83 ec 04             	sub    $0x4,%esp
    19d4:	89 e0                	mov    %esp,%eax
    19d6:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    19da:	66 89 10             	mov    %dx,(%eax)
    19dd:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    19e1:	88 50 02             	mov    %dl,0x2(%eax)
    19e4:	ff 75 18             	pushl  0x18(%ebp)
    19e7:	ff 75 14             	pushl  0x14(%ebp)
    19ea:	ff 75 ec             	pushl  -0x14(%ebp)
    19ed:	ff 75 e8             	pushl  -0x18(%ebp)
    19f0:	ff 75 08             	pushl  0x8(%ebp)
    19f3:	e8 6d fe ff ff       	call   1865 <drawRect>
    19f8:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    19fb:	8b 45 20             	mov    0x20(%ebp),%eax
    19fe:	8b 55 28             	mov    0x28(%ebp),%edx
    1a01:	01 d2                	add    %edx,%edx
    1a03:	29 d0                	sub    %edx,%eax
    1a05:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1a08:	8b 45 28             	mov    0x28(%ebp),%eax
    1a0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1a0e:	8b 55 0c             	mov    0xc(%ebp),%edx
    1a11:	8b 45 24             	mov    0x24(%ebp),%eax
    1a14:	01 d0                	add    %edx,%eax
    1a16:	2b 45 28             	sub    0x28(%ebp),%eax
    1a19:	89 45 f8             	mov    %eax,-0x8(%ebp)
    1a1c:	8b 55 10             	mov    0x10(%ebp),%edx
    1a1f:	8b 45 28             	mov    0x28(%ebp),%eax
    1a22:	01 d0                	add    %edx,%eax
    1a24:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1a27:	ff 75 f4             	pushl  -0xc(%ebp)
    1a2a:	ff 75 f0             	pushl  -0x10(%ebp)
    1a2d:	83 ec 04             	sub    $0x4,%esp
    1a30:	89 e0                	mov    %esp,%eax
    1a32:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1a36:	66 89 10             	mov    %dx,(%eax)
    1a39:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1a3d:	88 50 02             	mov    %dl,0x2(%eax)
    1a40:	ff 75 18             	pushl  0x18(%ebp)
    1a43:	ff 75 14             	pushl  0x14(%ebp)
    1a46:	ff 75 fc             	pushl  -0x4(%ebp)
    1a49:	ff 75 f8             	pushl  -0x8(%ebp)
    1a4c:	ff 75 08             	pushl  0x8(%ebp)
    1a4f:	e8 11 fe ff ff       	call   1865 <drawRect>
    1a54:	83 c4 20             	add    $0x20,%esp
}
    1a57:	90                   	nop
    1a58:	c9                   	leave  
    1a59:	c3                   	ret    

00001a5a <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1a5a:	55                   	push   %ebp
    1a5b:	89 e5                	mov    %esp,%ebp
    1a5d:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1a60:	8b 45 30             	mov    0x30(%ebp),%eax
    1a63:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    1a66:	8b 45 34             	mov    0x34(%ebp),%eax
    1a69:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    1a6c:	8b 55 20             	mov    0x20(%ebp),%edx
    1a6f:	8b 45 14             	mov    0x14(%ebp),%eax
    1a72:	29 c2                	sub    %eax,%edx
    1a74:	89 d0                	mov    %edx,%eax
    1a76:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1a79:	7d 0d                	jge    1a88 <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    1a7b:	8b 55 20             	mov    0x20(%ebp),%edx
    1a7e:	8b 45 14             	mov    0x14(%ebp),%eax
    1a81:	29 c2                	sub    %eax,%edx
    1a83:	89 d0                	mov    %edx,%eax
    1a85:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1a88:	8b 55 28             	mov    0x28(%ebp),%edx
    1a8b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1a8e:	29 c2                	sub    %eax,%edx
    1a90:	89 d0                	mov    %edx,%eax
    1a92:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1a95:	7d 0d                	jge    1aa4 <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1a97:	8b 55 28             	mov    0x28(%ebp),%edx
    1a9a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1a9d:	29 c2                	sub    %eax,%edx
    1a9f:	89 d0                	mov    %edx,%eax
    1aa1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1aa4:	8b 55 24             	mov    0x24(%ebp),%edx
    1aa7:	8b 45 10             	mov    0x10(%ebp),%eax
    1aaa:	29 c2                	sub    %eax,%edx
    1aac:	89 d0                	mov    %edx,%eax
    1aae:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1ab1:	7d 0d                	jge    1ac0 <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    1ab3:	8b 55 24             	mov    0x24(%ebp),%edx
    1ab6:	8b 45 10             	mov    0x10(%ebp),%eax
    1ab9:	29 c2                	sub    %eax,%edx
    1abb:	89 d0                	mov    %edx,%eax
    1abd:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1ac0:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1ac3:	8b 45 18             	mov    0x18(%ebp),%eax
    1ac6:	29 c2                	sub    %eax,%edx
    1ac8:	89 d0                	mov    %edx,%eax
    1aca:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1acd:	7d 0d                	jge    1adc <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    1acf:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1ad2:	8b 45 18             	mov    0x18(%ebp),%eax
    1ad5:	29 c2                	sub    %eax,%edx
    1ad7:	89 d0                	mov    %edx,%eax
    1ad9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1adc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    1ae3:	e9 83 00 00 00       	jmp    1b6b <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    1ae8:	8b 55 14             	mov    0x14(%ebp),%edx
    1aeb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1aee:	01 d0                	add    %edx,%eax
    1af0:	85 c0                	test   %eax,%eax
    1af2:	78 72                	js     1b66 <drawBitmap+0x10c>
    1af4:	8b 55 14             	mov    0x14(%ebp),%edx
    1af7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1afa:	01 c2                	add    %eax,%edx
    1afc:	8b 45 20             	mov    0x20(%ebp),%eax
    1aff:	39 c2                	cmp    %eax,%edx
    1b01:	7d 63                	jge    1b66 <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    1b03:	8b 55 14             	mov    0x14(%ebp),%edx
    1b06:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b09:	01 c2                	add    %eax,%edx
    1b0b:	8b 45 24             	mov    0x24(%ebp),%eax
    1b0e:	0f af c2             	imul   %edx,%eax
    1b11:	89 c2                	mov    %eax,%edx
    1b13:	8b 45 10             	mov    0x10(%ebp),%eax
    1b16:	01 c2                	add    %eax,%edx
    1b18:	89 d0                	mov    %edx,%eax
    1b1a:	01 c0                	add    %eax,%eax
    1b1c:	01 c2                	add    %eax,%edx
    1b1e:	8b 45 08             	mov    0x8(%ebp),%eax
    1b21:	01 d0                	add    %edx,%eax
    1b23:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    1b26:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1b29:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b2c:	01 c2                	add    %eax,%edx
    1b2e:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1b31:	0f af c2             	imul   %edx,%eax
    1b34:	89 c2                	mov    %eax,%edx
    1b36:	8b 45 18             	mov    0x18(%ebp),%eax
    1b39:	01 c2                	add    %eax,%edx
    1b3b:	89 d0                	mov    %edx,%eax
    1b3d:	01 c0                	add    %eax,%eax
    1b3f:	01 c2                	add    %eax,%edx
    1b41:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b44:	01 d0                	add    %edx,%eax
    1b46:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    1b49:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1b4c:	89 d0                	mov    %edx,%eax
    1b4e:	01 c0                	add    %eax,%eax
    1b50:	01 d0                	add    %edx,%eax
    1b52:	83 ec 04             	sub    $0x4,%esp
    1b55:	50                   	push   %eax
    1b56:	ff 75 e4             	pushl  -0x1c(%ebp)
    1b59:	ff 75 e8             	pushl  -0x18(%ebp)
    1b5c:	e8 23 e7 ff ff       	call   284 <memmove>
    1b61:	83 c4 10             	add    $0x10,%esp
    1b64:	eb 01                	jmp    1b67 <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    1b66:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1b67:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    1b6b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b6e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1b71:	0f 8c 71 ff ff ff    	jl     1ae8 <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    1b77:	90                   	nop
    1b78:	c9                   	leave  
    1b79:	c3                   	ret    

00001b7a <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1b7a:	55                   	push   %ebp
    1b7b:	89 e5                	mov    %esp,%ebp
    1b7d:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1b80:	8b 45 30             	mov    0x30(%ebp),%eax
    1b83:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    1b86:	8b 45 34             	mov    0x34(%ebp),%eax
    1b89:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    1b8c:	8b 55 20             	mov    0x20(%ebp),%edx
    1b8f:	8b 45 14             	mov    0x14(%ebp),%eax
    1b92:	29 c2                	sub    %eax,%edx
    1b94:	89 d0                	mov    %edx,%eax
    1b96:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1b99:	7d 0d                	jge    1ba8 <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    1b9b:	8b 55 20             	mov    0x20(%ebp),%edx
    1b9e:	8b 45 14             	mov    0x14(%ebp),%eax
    1ba1:	29 c2                	sub    %eax,%edx
    1ba3:	89 d0                	mov    %edx,%eax
    1ba5:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1ba8:	8b 55 28             	mov    0x28(%ebp),%edx
    1bab:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1bae:	29 c2                	sub    %eax,%edx
    1bb0:	89 d0                	mov    %edx,%eax
    1bb2:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1bb5:	7d 0d                	jge    1bc4 <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1bb7:	8b 55 28             	mov    0x28(%ebp),%edx
    1bba:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1bbd:	29 c2                	sub    %eax,%edx
    1bbf:	89 d0                	mov    %edx,%eax
    1bc1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1bc4:	8b 55 24             	mov    0x24(%ebp),%edx
    1bc7:	8b 45 10             	mov    0x10(%ebp),%eax
    1bca:	29 c2                	sub    %eax,%edx
    1bcc:	89 d0                	mov    %edx,%eax
    1bce:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1bd1:	7d 0d                	jge    1be0 <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    1bd3:	8b 55 24             	mov    0x24(%ebp),%edx
    1bd6:	8b 45 10             	mov    0x10(%ebp),%eax
    1bd9:	29 c2                	sub    %eax,%edx
    1bdb:	89 d0                	mov    %edx,%eax
    1bdd:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1be0:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1be3:	8b 45 18             	mov    0x18(%ebp),%eax
    1be6:	29 c2                	sub    %eax,%edx
    1be8:	89 d0                	mov    %edx,%eax
    1bea:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1bed:	7d 0d                	jge    1bfc <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    1bef:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1bf2:	8b 45 18             	mov    0x18(%ebp),%eax
    1bf5:	29 c2                	sub    %eax,%edx
    1bf7:	89 d0                	mov    %edx,%eax
    1bf9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    1bfc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1c03:	e9 b8 00 00 00       	jmp    1cc0 <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    1c08:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1c0f:	e9 9c 00 00 00       	jmp    1cb0 <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    1c14:	8b 55 14             	mov    0x14(%ebp),%edx
    1c17:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1c1a:	01 c2                	add    %eax,%edx
    1c1c:	8b 45 24             	mov    0x24(%ebp),%eax
    1c1f:	0f af c2             	imul   %edx,%eax
    1c22:	89 c2                	mov    %eax,%edx
    1c24:	8b 45 10             	mov    0x10(%ebp),%eax
    1c27:	01 c2                	add    %eax,%edx
    1c29:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1c2c:	01 c2                	add    %eax,%edx
    1c2e:	89 d0                	mov    %edx,%eax
    1c30:	01 c0                	add    %eax,%eax
    1c32:	01 c2                	add    %eax,%edx
    1c34:	8b 45 08             	mov    0x8(%ebp),%eax
    1c37:	01 d0                	add    %edx,%eax
    1c39:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    1c3c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1c3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1c42:	01 c2                	add    %eax,%edx
    1c44:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1c47:	0f af c2             	imul   %edx,%eax
    1c4a:	89 c2                	mov    %eax,%edx
    1c4c:	8b 45 18             	mov    0x18(%ebp),%eax
    1c4f:	01 c2                	add    %eax,%edx
    1c51:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1c54:	01 c2                	add    %eax,%edx
    1c56:	89 d0                	mov    %edx,%eax
    1c58:	01 c0                	add    %eax,%eax
    1c5a:	01 c2                	add    %eax,%edx
    1c5c:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c5f:	01 d0                	add    %edx,%eax
    1c61:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    1c64:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c67:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1c6b:	3c ff                	cmp    $0xff,%al
    1c6d:	75 15                	jne    1c84 <drawTransparentBitmap+0x10a>
    1c6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c72:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1c76:	3c ff                	cmp    $0xff,%al
    1c78:	75 0a                	jne    1c84 <drawTransparentBitmap+0x10a>
    1c7a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c7d:	0f b6 00             	movzbl (%eax),%eax
    1c80:	3c ff                	cmp    $0xff,%al
    1c82:	74 27                	je     1cab <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    1c84:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c87:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    1c8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c8e:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    1c91:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c94:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    1c98:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c9b:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    1c9e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1ca1:	0f b6 10             	movzbl (%eax),%edx
    1ca4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ca7:	88 10                	mov    %dl,(%eax)
    1ca9:	eb 01                	jmp    1cac <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    1cab:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    1cac:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1cb0:	8b 45 34             	mov    0x34(%ebp),%eax
    1cb3:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1cb6:	0f 8f 58 ff ff ff    	jg     1c14 <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    1cbc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1cc0:	8b 45 30             	mov    0x30(%ebp),%eax
    1cc3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1cc6:	0f 8f 3c ff ff ff    	jg     1c08 <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    1ccc:	90                   	nop
    1ccd:	c9                   	leave  
    1cce:	c3                   	ret    

00001ccf <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    1ccf:	55                   	push   %ebp
    1cd0:	89 e5                	mov    %esp,%ebp
    1cd2:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    1cd5:	ff 75 24             	pushl  0x24(%ebp)
    1cd8:	ff 75 20             	pushl  0x20(%ebp)
    1cdb:	ff 75 1c             	pushl  0x1c(%ebp)
    1cde:	ff 75 18             	pushl  0x18(%ebp)
    1ce1:	ff 75 1c             	pushl  0x1c(%ebp)
    1ce4:	ff 75 18             	pushl  0x18(%ebp)
    1ce7:	ff 75 14             	pushl  0x14(%ebp)
    1cea:	ff 75 10             	pushl  0x10(%ebp)
    1ced:	ff 75 14             	pushl  0x14(%ebp)
    1cf0:	ff 75 10             	pushl  0x10(%ebp)
    1cf3:	ff 75 0c             	pushl  0xc(%ebp)
    1cf6:	ff 75 08             	pushl  0x8(%ebp)
    1cf9:	e8 5c fd ff ff       	call   1a5a <drawBitmap>
    1cfe:	83 c4 30             	add    $0x30,%esp
}
    1d01:	90                   	nop
    1d02:	c9                   	leave  
    1d03:	c3                   	ret    

00001d04 <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    1d04:	55                   	push   %ebp
    1d05:	89 e5                	mov    %esp,%ebp
    1d07:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1d0a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1d0d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1d10:	8b 45 20             	mov    0x20(%ebp),%eax
    1d13:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1d16:	8b 55 14             	mov    0x14(%ebp),%edx
    1d19:	8b 45 10             	mov    0x10(%ebp),%eax
    1d1c:	29 c2                	sub    %eax,%edx
    1d1e:	89 d0                	mov    %edx,%eax
    1d20:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1d23:	7d 0d                	jge    1d32 <colorShift+0x2e>
        draw_h = s.h - p.y;
    1d25:	8b 55 14             	mov    0x14(%ebp),%edx
    1d28:	8b 45 10             	mov    0x10(%ebp),%eax
    1d2b:	29 c2                	sub    %eax,%edx
    1d2d:	89 d0                	mov    %edx,%eax
    1d2f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1d32:	8b 55 18             	mov    0x18(%ebp),%edx
    1d35:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d38:	29 c2                	sub    %eax,%edx
    1d3a:	89 d0                	mov    %edx,%eax
    1d3c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1d3f:	7d 0d                	jge    1d4e <colorShift+0x4a>
        draw_w = s.w - p.x;
    1d41:	8b 55 18             	mov    0x18(%ebp),%edx
    1d44:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d47:	29 c2                	sub    %eax,%edx
    1d49:	89 d0                	mov    %edx,%eax
    1d4b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1d4e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1d55:	e9 fc 00 00 00       	jmp    1e56 <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    1d5a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1d61:	e9 e0 00 00 00       	jmp    1e46 <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    1d66:	8b 55 10             	mov    0x10(%ebp),%edx
    1d69:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1d6c:	01 c2                	add    %eax,%edx
    1d6e:	8b 45 18             	mov    0x18(%ebp),%eax
    1d71:	0f af c2             	imul   %edx,%eax
    1d74:	89 c2                	mov    %eax,%edx
    1d76:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d79:	01 c2                	add    %eax,%edx
    1d7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1d7e:	01 c2                	add    %eax,%edx
    1d80:	89 d0                	mov    %edx,%eax
    1d82:	01 c0                	add    %eax,%eax
    1d84:	01 c2                	add    %eax,%edx
    1d86:	8b 45 08             	mov    0x8(%ebp),%eax
    1d89:	01 d0                	add    %edx,%eax
    1d8b:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    1d8e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d91:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1d95:	3c c8                	cmp    $0xc8,%al
    1d97:	0f 86 a5 00 00 00    	jbe    1e42 <colorShift+0x13e>
    1d9d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1da0:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1da4:	3c c8                	cmp    $0xc8,%al
    1da6:	0f 86 96 00 00 00    	jbe    1e42 <colorShift+0x13e>
    1dac:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1daf:	0f b6 00             	movzbl (%eax),%eax
    1db2:	3c c8                	cmp    $0xc8,%al
    1db4:	0f 86 88 00 00 00    	jbe    1e42 <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    1dba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1dbd:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1dc1:	0f b6 d0             	movzbl %al,%edx
    1dc4:	8b 45 24             	mov    0x24(%ebp),%eax
    1dc7:	01 d0                	add    %edx,%eax
    1dc9:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1dcf:	89 d0                	mov    %edx,%eax
    1dd1:	c1 f8 1f             	sar    $0x1f,%eax
    1dd4:	c1 e8 18             	shr    $0x18,%eax
    1dd7:	01 c2                	add    %eax,%edx
    1dd9:	0f b6 d2             	movzbl %dl,%edx
    1ddc:	29 c2                	sub    %eax,%edx
    1dde:	89 d0                	mov    %edx,%eax
    1de0:	89 c2                	mov    %eax,%edx
    1de2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1de5:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    1de8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1deb:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1def:	0f b6 d0             	movzbl %al,%edx
    1df2:	8b 45 24             	mov    0x24(%ebp),%eax
    1df5:	01 d0                	add    %edx,%eax
    1df7:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1dfd:	89 d0                	mov    %edx,%eax
    1dff:	c1 f8 1f             	sar    $0x1f,%eax
    1e02:	c1 e8 18             	shr    $0x18,%eax
    1e05:	01 c2                	add    %eax,%edx
    1e07:	0f b6 d2             	movzbl %dl,%edx
    1e0a:	29 c2                	sub    %eax,%edx
    1e0c:	89 d0                	mov    %edx,%eax
    1e0e:	89 c2                	mov    %eax,%edx
    1e10:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e13:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    1e16:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e19:	0f b6 00             	movzbl (%eax),%eax
    1e1c:	0f b6 d0             	movzbl %al,%edx
    1e1f:	8b 45 24             	mov    0x24(%ebp),%eax
    1e22:	01 d0                	add    %edx,%eax
    1e24:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1e2a:	89 d0                	mov    %edx,%eax
    1e2c:	c1 f8 1f             	sar    $0x1f,%eax
    1e2f:	c1 e8 18             	shr    $0x18,%eax
    1e32:	01 c2                	add    %eax,%edx
    1e34:	0f b6 d2             	movzbl %dl,%edx
    1e37:	29 c2                	sub    %eax,%edx
    1e39:	89 d0                	mov    %edx,%eax
    1e3b:	89 c2                	mov    %eax,%edx
    1e3d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e40:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1e42:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1e46:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e49:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1e4c:	0f 8c 14 ff ff ff    	jl     1d66 <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1e52:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1e56:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e59:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1e5c:	0f 8c f8 fe ff ff    	jl     1d5a <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    1e62:	90                   	nop
    1e63:	c9                   	leave  
    1e64:	c3                   	ret    

00001e65 <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    1e65:	55                   	push   %ebp
    1e66:	89 e5                	mov    %esp,%ebp
    1e68:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1e6b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1e72:	e9 fb 00 00 00       	jmp    1f72 <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    1e77:	8b 55 14             	mov    0x14(%ebp),%edx
    1e7a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1e7d:	01 c2                	add    %eax,%edx
    1e7f:	0f b7 05 16 e5 01 00 	movzwl 0x1e516,%eax
    1e86:	0f b7 c0             	movzwl %ax,%eax
    1e89:	39 c2                	cmp    %eax,%edx
    1e8b:	0f 8f eb 00 00 00    	jg     1f7c <drawMouse+0x117>
    1e91:	8b 55 14             	mov    0x14(%ebp),%edx
    1e94:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1e97:	01 d0                	add    %edx,%eax
    1e99:	85 c0                	test   %eax,%eax
    1e9b:	0f 88 db 00 00 00    	js     1f7c <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1ea1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1ea8:	e9 b7 00 00 00       	jmp    1f64 <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    1ead:	8b 55 10             	mov    0x10(%ebp),%edx
    1eb0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1eb3:	01 c2                	add    %eax,%edx
    1eb5:	0f b7 05 14 e5 01 00 	movzwl 0x1e514,%eax
    1ebc:	0f b7 c0             	movzwl %ax,%eax
    1ebf:	39 c2                	cmp    %eax,%edx
    1ec1:	0f 8f a7 00 00 00    	jg     1f6e <drawMouse+0x109>
    1ec7:	8b 55 10             	mov    0x10(%ebp),%edx
    1eca:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1ecd:	01 d0                	add    %edx,%eax
    1ecf:	85 c0                	test   %eax,%eax
    1ed1:	0f 88 97 00 00 00    	js     1f6e <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    1ed7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1eda:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1edd:	89 d0                	mov    %edx,%eax
    1edf:	c1 e0 04             	shl    $0x4,%eax
    1ee2:	29 d0                	sub    %edx,%eax
    1ee4:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    1eea:	01 c2                	add    %eax,%edx
    1eec:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1eef:	01 d0                	add    %edx,%eax
    1ef1:	05 40 5e 01 00       	add    $0x15e40,%eax
    1ef6:	0f b6 00             	movzbl (%eax),%eax
    1ef9:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    1efc:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    1f00:	74 5e                	je     1f60 <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    1f02:	8b 55 14             	mov    0x14(%ebp),%edx
    1f05:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1f08:	01 c2                	add    %eax,%edx
    1f0a:	0f b7 05 14 e5 01 00 	movzwl 0x1e514,%eax
    1f11:	0f b7 c0             	movzwl %ax,%eax
    1f14:	0f af c2             	imul   %edx,%eax
    1f17:	89 c2                	mov    %eax,%edx
    1f19:	8b 45 10             	mov    0x10(%ebp),%eax
    1f1c:	01 c2                	add    %eax,%edx
    1f1e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1f21:	01 c2                	add    %eax,%edx
    1f23:	89 d0                	mov    %edx,%eax
    1f25:	01 c0                	add    %eax,%eax
    1f27:	01 c2                	add    %eax,%edx
    1f29:	8b 45 08             	mov    0x8(%ebp),%eax
    1f2c:	01 d0                	add    %edx,%eax
    1f2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    1f31:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    1f35:	8d 50 ff             	lea    -0x1(%eax),%edx
    1f38:	89 d0                	mov    %edx,%eax
    1f3a:	01 c0                	add    %eax,%eax
    1f3c:	01 d0                	add    %edx,%eax
    1f3e:	05 1c e5 01 00       	add    $0x1e51c,%eax
    1f43:	83 ec 04             	sub    $0x4,%esp
    1f46:	89 e2                	mov    %esp,%edx
    1f48:	0f b7 08             	movzwl (%eax),%ecx
    1f4b:	66 89 0a             	mov    %cx,(%edx)
    1f4e:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1f52:	88 42 02             	mov    %al,0x2(%edx)
    1f55:	ff 75 f0             	pushl  -0x10(%ebp)
    1f58:	e8 73 f6 ff ff       	call   15d0 <drawPoint>
    1f5d:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1f60:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    1f64:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    1f68:	0f 8e 3f ff ff ff    	jle    1ead <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1f6e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    1f72:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    1f76:	0f 8e fb fe ff ff    	jle    1e77 <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    1f7c:	90                   	nop
    1f7d:	c9                   	leave  
    1f7e:	c3                   	ret    

00001f7f <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    1f7f:	55                   	push   %ebp
    1f80:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    1f82:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1f86:	78 1b                	js     1fa3 <getColor+0x24>
    1f88:	8b 45 08             	mov    0x8(%ebp),%eax
    1f8b:	8b 40 04             	mov    0x4(%eax),%eax
    1f8e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    1f91:	7c 10                	jl     1fa3 <getColor+0x24>
    1f93:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    1f97:	78 0a                	js     1fa3 <getColor+0x24>
    1f99:	8b 45 08             	mov    0x8(%ebp),%eax
    1f9c:	8b 00                	mov    (%eax),%eax
    1f9e:	3b 45 10             	cmp    0x10(%ebp),%eax
    1fa1:	7d 10                	jge    1fb3 <getColor+0x34>
    {
        *isInPic = 1;
    1fa3:	8b 45 14             	mov    0x14(%ebp),%eax
    1fa6:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    1fac:	b8 d1 e0 01 00       	mov    $0x1e0d1,%eax
    1fb1:	eb 44                	jmp    1ff7 <getColor+0x78>
    }

    if (y == pic->height)
    1fb3:	8b 45 08             	mov    0x8(%ebp),%eax
    1fb6:	8b 40 04             	mov    0x4(%eax),%eax
    1fb9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    1fbc:	75 04                	jne    1fc2 <getColor+0x43>
        y--;
    1fbe:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    1fc2:	8b 45 08             	mov    0x8(%ebp),%eax
    1fc5:	8b 00                	mov    (%eax),%eax
    1fc7:	3b 45 10             	cmp    0x10(%ebp),%eax
    1fca:	75 04                	jne    1fd0 <getColor+0x51>
        x--;
    1fcc:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    1fd0:	8b 45 14             	mov    0x14(%ebp),%eax
    1fd3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    1fd9:	8b 45 08             	mov    0x8(%ebp),%eax
    1fdc:	8b 48 08             	mov    0x8(%eax),%ecx
    1fdf:	8b 45 08             	mov    0x8(%ebp),%eax
    1fe2:	8b 00                	mov    (%eax),%eax
    1fe4:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1fe8:	89 c2                	mov    %eax,%edx
    1fea:	8b 45 10             	mov    0x10(%ebp),%eax
    1fed:	01 c2                	add    %eax,%edx
    1fef:	89 d0                	mov    %edx,%eax
    1ff1:	01 c0                	add    %eax,%eax
    1ff3:	01 d0                	add    %edx,%eax
    1ff5:	01 c8                	add    %ecx,%eax
}
    1ff7:	5d                   	pop    %ebp
    1ff8:	c3                   	ret    

00001ff9 <setColor>:

int setColor(RGB *src, RGB *dst)
{
    1ff9:	55                   	push   %ebp
    1ffa:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    1ffc:	8b 45 08             	mov    0x8(%ebp),%eax
    1fff:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    2003:	8b 45 0c             	mov    0xc(%ebp),%eax
    2006:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    2009:	8b 45 08             	mov    0x8(%ebp),%eax
    200c:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    2010:	8b 45 0c             	mov    0xc(%ebp),%eax
    2013:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    2016:	8b 45 08             	mov    0x8(%ebp),%eax
    2019:	0f b6 10             	movzbl (%eax),%edx
    201c:	8b 45 0c             	mov    0xc(%ebp),%eax
    201f:	88 10                	mov    %dl,(%eax)

    return 1;
    2021:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2026:	5d                   	pop    %ebp
    2027:	c3                   	ret    

00002028 <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    2028:	55                   	push   %ebp
    2029:	89 e5                	mov    %esp,%ebp
    202b:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    202e:	d9 45 10             	flds   0x10(%ebp)
    2031:	d9 7d be             	fnstcw -0x42(%ebp)
    2034:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    2038:	b4 0c                	mov    $0xc,%ah
    203a:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    203e:	d9 6d bc             	fldcw  -0x44(%ebp)
    2041:	db 5d fc             	fistpl -0x4(%ebp)
    2044:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    2047:	d9 45 0c             	flds   0xc(%ebp)
    204a:	d9 6d bc             	fldcw  -0x44(%ebp)
    204d:	db 5d f8             	fistpl -0x8(%ebp)
    2050:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    2053:	db 45 fc             	fildl  -0x4(%ebp)
    2056:	d9 45 10             	flds   0x10(%ebp)
    2059:	d9 c9                	fxch   %st(1)
    205b:	df e9                	fucomip %st(1),%st
    205d:	dd d8                	fstp   %st(0)
    205f:	76 04                	jbe    2065 <mixColor+0x3d>
        x--;
    2061:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    2065:	db 45 f8             	fildl  -0x8(%ebp)
    2068:	d9 45 0c             	flds   0xc(%ebp)
    206b:	d9 c9                	fxch   %st(1)
    206d:	df e9                	fucomip %st(1),%st
    206f:	dd d8                	fstp   %st(0)
    2071:	76 04                	jbe    2077 <mixColor+0x4f>
        y--;
    2073:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2077:	8d 45 c0             	lea    -0x40(%ebp),%eax
    207a:	50                   	push   %eax
    207b:	ff 75 fc             	pushl  -0x4(%ebp)
    207e:	ff 75 f8             	pushl  -0x8(%ebp)
    2081:	ff 75 08             	pushl  0x8(%ebp)
    2084:	e8 f6 fe ff ff       	call   1f7f <getColor>
    2089:	83 c4 10             	add    $0x10,%esp
    208c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    208f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2092:	83 c0 01             	add    $0x1,%eax
    2095:	8d 55 c0             	lea    -0x40(%ebp),%edx
    2098:	83 c2 04             	add    $0x4,%edx
    209b:	52                   	push   %edx
    209c:	ff 75 fc             	pushl  -0x4(%ebp)
    209f:	50                   	push   %eax
    20a0:	ff 75 08             	pushl  0x8(%ebp)
    20a3:	e8 d7 fe ff ff       	call   1f7f <getColor>
    20a8:	83 c4 10             	add    $0x10,%esp
    20ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    20ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
    20b1:	83 c0 01             	add    $0x1,%eax
    20b4:	8d 55 c0             	lea    -0x40(%ebp),%edx
    20b7:	83 c2 08             	add    $0x8,%edx
    20ba:	52                   	push   %edx
    20bb:	50                   	push   %eax
    20bc:	ff 75 f8             	pushl  -0x8(%ebp)
    20bf:	ff 75 08             	pushl  0x8(%ebp)
    20c2:	e8 b8 fe ff ff       	call   1f7f <getColor>
    20c7:	83 c4 10             	add    $0x10,%esp
    20ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    20cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    20d0:	8d 50 01             	lea    0x1(%eax),%edx
    20d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    20d6:	83 c0 01             	add    $0x1,%eax
    20d9:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    20dc:	83 c1 0c             	add    $0xc,%ecx
    20df:	51                   	push   %ecx
    20e0:	52                   	push   %edx
    20e1:	50                   	push   %eax
    20e2:	ff 75 08             	pushl  0x8(%ebp)
    20e5:	e8 95 fe ff ff       	call   1f7f <getColor>
    20ea:	83 c4 10             	add    $0x10,%esp
    20ed:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    20f0:	db 45 fc             	fildl  -0x4(%ebp)
    20f3:	d9 45 10             	flds   0x10(%ebp)
    20f6:	de e1                	fsubp  %st,%st(1)
    20f8:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    20fb:	db 45 f8             	fildl  -0x8(%ebp)
    20fe:	d9 45 0c             	flds   0xc(%ebp)
    2101:	de e1                	fsubp  %st,%st(1)
    2103:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    2106:	d9 45 e4             	flds   -0x1c(%ebp)
    2109:	d8 4d e0             	fmuls  -0x20(%ebp)
    210c:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    210f:	d9 e8                	fld1   
    2111:	d8 65 e0             	fsubs  -0x20(%ebp)
    2114:	d8 4d e4             	fmuls  -0x1c(%ebp)
    2117:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    211a:	d9 e8                	fld1   
    211c:	d8 65 e4             	fsubs  -0x1c(%ebp)
    211f:	d8 4d e0             	fmuls  -0x20(%ebp)
    2122:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    2125:	d9 e8                	fld1   
    2127:	d8 65 e4             	fsubs  -0x1c(%ebp)
    212a:	d9 e8                	fld1   
    212c:	d8 65 e0             	fsubs  -0x20(%ebp)
    212f:	de c9                	fmulp  %st,%st(1)
    2131:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    2134:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2137:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    213b:	0f b6 c0             	movzbl %al,%eax
    213e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2141:	db 45 b4             	fildl  -0x4c(%ebp)
    2144:	d8 4d d0             	fmuls  -0x30(%ebp)
    2147:	8b 45 c0             	mov    -0x40(%ebp),%eax
    214a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    214d:	db 45 b4             	fildl  -0x4c(%ebp)
    2150:	de c9                	fmulp  %st,%st(1)
    2152:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2155:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2159:	0f b6 c0             	movzbl %al,%eax
    215c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    215f:	db 45 b4             	fildl  -0x4c(%ebp)
    2162:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2165:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2168:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    216b:	db 45 b4             	fildl  -0x4c(%ebp)
    216e:	de c9                	fmulp  %st,%st(1)
    2170:	de c1                	faddp  %st,%st(1)
    2172:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2175:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2179:	0f b6 c0             	movzbl %al,%eax
    217c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    217f:	db 45 b4             	fildl  -0x4c(%ebp)
    2182:	d8 4d d8             	fmuls  -0x28(%ebp)
    2185:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2188:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    218b:	db 45 b4             	fildl  -0x4c(%ebp)
    218e:	de c9                	fmulp  %st,%st(1)
    2190:	de c1                	faddp  %st,%st(1)
    2192:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2195:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2199:	0f b6 c0             	movzbl %al,%eax
    219c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    219f:	db 45 b4             	fildl  -0x4c(%ebp)
    21a2:	d8 4d dc             	fmuls  -0x24(%ebp)
    21a5:	8b 45 cc             	mov    -0x34(%ebp),%eax
    21a8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21ab:	db 45 b4             	fildl  -0x4c(%ebp)
    21ae:	de c9                	fmulp  %st,%st(1)
    21b0:	de c1                	faddp  %st,%st(1)
    21b2:	d9 7d be             	fnstcw -0x42(%ebp)
    21b5:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    21b9:	b4 0c                	mov    $0xc,%ah
    21bb:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    21bf:	d9 6d bc             	fldcw  -0x44(%ebp)
    21c2:	db 5d b8             	fistpl -0x48(%ebp)
    21c5:	d9 6d be             	fldcw  -0x42(%ebp)
    21c8:	8b 45 b8             	mov    -0x48(%ebp),%eax
    21cb:	89 c2                	mov    %eax,%edx
    21cd:	8b 45 14             	mov    0x14(%ebp),%eax
    21d0:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    21d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    21d6:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    21da:	0f b6 c0             	movzbl %al,%eax
    21dd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21e0:	db 45 b4             	fildl  -0x4c(%ebp)
    21e3:	d8 4d d0             	fmuls  -0x30(%ebp)
    21e6:	8b 45 c0             	mov    -0x40(%ebp),%eax
    21e9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21ec:	db 45 b4             	fildl  -0x4c(%ebp)
    21ef:	de c9                	fmulp  %st,%st(1)
    21f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    21f4:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    21f8:	0f b6 c0             	movzbl %al,%eax
    21fb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21fe:	db 45 b4             	fildl  -0x4c(%ebp)
    2201:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2204:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2207:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    220a:	db 45 b4             	fildl  -0x4c(%ebp)
    220d:	de c9                	fmulp  %st,%st(1)
    220f:	de c1                	faddp  %st,%st(1)
    2211:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2214:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2218:	0f b6 c0             	movzbl %al,%eax
    221b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    221e:	db 45 b4             	fildl  -0x4c(%ebp)
    2221:	d8 4d d8             	fmuls  -0x28(%ebp)
    2224:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2227:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    222a:	db 45 b4             	fildl  -0x4c(%ebp)
    222d:	de c9                	fmulp  %st,%st(1)
    222f:	de c1                	faddp  %st,%st(1)
    2231:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2234:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2238:	0f b6 c0             	movzbl %al,%eax
    223b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    223e:	db 45 b4             	fildl  -0x4c(%ebp)
    2241:	d8 4d dc             	fmuls  -0x24(%ebp)
    2244:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2247:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    224a:	db 45 b4             	fildl  -0x4c(%ebp)
    224d:	de c9                	fmulp  %st,%st(1)
    224f:	de c1                	faddp  %st,%st(1)
    2251:	d9 6d bc             	fldcw  -0x44(%ebp)
    2254:	db 5d b8             	fistpl -0x48(%ebp)
    2257:	d9 6d be             	fldcw  -0x42(%ebp)
    225a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    225d:	89 c2                	mov    %eax,%edx
    225f:	8b 45 14             	mov    0x14(%ebp),%eax
    2262:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    2265:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2268:	0f b6 00             	movzbl (%eax),%eax
    226b:	0f b6 c0             	movzbl %al,%eax
    226e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2271:	db 45 b4             	fildl  -0x4c(%ebp)
    2274:	d8 4d d0             	fmuls  -0x30(%ebp)
    2277:	8b 45 c0             	mov    -0x40(%ebp),%eax
    227a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    227d:	db 45 b4             	fildl  -0x4c(%ebp)
    2280:	de c9                	fmulp  %st,%st(1)
    2282:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2285:	0f b6 00             	movzbl (%eax),%eax
    2288:	0f b6 c0             	movzbl %al,%eax
    228b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    228e:	db 45 b4             	fildl  -0x4c(%ebp)
    2291:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2294:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2297:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    229a:	db 45 b4             	fildl  -0x4c(%ebp)
    229d:	de c9                	fmulp  %st,%st(1)
    229f:	de c1                	faddp  %st,%st(1)
    22a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    22a4:	0f b6 00             	movzbl (%eax),%eax
    22a7:	0f b6 c0             	movzbl %al,%eax
    22aa:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22ad:	db 45 b4             	fildl  -0x4c(%ebp)
    22b0:	d8 4d d8             	fmuls  -0x28(%ebp)
    22b3:	8b 45 c8             	mov    -0x38(%ebp),%eax
    22b6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22b9:	db 45 b4             	fildl  -0x4c(%ebp)
    22bc:	de c9                	fmulp  %st,%st(1)
    22be:	de c1                	faddp  %st,%st(1)
    22c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    22c3:	0f b6 00             	movzbl (%eax),%eax
    22c6:	0f b6 c0             	movzbl %al,%eax
    22c9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22cc:	db 45 b4             	fildl  -0x4c(%ebp)
    22cf:	d8 4d dc             	fmuls  -0x24(%ebp)
    22d2:	8b 45 cc             	mov    -0x34(%ebp),%eax
    22d5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22d8:	db 45 b4             	fildl  -0x4c(%ebp)
    22db:	de c9                	fmulp  %st,%st(1)
    22dd:	de c1                	faddp  %st,%st(1)
    22df:	d9 6d bc             	fldcw  -0x44(%ebp)
    22e2:	db 5d b8             	fistpl -0x48(%ebp)
    22e5:	d9 6d be             	fldcw  -0x42(%ebp)
    22e8:	8b 45 b8             	mov    -0x48(%ebp),%eax
    22eb:	89 c2                	mov    %eax,%edx
    22ed:	8b 45 14             	mov    0x14(%ebp),%eax
    22f0:	88 10                	mov    %dl,(%eax)

    return 1;
    22f2:	b8 01 00 00 00       	mov    $0x1,%eax
}
    22f7:	c9                   	leave  
    22f8:	c3                   	ret    

000022f9 <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    22f9:	55                   	push   %ebp
    22fa:	89 e5                	mov    %esp,%ebp
    22fc:	53                   	push   %ebx
    22fd:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    2300:	8b 45 10             	mov    0x10(%ebp),%eax
    2303:	c1 f8 10             	sar    $0x10,%eax
    2306:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    2309:	8b 45 0c             	mov    0xc(%ebp),%eax
    230c:	c1 f8 10             	sar    $0x10,%eax
    230f:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2312:	8d 45 bc             	lea    -0x44(%ebp),%eax
    2315:	50                   	push   %eax
    2316:	ff 75 f8             	pushl  -0x8(%ebp)
    2319:	ff 75 f4             	pushl  -0xc(%ebp)
    231c:	ff 75 08             	pushl  0x8(%ebp)
    231f:	e8 5b fc ff ff       	call   1f7f <getColor>
    2324:	83 c4 10             	add    $0x10,%esp
    2327:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    232a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    232d:	83 c0 01             	add    $0x1,%eax
    2330:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2333:	83 c2 04             	add    $0x4,%edx
    2336:	52                   	push   %edx
    2337:	ff 75 f8             	pushl  -0x8(%ebp)
    233a:	50                   	push   %eax
    233b:	ff 75 08             	pushl  0x8(%ebp)
    233e:	e8 3c fc ff ff       	call   1f7f <getColor>
    2343:	83 c4 10             	add    $0x10,%esp
    2346:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    2349:	8b 45 f8             	mov    -0x8(%ebp),%eax
    234c:	83 c0 01             	add    $0x1,%eax
    234f:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2352:	83 c2 08             	add    $0x8,%edx
    2355:	52                   	push   %edx
    2356:	50                   	push   %eax
    2357:	ff 75 f4             	pushl  -0xc(%ebp)
    235a:	ff 75 08             	pushl  0x8(%ebp)
    235d:	e8 1d fc ff ff       	call   1f7f <getColor>
    2362:	83 c4 10             	add    $0x10,%esp
    2365:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    2368:	8b 45 f8             	mov    -0x8(%ebp),%eax
    236b:	8d 50 01             	lea    0x1(%eax),%edx
    236e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2371:	83 c0 01             	add    $0x1,%eax
    2374:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    2377:	83 c1 0c             	add    $0xc,%ecx
    237a:	51                   	push   %ecx
    237b:	52                   	push   %edx
    237c:	50                   	push   %eax
    237d:	ff 75 08             	pushl  0x8(%ebp)
    2380:	e8 fa fb ff ff       	call   1f7f <getColor>
    2385:	83 c4 10             	add    $0x10,%esp
    2388:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    238b:	8b 45 10             	mov    0x10(%ebp),%eax
    238e:	0f b7 c0             	movzwl %ax,%eax
    2391:	c1 f8 08             	sar    $0x8,%eax
    2394:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    2397:	8b 45 0c             	mov    0xc(%ebp),%eax
    239a:	0f b7 c0             	movzwl %ax,%eax
    239d:	c1 f8 08             	sar    $0x8,%eax
    23a0:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    23a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    23a6:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    23aa:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    23ad:	b8 ff 00 00 00       	mov    $0xff,%eax
    23b2:	2b 45 dc             	sub    -0x24(%ebp),%eax
    23b5:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    23b9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    23bc:	b8 ff 00 00 00       	mov    $0xff,%eax
    23c1:	2b 45 e0             	sub    -0x20(%ebp),%eax
    23c4:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    23c8:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    23cb:	b8 ff 00 00 00       	mov    $0xff,%eax
    23d0:	2b 45 e0             	sub    -0x20(%ebp),%eax
    23d3:	89 c2                	mov    %eax,%edx
    23d5:	b8 ff 00 00 00       	mov    $0xff,%eax
    23da:	2b 45 dc             	sub    -0x24(%ebp),%eax
    23dd:	0f af c2             	imul   %edx,%eax
    23e0:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    23e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    23e6:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    23ea:	0f b6 c0             	movzbl %al,%eax
    23ed:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    23f1:	8b 55 bc             	mov    -0x44(%ebp),%edx
    23f4:	0f af d0             	imul   %eax,%edx
    23f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    23fa:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    23fe:	0f b6 c0             	movzbl %al,%eax
    2401:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2405:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2408:	0f af c1             	imul   %ecx,%eax
    240b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    240e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2411:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2415:	0f b6 c0             	movzbl %al,%eax
    2418:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    241c:	8b 55 c8             	mov    -0x38(%ebp),%edx
    241f:	0f af d0             	imul   %eax,%edx
    2422:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2425:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2429:	0f b6 c0             	movzbl %al,%eax
    242c:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2430:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2433:	0f af c1             	imul   %ecx,%eax
    2436:	01 d0                	add    %edx,%eax
    2438:	01 d8                	add    %ebx,%eax
    243a:	c1 e8 10             	shr    $0x10,%eax
    243d:	89 c2                	mov    %eax,%edx
    243f:	8b 45 14             	mov    0x14(%ebp),%eax
    2442:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    2445:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2448:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    244c:	0f b6 c0             	movzbl %al,%eax
    244f:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2453:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2456:	0f af d0             	imul   %eax,%edx
    2459:	8b 45 ec             	mov    -0x14(%ebp),%eax
    245c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2460:	0f b6 c0             	movzbl %al,%eax
    2463:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2467:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    246a:	0f af c1             	imul   %ecx,%eax
    246d:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2470:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2473:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2477:	0f b6 c0             	movzbl %al,%eax
    247a:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    247e:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2481:	0f af d0             	imul   %eax,%edx
    2484:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2487:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    248b:	0f b6 c0             	movzbl %al,%eax
    248e:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2492:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2495:	0f af c1             	imul   %ecx,%eax
    2498:	01 d0                	add    %edx,%eax
    249a:	01 d8                	add    %ebx,%eax
    249c:	c1 e8 10             	shr    $0x10,%eax
    249f:	89 c2                	mov    %eax,%edx
    24a1:	8b 45 14             	mov    0x14(%ebp),%eax
    24a4:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    24a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    24aa:	0f b6 00             	movzbl (%eax),%eax
    24ad:	0f b6 c0             	movzbl %al,%eax
    24b0:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    24b4:	8b 55 bc             	mov    -0x44(%ebp),%edx
    24b7:	0f af d0             	imul   %eax,%edx
    24ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    24bd:	0f b6 00             	movzbl (%eax),%eax
    24c0:	0f b6 c0             	movzbl %al,%eax
    24c3:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    24c7:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    24ca:	0f af c1             	imul   %ecx,%eax
    24cd:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    24d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    24d3:	0f b6 00             	movzbl (%eax),%eax
    24d6:	0f b6 c0             	movzbl %al,%eax
    24d9:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    24dd:	8b 55 c8             	mov    -0x38(%ebp),%edx
    24e0:	0f af d0             	imul   %eax,%edx
    24e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    24e6:	0f b6 00             	movzbl (%eax),%eax
    24e9:	0f b6 c0             	movzbl %al,%eax
    24ec:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    24f0:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    24f3:	0f af c1             	imul   %ecx,%eax
    24f6:	01 d0                	add    %edx,%eax
    24f8:	01 d8                	add    %ebx,%eax
    24fa:	c1 e8 10             	shr    $0x10,%eax
    24fd:	89 c2                	mov    %eax,%edx
    24ff:	8b 45 14             	mov    0x14(%ebp),%eax
    2502:	88 10                	mov    %dl,(%eax)
}
    2504:	90                   	nop
    2505:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2508:	c9                   	leave  
    2509:	c3                   	ret    

0000250a <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    250a:	55                   	push   %ebp
    250b:	89 e5                	mov    %esp,%ebp
    250d:	53                   	push   %ebx
    250e:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    2511:	8b 45 08             	mov    0x8(%ebp),%eax
    2514:	8b 00                	mov    (%eax),%eax
    2516:	c1 e0 10             	shl    $0x10,%eax
    2519:	89 c1                	mov    %eax,%ecx
    251b:	8b 45 0c             	mov    0xc(%ebp),%eax
    251e:	8b 18                	mov    (%eax),%ebx
    2520:	89 c8                	mov    %ecx,%eax
    2522:	99                   	cltd   
    2523:	f7 fb                	idiv   %ebx
    2525:	83 c0 01             	add    $0x1,%eax
    2528:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    252b:	8b 45 08             	mov    0x8(%ebp),%eax
    252e:	8b 40 04             	mov    0x4(%eax),%eax
    2531:	c1 e0 10             	shl    $0x10,%eax
    2534:	89 c1                	mov    %eax,%ecx
    2536:	8b 45 0c             	mov    0xc(%ebp),%eax
    2539:	8b 58 04             	mov    0x4(%eax),%ebx
    253c:	89 c8                	mov    %ecx,%eax
    253e:	99                   	cltd   
    253f:	f7 fb                	idiv   %ebx
    2541:	83 c0 01             	add    $0x1,%eax
    2544:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    2547:	8b 45 e8             	mov    -0x18(%ebp),%eax
    254a:	d1 f8                	sar    %eax
    254c:	2d 00 80 00 00       	sub    $0x8000,%eax
    2551:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    2554:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2557:	d1 f8                	sar    %eax
    2559:	2d 00 80 00 00       	sub    $0x8000,%eax
    255e:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    2561:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2564:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    2567:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    256e:	eb 5d                	jmp    25cd <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    2570:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2573:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    2576:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    257d:	eb 3a                	jmp    25b9 <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    257f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2582:	8b 48 08             	mov    0x8(%eax),%ecx
    2585:	8b 45 0c             	mov    0xc(%ebp),%eax
    2588:	8b 00                	mov    (%eax),%eax
    258a:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    258e:	89 c2                	mov    %eax,%edx
    2590:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2593:	01 c2                	add    %eax,%edx
    2595:	89 d0                	mov    %edx,%eax
    2597:	01 c0                	add    %eax,%eax
    2599:	01 d0                	add    %edx,%eax
    259b:	01 c8                	add    %ecx,%eax
    259d:	50                   	push   %eax
    259e:	ff 75 f0             	pushl  -0x10(%ebp)
    25a1:	ff 75 f8             	pushl  -0x8(%ebp)
    25a4:	ff 75 08             	pushl  0x8(%ebp)
    25a7:	e8 4d fd ff ff       	call   22f9 <mixColorInt>
    25ac:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    25af:	8b 45 e8             	mov    -0x18(%ebp),%eax
    25b2:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    25b5:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    25b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    25bc:	8b 00                	mov    (%eax),%eax
    25be:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    25c1:	7f bc                	jg     257f <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    25c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    25c6:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    25c9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    25cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    25d0:	8b 40 04             	mov    0x4(%eax),%eax
    25d3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    25d6:	7f 98                	jg     2570 <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    25d8:	b8 01 00 00 00       	mov    $0x1,%eax
}
    25dd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    25e0:	c9                   	leave  
    25e1:	c3                   	ret    

000025e2 <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    25e2:	55                   	push   %ebp
    25e3:	89 e5                	mov    %esp,%ebp
    25e5:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    25e8:	8b 45 08             	mov    0x8(%ebp),%eax
    25eb:	8b 00                	mov    (%eax),%eax
    25ed:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    25f0:	db 45 e4             	fildl  -0x1c(%ebp)
    25f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    25f6:	8b 00                	mov    (%eax),%eax
    25f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    25fb:	db 45 e4             	fildl  -0x1c(%ebp)
    25fe:	de f9                	fdivrp %st,%st(1)
    2600:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    2603:	8b 45 08             	mov    0x8(%ebp),%eax
    2606:	8b 40 04             	mov    0x4(%eax),%eax
    2609:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    260c:	db 45 e4             	fildl  -0x1c(%ebp)
    260f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2612:	8b 40 04             	mov    0x4(%eax),%eax
    2615:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2618:	db 45 e4             	fildl  -0x1c(%ebp)
    261b:	de f9                	fdivrp %st,%st(1)
    261d:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    2620:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    2627:	eb 5e                	jmp    2687 <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    2629:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2630:	eb 47                	jmp    2679 <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    2632:	db 45 f8             	fildl  -0x8(%ebp)
    2635:	d8 4d f4             	fmuls  -0xc(%ebp)
    2638:	d9 7d ee             	fnstcw -0x12(%ebp)
    263b:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    263f:	b4 0c                	mov    $0xc,%ah
    2641:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    2645:	d9 6d ec             	fldcw  -0x14(%ebp)
    2648:	db 5d e8             	fistpl -0x18(%ebp)
    264b:	d9 6d ee             	fldcw  -0x12(%ebp)
    264e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2651:	db 45 fc             	fildl  -0x4(%ebp)
    2654:	d8 4d f0             	fmuls  -0x10(%ebp)
    2657:	d9 6d ec             	fldcw  -0x14(%ebp)
    265a:	db 5d e8             	fistpl -0x18(%ebp)
    265d:	d9 6d ee             	fldcw  -0x12(%ebp)
    2660:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2663:	6a 00                	push   $0x0
    2665:	52                   	push   %edx
    2666:	50                   	push   %eax
    2667:	ff 75 08             	pushl  0x8(%ebp)
    266a:	e8 10 f9 ff ff       	call   1f7f <getColor>
    266f:	83 c4 10             	add    $0x10,%esp
    2672:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    2675:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2679:	8b 45 0c             	mov    0xc(%ebp),%eax
    267c:	8b 00                	mov    (%eax),%eax
    267e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2681:	7f af                	jg     2632 <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    2683:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2687:	8b 45 0c             	mov    0xc(%ebp),%eax
    268a:	8b 40 04             	mov    0x4(%eax),%eax
    268d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2690:	7f 97                	jg     2629 <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    2692:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2697:	c9                   	leave  
    2698:	c3                   	ret    

00002699 <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    2699:	55                   	push   %ebp
    269a:	89 e5                	mov    %esp,%ebp
    269c:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    269f:	8b 45 08             	mov    0x8(%ebp),%eax
    26a2:	8b 00                	mov    (%eax),%eax
    26a4:	89 45 e0             	mov    %eax,-0x20(%ebp)
    26a7:	db 45 e0             	fildl  -0x20(%ebp)
    26aa:	d9 5d e0             	fstps  -0x20(%ebp)
    26ad:	83 ec 0c             	sub    $0xc,%esp
    26b0:	ff 75 10             	pushl  0x10(%ebp)
    26b3:	e8 6b e2 ff ff       	call   923 <cos>
    26b8:	83 c4 10             	add    $0x10,%esp
    26bb:	d9 5d dc             	fstps  -0x24(%ebp)
    26be:	8b 45 dc             	mov    -0x24(%ebp),%eax
    26c1:	83 ec 0c             	sub    $0xc,%esp
    26c4:	50                   	push   %eax
    26c5:	e8 90 e1 ff ff       	call   85a <abs>
    26ca:	83 c4 10             	add    $0x10,%esp
    26cd:	d8 4d e0             	fmuls  -0x20(%ebp)
    26d0:	d9 5d e0             	fstps  -0x20(%ebp)
    26d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    26d6:	8b 00                	mov    (%eax),%eax
    26d8:	89 45 dc             	mov    %eax,-0x24(%ebp)
    26db:	db 45 dc             	fildl  -0x24(%ebp)
    26de:	d9 5d dc             	fstps  -0x24(%ebp)
    26e1:	83 ec 0c             	sub    $0xc,%esp
    26e4:	ff 75 10             	pushl  0x10(%ebp)
    26e7:	e8 da e3 ff ff       	call   ac6 <sin>
    26ec:	83 c4 10             	add    $0x10,%esp
    26ef:	d9 5d d8             	fstps  -0x28(%ebp)
    26f2:	8b 45 d8             	mov    -0x28(%ebp),%eax
    26f5:	83 ec 0c             	sub    $0xc,%esp
    26f8:	50                   	push   %eax
    26f9:	e8 5c e1 ff ff       	call   85a <abs>
    26fe:	83 c4 10             	add    $0x10,%esp
    2701:	d8 4d dc             	fmuls  -0x24(%ebp)
    2704:	d8 45 e0             	fadds  -0x20(%ebp)
    2707:	d9 7d e6             	fnstcw -0x1a(%ebp)
    270a:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    270e:	b4 0c                	mov    $0xc,%ah
    2710:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2714:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2717:	db 5d f4             	fistpl -0xc(%ebp)
    271a:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    271d:	8b 45 08             	mov    0x8(%ebp),%eax
    2720:	8b 00                	mov    (%eax),%eax
    2722:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2725:	db 45 e0             	fildl  -0x20(%ebp)
    2728:	d9 5d e0             	fstps  -0x20(%ebp)
    272b:	83 ec 0c             	sub    $0xc,%esp
    272e:	ff 75 10             	pushl  0x10(%ebp)
    2731:	e8 90 e3 ff ff       	call   ac6 <sin>
    2736:	83 c4 10             	add    $0x10,%esp
    2739:	d9 5d dc             	fstps  -0x24(%ebp)
    273c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    273f:	83 ec 0c             	sub    $0xc,%esp
    2742:	50                   	push   %eax
    2743:	e8 12 e1 ff ff       	call   85a <abs>
    2748:	83 c4 10             	add    $0x10,%esp
    274b:	d8 4d e0             	fmuls  -0x20(%ebp)
    274e:	d9 5d e0             	fstps  -0x20(%ebp)
    2751:	8b 45 0c             	mov    0xc(%ebp),%eax
    2754:	8b 00                	mov    (%eax),%eax
    2756:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2759:	db 45 dc             	fildl  -0x24(%ebp)
    275c:	d9 5d dc             	fstps  -0x24(%ebp)
    275f:	83 ec 0c             	sub    $0xc,%esp
    2762:	ff 75 10             	pushl  0x10(%ebp)
    2765:	e8 b9 e1 ff ff       	call   923 <cos>
    276a:	83 c4 10             	add    $0x10,%esp
    276d:	d9 5d d8             	fstps  -0x28(%ebp)
    2770:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2773:	83 ec 0c             	sub    $0xc,%esp
    2776:	50                   	push   %eax
    2777:	e8 de e0 ff ff       	call   85a <abs>
    277c:	83 c4 10             	add    $0x10,%esp
    277f:	d8 4d dc             	fmuls  -0x24(%ebp)
    2782:	d8 45 e0             	fadds  -0x20(%ebp)
    2785:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2788:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    278c:	b4 0c                	mov    $0xc,%ah
    278e:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2792:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2795:	db 5d f0             	fistpl -0x10(%ebp)
    2798:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    279b:	8b 45 0c             	mov    0xc(%ebp),%eax
    279e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    27a1:	89 10                	mov    %edx,(%eax)
    *width = w;
    27a3:	8b 45 08             	mov    0x8(%ebp),%eax
    27a6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    27a9:	89 10                	mov    %edx,(%eax)
    return 1;
    27ab:	b8 01 00 00 00       	mov    $0x1,%eax
}
    27b0:	c9                   	leave  
    27b1:	c3                   	ret    

000027b2 <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    27b2:	55                   	push   %ebp
    27b3:	89 e5                	mov    %esp,%ebp
    27b5:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    27b8:	8b 45 08             	mov    0x8(%ebp),%eax
    27bb:	8b 40 04             	mov    0x4(%eax),%eax
    27be:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    27c1:	db 45 c4             	fildl  -0x3c(%ebp)
    27c4:	d9 05 84 9c 01 00    	flds   0x19c84
    27ca:	de f9                	fdivrp %st,%st(1)
    27cc:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    27cf:	8b 45 08             	mov    0x8(%ebp),%eax
    27d2:	8b 00                	mov    (%eax),%eax
    27d4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    27d7:	db 45 c4             	fildl  -0x3c(%ebp)
    27da:	d9 05 84 9c 01 00    	flds   0x19c84
    27e0:	de f9                	fdivrp %st,%st(1)
    27e2:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    27e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    27e8:	8b 50 04             	mov    0x4(%eax),%edx
    27eb:	8b 45 08             	mov    0x8(%ebp),%eax
    27ee:	8b 40 04             	mov    0x4(%eax),%eax
    27f1:	29 c2                	sub    %eax,%edx
    27f3:	89 d0                	mov    %edx,%eax
    27f5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    27f8:	db 45 c4             	fildl  -0x3c(%ebp)
    27fb:	d9 05 84 9c 01 00    	flds   0x19c84
    2801:	de f9                	fdivrp %st,%st(1)
    2803:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    2806:	8b 45 0c             	mov    0xc(%ebp),%eax
    2809:	8b 10                	mov    (%eax),%edx
    280b:	8b 45 08             	mov    0x8(%ebp),%eax
    280e:	8b 00                	mov    (%eax),%eax
    2810:	29 c2                	sub    %eax,%edx
    2812:	89 d0                	mov    %edx,%eax
    2814:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2817:	db 45 c4             	fildl  -0x3c(%ebp)
    281a:	d9 05 84 9c 01 00    	flds   0x19c84
    2820:	de f9                	fdivrp %st,%st(1)
    2822:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    2825:	d9 45 10             	flds   0x10(%ebp)
    2828:	d9 e0                	fchs   
    282a:	83 ec 0c             	sub    $0xc,%esp
    282d:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2831:	d9 1c 24             	fstps  (%esp)
    2834:	e8 ea e0 ff ff       	call   923 <cos>
    2839:	83 c4 10             	add    $0x10,%esp
    283c:	d9 5d c4             	fstps  -0x3c(%ebp)
    283f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2842:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    2845:	d9 45 10             	flds   0x10(%ebp)
    2848:	d9 e0                	fchs   
    284a:	83 ec 0c             	sub    $0xc,%esp
    284d:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2851:	d9 1c 24             	fstps  (%esp)
    2854:	e8 6d e2 ff ff       	call   ac6 <sin>
    2859:	83 c4 10             	add    $0x10,%esp
    285c:	d9 5d c4             	fstps  -0x3c(%ebp)
    285f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2862:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    2865:	d9 ee                	fldz   
    2867:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    286a:	d9 ee                	fldz   
    286c:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    286f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2876:	e9 28 01 00 00       	jmp    29a3 <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    287b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2882:	e9 0a 01 00 00       	jmp    2991 <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    2887:	db 45 f4             	fildl  -0xc(%ebp)
    288a:	d8 65 e4             	fsubs  -0x1c(%ebp)
    288d:	d8 65 ec             	fsubs  -0x14(%ebp)
    2890:	d8 4d dc             	fmuls  -0x24(%ebp)
    2893:	db 45 f0             	fildl  -0x10(%ebp)
    2896:	d8 65 e0             	fsubs  -0x20(%ebp)
    2899:	d8 65 e8             	fsubs  -0x18(%ebp)
    289c:	d8 4d d8             	fmuls  -0x28(%ebp)
    289f:	de c1                	faddp  %st,%st(1)
    28a1:	d8 45 ec             	fadds  -0x14(%ebp)
    28a4:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    28a7:	db 45 f0             	fildl  -0x10(%ebp)
    28aa:	d8 65 e0             	fsubs  -0x20(%ebp)
    28ad:	d8 65 e8             	fsubs  -0x18(%ebp)
    28b0:	d8 4d dc             	fmuls  -0x24(%ebp)
    28b3:	db 45 f4             	fildl  -0xc(%ebp)
    28b6:	d8 65 e4             	fsubs  -0x1c(%ebp)
    28b9:	d8 65 ec             	fsubs  -0x14(%ebp)
    28bc:	d8 4d d8             	fmuls  -0x28(%ebp)
    28bf:	de e9                	fsubrp %st,%st(1)
    28c1:	d8 45 e8             	fadds  -0x18(%ebp)
    28c4:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    28c7:	d9 45 d4             	flds   -0x2c(%ebp)
    28ca:	d9 ee                	fldz   
    28cc:	d9 c9                	fxch   %st(1)
    28ce:	df e9                	fucomip %st(1),%st
    28d0:	dd d8                	fstp   %st(0)
    28d2:	0f 93 c0             	setae  %al
    28d5:	83 f0 01             	xor    $0x1,%eax
    28d8:	84 c0                	test   %al,%al
    28da:	75 52                	jne    292e <picTurn+0x17c>
    28dc:	8b 45 08             	mov    0x8(%ebp),%eax
    28df:	8b 40 04             	mov    0x4(%eax),%eax
    28e2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    28e5:	db 45 c4             	fildl  -0x3c(%ebp)
    28e8:	d9 45 d4             	flds   -0x2c(%ebp)
    28eb:	d9 c9                	fxch   %st(1)
    28ed:	df e9                	fucomip %st(1),%st
    28ef:	dd d8                	fstp   %st(0)
    28f1:	0f 97 c0             	seta   %al
    28f4:	83 f0 01             	xor    $0x1,%eax
    28f7:	84 c0                	test   %al,%al
    28f9:	75 33                	jne    292e <picTurn+0x17c>
    28fb:	d9 45 d0             	flds   -0x30(%ebp)
    28fe:	d9 ee                	fldz   
    2900:	d9 c9                	fxch   %st(1)
    2902:	df e9                	fucomip %st(1),%st
    2904:	dd d8                	fstp   %st(0)
    2906:	0f 93 c0             	setae  %al
    2909:	83 f0 01             	xor    $0x1,%eax
    290c:	84 c0                	test   %al,%al
    290e:	75 1e                	jne    292e <picTurn+0x17c>
    2910:	8b 45 08             	mov    0x8(%ebp),%eax
    2913:	8b 00                	mov    (%eax),%eax
    2915:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2918:	db 45 c4             	fildl  -0x3c(%ebp)
    291b:	d9 45 d0             	flds   -0x30(%ebp)
    291e:	d9 c9                	fxch   %st(1)
    2920:	df e9                	fucomip %st(1),%st
    2922:	dd d8                	fstp   %st(0)
    2924:	0f 97 c0             	seta   %al
    2927:	83 f0 01             	xor    $0x1,%eax
    292a:	84 c0                	test   %al,%al
    292c:	74 2f                	je     295d <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    292e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2931:	8b 48 08             	mov    0x8(%eax),%ecx
    2934:	8b 45 0c             	mov    0xc(%ebp),%eax
    2937:	8b 00                	mov    (%eax),%eax
    2939:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    293d:	89 c2                	mov    %eax,%edx
    293f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2942:	01 c2                	add    %eax,%edx
    2944:	89 d0                	mov    %edx,%eax
    2946:	01 c0                	add    %eax,%eax
    2948:	01 d0                	add    %edx,%eax
    294a:	01 c8                	add    %ecx,%eax
    294c:	83 ec 08             	sub    $0x8,%esp
    294f:	50                   	push   %eax
    2950:	68 d1 e0 01 00       	push   $0x1e0d1
    2955:	e8 9f f6 ff ff       	call   1ff9 <setColor>
    295a:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    295d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2960:	8b 48 08             	mov    0x8(%eax),%ecx
    2963:	8b 45 0c             	mov    0xc(%ebp),%eax
    2966:	8b 00                	mov    (%eax),%eax
    2968:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    296c:	89 c2                	mov    %eax,%edx
    296e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2971:	01 c2                	add    %eax,%edx
    2973:	89 d0                	mov    %edx,%eax
    2975:	01 c0                	add    %eax,%eax
    2977:	01 d0                	add    %edx,%eax
    2979:	01 c8                	add    %ecx,%eax
    297b:	50                   	push   %eax
    297c:	ff 75 d0             	pushl  -0x30(%ebp)
    297f:	ff 75 d4             	pushl  -0x2c(%ebp)
    2982:	ff 75 08             	pushl  0x8(%ebp)
    2985:	e8 9e f6 ff ff       	call   2028 <mixColor>
    298a:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    298d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2991:	8b 45 0c             	mov    0xc(%ebp),%eax
    2994:	8b 00                	mov    (%eax),%eax
    2996:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2999:	0f 8f e8 fe ff ff    	jg     2887 <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    299f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    29a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    29a6:	8b 40 04             	mov    0x4(%eax),%eax
    29a9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    29ac:	0f 8f c9 fe ff ff    	jg     287b <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    29b2:	b8 01 00 00 00       	mov    $0x1,%eax
}
    29b7:	c9                   	leave  
    29b8:	c3                   	ret    

000029b9 <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    29b9:	55                   	push   %ebp
    29ba:	89 e5                	mov    %esp,%ebp
    29bc:	53                   	push   %ebx
    29bd:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    29c0:	8b 45 08             	mov    0x8(%ebp),%eax
    29c3:	8b 10                	mov    (%eax),%edx
    29c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    29c8:	8b 00                	mov    (%eax),%eax
    29ca:	39 c2                	cmp    %eax,%edx
    29cc:	75 10                	jne    29de <picRollingOver+0x25>
    29ce:	8b 45 08             	mov    0x8(%ebp),%eax
    29d1:	8b 50 04             	mov    0x4(%eax),%edx
    29d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    29d7:	8b 40 04             	mov    0x4(%eax),%eax
    29da:	39 c2                	cmp    %eax,%edx
    29dc:	74 0a                	je     29e8 <picRollingOver+0x2f>
        return 0;
    29de:	b8 00 00 00 00       	mov    $0x0,%eax
    29e3:	e9 88 00 00 00       	jmp    2a70 <picRollingOver+0xb7>

    int h = src->height;
    29e8:	8b 45 08             	mov    0x8(%ebp),%eax
    29eb:	8b 40 04             	mov    0x4(%eax),%eax
    29ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    29f1:	8b 45 08             	mov    0x8(%ebp),%eax
    29f4:	8b 00                	mov    (%eax),%eax
    29f6:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    29f9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2a00:	eb 61                	jmp    2a63 <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    2a02:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2a09:	eb 4c                	jmp    2a57 <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    2a0b:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a0e:	8b 48 08             	mov    0x8(%eax),%ecx
    2a11:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2a14:	2b 45 f8             	sub    -0x8(%ebp),%eax
    2a17:	83 e8 01             	sub    $0x1,%eax
    2a1a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2a1e:	89 c2                	mov    %eax,%edx
    2a20:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a23:	01 c2                	add    %eax,%edx
    2a25:	89 d0                	mov    %edx,%eax
    2a27:	01 c0                	add    %eax,%eax
    2a29:	01 d0                	add    %edx,%eax
    2a2b:	01 c1                	add    %eax,%ecx
    2a2d:	8b 45 08             	mov    0x8(%ebp),%eax
    2a30:	8b 58 08             	mov    0x8(%eax),%ebx
    2a33:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a36:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2a3a:	89 c2                	mov    %eax,%edx
    2a3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a3f:	01 c2                	add    %eax,%edx
    2a41:	89 d0                	mov    %edx,%eax
    2a43:	01 c0                	add    %eax,%eax
    2a45:	01 d0                	add    %edx,%eax
    2a47:	01 d8                	add    %ebx,%eax
    2a49:	51                   	push   %ecx
    2a4a:	50                   	push   %eax
    2a4b:	e8 a9 f5 ff ff       	call   1ff9 <setColor>
    2a50:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2a53:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2a57:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a5a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2a5d:	7c ac                	jl     2a0b <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2a5f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2a63:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a66:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2a69:	7c 97                	jl     2a02 <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    2a6b:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2a70:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2a73:	c9                   	leave  
    2a74:	c3                   	ret    

00002a75 <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    2a75:	55                   	push   %ebp
    2a76:	89 e5                	mov    %esp,%ebp
    2a78:	53                   	push   %ebx
    2a79:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2a7c:	8b 45 08             	mov    0x8(%ebp),%eax
    2a7f:	8b 10                	mov    (%eax),%edx
    2a81:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a84:	8b 00                	mov    (%eax),%eax
    2a86:	39 c2                	cmp    %eax,%edx
    2a88:	75 10                	jne    2a9a <picTurnAround+0x25>
    2a8a:	8b 45 08             	mov    0x8(%ebp),%eax
    2a8d:	8b 50 04             	mov    0x4(%eax),%edx
    2a90:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a93:	8b 40 04             	mov    0x4(%eax),%eax
    2a96:	39 c2                	cmp    %eax,%edx
    2a98:	74 0a                	je     2aa4 <picTurnAround+0x2f>
        return 0;
    2a9a:	b8 00 00 00 00       	mov    $0x0,%eax
    2a9f:	e9 88 00 00 00       	jmp    2b2c <picTurnAround+0xb7>

    int h = src->height;
    2aa4:	8b 45 08             	mov    0x8(%ebp),%eax
    2aa7:	8b 40 04             	mov    0x4(%eax),%eax
    2aaa:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2aad:	8b 45 08             	mov    0x8(%ebp),%eax
    2ab0:	8b 00                	mov    (%eax),%eax
    2ab2:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2ab5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2abc:	eb 61                	jmp    2b1f <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    2abe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2ac5:	eb 4c                	jmp    2b13 <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    2ac7:	8b 45 0c             	mov    0xc(%ebp),%eax
    2aca:	8b 48 08             	mov    0x8(%eax),%ecx
    2acd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2ad0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2ad4:	89 c2                	mov    %eax,%edx
    2ad6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2ad9:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2adc:	01 c2                	add    %eax,%edx
    2ade:	89 d0                	mov    %edx,%eax
    2ae0:	01 c0                	add    %eax,%eax
    2ae2:	01 d0                	add    %edx,%eax
    2ae4:	83 e8 03             	sub    $0x3,%eax
    2ae7:	01 c1                	add    %eax,%ecx
    2ae9:	8b 45 08             	mov    0x8(%ebp),%eax
    2aec:	8b 58 08             	mov    0x8(%eax),%ebx
    2aef:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2af2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2af6:	89 c2                	mov    %eax,%edx
    2af8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2afb:	01 c2                	add    %eax,%edx
    2afd:	89 d0                	mov    %edx,%eax
    2aff:	01 c0                	add    %eax,%eax
    2b01:	01 d0                	add    %edx,%eax
    2b03:	01 d8                	add    %ebx,%eax
    2b05:	51                   	push   %ecx
    2b06:	50                   	push   %eax
    2b07:	e8 ed f4 ff ff       	call   1ff9 <setColor>
    2b0c:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2b0f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2b13:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b16:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2b19:	7c ac                	jl     2ac7 <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2b1b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2b1f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2b22:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2b25:	7c 97                	jl     2abe <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    2b27:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2b2c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2b2f:	c9                   	leave  
    2b30:	c3                   	ret    

00002b31 <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    2b31:	55                   	push   %ebp
    2b32:	89 e5                	mov    %esp,%ebp
    2b34:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    2b37:	83 ec 0c             	sub    $0xc,%esp
    2b3a:	ff 75 08             	pushl  0x8(%ebp)
    2b3d:	e8 c5 d5 ff ff       	call   107 <strlen>
    2b42:	83 c4 10             	add    $0x10,%esp
    2b45:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    2b48:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b4b:	8d 50 ff             	lea    -0x1(%eax),%edx
    2b4e:	8b 45 08             	mov    0x8(%ebp),%eax
    2b51:	01 d0                	add    %edx,%eax
    2b53:	0f b6 00             	movzbl (%eax),%eax
    2b56:	3c 67                	cmp    $0x67,%al
    2b58:	75 2b                	jne    2b85 <type+0x54>
    2b5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b5d:	8d 50 fe             	lea    -0x2(%eax),%edx
    2b60:	8b 45 08             	mov    0x8(%ebp),%eax
    2b63:	01 d0                	add    %edx,%eax
    2b65:	0f b6 00             	movzbl (%eax),%eax
    2b68:	3c 70                	cmp    $0x70,%al
    2b6a:	75 19                	jne    2b85 <type+0x54>
    2b6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b6f:	8d 50 fd             	lea    -0x3(%eax),%edx
    2b72:	8b 45 08             	mov    0x8(%ebp),%eax
    2b75:	01 d0                	add    %edx,%eax
    2b77:	0f b6 00             	movzbl (%eax),%eax
    2b7a:	3c 6a                	cmp    $0x6a,%al
    2b7c:	75 07                	jne    2b85 <type+0x54>
    2b7e:	b8 00 00 00 00       	mov    $0x0,%eax
    2b83:	eb 7f                	jmp    2c04 <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    2b85:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b88:	8d 50 ff             	lea    -0x1(%eax),%edx
    2b8b:	8b 45 08             	mov    0x8(%ebp),%eax
    2b8e:	01 d0                	add    %edx,%eax
    2b90:	0f b6 00             	movzbl (%eax),%eax
    2b93:	3c 70                	cmp    $0x70,%al
    2b95:	75 2b                	jne    2bc2 <type+0x91>
    2b97:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b9a:	8d 50 fe             	lea    -0x2(%eax),%edx
    2b9d:	8b 45 08             	mov    0x8(%ebp),%eax
    2ba0:	01 d0                	add    %edx,%eax
    2ba2:	0f b6 00             	movzbl (%eax),%eax
    2ba5:	3c 6d                	cmp    $0x6d,%al
    2ba7:	75 19                	jne    2bc2 <type+0x91>
    2ba9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bac:	8d 50 fd             	lea    -0x3(%eax),%edx
    2baf:	8b 45 08             	mov    0x8(%ebp),%eax
    2bb2:	01 d0                	add    %edx,%eax
    2bb4:	0f b6 00             	movzbl (%eax),%eax
    2bb7:	3c 62                	cmp    $0x62,%al
    2bb9:	75 07                	jne    2bc2 <type+0x91>
    2bbb:	b8 01 00 00 00       	mov    $0x1,%eax
    2bc0:	eb 42                	jmp    2c04 <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    2bc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bc5:	8d 50 ff             	lea    -0x1(%eax),%edx
    2bc8:	8b 45 08             	mov    0x8(%ebp),%eax
    2bcb:	01 d0                	add    %edx,%eax
    2bcd:	0f b6 00             	movzbl (%eax),%eax
    2bd0:	3c 67                	cmp    $0x67,%al
    2bd2:	75 2b                	jne    2bff <type+0xce>
    2bd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bd7:	8d 50 fe             	lea    -0x2(%eax),%edx
    2bda:	8b 45 08             	mov    0x8(%ebp),%eax
    2bdd:	01 d0                	add    %edx,%eax
    2bdf:	0f b6 00             	movzbl (%eax),%eax
    2be2:	3c 6e                	cmp    $0x6e,%al
    2be4:	75 19                	jne    2bff <type+0xce>
    2be6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2be9:	8d 50 fd             	lea    -0x3(%eax),%edx
    2bec:	8b 45 08             	mov    0x8(%ebp),%eax
    2bef:	01 d0                	add    %edx,%eax
    2bf1:	0f b6 00             	movzbl (%eax),%eax
    2bf4:	3c 70                	cmp    $0x70,%al
    2bf6:	75 07                	jne    2bff <type+0xce>
    2bf8:	b8 02 00 00 00       	mov    $0x2,%eax
    2bfd:	eb 05                	jmp    2c04 <type+0xd3>
    else return NONE;
    2bff:	b8 03 00 00 00       	mov    $0x3,%eax
}
    2c04:	c9                   	leave  
    2c05:	c3                   	ret    

00002c06 <LoadBmp>:

PBitmap LoadBmp(char* filename){
    2c06:	55                   	push   %ebp
    2c07:	89 e5                	mov    %esp,%ebp
    2c09:	56                   	push   %esi
    2c0a:	53                   	push   %ebx
    2c0b:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    2c0e:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    2c15:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    2c1c:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    2c23:	83 ec 08             	sub    $0x8,%esp
    2c26:	6a 00                	push   $0x0
    2c28:	ff 75 0c             	pushl  0xc(%ebp)
    2c2b:	e8 d9 d6 ff ff       	call   309 <open>
    2c30:	83 c4 10             	add    $0x10,%esp
    2c33:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2c36:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2c3a:	79 2c                	jns    2c68 <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    2c3c:	83 ec 08             	sub    $0x8,%esp
    2c3f:	ff 75 0c             	pushl  0xc(%ebp)
    2c42:	68 88 9c 01 00       	push   $0x19c88
    2c47:	e8 24 d8 ff ff       	call   470 <printf>
    2c4c:	83 c4 10             	add    $0x10,%esp
        return bmp;
    2c4f:	8b 45 08             	mov    0x8(%ebp),%eax
    2c52:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2c55:	89 10                	mov    %edx,(%eax)
    2c57:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2c5a:	89 50 04             	mov    %edx,0x4(%eax)
    2c5d:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2c60:	89 50 08             	mov    %edx,0x8(%eax)
    2c63:	e9 2d 02 00 00       	jmp    2e95 <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    2c68:	83 ec 04             	sub    $0x4,%esp
    2c6b:	6a 0e                	push   $0xe
    2c6d:	8d 45 aa             	lea    -0x56(%ebp),%eax
    2c70:	50                   	push   %eax
    2c71:	ff 75 ec             	pushl  -0x14(%ebp)
    2c74:	e8 68 d6 ff ff       	call   2e1 <read>
    2c79:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    2c7c:	83 ec 04             	sub    $0x4,%esp
    2c7f:	6a 28                	push   $0x28
    2c81:	8d 45 82             	lea    -0x7e(%ebp),%eax
    2c84:	50                   	push   %eax
    2c85:	ff 75 ec             	pushl  -0x14(%ebp)
    2c88:	e8 54 d6 ff ff       	call   2e1 <read>
    2c8d:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2c90:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2c94:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2c97:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2c9b:	0f b7 d8             	movzwl %ax,%ebx
    2c9e:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    2ca1:	8b 55 ac             	mov    -0x54(%ebp),%edx
    2ca4:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    2ca8:	0f b7 c0             	movzwl %ax,%eax
    2cab:	83 ec 04             	sub    $0x4,%esp
    2cae:	6a 36                	push   $0x36
    2cb0:	56                   	push   %esi
    2cb1:	53                   	push   %ebx
    2cb2:	51                   	push   %ecx
    2cb3:	52                   	push   %edx
    2cb4:	50                   	push   %eax
    2cb5:	68 98 9c 01 00       	push   $0x19c98
    2cba:	e8 b1 d7 ff ff       	call   470 <printf>
    2cbf:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    2cc2:	8b 45 86             	mov    -0x7a(%ebp),%eax
    2cc5:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    2cc8:	8b 45 8a             	mov    -0x76(%ebp),%eax
    2ccb:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    2cce:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2cd1:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2cd4:	0f af c2             	imul   %edx,%eax
    2cd7:	89 c2                	mov    %eax,%edx
    2cd9:	89 d0                	mov    %edx,%eax
    2cdb:	01 c0                	add    %eax,%eax
    2cdd:	01 d0                	add    %edx,%eax
    2cdf:	83 ec 0c             	sub    $0xc,%esp
    2ce2:	50                   	push   %eax
    2ce3:	e8 5b da ff ff       	call   743 <malloc>
    2ce8:	83 c4 10             	add    $0x10,%esp
    2ceb:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    2cee:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2cf2:	0f b7 c0             	movzwl %ax,%eax
    2cf5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    2cf8:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2cfb:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    2cff:	83 c0 1f             	add    $0x1f,%eax
    2d02:	c1 f8 05             	sar    $0x5,%eax
    2d05:	c1 e0 02             	shl    $0x2,%eax
    2d08:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    2d0b:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2d0e:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2d12:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    2d15:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2d18:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2d1b:	83 ec 08             	sub    $0x8,%esp
    2d1e:	52                   	push   %edx
    2d1f:	50                   	push   %eax
    2d20:	ff 75 e8             	pushl  -0x18(%ebp)
    2d23:	ff 75 e0             	pushl  -0x20(%ebp)
    2d26:	ff 75 e4             	pushl  -0x1c(%ebp)
    2d29:	68 c0 9c 01 00       	push   $0x19cc0
    2d2e:	e8 3d d7 ff ff       	call   470 <printf>
    2d33:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    2d36:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    2d39:	83 e8 36             	sub    $0x36,%eax
    2d3c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    2d3f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2d42:	83 ec 0c             	sub    $0xc,%esp
    2d45:	50                   	push   %eax
    2d46:	e8 f8 d9 ff ff       	call   743 <malloc>
    2d4b:	83 c4 10             	add    $0x10,%esp
    2d4e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    2d51:	83 ec 04             	sub    $0x4,%esp
    2d54:	ff 75 dc             	pushl  -0x24(%ebp)
    2d57:	ff 75 d8             	pushl  -0x28(%ebp)
    2d5a:	ff 75 ec             	pushl  -0x14(%ebp)
    2d5d:	e8 7f d5 ff ff       	call   2e1 <read>
    2d62:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    2d65:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2d68:	83 ec 0c             	sub    $0xc,%esp
    2d6b:	50                   	push   %eax
    2d6c:	e8 d2 d9 ff ff       	call   743 <malloc>
    2d71:	83 c4 10             	add    $0x10,%esp
    2d74:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    2d77:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2d7a:	83 ec 04             	sub    $0x4,%esp
    2d7d:	50                   	push   %eax
    2d7e:	ff 75 d4             	pushl  -0x2c(%ebp)
    2d81:	ff 75 ec             	pushl  -0x14(%ebp)
    2d84:	e8 58 d5 ff ff       	call   2e1 <read>
    2d89:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    2d8c:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2d90:	66 c1 e8 03          	shr    $0x3,%ax
    2d94:	0f b7 c0             	movzwl %ax,%eax
    2d97:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    2d9a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2da1:	e9 c1 00 00 00       	jmp    2e67 <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    2da6:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2da9:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2dac:	8d 50 ff             	lea    -0x1(%eax),%edx
    2daf:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2db2:	0f af c2             	imul   %edx,%eax
    2db5:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    2db8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2dbb:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2dbf:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    2dc2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2dc9:	e9 89 00 00 00       	jmp    2e57 <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    2dce:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2dd1:	83 c0 01             	add    $0x1,%eax
    2dd4:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2dd8:	89 c2                	mov    %eax,%edx
    2dda:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2ddd:	01 d0                	add    %edx,%eax
    2ddf:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    2de2:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2de5:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2de8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2deb:	01 c8                	add    %ecx,%eax
    2ded:	89 c1                	mov    %eax,%ecx
    2def:	89 c8                	mov    %ecx,%eax
    2df1:	01 c0                	add    %eax,%eax
    2df3:	01 c8                	add    %ecx,%eax
    2df5:	01 c2                	add    %eax,%edx
    2df7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2dfa:	8d 48 ff             	lea    -0x1(%eax),%ecx
    2dfd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2e00:	01 c8                	add    %ecx,%eax
    2e02:	0f b6 00             	movzbl (%eax),%eax
    2e05:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    2e08:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e0b:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2e0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e11:	01 c8                	add    %ecx,%eax
    2e13:	89 c1                	mov    %eax,%ecx
    2e15:	89 c8                	mov    %ecx,%eax
    2e17:	01 c0                	add    %eax,%eax
    2e19:	01 c8                	add    %ecx,%eax
    2e1b:	01 c2                	add    %eax,%edx
    2e1d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2e20:	8d 48 fe             	lea    -0x2(%eax),%ecx
    2e23:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2e26:	01 c8                	add    %ecx,%eax
    2e28:	0f b6 00             	movzbl (%eax),%eax
    2e2b:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    2e2e:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e31:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2e34:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e37:	01 c8                	add    %ecx,%eax
    2e39:	89 c1                	mov    %eax,%ecx
    2e3b:	89 c8                	mov    %ecx,%eax
    2e3d:	01 c0                	add    %eax,%eax
    2e3f:	01 c8                	add    %ecx,%eax
    2e41:	01 c2                	add    %eax,%edx
    2e43:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2e46:	8d 48 fd             	lea    -0x3(%eax),%ecx
    2e49:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2e4c:	01 c8                	add    %ecx,%eax
    2e4e:	0f b6 00             	movzbl (%eax),%eax
    2e51:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    2e53:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2e57:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2e5a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2e5d:	0f 8f 6b ff ff ff    	jg     2dce <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    2e63:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2e67:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2e6a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2e6d:	0f 8f 33 ff ff ff    	jg     2da6 <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    2e73:	83 ec 0c             	sub    $0xc,%esp
    2e76:	ff 75 ec             	pushl  -0x14(%ebp)
    2e79:	e8 73 d4 ff ff       	call   2f1 <close>
    2e7e:	83 c4 10             	add    $0x10,%esp
    return bmp;
    2e81:	8b 45 08             	mov    0x8(%ebp),%eax
    2e84:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2e87:	89 10                	mov    %edx,(%eax)
    2e89:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2e8c:	89 50 04             	mov    %edx,0x4(%eax)
    2e8f:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e92:	89 50 08             	mov    %edx,0x8(%eax)
}
    2e95:	8b 45 08             	mov    0x8(%ebp),%eax
    2e98:	8d 65 f8             	lea    -0x8(%ebp),%esp
    2e9b:	5b                   	pop    %ebx
    2e9c:	5e                   	pop    %esi
    2e9d:	5d                   	pop    %ebp
    2e9e:	c2 04 00             	ret    $0x4

00002ea1 <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    2ea1:	55                   	push   %ebp
    2ea2:	89 e5                	mov    %esp,%ebp
    2ea4:	53                   	push   %ebx
    2ea5:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    2ea8:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    2eac:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    2eb0:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    2eb4:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    2eb8:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    2ebc:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    2ec0:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    2ec4:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    2ec8:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    2ecc:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    2ed0:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    2ed4:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    2ed8:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    2edc:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    2ee0:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    2ee4:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    2ee8:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    2eec:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    2ef0:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    2ef4:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    2ef8:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    2efc:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    2f00:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    2f04:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    2f08:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    2f0c:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    2f10:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    2f14:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    2f18:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    2f1c:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    2f20:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    2f24:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    2f28:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    2f2c:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    2f30:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    2f34:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    2f38:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    2f3c:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    2f40:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    2f44:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    2f48:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    2f4c:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    2f50:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    2f54:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    2f58:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    2f5c:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    2f60:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    2f64:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    2f68:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    2f6c:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    2f70:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    2f74:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    2f78:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    2f7c:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    2f80:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    2f84:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    2f88:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    2f8c:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    2f90:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    2f94:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    2f98:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    2f9c:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    2fa0:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    2fa4:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    2fa8:	83 ec 0c             	sub    $0xc,%esp
    2fab:	68 c8 02 08 00       	push   $0x802c8
    2fb0:	e8 8e d7 ff ff       	call   743 <malloc>
    2fb5:	83 c4 10             	add    $0x10,%esp
    2fb8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    2fbb:	83 ec 04             	sub    $0x4,%esp
    2fbe:	68 c8 02 08 00       	push   $0x802c8
    2fc3:	6a 00                	push   $0x0
    2fc5:	ff 75 f0             	pushl  -0x10(%ebp)
    2fc8:	e8 61 d1 ff ff       	call   12e <memset>
    2fcd:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    2fd0:	83 ec 08             	sub    $0x8,%esp
    2fd3:	6a 00                	push   $0x0
    2fd5:	ff 75 0c             	pushl  0xc(%ebp)
    2fd8:	e8 2c d3 ff ff       	call   309 <open>
    2fdd:	83 c4 10             	add    $0x10,%esp
    2fe0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    2fe3:	83 ec 0c             	sub    $0xc,%esp
    2fe6:	68 40 42 0f 00       	push   $0xf4240
    2feb:	e8 53 d7 ff ff       	call   743 <malloc>
    2ff0:	83 c4 10             	add    $0x10,%esp
    2ff3:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    2ff6:	83 ec 04             	sub    $0x4,%esp
    2ff9:	68 40 42 0f 00       	push   $0xf4240
    2ffe:	ff 75 e8             	pushl  -0x18(%ebp)
    3001:	ff 75 ec             	pushl  -0x14(%ebp)
    3004:	e8 d8 d2 ff ff       	call   2e1 <read>
    3009:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    300c:	83 ec 0c             	sub    $0xc,%esp
    300f:	ff 75 ec             	pushl  -0x14(%ebp)
    3012:	e8 da d2 ff ff       	call   2f1 <close>
    3017:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    301a:	68 40 42 0f 00       	push   $0xf4240
    301f:	ff 75 e8             	pushl  -0x18(%ebp)
    3022:	8d 45 9c             	lea    -0x64(%ebp),%eax
    3025:	50                   	push   %eax
    3026:	ff 75 f0             	pushl  -0x10(%ebp)
    3029:	e8 5e 0c 01 00       	call   13c8c <_DecodeJPEG>
    302e:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    3031:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    3038:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    303f:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    3046:	83 ec 0c             	sub    $0xc,%esp
    3049:	ff 75 f0             	pushl  -0x10(%ebp)
    304c:	e8 29 0b 01 00       	call   13b7a <GetImageSize>
    3051:	83 c4 10             	add    $0x10,%esp
    3054:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    3057:	83 ec 0c             	sub    $0xc,%esp
    305a:	ff 75 f0             	pushl  -0x10(%ebp)
    305d:	e8 e1 0a 01 00       	call   13b43 <GetImage>
    3062:	83 c4 10             	add    $0x10,%esp
    3065:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    3068:	83 ec 0c             	sub    $0xc,%esp
    306b:	ff 75 f0             	pushl  -0x10(%ebp)
    306e:	e8 f1 0a 01 00       	call   13b64 <GetWidth>
    3073:	83 c4 10             	add    $0x10,%esp
    3076:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    3079:	83 ec 0c             	sub    $0xc,%esp
    307c:	ff 75 f0             	pushl  -0x10(%ebp)
    307f:	e8 eb 0a 01 00       	call   13b6f <GetHeight>
    3084:	83 c4 10             	add    $0x10,%esp
    3087:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    308a:	8b 55 90             	mov    -0x70(%ebp),%edx
    308d:	8b 45 94             	mov    -0x6c(%ebp),%eax
    3090:	0f af c2             	imul   %edx,%eax
    3093:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    3096:	8b 55 dc             	mov    -0x24(%ebp),%edx
    3099:	89 d0                	mov    %edx,%eax
    309b:	01 c0                	add    %eax,%eax
    309d:	01 d0                	add    %edx,%eax
    309f:	83 ec 0c             	sub    $0xc,%esp
    30a2:	50                   	push   %eax
    30a3:	e8 9b d6 ff ff       	call   743 <malloc>
    30a8:	83 c4 10             	add    $0x10,%esp
    30ab:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    30ae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    30b5:	e9 9c 00 00 00       	jmp    3156 <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    30ba:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    30bd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    30c0:	ba 56 55 55 55       	mov    $0x55555556,%edx
    30c5:	89 c8                	mov    %ecx,%eax
    30c7:	f7 ea                	imul   %edx
    30c9:	89 c8                	mov    %ecx,%eax
    30cb:	c1 f8 1f             	sar    $0x1f,%eax
    30ce:	29 c2                	sub    %eax,%edx
    30d0:	89 d0                	mov    %edx,%eax
    30d2:	89 c2                	mov    %eax,%edx
    30d4:	89 d0                	mov    %edx,%eax
    30d6:	01 c0                	add    %eax,%eax
    30d8:	01 d0                	add    %edx,%eax
    30da:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    30dd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    30e0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    30e3:	01 c8                	add    %ecx,%eax
    30e5:	0f b6 00             	movzbl (%eax),%eax
    30e8:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    30eb:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    30ee:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    30f1:	ba 56 55 55 55       	mov    $0x55555556,%edx
    30f6:	89 c8                	mov    %ecx,%eax
    30f8:	f7 ea                	imul   %edx
    30fa:	89 c8                	mov    %ecx,%eax
    30fc:	c1 f8 1f             	sar    $0x1f,%eax
    30ff:	29 c2                	sub    %eax,%edx
    3101:	89 d0                	mov    %edx,%eax
    3103:	89 c2                	mov    %eax,%edx
    3105:	89 d0                	mov    %edx,%eax
    3107:	01 c0                	add    %eax,%eax
    3109:	01 d0                	add    %edx,%eax
    310b:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    310e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3111:	8d 48 01             	lea    0x1(%eax),%ecx
    3114:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3117:	01 c8                	add    %ecx,%eax
    3119:	0f b6 00             	movzbl (%eax),%eax
    311c:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    311f:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3122:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3125:	ba 56 55 55 55       	mov    $0x55555556,%edx
    312a:	89 c8                	mov    %ecx,%eax
    312c:	f7 ea                	imul   %edx
    312e:	89 c8                	mov    %ecx,%eax
    3130:	c1 f8 1f             	sar    $0x1f,%eax
    3133:	29 c2                	sub    %eax,%edx
    3135:	89 d0                	mov    %edx,%eax
    3137:	89 c2                	mov    %eax,%edx
    3139:	89 d0                	mov    %edx,%eax
    313b:	01 c0                	add    %eax,%eax
    313d:	01 d0                	add    %edx,%eax
    313f:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3142:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3145:	8d 48 02             	lea    0x2(%eax),%ecx
    3148:	8b 45 e0             	mov    -0x20(%ebp),%eax
    314b:	01 c8                	add    %ecx,%eax
    314d:	0f b6 00             	movzbl (%eax),%eax
    3150:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    3152:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    3156:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3159:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    315c:	0f 8c 58 ff ff ff    	jl     30ba <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    3162:	8b 45 08             	mov    0x8(%ebp),%eax
    3165:	8b 55 90             	mov    -0x70(%ebp),%edx
    3168:	89 10                	mov    %edx,(%eax)
    316a:	8b 55 94             	mov    -0x6c(%ebp),%edx
    316d:	89 50 04             	mov    %edx,0x4(%eax)
    3170:	8b 55 98             	mov    -0x68(%ebp),%edx
    3173:	89 50 08             	mov    %edx,0x8(%eax)
}
    3176:	8b 45 08             	mov    0x8(%ebp),%eax
    3179:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    317c:	c9                   	leave  
    317d:	c2 04 00             	ret    $0x4

00003180 <LoadPng>:

PBitmap LoadPng(char* filename){
    3180:	55                   	push   %ebp
    3181:	89 e5                	mov    %esp,%ebp
    3183:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    3186:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    318d:	ff 75 0c             	pushl  0xc(%ebp)
    3190:	8d 45 e0             	lea    -0x20(%ebp),%eax
    3193:	50                   	push   %eax
    3194:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    3197:	50                   	push   %eax
    3198:	8d 45 e8             	lea    -0x18(%ebp),%eax
    319b:	50                   	push   %eax
    319c:	e8 d3 d3 00 00       	call   10574 <lodepng_decode24_file>
    31a1:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    31a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    31a7:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    31aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    31ad:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    31b0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    31b7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    31ba:	8b 45 d8             	mov    -0x28(%ebp),%eax
    31bd:	0f af c2             	imul   %edx,%eax
    31c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    31c3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    31c6:	89 d0                	mov    %edx,%eax
    31c8:	01 c0                	add    %eax,%eax
    31ca:	01 d0                	add    %edx,%eax
    31cc:	83 ec 0c             	sub    $0xc,%esp
    31cf:	50                   	push   %eax
    31d0:	e8 6e d5 ff ff       	call   743 <malloc>
    31d5:	83 c4 10             	add    $0x10,%esp
    31d8:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    31db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    31e2:	e9 87 00 00 00       	jmp    326e <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    31e7:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    31ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
    31ed:	89 d0                	mov    %edx,%eax
    31ef:	01 c0                	add    %eax,%eax
    31f1:	01 d0                	add    %edx,%eax
    31f3:	01 c8                	add    %ecx,%eax
    31f5:	0f b6 00             	movzbl (%eax),%eax
    31f8:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    31fb:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    31fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3201:	89 d0                	mov    %edx,%eax
    3203:	01 c0                	add    %eax,%eax
    3205:	01 d0                	add    %edx,%eax
    3207:	83 c0 01             	add    $0x1,%eax
    320a:	01 c8                	add    %ecx,%eax
    320c:	0f b6 00             	movzbl (%eax),%eax
    320f:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    3212:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3215:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3218:	89 d0                	mov    %edx,%eax
    321a:	01 c0                	add    %eax,%eax
    321c:	01 d0                	add    %edx,%eax
    321e:	83 c0 02             	add    $0x2,%eax
    3221:	01 c8                	add    %ecx,%eax
    3223:	0f b6 00             	movzbl (%eax),%eax
    3226:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    3229:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    322c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    322f:	89 d0                	mov    %edx,%eax
    3231:	01 c0                	add    %eax,%eax
    3233:	01 d0                	add    %edx,%eax
    3235:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3238:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    323c:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    323f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3242:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3245:	89 d0                	mov    %edx,%eax
    3247:	01 c0                	add    %eax,%eax
    3249:	01 d0                	add    %edx,%eax
    324b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    324e:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    3252:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    3255:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3258:	8b 55 f4             	mov    -0xc(%ebp),%edx
    325b:	89 d0                	mov    %edx,%eax
    325d:	01 c0                	add    %eax,%eax
    325f:	01 d0                	add    %edx,%eax
    3261:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3264:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    3268:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    326a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    326e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3271:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3274:	0f 8c 6d ff ff ff    	jl     31e7 <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    327a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    327d:	83 ec 0c             	sub    $0xc,%esp
    3280:	50                   	push   %eax
    3281:	e8 7b d3 ff ff       	call   601 <free>
    3286:	83 c4 10             	add    $0x10,%esp
    return bmp;
    3289:	8b 45 08             	mov    0x8(%ebp),%eax
    328c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    328f:	89 10                	mov    %edx,(%eax)
    3291:	8b 55 d8             	mov    -0x28(%ebp),%edx
    3294:	89 50 04             	mov    %edx,0x4(%eax)
    3297:	8b 55 dc             	mov    -0x24(%ebp),%edx
    329a:	89 50 08             	mov    %edx,0x8(%eax)

}
    329d:	8b 45 08             	mov    0x8(%ebp),%eax
    32a0:	c9                   	leave  
    32a1:	c2 04 00             	ret    $0x4

000032a4 <LoadImg>:

PBitmap LoadImg(char* filename){
    32a4:	55                   	push   %ebp
    32a5:	89 e5                	mov    %esp,%ebp
    32a7:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    32aa:	83 ec 0c             	sub    $0xc,%esp
    32ad:	ff 75 0c             	pushl  0xc(%ebp)
    32b0:	e8 7c f8 ff ff       	call   2b31 <type>
    32b5:	83 c4 10             	add    $0x10,%esp
    32b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    32bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    32be:	83 f8 01             	cmp    $0x1,%eax
    32c1:	74 1d                	je     32e0 <LoadImg+0x3c>
    32c3:	83 f8 02             	cmp    $0x2,%eax
    32c6:	74 2c                	je     32f4 <LoadImg+0x50>
    32c8:	85 c0                	test   %eax,%eax
    32ca:	75 3c                	jne    3308 <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    32cc:	8b 45 08             	mov    0x8(%ebp),%eax
    32cf:	83 ec 08             	sub    $0x8,%esp
    32d2:	ff 75 0c             	pushl  0xc(%ebp)
    32d5:	50                   	push   %eax
    32d6:	e8 c6 fb ff ff       	call   2ea1 <LoadJpeg>
    32db:	83 c4 0c             	add    $0xc,%esp
    32de:	eb 3c                	jmp    331c <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    32e0:	8b 45 08             	mov    0x8(%ebp),%eax
    32e3:	83 ec 08             	sub    $0x8,%esp
    32e6:	ff 75 0c             	pushl  0xc(%ebp)
    32e9:	50                   	push   %eax
    32ea:	e8 17 f9 ff ff       	call   2c06 <LoadBmp>
    32ef:	83 c4 0c             	add    $0xc,%esp
    32f2:	eb 28                	jmp    331c <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    32f4:	8b 45 08             	mov    0x8(%ebp),%eax
    32f7:	83 ec 08             	sub    $0x8,%esp
    32fa:	ff 75 0c             	pushl  0xc(%ebp)
    32fd:	50                   	push   %eax
    32fe:	e8 7d fe ff ff       	call   3180 <LoadPng>
    3303:	83 c4 0c             	add    $0xc,%esp
    3306:	eb 14                	jmp    331c <LoadImg+0x78>

        default: return bmp;
    3308:	8b 45 08             	mov    0x8(%ebp),%eax
    330b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    330e:	89 10                	mov    %edx,(%eax)
    3310:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3313:	89 50 04             	mov    %edx,0x4(%eax)
    3316:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3319:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    331c:	8b 45 08             	mov    0x8(%ebp),%eax
    331f:	c9                   	leave  
    3320:	c2 04 00             	ret    $0x4

00003323 <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    3323:	55                   	push   %ebp
    3324:	89 e5                	mov    %esp,%ebp
    3326:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    3329:	8b 45 08             	mov    0x8(%ebp),%eax
    332c:	83 ec 0c             	sub    $0xc,%esp
    332f:	50                   	push   %eax
    3330:	e8 0e d4 ff ff       	call   743 <malloc>
    3335:	83 c4 10             	add    $0x10,%esp
}
    3338:	c9                   	leave  
    3339:	c3                   	ret    

0000333a <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    333a:	55                   	push   %ebp
    333b:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    333d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3342:	5d                   	pop    %ebp
    3343:	c3                   	ret    

00003344 <lodepng_free>:

static void lodepng_free(void* ptr) {
    3344:	55                   	push   %ebp
    3345:	89 e5                	mov    %esp,%ebp
    3347:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    334a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    334e:	74 0e                	je     335e <lodepng_free+0x1a>
    free(ptr);
    3350:	83 ec 0c             	sub    $0xc,%esp
    3353:	ff 75 08             	pushl  0x8(%ebp)
    3356:	e8 a6 d2 ff ff       	call   601 <free>
    335b:	83 c4 10             	add    $0x10,%esp
}
    335e:	90                   	nop
    335f:	c9                   	leave  
    3360:	c3                   	ret    

00003361 <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    3361:	55                   	push   %ebp
    3362:	89 e5                	mov    %esp,%ebp
    3364:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    3367:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    336e:	eb 19                	jmp    3389 <lodepng_memcpy+0x28>
    3370:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3373:	8b 45 08             	mov    0x8(%ebp),%eax
    3376:	01 c2                	add    %eax,%edx
    3378:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    337b:	8b 45 0c             	mov    0xc(%ebp),%eax
    337e:	01 c8                	add    %ecx,%eax
    3380:	0f b6 00             	movzbl (%eax),%eax
    3383:	88 02                	mov    %al,(%edx)
    3385:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3389:	8b 45 fc             	mov    -0x4(%ebp),%eax
    338c:	3b 45 10             	cmp    0x10(%ebp),%eax
    338f:	7c df                	jl     3370 <lodepng_memcpy+0xf>
}
    3391:	90                   	nop
    3392:	c9                   	leave  
    3393:	c3                   	ret    

00003394 <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    3394:	55                   	push   %ebp
    3395:	89 e5                	mov    %esp,%ebp
    3397:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    339a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    33a1:	eb 11                	jmp    33b4 <lodepng_memset+0x20>
    33a3:	8b 55 fc             	mov    -0x4(%ebp),%edx
    33a6:	8b 45 08             	mov    0x8(%ebp),%eax
    33a9:	01 d0                	add    %edx,%eax
    33ab:	8b 55 0c             	mov    0xc(%ebp),%edx
    33ae:	88 10                	mov    %dl,(%eax)
    33b0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    33b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    33b7:	3b 45 10             	cmp    0x10(%ebp),%eax
    33ba:	7c e7                	jl     33a3 <lodepng_memset+0xf>
}
    33bc:	90                   	nop
    33bd:	c9                   	leave  
    33be:	c3                   	ret    

000033bf <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    33bf:	55                   	push   %ebp
    33c0:	89 e5                	mov    %esp,%ebp
    33c2:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    33c5:	8b 45 08             	mov    0x8(%ebp),%eax
    33c8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    33cb:	eb 04                	jmp    33d1 <lodepng_strlen+0x12>
    33cd:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    33d1:	8b 45 08             	mov    0x8(%ebp),%eax
    33d4:	0f b6 00             	movzbl (%eax),%eax
    33d7:	84 c0                	test   %al,%al
    33d9:	75 f2                	jne    33cd <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    33db:	8b 55 08             	mov    0x8(%ebp),%edx
    33de:	8b 45 fc             	mov    -0x4(%ebp),%eax
    33e1:	29 c2                	sub    %eax,%edx
    33e3:	89 d0                	mov    %edx,%eax
}
    33e5:	c9                   	leave  
    33e6:	c3                   	ret    

000033e7 <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    33e7:	55                   	push   %ebp
    33e8:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    33ea:	8b 55 08             	mov    0x8(%ebp),%edx
    33ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    33f0:	01 c2                	add    %eax,%edx
    33f2:	8b 45 10             	mov    0x10(%ebp),%eax
    33f5:	89 10                	mov    %edx,(%eax)
  return *result < a;
    33f7:	8b 45 10             	mov    0x10(%ebp),%eax
    33fa:	8b 00                	mov    (%eax),%eax
    33fc:	3b 45 08             	cmp    0x8(%ebp),%eax
    33ff:	0f 9c c0             	setl   %al
    3402:	0f b6 c0             	movzbl %al,%eax
}
    3405:	5d                   	pop    %ebp
    3406:	c3                   	ret    

00003407 <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    3407:	55                   	push   %ebp
    3408:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    340a:	8b 45 08             	mov    0x8(%ebp),%eax
    340d:	0f af 45 0c          	imul   0xc(%ebp),%eax
    3411:	89 c2                	mov    %eax,%edx
    3413:	8b 45 10             	mov    0x10(%ebp),%eax
    3416:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    3418:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    341c:	74 15                	je     3433 <lodepng_mulofl+0x2c>
    341e:	8b 45 10             	mov    0x10(%ebp),%eax
    3421:	8b 00                	mov    (%eax),%eax
    3423:	99                   	cltd   
    3424:	f7 7d 08             	idivl  0x8(%ebp)
    3427:	3b 45 0c             	cmp    0xc(%ebp),%eax
    342a:	74 07                	je     3433 <lodepng_mulofl+0x2c>
    342c:	b8 01 00 00 00       	mov    $0x1,%eax
    3431:	eb 05                	jmp    3438 <lodepng_mulofl+0x31>
    3433:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3438:	5d                   	pop    %ebp
    3439:	c3                   	ret    

0000343a <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    343a:	55                   	push   %ebp
    343b:	89 e5                	mov    %esp,%ebp
    343d:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    3440:	8d 45 fc             	lea    -0x4(%ebp),%eax
    3443:	50                   	push   %eax
    3444:	ff 75 0c             	pushl  0xc(%ebp)
    3447:	ff 75 08             	pushl  0x8(%ebp)
    344a:	e8 98 ff ff ff       	call   33e7 <lodepng_addofl>
    344f:	83 c4 0c             	add    $0xc,%esp
    3452:	85 c0                	test   %eax,%eax
    3454:	74 07                	je     345d <lodepng_gtofl+0x23>
    3456:	b8 01 00 00 00       	mov    $0x1,%eax
    345b:	eb 0c                	jmp    3469 <lodepng_gtofl+0x2f>
  return d > c;
    345d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3460:	3b 45 10             	cmp    0x10(%ebp),%eax
    3463:	0f 9f c0             	setg   %al
    3466:	0f b6 c0             	movzbl %al,%eax
}
    3469:	c9                   	leave  
    346a:	c3                   	ret    

0000346b <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    346b:	55                   	push   %ebp
    346c:	89 e5                	mov    %esp,%ebp
    346e:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    3471:	8b 45 08             	mov    0x8(%ebp),%eax
    3474:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    347b:	8b 45 08             	mov    0x8(%ebp),%eax
    347e:	8b 50 08             	mov    0x8(%eax),%edx
    3481:	8b 45 08             	mov    0x8(%ebp),%eax
    3484:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    3487:	8b 45 08             	mov    0x8(%ebp),%eax
    348a:	8b 00                	mov    (%eax),%eax
    348c:	83 ec 0c             	sub    $0xc,%esp
    348f:	50                   	push   %eax
    3490:	e8 af fe ff ff       	call   3344 <lodepng_free>
    3495:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    3498:	8b 45 08             	mov    0x8(%ebp),%eax
    349b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    34a1:	90                   	nop
    34a2:	c9                   	leave  
    34a3:	c3                   	ret    

000034a4 <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    34a4:	55                   	push   %ebp
    34a5:	89 e5                	mov    %esp,%ebp
    34a7:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    34aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    34ad:	c1 e0 02             	shl    $0x2,%eax
    34b0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    34b3:	8b 45 08             	mov    0x8(%ebp),%eax
    34b6:	8b 40 08             	mov    0x8(%eax),%eax
    34b9:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    34bc:	7d 46                	jge    3504 <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    34be:	8b 45 08             	mov    0x8(%ebp),%eax
    34c1:	8b 40 08             	mov    0x8(%eax),%eax
    34c4:	d1 f8                	sar    %eax
    34c6:	89 c2                	mov    %eax,%edx
    34c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    34cb:	01 d0                	add    %edx,%eax
    34cd:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    34d0:	8b 45 08             	mov    0x8(%ebp),%eax
    34d3:	8b 00                	mov    (%eax),%eax
    34d5:	ff 75 f8             	pushl  -0x8(%ebp)
    34d8:	50                   	push   %eax
    34d9:	e8 5c fe ff ff       	call   333a <lodepng_realloc>
    34de:	83 c4 08             	add    $0x8,%esp
    34e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    34e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    34e8:	74 13                	je     34fd <uivector_resize+0x59>
      p->allocsize = newsize;
    34ea:	8b 45 08             	mov    0x8(%ebp),%eax
    34ed:	8b 55 f8             	mov    -0x8(%ebp),%edx
    34f0:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    34f3:	8b 45 08             	mov    0x8(%ebp),%eax
    34f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    34f9:	89 10                	mov    %edx,(%eax)
    34fb:	eb 07                	jmp    3504 <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    34fd:	b8 00 00 00 00       	mov    $0x0,%eax
    3502:	eb 0e                	jmp    3512 <uivector_resize+0x6e>
  }
  p->size = size;
    3504:	8b 45 08             	mov    0x8(%ebp),%eax
    3507:	8b 55 0c             	mov    0xc(%ebp),%edx
    350a:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    350d:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3512:	c9                   	leave  
    3513:	c3                   	ret    

00003514 <uivector_init>:

static void uivector_init(uivector* p) {
    3514:	55                   	push   %ebp
    3515:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    3517:	8b 45 08             	mov    0x8(%ebp),%eax
    351a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    3520:	8b 45 08             	mov    0x8(%ebp),%eax
    3523:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    352a:	8b 45 08             	mov    0x8(%ebp),%eax
    352d:	8b 50 08             	mov    0x8(%eax),%edx
    3530:	8b 45 08             	mov    0x8(%ebp),%eax
    3533:	89 50 04             	mov    %edx,0x4(%eax)
}
    3536:	90                   	nop
    3537:	5d                   	pop    %ebp
    3538:	c3                   	ret    

00003539 <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    3539:	55                   	push   %ebp
    353a:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    353c:	8b 45 08             	mov    0x8(%ebp),%eax
    353f:	8b 40 04             	mov    0x4(%eax),%eax
    3542:	83 c0 01             	add    $0x1,%eax
    3545:	50                   	push   %eax
    3546:	ff 75 08             	pushl  0x8(%ebp)
    3549:	e8 56 ff ff ff       	call   34a4 <uivector_resize>
    354e:	83 c4 08             	add    $0x8,%esp
    3551:	85 c0                	test   %eax,%eax
    3553:	75 07                	jne    355c <uivector_push_back+0x23>
    3555:	b8 00 00 00 00       	mov    $0x0,%eax
    355a:	eb 1f                	jmp    357b <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    355c:	8b 45 08             	mov    0x8(%ebp),%eax
    355f:	8b 10                	mov    (%eax),%edx
    3561:	8b 45 08             	mov    0x8(%ebp),%eax
    3564:	8b 40 04             	mov    0x4(%eax),%eax
    3567:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    356c:	c1 e0 02             	shl    $0x2,%eax
    356f:	01 c2                	add    %eax,%edx
    3571:	8b 45 0c             	mov    0xc(%ebp),%eax
    3574:	89 02                	mov    %eax,(%edx)
  return 1;
    3576:	b8 01 00 00 00       	mov    $0x1,%eax
}
    357b:	c9                   	leave  
    357c:	c3                   	ret    

0000357d <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    357d:	55                   	push   %ebp
    357e:	89 e5                	mov    %esp,%ebp
    3580:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    3583:	8b 45 08             	mov    0x8(%ebp),%eax
    3586:	8b 40 08             	mov    0x8(%eax),%eax
    3589:	3b 45 0c             	cmp    0xc(%ebp),%eax
    358c:	7d 46                	jge    35d4 <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    358e:	8b 45 08             	mov    0x8(%ebp),%eax
    3591:	8b 40 08             	mov    0x8(%eax),%eax
    3594:	d1 f8                	sar    %eax
    3596:	89 c2                	mov    %eax,%edx
    3598:	8b 45 0c             	mov    0xc(%ebp),%eax
    359b:	01 d0                	add    %edx,%eax
    359d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    35a0:	8b 45 08             	mov    0x8(%ebp),%eax
    35a3:	8b 00                	mov    (%eax),%eax
    35a5:	ff 75 fc             	pushl  -0x4(%ebp)
    35a8:	50                   	push   %eax
    35a9:	e8 8c fd ff ff       	call   333a <lodepng_realloc>
    35ae:	83 c4 08             	add    $0x8,%esp
    35b1:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    35b4:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    35b8:	74 13                	je     35cd <ucvector_resize+0x50>
      p->allocsize = newsize;
    35ba:	8b 45 08             	mov    0x8(%ebp),%eax
    35bd:	8b 55 fc             	mov    -0x4(%ebp),%edx
    35c0:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    35c3:	8b 45 08             	mov    0x8(%ebp),%eax
    35c6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    35c9:	89 10                	mov    %edx,(%eax)
    35cb:	eb 07                	jmp    35d4 <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    35cd:	b8 00 00 00 00       	mov    $0x0,%eax
    35d2:	eb 0e                	jmp    35e2 <ucvector_resize+0x65>
  }
  p->size = size;
    35d4:	8b 45 08             	mov    0x8(%ebp),%eax
    35d7:	8b 55 0c             	mov    0xc(%ebp),%edx
    35da:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    35dd:	b8 01 00 00 00       	mov    $0x1,%eax
}
    35e2:	c9                   	leave  
    35e3:	c3                   	ret    

000035e4 <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    35e4:	55                   	push   %ebp
    35e5:	89 e5                	mov    %esp,%ebp
    35e7:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    35ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    35ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    35f0:	8b 45 10             	mov    0x10(%ebp),%eax
    35f3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    35f6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    35f9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    35fc:	8b 45 08             	mov    0x8(%ebp),%eax
    35ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3602:	89 10                	mov    %edx,(%eax)
    3604:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3607:	89 50 04             	mov    %edx,0x4(%eax)
    360a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    360d:	89 50 08             	mov    %edx,0x8(%eax)
}
    3610:	8b 45 08             	mov    0x8(%ebp),%eax
    3613:	c9                   	leave  
    3614:	c2 04 00             	ret    $0x4

00003617 <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    3617:	55                   	push   %ebp
    3618:	89 e5                	mov    %esp,%ebp
    361a:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    361d:	8b 45 08             	mov    0x8(%ebp),%eax
    3620:	8b 00                	mov    (%eax),%eax
    3622:	83 ec 0c             	sub    $0xc,%esp
    3625:	50                   	push   %eax
    3626:	e8 19 fd ff ff       	call   3344 <lodepng_free>
    362b:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    362e:	8b 45 08             	mov    0x8(%ebp),%eax
    3631:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3637:	90                   	nop
    3638:	c9                   	leave  
    3639:	c3                   	ret    

0000363a <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    363a:	55                   	push   %ebp
    363b:	89 e5                	mov    %esp,%ebp
    363d:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    3640:	8b 45 0c             	mov    0xc(%ebp),%eax
    3643:	83 c0 01             	add    $0x1,%eax
    3646:	83 ec 0c             	sub    $0xc,%esp
    3649:	50                   	push   %eax
    364a:	e8 d4 fc ff ff       	call   3323 <lodepng_malloc>
    364f:	83 c4 10             	add    $0x10,%esp
    3652:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    3655:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3659:	74 1f                	je     367a <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    365b:	83 ec 04             	sub    $0x4,%esp
    365e:	ff 75 0c             	pushl  0xc(%ebp)
    3661:	ff 75 08             	pushl  0x8(%ebp)
    3664:	ff 75 f4             	pushl  -0xc(%ebp)
    3667:	e8 f5 fc ff ff       	call   3361 <lodepng_memcpy>
    366c:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    366f:	8b 55 0c             	mov    0xc(%ebp),%edx
    3672:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3675:	01 d0                	add    %edx,%eax
    3677:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    367a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    367d:	c9                   	leave  
    367e:	c3                   	ret    

0000367f <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    367f:	55                   	push   %ebp
    3680:	89 e5                	mov    %esp,%ebp
    3682:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    3685:	ff 75 08             	pushl  0x8(%ebp)
    3688:	e8 32 fd ff ff       	call   33bf <lodepng_strlen>
    368d:	83 c4 04             	add    $0x4,%esp
    3690:	83 ec 08             	sub    $0x8,%esp
    3693:	50                   	push   %eax
    3694:	ff 75 08             	pushl  0x8(%ebp)
    3697:	e8 9e ff ff ff       	call   363a <alloc_string_sized>
    369c:	83 c4 10             	add    $0x10,%esp
}
    369f:	c9                   	leave  
    36a0:	c3                   	ret    

000036a1 <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    36a1:	55                   	push   %ebp
    36a2:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    36a4:	8b 45 08             	mov    0x8(%ebp),%eax
    36a7:	0f b6 00             	movzbl (%eax),%eax
    36aa:	0f b6 c0             	movzbl %al,%eax
    36ad:	c1 e0 18             	shl    $0x18,%eax
    36b0:	89 c2                	mov    %eax,%edx
    36b2:	8b 45 08             	mov    0x8(%ebp),%eax
    36b5:	83 c0 01             	add    $0x1,%eax
    36b8:	0f b6 00             	movzbl (%eax),%eax
    36bb:	0f b6 c0             	movzbl %al,%eax
    36be:	c1 e0 10             	shl    $0x10,%eax
    36c1:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    36c3:	8b 45 08             	mov    0x8(%ebp),%eax
    36c6:	83 c0 02             	add    $0x2,%eax
    36c9:	0f b6 00             	movzbl (%eax),%eax
    36cc:	0f b6 c0             	movzbl %al,%eax
    36cf:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    36d2:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    36d4:	8b 45 08             	mov    0x8(%ebp),%eax
    36d7:	83 c0 03             	add    $0x3,%eax
    36da:	0f b6 00             	movzbl (%eax),%eax
    36dd:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    36e0:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    36e2:	5d                   	pop    %ebp
    36e3:	c3                   	ret    

000036e4 <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    36e4:	55                   	push   %ebp
    36e5:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    36e7:	8b 45 0c             	mov    0xc(%ebp),%eax
    36ea:	c1 e8 18             	shr    $0x18,%eax
    36ed:	89 c2                	mov    %eax,%edx
    36ef:	8b 45 08             	mov    0x8(%ebp),%eax
    36f2:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    36f4:	8b 45 08             	mov    0x8(%ebp),%eax
    36f7:	83 c0 01             	add    $0x1,%eax
    36fa:	8b 55 0c             	mov    0xc(%ebp),%edx
    36fd:	c1 ea 10             	shr    $0x10,%edx
    3700:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    3702:	8b 45 08             	mov    0x8(%ebp),%eax
    3705:	83 c0 02             	add    $0x2,%eax
    3708:	8b 55 0c             	mov    0xc(%ebp),%edx
    370b:	c1 ea 08             	shr    $0x8,%edx
    370e:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    3710:	8b 45 08             	mov    0x8(%ebp),%eax
    3713:	83 c0 03             	add    $0x3,%eax
    3716:	8b 55 0c             	mov    0xc(%ebp),%edx
    3719:	88 10                	mov    %dl,(%eax)
}
    371b:	90                   	nop
    371c:	5d                   	pop    %ebp
    371d:	c3                   	ret    

0000371e <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    371e:	55                   	push   %ebp
    371f:	89 e5                	mov    %esp,%ebp
    3721:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    3724:	83 ec 08             	sub    $0x8,%esp
    3727:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    372a:	50                   	push   %eax
    372b:	ff 75 08             	pushl  0x8(%ebp)
    372e:	e8 b7 ca ff ff       	call   1ea <stat>
    3733:	83 c4 10             	add    $0x10,%esp
  return s.size;
    3736:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3739:	c9                   	leave  
    373a:	c3                   	ret    

0000373b <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    373b:	55                   	push   %ebp
    373c:	89 e5                	mov    %esp,%ebp
    373e:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    3741:	83 ec 08             	sub    $0x8,%esp
    3744:	6a 00                	push   $0x0
    3746:	ff 75 10             	pushl  0x10(%ebp)
    3749:	e8 bb cb ff ff       	call   309 <open>
    374e:	83 c4 10             	add    $0x10,%esp
    3751:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    3754:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3758:	79 07                	jns    3761 <lodepng_buffer_file+0x26>
  {
      return -1;
    375a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    375f:	eb 19                	jmp    377a <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    3761:	83 ec 04             	sub    $0x4,%esp
    3764:	ff 75 0c             	pushl  0xc(%ebp)
    3767:	ff 75 08             	pushl  0x8(%ebp)
    376a:	ff 75 f4             	pushl  -0xc(%ebp)
    376d:	e8 6f cb ff ff       	call   2e1 <read>
    3772:	83 c4 10             	add    $0x10,%esp
  return 0;
    3775:	b8 00 00 00 00       	mov    $0x0,%eax
}
    377a:	c9                   	leave  
    377b:	c3                   	ret    

0000377c <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    377c:	55                   	push   %ebp
    377d:	89 e5                	mov    %esp,%ebp
    377f:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    3782:	83 ec 0c             	sub    $0xc,%esp
    3785:	ff 75 10             	pushl  0x10(%ebp)
    3788:	e8 91 ff ff ff       	call   371e <lodepng_filesize>
    378d:	83 c4 10             	add    $0x10,%esp
    3790:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    3793:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3797:	79 07                	jns    37a0 <lodepng_load_file+0x24>
    3799:	b8 4e 00 00 00       	mov    $0x4e,%eax
    379e:	eb 4a                	jmp    37ea <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    37a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    37a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    37a6:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    37a8:	83 ec 0c             	sub    $0xc,%esp
    37ab:	ff 75 f4             	pushl  -0xc(%ebp)
    37ae:	e8 70 fb ff ff       	call   3323 <lodepng_malloc>
    37b3:	83 c4 10             	add    $0x10,%esp
    37b6:	89 c2                	mov    %eax,%edx
    37b8:	8b 45 08             	mov    0x8(%ebp),%eax
    37bb:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    37bd:	8b 45 08             	mov    0x8(%ebp),%eax
    37c0:	8b 00                	mov    (%eax),%eax
    37c2:	85 c0                	test   %eax,%eax
    37c4:	75 0d                	jne    37d3 <lodepng_load_file+0x57>
    37c6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    37ca:	7e 07                	jle    37d3 <lodepng_load_file+0x57>
    37cc:	b8 53 00 00 00       	mov    $0x53,%eax
    37d1:	eb 17                	jmp    37ea <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    37d3:	8b 45 08             	mov    0x8(%ebp),%eax
    37d6:	8b 00                	mov    (%eax),%eax
    37d8:	83 ec 04             	sub    $0x4,%esp
    37db:	ff 75 10             	pushl  0x10(%ebp)
    37de:	ff 75 f4             	pushl  -0xc(%ebp)
    37e1:	50                   	push   %eax
    37e2:	e8 54 ff ff ff       	call   373b <lodepng_buffer_file>
    37e7:	83 c4 10             	add    $0x10,%esp
}
    37ea:	c9                   	leave  
    37eb:	c3                   	ret    

000037ec <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    37ec:	55                   	push   %ebp
    37ed:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    37ef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    37f4:	5d                   	pop    %ebp
    37f5:	c3                   	ret    

000037f6 <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    37f6:	55                   	push   %ebp
    37f7:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    37f9:	8b 45 08             	mov    0x8(%ebp),%eax
    37fc:	8b 55 0c             	mov    0xc(%ebp),%edx
    37ff:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    3801:	8b 45 08             	mov    0x8(%ebp),%eax
    3804:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    3808:	90                   	nop
    3809:	5d                   	pop    %ebp
    380a:	c3                   	ret    

0000380b <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    380b:	55                   	push   %ebp
    380c:	89 e5                	mov    %esp,%ebp
    380e:	56                   	push   %esi
    380f:	53                   	push   %ebx
    3810:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    3813:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    3817:	0f 85 aa 00 00 00    	jne    38c7 <writeBits+0xbc>
    WRITEBIT(writer, value);
    381d:	8b 45 08             	mov    0x8(%ebp),%eax
    3820:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3824:	0f b6 c0             	movzbl %al,%eax
    3827:	83 e0 07             	and    $0x7,%eax
    382a:	85 c0                	test   %eax,%eax
    382c:	75 39                	jne    3867 <writeBits+0x5c>
    382e:	8b 45 08             	mov    0x8(%ebp),%eax
    3831:	8b 00                	mov    (%eax),%eax
    3833:	8b 40 04             	mov    0x4(%eax),%eax
    3836:	8d 50 01             	lea    0x1(%eax),%edx
    3839:	8b 45 08             	mov    0x8(%ebp),%eax
    383c:	8b 00                	mov    (%eax),%eax
    383e:	52                   	push   %edx
    383f:	50                   	push   %eax
    3840:	e8 38 fd ff ff       	call   357d <ucvector_resize>
    3845:	83 c4 08             	add    $0x8,%esp
    3848:	85 c0                	test   %eax,%eax
    384a:	0f 84 44 01 00 00    	je     3994 <writeBits+0x189>
    3850:	8b 45 08             	mov    0x8(%ebp),%eax
    3853:	8b 00                	mov    (%eax),%eax
    3855:	8b 10                	mov    (%eax),%edx
    3857:	8b 45 08             	mov    0x8(%ebp),%eax
    385a:	8b 00                	mov    (%eax),%eax
    385c:	8b 40 04             	mov    0x4(%eax),%eax
    385f:	83 e8 01             	sub    $0x1,%eax
    3862:	01 d0                	add    %edx,%eax
    3864:	c6 00 00             	movb   $0x0,(%eax)
    3867:	8b 45 08             	mov    0x8(%ebp),%eax
    386a:	8b 00                	mov    (%eax),%eax
    386c:	8b 10                	mov    (%eax),%edx
    386e:	8b 45 08             	mov    0x8(%ebp),%eax
    3871:	8b 00                	mov    (%eax),%eax
    3873:	8b 40 04             	mov    0x4(%eax),%eax
    3876:	83 e8 01             	sub    $0x1,%eax
    3879:	01 c2                	add    %eax,%edx
    387b:	8b 45 08             	mov    0x8(%ebp),%eax
    387e:	8b 00                	mov    (%eax),%eax
    3880:	8b 08                	mov    (%eax),%ecx
    3882:	8b 45 08             	mov    0x8(%ebp),%eax
    3885:	8b 00                	mov    (%eax),%eax
    3887:	8b 40 04             	mov    0x4(%eax),%eax
    388a:	83 e8 01             	sub    $0x1,%eax
    388d:	01 c8                	add    %ecx,%eax
    388f:	0f b6 00             	movzbl (%eax),%eax
    3892:	88 45 e7             	mov    %al,-0x19(%ebp)
    3895:	8b 45 08             	mov    0x8(%ebp),%eax
    3898:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    389c:	0f b6 c0             	movzbl %al,%eax
    389f:	83 e0 07             	and    $0x7,%eax
    38a2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    38a5:	89 de                	mov    %ebx,%esi
    38a7:	89 c1                	mov    %eax,%ecx
    38a9:	d3 e6                	shl    %cl,%esi
    38ab:	89 f0                	mov    %esi,%eax
    38ad:	0a 45 e7             	or     -0x19(%ebp),%al
    38b0:	88 02                	mov    %al,(%edx)
    38b2:	8b 45 08             	mov    0x8(%ebp),%eax
    38b5:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    38b9:	8d 50 01             	lea    0x1(%eax),%edx
    38bc:	8b 45 08             	mov    0x8(%ebp),%eax
    38bf:	88 50 04             	mov    %dl,0x4(%eax)
    38c2:	e9 d1 00 00 00       	jmp    3998 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    38c7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    38ce:	e9 b3 00 00 00       	jmp    3986 <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    38d3:	8b 45 08             	mov    0x8(%ebp),%eax
    38d6:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    38da:	0f b6 c0             	movzbl %al,%eax
    38dd:	83 e0 07             	and    $0x7,%eax
    38e0:	85 c0                	test   %eax,%eax
    38e2:	75 39                	jne    391d <writeBits+0x112>
    38e4:	8b 45 08             	mov    0x8(%ebp),%eax
    38e7:	8b 00                	mov    (%eax),%eax
    38e9:	8b 40 04             	mov    0x4(%eax),%eax
    38ec:	8d 50 01             	lea    0x1(%eax),%edx
    38ef:	8b 45 08             	mov    0x8(%ebp),%eax
    38f2:	8b 00                	mov    (%eax),%eax
    38f4:	52                   	push   %edx
    38f5:	50                   	push   %eax
    38f6:	e8 82 fc ff ff       	call   357d <ucvector_resize>
    38fb:	83 c4 08             	add    $0x8,%esp
    38fe:	85 c0                	test   %eax,%eax
    3900:	0f 84 91 00 00 00    	je     3997 <writeBits+0x18c>
    3906:	8b 45 08             	mov    0x8(%ebp),%eax
    3909:	8b 00                	mov    (%eax),%eax
    390b:	8b 10                	mov    (%eax),%edx
    390d:	8b 45 08             	mov    0x8(%ebp),%eax
    3910:	8b 00                	mov    (%eax),%eax
    3912:	8b 40 04             	mov    0x4(%eax),%eax
    3915:	83 e8 01             	sub    $0x1,%eax
    3918:	01 d0                	add    %edx,%eax
    391a:	c6 00 00             	movb   $0x0,(%eax)
    391d:	8b 45 08             	mov    0x8(%ebp),%eax
    3920:	8b 00                	mov    (%eax),%eax
    3922:	8b 10                	mov    (%eax),%edx
    3924:	8b 45 08             	mov    0x8(%ebp),%eax
    3927:	8b 00                	mov    (%eax),%eax
    3929:	8b 40 04             	mov    0x4(%eax),%eax
    392c:	83 e8 01             	sub    $0x1,%eax
    392f:	01 c2                	add    %eax,%edx
    3931:	8b 45 08             	mov    0x8(%ebp),%eax
    3934:	8b 00                	mov    (%eax),%eax
    3936:	8b 08                	mov    (%eax),%ecx
    3938:	8b 45 08             	mov    0x8(%ebp),%eax
    393b:	8b 00                	mov    (%eax),%eax
    393d:	8b 40 04             	mov    0x4(%eax),%eax
    3940:	83 e8 01             	sub    $0x1,%eax
    3943:	01 c8                	add    %ecx,%eax
    3945:	0f b6 00             	movzbl (%eax),%eax
    3948:	89 c6                	mov    %eax,%esi
    394a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    394d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3950:	89 c1                	mov    %eax,%ecx
    3952:	d3 eb                	shr    %cl,%ebx
    3954:	89 d8                	mov    %ebx,%eax
    3956:	83 e0 01             	and    $0x1,%eax
    3959:	89 c3                	mov    %eax,%ebx
    395b:	8b 45 08             	mov    0x8(%ebp),%eax
    395e:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3962:	0f b6 c0             	movzbl %al,%eax
    3965:	83 e0 07             	and    $0x7,%eax
    3968:	89 c1                	mov    %eax,%ecx
    396a:	d3 e3                	shl    %cl,%ebx
    396c:	89 d8                	mov    %ebx,%eax
    396e:	09 f0                	or     %esi,%eax
    3970:	88 02                	mov    %al,(%edx)
    3972:	8b 45 08             	mov    0x8(%ebp),%eax
    3975:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3979:	8d 50 01             	lea    0x1(%eax),%edx
    397c:	8b 45 08             	mov    0x8(%ebp),%eax
    397f:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3982:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3986:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3989:	3b 45 10             	cmp    0x10(%ebp),%eax
    398c:	0f 85 41 ff ff ff    	jne    38d3 <writeBits+0xc8>
    3992:	eb 04                	jmp    3998 <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    3994:	90                   	nop
    3995:	eb 01                	jmp    3998 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3997:	90                   	nop
    }
  }
}
    3998:	8d 65 f8             	lea    -0x8(%ebp),%esp
    399b:	5b                   	pop    %ebx
    399c:	5e                   	pop    %esi
    399d:	5d                   	pop    %ebp
    399e:	c3                   	ret    

0000399f <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    399f:	55                   	push   %ebp
    39a0:	89 e5                	mov    %esp,%ebp
    39a2:	56                   	push   %esi
    39a3:	53                   	push   %ebx
    39a4:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    39a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    39ae:	e9 bd 00 00 00       	jmp    3a70 <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    39b3:	8b 45 08             	mov    0x8(%ebp),%eax
    39b6:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    39ba:	0f b6 c0             	movzbl %al,%eax
    39bd:	83 e0 07             	and    $0x7,%eax
    39c0:	85 c0                	test   %eax,%eax
    39c2:	75 39                	jne    39fd <writeBitsReversed+0x5e>
    39c4:	8b 45 08             	mov    0x8(%ebp),%eax
    39c7:	8b 00                	mov    (%eax),%eax
    39c9:	8b 40 04             	mov    0x4(%eax),%eax
    39cc:	8d 50 01             	lea    0x1(%eax),%edx
    39cf:	8b 45 08             	mov    0x8(%ebp),%eax
    39d2:	8b 00                	mov    (%eax),%eax
    39d4:	52                   	push   %edx
    39d5:	50                   	push   %eax
    39d6:	e8 a2 fb ff ff       	call   357d <ucvector_resize>
    39db:	83 c4 08             	add    $0x8,%esp
    39de:	85 c0                	test   %eax,%eax
    39e0:	0f 84 98 00 00 00    	je     3a7e <writeBitsReversed+0xdf>
    39e6:	8b 45 08             	mov    0x8(%ebp),%eax
    39e9:	8b 00                	mov    (%eax),%eax
    39eb:	8b 10                	mov    (%eax),%edx
    39ed:	8b 45 08             	mov    0x8(%ebp),%eax
    39f0:	8b 00                	mov    (%eax),%eax
    39f2:	8b 40 04             	mov    0x4(%eax),%eax
    39f5:	83 e8 01             	sub    $0x1,%eax
    39f8:	01 d0                	add    %edx,%eax
    39fa:	c6 00 00             	movb   $0x0,(%eax)
    39fd:	8b 45 08             	mov    0x8(%ebp),%eax
    3a00:	8b 00                	mov    (%eax),%eax
    3a02:	8b 10                	mov    (%eax),%edx
    3a04:	8b 45 08             	mov    0x8(%ebp),%eax
    3a07:	8b 00                	mov    (%eax),%eax
    3a09:	8b 40 04             	mov    0x4(%eax),%eax
    3a0c:	83 e8 01             	sub    $0x1,%eax
    3a0f:	01 c2                	add    %eax,%edx
    3a11:	8b 45 08             	mov    0x8(%ebp),%eax
    3a14:	8b 00                	mov    (%eax),%eax
    3a16:	8b 08                	mov    (%eax),%ecx
    3a18:	8b 45 08             	mov    0x8(%ebp),%eax
    3a1b:	8b 00                	mov    (%eax),%eax
    3a1d:	8b 40 04             	mov    0x4(%eax),%eax
    3a20:	83 e8 01             	sub    $0x1,%eax
    3a23:	01 c8                	add    %ecx,%eax
    3a25:	0f b6 00             	movzbl (%eax),%eax
    3a28:	89 c6                	mov    %eax,%esi
    3a2a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    3a2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a30:	29 c1                	sub    %eax,%ecx
    3a32:	89 c8                	mov    %ecx,%eax
    3a34:	83 e8 01             	sub    $0x1,%eax
    3a37:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3a3a:	89 c1                	mov    %eax,%ecx
    3a3c:	d3 eb                	shr    %cl,%ebx
    3a3e:	89 d8                	mov    %ebx,%eax
    3a40:	83 e0 01             	and    $0x1,%eax
    3a43:	89 c3                	mov    %eax,%ebx
    3a45:	8b 45 08             	mov    0x8(%ebp),%eax
    3a48:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a4c:	0f b6 c0             	movzbl %al,%eax
    3a4f:	83 e0 07             	and    $0x7,%eax
    3a52:	89 c1                	mov    %eax,%ecx
    3a54:	d3 e3                	shl    %cl,%ebx
    3a56:	89 d8                	mov    %ebx,%eax
    3a58:	09 f0                	or     %esi,%eax
    3a5a:	88 02                	mov    %al,(%edx)
    3a5c:	8b 45 08             	mov    0x8(%ebp),%eax
    3a5f:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a63:	8d 50 01             	lea    0x1(%eax),%edx
    3a66:	8b 45 08             	mov    0x8(%ebp),%eax
    3a69:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3a6c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3a70:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a73:	3b 45 10             	cmp    0x10(%ebp),%eax
    3a76:	0f 85 37 ff ff ff    	jne    39b3 <writeBitsReversed+0x14>
    3a7c:	eb 01                	jmp    3a7f <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3a7e:	90                   	nop
  }
}
    3a7f:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3a82:	5b                   	pop    %ebx
    3a83:	5e                   	pop    %esi
    3a84:	5d                   	pop    %ebp
    3a85:	c3                   	ret    

00003a86 <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    3a86:	55                   	push   %ebp
    3a87:	89 e5                	mov    %esp,%ebp
    3a89:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    3a8c:	8b 45 08             	mov    0x8(%ebp),%eax
    3a8f:	8b 55 0c             	mov    0xc(%ebp),%edx
    3a92:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    3a94:	8b 45 08             	mov    0x8(%ebp),%eax
    3a97:	8b 55 10             	mov    0x10(%ebp),%edx
    3a9a:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    3a9d:	8b 45 08             	mov    0x8(%ebp),%eax
    3aa0:	83 c0 08             	add    $0x8,%eax
    3aa3:	50                   	push   %eax
    3aa4:	6a 08                	push   $0x8
    3aa6:	ff 75 10             	pushl  0x10(%ebp)
    3aa9:	e8 59 f9 ff ff       	call   3407 <lodepng_mulofl>
    3aae:	83 c4 0c             	add    $0xc,%esp
    3ab1:	85 c0                	test   %eax,%eax
    3ab3:	74 07                	je     3abc <LodePNGBitReader_init+0x36>
    3ab5:	b8 69 00 00 00       	mov    $0x69,%eax
    3aba:	eb 39                	jmp    3af5 <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    3abc:	8b 45 08             	mov    0x8(%ebp),%eax
    3abf:	8b 40 08             	mov    0x8(%eax),%eax
    3ac2:	8d 55 fc             	lea    -0x4(%ebp),%edx
    3ac5:	52                   	push   %edx
    3ac6:	6a 40                	push   $0x40
    3ac8:	50                   	push   %eax
    3ac9:	e8 19 f9 ff ff       	call   33e7 <lodepng_addofl>
    3ace:	83 c4 0c             	add    $0xc,%esp
    3ad1:	85 c0                	test   %eax,%eax
    3ad3:	74 07                	je     3adc <LodePNGBitReader_init+0x56>
    3ad5:	b8 69 00 00 00       	mov    $0x69,%eax
    3ada:	eb 19                	jmp    3af5 <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    3adc:	8b 45 08             	mov    0x8(%ebp),%eax
    3adf:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    3ae6:	8b 45 08             	mov    0x8(%ebp),%eax
    3ae9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    3af0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3af5:	c9                   	leave  
    3af6:	c3                   	ret    

00003af7 <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    3af7:	55                   	push   %ebp
    3af8:	89 e5                	mov    %esp,%ebp
    3afa:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3afd:	8b 45 08             	mov    0x8(%ebp),%eax
    3b00:	8b 40 0c             	mov    0xc(%eax),%eax
    3b03:	c1 f8 03             	sar    $0x3,%eax
    3b06:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3b09:	8b 45 08             	mov    0x8(%ebp),%eax
    3b0c:	8b 40 04             	mov    0x4(%eax),%eax
    3b0f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    3b12:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3b15:	8d 50 01             	lea    0x1(%eax),%edx
    3b18:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3b1b:	39 c2                	cmp    %eax,%edx
    3b1d:	73 4e                	jae    3b6d <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    3b1f:	8b 45 08             	mov    0x8(%ebp),%eax
    3b22:	8b 10                	mov    (%eax),%edx
    3b24:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3b27:	01 d0                	add    %edx,%eax
    3b29:	0f b6 00             	movzbl (%eax),%eax
    3b2c:	0f b6 d0             	movzbl %al,%edx
    3b2f:	8b 45 08             	mov    0x8(%ebp),%eax
    3b32:	8b 00                	mov    (%eax),%eax
    3b34:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3b37:	83 c1 01             	add    $0x1,%ecx
    3b3a:	01 c8                	add    %ecx,%eax
    3b3c:	0f b6 00             	movzbl (%eax),%eax
    3b3f:	0f b6 c0             	movzbl %al,%eax
    3b42:	c1 e0 08             	shl    $0x8,%eax
    3b45:	09 c2                	or     %eax,%edx
    3b47:	8b 45 08             	mov    0x8(%ebp),%eax
    3b4a:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3b4d:	8b 45 08             	mov    0x8(%ebp),%eax
    3b50:	8b 50 10             	mov    0x10(%eax),%edx
    3b53:	8b 45 08             	mov    0x8(%ebp),%eax
    3b56:	8b 40 0c             	mov    0xc(%eax),%eax
    3b59:	83 e0 07             	and    $0x7,%eax
    3b5c:	89 c1                	mov    %eax,%ecx
    3b5e:	d3 ea                	shr    %cl,%edx
    3b60:	8b 45 08             	mov    0x8(%ebp),%eax
    3b63:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3b66:	b8 01 00 00 00       	mov    $0x1,%eax
    3b6b:	eb 64                	jmp    3bd1 <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    3b6d:	8b 45 08             	mov    0x8(%ebp),%eax
    3b70:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3b77:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3b7a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3b7d:	39 c2                	cmp    %eax,%edx
    3b7f:	73 1e                	jae    3b9f <ensureBits9+0xa8>
    3b81:	8b 45 08             	mov    0x8(%ebp),%eax
    3b84:	8b 50 10             	mov    0x10(%eax),%edx
    3b87:	8b 45 08             	mov    0x8(%ebp),%eax
    3b8a:	8b 08                	mov    (%eax),%ecx
    3b8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3b8f:	01 c8                	add    %ecx,%eax
    3b91:	0f b6 00             	movzbl (%eax),%eax
    3b94:	0f b6 c0             	movzbl %al,%eax
    3b97:	09 c2                	or     %eax,%edx
    3b99:	8b 45 08             	mov    0x8(%ebp),%eax
    3b9c:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3b9f:	8b 45 08             	mov    0x8(%ebp),%eax
    3ba2:	8b 50 10             	mov    0x10(%eax),%edx
    3ba5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ba8:	8b 40 0c             	mov    0xc(%eax),%eax
    3bab:	83 e0 07             	and    $0x7,%eax
    3bae:	89 c1                	mov    %eax,%ecx
    3bb0:	d3 ea                	shr    %cl,%edx
    3bb2:	8b 45 08             	mov    0x8(%ebp),%eax
    3bb5:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3bb8:	8b 45 08             	mov    0x8(%ebp),%eax
    3bbb:	8b 50 0c             	mov    0xc(%eax),%edx
    3bbe:	8b 45 0c             	mov    0xc(%ebp),%eax
    3bc1:	01 c2                	add    %eax,%edx
    3bc3:	8b 45 08             	mov    0x8(%ebp),%eax
    3bc6:	8b 40 08             	mov    0x8(%eax),%eax
    3bc9:	39 c2                	cmp    %eax,%edx
    3bcb:	0f 9e c0             	setle  %al
    3bce:	0f b6 c0             	movzbl %al,%eax
  }
}
    3bd1:	c9                   	leave  
    3bd2:	c3                   	ret    

00003bd3 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    3bd3:	55                   	push   %ebp
    3bd4:	89 e5                	mov    %esp,%ebp
    3bd6:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3bd9:	8b 45 08             	mov    0x8(%ebp),%eax
    3bdc:	8b 40 0c             	mov    0xc(%eax),%eax
    3bdf:	c1 f8 03             	sar    $0x3,%eax
    3be2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3be5:	8b 45 08             	mov    0x8(%ebp),%eax
    3be8:	8b 40 04             	mov    0x4(%eax),%eax
    3beb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    3bee:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3bf1:	8d 50 02             	lea    0x2(%eax),%edx
    3bf4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3bf7:	39 c2                	cmp    %eax,%edx
    3bf9:	73 6d                	jae    3c68 <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3bfb:	8b 45 08             	mov    0x8(%ebp),%eax
    3bfe:	8b 10                	mov    (%eax),%edx
    3c00:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c03:	01 d0                	add    %edx,%eax
    3c05:	0f b6 00             	movzbl (%eax),%eax
    3c08:	0f b6 d0             	movzbl %al,%edx
    3c0b:	8b 45 08             	mov    0x8(%ebp),%eax
    3c0e:	8b 00                	mov    (%eax),%eax
    3c10:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3c13:	83 c1 01             	add    $0x1,%ecx
    3c16:	01 c8                	add    %ecx,%eax
    3c18:	0f b6 00             	movzbl (%eax),%eax
    3c1b:	0f b6 c0             	movzbl %al,%eax
    3c1e:	c1 e0 08             	shl    $0x8,%eax
    3c21:	89 d1                	mov    %edx,%ecx
    3c23:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    3c25:	8b 45 08             	mov    0x8(%ebp),%eax
    3c28:	8b 00                	mov    (%eax),%eax
    3c2a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3c2d:	83 c2 02             	add    $0x2,%edx
    3c30:	01 d0                	add    %edx,%eax
    3c32:	0f b6 00             	movzbl (%eax),%eax
    3c35:	0f b6 c0             	movzbl %al,%eax
    3c38:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3c3b:	09 c1                	or     %eax,%ecx
    3c3d:	89 ca                	mov    %ecx,%edx
    3c3f:	8b 45 08             	mov    0x8(%ebp),%eax
    3c42:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    3c45:	8b 45 08             	mov    0x8(%ebp),%eax
    3c48:	8b 50 10             	mov    0x10(%eax),%edx
    3c4b:	8b 45 08             	mov    0x8(%ebp),%eax
    3c4e:	8b 40 0c             	mov    0xc(%eax),%eax
    3c51:	83 e0 07             	and    $0x7,%eax
    3c54:	89 c1                	mov    %eax,%ecx
    3c56:	d3 ea                	shr    %cl,%edx
    3c58:	8b 45 08             	mov    0x8(%ebp),%eax
    3c5b:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3c5e:	b8 01 00 00 00       	mov    $0x1,%eax
    3c63:	e9 95 00 00 00       	jmp    3cfd <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    3c68:	8b 45 08             	mov    0x8(%ebp),%eax
    3c6b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3c72:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3c75:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c78:	39 c2                	cmp    %eax,%edx
    3c7a:	73 1e                	jae    3c9a <ensureBits17+0xc7>
    3c7c:	8b 45 08             	mov    0x8(%ebp),%eax
    3c7f:	8b 50 10             	mov    0x10(%eax),%edx
    3c82:	8b 45 08             	mov    0x8(%ebp),%eax
    3c85:	8b 08                	mov    (%eax),%ecx
    3c87:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c8a:	01 c8                	add    %ecx,%eax
    3c8c:	0f b6 00             	movzbl (%eax),%eax
    3c8f:	0f b6 c0             	movzbl %al,%eax
    3c92:	09 c2                	or     %eax,%edx
    3c94:	8b 45 08             	mov    0x8(%ebp),%eax
    3c97:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3c9a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c9d:	8d 50 01             	lea    0x1(%eax),%edx
    3ca0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ca3:	39 c2                	cmp    %eax,%edx
    3ca5:	73 24                	jae    3ccb <ensureBits17+0xf8>
    3ca7:	8b 45 08             	mov    0x8(%ebp),%eax
    3caa:	8b 50 10             	mov    0x10(%eax),%edx
    3cad:	8b 45 08             	mov    0x8(%ebp),%eax
    3cb0:	8b 00                	mov    (%eax),%eax
    3cb2:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3cb5:	83 c1 01             	add    $0x1,%ecx
    3cb8:	01 c8                	add    %ecx,%eax
    3cba:	0f b6 00             	movzbl (%eax),%eax
    3cbd:	0f b6 c0             	movzbl %al,%eax
    3cc0:	c1 e0 08             	shl    $0x8,%eax
    3cc3:	09 c2                	or     %eax,%edx
    3cc5:	8b 45 08             	mov    0x8(%ebp),%eax
    3cc8:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3ccb:	8b 45 08             	mov    0x8(%ebp),%eax
    3cce:	8b 50 10             	mov    0x10(%eax),%edx
    3cd1:	8b 45 08             	mov    0x8(%ebp),%eax
    3cd4:	8b 40 0c             	mov    0xc(%eax),%eax
    3cd7:	83 e0 07             	and    $0x7,%eax
    3cda:	89 c1                	mov    %eax,%ecx
    3cdc:	d3 ea                	shr    %cl,%edx
    3cde:	8b 45 08             	mov    0x8(%ebp),%eax
    3ce1:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3ce4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ce7:	8b 50 0c             	mov    0xc(%eax),%edx
    3cea:	8b 45 0c             	mov    0xc(%ebp),%eax
    3ced:	01 c2                	add    %eax,%edx
    3cef:	8b 45 08             	mov    0x8(%ebp),%eax
    3cf2:	8b 40 08             	mov    0x8(%eax),%eax
    3cf5:	39 c2                	cmp    %eax,%edx
    3cf7:	0f 9e c0             	setle  %al
    3cfa:	0f b6 c0             	movzbl %al,%eax
  }
}
    3cfd:	c9                   	leave  
    3cfe:	c3                   	ret    

00003cff <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    3cff:	55                   	push   %ebp
    3d00:	89 e5                	mov    %esp,%ebp
    3d02:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3d05:	8b 45 08             	mov    0x8(%ebp),%eax
    3d08:	8b 40 0c             	mov    0xc(%eax),%eax
    3d0b:	c1 f8 03             	sar    $0x3,%eax
    3d0e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3d11:	8b 45 08             	mov    0x8(%ebp),%eax
    3d14:	8b 40 04             	mov    0x4(%eax),%eax
    3d17:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    3d1a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d1d:	8d 50 03             	lea    0x3(%eax),%edx
    3d20:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3d23:	39 c2                	cmp    %eax,%edx
    3d25:	0f 83 85 00 00 00    	jae    3db0 <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d2b:	8b 45 08             	mov    0x8(%ebp),%eax
    3d2e:	8b 10                	mov    (%eax),%edx
    3d30:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d33:	01 d0                	add    %edx,%eax
    3d35:	0f b6 00             	movzbl (%eax),%eax
    3d38:	0f b6 d0             	movzbl %al,%edx
    3d3b:	8b 45 08             	mov    0x8(%ebp),%eax
    3d3e:	8b 00                	mov    (%eax),%eax
    3d40:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3d43:	83 c1 01             	add    $0x1,%ecx
    3d46:	01 c8                	add    %ecx,%eax
    3d48:	0f b6 00             	movzbl (%eax),%eax
    3d4b:	0f b6 c0             	movzbl %al,%eax
    3d4e:	c1 e0 08             	shl    $0x8,%eax
    3d51:	89 d1                	mov    %edx,%ecx
    3d53:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3d55:	8b 45 08             	mov    0x8(%ebp),%eax
    3d58:	8b 00                	mov    (%eax),%eax
    3d5a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d5d:	83 c2 02             	add    $0x2,%edx
    3d60:	01 d0                	add    %edx,%eax
    3d62:	0f b6 00             	movzbl (%eax),%eax
    3d65:	0f b6 c0             	movzbl %al,%eax
    3d68:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d6b:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3d6d:	8b 45 08             	mov    0x8(%ebp),%eax
    3d70:	8b 00                	mov    (%eax),%eax
    3d72:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d75:	83 c2 03             	add    $0x3,%edx
    3d78:	01 d0                	add    %edx,%eax
    3d7a:	0f b6 00             	movzbl (%eax),%eax
    3d7d:	0f b6 c0             	movzbl %al,%eax
    3d80:	c1 e0 18             	shl    $0x18,%eax
    3d83:	09 c1                	or     %eax,%ecx
    3d85:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d87:	8b 45 08             	mov    0x8(%ebp),%eax
    3d8a:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3d8d:	8b 45 08             	mov    0x8(%ebp),%eax
    3d90:	8b 50 10             	mov    0x10(%eax),%edx
    3d93:	8b 45 08             	mov    0x8(%ebp),%eax
    3d96:	8b 40 0c             	mov    0xc(%eax),%eax
    3d99:	83 e0 07             	and    $0x7,%eax
    3d9c:	89 c1                	mov    %eax,%ecx
    3d9e:	d3 ea                	shr    %cl,%edx
    3da0:	8b 45 08             	mov    0x8(%ebp),%eax
    3da3:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3da6:	b8 01 00 00 00       	mov    $0x1,%eax
    3dab:	e9 c6 00 00 00       	jmp    3e76 <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    3db0:	8b 45 08             	mov    0x8(%ebp),%eax
    3db3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3dba:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3dbd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3dc0:	39 c2                	cmp    %eax,%edx
    3dc2:	73 1e                	jae    3de2 <ensureBits25+0xe3>
    3dc4:	8b 45 08             	mov    0x8(%ebp),%eax
    3dc7:	8b 50 10             	mov    0x10(%eax),%edx
    3dca:	8b 45 08             	mov    0x8(%ebp),%eax
    3dcd:	8b 08                	mov    (%eax),%ecx
    3dcf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3dd2:	01 c8                	add    %ecx,%eax
    3dd4:	0f b6 00             	movzbl (%eax),%eax
    3dd7:	0f b6 c0             	movzbl %al,%eax
    3dda:	09 c2                	or     %eax,%edx
    3ddc:	8b 45 08             	mov    0x8(%ebp),%eax
    3ddf:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3de2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3de5:	8d 50 01             	lea    0x1(%eax),%edx
    3de8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3deb:	39 c2                	cmp    %eax,%edx
    3ded:	73 24                	jae    3e13 <ensureBits25+0x114>
    3def:	8b 45 08             	mov    0x8(%ebp),%eax
    3df2:	8b 50 10             	mov    0x10(%eax),%edx
    3df5:	8b 45 08             	mov    0x8(%ebp),%eax
    3df8:	8b 00                	mov    (%eax),%eax
    3dfa:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3dfd:	83 c1 01             	add    $0x1,%ecx
    3e00:	01 c8                	add    %ecx,%eax
    3e02:	0f b6 00             	movzbl (%eax),%eax
    3e05:	0f b6 c0             	movzbl %al,%eax
    3e08:	c1 e0 08             	shl    $0x8,%eax
    3e0b:	09 c2                	or     %eax,%edx
    3e0d:	8b 45 08             	mov    0x8(%ebp),%eax
    3e10:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    3e13:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3e16:	8d 50 02             	lea    0x2(%eax),%edx
    3e19:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e1c:	39 c2                	cmp    %eax,%edx
    3e1e:	73 24                	jae    3e44 <ensureBits25+0x145>
    3e20:	8b 45 08             	mov    0x8(%ebp),%eax
    3e23:	8b 50 10             	mov    0x10(%eax),%edx
    3e26:	8b 45 08             	mov    0x8(%ebp),%eax
    3e29:	8b 00                	mov    (%eax),%eax
    3e2b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3e2e:	83 c1 02             	add    $0x2,%ecx
    3e31:	01 c8                	add    %ecx,%eax
    3e33:	0f b6 00             	movzbl (%eax),%eax
    3e36:	0f b6 c0             	movzbl %al,%eax
    3e39:	c1 e0 10             	shl    $0x10,%eax
    3e3c:	09 c2                	or     %eax,%edx
    3e3e:	8b 45 08             	mov    0x8(%ebp),%eax
    3e41:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3e44:	8b 45 08             	mov    0x8(%ebp),%eax
    3e47:	8b 50 10             	mov    0x10(%eax),%edx
    3e4a:	8b 45 08             	mov    0x8(%ebp),%eax
    3e4d:	8b 40 0c             	mov    0xc(%eax),%eax
    3e50:	83 e0 07             	and    $0x7,%eax
    3e53:	89 c1                	mov    %eax,%ecx
    3e55:	d3 ea                	shr    %cl,%edx
    3e57:	8b 45 08             	mov    0x8(%ebp),%eax
    3e5a:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3e5d:	8b 45 08             	mov    0x8(%ebp),%eax
    3e60:	8b 50 0c             	mov    0xc(%eax),%edx
    3e63:	8b 45 0c             	mov    0xc(%ebp),%eax
    3e66:	01 c2                	add    %eax,%edx
    3e68:	8b 45 08             	mov    0x8(%ebp),%eax
    3e6b:	8b 40 08             	mov    0x8(%eax),%eax
    3e6e:	39 c2                	cmp    %eax,%edx
    3e70:	0f 9e c0             	setle  %al
    3e73:	0f b6 c0             	movzbl %al,%eax
  }
}
    3e76:	c9                   	leave  
    3e77:	c3                   	ret    

00003e78 <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    3e78:	55                   	push   %ebp
    3e79:	89 e5                	mov    %esp,%ebp
    3e7b:	53                   	push   %ebx
    3e7c:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3e7f:	8b 45 08             	mov    0x8(%ebp),%eax
    3e82:	8b 40 0c             	mov    0xc(%eax),%eax
    3e85:	c1 f8 03             	sar    $0x3,%eax
    3e88:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    3e8b:	8b 45 08             	mov    0x8(%ebp),%eax
    3e8e:	8b 40 04             	mov    0x4(%eax),%eax
    3e91:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    3e94:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e97:	8d 50 04             	lea    0x4(%eax),%edx
    3e9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3e9d:	39 c2                	cmp    %eax,%edx
    3e9f:	0f 83 c3 00 00 00    	jae    3f68 <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3ea5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ea8:	8b 10                	mov    (%eax),%edx
    3eaa:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ead:	01 d0                	add    %edx,%eax
    3eaf:	0f b6 00             	movzbl (%eax),%eax
    3eb2:	0f b6 d0             	movzbl %al,%edx
    3eb5:	8b 45 08             	mov    0x8(%ebp),%eax
    3eb8:	8b 00                	mov    (%eax),%eax
    3eba:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3ebd:	83 c1 01             	add    $0x1,%ecx
    3ec0:	01 c8                	add    %ecx,%eax
    3ec2:	0f b6 00             	movzbl (%eax),%eax
    3ec5:	0f b6 c0             	movzbl %al,%eax
    3ec8:	c1 e0 08             	shl    $0x8,%eax
    3ecb:	89 d1                	mov    %edx,%ecx
    3ecd:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3ecf:	8b 45 08             	mov    0x8(%ebp),%eax
    3ed2:	8b 00                	mov    (%eax),%eax
    3ed4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3ed7:	83 c2 02             	add    $0x2,%edx
    3eda:	01 d0                	add    %edx,%eax
    3edc:	0f b6 00             	movzbl (%eax),%eax
    3edf:	0f b6 c0             	movzbl %al,%eax
    3ee2:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3ee5:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3ee7:	8b 45 08             	mov    0x8(%ebp),%eax
    3eea:	8b 00                	mov    (%eax),%eax
    3eec:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3eef:	83 c2 03             	add    $0x3,%edx
    3ef2:	01 d0                	add    %edx,%eax
    3ef4:	0f b6 00             	movzbl (%eax),%eax
    3ef7:	0f b6 c0             	movzbl %al,%eax
    3efa:	c1 e0 18             	shl    $0x18,%eax
    3efd:	09 c1                	or     %eax,%ecx
    3eff:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3f01:	8b 45 08             	mov    0x8(%ebp),%eax
    3f04:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3f07:	8b 45 08             	mov    0x8(%ebp),%eax
    3f0a:	8b 50 10             	mov    0x10(%eax),%edx
    3f0d:	8b 45 08             	mov    0x8(%ebp),%eax
    3f10:	8b 40 0c             	mov    0xc(%eax),%eax
    3f13:	83 e0 07             	and    $0x7,%eax
    3f16:	89 c1                	mov    %eax,%ecx
    3f18:	d3 ea                	shr    %cl,%edx
    3f1a:	8b 45 08             	mov    0x8(%ebp),%eax
    3f1d:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    3f20:	8b 45 08             	mov    0x8(%ebp),%eax
    3f23:	8b 50 10             	mov    0x10(%eax),%edx
    3f26:	8b 45 08             	mov    0x8(%ebp),%eax
    3f29:	8b 00                	mov    (%eax),%eax
    3f2b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3f2e:	83 c1 04             	add    $0x4,%ecx
    3f31:	01 c8                	add    %ecx,%eax
    3f33:	0f b6 00             	movzbl (%eax),%eax
    3f36:	0f b6 c0             	movzbl %al,%eax
    3f39:	c1 e0 18             	shl    $0x18,%eax
    3f3c:	89 c3                	mov    %eax,%ebx
    3f3e:	8b 45 08             	mov    0x8(%ebp),%eax
    3f41:	8b 40 0c             	mov    0xc(%eax),%eax
    3f44:	83 e0 07             	and    $0x7,%eax
    3f47:	b9 08 00 00 00       	mov    $0x8,%ecx
    3f4c:	29 c1                	sub    %eax,%ecx
    3f4e:	89 c8                	mov    %ecx,%eax
    3f50:	89 c1                	mov    %eax,%ecx
    3f52:	d3 e3                	shl    %cl,%ebx
    3f54:	89 d8                	mov    %ebx,%eax
    3f56:	09 c2                	or     %eax,%edx
    3f58:	8b 45 08             	mov    0x8(%ebp),%eax
    3f5b:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3f5e:	b8 01 00 00 00       	mov    $0x1,%eax
    3f63:	e9 f7 00 00 00       	jmp    405f <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    3f68:	8b 45 08             	mov    0x8(%ebp),%eax
    3f6b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3f72:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3f75:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3f78:	39 c2                	cmp    %eax,%edx
    3f7a:	73 1e                	jae    3f9a <ensureBits32+0x122>
    3f7c:	8b 45 08             	mov    0x8(%ebp),%eax
    3f7f:	8b 50 10             	mov    0x10(%eax),%edx
    3f82:	8b 45 08             	mov    0x8(%ebp),%eax
    3f85:	8b 08                	mov    (%eax),%ecx
    3f87:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f8a:	01 c8                	add    %ecx,%eax
    3f8c:	0f b6 00             	movzbl (%eax),%eax
    3f8f:	0f b6 c0             	movzbl %al,%eax
    3f92:	09 c2                	or     %eax,%edx
    3f94:	8b 45 08             	mov    0x8(%ebp),%eax
    3f97:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3f9a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f9d:	8d 50 01             	lea    0x1(%eax),%edx
    3fa0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3fa3:	39 c2                	cmp    %eax,%edx
    3fa5:	73 24                	jae    3fcb <ensureBits32+0x153>
    3fa7:	8b 45 08             	mov    0x8(%ebp),%eax
    3faa:	8b 50 10             	mov    0x10(%eax),%edx
    3fad:	8b 45 08             	mov    0x8(%ebp),%eax
    3fb0:	8b 00                	mov    (%eax),%eax
    3fb2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3fb5:	83 c1 01             	add    $0x1,%ecx
    3fb8:	01 c8                	add    %ecx,%eax
    3fba:	0f b6 00             	movzbl (%eax),%eax
    3fbd:	0f b6 c0             	movzbl %al,%eax
    3fc0:	c1 e0 08             	shl    $0x8,%eax
    3fc3:	09 c2                	or     %eax,%edx
    3fc5:	8b 45 08             	mov    0x8(%ebp),%eax
    3fc8:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    3fcb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3fce:	8d 50 02             	lea    0x2(%eax),%edx
    3fd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3fd4:	39 c2                	cmp    %eax,%edx
    3fd6:	73 24                	jae    3ffc <ensureBits32+0x184>
    3fd8:	8b 45 08             	mov    0x8(%ebp),%eax
    3fdb:	8b 50 10             	mov    0x10(%eax),%edx
    3fde:	8b 45 08             	mov    0x8(%ebp),%eax
    3fe1:	8b 00                	mov    (%eax),%eax
    3fe3:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3fe6:	83 c1 02             	add    $0x2,%ecx
    3fe9:	01 c8                	add    %ecx,%eax
    3feb:	0f b6 00             	movzbl (%eax),%eax
    3fee:	0f b6 c0             	movzbl %al,%eax
    3ff1:	c1 e0 10             	shl    $0x10,%eax
    3ff4:	09 c2                	or     %eax,%edx
    3ff6:	8b 45 08             	mov    0x8(%ebp),%eax
    3ff9:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    3ffc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3fff:	8d 50 03             	lea    0x3(%eax),%edx
    4002:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4005:	39 c2                	cmp    %eax,%edx
    4007:	73 24                	jae    402d <ensureBits32+0x1b5>
    4009:	8b 45 08             	mov    0x8(%ebp),%eax
    400c:	8b 50 10             	mov    0x10(%eax),%edx
    400f:	8b 45 08             	mov    0x8(%ebp),%eax
    4012:	8b 00                	mov    (%eax),%eax
    4014:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4017:	83 c1 03             	add    $0x3,%ecx
    401a:	01 c8                	add    %ecx,%eax
    401c:	0f b6 00             	movzbl (%eax),%eax
    401f:	0f b6 c0             	movzbl %al,%eax
    4022:	c1 e0 18             	shl    $0x18,%eax
    4025:	09 c2                	or     %eax,%edx
    4027:	8b 45 08             	mov    0x8(%ebp),%eax
    402a:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    402d:	8b 45 08             	mov    0x8(%ebp),%eax
    4030:	8b 50 10             	mov    0x10(%eax),%edx
    4033:	8b 45 08             	mov    0x8(%ebp),%eax
    4036:	8b 40 0c             	mov    0xc(%eax),%eax
    4039:	83 e0 07             	and    $0x7,%eax
    403c:	89 c1                	mov    %eax,%ecx
    403e:	d3 ea                	shr    %cl,%edx
    4040:	8b 45 08             	mov    0x8(%ebp),%eax
    4043:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4046:	8b 45 08             	mov    0x8(%ebp),%eax
    4049:	8b 50 0c             	mov    0xc(%eax),%edx
    404c:	8b 45 0c             	mov    0xc(%ebp),%eax
    404f:	01 c2                	add    %eax,%edx
    4051:	8b 45 08             	mov    0x8(%ebp),%eax
    4054:	8b 40 08             	mov    0x8(%eax),%eax
    4057:	39 c2                	cmp    %eax,%edx
    4059:	0f 9e c0             	setle  %al
    405c:	0f b6 c0             	movzbl %al,%eax
  }
}
    405f:	83 c4 10             	add    $0x10,%esp
    4062:	5b                   	pop    %ebx
    4063:	5d                   	pop    %ebp
    4064:	c3                   	ret    

00004065 <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    4065:	55                   	push   %ebp
    4066:	89 e5                	mov    %esp,%ebp
    4068:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    4069:	8b 45 08             	mov    0x8(%ebp),%eax
    406c:	8b 50 10             	mov    0x10(%eax),%edx
    406f:	8b 45 0c             	mov    0xc(%ebp),%eax
    4072:	bb 01 00 00 00       	mov    $0x1,%ebx
    4077:	89 c1                	mov    %eax,%ecx
    4079:	d3 e3                	shl    %cl,%ebx
    407b:	89 d8                	mov    %ebx,%eax
    407d:	83 e8 01             	sub    $0x1,%eax
    4080:	21 d0                	and    %edx,%eax
}
    4082:	5b                   	pop    %ebx
    4083:	5d                   	pop    %ebp
    4084:	c3                   	ret    

00004085 <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    4085:	55                   	push   %ebp
    4086:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    4088:	8b 45 08             	mov    0x8(%ebp),%eax
    408b:	8b 50 10             	mov    0x10(%eax),%edx
    408e:	8b 45 0c             	mov    0xc(%ebp),%eax
    4091:	89 c1                	mov    %eax,%ecx
    4093:	d3 ea                	shr    %cl,%edx
    4095:	8b 45 08             	mov    0x8(%ebp),%eax
    4098:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    409b:	8b 45 08             	mov    0x8(%ebp),%eax
    409e:	8b 50 0c             	mov    0xc(%eax),%edx
    40a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    40a4:	01 c2                	add    %eax,%edx
    40a6:	8b 45 08             	mov    0x8(%ebp),%eax
    40a9:	89 50 0c             	mov    %edx,0xc(%eax)
}
    40ac:	90                   	nop
    40ad:	5d                   	pop    %ebp
    40ae:	c3                   	ret    

000040af <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    40af:	55                   	push   %ebp
    40b0:	89 e5                	mov    %esp,%ebp
    40b2:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    40b5:	ff 75 0c             	pushl  0xc(%ebp)
    40b8:	ff 75 08             	pushl  0x8(%ebp)
    40bb:	e8 a5 ff ff ff       	call   4065 <peekBits>
    40c0:	83 c4 08             	add    $0x8,%esp
    40c3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    40c6:	ff 75 0c             	pushl  0xc(%ebp)
    40c9:	ff 75 08             	pushl  0x8(%ebp)
    40cc:	e8 b4 ff ff ff       	call   4085 <advanceBits>
    40d1:	83 c4 08             	add    $0x8,%esp
  return result;
    40d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    40d7:	c9                   	leave  
    40d8:	c3                   	ret    

000040d9 <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    40d9:	55                   	push   %ebp
    40da:	89 e5                	mov    %esp,%ebp
    40dc:	53                   	push   %ebx
    40dd:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    40e0:	ff 75 0c             	pushl  0xc(%ebp)
    40e3:	ff 75 08             	pushl  0x8(%ebp)
    40e6:	8d 45 d8             	lea    -0x28(%ebp),%eax
    40e9:	50                   	push   %eax
    40ea:	e8 97 f9 ff ff       	call   3a86 <LodePNGBitReader_init>
    40ef:	83 c4 0c             	add    $0xc,%esp
    40f2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    40f5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    40f9:	74 0a                	je     4105 <lode_png_test_bitreader+0x2c>
    40fb:	b8 00 00 00 00       	mov    $0x0,%eax
    4100:	e9 c3 00 00 00       	jmp    41c8 <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    4105:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    410c:	e9 a6 00 00 00       	jmp    41b7 <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    4111:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4114:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    411b:	8b 45 14             	mov    0x14(%ebp),%eax
    411e:	01 d0                	add    %edx,%eax
    4120:	8b 00                	mov    (%eax),%eax
    4122:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    4125:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    4129:	7e 14                	jle    413f <lode_png_test_bitreader+0x66>
    412b:	ff 75 ec             	pushl  -0x14(%ebp)
    412e:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4131:	50                   	push   %eax
    4132:	e8 41 fd ff ff       	call   3e78 <ensureBits32>
    4137:	83 c4 08             	add    $0x8,%esp
    413a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    413d:	eb 46                	jmp    4185 <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    413f:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    4143:	7e 14                	jle    4159 <lode_png_test_bitreader+0x80>
    4145:	ff 75 ec             	pushl  -0x14(%ebp)
    4148:	8d 45 d8             	lea    -0x28(%ebp),%eax
    414b:	50                   	push   %eax
    414c:	e8 ae fb ff ff       	call   3cff <ensureBits25>
    4151:	83 c4 08             	add    $0x8,%esp
    4154:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4157:	eb 2c                	jmp    4185 <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    4159:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    415d:	7e 14                	jle    4173 <lode_png_test_bitreader+0x9a>
    415f:	ff 75 ec             	pushl  -0x14(%ebp)
    4162:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4165:	50                   	push   %eax
    4166:	e8 68 fa ff ff       	call   3bd3 <ensureBits17>
    416b:	83 c4 08             	add    $0x8,%esp
    416e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4171:	eb 12                	jmp    4185 <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    4173:	ff 75 ec             	pushl  -0x14(%ebp)
    4176:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4179:	50                   	push   %eax
    417a:	e8 78 f9 ff ff       	call   3af7 <ensureBits9>
    417f:	83 c4 08             	add    $0x8,%esp
    4182:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    4185:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4189:	75 07                	jne    4192 <lode_png_test_bitreader+0xb9>
    418b:	b8 00 00 00 00       	mov    $0x0,%eax
    4190:	eb 36                	jmp    41c8 <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    4192:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4195:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    419c:	8b 45 18             	mov    0x18(%ebp),%eax
    419f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    41a2:	ff 75 ec             	pushl  -0x14(%ebp)
    41a5:	8d 45 d8             	lea    -0x28(%ebp),%eax
    41a8:	50                   	push   %eax
    41a9:	e8 01 ff ff ff       	call   40af <readBits>
    41ae:	83 c4 08             	add    $0x8,%esp
    41b1:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    41b3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    41b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    41ba:	3b 45 10             	cmp    0x10(%ebp),%eax
    41bd:	0f 8c 4e ff ff ff    	jl     4111 <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    41c3:	b8 01 00 00 00       	mov    $0x1,%eax
}
    41c8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    41cb:	c9                   	leave  
    41cc:	c3                   	ret    

000041cd <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    41cd:	55                   	push   %ebp
    41ce:	89 e5                	mov    %esp,%ebp
    41d0:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    41d3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    41da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    41e1:	eb 27                	jmp    420a <reverseBits+0x3d>
    41e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    41e6:	2b 45 fc             	sub    -0x4(%ebp),%eax
    41e9:	83 e8 01             	sub    $0x1,%eax
    41ec:	8b 55 08             	mov    0x8(%ebp),%edx
    41ef:	89 c1                	mov    %eax,%ecx
    41f1:	d3 ea                	shr    %cl,%edx
    41f3:	89 d0                	mov    %edx,%eax
    41f5:	83 e0 01             	and    $0x1,%eax
    41f8:	89 c2                	mov    %eax,%edx
    41fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
    41fd:	89 c1                	mov    %eax,%ecx
    41ff:	d3 e2                	shl    %cl,%edx
    4201:	89 d0                	mov    %edx,%eax
    4203:	09 45 f8             	or     %eax,-0x8(%ebp)
    4206:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    420a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    420d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4210:	72 d1                	jb     41e3 <reverseBits+0x16>
  return result;
    4212:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    4215:	c9                   	leave  
    4216:	c3                   	ret    

00004217 <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    4217:	55                   	push   %ebp
    4218:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    421a:	8b 45 08             	mov    0x8(%ebp),%eax
    421d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    4223:	8b 45 08             	mov    0x8(%ebp),%eax
    4226:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    422d:	8b 45 08             	mov    0x8(%ebp),%eax
    4230:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    4237:	8b 45 08             	mov    0x8(%ebp),%eax
    423a:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    4241:	90                   	nop
    4242:	5d                   	pop    %ebp
    4243:	c3                   	ret    

00004244 <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    4244:	55                   	push   %ebp
    4245:	89 e5                	mov    %esp,%ebp
    4247:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    424a:	8b 45 08             	mov    0x8(%ebp),%eax
    424d:	8b 00                	mov    (%eax),%eax
    424f:	83 ec 0c             	sub    $0xc,%esp
    4252:	50                   	push   %eax
    4253:	e8 ec f0 ff ff       	call   3344 <lodepng_free>
    4258:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    425b:	8b 45 08             	mov    0x8(%ebp),%eax
    425e:	8b 40 04             	mov    0x4(%eax),%eax
    4261:	83 ec 0c             	sub    $0xc,%esp
    4264:	50                   	push   %eax
    4265:	e8 da f0 ff ff       	call   3344 <lodepng_free>
    426a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    426d:	8b 45 08             	mov    0x8(%ebp),%eax
    4270:	8b 40 10             	mov    0x10(%eax),%eax
    4273:	83 ec 0c             	sub    $0xc,%esp
    4276:	50                   	push   %eax
    4277:	e8 c8 f0 ff ff       	call   3344 <lodepng_free>
    427c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    427f:	8b 45 08             	mov    0x8(%ebp),%eax
    4282:	8b 40 14             	mov    0x14(%eax),%eax
    4285:	83 ec 0c             	sub    $0xc,%esp
    4288:	50                   	push   %eax
    4289:	e8 b6 f0 ff ff       	call   3344 <lodepng_free>
    428e:	83 c4 10             	add    $0x10,%esp
}
    4291:	90                   	nop
    4292:	c9                   	leave  
    4293:	c3                   	ret    

00004294 <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    4294:	55                   	push   %ebp
    4295:	89 e5                	mov    %esp,%ebp
    4297:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    429a:	a1 a8 b5 01 00       	mov    0x1b5a8,%eax
    429f:	c1 e0 02             	shl    $0x2,%eax
    42a2:	83 ec 0c             	sub    $0xc,%esp
    42a5:	50                   	push   %eax
    42a6:	e8 78 f0 ff ff       	call   3323 <lodepng_malloc>
    42ab:	83 c4 10             	add    $0x10,%esp
    42ae:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    42b1:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    42b5:	75 0a                	jne    42c1 <HuffmanTree_makeTable+0x2d>
    42b7:	b8 53 00 00 00       	mov    $0x53,%eax
    42bc:	e9 61 04 00 00       	jmp    4722 <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    42c1:	a1 a8 b5 01 00       	mov    0x1b5a8,%eax
    42c6:	c1 e0 02             	shl    $0x2,%eax
    42c9:	83 ec 04             	sub    $0x4,%esp
    42cc:	50                   	push   %eax
    42cd:	6a 00                	push   $0x0
    42cf:	ff 75 dc             	pushl  -0x24(%ebp)
    42d2:	e8 bd f0 ff ff       	call   3394 <lodepng_memset>
    42d7:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    42da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    42e1:	eb 7d                	jmp    4360 <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    42e3:	8b 45 08             	mov    0x8(%ebp),%eax
    42e6:	8b 00                	mov    (%eax),%eax
    42e8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    42eb:	c1 e2 02             	shl    $0x2,%edx
    42ee:	01 d0                	add    %edx,%eax
    42f0:	8b 00                	mov    (%eax),%eax
    42f2:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    42f5:	8b 45 08             	mov    0x8(%ebp),%eax
    42f8:	8b 40 04             	mov    0x4(%eax),%eax
    42fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    42fe:	c1 e2 02             	shl    $0x2,%edx
    4301:	01 d0                	add    %edx,%eax
    4303:	8b 00                	mov    (%eax),%eax
    4305:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    4308:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    430c:	76 4d                	jbe    435b <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    430e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4311:	83 e8 09             	sub    $0x9,%eax
    4314:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4317:	89 c1                	mov    %eax,%ecx
    4319:	d3 ea                	shr    %cl,%edx
    431b:	89 d0                	mov    %edx,%eax
    431d:	83 ec 08             	sub    $0x8,%esp
    4320:	6a 09                	push   $0x9
    4322:	50                   	push   %eax
    4323:	e8 a5 fe ff ff       	call   41cd <reverseBits>
    4328:	83 c4 10             	add    $0x10,%esp
    432b:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    432e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4331:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4338:	8b 45 dc             	mov    -0x24(%ebp),%eax
    433b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    433e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4341:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4348:	8b 45 dc             	mov    -0x24(%ebp),%eax
    434b:	01 d0                	add    %edx,%eax
    434d:	8b 10                	mov    (%eax),%edx
    434f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4352:	39 c2                	cmp    %eax,%edx
    4354:	0f 43 c2             	cmovae %edx,%eax
    4357:	89 01                	mov    %eax,(%ecx)
    4359:	eb 01                	jmp    435c <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    435b:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    435c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4360:	8b 45 08             	mov    0x8(%ebp),%eax
    4363:	8b 50 0c             	mov    0xc(%eax),%edx
    4366:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4369:	39 c2                	cmp    %eax,%edx
    436b:	0f 87 72 ff ff ff    	ja     42e3 <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    4371:	a1 a8 b5 01 00       	mov    0x1b5a8,%eax
    4376:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    4379:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4380:	eb 35                	jmp    43b7 <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    4382:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4385:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    438c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    438f:	01 d0                	add    %edx,%eax
    4391:	8b 00                	mov    (%eax),%eax
    4393:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    4396:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    439a:	76 17                	jbe    43b3 <HuffmanTree_makeTable+0x11f>
    439c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    439f:	83 e8 09             	sub    $0x9,%eax
    43a2:	ba 01 00 00 00       	mov    $0x1,%edx
    43a7:	89 c1                	mov    %eax,%ecx
    43a9:	d3 e2                	shl    %cl,%edx
    43ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    43ae:	01 d0                	add    %edx,%eax
    43b0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    43b3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    43b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    43ba:	a1 a8 b5 01 00       	mov    0x1b5a8,%eax
    43bf:	39 c2                	cmp    %eax,%edx
    43c1:	72 bf                	jb     4382 <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    43c3:	83 ec 0c             	sub    $0xc,%esp
    43c6:	ff 75 e8             	pushl  -0x18(%ebp)
    43c9:	e8 55 ef ff ff       	call   3323 <lodepng_malloc>
    43ce:	83 c4 10             	add    $0x10,%esp
    43d1:	89 c2                	mov    %eax,%edx
    43d3:	8b 45 08             	mov    0x8(%ebp),%eax
    43d6:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    43d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    43dc:	01 c0                	add    %eax,%eax
    43de:	83 ec 0c             	sub    $0xc,%esp
    43e1:	50                   	push   %eax
    43e2:	e8 3c ef ff ff       	call   3323 <lodepng_malloc>
    43e7:	83 c4 10             	add    $0x10,%esp
    43ea:	89 c2                	mov    %eax,%edx
    43ec:	8b 45 08             	mov    0x8(%ebp),%eax
    43ef:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    43f2:	8b 45 08             	mov    0x8(%ebp),%eax
    43f5:	8b 40 10             	mov    0x10(%eax),%eax
    43f8:	85 c0                	test   %eax,%eax
    43fa:	74 0a                	je     4406 <HuffmanTree_makeTable+0x172>
    43fc:	8b 45 08             	mov    0x8(%ebp),%eax
    43ff:	8b 40 14             	mov    0x14(%eax),%eax
    4402:	85 c0                	test   %eax,%eax
    4404:	75 18                	jne    441e <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    4406:	83 ec 0c             	sub    $0xc,%esp
    4409:	ff 75 dc             	pushl  -0x24(%ebp)
    440c:	e8 33 ef ff ff       	call   3344 <lodepng_free>
    4411:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    4414:	b8 53 00 00 00       	mov    $0x53,%eax
    4419:	e9 04 03 00 00       	jmp    4722 <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    441e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4425:	eb 12                	jmp    4439 <HuffmanTree_makeTable+0x1a5>
    4427:	8b 45 08             	mov    0x8(%ebp),%eax
    442a:	8b 50 10             	mov    0x10(%eax),%edx
    442d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4430:	01 d0                	add    %edx,%eax
    4432:	c6 00 10             	movb   $0x10,(%eax)
    4435:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4439:	8b 45 f4             	mov    -0xc(%ebp),%eax
    443c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    443f:	7c e6                	jl     4427 <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    4441:	a1 a8 b5 01 00       	mov    0x1b5a8,%eax
    4446:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    4449:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4450:	eb 5b                	jmp    44ad <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    4452:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4455:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    445c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    445f:	01 d0                	add    %edx,%eax
    4461:	8b 00                	mov    (%eax),%eax
    4463:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    4466:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    446a:	76 3c                	jbe    44a8 <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    446c:	8b 45 08             	mov    0x8(%ebp),%eax
    446f:	8b 50 10             	mov    0x10(%eax),%edx
    4472:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4475:	01 d0                	add    %edx,%eax
    4477:	8b 55 c8             	mov    -0x38(%ebp),%edx
    447a:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    447c:	8b 45 08             	mov    0x8(%ebp),%eax
    447f:	8b 40 14             	mov    0x14(%eax),%eax
    4482:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4485:	01 d2                	add    %edx,%edx
    4487:	01 d0                	add    %edx,%eax
    4489:	8b 55 ec             	mov    -0x14(%ebp),%edx
    448c:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    448f:	8b 45 c8             	mov    -0x38(%ebp),%eax
    4492:	83 e8 09             	sub    $0x9,%eax
    4495:	ba 01 00 00 00       	mov    $0x1,%edx
    449a:	89 c1                	mov    %eax,%ecx
    449c:	d3 e2                	shl    %cl,%edx
    449e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    44a1:	01 d0                	add    %edx,%eax
    44a3:	89 45 ec             	mov    %eax,-0x14(%ebp)
    44a6:	eb 01                	jmp    44a9 <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    44a8:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    44a9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    44ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
    44b0:	a1 a8 b5 01 00       	mov    0x1b5a8,%eax
    44b5:	39 c2                	cmp    %eax,%edx
    44b7:	72 99                	jb     4452 <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    44b9:	83 ec 0c             	sub    $0xc,%esp
    44bc:	ff 75 dc             	pushl  -0x24(%ebp)
    44bf:	e8 80 ee ff ff       	call   3344 <lodepng_free>
    44c4:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    44c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    44ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    44d5:	e9 9d 01 00 00       	jmp    4677 <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    44da:	8b 45 08             	mov    0x8(%ebp),%eax
    44dd:	8b 40 04             	mov    0x4(%eax),%eax
    44e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    44e3:	c1 e2 02             	shl    $0x2,%edx
    44e6:	01 d0                	add    %edx,%eax
    44e8:	8b 00                	mov    (%eax),%eax
    44ea:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    44ed:	8b 45 08             	mov    0x8(%ebp),%eax
    44f0:	8b 00                	mov    (%eax),%eax
    44f2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    44f5:	c1 e2 02             	shl    $0x2,%edx
    44f8:	01 d0                	add    %edx,%eax
    44fa:	8b 00                	mov    (%eax),%eax
    44fc:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    44ff:	83 ec 08             	sub    $0x8,%esp
    4502:	ff 75 c4             	pushl  -0x3c(%ebp)
    4505:	ff 75 c0             	pushl  -0x40(%ebp)
    4508:	e8 c0 fc ff ff       	call   41cd <reverseBits>
    450d:	83 c4 10             	add    $0x10,%esp
    4510:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    4513:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    4517:	0f 84 55 01 00 00    	je     4672 <HuffmanTree_makeTable+0x3de>
    numpresent++;
    451d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    4521:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    4525:	0f 87 81 00 00 00    	ja     45ac <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    452b:	b8 09 00 00 00       	mov    $0x9,%eax
    4530:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    4533:	ba 01 00 00 00       	mov    $0x1,%edx
    4538:	89 c1                	mov    %eax,%ecx
    453a:	d3 e2                	shl    %cl,%edx
    453c:	89 d0                	mov    %edx,%eax
    453e:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    4541:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    4548:	eb 55                	jmp    459f <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    454a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    454d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4550:	89 c1                	mov    %eax,%ecx
    4552:	d3 e2                	shl    %cl,%edx
    4554:	89 d0                	mov    %edx,%eax
    4556:	0b 45 bc             	or     -0x44(%ebp),%eax
    4559:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    455c:	8b 45 08             	mov    0x8(%ebp),%eax
    455f:	8b 50 10             	mov    0x10(%eax),%edx
    4562:	8b 45 98             	mov    -0x68(%ebp),%eax
    4565:	01 d0                	add    %edx,%eax
    4567:	0f b6 00             	movzbl (%eax),%eax
    456a:	3c 10                	cmp    $0x10,%al
    456c:	74 0a                	je     4578 <HuffmanTree_makeTable+0x2e4>
    456e:	b8 37 00 00 00       	mov    $0x37,%eax
    4573:	e9 aa 01 00 00       	jmp    4722 <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    4578:	8b 45 08             	mov    0x8(%ebp),%eax
    457b:	8b 50 10             	mov    0x10(%eax),%edx
    457e:	8b 45 98             	mov    -0x68(%ebp),%eax
    4581:	01 d0                	add    %edx,%eax
    4583:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4586:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    4588:	8b 45 08             	mov    0x8(%ebp),%eax
    458b:	8b 40 14             	mov    0x14(%eax),%eax
    458e:	8b 55 98             	mov    -0x68(%ebp),%edx
    4591:	01 d2                	add    %edx,%edx
    4593:	01 d0                	add    %edx,%eax
    4595:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4598:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    459b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    459f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    45a2:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    45a5:	72 a3                	jb     454a <HuffmanTree_makeTable+0x2b6>
    45a7:	e9 c7 00 00 00       	jmp    4673 <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    45ac:	a1 ac b5 01 00       	mov    0x1b5ac,%eax
    45b1:	23 45 bc             	and    -0x44(%ebp),%eax
    45b4:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    45b7:	8b 45 08             	mov    0x8(%ebp),%eax
    45ba:	8b 50 10             	mov    0x10(%eax),%edx
    45bd:	8b 45 b8             	mov    -0x48(%ebp),%eax
    45c0:	01 d0                	add    %edx,%eax
    45c2:	0f b6 00             	movzbl (%eax),%eax
    45c5:	0f b6 c0             	movzbl %al,%eax
    45c8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    45cb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    45ce:	83 e8 09             	sub    $0x9,%eax
    45d1:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    45d4:	8b 45 08             	mov    0x8(%ebp),%eax
    45d7:	8b 40 14             	mov    0x14(%eax),%eax
    45da:	8b 55 b8             	mov    -0x48(%ebp),%edx
    45dd:	01 d2                	add    %edx,%edx
    45df:	01 d0                	add    %edx,%eax
    45e1:	0f b7 00             	movzwl (%eax),%eax
    45e4:	0f b7 c0             	movzwl %ax,%eax
    45e7:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    45ea:	8b 45 b0             	mov    -0x50(%ebp),%eax
    45ed:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    45f0:	83 c0 09             	add    $0x9,%eax
    45f3:	ba 01 00 00 00       	mov    $0x1,%edx
    45f8:	89 c1                	mov    %eax,%ecx
    45fa:	d3 e2                	shl    %cl,%edx
    45fc:	89 d0                	mov    %edx,%eax
    45fe:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    4601:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    4604:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    4607:	73 0a                	jae    4613 <HuffmanTree_makeTable+0x37f>
    4609:	b8 37 00 00 00       	mov    $0x37,%eax
    460e:	e9 0f 01 00 00       	jmp    4722 <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    4613:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    461a:	eb 4c                	jmp    4668 <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    461c:	8b 45 bc             	mov    -0x44(%ebp),%eax
    461f:	c1 e8 09             	shr    $0x9,%eax
    4622:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    4625:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4628:	83 e8 09             	sub    $0x9,%eax
    462b:	8b 55 e0             	mov    -0x20(%ebp),%edx
    462e:	89 c1                	mov    %eax,%ecx
    4630:	d3 e2                	shl    %cl,%edx
    4632:	89 d0                	mov    %edx,%eax
    4634:	0b 45 a4             	or     -0x5c(%ebp),%eax
    4637:	89 c2                	mov    %eax,%edx
    4639:	8b 45 ac             	mov    -0x54(%ebp),%eax
    463c:	01 d0                	add    %edx,%eax
    463e:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    4641:	8b 45 08             	mov    0x8(%ebp),%eax
    4644:	8b 50 10             	mov    0x10(%eax),%edx
    4647:	8b 45 a0             	mov    -0x60(%ebp),%eax
    464a:	01 d0                	add    %edx,%eax
    464c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    464f:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    4651:	8b 45 08             	mov    0x8(%ebp),%eax
    4654:	8b 40 14             	mov    0x14(%eax),%eax
    4657:	8b 55 a0             	mov    -0x60(%ebp),%edx
    465a:	01 d2                	add    %edx,%edx
    465c:	01 d0                	add    %edx,%eax
    465e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4661:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    4664:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4668:	8b 45 e0             	mov    -0x20(%ebp),%eax
    466b:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    466e:	72 ac                	jb     461c <HuffmanTree_makeTable+0x388>
    4670:	eb 01                	jmp    4673 <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    4672:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    4673:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4677:	8b 45 08             	mov    0x8(%ebp),%eax
    467a:	8b 50 0c             	mov    0xc(%eax),%edx
    467d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4680:	39 c2                	cmp    %eax,%edx
    4682:	0f 87 52 fe ff ff    	ja     44da <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    4688:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    468c:	7f 61                	jg     46ef <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    468e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4695:	eb 4e                	jmp    46e5 <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    4697:	8b 45 08             	mov    0x8(%ebp),%eax
    469a:	8b 50 10             	mov    0x10(%eax),%edx
    469d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46a0:	01 d0                	add    %edx,%eax
    46a2:	0f b6 00             	movzbl (%eax),%eax
    46a5:	3c 10                	cmp    $0x10,%al
    46a7:	75 38                	jne    46e1 <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    46a9:	8b 45 08             	mov    0x8(%ebp),%eax
    46ac:	8b 50 10             	mov    0x10(%eax),%edx
    46af:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46b2:	01 d0                	add    %edx,%eax
    46b4:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    46b7:	8b 15 a8 b5 01 00    	mov    0x1b5a8,%edx
    46bd:	39 d1                	cmp    %edx,%ecx
    46bf:	73 07                	jae    46c8 <HuffmanTree_makeTable+0x434>
    46c1:	ba 01 00 00 00       	mov    $0x1,%edx
    46c6:	eb 05                	jmp    46cd <HuffmanTree_makeTable+0x439>
    46c8:	ba 0a 00 00 00       	mov    $0xa,%edx
    46cd:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    46cf:	8b 45 08             	mov    0x8(%ebp),%eax
    46d2:	8b 40 14             	mov    0x14(%eax),%eax
    46d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    46d8:	01 d2                	add    %edx,%edx
    46da:	01 d0                	add    %edx,%eax
    46dc:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    46e1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    46e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46e8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    46eb:	7c aa                	jl     4697 <HuffmanTree_makeTable+0x403>
    46ed:	eb 2e                	jmp    471d <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    46ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    46f6:	eb 1d                	jmp    4715 <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    46f8:	8b 45 08             	mov    0x8(%ebp),%eax
    46fb:	8b 50 10             	mov    0x10(%eax),%edx
    46fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4701:	01 d0                	add    %edx,%eax
    4703:	0f b6 00             	movzbl (%eax),%eax
    4706:	3c 10                	cmp    $0x10,%al
    4708:	75 07                	jne    4711 <HuffmanTree_makeTable+0x47d>
    470a:	b8 37 00 00 00       	mov    $0x37,%eax
    470f:	eb 11                	jmp    4722 <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    4711:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4715:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4718:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    471b:	7c db                	jl     46f8 <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    471d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4722:	c9                   	leave  
    4723:	c3                   	ret    

00004724 <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    4724:	55                   	push   %ebp
    4725:	89 e5                	mov    %esp,%ebp
    4727:	56                   	push   %esi
    4728:	53                   	push   %ebx
    4729:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    472c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    4733:	8b 45 08             	mov    0x8(%ebp),%eax
    4736:	8b 40 0c             	mov    0xc(%eax),%eax
    4739:	c1 e0 02             	shl    $0x2,%eax
    473c:	83 ec 0c             	sub    $0xc,%esp
    473f:	50                   	push   %eax
    4740:	e8 de eb ff ff       	call   3323 <lodepng_malloc>
    4745:	83 c4 10             	add    $0x10,%esp
    4748:	89 c2                	mov    %eax,%edx
    474a:	8b 45 08             	mov    0x8(%ebp),%eax
    474d:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    474f:	8b 45 08             	mov    0x8(%ebp),%eax
    4752:	8b 40 08             	mov    0x8(%eax),%eax
    4755:	83 c0 01             	add    $0x1,%eax
    4758:	c1 e0 02             	shl    $0x2,%eax
    475b:	83 ec 0c             	sub    $0xc,%esp
    475e:	50                   	push   %eax
    475f:	e8 bf eb ff ff       	call   3323 <lodepng_malloc>
    4764:	83 c4 10             	add    $0x10,%esp
    4767:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    476a:	8b 45 08             	mov    0x8(%ebp),%eax
    476d:	8b 40 08             	mov    0x8(%eax),%eax
    4770:	83 c0 01             	add    $0x1,%eax
    4773:	c1 e0 02             	shl    $0x2,%eax
    4776:	83 ec 0c             	sub    $0xc,%esp
    4779:	50                   	push   %eax
    477a:	e8 a4 eb ff ff       	call   3323 <lodepng_malloc>
    477f:	83 c4 10             	add    $0x10,%esp
    4782:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    4785:	8b 45 08             	mov    0x8(%ebp),%eax
    4788:	8b 00                	mov    (%eax),%eax
    478a:	85 c0                	test   %eax,%eax
    478c:	74 0c                	je     479a <HuffmanTree_makeFromLengths2+0x76>
    478e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    4792:	74 06                	je     479a <HuffmanTree_makeFromLengths2+0x76>
    4794:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4798:	75 07                	jne    47a1 <HuffmanTree_makeFromLengths2+0x7d>
    479a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    47a1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    47a5:	0f 85 7d 01 00 00    	jne    4928 <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    47ab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    47b2:	eb 2c                	jmp    47e0 <HuffmanTree_makeFromLengths2+0xbc>
    47b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    47b7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    47be:	8b 45 e8             	mov    -0x18(%ebp),%eax
    47c1:	01 c2                	add    %eax,%edx
    47c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    47c6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    47cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    47d0:	01 c8                	add    %ecx,%eax
    47d2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    47d8:	8b 00                	mov    (%eax),%eax
    47da:	89 02                	mov    %eax,(%edx)
    47dc:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    47e0:	8b 45 08             	mov    0x8(%ebp),%eax
    47e3:	8b 40 08             	mov    0x8(%eax),%eax
    47e6:	83 c0 01             	add    $0x1,%eax
    47e9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    47ec:	75 c6                	jne    47b4 <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    47ee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    47f5:	eb 27                	jmp    481e <HuffmanTree_makeFromLengths2+0xfa>
    47f7:	8b 45 08             	mov    0x8(%ebp),%eax
    47fa:	8b 40 04             	mov    0x4(%eax),%eax
    47fd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4800:	c1 e2 02             	shl    $0x2,%edx
    4803:	01 d0                	add    %edx,%eax
    4805:	8b 00                	mov    (%eax),%eax
    4807:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    480e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4811:	01 d0                	add    %edx,%eax
    4813:	8b 10                	mov    (%eax),%edx
    4815:	83 c2 01             	add    $0x1,%edx
    4818:	89 10                	mov    %edx,(%eax)
    481a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    481e:	8b 45 08             	mov    0x8(%ebp),%eax
    4821:	8b 40 0c             	mov    0xc(%eax),%eax
    4824:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4827:	75 ce                	jne    47f7 <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4829:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    4830:	eb 47                	jmp    4879 <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    4832:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4835:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    483c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    483f:	01 d0                	add    %edx,%eax
    4841:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4844:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    484a:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    4851:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4854:	01 ca                	add    %ecx,%edx
    4856:	8b 0a                	mov    (%edx),%ecx
    4858:	8b 55 f0             	mov    -0x10(%ebp),%edx
    485b:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4861:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    4868:	8b 55 e8             	mov    -0x18(%ebp),%edx
    486b:	01 da                	add    %ebx,%edx
    486d:	8b 12                	mov    (%edx),%edx
    486f:	01 ca                	add    %ecx,%edx
    4871:	01 d2                	add    %edx,%edx
    4873:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4875:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4879:	8b 45 08             	mov    0x8(%ebp),%eax
    487c:	8b 40 08             	mov    0x8(%eax),%eax
    487f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4882:	73 ae                	jae    4832 <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4884:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    488b:	e9 89 00 00 00       	jmp    4919 <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    4890:	8b 45 08             	mov    0x8(%ebp),%eax
    4893:	8b 40 04             	mov    0x4(%eax),%eax
    4896:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4899:	c1 e2 02             	shl    $0x2,%edx
    489c:	01 d0                	add    %edx,%eax
    489e:	8b 00                	mov    (%eax),%eax
    48a0:	85 c0                	test   %eax,%eax
    48a2:	74 71                	je     4915 <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    48a4:	8b 45 08             	mov    0x8(%ebp),%eax
    48a7:	8b 00                	mov    (%eax),%eax
    48a9:	8b 55 ec             	mov    -0x14(%ebp),%edx
    48ac:	c1 e2 02             	shl    $0x2,%edx
    48af:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    48b2:	8b 45 08             	mov    0x8(%ebp),%eax
    48b5:	8b 40 04             	mov    0x4(%eax),%eax
    48b8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    48bb:	c1 e2 02             	shl    $0x2,%edx
    48be:	01 d0                	add    %edx,%eax
    48c0:	8b 00                	mov    (%eax),%eax
    48c2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    48c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    48cc:	01 c2                	add    %eax,%edx
    48ce:	8b 02                	mov    (%edx),%eax
    48d0:	8d 48 01             	lea    0x1(%eax),%ecx
    48d3:	89 0a                	mov    %ecx,(%edx)
    48d5:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    48d7:	8b 45 08             	mov    0x8(%ebp),%eax
    48da:	8b 00                	mov    (%eax),%eax
    48dc:	8b 55 ec             	mov    -0x14(%ebp),%edx
    48df:	c1 e2 02             	shl    $0x2,%edx
    48e2:	01 c2                	add    %eax,%edx
    48e4:	8b 45 08             	mov    0x8(%ebp),%eax
    48e7:	8b 00                	mov    (%eax),%eax
    48e9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    48ec:	c1 e1 02             	shl    $0x2,%ecx
    48ef:	01 c8                	add    %ecx,%eax
    48f1:	8b 18                	mov    (%eax),%ebx
    48f3:	8b 45 08             	mov    0x8(%ebp),%eax
    48f6:	8b 40 04             	mov    0x4(%eax),%eax
    48f9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    48fc:	c1 e1 02             	shl    $0x2,%ecx
    48ff:	01 c8                	add    %ecx,%eax
    4901:	8b 00                	mov    (%eax),%eax
    4903:	be 01 00 00 00       	mov    $0x1,%esi
    4908:	89 c1                	mov    %eax,%ecx
    490a:	d3 e6                	shl    %cl,%esi
    490c:	89 f0                	mov    %esi,%eax
    490e:	83 e8 01             	sub    $0x1,%eax
    4911:	21 d8                	and    %ebx,%eax
    4913:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4915:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    4919:	8b 45 08             	mov    0x8(%ebp),%eax
    491c:	8b 40 0c             	mov    0xc(%eax),%eax
    491f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4922:	0f 85 68 ff ff ff    	jne    4890 <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    4928:	83 ec 0c             	sub    $0xc,%esp
    492b:	ff 75 e8             	pushl  -0x18(%ebp)
    492e:	e8 11 ea ff ff       	call   3344 <lodepng_free>
    4933:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    4936:	83 ec 0c             	sub    $0xc,%esp
    4939:	ff 75 e4             	pushl  -0x1c(%ebp)
    493c:	e8 03 ea ff ff       	call   3344 <lodepng_free>
    4941:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    4944:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4948:	75 11                	jne    495b <HuffmanTree_makeFromLengths2+0x237>
    494a:	83 ec 0c             	sub    $0xc,%esp
    494d:	ff 75 08             	pushl  0x8(%ebp)
    4950:	e8 3f f9 ff ff       	call   4294 <HuffmanTree_makeTable>
    4955:	83 c4 10             	add    $0x10,%esp
    4958:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    495b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    495e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4961:	5b                   	pop    %ebx
    4962:	5e                   	pop    %esi
    4963:	5d                   	pop    %ebp
    4964:	c3                   	ret    

00004965 <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    4965:	55                   	push   %ebp
    4966:	89 e5                	mov    %esp,%ebp
    4968:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    496b:	8b 45 10             	mov    0x10(%ebp),%eax
    496e:	c1 e0 02             	shl    $0x2,%eax
    4971:	83 ec 0c             	sub    $0xc,%esp
    4974:	50                   	push   %eax
    4975:	e8 a9 e9 ff ff       	call   3323 <lodepng_malloc>
    497a:	83 c4 10             	add    $0x10,%esp
    497d:	89 c2                	mov    %eax,%edx
    497f:	8b 45 08             	mov    0x8(%ebp),%eax
    4982:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    4985:	8b 45 08             	mov    0x8(%ebp),%eax
    4988:	8b 40 04             	mov    0x4(%eax),%eax
    498b:	85 c0                	test   %eax,%eax
    498d:	75 07                	jne    4996 <HuffmanTree_makeFromLengths+0x31>
    498f:	b8 53 00 00 00       	mov    $0x53,%eax
    4994:	eb 56                	jmp    49ec <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    4996:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    499d:	eb 25                	jmp    49c4 <HuffmanTree_makeFromLengths+0x5f>
    499f:	8b 45 08             	mov    0x8(%ebp),%eax
    49a2:	8b 40 04             	mov    0x4(%eax),%eax
    49a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    49a8:	c1 e2 02             	shl    $0x2,%edx
    49ab:	01 c2                	add    %eax,%edx
    49ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49b0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    49b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    49ba:	01 c8                	add    %ecx,%eax
    49bc:	8b 00                	mov    (%eax),%eax
    49be:	89 02                	mov    %eax,(%edx)
    49c0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    49c4:	8b 45 10             	mov    0x10(%ebp),%eax
    49c7:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    49ca:	75 d3                	jne    499f <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    49cc:	8b 55 10             	mov    0x10(%ebp),%edx
    49cf:	8b 45 08             	mov    0x8(%ebp),%eax
    49d2:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    49d5:	8b 45 08             	mov    0x8(%ebp),%eax
    49d8:	8b 55 14             	mov    0x14(%ebp),%edx
    49db:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    49de:	83 ec 0c             	sub    $0xc,%esp
    49e1:	ff 75 08             	pushl  0x8(%ebp)
    49e4:	e8 3b fd ff ff       	call   4724 <HuffmanTree_makeFromLengths2>
    49e9:	83 c4 10             	add    $0x10,%esp
}
    49ec:	c9                   	leave  
    49ed:	c3                   	ret    

000049ee <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    49ee:	55                   	push   %ebp
    49ef:	89 e5                	mov    %esp,%ebp
    49f1:	53                   	push   %ebx
    49f2:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    49f5:	8b 45 08             	mov    0x8(%ebp),%eax
    49f8:	8b 50 0c             	mov    0xc(%eax),%edx
    49fb:	8b 45 08             	mov    0x8(%ebp),%eax
    49fe:	8b 40 08             	mov    0x8(%eax),%eax
    4a01:	39 c2                	cmp    %eax,%edx
    4a03:	0f 82 0b 01 00 00    	jb     4b14 <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    4a09:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4a10:	eb 19                	jmp    4a2b <bpmnode_create+0x3d>
    4a12:	8b 45 08             	mov    0x8(%ebp),%eax
    4a15:	8b 40 04             	mov    0x4(%eax),%eax
    4a18:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a1b:	c1 e2 04             	shl    $0x4,%edx
    4a1e:	01 d0                	add    %edx,%eax
    4a20:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    4a27:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4a2b:	8b 45 08             	mov    0x8(%ebp),%eax
    4a2e:	8b 00                	mov    (%eax),%eax
    4a30:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4a33:	75 dd                	jne    4a12 <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    4a35:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4a3c:	eb 60                	jmp    4a9e <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    4a3e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a41:	8b 40 18             	mov    0x18(%eax),%eax
    4a44:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a47:	c1 e2 02             	shl    $0x2,%edx
    4a4a:	01 d0                	add    %edx,%eax
    4a4c:	8b 00                	mov    (%eax),%eax
    4a4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a51:	eb 13                	jmp    4a66 <bpmnode_create+0x78>
    4a53:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a56:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4a5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a60:	8b 40 08             	mov    0x8(%eax),%eax
    4a63:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a66:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4a6a:	75 e7                	jne    4a53 <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    4a6c:	8b 45 08             	mov    0x8(%ebp),%eax
    4a6f:	8b 40 1c             	mov    0x1c(%eax),%eax
    4a72:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a75:	c1 e2 02             	shl    $0x2,%edx
    4a78:	01 d0                	add    %edx,%eax
    4a7a:	8b 00                	mov    (%eax),%eax
    4a7c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a7f:	eb 13                	jmp    4a94 <bpmnode_create+0xa6>
    4a81:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a84:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4a8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a8e:	8b 40 08             	mov    0x8(%eax),%eax
    4a91:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a94:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4a98:	75 e7                	jne    4a81 <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    4a9a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4a9e:	8b 45 08             	mov    0x8(%ebp),%eax
    4aa1:	8b 40 14             	mov    0x14(%eax),%eax
    4aa4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4aa7:	75 95                	jne    4a3e <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    4aa9:	8b 45 08             	mov    0x8(%ebp),%eax
    4aac:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    4ab3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4aba:	eb 44                	jmp    4b00 <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    4abc:	8b 45 08             	mov    0x8(%ebp),%eax
    4abf:	8b 40 04             	mov    0x4(%eax),%eax
    4ac2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4ac5:	c1 e2 04             	shl    $0x4,%edx
    4ac8:	01 d0                	add    %edx,%eax
    4aca:	8b 40 0c             	mov    0xc(%eax),%eax
    4acd:	85 c0                	test   %eax,%eax
    4acf:	75 2b                	jne    4afc <bpmnode_create+0x10e>
    4ad1:	8b 45 08             	mov    0x8(%ebp),%eax
    4ad4:	8b 58 10             	mov    0x10(%eax),%ebx
    4ad7:	8b 45 08             	mov    0x8(%ebp),%eax
    4ada:	8b 40 08             	mov    0x8(%eax),%eax
    4add:	8d 48 01             	lea    0x1(%eax),%ecx
    4ae0:	8b 55 08             	mov    0x8(%ebp),%edx
    4ae3:	89 4a 08             	mov    %ecx,0x8(%edx)
    4ae6:	c1 e0 02             	shl    $0x2,%eax
    4ae9:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    4aec:	8b 45 08             	mov    0x8(%ebp),%eax
    4aef:	8b 40 04             	mov    0x4(%eax),%eax
    4af2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4af5:	c1 e1 04             	shl    $0x4,%ecx
    4af8:	01 c8                	add    %ecx,%eax
    4afa:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    4afc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4b00:	8b 45 08             	mov    0x8(%ebp),%eax
    4b03:	8b 00                	mov    (%eax),%eax
    4b05:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4b08:	75 b2                	jne    4abc <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    4b0a:	8b 45 08             	mov    0x8(%ebp),%eax
    4b0d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    4b14:	8b 45 08             	mov    0x8(%ebp),%eax
    4b17:	8b 58 10             	mov    0x10(%eax),%ebx
    4b1a:	8b 45 08             	mov    0x8(%ebp),%eax
    4b1d:	8b 40 0c             	mov    0xc(%eax),%eax
    4b20:	8d 48 01             	lea    0x1(%eax),%ecx
    4b23:	8b 55 08             	mov    0x8(%ebp),%edx
    4b26:	89 4a 0c             	mov    %ecx,0xc(%edx)
    4b29:	c1 e0 02             	shl    $0x2,%eax
    4b2c:	01 d8                	add    %ebx,%eax
    4b2e:	8b 00                	mov    (%eax),%eax
    4b30:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    4b33:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b36:	8b 55 0c             	mov    0xc(%ebp),%edx
    4b39:	89 10                	mov    %edx,(%eax)
  result->index = index;
    4b3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b3e:	8b 55 10             	mov    0x10(%ebp),%edx
    4b41:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    4b44:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b47:	8b 55 14             	mov    0x14(%ebp),%edx
    4b4a:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    4b4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    4b50:	83 c4 10             	add    $0x10,%esp
    4b53:	5b                   	pop    %ebx
    4b54:	5d                   	pop    %ebp
    4b55:	c3                   	ret    

00004b56 <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    4b56:	55                   	push   %ebp
    4b57:	89 e5                	mov    %esp,%ebp
    4b59:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    4b5c:	8b 45 0c             	mov    0xc(%ebp),%eax
    4b5f:	c1 e0 04             	shl    $0x4,%eax
    4b62:	83 ec 0c             	sub    $0xc,%esp
    4b65:	50                   	push   %eax
    4b66:	e8 b8 e7 ff ff       	call   3323 <lodepng_malloc>
    4b6b:	83 c4 10             	add    $0x10,%esp
    4b6e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    4b71:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    4b78:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    4b7f:	e9 41 01 00 00       	jmp    4cc5 <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    4b84:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b87:	83 e0 01             	and    $0x1,%eax
    4b8a:	85 c0                	test   %eax,%eax
    4b8c:	74 05                	je     4b93 <bpmnode_sort+0x3d>
    4b8e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4b91:	eb 03                	jmp    4b96 <bpmnode_sort+0x40>
    4b93:	8b 45 08             	mov    0x8(%ebp),%eax
    4b96:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    4b99:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b9c:	83 e0 01             	and    $0x1,%eax
    4b9f:	85 c0                	test   %eax,%eax
    4ba1:	74 05                	je     4ba8 <bpmnode_sort+0x52>
    4ba3:	8b 45 08             	mov    0x8(%ebp),%eax
    4ba6:	eb 03                	jmp    4bab <bpmnode_sort+0x55>
    4ba8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4bab:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4bae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4bb5:	e9 f8 00 00 00       	jmp    4cb2 <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    4bba:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4bbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4bc0:	01 c2                	add    %eax,%edx
    4bc2:	8b 45 0c             	mov    0xc(%ebp),%eax
    4bc5:	39 c2                	cmp    %eax,%edx
    4bc7:	0f 4e c2             	cmovle %edx,%eax
    4bca:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    4bcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4bd0:	8d 14 00             	lea    (%eax,%eax,1),%edx
    4bd3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4bd6:	01 c2                	add    %eax,%edx
    4bd8:	8b 45 0c             	mov    0xc(%ebp),%eax
    4bdb:	39 c2                	cmp    %eax,%edx
    4bdd:	0f 4e c2             	cmovle %edx,%eax
    4be0:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    4be3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4be6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    4be9:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4bec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    4bef:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4bf2:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4bf5:	e9 a4 00 00 00       	jmp    4c9e <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    4bfa:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4bfd:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    4c00:	7d 62                	jge    4c64 <bpmnode_sort+0x10e>
    4c02:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c05:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4c08:	7d 22                	jge    4c2c <bpmnode_sort+0xd6>
    4c0a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4c0d:	c1 e0 04             	shl    $0x4,%eax
    4c10:	89 c2                	mov    %eax,%edx
    4c12:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4c15:	01 d0                	add    %edx,%eax
    4c17:	8b 10                	mov    (%eax),%edx
    4c19:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c1c:	c1 e0 04             	shl    $0x4,%eax
    4c1f:	89 c1                	mov    %eax,%ecx
    4c21:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4c24:	01 c8                	add    %ecx,%eax
    4c26:	8b 00                	mov    (%eax),%eax
    4c28:	39 c2                	cmp    %eax,%edx
    4c2a:	7f 38                	jg     4c64 <bpmnode_sort+0x10e>
    4c2c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4c2f:	c1 e0 04             	shl    $0x4,%eax
    4c32:	89 c2                	mov    %eax,%edx
    4c34:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4c37:	01 d0                	add    %edx,%eax
    4c39:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4c3c:	8d 4a 01             	lea    0x1(%edx),%ecx
    4c3f:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    4c42:	89 d1                	mov    %edx,%ecx
    4c44:	c1 e1 04             	shl    $0x4,%ecx
    4c47:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4c4a:	01 ca                	add    %ecx,%edx
    4c4c:	8b 0a                	mov    (%edx),%ecx
    4c4e:	89 08                	mov    %ecx,(%eax)
    4c50:	8b 4a 04             	mov    0x4(%edx),%ecx
    4c53:	89 48 04             	mov    %ecx,0x4(%eax)
    4c56:	8b 4a 08             	mov    0x8(%edx),%ecx
    4c59:	89 48 08             	mov    %ecx,0x8(%eax)
    4c5c:	8b 52 0c             	mov    0xc(%edx),%edx
    4c5f:	89 50 0c             	mov    %edx,0xc(%eax)
    4c62:	eb 36                	jmp    4c9a <bpmnode_sort+0x144>
        else b[k] = a[j++];
    4c64:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4c67:	c1 e0 04             	shl    $0x4,%eax
    4c6a:	89 c2                	mov    %eax,%edx
    4c6c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4c6f:	01 d0                	add    %edx,%eax
    4c71:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4c74:	8d 4a 01             	lea    0x1(%edx),%ecx
    4c77:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    4c7a:	89 d1                	mov    %edx,%ecx
    4c7c:	c1 e1 04             	shl    $0x4,%ecx
    4c7f:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4c82:	01 ca                	add    %ecx,%edx
    4c84:	8b 0a                	mov    (%edx),%ecx
    4c86:	89 08                	mov    %ecx,(%eax)
    4c88:	8b 4a 04             	mov    0x4(%edx),%ecx
    4c8b:	89 48 04             	mov    %ecx,0x4(%eax)
    4c8e:	8b 4a 08             	mov    0x8(%edx),%ecx
    4c91:	89 48 08             	mov    %ecx,0x8(%eax)
    4c94:	8b 52 0c             	mov    0xc(%edx),%edx
    4c97:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    4c9a:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4c9e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4ca1:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4ca4:	0f 8c 50 ff ff ff    	jl     4bfa <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4caa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4cad:	01 c0                	add    %eax,%eax
    4caf:	01 45 ec             	add    %eax,-0x14(%ebp)
    4cb2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4cb5:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4cb8:	0f 8c fc fe ff ff    	jl     4bba <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    4cbe:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    4cc2:	d1 65 f4             	shll   -0xc(%ebp)
    4cc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4cc8:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4ccb:	0f 8c b3 fe ff ff    	jl     4b84 <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    4cd1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4cd4:	83 e0 01             	and    $0x1,%eax
    4cd7:	85 c0                	test   %eax,%eax
    4cd9:	74 18                	je     4cf3 <bpmnode_sort+0x19d>
    4cdb:	8b 45 0c             	mov    0xc(%ebp),%eax
    4cde:	c1 e0 04             	shl    $0x4,%eax
    4ce1:	83 ec 04             	sub    $0x4,%esp
    4ce4:	50                   	push   %eax
    4ce5:	ff 75 dc             	pushl  -0x24(%ebp)
    4ce8:	ff 75 08             	pushl  0x8(%ebp)
    4ceb:	e8 71 e6 ff ff       	call   3361 <lodepng_memcpy>
    4cf0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    4cf3:	83 ec 0c             	sub    $0xc,%esp
    4cf6:	ff 75 dc             	pushl  -0x24(%ebp)
    4cf9:	e8 46 e6 ff ff       	call   3344 <lodepng_free>
    4cfe:	83 c4 10             	add    $0x10,%esp
}
    4d01:	90                   	nop
    4d02:	c9                   	leave  
    4d03:	c3                   	ret    

00004d04 <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    4d04:	55                   	push   %ebp
    4d05:	89 e5                	mov    %esp,%ebp
    4d07:	56                   	push   %esi
    4d08:	53                   	push   %ebx
    4d09:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    4d0c:	8b 45 08             	mov    0x8(%ebp),%eax
    4d0f:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d12:	8b 55 14             	mov    0x14(%ebp),%edx
    4d15:	c1 e2 02             	shl    $0x2,%edx
    4d18:	01 d0                	add    %edx,%eax
    4d1a:	8b 00                	mov    (%eax),%eax
    4d1c:	8b 40 04             	mov    0x4(%eax),%eax
    4d1f:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    4d22:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    4d26:	75 66                	jne    4d8e <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    4d28:	8b 45 10             	mov    0x10(%ebp),%eax
    4d2b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4d2e:	0f 83 a0 01 00 00    	jae    4ed4 <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    4d34:	8b 45 08             	mov    0x8(%ebp),%eax
    4d37:	8b 40 18             	mov    0x18(%eax),%eax
    4d3a:	8b 55 14             	mov    0x14(%ebp),%edx
    4d3d:	c1 e2 02             	shl    $0x2,%edx
    4d40:	01 c2                	add    %eax,%edx
    4d42:	8b 45 08             	mov    0x8(%ebp),%eax
    4d45:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d48:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4d4b:	c1 e1 02             	shl    $0x2,%ecx
    4d4e:	01 c8                	add    %ecx,%eax
    4d50:	8b 00                	mov    (%eax),%eax
    4d52:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    4d54:	8b 45 08             	mov    0x8(%ebp),%eax
    4d57:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d5a:	8b 55 14             	mov    0x14(%ebp),%edx
    4d5d:	c1 e2 02             	shl    $0x2,%edx
    4d60:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4d63:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d66:	8d 50 01             	lea    0x1(%eax),%edx
    4d69:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d6c:	c1 e0 04             	shl    $0x4,%eax
    4d6f:	89 c1                	mov    %eax,%ecx
    4d71:	8b 45 0c             	mov    0xc(%ebp),%eax
    4d74:	01 c8                	add    %ecx,%eax
    4d76:	8b 00                	mov    (%eax),%eax
    4d78:	6a 00                	push   $0x0
    4d7a:	52                   	push   %edx
    4d7b:	50                   	push   %eax
    4d7c:	ff 75 08             	pushl  0x8(%ebp)
    4d7f:	e8 6a fc ff ff       	call   49ee <bpmnode_create>
    4d84:	83 c4 10             	add    $0x10,%esp
    4d87:	89 03                	mov    %eax,(%ebx)
    4d89:	e9 47 01 00 00       	jmp    4ed5 <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    4d8e:	8b 45 08             	mov    0x8(%ebp),%eax
    4d91:	8b 40 18             	mov    0x18(%eax),%eax
    4d94:	8b 55 14             	mov    0x14(%ebp),%edx
    4d97:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4d9d:	c1 e2 02             	shl    $0x2,%edx
    4da0:	01 d0                	add    %edx,%eax
    4da2:	8b 00                	mov    (%eax),%eax
    4da4:	8b 10                	mov    (%eax),%edx
    4da6:	8b 45 08             	mov    0x8(%ebp),%eax
    4da9:	8b 40 1c             	mov    0x1c(%eax),%eax
    4dac:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4daf:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    4db5:	c1 e1 02             	shl    $0x2,%ecx
    4db8:	01 c8                	add    %ecx,%eax
    4dba:	8b 00                	mov    (%eax),%eax
    4dbc:	8b 00                	mov    (%eax),%eax
    4dbe:	01 d0                	add    %edx,%eax
    4dc0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    4dc3:	8b 45 08             	mov    0x8(%ebp),%eax
    4dc6:	8b 40 18             	mov    0x18(%eax),%eax
    4dc9:	8b 55 14             	mov    0x14(%ebp),%edx
    4dcc:	c1 e2 02             	shl    $0x2,%edx
    4dcf:	01 c2                	add    %eax,%edx
    4dd1:	8b 45 08             	mov    0x8(%ebp),%eax
    4dd4:	8b 40 1c             	mov    0x1c(%eax),%eax
    4dd7:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4dda:	c1 e1 02             	shl    $0x2,%ecx
    4ddd:	01 c8                	add    %ecx,%eax
    4ddf:	8b 00                	mov    (%eax),%eax
    4de1:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    4de3:	8b 45 10             	mov    0x10(%ebp),%eax
    4de6:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4de9:	73 60                	jae    4e4b <boundaryPM+0x147>
    4deb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4dee:	c1 e0 04             	shl    $0x4,%eax
    4df1:	89 c2                	mov    %eax,%edx
    4df3:	8b 45 0c             	mov    0xc(%ebp),%eax
    4df6:	01 d0                	add    %edx,%eax
    4df8:	8b 00                	mov    (%eax),%eax
    4dfa:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4dfd:	7d 4c                	jge    4e4b <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    4dff:	8b 45 08             	mov    0x8(%ebp),%eax
    4e02:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e05:	8b 55 14             	mov    0x14(%ebp),%edx
    4e08:	c1 e2 02             	shl    $0x2,%edx
    4e0b:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4e0e:	8b 45 08             	mov    0x8(%ebp),%eax
    4e11:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e14:	8b 55 14             	mov    0x14(%ebp),%edx
    4e17:	c1 e2 02             	shl    $0x2,%edx
    4e1a:	01 d0                	add    %edx,%eax
    4e1c:	8b 00                	mov    (%eax),%eax
    4e1e:	8b 50 08             	mov    0x8(%eax),%edx
    4e21:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e24:	8d 48 01             	lea    0x1(%eax),%ecx
    4e27:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e2a:	c1 e0 04             	shl    $0x4,%eax
    4e2d:	89 c6                	mov    %eax,%esi
    4e2f:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e32:	01 f0                	add    %esi,%eax
    4e34:	8b 00                	mov    (%eax),%eax
    4e36:	52                   	push   %edx
    4e37:	51                   	push   %ecx
    4e38:	50                   	push   %eax
    4e39:	ff 75 08             	pushl  0x8(%ebp)
    4e3c:	e8 ad fb ff ff       	call   49ee <bpmnode_create>
    4e41:	83 c4 10             	add    $0x10,%esp
    4e44:	89 03                	mov    %eax,(%ebx)
      return;
    4e46:	e9 8a 00 00 00       	jmp    4ed5 <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    4e4b:	8b 45 08             	mov    0x8(%ebp),%eax
    4e4e:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e51:	8b 55 14             	mov    0x14(%ebp),%edx
    4e54:	c1 e2 02             	shl    $0x2,%edx
    4e57:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4e5a:	8b 45 08             	mov    0x8(%ebp),%eax
    4e5d:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e60:	8b 55 14             	mov    0x14(%ebp),%edx
    4e63:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4e69:	c1 e2 02             	shl    $0x2,%edx
    4e6c:	01 d0                	add    %edx,%eax
    4e6e:	8b 00                	mov    (%eax),%eax
    4e70:	50                   	push   %eax
    4e71:	ff 75 f4             	pushl  -0xc(%ebp)
    4e74:	ff 75 f0             	pushl  -0x10(%ebp)
    4e77:	ff 75 08             	pushl  0x8(%ebp)
    4e7a:	e8 6f fb ff ff       	call   49ee <bpmnode_create>
    4e7f:	83 c4 10             	add    $0x10,%esp
    4e82:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    4e84:	8b 45 18             	mov    0x18(%ebp),%eax
    4e87:	8d 50 01             	lea    0x1(%eax),%edx
    4e8a:	8b 45 10             	mov    0x10(%ebp),%eax
    4e8d:	83 e8 01             	sub    $0x1,%eax
    4e90:	01 c0                	add    %eax,%eax
    4e92:	39 c2                	cmp    %eax,%edx
    4e94:	7d 3f                	jge    4ed5 <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4e96:	8b 45 14             	mov    0x14(%ebp),%eax
    4e99:	83 e8 01             	sub    $0x1,%eax
    4e9c:	83 ec 0c             	sub    $0xc,%esp
    4e9f:	ff 75 18             	pushl  0x18(%ebp)
    4ea2:	50                   	push   %eax
    4ea3:	ff 75 10             	pushl  0x10(%ebp)
    4ea6:	ff 75 0c             	pushl  0xc(%ebp)
    4ea9:	ff 75 08             	pushl  0x8(%ebp)
    4eac:	e8 53 fe ff ff       	call   4d04 <boundaryPM>
    4eb1:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4eb4:	8b 45 14             	mov    0x14(%ebp),%eax
    4eb7:	83 e8 01             	sub    $0x1,%eax
    4eba:	83 ec 0c             	sub    $0xc,%esp
    4ebd:	ff 75 18             	pushl  0x18(%ebp)
    4ec0:	50                   	push   %eax
    4ec1:	ff 75 10             	pushl  0x10(%ebp)
    4ec4:	ff 75 0c             	pushl  0xc(%ebp)
    4ec7:	ff 75 08             	pushl  0x8(%ebp)
    4eca:	e8 35 fe ff ff       	call   4d04 <boundaryPM>
    4ecf:	83 c4 20             	add    $0x20,%esp
    4ed2:	eb 01                	jmp    4ed5 <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    4ed4:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    4ed5:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4ed8:	5b                   	pop    %ebx
    4ed9:	5e                   	pop    %esi
    4eda:	5d                   	pop    %ebp
    4edb:	c3                   	ret    

00004edc <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    4edc:	55                   	push   %ebp
    4edd:	89 e5                	mov    %esp,%ebp
    4edf:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    4ee2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    4ee9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    4ef0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    4ef4:	75 0a                	jne    4f00 <lodepng_huffman_code_lengths+0x24>
    4ef6:	b8 50 00 00 00       	mov    $0x50,%eax
    4efb:	e9 4d 03 00 00       	jmp    524d <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    4f00:	8b 45 14             	mov    0x14(%ebp),%eax
    4f03:	ba 01 00 00 00       	mov    $0x1,%edx
    4f08:	89 c1                	mov    %eax,%ecx
    4f0a:	d3 e2                	shl    %cl,%edx
    4f0c:	8b 45 10             	mov    0x10(%ebp),%eax
    4f0f:	39 c2                	cmp    %eax,%edx
    4f11:	73 0a                	jae    4f1d <lodepng_huffman_code_lengths+0x41>
    4f13:	b8 50 00 00 00       	mov    $0x50,%eax
    4f18:	e9 30 03 00 00       	jmp    524d <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    4f1d:	8b 45 10             	mov    0x10(%ebp),%eax
    4f20:	c1 e0 04             	shl    $0x4,%eax
    4f23:	83 ec 0c             	sub    $0xc,%esp
    4f26:	50                   	push   %eax
    4f27:	e8 f7 e3 ff ff       	call   3323 <lodepng_malloc>
    4f2c:	83 c4 10             	add    $0x10,%esp
    4f2f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    4f32:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4f36:	75 0a                	jne    4f42 <lodepng_huffman_code_lengths+0x66>
    4f38:	b8 53 00 00 00       	mov    $0x53,%eax
    4f3d:	e9 0b 03 00 00       	jmp    524d <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    4f42:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4f49:	eb 50                	jmp    4f9b <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    4f4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4f4e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4f55:	8b 45 0c             	mov    0xc(%ebp),%eax
    4f58:	01 d0                	add    %edx,%eax
    4f5a:	8b 00                	mov    (%eax),%eax
    4f5c:	85 c0                	test   %eax,%eax
    4f5e:	74 37                	je     4f97 <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    4f60:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f63:	c1 e0 04             	shl    $0x4,%eax
    4f66:	89 c2                	mov    %eax,%edx
    4f68:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4f6b:	01 d0                	add    %edx,%eax
    4f6d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4f70:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    4f77:	8b 55 0c             	mov    0xc(%ebp),%edx
    4f7a:	01 ca                	add    %ecx,%edx
    4f7c:	8b 12                	mov    (%edx),%edx
    4f7e:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    4f80:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f83:	c1 e0 04             	shl    $0x4,%eax
    4f86:	89 c2                	mov    %eax,%edx
    4f88:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4f8b:	01 c2                	add    %eax,%edx
    4f8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4f90:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    4f93:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    4f97:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4f9b:	8b 45 10             	mov    0x10(%ebp),%eax
    4f9e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    4fa1:	75 a8                	jne    4f4b <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    4fa3:	8b 45 10             	mov    0x10(%ebp),%eax
    4fa6:	c1 e0 02             	shl    $0x2,%eax
    4fa9:	83 ec 04             	sub    $0x4,%esp
    4fac:	50                   	push   %eax
    4fad:	6a 00                	push   $0x0
    4faf:	ff 75 08             	pushl  0x8(%ebp)
    4fb2:	e8 dd e3 ff ff       	call   3394 <lodepng_memset>
    4fb7:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    4fba:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    4fbe:	75 18                	jne    4fd8 <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    4fc0:	8b 45 08             	mov    0x8(%ebp),%eax
    4fc3:	83 c0 04             	add    $0x4,%eax
    4fc6:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    4fcc:	8b 10                	mov    (%eax),%edx
    4fce:	8b 45 08             	mov    0x8(%ebp),%eax
    4fd1:	89 10                	mov    %edx,(%eax)
    4fd3:	e9 64 02 00 00       	jmp    523c <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    4fd8:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    4fdc:	75 3e                	jne    501c <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    4fde:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4fe1:	8b 40 04             	mov    0x4(%eax),%eax
    4fe4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4feb:	8b 45 08             	mov    0x8(%ebp),%eax
    4fee:	01 d0                	add    %edx,%eax
    4ff0:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    4ff6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4ff9:	8b 40 04             	mov    0x4(%eax),%eax
    4ffc:	85 c0                	test   %eax,%eax
    4ffe:	75 07                	jne    5007 <lodepng_huffman_code_lengths+0x12b>
    5000:	ba 04 00 00 00       	mov    $0x4,%edx
    5005:	eb 05                	jmp    500c <lodepng_huffman_code_lengths+0x130>
    5007:	ba 00 00 00 00       	mov    $0x0,%edx
    500c:	8b 45 08             	mov    0x8(%ebp),%eax
    500f:	01 d0                	add    %edx,%eax
    5011:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    5017:	e9 20 02 00 00       	jmp    523c <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    501c:	83 ec 08             	sub    $0x8,%esp
    501f:	ff 75 ec             	pushl  -0x14(%ebp)
    5022:	ff 75 e4             	pushl  -0x1c(%ebp)
    5025:	e8 2c fb ff ff       	call   4b56 <bpmnode_sort>
    502a:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    502d:	8b 45 14             	mov    0x14(%ebp),%eax
    5030:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    5033:	8b 45 14             	mov    0x14(%ebp),%eax
    5036:	83 c0 01             	add    $0x1,%eax
    5039:	0f af 45 14          	imul   0x14(%ebp),%eax
    503d:	01 c0                	add    %eax,%eax
    503f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    5042:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    5049:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    504c:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    504f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5052:	c1 e0 04             	shl    $0x4,%eax
    5055:	83 ec 0c             	sub    $0xc,%esp
    5058:	50                   	push   %eax
    5059:	e8 c5 e2 ff ff       	call   3323 <lodepng_malloc>
    505e:	83 c4 10             	add    $0x10,%esp
    5061:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    5064:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5067:	c1 e0 02             	shl    $0x2,%eax
    506a:	83 ec 0c             	sub    $0xc,%esp
    506d:	50                   	push   %eax
    506e:	e8 b0 e2 ff ff       	call   3323 <lodepng_malloc>
    5073:	83 c4 10             	add    $0x10,%esp
    5076:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5079:	8b 45 d8             	mov    -0x28(%ebp),%eax
    507c:	c1 e0 02             	shl    $0x2,%eax
    507f:	83 ec 0c             	sub    $0xc,%esp
    5082:	50                   	push   %eax
    5083:	e8 9b e2 ff ff       	call   3323 <lodepng_malloc>
    5088:	83 c4 10             	add    $0x10,%esp
    508b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    508e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5091:	c1 e0 02             	shl    $0x2,%eax
    5094:	83 ec 0c             	sub    $0xc,%esp
    5097:	50                   	push   %eax
    5098:	e8 86 e2 ff ff       	call   3323 <lodepng_malloc>
    509d:	83 c4 10             	add    $0x10,%esp
    50a0:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    50a3:	8b 45 c8             	mov    -0x38(%ebp),%eax
    50a6:	85 c0                	test   %eax,%eax
    50a8:	74 15                	je     50bf <lodepng_huffman_code_lengths+0x1e3>
    50aa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    50ad:	85 c0                	test   %eax,%eax
    50af:	74 0e                	je     50bf <lodepng_huffman_code_lengths+0x1e3>
    50b1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    50b4:	85 c0                	test   %eax,%eax
    50b6:	74 07                	je     50bf <lodepng_huffman_code_lengths+0x1e3>
    50b8:	8b 45 e0             	mov    -0x20(%ebp),%eax
    50bb:	85 c0                	test   %eax,%eax
    50bd:	75 07                	jne    50c6 <lodepng_huffman_code_lengths+0x1ea>
    50bf:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    50c6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    50ca:	0f 85 30 01 00 00    	jne    5200 <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    50d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    50d7:	eb 1c                	jmp    50f5 <lodepng_huffman_code_lengths+0x219>
    50d9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    50dc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    50df:	c1 e2 02             	shl    $0x2,%edx
    50e2:	01 d0                	add    %edx,%eax
    50e4:	8b 55 c8             	mov    -0x38(%ebp),%edx
    50e7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    50ea:	c1 e1 04             	shl    $0x4,%ecx
    50ed:	01 ca                	add    %ecx,%edx
    50ef:	89 10                	mov    %edx,(%eax)
    50f1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    50f5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    50f8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    50fb:	75 dc                	jne    50d9 <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    50fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5100:	8b 00                	mov    (%eax),%eax
    5102:	6a 00                	push   $0x0
    5104:	6a 01                	push   $0x1
    5106:	50                   	push   %eax
    5107:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    510a:	50                   	push   %eax
    510b:	e8 de f8 ff ff       	call   49ee <bpmnode_create>
    5110:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    5113:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5116:	83 c0 10             	add    $0x10,%eax
    5119:	8b 00                	mov    (%eax),%eax
    511b:	6a 00                	push   $0x0
    511d:	6a 02                	push   $0x2
    511f:	50                   	push   %eax
    5120:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5123:	50                   	push   %eax
    5124:	e8 c5 f8 ff ff       	call   49ee <bpmnode_create>
    5129:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    512c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5133:	eb 27                	jmp    515c <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    5135:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5138:	8b 55 f0             	mov    -0x10(%ebp),%edx
    513b:	c1 e2 02             	shl    $0x2,%edx
    513e:	01 c2                	add    %eax,%edx
    5140:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5143:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    5145:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5148:	8b 55 f0             	mov    -0x10(%ebp),%edx
    514b:	c1 e2 02             	shl    $0x2,%edx
    514e:	01 d0                	add    %edx,%eax
    5150:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5153:	83 c2 10             	add    $0x10,%edx
    5156:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    5158:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    515c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    515f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5162:	75 d1                	jne    5135 <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    5164:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    516b:	eb 24                	jmp    5191 <lodepng_huffman_code_lengths+0x2b5>
    516d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5170:	8b 55 14             	mov    0x14(%ebp),%edx
    5173:	83 ea 01             	sub    $0x1,%edx
    5176:	83 ec 0c             	sub    $0xc,%esp
    5179:	50                   	push   %eax
    517a:	52                   	push   %edx
    517b:	ff 75 ec             	pushl  -0x14(%ebp)
    517e:	ff 75 e4             	pushl  -0x1c(%ebp)
    5181:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5184:	50                   	push   %eax
    5185:	e8 7a fb ff ff       	call   4d04 <boundaryPM>
    518a:	83 c4 20             	add    $0x20,%esp
    518d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5191:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5194:	83 e8 01             	sub    $0x1,%eax
    5197:	01 c0                	add    %eax,%eax
    5199:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    519c:	75 cf                	jne    516d <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    519e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    51a1:	8b 55 14             	mov    0x14(%ebp),%edx
    51a4:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    51aa:	c1 e2 02             	shl    $0x2,%edx
    51ad:	01 d0                	add    %edx,%eax
    51af:	8b 00                	mov    (%eax),%eax
    51b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    51b4:	eb 44                	jmp    51fa <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    51b6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    51bd:	eb 27                	jmp    51e6 <lodepng_huffman_code_lengths+0x30a>
    51bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    51c2:	c1 e0 04             	shl    $0x4,%eax
    51c5:	89 c2                	mov    %eax,%edx
    51c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    51ca:	01 d0                	add    %edx,%eax
    51cc:	8b 40 04             	mov    0x4(%eax),%eax
    51cf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    51d6:	8b 45 08             	mov    0x8(%ebp),%eax
    51d9:	01 d0                	add    %edx,%eax
    51db:	8b 10                	mov    (%eax),%edx
    51dd:	83 c2 01             	add    $0x1,%edx
    51e0:	89 10                	mov    %edx,(%eax)
    51e2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    51e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    51e9:	8b 40 04             	mov    0x4(%eax),%eax
    51ec:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    51ef:	75 ce                	jne    51bf <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    51f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    51f4:	8b 40 08             	mov    0x8(%eax),%eax
    51f7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    51fa:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    51fe:	75 b6                	jne    51b6 <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    5200:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5203:	83 ec 0c             	sub    $0xc,%esp
    5206:	50                   	push   %eax
    5207:	e8 38 e1 ff ff       	call   3344 <lodepng_free>
    520c:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    520f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5212:	83 ec 0c             	sub    $0xc,%esp
    5215:	50                   	push   %eax
    5216:	e8 29 e1 ff ff       	call   3344 <lodepng_free>
    521b:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    521e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5221:	83 ec 0c             	sub    $0xc,%esp
    5224:	50                   	push   %eax
    5225:	e8 1a e1 ff ff       	call   3344 <lodepng_free>
    522a:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    522d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5230:	83 ec 0c             	sub    $0xc,%esp
    5233:	50                   	push   %eax
    5234:	e8 0b e1 ff ff       	call   3344 <lodepng_free>
    5239:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    523c:	83 ec 0c             	sub    $0xc,%esp
    523f:	ff 75 e4             	pushl  -0x1c(%ebp)
    5242:	e8 fd e0 ff ff       	call   3344 <lodepng_free>
    5247:	83 c4 10             	add    $0x10,%esp
  return error;
    524a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    524d:	c9                   	leave  
    524e:	c3                   	ret    

0000524f <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    524f:	55                   	push   %ebp
    5250:	89 e5                	mov    %esp,%ebp
    5252:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    5255:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    525c:	eb 04                	jmp    5262 <HuffmanTree_makeFromFrequencies+0x13>
    525e:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    5262:	8b 45 14             	mov    0x14(%ebp),%eax
    5265:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    526a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5271:	8b 45 0c             	mov    0xc(%ebp),%eax
    5274:	01 d0                	add    %edx,%eax
    5276:	8b 00                	mov    (%eax),%eax
    5278:	85 c0                	test   %eax,%eax
    527a:	75 08                	jne    5284 <HuffmanTree_makeFromFrequencies+0x35>
    527c:	8b 45 14             	mov    0x14(%ebp),%eax
    527f:	3b 45 10             	cmp    0x10(%ebp),%eax
    5282:	7f da                	jg     525e <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    5284:	8b 45 14             	mov    0x14(%ebp),%eax
    5287:	c1 e0 02             	shl    $0x2,%eax
    528a:	83 ec 0c             	sub    $0xc,%esp
    528d:	50                   	push   %eax
    528e:	e8 90 e0 ff ff       	call   3323 <lodepng_malloc>
    5293:	83 c4 10             	add    $0x10,%esp
    5296:	89 c2                	mov    %eax,%edx
    5298:	8b 45 08             	mov    0x8(%ebp),%eax
    529b:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    529e:	8b 45 08             	mov    0x8(%ebp),%eax
    52a1:	8b 40 04             	mov    0x4(%eax),%eax
    52a4:	85 c0                	test   %eax,%eax
    52a6:	75 07                	jne    52af <HuffmanTree_makeFromFrequencies+0x60>
    52a8:	b8 53 00 00 00       	mov    $0x53,%eax
    52ad:	eb 47                	jmp    52f6 <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    52af:	8b 45 08             	mov    0x8(%ebp),%eax
    52b2:	8b 55 18             	mov    0x18(%ebp),%edx
    52b5:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    52b8:	8b 55 14             	mov    0x14(%ebp),%edx
    52bb:	8b 45 08             	mov    0x8(%ebp),%eax
    52be:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    52c1:	8b 45 08             	mov    0x8(%ebp),%eax
    52c4:	8b 40 04             	mov    0x4(%eax),%eax
    52c7:	ff 75 18             	pushl  0x18(%ebp)
    52ca:	ff 75 14             	pushl  0x14(%ebp)
    52cd:	ff 75 0c             	pushl  0xc(%ebp)
    52d0:	50                   	push   %eax
    52d1:	e8 06 fc ff ff       	call   4edc <lodepng_huffman_code_lengths>
    52d6:	83 c4 10             	add    $0x10,%esp
    52d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    52dc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    52e0:	75 11                	jne    52f3 <HuffmanTree_makeFromFrequencies+0xa4>
    52e2:	83 ec 0c             	sub    $0xc,%esp
    52e5:	ff 75 08             	pushl  0x8(%ebp)
    52e8:	e8 37 f4 ff ff       	call   4724 <HuffmanTree_makeFromLengths2>
    52ed:	83 c4 10             	add    $0x10,%esp
    52f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    52f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    52f6:	c9                   	leave  
    52f7:	c3                   	ret    

000052f8 <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    52f8:	55                   	push   %ebp
    52f9:	89 e5                	mov    %esp,%ebp
    52fb:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    52fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    5305:	83 ec 0c             	sub    $0xc,%esp
    5308:	68 80 04 00 00       	push   $0x480
    530d:	e8 11 e0 ff ff       	call   3323 <lodepng_malloc>
    5312:	83 c4 10             	add    $0x10,%esp
    5315:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    5318:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    531c:	75 0a                	jne    5328 <generateFixedLitLenTree+0x30>
    531e:	b8 53 00 00 00       	mov    $0x53,%eax
    5323:	e9 d5 00 00 00       	jmp    53fd <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    5328:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    532f:	eb 19                	jmp    534a <generateFixedLitLenTree+0x52>
    5331:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5334:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    533b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    533e:	01 d0                	add    %edx,%eax
    5340:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5346:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    534a:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    5351:	76 de                	jbe    5331 <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    5353:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    535a:	eb 19                	jmp    5375 <generateFixedLitLenTree+0x7d>
    535c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    535f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5366:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5369:	01 d0                	add    %edx,%eax
    536b:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    5371:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5375:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    537c:	76 de                	jbe    535c <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    537e:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    5385:	eb 19                	jmp    53a0 <generateFixedLitLenTree+0xa8>
    5387:	8b 45 f4             	mov    -0xc(%ebp),%eax
    538a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5391:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5394:	01 d0                	add    %edx,%eax
    5396:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    539c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    53a0:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    53a7:	76 de                	jbe    5387 <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    53a9:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    53b0:	eb 19                	jmp    53cb <generateFixedLitLenTree+0xd3>
    53b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    53b5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    53bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    53bf:	01 d0                	add    %edx,%eax
    53c1:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    53c7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    53cb:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    53d2:	76 de                	jbe    53b2 <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    53d4:	6a 0f                	push   $0xf
    53d6:	68 20 01 00 00       	push   $0x120
    53db:	ff 75 ec             	pushl  -0x14(%ebp)
    53de:	ff 75 08             	pushl  0x8(%ebp)
    53e1:	e8 7f f5 ff ff       	call   4965 <HuffmanTree_makeFromLengths>
    53e6:	83 c4 10             	add    $0x10,%esp
    53e9:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    53ec:	83 ec 0c             	sub    $0xc,%esp
    53ef:	ff 75 ec             	pushl  -0x14(%ebp)
    53f2:	e8 4d df ff ff       	call   3344 <lodepng_free>
    53f7:	83 c4 10             	add    $0x10,%esp
  return error;
    53fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    53fd:	c9                   	leave  
    53fe:	c3                   	ret    

000053ff <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    53ff:	55                   	push   %ebp
    5400:	89 e5                	mov    %esp,%ebp
    5402:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    5405:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    540c:	83 ec 0c             	sub    $0xc,%esp
    540f:	68 80 00 00 00       	push   $0x80
    5414:	e8 0a df ff ff       	call   3323 <lodepng_malloc>
    5419:	83 c4 10             	add    $0x10,%esp
    541c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    541f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5423:	75 07                	jne    542c <generateFixedDistanceTree+0x2d>
    5425:	b8 53 00 00 00       	mov    $0x53,%eax
    542a:	eb 4e                	jmp    547a <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    542c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5433:	eb 19                	jmp    544e <generateFixedDistanceTree+0x4f>
    5435:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5438:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    543f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5442:	01 d0                	add    %edx,%eax
    5444:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    544a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    544e:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    5452:	75 e1                	jne    5435 <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    5454:	6a 0f                	push   $0xf
    5456:	6a 20                	push   $0x20
    5458:	ff 75 ec             	pushl  -0x14(%ebp)
    545b:	ff 75 08             	pushl  0x8(%ebp)
    545e:	e8 02 f5 ff ff       	call   4965 <HuffmanTree_makeFromLengths>
    5463:	83 c4 10             	add    $0x10,%esp
    5466:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    5469:	83 ec 0c             	sub    $0xc,%esp
    546c:	ff 75 ec             	pushl  -0x14(%ebp)
    546f:	e8 d0 de ff ff       	call   3344 <lodepng_free>
    5474:	83 c4 10             	add    $0x10,%esp
  return error;
    5477:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    547a:	c9                   	leave  
    547b:	c3                   	ret    

0000547c <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    547c:	55                   	push   %ebp
    547d:	89 e5                	mov    %esp,%ebp
    547f:	53                   	push   %ebx
    5480:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    5483:	6a 09                	push   $0x9
    5485:	ff 75 08             	pushl  0x8(%ebp)
    5488:	e8 d8 eb ff ff       	call   4065 <peekBits>
    548d:	83 c4 08             	add    $0x8,%esp
    5490:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    5494:	8b 45 0c             	mov    0xc(%ebp),%eax
    5497:	8b 50 10             	mov    0x10(%eax),%edx
    549a:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    549e:	01 d0                	add    %edx,%eax
    54a0:	0f b6 00             	movzbl (%eax),%eax
    54a3:	0f b6 c0             	movzbl %al,%eax
    54a6:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    54aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    54ad:	8b 40 14             	mov    0x14(%eax),%eax
    54b0:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    54b4:	01 d2                	add    %edx,%edx
    54b6:	01 d0                	add    %edx,%eax
    54b8:	0f b7 00             	movzwl (%eax),%eax
    54bb:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    54bf:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    54c4:	77 16                	ja     54dc <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    54c6:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    54ca:	50                   	push   %eax
    54cb:	ff 75 08             	pushl  0x8(%ebp)
    54ce:	e8 b2 eb ff ff       	call   4085 <advanceBits>
    54d3:	83 c4 08             	add    $0x8,%esp
    return value;
    54d6:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    54da:	eb 5c                	jmp    5538 <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    54dc:	6a 09                	push   $0x9
    54de:	ff 75 08             	pushl  0x8(%ebp)
    54e1:	e8 9f eb ff ff       	call   4085 <advanceBits>
    54e6:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    54e9:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    54ed:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    54f1:	83 e8 09             	sub    $0x9,%eax
    54f4:	50                   	push   %eax
    54f5:	ff 75 08             	pushl  0x8(%ebp)
    54f8:	e8 68 eb ff ff       	call   4065 <peekBits>
    54fd:	83 c4 08             	add    $0x8,%esp
    5500:	01 d8                	add    %ebx,%eax
    5502:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    5505:	8b 45 0c             	mov    0xc(%ebp),%eax
    5508:	8b 50 10             	mov    0x10(%eax),%edx
    550b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    550e:	01 d0                	add    %edx,%eax
    5510:	0f b6 00             	movzbl (%eax),%eax
    5513:	0f b6 c0             	movzbl %al,%eax
    5516:	83 e8 09             	sub    $0x9,%eax
    5519:	50                   	push   %eax
    551a:	ff 75 08             	pushl  0x8(%ebp)
    551d:	e8 63 eb ff ff       	call   4085 <advanceBits>
    5522:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    5525:	8b 45 0c             	mov    0xc(%ebp),%eax
    5528:	8b 40 14             	mov    0x14(%eax),%eax
    552b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    552e:	01 d2                	add    %edx,%edx
    5530:	01 d0                	add    %edx,%eax
    5532:	0f b7 00             	movzwl (%eax),%eax
    5535:	0f b7 c0             	movzwl %ax,%eax
  }
}
    5538:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    553b:	c9                   	leave  
    553c:	c3                   	ret    

0000553d <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    553d:	55                   	push   %ebp
    553e:	89 e5                	mov    %esp,%ebp
    5540:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    5543:	83 ec 0c             	sub    $0xc,%esp
    5546:	ff 75 08             	pushl  0x8(%ebp)
    5549:	e8 aa fd ff ff       	call   52f8 <generateFixedLitLenTree>
    554e:	83 c4 10             	add    $0x10,%esp
    5551:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    5554:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5558:	74 05                	je     555f <getTreeInflateFixed+0x22>
    555a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    555d:	eb 0e                	jmp    556d <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    555f:	83 ec 0c             	sub    $0xc,%esp
    5562:	ff 75 0c             	pushl  0xc(%ebp)
    5565:	e8 95 fe ff ff       	call   53ff <generateFixedDistanceTree>
    556a:	83 c4 10             	add    $0x10,%esp
}
    556d:	c9                   	leave  
    556e:	c3                   	ret    

0000556f <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    556f:	55                   	push   %ebp
    5570:	89 e5                	mov    %esp,%ebp
    5572:	53                   	push   %ebx
    5573:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    5576:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    557d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    5584:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    558b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    5592:	6a 0e                	push   $0xe
    5594:	ff 75 10             	pushl  0x10(%ebp)
    5597:	e8 37 e6 ff ff       	call   3bd3 <ensureBits17>
    559c:	83 c4 08             	add    $0x8,%esp
    559f:	85 c0                	test   %eax,%eax
    55a1:	75 0a                	jne    55ad <getTreeInflateDynamic+0x3e>
    55a3:	b8 31 00 00 00       	mov    $0x31,%eax
    55a8:	e9 ec 04 00 00       	jmp    5a99 <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    55ad:	6a 05                	push   $0x5
    55af:	ff 75 10             	pushl  0x10(%ebp)
    55b2:	e8 f8 ea ff ff       	call   40af <readBits>
    55b7:	83 c4 08             	add    $0x8,%esp
    55ba:	05 01 01 00 00       	add    $0x101,%eax
    55bf:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    55c2:	6a 05                	push   $0x5
    55c4:	ff 75 10             	pushl  0x10(%ebp)
    55c7:	e8 e3 ea ff ff       	call   40af <readBits>
    55cc:	83 c4 08             	add    $0x8,%esp
    55cf:	83 c0 01             	add    $0x1,%eax
    55d2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    55d5:	6a 04                	push   $0x4
    55d7:	ff 75 10             	pushl  0x10(%ebp)
    55da:	e8 d0 ea ff ff       	call   40af <readBits>
    55df:	83 c4 08             	add    $0x8,%esp
    55e2:	83 c0 04             	add    $0x4,%eax
    55e5:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    55e8:	83 ec 0c             	sub    $0xc,%esp
    55eb:	6a 4c                	push   $0x4c
    55ed:	e8 31 dd ff ff       	call   3323 <lodepng_malloc>
    55f2:	83 c4 10             	add    $0x10,%esp
    55f5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    55f8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    55fc:	75 0a                	jne    5608 <getTreeInflateDynamic+0x99>
    55fe:	b8 53 00 00 00       	mov    $0x53,%eax
    5603:	e9 91 04 00 00       	jmp    5a99 <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    5608:	83 ec 0c             	sub    $0xc,%esp
    560b:	8d 45 a8             	lea    -0x58(%ebp),%eax
    560e:	50                   	push   %eax
    560f:	e8 03 ec ff ff       	call   4217 <HuffmanTree_init>
    5614:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    5617:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    561b:	0f 85 3c 04 00 00    	jne    5a5d <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    5621:	8b 45 10             	mov    0x10(%ebp),%eax
    5624:	8b 48 08             	mov    0x8(%eax),%ecx
    5627:	8b 55 d0             	mov    -0x30(%ebp),%edx
    562a:	89 d0                	mov    %edx,%eax
    562c:	01 c0                	add    %eax,%eax
    562e:	01 d0                	add    %edx,%eax
    5630:	89 c2                	mov    %eax,%edx
    5632:	8b 45 10             	mov    0x10(%ebp),%eax
    5635:	8b 40 0c             	mov    0xc(%eax),%eax
    5638:	83 ec 04             	sub    $0x4,%esp
    563b:	51                   	push   %ecx
    563c:	52                   	push   %edx
    563d:	50                   	push   %eax
    563e:	e8 f7 dd ff ff       	call   343a <lodepng_gtofl>
    5643:	83 c4 10             	add    $0x10,%esp
    5646:	85 c0                	test   %eax,%eax
    5648:	74 0c                	je     5656 <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    564a:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5651:	e9 07 04 00 00       	jmp    5a5d <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    5656:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    565d:	eb 3d                	jmp    569c <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    565f:	83 ec 08             	sub    $0x8,%esp
    5662:	6a 03                	push   $0x3
    5664:	ff 75 10             	pushl  0x10(%ebp)
    5667:	e8 8b e4 ff ff       	call   3af7 <ensureBits9>
    566c:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    566f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5672:	8b 04 85 20 9f 01 00 	mov    0x19f20(,%eax,4),%eax
    5679:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5680:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5683:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    5686:	83 ec 08             	sub    $0x8,%esp
    5689:	6a 03                	push   $0x3
    568b:	ff 75 10             	pushl  0x10(%ebp)
    568e:	e8 1c ea ff ff       	call   40af <readBits>
    5693:	83 c4 10             	add    $0x10,%esp
    5696:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    5698:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    569c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    569f:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    56a2:	75 bb                	jne    565f <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    56a4:	8b 45 d0             	mov    -0x30(%ebp),%eax
    56a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    56aa:	eb 20                	jmp    56cc <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    56ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
    56af:	8b 04 85 20 9f 01 00 	mov    0x19f20(,%eax,4),%eax
    56b6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    56bd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    56c0:	01 d0                	add    %edx,%eax
    56c2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    56c8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    56cc:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    56d0:	75 da                	jne    56ac <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    56d2:	6a 07                	push   $0x7
    56d4:	6a 13                	push   $0x13
    56d6:	ff 75 dc             	pushl  -0x24(%ebp)
    56d9:	8d 45 a8             	lea    -0x58(%ebp),%eax
    56dc:	50                   	push   %eax
    56dd:	e8 83 f2 ff ff       	call   4965 <HuffmanTree_makeFromLengths>
    56e2:	83 c4 10             	add    $0x10,%esp
    56e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    56e8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    56ec:	0f 85 64 03 00 00    	jne    5a56 <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    56f2:	83 ec 0c             	sub    $0xc,%esp
    56f5:	68 80 04 00 00       	push   $0x480
    56fa:	e8 24 dc ff ff       	call   3323 <lodepng_malloc>
    56ff:	83 c4 10             	add    $0x10,%esp
    5702:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    5705:	83 ec 0c             	sub    $0xc,%esp
    5708:	68 80 00 00 00       	push   $0x80
    570d:	e8 11 dc ff ff       	call   3323 <lodepng_malloc>
    5712:	83 c4 10             	add    $0x10,%esp
    5715:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    5718:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    571c:	74 06                	je     5724 <getTreeInflateDynamic+0x1b5>
    571e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5722:	75 0c                	jne    5730 <getTreeInflateDynamic+0x1c1>
    5724:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    572b:	e9 2d 03 00 00       	jmp    5a5d <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    5730:	83 ec 04             	sub    $0x4,%esp
    5733:	68 80 04 00 00       	push   $0x480
    5738:	6a 00                	push   $0x0
    573a:	ff 75 e8             	pushl  -0x18(%ebp)
    573d:	e8 52 dc ff ff       	call   3394 <lodepng_memset>
    5742:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    5745:	83 ec 04             	sub    $0x4,%esp
    5748:	68 80 00 00 00       	push   $0x80
    574d:	6a 00                	push   $0x0
    574f:	ff 75 e4             	pushl  -0x1c(%ebp)
    5752:	e8 3d dc ff ff       	call   3394 <lodepng_memset>
    5757:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    575a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    5761:	e9 8d 02 00 00       	jmp    59f3 <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    5766:	83 ec 08             	sub    $0x8,%esp
    5769:	6a 16                	push   $0x16
    576b:	ff 75 10             	pushl  0x10(%ebp)
    576e:	e8 8c e5 ff ff       	call   3cff <ensureBits25>
    5773:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    5776:	83 ec 08             	sub    $0x8,%esp
    5779:	8d 45 a8             	lea    -0x58(%ebp),%eax
    577c:	50                   	push   %eax
    577d:	ff 75 10             	pushl  0x10(%ebp)
    5780:	e8 f7 fc ff ff       	call   547c <huffmanDecodeSymbol>
    5785:	83 c4 10             	add    $0x10,%esp
    5788:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    578b:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    578f:	77 3e                	ja     57cf <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    5791:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5794:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5797:	73 16                	jae    57af <getTreeInflateDynamic+0x240>
    5799:	8b 45 ec             	mov    -0x14(%ebp),%eax
    579c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    57a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    57a6:	01 c2                	add    %eax,%edx
    57a8:	8b 45 cc             	mov    -0x34(%ebp),%eax
    57ab:	89 02                	mov    %eax,(%edx)
    57ad:	eb 17                	jmp    57c6 <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    57af:	8b 45 ec             	mov    -0x14(%ebp),%eax
    57b2:	2b 45 d8             	sub    -0x28(%ebp),%eax
    57b5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    57bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    57bf:	01 c2                	add    %eax,%edx
    57c1:	8b 45 cc             	mov    -0x34(%ebp),%eax
    57c4:	89 02                	mov    %eax,(%edx)
        ++i;
    57c6:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    57ca:	e9 0b 02 00 00       	jmp    59da <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    57cf:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    57d3:	0f 85 da 00 00 00    	jne    58b3 <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    57d9:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    57e0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    57e4:	75 0c                	jne    57f2 <getTreeInflateDynamic+0x283>
    57e6:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    57ed:	e9 12 02 00 00       	jmp    5a04 <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    57f2:	83 ec 08             	sub    $0x8,%esp
    57f5:	6a 02                	push   $0x2
    57f7:	ff 75 10             	pushl  0x10(%ebp)
    57fa:	e8 b0 e8 ff ff       	call   40af <readBits>
    57ff:	83 c4 10             	add    $0x10,%esp
    5802:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    5805:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5808:	83 c0 01             	add    $0x1,%eax
    580b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    580e:	76 1b                	jbe    582b <getTreeInflateDynamic+0x2bc>
    5810:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5813:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5818:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    581f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5822:	01 d0                	add    %edx,%eax
    5824:	8b 00                	mov    (%eax),%eax
    5826:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5829:	eb 1c                	jmp    5847 <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    582b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    582e:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5831:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5836:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    583d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5840:	01 d0                	add    %edx,%eax
    5842:	8b 00                	mov    (%eax),%eax
    5844:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5847:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    584e:	eb 56                	jmp    58a6 <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    5850:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5853:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5856:	01 d0                	add    %edx,%eax
    5858:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    585b:	77 0c                	ja     5869 <getTreeInflateDynamic+0x2fa>
    585d:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    5864:	e9 71 01 00 00       	jmp    59da <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    5869:	8b 45 ec             	mov    -0x14(%ebp),%eax
    586c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    586f:	73 16                	jae    5887 <getTreeInflateDynamic+0x318>
    5871:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5874:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    587b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    587e:	01 c2                	add    %eax,%edx
    5880:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5883:	89 02                	mov    %eax,(%edx)
    5885:	eb 17                	jmp    589e <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    5887:	8b 45 ec             	mov    -0x14(%ebp),%eax
    588a:	2b 45 d8             	sub    -0x28(%ebp),%eax
    588d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5894:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5897:	01 c2                	add    %eax,%edx
    5899:	8b 45 e0             	mov    -0x20(%ebp),%eax
    589c:	89 02                	mov    %eax,(%edx)
          ++i;
    589e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    58a2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    58a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    58a9:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    58ac:	72 a2                	jb     5850 <getTreeInflateDynamic+0x2e1>
    58ae:	e9 27 01 00 00       	jmp    59da <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    58b3:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    58b7:	0f 85 88 00 00 00    	jne    5945 <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    58bd:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    58c4:	83 ec 08             	sub    $0x8,%esp
    58c7:	6a 03                	push   $0x3
    58c9:	ff 75 10             	pushl  0x10(%ebp)
    58cc:	e8 de e7 ff ff       	call   40af <readBits>
    58d1:	83 c4 10             	add    $0x10,%esp
    58d4:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    58d7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    58de:	eb 58                	jmp    5938 <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    58e0:	8b 55 d8             	mov    -0x28(%ebp),%edx
    58e3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    58e6:	01 d0                	add    %edx,%eax
    58e8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    58eb:	77 0c                	ja     58f9 <getTreeInflateDynamic+0x38a>
    58ed:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    58f4:	e9 e1 00 00 00       	jmp    59da <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    58f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58fc:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    58ff:	73 17                	jae    5918 <getTreeInflateDynamic+0x3a9>
    5901:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5904:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    590b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    590e:	01 d0                	add    %edx,%eax
    5910:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5916:	eb 18                	jmp    5930 <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    5918:	8b 45 ec             	mov    -0x14(%ebp),%eax
    591b:	2b 45 d8             	sub    -0x28(%ebp),%eax
    591e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5925:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5928:	01 d0                	add    %edx,%eax
    592a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5930:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5934:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5938:	8b 45 f0             	mov    -0x10(%ebp),%eax
    593b:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    593e:	72 a0                	jb     58e0 <getTreeInflateDynamic+0x371>
    5940:	e9 95 00 00 00       	jmp    59da <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    5945:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    5949:	0f 85 82 00 00 00    	jne    59d1 <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    594f:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    5956:	83 ec 08             	sub    $0x8,%esp
    5959:	6a 07                	push   $0x7
    595b:	ff 75 10             	pushl  0x10(%ebp)
    595e:	e8 4c e7 ff ff       	call   40af <readBits>
    5963:	83 c4 10             	add    $0x10,%esp
    5966:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5969:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5970:	eb 55                	jmp    59c7 <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    5972:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5975:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5978:	01 d0                	add    %edx,%eax
    597a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    597d:	77 09                	ja     5988 <getTreeInflateDynamic+0x419>
    597f:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    5986:	eb 52                	jmp    59da <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5988:	8b 45 ec             	mov    -0x14(%ebp),%eax
    598b:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    598e:	73 17                	jae    59a7 <getTreeInflateDynamic+0x438>
    5990:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5993:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    599a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    599d:	01 d0                	add    %edx,%eax
    599f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    59a5:	eb 18                	jmp    59bf <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    59a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59aa:	2b 45 d8             	sub    -0x28(%ebp),%eax
    59ad:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    59b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    59b7:	01 d0                	add    %edx,%eax
    59b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    59bf:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    59c3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    59c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    59ca:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    59cd:	72 a3                	jb     5972 <getTreeInflateDynamic+0x403>
    59cf:	eb 09                	jmp    59da <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    59d1:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    59d8:	eb 2a                	jmp    5a04 <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    59da:	8b 45 10             	mov    0x10(%ebp),%eax
    59dd:	8b 50 0c             	mov    0xc(%eax),%edx
    59e0:	8b 45 10             	mov    0x10(%ebp),%eax
    59e3:	8b 40 08             	mov    0x8(%eax),%eax
    59e6:	39 c2                	cmp    %eax,%edx
    59e8:	7e 09                	jle    59f3 <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    59ea:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    59f1:	eb 11                	jmp    5a04 <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    59f3:	8b 55 d8             	mov    -0x28(%ebp),%edx
    59f6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    59f9:	01 d0                	add    %edx,%eax
    59fb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    59fe:	0f 87 62 fd ff ff    	ja     5766 <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5a04:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5a08:	75 4f                	jne    5a59 <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    5a0a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5a0d:	05 00 04 00 00       	add    $0x400,%eax
    5a12:	8b 00                	mov    (%eax),%eax
    5a14:	85 c0                	test   %eax,%eax
    5a16:	75 09                	jne    5a21 <getTreeInflateDynamic+0x4b2>
    5a18:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    5a1f:	eb 3c                	jmp    5a5d <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5a21:	6a 0f                	push   $0xf
    5a23:	68 20 01 00 00       	push   $0x120
    5a28:	ff 75 e8             	pushl  -0x18(%ebp)
    5a2b:	ff 75 08             	pushl  0x8(%ebp)
    5a2e:	e8 32 ef ff ff       	call   4965 <HuffmanTree_makeFromLengths>
    5a33:	83 c4 10             	add    $0x10,%esp
    5a36:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5a39:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5a3d:	75 1d                	jne    5a5c <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    5a3f:	6a 0f                	push   $0xf
    5a41:	6a 20                	push   $0x20
    5a43:	ff 75 e4             	pushl  -0x1c(%ebp)
    5a46:	ff 75 0c             	pushl  0xc(%ebp)
    5a49:	e8 17 ef ff ff       	call   4965 <HuffmanTree_makeFromLengths>
    5a4e:	83 c4 10             	add    $0x10,%esp
    5a51:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    5a54:	eb 07                	jmp    5a5d <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    5a56:	90                   	nop
    5a57:	eb 04                	jmp    5a5d <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5a59:	90                   	nop
    5a5a:	eb 01                	jmp    5a5d <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    5a5c:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    5a5d:	83 ec 0c             	sub    $0xc,%esp
    5a60:	ff 75 dc             	pushl  -0x24(%ebp)
    5a63:	e8 dc d8 ff ff       	call   3344 <lodepng_free>
    5a68:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    5a6b:	83 ec 0c             	sub    $0xc,%esp
    5a6e:	ff 75 e8             	pushl  -0x18(%ebp)
    5a71:	e8 ce d8 ff ff       	call   3344 <lodepng_free>
    5a76:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    5a79:	83 ec 0c             	sub    $0xc,%esp
    5a7c:	ff 75 e4             	pushl  -0x1c(%ebp)
    5a7f:	e8 c0 d8 ff ff       	call   3344 <lodepng_free>
    5a84:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    5a87:	83 ec 0c             	sub    $0xc,%esp
    5a8a:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5a8d:	50                   	push   %eax
    5a8e:	e8 b1 e7 ff ff       	call   4244 <HuffmanTree_cleanup>
    5a93:	83 c4 10             	add    $0x10,%esp

  return error;
    5a96:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5a99:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5a9c:	c9                   	leave  
    5a9d:	c3                   	ret    

00005a9e <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    5a9e:	55                   	push   %ebp
    5a9f:	89 e5                	mov    %esp,%ebp
    5aa1:	53                   	push   %ebx
    5aa2:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    5aa5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    5aac:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5aaf:	50                   	push   %eax
    5ab0:	e8 62 e7 ff ff       	call   4217 <HuffmanTree_init>
    5ab5:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    5ab8:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5abb:	50                   	push   %eax
    5abc:	e8 56 e7 ff ff       	call   4217 <HuffmanTree_init>
    5ac1:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    5ac4:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    5ac8:	75 1b                	jne    5ae5 <inflateHuffmanBlock+0x47>
    5aca:	83 ec 08             	sub    $0x8,%esp
    5acd:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5ad0:	50                   	push   %eax
    5ad1:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5ad4:	50                   	push   %eax
    5ad5:	e8 63 fa ff ff       	call   553d <getTreeInflateFixed>
    5ada:	83 c4 10             	add    $0x10,%esp
    5add:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5ae0:	e9 9a 02 00 00       	jmp    5d7f <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    5ae5:	83 ec 04             	sub    $0x4,%esp
    5ae8:	ff 75 0c             	pushl  0xc(%ebp)
    5aeb:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5aee:	50                   	push   %eax
    5aef:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5af2:	50                   	push   %eax
    5af3:	e8 77 fa ff ff       	call   556f <getTreeInflateDynamic>
    5af8:	83 c4 10             	add    $0x10,%esp
    5afb:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5afe:	e9 7c 02 00 00       	jmp    5d7f <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    5b03:	83 ec 08             	sub    $0x8,%esp
    5b06:	6a 14                	push   $0x14
    5b08:	ff 75 0c             	pushl  0xc(%ebp)
    5b0b:	e8 ef e1 ff ff       	call   3cff <ensureBits25>
    5b10:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    5b13:	83 ec 08             	sub    $0x8,%esp
    5b16:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5b19:	50                   	push   %eax
    5b1a:	ff 75 0c             	pushl  0xc(%ebp)
    5b1d:	e8 5a f9 ff ff       	call   547c <huffmanDecodeSymbol>
    5b22:	83 c4 10             	add    $0x10,%esp
    5b25:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    5b28:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    5b2f:	77 42                	ja     5b73 <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    5b31:	8b 45 08             	mov    0x8(%ebp),%eax
    5b34:	8b 40 04             	mov    0x4(%eax),%eax
    5b37:	83 c0 01             	add    $0x1,%eax
    5b3a:	83 ec 08             	sub    $0x8,%esp
    5b3d:	50                   	push   %eax
    5b3e:	ff 75 08             	pushl  0x8(%ebp)
    5b41:	e8 37 da ff ff       	call   357d <ucvector_resize>
    5b46:	83 c4 10             	add    $0x10,%esp
    5b49:	85 c0                	test   %eax,%eax
    5b4b:	75 0c                	jne    5b59 <inflateHuffmanBlock+0xbb>
    5b4d:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5b54:	e9 33 02 00 00       	jmp    5d8c <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    5b59:	8b 45 08             	mov    0x8(%ebp),%eax
    5b5c:	8b 10                	mov    (%eax),%edx
    5b5e:	8b 45 08             	mov    0x8(%ebp),%eax
    5b61:	8b 40 04             	mov    0x4(%eax),%eax
    5b64:	83 e8 01             	sub    $0x1,%eax
    5b67:	01 d0                	add    %edx,%eax
    5b69:	8b 55 dc             	mov    -0x24(%ebp),%edx
    5b6c:	88 10                	mov    %dl,(%eax)
    5b6e:	e9 d9 01 00 00       	jmp    5d4c <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5b73:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5b7a:	0f 86 ba 01 00 00    	jbe    5d3a <inflateHuffmanBlock+0x29c>
    5b80:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    5b87:	0f 87 ad 01 00 00    	ja     5d3a <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    5b8d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5b90:	2d 01 01 00 00       	sub    $0x101,%eax
    5b95:	8b 04 85 20 9d 01 00 	mov    0x19d20(,%eax,4),%eax
    5b9c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    5b9f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5ba2:	2d 01 01 00 00       	sub    $0x101,%eax
    5ba7:	8b 04 85 a0 9d 01 00 	mov    0x19da0(,%eax,4),%eax
    5bae:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    5bb1:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    5bb5:	74 1c                	je     5bd3 <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    5bb7:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5bba:	83 ec 08             	sub    $0x8,%esp
    5bbd:	50                   	push   %eax
    5bbe:	ff 75 0c             	pushl  0xc(%ebp)
    5bc1:	e8 e9 e4 ff ff       	call   40af <readBits>
    5bc6:	83 c4 10             	add    $0x10,%esp
    5bc9:	89 c2                	mov    %eax,%edx
    5bcb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5bce:	01 d0                	add    %edx,%eax
    5bd0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    5bd3:	83 ec 08             	sub    $0x8,%esp
    5bd6:	6a 1c                	push   $0x1c
    5bd8:	ff 75 0c             	pushl  0xc(%ebp)
    5bdb:	e8 98 e2 ff ff       	call   3e78 <ensureBits32>
    5be0:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    5be3:	83 ec 08             	sub    $0x8,%esp
    5be6:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5be9:	50                   	push   %eax
    5bea:	ff 75 0c             	pushl  0xc(%ebp)
    5bed:	e8 8a f8 ff ff       	call   547c <huffmanDecodeSymbol>
    5bf2:	83 c4 10             	add    $0x10,%esp
    5bf5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    5bf8:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    5bfc:	76 1e                	jbe    5c1c <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    5bfe:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    5c02:	77 0c                	ja     5c10 <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    5c04:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    5c0b:	e9 7c 01 00 00       	jmp    5d8c <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5c10:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5c17:	e9 70 01 00 00       	jmp    5d8c <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    5c1c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5c1f:	8b 04 85 20 9e 01 00 	mov    0x19e20(,%eax,4),%eax
    5c26:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    5c29:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5c2c:	8b 04 85 a0 9e 01 00 	mov    0x19ea0(,%eax,4),%eax
    5c33:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    5c36:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    5c3a:	74 15                	je     5c51 <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    5c3c:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5c3f:	83 ec 08             	sub    $0x8,%esp
    5c42:	50                   	push   %eax
    5c43:	ff 75 0c             	pushl  0xc(%ebp)
    5c46:	e8 64 e4 ff ff       	call   40af <readBits>
    5c4b:	83 c4 10             	add    $0x10,%esp
    5c4e:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    5c51:	8b 45 08             	mov    0x8(%ebp),%eax
    5c54:	8b 40 04             	mov    0x4(%eax),%eax
    5c57:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    5c5a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c5d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5c60:	76 0c                	jbe    5c6e <inflateHuffmanBlock+0x1d0>
    5c62:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    5c69:	e9 1e 01 00 00       	jmp    5d8c <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    5c6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c71:	2b 45 f0             	sub    -0x10(%ebp),%eax
    5c74:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    5c77:	8b 45 08             	mov    0x8(%ebp),%eax
    5c7a:	8b 50 04             	mov    0x4(%eax),%edx
    5c7d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c80:	01 d0                	add    %edx,%eax
    5c82:	83 ec 08             	sub    $0x8,%esp
    5c85:	50                   	push   %eax
    5c86:	ff 75 08             	pushl  0x8(%ebp)
    5c89:	e8 ef d8 ff ff       	call   357d <ucvector_resize>
    5c8e:	83 c4 10             	add    $0x10,%esp
    5c91:	85 c0                	test   %eax,%eax
    5c93:	75 0c                	jne    5ca1 <inflateHuffmanBlock+0x203>
    5c95:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5c9c:	e9 eb 00 00 00       	jmp    5d8c <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    5ca1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5ca4:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5ca7:	73 6b                	jae    5d14 <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    5ca9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5cac:	8b 55 08             	mov    0x8(%ebp),%edx
    5caf:	8b 0a                	mov    (%edx),%ecx
    5cb1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5cb4:	01 d1                	add    %edx,%ecx
    5cb6:	8b 55 08             	mov    0x8(%ebp),%edx
    5cb9:	8b 1a                	mov    (%edx),%ebx
    5cbb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5cbe:	01 da                	add    %ebx,%edx
    5cc0:	83 ec 04             	sub    $0x4,%esp
    5cc3:	50                   	push   %eax
    5cc4:	51                   	push   %ecx
    5cc5:	52                   	push   %edx
    5cc6:	e8 96 d6 ff ff       	call   3361 <lodepng_memcpy>
    5ccb:	83 c4 10             	add    $0x10,%esp
        start += distance;
    5cce:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5cd1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5cd4:	01 d0                	add    %edx,%eax
    5cd6:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    5cd9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5cdc:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5cdf:	eb 29                	jmp    5d0a <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    5ce1:	8b 45 08             	mov    0x8(%ebp),%eax
    5ce4:	8b 08                	mov    (%eax),%ecx
    5ce6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ce9:	8d 50 01             	lea    0x1(%eax),%edx
    5cec:	89 55 ec             	mov    %edx,-0x14(%ebp)
    5cef:	01 c1                	add    %eax,%ecx
    5cf1:	8b 45 08             	mov    0x8(%ebp),%eax
    5cf4:	8b 18                	mov    (%eax),%ebx
    5cf6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5cf9:	8d 50 01             	lea    0x1(%eax),%edx
    5cfc:	89 55 e8             	mov    %edx,-0x18(%ebp)
    5cff:	01 d8                	add    %ebx,%eax
    5d01:	0f b6 00             	movzbl (%eax),%eax
    5d04:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    5d06:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5d0a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5d0d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    5d10:	7c cf                	jl     5ce1 <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5d12:	eb 38                	jmp    5d4c <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    5d14:	8b 45 08             	mov    0x8(%ebp),%eax
    5d17:	8b 10                	mov    (%eax),%edx
    5d19:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5d1c:	01 c2                	add    %eax,%edx
    5d1e:	8b 45 08             	mov    0x8(%ebp),%eax
    5d21:	8b 08                	mov    (%eax),%ecx
    5d23:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d26:	01 c8                	add    %ecx,%eax
    5d28:	83 ec 04             	sub    $0x4,%esp
    5d2b:	ff 75 e4             	pushl  -0x1c(%ebp)
    5d2e:	52                   	push   %edx
    5d2f:	50                   	push   %eax
    5d30:	e8 2c d6 ff ff       	call   3361 <lodepng_memcpy>
    5d35:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5d38:	eb 12                	jmp    5d4c <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    5d3a:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5d41:	74 48                	je     5d8b <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5d43:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5d4a:	eb 40                	jmp    5d8c <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    5d4c:	8b 45 0c             	mov    0xc(%ebp),%eax
    5d4f:	8b 50 0c             	mov    0xc(%eax),%edx
    5d52:	8b 45 0c             	mov    0xc(%ebp),%eax
    5d55:	8b 40 08             	mov    0x8(%eax),%eax
    5d58:	39 c2                	cmp    %eax,%edx
    5d5a:	7e 09                	jle    5d65 <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    5d5c:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    5d63:	eb 27                	jmp    5d8c <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    5d65:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    5d69:	74 14                	je     5d7f <inflateHuffmanBlock+0x2e1>
    5d6b:	8b 45 08             	mov    0x8(%ebp),%eax
    5d6e:	8b 40 04             	mov    0x4(%eax),%eax
    5d71:	3b 45 14             	cmp    0x14(%ebp),%eax
    5d74:	7e 09                	jle    5d7f <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    5d76:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    5d7d:	eb 0d                	jmp    5d8c <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5d7f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5d83:	0f 84 7a fd ff ff    	je     5b03 <inflateHuffmanBlock+0x65>
    5d89:	eb 01                	jmp    5d8c <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    5d8b:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    5d8c:	83 ec 0c             	sub    $0xc,%esp
    5d8f:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5d92:	50                   	push   %eax
    5d93:	e8 ac e4 ff ff       	call   4244 <HuffmanTree_cleanup>
    5d98:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    5d9b:	83 ec 0c             	sub    $0xc,%esp
    5d9e:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5da1:	50                   	push   %eax
    5da2:	e8 9d e4 ff ff       	call   4244 <HuffmanTree_cleanup>
    5da7:	83 c4 10             	add    $0x10,%esp

  return error;
    5daa:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5dad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5db0:	c9                   	leave  
    5db1:	c3                   	ret    

00005db2 <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    5db2:	55                   	push   %ebp
    5db3:	89 e5                	mov    %esp,%ebp
    5db5:	53                   	push   %ebx
    5db6:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    5db9:	8b 45 0c             	mov    0xc(%ebp),%eax
    5dbc:	8b 40 04             	mov    0x4(%eax),%eax
    5dbf:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    5dc2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    5dc9:	8b 45 0c             	mov    0xc(%ebp),%eax
    5dcc:	8b 40 0c             	mov    0xc(%eax),%eax
    5dcf:	83 c0 07             	add    $0x7,%eax
    5dd2:	c1 e8 03             	shr    $0x3,%eax
    5dd5:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    5dd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5ddb:	83 c0 04             	add    $0x4,%eax
    5dde:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5de1:	7c 0a                	jl     5ded <inflateNoCompression+0x3b>
    5de3:	b8 34 00 00 00       	mov    $0x34,%eax
    5de8:	e9 01 01 00 00       	jmp    5eee <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5ded:	8b 45 0c             	mov    0xc(%ebp),%eax
    5df0:	8b 10                	mov    (%eax),%edx
    5df2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5df5:	01 d0                	add    %edx,%eax
    5df7:	0f b6 00             	movzbl (%eax),%eax
    5dfa:	0f b6 d0             	movzbl %al,%edx
    5dfd:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e00:	8b 00                	mov    (%eax),%eax
    5e02:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5e05:	83 c1 01             	add    $0x1,%ecx
    5e08:	01 c8                	add    %ecx,%eax
    5e0a:	0f b6 00             	movzbl (%eax),%eax
    5e0d:	0f b6 c0             	movzbl %al,%eax
    5e10:	c1 e0 08             	shl    $0x8,%eax
    5e13:	01 d0                	add    %edx,%eax
    5e15:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5e18:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5e1c:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e1f:	8b 10                	mov    (%eax),%edx
    5e21:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5e24:	01 d0                	add    %edx,%eax
    5e26:	0f b6 00             	movzbl (%eax),%eax
    5e29:	0f b6 d0             	movzbl %al,%edx
    5e2c:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e2f:	8b 00                	mov    (%eax),%eax
    5e31:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5e34:	83 c1 01             	add    $0x1,%ecx
    5e37:	01 c8                	add    %ecx,%eax
    5e39:	0f b6 00             	movzbl (%eax),%eax
    5e3c:	0f b6 c0             	movzbl %al,%eax
    5e3f:	c1 e0 08             	shl    $0x8,%eax
    5e42:	01 d0                	add    %edx,%eax
    5e44:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5e47:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    5e4b:	8b 45 10             	mov    0x10(%ebp),%eax
    5e4e:	8b 40 04             	mov    0x4(%eax),%eax
    5e51:	85 c0                	test   %eax,%eax
    5e53:	75 19                	jne    5e6e <inflateNoCompression+0xbc>
    5e55:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5e58:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5e5b:	01 d0                	add    %edx,%eax
    5e5d:	3d ff ff 00 00       	cmp    $0xffff,%eax
    5e62:	74 0a                	je     5e6e <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    5e64:	b8 15 00 00 00       	mov    $0x15,%eax
    5e69:	e9 80 00 00 00       	jmp    5eee <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    5e6e:	8b 45 08             	mov    0x8(%ebp),%eax
    5e71:	8b 40 04             	mov    0x4(%eax),%eax
    5e74:	89 c2                	mov    %eax,%edx
    5e76:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e79:	01 d0                	add    %edx,%eax
    5e7b:	50                   	push   %eax
    5e7c:	ff 75 08             	pushl  0x8(%ebp)
    5e7f:	e8 f9 d6 ff ff       	call   357d <ucvector_resize>
    5e84:	83 c4 08             	add    $0x8,%esp
    5e87:	85 c0                	test   %eax,%eax
    5e89:	75 07                	jne    5e92 <inflateNoCompression+0xe0>
    5e8b:	b8 53 00 00 00       	mov    $0x53,%eax
    5e90:	eb 5c                	jmp    5eee <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    5e92:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5e95:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e98:	01 c2                	add    %eax,%edx
    5e9a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5e9d:	39 c2                	cmp    %eax,%edx
    5e9f:	76 07                	jbe    5ea8 <inflateNoCompression+0xf6>
    5ea1:	b8 17 00 00 00       	mov    $0x17,%eax
    5ea6:	eb 46                	jmp    5eee <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    5ea8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5eab:	8b 55 0c             	mov    0xc(%ebp),%edx
    5eae:	8b 0a                	mov    (%edx),%ecx
    5eb0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5eb3:	01 d1                	add    %edx,%ecx
    5eb5:	8b 55 08             	mov    0x8(%ebp),%edx
    5eb8:	8b 1a                	mov    (%edx),%ebx
    5eba:	8b 55 08             	mov    0x8(%ebp),%edx
    5ebd:	8b 52 04             	mov    0x4(%edx),%edx
    5ec0:	2b 55 ec             	sub    -0x14(%ebp),%edx
    5ec3:	01 da                	add    %ebx,%edx
    5ec5:	50                   	push   %eax
    5ec6:	51                   	push   %ecx
    5ec7:	52                   	push   %edx
    5ec8:	e8 94 d4 ff ff       	call   3361 <lodepng_memcpy>
    5ecd:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    5ed0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5ed3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ed6:	01 d0                	add    %edx,%eax
    5ed8:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    5edb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5ede:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    5ee5:	8b 45 0c             	mov    0xc(%ebp),%eax
    5ee8:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    5eeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5eee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5ef1:	c9                   	leave  
    5ef2:	c3                   	ret    

00005ef3 <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    5ef3:	55                   	push   %ebp
    5ef4:	89 e5                	mov    %esp,%ebp
    5ef6:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    5ef9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    5f00:	ff 75 10             	pushl  0x10(%ebp)
    5f03:	ff 75 0c             	pushl  0xc(%ebp)
    5f06:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f09:	50                   	push   %eax
    5f0a:	e8 77 db ff ff       	call   3a86 <LodePNGBitReader_init>
    5f0f:	83 c4 0c             	add    $0xc,%esp
    5f12:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    5f15:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5f19:	0f 84 b9 00 00 00    	je     5fd8 <lodepng_inflatev+0xe5>
    5f1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f22:	e9 c1 00 00 00       	jmp    5fe8 <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    5f27:	6a 03                	push   $0x3
    5f29:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f2c:	50                   	push   %eax
    5f2d:	e8 c5 db ff ff       	call   3af7 <ensureBits9>
    5f32:	83 c4 08             	add    $0x8,%esp
    5f35:	85 c0                	test   %eax,%eax
    5f37:	75 0a                	jne    5f43 <lodepng_inflatev+0x50>
    5f39:	b8 34 00 00 00       	mov    $0x34,%eax
    5f3e:	e9 a5 00 00 00       	jmp    5fe8 <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    5f43:	6a 01                	push   $0x1
    5f45:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f48:	50                   	push   %eax
    5f49:	e8 61 e1 ff ff       	call   40af <readBits>
    5f4e:	83 c4 08             	add    $0x8,%esp
    5f51:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    5f54:	6a 02                	push   $0x2
    5f56:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f59:	50                   	push   %eax
    5f5a:	e8 50 e1 ff ff       	call   40af <readBits>
    5f5f:	83 c4 08             	add    $0x8,%esp
    5f62:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    5f65:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    5f69:	75 07                	jne    5f72 <lodepng_inflatev+0x7f>
    5f6b:	b8 14 00 00 00       	mov    $0x14,%eax
    5f70:	eb 76                	jmp    5fe8 <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    5f72:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5f76:	75 17                	jne    5f8f <lodepng_inflatev+0x9c>
    5f78:	ff 75 14             	pushl  0x14(%ebp)
    5f7b:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f7e:	50                   	push   %eax
    5f7f:	ff 75 08             	pushl  0x8(%ebp)
    5f82:	e8 2b fe ff ff       	call   5db2 <inflateNoCompression>
    5f87:	83 c4 0c             	add    $0xc,%esp
    5f8a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    5f8d:	eb 1c                	jmp    5fab <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    5f8f:	8b 45 14             	mov    0x14(%ebp),%eax
    5f92:	8b 40 08             	mov    0x8(%eax),%eax
    5f95:	50                   	push   %eax
    5f96:	ff 75 ec             	pushl  -0x14(%ebp)
    5f99:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f9c:	50                   	push   %eax
    5f9d:	ff 75 08             	pushl  0x8(%ebp)
    5fa0:	e8 f9 fa ff ff       	call   5a9e <inflateHuffmanBlock>
    5fa5:	83 c4 10             	add    $0x10,%esp
    5fa8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    5fab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5faf:	75 21                	jne    5fd2 <lodepng_inflatev+0xdf>
    5fb1:	8b 45 14             	mov    0x14(%ebp),%eax
    5fb4:	8b 40 08             	mov    0x8(%eax),%eax
    5fb7:	85 c0                	test   %eax,%eax
    5fb9:	74 17                	je     5fd2 <lodepng_inflatev+0xdf>
    5fbb:	8b 45 08             	mov    0x8(%ebp),%eax
    5fbe:	8b 50 04             	mov    0x4(%eax),%edx
    5fc1:	8b 45 14             	mov    0x14(%ebp),%eax
    5fc4:	8b 40 08             	mov    0x8(%eax),%eax
    5fc7:	39 c2                	cmp    %eax,%edx
    5fc9:	7e 07                	jle    5fd2 <lodepng_inflatev+0xdf>
    5fcb:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    5fd2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5fd6:	75 0c                	jne    5fe4 <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    5fd8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5fdc:	0f 84 45 ff ff ff    	je     5f27 <lodepng_inflatev+0x34>
    5fe2:	eb 01                	jmp    5fe5 <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    5fe4:	90                   	nop
  }

  return error;
    5fe5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    5fe8:	c9                   	leave  
    5fe9:	c3                   	ret    

00005fea <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    5fea:	55                   	push   %ebp
    5feb:	89 e5                	mov    %esp,%ebp
    5fed:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    5ff0:	8b 45 0c             	mov    0xc(%ebp),%eax
    5ff3:	8b 08                	mov    (%eax),%ecx
    5ff5:	8b 45 08             	mov    0x8(%ebp),%eax
    5ff8:	8b 10                	mov    (%eax),%edx
    5ffa:	8d 45 e8             	lea    -0x18(%ebp),%eax
    5ffd:	51                   	push   %ecx
    5ffe:	52                   	push   %edx
    5fff:	50                   	push   %eax
    6000:	e8 df d5 ff ff       	call   35e4 <ucvector_init>
    6005:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    6008:	ff 75 18             	pushl  0x18(%ebp)
    600b:	ff 75 14             	pushl  0x14(%ebp)
    600e:	ff 75 10             	pushl  0x10(%ebp)
    6011:	8d 45 e8             	lea    -0x18(%ebp),%eax
    6014:	50                   	push   %eax
    6015:	e8 d9 fe ff ff       	call   5ef3 <lodepng_inflatev>
    601a:	83 c4 10             	add    $0x10,%esp
    601d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    6020:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6023:	8b 45 08             	mov    0x8(%ebp),%eax
    6026:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    6028:	8b 55 ec             	mov    -0x14(%ebp),%edx
    602b:	8b 45 0c             	mov    0xc(%ebp),%eax
    602e:	89 10                	mov    %edx,(%eax)
  return error;
    6030:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6033:	c9                   	leave  
    6034:	c3                   	ret    

00006035 <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    6035:	55                   	push   %ebp
    6036:	89 e5                	mov    %esp,%ebp
    6038:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    603b:	8b 45 14             	mov    0x14(%ebp),%eax
    603e:	8b 40 10             	mov    0x10(%eax),%eax
    6041:	85 c0                	test   %eax,%eax
    6043:	74 64                	je     60a9 <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    6045:	8b 45 14             	mov    0x14(%ebp),%eax
    6048:	8b 40 10             	mov    0x10(%eax),%eax
    604b:	8b 55 08             	mov    0x8(%ebp),%edx
    604e:	8d 4a 04             	lea    0x4(%edx),%ecx
    6051:	8b 55 08             	mov    0x8(%ebp),%edx
    6054:	83 ec 0c             	sub    $0xc,%esp
    6057:	ff 75 14             	pushl  0x14(%ebp)
    605a:	ff 75 10             	pushl  0x10(%ebp)
    605d:	ff 75 0c             	pushl  0xc(%ebp)
    6060:	51                   	push   %ecx
    6061:	52                   	push   %edx
    6062:	ff d0                	call   *%eax
    6064:	83 c4 20             	add    $0x20,%esp
    6067:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    606a:	8b 45 08             	mov    0x8(%ebp),%eax
    606d:	8b 50 04             	mov    0x4(%eax),%edx
    6070:	8b 45 08             	mov    0x8(%ebp),%eax
    6073:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    6076:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    607a:	74 28                	je     60a4 <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    607c:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    6083:	8b 45 14             	mov    0x14(%ebp),%eax
    6086:	8b 40 08             	mov    0x8(%eax),%eax
    6089:	85 c0                	test   %eax,%eax
    608b:	74 17                	je     60a4 <inflatev+0x6f>
    608d:	8b 45 08             	mov    0x8(%ebp),%eax
    6090:	8b 50 04             	mov    0x4(%eax),%edx
    6093:	8b 45 14             	mov    0x14(%ebp),%eax
    6096:	8b 40 08             	mov    0x8(%eax),%eax
    6099:	39 c2                	cmp    %eax,%edx
    609b:	7e 07                	jle    60a4 <inflatev+0x6f>
    609d:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    60a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    60a7:	eb 14                	jmp    60bd <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    60a9:	ff 75 14             	pushl  0x14(%ebp)
    60ac:	ff 75 10             	pushl  0x10(%ebp)
    60af:	ff 75 0c             	pushl  0xc(%ebp)
    60b2:	ff 75 08             	pushl  0x8(%ebp)
    60b5:	e8 39 fe ff ff       	call   5ef3 <lodepng_inflatev>
    60ba:	83 c4 10             	add    $0x10,%esp
  }
}
    60bd:	c9                   	leave  
    60be:	c3                   	ret    

000060bf <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    60bf:	55                   	push   %ebp
    60c0:	89 e5                	mov    %esp,%ebp
    60c2:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    60c5:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    60cc:	8b 45 0c             	mov    0xc(%ebp),%eax
    60cf:	83 e8 01             	sub    $0x1,%eax
    60d2:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    60d5:	eb 39                	jmp    6110 <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    60d7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    60da:	8b 45 f8             	mov    -0x8(%ebp),%eax
    60dd:	01 d0                	add    %edx,%eax
    60df:	d1 f8                	sar    %eax
    60e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    60e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    60e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    60ee:	8b 45 08             	mov    0x8(%ebp),%eax
    60f1:	01 d0                	add    %edx,%eax
    60f3:	8b 10                	mov    (%eax),%edx
    60f5:	8b 45 10             	mov    0x10(%ebp),%eax
    60f8:	39 c2                	cmp    %eax,%edx
    60fa:	72 0b                	jb     6107 <searchCodeIndex+0x48>
    60fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    60ff:	83 e8 01             	sub    $0x1,%eax
    6102:	89 45 f8             	mov    %eax,-0x8(%ebp)
    6105:	eb 09                	jmp    6110 <searchCodeIndex+0x51>
    else left = mid + 1;
    6107:	8b 45 f4             	mov    -0xc(%ebp),%eax
    610a:	83 c0 01             	add    $0x1,%eax
    610d:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    6110:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6113:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6116:	7e bf                	jle    60d7 <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    6118:	8b 45 fc             	mov    -0x4(%ebp),%eax
    611b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    611e:	7d 18                	jge    6138 <searchCodeIndex+0x79>
    6120:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6123:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    612a:	8b 45 08             	mov    0x8(%ebp),%eax
    612d:	01 d0                	add    %edx,%eax
    612f:	8b 10                	mov    (%eax),%edx
    6131:	8b 45 10             	mov    0x10(%ebp),%eax
    6134:	39 c2                	cmp    %eax,%edx
    6136:	76 04                	jbe    613c <searchCodeIndex+0x7d>
    6138:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    613c:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    613f:	c9                   	leave  
    6140:	c3                   	ret    

00006141 <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    6141:	55                   	push   %ebp
    6142:	89 e5                	mov    %esp,%ebp
    6144:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    6147:	ff 75 0c             	pushl  0xc(%ebp)
    614a:	6a 1d                	push   $0x1d
    614c:	68 20 9d 01 00       	push   $0x19d20
    6151:	e8 69 ff ff ff       	call   60bf <searchCodeIndex>
    6156:	83 c4 0c             	add    $0xc,%esp
    6159:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    615c:	8b 55 0c             	mov    0xc(%ebp),%edx
    615f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6162:	8b 04 85 20 9d 01 00 	mov    0x19d20(,%eax,4),%eax
    6169:	29 c2                	sub    %eax,%edx
    616b:	89 d0                	mov    %edx,%eax
    616d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    6170:	ff 75 10             	pushl  0x10(%ebp)
    6173:	6a 1e                	push   $0x1e
    6175:	68 20 9e 01 00       	push   $0x19e20
    617a:	e8 40 ff ff ff       	call   60bf <searchCodeIndex>
    617f:	83 c4 0c             	add    $0xc,%esp
    6182:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    6185:	8b 55 10             	mov    0x10(%ebp),%edx
    6188:	8b 45 f4             	mov    -0xc(%ebp),%eax
    618b:	8b 04 85 20 9e 01 00 	mov    0x19e20(,%eax,4),%eax
    6192:	29 c2                	sub    %eax,%edx
    6194:	89 d0                	mov    %edx,%eax
    6196:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    6199:	8b 45 08             	mov    0x8(%ebp),%eax
    619c:	8b 40 04             	mov    0x4(%eax),%eax
    619f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    61a2:	8b 45 08             	mov    0x8(%ebp),%eax
    61a5:	8b 40 04             	mov    0x4(%eax),%eax
    61a8:	83 c0 04             	add    $0x4,%eax
    61ab:	50                   	push   %eax
    61ac:	ff 75 08             	pushl  0x8(%ebp)
    61af:	e8 f0 d2 ff ff       	call   34a4 <uivector_resize>
    61b4:	83 c4 08             	add    $0x8,%esp
    61b7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    61ba:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    61be:	74 57                	je     6217 <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    61c0:	8b 45 08             	mov    0x8(%ebp),%eax
    61c3:	8b 00                	mov    (%eax),%eax
    61c5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61c8:	c1 e2 02             	shl    $0x2,%edx
    61cb:	01 d0                	add    %edx,%eax
    61cd:	8b 55 fc             	mov    -0x4(%ebp),%edx
    61d0:	81 c2 01 01 00 00    	add    $0x101,%edx
    61d6:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    61d8:	8b 45 08             	mov    0x8(%ebp),%eax
    61db:	8b 00                	mov    (%eax),%eax
    61dd:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61e0:	83 c2 01             	add    $0x1,%edx
    61e3:	c1 e2 02             	shl    $0x2,%edx
    61e6:	01 c2                	add    %eax,%edx
    61e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    61eb:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    61ed:	8b 45 08             	mov    0x8(%ebp),%eax
    61f0:	8b 00                	mov    (%eax),%eax
    61f2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61f5:	83 c2 02             	add    $0x2,%edx
    61f8:	c1 e2 02             	shl    $0x2,%edx
    61fb:	01 c2                	add    %eax,%edx
    61fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6200:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    6202:	8b 45 08             	mov    0x8(%ebp),%eax
    6205:	8b 00                	mov    (%eax),%eax
    6207:	8b 55 ec             	mov    -0x14(%ebp),%edx
    620a:	83 c2 03             	add    $0x3,%edx
    620d:	c1 e2 02             	shl    $0x2,%edx
    6210:	01 c2                	add    %eax,%edx
    6212:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6215:	89 02                	mov    %eax,(%edx)
  }
}
    6217:	90                   	nop
    6218:	c9                   	leave  
    6219:	c3                   	ret    

0000621a <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    621a:	55                   	push   %ebp
    621b:	89 e5                	mov    %esp,%ebp
    621d:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    6220:	b8 00 00 01 00       	mov    $0x10000,%eax
    6225:	c1 e0 02             	shl    $0x2,%eax
    6228:	83 ec 0c             	sub    $0xc,%esp
    622b:	50                   	push   %eax
    622c:	e8 f2 d0 ff ff       	call   3323 <lodepng_malloc>
    6231:	83 c4 10             	add    $0x10,%esp
    6234:	89 c2                	mov    %eax,%edx
    6236:	8b 45 08             	mov    0x8(%ebp),%eax
    6239:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    623b:	8b 45 0c             	mov    0xc(%ebp),%eax
    623e:	c1 e0 02             	shl    $0x2,%eax
    6241:	83 ec 0c             	sub    $0xc,%esp
    6244:	50                   	push   %eax
    6245:	e8 d9 d0 ff ff       	call   3323 <lodepng_malloc>
    624a:	83 c4 10             	add    $0x10,%esp
    624d:	89 c2                	mov    %eax,%edx
    624f:	8b 45 08             	mov    0x8(%ebp),%eax
    6252:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6255:	8b 45 0c             	mov    0xc(%ebp),%eax
    6258:	01 c0                	add    %eax,%eax
    625a:	83 ec 0c             	sub    $0xc,%esp
    625d:	50                   	push   %eax
    625e:	e8 c0 d0 ff ff       	call   3323 <lodepng_malloc>
    6263:	83 c4 10             	add    $0x10,%esp
    6266:	89 c2                	mov    %eax,%edx
    6268:	8b 45 08             	mov    0x8(%ebp),%eax
    626b:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    626e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6271:	01 c0                	add    %eax,%eax
    6273:	83 ec 0c             	sub    $0xc,%esp
    6276:	50                   	push   %eax
    6277:	e8 a7 d0 ff ff       	call   3323 <lodepng_malloc>
    627c:	83 c4 10             	add    $0x10,%esp
    627f:	89 c2                	mov    %eax,%edx
    6281:	8b 45 08             	mov    0x8(%ebp),%eax
    6284:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    6287:	b8 02 01 00 00       	mov    $0x102,%eax
    628c:	83 c0 01             	add    $0x1,%eax
    628f:	c1 e0 02             	shl    $0x2,%eax
    6292:	83 ec 0c             	sub    $0xc,%esp
    6295:	50                   	push   %eax
    6296:	e8 88 d0 ff ff       	call   3323 <lodepng_malloc>
    629b:	83 c4 10             	add    $0x10,%esp
    629e:	89 c2                	mov    %eax,%edx
    62a0:	8b 45 08             	mov    0x8(%ebp),%eax
    62a3:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    62a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    62a9:	01 c0                	add    %eax,%eax
    62ab:	83 ec 0c             	sub    $0xc,%esp
    62ae:	50                   	push   %eax
    62af:	e8 6f d0 ff ff       	call   3323 <lodepng_malloc>
    62b4:	83 c4 10             	add    $0x10,%esp
    62b7:	89 c2                	mov    %eax,%edx
    62b9:	8b 45 08             	mov    0x8(%ebp),%eax
    62bc:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    62bf:	8b 45 08             	mov    0x8(%ebp),%eax
    62c2:	8b 00                	mov    (%eax),%eax
    62c4:	85 c0                	test   %eax,%eax
    62c6:	74 32                	je     62fa <hash_init+0xe0>
    62c8:	8b 45 08             	mov    0x8(%ebp),%eax
    62cb:	8b 40 04             	mov    0x4(%eax),%eax
    62ce:	85 c0                	test   %eax,%eax
    62d0:	74 28                	je     62fa <hash_init+0xe0>
    62d2:	8b 45 08             	mov    0x8(%ebp),%eax
    62d5:	8b 40 08             	mov    0x8(%eax),%eax
    62d8:	85 c0                	test   %eax,%eax
    62da:	74 1e                	je     62fa <hash_init+0xe0>
    62dc:	8b 45 08             	mov    0x8(%ebp),%eax
    62df:	8b 40 0c             	mov    0xc(%eax),%eax
    62e2:	85 c0                	test   %eax,%eax
    62e4:	74 14                	je     62fa <hash_init+0xe0>
    62e6:	8b 45 08             	mov    0x8(%ebp),%eax
    62e9:	8b 40 10             	mov    0x10(%eax),%eax
    62ec:	85 c0                	test   %eax,%eax
    62ee:	74 0a                	je     62fa <hash_init+0xe0>
    62f0:	8b 45 08             	mov    0x8(%ebp),%eax
    62f3:	8b 40 14             	mov    0x14(%eax),%eax
    62f6:	85 c0                	test   %eax,%eax
    62f8:	75 0a                	jne    6304 <hash_init+0xea>
    return 83; /*alloc fail*/
    62fa:	b8 53 00 00 00       	mov    $0x53,%eax
    62ff:	e9 d3 00 00 00       	jmp    63d7 <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    6304:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    630b:	eb 17                	jmp    6324 <hash_init+0x10a>
    630d:	8b 45 08             	mov    0x8(%ebp),%eax
    6310:	8b 00                	mov    (%eax),%eax
    6312:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6315:	c1 e2 02             	shl    $0x2,%edx
    6318:	01 d0                	add    %edx,%eax
    631a:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6320:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6324:	b8 00 00 01 00       	mov    $0x10000,%eax
    6329:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    632c:	75 df                	jne    630d <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    632e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6335:	eb 18                	jmp    634f <hash_init+0x135>
    6337:	8b 45 08             	mov    0x8(%ebp),%eax
    633a:	8b 40 08             	mov    0x8(%eax),%eax
    633d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6340:	c1 e2 02             	shl    $0x2,%edx
    6343:	01 d0                	add    %edx,%eax
    6345:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    634b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    634f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6352:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6355:	75 e0                	jne    6337 <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    6357:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    635e:	eb 17                	jmp    6377 <hash_init+0x15d>
    6360:	8b 45 08             	mov    0x8(%ebp),%eax
    6363:	8b 40 04             	mov    0x4(%eax),%eax
    6366:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6369:	01 d2                	add    %edx,%edx
    636b:	01 d0                	add    %edx,%eax
    636d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6370:	66 89 10             	mov    %dx,(%eax)
    6373:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6377:	8b 45 f4             	mov    -0xc(%ebp),%eax
    637a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    637d:	75 e1                	jne    6360 <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    637f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6386:	eb 18                	jmp    63a0 <hash_init+0x186>
    6388:	8b 45 08             	mov    0x8(%ebp),%eax
    638b:	8b 40 0c             	mov    0xc(%eax),%eax
    638e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6391:	c1 e2 02             	shl    $0x2,%edx
    6394:	01 d0                	add    %edx,%eax
    6396:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    639c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    63a0:	b8 02 01 00 00       	mov    $0x102,%eax
    63a5:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    63a8:	76 de                	jbe    6388 <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    63aa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    63b1:	eb 17                	jmp    63ca <hash_init+0x1b0>
    63b3:	8b 45 08             	mov    0x8(%ebp),%eax
    63b6:	8b 40 10             	mov    0x10(%eax),%eax
    63b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63bc:	01 d2                	add    %edx,%edx
    63be:	01 d0                	add    %edx,%eax
    63c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63c3:	66 89 10             	mov    %dx,(%eax)
    63c6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    63ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    63cd:	3b 45 0c             	cmp    0xc(%ebp),%eax
    63d0:	75 e1                	jne    63b3 <hash_init+0x199>

  return 0;
    63d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    63d7:	c9                   	leave  
    63d8:	c3                   	ret    

000063d9 <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    63d9:	55                   	push   %ebp
    63da:	89 e5                	mov    %esp,%ebp
    63dc:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    63df:	8b 45 08             	mov    0x8(%ebp),%eax
    63e2:	8b 00                	mov    (%eax),%eax
    63e4:	83 ec 0c             	sub    $0xc,%esp
    63e7:	50                   	push   %eax
    63e8:	e8 57 cf ff ff       	call   3344 <lodepng_free>
    63ed:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    63f0:	8b 45 08             	mov    0x8(%ebp),%eax
    63f3:	8b 40 08             	mov    0x8(%eax),%eax
    63f6:	83 ec 0c             	sub    $0xc,%esp
    63f9:	50                   	push   %eax
    63fa:	e8 45 cf ff ff       	call   3344 <lodepng_free>
    63ff:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    6402:	8b 45 08             	mov    0x8(%ebp),%eax
    6405:	8b 40 04             	mov    0x4(%eax),%eax
    6408:	83 ec 0c             	sub    $0xc,%esp
    640b:	50                   	push   %eax
    640c:	e8 33 cf ff ff       	call   3344 <lodepng_free>
    6411:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    6414:	8b 45 08             	mov    0x8(%ebp),%eax
    6417:	8b 40 14             	mov    0x14(%eax),%eax
    641a:	83 ec 0c             	sub    $0xc,%esp
    641d:	50                   	push   %eax
    641e:	e8 21 cf ff ff       	call   3344 <lodepng_free>
    6423:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    6426:	8b 45 08             	mov    0x8(%ebp),%eax
    6429:	8b 40 0c             	mov    0xc(%eax),%eax
    642c:	83 ec 0c             	sub    $0xc,%esp
    642f:	50                   	push   %eax
    6430:	e8 0f cf ff ff       	call   3344 <lodepng_free>
    6435:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    6438:	8b 45 08             	mov    0x8(%ebp),%eax
    643b:	8b 40 10             	mov    0x10(%eax),%eax
    643e:	83 ec 0c             	sub    $0xc,%esp
    6441:	50                   	push   %eax
    6442:	e8 fd ce ff ff       	call   3344 <lodepng_free>
    6447:	83 c4 10             	add    $0x10,%esp
}
    644a:	90                   	nop
    644b:	c9                   	leave  
    644c:	c3                   	ret    

0000644d <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    644d:	55                   	push   %ebp
    644e:	89 e5                	mov    %esp,%ebp
    6450:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    6453:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    645a:	8b 45 10             	mov    0x10(%ebp),%eax
    645d:	83 c0 02             	add    $0x2,%eax
    6460:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6463:	7d 41                	jge    64a6 <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    6465:	8b 55 10             	mov    0x10(%ebp),%edx
    6468:	8b 45 08             	mov    0x8(%ebp),%eax
    646b:	01 d0                	add    %edx,%eax
    646d:	0f b6 00             	movzbl (%eax),%eax
    6470:	0f b6 c0             	movzbl %al,%eax
    6473:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    6476:	8b 45 10             	mov    0x10(%ebp),%eax
    6479:	8d 50 01             	lea    0x1(%eax),%edx
    647c:	8b 45 08             	mov    0x8(%ebp),%eax
    647f:	01 d0                	add    %edx,%eax
    6481:	0f b6 00             	movzbl (%eax),%eax
    6484:	0f b6 c0             	movzbl %al,%eax
    6487:	c1 e0 04             	shl    $0x4,%eax
    648a:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    648d:	8b 45 10             	mov    0x10(%ebp),%eax
    6490:	8d 50 02             	lea    0x2(%eax),%edx
    6493:	8b 45 08             	mov    0x8(%ebp),%eax
    6496:	01 d0                	add    %edx,%eax
    6498:	0f b6 00             	movzbl (%eax),%eax
    649b:	0f b6 c0             	movzbl %al,%eax
    649e:	c1 e0 08             	shl    $0x8,%eax
    64a1:	31 45 fc             	xor    %eax,-0x4(%ebp)
    64a4:	eb 51                	jmp    64f7 <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    64a6:	8b 45 10             	mov    0x10(%ebp),%eax
    64a9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    64ac:	7c 07                	jl     64b5 <getHash+0x68>
    64ae:	b8 00 00 00 00       	mov    $0x0,%eax
    64b3:	eb 4a                	jmp    64ff <getHash+0xb2>
    amount = size - pos;
    64b5:	8b 45 0c             	mov    0xc(%ebp),%eax
    64b8:	2b 45 10             	sub    0x10(%ebp),%eax
    64bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    64be:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    64c5:	eb 28                	jmp    64ef <getHash+0xa2>
    64c7:	8b 55 10             	mov    0x10(%ebp),%edx
    64ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64cd:	01 d0                	add    %edx,%eax
    64cf:	89 c2                	mov    %eax,%edx
    64d1:	8b 45 08             	mov    0x8(%ebp),%eax
    64d4:	01 d0                	add    %edx,%eax
    64d6:	0f b6 00             	movzbl (%eax),%eax
    64d9:	0f b6 d0             	movzbl %al,%edx
    64dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64df:	c1 e0 03             	shl    $0x3,%eax
    64e2:	89 c1                	mov    %eax,%ecx
    64e4:	d3 e2                	shl    %cl,%edx
    64e6:	89 d0                	mov    %edx,%eax
    64e8:	31 45 fc             	xor    %eax,-0x4(%ebp)
    64eb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    64ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64f2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    64f5:	75 d0                	jne    64c7 <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    64f7:	b8 ff ff 00 00       	mov    $0xffff,%eax
    64fc:	23 45 fc             	and    -0x4(%ebp),%eax
}
    64ff:	c9                   	leave  
    6500:	c3                   	ret    

00006501 <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    6501:	55                   	push   %ebp
    6502:	89 e5                	mov    %esp,%ebp
    6504:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    6507:	8b 55 10             	mov    0x10(%ebp),%edx
    650a:	8b 45 08             	mov    0x8(%ebp),%eax
    650d:	01 d0                	add    %edx,%eax
    650f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    6512:	b8 02 01 00 00       	mov    $0x102,%eax
    6517:	89 c2                	mov    %eax,%edx
    6519:	8b 45 f8             	mov    -0x8(%ebp),%eax
    651c:	01 d0                	add    %edx,%eax
    651e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    6521:	8b 55 0c             	mov    0xc(%ebp),%edx
    6524:	8b 45 08             	mov    0x8(%ebp),%eax
    6527:	01 d0                	add    %edx,%eax
    6529:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    652c:	73 0b                	jae    6539 <countZeros+0x38>
    652e:	8b 55 0c             	mov    0xc(%ebp),%edx
    6531:	8b 45 08             	mov    0x8(%ebp),%eax
    6534:	01 d0                	add    %edx,%eax
    6536:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    6539:	8b 45 f8             	mov    -0x8(%ebp),%eax
    653c:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    653f:	eb 04                	jmp    6545 <countZeros+0x44>
    6541:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    6545:	8b 45 08             	mov    0x8(%ebp),%eax
    6548:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    654b:	74 0a                	je     6557 <countZeros+0x56>
    654d:	8b 45 08             	mov    0x8(%ebp),%eax
    6550:	0f b6 00             	movzbl (%eax),%eax
    6553:	84 c0                	test   %al,%al
    6555:	74 ea                	je     6541 <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    6557:	8b 55 08             	mov    0x8(%ebp),%edx
    655a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    655d:	29 c2                	sub    %eax,%edx
    655f:	89 d0                	mov    %edx,%eax
}
    6561:	c9                   	leave  
    6562:	c3                   	ret    

00006563 <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    6563:	55                   	push   %ebp
    6564:	89 e5                	mov    %esp,%ebp
    6566:	83 ec 04             	sub    $0x4,%esp
    6569:	8b 45 14             	mov    0x14(%ebp),%eax
    656c:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    6570:	8b 45 08             	mov    0x8(%ebp),%eax
    6573:	8b 40 08             	mov    0x8(%eax),%eax
    6576:	8b 55 0c             	mov    0xc(%ebp),%edx
    6579:	c1 e2 02             	shl    $0x2,%edx
    657c:	01 c2                	add    %eax,%edx
    657e:	8b 45 10             	mov    0x10(%ebp),%eax
    6581:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    6583:	8b 45 08             	mov    0x8(%ebp),%eax
    6586:	8b 00                	mov    (%eax),%eax
    6588:	8b 55 10             	mov    0x10(%ebp),%edx
    658b:	c1 e2 02             	shl    $0x2,%edx
    658e:	01 d0                	add    %edx,%eax
    6590:	8b 00                	mov    (%eax),%eax
    6592:	83 f8 ff             	cmp    $0xffffffff,%eax
    6595:	74 1f                	je     65b6 <updateHashChain+0x53>
    6597:	8b 45 08             	mov    0x8(%ebp),%eax
    659a:	8b 40 04             	mov    0x4(%eax),%eax
    659d:	8b 55 0c             	mov    0xc(%ebp),%edx
    65a0:	01 d2                	add    %edx,%edx
    65a2:	01 c2                	add    %eax,%edx
    65a4:	8b 45 08             	mov    0x8(%ebp),%eax
    65a7:	8b 00                	mov    (%eax),%eax
    65a9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    65ac:	c1 e1 02             	shl    $0x2,%ecx
    65af:	01 c8                	add    %ecx,%eax
    65b1:	8b 00                	mov    (%eax),%eax
    65b3:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    65b6:	8b 45 08             	mov    0x8(%ebp),%eax
    65b9:	8b 00                	mov    (%eax),%eax
    65bb:	8b 55 10             	mov    0x10(%ebp),%edx
    65be:	c1 e2 02             	shl    $0x2,%edx
    65c1:	01 c2                	add    %eax,%edx
    65c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    65c6:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    65c8:	8b 45 08             	mov    0x8(%ebp),%eax
    65cb:	8b 40 14             	mov    0x14(%eax),%eax
    65ce:	8b 55 0c             	mov    0xc(%ebp),%edx
    65d1:	01 d2                	add    %edx,%edx
    65d3:	01 c2                	add    %eax,%edx
    65d5:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    65d9:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    65dc:	8b 45 08             	mov    0x8(%ebp),%eax
    65df:	8b 40 0c             	mov    0xc(%eax),%eax
    65e2:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    65e6:	c1 e2 02             	shl    $0x2,%edx
    65e9:	01 d0                	add    %edx,%eax
    65eb:	8b 00                	mov    (%eax),%eax
    65ed:	83 f8 ff             	cmp    $0xffffffff,%eax
    65f0:	74 21                	je     6613 <updateHashChain+0xb0>
    65f2:	8b 45 08             	mov    0x8(%ebp),%eax
    65f5:	8b 40 10             	mov    0x10(%eax),%eax
    65f8:	8b 55 0c             	mov    0xc(%ebp),%edx
    65fb:	01 d2                	add    %edx,%edx
    65fd:	01 c2                	add    %eax,%edx
    65ff:	8b 45 08             	mov    0x8(%ebp),%eax
    6602:	8b 40 0c             	mov    0xc(%eax),%eax
    6605:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    6609:	c1 e1 02             	shl    $0x2,%ecx
    660c:	01 c8                	add    %ecx,%eax
    660e:	8b 00                	mov    (%eax),%eax
    6610:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    6613:	8b 45 08             	mov    0x8(%ebp),%eax
    6616:	8b 40 0c             	mov    0xc(%eax),%eax
    6619:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    661d:	c1 e2 02             	shl    $0x2,%edx
    6620:	01 c2                	add    %eax,%edx
    6622:	8b 45 0c             	mov    0xc(%ebp),%eax
    6625:	89 02                	mov    %eax,(%edx)
}
    6627:	90                   	nop
    6628:	c9                   	leave  
    6629:	c3                   	ret    

0000662a <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    662a:	55                   	push   %ebp
    662b:	89 e5                	mov    %esp,%ebp
    662d:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    6630:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    6637:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    663e:	77 08                	ja     6648 <encodeLZ77+0x1e>
    6640:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6643:	c1 e8 03             	shr    $0x3,%eax
    6646:	eb 03                	jmp    664b <encodeLZ77+0x21>
    6648:	8b 45 1c             	mov    0x1c(%ebp),%eax
    664b:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    664e:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6655:	76 07                	jbe    665e <encodeLZ77+0x34>
    6657:	b8 02 01 00 00       	mov    $0x102,%eax
    665c:	eb 05                	jmp    6663 <encodeLZ77+0x39>
    665e:	b8 40 00 00 00       	mov    $0x40,%eax
    6663:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    6666:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    666d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    6674:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    667b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    6682:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    6689:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    668d:	74 09                	je     6698 <encodeLZ77+0x6e>
    668f:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    6696:	76 0a                	jbe    66a2 <encodeLZ77+0x78>
    6698:	b8 3c 00 00 00       	mov    $0x3c,%eax
    669d:	e9 e3 04 00 00       	jmp    6b85 <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    66a2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    66a5:	83 e8 01             	sub    $0x1,%eax
    66a8:	23 45 1c             	and    0x1c(%ebp),%eax
    66ab:	85 c0                	test   %eax,%eax
    66ad:	74 0a                	je     66b9 <encodeLZ77+0x8f>
    66af:	b8 5a 00 00 00       	mov    $0x5a,%eax
    66b4:	e9 cc 04 00 00       	jmp    6b85 <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    66b9:	b8 02 01 00 00       	mov    $0x102,%eax
    66be:	39 45 24             	cmp    %eax,0x24(%ebp)
    66c1:	76 08                	jbe    66cb <encodeLZ77+0xa1>
    66c3:	b8 02 01 00 00       	mov    $0x102,%eax
    66c8:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    66cb:	8b 45 14             	mov    0x14(%ebp),%eax
    66ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
    66d1:	e9 a0 04 00 00       	jmp    6b76 <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    66d6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    66d9:	8d 50 ff             	lea    -0x1(%eax),%edx
    66dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    66df:	21 d0                	and    %edx,%eax
    66e1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    66e4:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    66eb:	ff 75 fc             	pushl  -0x4(%ebp)
    66ee:	ff 75 18             	pushl  0x18(%ebp)
    66f1:	ff 75 10             	pushl  0x10(%ebp)
    66f4:	e8 54 fd ff ff       	call   644d <getHash>
    66f9:	83 c4 0c             	add    $0xc,%esp
    66fc:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    66ff:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6703:	74 4e                	je     6753 <encodeLZ77+0x129>
    6705:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6709:	75 48                	jne    6753 <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    670b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    670f:	75 16                	jne    6727 <encodeLZ77+0xfd>
    6711:	ff 75 fc             	pushl  -0x4(%ebp)
    6714:	ff 75 18             	pushl  0x18(%ebp)
    6717:	ff 75 10             	pushl  0x10(%ebp)
    671a:	e8 e2 fd ff ff       	call   6501 <countZeros>
    671f:	83 c4 0c             	add    $0xc,%esp
    6722:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6725:	eb 35                	jmp    675c <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6727:	8b 55 fc             	mov    -0x4(%ebp),%edx
    672a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    672d:	01 c2                	add    %eax,%edx
    672f:	8b 45 18             	mov    0x18(%ebp),%eax
    6732:	39 c2                	cmp    %eax,%edx
    6734:	77 17                	ja     674d <encodeLZ77+0x123>
    6736:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6739:	8b 45 f0             	mov    -0x10(%ebp),%eax
    673c:	01 d0                	add    %edx,%eax
    673e:	8d 50 ff             	lea    -0x1(%eax),%edx
    6741:	8b 45 10             	mov    0x10(%ebp),%eax
    6744:	01 d0                	add    %edx,%eax
    6746:	0f b6 00             	movzbl (%eax),%eax
    6749:	84 c0                	test   %al,%al
    674b:	74 0f                	je     675c <encodeLZ77+0x132>
    674d:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6751:	eb 09                	jmp    675c <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    6753:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    675a:	eb 01                	jmp    675d <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    675c:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    675d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6760:	0f b7 c0             	movzwl %ax,%eax
    6763:	50                   	push   %eax
    6764:	ff 75 b0             	pushl  -0x50(%ebp)
    6767:	ff 75 b4             	pushl  -0x4c(%ebp)
    676a:	ff 75 0c             	pushl  0xc(%ebp)
    676d:	e8 f1 fd ff ff       	call   6563 <updateHashChain>
    6772:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    6775:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    677c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    6783:	8b 45 0c             	mov    0xc(%ebp),%eax
    6786:	8b 40 04             	mov    0x4(%eax),%eax
    6789:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    678c:	01 d2                	add    %edx,%edx
    678e:	01 d0                	add    %edx,%eax
    6790:	0f b7 00             	movzwl (%eax),%eax
    6793:	0f b7 c0             	movzwl %ax,%eax
    6796:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    6799:	ba 02 01 00 00       	mov    $0x102,%edx
    679e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    67a1:	01 c2                	add    %eax,%edx
    67a3:	8b 45 18             	mov    0x18(%ebp),%eax
    67a6:	39 c2                	cmp    %eax,%edx
    67a8:	0f 4e c2             	cmovle %edx,%eax
    67ab:	89 c2                	mov    %eax,%edx
    67ad:	8b 45 10             	mov    0x10(%ebp),%eax
    67b0:	01 d0                	add    %edx,%eax
    67b2:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    67b5:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    67bc:	8b 45 c8             	mov    -0x38(%ebp),%eax
    67bf:	8d 50 01             	lea    0x1(%eax),%edx
    67c2:	89 55 c8             	mov    %edx,-0x38(%ebp)
    67c5:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    67c8:	0f 83 67 01 00 00    	jae    6935 <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    67ce:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    67d1:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    67d4:	77 08                	ja     67de <encodeLZ77+0x1b4>
    67d6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    67d9:	2b 45 cc             	sub    -0x34(%ebp),%eax
    67dc:	eb 0d                	jmp    67eb <encodeLZ77+0x1c1>
    67de:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    67e1:	2b 45 cc             	sub    -0x34(%ebp),%eax
    67e4:	89 c2                	mov    %eax,%edx
    67e6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    67e9:	01 d0                	add    %edx,%eax
    67eb:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    67ee:	8b 45 a8             	mov    -0x58(%ebp),%eax
    67f1:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    67f4:	0f 82 3e 01 00 00    	jb     6938 <encodeLZ77+0x30e>
      prev_offset = current_offset;
    67fa:	8b 45 a8             	mov    -0x58(%ebp),%eax
    67fd:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    6800:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    6804:	0f 84 a3 00 00 00    	je     68ad <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    680a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    680d:	8b 45 10             	mov    0x10(%ebp),%eax
    6810:	01 d0                	add    %edx,%eax
    6812:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    6815:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6818:	2b 45 a8             	sub    -0x58(%ebp),%eax
    681b:	89 c2                	mov    %eax,%edx
    681d:	8b 45 10             	mov    0x10(%ebp),%eax
    6820:	01 d0                	add    %edx,%eax
    6822:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    6825:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6829:	76 3a                	jbe    6865 <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    682b:	8b 45 0c             	mov    0xc(%ebp),%eax
    682e:	8b 40 14             	mov    0x14(%eax),%eax
    6831:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6834:	01 d2                	add    %edx,%edx
    6836:	01 d0                	add    %edx,%eax
    6838:	0f b7 00             	movzwl (%eax),%eax
    683b:	0f b7 c0             	movzwl %ax,%eax
    683e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    6841:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6844:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6847:	76 06                	jbe    684f <encodeLZ77+0x225>
    6849:	8b 45 f0             	mov    -0x10(%ebp),%eax
    684c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    684f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6852:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    6855:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6858:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    685b:	eb 08                	jmp    6865 <encodeLZ77+0x23b>
          ++backptr;
    685d:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    6861:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6865:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6868:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    686b:	74 10                	je     687d <encodeLZ77+0x253>
    686d:	8b 45 d0             	mov    -0x30(%ebp),%eax
    6870:	0f b6 10             	movzbl (%eax),%edx
    6873:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6876:	0f b6 00             	movzbl (%eax),%eax
    6879:	38 c2                	cmp    %al,%dl
    687b:	74 e0                	je     685d <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    687d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6880:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    6883:	8b 55 10             	mov    0x10(%ebp),%edx
    6886:	01 ca                	add    %ecx,%edx
    6888:	29 d0                	sub    %edx,%eax
    688a:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    688d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6890:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6893:	76 18                	jbe    68ad <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    6895:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6898:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    689b:	8b 45 a8             	mov    -0x58(%ebp),%eax
    689e:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    68a1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    68a4:	3b 45 24             	cmp    0x24(%ebp),%eax
    68a7:	0f 83 8e 00 00 00    	jae    693b <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    68ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    68b0:	8b 40 04             	mov    0x4(%eax),%eax
    68b3:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68b6:	01 d2                	add    %edx,%edx
    68b8:	01 d0                	add    %edx,%eax
    68ba:	0f b7 00             	movzwl (%eax),%eax
    68bd:	0f b7 c0             	movzwl %ax,%eax
    68c0:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    68c3:	74 79                	je     693e <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    68c5:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    68c9:	76 38                	jbe    6903 <encodeLZ77+0x2d9>
    68cb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    68ce:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    68d1:	76 30                	jbe    6903 <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    68d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    68d6:	8b 40 10             	mov    0x10(%eax),%eax
    68d9:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68dc:	01 d2                	add    %edx,%edx
    68de:	01 d0                	add    %edx,%eax
    68e0:	0f b7 00             	movzwl (%eax),%eax
    68e3:	0f b7 c0             	movzwl %ax,%eax
    68e6:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    68e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    68ec:	8b 40 14             	mov    0x14(%eax),%eax
    68ef:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68f2:	01 d2                	add    %edx,%edx
    68f4:	01 d0                	add    %edx,%eax
    68f6:	0f b7 00             	movzwl (%eax),%eax
    68f9:	0f b7 c0             	movzwl %ax,%eax
    68fc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    68ff:	74 2f                	je     6930 <encodeLZ77+0x306>
    6901:	eb 3f                	jmp    6942 <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    6903:	8b 45 0c             	mov    0xc(%ebp),%eax
    6906:	8b 40 04             	mov    0x4(%eax),%eax
    6909:	8b 55 cc             	mov    -0x34(%ebp),%edx
    690c:	01 d2                	add    %edx,%edx
    690e:	01 d0                	add    %edx,%eax
    6910:	0f b7 00             	movzwl (%eax),%eax
    6913:	0f b7 c0             	movzwl %ax,%eax
    6916:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6919:	8b 45 0c             	mov    0xc(%ebp),%eax
    691c:	8b 40 08             	mov    0x8(%eax),%eax
    691f:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6922:	c1 e2 02             	shl    $0x2,%edx
    6925:	01 d0                	add    %edx,%eax
    6927:	8b 10                	mov    (%eax),%edx
    6929:	8b 45 b0             	mov    -0x50(%ebp),%eax
    692c:	39 c2                	cmp    %eax,%edx
    692e:	75 11                	jne    6941 <encodeLZ77+0x317>
      }
    }
    6930:	e9 87 fe ff ff       	jmp    67bc <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6935:	90                   	nop
    6936:	eb 0a                	jmp    6942 <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    6938:	90                   	nop
    6939:	eb 07                	jmp    6942 <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    693b:	90                   	nop
    693c:	eb 04                	jmp    6942 <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    693e:	90                   	nop
    693f:	eb 01                	jmp    6942 <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6941:	90                   	nop
      }
    }

    if(lazymatching) {
    6942:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    6946:	0f 84 c8 00 00 00    	je     6a14 <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    694c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6950:	75 30                	jne    6982 <encodeLZ77+0x358>
    6952:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6956:	76 2a                	jbe    6982 <encodeLZ77+0x358>
    6958:	8b 45 e8             	mov    -0x18(%ebp),%eax
    695b:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    695e:	77 22                	ja     6982 <encodeLZ77+0x358>
    6960:	b8 02 01 00 00       	mov    $0x102,%eax
    6965:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6968:	73 18                	jae    6982 <encodeLZ77+0x358>
        lazy = 1;
    696a:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    6971:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6974:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    6977:	8b 45 ec             	mov    -0x14(%ebp),%eax
    697a:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    697d:	e9 f0 01 00 00       	jmp    6b72 <encodeLZ77+0x548>
      }
      if(lazy) {
    6982:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6986:	0f 84 88 00 00 00    	je     6a14 <encodeLZ77+0x3ea>
        lazy = 0;
    698c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    6993:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    6997:	75 0c                	jne    69a5 <encodeLZ77+0x37b>
    6999:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    69a0:	e9 dd 01 00 00       	jmp    6b82 <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    69a5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    69a8:	83 c0 01             	add    $0x1,%eax
    69ab:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    69ae:	73 2d                	jae    69dd <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    69b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    69b3:	8d 50 ff             	lea    -0x1(%eax),%edx
    69b6:	8b 45 10             	mov    0x10(%ebp),%eax
    69b9:	01 d0                	add    %edx,%eax
    69bb:	0f b6 00             	movzbl (%eax),%eax
    69be:	0f b6 c0             	movzbl %al,%eax
    69c1:	50                   	push   %eax
    69c2:	ff 75 08             	pushl  0x8(%ebp)
    69c5:	e8 6f cb ff ff       	call   3539 <uivector_push_back>
    69ca:	83 c4 08             	add    $0x8,%esp
    69cd:	85 c0                	test   %eax,%eax
    69cf:	75 43                	jne    6a14 <encodeLZ77+0x3ea>
    69d1:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    69d8:	e9 a5 01 00 00       	jmp    6b82 <encodeLZ77+0x558>
        } else {
          length = lazylength;
    69dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
    69e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    69e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
    69e6:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    69e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    69ec:	8b 00                	mov    (%eax),%eax
    69ee:	8b 55 b0             	mov    -0x50(%ebp),%edx
    69f1:	c1 e2 02             	shl    $0x2,%edx
    69f4:	01 d0                	add    %edx,%eax
    69f6:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    69fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    69ff:	8b 40 0c             	mov    0xc(%eax),%eax
    6a02:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6a05:	c1 e2 02             	shl    $0x2,%edx
    6a08:	01 d0                	add    %edx,%eax
    6a0a:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    6a10:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    6a14:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6a18:	76 14                	jbe    6a2e <encodeLZ77+0x404>
    6a1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a1d:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    6a20:	76 0c                	jbe    6a2e <encodeLZ77+0x404>
    6a22:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    6a29:	e9 54 01 00 00       	jmp    6b82 <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    6a2e:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6a32:	77 2e                	ja     6a62 <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6a34:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6a37:	8b 45 10             	mov    0x10(%ebp),%eax
    6a3a:	01 d0                	add    %edx,%eax
    6a3c:	0f b6 00             	movzbl (%eax),%eax
    6a3f:	0f b6 c0             	movzbl %al,%eax
    6a42:	50                   	push   %eax
    6a43:	ff 75 08             	pushl  0x8(%ebp)
    6a46:	e8 ee ca ff ff       	call   3539 <uivector_push_back>
    6a4b:	83 c4 08             	add    $0x8,%esp
    6a4e:	85 c0                	test   %eax,%eax
    6a50:	0f 85 1c 01 00 00    	jne    6b72 <encodeLZ77+0x548>
    6a56:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6a5d:	e9 20 01 00 00       	jmp    6b82 <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    6a62:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6a65:	3b 45 20             	cmp    0x20(%ebp),%eax
    6a68:	72 0f                	jb     6a79 <encodeLZ77+0x44f>
    6a6a:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    6a6e:	75 37                	jne    6aa7 <encodeLZ77+0x47d>
    6a70:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    6a77:	76 2e                	jbe    6aa7 <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6a79:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6a7c:	8b 45 10             	mov    0x10(%ebp),%eax
    6a7f:	01 d0                	add    %edx,%eax
    6a81:	0f b6 00             	movzbl (%eax),%eax
    6a84:	0f b6 c0             	movzbl %al,%eax
    6a87:	50                   	push   %eax
    6a88:	ff 75 08             	pushl  0x8(%ebp)
    6a8b:	e8 a9 ca ff ff       	call   3539 <uivector_push_back>
    6a90:	83 c4 08             	add    $0x8,%esp
    6a93:	85 c0                	test   %eax,%eax
    6a95:	0f 85 d7 00 00 00    	jne    6b72 <encodeLZ77+0x548>
    6a9b:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6aa2:	e9 db 00 00 00       	jmp    6b82 <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    6aa7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6aaa:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6aad:	52                   	push   %edx
    6aae:	50                   	push   %eax
    6aaf:	ff 75 08             	pushl  0x8(%ebp)
    6ab2:	e8 8a f6 ff ff       	call   6141 <addLengthDistance>
    6ab7:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    6aba:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    6ac1:	e9 a0 00 00 00       	jmp    6b66 <encodeLZ77+0x53c>
        ++pos;
    6ac6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    6aca:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6acd:	8d 50 ff             	lea    -0x1(%eax),%edx
    6ad0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6ad3:	21 d0                	and    %edx,%eax
    6ad5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    6ad8:	ff 75 fc             	pushl  -0x4(%ebp)
    6adb:	ff 75 18             	pushl  0x18(%ebp)
    6ade:	ff 75 10             	pushl  0x10(%ebp)
    6ae1:	e8 67 f9 ff ff       	call   644d <getHash>
    6ae6:	83 c4 0c             	add    $0xc,%esp
    6ae9:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    6aec:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6af0:	74 4e                	je     6b40 <encodeLZ77+0x516>
    6af2:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6af6:	75 48                	jne    6b40 <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6af8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6afc:	75 16                	jne    6b14 <encodeLZ77+0x4ea>
    6afe:	ff 75 fc             	pushl  -0x4(%ebp)
    6b01:	ff 75 18             	pushl  0x18(%ebp)
    6b04:	ff 75 10             	pushl  0x10(%ebp)
    6b07:	e8 f5 f9 ff ff       	call   6501 <countZeros>
    6b0c:	83 c4 0c             	add    $0xc,%esp
    6b0f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6b12:	eb 35                	jmp    6b49 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6b14:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6b17:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b1a:	01 c2                	add    %eax,%edx
    6b1c:	8b 45 18             	mov    0x18(%ebp),%eax
    6b1f:	39 c2                	cmp    %eax,%edx
    6b21:	77 17                	ja     6b3a <encodeLZ77+0x510>
    6b23:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6b26:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b29:	01 d0                	add    %edx,%eax
    6b2b:	8d 50 ff             	lea    -0x1(%eax),%edx
    6b2e:	8b 45 10             	mov    0x10(%ebp),%eax
    6b31:	01 d0                	add    %edx,%eax
    6b33:	0f b6 00             	movzbl (%eax),%eax
    6b36:	84 c0                	test   %al,%al
    6b38:	74 0f                	je     6b49 <encodeLZ77+0x51f>
    6b3a:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6b3e:	eb 09                	jmp    6b49 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    6b40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6b47:	eb 01                	jmp    6b4a <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6b49:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    6b4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b4d:	0f b7 c0             	movzwl %ax,%eax
    6b50:	50                   	push   %eax
    6b51:	ff 75 b0             	pushl  -0x50(%ebp)
    6b54:	ff 75 b4             	pushl  -0x4c(%ebp)
    6b57:	ff 75 0c             	pushl  0xc(%ebp)
    6b5a:	e8 04 fa ff ff       	call   6563 <updateHashChain>
    6b5f:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    6b62:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6b66:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6b69:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6b6c:	0f 82 54 ff ff ff    	jb     6ac6 <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    6b72:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6b76:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6b79:	3b 45 18             	cmp    0x18(%ebp),%eax
    6b7c:	0f 8c 54 fb ff ff    	jl     66d6 <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    6b82:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6b85:	c9                   	leave  
    6b86:	c3                   	ret    

00006b87 <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    6b87:	55                   	push   %ebp
    6b88:	89 e5                	mov    %esp,%ebp
    6b8a:	53                   	push   %ebx
    6b8b:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    6b8e:	8b 45 10             	mov    0x10(%ebp),%eax
    6b91:	05 fe ff 00 00       	add    $0xfffe,%eax
    6b96:	ba 01 80 00 80       	mov    $0x80008001,%edx
    6b9b:	f7 e2                	mul    %edx
    6b9d:	89 d0                	mov    %edx,%eax
    6b9f:	c1 e8 0f             	shr    $0xf,%eax
    6ba2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    6ba5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    6bac:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6bb3:	e9 1b 01 00 00       	jmp    6cd3 <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    6bb8:	8b 45 08             	mov    0x8(%ebp),%eax
    6bbb:	8b 40 04             	mov    0x4(%eax),%eax
    6bbe:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    6bc1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6bc4:	83 e8 01             	sub    $0x1,%eax
    6bc7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6bca:	0f 94 c0             	sete   %al
    6bcd:	0f b6 c0             	movzbl %al,%eax
    6bd0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    6bd3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    6bda:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    6be1:	8b 45 10             	mov    0x10(%ebp),%eax
    6be4:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6be7:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    6bec:	77 09                	ja     6bf7 <deflateNoCompression+0x70>
    6bee:	8b 45 10             	mov    0x10(%ebp),%eax
    6bf1:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6bf4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    6bf7:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6bfc:	2b 45 f0             	sub    -0x10(%ebp),%eax
    6bff:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    6c02:	8b 45 08             	mov    0x8(%ebp),%eax
    6c05:	8b 40 04             	mov    0x4(%eax),%eax
    6c08:	89 c2                	mov    %eax,%edx
    6c0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c0d:	01 d0                	add    %edx,%eax
    6c0f:	83 c0 05             	add    $0x5,%eax
    6c12:	50                   	push   %eax
    6c13:	ff 75 08             	pushl  0x8(%ebp)
    6c16:	e8 62 c9 ff ff       	call   357d <ucvector_resize>
    6c1b:	83 c4 08             	add    $0x8,%esp
    6c1e:	85 c0                	test   %eax,%eax
    6c20:	75 0a                	jne    6c2c <deflateNoCompression+0xa5>
    6c22:	b8 53 00 00 00       	mov    $0x53,%eax
    6c27:	e9 b8 00 00 00       	jmp    6ce4 <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    6c2c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6c2f:	89 c2                	mov    %eax,%edx
    6c31:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6c34:	83 e0 01             	and    $0x1,%eax
    6c37:	01 c0                	add    %eax,%eax
    6c39:	01 c2                	add    %eax,%edx
    6c3b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6c3e:	83 e0 02             	and    $0x2,%eax
    6c41:	01 c0                	add    %eax,%eax
    6c43:	01 d0                	add    %edx,%eax
    6c45:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    6c48:	8b 45 08             	mov    0x8(%ebp),%eax
    6c4b:	8b 10                	mov    (%eax),%edx
    6c4d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6c50:	01 c2                	add    %eax,%edx
    6c52:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    6c56:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    6c58:	8b 45 08             	mov    0x8(%ebp),%eax
    6c5b:	8b 00                	mov    (%eax),%eax
    6c5d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c60:	83 c2 01             	add    $0x1,%edx
    6c63:	01 d0                	add    %edx,%eax
    6c65:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6c68:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    6c6a:	8b 45 08             	mov    0x8(%ebp),%eax
    6c6d:	8b 00                	mov    (%eax),%eax
    6c6f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c72:	83 c2 02             	add    $0x2,%edx
    6c75:	01 d0                	add    %edx,%eax
    6c77:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6c7a:	c1 ea 08             	shr    $0x8,%edx
    6c7d:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    6c7f:	8b 45 08             	mov    0x8(%ebp),%eax
    6c82:	8b 00                	mov    (%eax),%eax
    6c84:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c87:	83 c2 03             	add    $0x3,%edx
    6c8a:	01 d0                	add    %edx,%eax
    6c8c:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6c8f:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    6c91:	8b 45 08             	mov    0x8(%ebp),%eax
    6c94:	8b 00                	mov    (%eax),%eax
    6c96:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c99:	83 c2 04             	add    $0x4,%edx
    6c9c:	01 d0                	add    %edx,%eax
    6c9e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6ca1:	c1 ea 08             	shr    $0x8,%edx
    6ca4:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    6ca6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ca9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    6cac:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6caf:	01 d1                	add    %edx,%ecx
    6cb1:	8b 55 08             	mov    0x8(%ebp),%edx
    6cb4:	8b 12                	mov    (%edx),%edx
    6cb6:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6cb9:	83 c3 05             	add    $0x5,%ebx
    6cbc:	01 da                	add    %ebx,%edx
    6cbe:	50                   	push   %eax
    6cbf:	51                   	push   %ecx
    6cc0:	52                   	push   %edx
    6cc1:	e8 9b c6 ff ff       	call   3361 <lodepng_memcpy>
    6cc6:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    6cc9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ccc:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    6ccf:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6cd3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6cd6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6cd9:	0f 85 d9 fe ff ff    	jne    6bb8 <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    6cdf:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6ce4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6ce7:	c9                   	leave  
    6ce8:	c3                   	ret    

00006ce9 <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    6ce9:	55                   	push   %ebp
    6cea:	89 e5                	mov    %esp,%ebp
    6cec:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    6cef:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    6cf6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    6cfd:	e9 10 01 00 00       	jmp    6e12 <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    6d02:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d05:	8b 00                	mov    (%eax),%eax
    6d07:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d0a:	c1 e2 02             	shl    $0x2,%edx
    6d0d:	01 d0                	add    %edx,%eax
    6d0f:	8b 00                	mov    (%eax),%eax
    6d11:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    6d14:	8b 45 10             	mov    0x10(%ebp),%eax
    6d17:	8b 40 04             	mov    0x4(%eax),%eax
    6d1a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6d1d:	c1 e2 02             	shl    $0x2,%edx
    6d20:	01 d0                	add    %edx,%eax
    6d22:	8b 00                	mov    (%eax),%eax
    6d24:	89 c1                	mov    %eax,%ecx
    6d26:	8b 45 10             	mov    0x10(%ebp),%eax
    6d29:	8b 00                	mov    (%eax),%eax
    6d2b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6d2e:	c1 e2 02             	shl    $0x2,%edx
    6d31:	01 d0                	add    %edx,%eax
    6d33:	8b 00                	mov    (%eax),%eax
    6d35:	51                   	push   %ecx
    6d36:	50                   	push   %eax
    6d37:	ff 75 08             	pushl  0x8(%ebp)
    6d3a:	e8 60 cc ff ff       	call   399f <writeBitsReversed>
    6d3f:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    6d42:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    6d49:	0f 86 bf 00 00 00    	jbe    6e0e <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    6d4f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6d52:	2d 01 01 00 00       	sub    $0x101,%eax
    6d57:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    6d5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6d5d:	8b 04 85 a0 9d 01 00 	mov    0x19da0(,%eax,4),%eax
    6d64:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    6d67:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d6a:	8b 00                	mov    (%eax),%eax
    6d6c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6d70:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d73:	c1 e2 02             	shl    $0x2,%edx
    6d76:	01 d0                	add    %edx,%eax
    6d78:	8b 00                	mov    (%eax),%eax
    6d7a:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    6d7d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d80:	8b 00                	mov    (%eax),%eax
    6d82:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6d86:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d89:	c1 e2 02             	shl    $0x2,%edx
    6d8c:	01 d0                	add    %edx,%eax
    6d8e:	8b 00                	mov    (%eax),%eax
    6d90:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    6d93:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6d96:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    6d99:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6d9c:	8b 04 85 a0 9e 01 00 	mov    0x19ea0(,%eax,4),%eax
    6da3:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    6da6:	8b 45 0c             	mov    0xc(%ebp),%eax
    6da9:	8b 00                	mov    (%eax),%eax
    6dab:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6daf:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6db2:	c1 e2 02             	shl    $0x2,%edx
    6db5:	01 d0                	add    %edx,%eax
    6db7:	8b 00                	mov    (%eax),%eax
    6db9:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    6dbc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6dbf:	50                   	push   %eax
    6dc0:	ff 75 ec             	pushl  -0x14(%ebp)
    6dc3:	ff 75 08             	pushl  0x8(%ebp)
    6dc6:	e8 40 ca ff ff       	call   380b <writeBits>
    6dcb:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    6dce:	8b 45 14             	mov    0x14(%ebp),%eax
    6dd1:	8b 40 04             	mov    0x4(%eax),%eax
    6dd4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6dd7:	c1 e2 02             	shl    $0x2,%edx
    6dda:	01 d0                	add    %edx,%eax
    6ddc:	8b 00                	mov    (%eax),%eax
    6dde:	89 c1                	mov    %eax,%ecx
    6de0:	8b 45 14             	mov    0x14(%ebp),%eax
    6de3:	8b 00                	mov    (%eax),%eax
    6de5:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6de8:	c1 e2 02             	shl    $0x2,%edx
    6deb:	01 d0                	add    %edx,%eax
    6ded:	8b 00                	mov    (%eax),%eax
    6def:	51                   	push   %ecx
    6df0:	50                   	push   %eax
    6df1:	ff 75 08             	pushl  0x8(%ebp)
    6df4:	e8 a6 cb ff ff       	call   399f <writeBitsReversed>
    6df9:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    6dfc:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6dff:	50                   	push   %eax
    6e00:	ff 75 dc             	pushl  -0x24(%ebp)
    6e03:	ff 75 08             	pushl  0x8(%ebp)
    6e06:	e8 00 ca ff ff       	call   380b <writeBits>
    6e0b:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    6e0e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6e12:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e15:	8b 40 04             	mov    0x4(%eax),%eax
    6e18:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6e1b:	0f 85 e1 fe ff ff    	jne    6d02 <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    6e21:	90                   	nop
    6e22:	c9                   	leave  
    6e23:	c3                   	ret    

00006e24 <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    6e24:	55                   	push   %ebp
    6e25:	89 e5                	mov    %esp,%ebp
    6e27:	53                   	push   %ebx
    6e28:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    6e2e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    6e35:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    6e3c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    6e43:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    6e4a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    6e51:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    6e58:	8b 45 18             	mov    0x18(%ebp),%eax
    6e5b:	2b 45 14             	sub    0x14(%ebp),%eax
    6e5e:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    6e61:	8b 45 20             	mov    0x20(%ebp),%eax
    6e64:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    6e67:	8d 45 90             	lea    -0x70(%ebp),%eax
    6e6a:	50                   	push   %eax
    6e6b:	e8 a4 c6 ff ff       	call   3514 <uivector_init>
    6e70:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    6e73:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    6e79:	50                   	push   %eax
    6e7a:	e8 98 d3 ff ff       	call   4217 <HuffmanTree_init>
    6e7f:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    6e82:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    6e88:	50                   	push   %eax
    6e89:	e8 89 d3 ff ff       	call   4217 <HuffmanTree_init>
    6e8e:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    6e91:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    6e97:	50                   	push   %eax
    6e98:	e8 7a d3 ff ff       	call   4217 <HuffmanTree_init>
    6e9d:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    6ea0:	83 ec 0c             	sub    $0xc,%esp
    6ea3:	68 78 04 00 00       	push   $0x478
    6ea8:	e8 76 c4 ff ff       	call   3323 <lodepng_malloc>
    6ead:	83 c4 10             	add    $0x10,%esp
    6eb0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    6eb3:	83 ec 0c             	sub    $0xc,%esp
    6eb6:	6a 78                	push   $0x78
    6eb8:	e8 66 c4 ff ff       	call   3323 <lodepng_malloc>
    6ebd:	83 c4 10             	add    $0x10,%esp
    6ec0:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6ec3:	83 ec 0c             	sub    $0xc,%esp
    6ec6:	6a 4c                	push   $0x4c
    6ec8:	e8 56 c4 ff ff       	call   3323 <lodepng_malloc>
    6ecd:	83 c4 10             	add    $0x10,%esp
    6ed0:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    6ed3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    6ed7:	74 0c                	je     6ee5 <deflateDynamic+0xc1>
    6ed9:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    6edd:	74 06                	je     6ee5 <deflateDynamic+0xc1>
    6edf:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    6ee3:	75 07                	jne    6eec <deflateDynamic+0xc8>
    6ee5:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    6eec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6ef0:	0f 85 f6 07 00 00    	jne    76ec <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    6ef6:	83 ec 04             	sub    $0x4,%esp
    6ef9:	68 78 04 00 00       	push   $0x478
    6efe:	6a 00                	push   $0x0
    6f00:	ff 75 d4             	pushl  -0x2c(%ebp)
    6f03:	e8 8c c4 ff ff       	call   3394 <lodepng_memset>
    6f08:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    6f0b:	83 ec 04             	sub    $0x4,%esp
    6f0e:	6a 78                	push   $0x78
    6f10:	6a 00                	push   $0x0
    6f12:	ff 75 d0             	pushl  -0x30(%ebp)
    6f15:	e8 7a c4 ff ff       	call   3394 <lodepng_memset>
    6f1a:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6f1d:	83 ec 04             	sub    $0x4,%esp
    6f20:	6a 4c                	push   $0x4c
    6f22:	6a 00                	push   $0x0
    6f24:	ff 75 cc             	pushl  -0x34(%ebp)
    6f27:	e8 68 c4 ff ff       	call   3394 <lodepng_memset>
    6f2c:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    6f2f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f32:	8b 40 04             	mov    0x4(%eax),%eax
    6f35:	85 c0                	test   %eax,%eax
    6f37:	74 45                	je     6f7e <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    6f39:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f3c:	8b 58 14             	mov    0x14(%eax),%ebx
    6f3f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f42:	8b 48 10             	mov    0x10(%eax),%ecx
    6f45:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f48:	8b 50 0c             	mov    0xc(%eax),%edx
    6f4b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f4e:	8b 40 08             	mov    0x8(%eax),%eax
    6f51:	83 ec 0c             	sub    $0xc,%esp
    6f54:	53                   	push   %ebx
    6f55:	51                   	push   %ecx
    6f56:	52                   	push   %edx
    6f57:	50                   	push   %eax
    6f58:	ff 75 18             	pushl  0x18(%ebp)
    6f5b:	ff 75 14             	pushl  0x14(%ebp)
    6f5e:	ff 75 10             	pushl  0x10(%ebp)
    6f61:	ff 75 0c             	pushl  0xc(%ebp)
    6f64:	8d 45 90             	lea    -0x70(%ebp),%eax
    6f67:	50                   	push   %eax
    6f68:	e8 bd f6 ff ff       	call   662a <encodeLZ77>
    6f6d:	83 c4 30             	add    $0x30,%esp
    6f70:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    6f73:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6f77:	74 59                	je     6fd2 <deflateDynamic+0x1ae>
    6f79:	e9 6e 07 00 00       	jmp    76ec <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    6f7e:	83 ec 08             	sub    $0x8,%esp
    6f81:	ff 75 c8             	pushl  -0x38(%ebp)
    6f84:	8d 45 90             	lea    -0x70(%ebp),%eax
    6f87:	50                   	push   %eax
    6f88:	e8 17 c5 ff ff       	call   34a4 <uivector_resize>
    6f8d:	83 c4 10             	add    $0x10,%esp
    6f90:	85 c0                	test   %eax,%eax
    6f92:	75 0c                	jne    6fa0 <deflateDynamic+0x17c>
    6f94:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6f9b:	e9 4c 07 00 00       	jmp    76ec <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    6fa0:	8b 45 14             	mov    0x14(%ebp),%eax
    6fa3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    6fa6:	eb 22                	jmp    6fca <deflateDynamic+0x1a6>
    6fa8:	8b 55 90             	mov    -0x70(%ebp),%edx
    6fab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6fae:	2b 45 14             	sub    0x14(%ebp),%eax
    6fb1:	c1 e0 02             	shl    $0x2,%eax
    6fb4:	01 c2                	add    %eax,%edx
    6fb6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    6fb9:	8b 45 10             	mov    0x10(%ebp),%eax
    6fbc:	01 c8                	add    %ecx,%eax
    6fbe:	0f b6 00             	movzbl (%eax),%eax
    6fc1:	0f b6 c0             	movzbl %al,%eax
    6fc4:	89 02                	mov    %eax,(%edx)
    6fc6:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    6fca:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6fcd:	3b 45 18             	cmp    0x18(%ebp),%eax
    6fd0:	7c d6                	jl     6fa8 <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    6fd2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    6fd9:	eb 60                	jmp    703b <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    6fdb:	8b 45 90             	mov    -0x70(%ebp),%eax
    6fde:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6fe1:	c1 e2 02             	shl    $0x2,%edx
    6fe4:	01 d0                	add    %edx,%eax
    6fe6:	8b 00                	mov    (%eax),%eax
    6fe8:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    6feb:	8b 45 c0             	mov    -0x40(%ebp),%eax
    6fee:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6ff5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6ff8:	01 d0                	add    %edx,%eax
    6ffa:	8b 10                	mov    (%eax),%edx
    6ffc:	83 c2 01             	add    $0x1,%edx
    6fff:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    7001:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    7008:	76 2d                	jbe    7037 <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    700a:	8b 45 90             	mov    -0x70(%ebp),%eax
    700d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7010:	83 c2 02             	add    $0x2,%edx
    7013:	c1 e2 02             	shl    $0x2,%edx
    7016:	01 d0                	add    %edx,%eax
    7018:	8b 00                	mov    (%eax),%eax
    701a:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    701d:	8b 45 bc             	mov    -0x44(%ebp),%eax
    7020:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7027:	8b 45 d0             	mov    -0x30(%ebp),%eax
    702a:	01 d0                	add    %edx,%eax
    702c:	8b 10                	mov    (%eax),%edx
    702e:	83 c2 01             	add    $0x1,%edx
    7031:	89 10                	mov    %edx,(%eax)
        i += 3;
    7033:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    7037:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    703b:	8b 45 94             	mov    -0x6c(%ebp),%eax
    703e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7041:	75 98                	jne    6fdb <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    7043:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7046:	05 00 04 00 00       	add    $0x400,%eax
    704b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    7051:	83 ec 0c             	sub    $0xc,%esp
    7054:	6a 0f                	push   $0xf
    7056:	68 1e 01 00 00       	push   $0x11e
    705b:	68 01 01 00 00       	push   $0x101
    7060:	ff 75 d4             	pushl  -0x2c(%ebp)
    7063:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7069:	50                   	push   %eax
    706a:	e8 e0 e1 ff ff       	call   524f <HuffmanTree_makeFromFrequencies>
    706f:	83 c4 20             	add    $0x20,%esp
    7072:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7075:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7079:	0f 85 66 06 00 00    	jne    76e5 <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    707f:	83 ec 0c             	sub    $0xc,%esp
    7082:	6a 0f                	push   $0xf
    7084:	6a 1e                	push   $0x1e
    7086:	6a 02                	push   $0x2
    7088:	ff 75 d0             	pushl  -0x30(%ebp)
    708b:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7091:	50                   	push   %eax
    7092:	e8 b8 e1 ff ff       	call   524f <HuffmanTree_makeFromFrequencies>
    7097:	83 c4 20             	add    $0x20,%esp
    709a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    709d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    70a1:	0f 85 41 06 00 00    	jne    76e8 <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    70a7:	8b 45 84             	mov    -0x7c(%ebp),%eax
    70aa:	ba 1e 01 00 00       	mov    $0x11e,%edx
    70af:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    70b4:	0f 47 c2             	cmova  %edx,%eax
    70b7:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    70ba:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    70c0:	ba 1e 00 00 00       	mov    $0x1e,%edx
    70c5:	83 f8 1e             	cmp    $0x1e,%eax
    70c8:	0f 47 c2             	cmova  %edx,%eax
    70cb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    70ce:	8b 55 b8             	mov    -0x48(%ebp),%edx
    70d1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    70d4:	01 d0                	add    %edx,%eax
    70d6:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    70d9:	8b 45 b0             	mov    -0x50(%ebp),%eax
    70dc:	c1 e0 02             	shl    $0x2,%eax
    70df:	83 ec 0c             	sub    $0xc,%esp
    70e2:	50                   	push   %eax
    70e3:	e8 3b c2 ff ff       	call   3323 <lodepng_malloc>
    70e8:	83 c4 10             	add    $0x10,%esp
    70eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    70ee:	8b 45 b0             	mov    -0x50(%ebp),%eax
    70f1:	c1 e0 02             	shl    $0x2,%eax
    70f4:	83 ec 0c             	sub    $0xc,%esp
    70f7:	50                   	push   %eax
    70f8:	e8 26 c2 ff ff       	call   3323 <lodepng_malloc>
    70fd:	83 c4 10             	add    $0x10,%esp
    7100:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    7103:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7107:	74 06                	je     710f <deflateDynamic+0x2eb>
    7109:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    710d:	75 0c                	jne    711b <deflateDynamic+0x2f7>
    710f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7116:	e9 d1 05 00 00       	jmp    76ec <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    711b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    7122:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7129:	eb 25                	jmp    7150 <deflateDynamic+0x32c>
    712b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    712e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7135:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7138:	01 c2                	add    %eax,%edx
    713a:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7140:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7143:	c1 e1 02             	shl    $0x2,%ecx
    7146:	01 c8                	add    %ecx,%eax
    7148:	8b 00                	mov    (%eax),%eax
    714a:	89 02                	mov    %eax,(%edx)
    714c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7150:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7153:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    7156:	75 d3                	jne    712b <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    7158:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    715f:	eb 2a                	jmp    718b <deflateDynamic+0x367>
    7161:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7164:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7167:	01 d0                	add    %edx,%eax
    7169:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7170:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7173:	01 c2                	add    %eax,%edx
    7175:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    717b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    717e:	c1 e1 02             	shl    $0x2,%ecx
    7181:	01 c8                	add    %ecx,%eax
    7183:	8b 00                	mov    (%eax),%eax
    7185:	89 02                	mov    %eax,(%edx)
    7187:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    718b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    718e:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    7191:	75 ce                	jne    7161 <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7193:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    719a:	e9 3b 02 00 00       	jmp    73da <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    719f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    71a6:	eb 04                	jmp    71ac <deflateDynamic+0x388>
    71a8:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    71ac:	8b 55 e8             	mov    -0x18(%ebp),%edx
    71af:	8b 45 dc             	mov    -0x24(%ebp),%eax
    71b2:	01 d0                	add    %edx,%eax
    71b4:	8d 50 01             	lea    0x1(%eax),%edx
    71b7:	8b 45 b0             	mov    -0x50(%ebp),%eax
    71ba:	39 c2                	cmp    %eax,%edx
    71bc:	73 2e                	jae    71ec <deflateDynamic+0x3c8>
    71be:	8b 55 e8             	mov    -0x18(%ebp),%edx
    71c1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    71c4:	01 d0                	add    %edx,%eax
    71c6:	83 c0 01             	add    $0x1,%eax
    71c9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    71d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    71d3:	01 d0                	add    %edx,%eax
    71d5:	8b 10                	mov    (%eax),%edx
    71d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71da:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    71e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    71e4:	01 c8                	add    %ecx,%eax
    71e6:	8b 00                	mov    (%eax),%eax
    71e8:	39 c2                	cmp    %eax,%edx
    71ea:	74 bc                	je     71a8 <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    71ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71ef:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    71f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    71f9:	01 d0                	add    %edx,%eax
    71fb:	8b 00                	mov    (%eax),%eax
    71fd:	85 c0                	test   %eax,%eax
    71ff:	0f 85 a9 00 00 00    	jne    72ae <deflateDynamic+0x48a>
    7205:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    7209:	0f 86 9f 00 00 00    	jbe    72ae <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    720f:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    7213:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    7217:	77 3a                	ja     7253 <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    7219:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    721c:	8d 50 01             	lea    0x1(%eax),%edx
    721f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7222:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7229:	8b 45 ec             	mov    -0x14(%ebp),%eax
    722c:	01 d0                	add    %edx,%eax
    722e:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    7234:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7237:	8d 50 01             	lea    0x1(%eax),%edx
    723a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    723d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7244:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7247:	01 d0                	add    %edx,%eax
    7249:	8b 55 dc             	mov    -0x24(%ebp),%edx
    724c:	83 ea 03             	sub    $0x3,%edx
    724f:	89 10                	mov    %edx,(%eax)
    7251:	eb 48                	jmp    729b <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    7253:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    725a:	76 07                	jbe    7263 <deflateDynamic+0x43f>
    725c:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    7263:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7266:	8d 50 01             	lea    0x1(%eax),%edx
    7269:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    726c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7273:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7276:	01 d0                	add    %edx,%eax
    7278:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    727e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7281:	8d 50 01             	lea    0x1(%eax),%edx
    7284:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7287:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    728e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7291:	01 d0                	add    %edx,%eax
    7293:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7296:	83 ea 0b             	sub    $0xb,%edx
    7299:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    729b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    729e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    72a1:	01 d0                	add    %edx,%eax
    72a3:	83 e8 01             	sub    $0x1,%eax
    72a6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    72a9:	e9 28 01 00 00       	jmp    73d6 <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    72ae:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    72b2:	0f 86 f6 00 00 00    	jbe    73ae <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    72b8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    72bb:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    72c0:	f7 e2                	mul    %edx
    72c2:	89 d0                	mov    %edx,%eax
    72c4:	c1 e8 02             	shr    $0x2,%eax
    72c7:	89 45 ac             	mov    %eax,-0x54(%ebp)
    72ca:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    72cd:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    72d2:	89 c8                	mov    %ecx,%eax
    72d4:	f7 e2                	mul    %edx
    72d6:	c1 ea 02             	shr    $0x2,%edx
    72d9:	89 d0                	mov    %edx,%eax
    72db:	01 c0                	add    %eax,%eax
    72dd:	01 d0                	add    %edx,%eax
    72df:	01 c0                	add    %eax,%eax
    72e1:	29 c1                	sub    %eax,%ecx
    72e3:	89 c8                	mov    %ecx,%eax
    72e5:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    72e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72eb:	8d 50 01             	lea    0x1(%eax),%edx
    72ee:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    72f1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    72fb:	01 c2                	add    %eax,%edx
    72fd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7300:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7307:	8b 45 f0             	mov    -0x10(%ebp),%eax
    730a:	01 c8                	add    %ecx,%eax
    730c:	8b 00                	mov    (%eax),%eax
    730e:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    7310:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    7317:	eb 3a                	jmp    7353 <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    7319:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    731c:	8d 50 01             	lea    0x1(%eax),%edx
    731f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7322:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7329:	8b 45 ec             	mov    -0x14(%ebp),%eax
    732c:	01 d0                	add    %edx,%eax
    732e:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    7334:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7337:	8d 50 01             	lea    0x1(%eax),%edx
    733a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    733d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7344:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7347:	01 d0                	add    %edx,%eax
    7349:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    734f:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    7353:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7356:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    7359:	72 be                	jb     7319 <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    735b:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    735f:	76 3a                	jbe    739b <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    7361:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7364:	8d 50 01             	lea    0x1(%eax),%edx
    7367:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    736a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7371:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7374:	01 d0                	add    %edx,%eax
    7376:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    737c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    737f:	8d 50 01             	lea    0x1(%eax),%edx
    7382:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7385:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    738c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    738f:	01 d0                	add    %edx,%eax
    7391:	8b 55 a8             	mov    -0x58(%ebp),%edx
    7394:	83 ea 03             	sub    $0x3,%edx
    7397:	89 10                	mov    %edx,(%eax)
    7399:	eb 06                	jmp    73a1 <deflateDynamic+0x57d>
        }
        else j -= rest;
    739b:	8b 45 a8             	mov    -0x58(%ebp),%eax
    739e:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    73a1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    73a4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    73a7:	01 d0                	add    %edx,%eax
    73a9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    73ac:	eb 28                	jmp    73d6 <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    73ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73b1:	8d 50 01             	lea    0x1(%eax),%edx
    73b4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    73b7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73be:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73c1:	01 c2                	add    %eax,%edx
    73c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73c6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    73cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    73d0:	01 c8                	add    %ecx,%eax
    73d2:	8b 00                	mov    (%eax),%eax
    73d4:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    73d6:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    73da:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73dd:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    73e0:	0f 85 b9 fd ff ff    	jne    719f <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    73e6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    73ed:	eb 42                	jmp    7431 <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    73ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73f2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73fc:	01 d0                	add    %edx,%eax
    73fe:	8b 00                	mov    (%eax),%eax
    7400:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7407:	8b 45 cc             	mov    -0x34(%ebp),%eax
    740a:	01 d0                	add    %edx,%eax
    740c:	8b 10                	mov    (%eax),%edx
    740e:	83 c2 01             	add    $0x1,%edx
    7411:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    7413:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7416:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    741d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7420:	01 d0                	add    %edx,%eax
    7422:	8b 00                	mov    (%eax),%eax
    7424:	83 f8 0f             	cmp    $0xf,%eax
    7427:	76 04                	jbe    742d <deflateDynamic+0x609>
    7429:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    742d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7431:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7434:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7437:	75 b6                	jne    73ef <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    7439:	83 ec 0c             	sub    $0xc,%esp
    743c:	6a 07                	push   $0x7
    743e:	6a 13                	push   $0x13
    7440:	6a 13                	push   $0x13
    7442:	ff 75 cc             	pushl  -0x34(%ebp)
    7445:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    744b:	50                   	push   %eax
    744c:	e8 fe dd ff ff       	call   524f <HuffmanTree_makeFromFrequencies>
    7451:	83 c4 20             	add    $0x20,%esp
    7454:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    7457:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    745b:	0f 85 8a 02 00 00    	jne    76eb <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    7461:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7468:	eb 04                	jmp    746e <deflateDynamic+0x64a>
      numcodes_cl--;
    746a:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    746e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7471:	83 f8 04             	cmp    $0x4,%eax
    7474:	76 1e                	jbe    7494 <deflateDynamic+0x670>
    7476:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    747c:	8b 55 e0             	mov    -0x20(%ebp),%edx
    747f:	83 ea 01             	sub    $0x1,%edx
    7482:	8b 14 95 20 9f 01 00 	mov    0x19f20(,%edx,4),%edx
    7489:	c1 e2 02             	shl    $0x2,%edx
    748c:	01 d0                	add    %edx,%eax
    748e:	8b 00                	mov    (%eax),%eax
    7490:	85 c0                	test   %eax,%eax
    7492:	74 d6                	je     746a <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    7494:	83 ec 04             	sub    $0x4,%esp
    7497:	6a 01                	push   $0x1
    7499:	ff 75 c4             	pushl  -0x3c(%ebp)
    749c:	ff 75 08             	pushl  0x8(%ebp)
    749f:	e8 67 c3 ff ff       	call   380b <writeBits>
    74a4:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    74a7:	83 ec 04             	sub    $0x4,%esp
    74aa:	6a 01                	push   $0x1
    74ac:	6a 00                	push   $0x0
    74ae:	ff 75 08             	pushl  0x8(%ebp)
    74b1:	e8 55 c3 ff ff       	call   380b <writeBits>
    74b6:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    74b9:	83 ec 04             	sub    $0x4,%esp
    74bc:	6a 01                	push   $0x1
    74be:	6a 01                	push   $0x1
    74c0:	ff 75 08             	pushl  0x8(%ebp)
    74c3:	e8 43 c3 ff ff       	call   380b <writeBits>
    74c8:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    74cb:	8b 45 b8             	mov    -0x48(%ebp),%eax
    74ce:	2d 01 01 00 00       	sub    $0x101,%eax
    74d3:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    74d6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    74d9:	83 e8 01             	sub    $0x1,%eax
    74dc:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    74df:	8b 45 e0             	mov    -0x20(%ebp),%eax
    74e2:	83 e8 04             	sub    $0x4,%eax
    74e5:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    74e8:	83 ec 04             	sub    $0x4,%esp
    74eb:	6a 05                	push   $0x5
    74ed:	ff 75 a4             	pushl  -0x5c(%ebp)
    74f0:	ff 75 08             	pushl  0x8(%ebp)
    74f3:	e8 13 c3 ff ff       	call   380b <writeBits>
    74f8:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    74fb:	83 ec 04             	sub    $0x4,%esp
    74fe:	6a 05                	push   $0x5
    7500:	ff 75 a0             	pushl  -0x60(%ebp)
    7503:	ff 75 08             	pushl  0x8(%ebp)
    7506:	e8 00 c3 ff ff       	call   380b <writeBits>
    750b:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    750e:	83 ec 04             	sub    $0x4,%esp
    7511:	6a 04                	push   $0x4
    7513:	ff 75 9c             	pushl  -0x64(%ebp)
    7516:	ff 75 08             	pushl  0x8(%ebp)
    7519:	e8 ed c2 ff ff       	call   380b <writeBits>
    751e:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    7521:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7528:	eb 2c                	jmp    7556 <deflateDynamic+0x732>
    752a:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    7530:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7533:	8b 04 85 20 9f 01 00 	mov    0x19f20(,%eax,4),%eax
    753a:	c1 e0 02             	shl    $0x2,%eax
    753d:	01 d0                	add    %edx,%eax
    753f:	8b 00                	mov    (%eax),%eax
    7541:	83 ec 04             	sub    $0x4,%esp
    7544:	6a 03                	push   $0x3
    7546:	50                   	push   %eax
    7547:	ff 75 08             	pushl  0x8(%ebp)
    754a:	e8 bc c2 ff ff       	call   380b <writeBits>
    754f:	83 c4 10             	add    $0x10,%esp
    7552:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7556:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7559:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    755c:	75 cc                	jne    752a <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    755e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7565:	e9 0a 01 00 00       	jmp    7674 <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    756a:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7570:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7573:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    757a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    757d:	01 ca                	add    %ecx,%edx
    757f:	8b 12                	mov    (%edx),%edx
    7581:	c1 e2 02             	shl    $0x2,%edx
    7584:	01 d0                	add    %edx,%eax
    7586:	8b 00                	mov    (%eax),%eax
    7588:	89 c3                	mov    %eax,%ebx
    758a:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    7590:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7593:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    759a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    759d:	01 ca                	add    %ecx,%edx
    759f:	8b 12                	mov    (%edx),%edx
    75a1:	c1 e2 02             	shl    $0x2,%edx
    75a4:	01 d0                	add    %edx,%eax
    75a6:	8b 00                	mov    (%eax),%eax
    75a8:	83 ec 04             	sub    $0x4,%esp
    75ab:	53                   	push   %ebx
    75ac:	50                   	push   %eax
    75ad:	ff 75 08             	pushl  0x8(%ebp)
    75b0:	e8 ea c3 ff ff       	call   399f <writeBitsReversed>
    75b5:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    75b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75bb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75c5:	01 d0                	add    %edx,%eax
    75c7:	8b 00                	mov    (%eax),%eax
    75c9:	83 f8 10             	cmp    $0x10,%eax
    75cc:	75 28                	jne    75f6 <deflateDynamic+0x7d2>
    75ce:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    75d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75d5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75df:	01 d0                	add    %edx,%eax
    75e1:	8b 00                	mov    (%eax),%eax
    75e3:	83 ec 04             	sub    $0x4,%esp
    75e6:	6a 02                	push   $0x2
    75e8:	50                   	push   %eax
    75e9:	ff 75 08             	pushl  0x8(%ebp)
    75ec:	e8 1a c2 ff ff       	call   380b <writeBits>
    75f1:	83 c4 10             	add    $0x10,%esp
    75f4:	eb 7a                	jmp    7670 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    75f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75f9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7600:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7603:	01 d0                	add    %edx,%eax
    7605:	8b 00                	mov    (%eax),%eax
    7607:	83 f8 11             	cmp    $0x11,%eax
    760a:	75 28                	jne    7634 <deflateDynamic+0x810>
    760c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7610:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7613:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    761a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    761d:	01 d0                	add    %edx,%eax
    761f:	8b 00                	mov    (%eax),%eax
    7621:	83 ec 04             	sub    $0x4,%esp
    7624:	6a 03                	push   $0x3
    7626:	50                   	push   %eax
    7627:	ff 75 08             	pushl  0x8(%ebp)
    762a:	e8 dc c1 ff ff       	call   380b <writeBits>
    762f:	83 c4 10             	add    $0x10,%esp
    7632:	eb 3c                	jmp    7670 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    7634:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7637:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    763e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7641:	01 d0                	add    %edx,%eax
    7643:	8b 00                	mov    (%eax),%eax
    7645:	83 f8 12             	cmp    $0x12,%eax
    7648:	75 26                	jne    7670 <deflateDynamic+0x84c>
    764a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    764e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7651:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7658:	8b 45 ec             	mov    -0x14(%ebp),%eax
    765b:	01 d0                	add    %edx,%eax
    765d:	8b 00                	mov    (%eax),%eax
    765f:	83 ec 04             	sub    $0x4,%esp
    7662:	6a 07                	push   $0x7
    7664:	50                   	push   %eax
    7665:	ff 75 08             	pushl  0x8(%ebp)
    7668:	e8 9e c1 ff ff       	call   380b <writeBits>
    766d:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7670:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7674:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7677:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    767a:	0f 85 ea fe ff ff    	jne    756a <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7680:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7686:	50                   	push   %eax
    7687:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    768d:	50                   	push   %eax
    768e:	8d 45 90             	lea    -0x70(%ebp),%eax
    7691:	50                   	push   %eax
    7692:	ff 75 08             	pushl  0x8(%ebp)
    7695:	e8 4f f6 ff ff       	call   6ce9 <writeLZ77data>
    769a:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    769d:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    76a3:	05 00 04 00 00       	add    $0x400,%eax
    76a8:	8b 00                	mov    (%eax),%eax
    76aa:	85 c0                	test   %eax,%eax
    76ac:	75 09                	jne    76b7 <deflateDynamic+0x893>
    76ae:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    76b5:	eb 35                	jmp    76ec <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    76b7:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    76bd:	05 00 04 00 00       	add    $0x400,%eax
    76c2:	8b 00                	mov    (%eax),%eax
    76c4:	89 c2                	mov    %eax,%edx
    76c6:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    76cc:	05 00 04 00 00       	add    $0x400,%eax
    76d1:	8b 00                	mov    (%eax),%eax
    76d3:	83 ec 04             	sub    $0x4,%esp
    76d6:	52                   	push   %edx
    76d7:	50                   	push   %eax
    76d8:	ff 75 08             	pushl  0x8(%ebp)
    76db:	e8 bf c2 ff ff       	call   399f <writeBitsReversed>
    76e0:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    76e3:	eb 07                	jmp    76ec <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    76e5:	90                   	nop
    76e6:	eb 04                	jmp    76ec <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    76e8:	90                   	nop
    76e9:	eb 01                	jmp    76ec <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    76eb:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    76ec:	83 ec 0c             	sub    $0xc,%esp
    76ef:	8d 45 90             	lea    -0x70(%ebp),%eax
    76f2:	50                   	push   %eax
    76f3:	e8 73 bd ff ff       	call   346b <uivector_cleanup>
    76f8:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    76fb:	83 ec 0c             	sub    $0xc,%esp
    76fe:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7704:	50                   	push   %eax
    7705:	e8 3a cb ff ff       	call   4244 <HuffmanTree_cleanup>
    770a:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    770d:	83 ec 0c             	sub    $0xc,%esp
    7710:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7716:	50                   	push   %eax
    7717:	e8 28 cb ff ff       	call   4244 <HuffmanTree_cleanup>
    771c:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    771f:	83 ec 0c             	sub    $0xc,%esp
    7722:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7728:	50                   	push   %eax
    7729:	e8 16 cb ff ff       	call   4244 <HuffmanTree_cleanup>
    772e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    7731:	83 ec 0c             	sub    $0xc,%esp
    7734:	ff 75 d4             	pushl  -0x2c(%ebp)
    7737:	e8 08 bc ff ff       	call   3344 <lodepng_free>
    773c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    773f:	83 ec 0c             	sub    $0xc,%esp
    7742:	ff 75 d0             	pushl  -0x30(%ebp)
    7745:	e8 fa bb ff ff       	call   3344 <lodepng_free>
    774a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    774d:	83 ec 0c             	sub    $0xc,%esp
    7750:	ff 75 cc             	pushl  -0x34(%ebp)
    7753:	e8 ec bb ff ff       	call   3344 <lodepng_free>
    7758:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    775b:	83 ec 0c             	sub    $0xc,%esp
    775e:	ff 75 f0             	pushl  -0x10(%ebp)
    7761:	e8 de bb ff ff       	call   3344 <lodepng_free>
    7766:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    7769:	83 ec 0c             	sub    $0xc,%esp
    776c:	ff 75 ec             	pushl  -0x14(%ebp)
    776f:	e8 d0 bb ff ff       	call   3344 <lodepng_free>
    7774:	83 c4 10             	add    $0x10,%esp

  return error;
    7777:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    777a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    777d:	c9                   	leave  
    777e:	c3                   	ret    

0000777f <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    777f:	55                   	push   %ebp
    7780:	89 e5                	mov    %esp,%ebp
    7782:	53                   	push   %ebx
    7783:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    7786:	8b 45 20             	mov    0x20(%ebp),%eax
    7789:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    778c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    7793:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7796:	50                   	push   %eax
    7797:	e8 7b ca ff ff       	call   4217 <HuffmanTree_init>
    779c:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    779f:	8d 45 bc             	lea    -0x44(%ebp),%eax
    77a2:	50                   	push   %eax
    77a3:	e8 6f ca ff ff       	call   4217 <HuffmanTree_init>
    77a8:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    77ab:	83 ec 0c             	sub    $0xc,%esp
    77ae:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    77b1:	50                   	push   %eax
    77b2:	e8 41 db ff ff       	call   52f8 <generateFixedLitLenTree>
    77b7:	83 c4 10             	add    $0x10,%esp
    77ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    77bd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    77c1:	75 12                	jne    77d5 <deflateFixed+0x56>
    77c3:	83 ec 0c             	sub    $0xc,%esp
    77c6:	8d 45 bc             	lea    -0x44(%ebp),%eax
    77c9:	50                   	push   %eax
    77ca:	e8 30 dc ff ff       	call   53ff <generateFixedDistanceTree>
    77cf:	83 c4 10             	add    $0x10,%esp
    77d2:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    77d5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    77d9:	0f 85 3a 01 00 00    	jne    7919 <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    77df:	83 ec 04             	sub    $0x4,%esp
    77e2:	6a 01                	push   $0x1
    77e4:	ff 75 ec             	pushl  -0x14(%ebp)
    77e7:	ff 75 08             	pushl  0x8(%ebp)
    77ea:	e8 1c c0 ff ff       	call   380b <writeBits>
    77ef:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    77f2:	83 ec 04             	sub    $0x4,%esp
    77f5:	6a 01                	push   $0x1
    77f7:	6a 01                	push   $0x1
    77f9:	ff 75 08             	pushl  0x8(%ebp)
    77fc:	e8 0a c0 ff ff       	call   380b <writeBits>
    7801:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    7804:	83 ec 04             	sub    $0x4,%esp
    7807:	6a 01                	push   $0x1
    7809:	6a 00                	push   $0x0
    780b:	ff 75 08             	pushl  0x8(%ebp)
    780e:	e8 f8 bf ff ff       	call   380b <writeBits>
    7813:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    7816:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7819:	8b 40 04             	mov    0x4(%eax),%eax
    781c:	85 c0                	test   %eax,%eax
    781e:	74 77                	je     7897 <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    7820:	83 ec 0c             	sub    $0xc,%esp
    7823:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7826:	50                   	push   %eax
    7827:	e8 e8 bc ff ff       	call   3514 <uivector_init>
    782c:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    782f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7832:	8b 58 14             	mov    0x14(%eax),%ebx
    7835:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7838:	8b 48 10             	mov    0x10(%eax),%ecx
    783b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    783e:	8b 50 0c             	mov    0xc(%eax),%edx
    7841:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7844:	8b 40 08             	mov    0x8(%eax),%eax
    7847:	83 ec 0c             	sub    $0xc,%esp
    784a:	53                   	push   %ebx
    784b:	51                   	push   %ecx
    784c:	52                   	push   %edx
    784d:	50                   	push   %eax
    784e:	ff 75 18             	pushl  0x18(%ebp)
    7851:	ff 75 14             	pushl  0x14(%ebp)
    7854:	ff 75 10             	pushl  0x10(%ebp)
    7857:	ff 75 0c             	pushl  0xc(%ebp)
    785a:	8d 45 b0             	lea    -0x50(%ebp),%eax
    785d:	50                   	push   %eax
    785e:	e8 c7 ed ff ff       	call   662a <encodeLZ77>
    7863:	83 c4 30             	add    $0x30,%esp
    7866:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7869:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    786d:	75 17                	jne    7886 <deflateFixed+0x107>
    786f:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7872:	50                   	push   %eax
    7873:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7876:	50                   	push   %eax
    7877:	8d 45 b0             	lea    -0x50(%ebp),%eax
    787a:	50                   	push   %eax
    787b:	ff 75 08             	pushl  0x8(%ebp)
    787e:	e8 66 f4 ff ff       	call   6ce9 <writeLZ77data>
    7883:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    7886:	83 ec 0c             	sub    $0xc,%esp
    7889:	8d 45 b0             	lea    -0x50(%ebp),%eax
    788c:	50                   	push   %eax
    788d:	e8 d9 bb ff ff       	call   346b <uivector_cleanup>
    7892:	83 c4 10             	add    $0x10,%esp
    7895:	eb 56                	jmp    78ed <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7897:	8b 45 14             	mov    0x14(%ebp),%eax
    789a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    789d:	eb 46                	jmp    78e5 <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    789f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    78a2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    78a5:	8b 55 10             	mov    0x10(%ebp),%edx
    78a8:	01 ca                	add    %ecx,%edx
    78aa:	0f b6 12             	movzbl (%edx),%edx
    78ad:	0f b6 d2             	movzbl %dl,%edx
    78b0:	c1 e2 02             	shl    $0x2,%edx
    78b3:	01 d0                	add    %edx,%eax
    78b5:	8b 00                	mov    (%eax),%eax
    78b7:	89 c3                	mov    %eax,%ebx
    78b9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    78bc:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    78bf:	8b 55 10             	mov    0x10(%ebp),%edx
    78c2:	01 ca                	add    %ecx,%edx
    78c4:	0f b6 12             	movzbl (%edx),%edx
    78c7:	0f b6 d2             	movzbl %dl,%edx
    78ca:	c1 e2 02             	shl    $0x2,%edx
    78cd:	01 d0                	add    %edx,%eax
    78cf:	8b 00                	mov    (%eax),%eax
    78d1:	83 ec 04             	sub    $0x4,%esp
    78d4:	53                   	push   %ebx
    78d5:	50                   	push   %eax
    78d6:	ff 75 08             	pushl  0x8(%ebp)
    78d9:	e8 c1 c0 ff ff       	call   399f <writeBitsReversed>
    78de:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    78e1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    78e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    78e8:	3b 45 18             	cmp    0x18(%ebp),%eax
    78eb:	7c b2                	jl     789f <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    78ed:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    78f1:	75 26                	jne    7919 <deflateFixed+0x19a>
    78f3:	8b 45 d8             	mov    -0x28(%ebp),%eax
    78f6:	05 00 04 00 00       	add    $0x400,%eax
    78fb:	8b 00                	mov    (%eax),%eax
    78fd:	89 c2                	mov    %eax,%edx
    78ff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7902:	05 00 04 00 00       	add    $0x400,%eax
    7907:	8b 00                	mov    (%eax),%eax
    7909:	83 ec 04             	sub    $0x4,%esp
    790c:	52                   	push   %edx
    790d:	50                   	push   %eax
    790e:	ff 75 08             	pushl  0x8(%ebp)
    7911:	e8 89 c0 ff ff       	call   399f <writeBitsReversed>
    7916:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    7919:	83 ec 0c             	sub    $0xc,%esp
    791c:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    791f:	50                   	push   %eax
    7920:	e8 1f c9 ff ff       	call   4244 <HuffmanTree_cleanup>
    7925:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    7928:	83 ec 0c             	sub    $0xc,%esp
    792b:	8d 45 bc             	lea    -0x44(%ebp),%eax
    792e:	50                   	push   %eax
    792f:	e8 10 c9 ff ff       	call   4244 <HuffmanTree_cleanup>
    7934:	83 c4 10             	add    $0x10,%esp

  return error;
    7937:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    793a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    793d:	c9                   	leave  
    793e:	c3                   	ret    

0000793f <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    793f:	55                   	push   %ebp
    7940:	89 e5                	mov    %esp,%ebp
    7942:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    7945:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    794c:	ff 75 08             	pushl  0x8(%ebp)
    794f:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7952:	50                   	push   %eax
    7953:	e8 9e be ff ff       	call   37f6 <LodePNGBitWriter_init>
    7958:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    795b:	8b 45 14             	mov    0x14(%ebp),%eax
    795e:	8b 00                	mov    (%eax),%eax
    7960:	83 f8 02             	cmp    $0x2,%eax
    7963:	76 0a                	jbe    796f <lodepng_deflatev+0x30>
    7965:	b8 3d 00 00 00       	mov    $0x3d,%eax
    796a:	e9 68 01 00 00       	jmp    7ad7 <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    796f:	8b 45 14             	mov    0x14(%ebp),%eax
    7972:	8b 00                	mov    (%eax),%eax
    7974:	85 c0                	test   %eax,%eax
    7976:	75 16                	jne    798e <lodepng_deflatev+0x4f>
    7978:	ff 75 10             	pushl  0x10(%ebp)
    797b:	ff 75 0c             	pushl  0xc(%ebp)
    797e:	ff 75 08             	pushl  0x8(%ebp)
    7981:	e8 01 f2 ff ff       	call   6b87 <deflateNoCompression>
    7986:	83 c4 0c             	add    $0xc,%esp
    7989:	e9 49 01 00 00       	jmp    7ad7 <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    798e:	8b 45 14             	mov    0x14(%ebp),%eax
    7991:	8b 00                	mov    (%eax),%eax
    7993:	83 f8 01             	cmp    $0x1,%eax
    7996:	75 08                	jne    79a0 <lodepng_deflatev+0x61>
    7998:	8b 45 10             	mov    0x10(%ebp),%eax
    799b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    799e:	eb 2c                	jmp    79cc <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    79a0:	8b 45 10             	mov    0x10(%ebp),%eax
    79a3:	c1 e8 03             	shr    $0x3,%eax
    79a6:	83 c0 08             	add    $0x8,%eax
    79a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    79ac:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    79b3:	7f 07                	jg     79bc <lodepng_deflatev+0x7d>
    79b5:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    79bc:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    79c3:	7e 07                	jle    79cc <lodepng_deflatev+0x8d>
    79c5:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    79cc:	8b 55 10             	mov    0x10(%ebp),%edx
    79cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    79d2:	01 d0                	add    %edx,%eax
    79d4:	83 e8 01             	sub    $0x1,%eax
    79d7:	99                   	cltd   
    79d8:	f7 7d ec             	idivl  -0x14(%ebp)
    79db:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    79de:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    79e2:	75 07                	jne    79eb <lodepng_deflatev+0xac>
    79e4:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    79eb:	8b 45 14             	mov    0x14(%ebp),%eax
    79ee:	8b 40 08             	mov    0x8(%eax),%eax
    79f1:	83 ec 08             	sub    $0x8,%esp
    79f4:	50                   	push   %eax
    79f5:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    79f8:	50                   	push   %eax
    79f9:	e8 1c e8 ff ff       	call   621a <hash_init>
    79fe:	83 c4 10             	add    $0x10,%esp
    7a01:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7a04:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7a08:	0f 85 b7 00 00 00    	jne    7ac5 <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7a0e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7a15:	e9 99 00 00 00       	jmp    7ab3 <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    7a1a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7a1d:	83 e8 01             	sub    $0x1,%eax
    7a20:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7a23:	0f 94 c0             	sete   %al
    7a26:	0f b6 c0             	movzbl %al,%eax
    7a29:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    7a2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7a2f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    7a33:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    7a36:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7a39:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7a3c:	01 d0                	add    %edx,%eax
    7a3e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    7a41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7a44:	3b 45 10             	cmp    0x10(%ebp),%eax
    7a47:	7e 06                	jle    7a4f <lodepng_deflatev+0x110>
    7a49:	8b 45 10             	mov    0x10(%ebp),%eax
    7a4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    7a4f:	8b 45 14             	mov    0x14(%ebp),%eax
    7a52:	8b 00                	mov    (%eax),%eax
    7a54:	83 f8 01             	cmp    $0x1,%eax
    7a57:	75 27                	jne    7a80 <lodepng_deflatev+0x141>
    7a59:	83 ec 04             	sub    $0x4,%esp
    7a5c:	ff 75 e0             	pushl  -0x20(%ebp)
    7a5f:	ff 75 14             	pushl  0x14(%ebp)
    7a62:	ff 75 e4             	pushl  -0x1c(%ebp)
    7a65:	ff 75 dc             	pushl  -0x24(%ebp)
    7a68:	ff 75 0c             	pushl  0xc(%ebp)
    7a6b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7a6e:	50                   	push   %eax
    7a6f:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a72:	50                   	push   %eax
    7a73:	e8 07 fd ff ff       	call   777f <deflateFixed>
    7a78:	83 c4 20             	add    $0x20,%esp
    7a7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7a7e:	eb 2f                	jmp    7aaf <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    7a80:	8b 45 14             	mov    0x14(%ebp),%eax
    7a83:	8b 00                	mov    (%eax),%eax
    7a85:	83 f8 02             	cmp    $0x2,%eax
    7a88:	75 25                	jne    7aaf <lodepng_deflatev+0x170>
    7a8a:	83 ec 04             	sub    $0x4,%esp
    7a8d:	ff 75 e0             	pushl  -0x20(%ebp)
    7a90:	ff 75 14             	pushl  0x14(%ebp)
    7a93:	ff 75 e4             	pushl  -0x1c(%ebp)
    7a96:	ff 75 dc             	pushl  -0x24(%ebp)
    7a99:	ff 75 0c             	pushl  0xc(%ebp)
    7a9c:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7a9f:	50                   	push   %eax
    7aa0:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7aa3:	50                   	push   %eax
    7aa4:	e8 7b f3 ff ff       	call   6e24 <deflateDynamic>
    7aa9:	83 c4 20             	add    $0x20,%esp
    7aac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7aaf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7ab3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7ab6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7ab9:	74 0a                	je     7ac5 <lodepng_deflatev+0x186>
    7abb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7abf:	0f 84 55 ff ff ff    	je     7a1a <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    7ac5:	83 ec 0c             	sub    $0xc,%esp
    7ac8:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7acb:	50                   	push   %eax
    7acc:	e8 08 e9 ff ff       	call   63d9 <hash_cleanup>
    7ad1:	83 c4 10             	add    $0x10,%esp

  return error;
    7ad4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7ad7:	c9                   	leave  
    7ad8:	c3                   	ret    

00007ad9 <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    7ad9:	55                   	push   %ebp
    7ada:	89 e5                	mov    %esp,%ebp
    7adc:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7adf:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ae2:	8b 08                	mov    (%eax),%ecx
    7ae4:	8b 45 08             	mov    0x8(%ebp),%eax
    7ae7:	8b 10                	mov    (%eax),%edx
    7ae9:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7aec:	51                   	push   %ecx
    7aed:	52                   	push   %edx
    7aee:	50                   	push   %eax
    7aef:	e8 f0 ba ff ff       	call   35e4 <ucvector_init>
    7af4:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    7af7:	ff 75 18             	pushl  0x18(%ebp)
    7afa:	ff 75 14             	pushl  0x14(%ebp)
    7afd:	ff 75 10             	pushl  0x10(%ebp)
    7b00:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7b03:	50                   	push   %eax
    7b04:	e8 36 fe ff ff       	call   793f <lodepng_deflatev>
    7b09:	83 c4 10             	add    $0x10,%esp
    7b0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7b0f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7b12:	8b 45 08             	mov    0x8(%ebp),%eax
    7b15:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7b17:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7b1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    7b1d:	89 10                	mov    %edx,(%eax)
  return error;
    7b1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7b22:	c9                   	leave  
    7b23:	c3                   	ret    

00007b24 <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    7b24:	55                   	push   %ebp
    7b25:	89 e5                	mov    %esp,%ebp
    7b27:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    7b2a:	8b 45 18             	mov    0x18(%ebp),%eax
    7b2d:	8b 40 1c             	mov    0x1c(%eax),%eax
    7b30:	85 c0                	test   %eax,%eax
    7b32:	74 34                	je     7b68 <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    7b34:	8b 45 18             	mov    0x18(%ebp),%eax
    7b37:	8b 40 1c             	mov    0x1c(%eax),%eax
    7b3a:	83 ec 0c             	sub    $0xc,%esp
    7b3d:	ff 75 18             	pushl  0x18(%ebp)
    7b40:	ff 75 14             	pushl  0x14(%ebp)
    7b43:	ff 75 10             	pushl  0x10(%ebp)
    7b46:	ff 75 0c             	pushl  0xc(%ebp)
    7b49:	ff 75 08             	pushl  0x8(%ebp)
    7b4c:	ff d0                	call   *%eax
    7b4e:	83 c4 20             	add    $0x20,%esp
    7b51:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    7b54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7b58:	74 07                	je     7b61 <deflate+0x3d>
    7b5a:	b8 6f 00 00 00       	mov    $0x6f,%eax
    7b5f:	eb 21                	jmp    7b82 <deflate+0x5e>
    7b61:	b8 00 00 00 00       	mov    $0x0,%eax
    7b66:	eb 1a                	jmp    7b82 <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    7b68:	83 ec 0c             	sub    $0xc,%esp
    7b6b:	ff 75 18             	pushl  0x18(%ebp)
    7b6e:	ff 75 14             	pushl  0x14(%ebp)
    7b71:	ff 75 10             	pushl  0x10(%ebp)
    7b74:	ff 75 0c             	pushl  0xc(%ebp)
    7b77:	ff 75 08             	pushl  0x8(%ebp)
    7b7a:	e8 5a ff ff ff       	call   7ad9 <lodepng_deflate>
    7b7f:	83 c4 20             	add    $0x20,%esp
  }
}
    7b82:	c9                   	leave  
    7b83:	c3                   	ret    

00007b84 <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    7b84:	55                   	push   %ebp
    7b85:	89 e5                	mov    %esp,%ebp
    7b87:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    7b8a:	8b 45 08             	mov    0x8(%ebp),%eax
    7b8d:	0f b7 c0             	movzwl %ax,%eax
    7b90:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    7b93:	8b 45 08             	mov    0x8(%ebp),%eax
    7b96:	c1 e8 10             	shr    $0x10,%eax
    7b99:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    7b9c:	e9 82 00 00 00       	jmp    7c23 <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    7ba1:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    7ba6:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    7bad:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    7bb1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    7bb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7bb7:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    7bba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7bc1:	eb 1c                	jmp    7bdf <update_adler32+0x5b>
      s1 += (*data++);
    7bc3:	8b 45 0c             	mov    0xc(%ebp),%eax
    7bc6:	8d 50 01             	lea    0x1(%eax),%edx
    7bc9:	89 55 0c             	mov    %edx,0xc(%ebp)
    7bcc:	0f b6 00             	movzbl (%eax),%eax
    7bcf:	0f b6 c0             	movzbl %al,%eax
    7bd2:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    7bd5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7bd8:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    7bdb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7bdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7be2:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7be5:	75 dc                	jne    7bc3 <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    7be7:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7bea:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7bef:	89 c8                	mov    %ecx,%eax
    7bf1:	f7 e2                	mul    %edx
    7bf3:	89 d0                	mov    %edx,%eax
    7bf5:	c1 e8 0f             	shr    $0xf,%eax
    7bf8:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7bfe:	29 c1                	sub    %eax,%ecx
    7c00:	89 c8                	mov    %ecx,%eax
    7c02:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    7c05:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7c08:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7c0d:	89 c8                	mov    %ecx,%eax
    7c0f:	f7 e2                	mul    %edx
    7c11:	89 d0                	mov    %edx,%eax
    7c13:	c1 e8 0f             	shr    $0xf,%eax
    7c16:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7c1c:	29 c1                	sub    %eax,%ecx
    7c1e:	89 c8                	mov    %ecx,%eax
    7c20:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    7c23:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7c27:	0f 85 74 ff ff ff    	jne    7ba1 <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    7c2d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7c30:	c1 e0 10             	shl    $0x10,%eax
    7c33:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    7c36:	c9                   	leave  
    7c37:	c3                   	ret    

00007c38 <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    7c38:	55                   	push   %ebp
    7c39:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    7c3b:	ff 75 0c             	pushl  0xc(%ebp)
    7c3e:	ff 75 08             	pushl  0x8(%ebp)
    7c41:	6a 01                	push   $0x1
    7c43:	e8 3c ff ff ff       	call   7b84 <update_adler32>
    7c48:	83 c4 0c             	add    $0xc,%esp
}
    7c4b:	c9                   	leave  
    7c4c:	c3                   	ret    

00007c4d <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    7c4d:	55                   	push   %ebp
    7c4e:	89 e5                	mov    %esp,%ebp
    7c50:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    7c53:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    7c5a:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    7c5e:	7f 0a                	jg     7c6a <lodepng_zlib_decompressv+0x1d>
    7c60:	b8 35 00 00 00       	mov    $0x35,%eax
    7c65:	e9 27 01 00 00       	jmp    7d91 <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    7c6a:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c6d:	0f b6 00             	movzbl (%eax),%eax
    7c70:	0f b6 c0             	movzbl %al,%eax
    7c73:	c1 e0 08             	shl    $0x8,%eax
    7c76:	89 c2                	mov    %eax,%edx
    7c78:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c7b:	83 c0 01             	add    $0x1,%eax
    7c7e:	0f b6 00             	movzbl (%eax),%eax
    7c81:	0f b6 c0             	movzbl %al,%eax
    7c84:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    7c87:	ba 43 08 21 84       	mov    $0x84210843,%edx
    7c8c:	89 c8                	mov    %ecx,%eax
    7c8e:	f7 ea                	imul   %edx
    7c90:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    7c93:	c1 f8 04             	sar    $0x4,%eax
    7c96:	89 c2                	mov    %eax,%edx
    7c98:	89 c8                	mov    %ecx,%eax
    7c9a:	c1 f8 1f             	sar    $0x1f,%eax
    7c9d:	29 c2                	sub    %eax,%edx
    7c9f:	89 d0                	mov    %edx,%eax
    7ca1:	89 c2                	mov    %eax,%edx
    7ca3:	c1 e2 05             	shl    $0x5,%edx
    7ca6:	29 c2                	sub    %eax,%edx
    7ca8:	89 c8                	mov    %ecx,%eax
    7caa:	29 d0                	sub    %edx,%eax
    7cac:	85 c0                	test   %eax,%eax
    7cae:	74 0a                	je     7cba <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    7cb0:	b8 18 00 00 00       	mov    $0x18,%eax
    7cb5:	e9 d7 00 00 00       	jmp    7d91 <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    7cba:	8b 45 0c             	mov    0xc(%ebp),%eax
    7cbd:	0f b6 00             	movzbl (%eax),%eax
    7cc0:	0f b6 c0             	movzbl %al,%eax
    7cc3:	83 e0 0f             	and    $0xf,%eax
    7cc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    7cc9:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ccc:	0f b6 00             	movzbl (%eax),%eax
    7ccf:	c0 e8 04             	shr    $0x4,%al
    7cd2:	0f b6 c0             	movzbl %al,%eax
    7cd5:	83 e0 0f             	and    $0xf,%eax
    7cd8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    7cdb:	8b 45 0c             	mov    0xc(%ebp),%eax
    7cde:	83 c0 01             	add    $0x1,%eax
    7ce1:	0f b6 00             	movzbl (%eax),%eax
    7ce4:	c0 e8 05             	shr    $0x5,%al
    7ce7:	0f b6 c0             	movzbl %al,%eax
    7cea:	83 e0 01             	and    $0x1,%eax
    7ced:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    7cf0:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    7cf4:	75 06                	jne    7cfc <lodepng_zlib_decompressv+0xaf>
    7cf6:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    7cfa:	76 0a                	jbe    7d06 <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    7cfc:	b8 19 00 00 00       	mov    $0x19,%eax
    7d01:	e9 8b 00 00 00       	jmp    7d91 <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    7d06:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7d0a:	74 07                	je     7d13 <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    7d0c:	b8 1a 00 00 00       	mov    $0x1a,%eax
    7d11:	eb 7e                	jmp    7d91 <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    7d13:	8b 45 10             	mov    0x10(%ebp),%eax
    7d16:	8d 50 fe             	lea    -0x2(%eax),%edx
    7d19:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d1c:	83 c0 02             	add    $0x2,%eax
    7d1f:	ff 75 14             	pushl  0x14(%ebp)
    7d22:	52                   	push   %edx
    7d23:	50                   	push   %eax
    7d24:	ff 75 08             	pushl  0x8(%ebp)
    7d27:	e8 09 e3 ff ff       	call   6035 <inflatev>
    7d2c:	83 c4 10             	add    $0x10,%esp
    7d2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    7d32:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7d36:	74 05                	je     7d3d <lodepng_zlib_decompressv+0xf0>
    7d38:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7d3b:	eb 54                	jmp    7d91 <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    7d3d:	8b 45 14             	mov    0x14(%ebp),%eax
    7d40:	8b 00                	mov    (%eax),%eax
    7d42:	85 c0                	test   %eax,%eax
    7d44:	75 46                	jne    7d8c <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    7d46:	8b 45 10             	mov    0x10(%ebp),%eax
    7d49:	8d 50 fc             	lea    -0x4(%eax),%edx
    7d4c:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d4f:	01 d0                	add    %edx,%eax
    7d51:	83 ec 0c             	sub    $0xc,%esp
    7d54:	50                   	push   %eax
    7d55:	e8 47 b9 ff ff       	call   36a1 <lodepng_read32bitInt>
    7d5a:	83 c4 10             	add    $0x10,%esp
    7d5d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    7d60:	8b 45 08             	mov    0x8(%ebp),%eax
    7d63:	8b 40 04             	mov    0x4(%eax),%eax
    7d66:	89 c2                	mov    %eax,%edx
    7d68:	8b 45 08             	mov    0x8(%ebp),%eax
    7d6b:	8b 00                	mov    (%eax),%eax
    7d6d:	83 ec 08             	sub    $0x8,%esp
    7d70:	52                   	push   %edx
    7d71:	50                   	push   %eax
    7d72:	e8 c1 fe ff ff       	call   7c38 <adler32>
    7d77:	83 c4 10             	add    $0x10,%esp
    7d7a:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    7d7d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7d80:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7d83:	74 07                	je     7d8c <lodepng_zlib_decompressv+0x13f>
    7d85:	b8 3a 00 00 00       	mov    $0x3a,%eax
    7d8a:	eb 05                	jmp    7d91 <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    7d8c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7d91:	c9                   	leave  
    7d92:	c3                   	ret    

00007d93 <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    7d93:	55                   	push   %ebp
    7d94:	89 e5                	mov    %esp,%ebp
    7d96:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7d99:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d9c:	8b 08                	mov    (%eax),%ecx
    7d9e:	8b 45 08             	mov    0x8(%ebp),%eax
    7da1:	8b 10                	mov    (%eax),%edx
    7da3:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7da6:	51                   	push   %ecx
    7da7:	52                   	push   %edx
    7da8:	50                   	push   %eax
    7da9:	e8 36 b8 ff ff       	call   35e4 <ucvector_init>
    7dae:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7db1:	ff 75 18             	pushl  0x18(%ebp)
    7db4:	ff 75 14             	pushl  0x14(%ebp)
    7db7:	ff 75 10             	pushl  0x10(%ebp)
    7dba:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7dbd:	50                   	push   %eax
    7dbe:	e8 8a fe ff ff       	call   7c4d <lodepng_zlib_decompressv>
    7dc3:	83 c4 10             	add    $0x10,%esp
    7dc6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7dc9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7dcc:	8b 45 08             	mov    0x8(%ebp),%eax
    7dcf:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7dd1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7dd4:	8b 45 0c             	mov    0xc(%ebp),%eax
    7dd7:	89 10                	mov    %edx,(%eax)
  return error;
    7dd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7ddc:	c9                   	leave  
    7ddd:	c3                   	ret    

00007dde <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    7dde:	55                   	push   %ebp
    7ddf:	89 e5                	mov    %esp,%ebp
    7de1:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    7de4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7de7:	8b 40 0c             	mov    0xc(%eax),%eax
    7dea:	85 c0                	test   %eax,%eax
    7dec:	74 57                	je     7e45 <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    7dee:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7df1:	8b 40 0c             	mov    0xc(%eax),%eax
    7df4:	83 ec 0c             	sub    $0xc,%esp
    7df7:	ff 75 1c             	pushl  0x1c(%ebp)
    7dfa:	ff 75 18             	pushl  0x18(%ebp)
    7dfd:	ff 75 14             	pushl  0x14(%ebp)
    7e00:	ff 75 0c             	pushl  0xc(%ebp)
    7e03:	ff 75 08             	pushl  0x8(%ebp)
    7e06:	ff d0                	call   *%eax
    7e08:	83 c4 20             	add    $0x20,%esp
    7e0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    7e0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7e12:	0f 84 98 00 00 00    	je     7eb0 <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    7e18:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    7e1f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7e22:	8b 40 08             	mov    0x8(%eax),%eax
    7e25:	85 c0                	test   %eax,%eax
    7e27:	0f 84 83 00 00 00    	je     7eb0 <zlib_decompress+0xd2>
    7e2d:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e30:	8b 10                	mov    (%eax),%edx
    7e32:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7e35:	8b 40 08             	mov    0x8(%eax),%eax
    7e38:	39 c2                	cmp    %eax,%edx
    7e3a:	7e 74                	jle    7eb0 <zlib_decompress+0xd2>
    7e3c:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    7e43:	eb 6b                	jmp    7eb0 <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    7e45:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e48:	8b 08                	mov    (%eax),%ecx
    7e4a:	8b 45 08             	mov    0x8(%ebp),%eax
    7e4d:	8b 10                	mov    (%eax),%edx
    7e4f:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e52:	83 ec 04             	sub    $0x4,%esp
    7e55:	51                   	push   %ecx
    7e56:	52                   	push   %edx
    7e57:	50                   	push   %eax
    7e58:	e8 87 b7 ff ff       	call   35e4 <ucvector_init>
    7e5d:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    7e60:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7e64:	74 22                	je     7e88 <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    7e66:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e69:	8b 10                	mov    (%eax),%edx
    7e6b:	8b 45 10             	mov    0x10(%ebp),%eax
    7e6e:	01 d0                	add    %edx,%eax
    7e70:	83 ec 08             	sub    $0x8,%esp
    7e73:	50                   	push   %eax
    7e74:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e77:	50                   	push   %eax
    7e78:	e8 00 b7 ff ff       	call   357d <ucvector_resize>
    7e7d:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    7e80:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e83:	8b 00                	mov    (%eax),%eax
    7e85:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7e88:	ff 75 1c             	pushl  0x1c(%ebp)
    7e8b:	ff 75 18             	pushl  0x18(%ebp)
    7e8e:	ff 75 14             	pushl  0x14(%ebp)
    7e91:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e94:	50                   	push   %eax
    7e95:	e8 b3 fd ff ff       	call   7c4d <lodepng_zlib_decompressv>
    7e9a:	83 c4 10             	add    $0x10,%esp
    7e9d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    7ea0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7ea3:	8b 45 08             	mov    0x8(%ebp),%eax
    7ea6:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    7ea8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7eab:	8b 45 0c             	mov    0xc(%ebp),%eax
    7eae:	89 10                	mov    %edx,(%eax)
  }
  return error;
    7eb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7eb3:	c9                   	leave  
    7eb4:	c3                   	ret    

00007eb5 <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    7eb5:	55                   	push   %ebp
    7eb6:	89 e5                	mov    %esp,%ebp
    7eb8:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    7ebb:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    7ec2:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    7ec9:	83 ec 0c             	sub    $0xc,%esp
    7ecc:	ff 75 18             	pushl  0x18(%ebp)
    7ecf:	ff 75 14             	pushl  0x14(%ebp)
    7ed2:	ff 75 10             	pushl  0x10(%ebp)
    7ed5:	8d 45 d0             	lea    -0x30(%ebp),%eax
    7ed8:	50                   	push   %eax
    7ed9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7edc:	50                   	push   %eax
    7edd:	e8 42 fc ff ff       	call   7b24 <deflate>
    7ee2:	83 c4 20             	add    $0x20,%esp
    7ee5:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    7ee8:	8b 45 08             	mov    0x8(%ebp),%eax
    7eeb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    7ef1:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ef4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    7efa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7efe:	75 33                	jne    7f33 <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    7f00:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7f03:	8d 50 06             	lea    0x6(%eax),%edx
    7f06:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f09:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    7f0b:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f0e:	8b 00                	mov    (%eax),%eax
    7f10:	83 ec 0c             	sub    $0xc,%esp
    7f13:	50                   	push   %eax
    7f14:	e8 0a b4 ff ff       	call   3323 <lodepng_malloc>
    7f19:	83 c4 10             	add    $0x10,%esp
    7f1c:	89 c2                	mov    %eax,%edx
    7f1e:	8b 45 08             	mov    0x8(%ebp),%eax
    7f21:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    7f23:	8b 45 08             	mov    0x8(%ebp),%eax
    7f26:	8b 00                	mov    (%eax),%eax
    7f28:	85 c0                	test   %eax,%eax
    7f2a:	75 07                	jne    7f33 <lodepng_zlib_compress+0x7e>
    7f2c:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    7f33:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7f37:	0f 85 e2 00 00 00    	jne    801f <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    7f3d:	8b 45 14             	mov    0x14(%ebp),%eax
    7f40:	83 ec 08             	sub    $0x8,%esp
    7f43:	50                   	push   %eax
    7f44:	ff 75 10             	pushl  0x10(%ebp)
    7f47:	e8 ec fc ff ff       	call   7c38 <adler32>
    7f4c:	83 c4 10             	add    $0x10,%esp
    7f4f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    7f52:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    7f59:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    7f60:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    7f67:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7f6a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7f71:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7f74:	01 d0                	add    %edx,%eax
    7f76:	8d 14 00             	lea    (%eax,%eax,1),%edx
    7f79:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7f7c:	01 d0                	add    %edx,%eax
    7f7e:	c1 e0 05             	shl    $0x5,%eax
    7f81:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    7f84:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7f87:	ba 85 10 42 08       	mov    $0x8421085,%edx
    7f8c:	89 c8                	mov    %ecx,%eax
    7f8e:	f7 e2                	mul    %edx
    7f90:	89 c8                	mov    %ecx,%eax
    7f92:	29 d0                	sub    %edx,%eax
    7f94:	d1 e8                	shr    %eax
    7f96:	01 d0                	add    %edx,%eax
    7f98:	c1 e8 04             	shr    $0x4,%eax
    7f9b:	89 c2                	mov    %eax,%edx
    7f9d:	c1 e2 05             	shl    $0x5,%edx
    7fa0:	29 c2                	sub    %eax,%edx
    7fa2:	89 c8                	mov    %ecx,%eax
    7fa4:	29 d0                	sub    %edx,%eax
    7fa6:	ba 1f 00 00 00       	mov    $0x1f,%edx
    7fab:	29 c2                	sub    %eax,%edx
    7fad:	89 d0                	mov    %edx,%eax
    7faf:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    7fb2:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7fb5:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    7fb8:	8b 45 08             	mov    0x8(%ebp),%eax
    7fbb:	8b 00                	mov    (%eax),%eax
    7fbd:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7fc0:	c1 ea 08             	shr    $0x8,%edx
    7fc3:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    7fc5:	8b 45 08             	mov    0x8(%ebp),%eax
    7fc8:	8b 00                	mov    (%eax),%eax
    7fca:	83 c0 01             	add    $0x1,%eax
    7fcd:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7fd0:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    7fd2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7fd9:	eb 1e                	jmp    7ff9 <lodepng_zlib_compress+0x144>
    7fdb:	8b 45 08             	mov    0x8(%ebp),%eax
    7fde:	8b 00                	mov    (%eax),%eax
    7fe0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7fe3:	83 c2 02             	add    $0x2,%edx
    7fe6:	01 c2                	add    %eax,%edx
    7fe8:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    7feb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7fee:	01 c8                	add    %ecx,%eax
    7ff0:	0f b6 00             	movzbl (%eax),%eax
    7ff3:	88 02                	mov    %al,(%edx)
    7ff5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7ff9:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7ffc:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    7fff:	75 da                	jne    7fdb <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    8001:	8b 45 08             	mov    0x8(%ebp),%eax
    8004:	8b 10                	mov    (%eax),%edx
    8006:	8b 45 0c             	mov    0xc(%ebp),%eax
    8009:	8b 00                	mov    (%eax),%eax
    800b:	83 e8 04             	sub    $0x4,%eax
    800e:	01 d0                	add    %edx,%eax
    8010:	83 ec 08             	sub    $0x8,%esp
    8013:	ff 75 ec             	pushl  -0x14(%ebp)
    8016:	50                   	push   %eax
    8017:	e8 c8 b6 ff ff       	call   36e4 <lodepng_set32bitInt>
    801c:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    801f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    8022:	83 ec 0c             	sub    $0xc,%esp
    8025:	50                   	push   %eax
    8026:	e8 19 b3 ff ff       	call   3344 <lodepng_free>
    802b:	83 c4 10             	add    $0x10,%esp
  return error;
    802e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    8031:	c9                   	leave  
    8032:	c3                   	ret    

00008033 <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    8033:	55                   	push   %ebp
    8034:	89 e5                	mov    %esp,%ebp
    8036:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    8039:	8b 45 18             	mov    0x18(%ebp),%eax
    803c:	8b 40 18             	mov    0x18(%eax),%eax
    803f:	85 c0                	test   %eax,%eax
    8041:	74 34                	je     8077 <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    8043:	8b 45 18             	mov    0x18(%ebp),%eax
    8046:	8b 40 18             	mov    0x18(%eax),%eax
    8049:	83 ec 0c             	sub    $0xc,%esp
    804c:	ff 75 18             	pushl  0x18(%ebp)
    804f:	ff 75 14             	pushl  0x14(%ebp)
    8052:	ff 75 10             	pushl  0x10(%ebp)
    8055:	ff 75 0c             	pushl  0xc(%ebp)
    8058:	ff 75 08             	pushl  0x8(%ebp)
    805b:	ff d0                	call   *%eax
    805d:	83 c4 20             	add    $0x20,%esp
    8060:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    8063:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8067:	74 07                	je     8070 <zlib_compress+0x3d>
    8069:	b8 6f 00 00 00       	mov    $0x6f,%eax
    806e:	eb 21                	jmp    8091 <zlib_compress+0x5e>
    8070:	b8 00 00 00 00       	mov    $0x0,%eax
    8075:	eb 1a                	jmp    8091 <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    8077:	83 ec 0c             	sub    $0xc,%esp
    807a:	ff 75 18             	pushl  0x18(%ebp)
    807d:	ff 75 14             	pushl  0x14(%ebp)
    8080:	ff 75 10             	pushl  0x10(%ebp)
    8083:	ff 75 0c             	pushl  0xc(%ebp)
    8086:	ff 75 08             	pushl  0x8(%ebp)
    8089:	e8 27 fe ff ff       	call   7eb5 <lodepng_zlib_compress>
    808e:	83 c4 20             	add    $0x20,%esp
  }
}
    8091:	c9                   	leave  
    8092:	c3                   	ret    

00008093 <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    8093:	55                   	push   %ebp
    8094:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    8096:	8b 45 08             	mov    0x8(%ebp),%eax
    8099:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    809f:	8b 45 08             	mov    0x8(%ebp),%eax
    80a2:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    80a9:	8b 45 08             	mov    0x8(%ebp),%eax
    80ac:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    80b3:	8b 45 08             	mov    0x8(%ebp),%eax
    80b6:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    80bd:	8b 45 08             	mov    0x8(%ebp),%eax
    80c0:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    80c7:	8b 45 08             	mov    0x8(%ebp),%eax
    80ca:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    80d1:	8b 45 08             	mov    0x8(%ebp),%eax
    80d4:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    80db:	8b 45 08             	mov    0x8(%ebp),%eax
    80de:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    80e5:	8b 45 08             	mov    0x8(%ebp),%eax
    80e8:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    80ef:	90                   	nop
    80f0:	5d                   	pop    %ebp
    80f1:	c3                   	ret    

000080f2 <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    80f2:	55                   	push   %ebp
    80f3:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    80f5:	8b 45 08             	mov    0x8(%ebp),%eax
    80f8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    80fe:	8b 45 08             	mov    0x8(%ebp),%eax
    8101:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    8108:	8b 45 08             	mov    0x8(%ebp),%eax
    810b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    8112:	8b 45 08             	mov    0x8(%ebp),%eax
    8115:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    811c:	8b 45 08             	mov    0x8(%ebp),%eax
    811f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    8126:	8b 45 08             	mov    0x8(%ebp),%eax
    8129:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    8130:	90                   	nop
    8131:	5d                   	pop    %ebp
    8132:	c3                   	ret    

00008133 <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    8133:	55                   	push   %ebp
    8134:	89 e5                	mov    %esp,%ebp
    8136:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    8139:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    8140:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8147:	eb 2a                	jmp    8173 <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    8149:	8b 55 f8             	mov    -0x8(%ebp),%edx
    814c:	8b 45 08             	mov    0x8(%ebp),%eax
    814f:	01 d0                	add    %edx,%eax
    8151:	0f b6 00             	movzbl (%eax),%eax
    8154:	0f b6 c0             	movzbl %al,%eax
    8157:	33 45 fc             	xor    -0x4(%ebp),%eax
    815a:	0f b6 c0             	movzbl %al,%eax
    815d:	8b 04 85 00 e1 01 00 	mov    0x1e100(,%eax,4),%eax
    8164:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8167:	c1 ea 08             	shr    $0x8,%edx
    816a:	31 d0                	xor    %edx,%eax
    816c:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    816f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8173:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8176:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8179:	7c ce                	jl     8149 <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    817b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    817e:	f7 d0                	not    %eax
}
    8180:	c9                   	leave  
    8181:	c3                   	ret    

00008182 <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    8182:	55                   	push   %ebp
    8183:	89 e5                	mov    %esp,%ebp
    8185:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    8188:	8b 45 08             	mov    0x8(%ebp),%eax
    818b:	8b 00                	mov    (%eax),%eax
    818d:	c1 f8 03             	sar    $0x3,%eax
    8190:	89 c2                	mov    %eax,%edx
    8192:	8b 45 0c             	mov    0xc(%ebp),%eax
    8195:	01 d0                	add    %edx,%eax
    8197:	0f b6 00             	movzbl (%eax),%eax
    819a:	0f b6 d0             	movzbl %al,%edx
    819d:	8b 45 08             	mov    0x8(%ebp),%eax
    81a0:	8b 00                	mov    (%eax),%eax
    81a2:	f7 d0                	not    %eax
    81a4:	83 e0 07             	and    $0x7,%eax
    81a7:	89 c1                	mov    %eax,%ecx
    81a9:	d3 fa                	sar    %cl,%edx
    81ab:	89 d0                	mov    %edx,%eax
    81ad:	83 e0 01             	and    $0x1,%eax
    81b0:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    81b3:	8b 45 08             	mov    0x8(%ebp),%eax
    81b6:	8b 00                	mov    (%eax),%eax
    81b8:	8d 50 01             	lea    0x1(%eax),%edx
    81bb:	8b 45 08             	mov    0x8(%ebp),%eax
    81be:	89 10                	mov    %edx,(%eax)
  return result;
    81c0:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    81c4:	c9                   	leave  
    81c5:	c3                   	ret    

000081c6 <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    81c6:	55                   	push   %ebp
    81c7:	89 e5                	mov    %esp,%ebp
    81c9:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    81cc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    81d3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    81da:	eb 1b                	jmp    81f7 <readBitsFromReversedStream+0x31>
    result <<= 1u;
    81dc:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    81df:	ff 75 0c             	pushl  0xc(%ebp)
    81e2:	ff 75 08             	pushl  0x8(%ebp)
    81e5:	e8 98 ff ff ff       	call   8182 <readBitFromReversedStream>
    81ea:	83 c4 08             	add    $0x8,%esp
    81ed:	0f b6 c0             	movzbl %al,%eax
    81f0:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    81f3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    81f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    81fa:	3b 45 10             	cmp    0x10(%ebp),%eax
    81fd:	7c dd                	jl     81dc <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    81ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    8202:	c9                   	leave  
    8203:	c3                   	ret    

00008204 <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    8204:	55                   	push   %ebp
    8205:	89 e5                	mov    %esp,%ebp
    8207:	56                   	push   %esi
    8208:	53                   	push   %ebx
    8209:	83 ec 04             	sub    $0x4,%esp
    820c:	8b 45 10             	mov    0x10(%ebp),%eax
    820f:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    8212:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    8216:	75 3e                	jne    8256 <setBitOfReversedStream+0x52>
    8218:	8b 45 08             	mov    0x8(%ebp),%eax
    821b:	8b 00                	mov    (%eax),%eax
    821d:	c1 f8 03             	sar    $0x3,%eax
    8220:	89 c2                	mov    %eax,%edx
    8222:	8b 45 0c             	mov    0xc(%ebp),%eax
    8225:	01 c2                	add    %eax,%edx
    8227:	8b 45 08             	mov    0x8(%ebp),%eax
    822a:	8b 00                	mov    (%eax),%eax
    822c:	c1 f8 03             	sar    $0x3,%eax
    822f:	89 c1                	mov    %eax,%ecx
    8231:	8b 45 0c             	mov    0xc(%ebp),%eax
    8234:	01 c8                	add    %ecx,%eax
    8236:	0f b6 18             	movzbl (%eax),%ebx
    8239:	8b 45 08             	mov    0x8(%ebp),%eax
    823c:	8b 00                	mov    (%eax),%eax
    823e:	f7 d0                	not    %eax
    8240:	83 e0 07             	and    $0x7,%eax
    8243:	be 01 00 00 00       	mov    $0x1,%esi
    8248:	89 c1                	mov    %eax,%ecx
    824a:	d3 e6                	shl    %cl,%esi
    824c:	89 f0                	mov    %esi,%eax
    824e:	f7 d0                	not    %eax
    8250:	21 d8                	and    %ebx,%eax
    8252:	88 02                	mov    %al,(%edx)
    8254:	eb 3a                	jmp    8290 <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    8256:	8b 45 08             	mov    0x8(%ebp),%eax
    8259:	8b 00                	mov    (%eax),%eax
    825b:	c1 f8 03             	sar    $0x3,%eax
    825e:	89 c2                	mov    %eax,%edx
    8260:	8b 45 0c             	mov    0xc(%ebp),%eax
    8263:	01 c2                	add    %eax,%edx
    8265:	8b 45 08             	mov    0x8(%ebp),%eax
    8268:	8b 00                	mov    (%eax),%eax
    826a:	c1 f8 03             	sar    $0x3,%eax
    826d:	89 c1                	mov    %eax,%ecx
    826f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8272:	01 c8                	add    %ecx,%eax
    8274:	0f b6 18             	movzbl (%eax),%ebx
    8277:	8b 45 08             	mov    0x8(%ebp),%eax
    827a:	8b 00                	mov    (%eax),%eax
    827c:	f7 d0                	not    %eax
    827e:	83 e0 07             	and    $0x7,%eax
    8281:	be 01 00 00 00       	mov    $0x1,%esi
    8286:	89 c1                	mov    %eax,%ecx
    8288:	d3 e6                	shl    %cl,%esi
    828a:	89 f0                	mov    %esi,%eax
    828c:	09 d8                	or     %ebx,%eax
    828e:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    8290:	8b 45 08             	mov    0x8(%ebp),%eax
    8293:	8b 00                	mov    (%eax),%eax
    8295:	8d 50 01             	lea    0x1(%eax),%edx
    8298:	8b 45 08             	mov    0x8(%ebp),%eax
    829b:	89 10                	mov    %edx,(%eax)
}
    829d:	90                   	nop
    829e:	83 c4 04             	add    $0x4,%esp
    82a1:	5b                   	pop    %ebx
    82a2:	5e                   	pop    %esi
    82a3:	5d                   	pop    %ebp
    82a4:	c3                   	ret    

000082a5 <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    82a5:	55                   	push   %ebp
    82a6:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    82a8:	ff 75 08             	pushl  0x8(%ebp)
    82ab:	e8 f1 b3 ff ff       	call   36a1 <lodepng_read32bitInt>
    82b0:	83 c4 04             	add    $0x4,%esp
}
    82b3:	c9                   	leave  
    82b4:	c3                   	ret    

000082b5 <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    82b5:	55                   	push   %ebp
    82b6:	89 e5                	mov    %esp,%ebp
    82b8:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    82bb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    82c2:	eb 1c                	jmp    82e0 <lodepng_chunk_type+0x2b>
    82c4:	8b 55 08             	mov    0x8(%ebp),%edx
    82c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    82ca:	01 d0                	add    %edx,%eax
    82cc:	8b 55 fc             	mov    -0x4(%ebp),%edx
    82cf:	8d 4a 04             	lea    0x4(%edx),%ecx
    82d2:	8b 55 0c             	mov    0xc(%ebp),%edx
    82d5:	01 ca                	add    %ecx,%edx
    82d7:	0f b6 12             	movzbl (%edx),%edx
    82da:	88 10                	mov    %dl,(%eax)
    82dc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    82e0:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    82e4:	75 de                	jne    82c4 <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    82e6:	8b 45 08             	mov    0x8(%ebp),%eax
    82e9:	83 c0 04             	add    $0x4,%eax
    82ec:	c6 00 00             	movb   $0x0,(%eax)
}
    82ef:	90                   	nop
    82f0:	c9                   	leave  
    82f1:	c3                   	ret    

000082f2 <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    82f2:	55                   	push   %ebp
    82f3:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    82f5:	ff 75 0c             	pushl  0xc(%ebp)
    82f8:	e8 c2 b0 ff ff       	call   33bf <lodepng_strlen>
    82fd:	83 c4 04             	add    $0x4,%esp
    8300:	83 f8 04             	cmp    $0x4,%eax
    8303:	74 07                	je     830c <lodepng_chunk_type_equals+0x1a>
    8305:	b8 00 00 00 00       	mov    $0x0,%eax
    830a:	eb 79                	jmp    8385 <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    830c:	8b 45 08             	mov    0x8(%ebp),%eax
    830f:	83 c0 04             	add    $0x4,%eax
    8312:	0f b6 00             	movzbl (%eax),%eax
    8315:	0f b6 d0             	movzbl %al,%edx
    8318:	8b 45 0c             	mov    0xc(%ebp),%eax
    831b:	0f b6 00             	movzbl (%eax),%eax
    831e:	0f be c0             	movsbl %al,%eax
    8321:	39 c2                	cmp    %eax,%edx
    8323:	75 5b                	jne    8380 <lodepng_chunk_type_equals+0x8e>
    8325:	8b 45 08             	mov    0x8(%ebp),%eax
    8328:	83 c0 05             	add    $0x5,%eax
    832b:	0f b6 00             	movzbl (%eax),%eax
    832e:	0f b6 d0             	movzbl %al,%edx
    8331:	8b 45 0c             	mov    0xc(%ebp),%eax
    8334:	83 c0 01             	add    $0x1,%eax
    8337:	0f b6 00             	movzbl (%eax),%eax
    833a:	0f be c0             	movsbl %al,%eax
    833d:	39 c2                	cmp    %eax,%edx
    833f:	75 3f                	jne    8380 <lodepng_chunk_type_equals+0x8e>
    8341:	8b 45 08             	mov    0x8(%ebp),%eax
    8344:	83 c0 06             	add    $0x6,%eax
    8347:	0f b6 00             	movzbl (%eax),%eax
    834a:	0f b6 d0             	movzbl %al,%edx
    834d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8350:	83 c0 02             	add    $0x2,%eax
    8353:	0f b6 00             	movzbl (%eax),%eax
    8356:	0f be c0             	movsbl %al,%eax
    8359:	39 c2                	cmp    %eax,%edx
    835b:	75 23                	jne    8380 <lodepng_chunk_type_equals+0x8e>
    835d:	8b 45 08             	mov    0x8(%ebp),%eax
    8360:	83 c0 07             	add    $0x7,%eax
    8363:	0f b6 00             	movzbl (%eax),%eax
    8366:	0f b6 d0             	movzbl %al,%edx
    8369:	8b 45 0c             	mov    0xc(%ebp),%eax
    836c:	83 c0 03             	add    $0x3,%eax
    836f:	0f b6 00             	movzbl (%eax),%eax
    8372:	0f be c0             	movsbl %al,%eax
    8375:	39 c2                	cmp    %eax,%edx
    8377:	75 07                	jne    8380 <lodepng_chunk_type_equals+0x8e>
    8379:	b8 01 00 00 00       	mov    $0x1,%eax
    837e:	eb 05                	jmp    8385 <lodepng_chunk_type_equals+0x93>
    8380:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8385:	c9                   	leave  
    8386:	c3                   	ret    

00008387 <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    8387:	55                   	push   %ebp
    8388:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    838a:	8b 45 08             	mov    0x8(%ebp),%eax
    838d:	83 c0 04             	add    $0x4,%eax
    8390:	0f b6 00             	movzbl (%eax),%eax
    8393:	0f b6 c0             	movzbl %al,%eax
    8396:	83 e0 20             	and    $0x20,%eax
    8399:	85 c0                	test   %eax,%eax
    839b:	0f 95 c0             	setne  %al
}
    839e:	5d                   	pop    %ebp
    839f:	c3                   	ret    

000083a0 <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    83a0:	55                   	push   %ebp
    83a1:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    83a3:	8b 45 08             	mov    0x8(%ebp),%eax
    83a6:	83 c0 06             	add    $0x6,%eax
    83a9:	0f b6 00             	movzbl (%eax),%eax
    83ac:	0f b6 c0             	movzbl %al,%eax
    83af:	83 e0 20             	and    $0x20,%eax
    83b2:	85 c0                	test   %eax,%eax
    83b4:	0f 95 c0             	setne  %al
}
    83b7:	5d                   	pop    %ebp
    83b8:	c3                   	ret    

000083b9 <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    83b9:	55                   	push   %ebp
    83ba:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    83bc:	8b 45 08             	mov    0x8(%ebp),%eax
    83bf:	83 c0 07             	add    $0x7,%eax
    83c2:	0f b6 00             	movzbl (%eax),%eax
    83c5:	0f b6 c0             	movzbl %al,%eax
    83c8:	83 e0 20             	and    $0x20,%eax
    83cb:	85 c0                	test   %eax,%eax
    83cd:	0f 95 c0             	setne  %al
}
    83d0:	5d                   	pop    %ebp
    83d1:	c3                   	ret    

000083d2 <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    83d2:	55                   	push   %ebp
    83d3:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    83d5:	8b 45 08             	mov    0x8(%ebp),%eax
    83d8:	83 c0 08             	add    $0x8,%eax
}
    83db:	5d                   	pop    %ebp
    83dc:	c3                   	ret    

000083dd <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    83dd:	55                   	push   %ebp
    83de:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    83e0:	8b 45 08             	mov    0x8(%ebp),%eax
    83e3:	83 c0 08             	add    $0x8,%eax
}
    83e6:	5d                   	pop    %ebp
    83e7:	c3                   	ret    

000083e8 <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    83e8:	55                   	push   %ebp
    83e9:	89 e5                	mov    %esp,%ebp
    83eb:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    83ee:	ff 75 08             	pushl  0x8(%ebp)
    83f1:	e8 af fe ff ff       	call   82a5 <lodepng_chunk_length>
    83f6:	83 c4 04             	add    $0x4,%esp
    83f9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    83fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    83ff:	8d 50 08             	lea    0x8(%eax),%edx
    8402:	8b 45 08             	mov    0x8(%ebp),%eax
    8405:	01 d0                	add    %edx,%eax
    8407:	50                   	push   %eax
    8408:	e8 94 b2 ff ff       	call   36a1 <lodepng_read32bitInt>
    840d:	83 c4 04             	add    $0x4,%esp
    8410:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    8413:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8416:	83 c0 04             	add    $0x4,%eax
    8419:	89 c2                	mov    %eax,%edx
    841b:	8b 45 08             	mov    0x8(%ebp),%eax
    841e:	83 c0 04             	add    $0x4,%eax
    8421:	52                   	push   %edx
    8422:	50                   	push   %eax
    8423:	e8 0b fd ff ff       	call   8133 <lodepng_crc32>
    8428:	83 c4 08             	add    $0x8,%esp
    842b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    842e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8431:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    8434:	74 07                	je     843d <lodepng_chunk_check_crc+0x55>
    8436:	b8 01 00 00 00       	mov    $0x1,%eax
    843b:	eb 05                	jmp    8442 <lodepng_chunk_check_crc+0x5a>
  else return 0;
    843d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8442:	c9                   	leave  
    8443:	c3                   	ret    

00008444 <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    8444:	55                   	push   %ebp
    8445:	89 e5                	mov    %esp,%ebp
    8447:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    844a:	ff 75 08             	pushl  0x8(%ebp)
    844d:	e8 53 fe ff ff       	call   82a5 <lodepng_chunk_length>
    8452:	83 c4 04             	add    $0x4,%esp
    8455:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    8458:	8b 45 fc             	mov    -0x4(%ebp),%eax
    845b:	83 c0 04             	add    $0x4,%eax
    845e:	89 c2                	mov    %eax,%edx
    8460:	8b 45 08             	mov    0x8(%ebp),%eax
    8463:	83 c0 04             	add    $0x4,%eax
    8466:	52                   	push   %edx
    8467:	50                   	push   %eax
    8468:	e8 c6 fc ff ff       	call   8133 <lodepng_crc32>
    846d:	83 c4 08             	add    $0x8,%esp
    8470:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    8473:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8476:	8d 50 08             	lea    0x8(%eax),%edx
    8479:	8b 45 08             	mov    0x8(%ebp),%eax
    847c:	01 d0                	add    %edx,%eax
    847e:	ff 75 f8             	pushl  -0x8(%ebp)
    8481:	50                   	push   %eax
    8482:	e8 5d b2 ff ff       	call   36e4 <lodepng_set32bitInt>
    8487:	83 c4 08             	add    $0x8,%esp
}
    848a:	90                   	nop
    848b:	c9                   	leave  
    848c:	c3                   	ret    

0000848d <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    848d:	55                   	push   %ebp
    848e:	89 e5                	mov    %esp,%ebp
    8490:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8493:	8b 45 08             	mov    0x8(%ebp),%eax
    8496:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8499:	73 0f                	jae    84aa <lodepng_chunk_next+0x1d>
    849b:	8b 55 0c             	mov    0xc(%ebp),%edx
    849e:	8b 45 08             	mov    0x8(%ebp),%eax
    84a1:	29 c2                	sub    %eax,%edx
    84a3:	89 d0                	mov    %edx,%eax
    84a5:	83 f8 0b             	cmp    $0xb,%eax
    84a8:	7f 08                	jg     84b2 <lodepng_chunk_next+0x25>
    84aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    84ad:	e9 af 00 00 00       	jmp    8561 <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    84b2:	8b 45 08             	mov    0x8(%ebp),%eax
    84b5:	0f b6 00             	movzbl (%eax),%eax
    84b8:	3c 89                	cmp    $0x89,%al
    84ba:	75 63                	jne    851f <lodepng_chunk_next+0x92>
    84bc:	8b 45 08             	mov    0x8(%ebp),%eax
    84bf:	83 c0 01             	add    $0x1,%eax
    84c2:	0f b6 00             	movzbl (%eax),%eax
    84c5:	3c 50                	cmp    $0x50,%al
    84c7:	75 56                	jne    851f <lodepng_chunk_next+0x92>
    84c9:	8b 45 08             	mov    0x8(%ebp),%eax
    84cc:	83 c0 02             	add    $0x2,%eax
    84cf:	0f b6 00             	movzbl (%eax),%eax
    84d2:	3c 4e                	cmp    $0x4e,%al
    84d4:	75 49                	jne    851f <lodepng_chunk_next+0x92>
    84d6:	8b 45 08             	mov    0x8(%ebp),%eax
    84d9:	83 c0 03             	add    $0x3,%eax
    84dc:	0f b6 00             	movzbl (%eax),%eax
    84df:	3c 47                	cmp    $0x47,%al
    84e1:	75 3c                	jne    851f <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    84e3:	8b 45 08             	mov    0x8(%ebp),%eax
    84e6:	83 c0 04             	add    $0x4,%eax
    84e9:	0f b6 00             	movzbl (%eax),%eax
    84ec:	3c 0d                	cmp    $0xd,%al
    84ee:	75 2f                	jne    851f <lodepng_chunk_next+0x92>
    84f0:	8b 45 08             	mov    0x8(%ebp),%eax
    84f3:	83 c0 05             	add    $0x5,%eax
    84f6:	0f b6 00             	movzbl (%eax),%eax
    84f9:	3c 0a                	cmp    $0xa,%al
    84fb:	75 22                	jne    851f <lodepng_chunk_next+0x92>
    84fd:	8b 45 08             	mov    0x8(%ebp),%eax
    8500:	83 c0 06             	add    $0x6,%eax
    8503:	0f b6 00             	movzbl (%eax),%eax
    8506:	3c 1a                	cmp    $0x1a,%al
    8508:	75 15                	jne    851f <lodepng_chunk_next+0x92>
    850a:	8b 45 08             	mov    0x8(%ebp),%eax
    850d:	83 c0 07             	add    $0x7,%eax
    8510:	0f b6 00             	movzbl (%eax),%eax
    8513:	3c 0a                	cmp    $0xa,%al
    8515:	75 08                	jne    851f <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    8517:	8b 45 08             	mov    0x8(%ebp),%eax
    851a:	83 c0 08             	add    $0x8,%eax
    851d:	eb 42                	jmp    8561 <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    851f:	ff 75 08             	pushl  0x8(%ebp)
    8522:	e8 7e fd ff ff       	call   82a5 <lodepng_chunk_length>
    8527:	83 c4 04             	add    $0x4,%esp
    852a:	89 c2                	mov    %eax,%edx
    852c:	8d 45 f8             	lea    -0x8(%ebp),%eax
    852f:	50                   	push   %eax
    8530:	6a 0c                	push   $0xc
    8532:	52                   	push   %edx
    8533:	e8 af ae ff ff       	call   33e7 <lodepng_addofl>
    8538:	83 c4 0c             	add    $0xc,%esp
    853b:	85 c0                	test   %eax,%eax
    853d:	74 05                	je     8544 <lodepng_chunk_next+0xb7>
    853f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8542:	eb 1d                	jmp    8561 <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    8544:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8547:	89 c2                	mov    %eax,%edx
    8549:	8b 45 08             	mov    0x8(%ebp),%eax
    854c:	01 d0                	add    %edx,%eax
    854e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8551:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8554:	3b 45 08             	cmp    0x8(%ebp),%eax
    8557:	73 05                	jae    855e <lodepng_chunk_next+0xd1>
    8559:	8b 45 0c             	mov    0xc(%ebp),%eax
    855c:	eb 03                	jmp    8561 <lodepng_chunk_next+0xd4>
    return result;
    855e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8561:	c9                   	leave  
    8562:	c3                   	ret    

00008563 <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    8563:	55                   	push   %ebp
    8564:	89 e5                	mov    %esp,%ebp
    8566:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8569:	8b 45 08             	mov    0x8(%ebp),%eax
    856c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    856f:	73 0f                	jae    8580 <lodepng_chunk_next_const+0x1d>
    8571:	8b 55 0c             	mov    0xc(%ebp),%edx
    8574:	8b 45 08             	mov    0x8(%ebp),%eax
    8577:	29 c2                	sub    %eax,%edx
    8579:	89 d0                	mov    %edx,%eax
    857b:	83 f8 0b             	cmp    $0xb,%eax
    857e:	7f 08                	jg     8588 <lodepng_chunk_next_const+0x25>
    8580:	8b 45 0c             	mov    0xc(%ebp),%eax
    8583:	e9 af 00 00 00       	jmp    8637 <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    8588:	8b 45 08             	mov    0x8(%ebp),%eax
    858b:	0f b6 00             	movzbl (%eax),%eax
    858e:	3c 89                	cmp    $0x89,%al
    8590:	75 63                	jne    85f5 <lodepng_chunk_next_const+0x92>
    8592:	8b 45 08             	mov    0x8(%ebp),%eax
    8595:	83 c0 01             	add    $0x1,%eax
    8598:	0f b6 00             	movzbl (%eax),%eax
    859b:	3c 50                	cmp    $0x50,%al
    859d:	75 56                	jne    85f5 <lodepng_chunk_next_const+0x92>
    859f:	8b 45 08             	mov    0x8(%ebp),%eax
    85a2:	83 c0 02             	add    $0x2,%eax
    85a5:	0f b6 00             	movzbl (%eax),%eax
    85a8:	3c 4e                	cmp    $0x4e,%al
    85aa:	75 49                	jne    85f5 <lodepng_chunk_next_const+0x92>
    85ac:	8b 45 08             	mov    0x8(%ebp),%eax
    85af:	83 c0 03             	add    $0x3,%eax
    85b2:	0f b6 00             	movzbl (%eax),%eax
    85b5:	3c 47                	cmp    $0x47,%al
    85b7:	75 3c                	jne    85f5 <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    85b9:	8b 45 08             	mov    0x8(%ebp),%eax
    85bc:	83 c0 04             	add    $0x4,%eax
    85bf:	0f b6 00             	movzbl (%eax),%eax
    85c2:	3c 0d                	cmp    $0xd,%al
    85c4:	75 2f                	jne    85f5 <lodepng_chunk_next_const+0x92>
    85c6:	8b 45 08             	mov    0x8(%ebp),%eax
    85c9:	83 c0 05             	add    $0x5,%eax
    85cc:	0f b6 00             	movzbl (%eax),%eax
    85cf:	3c 0a                	cmp    $0xa,%al
    85d1:	75 22                	jne    85f5 <lodepng_chunk_next_const+0x92>
    85d3:	8b 45 08             	mov    0x8(%ebp),%eax
    85d6:	83 c0 06             	add    $0x6,%eax
    85d9:	0f b6 00             	movzbl (%eax),%eax
    85dc:	3c 1a                	cmp    $0x1a,%al
    85de:	75 15                	jne    85f5 <lodepng_chunk_next_const+0x92>
    85e0:	8b 45 08             	mov    0x8(%ebp),%eax
    85e3:	83 c0 07             	add    $0x7,%eax
    85e6:	0f b6 00             	movzbl (%eax),%eax
    85e9:	3c 0a                	cmp    $0xa,%al
    85eb:	75 08                	jne    85f5 <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    85ed:	8b 45 08             	mov    0x8(%ebp),%eax
    85f0:	83 c0 08             	add    $0x8,%eax
    85f3:	eb 42                	jmp    8637 <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    85f5:	ff 75 08             	pushl  0x8(%ebp)
    85f8:	e8 a8 fc ff ff       	call   82a5 <lodepng_chunk_length>
    85fd:	83 c4 04             	add    $0x4,%esp
    8600:	89 c2                	mov    %eax,%edx
    8602:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8605:	50                   	push   %eax
    8606:	6a 0c                	push   $0xc
    8608:	52                   	push   %edx
    8609:	e8 d9 ad ff ff       	call   33e7 <lodepng_addofl>
    860e:	83 c4 0c             	add    $0xc,%esp
    8611:	85 c0                	test   %eax,%eax
    8613:	74 05                	je     861a <lodepng_chunk_next_const+0xb7>
    8615:	8b 45 0c             	mov    0xc(%ebp),%eax
    8618:	eb 1d                	jmp    8637 <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    861a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    861d:	89 c2                	mov    %eax,%edx
    861f:	8b 45 08             	mov    0x8(%ebp),%eax
    8622:	01 d0                	add    %edx,%eax
    8624:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8627:	8b 45 fc             	mov    -0x4(%ebp),%eax
    862a:	3b 45 08             	cmp    0x8(%ebp),%eax
    862d:	73 05                	jae    8634 <lodepng_chunk_next_const+0xd1>
    862f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8632:	eb 03                	jmp    8637 <lodepng_chunk_next_const+0xd4>
    return result;
    8634:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8637:	c9                   	leave  
    8638:	c3                   	ret    

00008639 <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    8639:	55                   	push   %ebp
    863a:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    863c:	8b 45 08             	mov    0x8(%ebp),%eax
    863f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8642:	73 0f                	jae    8653 <lodepng_chunk_find+0x1a>
    8644:	8b 55 0c             	mov    0xc(%ebp),%edx
    8647:	8b 45 08             	mov    0x8(%ebp),%eax
    864a:	29 c2                	sub    %eax,%edx
    864c:	89 d0                	mov    %edx,%eax
    864e:	83 f8 0b             	cmp    $0xb,%eax
    8651:	7f 07                	jg     865a <lodepng_chunk_find+0x21>
    8653:	b8 00 00 00 00       	mov    $0x0,%eax
    8658:	eb 2a                	jmp    8684 <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    865a:	ff 75 10             	pushl  0x10(%ebp)
    865d:	ff 75 08             	pushl  0x8(%ebp)
    8660:	e8 8d fc ff ff       	call   82f2 <lodepng_chunk_type_equals>
    8665:	83 c4 08             	add    $0x8,%esp
    8668:	84 c0                	test   %al,%al
    866a:	74 05                	je     8671 <lodepng_chunk_find+0x38>
    866c:	8b 45 08             	mov    0x8(%ebp),%eax
    866f:	eb 13                	jmp    8684 <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    8671:	ff 75 0c             	pushl  0xc(%ebp)
    8674:	ff 75 08             	pushl  0x8(%ebp)
    8677:	e8 11 fe ff ff       	call   848d <lodepng_chunk_next>
    867c:	83 c4 08             	add    $0x8,%esp
    867f:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8682:	eb b8                	jmp    863c <lodepng_chunk_find+0x3>
}
    8684:	c9                   	leave  
    8685:	c3                   	ret    

00008686 <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    8686:	55                   	push   %ebp
    8687:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    8689:	8b 45 08             	mov    0x8(%ebp),%eax
    868c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    868f:	73 0f                	jae    86a0 <lodepng_chunk_find_const+0x1a>
    8691:	8b 55 0c             	mov    0xc(%ebp),%edx
    8694:	8b 45 08             	mov    0x8(%ebp),%eax
    8697:	29 c2                	sub    %eax,%edx
    8699:	89 d0                	mov    %edx,%eax
    869b:	83 f8 0b             	cmp    $0xb,%eax
    869e:	7f 07                	jg     86a7 <lodepng_chunk_find_const+0x21>
    86a0:	b8 00 00 00 00       	mov    $0x0,%eax
    86a5:	eb 2a                	jmp    86d1 <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    86a7:	ff 75 10             	pushl  0x10(%ebp)
    86aa:	ff 75 08             	pushl  0x8(%ebp)
    86ad:	e8 40 fc ff ff       	call   82f2 <lodepng_chunk_type_equals>
    86b2:	83 c4 08             	add    $0x8,%esp
    86b5:	84 c0                	test   %al,%al
    86b7:	74 05                	je     86be <lodepng_chunk_find_const+0x38>
    86b9:	8b 45 08             	mov    0x8(%ebp),%eax
    86bc:	eb 13                	jmp    86d1 <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    86be:	ff 75 0c             	pushl  0xc(%ebp)
    86c1:	ff 75 08             	pushl  0x8(%ebp)
    86c4:	e8 9a fe ff ff       	call   8563 <lodepng_chunk_next_const>
    86c9:	83 c4 08             	add    $0x8,%esp
    86cc:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    86cf:	eb b8                	jmp    8689 <lodepng_chunk_find_const+0x3>
}
    86d1:	c9                   	leave  
    86d2:	c3                   	ret    

000086d3 <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    86d3:	55                   	push   %ebp
    86d4:	89 e5                	mov    %esp,%ebp
    86d6:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    86d9:	ff 75 10             	pushl  0x10(%ebp)
    86dc:	e8 c4 fb ff ff       	call   82a5 <lodepng_chunk_length>
    86e1:	83 c4 04             	add    $0x4,%esp
    86e4:	89 c2                	mov    %eax,%edx
    86e6:	8d 45 f0             	lea    -0x10(%ebp),%eax
    86e9:	50                   	push   %eax
    86ea:	6a 0c                	push   $0xc
    86ec:	52                   	push   %edx
    86ed:	e8 f5 ac ff ff       	call   33e7 <lodepng_addofl>
    86f2:	83 c4 0c             	add    $0xc,%esp
    86f5:	85 c0                	test   %eax,%eax
    86f7:	74 0a                	je     8703 <lodepng_chunk_append+0x30>
    86f9:	b8 4d 00 00 00       	mov    $0x4d,%eax
    86fe:	e9 96 00 00 00       	jmp    8799 <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    8703:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8706:	8b 45 0c             	mov    0xc(%ebp),%eax
    8709:	8b 00                	mov    (%eax),%eax
    870b:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    870e:	51                   	push   %ecx
    870f:	52                   	push   %edx
    8710:	50                   	push   %eax
    8711:	e8 d1 ac ff ff       	call   33e7 <lodepng_addofl>
    8716:	83 c4 0c             	add    $0xc,%esp
    8719:	85 c0                	test   %eax,%eax
    871b:	74 07                	je     8724 <lodepng_chunk_append+0x51>
    871d:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8722:	eb 75                	jmp    8799 <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    8724:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8727:	8b 45 08             	mov    0x8(%ebp),%eax
    872a:	8b 00                	mov    (%eax),%eax
    872c:	52                   	push   %edx
    872d:	50                   	push   %eax
    872e:	e8 07 ac ff ff       	call   333a <lodepng_realloc>
    8733:	83 c4 08             	add    $0x8,%esp
    8736:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    8739:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    873d:	75 07                	jne    8746 <lodepng_chunk_append+0x73>
    873f:	b8 53 00 00 00       	mov    $0x53,%eax
    8744:	eb 53                	jmp    8799 <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    8746:	8b 45 08             	mov    0x8(%ebp),%eax
    8749:	8b 55 f8             	mov    -0x8(%ebp),%edx
    874c:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    874e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8751:	8b 45 0c             	mov    0xc(%ebp),%eax
    8754:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    8756:	8b 45 08             	mov    0x8(%ebp),%eax
    8759:	8b 00                	mov    (%eax),%eax
    875b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    875e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8761:	29 d1                	sub    %edx,%ecx
    8763:	89 ca                	mov    %ecx,%edx
    8765:	01 d0                	add    %edx,%eax
    8767:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    876a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8771:	eb 19                	jmp    878c <lodepng_chunk_append+0xb9>
    8773:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8776:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8779:	01 c2                	add    %eax,%edx
    877b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    877e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8781:	01 c8                	add    %ecx,%eax
    8783:	0f b6 00             	movzbl (%eax),%eax
    8786:	88 02                	mov    %al,(%edx)
    8788:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    878c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    878f:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    8792:	75 df                	jne    8773 <lodepng_chunk_append+0xa0>

  return 0;
    8794:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8799:	c9                   	leave  
    879a:	c3                   	ret    

0000879b <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    879b:	55                   	push   %ebp
    879c:	89 e5                	mov    %esp,%ebp
    879e:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    87a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    87a4:	8b 40 04             	mov    0x4(%eax),%eax
    87a7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    87aa:	8b 55 10             	mov    0x10(%ebp),%edx
    87ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87b0:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    87b3:	51                   	push   %ecx
    87b4:	52                   	push   %edx
    87b5:	50                   	push   %eax
    87b6:	e8 2c ac ff ff       	call   33e7 <lodepng_addofl>
    87bb:	83 c4 0c             	add    $0xc,%esp
    87be:	85 c0                	test   %eax,%eax
    87c0:	74 07                	je     87c9 <lodepng_chunk_init+0x2e>
    87c2:	b8 4d 00 00 00       	mov    $0x4d,%eax
    87c7:	eb 78                	jmp    8841 <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    87c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87cc:	8d 55 fc             	lea    -0x4(%ebp),%edx
    87cf:	52                   	push   %edx
    87d0:	6a 0c                	push   $0xc
    87d2:	50                   	push   %eax
    87d3:	e8 0f ac ff ff       	call   33e7 <lodepng_addofl>
    87d8:	83 c4 0c             	add    $0xc,%esp
    87db:	85 c0                	test   %eax,%eax
    87dd:	74 07                	je     87e6 <lodepng_chunk_init+0x4b>
    87df:	b8 4d 00 00 00       	mov    $0x4d,%eax
    87e4:	eb 5b                	jmp    8841 <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    87e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87e9:	50                   	push   %eax
    87ea:	ff 75 0c             	pushl  0xc(%ebp)
    87ed:	e8 8b ad ff ff       	call   357d <ucvector_resize>
    87f2:	83 c4 08             	add    $0x8,%esp
    87f5:	85 c0                	test   %eax,%eax
    87f7:	75 07                	jne    8800 <lodepng_chunk_init+0x65>
    87f9:	b8 53 00 00 00       	mov    $0x53,%eax
    87fe:	eb 41                	jmp    8841 <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    8800:	8b 45 0c             	mov    0xc(%ebp),%eax
    8803:	8b 00                	mov    (%eax),%eax
    8805:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8808:	2b 55 10             	sub    0x10(%ebp),%edx
    880b:	83 ea 0c             	sub    $0xc,%edx
    880e:	01 c2                	add    %eax,%edx
    8810:	8b 45 08             	mov    0x8(%ebp),%eax
    8813:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    8815:	8b 45 08             	mov    0x8(%ebp),%eax
    8818:	8b 00                	mov    (%eax),%eax
    881a:	ff 75 10             	pushl  0x10(%ebp)
    881d:	50                   	push   %eax
    881e:	e8 c1 ae ff ff       	call   36e4 <lodepng_set32bitInt>
    8823:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    8826:	8b 45 08             	mov    0x8(%ebp),%eax
    8829:	8b 00                	mov    (%eax),%eax
    882b:	83 c0 04             	add    $0x4,%eax
    882e:	6a 04                	push   $0x4
    8830:	ff 75 14             	pushl  0x14(%ebp)
    8833:	50                   	push   %eax
    8834:	e8 28 ab ff ff       	call   3361 <lodepng_memcpy>
    8839:	83 c4 0c             	add    $0xc,%esp

  return 0;
    883c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8841:	c9                   	leave  
    8842:	c3                   	ret    

00008843 <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    8843:	55                   	push   %ebp
    8844:	89 e5                	mov    %esp,%ebp
    8846:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    8849:	ff 75 10             	pushl  0x10(%ebp)
    884c:	ff 75 0c             	pushl  0xc(%ebp)
    884f:	ff 75 08             	pushl  0x8(%ebp)
    8852:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8855:	50                   	push   %eax
    8856:	e8 40 ff ff ff       	call   879b <lodepng_chunk_init>
    885b:	83 c4 10             	add    $0x10,%esp
    885e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    8861:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    8865:	74 05                	je     886c <lodepng_chunk_createv+0x29>
    8867:	8b 45 fc             	mov    -0x4(%ebp),%eax
    886a:	eb 27                	jmp    8893 <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    886c:	8b 45 0c             	mov    0xc(%ebp),%eax
    886f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8872:	83 c2 08             	add    $0x8,%edx
    8875:	50                   	push   %eax
    8876:	ff 75 14             	pushl  0x14(%ebp)
    8879:	52                   	push   %edx
    887a:	e8 e2 aa ff ff       	call   3361 <lodepng_memcpy>
    887f:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    8882:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8885:	50                   	push   %eax
    8886:	e8 b9 fb ff ff       	call   8444 <lodepng_chunk_generate_crc>
    888b:	83 c4 04             	add    $0x4,%esp

  return 0;
    888e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8893:	c9                   	leave  
    8894:	c3                   	ret    

00008895 <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    8895:	55                   	push   %ebp
    8896:	89 e5                	mov    %esp,%ebp
    8898:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    889b:	8b 45 0c             	mov    0xc(%ebp),%eax
    889e:	8b 08                	mov    (%eax),%ecx
    88a0:	8b 45 08             	mov    0x8(%ebp),%eax
    88a3:	8b 10                	mov    (%eax),%edx
    88a5:	8d 45 f0             	lea    -0x10(%ebp),%eax
    88a8:	51                   	push   %ecx
    88a9:	52                   	push   %edx
    88aa:	50                   	push   %eax
    88ab:	e8 34 ad ff ff       	call   35e4 <ucvector_init>
    88b0:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    88b3:	ff 75 18             	pushl  0x18(%ebp)
    88b6:	ff 75 14             	pushl  0x14(%ebp)
    88b9:	ff 75 10             	pushl  0x10(%ebp)
    88bc:	8d 45 f0             	lea    -0x10(%ebp),%eax
    88bf:	50                   	push   %eax
    88c0:	e8 7e ff ff ff       	call   8843 <lodepng_chunk_createv>
    88c5:	83 c4 10             	add    $0x10,%esp
    88c8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    88cb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    88ce:	8b 45 08             	mov    0x8(%ebp),%eax
    88d1:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    88d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    88d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    88d9:	89 10                	mov    %edx,(%eax)
  return error;
    88db:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    88de:	c9                   	leave  
    88df:	c3                   	ret    

000088e0 <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    88e0:	55                   	push   %ebp
    88e1:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    88e3:	8b 45 08             	mov    0x8(%ebp),%eax
    88e6:	83 f8 03             	cmp    $0x3,%eax
    88e9:	74 6d                	je     8958 <checkColorValidity+0x78>
    88eb:	83 f8 03             	cmp    $0x3,%eax
    88ee:	77 0e                	ja     88fe <checkColorValidity+0x1e>
    88f0:	85 c0                	test   %eax,%eax
    88f2:	74 28                	je     891c <checkColorValidity+0x3c>
    88f4:	83 f8 02             	cmp    $0x2,%eax
    88f7:	74 4c                	je     8945 <checkColorValidity+0x65>
    88f9:	e9 a6 00 00 00       	jmp    89a4 <checkColorValidity+0xc4>
    88fe:	83 f8 06             	cmp    $0x6,%eax
    8901:	0f 84 83 00 00 00    	je     898a <checkColorValidity+0xaa>
    8907:	3d ff 00 00 00       	cmp    $0xff,%eax
    890c:	0f 84 8b 00 00 00    	je     899d <checkColorValidity+0xbd>
    8912:	83 f8 04             	cmp    $0x4,%eax
    8915:	74 60                	je     8977 <checkColorValidity+0x97>
    8917:	e9 88 00 00 00       	jmp    89a4 <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    891c:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8920:	0f 84 85 00 00 00    	je     89ab <checkColorValidity+0xcb>
    8926:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    892a:	74 7f                	je     89ab <checkColorValidity+0xcb>
    892c:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8930:	74 79                	je     89ab <checkColorValidity+0xcb>
    8932:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8936:	74 73                	je     89ab <checkColorValidity+0xcb>
    8938:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    893c:	74 6d                	je     89ab <checkColorValidity+0xcb>
    893e:	b8 25 00 00 00       	mov    $0x25,%eax
    8943:	eb 78                	jmp    89bd <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8945:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8949:	74 63                	je     89ae <checkColorValidity+0xce>
    894b:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    894f:	74 5d                	je     89ae <checkColorValidity+0xce>
    8951:	b8 25 00 00 00       	mov    $0x25,%eax
    8956:	eb 65                	jmp    89bd <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8958:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    895c:	74 53                	je     89b1 <checkColorValidity+0xd1>
    895e:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8962:	74 4d                	je     89b1 <checkColorValidity+0xd1>
    8964:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8968:	74 47                	je     89b1 <checkColorValidity+0xd1>
    896a:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    896e:	74 41                	je     89b1 <checkColorValidity+0xd1>
    8970:	b8 25 00 00 00       	mov    $0x25,%eax
    8975:	eb 46                	jmp    89bd <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8977:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    897b:	74 37                	je     89b4 <checkColorValidity+0xd4>
    897d:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8981:	74 31                	je     89b4 <checkColorValidity+0xd4>
    8983:	b8 25 00 00 00       	mov    $0x25,%eax
    8988:	eb 33                	jmp    89bd <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    898a:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    898e:	74 27                	je     89b7 <checkColorValidity+0xd7>
    8990:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8994:	74 21                	je     89b7 <checkColorValidity+0xd7>
    8996:	b8 25 00 00 00       	mov    $0x25,%eax
    899b:	eb 20                	jmp    89bd <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    899d:	b8 1f 00 00 00       	mov    $0x1f,%eax
    89a2:	eb 19                	jmp    89bd <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    89a4:	b8 1f 00 00 00       	mov    $0x1f,%eax
    89a9:	eb 12                	jmp    89bd <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    89ab:	90                   	nop
    89ac:	eb 0a                	jmp    89b8 <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89ae:	90                   	nop
    89af:	eb 07                	jmp    89b8 <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    89b1:	90                   	nop
    89b2:	eb 04                	jmp    89b8 <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89b4:	90                   	nop
    89b5:	eb 01                	jmp    89b8 <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89b7:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    89b8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    89bd:	5d                   	pop    %ebp
    89be:	c3                   	ret    

000089bf <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    89bf:	55                   	push   %ebp
    89c0:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    89c2:	8b 45 08             	mov    0x8(%ebp),%eax
    89c5:	83 f8 03             	cmp    $0x3,%eax
    89c8:	74 31                	je     89fb <getNumColorChannels+0x3c>
    89ca:	83 f8 03             	cmp    $0x3,%eax
    89cd:	77 0b                	ja     89da <getNumColorChannels+0x1b>
    89cf:	85 c0                	test   %eax,%eax
    89d1:	74 1a                	je     89ed <getNumColorChannels+0x2e>
    89d3:	83 f8 02             	cmp    $0x2,%eax
    89d6:	74 1c                	je     89f4 <getNumColorChannels+0x35>
    89d8:	eb 3d                	jmp    8a17 <getNumColorChannels+0x58>
    89da:	83 f8 06             	cmp    $0x6,%eax
    89dd:	74 2a                	je     8a09 <getNumColorChannels+0x4a>
    89df:	3d ff 00 00 00       	cmp    $0xff,%eax
    89e4:	74 2a                	je     8a10 <getNumColorChannels+0x51>
    89e6:	83 f8 04             	cmp    $0x4,%eax
    89e9:	74 17                	je     8a02 <getNumColorChannels+0x43>
    89eb:	eb 2a                	jmp    8a17 <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    89ed:	b8 01 00 00 00       	mov    $0x1,%eax
    89f2:	eb 28                	jmp    8a1c <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    89f4:	b8 03 00 00 00       	mov    $0x3,%eax
    89f9:	eb 21                	jmp    8a1c <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    89fb:	b8 01 00 00 00       	mov    $0x1,%eax
    8a00:	eb 1a                	jmp    8a1c <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    8a02:	b8 02 00 00 00       	mov    $0x2,%eax
    8a07:	eb 13                	jmp    8a1c <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    8a09:	b8 04 00 00 00       	mov    $0x4,%eax
    8a0e:	eb 0c                	jmp    8a1c <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    8a10:	b8 00 00 00 00       	mov    $0x0,%eax
    8a15:	eb 05                	jmp    8a1c <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    8a17:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    8a1c:	5d                   	pop    %ebp
    8a1d:	c3                   	ret    

00008a1e <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    8a1e:	55                   	push   %ebp
    8a1f:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    8a21:	ff 75 08             	pushl  0x8(%ebp)
    8a24:	e8 96 ff ff ff       	call   89bf <getNumColorChannels>
    8a29:	83 c4 04             	add    $0x4,%esp
    8a2c:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    8a30:	c9                   	leave  
    8a31:	c3                   	ret    

00008a32 <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    8a32:	55                   	push   %ebp
    8a33:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    8a35:	8b 45 08             	mov    0x8(%ebp),%eax
    8a38:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    8a3f:	8b 45 08             	mov    0x8(%ebp),%eax
    8a42:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    8a49:	8b 45 08             	mov    0x8(%ebp),%eax
    8a4c:	8b 50 1c             	mov    0x1c(%eax),%edx
    8a4f:	8b 45 08             	mov    0x8(%ebp),%eax
    8a52:	89 50 18             	mov    %edx,0x18(%eax)
    8a55:	8b 45 08             	mov    0x8(%ebp),%eax
    8a58:	8b 50 18             	mov    0x18(%eax),%edx
    8a5b:	8b 45 08             	mov    0x8(%ebp),%eax
    8a5e:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    8a61:	8b 45 08             	mov    0x8(%ebp),%eax
    8a64:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    8a6a:	8b 45 08             	mov    0x8(%ebp),%eax
    8a6d:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    8a74:	8b 45 08             	mov    0x8(%ebp),%eax
    8a77:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8a7e:	8b 45 08             	mov    0x8(%ebp),%eax
    8a81:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8a88:	90                   	nop
    8a89:	5d                   	pop    %ebp
    8a8a:	c3                   	ret    

00008a8b <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    8a8b:	55                   	push   %ebp
    8a8c:	89 e5                	mov    %esp,%ebp
    8a8e:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    8a91:	8b 45 08             	mov    0x8(%ebp),%eax
    8a94:	8b 40 08             	mov    0x8(%eax),%eax
    8a97:	85 c0                	test   %eax,%eax
    8a99:	75 18                	jne    8ab3 <lodepng_color_mode_alloc_palette+0x28>
    8a9b:	83 ec 0c             	sub    $0xc,%esp
    8a9e:	68 00 04 00 00       	push   $0x400
    8aa3:	e8 7b a8 ff ff       	call   3323 <lodepng_malloc>
    8aa8:	83 c4 10             	add    $0x10,%esp
    8aab:	89 c2                	mov    %eax,%edx
    8aad:	8b 45 08             	mov    0x8(%ebp),%eax
    8ab0:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    8ab3:	8b 45 08             	mov    0x8(%ebp),%eax
    8ab6:	8b 40 08             	mov    0x8(%eax),%eax
    8ab9:	85 c0                	test   %eax,%eax
    8abb:	74 65                	je     8b22 <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    8abd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8ac4:	eb 51                	jmp    8b17 <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    8ac6:	8b 45 08             	mov    0x8(%ebp),%eax
    8ac9:	8b 40 08             	mov    0x8(%eax),%eax
    8acc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8acf:	c1 e2 02             	shl    $0x2,%edx
    8ad2:	01 d0                	add    %edx,%eax
    8ad4:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    8ad7:	8b 45 08             	mov    0x8(%ebp),%eax
    8ada:	8b 40 08             	mov    0x8(%eax),%eax
    8add:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8ae0:	c1 e2 02             	shl    $0x2,%edx
    8ae3:	83 c2 01             	add    $0x1,%edx
    8ae6:	01 d0                	add    %edx,%eax
    8ae8:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    8aeb:	8b 45 08             	mov    0x8(%ebp),%eax
    8aee:	8b 40 08             	mov    0x8(%eax),%eax
    8af1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8af4:	c1 e2 02             	shl    $0x2,%edx
    8af7:	83 c2 02             	add    $0x2,%edx
    8afa:	01 d0                	add    %edx,%eax
    8afc:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    8aff:	8b 45 08             	mov    0x8(%ebp),%eax
    8b02:	8b 40 08             	mov    0x8(%eax),%eax
    8b05:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8b08:	c1 e2 02             	shl    $0x2,%edx
    8b0b:	83 c2 03             	add    $0x3,%edx
    8b0e:	01 d0                	add    %edx,%eax
    8b10:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    8b13:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8b17:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    8b1e:	75 a6                	jne    8ac6 <lodepng_color_mode_alloc_palette+0x3b>
    8b20:	eb 01                	jmp    8b23 <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    8b22:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    8b23:	c9                   	leave  
    8b24:	c3                   	ret    

00008b25 <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    8b25:	55                   	push   %ebp
    8b26:	89 e5                	mov    %esp,%ebp
    8b28:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    8b2b:	83 ec 0c             	sub    $0xc,%esp
    8b2e:	ff 75 08             	pushl  0x8(%ebp)
    8b31:	e8 f3 01 00 00       	call   8d29 <lodepng_palette_clear>
    8b36:	83 c4 10             	add    $0x10,%esp
}
    8b39:	90                   	nop
    8b3a:	c9                   	leave  
    8b3b:	c3                   	ret    

00008b3c <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    8b3c:	55                   	push   %ebp
    8b3d:	89 e5                	mov    %esp,%ebp
    8b3f:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    8b42:	83 ec 0c             	sub    $0xc,%esp
    8b45:	ff 75 08             	pushl  0x8(%ebp)
    8b48:	e8 d8 ff ff ff       	call   8b25 <lodepng_color_mode_cleanup>
    8b4d:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    8b50:	83 ec 04             	sub    $0x4,%esp
    8b53:	6a 20                	push   $0x20
    8b55:	ff 75 0c             	pushl  0xc(%ebp)
    8b58:	ff 75 08             	pushl  0x8(%ebp)
    8b5b:	e8 01 a8 ff ff       	call   3361 <lodepng_memcpy>
    8b60:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    8b63:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b66:	8b 40 08             	mov    0x8(%eax),%eax
    8b69:	85 c0                	test   %eax,%eax
    8b6b:	74 5a                	je     8bc7 <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    8b6d:	83 ec 0c             	sub    $0xc,%esp
    8b70:	68 00 04 00 00       	push   $0x400
    8b75:	e8 a9 a7 ff ff       	call   3323 <lodepng_malloc>
    8b7a:	83 c4 10             	add    $0x10,%esp
    8b7d:	89 c2                	mov    %eax,%edx
    8b7f:	8b 45 08             	mov    0x8(%ebp),%eax
    8b82:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    8b85:	8b 45 08             	mov    0x8(%ebp),%eax
    8b88:	8b 40 08             	mov    0x8(%eax),%eax
    8b8b:	85 c0                	test   %eax,%eax
    8b8d:	75 11                	jne    8ba0 <lodepng_color_mode_copy+0x64>
    8b8f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b92:	8b 40 0c             	mov    0xc(%eax),%eax
    8b95:	85 c0                	test   %eax,%eax
    8b97:	74 07                	je     8ba0 <lodepng_color_mode_copy+0x64>
    8b99:	b8 53 00 00 00       	mov    $0x53,%eax
    8b9e:	eb 2c                	jmp    8bcc <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    8ba0:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ba3:	8b 40 0c             	mov    0xc(%eax),%eax
    8ba6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    8bad:	8b 45 0c             	mov    0xc(%ebp),%eax
    8bb0:	8b 50 08             	mov    0x8(%eax),%edx
    8bb3:	8b 45 08             	mov    0x8(%ebp),%eax
    8bb6:	8b 40 08             	mov    0x8(%eax),%eax
    8bb9:	83 ec 04             	sub    $0x4,%esp
    8bbc:	51                   	push   %ecx
    8bbd:	52                   	push   %edx
    8bbe:	50                   	push   %eax
    8bbf:	e8 9d a7 ff ff       	call   3361 <lodepng_memcpy>
    8bc4:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    8bc7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8bcc:	c9                   	leave  
    8bcd:	c3                   	ret    

00008bce <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    8bce:	55                   	push   %ebp
    8bcf:	89 e5                	mov    %esp,%ebp
    8bd1:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    8bd4:	8d 45 e0             	lea    -0x20(%ebp),%eax
    8bd7:	50                   	push   %eax
    8bd8:	e8 55 fe ff ff       	call   8a32 <lodepng_color_mode_init>
    8bdd:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    8be0:	8b 45 0c             	mov    0xc(%ebp),%eax
    8be3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    8be6:	8b 45 10             	mov    0x10(%ebp),%eax
    8be9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    8bec:	8b 45 08             	mov    0x8(%ebp),%eax
    8bef:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8bf2:	89 10                	mov    %edx,(%eax)
    8bf4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8bf7:	89 50 04             	mov    %edx,0x4(%eax)
    8bfa:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8bfd:	89 50 08             	mov    %edx,0x8(%eax)
    8c00:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8c03:	89 50 0c             	mov    %edx,0xc(%eax)
    8c06:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8c09:	89 50 10             	mov    %edx,0x10(%eax)
    8c0c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8c0f:	89 50 14             	mov    %edx,0x14(%eax)
    8c12:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8c15:	89 50 18             	mov    %edx,0x18(%eax)
    8c18:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8c1b:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    8c1e:	8b 45 08             	mov    0x8(%ebp),%eax
    8c21:	c9                   	leave  
    8c22:	c2 04 00             	ret    $0x4

00008c25 <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    8c25:	55                   	push   %ebp
    8c26:	89 e5                	mov    %esp,%ebp
    8c28:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    8c2b:	8b 45 08             	mov    0x8(%ebp),%eax
    8c2e:	8b 10                	mov    (%eax),%edx
    8c30:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c33:	8b 00                	mov    (%eax),%eax
    8c35:	39 c2                	cmp    %eax,%edx
    8c37:	74 0a                	je     8c43 <lodepng_color_mode_equal+0x1e>
    8c39:	b8 00 00 00 00       	mov    $0x0,%eax
    8c3e:	e9 e4 00 00 00       	jmp    8d27 <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    8c43:	8b 45 08             	mov    0x8(%ebp),%eax
    8c46:	8b 50 04             	mov    0x4(%eax),%edx
    8c49:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c4c:	8b 40 04             	mov    0x4(%eax),%eax
    8c4f:	39 c2                	cmp    %eax,%edx
    8c51:	74 0a                	je     8c5d <lodepng_color_mode_equal+0x38>
    8c53:	b8 00 00 00 00       	mov    $0x0,%eax
    8c58:	e9 ca 00 00 00       	jmp    8d27 <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    8c5d:	8b 45 08             	mov    0x8(%ebp),%eax
    8c60:	8b 50 10             	mov    0x10(%eax),%edx
    8c63:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c66:	8b 40 10             	mov    0x10(%eax),%eax
    8c69:	39 c2                	cmp    %eax,%edx
    8c6b:	74 0a                	je     8c77 <lodepng_color_mode_equal+0x52>
    8c6d:	b8 00 00 00 00       	mov    $0x0,%eax
    8c72:	e9 b0 00 00 00       	jmp    8d27 <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    8c77:	8b 45 08             	mov    0x8(%ebp),%eax
    8c7a:	8b 40 10             	mov    0x10(%eax),%eax
    8c7d:	85 c0                	test   %eax,%eax
    8c7f:	74 48                	je     8cc9 <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    8c81:	8b 45 08             	mov    0x8(%ebp),%eax
    8c84:	8b 50 14             	mov    0x14(%eax),%edx
    8c87:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c8a:	8b 40 14             	mov    0x14(%eax),%eax
    8c8d:	39 c2                	cmp    %eax,%edx
    8c8f:	74 0a                	je     8c9b <lodepng_color_mode_equal+0x76>
    8c91:	b8 00 00 00 00       	mov    $0x0,%eax
    8c96:	e9 8c 00 00 00       	jmp    8d27 <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    8c9b:	8b 45 08             	mov    0x8(%ebp),%eax
    8c9e:	8b 50 18             	mov    0x18(%eax),%edx
    8ca1:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ca4:	8b 40 18             	mov    0x18(%eax),%eax
    8ca7:	39 c2                	cmp    %eax,%edx
    8ca9:	74 07                	je     8cb2 <lodepng_color_mode_equal+0x8d>
    8cab:	b8 00 00 00 00       	mov    $0x0,%eax
    8cb0:	eb 75                	jmp    8d27 <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    8cb2:	8b 45 08             	mov    0x8(%ebp),%eax
    8cb5:	8b 50 1c             	mov    0x1c(%eax),%edx
    8cb8:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cbb:	8b 40 1c             	mov    0x1c(%eax),%eax
    8cbe:	39 c2                	cmp    %eax,%edx
    8cc0:	74 07                	je     8cc9 <lodepng_color_mode_equal+0xa4>
    8cc2:	b8 00 00 00 00       	mov    $0x0,%eax
    8cc7:	eb 5e                	jmp    8d27 <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    8cc9:	8b 45 08             	mov    0x8(%ebp),%eax
    8ccc:	8b 50 0c             	mov    0xc(%eax),%edx
    8ccf:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cd2:	8b 40 0c             	mov    0xc(%eax),%eax
    8cd5:	39 c2                	cmp    %eax,%edx
    8cd7:	74 07                	je     8ce0 <lodepng_color_mode_equal+0xbb>
    8cd9:	b8 00 00 00 00       	mov    $0x0,%eax
    8cde:	eb 47                	jmp    8d27 <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    8ce0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8ce7:	eb 2b                	jmp    8d14 <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    8ce9:	8b 45 08             	mov    0x8(%ebp),%eax
    8cec:	8b 50 08             	mov    0x8(%eax),%edx
    8cef:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8cf2:	01 d0                	add    %edx,%eax
    8cf4:	0f b6 10             	movzbl (%eax),%edx
    8cf7:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cfa:	8b 48 08             	mov    0x8(%eax),%ecx
    8cfd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8d00:	01 c8                	add    %ecx,%eax
    8d02:	0f b6 00             	movzbl (%eax),%eax
    8d05:	38 c2                	cmp    %al,%dl
    8d07:	74 07                	je     8d10 <lodepng_color_mode_equal+0xeb>
    8d09:	b8 00 00 00 00       	mov    $0x0,%eax
    8d0e:	eb 17                	jmp    8d27 <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    8d10:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8d14:	8b 45 08             	mov    0x8(%ebp),%eax
    8d17:	8b 40 0c             	mov    0xc(%eax),%eax
    8d1a:	c1 e0 02             	shl    $0x2,%eax
    8d1d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8d20:	75 c7                	jne    8ce9 <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    8d22:	b8 01 00 00 00       	mov    $0x1,%eax
}
    8d27:	c9                   	leave  
    8d28:	c3                   	ret    

00008d29 <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    8d29:	55                   	push   %ebp
    8d2a:	89 e5                	mov    %esp,%ebp
    8d2c:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    8d2f:	8b 45 08             	mov    0x8(%ebp),%eax
    8d32:	8b 40 08             	mov    0x8(%eax),%eax
    8d35:	85 c0                	test   %eax,%eax
    8d37:	74 12                	je     8d4b <lodepng_palette_clear+0x22>
    8d39:	8b 45 08             	mov    0x8(%ebp),%eax
    8d3c:	8b 40 08             	mov    0x8(%eax),%eax
    8d3f:	83 ec 0c             	sub    $0xc,%esp
    8d42:	50                   	push   %eax
    8d43:	e8 fc a5 ff ff       	call   3344 <lodepng_free>
    8d48:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    8d4b:	8b 45 08             	mov    0x8(%ebp),%eax
    8d4e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8d55:	8b 45 08             	mov    0x8(%ebp),%eax
    8d58:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8d5f:	90                   	nop
    8d60:	c9                   	leave  
    8d61:	c3                   	ret    

00008d62 <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    8d62:	55                   	push   %ebp
    8d63:	89 e5                	mov    %esp,%ebp
    8d65:	53                   	push   %ebx
    8d66:	83 ec 14             	sub    $0x14,%esp
    8d69:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    8d6c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8d6f:	8b 55 14             	mov    0x14(%ebp),%edx
    8d72:	8b 45 18             	mov    0x18(%ebp),%eax
    8d75:	88 5d f4             	mov    %bl,-0xc(%ebp)
    8d78:	88 4d f0             	mov    %cl,-0x10(%ebp)
    8d7b:	88 55 ec             	mov    %dl,-0x14(%ebp)
    8d7e:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    8d81:	8b 45 08             	mov    0x8(%ebp),%eax
    8d84:	8b 40 08             	mov    0x8(%eax),%eax
    8d87:	85 c0                	test   %eax,%eax
    8d89:	75 22                	jne    8dad <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    8d8b:	83 ec 0c             	sub    $0xc,%esp
    8d8e:	ff 75 08             	pushl  0x8(%ebp)
    8d91:	e8 f5 fc ff ff       	call   8a8b <lodepng_color_mode_alloc_palette>
    8d96:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    8d99:	8b 45 08             	mov    0x8(%ebp),%eax
    8d9c:	8b 40 08             	mov    0x8(%eax),%eax
    8d9f:	85 c0                	test   %eax,%eax
    8da1:	75 0a                	jne    8dad <lodepng_palette_add+0x4b>
    8da3:	b8 53 00 00 00       	mov    $0x53,%eax
    8da8:	e9 8d 00 00 00       	jmp    8e3a <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    8dad:	8b 45 08             	mov    0x8(%ebp),%eax
    8db0:	8b 40 0c             	mov    0xc(%eax),%eax
    8db3:	3d ff 00 00 00       	cmp    $0xff,%eax
    8db8:	7e 07                	jle    8dc1 <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    8dba:	b8 6c 00 00 00       	mov    $0x6c,%eax
    8dbf:	eb 79                	jmp    8e3a <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    8dc1:	8b 45 08             	mov    0x8(%ebp),%eax
    8dc4:	8b 50 08             	mov    0x8(%eax),%edx
    8dc7:	8b 45 08             	mov    0x8(%ebp),%eax
    8dca:	8b 40 0c             	mov    0xc(%eax),%eax
    8dcd:	c1 e0 02             	shl    $0x2,%eax
    8dd0:	01 c2                	add    %eax,%edx
    8dd2:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    8dd6:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    8dd8:	8b 45 08             	mov    0x8(%ebp),%eax
    8ddb:	8b 50 08             	mov    0x8(%eax),%edx
    8dde:	8b 45 08             	mov    0x8(%ebp),%eax
    8de1:	8b 40 0c             	mov    0xc(%eax),%eax
    8de4:	c1 e0 02             	shl    $0x2,%eax
    8de7:	83 c0 01             	add    $0x1,%eax
    8dea:	01 c2                	add    %eax,%edx
    8dec:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    8df0:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    8df2:	8b 45 08             	mov    0x8(%ebp),%eax
    8df5:	8b 50 08             	mov    0x8(%eax),%edx
    8df8:	8b 45 08             	mov    0x8(%ebp),%eax
    8dfb:	8b 40 0c             	mov    0xc(%eax),%eax
    8dfe:	c1 e0 02             	shl    $0x2,%eax
    8e01:	83 c0 02             	add    $0x2,%eax
    8e04:	01 c2                	add    %eax,%edx
    8e06:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    8e0a:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    8e0c:	8b 45 08             	mov    0x8(%ebp),%eax
    8e0f:	8b 50 08             	mov    0x8(%eax),%edx
    8e12:	8b 45 08             	mov    0x8(%ebp),%eax
    8e15:	8b 40 0c             	mov    0xc(%eax),%eax
    8e18:	c1 e0 02             	shl    $0x2,%eax
    8e1b:	83 c0 03             	add    $0x3,%eax
    8e1e:	01 c2                	add    %eax,%edx
    8e20:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    8e24:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    8e26:	8b 45 08             	mov    0x8(%ebp),%eax
    8e29:	8b 40 0c             	mov    0xc(%eax),%eax
    8e2c:	8d 50 01             	lea    0x1(%eax),%edx
    8e2f:	8b 45 08             	mov    0x8(%ebp),%eax
    8e32:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    8e35:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8e3a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8e3d:	c9                   	leave  
    8e3e:	c3                   	ret    

00008e3f <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    8e3f:	55                   	push   %ebp
    8e40:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    8e42:	8b 45 08             	mov    0x8(%ebp),%eax
    8e45:	8b 50 04             	mov    0x4(%eax),%edx
    8e48:	8b 45 08             	mov    0x8(%ebp),%eax
    8e4b:	8b 00                	mov    (%eax),%eax
    8e4d:	52                   	push   %edx
    8e4e:	50                   	push   %eax
    8e4f:	e8 ca fb ff ff       	call   8a1e <lodepng_get_bpp_lct>
    8e54:	83 c4 08             	add    $0x8,%esp
}
    8e57:	c9                   	leave  
    8e58:	c3                   	ret    

00008e59 <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    8e59:	55                   	push   %ebp
    8e5a:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    8e5c:	8b 45 08             	mov    0x8(%ebp),%eax
    8e5f:	8b 00                	mov    (%eax),%eax
    8e61:	50                   	push   %eax
    8e62:	e8 58 fb ff ff       	call   89bf <getNumColorChannels>
    8e67:	83 c4 04             	add    $0x4,%esp
}
    8e6a:	c9                   	leave  
    8e6b:	c3                   	ret    

00008e6c <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    8e6c:	55                   	push   %ebp
    8e6d:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    8e6f:	8b 45 08             	mov    0x8(%ebp),%eax
    8e72:	8b 00                	mov    (%eax),%eax
    8e74:	85 c0                	test   %eax,%eax
    8e76:	74 0a                	je     8e82 <lodepng_is_greyscale_type+0x16>
    8e78:	8b 45 08             	mov    0x8(%ebp),%eax
    8e7b:	8b 00                	mov    (%eax),%eax
    8e7d:	83 f8 04             	cmp    $0x4,%eax
    8e80:	75 07                	jne    8e89 <lodepng_is_greyscale_type+0x1d>
    8e82:	b8 01 00 00 00       	mov    $0x1,%eax
    8e87:	eb 05                	jmp    8e8e <lodepng_is_greyscale_type+0x22>
    8e89:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8e8e:	5d                   	pop    %ebp
    8e8f:	c3                   	ret    

00008e90 <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    8e90:	55                   	push   %ebp
    8e91:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    8e93:	8b 45 08             	mov    0x8(%ebp),%eax
    8e96:	8b 00                	mov    (%eax),%eax
    8e98:	83 e0 04             	and    $0x4,%eax
    8e9b:	85 c0                	test   %eax,%eax
    8e9d:	0f 95 c0             	setne  %al
    8ea0:	0f b6 c0             	movzbl %al,%eax
}
    8ea3:	5d                   	pop    %ebp
    8ea4:	c3                   	ret    

00008ea5 <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    8ea5:	55                   	push   %ebp
    8ea6:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    8ea8:	8b 45 08             	mov    0x8(%ebp),%eax
    8eab:	8b 00                	mov    (%eax),%eax
    8ead:	83 f8 03             	cmp    $0x3,%eax
    8eb0:	0f 94 c0             	sete   %al
    8eb3:	0f b6 c0             	movzbl %al,%eax
}
    8eb6:	5d                   	pop    %ebp
    8eb7:	c3                   	ret    

00008eb8 <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    8eb8:	55                   	push   %ebp
    8eb9:	89 e5                	mov    %esp,%ebp
    8ebb:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8ebe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8ec5:	eb 23                	jmp    8eea <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    8ec7:	8b 45 08             	mov    0x8(%ebp),%eax
    8eca:	8b 40 08             	mov    0x8(%eax),%eax
    8ecd:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8ed0:	c1 e2 02             	shl    $0x2,%edx
    8ed3:	83 c2 03             	add    $0x3,%edx
    8ed6:	01 d0                	add    %edx,%eax
    8ed8:	0f b6 00             	movzbl (%eax),%eax
    8edb:	3c ff                	cmp    $0xff,%al
    8edd:	74 07                	je     8ee6 <lodepng_has_palette_alpha+0x2e>
    8edf:	b8 01 00 00 00       	mov    $0x1,%eax
    8ee4:	eb 14                	jmp    8efa <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8ee6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8eea:	8b 45 08             	mov    0x8(%ebp),%eax
    8eed:	8b 40 0c             	mov    0xc(%eax),%eax
    8ef0:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8ef3:	75 d2                	jne    8ec7 <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    8ef5:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8efa:	c9                   	leave  
    8efb:	c3                   	ret    

00008efc <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    8efc:	55                   	push   %ebp
    8efd:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    8eff:	8b 45 08             	mov    0x8(%ebp),%eax
    8f02:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    8f05:	85 c0                	test   %eax,%eax
    8f07:	75 1e                	jne    8f27 <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    8f09:	ff 75 08             	pushl  0x8(%ebp)
    8f0c:	e8 7f ff ff ff       	call   8e90 <lodepng_is_alpha_type>
    8f11:	83 c4 04             	add    $0x4,%esp
    8f14:	85 c0                	test   %eax,%eax
    8f16:	75 0f                	jne    8f27 <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    8f18:	ff 75 08             	pushl  0x8(%ebp)
    8f1b:	e8 98 ff ff ff       	call   8eb8 <lodepng_has_palette_alpha>
    8f20:	83 c4 04             	add    $0x4,%esp
    8f23:	85 c0                	test   %eax,%eax
    8f25:	74 07                	je     8f2e <lodepng_can_have_alpha+0x32>
    8f27:	b8 01 00 00 00       	mov    $0x1,%eax
    8f2c:	eb 05                	jmp    8f33 <lodepng_can_have_alpha+0x37>
    8f2e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f33:	c9                   	leave  
    8f34:	c3                   	ret    

00008f35 <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    8f35:	55                   	push   %ebp
    8f36:	89 e5                	mov    %esp,%ebp
    8f38:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    8f3b:	ff 75 14             	pushl  0x14(%ebp)
    8f3e:	ff 75 10             	pushl  0x10(%ebp)
    8f41:	e8 d8 fa ff ff       	call   8a1e <lodepng_get_bpp_lct>
    8f46:	83 c4 08             	add    $0x8,%esp
    8f49:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    8f4c:	8b 55 08             	mov    0x8(%ebp),%edx
    8f4f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f52:	0f af c2             	imul   %edx,%eax
    8f55:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    8f58:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8f5b:	c1 e8 03             	shr    $0x3,%eax
    8f5e:	89 c2                	mov    %eax,%edx
    8f60:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8f63:	0f af c2             	imul   %edx,%eax
    8f66:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8f69:	89 d1                	mov    %edx,%ecx
    8f6b:	83 e1 07             	and    $0x7,%ecx
    8f6e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8f71:	0f af d1             	imul   %ecx,%edx
    8f74:	83 c2 07             	add    $0x7,%edx
    8f77:	c1 ea 03             	shr    $0x3,%edx
    8f7a:	01 d0                	add    %edx,%eax
}
    8f7c:	c9                   	leave  
    8f7d:	c3                   	ret    

00008f7e <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    8f7e:	55                   	push   %ebp
    8f7f:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    8f81:	8b 45 10             	mov    0x10(%ebp),%eax
    8f84:	8b 50 04             	mov    0x4(%eax),%edx
    8f87:	8b 45 10             	mov    0x10(%ebp),%eax
    8f8a:	8b 00                	mov    (%eax),%eax
    8f8c:	52                   	push   %edx
    8f8d:	50                   	push   %eax
    8f8e:	ff 75 0c             	pushl  0xc(%ebp)
    8f91:	ff 75 08             	pushl  0x8(%ebp)
    8f94:	e8 9c ff ff ff       	call   8f35 <lodepng_get_raw_size_lct>
    8f99:	83 c4 10             	add    $0x10,%esp
}
    8f9c:	c9                   	leave  
    8f9d:	c3                   	ret    

00008f9e <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    8f9e:	55                   	push   %ebp
    8f9f:	89 e5                	mov    %esp,%ebp
    8fa1:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    8fa4:	8b 45 08             	mov    0x8(%ebp),%eax
    8fa7:	c1 e8 03             	shr    $0x3,%eax
    8faa:	0f af 45 10          	imul   0x10(%ebp),%eax
    8fae:	8b 55 08             	mov    0x8(%ebp),%edx
    8fb1:	83 e2 07             	and    $0x7,%edx
    8fb4:	0f af 55 10          	imul   0x10(%ebp),%edx
    8fb8:	83 c2 07             	add    $0x7,%edx
    8fbb:	c1 ea 03             	shr    $0x3,%edx
    8fbe:	01 d0                	add    %edx,%eax
    8fc0:	83 c0 01             	add    $0x1,%eax
    8fc3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    8fc6:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fc9:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    8fcd:	c9                   	leave  
    8fce:	c3                   	ret    

00008fcf <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    8fcf:	55                   	push   %ebp
    8fd0:	89 e5                	mov    %esp,%ebp
    8fd2:	53                   	push   %ebx
    8fd3:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    8fd6:	ff 75 10             	pushl  0x10(%ebp)
    8fd9:	e8 61 fe ff ff       	call   8e3f <lodepng_get_bpp>
    8fde:	83 c4 04             	add    $0x4,%esp
    8fe1:	89 c3                	mov    %eax,%ebx
    8fe3:	ff 75 14             	pushl  0x14(%ebp)
    8fe6:	e8 54 fe ff ff       	call   8e3f <lodepng_get_bpp>
    8feb:	83 c4 04             	add    $0x4,%esp
    8fee:	39 c3                	cmp    %eax,%ebx
    8ff0:	76 0d                	jbe    8fff <lodepng_pixel_overflow+0x30>
    8ff2:	ff 75 10             	pushl  0x10(%ebp)
    8ff5:	e8 45 fe ff ff       	call   8e3f <lodepng_get_bpp>
    8ffa:	83 c4 04             	add    $0x4,%esp
    8ffd:	eb 0b                	jmp    900a <lodepng_pixel_overflow+0x3b>
    8fff:	ff 75 14             	pushl  0x14(%ebp)
    9002:	e8 38 fe ff ff       	call   8e3f <lodepng_get_bpp>
    9007:	83 c4 04             	add    $0x4,%esp
    900a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    900d:	8b 55 0c             	mov    0xc(%ebp),%edx
    9010:	8b 45 08             	mov    0x8(%ebp),%eax
    9013:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    9016:	51                   	push   %ecx
    9017:	52                   	push   %edx
    9018:	50                   	push   %eax
    9019:	e8 e9 a3 ff ff       	call   3407 <lodepng_mulofl>
    901e:	83 c4 0c             	add    $0xc,%esp
    9021:	85 c0                	test   %eax,%eax
    9023:	74 0a                	je     902f <lodepng_pixel_overflow+0x60>
    9025:	b8 01 00 00 00       	mov    $0x1,%eax
    902a:	e9 b6 00 00 00       	jmp    90e5 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    902f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9032:	8d 55 f0             	lea    -0x10(%ebp),%edx
    9035:	52                   	push   %edx
    9036:	6a 08                	push   $0x8
    9038:	50                   	push   %eax
    9039:	e8 c9 a3 ff ff       	call   3407 <lodepng_mulofl>
    903e:	83 c4 0c             	add    $0xc,%esp
    9041:	85 c0                	test   %eax,%eax
    9043:	74 0a                	je     904f <lodepng_pixel_overflow+0x80>
    9045:	b8 01 00 00 00       	mov    $0x1,%eax
    904a:	e9 96 00 00 00       	jmp    90e5 <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    904f:	8b 45 08             	mov    0x8(%ebp),%eax
    9052:	c1 e8 03             	shr    $0x3,%eax
    9055:	89 c2                	mov    %eax,%edx
    9057:	8d 45 ec             	lea    -0x14(%ebp),%eax
    905a:	50                   	push   %eax
    905b:	ff 75 f8             	pushl  -0x8(%ebp)
    905e:	52                   	push   %edx
    905f:	e8 a3 a3 ff ff       	call   3407 <lodepng_mulofl>
    9064:	83 c4 0c             	add    $0xc,%esp
    9067:	85 c0                	test   %eax,%eax
    9069:	74 07                	je     9072 <lodepng_pixel_overflow+0xa3>
    906b:	b8 01 00 00 00       	mov    $0x1,%eax
    9070:	eb 73                	jmp    90e5 <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    9072:	8b 45 08             	mov    0x8(%ebp),%eax
    9075:	83 e0 07             	and    $0x7,%eax
    9078:	89 c2                	mov    %eax,%edx
    907a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    907d:	0f af c2             	imul   %edx,%eax
    9080:	83 c0 07             	add    $0x7,%eax
    9083:	c1 e8 03             	shr    $0x3,%eax
    9086:	89 c1                	mov    %eax,%ecx
    9088:	8b 45 ec             	mov    -0x14(%ebp),%eax
    908b:	8d 55 ec             	lea    -0x14(%ebp),%edx
    908e:	52                   	push   %edx
    908f:	51                   	push   %ecx
    9090:	50                   	push   %eax
    9091:	e8 51 a3 ff ff       	call   33e7 <lodepng_addofl>
    9096:	83 c4 0c             	add    $0xc,%esp
    9099:	85 c0                	test   %eax,%eax
    909b:	74 07                	je     90a4 <lodepng_pixel_overflow+0xd5>
    909d:	b8 01 00 00 00       	mov    $0x1,%eax
    90a2:	eb 41                	jmp    90e5 <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    90a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    90a7:	8d 55 ec             	lea    -0x14(%ebp),%edx
    90aa:	52                   	push   %edx
    90ab:	6a 05                	push   $0x5
    90ad:	50                   	push   %eax
    90ae:	e8 34 a3 ff ff       	call   33e7 <lodepng_addofl>
    90b3:	83 c4 0c             	add    $0xc,%esp
    90b6:	85 c0                	test   %eax,%eax
    90b8:	74 07                	je     90c1 <lodepng_pixel_overflow+0xf2>
    90ba:	b8 01 00 00 00       	mov    $0x1,%eax
    90bf:	eb 24                	jmp    90e5 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    90c1:	8b 55 0c             	mov    0xc(%ebp),%edx
    90c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    90c7:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    90ca:	51                   	push   %ecx
    90cb:	52                   	push   %edx
    90cc:	50                   	push   %eax
    90cd:	e8 35 a3 ff ff       	call   3407 <lodepng_mulofl>
    90d2:	83 c4 0c             	add    $0xc,%esp
    90d5:	85 c0                	test   %eax,%eax
    90d7:	74 07                	je     90e0 <lodepng_pixel_overflow+0x111>
    90d9:	b8 01 00 00 00       	mov    $0x1,%eax
    90de:	eb 05                	jmp    90e5 <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    90e0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    90e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    90e8:	c9                   	leave  
    90e9:	c3                   	ret    

000090ea <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    90ea:	55                   	push   %ebp
    90eb:	89 e5                	mov    %esp,%ebp
    90ed:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    90f0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    90f7:	eb 15                	jmp    910e <LodePNGUnknownChunks_init+0x24>
    90f9:	8b 45 08             	mov    0x8(%ebp),%eax
    90fc:	8b 55 fc             	mov    -0x4(%ebp),%edx
    90ff:	83 c2 30             	add    $0x30,%edx
    9102:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    9109:	00 
    910a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    910e:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    9112:	75 e5                	jne    90f9 <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    9114:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    911b:	eb 15                	jmp    9132 <LodePNGUnknownChunks_init+0x48>
    911d:	8b 45 08             	mov    0x8(%ebp),%eax
    9120:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9123:	83 c2 34             	add    $0x34,%edx
    9126:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    912d:	00 
    912e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9132:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    9136:	75 e5                	jne    911d <LodePNGUnknownChunks_init+0x33>
}
    9138:	90                   	nop
    9139:	c9                   	leave  
    913a:	c3                   	ret    

0000913b <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    913b:	55                   	push   %ebp
    913c:	89 e5                	mov    %esp,%ebp
    913e:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    9141:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9148:	eb 1d                	jmp    9167 <LodePNGUnknownChunks_cleanup+0x2c>
    914a:	8b 45 08             	mov    0x8(%ebp),%eax
    914d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9150:	83 c2 30             	add    $0x30,%edx
    9153:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    9157:	83 ec 0c             	sub    $0xc,%esp
    915a:	50                   	push   %eax
    915b:	e8 e4 a1 ff ff       	call   3344 <lodepng_free>
    9160:	83 c4 10             	add    $0x10,%esp
    9163:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9167:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    916b:	75 dd                	jne    914a <LodePNGUnknownChunks_cleanup+0xf>
}
    916d:	90                   	nop
    916e:	c9                   	leave  
    916f:	c3                   	ret    

00009170 <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    9170:	55                   	push   %ebp
    9171:	89 e5                	mov    %esp,%ebp
    9173:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    9176:	83 ec 0c             	sub    $0xc,%esp
    9179:	ff 75 08             	pushl  0x8(%ebp)
    917c:	e8 ba ff ff ff       	call   913b <LodePNGUnknownChunks_cleanup>
    9181:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    9184:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    918b:	e9 b7 00 00 00       	jmp    9247 <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    9190:	8b 45 0c             	mov    0xc(%ebp),%eax
    9193:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9196:	83 c2 34             	add    $0x34,%edx
    9199:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    919d:	8b 45 08             	mov    0x8(%ebp),%eax
    91a0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    91a3:	83 c1 34             	add    $0x34,%ecx
    91a6:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    91aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    91ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91b0:	83 c2 34             	add    $0x34,%edx
    91b3:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    91b7:	83 ec 0c             	sub    $0xc,%esp
    91ba:	50                   	push   %eax
    91bb:	e8 63 a1 ff ff       	call   3323 <lodepng_malloc>
    91c0:	83 c4 10             	add    $0x10,%esp
    91c3:	89 c1                	mov    %eax,%ecx
    91c5:	8b 45 08             	mov    0x8(%ebp),%eax
    91c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91cb:	83 c2 30             	add    $0x30,%edx
    91ce:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    91d2:	8b 45 08             	mov    0x8(%ebp),%eax
    91d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91d8:	83 c2 30             	add    $0x30,%edx
    91db:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    91df:	85 c0                	test   %eax,%eax
    91e1:	75 18                	jne    91fb <LodePNGUnknownChunks_copy+0x8b>
    91e3:	8b 45 08             	mov    0x8(%ebp),%eax
    91e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91e9:	83 c2 34             	add    $0x34,%edx
    91ec:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    91f0:	85 c0                	test   %eax,%eax
    91f2:	74 07                	je     91fb <LodePNGUnknownChunks_copy+0x8b>
    91f4:	b8 53 00 00 00       	mov    $0x53,%eax
    91f9:	eb 5b                	jmp    9256 <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    91fb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    9202:	eb 2d                	jmp    9231 <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    9204:	8b 45 08             	mov    0x8(%ebp),%eax
    9207:	8b 55 f4             	mov    -0xc(%ebp),%edx
    920a:	83 c2 30             	add    $0x30,%edx
    920d:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    9211:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9214:	01 c2                	add    %eax,%edx
    9216:	8b 45 0c             	mov    0xc(%ebp),%eax
    9219:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    921c:	83 c1 30             	add    $0x30,%ecx
    921f:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    9223:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9226:	01 c8                	add    %ecx,%eax
    9228:	0f b6 00             	movzbl (%eax),%eax
    922b:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    922d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    9231:	8b 45 0c             	mov    0xc(%ebp),%eax
    9234:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9237:	83 c2 34             	add    $0x34,%edx
    923a:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    923e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    9241:	7f c1                	jg     9204 <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    9243:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9247:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    924b:	0f 85 3f ff ff ff    	jne    9190 <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    9251:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9256:	c9                   	leave  
    9257:	c3                   	ret    

00009258 <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    9258:	55                   	push   %ebp
    9259:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    925b:	8b 45 08             	mov    0x8(%ebp),%eax
    925e:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    9265:	8b 45 08             	mov    0x8(%ebp),%eax
    9268:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    926f:	8b 45 08             	mov    0x8(%ebp),%eax
    9272:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    9279:	90                   	nop
    927a:	5d                   	pop    %ebp
    927b:	c3                   	ret    

0000927c <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    927c:	55                   	push   %ebp
    927d:	89 e5                	mov    %esp,%ebp
    927f:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9282:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9289:	eb 38                	jmp    92c3 <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    928b:	8b 45 08             	mov    0x8(%ebp),%eax
    928e:	8b 40 40             	mov    0x40(%eax),%eax
    9291:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9294:	c1 e2 02             	shl    $0x2,%edx
    9297:	01 d0                	add    %edx,%eax
    9299:	83 ec 0c             	sub    $0xc,%esp
    929c:	50                   	push   %eax
    929d:	e8 75 a3 ff ff       	call   3617 <string_cleanup>
    92a2:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    92a5:	8b 45 08             	mov    0x8(%ebp),%eax
    92a8:	8b 40 44             	mov    0x44(%eax),%eax
    92ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92ae:	c1 e2 02             	shl    $0x2,%edx
    92b1:	01 d0                	add    %edx,%eax
    92b3:	83 ec 0c             	sub    $0xc,%esp
    92b6:	50                   	push   %eax
    92b7:	e8 5b a3 ff ff       	call   3617 <string_cleanup>
    92bc:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    92bf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    92c3:	8b 45 08             	mov    0x8(%ebp),%eax
    92c6:	8b 40 3c             	mov    0x3c(%eax),%eax
    92c9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    92cc:	75 bd                	jne    928b <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    92ce:	8b 45 08             	mov    0x8(%ebp),%eax
    92d1:	8b 40 40             	mov    0x40(%eax),%eax
    92d4:	83 ec 0c             	sub    $0xc,%esp
    92d7:	50                   	push   %eax
    92d8:	e8 67 a0 ff ff       	call   3344 <lodepng_free>
    92dd:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    92e0:	8b 45 08             	mov    0x8(%ebp),%eax
    92e3:	8b 40 44             	mov    0x44(%eax),%eax
    92e6:	83 ec 0c             	sub    $0xc,%esp
    92e9:	50                   	push   %eax
    92ea:	e8 55 a0 ff ff       	call   3344 <lodepng_free>
    92ef:	83 c4 10             	add    $0x10,%esp
}
    92f2:	90                   	nop
    92f3:	c9                   	leave  
    92f4:	c3                   	ret    

000092f5 <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    92f5:	55                   	push   %ebp
    92f6:	89 e5                	mov    %esp,%ebp
    92f8:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    92fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    9302:	8b 45 08             	mov    0x8(%ebp),%eax
    9305:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    930c:	8b 45 08             	mov    0x8(%ebp),%eax
    930f:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    9316:	8b 45 08             	mov    0x8(%ebp),%eax
    9319:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    9320:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9327:	eb 42                	jmp    936b <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    9329:	8b 45 0c             	mov    0xc(%ebp),%eax
    932c:	8b 40 44             	mov    0x44(%eax),%eax
    932f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9332:	c1 e2 02             	shl    $0x2,%edx
    9335:	01 d0                	add    %edx,%eax
    9337:	8b 10                	mov    (%eax),%edx
    9339:	8b 45 0c             	mov    0xc(%ebp),%eax
    933c:	8b 40 40             	mov    0x40(%eax),%eax
    933f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9342:	c1 e1 02             	shl    $0x2,%ecx
    9345:	01 c8                	add    %ecx,%eax
    9347:	8b 00                	mov    (%eax),%eax
    9349:	83 ec 04             	sub    $0x4,%esp
    934c:	52                   	push   %edx
    934d:	50                   	push   %eax
    934e:	ff 75 08             	pushl  0x8(%ebp)
    9351:	e8 4d 01 00 00       	call   94a3 <lodepng_add_text>
    9356:	83 c4 10             	add    $0x10,%esp
    9359:	89 45 f0             	mov    %eax,-0x10(%ebp)
    935c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9360:	74 05                	je     9367 <LodePNGText_copy+0x72>
    9362:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9365:	eb 14                	jmp    937b <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    9367:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    936b:	8b 45 0c             	mov    0xc(%ebp),%eax
    936e:	8b 40 3c             	mov    0x3c(%eax),%eax
    9371:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9374:	75 b3                	jne    9329 <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    9376:	b8 00 00 00 00       	mov    $0x0,%eax
}
    937b:	c9                   	leave  
    937c:	c3                   	ret    

0000937d <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    937d:	55                   	push   %ebp
    937e:	89 e5                	mov    %esp,%ebp
    9380:	53                   	push   %ebx
    9381:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    9384:	8b 45 08             	mov    0x8(%ebp),%eax
    9387:	8b 40 3c             	mov    0x3c(%eax),%eax
    938a:	83 c0 01             	add    $0x1,%eax
    938d:	c1 e0 02             	shl    $0x2,%eax
    9390:	89 c2                	mov    %eax,%edx
    9392:	8b 45 08             	mov    0x8(%ebp),%eax
    9395:	8b 40 40             	mov    0x40(%eax),%eax
    9398:	52                   	push   %edx
    9399:	50                   	push   %eax
    939a:	e8 9b 9f ff ff       	call   333a <lodepng_realloc>
    939f:	83 c4 08             	add    $0x8,%esp
    93a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    93a5:	8b 45 08             	mov    0x8(%ebp),%eax
    93a8:	8b 40 3c             	mov    0x3c(%eax),%eax
    93ab:	83 c0 01             	add    $0x1,%eax
    93ae:	c1 e0 02             	shl    $0x2,%eax
    93b1:	89 c2                	mov    %eax,%edx
    93b3:	8b 45 08             	mov    0x8(%ebp),%eax
    93b6:	8b 40 44             	mov    0x44(%eax),%eax
    93b9:	52                   	push   %edx
    93ba:	50                   	push   %eax
    93bb:	e8 7a 9f ff ff       	call   333a <lodepng_realloc>
    93c0:	83 c4 08             	add    $0x8,%esp
    93c3:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    93c6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    93ca:	74 09                	je     93d5 <lodepng_add_text_sized+0x58>
    93cc:	8b 45 08             	mov    0x8(%ebp),%eax
    93cf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    93d2:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    93d5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    93d9:	74 09                	je     93e4 <lodepng_add_text_sized+0x67>
    93db:	8b 45 08             	mov    0x8(%ebp),%eax
    93de:	8b 55 f0             	mov    -0x10(%ebp),%edx
    93e1:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    93e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    93e8:	74 06                	je     93f0 <lodepng_add_text_sized+0x73>
    93ea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    93ee:	75 0a                	jne    93fa <lodepng_add_text_sized+0x7d>
    93f0:	b8 53 00 00 00       	mov    $0x53,%eax
    93f5:	e9 a4 00 00 00       	jmp    949e <lodepng_add_text_sized+0x121>

  ++info->text_num;
    93fa:	8b 45 08             	mov    0x8(%ebp),%eax
    93fd:	8b 40 3c             	mov    0x3c(%eax),%eax
    9400:	8d 50 01             	lea    0x1(%eax),%edx
    9403:	8b 45 08             	mov    0x8(%ebp),%eax
    9406:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    9409:	8b 45 08             	mov    0x8(%ebp),%eax
    940c:	8b 50 40             	mov    0x40(%eax),%edx
    940f:	8b 45 08             	mov    0x8(%ebp),%eax
    9412:	8b 40 3c             	mov    0x3c(%eax),%eax
    9415:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    941a:	c1 e0 02             	shl    $0x2,%eax
    941d:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9420:	83 ec 0c             	sub    $0xc,%esp
    9423:	ff 75 0c             	pushl  0xc(%ebp)
    9426:	e8 54 a2 ff ff       	call   367f <alloc_string>
    942b:	83 c4 10             	add    $0x10,%esp
    942e:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    9430:	8b 45 08             	mov    0x8(%ebp),%eax
    9433:	8b 50 44             	mov    0x44(%eax),%edx
    9436:	8b 45 08             	mov    0x8(%ebp),%eax
    9439:	8b 40 3c             	mov    0x3c(%eax),%eax
    943c:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9441:	c1 e0 02             	shl    $0x2,%eax
    9444:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9447:	83 ec 08             	sub    $0x8,%esp
    944a:	ff 75 14             	pushl  0x14(%ebp)
    944d:	ff 75 10             	pushl  0x10(%ebp)
    9450:	e8 e5 a1 ff ff       	call   363a <alloc_string_sized>
    9455:	83 c4 10             	add    $0x10,%esp
    9458:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    945a:	8b 45 08             	mov    0x8(%ebp),%eax
    945d:	8b 50 40             	mov    0x40(%eax),%edx
    9460:	8b 45 08             	mov    0x8(%ebp),%eax
    9463:	8b 40 3c             	mov    0x3c(%eax),%eax
    9466:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    946b:	c1 e0 02             	shl    $0x2,%eax
    946e:	01 d0                	add    %edx,%eax
    9470:	8b 00                	mov    (%eax),%eax
    9472:	85 c0                	test   %eax,%eax
    9474:	74 1c                	je     9492 <lodepng_add_text_sized+0x115>
    9476:	8b 45 08             	mov    0x8(%ebp),%eax
    9479:	8b 50 44             	mov    0x44(%eax),%edx
    947c:	8b 45 08             	mov    0x8(%ebp),%eax
    947f:	8b 40 3c             	mov    0x3c(%eax),%eax
    9482:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9487:	c1 e0 02             	shl    $0x2,%eax
    948a:	01 d0                	add    %edx,%eax
    948c:	8b 00                	mov    (%eax),%eax
    948e:	85 c0                	test   %eax,%eax
    9490:	75 07                	jne    9499 <lodepng_add_text_sized+0x11c>
    9492:	b8 53 00 00 00       	mov    $0x53,%eax
    9497:	eb 05                	jmp    949e <lodepng_add_text_sized+0x121>

  return 0;
    9499:	b8 00 00 00 00       	mov    $0x0,%eax
}
    949e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    94a1:	c9                   	leave  
    94a2:	c3                   	ret    

000094a3 <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    94a3:	55                   	push   %ebp
    94a4:	89 e5                	mov    %esp,%ebp
    94a6:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    94a9:	ff 75 10             	pushl  0x10(%ebp)
    94ac:	e8 0e 9f ff ff       	call   33bf <lodepng_strlen>
    94b1:	83 c4 04             	add    $0x4,%esp
    94b4:	50                   	push   %eax
    94b5:	ff 75 10             	pushl  0x10(%ebp)
    94b8:	ff 75 0c             	pushl  0xc(%ebp)
    94bb:	ff 75 08             	pushl  0x8(%ebp)
    94be:	e8 ba fe ff ff       	call   937d <lodepng_add_text_sized>
    94c3:	83 c4 10             	add    $0x10,%esp
}
    94c6:	c9                   	leave  
    94c7:	c3                   	ret    

000094c8 <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    94c8:	55                   	push   %ebp
    94c9:	89 e5                	mov    %esp,%ebp
    94cb:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    94ce:	83 ec 0c             	sub    $0xc,%esp
    94d1:	ff 75 08             	pushl  0x8(%ebp)
    94d4:	e8 a3 fd ff ff       	call   927c <LodePNGText_cleanup>
    94d9:	83 c4 10             	add    $0x10,%esp
}
    94dc:	90                   	nop
    94dd:	c9                   	leave  
    94de:	c3                   	ret    

000094df <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    94df:	55                   	push   %ebp
    94e0:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    94e2:	8b 45 08             	mov    0x8(%ebp),%eax
    94e5:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    94ec:	8b 45 08             	mov    0x8(%ebp),%eax
    94ef:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    94f6:	8b 45 08             	mov    0x8(%ebp),%eax
    94f9:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    9500:	8b 45 08             	mov    0x8(%ebp),%eax
    9503:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    950a:	8b 45 08             	mov    0x8(%ebp),%eax
    950d:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    9514:	90                   	nop
    9515:	5d                   	pop    %ebp
    9516:	c3                   	ret    

00009517 <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    9517:	55                   	push   %ebp
    9518:	89 e5                	mov    %esp,%ebp
    951a:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    951d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9524:	eb 6c                	jmp    9592 <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    9526:	8b 45 08             	mov    0x8(%ebp),%eax
    9529:	8b 40 4c             	mov    0x4c(%eax),%eax
    952c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    952f:	c1 e2 02             	shl    $0x2,%edx
    9532:	01 d0                	add    %edx,%eax
    9534:	83 ec 0c             	sub    $0xc,%esp
    9537:	50                   	push   %eax
    9538:	e8 da a0 ff ff       	call   3617 <string_cleanup>
    953d:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    9540:	8b 45 08             	mov    0x8(%ebp),%eax
    9543:	8b 40 50             	mov    0x50(%eax),%eax
    9546:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9549:	c1 e2 02             	shl    $0x2,%edx
    954c:	01 d0                	add    %edx,%eax
    954e:	83 ec 0c             	sub    $0xc,%esp
    9551:	50                   	push   %eax
    9552:	e8 c0 a0 ff ff       	call   3617 <string_cleanup>
    9557:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    955a:	8b 45 08             	mov    0x8(%ebp),%eax
    955d:	8b 40 54             	mov    0x54(%eax),%eax
    9560:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9563:	c1 e2 02             	shl    $0x2,%edx
    9566:	01 d0                	add    %edx,%eax
    9568:	83 ec 0c             	sub    $0xc,%esp
    956b:	50                   	push   %eax
    956c:	e8 a6 a0 ff ff       	call   3617 <string_cleanup>
    9571:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    9574:	8b 45 08             	mov    0x8(%ebp),%eax
    9577:	8b 40 58             	mov    0x58(%eax),%eax
    957a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    957d:	c1 e2 02             	shl    $0x2,%edx
    9580:	01 d0                	add    %edx,%eax
    9582:	83 ec 0c             	sub    $0xc,%esp
    9585:	50                   	push   %eax
    9586:	e8 8c a0 ff ff       	call   3617 <string_cleanup>
    958b:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    958e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9592:	8b 45 08             	mov    0x8(%ebp),%eax
    9595:	8b 40 48             	mov    0x48(%eax),%eax
    9598:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    959b:	75 89                	jne    9526 <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    959d:	8b 45 08             	mov    0x8(%ebp),%eax
    95a0:	8b 40 4c             	mov    0x4c(%eax),%eax
    95a3:	83 ec 0c             	sub    $0xc,%esp
    95a6:	50                   	push   %eax
    95a7:	e8 98 9d ff ff       	call   3344 <lodepng_free>
    95ac:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    95af:	8b 45 08             	mov    0x8(%ebp),%eax
    95b2:	8b 40 50             	mov    0x50(%eax),%eax
    95b5:	83 ec 0c             	sub    $0xc,%esp
    95b8:	50                   	push   %eax
    95b9:	e8 86 9d ff ff       	call   3344 <lodepng_free>
    95be:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    95c1:	8b 45 08             	mov    0x8(%ebp),%eax
    95c4:	8b 40 54             	mov    0x54(%eax),%eax
    95c7:	83 ec 0c             	sub    $0xc,%esp
    95ca:	50                   	push   %eax
    95cb:	e8 74 9d ff ff       	call   3344 <lodepng_free>
    95d0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    95d3:	8b 45 08             	mov    0x8(%ebp),%eax
    95d6:	8b 40 58             	mov    0x58(%eax),%eax
    95d9:	83 ec 0c             	sub    $0xc,%esp
    95dc:	50                   	push   %eax
    95dd:	e8 62 9d ff ff       	call   3344 <lodepng_free>
    95e2:	83 c4 10             	add    $0x10,%esp
}
    95e5:	90                   	nop
    95e6:	c9                   	leave  
    95e7:	c3                   	ret    

000095e8 <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    95e8:	55                   	push   %ebp
    95e9:	89 e5                	mov    %esp,%ebp
    95eb:	56                   	push   %esi
    95ec:	53                   	push   %ebx
    95ed:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    95f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    95f7:	8b 45 08             	mov    0x8(%ebp),%eax
    95fa:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    9601:	8b 45 08             	mov    0x8(%ebp),%eax
    9604:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    960b:	8b 45 08             	mov    0x8(%ebp),%eax
    960e:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    9615:	8b 45 08             	mov    0x8(%ebp),%eax
    9618:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    961f:	8b 45 08             	mov    0x8(%ebp),%eax
    9622:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    9629:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9630:	eb 64                	jmp    9696 <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    9632:	8b 45 0c             	mov    0xc(%ebp),%eax
    9635:	8b 40 58             	mov    0x58(%eax),%eax
    9638:	8b 55 f4             	mov    -0xc(%ebp),%edx
    963b:	c1 e2 02             	shl    $0x2,%edx
    963e:	01 d0                	add    %edx,%eax
    9640:	8b 18                	mov    (%eax),%ebx
    9642:	8b 45 0c             	mov    0xc(%ebp),%eax
    9645:	8b 40 54             	mov    0x54(%eax),%eax
    9648:	8b 55 f4             	mov    -0xc(%ebp),%edx
    964b:	c1 e2 02             	shl    $0x2,%edx
    964e:	01 d0                	add    %edx,%eax
    9650:	8b 08                	mov    (%eax),%ecx
    9652:	8b 45 0c             	mov    0xc(%ebp),%eax
    9655:	8b 40 50             	mov    0x50(%eax),%eax
    9658:	8b 55 f4             	mov    -0xc(%ebp),%edx
    965b:	c1 e2 02             	shl    $0x2,%edx
    965e:	01 d0                	add    %edx,%eax
    9660:	8b 10                	mov    (%eax),%edx
    9662:	8b 45 0c             	mov    0xc(%ebp),%eax
    9665:	8b 40 4c             	mov    0x4c(%eax),%eax
    9668:	8b 75 f4             	mov    -0xc(%ebp),%esi
    966b:	c1 e6 02             	shl    $0x2,%esi
    966e:	01 f0                	add    %esi,%eax
    9670:	8b 00                	mov    (%eax),%eax
    9672:	83 ec 0c             	sub    $0xc,%esp
    9675:	53                   	push   %ebx
    9676:	51                   	push   %ecx
    9677:	52                   	push   %edx
    9678:	50                   	push   %eax
    9679:	ff 75 08             	pushl  0x8(%ebp)
    967c:	e8 e4 01 00 00       	call   9865 <lodepng_add_itext>
    9681:	83 c4 20             	add    $0x20,%esp
    9684:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9687:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    968b:	74 05                	je     9692 <LodePNGIText_copy+0xaa>
    968d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9690:	eb 14                	jmp    96a6 <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    9692:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9696:	8b 45 0c             	mov    0xc(%ebp),%eax
    9699:	8b 40 48             	mov    0x48(%eax),%eax
    969c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    969f:	75 91                	jne    9632 <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    96a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    96a6:	8d 65 f8             	lea    -0x8(%ebp),%esp
    96a9:	5b                   	pop    %ebx
    96aa:	5e                   	pop    %esi
    96ab:	5d                   	pop    %ebp
    96ac:	c3                   	ret    

000096ad <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    96ad:	55                   	push   %ebp
    96ae:	89 e5                	mov    %esp,%ebp
    96b0:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    96b3:	83 ec 0c             	sub    $0xc,%esp
    96b6:	ff 75 08             	pushl  0x8(%ebp)
    96b9:	e8 59 fe ff ff       	call   9517 <LodePNGIText_cleanup>
    96be:	83 c4 10             	add    $0x10,%esp
}
    96c1:	90                   	nop
    96c2:	c9                   	leave  
    96c3:	c3                   	ret    

000096c4 <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    96c4:	55                   	push   %ebp
    96c5:	89 e5                	mov    %esp,%ebp
    96c7:	53                   	push   %ebx
    96c8:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    96cb:	8b 45 08             	mov    0x8(%ebp),%eax
    96ce:	8b 40 48             	mov    0x48(%eax),%eax
    96d1:	83 c0 01             	add    $0x1,%eax
    96d4:	c1 e0 02             	shl    $0x2,%eax
    96d7:	89 c2                	mov    %eax,%edx
    96d9:	8b 45 08             	mov    0x8(%ebp),%eax
    96dc:	8b 40 4c             	mov    0x4c(%eax),%eax
    96df:	52                   	push   %edx
    96e0:	50                   	push   %eax
    96e1:	e8 54 9c ff ff       	call   333a <lodepng_realloc>
    96e6:	83 c4 08             	add    $0x8,%esp
    96e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    96ec:	8b 45 08             	mov    0x8(%ebp),%eax
    96ef:	8b 40 48             	mov    0x48(%eax),%eax
    96f2:	83 c0 01             	add    $0x1,%eax
    96f5:	c1 e0 02             	shl    $0x2,%eax
    96f8:	89 c2                	mov    %eax,%edx
    96fa:	8b 45 08             	mov    0x8(%ebp),%eax
    96fd:	8b 40 50             	mov    0x50(%eax),%eax
    9700:	52                   	push   %edx
    9701:	50                   	push   %eax
    9702:	e8 33 9c ff ff       	call   333a <lodepng_realloc>
    9707:	83 c4 08             	add    $0x8,%esp
    970a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    970d:	8b 45 08             	mov    0x8(%ebp),%eax
    9710:	8b 40 48             	mov    0x48(%eax),%eax
    9713:	83 c0 01             	add    $0x1,%eax
    9716:	c1 e0 02             	shl    $0x2,%eax
    9719:	89 c2                	mov    %eax,%edx
    971b:	8b 45 08             	mov    0x8(%ebp),%eax
    971e:	8b 40 54             	mov    0x54(%eax),%eax
    9721:	52                   	push   %edx
    9722:	50                   	push   %eax
    9723:	e8 12 9c ff ff       	call   333a <lodepng_realloc>
    9728:	83 c4 08             	add    $0x8,%esp
    972b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    972e:	8b 45 08             	mov    0x8(%ebp),%eax
    9731:	8b 40 48             	mov    0x48(%eax),%eax
    9734:	83 c0 01             	add    $0x1,%eax
    9737:	c1 e0 02             	shl    $0x2,%eax
    973a:	89 c2                	mov    %eax,%edx
    973c:	8b 45 08             	mov    0x8(%ebp),%eax
    973f:	8b 40 58             	mov    0x58(%eax),%eax
    9742:	52                   	push   %edx
    9743:	50                   	push   %eax
    9744:	e8 f1 9b ff ff       	call   333a <lodepng_realloc>
    9749:	83 c4 08             	add    $0x8,%esp
    974c:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    974f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9753:	74 09                	je     975e <lodepng_add_itext_sized+0x9a>
    9755:	8b 45 08             	mov    0x8(%ebp),%eax
    9758:	8b 55 f4             	mov    -0xc(%ebp),%edx
    975b:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    975e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9762:	74 09                	je     976d <lodepng_add_itext_sized+0xa9>
    9764:	8b 45 08             	mov    0x8(%ebp),%eax
    9767:	8b 55 f0             	mov    -0x10(%ebp),%edx
    976a:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    976d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9771:	74 09                	je     977c <lodepng_add_itext_sized+0xb8>
    9773:	8b 45 08             	mov    0x8(%ebp),%eax
    9776:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9779:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    977c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9780:	74 09                	je     978b <lodepng_add_itext_sized+0xc7>
    9782:	8b 45 08             	mov    0x8(%ebp),%eax
    9785:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9788:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    978b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    978f:	74 12                	je     97a3 <lodepng_add_itext_sized+0xdf>
    9791:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9795:	74 0c                	je     97a3 <lodepng_add_itext_sized+0xdf>
    9797:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    979b:	74 06                	je     97a3 <lodepng_add_itext_sized+0xdf>
    979d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    97a1:	75 0a                	jne    97ad <lodepng_add_itext_sized+0xe9>
    97a3:	b8 53 00 00 00       	mov    $0x53,%eax
    97a8:	e9 b3 00 00 00       	jmp    9860 <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    97ad:	8b 45 08             	mov    0x8(%ebp),%eax
    97b0:	8b 40 48             	mov    0x48(%eax),%eax
    97b3:	8d 50 01             	lea    0x1(%eax),%edx
    97b6:	8b 45 08             	mov    0x8(%ebp),%eax
    97b9:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    97bc:	8b 45 08             	mov    0x8(%ebp),%eax
    97bf:	8b 50 4c             	mov    0x4c(%eax),%edx
    97c2:	8b 45 08             	mov    0x8(%ebp),%eax
    97c5:	8b 40 48             	mov    0x48(%eax),%eax
    97c8:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    97cd:	c1 e0 02             	shl    $0x2,%eax
    97d0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    97d3:	83 ec 0c             	sub    $0xc,%esp
    97d6:	ff 75 0c             	pushl  0xc(%ebp)
    97d9:	e8 a1 9e ff ff       	call   367f <alloc_string>
    97de:	83 c4 10             	add    $0x10,%esp
    97e1:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    97e3:	8b 45 08             	mov    0x8(%ebp),%eax
    97e6:	8b 50 50             	mov    0x50(%eax),%edx
    97e9:	8b 45 08             	mov    0x8(%ebp),%eax
    97ec:	8b 40 48             	mov    0x48(%eax),%eax
    97ef:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    97f4:	c1 e0 02             	shl    $0x2,%eax
    97f7:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    97fa:	83 ec 0c             	sub    $0xc,%esp
    97fd:	ff 75 10             	pushl  0x10(%ebp)
    9800:	e8 7a 9e ff ff       	call   367f <alloc_string>
    9805:	83 c4 10             	add    $0x10,%esp
    9808:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    980a:	8b 45 08             	mov    0x8(%ebp),%eax
    980d:	8b 50 54             	mov    0x54(%eax),%edx
    9810:	8b 45 08             	mov    0x8(%ebp),%eax
    9813:	8b 40 48             	mov    0x48(%eax),%eax
    9816:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    981b:	c1 e0 02             	shl    $0x2,%eax
    981e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9821:	83 ec 0c             	sub    $0xc,%esp
    9824:	ff 75 14             	pushl  0x14(%ebp)
    9827:	e8 53 9e ff ff       	call   367f <alloc_string>
    982c:	83 c4 10             	add    $0x10,%esp
    982f:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    9831:	8b 45 08             	mov    0x8(%ebp),%eax
    9834:	8b 50 58             	mov    0x58(%eax),%edx
    9837:	8b 45 08             	mov    0x8(%ebp),%eax
    983a:	8b 40 48             	mov    0x48(%eax),%eax
    983d:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9842:	c1 e0 02             	shl    $0x2,%eax
    9845:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9848:	83 ec 08             	sub    $0x8,%esp
    984b:	ff 75 1c             	pushl  0x1c(%ebp)
    984e:	ff 75 18             	pushl  0x18(%ebp)
    9851:	e8 e4 9d ff ff       	call   363a <alloc_string_sized>
    9856:	83 c4 10             	add    $0x10,%esp
    9859:	89 03                	mov    %eax,(%ebx)

  return 0;
    985b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9860:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9863:	c9                   	leave  
    9864:	c3                   	ret    

00009865 <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    9865:	55                   	push   %ebp
    9866:	89 e5                	mov    %esp,%ebp
    9868:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    986b:	ff 75 18             	pushl  0x18(%ebp)
    986e:	e8 4c 9b ff ff       	call   33bf <lodepng_strlen>
    9873:	83 c4 04             	add    $0x4,%esp
    9876:	83 ec 08             	sub    $0x8,%esp
    9879:	50                   	push   %eax
    987a:	ff 75 18             	pushl  0x18(%ebp)
    987d:	ff 75 14             	pushl  0x14(%ebp)
    9880:	ff 75 10             	pushl  0x10(%ebp)
    9883:	ff 75 0c             	pushl  0xc(%ebp)
    9886:	ff 75 08             	pushl  0x8(%ebp)
    9889:	e8 36 fe ff ff       	call   96c4 <lodepng_add_itext_sized>
    988e:	83 c4 20             	add    $0x20,%esp
}
    9891:	c9                   	leave  
    9892:	c3                   	ret    

00009893 <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9893:	55                   	push   %ebp
    9894:	89 e5                	mov    %esp,%ebp
    9896:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    9899:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    989d:	75 0a                	jne    98a9 <lodepng_assign_icc+0x16>
    989f:	b8 64 00 00 00       	mov    $0x64,%eax
    98a4:	e9 81 00 00 00       	jmp    992a <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    98a9:	83 ec 0c             	sub    $0xc,%esp
    98ac:	ff 75 0c             	pushl  0xc(%ebp)
    98af:	e8 cb 9d ff ff       	call   367f <alloc_string>
    98b4:	83 c4 10             	add    $0x10,%esp
    98b7:	89 c2                	mov    %eax,%edx
    98b9:	8b 45 08             	mov    0x8(%ebp),%eax
    98bc:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    98c2:	8b 45 14             	mov    0x14(%ebp),%eax
    98c5:	83 ec 0c             	sub    $0xc,%esp
    98c8:	50                   	push   %eax
    98c9:	e8 55 9a ff ff       	call   3323 <lodepng_malloc>
    98ce:	83 c4 10             	add    $0x10,%esp
    98d1:	89 c2                	mov    %eax,%edx
    98d3:	8b 45 08             	mov    0x8(%ebp),%eax
    98d6:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    98dc:	8b 45 08             	mov    0x8(%ebp),%eax
    98df:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    98e5:	85 c0                	test   %eax,%eax
    98e7:	74 0d                	je     98f6 <lodepng_assign_icc+0x63>
    98e9:	8b 45 08             	mov    0x8(%ebp),%eax
    98ec:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    98f2:	85 c0                	test   %eax,%eax
    98f4:	75 07                	jne    98fd <lodepng_assign_icc+0x6a>
    98f6:	b8 53 00 00 00       	mov    $0x53,%eax
    98fb:	eb 2d                	jmp    992a <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    98fd:	8b 55 14             	mov    0x14(%ebp),%edx
    9900:	8b 45 08             	mov    0x8(%ebp),%eax
    9903:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9909:	83 ec 04             	sub    $0x4,%esp
    990c:	52                   	push   %edx
    990d:	ff 75 10             	pushl  0x10(%ebp)
    9910:	50                   	push   %eax
    9911:	e8 4b 9a ff ff       	call   3361 <lodepng_memcpy>
    9916:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    9919:	8b 45 08             	mov    0x8(%ebp),%eax
    991c:	8b 55 14             	mov    0x14(%ebp),%edx
    991f:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    9925:	b8 00 00 00 00       	mov    $0x0,%eax
}
    992a:	c9                   	leave  
    992b:	c3                   	ret    

0000992c <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    992c:	55                   	push   %ebp
    992d:	89 e5                	mov    %esp,%ebp
    992f:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    9932:	8b 45 08             	mov    0x8(%ebp),%eax
    9935:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    993b:	85 c0                	test   %eax,%eax
    993d:	74 0e                	je     994d <lodepng_set_icc+0x21>
    993f:	83 ec 0c             	sub    $0xc,%esp
    9942:	ff 75 08             	pushl  0x8(%ebp)
    9945:	e8 26 00 00 00       	call   9970 <lodepng_clear_icc>
    994a:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    994d:	8b 45 08             	mov    0x8(%ebp),%eax
    9950:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    9957:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    995a:	ff 75 14             	pushl  0x14(%ebp)
    995d:	ff 75 10             	pushl  0x10(%ebp)
    9960:	ff 75 0c             	pushl  0xc(%ebp)
    9963:	ff 75 08             	pushl  0x8(%ebp)
    9966:	e8 28 ff ff ff       	call   9893 <lodepng_assign_icc>
    996b:	83 c4 10             	add    $0x10,%esp
}
    996e:	c9                   	leave  
    996f:	c3                   	ret    

00009970 <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    9970:	55                   	push   %ebp
    9971:	89 e5                	mov    %esp,%ebp
    9973:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    9976:	8b 45 08             	mov    0x8(%ebp),%eax
    9979:	05 c0 00 00 00       	add    $0xc0,%eax
    997e:	83 ec 0c             	sub    $0xc,%esp
    9981:	50                   	push   %eax
    9982:	e8 90 9c ff ff       	call   3617 <string_cleanup>
    9987:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    998a:	8b 45 08             	mov    0x8(%ebp),%eax
    998d:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9993:	83 ec 0c             	sub    $0xc,%esp
    9996:	50                   	push   %eax
    9997:	e8 a8 99 ff ff       	call   3344 <lodepng_free>
    999c:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    999f:	8b 45 08             	mov    0x8(%ebp),%eax
    99a2:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    99a9:	00 00 00 
  info->iccp_profile_size = 0;
    99ac:	8b 45 08             	mov    0x8(%ebp),%eax
    99af:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    99b6:	00 00 00 
  info->iccp_defined = 0;
    99b9:	8b 45 08             	mov    0x8(%ebp),%eax
    99bc:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    99c3:	00 00 00 
}
    99c6:	90                   	nop
    99c7:	c9                   	leave  
    99c8:	c3                   	ret    

000099c9 <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    99c9:	55                   	push   %ebp
    99ca:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    99cc:	8b 45 08             	mov    0x8(%ebp),%eax
    99cf:	83 c0 0c             	add    $0xc,%eax
    99d2:	50                   	push   %eax
    99d3:	e8 5a f0 ff ff       	call   8a32 <lodepng_color_mode_init>
    99d8:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    99db:	8b 45 08             	mov    0x8(%ebp),%eax
    99de:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    99e5:	8b 45 08             	mov    0x8(%ebp),%eax
    99e8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    99ee:	8b 45 08             	mov    0x8(%ebp),%eax
    99f1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    99f8:	8b 45 08             	mov    0x8(%ebp),%eax
    99fb:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    9a02:	8b 45 08             	mov    0x8(%ebp),%eax
    9a05:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    9a0c:	8b 45 08             	mov    0x8(%ebp),%eax
    9a0f:	8b 50 38             	mov    0x38(%eax),%edx
    9a12:	8b 45 08             	mov    0x8(%ebp),%eax
    9a15:	89 50 34             	mov    %edx,0x34(%eax)
    9a18:	8b 45 08             	mov    0x8(%ebp),%eax
    9a1b:	8b 50 34             	mov    0x34(%eax),%edx
    9a1e:	8b 45 08             	mov    0x8(%ebp),%eax
    9a21:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    9a24:	ff 75 08             	pushl  0x8(%ebp)
    9a27:	e8 2c f8 ff ff       	call   9258 <LodePNGText_init>
    9a2c:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    9a2f:	ff 75 08             	pushl  0x8(%ebp)
    9a32:	e8 a8 fa ff ff       	call   94df <LodePNGIText_init>
    9a37:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    9a3a:	8b 45 08             	mov    0x8(%ebp),%eax
    9a3d:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    9a44:	8b 45 08             	mov    0x8(%ebp),%eax
    9a47:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    9a4e:	8b 45 08             	mov    0x8(%ebp),%eax
    9a51:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    9a58:	00 00 00 
  info->chrm_defined = 0;
    9a5b:	8b 45 08             	mov    0x8(%ebp),%eax
    9a5e:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    9a65:	00 00 00 
  info->srgb_defined = 0;
    9a68:	8b 45 08             	mov    0x8(%ebp),%eax
    9a6b:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    9a72:	00 00 00 
  info->iccp_defined = 0;
    9a75:	8b 45 08             	mov    0x8(%ebp),%eax
    9a78:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9a7f:	00 00 00 
  info->iccp_name = NULL;
    9a82:	8b 45 08             	mov    0x8(%ebp),%eax
    9a85:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    9a8c:	00 00 00 
  info->iccp_profile = NULL;
    9a8f:	8b 45 08             	mov    0x8(%ebp),%eax
    9a92:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9a99:	00 00 00 

  LodePNGUnknownChunks_init(info);
    9a9c:	ff 75 08             	pushl  0x8(%ebp)
    9a9f:	e8 46 f6 ff ff       	call   90ea <LodePNGUnknownChunks_init>
    9aa4:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9aa7:	90                   	nop
    9aa8:	c9                   	leave  
    9aa9:	c3                   	ret    

00009aaa <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    9aaa:	55                   	push   %ebp
    9aab:	89 e5                	mov    %esp,%ebp
    9aad:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    9ab0:	8b 45 08             	mov    0x8(%ebp),%eax
    9ab3:	83 c0 0c             	add    $0xc,%eax
    9ab6:	83 ec 0c             	sub    $0xc,%esp
    9ab9:	50                   	push   %eax
    9aba:	e8 66 f0 ff ff       	call   8b25 <lodepng_color_mode_cleanup>
    9abf:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    9ac2:	83 ec 0c             	sub    $0xc,%esp
    9ac5:	ff 75 08             	pushl  0x8(%ebp)
    9ac8:	e8 af f7 ff ff       	call   927c <LodePNGText_cleanup>
    9acd:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    9ad0:	83 ec 0c             	sub    $0xc,%esp
    9ad3:	ff 75 08             	pushl  0x8(%ebp)
    9ad6:	e8 3c fa ff ff       	call   9517 <LodePNGIText_cleanup>
    9adb:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    9ade:	83 ec 0c             	sub    $0xc,%esp
    9ae1:	ff 75 08             	pushl  0x8(%ebp)
    9ae4:	e8 87 fe ff ff       	call   9970 <lodepng_clear_icc>
    9ae9:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    9aec:	83 ec 0c             	sub    $0xc,%esp
    9aef:	ff 75 08             	pushl  0x8(%ebp)
    9af2:	e8 44 f6 ff ff       	call   913b <LodePNGUnknownChunks_cleanup>
    9af7:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9afa:	90                   	nop
    9afb:	c9                   	leave  
    9afc:	c3                   	ret    

00009afd <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9afd:	55                   	push   %ebp
    9afe:	89 e5                	mov    %esp,%ebp
    9b00:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    9b03:	83 ec 0c             	sub    $0xc,%esp
    9b06:	ff 75 08             	pushl  0x8(%ebp)
    9b09:	e8 9c ff ff ff       	call   9aaa <lodepng_info_cleanup>
    9b0e:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    9b11:	83 ec 04             	sub    $0x4,%esp
    9b14:	68 e4 00 00 00       	push   $0xe4
    9b19:	ff 75 0c             	pushl  0xc(%ebp)
    9b1c:	ff 75 08             	pushl  0x8(%ebp)
    9b1f:	e8 3d 98 ff ff       	call   3361 <lodepng_memcpy>
    9b24:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    9b27:	8b 45 08             	mov    0x8(%ebp),%eax
    9b2a:	83 c0 0c             	add    $0xc,%eax
    9b2d:	83 ec 0c             	sub    $0xc,%esp
    9b30:	50                   	push   %eax
    9b31:	e8 fc ee ff ff       	call   8a32 <lodepng_color_mode_init>
    9b36:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    9b39:	8b 45 0c             	mov    0xc(%ebp),%eax
    9b3c:	8d 50 0c             	lea    0xc(%eax),%edx
    9b3f:	8b 45 08             	mov    0x8(%ebp),%eax
    9b42:	83 c0 0c             	add    $0xc,%eax
    9b45:	83 ec 08             	sub    $0x8,%esp
    9b48:	52                   	push   %edx
    9b49:	50                   	push   %eax
    9b4a:	e8 ed ef ff ff       	call   8b3c <lodepng_color_mode_copy>
    9b4f:	83 c4 10             	add    $0x10,%esp
    9b52:	89 45 f4             	mov    %eax,-0xc(%ebp)
    9b55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9b59:	74 08                	je     9b63 <lodepng_info_copy+0x66>
    9b5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9b5e:	e9 b7 00 00 00       	jmp    9c1a <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    9b63:	83 ec 08             	sub    $0x8,%esp
    9b66:	ff 75 0c             	pushl  0xc(%ebp)
    9b69:	ff 75 08             	pushl  0x8(%ebp)
    9b6c:	e8 84 f7 ff ff       	call   92f5 <LodePNGText_copy>
    9b71:	83 c4 10             	add    $0x10,%esp
    9b74:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9b77:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9b7b:	74 08                	je     9b85 <lodepng_info_copy+0x88>
    9b7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9b80:	e9 95 00 00 00       	jmp    9c1a <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    9b85:	83 ec 08             	sub    $0x8,%esp
    9b88:	ff 75 0c             	pushl  0xc(%ebp)
    9b8b:	ff 75 08             	pushl  0x8(%ebp)
    9b8e:	e8 55 fa ff ff       	call   95e8 <LodePNGIText_copy>
    9b93:	83 c4 10             	add    $0x10,%esp
    9b96:	89 45 ec             	mov    %eax,-0x14(%ebp)
    9b99:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9b9d:	74 05                	je     9ba4 <lodepng_info_copy+0xa7>
    9b9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9ba2:	eb 76                	jmp    9c1a <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    9ba4:	8b 45 0c             	mov    0xc(%ebp),%eax
    9ba7:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    9bad:	85 c0                	test   %eax,%eax
    9baf:	74 37                	je     9be8 <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    9bb1:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bb4:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    9bba:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bbd:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    9bc3:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bc6:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9bcc:	51                   	push   %ecx
    9bcd:	52                   	push   %edx
    9bce:	50                   	push   %eax
    9bcf:	ff 75 08             	pushl  0x8(%ebp)
    9bd2:	e8 bc fc ff ff       	call   9893 <lodepng_assign_icc>
    9bd7:	83 c4 10             	add    $0x10,%esp
    9bda:	89 45 e8             	mov    %eax,-0x18(%ebp)
    9bdd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9be1:	74 05                	je     9be8 <lodepng_info_copy+0xeb>
    9be3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9be6:	eb 32                	jmp    9c1a <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    9be8:	83 ec 0c             	sub    $0xc,%esp
    9beb:	ff 75 08             	pushl  0x8(%ebp)
    9bee:	e8 f7 f4 ff ff       	call   90ea <LodePNGUnknownChunks_init>
    9bf3:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    9bf6:	83 ec 08             	sub    $0x8,%esp
    9bf9:	ff 75 0c             	pushl  0xc(%ebp)
    9bfc:	ff 75 08             	pushl  0x8(%ebp)
    9bff:	e8 6c f5 ff ff       	call   9170 <LodePNGUnknownChunks_copy>
    9c04:	83 c4 10             	add    $0x10,%esp
    9c07:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9c0a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    9c0e:	74 05                	je     9c15 <lodepng_info_copy+0x118>
    9c10:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9c13:	eb 05                	jmp    9c1a <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    9c15:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9c1a:	c9                   	leave  
    9c1b:	c3                   	ret    

00009c1c <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    9c1c:	55                   	push   %ebp
    9c1d:	89 e5                	mov    %esp,%ebp
    9c1f:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    9c22:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    9c26:	74 14                	je     9c3c <addColorBits+0x20>
    9c28:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    9c2c:	75 07                	jne    9c35 <addColorBits+0x19>
    9c2e:	b8 03 00 00 00       	mov    $0x3,%eax
    9c33:	eb 0c                	jmp    9c41 <addColorBits+0x25>
    9c35:	b8 01 00 00 00       	mov    $0x1,%eax
    9c3a:	eb 05                	jmp    9c41 <addColorBits+0x25>
    9c3c:	b8 07 00 00 00       	mov    $0x7,%eax
    9c41:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    9c44:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c47:	23 45 fc             	and    -0x4(%ebp),%eax
    9c4a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    9c4d:	8b 45 10             	mov    0x10(%ebp),%eax
    9c50:	ba 01 00 00 00       	mov    $0x1,%edx
    9c55:	89 c1                	mov    %eax,%ecx
    9c57:	d3 e2                	shl    %cl,%edx
    9c59:	89 d0                	mov    %edx,%eax
    9c5b:	83 e8 01             	sub    $0x1,%eax
    9c5e:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    9c61:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9c64:	2b 45 f8             	sub    -0x8(%ebp),%eax
    9c67:	0f af 45 10          	imul   0x10(%ebp),%eax
    9c6b:	89 c1                	mov    %eax,%ecx
    9c6d:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    9c70:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    9c74:	75 18                	jne    9c8e <addColorBits+0x72>
    9c76:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c79:	0f af 45 10          	imul   0x10(%ebp),%eax
    9c7d:	c1 e8 03             	shr    $0x3,%eax
    9c80:	89 c2                	mov    %eax,%edx
    9c82:	8b 45 08             	mov    0x8(%ebp),%eax
    9c85:	01 d0                	add    %edx,%eax
    9c87:	8b 55 14             	mov    0x14(%ebp),%edx
    9c8a:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    9c8c:	eb 1e                	jmp    9cac <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    9c8e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c91:	0f af 45 10          	imul   0x10(%ebp),%eax
    9c95:	c1 e8 03             	shr    $0x3,%eax
    9c98:	8b 55 08             	mov    0x8(%ebp),%edx
    9c9b:	01 c2                	add    %eax,%edx
    9c9d:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9ca0:	01 c8                	add    %ecx,%eax
    9ca2:	0f b6 08             	movzbl (%eax),%ecx
    9ca5:	8b 45 14             	mov    0x14(%ebp),%eax
    9ca8:	09 c8                	or     %ecx,%eax
    9caa:	88 02                	mov    %al,(%edx)
}
    9cac:	90                   	nop
    9cad:	c9                   	leave  
    9cae:	c3                   	ret    

00009caf <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    9caf:	55                   	push   %ebp
    9cb0:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    9cb2:	8b 45 08             	mov    0x8(%ebp),%eax
    9cb5:	6a 40                	push   $0x40
    9cb7:	6a 00                	push   $0x0
    9cb9:	50                   	push   %eax
    9cba:	e8 d5 96 ff ff       	call   3394 <lodepng_memset>
    9cbf:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    9cc2:	8b 45 08             	mov    0x8(%ebp),%eax
    9cc5:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    9ccc:	90                   	nop
    9ccd:	c9                   	leave  
    9cce:	c3                   	ret    

00009ccf <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    9ccf:	55                   	push   %ebp
    9cd0:	89 e5                	mov    %esp,%ebp
    9cd2:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    9cd5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9cdc:	eb 3b                	jmp    9d19 <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    9cde:	8b 45 08             	mov    0x8(%ebp),%eax
    9ce1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9ce4:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9ce7:	85 c0                	test   %eax,%eax
    9ce9:	74 2a                	je     9d15 <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    9ceb:	8b 45 08             	mov    0x8(%ebp),%eax
    9cee:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9cf1:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9cf4:	83 ec 0c             	sub    $0xc,%esp
    9cf7:	50                   	push   %eax
    9cf8:	e8 d2 ff ff ff       	call   9ccf <color_tree_cleanup>
    9cfd:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    9d00:	8b 45 08             	mov    0x8(%ebp),%eax
    9d03:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d06:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9d09:	83 ec 0c             	sub    $0xc,%esp
    9d0c:	50                   	push   %eax
    9d0d:	e8 32 96 ff ff       	call   3344 <lodepng_free>
    9d12:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    9d15:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9d19:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    9d1d:	75 bf                	jne    9cde <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    9d1f:	90                   	nop
    9d20:	c9                   	leave  
    9d21:	c3                   	ret    

00009d22 <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9d22:	55                   	push   %ebp
    9d23:	89 e5                	mov    %esp,%ebp
    9d25:	53                   	push   %ebx
    9d26:	83 ec 20             	sub    $0x20,%esp
    9d29:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9d2c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9d2f:	8b 55 14             	mov    0x14(%ebp),%edx
    9d32:	8b 45 18             	mov    0x18(%ebp),%eax
    9d35:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9d38:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9d3b:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9d3e:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    9d41:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    9d48:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    9d4f:	eb 76                	jmp    9dc7 <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9d51:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    9d55:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d58:	89 c1                	mov    %eax,%ecx
    9d5a:	d3 fa                	sar    %cl,%edx
    9d5c:	89 d0                	mov    %edx,%eax
    9d5e:	83 e0 01             	and    $0x1,%eax
    9d61:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9d64:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9d68:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d6b:	89 c1                	mov    %eax,%ecx
    9d6d:	d3 fa                	sar    %cl,%edx
    9d6f:	89 d0                	mov    %edx,%eax
    9d71:	83 e0 01             	and    $0x1,%eax
    9d74:	01 d8                	add    %ebx,%eax
    9d76:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9d79:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9d7d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d80:	89 c1                	mov    %eax,%ecx
    9d82:	d3 fa                	sar    %cl,%edx
    9d84:	89 d0                	mov    %edx,%eax
    9d86:	83 e0 01             	and    $0x1,%eax
    9d89:	01 d8                	add    %ebx,%eax
    9d8b:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9d8e:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9d92:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d95:	89 c1                	mov    %eax,%ecx
    9d97:	d3 fa                	sar    %cl,%edx
    9d99:	89 d0                	mov    %edx,%eax
    9d9b:	83 e0 01             	and    $0x1,%eax
    9d9e:	01 d8                	add    %ebx,%eax
    9da0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    9da3:	8b 45 08             	mov    0x8(%ebp),%eax
    9da6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9da9:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9dac:	85 c0                	test   %eax,%eax
    9dae:	75 07                	jne    9db7 <color_tree_get+0x95>
    9db0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9db5:	eb 2a                	jmp    9de1 <color_tree_get+0xbf>
    else tree = tree->children[i];
    9db7:	8b 45 08             	mov    0x8(%ebp),%eax
    9dba:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9dbd:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9dc0:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    9dc3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    9dc7:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    9dcb:	7e 84                	jle    9d51 <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    9dcd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    9dd1:	74 08                	je     9ddb <color_tree_get+0xb9>
    9dd3:	8b 45 08             	mov    0x8(%ebp),%eax
    9dd6:	8b 40 40             	mov    0x40(%eax),%eax
    9dd9:	eb 05                	jmp    9de0 <color_tree_get+0xbe>
    9ddb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9de0:	90                   	nop
}
    9de1:	83 c4 20             	add    $0x20,%esp
    9de4:	5b                   	pop    %ebx
    9de5:	5d                   	pop    %ebp
    9de6:	c3                   	ret    

00009de7 <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9de7:	55                   	push   %ebp
    9de8:	89 e5                	mov    %esp,%ebp
    9dea:	53                   	push   %ebx
    9deb:	83 ec 10             	sub    $0x10,%esp
    9dee:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9df1:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9df4:	8b 55 14             	mov    0x14(%ebp),%edx
    9df7:	8b 45 18             	mov    0x18(%ebp),%eax
    9dfa:	88 5d f8             	mov    %bl,-0x8(%ebp)
    9dfd:	88 4d f4             	mov    %cl,-0xc(%ebp)
    9e00:	88 55 f0             	mov    %dl,-0x10(%ebp)
    9e03:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    9e06:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    9e0a:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    9e0e:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    9e12:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    9e16:	53                   	push   %ebx
    9e17:	51                   	push   %ecx
    9e18:	52                   	push   %edx
    9e19:	50                   	push   %eax
    9e1a:	ff 75 08             	pushl  0x8(%ebp)
    9e1d:	e8 00 ff ff ff       	call   9d22 <color_tree_get>
    9e22:	83 c4 14             	add    $0x14,%esp
    9e25:	f7 d0                	not    %eax
    9e27:	c1 e8 1f             	shr    $0x1f,%eax
    9e2a:	0f b6 c0             	movzbl %al,%eax
}
    9e2d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9e30:	c9                   	leave  
    9e31:	c3                   	ret    

00009e32 <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    9e32:	55                   	push   %ebp
    9e33:	89 e5                	mov    %esp,%ebp
    9e35:	53                   	push   %ebx
    9e36:	83 ec 24             	sub    $0x24,%esp
    9e39:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9e3c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9e3f:	8b 55 14             	mov    0x14(%ebp),%edx
    9e42:	8b 45 18             	mov    0x18(%ebp),%eax
    9e45:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    9e48:	88 4d e0             	mov    %cl,-0x20(%ebp)
    9e4b:	88 55 dc             	mov    %dl,-0x24(%ebp)
    9e4e:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9e51:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9e58:	e9 b0 00 00 00       	jmp    9f0d <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9e5d:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9e61:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e64:	89 c1                	mov    %eax,%ecx
    9e66:	d3 fa                	sar    %cl,%edx
    9e68:	89 d0                	mov    %edx,%eax
    9e6a:	83 e0 01             	and    $0x1,%eax
    9e6d:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e70:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9e74:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e77:	89 c1                	mov    %eax,%ecx
    9e79:	d3 fa                	sar    %cl,%edx
    9e7b:	89 d0                	mov    %edx,%eax
    9e7d:	83 e0 01             	and    $0x1,%eax
    9e80:	01 d8                	add    %ebx,%eax
    9e82:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e85:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9e89:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e8c:	89 c1                	mov    %eax,%ecx
    9e8e:	d3 fa                	sar    %cl,%edx
    9e90:	89 d0                	mov    %edx,%eax
    9e92:	83 e0 01             	and    $0x1,%eax
    9e95:	01 d8                	add    %ebx,%eax
    9e97:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e9a:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    9e9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9ea1:	89 c1                	mov    %eax,%ecx
    9ea3:	d3 fa                	sar    %cl,%edx
    9ea5:	89 d0                	mov    %edx,%eax
    9ea7:	83 e0 01             	and    $0x1,%eax
    9eaa:	01 d8                	add    %ebx,%eax
    9eac:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    9eaf:	8b 45 08             	mov    0x8(%ebp),%eax
    9eb2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9eb5:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9eb8:	85 c0                	test   %eax,%eax
    9eba:	75 41                	jne    9efd <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    9ebc:	83 ec 0c             	sub    $0xc,%esp
    9ebf:	6a 44                	push   $0x44
    9ec1:	e8 5d 94 ff ff       	call   3323 <lodepng_malloc>
    9ec6:	83 c4 10             	add    $0x10,%esp
    9ec9:	89 c1                	mov    %eax,%ecx
    9ecb:	8b 45 08             	mov    0x8(%ebp),%eax
    9ece:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ed1:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    9ed4:	8b 45 08             	mov    0x8(%ebp),%eax
    9ed7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9eda:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9edd:	85 c0                	test   %eax,%eax
    9edf:	75 07                	jne    9ee8 <color_tree_add+0xb6>
    9ee1:	b8 53 00 00 00       	mov    $0x53,%eax
    9ee6:	eb 3d                	jmp    9f25 <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    9ee8:	8b 45 08             	mov    0x8(%ebp),%eax
    9eeb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9eee:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9ef1:	83 ec 0c             	sub    $0xc,%esp
    9ef4:	50                   	push   %eax
    9ef5:	e8 b5 fd ff ff       	call   9caf <color_tree_init>
    9efa:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    9efd:	8b 45 08             	mov    0x8(%ebp),%eax
    9f00:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f03:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9f06:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9f09:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9f0d:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    9f11:	0f 8e 46 ff ff ff    	jle    9e5d <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    9f17:	8b 55 1c             	mov    0x1c(%ebp),%edx
    9f1a:	8b 45 08             	mov    0x8(%ebp),%eax
    9f1d:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    9f20:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9f25:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9f28:	c9                   	leave  
    9f29:	c3                   	ret    

00009f2a <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9f2a:	55                   	push   %ebp
    9f2b:	89 e5                	mov    %esp,%ebp
    9f2d:	53                   	push   %ebx
    9f2e:	83 ec 20             	sub    $0x20,%esp
    9f31:	8b 5d 18             	mov    0x18(%ebp),%ebx
    9f34:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    9f37:	8b 55 20             	mov    0x20(%ebp),%edx
    9f3a:	8b 45 24             	mov    0x24(%ebp),%eax
    9f3d:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9f40:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9f43:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9f46:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    9f49:	8b 45 10             	mov    0x10(%ebp),%eax
    9f4c:	8b 00                	mov    (%eax),%eax
    9f4e:	85 c0                	test   %eax,%eax
    9f50:	0f 85 ad 00 00 00    	jne    a003 <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    9f56:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    9f5a:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    9f5d:	8b 45 10             	mov    0x10(%ebp),%eax
    9f60:	8b 40 04             	mov    0x4(%eax),%eax
    9f63:	83 f8 08             	cmp    $0x8,%eax
    9f66:	75 13                	jne    9f7b <rgba8ToPixel+0x51>
    9f68:	8b 55 0c             	mov    0xc(%ebp),%edx
    9f6b:	8b 45 08             	mov    0x8(%ebp),%eax
    9f6e:	01 c2                	add    %eax,%edx
    9f70:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    9f74:	88 02                	mov    %al,(%edx)
    9f76:	e9 b4 03 00 00       	jmp    a32f <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    9f7b:	8b 45 10             	mov    0x10(%ebp),%eax
    9f7e:	8b 40 04             	mov    0x4(%eax),%eax
    9f81:	83 f8 10             	cmp    $0x10,%eax
    9f84:	75 2a                	jne    9fb0 <rgba8ToPixel+0x86>
    9f86:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f89:	01 c0                	add    %eax,%eax
    9f8b:	89 c2                	mov    %eax,%edx
    9f8d:	8b 45 08             	mov    0x8(%ebp),%eax
    9f90:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    9f93:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f96:	01 c0                	add    %eax,%eax
    9f98:	8d 50 01             	lea    0x1(%eax),%edx
    9f9b:	8b 45 08             	mov    0x8(%ebp),%eax
    9f9e:	01 d0                	add    %edx,%eax
    9fa0:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    9fa4:	88 10                	mov    %dl,(%eax)
    9fa6:	0f b6 00             	movzbl (%eax),%eax
    9fa9:	88 01                	mov    %al,(%ecx)
    9fab:	e9 7f 03 00 00       	jmp    a32f <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    9fb0:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    9fb4:	8b 45 10             	mov    0x10(%ebp),%eax
    9fb7:	8b 40 04             	mov    0x4(%eax),%eax
    9fba:	b9 08 00 00 00       	mov    $0x8,%ecx
    9fbf:	29 c1                	sub    %eax,%ecx
    9fc1:	89 c8                	mov    %ecx,%eax
    9fc3:	89 c1                	mov    %eax,%ecx
    9fc5:	d3 ea                	shr    %cl,%edx
    9fc7:	89 d0                	mov    %edx,%eax
    9fc9:	89 c2                	mov    %eax,%edx
    9fcb:	8b 45 10             	mov    0x10(%ebp),%eax
    9fce:	8b 40 04             	mov    0x4(%eax),%eax
    9fd1:	bb 01 00 00 00       	mov    $0x1,%ebx
    9fd6:	89 c1                	mov    %eax,%ecx
    9fd8:	d3 e3                	shl    %cl,%ebx
    9fda:	89 d8                	mov    %ebx,%eax
    9fdc:	83 e8 01             	sub    $0x1,%eax
    9fdf:	21 d0                	and    %edx,%eax
    9fe1:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    9fe4:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    9fe8:	8b 45 10             	mov    0x10(%ebp),%eax
    9feb:	8b 40 04             	mov    0x4(%eax),%eax
    9fee:	52                   	push   %edx
    9fef:	50                   	push   %eax
    9ff0:	ff 75 0c             	pushl  0xc(%ebp)
    9ff3:	ff 75 08             	pushl  0x8(%ebp)
    9ff6:	e8 21 fc ff ff       	call   9c1c <addColorBits>
    9ffb:	83 c4 10             	add    $0x10,%esp
    9ffe:	e9 2c 03 00 00       	jmp    a32f <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    a003:	8b 45 10             	mov    0x10(%ebp),%eax
    a006:	8b 00                	mov    (%eax),%eax
    a008:	83 f8 02             	cmp    $0x2,%eax
    a00b:	0f 85 ee 00 00 00    	jne    a0ff <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    a011:	8b 45 10             	mov    0x10(%ebp),%eax
    a014:	8b 40 04             	mov    0x4(%eax),%eax
    a017:	83 f8 08             	cmp    $0x8,%eax
    a01a:	75 49                	jne    a065 <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    a01c:	8b 55 0c             	mov    0xc(%ebp),%edx
    a01f:	89 d0                	mov    %edx,%eax
    a021:	01 c0                	add    %eax,%eax
    a023:	01 d0                	add    %edx,%eax
    a025:	89 c2                	mov    %eax,%edx
    a027:	8b 45 08             	mov    0x8(%ebp),%eax
    a02a:	01 c2                	add    %eax,%edx
    a02c:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a030:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    a032:	8b 55 0c             	mov    0xc(%ebp),%edx
    a035:	89 d0                	mov    %edx,%eax
    a037:	01 c0                	add    %eax,%eax
    a039:	01 d0                	add    %edx,%eax
    a03b:	8d 50 01             	lea    0x1(%eax),%edx
    a03e:	8b 45 08             	mov    0x8(%ebp),%eax
    a041:	01 c2                	add    %eax,%edx
    a043:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a047:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    a049:	8b 55 0c             	mov    0xc(%ebp),%edx
    a04c:	89 d0                	mov    %edx,%eax
    a04e:	01 c0                	add    %eax,%eax
    a050:	01 d0                	add    %edx,%eax
    a052:	8d 50 02             	lea    0x2(%eax),%edx
    a055:	8b 45 08             	mov    0x8(%ebp),%eax
    a058:	01 c2                	add    %eax,%edx
    a05a:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a05e:	88 02                	mov    %al,(%edx)
    a060:	e9 ca 02 00 00       	jmp    a32f <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    a065:	8b 55 0c             	mov    0xc(%ebp),%edx
    a068:	89 d0                	mov    %edx,%eax
    a06a:	01 c0                	add    %eax,%eax
    a06c:	01 d0                	add    %edx,%eax
    a06e:	01 c0                	add    %eax,%eax
    a070:	89 c2                	mov    %eax,%edx
    a072:	8b 45 08             	mov    0x8(%ebp),%eax
    a075:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a078:	8b 55 0c             	mov    0xc(%ebp),%edx
    a07b:	89 d0                	mov    %edx,%eax
    a07d:	01 c0                	add    %eax,%eax
    a07f:	01 d0                	add    %edx,%eax
    a081:	01 c0                	add    %eax,%eax
    a083:	8d 50 01             	lea    0x1(%eax),%edx
    a086:	8b 45 08             	mov    0x8(%ebp),%eax
    a089:	01 d0                	add    %edx,%eax
    a08b:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a08f:	88 10                	mov    %dl,(%eax)
    a091:	0f b6 00             	movzbl (%eax),%eax
    a094:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    a096:	8b 55 0c             	mov    0xc(%ebp),%edx
    a099:	89 d0                	mov    %edx,%eax
    a09b:	01 c0                	add    %eax,%eax
    a09d:	01 d0                	add    %edx,%eax
    a09f:	01 c0                	add    %eax,%eax
    a0a1:	8d 50 02             	lea    0x2(%eax),%edx
    a0a4:	8b 45 08             	mov    0x8(%ebp),%eax
    a0a7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a0aa:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0ad:	89 d0                	mov    %edx,%eax
    a0af:	01 c0                	add    %eax,%eax
    a0b1:	01 d0                	add    %edx,%eax
    a0b3:	01 c0                	add    %eax,%eax
    a0b5:	8d 50 03             	lea    0x3(%eax),%edx
    a0b8:	8b 45 08             	mov    0x8(%ebp),%eax
    a0bb:	01 d0                	add    %edx,%eax
    a0bd:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a0c1:	88 10                	mov    %dl,(%eax)
    a0c3:	0f b6 00             	movzbl (%eax),%eax
    a0c6:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    a0c8:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0cb:	89 d0                	mov    %edx,%eax
    a0cd:	01 c0                	add    %eax,%eax
    a0cf:	01 d0                	add    %edx,%eax
    a0d1:	01 c0                	add    %eax,%eax
    a0d3:	8d 50 04             	lea    0x4(%eax),%edx
    a0d6:	8b 45 08             	mov    0x8(%ebp),%eax
    a0d9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a0dc:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0df:	89 d0                	mov    %edx,%eax
    a0e1:	01 c0                	add    %eax,%eax
    a0e3:	01 d0                	add    %edx,%eax
    a0e5:	01 c0                	add    %eax,%eax
    a0e7:	8d 50 05             	lea    0x5(%eax),%edx
    a0ea:	8b 45 08             	mov    0x8(%ebp),%eax
    a0ed:	01 d0                	add    %edx,%eax
    a0ef:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a0f3:	88 10                	mov    %dl,(%eax)
    a0f5:	0f b6 00             	movzbl (%eax),%eax
    a0f8:	88 01                	mov    %al,(%ecx)
    a0fa:	e9 30 02 00 00       	jmp    a32f <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a0ff:	8b 45 10             	mov    0x10(%ebp),%eax
    a102:	8b 00                	mov    (%eax),%eax
    a104:	83 f8 03             	cmp    $0x3,%eax
    a107:	75 6d                	jne    a176 <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    a109:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    a10d:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    a111:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a115:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a119:	53                   	push   %ebx
    a11a:	51                   	push   %ecx
    a11b:	52                   	push   %edx
    a11c:	50                   	push   %eax
    a11d:	ff 75 14             	pushl  0x14(%ebp)
    a120:	e8 fd fb ff ff       	call   9d22 <color_tree_get>
    a125:	83 c4 14             	add    $0x14,%esp
    a128:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    a12b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a12f:	79 0a                	jns    a13b <rgba8ToPixel+0x211>
    a131:	b8 52 00 00 00       	mov    $0x52,%eax
    a136:	e9 f9 01 00 00       	jmp    a334 <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    a13b:	8b 45 10             	mov    0x10(%ebp),%eax
    a13e:	8b 40 04             	mov    0x4(%eax),%eax
    a141:	83 f8 08             	cmp    $0x8,%eax
    a144:	75 12                	jne    a158 <rgba8ToPixel+0x22e>
    a146:	8b 55 0c             	mov    0xc(%ebp),%edx
    a149:	8b 45 08             	mov    0x8(%ebp),%eax
    a14c:	01 d0                	add    %edx,%eax
    a14e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a151:	88 10                	mov    %dl,(%eax)
    a153:	e9 d7 01 00 00       	jmp    a32f <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    a158:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a15b:	8b 45 10             	mov    0x10(%ebp),%eax
    a15e:	8b 40 04             	mov    0x4(%eax),%eax
    a161:	52                   	push   %edx
    a162:	50                   	push   %eax
    a163:	ff 75 0c             	pushl  0xc(%ebp)
    a166:	ff 75 08             	pushl  0x8(%ebp)
    a169:	e8 ae fa ff ff       	call   9c1c <addColorBits>
    a16e:	83 c4 10             	add    $0x10,%esp
    a171:	e9 b9 01 00 00       	jmp    a32f <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a176:	8b 45 10             	mov    0x10(%ebp),%eax
    a179:	8b 00                	mov    (%eax),%eax
    a17b:	83 f8 04             	cmp    $0x4,%eax
    a17e:	0f 85 9f 00 00 00    	jne    a223 <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a184:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a188:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    a18b:	8b 45 10             	mov    0x10(%ebp),%eax
    a18e:	8b 40 04             	mov    0x4(%eax),%eax
    a191:	83 f8 08             	cmp    $0x8,%eax
    a194:	75 2a                	jne    a1c0 <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    a196:	8b 45 0c             	mov    0xc(%ebp),%eax
    a199:	01 c0                	add    %eax,%eax
    a19b:	89 c2                	mov    %eax,%edx
    a19d:	8b 45 08             	mov    0x8(%ebp),%eax
    a1a0:	01 c2                	add    %eax,%edx
    a1a2:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    a1a6:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    a1a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1ab:	01 c0                	add    %eax,%eax
    a1ad:	8d 50 01             	lea    0x1(%eax),%edx
    a1b0:	8b 45 08             	mov    0x8(%ebp),%eax
    a1b3:	01 c2                	add    %eax,%edx
    a1b5:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a1b9:	88 02                	mov    %al,(%edx)
    a1bb:	e9 6f 01 00 00       	jmp    a32f <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    a1c0:	8b 45 10             	mov    0x10(%ebp),%eax
    a1c3:	8b 40 04             	mov    0x4(%eax),%eax
    a1c6:	83 f8 10             	cmp    $0x10,%eax
    a1c9:	0f 85 60 01 00 00    	jne    a32f <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    a1cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1d2:	c1 e0 02             	shl    $0x2,%eax
    a1d5:	89 c2                	mov    %eax,%edx
    a1d7:	8b 45 08             	mov    0x8(%ebp),%eax
    a1da:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a1dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1e0:	c1 e0 02             	shl    $0x2,%eax
    a1e3:	8d 50 01             	lea    0x1(%eax),%edx
    a1e6:	8b 45 08             	mov    0x8(%ebp),%eax
    a1e9:	01 d0                	add    %edx,%eax
    a1eb:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    a1ef:	88 10                	mov    %dl,(%eax)
    a1f1:	0f b6 00             	movzbl (%eax),%eax
    a1f4:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    a1f6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1f9:	c1 e0 02             	shl    $0x2,%eax
    a1fc:	8d 50 02             	lea    0x2(%eax),%edx
    a1ff:	8b 45 08             	mov    0x8(%ebp),%eax
    a202:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a205:	8b 45 0c             	mov    0xc(%ebp),%eax
    a208:	c1 e0 02             	shl    $0x2,%eax
    a20b:	8d 50 03             	lea    0x3(%eax),%edx
    a20e:	8b 45 08             	mov    0x8(%ebp),%eax
    a211:	01 d0                	add    %edx,%eax
    a213:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a217:	88 10                	mov    %dl,(%eax)
    a219:	0f b6 00             	movzbl (%eax),%eax
    a21c:	88 01                	mov    %al,(%ecx)
    a21e:	e9 0c 01 00 00       	jmp    a32f <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    a223:	8b 45 10             	mov    0x10(%ebp),%eax
    a226:	8b 00                	mov    (%eax),%eax
    a228:	83 f8 06             	cmp    $0x6,%eax
    a22b:	0f 85 fe 00 00 00    	jne    a32f <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    a231:	8b 45 10             	mov    0x10(%ebp),%eax
    a234:	8b 40 04             	mov    0x4(%eax),%eax
    a237:	83 f8 08             	cmp    $0x8,%eax
    a23a:	75 54                	jne    a290 <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    a23c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a23f:	c1 e0 02             	shl    $0x2,%eax
    a242:	89 c2                	mov    %eax,%edx
    a244:	8b 45 08             	mov    0x8(%ebp),%eax
    a247:	01 c2                	add    %eax,%edx
    a249:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a24d:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    a24f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a252:	c1 e0 02             	shl    $0x2,%eax
    a255:	8d 50 01             	lea    0x1(%eax),%edx
    a258:	8b 45 08             	mov    0x8(%ebp),%eax
    a25b:	01 c2                	add    %eax,%edx
    a25d:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a261:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    a263:	8b 45 0c             	mov    0xc(%ebp),%eax
    a266:	c1 e0 02             	shl    $0x2,%eax
    a269:	8d 50 02             	lea    0x2(%eax),%edx
    a26c:	8b 45 08             	mov    0x8(%ebp),%eax
    a26f:	01 c2                	add    %eax,%edx
    a271:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a275:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    a277:	8b 45 0c             	mov    0xc(%ebp),%eax
    a27a:	c1 e0 02             	shl    $0x2,%eax
    a27d:	8d 50 03             	lea    0x3(%eax),%edx
    a280:	8b 45 08             	mov    0x8(%ebp),%eax
    a283:	01 c2                	add    %eax,%edx
    a285:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a289:	88 02                	mov    %al,(%edx)
    a28b:	e9 9f 00 00 00       	jmp    a32f <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    a290:	8b 45 0c             	mov    0xc(%ebp),%eax
    a293:	c1 e0 03             	shl    $0x3,%eax
    a296:	89 c2                	mov    %eax,%edx
    a298:	8b 45 08             	mov    0x8(%ebp),%eax
    a29b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a29e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2a1:	c1 e0 03             	shl    $0x3,%eax
    a2a4:	8d 50 01             	lea    0x1(%eax),%edx
    a2a7:	8b 45 08             	mov    0x8(%ebp),%eax
    a2aa:	01 d0                	add    %edx,%eax
    a2ac:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a2b0:	88 10                	mov    %dl,(%eax)
    a2b2:	0f b6 00             	movzbl (%eax),%eax
    a2b5:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    a2b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2ba:	c1 e0 03             	shl    $0x3,%eax
    a2bd:	8d 50 02             	lea    0x2(%eax),%edx
    a2c0:	8b 45 08             	mov    0x8(%ebp),%eax
    a2c3:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a2c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2c9:	c1 e0 03             	shl    $0x3,%eax
    a2cc:	8d 50 03             	lea    0x3(%eax),%edx
    a2cf:	8b 45 08             	mov    0x8(%ebp),%eax
    a2d2:	01 d0                	add    %edx,%eax
    a2d4:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a2d8:	88 10                	mov    %dl,(%eax)
    a2da:	0f b6 00             	movzbl (%eax),%eax
    a2dd:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    a2df:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2e2:	c1 e0 03             	shl    $0x3,%eax
    a2e5:	8d 50 04             	lea    0x4(%eax),%edx
    a2e8:	8b 45 08             	mov    0x8(%ebp),%eax
    a2eb:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a2ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2f1:	c1 e0 03             	shl    $0x3,%eax
    a2f4:	8d 50 05             	lea    0x5(%eax),%edx
    a2f7:	8b 45 08             	mov    0x8(%ebp),%eax
    a2fa:	01 d0                	add    %edx,%eax
    a2fc:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a300:	88 10                	mov    %dl,(%eax)
    a302:	0f b6 00             	movzbl (%eax),%eax
    a305:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    a307:	8b 45 0c             	mov    0xc(%ebp),%eax
    a30a:	c1 e0 03             	shl    $0x3,%eax
    a30d:	8d 50 06             	lea    0x6(%eax),%edx
    a310:	8b 45 08             	mov    0x8(%ebp),%eax
    a313:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a316:	8b 45 0c             	mov    0xc(%ebp),%eax
    a319:	c1 e0 03             	shl    $0x3,%eax
    a31c:	8d 50 07             	lea    0x7(%eax),%edx
    a31f:	8b 45 08             	mov    0x8(%ebp),%eax
    a322:	01 d0                	add    %edx,%eax
    a324:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a328:	88 10                	mov    %dl,(%eax)
    a32a:	0f b6 00             	movzbl (%eax),%eax
    a32d:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    a32f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a334:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a337:	c9                   	leave  
    a338:	c3                   	ret    

0000a339 <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    a339:	55                   	push   %ebp
    a33a:	89 e5                	mov    %esp,%ebp
    a33c:	53                   	push   %ebx
    a33d:	83 ec 20             	sub    $0x20,%esp
    a340:	8b 5d 14             	mov    0x14(%ebp),%ebx
    a343:	8b 4d 18             	mov    0x18(%ebp),%ecx
    a346:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a349:	8b 45 20             	mov    0x20(%ebp),%eax
    a34c:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    a350:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    a354:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    a358:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a35c:	8b 45 10             	mov    0x10(%ebp),%eax
    a35f:	8b 00                	mov    (%eax),%eax
    a361:	85 c0                	test   %eax,%eax
    a363:	75 36                	jne    a39b <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a365:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a369:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    a36d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a370:	01 c0                	add    %eax,%eax
    a372:	89 c2                	mov    %eax,%edx
    a374:	8b 45 08             	mov    0x8(%ebp),%eax
    a377:	01 d0                	add    %edx,%eax
    a379:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a37d:	66 c1 ea 08          	shr    $0x8,%dx
    a381:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    a383:	8b 45 0c             	mov    0xc(%ebp),%eax
    a386:	01 c0                	add    %eax,%eax
    a388:	8d 50 01             	lea    0x1(%eax),%edx
    a38b:	8b 45 08             	mov    0x8(%ebp),%eax
    a38e:	01 d0                	add    %edx,%eax
    a390:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a394:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a396:	e9 df 01 00 00       	jmp    a57a <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    a39b:	8b 45 10             	mov    0x10(%ebp),%eax
    a39e:	8b 00                	mov    (%eax),%eax
    a3a0:	83 f8 02             	cmp    $0x2,%eax
    a3a3:	0f 85 a6 00 00 00    	jne    a44f <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    a3a9:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3ac:	89 d0                	mov    %edx,%eax
    a3ae:	01 c0                	add    %eax,%eax
    a3b0:	01 d0                	add    %edx,%eax
    a3b2:	01 c0                	add    %eax,%eax
    a3b4:	89 c2                	mov    %eax,%edx
    a3b6:	8b 45 08             	mov    0x8(%ebp),%eax
    a3b9:	01 d0                	add    %edx,%eax
    a3bb:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a3bf:	66 c1 ea 08          	shr    $0x8,%dx
    a3c3:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    a3c5:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3c8:	89 d0                	mov    %edx,%eax
    a3ca:	01 c0                	add    %eax,%eax
    a3cc:	01 d0                	add    %edx,%eax
    a3ce:	01 c0                	add    %eax,%eax
    a3d0:	8d 50 01             	lea    0x1(%eax),%edx
    a3d3:	8b 45 08             	mov    0x8(%ebp),%eax
    a3d6:	01 d0                	add    %edx,%eax
    a3d8:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a3dc:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    a3de:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3e1:	89 d0                	mov    %edx,%eax
    a3e3:	01 c0                	add    %eax,%eax
    a3e5:	01 d0                	add    %edx,%eax
    a3e7:	01 c0                	add    %eax,%eax
    a3e9:	8d 50 02             	lea    0x2(%eax),%edx
    a3ec:	8b 45 08             	mov    0x8(%ebp),%eax
    a3ef:	01 d0                	add    %edx,%eax
    a3f1:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a3f5:	66 c1 ea 08          	shr    $0x8,%dx
    a3f9:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    a3fb:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3fe:	89 d0                	mov    %edx,%eax
    a400:	01 c0                	add    %eax,%eax
    a402:	01 d0                	add    %edx,%eax
    a404:	01 c0                	add    %eax,%eax
    a406:	8d 50 03             	lea    0x3(%eax),%edx
    a409:	8b 45 08             	mov    0x8(%ebp),%eax
    a40c:	01 d0                	add    %edx,%eax
    a40e:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a412:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    a414:	8b 55 0c             	mov    0xc(%ebp),%edx
    a417:	89 d0                	mov    %edx,%eax
    a419:	01 c0                	add    %eax,%eax
    a41b:	01 d0                	add    %edx,%eax
    a41d:	01 c0                	add    %eax,%eax
    a41f:	8d 50 04             	lea    0x4(%eax),%edx
    a422:	8b 45 08             	mov    0x8(%ebp),%eax
    a425:	01 d0                	add    %edx,%eax
    a427:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a42b:	66 c1 ea 08          	shr    $0x8,%dx
    a42f:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    a431:	8b 55 0c             	mov    0xc(%ebp),%edx
    a434:	89 d0                	mov    %edx,%eax
    a436:	01 c0                	add    %eax,%eax
    a438:	01 d0                	add    %edx,%eax
    a43a:	01 c0                	add    %eax,%eax
    a43c:	8d 50 05             	lea    0x5(%eax),%edx
    a43f:	8b 45 08             	mov    0x8(%ebp),%eax
    a442:	01 d0                	add    %edx,%eax
    a444:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a448:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a44a:	e9 2b 01 00 00       	jmp    a57a <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a44f:	8b 45 10             	mov    0x10(%ebp),%eax
    a452:	8b 00                	mov    (%eax),%eax
    a454:	83 f8 04             	cmp    $0x4,%eax
    a457:	75 64                	jne    a4bd <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a459:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a45d:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    a461:	8b 45 0c             	mov    0xc(%ebp),%eax
    a464:	c1 e0 02             	shl    $0x2,%eax
    a467:	89 c2                	mov    %eax,%edx
    a469:	8b 45 08             	mov    0x8(%ebp),%eax
    a46c:	01 d0                	add    %edx,%eax
    a46e:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a472:	66 c1 ea 08          	shr    $0x8,%dx
    a476:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    a478:	8b 45 0c             	mov    0xc(%ebp),%eax
    a47b:	c1 e0 02             	shl    $0x2,%eax
    a47e:	8d 50 01             	lea    0x1(%eax),%edx
    a481:	8b 45 08             	mov    0x8(%ebp),%eax
    a484:	01 d0                	add    %edx,%eax
    a486:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a48a:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    a48c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a48f:	c1 e0 02             	shl    $0x2,%eax
    a492:	8d 50 02             	lea    0x2(%eax),%edx
    a495:	8b 45 08             	mov    0x8(%ebp),%eax
    a498:	01 d0                	add    %edx,%eax
    a49a:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a49e:	66 c1 ea 08          	shr    $0x8,%dx
    a4a2:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    a4a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4a7:	c1 e0 02             	shl    $0x2,%eax
    a4aa:	8d 50 03             	lea    0x3(%eax),%edx
    a4ad:	8b 45 08             	mov    0x8(%ebp),%eax
    a4b0:	01 d0                	add    %edx,%eax
    a4b2:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a4b6:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a4b8:	e9 bd 00 00 00       	jmp    a57a <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    a4bd:	8b 45 10             	mov    0x10(%ebp),%eax
    a4c0:	8b 00                	mov    (%eax),%eax
    a4c2:	83 f8 06             	cmp    $0x6,%eax
    a4c5:	0f 85 af 00 00 00    	jne    a57a <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    a4cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4ce:	c1 e0 03             	shl    $0x3,%eax
    a4d1:	89 c2                	mov    %eax,%edx
    a4d3:	8b 45 08             	mov    0x8(%ebp),%eax
    a4d6:	01 d0                	add    %edx,%eax
    a4d8:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a4dc:	66 c1 ea 08          	shr    $0x8,%dx
    a4e0:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    a4e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4e5:	c1 e0 03             	shl    $0x3,%eax
    a4e8:	8d 50 01             	lea    0x1(%eax),%edx
    a4eb:	8b 45 08             	mov    0x8(%ebp),%eax
    a4ee:	01 d0                	add    %edx,%eax
    a4f0:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a4f4:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    a4f6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4f9:	c1 e0 03             	shl    $0x3,%eax
    a4fc:	8d 50 02             	lea    0x2(%eax),%edx
    a4ff:	8b 45 08             	mov    0x8(%ebp),%eax
    a502:	01 d0                	add    %edx,%eax
    a504:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a508:	66 c1 ea 08          	shr    $0x8,%dx
    a50c:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    a50e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a511:	c1 e0 03             	shl    $0x3,%eax
    a514:	8d 50 03             	lea    0x3(%eax),%edx
    a517:	8b 45 08             	mov    0x8(%ebp),%eax
    a51a:	01 d0                	add    %edx,%eax
    a51c:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a520:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    a522:	8b 45 0c             	mov    0xc(%ebp),%eax
    a525:	c1 e0 03             	shl    $0x3,%eax
    a528:	8d 50 04             	lea    0x4(%eax),%edx
    a52b:	8b 45 08             	mov    0x8(%ebp),%eax
    a52e:	01 d0                	add    %edx,%eax
    a530:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a534:	66 c1 ea 08          	shr    $0x8,%dx
    a538:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    a53a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a53d:	c1 e0 03             	shl    $0x3,%eax
    a540:	8d 50 05             	lea    0x5(%eax),%edx
    a543:	8b 45 08             	mov    0x8(%ebp),%eax
    a546:	01 d0                	add    %edx,%eax
    a548:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a54c:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    a54e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a551:	c1 e0 03             	shl    $0x3,%eax
    a554:	8d 50 06             	lea    0x6(%eax),%edx
    a557:	8b 45 08             	mov    0x8(%ebp),%eax
    a55a:	01 d0                	add    %edx,%eax
    a55c:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a560:	66 c1 ea 08          	shr    $0x8,%dx
    a564:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    a566:	8b 45 0c             	mov    0xc(%ebp),%eax
    a569:	c1 e0 03             	shl    $0x3,%eax
    a56c:	8d 50 07             	lea    0x7(%eax),%edx
    a56f:	8b 45 08             	mov    0x8(%ebp),%eax
    a572:	01 d0                	add    %edx,%eax
    a574:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a578:	88 10                	mov    %dl,(%eax)
  }
}
    a57a:	90                   	nop
    a57b:	83 c4 20             	add    $0x20,%esp
    a57e:	5b                   	pop    %ebx
    a57f:	5d                   	pop    %ebp
    a580:	c3                   	ret    

0000a581 <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    a581:	55                   	push   %ebp
    a582:	89 e5                	mov    %esp,%ebp
    a584:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    a587:	8b 45 20             	mov    0x20(%ebp),%eax
    a58a:	8b 00                	mov    (%eax),%eax
    a58c:	85 c0                	test   %eax,%eax
    a58e:	0f 85 8c 01 00 00    	jne    a720 <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    a594:	8b 45 20             	mov    0x20(%ebp),%eax
    a597:	8b 40 04             	mov    0x4(%eax),%eax
    a59a:	83 f8 08             	cmp    $0x8,%eax
    a59d:	75 59                	jne    a5f8 <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    a59f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a5a2:	8b 45 18             	mov    0x18(%ebp),%eax
    a5a5:	01 d0                	add    %edx,%eax
    a5a7:	0f b6 10             	movzbl (%eax),%edx
    a5aa:	8b 45 10             	mov    0x10(%ebp),%eax
    a5ad:	88 10                	mov    %dl,(%eax)
    a5af:	8b 45 10             	mov    0x10(%ebp),%eax
    a5b2:	0f b6 10             	movzbl (%eax),%edx
    a5b5:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5b8:	88 10                	mov    %dl,(%eax)
    a5ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5bd:	0f b6 10             	movzbl (%eax),%edx
    a5c0:	8b 45 08             	mov    0x8(%ebp),%eax
    a5c3:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    a5c5:	8b 45 20             	mov    0x20(%ebp),%eax
    a5c8:	8b 40 10             	mov    0x10(%eax),%eax
    a5cb:	85 c0                	test   %eax,%eax
    a5cd:	74 1e                	je     a5ed <getPixelColorRGBA8+0x6c>
    a5cf:	8b 45 08             	mov    0x8(%ebp),%eax
    a5d2:	0f b6 00             	movzbl (%eax),%eax
    a5d5:	0f b6 d0             	movzbl %al,%edx
    a5d8:	8b 45 20             	mov    0x20(%ebp),%eax
    a5db:	8b 40 14             	mov    0x14(%eax),%eax
    a5de:	39 c2                	cmp    %eax,%edx
    a5e0:	75 0b                	jne    a5ed <getPixelColorRGBA8+0x6c>
    a5e2:	8b 45 14             	mov    0x14(%ebp),%eax
    a5e5:	c6 00 00             	movb   $0x0,(%eax)
    a5e8:	e9 5e 05 00 00       	jmp    ab4b <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a5ed:	8b 45 14             	mov    0x14(%ebp),%eax
    a5f0:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a5f3:	e9 53 05 00 00       	jmp    ab4b <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    a5f8:	8b 45 20             	mov    0x20(%ebp),%eax
    a5fb:	8b 40 04             	mov    0x4(%eax),%eax
    a5fe:	83 f8 10             	cmp    $0x10,%eax
    a601:	0f 85 80 00 00 00    	jne    a687 <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    a607:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a60a:	01 c0                	add    %eax,%eax
    a60c:	89 c2                	mov    %eax,%edx
    a60e:	8b 45 18             	mov    0x18(%ebp),%eax
    a611:	01 d0                	add    %edx,%eax
    a613:	0f b6 10             	movzbl (%eax),%edx
    a616:	8b 45 10             	mov    0x10(%ebp),%eax
    a619:	88 10                	mov    %dl,(%eax)
    a61b:	8b 45 10             	mov    0x10(%ebp),%eax
    a61e:	0f b6 10             	movzbl (%eax),%edx
    a621:	8b 45 0c             	mov    0xc(%ebp),%eax
    a624:	88 10                	mov    %dl,(%eax)
    a626:	8b 45 0c             	mov    0xc(%ebp),%eax
    a629:	0f b6 10             	movzbl (%eax),%edx
    a62c:	8b 45 08             	mov    0x8(%ebp),%eax
    a62f:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    a631:	8b 45 20             	mov    0x20(%ebp),%eax
    a634:	8b 40 10             	mov    0x10(%eax),%eax
    a637:	85 c0                	test   %eax,%eax
    a639:	74 41                	je     a67c <getPixelColorRGBA8+0xfb>
    a63b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a63e:	01 c0                	add    %eax,%eax
    a640:	89 c2                	mov    %eax,%edx
    a642:	8b 45 18             	mov    0x18(%ebp),%eax
    a645:	01 d0                	add    %edx,%eax
    a647:	0f b6 00             	movzbl (%eax),%eax
    a64a:	0f b6 c0             	movzbl %al,%eax
    a64d:	c1 e0 08             	shl    $0x8,%eax
    a650:	89 c2                	mov    %eax,%edx
    a652:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a655:	01 c0                	add    %eax,%eax
    a657:	8d 48 01             	lea    0x1(%eax),%ecx
    a65a:	8b 45 18             	mov    0x18(%ebp),%eax
    a65d:	01 c8                	add    %ecx,%eax
    a65f:	0f b6 00             	movzbl (%eax),%eax
    a662:	0f b6 c0             	movzbl %al,%eax
    a665:	01 c2                	add    %eax,%edx
    a667:	8b 45 20             	mov    0x20(%ebp),%eax
    a66a:	8b 40 14             	mov    0x14(%eax),%eax
    a66d:	39 c2                	cmp    %eax,%edx
    a66f:	75 0b                	jne    a67c <getPixelColorRGBA8+0xfb>
    a671:	8b 45 14             	mov    0x14(%ebp),%eax
    a674:	c6 00 00             	movb   $0x0,(%eax)
    a677:	e9 cf 04 00 00       	jmp    ab4b <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a67c:	8b 45 14             	mov    0x14(%ebp),%eax
    a67f:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a682:	e9 c4 04 00 00       	jmp    ab4b <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    a687:	8b 45 20             	mov    0x20(%ebp),%eax
    a68a:	8b 40 04             	mov    0x4(%eax),%eax
    a68d:	ba 01 00 00 00       	mov    $0x1,%edx
    a692:	89 c1                	mov    %eax,%ecx
    a694:	d3 e2                	shl    %cl,%edx
    a696:	89 d0                	mov    %edx,%eax
    a698:	83 e8 01             	sub    $0x1,%eax
    a69b:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    a69e:	8b 45 20             	mov    0x20(%ebp),%eax
    a6a1:	8b 50 04             	mov    0x4(%eax),%edx
    a6a4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a6a7:	0f af c2             	imul   %edx,%eax
    a6aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a6ad:	8b 45 20             	mov    0x20(%ebp),%eax
    a6b0:	8b 40 04             	mov    0x4(%eax),%eax
    a6b3:	50                   	push   %eax
    a6b4:	ff 75 18             	pushl  0x18(%ebp)
    a6b7:	8d 45 f0             	lea    -0x10(%ebp),%eax
    a6ba:	50                   	push   %eax
    a6bb:	e8 06 db ff ff       	call   81c6 <readBitsFromReversedStream>
    a6c0:	83 c4 0c             	add    $0xc,%esp
    a6c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    a6c6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a6c9:	89 d0                	mov    %edx,%eax
    a6cb:	c1 e0 08             	shl    $0x8,%eax
    a6ce:	29 d0                	sub    %edx,%eax
    a6d0:	ba 00 00 00 00       	mov    $0x0,%edx
    a6d5:	f7 75 f8             	divl   -0x8(%ebp)
    a6d8:	89 c2                	mov    %eax,%edx
    a6da:	8b 45 10             	mov    0x10(%ebp),%eax
    a6dd:	88 10                	mov    %dl,(%eax)
    a6df:	8b 45 10             	mov    0x10(%ebp),%eax
    a6e2:	0f b6 10             	movzbl (%eax),%edx
    a6e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6e8:	88 10                	mov    %dl,(%eax)
    a6ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6ed:	0f b6 10             	movzbl (%eax),%edx
    a6f0:	8b 45 08             	mov    0x8(%ebp),%eax
    a6f3:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    a6f5:	8b 45 20             	mov    0x20(%ebp),%eax
    a6f8:	8b 40 10             	mov    0x10(%eax),%eax
    a6fb:	85 c0                	test   %eax,%eax
    a6fd:	74 16                	je     a715 <getPixelColorRGBA8+0x194>
    a6ff:	8b 45 20             	mov    0x20(%ebp),%eax
    a702:	8b 40 14             	mov    0x14(%eax),%eax
    a705:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a708:	75 0b                	jne    a715 <getPixelColorRGBA8+0x194>
    a70a:	8b 45 14             	mov    0x14(%ebp),%eax
    a70d:	c6 00 00             	movb   $0x0,(%eax)
    a710:	e9 36 04 00 00       	jmp    ab4b <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a715:	8b 45 14             	mov    0x14(%ebp),%eax
    a718:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a71b:	e9 2b 04 00 00       	jmp    ab4b <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    a720:	8b 45 20             	mov    0x20(%ebp),%eax
    a723:	8b 00                	mov    (%eax),%eax
    a725:	83 f8 02             	cmp    $0x2,%eax
    a728:	0f 85 f5 01 00 00    	jne    a923 <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    a72e:	8b 45 20             	mov    0x20(%ebp),%eax
    a731:	8b 40 04             	mov    0x4(%eax),%eax
    a734:	83 f8 08             	cmp    $0x8,%eax
    a737:	0f 85 a3 00 00 00    	jne    a7e0 <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    a73d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a740:	89 d0                	mov    %edx,%eax
    a742:	01 c0                	add    %eax,%eax
    a744:	01 d0                	add    %edx,%eax
    a746:	89 c2                	mov    %eax,%edx
    a748:	8b 45 18             	mov    0x18(%ebp),%eax
    a74b:	01 d0                	add    %edx,%eax
    a74d:	0f b6 10             	movzbl (%eax),%edx
    a750:	8b 45 08             	mov    0x8(%ebp),%eax
    a753:	88 10                	mov    %dl,(%eax)
    a755:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a758:	89 d0                	mov    %edx,%eax
    a75a:	01 c0                	add    %eax,%eax
    a75c:	01 d0                	add    %edx,%eax
    a75e:	8d 50 01             	lea    0x1(%eax),%edx
    a761:	8b 45 18             	mov    0x18(%ebp),%eax
    a764:	01 d0                	add    %edx,%eax
    a766:	0f b6 10             	movzbl (%eax),%edx
    a769:	8b 45 0c             	mov    0xc(%ebp),%eax
    a76c:	88 10                	mov    %dl,(%eax)
    a76e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a771:	89 d0                	mov    %edx,%eax
    a773:	01 c0                	add    %eax,%eax
    a775:	01 d0                	add    %edx,%eax
    a777:	8d 50 02             	lea    0x2(%eax),%edx
    a77a:	8b 45 18             	mov    0x18(%ebp),%eax
    a77d:	01 d0                	add    %edx,%eax
    a77f:	0f b6 10             	movzbl (%eax),%edx
    a782:	8b 45 10             	mov    0x10(%ebp),%eax
    a785:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    a787:	8b 45 20             	mov    0x20(%ebp),%eax
    a78a:	8b 40 10             	mov    0x10(%eax),%eax
    a78d:	85 c0                	test   %eax,%eax
    a78f:	74 44                	je     a7d5 <getPixelColorRGBA8+0x254>
    a791:	8b 45 08             	mov    0x8(%ebp),%eax
    a794:	0f b6 00             	movzbl (%eax),%eax
    a797:	0f b6 d0             	movzbl %al,%edx
    a79a:	8b 45 20             	mov    0x20(%ebp),%eax
    a79d:	8b 40 14             	mov    0x14(%eax),%eax
    a7a0:	39 c2                	cmp    %eax,%edx
    a7a2:	75 31                	jne    a7d5 <getPixelColorRGBA8+0x254>
    a7a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7a7:	0f b6 00             	movzbl (%eax),%eax
    a7aa:	0f b6 d0             	movzbl %al,%edx
    a7ad:	8b 45 20             	mov    0x20(%ebp),%eax
    a7b0:	8b 40 18             	mov    0x18(%eax),%eax
    a7b3:	39 c2                	cmp    %eax,%edx
    a7b5:	75 1e                	jne    a7d5 <getPixelColorRGBA8+0x254>
    a7b7:	8b 45 10             	mov    0x10(%ebp),%eax
    a7ba:	0f b6 00             	movzbl (%eax),%eax
    a7bd:	0f b6 d0             	movzbl %al,%edx
    a7c0:	8b 45 20             	mov    0x20(%ebp),%eax
    a7c3:	8b 40 1c             	mov    0x1c(%eax),%eax
    a7c6:	39 c2                	cmp    %eax,%edx
    a7c8:	75 0b                	jne    a7d5 <getPixelColorRGBA8+0x254>
    a7ca:	8b 45 14             	mov    0x14(%ebp),%eax
    a7cd:	c6 00 00             	movb   $0x0,(%eax)
    a7d0:	e9 76 03 00 00       	jmp    ab4b <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a7d5:	8b 45 14             	mov    0x14(%ebp),%eax
    a7d8:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a7db:	e9 6b 03 00 00       	jmp    ab4b <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    a7e0:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a7e3:	89 d0                	mov    %edx,%eax
    a7e5:	01 c0                	add    %eax,%eax
    a7e7:	01 d0                	add    %edx,%eax
    a7e9:	01 c0                	add    %eax,%eax
    a7eb:	89 c2                	mov    %eax,%edx
    a7ed:	8b 45 18             	mov    0x18(%ebp),%eax
    a7f0:	01 d0                	add    %edx,%eax
    a7f2:	0f b6 10             	movzbl (%eax),%edx
    a7f5:	8b 45 08             	mov    0x8(%ebp),%eax
    a7f8:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    a7fa:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a7fd:	89 d0                	mov    %edx,%eax
    a7ff:	01 c0                	add    %eax,%eax
    a801:	01 d0                	add    %edx,%eax
    a803:	01 c0                	add    %eax,%eax
    a805:	8d 50 02             	lea    0x2(%eax),%edx
    a808:	8b 45 18             	mov    0x18(%ebp),%eax
    a80b:	01 d0                	add    %edx,%eax
    a80d:	0f b6 10             	movzbl (%eax),%edx
    a810:	8b 45 0c             	mov    0xc(%ebp),%eax
    a813:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    a815:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a818:	89 d0                	mov    %edx,%eax
    a81a:	01 c0                	add    %eax,%eax
    a81c:	01 d0                	add    %edx,%eax
    a81e:	01 c0                	add    %eax,%eax
    a820:	8d 50 04             	lea    0x4(%eax),%edx
    a823:	8b 45 18             	mov    0x18(%ebp),%eax
    a826:	01 d0                	add    %edx,%eax
    a828:	0f b6 10             	movzbl (%eax),%edx
    a82b:	8b 45 10             	mov    0x10(%ebp),%eax
    a82e:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    a830:	8b 45 20             	mov    0x20(%ebp),%eax
    a833:	8b 40 10             	mov    0x10(%eax),%eax
    a836:	85 c0                	test   %eax,%eax
    a838:	0f 84 da 00 00 00    	je     a918 <getPixelColorRGBA8+0x397>
    a83e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a841:	89 d0                	mov    %edx,%eax
    a843:	01 c0                	add    %eax,%eax
    a845:	01 d0                	add    %edx,%eax
    a847:	01 c0                	add    %eax,%eax
    a849:	89 c2                	mov    %eax,%edx
    a84b:	8b 45 18             	mov    0x18(%ebp),%eax
    a84e:	01 d0                	add    %edx,%eax
    a850:	0f b6 00             	movzbl (%eax),%eax
    a853:	0f b6 c0             	movzbl %al,%eax
    a856:	c1 e0 08             	shl    $0x8,%eax
    a859:	89 c1                	mov    %eax,%ecx
    a85b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a85e:	89 d0                	mov    %edx,%eax
    a860:	01 c0                	add    %eax,%eax
    a862:	01 d0                	add    %edx,%eax
    a864:	01 c0                	add    %eax,%eax
    a866:	8d 50 01             	lea    0x1(%eax),%edx
    a869:	8b 45 18             	mov    0x18(%ebp),%eax
    a86c:	01 d0                	add    %edx,%eax
    a86e:	0f b6 00             	movzbl (%eax),%eax
    a871:	0f b6 c0             	movzbl %al,%eax
    a874:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a877:	8b 45 20             	mov    0x20(%ebp),%eax
    a87a:	8b 40 14             	mov    0x14(%eax),%eax
    a87d:	39 c2                	cmp    %eax,%edx
    a87f:	0f 85 93 00 00 00    	jne    a918 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    a885:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a888:	89 d0                	mov    %edx,%eax
    a88a:	01 c0                	add    %eax,%eax
    a88c:	01 d0                	add    %edx,%eax
    a88e:	01 c0                	add    %eax,%eax
    a890:	8d 50 02             	lea    0x2(%eax),%edx
    a893:	8b 45 18             	mov    0x18(%ebp),%eax
    a896:	01 d0                	add    %edx,%eax
    a898:	0f b6 00             	movzbl (%eax),%eax
    a89b:	0f b6 c0             	movzbl %al,%eax
    a89e:	c1 e0 08             	shl    $0x8,%eax
    a8a1:	89 c1                	mov    %eax,%ecx
    a8a3:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8a6:	89 d0                	mov    %edx,%eax
    a8a8:	01 c0                	add    %eax,%eax
    a8aa:	01 d0                	add    %edx,%eax
    a8ac:	01 c0                	add    %eax,%eax
    a8ae:	8d 50 03             	lea    0x3(%eax),%edx
    a8b1:	8b 45 18             	mov    0x18(%ebp),%eax
    a8b4:	01 d0                	add    %edx,%eax
    a8b6:	0f b6 00             	movzbl (%eax),%eax
    a8b9:	0f b6 c0             	movzbl %al,%eax
    a8bc:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a8bf:	8b 45 20             	mov    0x20(%ebp),%eax
    a8c2:	8b 40 18             	mov    0x18(%eax),%eax
    a8c5:	39 c2                	cmp    %eax,%edx
    a8c7:	75 4f                	jne    a918 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    a8c9:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8cc:	89 d0                	mov    %edx,%eax
    a8ce:	01 c0                	add    %eax,%eax
    a8d0:	01 d0                	add    %edx,%eax
    a8d2:	01 c0                	add    %eax,%eax
    a8d4:	8d 50 04             	lea    0x4(%eax),%edx
    a8d7:	8b 45 18             	mov    0x18(%ebp),%eax
    a8da:	01 d0                	add    %edx,%eax
    a8dc:	0f b6 00             	movzbl (%eax),%eax
    a8df:	0f b6 c0             	movzbl %al,%eax
    a8e2:	c1 e0 08             	shl    $0x8,%eax
    a8e5:	89 c1                	mov    %eax,%ecx
    a8e7:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8ea:	89 d0                	mov    %edx,%eax
    a8ec:	01 c0                	add    %eax,%eax
    a8ee:	01 d0                	add    %edx,%eax
    a8f0:	01 c0                	add    %eax,%eax
    a8f2:	8d 50 05             	lea    0x5(%eax),%edx
    a8f5:	8b 45 18             	mov    0x18(%ebp),%eax
    a8f8:	01 d0                	add    %edx,%eax
    a8fa:	0f b6 00             	movzbl (%eax),%eax
    a8fd:	0f b6 c0             	movzbl %al,%eax
    a900:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a903:	8b 45 20             	mov    0x20(%ebp),%eax
    a906:	8b 40 1c             	mov    0x1c(%eax),%eax
    a909:	39 c2                	cmp    %eax,%edx
    a90b:	75 0b                	jne    a918 <getPixelColorRGBA8+0x397>
    a90d:	8b 45 14             	mov    0x14(%ebp),%eax
    a910:	c6 00 00             	movb   $0x0,(%eax)
    a913:	e9 33 02 00 00       	jmp    ab4b <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a918:	8b 45 14             	mov    0x14(%ebp),%eax
    a91b:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a91e:	e9 28 02 00 00       	jmp    ab4b <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a923:	8b 45 20             	mov    0x20(%ebp),%eax
    a926:	8b 00                	mov    (%eax),%eax
    a928:	83 f8 03             	cmp    $0x3,%eax
    a92b:	0f 85 ac 00 00 00    	jne    a9dd <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    a931:	8b 45 20             	mov    0x20(%ebp),%eax
    a934:	8b 40 04             	mov    0x4(%eax),%eax
    a937:	83 f8 08             	cmp    $0x8,%eax
    a93a:	75 13                	jne    a94f <getPixelColorRGBA8+0x3ce>
    a93c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a93f:	8b 45 18             	mov    0x18(%ebp),%eax
    a942:	01 d0                	add    %edx,%eax
    a944:	0f b6 00             	movzbl (%eax),%eax
    a947:	0f b6 c0             	movzbl %al,%eax
    a94a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    a94d:	eb 28                	jmp    a977 <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    a94f:	8b 45 20             	mov    0x20(%ebp),%eax
    a952:	8b 50 04             	mov    0x4(%eax),%edx
    a955:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a958:	0f af c2             	imul   %edx,%eax
    a95b:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a95e:	8b 45 20             	mov    0x20(%ebp),%eax
    a961:	8b 40 04             	mov    0x4(%eax),%eax
    a964:	50                   	push   %eax
    a965:	ff 75 18             	pushl  0x18(%ebp)
    a968:	8d 45 ec             	lea    -0x14(%ebp),%eax
    a96b:	50                   	push   %eax
    a96c:	e8 55 d8 ff ff       	call   81c6 <readBitsFromReversedStream>
    a971:	83 c4 0c             	add    $0xc,%esp
    a974:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    a977:	8b 45 20             	mov    0x20(%ebp),%eax
    a97a:	8b 40 08             	mov    0x8(%eax),%eax
    a97d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a980:	c1 e2 02             	shl    $0x2,%edx
    a983:	01 d0                	add    %edx,%eax
    a985:	0f b6 10             	movzbl (%eax),%edx
    a988:	8b 45 08             	mov    0x8(%ebp),%eax
    a98b:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    a98d:	8b 45 20             	mov    0x20(%ebp),%eax
    a990:	8b 40 08             	mov    0x8(%eax),%eax
    a993:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a996:	c1 e2 02             	shl    $0x2,%edx
    a999:	83 c2 01             	add    $0x1,%edx
    a99c:	01 d0                	add    %edx,%eax
    a99e:	0f b6 10             	movzbl (%eax),%edx
    a9a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9a4:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    a9a6:	8b 45 20             	mov    0x20(%ebp),%eax
    a9a9:	8b 40 08             	mov    0x8(%eax),%eax
    a9ac:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a9af:	c1 e2 02             	shl    $0x2,%edx
    a9b2:	83 c2 02             	add    $0x2,%edx
    a9b5:	01 d0                	add    %edx,%eax
    a9b7:	0f b6 10             	movzbl (%eax),%edx
    a9ba:	8b 45 10             	mov    0x10(%ebp),%eax
    a9bd:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    a9bf:	8b 45 20             	mov    0x20(%ebp),%eax
    a9c2:	8b 40 08             	mov    0x8(%eax),%eax
    a9c5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a9c8:	c1 e2 02             	shl    $0x2,%edx
    a9cb:	83 c2 03             	add    $0x3,%edx
    a9ce:	01 d0                	add    %edx,%eax
    a9d0:	0f b6 10             	movzbl (%eax),%edx
    a9d3:	8b 45 14             	mov    0x14(%ebp),%eax
    a9d6:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a9d8:	e9 6e 01 00 00       	jmp    ab4b <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a9dd:	8b 45 20             	mov    0x20(%ebp),%eax
    a9e0:	8b 00                	mov    (%eax),%eax
    a9e2:	83 f8 04             	cmp    $0x4,%eax
    a9e5:	0f 85 95 00 00 00    	jne    aa80 <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    a9eb:	8b 45 20             	mov    0x20(%ebp),%eax
    a9ee:	8b 40 04             	mov    0x4(%eax),%eax
    a9f1:	83 f8 08             	cmp    $0x8,%eax
    a9f4:	75 44                	jne    aa3a <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    a9f6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a9f9:	01 c0                	add    %eax,%eax
    a9fb:	89 c2                	mov    %eax,%edx
    a9fd:	8b 45 18             	mov    0x18(%ebp),%eax
    aa00:	01 d0                	add    %edx,%eax
    aa02:	0f b6 10             	movzbl (%eax),%edx
    aa05:	8b 45 10             	mov    0x10(%ebp),%eax
    aa08:	88 10                	mov    %dl,(%eax)
    aa0a:	8b 45 10             	mov    0x10(%ebp),%eax
    aa0d:	0f b6 10             	movzbl (%eax),%edx
    aa10:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa13:	88 10                	mov    %dl,(%eax)
    aa15:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa18:	0f b6 10             	movzbl (%eax),%edx
    aa1b:	8b 45 08             	mov    0x8(%ebp),%eax
    aa1e:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    aa20:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa23:	01 c0                	add    %eax,%eax
    aa25:	8d 50 01             	lea    0x1(%eax),%edx
    aa28:	8b 45 18             	mov    0x18(%ebp),%eax
    aa2b:	01 d0                	add    %edx,%eax
    aa2d:	0f b6 10             	movzbl (%eax),%edx
    aa30:	8b 45 14             	mov    0x14(%ebp),%eax
    aa33:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aa35:	e9 11 01 00 00       	jmp    ab4b <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    aa3a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa3d:	c1 e0 02             	shl    $0x2,%eax
    aa40:	89 c2                	mov    %eax,%edx
    aa42:	8b 45 18             	mov    0x18(%ebp),%eax
    aa45:	01 d0                	add    %edx,%eax
    aa47:	0f b6 10             	movzbl (%eax),%edx
    aa4a:	8b 45 10             	mov    0x10(%ebp),%eax
    aa4d:	88 10                	mov    %dl,(%eax)
    aa4f:	8b 45 10             	mov    0x10(%ebp),%eax
    aa52:	0f b6 10             	movzbl (%eax),%edx
    aa55:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa58:	88 10                	mov    %dl,(%eax)
    aa5a:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa5d:	0f b6 10             	movzbl (%eax),%edx
    aa60:	8b 45 08             	mov    0x8(%ebp),%eax
    aa63:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    aa65:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa68:	c1 e0 02             	shl    $0x2,%eax
    aa6b:	8d 50 02             	lea    0x2(%eax),%edx
    aa6e:	8b 45 18             	mov    0x18(%ebp),%eax
    aa71:	01 d0                	add    %edx,%eax
    aa73:	0f b6 10             	movzbl (%eax),%edx
    aa76:	8b 45 14             	mov    0x14(%ebp),%eax
    aa79:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aa7b:	e9 cb 00 00 00       	jmp    ab4b <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    aa80:	8b 45 20             	mov    0x20(%ebp),%eax
    aa83:	8b 00                	mov    (%eax),%eax
    aa85:	83 f8 06             	cmp    $0x6,%eax
    aa88:	0f 85 bd 00 00 00    	jne    ab4b <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    aa8e:	8b 45 20             	mov    0x20(%ebp),%eax
    aa91:	8b 40 04             	mov    0x4(%eax),%eax
    aa94:	83 f8 08             	cmp    $0x8,%eax
    aa97:	75 59                	jne    aaf2 <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    aa99:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa9c:	c1 e0 02             	shl    $0x2,%eax
    aa9f:	89 c2                	mov    %eax,%edx
    aaa1:	8b 45 18             	mov    0x18(%ebp),%eax
    aaa4:	01 d0                	add    %edx,%eax
    aaa6:	0f b6 10             	movzbl (%eax),%edx
    aaa9:	8b 45 08             	mov    0x8(%ebp),%eax
    aaac:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    aaae:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aab1:	c1 e0 02             	shl    $0x2,%eax
    aab4:	8d 50 01             	lea    0x1(%eax),%edx
    aab7:	8b 45 18             	mov    0x18(%ebp),%eax
    aaba:	01 d0                	add    %edx,%eax
    aabc:	0f b6 10             	movzbl (%eax),%edx
    aabf:	8b 45 0c             	mov    0xc(%ebp),%eax
    aac2:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    aac4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aac7:	c1 e0 02             	shl    $0x2,%eax
    aaca:	8d 50 02             	lea    0x2(%eax),%edx
    aacd:	8b 45 18             	mov    0x18(%ebp),%eax
    aad0:	01 d0                	add    %edx,%eax
    aad2:	0f b6 10             	movzbl (%eax),%edx
    aad5:	8b 45 10             	mov    0x10(%ebp),%eax
    aad8:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    aada:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aadd:	c1 e0 02             	shl    $0x2,%eax
    aae0:	8d 50 03             	lea    0x3(%eax),%edx
    aae3:	8b 45 18             	mov    0x18(%ebp),%eax
    aae6:	01 d0                	add    %edx,%eax
    aae8:	0f b6 10             	movzbl (%eax),%edx
    aaeb:	8b 45 14             	mov    0x14(%ebp),%eax
    aaee:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aaf0:	eb 59                	jmp    ab4b <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    aaf2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aaf5:	c1 e0 03             	shl    $0x3,%eax
    aaf8:	89 c2                	mov    %eax,%edx
    aafa:	8b 45 18             	mov    0x18(%ebp),%eax
    aafd:	01 d0                	add    %edx,%eax
    aaff:	0f b6 10             	movzbl (%eax),%edx
    ab02:	8b 45 08             	mov    0x8(%ebp),%eax
    ab05:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    ab07:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab0a:	c1 e0 03             	shl    $0x3,%eax
    ab0d:	8d 50 02             	lea    0x2(%eax),%edx
    ab10:	8b 45 18             	mov    0x18(%ebp),%eax
    ab13:	01 d0                	add    %edx,%eax
    ab15:	0f b6 10             	movzbl (%eax),%edx
    ab18:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab1b:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    ab1d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab20:	c1 e0 03             	shl    $0x3,%eax
    ab23:	8d 50 04             	lea    0x4(%eax),%edx
    ab26:	8b 45 18             	mov    0x18(%ebp),%eax
    ab29:	01 d0                	add    %edx,%eax
    ab2b:	0f b6 10             	movzbl (%eax),%edx
    ab2e:	8b 45 10             	mov    0x10(%ebp),%eax
    ab31:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    ab33:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab36:	c1 e0 03             	shl    $0x3,%eax
    ab39:	8d 50 06             	lea    0x6(%eax),%edx
    ab3c:	8b 45 18             	mov    0x18(%ebp),%eax
    ab3f:	01 d0                	add    %edx,%eax
    ab41:	0f b6 10             	movzbl (%eax),%edx
    ab44:	8b 45 14             	mov    0x14(%ebp),%eax
    ab47:	88 10                	mov    %dl,(%eax)
    }
  }
}
    ab49:	eb 00                	jmp    ab4b <getPixelColorRGBA8+0x5ca>
    ab4b:	90                   	nop
    ab4c:	c9                   	leave  
    ab4d:	c3                   	ret    

0000ab4e <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    ab4e:	55                   	push   %ebp
    ab4f:	89 e5                	mov    %esp,%ebp
    ab51:	53                   	push   %ebx
    ab52:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    ab55:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    ab5c:	8b 45 14             	mov    0x14(%ebp),%eax
    ab5f:	8b 00                	mov    (%eax),%eax
    ab61:	85 c0                	test   %eax,%eax
    ab63:	0f 85 14 02 00 00    	jne    ad7d <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    ab69:	8b 45 14             	mov    0x14(%ebp),%eax
    ab6c:	8b 40 04             	mov    0x4(%eax),%eax
    ab6f:	83 f8 08             	cmp    $0x8,%eax
    ab72:	0f 85 a0 00 00 00    	jne    ac18 <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ab78:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ab7f:	eb 39                	jmp    abba <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    ab81:	8b 45 08             	mov    0x8(%ebp),%eax
    ab84:	83 c0 01             	add    $0x1,%eax
    ab87:	8b 55 08             	mov    0x8(%ebp),%edx
    ab8a:	83 c2 02             	add    $0x2,%edx
    ab8d:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    ab90:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ab93:	01 d9                	add    %ebx,%ecx
    ab95:	0f b6 09             	movzbl (%ecx),%ecx
    ab98:	88 0a                	mov    %cl,(%edx)
    ab9a:	0f b6 12             	movzbl (%edx),%edx
    ab9d:	88 10                	mov    %dl,(%eax)
    ab9f:	0f b6 10             	movzbl (%eax),%edx
    aba2:	8b 45 08             	mov    0x8(%ebp),%eax
    aba5:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    aba7:	8b 45 08             	mov    0x8(%ebp),%eax
    abaa:	83 c0 03             	add    $0x3,%eax
    abad:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    abb0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    abb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    abb7:	01 45 08             	add    %eax,0x8(%ebp)
    abba:	8b 45 f8             	mov    -0x8(%ebp),%eax
    abbd:	3b 45 0c             	cmp    0xc(%ebp),%eax
    abc0:	75 bf                	jne    ab81 <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    abc2:	8b 45 14             	mov    0x14(%ebp),%eax
    abc5:	8b 40 10             	mov    0x10(%eax),%eax
    abc8:	85 c0                	test   %eax,%eax
    abca:	0f 84 48 06 00 00    	je     b218 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    abd0:	8b 45 0c             	mov    0xc(%ebp),%eax
    abd3:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    abd7:	f7 d8                	neg    %eax
    abd9:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    abdc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    abe3:	eb 26                	jmp    ac0b <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    abe5:	8b 45 08             	mov    0x8(%ebp),%eax
    abe8:	0f b6 00             	movzbl (%eax),%eax
    abeb:	0f b6 d0             	movzbl %al,%edx
    abee:	8b 45 14             	mov    0x14(%ebp),%eax
    abf1:	8b 40 14             	mov    0x14(%eax),%eax
    abf4:	39 c2                	cmp    %eax,%edx
    abf6:	75 09                	jne    ac01 <getPixelColorsRGBA8+0xb3>
    abf8:	8b 45 08             	mov    0x8(%ebp),%eax
    abfb:	83 c0 03             	add    $0x3,%eax
    abfe:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac01:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ac05:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ac08:	01 45 08             	add    %eax,0x8(%ebp)
    ac0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac0e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ac11:	75 d2                	jne    abe5 <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ac13:	e9 00 06 00 00       	jmp    b218 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    ac18:	8b 45 14             	mov    0x14(%ebp),%eax
    ac1b:	8b 40 04             	mov    0x4(%eax),%eax
    ac1e:	83 f8 10             	cmp    $0x10,%eax
    ac21:	0f 85 a5 00 00 00    	jne    accc <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac27:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ac2e:	e9 88 00 00 00       	jmp    acbb <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    ac33:	8b 45 08             	mov    0x8(%ebp),%eax
    ac36:	83 c0 01             	add    $0x1,%eax
    ac39:	8b 55 08             	mov    0x8(%ebp),%edx
    ac3c:	83 c2 02             	add    $0x2,%edx
    ac3f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    ac42:	01 c9                	add    %ecx,%ecx
    ac44:	89 cb                	mov    %ecx,%ebx
    ac46:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ac49:	01 d9                	add    %ebx,%ecx
    ac4b:	0f b6 09             	movzbl (%ecx),%ecx
    ac4e:	88 0a                	mov    %cl,(%edx)
    ac50:	0f b6 12             	movzbl (%edx),%edx
    ac53:	88 10                	mov    %dl,(%eax)
    ac55:	0f b6 10             	movzbl (%eax),%edx
    ac58:	8b 45 08             	mov    0x8(%ebp),%eax
    ac5b:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    ac5d:	8b 45 08             	mov    0x8(%ebp),%eax
    ac60:	8d 50 03             	lea    0x3(%eax),%edx
    ac63:	8b 45 14             	mov    0x14(%ebp),%eax
    ac66:	8b 40 10             	mov    0x10(%eax),%eax
    ac69:	85 c0                	test   %eax,%eax
    ac6b:	74 3d                	je     acaa <getPixelColorsRGBA8+0x15c>
    ac6d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac70:	01 c0                	add    %eax,%eax
    ac72:	89 c1                	mov    %eax,%ecx
    ac74:	8b 45 10             	mov    0x10(%ebp),%eax
    ac77:	01 c8                	add    %ecx,%eax
    ac79:	0f b6 00             	movzbl (%eax),%eax
    ac7c:	0f b6 c0             	movzbl %al,%eax
    ac7f:	c1 e0 08             	shl    $0x8,%eax
    ac82:	89 c1                	mov    %eax,%ecx
    ac84:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac87:	01 c0                	add    %eax,%eax
    ac89:	8d 58 01             	lea    0x1(%eax),%ebx
    ac8c:	8b 45 10             	mov    0x10(%ebp),%eax
    ac8f:	01 d8                	add    %ebx,%eax
    ac91:	0f b6 00             	movzbl (%eax),%eax
    ac94:	0f b6 c0             	movzbl %al,%eax
    ac97:	01 c1                	add    %eax,%ecx
    ac99:	8b 45 14             	mov    0x14(%ebp),%eax
    ac9c:	8b 40 14             	mov    0x14(%eax),%eax
    ac9f:	39 c1                	cmp    %eax,%ecx
    aca1:	75 07                	jne    acaa <getPixelColorsRGBA8+0x15c>
    aca3:	b8 00 00 00 00       	mov    $0x0,%eax
    aca8:	eb 05                	jmp    acaf <getPixelColorsRGBA8+0x161>
    acaa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    acaf:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    acb1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    acb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    acb8:	01 45 08             	add    %eax,0x8(%ebp)
    acbb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    acbe:	3b 45 0c             	cmp    0xc(%ebp),%eax
    acc1:	0f 85 6c ff ff ff    	jne    ac33 <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    acc7:	e9 4c 05 00 00       	jmp    b218 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    accc:	8b 45 14             	mov    0x14(%ebp),%eax
    accf:	8b 40 04             	mov    0x4(%eax),%eax
    acd2:	ba 01 00 00 00       	mov    $0x1,%edx
    acd7:	89 c1                	mov    %eax,%ecx
    acd9:	d3 e2                	shl    %cl,%edx
    acdb:	89 d0                	mov    %edx,%eax
    acdd:	83 e8 01             	sub    $0x1,%eax
    ace0:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    ace3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    acea:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    acf1:	eb 79                	jmp    ad6c <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    acf3:	8b 45 14             	mov    0x14(%ebp),%eax
    acf6:	8b 40 04             	mov    0x4(%eax),%eax
    acf9:	50                   	push   %eax
    acfa:	ff 75 10             	pushl  0x10(%ebp)
    acfd:	8d 45 e0             	lea    -0x20(%ebp),%eax
    ad00:	50                   	push   %eax
    ad01:	e8 c0 d4 ff ff       	call   81c6 <readBitsFromReversedStream>
    ad06:	83 c4 0c             	add    $0xc,%esp
    ad09:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    ad0c:	8b 45 08             	mov    0x8(%ebp),%eax
    ad0f:	8d 48 01             	lea    0x1(%eax),%ecx
    ad12:	8b 45 08             	mov    0x8(%ebp),%eax
    ad15:	8d 58 02             	lea    0x2(%eax),%ebx
    ad18:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ad1b:	89 d0                	mov    %edx,%eax
    ad1d:	c1 e0 08             	shl    $0x8,%eax
    ad20:	29 d0                	sub    %edx,%eax
    ad22:	ba 00 00 00 00       	mov    $0x0,%edx
    ad27:	f7 75 f0             	divl   -0x10(%ebp)
    ad2a:	88 03                	mov    %al,(%ebx)
    ad2c:	0f b6 03             	movzbl (%ebx),%eax
    ad2f:	88 01                	mov    %al,(%ecx)
    ad31:	0f b6 11             	movzbl (%ecx),%edx
    ad34:	8b 45 08             	mov    0x8(%ebp),%eax
    ad37:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    ad39:	8b 45 08             	mov    0x8(%ebp),%eax
    ad3c:	8d 50 03             	lea    0x3(%eax),%edx
    ad3f:	8b 45 14             	mov    0x14(%ebp),%eax
    ad42:	8b 40 10             	mov    0x10(%eax),%eax
    ad45:	85 c0                	test   %eax,%eax
    ad47:	74 12                	je     ad5b <getPixelColorsRGBA8+0x20d>
    ad49:	8b 45 14             	mov    0x14(%ebp),%eax
    ad4c:	8b 40 14             	mov    0x14(%eax),%eax
    ad4f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    ad52:	75 07                	jne    ad5b <getPixelColorsRGBA8+0x20d>
    ad54:	b8 00 00 00 00       	mov    $0x0,%eax
    ad59:	eb 05                	jmp    ad60 <getPixelColorsRGBA8+0x212>
    ad5b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    ad60:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad62:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ad66:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ad69:	01 45 08             	add    %eax,0x8(%ebp)
    ad6c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad6f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ad72:	0f 85 7b ff ff ff    	jne    acf3 <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ad78:	e9 9b 04 00 00       	jmp    b218 <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    ad7d:	8b 45 14             	mov    0x14(%ebp),%eax
    ad80:	8b 00                	mov    (%eax),%eax
    ad82:	83 f8 02             	cmp    $0x2,%eax
    ad85:	0f 85 41 02 00 00    	jne    afcc <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    ad8b:	8b 45 14             	mov    0x14(%ebp),%eax
    ad8e:	8b 40 04             	mov    0x4(%eax),%eax
    ad91:	83 f8 08             	cmp    $0x8,%eax
    ad94:	0f 85 c4 00 00 00    	jne    ae5e <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad9a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ada1:	eb 31                	jmp    add4 <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    ada3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ada6:	89 d0                	mov    %edx,%eax
    ada8:	01 c0                	add    %eax,%eax
    adaa:	01 d0                	add    %edx,%eax
    adac:	89 c2                	mov    %eax,%edx
    adae:	8b 45 10             	mov    0x10(%ebp),%eax
    adb1:	01 d0                	add    %edx,%eax
    adb3:	6a 03                	push   $0x3
    adb5:	50                   	push   %eax
    adb6:	ff 75 08             	pushl  0x8(%ebp)
    adb9:	e8 a3 85 ff ff       	call   3361 <lodepng_memcpy>
    adbe:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    adc1:	8b 45 08             	mov    0x8(%ebp),%eax
    adc4:	83 c0 03             	add    $0x3,%eax
    adc7:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    adca:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    adce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    add1:	01 45 08             	add    %eax,0x8(%ebp)
    add4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    add7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    adda:	75 c7                	jne    ada3 <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    addc:	8b 45 14             	mov    0x14(%ebp),%eax
    addf:	8b 40 10             	mov    0x10(%eax),%eax
    ade2:	85 c0                	test   %eax,%eax
    ade4:	0f 84 2e 04 00 00    	je     b218 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    adea:	8b 45 0c             	mov    0xc(%ebp),%eax
    aded:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    adf1:	f7 d8                	neg    %eax
    adf3:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    adf6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    adfd:	eb 52                	jmp    ae51 <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    adff:	8b 45 08             	mov    0x8(%ebp),%eax
    ae02:	0f b6 00             	movzbl (%eax),%eax
    ae05:	0f b6 d0             	movzbl %al,%edx
    ae08:	8b 45 14             	mov    0x14(%ebp),%eax
    ae0b:	8b 40 14             	mov    0x14(%eax),%eax
    ae0e:	39 c2                	cmp    %eax,%edx
    ae10:	75 35                	jne    ae47 <getPixelColorsRGBA8+0x2f9>
    ae12:	8b 45 08             	mov    0x8(%ebp),%eax
    ae15:	83 c0 01             	add    $0x1,%eax
    ae18:	0f b6 00             	movzbl (%eax),%eax
    ae1b:	0f b6 d0             	movzbl %al,%edx
    ae1e:	8b 45 14             	mov    0x14(%ebp),%eax
    ae21:	8b 40 18             	mov    0x18(%eax),%eax
    ae24:	39 c2                	cmp    %eax,%edx
    ae26:	75 1f                	jne    ae47 <getPixelColorsRGBA8+0x2f9>
    ae28:	8b 45 08             	mov    0x8(%ebp),%eax
    ae2b:	83 c0 02             	add    $0x2,%eax
    ae2e:	0f b6 00             	movzbl (%eax),%eax
    ae31:	0f b6 d0             	movzbl %al,%edx
    ae34:	8b 45 14             	mov    0x14(%ebp),%eax
    ae37:	8b 40 1c             	mov    0x1c(%eax),%eax
    ae3a:	39 c2                	cmp    %eax,%edx
    ae3c:	75 09                	jne    ae47 <getPixelColorsRGBA8+0x2f9>
    ae3e:	8b 45 08             	mov    0x8(%ebp),%eax
    ae41:	83 c0 03             	add    $0x3,%eax
    ae44:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae47:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ae4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ae4e:	01 45 08             	add    %eax,0x8(%ebp)
    ae51:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae54:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ae57:	75 a6                	jne    adff <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ae59:	e9 ba 03 00 00       	jmp    b218 <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae5e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae65:	e9 51 01 00 00       	jmp    afbb <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    ae6a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae6d:	89 d0                	mov    %edx,%eax
    ae6f:	01 c0                	add    %eax,%eax
    ae71:	01 d0                	add    %edx,%eax
    ae73:	01 c0                	add    %eax,%eax
    ae75:	89 c2                	mov    %eax,%edx
    ae77:	8b 45 10             	mov    0x10(%ebp),%eax
    ae7a:	01 d0                	add    %edx,%eax
    ae7c:	0f b6 10             	movzbl (%eax),%edx
    ae7f:	8b 45 08             	mov    0x8(%ebp),%eax
    ae82:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    ae84:	8b 45 08             	mov    0x8(%ebp),%eax
    ae87:	8d 48 01             	lea    0x1(%eax),%ecx
    ae8a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae8d:	89 d0                	mov    %edx,%eax
    ae8f:	01 c0                	add    %eax,%eax
    ae91:	01 d0                	add    %edx,%eax
    ae93:	01 c0                	add    %eax,%eax
    ae95:	8d 50 02             	lea    0x2(%eax),%edx
    ae98:	8b 45 10             	mov    0x10(%ebp),%eax
    ae9b:	01 d0                	add    %edx,%eax
    ae9d:	0f b6 00             	movzbl (%eax),%eax
    aea0:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    aea2:	8b 45 08             	mov    0x8(%ebp),%eax
    aea5:	8d 48 02             	lea    0x2(%eax),%ecx
    aea8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aeab:	89 d0                	mov    %edx,%eax
    aead:	01 c0                	add    %eax,%eax
    aeaf:	01 d0                	add    %edx,%eax
    aeb1:	01 c0                	add    %eax,%eax
    aeb3:	8d 50 04             	lea    0x4(%eax),%edx
    aeb6:	8b 45 10             	mov    0x10(%ebp),%eax
    aeb9:	01 d0                	add    %edx,%eax
    aebb:	0f b6 00             	movzbl (%eax),%eax
    aebe:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    aec0:	8b 45 08             	mov    0x8(%ebp),%eax
    aec3:	8d 48 03             	lea    0x3(%eax),%ecx
    aec6:	8b 45 14             	mov    0x14(%ebp),%eax
    aec9:	8b 40 10             	mov    0x10(%eax),%eax
    aecc:	85 c0                	test   %eax,%eax
    aece:	0f 84 d6 00 00 00    	je     afaa <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    aed4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aed7:	89 d0                	mov    %edx,%eax
    aed9:	01 c0                	add    %eax,%eax
    aedb:	01 d0                	add    %edx,%eax
    aedd:	01 c0                	add    %eax,%eax
    aedf:	89 c2                	mov    %eax,%edx
    aee1:	8b 45 10             	mov    0x10(%ebp),%eax
    aee4:	01 d0                	add    %edx,%eax
    aee6:	0f b6 00             	movzbl (%eax),%eax
    aee9:	0f b6 c0             	movzbl %al,%eax
    aeec:	c1 e0 08             	shl    $0x8,%eax
    aeef:	89 c3                	mov    %eax,%ebx
    aef1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aef4:	89 d0                	mov    %edx,%eax
    aef6:	01 c0                	add    %eax,%eax
    aef8:	01 d0                	add    %edx,%eax
    aefa:	01 c0                	add    %eax,%eax
    aefc:	8d 50 01             	lea    0x1(%eax),%edx
    aeff:	8b 45 10             	mov    0x10(%ebp),%eax
    af02:	01 d0                	add    %edx,%eax
    af04:	0f b6 00             	movzbl (%eax),%eax
    af07:	0f b6 c0             	movzbl %al,%eax
    af0a:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    af0d:	8b 45 14             	mov    0x14(%ebp),%eax
    af10:	8b 40 14             	mov    0x14(%eax),%eax
    af13:	39 c2                	cmp    %eax,%edx
    af15:	0f 85 8f 00 00 00    	jne    afaa <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    af1b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af1e:	89 d0                	mov    %edx,%eax
    af20:	01 c0                	add    %eax,%eax
    af22:	01 d0                	add    %edx,%eax
    af24:	01 c0                	add    %eax,%eax
    af26:	8d 50 02             	lea    0x2(%eax),%edx
    af29:	8b 45 10             	mov    0x10(%ebp),%eax
    af2c:	01 d0                	add    %edx,%eax
    af2e:	0f b6 00             	movzbl (%eax),%eax
    af31:	0f b6 c0             	movzbl %al,%eax
    af34:	c1 e0 08             	shl    $0x8,%eax
    af37:	89 c3                	mov    %eax,%ebx
    af39:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af3c:	89 d0                	mov    %edx,%eax
    af3e:	01 c0                	add    %eax,%eax
    af40:	01 d0                	add    %edx,%eax
    af42:	01 c0                	add    %eax,%eax
    af44:	8d 50 03             	lea    0x3(%eax),%edx
    af47:	8b 45 10             	mov    0x10(%ebp),%eax
    af4a:	01 d0                	add    %edx,%eax
    af4c:	0f b6 00             	movzbl (%eax),%eax
    af4f:	0f b6 c0             	movzbl %al,%eax
    af52:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    af55:	8b 45 14             	mov    0x14(%ebp),%eax
    af58:	8b 40 18             	mov    0x18(%eax),%eax
    af5b:	39 c2                	cmp    %eax,%edx
    af5d:	75 4b                	jne    afaa <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    af5f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af62:	89 d0                	mov    %edx,%eax
    af64:	01 c0                	add    %eax,%eax
    af66:	01 d0                	add    %edx,%eax
    af68:	01 c0                	add    %eax,%eax
    af6a:	8d 50 04             	lea    0x4(%eax),%edx
    af6d:	8b 45 10             	mov    0x10(%ebp),%eax
    af70:	01 d0                	add    %edx,%eax
    af72:	0f b6 00             	movzbl (%eax),%eax
    af75:	0f b6 c0             	movzbl %al,%eax
    af78:	c1 e0 08             	shl    $0x8,%eax
    af7b:	89 c3                	mov    %eax,%ebx
    af7d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af80:	89 d0                	mov    %edx,%eax
    af82:	01 c0                	add    %eax,%eax
    af84:	01 d0                	add    %edx,%eax
    af86:	01 c0                	add    %eax,%eax
    af88:	8d 50 05             	lea    0x5(%eax),%edx
    af8b:	8b 45 10             	mov    0x10(%ebp),%eax
    af8e:	01 d0                	add    %edx,%eax
    af90:	0f b6 00             	movzbl (%eax),%eax
    af93:	0f b6 c0             	movzbl %al,%eax
    af96:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    af99:	8b 45 14             	mov    0x14(%ebp),%eax
    af9c:	8b 40 1c             	mov    0x1c(%eax),%eax
    af9f:	39 c2                	cmp    %eax,%edx
    afa1:	75 07                	jne    afaa <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    afa3:	b8 00 00 00 00       	mov    $0x0,%eax
    afa8:	eb 05                	jmp    afaf <getPixelColorsRGBA8+0x461>
    afaa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    afaf:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    afb1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    afb5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    afb8:	01 45 08             	add    %eax,0x8(%ebp)
    afbb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    afbe:	3b 45 0c             	cmp    0xc(%ebp),%eax
    afc1:	0f 85 a3 fe ff ff    	jne    ae6a <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    afc7:	e9 4c 02 00 00       	jmp    b218 <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    afcc:	8b 45 14             	mov    0x14(%ebp),%eax
    afcf:	8b 00                	mov    (%eax),%eax
    afd1:	83 f8 03             	cmp    $0x3,%eax
    afd4:	0f 85 b4 00 00 00    	jne    b08e <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    afda:	8b 45 14             	mov    0x14(%ebp),%eax
    afdd:	8b 40 04             	mov    0x4(%eax),%eax
    afe0:	83 f8 08             	cmp    $0x8,%eax
    afe3:	75 4d                	jne    b032 <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    afe5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    afec:	eb 37                	jmp    b025 <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    afee:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aff1:	8b 45 10             	mov    0x10(%ebp),%eax
    aff4:	01 d0                	add    %edx,%eax
    aff6:	0f b6 00             	movzbl (%eax),%eax
    aff9:	0f b6 c0             	movzbl %al,%eax
    affc:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    afff:	8b 45 14             	mov    0x14(%ebp),%eax
    b002:	8b 40 08             	mov    0x8(%eax),%eax
    b005:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b008:	c1 e2 02             	shl    $0x2,%edx
    b00b:	01 d0                	add    %edx,%eax
    b00d:	6a 04                	push   $0x4
    b00f:	50                   	push   %eax
    b010:	ff 75 08             	pushl  0x8(%ebp)
    b013:	e8 49 83 ff ff       	call   3361 <lodepng_memcpy>
    b018:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b01b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b01f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b022:	01 45 08             	add    %eax,0x8(%ebp)
    b025:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b028:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b02b:	75 c1                	jne    afee <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b02d:	e9 e6 01 00 00       	jmp    b218 <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    b032:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b039:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b040:	eb 3f                	jmp    b081 <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b042:	8b 45 14             	mov    0x14(%ebp),%eax
    b045:	8b 40 04             	mov    0x4(%eax),%eax
    b048:	50                   	push   %eax
    b049:	ff 75 10             	pushl  0x10(%ebp)
    b04c:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b04f:	50                   	push   %eax
    b050:	e8 71 d1 ff ff       	call   81c6 <readBitsFromReversedStream>
    b055:	83 c4 0c             	add    $0xc,%esp
    b058:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b05b:	8b 45 14             	mov    0x14(%ebp),%eax
    b05e:	8b 40 08             	mov    0x8(%eax),%eax
    b061:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b064:	c1 e2 02             	shl    $0x2,%edx
    b067:	01 d0                	add    %edx,%eax
    b069:	6a 04                	push   $0x4
    b06b:	50                   	push   %eax
    b06c:	ff 75 08             	pushl  0x8(%ebp)
    b06f:	e8 ed 82 ff ff       	call   3361 <lodepng_memcpy>
    b074:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b077:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b07b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b07e:	01 45 08             	add    %eax,0x8(%ebp)
    b081:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b084:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b087:	75 b9                	jne    b042 <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b089:	e9 8a 01 00 00       	jmp    b218 <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b08e:	8b 45 14             	mov    0x14(%ebp),%eax
    b091:	8b 00                	mov    (%eax),%eax
    b093:	83 f8 04             	cmp    $0x4,%eax
    b096:	0f 85 d1 00 00 00    	jne    b16d <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    b09c:	8b 45 14             	mov    0x14(%ebp),%eax
    b09f:	8b 40 04             	mov    0x4(%eax),%eax
    b0a2:	83 f8 08             	cmp    $0x8,%eax
    b0a5:	75 62                	jne    b109 <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0a7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b0ae:	eb 4c                	jmp    b0fc <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b0b0:	8b 45 08             	mov    0x8(%ebp),%eax
    b0b3:	83 c0 01             	add    $0x1,%eax
    b0b6:	8b 55 08             	mov    0x8(%ebp),%edx
    b0b9:	83 c2 02             	add    $0x2,%edx
    b0bc:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b0bf:	01 c9                	add    %ecx,%ecx
    b0c1:	89 cb                	mov    %ecx,%ebx
    b0c3:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b0c6:	01 d9                	add    %ebx,%ecx
    b0c8:	0f b6 09             	movzbl (%ecx),%ecx
    b0cb:	88 0a                	mov    %cl,(%edx)
    b0cd:	0f b6 12             	movzbl (%edx),%edx
    b0d0:	88 10                	mov    %dl,(%eax)
    b0d2:	0f b6 10             	movzbl (%eax),%edx
    b0d5:	8b 45 08             	mov    0x8(%ebp),%eax
    b0d8:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    b0da:	8b 45 08             	mov    0x8(%ebp),%eax
    b0dd:	8d 50 03             	lea    0x3(%eax),%edx
    b0e0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b0e3:	01 c0                	add    %eax,%eax
    b0e5:	8d 48 01             	lea    0x1(%eax),%ecx
    b0e8:	8b 45 10             	mov    0x10(%ebp),%eax
    b0eb:	01 c8                	add    %ecx,%eax
    b0ed:	0f b6 00             	movzbl (%eax),%eax
    b0f0:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0f2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b0f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b0f9:	01 45 08             	add    %eax,0x8(%ebp)
    b0fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b0ff:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b102:	75 ac                	jne    b0b0 <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b104:	e9 0f 01 00 00       	jmp    b218 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b109:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b110:	eb 4e                	jmp    b160 <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b112:	8b 45 08             	mov    0x8(%ebp),%eax
    b115:	83 c0 01             	add    $0x1,%eax
    b118:	8b 55 08             	mov    0x8(%ebp),%edx
    b11b:	83 c2 02             	add    $0x2,%edx
    b11e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b121:	c1 e1 02             	shl    $0x2,%ecx
    b124:	89 cb                	mov    %ecx,%ebx
    b126:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b129:	01 d9                	add    %ebx,%ecx
    b12b:	0f b6 09             	movzbl (%ecx),%ecx
    b12e:	88 0a                	mov    %cl,(%edx)
    b130:	0f b6 12             	movzbl (%edx),%edx
    b133:	88 10                	mov    %dl,(%eax)
    b135:	0f b6 10             	movzbl (%eax),%edx
    b138:	8b 45 08             	mov    0x8(%ebp),%eax
    b13b:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    b13d:	8b 45 08             	mov    0x8(%ebp),%eax
    b140:	8d 50 03             	lea    0x3(%eax),%edx
    b143:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b146:	c1 e0 02             	shl    $0x2,%eax
    b149:	8d 48 02             	lea    0x2(%eax),%ecx
    b14c:	8b 45 10             	mov    0x10(%ebp),%eax
    b14f:	01 c8                	add    %ecx,%eax
    b151:	0f b6 00             	movzbl (%eax),%eax
    b154:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b156:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b15a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b15d:	01 45 08             	add    %eax,0x8(%ebp)
    b160:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b163:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b166:	75 aa                	jne    b112 <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b168:	e9 ab 00 00 00       	jmp    b218 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b16d:	8b 45 14             	mov    0x14(%ebp),%eax
    b170:	8b 00                	mov    (%eax),%eax
    b172:	83 f8 06             	cmp    $0x6,%eax
    b175:	0f 85 9d 00 00 00    	jne    b218 <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    b17b:	8b 45 14             	mov    0x14(%ebp),%eax
    b17e:	8b 40 04             	mov    0x4(%eax),%eax
    b181:	83 f8 08             	cmp    $0x8,%eax
    b184:	75 17                	jne    b19d <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    b186:	8b 45 0c             	mov    0xc(%ebp),%eax
    b189:	c1 e0 02             	shl    $0x2,%eax
    b18c:	50                   	push   %eax
    b18d:	ff 75 10             	pushl  0x10(%ebp)
    b190:	ff 75 08             	pushl  0x8(%ebp)
    b193:	e8 c9 81 ff ff       	call   3361 <lodepng_memcpy>
    b198:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b19b:	eb 7b                	jmp    b218 <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b19d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b1a4:	eb 6a                	jmp    b210 <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    b1a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1a9:	c1 e0 03             	shl    $0x3,%eax
    b1ac:	89 c2                	mov    %eax,%edx
    b1ae:	8b 45 10             	mov    0x10(%ebp),%eax
    b1b1:	01 d0                	add    %edx,%eax
    b1b3:	0f b6 10             	movzbl (%eax),%edx
    b1b6:	8b 45 08             	mov    0x8(%ebp),%eax
    b1b9:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b1bb:	8b 45 08             	mov    0x8(%ebp),%eax
    b1be:	8d 50 01             	lea    0x1(%eax),%edx
    b1c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1c4:	c1 e0 03             	shl    $0x3,%eax
    b1c7:	8d 48 02             	lea    0x2(%eax),%ecx
    b1ca:	8b 45 10             	mov    0x10(%ebp),%eax
    b1cd:	01 c8                	add    %ecx,%eax
    b1cf:	0f b6 00             	movzbl (%eax),%eax
    b1d2:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b1d4:	8b 45 08             	mov    0x8(%ebp),%eax
    b1d7:	8d 50 02             	lea    0x2(%eax),%edx
    b1da:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1dd:	c1 e0 03             	shl    $0x3,%eax
    b1e0:	8d 48 04             	lea    0x4(%eax),%ecx
    b1e3:	8b 45 10             	mov    0x10(%ebp),%eax
    b1e6:	01 c8                	add    %ecx,%eax
    b1e8:	0f b6 00             	movzbl (%eax),%eax
    b1eb:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    b1ed:	8b 45 08             	mov    0x8(%ebp),%eax
    b1f0:	8d 50 03             	lea    0x3(%eax),%edx
    b1f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1f6:	c1 e0 03             	shl    $0x3,%eax
    b1f9:	8d 48 06             	lea    0x6(%eax),%ecx
    b1fc:	8b 45 10             	mov    0x10(%ebp),%eax
    b1ff:	01 c8                	add    %ecx,%eax
    b201:	0f b6 00             	movzbl (%eax),%eax
    b204:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b206:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b20a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b20d:	01 45 08             	add    %eax,0x8(%ebp)
    b210:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b213:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b216:	75 8e                	jne    b1a6 <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b218:	90                   	nop
    b219:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b21c:	c9                   	leave  
    b21d:	c3                   	ret    

0000b21e <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    b21e:	55                   	push   %ebp
    b21f:	89 e5                	mov    %esp,%ebp
    b221:	53                   	push   %ebx
    b222:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    b225:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b22c:	8b 45 14             	mov    0x14(%ebp),%eax
    b22f:	8b 00                	mov    (%eax),%eax
    b231:	85 c0                	test   %eax,%eax
    b233:	0f 85 2a 01 00 00    	jne    b363 <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    b239:	8b 45 14             	mov    0x14(%ebp),%eax
    b23c:	8b 40 04             	mov    0x4(%eax),%eax
    b23f:	83 f8 08             	cmp    $0x8,%eax
    b242:	75 46                	jne    b28a <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b244:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b24b:	eb 30                	jmp    b27d <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b24d:	8b 45 08             	mov    0x8(%ebp),%eax
    b250:	83 c0 01             	add    $0x1,%eax
    b253:	8b 55 08             	mov    0x8(%ebp),%edx
    b256:	83 c2 02             	add    $0x2,%edx
    b259:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b25c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b25f:	01 d9                	add    %ebx,%ecx
    b261:	0f b6 09             	movzbl (%ecx),%ecx
    b264:	88 0a                	mov    %cl,(%edx)
    b266:	0f b6 12             	movzbl (%edx),%edx
    b269:	88 10                	mov    %dl,(%eax)
    b26b:	0f b6 10             	movzbl (%eax),%edx
    b26e:	8b 45 08             	mov    0x8(%ebp),%eax
    b271:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b273:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b277:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b27a:	01 45 08             	add    %eax,0x8(%ebp)
    b27d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b280:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b283:	75 c8                	jne    b24d <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b285:	e9 a8 03 00 00       	jmp    b632 <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    b28a:	8b 45 14             	mov    0x14(%ebp),%eax
    b28d:	8b 40 04             	mov    0x4(%eax),%eax
    b290:	83 f8 10             	cmp    $0x10,%eax
    b293:	75 4a                	jne    b2df <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b295:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b29c:	eb 34                	jmp    b2d2 <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b29e:	8b 45 08             	mov    0x8(%ebp),%eax
    b2a1:	83 c0 01             	add    $0x1,%eax
    b2a4:	8b 55 08             	mov    0x8(%ebp),%edx
    b2a7:	83 c2 02             	add    $0x2,%edx
    b2aa:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b2ad:	01 c9                	add    %ecx,%ecx
    b2af:	89 cb                	mov    %ecx,%ebx
    b2b1:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b2b4:	01 d9                	add    %ebx,%ecx
    b2b6:	0f b6 09             	movzbl (%ecx),%ecx
    b2b9:	88 0a                	mov    %cl,(%edx)
    b2bb:	0f b6 12             	movzbl (%edx),%edx
    b2be:	88 10                	mov    %dl,(%eax)
    b2c0:	0f b6 10             	movzbl (%eax),%edx
    b2c3:	8b 45 08             	mov    0x8(%ebp),%eax
    b2c6:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2c8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b2cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b2cf:	01 45 08             	add    %eax,0x8(%ebp)
    b2d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2d5:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b2d8:	75 c4                	jne    b29e <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b2da:	e9 53 03 00 00       	jmp    b632 <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b2df:	8b 45 14             	mov    0x14(%ebp),%eax
    b2e2:	8b 40 04             	mov    0x4(%eax),%eax
    b2e5:	ba 01 00 00 00       	mov    $0x1,%edx
    b2ea:	89 c1                	mov    %eax,%ecx
    b2ec:	d3 e2                	shl    %cl,%edx
    b2ee:	89 d0                	mov    %edx,%eax
    b2f0:	83 e8 01             	sub    $0x1,%eax
    b2f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b2f6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2fd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b304:	eb 50                	jmp    b356 <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b306:	8b 45 14             	mov    0x14(%ebp),%eax
    b309:	8b 40 04             	mov    0x4(%eax),%eax
    b30c:	50                   	push   %eax
    b30d:	ff 75 10             	pushl  0x10(%ebp)
    b310:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b313:	50                   	push   %eax
    b314:	e8 ad ce ff ff       	call   81c6 <readBitsFromReversedStream>
    b319:	83 c4 0c             	add    $0xc,%esp
    b31c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b31f:	8b 45 08             	mov    0x8(%ebp),%eax
    b322:	8d 48 01             	lea    0x1(%eax),%ecx
    b325:	8b 45 08             	mov    0x8(%ebp),%eax
    b328:	8d 58 02             	lea    0x2(%eax),%ebx
    b32b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b32e:	89 d0                	mov    %edx,%eax
    b330:	c1 e0 08             	shl    $0x8,%eax
    b333:	29 d0                	sub    %edx,%eax
    b335:	ba 00 00 00 00       	mov    $0x0,%edx
    b33a:	f7 75 f0             	divl   -0x10(%ebp)
    b33d:	88 03                	mov    %al,(%ebx)
    b33f:	0f b6 03             	movzbl (%ebx),%eax
    b342:	88 01                	mov    %al,(%ecx)
    b344:	0f b6 11             	movzbl (%ecx),%edx
    b347:	8b 45 08             	mov    0x8(%ebp),%eax
    b34a:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b34c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b350:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b353:	01 45 08             	add    %eax,0x8(%ebp)
    b356:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b359:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b35c:	75 a8                	jne    b306 <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b35e:	e9 cf 02 00 00       	jmp    b632 <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b363:	8b 45 14             	mov    0x14(%ebp),%eax
    b366:	8b 00                	mov    (%eax),%eax
    b368:	83 f8 02             	cmp    $0x2,%eax
    b36b:	0f 85 9e 00 00 00    	jne    b40f <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    b371:	8b 45 14             	mov    0x14(%ebp),%eax
    b374:	8b 40 04             	mov    0x4(%eax),%eax
    b377:	83 f8 08             	cmp    $0x8,%eax
    b37a:	75 1d                	jne    b399 <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    b37c:	8b 55 0c             	mov    0xc(%ebp),%edx
    b37f:	89 d0                	mov    %edx,%eax
    b381:	01 c0                	add    %eax,%eax
    b383:	01 d0                	add    %edx,%eax
    b385:	50                   	push   %eax
    b386:	ff 75 10             	pushl  0x10(%ebp)
    b389:	ff 75 08             	pushl  0x8(%ebp)
    b38c:	e8 d0 7f ff ff       	call   3361 <lodepng_memcpy>
    b391:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b394:	e9 99 02 00 00       	jmp    b632 <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b399:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b3a0:	eb 60                	jmp    b402 <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    b3a2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3a5:	89 d0                	mov    %edx,%eax
    b3a7:	01 c0                	add    %eax,%eax
    b3a9:	01 d0                	add    %edx,%eax
    b3ab:	01 c0                	add    %eax,%eax
    b3ad:	89 c2                	mov    %eax,%edx
    b3af:	8b 45 10             	mov    0x10(%ebp),%eax
    b3b2:	01 d0                	add    %edx,%eax
    b3b4:	0f b6 10             	movzbl (%eax),%edx
    b3b7:	8b 45 08             	mov    0x8(%ebp),%eax
    b3ba:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b3bc:	8b 45 08             	mov    0x8(%ebp),%eax
    b3bf:	8d 48 01             	lea    0x1(%eax),%ecx
    b3c2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3c5:	89 d0                	mov    %edx,%eax
    b3c7:	01 c0                	add    %eax,%eax
    b3c9:	01 d0                	add    %edx,%eax
    b3cb:	01 c0                	add    %eax,%eax
    b3cd:	8d 50 02             	lea    0x2(%eax),%edx
    b3d0:	8b 45 10             	mov    0x10(%ebp),%eax
    b3d3:	01 d0                	add    %edx,%eax
    b3d5:	0f b6 00             	movzbl (%eax),%eax
    b3d8:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b3da:	8b 45 08             	mov    0x8(%ebp),%eax
    b3dd:	8d 48 02             	lea    0x2(%eax),%ecx
    b3e0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3e3:	89 d0                	mov    %edx,%eax
    b3e5:	01 c0                	add    %eax,%eax
    b3e7:	01 d0                	add    %edx,%eax
    b3e9:	01 c0                	add    %eax,%eax
    b3eb:	8d 50 04             	lea    0x4(%eax),%edx
    b3ee:	8b 45 10             	mov    0x10(%ebp),%eax
    b3f1:	01 d0                	add    %edx,%eax
    b3f3:	0f b6 00             	movzbl (%eax),%eax
    b3f6:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3f8:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b3fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3ff:	01 45 08             	add    %eax,0x8(%ebp)
    b402:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b405:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b408:	75 98                	jne    b3a2 <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b40a:	e9 23 02 00 00       	jmp    b632 <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b40f:	8b 45 14             	mov    0x14(%ebp),%eax
    b412:	8b 00                	mov    (%eax),%eax
    b414:	83 f8 03             	cmp    $0x3,%eax
    b417:	0f 85 b4 00 00 00    	jne    b4d1 <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    b41d:	8b 45 14             	mov    0x14(%ebp),%eax
    b420:	8b 40 04             	mov    0x4(%eax),%eax
    b423:	83 f8 08             	cmp    $0x8,%eax
    b426:	75 4d                	jne    b475 <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b428:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b42f:	eb 37                	jmp    b468 <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    b431:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b434:	8b 45 10             	mov    0x10(%ebp),%eax
    b437:	01 d0                	add    %edx,%eax
    b439:	0f b6 00             	movzbl (%eax),%eax
    b43c:	0f b6 c0             	movzbl %al,%eax
    b43f:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b442:	8b 45 14             	mov    0x14(%ebp),%eax
    b445:	8b 40 08             	mov    0x8(%eax),%eax
    b448:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b44b:	c1 e2 02             	shl    $0x2,%edx
    b44e:	01 d0                	add    %edx,%eax
    b450:	6a 03                	push   $0x3
    b452:	50                   	push   %eax
    b453:	ff 75 08             	pushl  0x8(%ebp)
    b456:	e8 06 7f ff ff       	call   3361 <lodepng_memcpy>
    b45b:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b45e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b462:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b465:	01 45 08             	add    %eax,0x8(%ebp)
    b468:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b46b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b46e:	75 c1                	jne    b431 <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b470:	e9 bd 01 00 00       	jmp    b632 <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    b475:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b47c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b483:	eb 3f                	jmp    b4c4 <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b485:	8b 45 14             	mov    0x14(%ebp),%eax
    b488:	8b 40 04             	mov    0x4(%eax),%eax
    b48b:	50                   	push   %eax
    b48c:	ff 75 10             	pushl  0x10(%ebp)
    b48f:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b492:	50                   	push   %eax
    b493:	e8 2e cd ff ff       	call   81c6 <readBitsFromReversedStream>
    b498:	83 c4 0c             	add    $0xc,%esp
    b49b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b49e:	8b 45 14             	mov    0x14(%ebp),%eax
    b4a1:	8b 40 08             	mov    0x8(%eax),%eax
    b4a4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b4a7:	c1 e2 02             	shl    $0x2,%edx
    b4aa:	01 d0                	add    %edx,%eax
    b4ac:	6a 03                	push   $0x3
    b4ae:	50                   	push   %eax
    b4af:	ff 75 08             	pushl  0x8(%ebp)
    b4b2:	e8 aa 7e ff ff       	call   3361 <lodepng_memcpy>
    b4b7:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4ba:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b4be:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b4c1:	01 45 08             	add    %eax,0x8(%ebp)
    b4c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4c7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b4ca:	75 b9                	jne    b485 <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b4cc:	e9 61 01 00 00       	jmp    b632 <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b4d1:	8b 45 14             	mov    0x14(%ebp),%eax
    b4d4:	8b 00                	mov    (%eax),%eax
    b4d6:	83 f8 04             	cmp    $0x4,%eax
    b4d9:	0f 85 a0 00 00 00    	jne    b57f <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    b4df:	8b 45 14             	mov    0x14(%ebp),%eax
    b4e2:	8b 40 04             	mov    0x4(%eax),%eax
    b4e5:	83 f8 08             	cmp    $0x8,%eax
    b4e8:	75 4a                	jne    b534 <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4ea:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b4f1:	eb 34                	jmp    b527 <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b4f3:	8b 45 08             	mov    0x8(%ebp),%eax
    b4f6:	83 c0 01             	add    $0x1,%eax
    b4f9:	8b 55 08             	mov    0x8(%ebp),%edx
    b4fc:	83 c2 02             	add    $0x2,%edx
    b4ff:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b502:	01 c9                	add    %ecx,%ecx
    b504:	89 cb                	mov    %ecx,%ebx
    b506:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b509:	01 d9                	add    %ebx,%ecx
    b50b:	0f b6 09             	movzbl (%ecx),%ecx
    b50e:	88 0a                	mov    %cl,(%edx)
    b510:	0f b6 12             	movzbl (%edx),%edx
    b513:	88 10                	mov    %dl,(%eax)
    b515:	0f b6 10             	movzbl (%eax),%edx
    b518:	8b 45 08             	mov    0x8(%ebp),%eax
    b51b:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b51d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b521:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b524:	01 45 08             	add    %eax,0x8(%ebp)
    b527:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b52a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b52d:	75 c4                	jne    b4f3 <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b52f:	e9 fe 00 00 00       	jmp    b632 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b534:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b53b:	eb 35                	jmp    b572 <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b53d:	8b 45 08             	mov    0x8(%ebp),%eax
    b540:	83 c0 01             	add    $0x1,%eax
    b543:	8b 55 08             	mov    0x8(%ebp),%edx
    b546:	83 c2 02             	add    $0x2,%edx
    b549:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b54c:	c1 e1 02             	shl    $0x2,%ecx
    b54f:	89 cb                	mov    %ecx,%ebx
    b551:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b554:	01 d9                	add    %ebx,%ecx
    b556:	0f b6 09             	movzbl (%ecx),%ecx
    b559:	88 0a                	mov    %cl,(%edx)
    b55b:	0f b6 12             	movzbl (%edx),%edx
    b55e:	88 10                	mov    %dl,(%eax)
    b560:	0f b6 10             	movzbl (%eax),%edx
    b563:	8b 45 08             	mov    0x8(%ebp),%eax
    b566:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b568:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b56c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b56f:	01 45 08             	add    %eax,0x8(%ebp)
    b572:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b575:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b578:	75 c3                	jne    b53d <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b57a:	e9 b3 00 00 00       	jmp    b632 <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b57f:	8b 45 14             	mov    0x14(%ebp),%eax
    b582:	8b 00                	mov    (%eax),%eax
    b584:	83 f8 06             	cmp    $0x6,%eax
    b587:	0f 85 a5 00 00 00    	jne    b632 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    b58d:	8b 45 14             	mov    0x14(%ebp),%eax
    b590:	8b 40 04             	mov    0x4(%eax),%eax
    b593:	83 f8 08             	cmp    $0x8,%eax
    b596:	75 38                	jne    b5d0 <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b598:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b59f:	eb 25                	jmp    b5c6 <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    b5a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5a4:	c1 e0 02             	shl    $0x2,%eax
    b5a7:	89 c2                	mov    %eax,%edx
    b5a9:	8b 45 10             	mov    0x10(%ebp),%eax
    b5ac:	01 d0                	add    %edx,%eax
    b5ae:	6a 03                	push   $0x3
    b5b0:	50                   	push   %eax
    b5b1:	ff 75 08             	pushl  0x8(%ebp)
    b5b4:	e8 a8 7d ff ff       	call   3361 <lodepng_memcpy>
    b5b9:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5bc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b5c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b5c3:	01 45 08             	add    %eax,0x8(%ebp)
    b5c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5c9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b5cc:	75 d3                	jne    b5a1 <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b5ce:	eb 62                	jmp    b632 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5d0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b5d7:	eb 51                	jmp    b62a <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    b5d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5dc:	c1 e0 03             	shl    $0x3,%eax
    b5df:	89 c2                	mov    %eax,%edx
    b5e1:	8b 45 10             	mov    0x10(%ebp),%eax
    b5e4:	01 d0                	add    %edx,%eax
    b5e6:	0f b6 10             	movzbl (%eax),%edx
    b5e9:	8b 45 08             	mov    0x8(%ebp),%eax
    b5ec:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b5ee:	8b 45 08             	mov    0x8(%ebp),%eax
    b5f1:	8d 50 01             	lea    0x1(%eax),%edx
    b5f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5f7:	c1 e0 03             	shl    $0x3,%eax
    b5fa:	8d 48 02             	lea    0x2(%eax),%ecx
    b5fd:	8b 45 10             	mov    0x10(%ebp),%eax
    b600:	01 c8                	add    %ecx,%eax
    b602:	0f b6 00             	movzbl (%eax),%eax
    b605:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b607:	8b 45 08             	mov    0x8(%ebp),%eax
    b60a:	8d 50 02             	lea    0x2(%eax),%edx
    b60d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b610:	c1 e0 03             	shl    $0x3,%eax
    b613:	8d 48 04             	lea    0x4(%eax),%ecx
    b616:	8b 45 10             	mov    0x10(%ebp),%eax
    b619:	01 c8                	add    %ecx,%eax
    b61b:	0f b6 00             	movzbl (%eax),%eax
    b61e:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b620:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b624:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b627:	01 45 08             	add    %eax,0x8(%ebp)
    b62a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b62d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b630:	75 a7                	jne    b5d9 <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b632:	90                   	nop
    b633:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b636:	c9                   	leave  
    b637:	c3                   	ret    

0000b638 <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    b638:	55                   	push   %ebp
    b639:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    b63b:	8b 45 20             	mov    0x20(%ebp),%eax
    b63e:	8b 00                	mov    (%eax),%eax
    b640:	85 c0                	test   %eax,%eax
    b642:	0f 85 a4 00 00 00    	jne    b6ec <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    b648:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b64b:	01 c0                	add    %eax,%eax
    b64d:	89 c2                	mov    %eax,%edx
    b64f:	8b 45 18             	mov    0x18(%ebp),%eax
    b652:	01 d0                	add    %edx,%eax
    b654:	0f b6 00             	movzbl (%eax),%eax
    b657:	0f b6 c0             	movzbl %al,%eax
    b65a:	c1 e0 08             	shl    $0x8,%eax
    b65d:	89 c2                	mov    %eax,%edx
    b65f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b662:	01 c0                	add    %eax,%eax
    b664:	8d 48 01             	lea    0x1(%eax),%ecx
    b667:	8b 45 18             	mov    0x18(%ebp),%eax
    b66a:	01 c8                	add    %ecx,%eax
    b66c:	0f b6 00             	movzbl (%eax),%eax
    b66f:	0f b6 c0             	movzbl %al,%eax
    b672:	01 c2                	add    %eax,%edx
    b674:	8b 45 10             	mov    0x10(%ebp),%eax
    b677:	66 89 10             	mov    %dx,(%eax)
    b67a:	8b 45 10             	mov    0x10(%ebp),%eax
    b67d:	0f b7 10             	movzwl (%eax),%edx
    b680:	8b 45 0c             	mov    0xc(%ebp),%eax
    b683:	66 89 10             	mov    %dx,(%eax)
    b686:	8b 45 0c             	mov    0xc(%ebp),%eax
    b689:	0f b7 10             	movzwl (%eax),%edx
    b68c:	8b 45 08             	mov    0x8(%ebp),%eax
    b68f:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    b692:	8b 45 20             	mov    0x20(%ebp),%eax
    b695:	8b 40 10             	mov    0x10(%eax),%eax
    b698:	85 c0                	test   %eax,%eax
    b69a:	74 43                	je     b6df <getPixelColorRGBA16+0xa7>
    b69c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b69f:	01 c0                	add    %eax,%eax
    b6a1:	89 c2                	mov    %eax,%edx
    b6a3:	8b 45 18             	mov    0x18(%ebp),%eax
    b6a6:	01 d0                	add    %edx,%eax
    b6a8:	0f b6 00             	movzbl (%eax),%eax
    b6ab:	0f b6 c0             	movzbl %al,%eax
    b6ae:	c1 e0 08             	shl    $0x8,%eax
    b6b1:	89 c2                	mov    %eax,%edx
    b6b3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b6b6:	01 c0                	add    %eax,%eax
    b6b8:	8d 48 01             	lea    0x1(%eax),%ecx
    b6bb:	8b 45 18             	mov    0x18(%ebp),%eax
    b6be:	01 c8                	add    %ecx,%eax
    b6c0:	0f b6 00             	movzbl (%eax),%eax
    b6c3:	0f b6 c0             	movzbl %al,%eax
    b6c6:	01 c2                	add    %eax,%edx
    b6c8:	8b 45 20             	mov    0x20(%ebp),%eax
    b6cb:	8b 40 14             	mov    0x14(%eax),%eax
    b6ce:	39 c2                	cmp    %eax,%edx
    b6d0:	75 0d                	jne    b6df <getPixelColorRGBA16+0xa7>
    b6d2:	8b 45 14             	mov    0x14(%ebp),%eax
    b6d5:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b6da:	e9 48 03 00 00       	jmp    ba27 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b6df:	8b 45 14             	mov    0x14(%ebp),%eax
    b6e2:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b6e7:	e9 3b 03 00 00       	jmp    ba27 <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    b6ec:	8b 45 20             	mov    0x20(%ebp),%eax
    b6ef:	8b 00                	mov    (%eax),%eax
    b6f1:	83 f8 02             	cmp    $0x2,%eax
    b6f4:	0f 85 b6 01 00 00    	jne    b8b0 <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    b6fa:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b6fd:	89 d0                	mov    %edx,%eax
    b6ff:	01 c0                	add    %eax,%eax
    b701:	01 d0                	add    %edx,%eax
    b703:	01 c0                	add    %eax,%eax
    b705:	89 c2                	mov    %eax,%edx
    b707:	8b 45 18             	mov    0x18(%ebp),%eax
    b70a:	01 d0                	add    %edx,%eax
    b70c:	0f b6 00             	movzbl (%eax),%eax
    b70f:	0f b6 c0             	movzbl %al,%eax
    b712:	c1 e0 08             	shl    $0x8,%eax
    b715:	89 c1                	mov    %eax,%ecx
    b717:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b71a:	89 d0                	mov    %edx,%eax
    b71c:	01 c0                	add    %eax,%eax
    b71e:	01 d0                	add    %edx,%eax
    b720:	01 c0                	add    %eax,%eax
    b722:	8d 50 01             	lea    0x1(%eax),%edx
    b725:	8b 45 18             	mov    0x18(%ebp),%eax
    b728:	01 d0                	add    %edx,%eax
    b72a:	0f b6 00             	movzbl (%eax),%eax
    b72d:	0f b6 c0             	movzbl %al,%eax
    b730:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b733:	8b 45 08             	mov    0x8(%ebp),%eax
    b736:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    b739:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b73c:	89 d0                	mov    %edx,%eax
    b73e:	01 c0                	add    %eax,%eax
    b740:	01 d0                	add    %edx,%eax
    b742:	01 c0                	add    %eax,%eax
    b744:	8d 50 02             	lea    0x2(%eax),%edx
    b747:	8b 45 18             	mov    0x18(%ebp),%eax
    b74a:	01 d0                	add    %edx,%eax
    b74c:	0f b6 00             	movzbl (%eax),%eax
    b74f:	0f b6 c0             	movzbl %al,%eax
    b752:	c1 e0 08             	shl    $0x8,%eax
    b755:	89 c1                	mov    %eax,%ecx
    b757:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b75a:	89 d0                	mov    %edx,%eax
    b75c:	01 c0                	add    %eax,%eax
    b75e:	01 d0                	add    %edx,%eax
    b760:	01 c0                	add    %eax,%eax
    b762:	8d 50 03             	lea    0x3(%eax),%edx
    b765:	8b 45 18             	mov    0x18(%ebp),%eax
    b768:	01 d0                	add    %edx,%eax
    b76a:	0f b6 00             	movzbl (%eax),%eax
    b76d:	0f b6 c0             	movzbl %al,%eax
    b770:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b773:	8b 45 0c             	mov    0xc(%ebp),%eax
    b776:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    b779:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b77c:	89 d0                	mov    %edx,%eax
    b77e:	01 c0                	add    %eax,%eax
    b780:	01 d0                	add    %edx,%eax
    b782:	01 c0                	add    %eax,%eax
    b784:	8d 50 04             	lea    0x4(%eax),%edx
    b787:	8b 45 18             	mov    0x18(%ebp),%eax
    b78a:	01 d0                	add    %edx,%eax
    b78c:	0f b6 00             	movzbl (%eax),%eax
    b78f:	0f b6 c0             	movzbl %al,%eax
    b792:	c1 e0 08             	shl    $0x8,%eax
    b795:	89 c1                	mov    %eax,%ecx
    b797:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b79a:	89 d0                	mov    %edx,%eax
    b79c:	01 c0                	add    %eax,%eax
    b79e:	01 d0                	add    %edx,%eax
    b7a0:	01 c0                	add    %eax,%eax
    b7a2:	8d 50 05             	lea    0x5(%eax),%edx
    b7a5:	8b 45 18             	mov    0x18(%ebp),%eax
    b7a8:	01 d0                	add    %edx,%eax
    b7aa:	0f b6 00             	movzbl (%eax),%eax
    b7ad:	0f b6 c0             	movzbl %al,%eax
    b7b0:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b7b3:	8b 45 10             	mov    0x10(%ebp),%eax
    b7b6:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    b7b9:	8b 45 20             	mov    0x20(%ebp),%eax
    b7bc:	8b 40 10             	mov    0x10(%eax),%eax
    b7bf:	85 c0                	test   %eax,%eax
    b7c1:	0f 84 dc 00 00 00    	je     b8a3 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b7c7:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7ca:	89 d0                	mov    %edx,%eax
    b7cc:	01 c0                	add    %eax,%eax
    b7ce:	01 d0                	add    %edx,%eax
    b7d0:	01 c0                	add    %eax,%eax
    b7d2:	89 c2                	mov    %eax,%edx
    b7d4:	8b 45 18             	mov    0x18(%ebp),%eax
    b7d7:	01 d0                	add    %edx,%eax
    b7d9:	0f b6 00             	movzbl (%eax),%eax
    b7dc:	0f b6 c0             	movzbl %al,%eax
    b7df:	c1 e0 08             	shl    $0x8,%eax
    b7e2:	89 c1                	mov    %eax,%ecx
    b7e4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7e7:	89 d0                	mov    %edx,%eax
    b7e9:	01 c0                	add    %eax,%eax
    b7eb:	01 d0                	add    %edx,%eax
    b7ed:	01 c0                	add    %eax,%eax
    b7ef:	8d 50 01             	lea    0x1(%eax),%edx
    b7f2:	8b 45 18             	mov    0x18(%ebp),%eax
    b7f5:	01 d0                	add    %edx,%eax
    b7f7:	0f b6 00             	movzbl (%eax),%eax
    b7fa:	0f b6 c0             	movzbl %al,%eax
    b7fd:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b800:	8b 45 20             	mov    0x20(%ebp),%eax
    b803:	8b 40 14             	mov    0x14(%eax),%eax
    b806:	39 c2                	cmp    %eax,%edx
    b808:	0f 85 95 00 00 00    	jne    b8a3 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b80e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b811:	89 d0                	mov    %edx,%eax
    b813:	01 c0                	add    %eax,%eax
    b815:	01 d0                	add    %edx,%eax
    b817:	01 c0                	add    %eax,%eax
    b819:	8d 50 02             	lea    0x2(%eax),%edx
    b81c:	8b 45 18             	mov    0x18(%ebp),%eax
    b81f:	01 d0                	add    %edx,%eax
    b821:	0f b6 00             	movzbl (%eax),%eax
    b824:	0f b6 c0             	movzbl %al,%eax
    b827:	c1 e0 08             	shl    $0x8,%eax
    b82a:	89 c1                	mov    %eax,%ecx
    b82c:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b82f:	89 d0                	mov    %edx,%eax
    b831:	01 c0                	add    %eax,%eax
    b833:	01 d0                	add    %edx,%eax
    b835:	01 c0                	add    %eax,%eax
    b837:	8d 50 03             	lea    0x3(%eax),%edx
    b83a:	8b 45 18             	mov    0x18(%ebp),%eax
    b83d:	01 d0                	add    %edx,%eax
    b83f:	0f b6 00             	movzbl (%eax),%eax
    b842:	0f b6 c0             	movzbl %al,%eax
    b845:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b848:	8b 45 20             	mov    0x20(%ebp),%eax
    b84b:	8b 40 18             	mov    0x18(%eax),%eax
    b84e:	39 c2                	cmp    %eax,%edx
    b850:	75 51                	jne    b8a3 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    b852:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b855:	89 d0                	mov    %edx,%eax
    b857:	01 c0                	add    %eax,%eax
    b859:	01 d0                	add    %edx,%eax
    b85b:	01 c0                	add    %eax,%eax
    b85d:	8d 50 04             	lea    0x4(%eax),%edx
    b860:	8b 45 18             	mov    0x18(%ebp),%eax
    b863:	01 d0                	add    %edx,%eax
    b865:	0f b6 00             	movzbl (%eax),%eax
    b868:	0f b6 c0             	movzbl %al,%eax
    b86b:	c1 e0 08             	shl    $0x8,%eax
    b86e:	89 c1                	mov    %eax,%ecx
    b870:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b873:	89 d0                	mov    %edx,%eax
    b875:	01 c0                	add    %eax,%eax
    b877:	01 d0                	add    %edx,%eax
    b879:	01 c0                	add    %eax,%eax
    b87b:	8d 50 05             	lea    0x5(%eax),%edx
    b87e:	8b 45 18             	mov    0x18(%ebp),%eax
    b881:	01 d0                	add    %edx,%eax
    b883:	0f b6 00             	movzbl (%eax),%eax
    b886:	0f b6 c0             	movzbl %al,%eax
    b889:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b88c:	8b 45 20             	mov    0x20(%ebp),%eax
    b88f:	8b 40 1c             	mov    0x1c(%eax),%eax
    b892:	39 c2                	cmp    %eax,%edx
    b894:	75 0d                	jne    b8a3 <getPixelColorRGBA16+0x26b>
    b896:	8b 45 14             	mov    0x14(%ebp),%eax
    b899:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b89e:	e9 84 01 00 00       	jmp    ba27 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b8a3:	8b 45 14             	mov    0x14(%ebp),%eax
    b8a6:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b8ab:	e9 77 01 00 00       	jmp    ba27 <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b8b0:	8b 45 20             	mov    0x20(%ebp),%eax
    b8b3:	8b 00                	mov    (%eax),%eax
    b8b5:	83 f8 04             	cmp    $0x4,%eax
    b8b8:	0f 85 86 00 00 00    	jne    b944 <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    b8be:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b8c1:	c1 e0 02             	shl    $0x2,%eax
    b8c4:	89 c2                	mov    %eax,%edx
    b8c6:	8b 45 18             	mov    0x18(%ebp),%eax
    b8c9:	01 d0                	add    %edx,%eax
    b8cb:	0f b6 00             	movzbl (%eax),%eax
    b8ce:	0f b6 c0             	movzbl %al,%eax
    b8d1:	c1 e0 08             	shl    $0x8,%eax
    b8d4:	89 c2                	mov    %eax,%edx
    b8d6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b8d9:	c1 e0 02             	shl    $0x2,%eax
    b8dc:	8d 48 01             	lea    0x1(%eax),%ecx
    b8df:	8b 45 18             	mov    0x18(%ebp),%eax
    b8e2:	01 c8                	add    %ecx,%eax
    b8e4:	0f b6 00             	movzbl (%eax),%eax
    b8e7:	0f b6 c0             	movzbl %al,%eax
    b8ea:	01 c2                	add    %eax,%edx
    b8ec:	8b 45 10             	mov    0x10(%ebp),%eax
    b8ef:	66 89 10             	mov    %dx,(%eax)
    b8f2:	8b 45 10             	mov    0x10(%ebp),%eax
    b8f5:	0f b7 10             	movzwl (%eax),%edx
    b8f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8fb:	66 89 10             	mov    %dx,(%eax)
    b8fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    b901:	0f b7 10             	movzwl (%eax),%edx
    b904:	8b 45 08             	mov    0x8(%ebp),%eax
    b907:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    b90a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b90d:	c1 e0 02             	shl    $0x2,%eax
    b910:	8d 50 02             	lea    0x2(%eax),%edx
    b913:	8b 45 18             	mov    0x18(%ebp),%eax
    b916:	01 d0                	add    %edx,%eax
    b918:	0f b6 00             	movzbl (%eax),%eax
    b91b:	0f b6 c0             	movzbl %al,%eax
    b91e:	c1 e0 08             	shl    $0x8,%eax
    b921:	89 c2                	mov    %eax,%edx
    b923:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b926:	c1 e0 02             	shl    $0x2,%eax
    b929:	8d 48 03             	lea    0x3(%eax),%ecx
    b92c:	8b 45 18             	mov    0x18(%ebp),%eax
    b92f:	01 c8                	add    %ecx,%eax
    b931:	0f b6 00             	movzbl (%eax),%eax
    b934:	0f b6 c0             	movzbl %al,%eax
    b937:	01 c2                	add    %eax,%edx
    b939:	8b 45 14             	mov    0x14(%ebp),%eax
    b93c:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b93f:	e9 e3 00 00 00       	jmp    ba27 <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    b944:	8b 45 20             	mov    0x20(%ebp),%eax
    b947:	8b 00                	mov    (%eax),%eax
    b949:	83 f8 06             	cmp    $0x6,%eax
    b94c:	0f 85 d5 00 00 00    	jne    ba27 <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    b952:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b955:	c1 e0 03             	shl    $0x3,%eax
    b958:	89 c2                	mov    %eax,%edx
    b95a:	8b 45 18             	mov    0x18(%ebp),%eax
    b95d:	01 d0                	add    %edx,%eax
    b95f:	0f b6 00             	movzbl (%eax),%eax
    b962:	0f b6 c0             	movzbl %al,%eax
    b965:	c1 e0 08             	shl    $0x8,%eax
    b968:	89 c2                	mov    %eax,%edx
    b96a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b96d:	c1 e0 03             	shl    $0x3,%eax
    b970:	8d 48 01             	lea    0x1(%eax),%ecx
    b973:	8b 45 18             	mov    0x18(%ebp),%eax
    b976:	01 c8                	add    %ecx,%eax
    b978:	0f b6 00             	movzbl (%eax),%eax
    b97b:	0f b6 c0             	movzbl %al,%eax
    b97e:	01 c2                	add    %eax,%edx
    b980:	8b 45 08             	mov    0x8(%ebp),%eax
    b983:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    b986:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b989:	c1 e0 03             	shl    $0x3,%eax
    b98c:	8d 50 02             	lea    0x2(%eax),%edx
    b98f:	8b 45 18             	mov    0x18(%ebp),%eax
    b992:	01 d0                	add    %edx,%eax
    b994:	0f b6 00             	movzbl (%eax),%eax
    b997:	0f b6 c0             	movzbl %al,%eax
    b99a:	c1 e0 08             	shl    $0x8,%eax
    b99d:	89 c2                	mov    %eax,%edx
    b99f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9a2:	c1 e0 03             	shl    $0x3,%eax
    b9a5:	8d 48 03             	lea    0x3(%eax),%ecx
    b9a8:	8b 45 18             	mov    0x18(%ebp),%eax
    b9ab:	01 c8                	add    %ecx,%eax
    b9ad:	0f b6 00             	movzbl (%eax),%eax
    b9b0:	0f b6 c0             	movzbl %al,%eax
    b9b3:	01 c2                	add    %eax,%edx
    b9b5:	8b 45 0c             	mov    0xc(%ebp),%eax
    b9b8:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    b9bb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9be:	c1 e0 03             	shl    $0x3,%eax
    b9c1:	8d 50 04             	lea    0x4(%eax),%edx
    b9c4:	8b 45 18             	mov    0x18(%ebp),%eax
    b9c7:	01 d0                	add    %edx,%eax
    b9c9:	0f b6 00             	movzbl (%eax),%eax
    b9cc:	0f b6 c0             	movzbl %al,%eax
    b9cf:	c1 e0 08             	shl    $0x8,%eax
    b9d2:	89 c2                	mov    %eax,%edx
    b9d4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9d7:	c1 e0 03             	shl    $0x3,%eax
    b9da:	8d 48 05             	lea    0x5(%eax),%ecx
    b9dd:	8b 45 18             	mov    0x18(%ebp),%eax
    b9e0:	01 c8                	add    %ecx,%eax
    b9e2:	0f b6 00             	movzbl (%eax),%eax
    b9e5:	0f b6 c0             	movzbl %al,%eax
    b9e8:	01 c2                	add    %eax,%edx
    b9ea:	8b 45 10             	mov    0x10(%ebp),%eax
    b9ed:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    b9f0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9f3:	c1 e0 03             	shl    $0x3,%eax
    b9f6:	8d 50 06             	lea    0x6(%eax),%edx
    b9f9:	8b 45 18             	mov    0x18(%ebp),%eax
    b9fc:	01 d0                	add    %edx,%eax
    b9fe:	0f b6 00             	movzbl (%eax),%eax
    ba01:	0f b6 c0             	movzbl %al,%eax
    ba04:	c1 e0 08             	shl    $0x8,%eax
    ba07:	89 c2                	mov    %eax,%edx
    ba09:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba0c:	c1 e0 03             	shl    $0x3,%eax
    ba0f:	8d 48 07             	lea    0x7(%eax),%ecx
    ba12:	8b 45 18             	mov    0x18(%ebp),%eax
    ba15:	01 c8                	add    %ecx,%eax
    ba17:	0f b6 00             	movzbl (%eax),%eax
    ba1a:	0f b6 c0             	movzbl %al,%eax
    ba1d:	01 c2                	add    %eax,%edx
    ba1f:	8b 45 14             	mov    0x14(%ebp),%eax
    ba22:	66 89 10             	mov    %dx,(%eax)
  }
}
    ba25:	eb 00                	jmp    ba27 <getPixelColorRGBA16+0x3ef>
    ba27:	90                   	nop
    ba28:	5d                   	pop    %ebp
    ba29:	c3                   	ret    

0000ba2a <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    ba2a:	55                   	push   %ebp
    ba2b:	89 e5                	mov    %esp,%ebp
    ba2d:	56                   	push   %esi
    ba2e:	53                   	push   %ebx
    ba2f:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    ba32:	8b 55 18             	mov    0x18(%ebp),%edx
    ba35:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba38:	0f af c2             	imul   %edx,%eax
    ba3b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    ba3e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    ba45:	8b 45 14             	mov    0x14(%ebp),%eax
    ba48:	8b 00                	mov    (%eax),%eax
    ba4a:	83 f8 03             	cmp    $0x3,%eax
    ba4d:	75 14                	jne    ba63 <lodepng_convert+0x39>
    ba4f:	8b 45 14             	mov    0x14(%ebp),%eax
    ba52:	8b 40 08             	mov    0x8(%eax),%eax
    ba55:	85 c0                	test   %eax,%eax
    ba57:	75 0a                	jne    ba63 <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    ba59:	b8 6b 00 00 00       	mov    $0x6b,%eax
    ba5e:	e9 19 03 00 00       	jmp    bd7c <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    ba63:	ff 75 14             	pushl  0x14(%ebp)
    ba66:	ff 75 10             	pushl  0x10(%ebp)
    ba69:	e8 b7 d1 ff ff       	call   8c25 <lodepng_color_mode_equal>
    ba6e:	83 c4 08             	add    $0x8,%esp
    ba71:	85 c0                	test   %eax,%eax
    ba73:	74 2f                	je     baa4 <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    ba75:	ff 75 14             	pushl  0x14(%ebp)
    ba78:	ff 75 1c             	pushl  0x1c(%ebp)
    ba7b:	ff 75 18             	pushl  0x18(%ebp)
    ba7e:	e8 fb d4 ff ff       	call   8f7e <lodepng_get_raw_size>
    ba83:	83 c4 0c             	add    $0xc,%esp
    ba86:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    ba89:	ff 75 dc             	pushl  -0x24(%ebp)
    ba8c:	ff 75 0c             	pushl  0xc(%ebp)
    ba8f:	ff 75 08             	pushl  0x8(%ebp)
    ba92:	e8 ca 78 ff ff       	call   3361 <lodepng_memcpy>
    ba97:	83 c4 0c             	add    $0xc,%esp
    return 0;
    ba9a:	b8 00 00 00 00       	mov    $0x0,%eax
    ba9f:	e9 d8 02 00 00       	jmp    bd7c <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    baa4:	8b 45 10             	mov    0x10(%ebp),%eax
    baa7:	8b 00                	mov    (%eax),%eax
    baa9:	83 f8 03             	cmp    $0x3,%eax
    baac:	0f 85 16 01 00 00    	jne    bbc8 <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    bab2:	8b 45 10             	mov    0x10(%ebp),%eax
    bab5:	8b 40 0c             	mov    0xc(%eax),%eax
    bab8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    babb:	8b 45 10             	mov    0x10(%ebp),%eax
    babe:	8b 40 08             	mov    0x8(%eax),%eax
    bac1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    bac4:	8b 45 10             	mov    0x10(%ebp),%eax
    bac7:	8b 40 04             	mov    0x4(%eax),%eax
    baca:	ba 01 00 00 00       	mov    $0x1,%edx
    bacf:	89 c1                	mov    %eax,%ecx
    bad1:	d3 e2                	shl    %cl,%edx
    bad3:	89 d0                	mov    %edx,%eax
    bad5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    bad8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    badc:	75 5b                	jne    bb39 <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    bade:	8b 45 14             	mov    0x14(%ebp),%eax
    bae1:	8b 40 0c             	mov    0xc(%eax),%eax
    bae4:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    bae7:	8b 45 14             	mov    0x14(%ebp),%eax
    baea:	8b 40 08             	mov    0x8(%eax),%eax
    baed:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    baf0:	8b 45 14             	mov    0x14(%ebp),%eax
    baf3:	8b 00                	mov    (%eax),%eax
    baf5:	83 f8 03             	cmp    $0x3,%eax
    baf8:	75 3f                	jne    bb39 <lodepng_convert+0x10f>
    bafa:	8b 45 14             	mov    0x14(%ebp),%eax
    bafd:	8b 50 04             	mov    0x4(%eax),%edx
    bb00:	8b 45 10             	mov    0x10(%ebp),%eax
    bb03:	8b 40 04             	mov    0x4(%eax),%eax
    bb06:	39 c2                	cmp    %eax,%edx
    bb08:	75 2f                	jne    bb39 <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bb0a:	ff 75 14             	pushl  0x14(%ebp)
    bb0d:	ff 75 1c             	pushl  0x1c(%ebp)
    bb10:	ff 75 18             	pushl  0x18(%ebp)
    bb13:	e8 66 d4 ff ff       	call   8f7e <lodepng_get_raw_size>
    bb18:	83 c4 0c             	add    $0xc,%esp
    bb1b:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    bb1e:	ff 75 d8             	pushl  -0x28(%ebp)
    bb21:	ff 75 0c             	pushl  0xc(%ebp)
    bb24:	ff 75 08             	pushl  0x8(%ebp)
    bb27:	e8 35 78 ff ff       	call   3361 <lodepng_memcpy>
    bb2c:	83 c4 0c             	add    $0xc,%esp
        return 0;
    bb2f:	b8 00 00 00 00       	mov    $0x0,%eax
    bb34:	e9 43 02 00 00       	jmp    bd7c <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    bb39:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bb3c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bb3f:	7d 06                	jge    bb47 <lodepng_convert+0x11d>
    bb41:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bb44:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    bb47:	8d 45 90             	lea    -0x70(%ebp),%eax
    bb4a:	50                   	push   %eax
    bb4b:	e8 5f e1 ff ff       	call   9caf <color_tree_init>
    bb50:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    bb53:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bb5a:	eb 61                	jmp    bbbd <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    bb5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bb5f:	c1 e0 02             	shl    $0x2,%eax
    bb62:	89 c2                	mov    %eax,%edx
    bb64:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bb67:	01 d0                	add    %edx,%eax
    bb69:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    bb6c:	8b 75 f4             	mov    -0xc(%ebp),%esi
    bb6f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb72:	83 c0 03             	add    $0x3,%eax
    bb75:	0f b6 00             	movzbl (%eax),%eax
    bb78:	0f b6 d8             	movzbl %al,%ebx
    bb7b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb7e:	83 c0 02             	add    $0x2,%eax
    bb81:	0f b6 00             	movzbl (%eax),%eax
    bb84:	0f b6 c8             	movzbl %al,%ecx
    bb87:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb8a:	83 c0 01             	add    $0x1,%eax
    bb8d:	0f b6 00             	movzbl (%eax),%eax
    bb90:	0f b6 d0             	movzbl %al,%edx
    bb93:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb96:	0f b6 00             	movzbl (%eax),%eax
    bb99:	0f b6 c0             	movzbl %al,%eax
    bb9c:	83 ec 08             	sub    $0x8,%esp
    bb9f:	56                   	push   %esi
    bba0:	53                   	push   %ebx
    bba1:	51                   	push   %ecx
    bba2:	52                   	push   %edx
    bba3:	50                   	push   %eax
    bba4:	8d 45 90             	lea    -0x70(%ebp),%eax
    bba7:	50                   	push   %eax
    bba8:	e8 85 e2 ff ff       	call   9e32 <color_tree_add>
    bbad:	83 c4 20             	add    $0x20,%esp
    bbb0:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    bbb3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bbb7:	75 0e                	jne    bbc7 <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    bbb9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bbbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bbc0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bbc3:	75 97                	jne    bb5c <lodepng_convert+0x132>
    bbc5:	eb 01                	jmp    bbc8 <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    bbc7:	90                   	nop
    }
  }

  if(!error) {
    bbc8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bbcc:	0f 85 8e 01 00 00    	jne    bd60 <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bbd2:	8b 45 14             	mov    0x14(%ebp),%eax
    bbd5:	8b 40 04             	mov    0x4(%eax),%eax
    bbd8:	83 f8 10             	cmp    $0x10,%eax
    bbdb:	0f 85 99 00 00 00    	jne    bc7a <lodepng_convert+0x250>
    bbe1:	8b 45 10             	mov    0x10(%ebp),%eax
    bbe4:	8b 40 04             	mov    0x4(%eax),%eax
    bbe7:	83 f8 10             	cmp    $0x10,%eax
    bbea:	0f 85 8a 00 00 00    	jne    bc7a <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    bbf0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bbf7:	eb 74                	jmp    bc6d <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    bbf9:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    bbff:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    bc05:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    bc0b:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    bc11:	83 ec 04             	sub    $0x4,%esp
    bc14:	ff 75 14             	pushl  0x14(%ebp)
    bc17:	ff 75 f4             	pushl  -0xc(%ebp)
    bc1a:	ff 75 0c             	pushl  0xc(%ebp)
    bc1d:	8d 45 88             	lea    -0x78(%ebp),%eax
    bc20:	50                   	push   %eax
    bc21:	8d 45 8a             	lea    -0x76(%ebp),%eax
    bc24:	50                   	push   %eax
    bc25:	8d 45 8c             	lea    -0x74(%ebp),%eax
    bc28:	50                   	push   %eax
    bc29:	8d 45 8e             	lea    -0x72(%ebp),%eax
    bc2c:	50                   	push   %eax
    bc2d:	e8 06 fa ff ff       	call   b638 <getPixelColorRGBA16>
    bc32:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    bc35:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    bc39:	0f b7 d8             	movzwl %ax,%ebx
    bc3c:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    bc40:	0f b7 c8             	movzwl %ax,%ecx
    bc43:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    bc47:	0f b7 d0             	movzwl %ax,%edx
    bc4a:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    bc4e:	0f b7 c0             	movzwl %ax,%eax
    bc51:	83 ec 04             	sub    $0x4,%esp
    bc54:	53                   	push   %ebx
    bc55:	51                   	push   %ecx
    bc56:	52                   	push   %edx
    bc57:	50                   	push   %eax
    bc58:	ff 75 10             	pushl  0x10(%ebp)
    bc5b:	ff 75 f4             	pushl  -0xc(%ebp)
    bc5e:	ff 75 08             	pushl  0x8(%ebp)
    bc61:	e8 d3 e6 ff ff       	call   a339 <rgba16ToPixel>
    bc66:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    bc69:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bc6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bc70:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bc73:	75 84                	jne    bbf9 <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bc75:	e9 e6 00 00 00       	jmp    bd60 <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    bc7a:	8b 45 10             	mov    0x10(%ebp),%eax
    bc7d:	8b 40 04             	mov    0x4(%eax),%eax
    bc80:	83 f8 08             	cmp    $0x8,%eax
    bc83:	75 23                	jne    bca8 <lodepng_convert+0x27e>
    bc85:	8b 45 10             	mov    0x10(%ebp),%eax
    bc88:	8b 00                	mov    (%eax),%eax
    bc8a:	83 f8 06             	cmp    $0x6,%eax
    bc8d:	75 19                	jne    bca8 <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    bc8f:	ff 75 14             	pushl  0x14(%ebp)
    bc92:	ff 75 0c             	pushl  0xc(%ebp)
    bc95:	ff 75 e0             	pushl  -0x20(%ebp)
    bc98:	ff 75 08             	pushl  0x8(%ebp)
    bc9b:	e8 ae ee ff ff       	call   ab4e <getPixelColorsRGBA8>
    bca0:	83 c4 10             	add    $0x10,%esp
    bca3:	e9 b8 00 00 00       	jmp    bd60 <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    bca8:	8b 45 10             	mov    0x10(%ebp),%eax
    bcab:	8b 40 04             	mov    0x4(%eax),%eax
    bcae:	83 f8 08             	cmp    $0x8,%eax
    bcb1:	75 23                	jne    bcd6 <lodepng_convert+0x2ac>
    bcb3:	8b 45 10             	mov    0x10(%ebp),%eax
    bcb6:	8b 00                	mov    (%eax),%eax
    bcb8:	83 f8 02             	cmp    $0x2,%eax
    bcbb:	75 19                	jne    bcd6 <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    bcbd:	ff 75 14             	pushl  0x14(%ebp)
    bcc0:	ff 75 0c             	pushl  0xc(%ebp)
    bcc3:	ff 75 e0             	pushl  -0x20(%ebp)
    bcc6:	ff 75 08             	pushl  0x8(%ebp)
    bcc9:	e8 50 f5 ff ff       	call   b21e <getPixelColorsRGB8>
    bcce:	83 c4 10             	add    $0x10,%esp
    bcd1:	e9 8a 00 00 00       	jmp    bd60 <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    bcd6:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    bcda:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    bcde:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    bce2:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    bce6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bced:	eb 66                	jmp    bd55 <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    bcef:	83 ec 04             	sub    $0x4,%esp
    bcf2:	ff 75 14             	pushl  0x14(%ebp)
    bcf5:	ff 75 f4             	pushl  -0xc(%ebp)
    bcf8:	ff 75 0c             	pushl  0xc(%ebp)
    bcfb:	8d 45 84             	lea    -0x7c(%ebp),%eax
    bcfe:	50                   	push   %eax
    bcff:	8d 45 85             	lea    -0x7b(%ebp),%eax
    bd02:	50                   	push   %eax
    bd03:	8d 45 86             	lea    -0x7a(%ebp),%eax
    bd06:	50                   	push   %eax
    bd07:	8d 45 87             	lea    -0x79(%ebp),%eax
    bd0a:	50                   	push   %eax
    bd0b:	e8 71 e8 ff ff       	call   a581 <getPixelColorRGBA8>
    bd10:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    bd13:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    bd17:	0f b6 d8             	movzbl %al,%ebx
    bd1a:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    bd1e:	0f b6 c8             	movzbl %al,%ecx
    bd21:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    bd25:	0f b6 d0             	movzbl %al,%edx
    bd28:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    bd2c:	0f b6 c0             	movzbl %al,%eax
    bd2f:	53                   	push   %ebx
    bd30:	51                   	push   %ecx
    bd31:	52                   	push   %edx
    bd32:	50                   	push   %eax
    bd33:	8d 45 90             	lea    -0x70(%ebp),%eax
    bd36:	50                   	push   %eax
    bd37:	ff 75 10             	pushl  0x10(%ebp)
    bd3a:	ff 75 f4             	pushl  -0xc(%ebp)
    bd3d:	ff 75 08             	pushl  0x8(%ebp)
    bd40:	e8 e5 e1 ff ff       	call   9f2a <rgba8ToPixel>
    bd45:	83 c4 20             	add    $0x20,%esp
    bd48:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    bd4b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bd4f:	75 0e                	jne    bd5f <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    bd51:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bd55:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bd58:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bd5b:	75 92                	jne    bcef <lodepng_convert+0x2c5>
    bd5d:	eb 01                	jmp    bd60 <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    bd5f:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    bd60:	8b 45 10             	mov    0x10(%ebp),%eax
    bd63:	8b 00                	mov    (%eax),%eax
    bd65:	83 f8 03             	cmp    $0x3,%eax
    bd68:	75 0f                	jne    bd79 <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    bd6a:	83 ec 0c             	sub    $0xc,%esp
    bd6d:	8d 45 90             	lea    -0x70(%ebp),%eax
    bd70:	50                   	push   %eax
    bd71:	e8 59 df ff ff       	call   9ccf <color_tree_cleanup>
    bd76:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    bd79:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    bd7c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    bd7f:	5b                   	pop    %ebx
    bd80:	5e                   	pop    %esi
    bd81:	5d                   	pop    %ebp
    bd82:	c3                   	ret    

0000bd83 <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    bd83:	55                   	push   %ebp
    bd84:	89 e5                	mov    %esp,%ebp
    bd86:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    bd89:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    bd90:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bd97:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    bd9e:	8b 45 24             	mov    0x24(%ebp),%eax
    bda1:	8b 40 04             	mov    0x4(%eax),%eax
    bda4:	ba 01 00 00 00       	mov    $0x1,%edx
    bda9:	89 c1                	mov    %eax,%ecx
    bdab:	d3 e2                	shl    %cl,%edx
    bdad:	89 d0                	mov    %edx,%eax
    bdaf:	8d 48 ff             	lea    -0x1(%eax),%ecx
    bdb2:	b8 ff ff 00 00       	mov    $0xffff,%eax
    bdb7:	ba 00 00 00 00       	mov    $0x0,%edx
    bdbc:	f7 f1                	div    %ecx
    bdbe:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    bdc1:	8b 45 20             	mov    0x20(%ebp),%eax
    bdc4:	8b 40 04             	mov    0x4(%eax),%eax
    bdc7:	ba 10 00 00 00       	mov    $0x10,%edx
    bdcc:	29 c2                	sub    %eax,%edx
    bdce:	89 d0                	mov    %edx,%eax
    bdd0:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    bdd3:	8b 45 24             	mov    0x24(%ebp),%eax
    bdd6:	8b 00                	mov    (%eax),%eax
    bdd8:	85 c0                	test   %eax,%eax
    bdda:	74 0a                	je     bde6 <lodepng_convert_rgb+0x63>
    bddc:	8b 45 24             	mov    0x24(%ebp),%eax
    bddf:	8b 00                	mov    (%eax),%eax
    bde1:	83 f8 04             	cmp    $0x4,%eax
    bde4:	75 1b                	jne    be01 <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    bde6:	8b 45 14             	mov    0x14(%ebp),%eax
    bde9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bded:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bdf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bdf3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    bdf6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bdf9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    bdfc:	e9 c2 00 00 00       	jmp    bec3 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    be01:	8b 45 24             	mov    0x24(%ebp),%eax
    be04:	8b 00                	mov    (%eax),%eax
    be06:	83 f8 02             	cmp    $0x2,%eax
    be09:	74 0a                	je     be15 <lodepng_convert_rgb+0x92>
    be0b:	8b 45 24             	mov    0x24(%ebp),%eax
    be0e:	8b 00                	mov    (%eax),%eax
    be10:	83 f8 06             	cmp    $0x6,%eax
    be13:	75 23                	jne    be38 <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    be15:	8b 45 14             	mov    0x14(%ebp),%eax
    be18:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be1c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    be1f:	8b 45 18             	mov    0x18(%ebp),%eax
    be22:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be26:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    be29:	8b 45 1c             	mov    0x1c(%ebp),%eax
    be2c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be30:	89 45 f4             	mov    %eax,-0xc(%ebp)
    be33:	e9 8b 00 00 00       	jmp    bec3 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    be38:	8b 45 24             	mov    0x24(%ebp),%eax
    be3b:	8b 00                	mov    (%eax),%eax
    be3d:	83 f8 03             	cmp    $0x3,%eax
    be40:	75 77                	jne    beb9 <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    be42:	8b 45 24             	mov    0x24(%ebp),%eax
    be45:	8b 40 0c             	mov    0xc(%eax),%eax
    be48:	3b 45 14             	cmp    0x14(%ebp),%eax
    be4b:	77 0a                	ja     be57 <lodepng_convert_rgb+0xd4>
    be4d:	b8 52 00 00 00       	mov    $0x52,%eax
    be52:	e9 cb 01 00 00       	jmp    c022 <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    be57:	8b 45 24             	mov    0x24(%ebp),%eax
    be5a:	8b 40 08             	mov    0x8(%eax),%eax
    be5d:	8b 55 14             	mov    0x14(%ebp),%edx
    be60:	c1 e2 02             	shl    $0x2,%edx
    be63:	01 d0                	add    %edx,%eax
    be65:	0f b6 00             	movzbl (%eax),%eax
    be68:	0f b6 d0             	movzbl %al,%edx
    be6b:	89 d0                	mov    %edx,%eax
    be6d:	c1 e0 08             	shl    $0x8,%eax
    be70:	01 d0                	add    %edx,%eax
    be72:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    be75:	8b 45 24             	mov    0x24(%ebp),%eax
    be78:	8b 40 08             	mov    0x8(%eax),%eax
    be7b:	8b 55 14             	mov    0x14(%ebp),%edx
    be7e:	c1 e2 02             	shl    $0x2,%edx
    be81:	83 c2 01             	add    $0x1,%edx
    be84:	01 d0                	add    %edx,%eax
    be86:	0f b6 00             	movzbl (%eax),%eax
    be89:	0f b6 d0             	movzbl %al,%edx
    be8c:	89 d0                	mov    %edx,%eax
    be8e:	c1 e0 08             	shl    $0x8,%eax
    be91:	01 d0                	add    %edx,%eax
    be93:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    be96:	8b 45 24             	mov    0x24(%ebp),%eax
    be99:	8b 40 08             	mov    0x8(%eax),%eax
    be9c:	8b 55 14             	mov    0x14(%ebp),%edx
    be9f:	c1 e2 02             	shl    $0x2,%edx
    bea2:	83 c2 02             	add    $0x2,%edx
    bea5:	01 d0                	add    %edx,%eax
    bea7:	0f b6 00             	movzbl (%eax),%eax
    beaa:	0f b6 d0             	movzbl %al,%edx
    bead:	89 d0                	mov    %edx,%eax
    beaf:	c1 e0 08             	shl    $0x8,%eax
    beb2:	01 d0                	add    %edx,%eax
    beb4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    beb7:	eb 0a                	jmp    bec3 <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    beb9:	b8 1f 00 00 00       	mov    $0x1f,%eax
    bebe:	e9 5f 01 00 00       	jmp    c022 <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    bec3:	8b 45 20             	mov    0x20(%ebp),%eax
    bec6:	8b 00                	mov    (%eax),%eax
    bec8:	85 c0                	test   %eax,%eax
    beca:	74 0a                	je     bed6 <lodepng_convert_rgb+0x153>
    becc:	8b 45 20             	mov    0x20(%ebp),%eax
    becf:	8b 00                	mov    (%eax),%eax
    bed1:	83 f8 04             	cmp    $0x4,%eax
    bed4:	75 14                	jne    beea <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    bed6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bed9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bedc:	89 c1                	mov    %eax,%ecx
    bede:	d3 ea                	shr    %cl,%edx
    bee0:	8b 45 08             	mov    0x8(%ebp),%eax
    bee3:	89 10                	mov    %edx,(%eax)
    bee5:	e9 33 01 00 00       	jmp    c01d <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    beea:	8b 45 20             	mov    0x20(%ebp),%eax
    beed:	8b 00                	mov    (%eax),%eax
    beef:	83 f8 02             	cmp    $0x2,%eax
    bef2:	74 0a                	je     befe <lodepng_convert_rgb+0x17b>
    bef4:	8b 45 20             	mov    0x20(%ebp),%eax
    bef7:	8b 00                	mov    (%eax),%eax
    bef9:	83 f8 06             	cmp    $0x6,%eax
    befc:	75 32                	jne    bf30 <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    befe:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf01:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bf04:	89 c1                	mov    %eax,%ecx
    bf06:	d3 ea                	shr    %cl,%edx
    bf08:	8b 45 08             	mov    0x8(%ebp),%eax
    bf0b:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    bf0d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf10:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bf13:	89 c1                	mov    %eax,%ecx
    bf15:	d3 ea                	shr    %cl,%edx
    bf17:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf1a:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    bf1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    bf22:	89 c1                	mov    %eax,%ecx
    bf24:	d3 ea                	shr    %cl,%edx
    bf26:	8b 45 10             	mov    0x10(%ebp),%eax
    bf29:	89 10                	mov    %edx,(%eax)
    bf2b:	e9 ed 00 00 00       	jmp    c01d <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    bf30:	8b 45 20             	mov    0x20(%ebp),%eax
    bf33:	8b 00                	mov    (%eax),%eax
    bf35:	83 f8 03             	cmp    $0x3,%eax
    bf38:	0f 85 d8 00 00 00    	jne    c016 <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    bf3e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bf41:	c1 e8 08             	shr    $0x8,%eax
    bf44:	89 c2                	mov    %eax,%edx
    bf46:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bf49:	0f b6 c0             	movzbl %al,%eax
    bf4c:	39 c2                	cmp    %eax,%edx
    bf4e:	75 24                	jne    bf74 <lodepng_convert_rgb+0x1f1>
    bf50:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bf53:	c1 e8 08             	shr    $0x8,%eax
    bf56:	89 c2                	mov    %eax,%edx
    bf58:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bf5b:	0f b6 c0             	movzbl %al,%eax
    bf5e:	39 c2                	cmp    %eax,%edx
    bf60:	75 12                	jne    bf74 <lodepng_convert_rgb+0x1f1>
    bf62:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf65:	c1 e8 08             	shr    $0x8,%eax
    bf68:	89 c2                	mov    %eax,%edx
    bf6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf6d:	0f b6 c0             	movzbl %al,%eax
    bf70:	39 c2                	cmp    %eax,%edx
    bf72:	74 0a                	je     bf7e <lodepng_convert_rgb+0x1fb>
    bf74:	b8 52 00 00 00       	mov    $0x52,%eax
    bf79:	e9 a4 00 00 00       	jmp    c022 <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    bf7e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    bf85:	eb 79                	jmp    c000 <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    bf87:	8b 45 f0             	mov    -0x10(%ebp),%eax
    bf8a:	c1 e0 02             	shl    $0x2,%eax
    bf8d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    bf90:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bf93:	c1 e8 08             	shr    $0x8,%eax
    bf96:	89 c1                	mov    %eax,%ecx
    bf98:	8b 45 20             	mov    0x20(%ebp),%eax
    bf9b:	8b 50 08             	mov    0x8(%eax),%edx
    bf9e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    bfa1:	01 d0                	add    %edx,%eax
    bfa3:	0f b6 00             	movzbl (%eax),%eax
    bfa6:	0f b6 c0             	movzbl %al,%eax
    bfa9:	39 c1                	cmp    %eax,%ecx
    bfab:	75 4f                	jne    bffc <lodepng_convert_rgb+0x279>
    bfad:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bfb0:	c1 e8 08             	shr    $0x8,%eax
    bfb3:	89 c1                	mov    %eax,%ecx
    bfb5:	8b 45 20             	mov    0x20(%ebp),%eax
    bfb8:	8b 40 08             	mov    0x8(%eax),%eax
    bfbb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    bfbe:	83 c2 01             	add    $0x1,%edx
    bfc1:	01 d0                	add    %edx,%eax
    bfc3:	0f b6 00             	movzbl (%eax),%eax
    bfc6:	0f b6 c0             	movzbl %al,%eax
    bfc9:	39 c1                	cmp    %eax,%ecx
    bfcb:	75 2f                	jne    bffc <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    bfcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bfd0:	c1 e8 08             	shr    $0x8,%eax
    bfd3:	89 c1                	mov    %eax,%ecx
    bfd5:	8b 45 20             	mov    0x20(%ebp),%eax
    bfd8:	8b 40 08             	mov    0x8(%eax),%eax
    bfdb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    bfde:	83 c2 02             	add    $0x2,%edx
    bfe1:	01 d0                	add    %edx,%eax
    bfe3:	0f b6 00             	movzbl (%eax),%eax
    bfe6:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    bfe9:	39 c1                	cmp    %eax,%ecx
    bfeb:	75 0f                	jne    bffc <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    bfed:	8b 45 08             	mov    0x8(%ebp),%eax
    bff0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    bff3:	89 10                	mov    %edx,(%eax)
        return 0;
    bff5:	b8 00 00 00 00       	mov    $0x0,%eax
    bffa:	eb 26                	jmp    c022 <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    bffc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c000:	8b 45 20             	mov    0x20(%ebp),%eax
    c003:	8b 40 0c             	mov    0xc(%eax),%eax
    c006:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    c009:	0f 87 78 ff ff ff    	ja     bf87 <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    c00f:	b8 52 00 00 00       	mov    $0x52,%eax
    c014:	eb 0c                	jmp    c022 <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    c016:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c01b:	eb 05                	jmp    c022 <lodepng_convert_rgb+0x29f>
  }

  return 0;
    c01d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c022:	c9                   	leave  
    c023:	c3                   	ret    

0000c024 <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    c024:	55                   	push   %ebp
    c025:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    c027:	8b 45 08             	mov    0x8(%ebp),%eax
    c02a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    c030:	8b 45 08             	mov    0x8(%ebp),%eax
    c033:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    c03a:	8b 45 08             	mov    0x8(%ebp),%eax
    c03d:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    c043:	8b 45 08             	mov    0x8(%ebp),%eax
    c046:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c04a:	8b 45 08             	mov    0x8(%ebp),%eax
    c04d:	66 89 50 0a          	mov    %dx,0xa(%eax)
    c051:	8b 45 08             	mov    0x8(%ebp),%eax
    c054:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c058:	8b 45 08             	mov    0x8(%ebp),%eax
    c05b:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    c05f:	8b 45 08             	mov    0x8(%ebp),%eax
    c062:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    c069:	8b 45 08             	mov    0x8(%ebp),%eax
    c06c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    c073:	8b 45 08             	mov    0x8(%ebp),%eax
    c076:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    c07d:	00 00 00 
  stats->numpixels = 0;
    c080:	8b 45 08             	mov    0x8(%ebp),%eax
    c083:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    c08a:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    c08d:	8b 45 08             	mov    0x8(%ebp),%eax
    c090:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    c097:	00 00 00 
  stats->allow_greyscale = 1;
    c09a:	8b 45 08             	mov    0x8(%ebp),%eax
    c09d:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    c0a4:	00 00 00 
}
    c0a7:	90                   	nop
    c0a8:	5d                   	pop    %ebp
    c0a9:	c3                   	ret    

0000c0aa <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    c0aa:	55                   	push   %ebp
    c0ab:	89 e5                	mov    %esp,%ebp
    c0ad:	53                   	push   %ebx
    c0ae:	83 ec 04             	sub    $0x4,%esp
    c0b1:	8b 45 08             	mov    0x8(%ebp),%eax
    c0b4:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    c0b7:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    c0bb:	74 06                	je     c0c3 <getValueRequiredBits+0x19>
    c0bd:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    c0c1:	75 07                	jne    c0ca <getValueRequiredBits+0x20>
    c0c3:	b8 01 00 00 00       	mov    $0x1,%eax
    c0c8:	eb 6b                	jmp    c135 <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    c0ca:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c0ce:	0f b6 d9             	movzbl %cl,%ebx
    c0d1:	89 da                	mov    %ebx,%edx
    c0d3:	89 d0                	mov    %edx,%eax
    c0d5:	c1 e0 04             	shl    $0x4,%eax
    c0d8:	89 c2                	mov    %eax,%edx
    c0da:	89 d0                	mov    %edx,%eax
    c0dc:	c1 e0 04             	shl    $0x4,%eax
    c0df:	29 d0                	sub    %edx,%eax
    c0e1:	01 d8                	add    %ebx,%eax
    c0e3:	66 c1 e8 08          	shr    $0x8,%ax
    c0e7:	c0 e8 04             	shr    $0x4,%al
    c0ea:	89 c2                	mov    %eax,%edx
    c0ec:	c1 e2 04             	shl    $0x4,%edx
    c0ef:	01 c2                	add    %eax,%edx
    c0f1:	89 c8                	mov    %ecx,%eax
    c0f3:	29 d0                	sub    %edx,%eax
    c0f5:	84 c0                	test   %al,%al
    c0f7:	75 37                	jne    c130 <getValueRequiredBits+0x86>
    c0f9:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c0fd:	0f b6 d1             	movzbl %cl,%edx
    c100:	89 d0                	mov    %edx,%eax
    c102:	01 c0                	add    %eax,%eax
    c104:	01 d0                	add    %edx,%eax
    c106:	c1 e0 06             	shl    $0x6,%eax
    c109:	01 d0                	add    %edx,%eax
    c10b:	66 c1 e8 08          	shr    $0x8,%ax
    c10f:	c0 e8 06             	shr    $0x6,%al
    c112:	ba 55 00 00 00       	mov    $0x55,%edx
    c117:	0f af c2             	imul   %edx,%eax
    c11a:	29 c1                	sub    %eax,%ecx
    c11c:	89 c8                	mov    %ecx,%eax
    c11e:	84 c0                	test   %al,%al
    c120:	75 07                	jne    c129 <getValueRequiredBits+0x7f>
    c122:	b8 02 00 00 00       	mov    $0x2,%eax
    c127:	eb 0c                	jmp    c135 <getValueRequiredBits+0x8b>
    c129:	b8 04 00 00 00       	mov    $0x4,%eax
    c12e:	eb 05                	jmp    c135 <getValueRequiredBits+0x8b>
  return 8;
    c130:	b8 08 00 00 00       	mov    $0x8,%eax
}
    c135:	83 c4 04             	add    $0x4,%esp
    c138:	5b                   	pop    %ebx
    c139:	5d                   	pop    %ebp
    c13a:	c3                   	ret    

0000c13b <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    c13b:	55                   	push   %ebp
    c13c:	89 e5                	mov    %esp,%ebp
    c13e:	56                   	push   %esi
    c13f:	53                   	push   %ebx
    c140:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c146:	8b 55 10             	mov    0x10(%ebp),%edx
    c149:	8b 45 14             	mov    0x14(%ebp),%eax
    c14c:	0f af c2             	imul   %edx,%eax
    c14f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    c152:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    c159:	ff 75 18             	pushl  0x18(%ebp)
    c15c:	e8 0b cd ff ff       	call   8e6c <lodepng_is_greyscale_type>
    c161:	83 c4 04             	add    $0x4,%esp
    c164:	85 c0                	test   %eax,%eax
    c166:	0f 95 c0             	setne  %al
    c169:	0f b6 c0             	movzbl %al,%eax
    c16c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    c16f:	ff 75 18             	pushl  0x18(%ebp)
    c172:	e8 85 cd ff ff       	call   8efc <lodepng_can_have_alpha>
    c177:	83 c4 04             	add    $0x4,%esp
    c17a:	85 c0                	test   %eax,%eax
    c17c:	0f 94 c0             	sete   %al
    c17f:	0f b6 c0             	movzbl %al,%eax
    c182:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    c185:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    c18c:	ff 75 18             	pushl  0x18(%ebp)
    c18f:	e8 ab cc ff ff       	call   8e3f <lodepng_get_bpp>
    c194:	83 c4 04             	add    $0x4,%esp
    c197:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    c19a:	8b 45 08             	mov    0x8(%ebp),%eax
    c19d:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c1a3:	83 f8 01             	cmp    $0x1,%eax
    c1a6:	75 0d                	jne    c1b5 <lodepng_compute_color_stats+0x7a>
    c1a8:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    c1ac:	75 07                	jne    c1b5 <lodepng_compute_color_stats+0x7a>
    c1ae:	b8 01 00 00 00       	mov    $0x1,%eax
    c1b3:	eb 05                	jmp    c1ba <lodepng_compute_color_stats+0x7f>
    c1b5:	b8 00 00 00 00       	mov    $0x0,%eax
    c1ba:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    c1bd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    c1c4:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    c1cb:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    c1cf:	77 26                	ja     c1f7 <lodepng_compute_color_stats+0xbc>
    c1d1:	8b 45 08             	mov    0x8(%ebp),%eax
    c1d4:	8b 50 14             	mov    0x14(%eax),%edx
    c1d7:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c1da:	bb 01 00 00 00       	mov    $0x1,%ebx
    c1df:	89 c1                	mov    %eax,%ecx
    c1e1:	d3 e3                	shl    %cl,%ebx
    c1e3:	89 d8                	mov    %ebx,%eax
    c1e5:	01 d0                	add    %edx,%eax
    c1e7:	ba 01 01 00 00       	mov    $0x101,%edx
    c1ec:	3d 01 01 00 00       	cmp    $0x101,%eax
    c1f1:	0f 47 c2             	cmova  %edx,%eax
    c1f4:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    c1f7:	8b 45 08             	mov    0x8(%ebp),%eax
    c1fa:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    c200:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c203:	01 c2                	add    %eax,%edx
    c205:	8b 45 08             	mov    0x8(%ebp),%eax
    c208:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    c20e:	8b 45 08             	mov    0x8(%ebp),%eax
    c211:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    c217:	85 c0                	test   %eax,%eax
    c219:	75 07                	jne    c222 <lodepng_compute_color_stats+0xe7>
    c21b:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    c222:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c228:	50                   	push   %eax
    c229:	e8 81 da ff ff       	call   9caf <color_tree_init>
    c22e:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    c231:	8b 45 08             	mov    0x8(%ebp),%eax
    c234:	8b 40 10             	mov    0x10(%eax),%eax
    c237:	85 c0                	test   %eax,%eax
    c239:	74 07                	je     c242 <lodepng_compute_color_stats+0x107>
    c23b:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    c242:	8b 45 08             	mov    0x8(%ebp),%eax
    c245:	8b 00                	mov    (%eax),%eax
    c247:	85 c0                	test   %eax,%eax
    c249:	74 07                	je     c252 <lodepng_compute_color_stats+0x117>
    c24b:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    c252:	8b 45 08             	mov    0x8(%ebp),%eax
    c255:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c25b:	83 f8 10             	cmp    $0x10,%eax
    c25e:	75 07                	jne    c267 <lodepng_compute_color_stats+0x12c>
    c260:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    c267:	8b 45 08             	mov    0x8(%ebp),%eax
    c26a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c270:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c273:	72 07                	jb     c27c <lodepng_compute_color_stats+0x141>
    c275:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    c27c:	8b 45 08             	mov    0x8(%ebp),%eax
    c27f:	8b 40 14             	mov    0x14(%eax),%eax
    c282:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c285:	72 07                	jb     c28e <lodepng_compute_color_stats+0x153>
    c287:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    c28e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c292:	0f 85 82 00 00 00    	jne    c31a <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    c298:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c29f:	eb 6c                	jmp    c30d <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    c2a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c2a4:	c1 e0 02             	shl    $0x2,%eax
    c2a7:	8d 50 10             	lea    0x10(%eax),%edx
    c2aa:	8b 45 08             	mov    0x8(%ebp),%eax
    c2ad:	01 d0                	add    %edx,%eax
    c2af:	83 c0 08             	add    $0x8,%eax
    c2b2:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    c2b5:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c2b8:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2bb:	83 c0 03             	add    $0x3,%eax
    c2be:	0f b6 00             	movzbl (%eax),%eax
    c2c1:	0f b6 d8             	movzbl %al,%ebx
    c2c4:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2c7:	83 c0 02             	add    $0x2,%eax
    c2ca:	0f b6 00             	movzbl (%eax),%eax
    c2cd:	0f b6 c8             	movzbl %al,%ecx
    c2d0:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2d3:	83 c0 01             	add    $0x1,%eax
    c2d6:	0f b6 00             	movzbl (%eax),%eax
    c2d9:	0f b6 d0             	movzbl %al,%edx
    c2dc:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2df:	0f b6 00             	movzbl (%eax),%eax
    c2e2:	0f b6 c0             	movzbl %al,%eax
    c2e5:	83 ec 08             	sub    $0x8,%esp
    c2e8:	56                   	push   %esi
    c2e9:	53                   	push   %ebx
    c2ea:	51                   	push   %ecx
    c2eb:	52                   	push   %edx
    c2ec:	50                   	push   %eax
    c2ed:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c2f3:	50                   	push   %eax
    c2f4:	e8 39 db ff ff       	call   9e32 <color_tree_add>
    c2f9:	83 c4 20             	add    $0x20,%esp
    c2fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    c2ff:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c303:	0f 85 22 09 00 00    	jne    cc2b <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    c309:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c30d:	8b 45 08             	mov    0x8(%ebp),%eax
    c310:	8b 50 14             	mov    0x14(%eax),%edx
    c313:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c316:	39 c2                	cmp    %eax,%edx
    c318:	77 87                	ja     c2a1 <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    c31a:	8b 45 18             	mov    0x18(%ebp),%eax
    c31d:	8b 40 04             	mov    0x4(%eax),%eax
    c320:	83 f8 10             	cmp    $0x10,%eax
    c323:	0f 85 1e 01 00 00    	jne    c447 <lodepng_compute_color_stats+0x30c>
    c329:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c32d:	0f 85 14 01 00 00    	jne    c447 <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c333:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    c33a:	00 00 
    c33c:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    c343:	00 00 
    c345:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    c34c:	00 00 
    c34e:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    c355:	00 00 
    for(i = 0; i != numpixels; ++i) {
    c357:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c35e:	e9 d8 00 00 00       	jmp    c43b <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c363:	83 ec 04             	sub    $0x4,%esp
    c366:	ff 75 18             	pushl  0x18(%ebp)
    c369:	ff 75 f4             	pushl  -0xc(%ebp)
    c36c:	ff 75 0c             	pushl  0xc(%ebp)
    c36f:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    c375:	50                   	push   %eax
    c376:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    c37c:	50                   	push   %eax
    c37d:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    c383:	50                   	push   %eax
    c384:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    c38a:	50                   	push   %eax
    c38b:	e8 a8 f2 ff ff       	call   b638 <getPixelColorRGBA16>
    c390:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c393:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c39a:	66 c1 e8 08          	shr    $0x8,%ax
    c39e:	89 c2                	mov    %eax,%edx
    c3a0:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c3a7:	31 d0                	xor    %edx,%eax
    c3a9:	0f b7 c0             	movzwl %ax,%eax
    c3ac:	0f b6 c0             	movzbl %al,%eax
    c3af:	85 c0                	test   %eax,%eax
    c3b1:	75 60                	jne    c413 <lodepng_compute_color_stats+0x2d8>
    c3b3:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c3ba:	66 c1 e8 08          	shr    $0x8,%ax
    c3be:	89 c2                	mov    %eax,%edx
    c3c0:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c3c7:	31 d0                	xor    %edx,%eax
    c3c9:	0f b7 c0             	movzwl %ax,%eax
    c3cc:	0f b6 c0             	movzbl %al,%eax
    c3cf:	85 c0                	test   %eax,%eax
    c3d1:	75 40                	jne    c413 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c3d3:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c3da:	66 c1 e8 08          	shr    $0x8,%ax
    c3de:	89 c2                	mov    %eax,%edx
    c3e0:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c3e7:	31 d0                	xor    %edx,%eax
    c3e9:	0f b7 c0             	movzwl %ax,%eax
    c3ec:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c3ef:	85 c0                	test   %eax,%eax
    c3f1:	75 20                	jne    c413 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c3f3:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c3fa:	66 c1 e8 08          	shr    $0x8,%ax
    c3fe:	89 c2                	mov    %eax,%edx
    c400:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c407:	31 d0                	xor    %edx,%eax
    c409:	0f b7 c0             	movzwl %ax,%eax
    c40c:	0f b6 c0             	movzbl %al,%eax
    c40f:	85 c0                	test   %eax,%eax
    c411:	74 24                	je     c437 <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    c413:	8b 45 08             	mov    0x8(%ebp),%eax
    c416:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    c41d:	00 00 00 
        sixteen = 1;
    c420:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    c427:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    c42e:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    c435:	eb 10                	jmp    c447 <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    c437:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c43b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c43e:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c441:	0f 85 1c ff ff ff    	jne    c363 <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    c447:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c44b:	0f 84 bd 02 00 00    	je     c70e <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c451:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    c458:	00 00 
    c45a:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    c461:	00 00 
    c463:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    c46a:	00 00 
    c46c:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    c473:	00 00 

    for(i = 0; i != numpixels; ++i) {
    c475:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c47c:	e9 b1 01 00 00       	jmp    c632 <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c481:	83 ec 04             	sub    $0x4,%esp
    c484:	ff 75 18             	pushl  0x18(%ebp)
    c487:	ff 75 f4             	pushl  -0xc(%ebp)
    c48a:	ff 75 0c             	pushl  0xc(%ebp)
    c48d:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c493:	50                   	push   %eax
    c494:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c49a:	50                   	push   %eax
    c49b:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c4a1:	50                   	push   %eax
    c4a2:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c4a8:	50                   	push   %eax
    c4a9:	e8 8a f1 ff ff       	call   b638 <getPixelColorRGBA16>
    c4ae:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    c4b1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c4b5:	75 36                	jne    c4ed <lodepng_compute_color_stats+0x3b2>
    c4b7:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c4be:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c4c5:	66 39 c2             	cmp    %ax,%dx
    c4c8:	75 13                	jne    c4dd <lodepng_compute_color_stats+0x3a2>
    c4ca:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c4d1:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c4d8:	66 39 c2             	cmp    %ax,%dx
    c4db:	74 10                	je     c4ed <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    c4dd:	8b 45 08             	mov    0x8(%ebp),%eax
    c4e0:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c4e6:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    c4ed:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c4f1:	0f 85 1f 01 00 00    	jne    c616 <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c4f7:	8b 45 08             	mov    0x8(%ebp),%eax
    c4fa:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c4fe:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c505:	66 39 c2             	cmp    %ax,%dx
    c508:	75 2d                	jne    c537 <lodepng_compute_color_stats+0x3fc>
    c50a:	8b 45 08             	mov    0x8(%ebp),%eax
    c50d:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c511:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c518:	66 39 c2             	cmp    %ax,%dx
    c51b:	75 1a                	jne    c537 <lodepng_compute_color_stats+0x3fc>
    c51d:	8b 45 08             	mov    0x8(%ebp),%eax
    c520:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c524:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c52b:	66 39 c2             	cmp    %ax,%dx
    c52e:	75 07                	jne    c537 <lodepng_compute_color_stats+0x3fc>
    c530:	b8 01 00 00 00       	mov    $0x1,%eax
    c535:	eb 05                	jmp    c53c <lodepng_compute_color_stats+0x401>
    c537:	b8 00 00 00 00       	mov    $0x0,%eax
    c53c:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    c53f:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c546:	66 83 f8 ff          	cmp    $0xffff,%ax
    c54a:	74 3c                	je     c588 <lodepng_compute_color_stats+0x44d>
    c54c:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c553:	66 85 c0             	test   %ax,%ax
    c556:	75 10                	jne    c568 <lodepng_compute_color_stats+0x42d>
    c558:	8b 45 08             	mov    0x8(%ebp),%eax
    c55b:	8b 40 04             	mov    0x4(%eax),%eax
    c55e:	85 c0                	test   %eax,%eax
    c560:	74 26                	je     c588 <lodepng_compute_color_stats+0x44d>
    c562:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c566:	75 20                	jne    c588 <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    c568:	8b 45 08             	mov    0x8(%ebp),%eax
    c56b:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c572:	8b 45 08             	mov    0x8(%ebp),%eax
    c575:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c57c:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    c583:	e9 8e 00 00 00       	jmp    c616 <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c588:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c58f:	66 85 c0             	test   %ax,%ax
    c592:	75 4a                	jne    c5de <lodepng_compute_color_stats+0x4a3>
    c594:	8b 45 08             	mov    0x8(%ebp),%eax
    c597:	8b 40 10             	mov    0x10(%eax),%eax
    c59a:	85 c0                	test   %eax,%eax
    c59c:	75 40                	jne    c5de <lodepng_compute_color_stats+0x4a3>
    c59e:	8b 45 08             	mov    0x8(%ebp),%eax
    c5a1:	8b 40 04             	mov    0x4(%eax),%eax
    c5a4:	85 c0                	test   %eax,%eax
    c5a6:	75 36                	jne    c5de <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    c5a8:	8b 45 08             	mov    0x8(%ebp),%eax
    c5ab:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c5b2:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c5b9:	8b 45 08             	mov    0x8(%ebp),%eax
    c5bc:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c5c0:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    c5c7:	8b 45 08             	mov    0x8(%ebp),%eax
    c5ca:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c5ce:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    c5d5:	8b 45 08             	mov    0x8(%ebp),%eax
    c5d8:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c5dc:	eb 38                	jmp    c616 <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    c5de:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c5e5:	66 83 f8 ff          	cmp    $0xffff,%ax
    c5e9:	75 2b                	jne    c616 <lodepng_compute_color_stats+0x4db>
    c5eb:	8b 45 08             	mov    0x8(%ebp),%eax
    c5ee:	8b 40 04             	mov    0x4(%eax),%eax
    c5f1:	85 c0                	test   %eax,%eax
    c5f3:	74 21                	je     c616 <lodepng_compute_color_stats+0x4db>
    c5f5:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c5f9:	74 1b                	je     c616 <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c5fb:	8b 45 08             	mov    0x8(%ebp),%eax
    c5fe:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c605:	8b 45 08             	mov    0x8(%ebp),%eax
    c608:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c60f:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c616:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c61a:	74 12                	je     c62e <lodepng_compute_color_stats+0x4f3>
    c61c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c620:	74 0c                	je     c62e <lodepng_compute_color_stats+0x4f3>
    c622:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c626:	74 06                	je     c62e <lodepng_compute_color_stats+0x4f3>
    c628:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c62c:	75 12                	jne    c640 <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    c62e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c632:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c635:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c638:	0f 85 43 fe ff ff    	jne    c481 <lodepng_compute_color_stats+0x346>
    c63e:	eb 01                	jmp    c641 <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c640:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    c641:	8b 45 08             	mov    0x8(%ebp),%eax
    c644:	8b 40 04             	mov    0x4(%eax),%eax
    c647:	85 c0                	test   %eax,%eax
    c649:	0f 84 e0 05 00 00    	je     cc2f <lodepng_compute_color_stats+0xaf4>
    c64f:	8b 45 08             	mov    0x8(%ebp),%eax
    c652:	8b 40 10             	mov    0x10(%eax),%eax
    c655:	85 c0                	test   %eax,%eax
    c657:	0f 85 d2 05 00 00    	jne    cc2f <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    c65d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c664:	e9 94 00 00 00       	jmp    c6fd <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c669:	83 ec 04             	sub    $0x4,%esp
    c66c:	ff 75 18             	pushl  0x18(%ebp)
    c66f:	ff 75 f4             	pushl  -0xc(%ebp)
    c672:	ff 75 0c             	pushl  0xc(%ebp)
    c675:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c67b:	50                   	push   %eax
    c67c:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c682:	50                   	push   %eax
    c683:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c689:	50                   	push   %eax
    c68a:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c690:	50                   	push   %eax
    c691:	e8 a2 ef ff ff       	call   b638 <getPixelColorRGBA16>
    c696:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    c699:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c6a0:	66 85 c0             	test   %ax,%ax
    c6a3:	74 54                	je     c6f9 <lodepng_compute_color_stats+0x5be>
    c6a5:	8b 45 08             	mov    0x8(%ebp),%eax
    c6a8:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c6ac:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c6b3:	66 39 c2             	cmp    %ax,%dx
    c6b6:	75 41                	jne    c6f9 <lodepng_compute_color_stats+0x5be>
    c6b8:	8b 45 08             	mov    0x8(%ebp),%eax
    c6bb:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c6bf:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c6c6:	66 39 c2             	cmp    %ax,%dx
    c6c9:	75 2e                	jne    c6f9 <lodepng_compute_color_stats+0x5be>
    c6cb:	8b 45 08             	mov    0x8(%ebp),%eax
    c6ce:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c6d2:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c6d9:	66 39 c2             	cmp    %ax,%dx
    c6dc:	75 1b                	jne    c6f9 <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c6de:	8b 45 08             	mov    0x8(%ebp),%eax
    c6e1:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c6e8:	8b 45 08             	mov    0x8(%ebp),%eax
    c6eb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c6f2:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    c6f9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c6fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c700:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c703:	0f 85 60 ff ff ff    	jne    c669 <lodepng_compute_color_stats+0x52e>
    c709:	e9 21 05 00 00       	jmp    cc2f <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    c70e:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    c715:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    c71c:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    c723:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    c72a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c731:	e9 ab 03 00 00       	jmp    cae1 <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    c736:	83 ec 04             	sub    $0x4,%esp
    c739:	ff 75 18             	pushl  0x18(%ebp)
    c73c:	ff 75 f4             	pushl  -0xc(%ebp)
    c73f:	ff 75 0c             	pushl  0xc(%ebp)
    c742:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    c748:	50                   	push   %eax
    c749:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    c74f:	50                   	push   %eax
    c750:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    c756:	50                   	push   %eax
    c757:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    c75d:	50                   	push   %eax
    c75e:	e8 1e de ff ff       	call   a581 <getPixelColorRGBA8>
    c763:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    c766:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c76a:	75 41                	jne    c7ad <lodepng_compute_color_stats+0x672>
    c76c:	8b 45 08             	mov    0x8(%ebp),%eax
    c76f:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c775:	83 f8 07             	cmp    $0x7,%eax
    c778:	77 33                	ja     c7ad <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    c77a:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c781:	0f b6 c0             	movzbl %al,%eax
    c784:	83 ec 0c             	sub    $0xc,%esp
    c787:	50                   	push   %eax
    c788:	e8 1d f9 ff ff       	call   c0aa <getValueRequiredBits>
    c78d:	83 c4 10             	add    $0x10,%esp
    c790:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    c793:	8b 45 08             	mov    0x8(%ebp),%eax
    c796:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c79c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    c79f:	73 0c                	jae    c7ad <lodepng_compute_color_stats+0x672>
    c7a1:	8b 45 08             	mov    0x8(%ebp),%eax
    c7a4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    c7a7:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    c7ad:	8b 45 08             	mov    0x8(%ebp),%eax
    c7b0:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c7b6:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c7b9:	0f 93 c0             	setae  %al
    c7bc:	0f b6 c0             	movzbl %al,%eax
    c7bf:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    c7c2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c7c6:	75 4f                	jne    c817 <lodepng_compute_color_stats+0x6dc>
    c7c8:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c7cf:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c7d6:	38 c2                	cmp    %al,%dl
    c7d8:	75 12                	jne    c7ec <lodepng_compute_color_stats+0x6b1>
    c7da:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c7e1:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c7e8:	38 c2                	cmp    %al,%dl
    c7ea:	74 2b                	je     c817 <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    c7ec:	8b 45 08             	mov    0x8(%ebp),%eax
    c7ef:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c7f5:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    c7fc:	8b 45 08             	mov    0x8(%ebp),%eax
    c7ff:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c805:	83 f8 07             	cmp    $0x7,%eax
    c808:	77 0d                	ja     c817 <lodepng_compute_color_stats+0x6dc>
    c80a:	8b 45 08             	mov    0x8(%ebp),%eax
    c80d:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c814:	00 00 00 
      }

      if(!alpha_done) {
    c817:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c81b:	0f 85 65 01 00 00    	jne    c986 <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c821:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c828:	0f b6 d0             	movzbl %al,%edx
    c82b:	8b 45 08             	mov    0x8(%ebp),%eax
    c82e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c832:	66 39 c2             	cmp    %ax,%dx
    c835:	75 33                	jne    c86a <lodepng_compute_color_stats+0x72f>
    c837:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c83e:	0f b6 d0             	movzbl %al,%edx
    c841:	8b 45 08             	mov    0x8(%ebp),%eax
    c844:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    c848:	66 39 c2             	cmp    %ax,%dx
    c84b:	75 1d                	jne    c86a <lodepng_compute_color_stats+0x72f>
    c84d:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c854:	0f b6 d0             	movzbl %al,%edx
    c857:	8b 45 08             	mov    0x8(%ebp),%eax
    c85a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    c85e:	66 39 c2             	cmp    %ax,%dx
    c861:	75 07                	jne    c86a <lodepng_compute_color_stats+0x72f>
    c863:	b8 01 00 00 00       	mov    $0x1,%eax
    c868:	eb 05                	jmp    c86f <lodepng_compute_color_stats+0x734>
    c86a:	b8 00 00 00 00       	mov    $0x0,%eax
    c86f:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    c872:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c879:	3c ff                	cmp    $0xff,%al
    c87b:	74 5a                	je     c8d7 <lodepng_compute_color_stats+0x79c>
    c87d:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c884:	84 c0                	test   %al,%al
    c886:	75 10                	jne    c898 <lodepng_compute_color_stats+0x75d>
    c888:	8b 45 08             	mov    0x8(%ebp),%eax
    c88b:	8b 40 04             	mov    0x4(%eax),%eax
    c88e:	85 c0                	test   %eax,%eax
    c890:	74 45                	je     c8d7 <lodepng_compute_color_stats+0x79c>
    c892:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c896:	75 3f                	jne    c8d7 <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    c898:	8b 45 08             	mov    0x8(%ebp),%eax
    c89b:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c8a2:	8b 45 08             	mov    0x8(%ebp),%eax
    c8a5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c8ac:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c8b3:	8b 45 08             	mov    0x8(%ebp),%eax
    c8b6:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c8bc:	83 f8 07             	cmp    $0x7,%eax
    c8bf:	0f 87 c1 00 00 00    	ja     c986 <lodepng_compute_color_stats+0x84b>
    c8c5:	8b 45 08             	mov    0x8(%ebp),%eax
    c8c8:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c8cf:	00 00 00 
    c8d2:	e9 af 00 00 00       	jmp    c986 <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c8d7:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c8de:	84 c0                	test   %al,%al
    c8e0:	75 53                	jne    c935 <lodepng_compute_color_stats+0x7fa>
    c8e2:	8b 45 08             	mov    0x8(%ebp),%eax
    c8e5:	8b 40 10             	mov    0x10(%eax),%eax
    c8e8:	85 c0                	test   %eax,%eax
    c8ea:	75 49                	jne    c935 <lodepng_compute_color_stats+0x7fa>
    c8ec:	8b 45 08             	mov    0x8(%ebp),%eax
    c8ef:	8b 40 04             	mov    0x4(%eax),%eax
    c8f2:	85 c0                	test   %eax,%eax
    c8f4:	75 3f                	jne    c935 <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    c8f6:	8b 45 08             	mov    0x8(%ebp),%eax
    c8f9:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c900:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c907:	0f b6 d0             	movzbl %al,%edx
    c90a:	8b 45 08             	mov    0x8(%ebp),%eax
    c90d:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c911:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c918:	0f b6 d0             	movzbl %al,%edx
    c91b:	8b 45 08             	mov    0x8(%ebp),%eax
    c91e:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c922:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c929:	0f b6 d0             	movzbl %al,%edx
    c92c:	8b 45 08             	mov    0x8(%ebp),%eax
    c92f:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c933:	eb 51                	jmp    c986 <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    c935:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c93c:	3c ff                	cmp    $0xff,%al
    c93e:	75 46                	jne    c986 <lodepng_compute_color_stats+0x84b>
    c940:	8b 45 08             	mov    0x8(%ebp),%eax
    c943:	8b 40 04             	mov    0x4(%eax),%eax
    c946:	85 c0                	test   %eax,%eax
    c948:	74 3c                	je     c986 <lodepng_compute_color_stats+0x84b>
    c94a:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c94e:	74 36                	je     c986 <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c950:	8b 45 08             	mov    0x8(%ebp),%eax
    c953:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c95a:	8b 45 08             	mov    0x8(%ebp),%eax
    c95d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c964:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c96b:	8b 45 08             	mov    0x8(%ebp),%eax
    c96e:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c974:	83 f8 07             	cmp    $0x7,%eax
    c977:	77 0d                	ja     c986 <lodepng_compute_color_stats+0x84b>
    c979:	8b 45 08             	mov    0x8(%ebp),%eax
    c97c:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c983:	00 00 00 
        }
      }

      if(!numcolors_done) {
    c986:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c98a:	0f 85 35 01 00 00    	jne    cac5 <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    c990:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c997:	0f b6 d8             	movzbl %al,%ebx
    c99a:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c9a1:	0f b6 c8             	movzbl %al,%ecx
    c9a4:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c9ab:	0f b6 d0             	movzbl %al,%edx
    c9ae:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c9b5:	0f b6 c0             	movzbl %al,%eax
    c9b8:	83 ec 0c             	sub    $0xc,%esp
    c9bb:	53                   	push   %ebx
    c9bc:	51                   	push   %ecx
    c9bd:	52                   	push   %edx
    c9be:	50                   	push   %eax
    c9bf:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c9c5:	50                   	push   %eax
    c9c6:	e8 1c d4 ff ff       	call   9de7 <color_tree_has>
    c9cb:	83 c4 20             	add    $0x20,%esp
    c9ce:	85 c0                	test   %eax,%eax
    c9d0:	0f 85 ef 00 00 00    	jne    cac5 <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    c9d6:	8b 45 08             	mov    0x8(%ebp),%eax
    c9d9:	8b 70 14             	mov    0x14(%eax),%esi
    c9dc:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c9e3:	0f b6 d8             	movzbl %al,%ebx
    c9e6:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c9ed:	0f b6 c8             	movzbl %al,%ecx
    c9f0:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c9f7:	0f b6 d0             	movzbl %al,%edx
    c9fa:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca01:	0f b6 c0             	movzbl %al,%eax
    ca04:	83 ec 08             	sub    $0x8,%esp
    ca07:	56                   	push   %esi
    ca08:	53                   	push   %ebx
    ca09:	51                   	push   %ecx
    ca0a:	52                   	push   %edx
    ca0b:	50                   	push   %eax
    ca0c:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    ca12:	50                   	push   %eax
    ca13:	e8 1a d4 ff ff       	call   9e32 <color_tree_add>
    ca18:	83 c4 20             	add    $0x20,%esp
    ca1b:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    ca1e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ca22:	0f 85 06 02 00 00    	jne    cc2e <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    ca28:	8b 45 08             	mov    0x8(%ebp),%eax
    ca2b:	8b 40 14             	mov    0x14(%eax),%eax
    ca2e:	3d ff 00 00 00       	cmp    $0xff,%eax
    ca33:	77 6f                	ja     caa4 <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    ca35:	8b 45 08             	mov    0x8(%ebp),%eax
    ca38:	83 c0 18             	add    $0x18,%eax
    ca3b:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    ca3e:	8b 45 08             	mov    0x8(%ebp),%eax
    ca41:	8b 40 14             	mov    0x14(%eax),%eax
    ca44:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    ca47:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca4a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ca51:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca54:	01 c2                	add    %eax,%edx
    ca56:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca5d:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    ca5f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca62:	c1 e0 02             	shl    $0x2,%eax
    ca65:	8d 50 01             	lea    0x1(%eax),%edx
    ca68:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca6b:	01 c2                	add    %eax,%edx
    ca6d:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ca74:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    ca76:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca79:	c1 e0 02             	shl    $0x2,%eax
    ca7c:	8d 50 02             	lea    0x2(%eax),%edx
    ca7f:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca82:	01 c2                	add    %eax,%edx
    ca84:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ca8b:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    ca8d:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca90:	c1 e0 02             	shl    $0x2,%eax
    ca93:	8d 50 03             	lea    0x3(%eax),%edx
    ca96:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca99:	01 c2                	add    %eax,%edx
    ca9b:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    caa2:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    caa4:	8b 45 08             	mov    0x8(%ebp),%eax
    caa7:	8b 40 14             	mov    0x14(%eax),%eax
    caaa:	8d 50 01             	lea    0x1(%eax),%edx
    caad:	8b 45 08             	mov    0x8(%ebp),%eax
    cab0:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    cab3:	8b 45 08             	mov    0x8(%ebp),%eax
    cab6:	8b 40 14             	mov    0x14(%eax),%eax
    cab9:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cabc:	0f 93 c0             	setae  %al
    cabf:	0f b6 c0             	movzbl %al,%eax
    cac2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cac5:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cac9:	74 12                	je     cadd <lodepng_compute_color_stats+0x9a2>
    cacb:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cacf:	74 0c                	je     cadd <lodepng_compute_color_stats+0x9a2>
    cad1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cad5:	74 06                	je     cadd <lodepng_compute_color_stats+0x9a2>
    cad7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cadb:	75 12                	jne    caef <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    cadd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cae1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cae4:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cae7:	0f 85 49 fc ff ff    	jne    c736 <lodepng_compute_color_stats+0x5fb>
    caed:	eb 01                	jmp    caf0 <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    caef:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    caf0:	8b 45 08             	mov    0x8(%ebp),%eax
    caf3:	8b 40 04             	mov    0x4(%eax),%eax
    caf6:	85 c0                	test   %eax,%eax
    caf8:	0f 84 dd 00 00 00    	je     cbdb <lodepng_compute_color_stats+0xaa0>
    cafe:	8b 45 08             	mov    0x8(%ebp),%eax
    cb01:	8b 40 10             	mov    0x10(%eax),%eax
    cb04:	85 c0                	test   %eax,%eax
    cb06:	0f 85 cf 00 00 00    	jne    cbdb <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    cb0c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cb13:	e9 b7 00 00 00       	jmp    cbcf <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    cb18:	83 ec 04             	sub    $0x4,%esp
    cb1b:	ff 75 18             	pushl  0x18(%ebp)
    cb1e:	ff 75 f4             	pushl  -0xc(%ebp)
    cb21:	ff 75 0c             	pushl  0xc(%ebp)
    cb24:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    cb2a:	50                   	push   %eax
    cb2b:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    cb31:	50                   	push   %eax
    cb32:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    cb38:	50                   	push   %eax
    cb39:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    cb3f:	50                   	push   %eax
    cb40:	e8 3c da ff ff       	call   a581 <getPixelColorRGBA8>
    cb45:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    cb48:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cb4f:	84 c0                	test   %al,%al
    cb51:	74 78                	je     cbcb <lodepng_compute_color_stats+0xa90>
    cb53:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cb5a:	0f b6 d0             	movzbl %al,%edx
    cb5d:	8b 45 08             	mov    0x8(%ebp),%eax
    cb60:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cb64:	66 39 c2             	cmp    %ax,%dx
    cb67:	75 62                	jne    cbcb <lodepng_compute_color_stats+0xa90>
    cb69:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cb70:	0f b6 d0             	movzbl %al,%edx
    cb73:	8b 45 08             	mov    0x8(%ebp),%eax
    cb76:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cb7a:	66 39 c2             	cmp    %ax,%dx
    cb7d:	75 4c                	jne    cbcb <lodepng_compute_color_stats+0xa90>
    cb7f:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cb86:	0f b6 d0             	movzbl %al,%edx
    cb89:	8b 45 08             	mov    0x8(%ebp),%eax
    cb8c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cb90:	66 39 c2             	cmp    %ax,%dx
    cb93:	75 36                	jne    cbcb <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cb95:	8b 45 08             	mov    0x8(%ebp),%eax
    cb98:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cb9f:	8b 45 08             	mov    0x8(%ebp),%eax
    cba2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cba9:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cbb0:	8b 45 08             	mov    0x8(%ebp),%eax
    cbb3:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cbb9:	83 f8 07             	cmp    $0x7,%eax
    cbbc:	77 0d                	ja     cbcb <lodepng_compute_color_stats+0xa90>
    cbbe:	8b 45 08             	mov    0x8(%ebp),%eax
    cbc1:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cbc8:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    cbcb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cbcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cbd2:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cbd5:	0f 85 3d ff ff ff    	jne    cb18 <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    cbdb:	8b 45 08             	mov    0x8(%ebp),%eax
    cbde:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    cbe2:	8b 45 08             	mov    0x8(%ebp),%eax
    cbe5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cbe9:	c1 e0 08             	shl    $0x8,%eax
    cbec:	01 c2                	add    %eax,%edx
    cbee:	8b 45 08             	mov    0x8(%ebp),%eax
    cbf1:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    cbf5:	8b 45 08             	mov    0x8(%ebp),%eax
    cbf8:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    cbfc:	8b 45 08             	mov    0x8(%ebp),%eax
    cbff:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cc03:	c1 e0 08             	shl    $0x8,%eax
    cc06:	01 c2                	add    %eax,%edx
    cc08:	8b 45 08             	mov    0x8(%ebp),%eax
    cc0b:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    cc0f:	8b 45 08             	mov    0x8(%ebp),%eax
    cc12:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    cc16:	8b 45 08             	mov    0x8(%ebp),%eax
    cc19:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cc1d:	c1 e0 08             	shl    $0x8,%eax
    cc20:	01 c2                	add    %eax,%edx
    cc22:	8b 45 08             	mov    0x8(%ebp),%eax
    cc25:	66 89 50 0c          	mov    %dx,0xc(%eax)
    cc29:	eb 04                	jmp    cc2f <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    cc2b:	90                   	nop
    cc2c:	eb 01                	jmp    cc2f <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    cc2e:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    cc2f:	83 ec 0c             	sub    $0xc,%esp
    cc32:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cc38:	50                   	push   %eax
    cc39:	e8 91 d0 ff ff       	call   9ccf <color_tree_cleanup>
    cc3e:	83 c4 10             	add    $0x10,%esp
  return error;
    cc41:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    cc44:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cc47:	5b                   	pop    %ebx
    cc48:	5e                   	pop    %esi
    cc49:	5d                   	pop    %ebp
    cc4a:	c3                   	ret    

0000cc4b <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    cc4b:	55                   	push   %ebp
    cc4c:	89 e5                	mov    %esp,%ebp
    cc4e:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    cc51:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    cc58:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cc5b:	50                   	push   %eax
    cc5c:	e8 d1 bd ff ff       	call   8a32 <lodepng_color_mode_init>
    cc61:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    cc64:	8b 45 0c             	mov    0xc(%ebp),%eax
    cc67:	c1 e8 08             	shr    $0x8,%eax
    cc6a:	88 45 ec             	mov    %al,-0x14(%ebp)
    cc6d:	8b 45 0c             	mov    0xc(%ebp),%eax
    cc70:	88 45 ed             	mov    %al,-0x13(%ebp)
    cc73:	8b 45 10             	mov    0x10(%ebp),%eax
    cc76:	c1 e8 08             	shr    $0x8,%eax
    cc79:	88 45 ee             	mov    %al,-0x12(%ebp)
    cc7c:	8b 45 10             	mov    0x10(%ebp),%eax
    cc7f:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    cc82:	8b 45 14             	mov    0x14(%ebp),%eax
    cc85:	c1 e8 08             	shr    $0x8,%eax
    cc88:	88 45 f0             	mov    %al,-0x10(%ebp)
    cc8b:	8b 45 14             	mov    0x14(%ebp),%eax
    cc8e:	88 45 f1             	mov    %al,-0xf(%ebp)
    cc91:	8b 45 18             	mov    0x18(%ebp),%eax
    cc94:	c1 e8 08             	shr    $0x8,%eax
    cc97:	88 45 f2             	mov    %al,-0xe(%ebp)
    cc9a:	8b 45 18             	mov    0x18(%ebp),%eax
    cc9d:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    cca0:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    cca7:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    ccae:	83 ec 0c             	sub    $0xc,%esp
    ccb1:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ccb4:	50                   	push   %eax
    ccb5:	6a 01                	push   $0x1
    ccb7:	6a 01                	push   $0x1
    ccb9:	8d 45 ec             	lea    -0x14(%ebp),%eax
    ccbc:	50                   	push   %eax
    ccbd:	ff 75 08             	pushl  0x8(%ebp)
    ccc0:	e8 76 f4 ff ff       	call   c13b <lodepng_compute_color_stats>
    ccc5:	83 c4 20             	add    $0x20,%esp
    ccc8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    cccb:	83 ec 0c             	sub    $0xc,%esp
    ccce:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ccd1:	50                   	push   %eax
    ccd2:	e8 4e be ff ff       	call   8b25 <lodepng_color_mode_cleanup>
    ccd7:	83 c4 10             	add    $0x10,%esp
  return error;
    ccda:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ccdd:	c9                   	leave  
    ccde:	c3                   	ret    

0000ccdf <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    ccdf:	55                   	push   %ebp
    cce0:	89 e5                	mov    %esp,%ebp
    cce2:	56                   	push   %esi
    cce3:	53                   	push   %ebx
    cce4:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    cce7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    ccee:	8b 45 10             	mov    0x10(%ebp),%eax
    ccf1:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    ccf7:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    ccfa:	8b 45 10             	mov    0x10(%ebp),%eax
    ccfd:	8b 40 10             	mov    0x10(%eax),%eax
    cd00:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    cd03:	8b 45 10             	mov    0x10(%ebp),%eax
    cd06:	8b 40 04             	mov    0x4(%eax),%eax
    cd09:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    cd0c:	8b 45 10             	mov    0x10(%ebp),%eax
    cd0f:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cd15:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    cd18:	8b 45 08             	mov    0x8(%ebp),%eax
    cd1b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    cd22:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cd26:	74 21                	je     cd49 <auto_choose_color+0x6a>
    cd28:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    cd2c:	7f 1b                	jg     cd49 <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    cd2e:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    cd35:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cd3c:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    cd40:	77 07                	ja     cd49 <auto_choose_color+0x6a>
    cd42:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    cd49:	8b 45 10             	mov    0x10(%ebp),%eax
    cd4c:	8b 00                	mov    (%eax),%eax
    cd4e:	85 c0                	test   %eax,%eax
    cd50:	0f 94 c0             	sete   %al
    cd53:	0f b6 c0             	movzbl %al,%eax
    cd56:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    cd59:	8b 45 10             	mov    0x10(%ebp),%eax
    cd5c:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    cd62:	85 c0                	test   %eax,%eax
    cd64:	75 07                	jne    cd6d <auto_choose_color+0x8e>
    cd66:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    cd6d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cd71:	75 0d                	jne    cd80 <auto_choose_color+0xa1>
    cd73:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    cd77:	77 07                	ja     cd80 <auto_choose_color+0xa1>
    cd79:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    cd80:	8b 45 10             	mov    0x10(%ebp),%eax
    cd83:	8b 40 14             	mov    0x14(%eax),%eax
    cd86:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    cd89:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    cd8d:	7e 21                	jle    cdb0 <auto_choose_color+0xd1>
    cd8f:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    cd93:	7e 14                	jle    cda9 <auto_choose_color+0xca>
    cd95:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    cd99:	7f 07                	jg     cda2 <auto_choose_color+0xc3>
    cd9b:	b8 04 00 00 00       	mov    $0x4,%eax
    cda0:	eb 13                	jmp    cdb5 <auto_choose_color+0xd6>
    cda2:	b8 08 00 00 00       	mov    $0x8,%eax
    cda7:	eb 0c                	jmp    cdb5 <auto_choose_color+0xd6>
    cda9:	b8 02 00 00 00       	mov    $0x2,%eax
    cdae:	eb 05                	jmp    cdb5 <auto_choose_color+0xd6>
    cdb0:	b8 01 00 00 00       	mov    $0x1,%eax
    cdb5:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    cdb8:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    cdbf:	7f 13                	jg     cdd4 <auto_choose_color+0xf5>
    cdc1:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    cdc5:	77 0d                	ja     cdd4 <auto_choose_color+0xf5>
    cdc7:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    cdcb:	74 07                	je     cdd4 <auto_choose_color+0xf5>
    cdcd:	b8 01 00 00 00       	mov    $0x1,%eax
    cdd2:	eb 05                	jmp    cdd9 <auto_choose_color+0xfa>
    cdd4:	b8 00 00 00 00       	mov    $0x0,%eax
    cdd9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    cddc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cddf:	01 c0                	add    %eax,%eax
    cde1:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cde4:	7e 07                	jle    cded <auto_choose_color+0x10e>
    cde6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    cded:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cdf1:	74 15                	je     ce08 <auto_choose_color+0x129>
    cdf3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cdf7:	75 0f                	jne    ce08 <auto_choose_color+0x129>
    cdf9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    cdfc:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    cdff:	77 07                	ja     ce08 <auto_choose_color+0x129>
    ce01:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    ce08:	8b 45 10             	mov    0x10(%ebp),%eax
    ce0b:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    ce11:	85 c0                	test   %eax,%eax
    ce13:	75 07                	jne    ce1c <auto_choose_color+0x13d>
    ce15:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    ce1c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ce20:	0f 84 0a 01 00 00    	je     cf30 <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    ce26:	8b 45 10             	mov    0x10(%ebp),%eax
    ce29:	83 c0 18             	add    $0x18,%eax
    ce2c:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    ce2f:	83 ec 0c             	sub    $0xc,%esp
    ce32:	ff 75 08             	pushl  0x8(%ebp)
    ce35:	e8 ef be ff ff       	call   8d29 <lodepng_palette_clear>
    ce3a:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    ce3d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ce44:	eb 6e                	jmp    ceb4 <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    ce46:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce49:	c1 e0 02             	shl    $0x2,%eax
    ce4c:	8d 50 03             	lea    0x3(%eax),%edx
    ce4f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce52:	01 d0                	add    %edx,%eax
    ce54:	0f b6 00             	movzbl (%eax),%eax
    ce57:	0f b6 d8             	movzbl %al,%ebx
    ce5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce5d:	c1 e0 02             	shl    $0x2,%eax
    ce60:	8d 50 02             	lea    0x2(%eax),%edx
    ce63:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce66:	01 d0                	add    %edx,%eax
    ce68:	0f b6 00             	movzbl (%eax),%eax
    ce6b:	0f b6 c8             	movzbl %al,%ecx
    ce6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce71:	c1 e0 02             	shl    $0x2,%eax
    ce74:	8d 50 01             	lea    0x1(%eax),%edx
    ce77:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce7a:	01 d0                	add    %edx,%eax
    ce7c:	0f b6 00             	movzbl (%eax),%eax
    ce7f:	0f b6 d0             	movzbl %al,%edx
    ce82:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce85:	c1 e0 02             	shl    $0x2,%eax
    ce88:	89 c6                	mov    %eax,%esi
    ce8a:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce8d:	01 f0                	add    %esi,%eax
    ce8f:	0f b6 00             	movzbl (%eax),%eax
    ce92:	0f b6 c0             	movzbl %al,%eax
    ce95:	83 ec 0c             	sub    $0xc,%esp
    ce98:	53                   	push   %ebx
    ce99:	51                   	push   %ecx
    ce9a:	52                   	push   %edx
    ce9b:	50                   	push   %eax
    ce9c:	ff 75 08             	pushl  0x8(%ebp)
    ce9f:	e8 be be ff ff       	call   8d62 <lodepng_palette_add>
    cea4:	83 c4 20             	add    $0x20,%esp
    cea7:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    ceaa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ceae:	75 13                	jne    cec3 <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    ceb0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ceb4:	8b 45 10             	mov    0x10(%ebp),%eax
    ceb7:	8b 50 14             	mov    0x14(%eax),%edx
    ceba:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cebd:	39 c2                	cmp    %eax,%edx
    cebf:	75 85                	jne    ce46 <auto_choose_color+0x167>
    cec1:	eb 01                	jmp    cec4 <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    cec3:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    cec4:	8b 45 08             	mov    0x8(%ebp),%eax
    cec7:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    cecd:	8b 45 08             	mov    0x8(%ebp),%eax
    ced0:	8b 55 d0             	mov    -0x30(%ebp),%edx
    ced3:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    ced6:	8b 45 0c             	mov    0xc(%ebp),%eax
    ced9:	8b 00                	mov    (%eax),%eax
    cedb:	83 f8 03             	cmp    $0x3,%eax
    cede:	0f 85 ec 00 00 00    	jne    cfd0 <auto_choose_color+0x2f1>
    cee4:	8b 45 0c             	mov    0xc(%ebp),%eax
    cee7:	8b 50 0c             	mov    0xc(%eax),%edx
    ceea:	8b 45 08             	mov    0x8(%ebp),%eax
    ceed:	8b 40 0c             	mov    0xc(%eax),%eax
    cef0:	39 c2                	cmp    %eax,%edx
    cef2:	0f 8c d8 00 00 00    	jl     cfd0 <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    cef8:	8b 45 0c             	mov    0xc(%ebp),%eax
    cefb:	8b 50 04             	mov    0x4(%eax),%edx
    cefe:	8b 45 08             	mov    0x8(%ebp),%eax
    cf01:	8b 40 04             	mov    0x4(%eax),%eax
    cf04:	39 c2                	cmp    %eax,%edx
    cf06:	0f 85 c4 00 00 00    	jne    cfd0 <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    cf0c:	83 ec 0c             	sub    $0xc,%esp
    cf0f:	ff 75 08             	pushl  0x8(%ebp)
    cf12:	e8 0e bc ff ff       	call   8b25 <lodepng_color_mode_cleanup>
    cf17:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    cf1a:	83 ec 08             	sub    $0x8,%esp
    cf1d:	ff 75 0c             	pushl  0xc(%ebp)
    cf20:	ff 75 08             	pushl  0x8(%ebp)
    cf23:	e8 14 bc ff ff       	call   8b3c <lodepng_color_mode_copy>
    cf28:	83 c4 10             	add    $0x10,%esp
    cf2b:	e9 a0 00 00 00       	jmp    cfd0 <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    cf30:	8b 45 08             	mov    0x8(%ebp),%eax
    cf33:	8b 55 dc             	mov    -0x24(%ebp),%edx
    cf36:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    cf39:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cf3d:	74 14                	je     cf53 <auto_choose_color+0x274>
    cf3f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cf43:	74 07                	je     cf4c <auto_choose_color+0x26d>
    cf45:	b8 04 00 00 00       	mov    $0x4,%eax
    cf4a:	eb 19                	jmp    cf65 <auto_choose_color+0x286>
    cf4c:	b8 06 00 00 00       	mov    $0x6,%eax
    cf51:	eb 12                	jmp    cf65 <auto_choose_color+0x286>
    cf53:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cf57:	74 07                	je     cf60 <auto_choose_color+0x281>
    cf59:	b8 00 00 00 00       	mov    $0x0,%eax
    cf5e:	eb 05                	jmp    cf65 <auto_choose_color+0x286>
    cf60:	b8 02 00 00 00       	mov    $0x2,%eax
    cf65:	8b 55 08             	mov    0x8(%ebp),%edx
    cf68:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    cf6a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cf6e:	74 60                	je     cfd0 <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    cf70:	8b 45 08             	mov    0x8(%ebp),%eax
    cf73:	8b 40 04             	mov    0x4(%eax),%eax
    cf76:	ba 01 00 00 00       	mov    $0x1,%edx
    cf7b:	89 c1                	mov    %eax,%ecx
    cf7d:	d3 e2                	shl    %cl,%edx
    cf7f:	89 d0                	mov    %edx,%eax
    cf81:	83 e8 01             	sub    $0x1,%eax
    cf84:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    cf87:	8b 45 10             	mov    0x10(%ebp),%eax
    cf8a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cf8e:	0f b7 c0             	movzwl %ax,%eax
    cf91:	23 45 c8             	and    -0x38(%ebp),%eax
    cf94:	89 c2                	mov    %eax,%edx
    cf96:	8b 45 08             	mov    0x8(%ebp),%eax
    cf99:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    cf9c:	8b 45 10             	mov    0x10(%ebp),%eax
    cf9f:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cfa3:	0f b7 c0             	movzwl %ax,%eax
    cfa6:	23 45 c8             	and    -0x38(%ebp),%eax
    cfa9:	89 c2                	mov    %eax,%edx
    cfab:	8b 45 08             	mov    0x8(%ebp),%eax
    cfae:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    cfb1:	8b 45 10             	mov    0x10(%ebp),%eax
    cfb4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cfb8:	0f b7 c0             	movzwl %ax,%eax
    cfbb:	23 45 c8             	and    -0x38(%ebp),%eax
    cfbe:	89 c2                	mov    %eax,%edx
    cfc0:	8b 45 08             	mov    0x8(%ebp),%eax
    cfc3:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    cfc6:	8b 45 08             	mov    0x8(%ebp),%eax
    cfc9:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    cfd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    cfd3:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cfd6:	5b                   	pop    %ebx
    cfd7:	5e                   	pop    %esi
    cfd8:	5d                   	pop    %ebp
    cfd9:	c3                   	ret    

0000cfda <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    cfda:	55                   	push   %ebp
    cfdb:	89 e5                	mov    %esp,%ebp
    cfdd:	83 ec 1c             	sub    $0x1c,%esp
    cfe0:	8b 4d 08             	mov    0x8(%ebp),%ecx
    cfe3:	8b 55 0c             	mov    0xc(%ebp),%edx
    cfe6:	8b 45 10             	mov    0x10(%ebp),%eax
    cfe9:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    cfed:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    cff1:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    cff5:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    cff9:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    cffd:	29 c2                	sub    %eax,%edx
    cfff:	89 d0                	mov    %edx,%eax
    d001:	99                   	cltd   
    d002:	31 d0                	xor    %edx,%eax
    d004:	29 d0                	sub    %edx,%eax
    d006:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    d00a:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d00e:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d012:	29 c2                	sub    %eax,%edx
    d014:	89 d0                	mov    %edx,%eax
    d016:	99                   	cltd   
    d017:	31 d0                	xor    %edx,%eax
    d019:	29 d0                	sub    %edx,%eax
    d01b:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    d01f:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d023:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    d027:	01 c2                	add    %eax,%edx
    d029:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d02d:	29 c2                	sub    %eax,%edx
    d02f:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d033:	29 c2                	sub    %eax,%edx
    d035:	89 d0                	mov    %edx,%eax
    d037:	99                   	cltd   
    d038:	31 d0                	xor    %edx,%eax
    d03a:	29 d0                	sub    %edx,%eax
    d03c:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    d040:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d044:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d048:	7d 10                	jge    d05a <paethPredictor+0x80>
    d04a:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    d04e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    d052:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d056:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    d05a:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    d05e:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d062:	7d 06                	jge    d06a <paethPredictor+0x90>
    d064:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    d068:	eb 04                	jmp    d06e <paethPredictor+0x94>
    d06a:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    d06e:	c9                   	leave  
    d06f:	c3                   	ret    

0000d070 <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    d070:	55                   	push   %ebp
    d071:	89 e5                	mov    %esp,%ebp
    d073:	56                   	push   %esi
    d074:	53                   	push   %ebx
    d075:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d078:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d07f:	e9 e2 00 00 00       	jmp    d166 <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    d084:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d087:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d08e:	8b 45 08             	mov    0x8(%ebp),%eax
    d091:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d094:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d097:	8b 14 85 f4 9f 01 00 	mov    0x19ff4(,%eax,4),%edx
    d09e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d0a1:	01 c2                	add    %eax,%edx
    d0a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0a6:	8b 04 85 bc 9f 01 00 	mov    0x19fbc(,%eax,4),%eax
    d0ad:	29 c2                	sub    %eax,%edx
    d0af:	89 d0                	mov    %edx,%eax
    d0b1:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d0b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0b7:	8b 34 85 f4 9f 01 00 	mov    0x19ff4(,%eax,4),%esi
    d0be:	89 d8                	mov    %ebx,%eax
    d0c0:	ba 00 00 00 00       	mov    $0x0,%edx
    d0c5:	f7 f6                	div    %esi
    d0c7:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    d0c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0cc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d0d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    d0d6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d0d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0dc:	8b 14 85 10 a0 01 00 	mov    0x1a010(,%eax,4),%edx
    d0e3:	8b 45 20             	mov    0x20(%ebp),%eax
    d0e6:	01 c2                	add    %eax,%edx
    d0e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0eb:	8b 04 85 d8 9f 01 00 	mov    0x19fd8(,%eax,4),%eax
    d0f2:	29 c2                	sub    %eax,%edx
    d0f4:	89 d0                	mov    %edx,%eax
    d0f6:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d0f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0fc:	8b 34 85 10 a0 01 00 	mov    0x1a010(,%eax,4),%esi
    d103:	89 d8                	mov    %ebx,%eax
    d105:	ba 00 00 00 00       	mov    $0x0,%edx
    d10a:	f7 f6                	div    %esi
    d10c:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    d10e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d111:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d118:	8b 45 08             	mov    0x8(%ebp),%eax
    d11b:	01 d0                	add    %edx,%eax
    d11d:	8b 00                	mov    (%eax),%eax
    d11f:	85 c0                	test   %eax,%eax
    d121:	75 15                	jne    d138 <Adam7_getpassvalues+0xc8>
    d123:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d126:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d12d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d130:	01 d0                	add    %edx,%eax
    d132:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    d138:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d13b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d142:	8b 45 0c             	mov    0xc(%ebp),%eax
    d145:	01 d0                	add    %edx,%eax
    d147:	8b 00                	mov    (%eax),%eax
    d149:	85 c0                	test   %eax,%eax
    d14b:	75 15                	jne    d162 <Adam7_getpassvalues+0xf2>
    d14d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d150:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d157:	8b 45 08             	mov    0x8(%ebp),%eax
    d15a:	01 d0                	add    %edx,%eax
    d15c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d162:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d166:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d16a:	0f 85 14 ff ff ff    	jne    d084 <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    d170:	8b 45 18             	mov    0x18(%ebp),%eax
    d173:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d179:	8b 45 18             	mov    0x18(%ebp),%eax
    d17c:	8b 10                	mov    (%eax),%edx
    d17e:	8b 45 14             	mov    0x14(%ebp),%eax
    d181:	89 10                	mov    %edx,(%eax)
    d183:	8b 45 14             	mov    0x14(%ebp),%eax
    d186:	8b 10                	mov    (%eax),%edx
    d188:	8b 45 10             	mov    0x10(%ebp),%eax
    d18b:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    d18d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d194:	e9 40 01 00 00       	jmp    d2d9 <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d199:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d19c:	83 c0 01             	add    $0x1,%eax
    d19f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1a6:	8b 45 10             	mov    0x10(%ebp),%eax
    d1a9:	01 c2                	add    %eax,%edx
    d1ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1ae:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1b5:	8b 45 10             	mov    0x10(%ebp),%eax
    d1b8:	01 c8                	add    %ecx,%eax
    d1ba:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    d1bc:	89 c6                	mov    %eax,%esi
    d1be:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1c1:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1c8:	8b 45 08             	mov    0x8(%ebp),%eax
    d1cb:	01 c8                	add    %ecx,%eax
    d1cd:	8b 00                	mov    (%eax),%eax
    d1cf:	85 c0                	test   %eax,%eax
    d1d1:	74 49                	je     d21c <Adam7_getpassvalues+0x1ac>
    d1d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1d6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1e0:	01 c8                	add    %ecx,%eax
    d1e2:	8b 00                	mov    (%eax),%eax
    d1e4:	85 c0                	test   %eax,%eax
    d1e6:	74 34                	je     d21c <Adam7_getpassvalues+0x1ac>
    d1e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1eb:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1f5:	01 c8                	add    %ecx,%eax
    d1f7:	8b 08                	mov    (%eax),%ecx
    d1f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1fc:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d203:	8b 45 08             	mov    0x8(%ebp),%eax
    d206:	01 d8                	add    %ebx,%eax
    d208:	8b 00                	mov    (%eax),%eax
    d20a:	0f af 45 24          	imul   0x24(%ebp),%eax
    d20e:	83 c0 07             	add    $0x7,%eax
    d211:	c1 e8 03             	shr    $0x3,%eax
    d214:	83 c0 01             	add    $0x1,%eax
    d217:	0f af c1             	imul   %ecx,%eax
    d21a:	eb 05                	jmp    d221 <Adam7_getpassvalues+0x1b1>
    d21c:	b8 00 00 00 00       	mov    $0x0,%eax
    d221:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d223:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    d225:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d228:	83 c0 01             	add    $0x1,%eax
    d22b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d232:	8b 45 14             	mov    0x14(%ebp),%eax
    d235:	01 c2                	add    %eax,%edx
    d237:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d23a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d241:	8b 45 14             	mov    0x14(%ebp),%eax
    d244:	01 c8                	add    %ecx,%eax
    d246:	8b 00                	mov    (%eax),%eax
    d248:	89 c6                	mov    %eax,%esi
    d24a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d24d:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d254:	8b 45 0c             	mov    0xc(%ebp),%eax
    d257:	01 c8                	add    %ecx,%eax
    d259:	8b 08                	mov    (%eax),%ecx
    d25b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d25e:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d265:	8b 45 08             	mov    0x8(%ebp),%eax
    d268:	01 d8                	add    %ebx,%eax
    d26a:	8b 00                	mov    (%eax),%eax
    d26c:	0f af 45 24          	imul   0x24(%ebp),%eax
    d270:	83 c0 07             	add    $0x7,%eax
    d273:	c1 e8 03             	shr    $0x3,%eax
    d276:	0f af c1             	imul   %ecx,%eax
    d279:	01 f0                	add    %esi,%eax
    d27b:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    d27d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d280:	83 c0 01             	add    $0x1,%eax
    d283:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d28a:	8b 45 18             	mov    0x18(%ebp),%eax
    d28d:	01 c2                	add    %eax,%edx
    d28f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d292:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d299:	8b 45 18             	mov    0x18(%ebp),%eax
    d29c:	01 c8                	add    %ecx,%eax
    d29e:	8b 00                	mov    (%eax),%eax
    d2a0:	89 c6                	mov    %eax,%esi
    d2a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2a5:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d2ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    d2af:	01 c8                	add    %ecx,%eax
    d2b1:	8b 08                	mov    (%eax),%ecx
    d2b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2b6:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d2bd:	8b 45 08             	mov    0x8(%ebp),%eax
    d2c0:	01 d8                	add    %ebx,%eax
    d2c2:	8b 00                	mov    (%eax),%eax
    d2c4:	0f af c1             	imul   %ecx,%eax
    d2c7:	0f af 45 24          	imul   0x24(%ebp),%eax
    d2cb:	83 c0 07             	add    $0x7,%eax
    d2ce:	c1 e8 03             	shr    $0x3,%eax
    d2d1:	01 f0                	add    %esi,%eax
    d2d3:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    d2d5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d2d9:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d2dd:	0f 85 b6 fe ff ff    	jne    d199 <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    d2e3:	90                   	nop
    d2e4:	83 c4 10             	add    $0x10,%esp
    d2e7:	5b                   	pop    %ebx
    d2e8:	5e                   	pop    %esi
    d2e9:	5d                   	pop    %ebp
    d2ea:	c3                   	ret    

0000d2eb <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    d2eb:	55                   	push   %ebp
    d2ec:	89 e5                	mov    %esp,%ebp
    d2ee:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    d2f1:	8b 45 10             	mov    0x10(%ebp),%eax
    d2f4:	05 98 00 00 00       	add    $0x98,%eax
    d2f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    d2fc:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    d300:	74 06                	je     d308 <lodepng_inspect+0x1d>
    d302:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d306:	75 17                	jne    d31f <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    d308:	8b 45 10             	mov    0x10(%ebp),%eax
    d30b:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    d312:	00 00 00 
    d315:	b8 30 00 00 00       	mov    $0x30,%eax
    d31a:	e9 ce 02 00 00       	jmp    d5ed <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    d31f:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    d323:	7f 17                	jg     d33c <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    d325:	8b 45 10             	mov    0x10(%ebp),%eax
    d328:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    d32f:	00 00 00 
    d332:	b8 1b 00 00 00       	mov    $0x1b,%eax
    d337:	e9 b1 02 00 00       	jmp    d5ed <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    d33c:	83 ec 0c             	sub    $0xc,%esp
    d33f:	ff 75 f4             	pushl  -0xc(%ebp)
    d342:	e8 63 c7 ff ff       	call   9aaa <lodepng_info_cleanup>
    d347:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    d34a:	83 ec 0c             	sub    $0xc,%esp
    d34d:	ff 75 f4             	pushl  -0xc(%ebp)
    d350:	e8 74 c6 ff ff       	call   99c9 <lodepng_info_init>
    d355:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    d358:	8b 45 14             	mov    0x14(%ebp),%eax
    d35b:	0f b6 00             	movzbl (%eax),%eax
    d35e:	3c 89                	cmp    $0x89,%al
    d360:	75 5b                	jne    d3bd <lodepng_inspect+0xd2>
    d362:	8b 45 14             	mov    0x14(%ebp),%eax
    d365:	83 c0 01             	add    $0x1,%eax
    d368:	0f b6 00             	movzbl (%eax),%eax
    d36b:	3c 50                	cmp    $0x50,%al
    d36d:	75 4e                	jne    d3bd <lodepng_inspect+0xd2>
    d36f:	8b 45 14             	mov    0x14(%ebp),%eax
    d372:	83 c0 02             	add    $0x2,%eax
    d375:	0f b6 00             	movzbl (%eax),%eax
    d378:	3c 4e                	cmp    $0x4e,%al
    d37a:	75 41                	jne    d3bd <lodepng_inspect+0xd2>
    d37c:	8b 45 14             	mov    0x14(%ebp),%eax
    d37f:	83 c0 03             	add    $0x3,%eax
    d382:	0f b6 00             	movzbl (%eax),%eax
    d385:	3c 47                	cmp    $0x47,%al
    d387:	75 34                	jne    d3bd <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    d389:	8b 45 14             	mov    0x14(%ebp),%eax
    d38c:	83 c0 04             	add    $0x4,%eax
    d38f:	0f b6 00             	movzbl (%eax),%eax
    d392:	3c 0d                	cmp    $0xd,%al
    d394:	75 27                	jne    d3bd <lodepng_inspect+0xd2>
    d396:	8b 45 14             	mov    0x14(%ebp),%eax
    d399:	83 c0 05             	add    $0x5,%eax
    d39c:	0f b6 00             	movzbl (%eax),%eax
    d39f:	3c 0a                	cmp    $0xa,%al
    d3a1:	75 1a                	jne    d3bd <lodepng_inspect+0xd2>
    d3a3:	8b 45 14             	mov    0x14(%ebp),%eax
    d3a6:	83 c0 06             	add    $0x6,%eax
    d3a9:	0f b6 00             	movzbl (%eax),%eax
    d3ac:	3c 1a                	cmp    $0x1a,%al
    d3ae:	75 0d                	jne    d3bd <lodepng_inspect+0xd2>
    d3b0:	8b 45 14             	mov    0x14(%ebp),%eax
    d3b3:	83 c0 07             	add    $0x7,%eax
    d3b6:	0f b6 00             	movzbl (%eax),%eax
    d3b9:	3c 0a                	cmp    $0xa,%al
    d3bb:	74 17                	je     d3d4 <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    d3bd:	8b 45 10             	mov    0x10(%ebp),%eax
    d3c0:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    d3c7:	00 00 00 
    d3ca:	b8 1c 00 00 00       	mov    $0x1c,%eax
    d3cf:	e9 19 02 00 00       	jmp    d5ed <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    d3d4:	8b 45 14             	mov    0x14(%ebp),%eax
    d3d7:	83 c0 08             	add    $0x8,%eax
    d3da:	83 ec 0c             	sub    $0xc,%esp
    d3dd:	50                   	push   %eax
    d3de:	e8 c2 ae ff ff       	call   82a5 <lodepng_chunk_length>
    d3e3:	83 c4 10             	add    $0x10,%esp
    d3e6:	83 f8 0d             	cmp    $0xd,%eax
    d3e9:	74 17                	je     d402 <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    d3eb:	8b 45 10             	mov    0x10(%ebp),%eax
    d3ee:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    d3f5:	00 00 00 
    d3f8:	b8 5e 00 00 00       	mov    $0x5e,%eax
    d3fd:	e9 eb 01 00 00       	jmp    d5ed <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    d402:	8b 45 14             	mov    0x14(%ebp),%eax
    d405:	83 c0 08             	add    $0x8,%eax
    d408:	83 ec 08             	sub    $0x8,%esp
    d40b:	68 2c a0 01 00       	push   $0x1a02c
    d410:	50                   	push   %eax
    d411:	e8 dc ae ff ff       	call   82f2 <lodepng_chunk_type_equals>
    d416:	83 c4 10             	add    $0x10,%esp
    d419:	84 c0                	test   %al,%al
    d41b:	75 17                	jne    d434 <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    d41d:	8b 45 10             	mov    0x10(%ebp),%eax
    d420:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    d427:	00 00 00 
    d42a:	b8 1d 00 00 00       	mov    $0x1d,%eax
    d42f:	e9 b9 01 00 00       	jmp    d5ed <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    d434:	8b 45 14             	mov    0x14(%ebp),%eax
    d437:	83 c0 10             	add    $0x10,%eax
    d43a:	83 ec 0c             	sub    $0xc,%esp
    d43d:	50                   	push   %eax
    d43e:	e8 5e 62 ff ff       	call   36a1 <lodepng_read32bitInt>
    d443:	83 c4 10             	add    $0x10,%esp
    d446:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    d449:	8b 45 14             	mov    0x14(%ebp),%eax
    d44c:	83 c0 14             	add    $0x14,%eax
    d44f:	83 ec 0c             	sub    $0xc,%esp
    d452:	50                   	push   %eax
    d453:	e8 49 62 ff ff       	call   36a1 <lodepng_read32bitInt>
    d458:	83 c4 10             	add    $0x10,%esp
    d45b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    d45e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    d462:	74 08                	je     d46c <lodepng_inspect+0x181>
    d464:	8b 45 08             	mov    0x8(%ebp),%eax
    d467:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d46a:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    d46c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    d470:	74 08                	je     d47a <lodepng_inspect+0x18f>
    d472:	8b 45 0c             	mov    0xc(%ebp),%eax
    d475:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d478:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    d47a:	8b 45 14             	mov    0x14(%ebp),%eax
    d47d:	83 c0 18             	add    $0x18,%eax
    d480:	0f b6 00             	movzbl (%eax),%eax
    d483:	0f b6 d0             	movzbl %al,%edx
    d486:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d489:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    d48c:	8b 45 14             	mov    0x14(%ebp),%eax
    d48f:	83 c0 19             	add    $0x19,%eax
    d492:	0f b6 00             	movzbl (%eax),%eax
    d495:	0f b6 d0             	movzbl %al,%edx
    d498:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d49b:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    d49e:	8b 45 14             	mov    0x14(%ebp),%eax
    d4a1:	83 c0 1a             	add    $0x1a,%eax
    d4a4:	0f b6 00             	movzbl (%eax),%eax
    d4a7:	0f b6 d0             	movzbl %al,%edx
    d4aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4ad:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    d4af:	8b 45 14             	mov    0x14(%ebp),%eax
    d4b2:	83 c0 1b             	add    $0x1b,%eax
    d4b5:	0f b6 00             	movzbl (%eax),%eax
    d4b8:	0f b6 d0             	movzbl %al,%edx
    d4bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4be:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    d4c1:	8b 45 14             	mov    0x14(%ebp),%eax
    d4c4:	83 c0 1c             	add    $0x1c,%eax
    d4c7:	0f b6 00             	movzbl (%eax),%eax
    d4ca:	0f b6 d0             	movzbl %al,%edx
    d4cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4d0:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    d4d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d4d7:	74 06                	je     d4df <lodepng_inspect+0x1f4>
    d4d9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d4dd:	75 17                	jne    d4f6 <lodepng_inspect+0x20b>
    d4df:	8b 45 10             	mov    0x10(%ebp),%eax
    d4e2:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    d4e9:	00 00 00 
    d4ec:	b8 5d 00 00 00       	mov    $0x5d,%eax
    d4f1:	e9 f7 00 00 00       	jmp    d5ed <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    d4f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4f9:	8b 50 10             	mov    0x10(%eax),%edx
    d4fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4ff:	8b 40 0c             	mov    0xc(%eax),%eax
    d502:	83 ec 08             	sub    $0x8,%esp
    d505:	52                   	push   %edx
    d506:	50                   	push   %eax
    d507:	e8 d4 b3 ff ff       	call   88e0 <checkColorValidity>
    d50c:	83 c4 10             	add    $0x10,%esp
    d50f:	89 c2                	mov    %eax,%edx
    d511:	8b 45 10             	mov    0x10(%ebp),%eax
    d514:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    d51a:	8b 45 10             	mov    0x10(%ebp),%eax
    d51d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d523:	85 c0                	test   %eax,%eax
    d525:	74 0e                	je     d535 <lodepng_inspect+0x24a>
    d527:	8b 45 10             	mov    0x10(%ebp),%eax
    d52a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d530:	e9 b8 00 00 00       	jmp    d5ed <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    d535:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d538:	8b 00                	mov    (%eax),%eax
    d53a:	85 c0                	test   %eax,%eax
    d53c:	74 17                	je     d555 <lodepng_inspect+0x26a>
    d53e:	8b 45 10             	mov    0x10(%ebp),%eax
    d541:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    d548:	00 00 00 
    d54b:	b8 20 00 00 00       	mov    $0x20,%eax
    d550:	e9 98 00 00 00       	jmp    d5ed <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    d555:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d558:	8b 40 04             	mov    0x4(%eax),%eax
    d55b:	85 c0                	test   %eax,%eax
    d55d:	74 14                	je     d573 <lodepng_inspect+0x288>
    d55f:	8b 45 10             	mov    0x10(%ebp),%eax
    d562:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    d569:	00 00 00 
    d56c:	b8 21 00 00 00       	mov    $0x21,%eax
    d571:	eb 7a                	jmp    d5ed <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    d573:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d576:	8b 40 08             	mov    0x8(%eax),%eax
    d579:	83 f8 01             	cmp    $0x1,%eax
    d57c:	76 14                	jbe    d592 <lodepng_inspect+0x2a7>
    d57e:	8b 45 10             	mov    0x10(%ebp),%eax
    d581:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    d588:	00 00 00 
    d58b:	b8 22 00 00 00       	mov    $0x22,%eax
    d590:	eb 5b                	jmp    d5ed <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    d592:	8b 45 10             	mov    0x10(%ebp),%eax
    d595:	8b 40 18             	mov    0x18(%eax),%eax
    d598:	85 c0                	test   %eax,%eax
    d59a:	75 48                	jne    d5e4 <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    d59c:	8b 45 14             	mov    0x14(%ebp),%eax
    d59f:	83 c0 1d             	add    $0x1d,%eax
    d5a2:	83 ec 0c             	sub    $0xc,%esp
    d5a5:	50                   	push   %eax
    d5a6:	e8 f6 60 ff ff       	call   36a1 <lodepng_read32bitInt>
    d5ab:	83 c4 10             	add    $0x10,%esp
    d5ae:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    d5b1:	8b 45 14             	mov    0x14(%ebp),%eax
    d5b4:	83 c0 0c             	add    $0xc,%eax
    d5b7:	83 ec 08             	sub    $0x8,%esp
    d5ba:	6a 11                	push   $0x11
    d5bc:	50                   	push   %eax
    d5bd:	e8 71 ab ff ff       	call   8133 <lodepng_crc32>
    d5c2:	83 c4 10             	add    $0x10,%esp
    d5c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    d5c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d5cb:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    d5ce:	74 14                	je     d5e4 <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    d5d0:	8b 45 10             	mov    0x10(%ebp),%eax
    d5d3:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    d5da:	00 00 00 
    d5dd:	b8 39 00 00 00       	mov    $0x39,%eax
    d5e2:	eb 09                	jmp    d5ed <lodepng_inspect+0x302>
    }
  }

  return state->error;
    d5e4:	8b 45 10             	mov    0x10(%ebp),%eax
    d5e7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    d5ed:	c9                   	leave  
    d5ee:	c3                   	ret    

0000d5ef <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    d5ef:	55                   	push   %ebp
    d5f0:	89 e5                	mov    %esp,%ebp
    d5f2:	56                   	push   %esi
    d5f3:	53                   	push   %ebx
    d5f4:	83 ec 44             	sub    $0x44,%esp
    d5f7:	8b 45 18             	mov    0x18(%ebp),%eax
    d5fa:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    d5fd:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    d601:	83 f8 04             	cmp    $0x4,%eax
    d604:	0f 87 81 07 00 00    	ja     dd8b <unfilterScanline+0x79c>
    d60a:	8b 04 85 34 a0 01 00 	mov    0x1a034(,%eax,4),%eax
    d611:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d613:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d61a:	eb 19                	jmp    d635 <unfilterScanline+0x46>
    d61c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d61f:	8b 45 08             	mov    0x8(%ebp),%eax
    d622:	01 c2                	add    %eax,%edx
    d624:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d627:	8b 45 0c             	mov    0xc(%ebp),%eax
    d62a:	01 c8                	add    %ecx,%eax
    d62c:	0f b6 00             	movzbl (%eax),%eax
    d62f:	88 02                	mov    %al,(%edx)
    d631:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d635:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d638:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d63b:	75 df                	jne    d61c <unfilterScanline+0x2d>
      break;
    d63d:	e9 50 07 00 00       	jmp    dd92 <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d642:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d649:	eb 19                	jmp    d664 <unfilterScanline+0x75>
    d64b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d64e:	8b 45 08             	mov    0x8(%ebp),%eax
    d651:	01 c2                	add    %eax,%edx
    d653:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d656:	8b 45 0c             	mov    0xc(%ebp),%eax
    d659:	01 c8                	add    %ecx,%eax
    d65b:	0f b6 00             	movzbl (%eax),%eax
    d65e:	88 02                	mov    %al,(%edx)
    d660:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d664:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d667:	3b 45 14             	cmp    0x14(%ebp),%eax
    d66a:	75 df                	jne    d64b <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    d66c:	8b 45 14             	mov    0x14(%ebp),%eax
    d66f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d672:	eb 2b                	jmp    d69f <unfilterScanline+0xb0>
    d674:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d677:	8b 45 08             	mov    0x8(%ebp),%eax
    d67a:	01 c2                	add    %eax,%edx
    d67c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d67f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d682:	01 c8                	add    %ecx,%eax
    d684:	0f b6 08             	movzbl (%eax),%ecx
    d687:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d68a:	2b 45 14             	sub    0x14(%ebp),%eax
    d68d:	89 c3                	mov    %eax,%ebx
    d68f:	8b 45 08             	mov    0x8(%ebp),%eax
    d692:	01 d8                	add    %ebx,%eax
    d694:	0f b6 00             	movzbl (%eax),%eax
    d697:	01 c8                	add    %ecx,%eax
    d699:	88 02                	mov    %al,(%edx)
    d69b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d69f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6a2:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d6a5:	7c cd                	jl     d674 <unfilterScanline+0x85>
      break;
    d6a7:	e9 e6 06 00 00       	jmp    dd92 <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    d6ac:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d6b0:	74 3c                	je     d6ee <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    d6b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d6b9:	eb 26                	jmp    d6e1 <unfilterScanline+0xf2>
    d6bb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d6be:	8b 45 08             	mov    0x8(%ebp),%eax
    d6c1:	01 d0                	add    %edx,%eax
    d6c3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d6c6:	8b 55 0c             	mov    0xc(%ebp),%edx
    d6c9:	01 ca                	add    %ecx,%edx
    d6cb:	0f b6 0a             	movzbl (%edx),%ecx
    d6ce:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d6d1:	8b 55 10             	mov    0x10(%ebp),%edx
    d6d4:	01 da                	add    %ebx,%edx
    d6d6:	0f b6 12             	movzbl (%edx),%edx
    d6d9:	01 ca                	add    %ecx,%edx
    d6db:	88 10                	mov    %dl,(%eax)
    d6dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d6e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6e4:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d6e7:	75 d2                	jne    d6bb <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    d6e9:	e9 a4 06 00 00       	jmp    dd92 <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d6ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d6f5:	eb 19                	jmp    d710 <unfilterScanline+0x121>
    d6f7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d6fa:	8b 45 08             	mov    0x8(%ebp),%eax
    d6fd:	01 c2                	add    %eax,%edx
    d6ff:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d702:	8b 45 0c             	mov    0xc(%ebp),%eax
    d705:	01 c8                	add    %ecx,%eax
    d707:	0f b6 00             	movzbl (%eax),%eax
    d70a:	88 02                	mov    %al,(%edx)
    d70c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d710:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d713:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d716:	75 df                	jne    d6f7 <unfilterScanline+0x108>
      }
      break;
    d718:	e9 75 06 00 00       	jmp    dd92 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    d71d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d721:	0f 84 8e 00 00 00    	je     d7b5 <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    d727:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d72e:	eb 28                	jmp    d758 <unfilterScanline+0x169>
    d730:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d733:	8b 45 08             	mov    0x8(%ebp),%eax
    d736:	01 d0                	add    %edx,%eax
    d738:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d73b:	8b 55 0c             	mov    0xc(%ebp),%edx
    d73e:	01 ca                	add    %ecx,%edx
    d740:	0f b6 12             	movzbl (%edx),%edx
    d743:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d746:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d749:	01 d9                	add    %ebx,%ecx
    d74b:	0f b6 09             	movzbl (%ecx),%ecx
    d74e:	d0 e9                	shr    %cl
    d750:	01 ca                	add    %ecx,%edx
    d752:	88 10                	mov    %dl,(%eax)
    d754:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d758:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d75b:	3b 45 14             	cmp    0x14(%ebp),%eax
    d75e:	75 d0                	jne    d730 <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    d760:	8b 45 14             	mov    0x14(%ebp),%eax
    d763:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d766:	eb 40                	jmp    d7a8 <unfilterScanline+0x1b9>
    d768:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d76b:	8b 45 08             	mov    0x8(%ebp),%eax
    d76e:	01 c2                	add    %eax,%edx
    d770:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d773:	8b 45 0c             	mov    0xc(%ebp),%eax
    d776:	01 c8                	add    %ecx,%eax
    d778:	0f b6 08             	movzbl (%eax),%ecx
    d77b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d77e:	2b 45 14             	sub    0x14(%ebp),%eax
    d781:	89 c3                	mov    %eax,%ebx
    d783:	8b 45 08             	mov    0x8(%ebp),%eax
    d786:	01 d8                	add    %ebx,%eax
    d788:	0f b6 00             	movzbl (%eax),%eax
    d78b:	0f b6 d8             	movzbl %al,%ebx
    d78e:	8b 75 f4             	mov    -0xc(%ebp),%esi
    d791:	8b 45 10             	mov    0x10(%ebp),%eax
    d794:	01 f0                	add    %esi,%eax
    d796:	0f b6 00             	movzbl (%eax),%eax
    d799:	0f b6 c0             	movzbl %al,%eax
    d79c:	01 d8                	add    %ebx,%eax
    d79e:	d1 f8                	sar    %eax
    d7a0:	01 c8                	add    %ecx,%eax
    d7a2:	88 02                	mov    %al,(%edx)
    d7a4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7ab:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d7ae:	7c b8                	jl     d768 <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    d7b0:	e9 dd 05 00 00       	jmp    dd92 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d7b5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d7bc:	eb 19                	jmp    d7d7 <unfilterScanline+0x1e8>
    d7be:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d7c1:	8b 45 08             	mov    0x8(%ebp),%eax
    d7c4:	01 c2                	add    %eax,%edx
    d7c6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7cc:	01 c8                	add    %ecx,%eax
    d7ce:	0f b6 00             	movzbl (%eax),%eax
    d7d1:	88 02                	mov    %al,(%edx)
    d7d3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7da:	3b 45 14             	cmp    0x14(%ebp),%eax
    d7dd:	75 df                	jne    d7be <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    d7df:	8b 45 14             	mov    0x14(%ebp),%eax
    d7e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d7e5:	eb 2d                	jmp    d814 <unfilterScanline+0x225>
    d7e7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d7ea:	8b 45 08             	mov    0x8(%ebp),%eax
    d7ed:	01 c2                	add    %eax,%edx
    d7ef:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7f5:	01 c8                	add    %ecx,%eax
    d7f7:	0f b6 08             	movzbl (%eax),%ecx
    d7fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7fd:	2b 45 14             	sub    0x14(%ebp),%eax
    d800:	89 c3                	mov    %eax,%ebx
    d802:	8b 45 08             	mov    0x8(%ebp),%eax
    d805:	01 d8                	add    %ebx,%eax
    d807:	0f b6 00             	movzbl (%eax),%eax
    d80a:	d0 e8                	shr    %al
    d80c:	01 c8                	add    %ecx,%eax
    d80e:	88 02                	mov    %al,(%edx)
    d810:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d814:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d817:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d81a:	7c cb                	jl     d7e7 <unfilterScanline+0x1f8>
      }
      break;
    d81c:	e9 71 05 00 00       	jmp    dd92 <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    d821:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d825:	0f 84 f9 04 00 00    	je     dd24 <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    d82b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d832:	eb 26                	jmp    d85a <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    d834:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d837:	8b 45 08             	mov    0x8(%ebp),%eax
    d83a:	01 d0                	add    %edx,%eax
    d83c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d83f:	8b 55 0c             	mov    0xc(%ebp),%edx
    d842:	01 ca                	add    %ecx,%edx
    d844:	0f b6 0a             	movzbl (%edx),%ecx
    d847:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d84a:	8b 55 10             	mov    0x10(%ebp),%edx
    d84d:	01 da                	add    %ebx,%edx
    d84f:	0f b6 12             	movzbl (%edx),%edx
    d852:	01 ca                	add    %ecx,%edx
    d854:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    d856:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d85a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d85d:	3b 45 14             	cmp    0x14(%ebp),%eax
    d860:	75 d2                	jne    d834 <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    d862:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    d866:	0f 8e db 01 00 00    	jle    da47 <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    d86c:	e9 c2 01 00 00       	jmp    da33 <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    d871:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d874:	2b 45 14             	sub    0x14(%ebp),%eax
    d877:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    d87a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d87d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d880:	01 d0                	add    %edx,%eax
    d882:	0f b6 00             	movzbl (%eax),%eax
    d885:	88 45 ef             	mov    %al,-0x11(%ebp)
    d888:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d88b:	8d 50 01             	lea    0x1(%eax),%edx
    d88e:	8b 45 0c             	mov    0xc(%ebp),%eax
    d891:	01 d0                	add    %edx,%eax
    d893:	0f b6 00             	movzbl (%eax),%eax
    d896:	88 45 ee             	mov    %al,-0x12(%ebp)
    d899:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d89c:	8d 50 02             	lea    0x2(%eax),%edx
    d89f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d8a2:	01 d0                	add    %edx,%eax
    d8a4:	0f b6 00             	movzbl (%eax),%eax
    d8a7:	88 45 ed             	mov    %al,-0x13(%ebp)
    d8aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8ad:	8d 50 03             	lea    0x3(%eax),%edx
    d8b0:	8b 45 0c             	mov    0xc(%ebp),%eax
    d8b3:	01 d0                	add    %edx,%eax
    d8b5:	0f b6 00             	movzbl (%eax),%eax
    d8b8:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    d8bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d8be:	8b 45 08             	mov    0x8(%ebp),%eax
    d8c1:	01 d0                	add    %edx,%eax
    d8c3:	0f b6 00             	movzbl (%eax),%eax
    d8c6:	88 45 eb             	mov    %al,-0x15(%ebp)
    d8c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d8cc:	8d 50 01             	lea    0x1(%eax),%edx
    d8cf:	8b 45 08             	mov    0x8(%ebp),%eax
    d8d2:	01 d0                	add    %edx,%eax
    d8d4:	0f b6 00             	movzbl (%eax),%eax
    d8d7:	88 45 ea             	mov    %al,-0x16(%ebp)
    d8da:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d8dd:	8d 50 02             	lea    0x2(%eax),%edx
    d8e0:	8b 45 08             	mov    0x8(%ebp),%eax
    d8e3:	01 d0                	add    %edx,%eax
    d8e5:	0f b6 00             	movzbl (%eax),%eax
    d8e8:	88 45 e9             	mov    %al,-0x17(%ebp)
    d8eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d8ee:	8d 50 03             	lea    0x3(%eax),%edx
    d8f1:	8b 45 08             	mov    0x8(%ebp),%eax
    d8f4:	01 d0                	add    %edx,%eax
    d8f6:	0f b6 00             	movzbl (%eax),%eax
    d8f9:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    d8fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d8ff:	8b 45 10             	mov    0x10(%ebp),%eax
    d902:	01 d0                	add    %edx,%eax
    d904:	0f b6 00             	movzbl (%eax),%eax
    d907:	88 45 e7             	mov    %al,-0x19(%ebp)
    d90a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d90d:	8d 50 01             	lea    0x1(%eax),%edx
    d910:	8b 45 10             	mov    0x10(%ebp),%eax
    d913:	01 d0                	add    %edx,%eax
    d915:	0f b6 00             	movzbl (%eax),%eax
    d918:	88 45 e6             	mov    %al,-0x1a(%ebp)
    d91b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d91e:	8d 50 02             	lea    0x2(%eax),%edx
    d921:	8b 45 10             	mov    0x10(%ebp),%eax
    d924:	01 d0                	add    %edx,%eax
    d926:	0f b6 00             	movzbl (%eax),%eax
    d929:	88 45 e5             	mov    %al,-0x1b(%ebp)
    d92c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d92f:	8d 50 03             	lea    0x3(%eax),%edx
    d932:	8b 45 10             	mov    0x10(%ebp),%eax
    d935:	01 d0                	add    %edx,%eax
    d937:	0f b6 00             	movzbl (%eax),%eax
    d93a:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    d93d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d940:	8b 45 10             	mov    0x10(%ebp),%eax
    d943:	01 d0                	add    %edx,%eax
    d945:	0f b6 00             	movzbl (%eax),%eax
    d948:	88 45 e3             	mov    %al,-0x1d(%ebp)
    d94b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d94e:	8d 50 01             	lea    0x1(%eax),%edx
    d951:	8b 45 10             	mov    0x10(%ebp),%eax
    d954:	01 d0                	add    %edx,%eax
    d956:	0f b6 00             	movzbl (%eax),%eax
    d959:	88 45 e2             	mov    %al,-0x1e(%ebp)
    d95c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d95f:	8d 50 02             	lea    0x2(%eax),%edx
    d962:	8b 45 10             	mov    0x10(%ebp),%eax
    d965:	01 d0                	add    %edx,%eax
    d967:	0f b6 00             	movzbl (%eax),%eax
    d96a:	88 45 e1             	mov    %al,-0x1f(%ebp)
    d96d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d970:	8d 50 03             	lea    0x3(%eax),%edx
    d973:	8b 45 10             	mov    0x10(%ebp),%eax
    d976:	01 d0                	add    %edx,%eax
    d978:	0f b6 00             	movzbl (%eax),%eax
    d97b:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    d97e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d981:	8b 45 08             	mov    0x8(%ebp),%eax
    d984:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d987:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    d98b:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    d98f:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    d993:	51                   	push   %ecx
    d994:	52                   	push   %edx
    d995:	50                   	push   %eax
    d996:	e8 3f f6 ff ff       	call   cfda <paethPredictor>
    d99b:	83 c4 0c             	add    $0xc,%esp
    d99e:	89 c2                	mov    %eax,%edx
    d9a0:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    d9a4:	01 d0                	add    %edx,%eax
    d9a6:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    d9a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9ab:	8d 50 01             	lea    0x1(%eax),%edx
    d9ae:	8b 45 08             	mov    0x8(%ebp),%eax
    d9b1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d9b4:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    d9b8:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    d9bc:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    d9c0:	51                   	push   %ecx
    d9c1:	52                   	push   %edx
    d9c2:	50                   	push   %eax
    d9c3:	e8 12 f6 ff ff       	call   cfda <paethPredictor>
    d9c8:	83 c4 0c             	add    $0xc,%esp
    d9cb:	89 c2                	mov    %eax,%edx
    d9cd:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    d9d1:	01 d0                	add    %edx,%eax
    d9d3:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    d9d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9d8:	8d 50 02             	lea    0x2(%eax),%edx
    d9db:	8b 45 08             	mov    0x8(%ebp),%eax
    d9de:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d9e1:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    d9e5:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    d9e9:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    d9ed:	51                   	push   %ecx
    d9ee:	52                   	push   %edx
    d9ef:	50                   	push   %eax
    d9f0:	e8 e5 f5 ff ff       	call   cfda <paethPredictor>
    d9f5:	83 c4 0c             	add    $0xc,%esp
    d9f8:	89 c2                	mov    %eax,%edx
    d9fa:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    d9fe:	01 d0                	add    %edx,%eax
    da00:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    da02:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da05:	8d 50 03             	lea    0x3(%eax),%edx
    da08:	8b 45 08             	mov    0x8(%ebp),%eax
    da0b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    da0e:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    da12:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    da16:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    da1a:	51                   	push   %ecx
    da1b:	52                   	push   %edx
    da1c:	50                   	push   %eax
    da1d:	e8 b8 f5 ff ff       	call   cfda <paethPredictor>
    da22:	83 c4 0c             	add    $0xc,%esp
    da25:	89 c2                	mov    %eax,%edx
    da27:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    da2b:	01 d0                	add    %edx,%eax
    da2d:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    da2f:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    da33:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da36:	83 c0 03             	add    $0x3,%eax
    da39:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    da3c:	0f 8c 2f fe ff ff    	jl     d871 <unfilterScanline+0x282>
    da42:	e9 d3 02 00 00       	jmp    dd1a <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    da47:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    da4b:	0f 8e 6a 01 00 00    	jle    dbbb <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    da51:	e9 51 01 00 00       	jmp    dba7 <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    da56:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da59:	2b 45 14             	sub    0x14(%ebp),%eax
    da5c:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    da5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da62:	8b 45 0c             	mov    0xc(%ebp),%eax
    da65:	01 d0                	add    %edx,%eax
    da67:	0f b6 00             	movzbl (%eax),%eax
    da6a:	88 45 db             	mov    %al,-0x25(%ebp)
    da6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da70:	8d 50 01             	lea    0x1(%eax),%edx
    da73:	8b 45 0c             	mov    0xc(%ebp),%eax
    da76:	01 d0                	add    %edx,%eax
    da78:	0f b6 00             	movzbl (%eax),%eax
    da7b:	88 45 da             	mov    %al,-0x26(%ebp)
    da7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da81:	8d 50 02             	lea    0x2(%eax),%edx
    da84:	8b 45 0c             	mov    0xc(%ebp),%eax
    da87:	01 d0                	add    %edx,%eax
    da89:	0f b6 00             	movzbl (%eax),%eax
    da8c:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    da8f:	8b 55 dc             	mov    -0x24(%ebp),%edx
    da92:	8b 45 08             	mov    0x8(%ebp),%eax
    da95:	01 d0                	add    %edx,%eax
    da97:	0f b6 00             	movzbl (%eax),%eax
    da9a:	88 45 d8             	mov    %al,-0x28(%ebp)
    da9d:	8b 45 dc             	mov    -0x24(%ebp),%eax
    daa0:	8d 50 01             	lea    0x1(%eax),%edx
    daa3:	8b 45 08             	mov    0x8(%ebp),%eax
    daa6:	01 d0                	add    %edx,%eax
    daa8:	0f b6 00             	movzbl (%eax),%eax
    daab:	88 45 d7             	mov    %al,-0x29(%ebp)
    daae:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dab1:	8d 50 02             	lea    0x2(%eax),%edx
    dab4:	8b 45 08             	mov    0x8(%ebp),%eax
    dab7:	01 d0                	add    %edx,%eax
    dab9:	0f b6 00             	movzbl (%eax),%eax
    dabc:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    dabf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dac2:	8b 45 10             	mov    0x10(%ebp),%eax
    dac5:	01 d0                	add    %edx,%eax
    dac7:	0f b6 00             	movzbl (%eax),%eax
    daca:	88 45 d5             	mov    %al,-0x2b(%ebp)
    dacd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dad0:	8d 50 01             	lea    0x1(%eax),%edx
    dad3:	8b 45 10             	mov    0x10(%ebp),%eax
    dad6:	01 d0                	add    %edx,%eax
    dad8:	0f b6 00             	movzbl (%eax),%eax
    dadb:	88 45 d4             	mov    %al,-0x2c(%ebp)
    dade:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dae1:	8d 50 02             	lea    0x2(%eax),%edx
    dae4:	8b 45 10             	mov    0x10(%ebp),%eax
    dae7:	01 d0                	add    %edx,%eax
    dae9:	0f b6 00             	movzbl (%eax),%eax
    daec:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    daef:	8b 55 dc             	mov    -0x24(%ebp),%edx
    daf2:	8b 45 10             	mov    0x10(%ebp),%eax
    daf5:	01 d0                	add    %edx,%eax
    daf7:	0f b6 00             	movzbl (%eax),%eax
    dafa:	88 45 d2             	mov    %al,-0x2e(%ebp)
    dafd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db00:	8d 50 01             	lea    0x1(%eax),%edx
    db03:	8b 45 10             	mov    0x10(%ebp),%eax
    db06:	01 d0                	add    %edx,%eax
    db08:	0f b6 00             	movzbl (%eax),%eax
    db0b:	88 45 d1             	mov    %al,-0x2f(%ebp)
    db0e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db11:	8d 50 02             	lea    0x2(%eax),%edx
    db14:	8b 45 10             	mov    0x10(%ebp),%eax
    db17:	01 d0                	add    %edx,%eax
    db19:	0f b6 00             	movzbl (%eax),%eax
    db1c:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    db1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    db22:	8b 45 08             	mov    0x8(%ebp),%eax
    db25:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db28:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    db2c:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    db30:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    db34:	51                   	push   %ecx
    db35:	52                   	push   %edx
    db36:	50                   	push   %eax
    db37:	e8 9e f4 ff ff       	call   cfda <paethPredictor>
    db3c:	83 c4 0c             	add    $0xc,%esp
    db3f:	89 c2                	mov    %eax,%edx
    db41:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    db45:	01 d0                	add    %edx,%eax
    db47:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    db49:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db4c:	8d 50 01             	lea    0x1(%eax),%edx
    db4f:	8b 45 08             	mov    0x8(%ebp),%eax
    db52:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db55:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    db59:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    db5d:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    db61:	51                   	push   %ecx
    db62:	52                   	push   %edx
    db63:	50                   	push   %eax
    db64:	e8 71 f4 ff ff       	call   cfda <paethPredictor>
    db69:	83 c4 0c             	add    $0xc,%esp
    db6c:	89 c2                	mov    %eax,%edx
    db6e:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    db72:	01 d0                	add    %edx,%eax
    db74:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    db76:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db79:	8d 50 02             	lea    0x2(%eax),%edx
    db7c:	8b 45 08             	mov    0x8(%ebp),%eax
    db7f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db82:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    db86:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    db8a:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    db8e:	51                   	push   %ecx
    db8f:	52                   	push   %edx
    db90:	50                   	push   %eax
    db91:	e8 44 f4 ff ff       	call   cfda <paethPredictor>
    db96:	83 c4 0c             	add    $0xc,%esp
    db99:	89 c2                	mov    %eax,%edx
    db9b:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    db9f:	01 d0                	add    %edx,%eax
    dba1:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    dba3:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    dba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbaa:	83 c0 02             	add    $0x2,%eax
    dbad:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dbb0:	0f 8c a0 fe ff ff    	jl     da56 <unfilterScanline+0x467>
    dbb6:	e9 5f 01 00 00       	jmp    dd1a <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    dbbb:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    dbbf:	0f 8e 55 01 00 00    	jle    dd1a <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    dbc5:	e9 e0 00 00 00       	jmp    dcaa <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    dbca:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbcd:	2b 45 14             	sub    0x14(%ebp),%eax
    dbd0:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    dbd3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dbd6:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbd9:	01 d0                	add    %edx,%eax
    dbdb:	0f b6 00             	movzbl (%eax),%eax
    dbde:	88 45 cb             	mov    %al,-0x35(%ebp)
    dbe1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbe4:	8d 50 01             	lea    0x1(%eax),%edx
    dbe7:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbea:	01 d0                	add    %edx,%eax
    dbec:	0f b6 00             	movzbl (%eax),%eax
    dbef:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    dbf2:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dbf5:	8b 45 08             	mov    0x8(%ebp),%eax
    dbf8:	01 d0                	add    %edx,%eax
    dbfa:	0f b6 00             	movzbl (%eax),%eax
    dbfd:	88 45 c9             	mov    %al,-0x37(%ebp)
    dc00:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dc03:	8d 50 01             	lea    0x1(%eax),%edx
    dc06:	8b 45 08             	mov    0x8(%ebp),%eax
    dc09:	01 d0                	add    %edx,%eax
    dc0b:	0f b6 00             	movzbl (%eax),%eax
    dc0e:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    dc11:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc14:	8b 45 10             	mov    0x10(%ebp),%eax
    dc17:	01 d0                	add    %edx,%eax
    dc19:	0f b6 00             	movzbl (%eax),%eax
    dc1c:	88 45 c7             	mov    %al,-0x39(%ebp)
    dc1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc22:	8d 50 01             	lea    0x1(%eax),%edx
    dc25:	8b 45 10             	mov    0x10(%ebp),%eax
    dc28:	01 d0                	add    %edx,%eax
    dc2a:	0f b6 00             	movzbl (%eax),%eax
    dc2d:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    dc30:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dc33:	8b 45 10             	mov    0x10(%ebp),%eax
    dc36:	01 d0                	add    %edx,%eax
    dc38:	0f b6 00             	movzbl (%eax),%eax
    dc3b:	88 45 c5             	mov    %al,-0x3b(%ebp)
    dc3e:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dc41:	8d 50 01             	lea    0x1(%eax),%edx
    dc44:	8b 45 10             	mov    0x10(%ebp),%eax
    dc47:	01 d0                	add    %edx,%eax
    dc49:	0f b6 00             	movzbl (%eax),%eax
    dc4c:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dc4f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc52:	8b 45 08             	mov    0x8(%ebp),%eax
    dc55:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc58:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    dc5c:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    dc60:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    dc64:	51                   	push   %ecx
    dc65:	52                   	push   %edx
    dc66:	50                   	push   %eax
    dc67:	e8 6e f3 ff ff       	call   cfda <paethPredictor>
    dc6c:	83 c4 0c             	add    $0xc,%esp
    dc6f:	89 c2                	mov    %eax,%edx
    dc71:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    dc75:	01 d0                	add    %edx,%eax
    dc77:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dc79:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc7c:	8d 50 01             	lea    0x1(%eax),%edx
    dc7f:	8b 45 08             	mov    0x8(%ebp),%eax
    dc82:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc85:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    dc89:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    dc8d:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    dc91:	51                   	push   %ecx
    dc92:	52                   	push   %edx
    dc93:	50                   	push   %eax
    dc94:	e8 41 f3 ff ff       	call   cfda <paethPredictor>
    dc99:	83 c4 0c             	add    $0xc,%esp
    dc9c:	89 c2                	mov    %eax,%edx
    dc9e:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    dca2:	01 d0                	add    %edx,%eax
    dca4:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    dca6:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    dcaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcad:	83 c0 01             	add    $0x1,%eax
    dcb0:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dcb3:	0f 8c 11 ff ff ff    	jl     dbca <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dcb9:	eb 5f                	jmp    dd1a <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    dcbb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcbe:	8b 45 08             	mov    0x8(%ebp),%eax
    dcc1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dcc4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcc7:	8b 45 0c             	mov    0xc(%ebp),%eax
    dcca:	01 d0                	add    %edx,%eax
    dccc:	0f b6 00             	movzbl (%eax),%eax
    dccf:	88 45 b7             	mov    %al,-0x49(%ebp)
    dcd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcd5:	2b 45 14             	sub    0x14(%ebp),%eax
    dcd8:	89 c2                	mov    %eax,%edx
    dcda:	8b 45 10             	mov    0x10(%ebp),%eax
    dcdd:	01 d0                	add    %edx,%eax
    dcdf:	0f b6 00             	movzbl (%eax),%eax
    dce2:	0f b6 c8             	movzbl %al,%ecx
    dce5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dce8:	8b 45 10             	mov    0x10(%ebp),%eax
    dceb:	01 d0                	add    %edx,%eax
    dced:	0f b6 00             	movzbl (%eax),%eax
    dcf0:	0f b6 d0             	movzbl %al,%edx
    dcf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcf6:	2b 45 14             	sub    0x14(%ebp),%eax
    dcf9:	89 c6                	mov    %eax,%esi
    dcfb:	8b 45 08             	mov    0x8(%ebp),%eax
    dcfe:	01 f0                	add    %esi,%eax
    dd00:	0f b6 00             	movzbl (%eax),%eax
    dd03:	0f b6 c0             	movzbl %al,%eax
    dd06:	51                   	push   %ecx
    dd07:	52                   	push   %edx
    dd08:	50                   	push   %eax
    dd09:	e8 cc f2 ff ff       	call   cfda <paethPredictor>
    dd0e:	83 c4 0c             	add    $0xc,%esp
    dd11:	02 45 b7             	add    -0x49(%ebp),%al
    dd14:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dd16:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd1d:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd20:	75 99                	jne    dcbb <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    dd22:	eb 6e                	jmp    dd92 <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    dd24:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dd2b:	eb 19                	jmp    dd46 <unfilterScanline+0x757>
          recon[i] = scanline[i];
    dd2d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd30:	8b 45 08             	mov    0x8(%ebp),%eax
    dd33:	01 c2                	add    %eax,%edx
    dd35:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dd38:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd3b:	01 c8                	add    %ecx,%eax
    dd3d:	0f b6 00             	movzbl (%eax),%eax
    dd40:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    dd42:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd46:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd49:	3b 45 14             	cmp    0x14(%ebp),%eax
    dd4c:	75 df                	jne    dd2d <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    dd4e:	8b 45 14             	mov    0x14(%ebp),%eax
    dd51:	89 45 f4             	mov    %eax,-0xc(%ebp)
    dd54:	eb 2b                	jmp    dd81 <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    dd56:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd59:	8b 45 08             	mov    0x8(%ebp),%eax
    dd5c:	01 c2                	add    %eax,%edx
    dd5e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dd61:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd64:	01 c8                	add    %ecx,%eax
    dd66:	0f b6 08             	movzbl (%eax),%ecx
    dd69:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd6c:	2b 45 14             	sub    0x14(%ebp),%eax
    dd6f:	89 c3                	mov    %eax,%ebx
    dd71:	8b 45 08             	mov    0x8(%ebp),%eax
    dd74:	01 d8                	add    %ebx,%eax
    dd76:	0f b6 00             	movzbl (%eax),%eax
    dd79:	01 c8                	add    %ecx,%eax
    dd7b:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    dd7d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd81:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd84:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd87:	7c cd                	jl     dd56 <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    dd89:	eb 07                	jmp    dd92 <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    dd8b:	b8 24 00 00 00       	mov    $0x24,%eax
    dd90:	eb 05                	jmp    dd97 <unfilterScanline+0x7a8>
  }
  return 0;
    dd92:	b8 00 00 00 00       	mov    $0x0,%eax
}
    dd97:	8d 65 f8             	lea    -0x8(%ebp),%esp
    dd9a:	5b                   	pop    %ebx
    dd9b:	5e                   	pop    %esi
    dd9c:	5d                   	pop    %ebp
    dd9d:	c3                   	ret    

0000dd9e <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    dd9e:	55                   	push   %ebp
    dd9f:	89 e5                	mov    %esp,%ebp
    dda1:	53                   	push   %ebx
    dda2:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    dda5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    ddac:	8b 45 18             	mov    0x18(%ebp),%eax
    ddaf:	83 c0 07             	add    $0x7,%eax
    ddb2:	c1 e8 03             	shr    $0x3,%eax
    ddb5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    ddb8:	ff 75 18             	pushl  0x18(%ebp)
    ddbb:	6a 01                	push   $0x1
    ddbd:	ff 75 10             	pushl  0x10(%ebp)
    ddc0:	e8 d9 b1 ff ff       	call   8f9e <lodepng_get_raw_size_idat>
    ddc5:	83 c4 0c             	add    $0xc,%esp
    ddc8:	83 e8 01             	sub    $0x1,%eax
    ddcb:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    ddce:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ddd5:	eb 6d                	jmp    de44 <unfilter+0xa6>
    size_t outindex = linebytes * y;
    ddd7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ddda:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    ddde:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    dde1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dde4:	83 c0 01             	add    $0x1,%eax
    dde7:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    ddeb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    ddee:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ddf1:	8b 45 0c             	mov    0xc(%ebp),%eax
    ddf4:	01 d0                	add    %edx,%eax
    ddf6:	0f b6 00             	movzbl (%eax),%eax
    ddf9:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    ddfc:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    de00:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    de03:	8d 4a 01             	lea    0x1(%edx),%ecx
    de06:	8b 55 0c             	mov    0xc(%ebp),%edx
    de09:	01 d1                	add    %edx,%ecx
    de0b:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    de0e:	8b 55 08             	mov    0x8(%ebp),%edx
    de11:	01 da                	add    %ebx,%edx
    de13:	ff 75 ec             	pushl  -0x14(%ebp)
    de16:	50                   	push   %eax
    de17:	ff 75 f0             	pushl  -0x10(%ebp)
    de1a:	ff 75 f4             	pushl  -0xc(%ebp)
    de1d:	51                   	push   %ecx
    de1e:	52                   	push   %edx
    de1f:	e8 cb f7 ff ff       	call   d5ef <unfilterScanline>
    de24:	83 c4 18             	add    $0x18,%esp
    de27:	89 45 dc             	mov    %eax,-0x24(%ebp)
    de2a:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    de2e:	74 05                	je     de35 <unfilter+0x97>
    de30:	8b 45 dc             	mov    -0x24(%ebp),%eax
    de33:	eb 1c                	jmp    de51 <unfilter+0xb3>

    prevline = &out[outindex];
    de35:	8b 55 e8             	mov    -0x18(%ebp),%edx
    de38:	8b 45 08             	mov    0x8(%ebp),%eax
    de3b:	01 d0                	add    %edx,%eax
    de3d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    de40:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    de44:	8b 45 f8             	mov    -0x8(%ebp),%eax
    de47:	3b 45 14             	cmp    0x14(%ebp),%eax
    de4a:	72 8b                	jb     ddd7 <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    de4c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    de51:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    de54:	c9                   	leave  
    de55:	c3                   	ret    

0000de56 <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    de56:	55                   	push   %ebp
    de57:	89 e5                	mov    %esp,%ebp
    de59:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    de5f:	ff 75 18             	pushl  0x18(%ebp)
    de62:	ff 75 14             	pushl  0x14(%ebp)
    de65:	ff 75 10             	pushl  0x10(%ebp)
    de68:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    de6e:	50                   	push   %eax
    de6f:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    de75:	50                   	push   %eax
    de76:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    de7c:	50                   	push   %eax
    de7d:	8d 45 94             	lea    -0x6c(%ebp),%eax
    de80:	50                   	push   %eax
    de81:	8d 45 b0             	lea    -0x50(%ebp),%eax
    de84:	50                   	push   %eax
    de85:	e8 e6 f1 ff ff       	call   d070 <Adam7_getpassvalues>
    de8a:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    de8d:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    de91:	0f 86 0a 01 00 00    	jbe    dfa1 <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    de97:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    de9e:	e9 ef 00 00 00       	jmp    df92 <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    dea3:	8b 45 18             	mov    0x18(%ebp),%eax
    dea6:	c1 e8 03             	shr    $0x3,%eax
    dea9:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    deac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    deb3:	e9 c6 00 00 00       	jmp    df7e <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    deb8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    debf:	e9 a6 00 00 00       	jmp    df6a <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    dec4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dec7:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    dece:	89 c1                	mov    %eax,%ecx
    ded0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ded3:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    ded7:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    dedb:	89 c2                	mov    %eax,%edx
    dedd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    dee0:	01 c2                	add    %eax,%edx
    dee2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    dee5:	0f af c2             	imul   %edx,%eax
    dee8:	01 c8                	add    %ecx,%eax
    deea:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    deed:	8b 45 fc             	mov    -0x4(%ebp),%eax
    def0:	8b 14 85 d8 9f 01 00 	mov    0x19fd8(,%eax,4),%edx
    def7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    defa:	8b 04 85 10 a0 01 00 	mov    0x1a010(,%eax,4),%eax
    df01:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    df05:	01 d0                	add    %edx,%eax
    df07:	0f af 45 10          	imul   0x10(%ebp),%eax
    df0b:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    df0d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df10:	8b 04 85 f4 9f 01 00 	mov    0x19ff4(,%eax,4),%eax
    df17:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    df1b:	01 c2                	add    %eax,%edx
    df1d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df20:	8b 04 85 bc 9f 01 00 	mov    0x19fbc(,%eax,4),%eax
    df27:	01 c2                	add    %eax,%edx
    df29:	8b 45 e0             	mov    -0x20(%ebp),%eax
    df2c:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    df2f:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    df32:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    df39:	eb 23                	jmp    df5e <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    df3b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    df3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    df41:	01 c2                	add    %eax,%edx
    df43:	8b 45 08             	mov    0x8(%ebp),%eax
    df46:	01 c2                	add    %eax,%edx
    df48:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    df4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    df4e:	01 c1                	add    %eax,%ecx
    df50:	8b 45 0c             	mov    0xc(%ebp),%eax
    df53:	01 c8                	add    %ecx,%eax
    df55:	0f b6 00             	movzbl (%eax),%eax
    df58:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    df5a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    df5e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    df61:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    df64:	72 d5                	jb     df3b <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    df66:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    df6a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df6d:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    df71:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    df74:	0f 87 4a ff ff ff    	ja     dec4 <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    df7a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    df7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df81:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    df85:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    df88:	0f 87 2a ff ff ff    	ja     deb8 <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    df8e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    df92:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    df96:	0f 85 07 ff ff ff    	jne    dea3 <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    df9c:	e9 22 01 00 00       	jmp    e0c3 <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    dfa1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    dfa8:	e9 0c 01 00 00       	jmp    e0b9 <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    dfad:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfb0:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    dfb4:	0f af 45 18          	imul   0x18(%ebp),%eax
    dfb8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    dfbb:	8b 45 18             	mov    0x18(%ebp),%eax
    dfbe:	0f af 45 10          	imul   0x10(%ebp),%eax
    dfc2:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    dfc5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    dfcc:	e9 d4 00 00 00       	jmp    e0a5 <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    dfd1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    dfd8:	e9 b4 00 00 00       	jmp    e091 <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    dfdd:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfe0:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    dfe7:	c1 e0 03             	shl    $0x3,%eax
    dfea:	89 c1                	mov    %eax,%ecx
    dfec:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dfef:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    dff3:	89 c2                	mov    %eax,%edx
    dff5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dff8:	0f af 45 18          	imul   0x18(%ebp),%eax
    dffc:	01 d0                	add    %edx,%eax
    dffe:	01 c8                	add    %ecx,%eax
    e000:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    e006:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e009:	8b 14 85 d8 9f 01 00 	mov    0x19fd8(,%eax,4),%edx
    e010:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e013:	8b 04 85 10 a0 01 00 	mov    0x1a010(,%eax,4),%eax
    e01a:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    e01e:	01 d0                	add    %edx,%eax
    e020:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    e024:	89 c2                	mov    %eax,%edx
    e026:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e029:	8b 0c 85 bc 9f 01 00 	mov    0x19fbc(,%eax,4),%ecx
    e030:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e033:	8b 04 85 f4 9f 01 00 	mov    0x19ff4(,%eax,4),%eax
    e03a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e03e:	01 c8                	add    %ecx,%eax
    e040:	0f af 45 18          	imul   0x18(%ebp),%eax
    e044:	01 d0                	add    %edx,%eax
    e046:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    e04c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e053:	eb 30                	jmp    e085 <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    e055:	ff 75 0c             	pushl  0xc(%ebp)
    e058:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    e05e:	50                   	push   %eax
    e05f:	e8 1e a1 ff ff       	call   8182 <readBitFromReversedStream>
    e064:	83 c4 08             	add    $0x8,%esp
    e067:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    e06a:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    e06e:	50                   	push   %eax
    e06f:	ff 75 08             	pushl  0x8(%ebp)
    e072:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    e078:	50                   	push   %eax
    e079:	e8 86 a1 ff ff       	call   8204 <setBitOfReversedStream>
    e07e:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    e081:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    e085:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e088:	3b 45 18             	cmp    0x18(%ebp),%eax
    e08b:	72 c8                	jb     e055 <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e08d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    e091:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e094:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e098:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e09b:	0f 87 3c ff ff ff    	ja     dfdd <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e0a1:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e0a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0a8:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e0ac:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e0af:	0f 87 1c ff ff ff    	ja     dfd1 <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e0b5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e0b9:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e0bd:	0f 85 ea fe ff ff    	jne    dfad <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e0c3:	90                   	nop
    e0c4:	c9                   	leave  
    e0c5:	c3                   	ret    

0000e0c6 <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    e0c6:	55                   	push   %ebp
    e0c7:	89 e5                	mov    %esp,%ebp
    e0c9:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    e0cc:	8b 45 14             	mov    0x14(%ebp),%eax
    e0cf:	2b 45 10             	sub    0x10(%ebp),%eax
    e0d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    e0d5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e0dc:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    e0e3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e0ea:	eb 4a                	jmp    e136 <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e0ec:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e0f3:	eb 2a                	jmp    e11f <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    e0f5:	ff 75 0c             	pushl  0xc(%ebp)
    e0f8:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e0fb:	50                   	push   %eax
    e0fc:	e8 81 a0 ff ff       	call   8182 <readBitFromReversedStream>
    e101:	83 c4 08             	add    $0x8,%esp
    e104:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    e107:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e10b:	50                   	push   %eax
    e10c:	ff 75 08             	pushl  0x8(%ebp)
    e10f:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e112:	50                   	push   %eax
    e113:	e8 ec a0 ff ff       	call   8204 <setBitOfReversedStream>
    e118:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e11b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e11f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e122:	3b 45 10             	cmp    0x10(%ebp),%eax
    e125:	7c ce                	jl     e0f5 <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    e127:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e12a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e12d:	01 d0                	add    %edx,%eax
    e12f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    e132:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e136:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e139:	3b 45 18             	cmp    0x18(%ebp),%eax
    e13c:	72 ae                	jb     e0ec <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    e13e:	90                   	nop
    e13f:	c9                   	leave  
    e140:	c3                   	ret    

0000e141 <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    e141:	55                   	push   %ebp
    e142:	89 e5                	mov    %esp,%ebp
    e144:	57                   	push   %edi
    e145:	56                   	push   %esi
    e146:	53                   	push   %ebx
    e147:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    e14d:	8b 45 18             	mov    0x18(%ebp),%eax
    e150:	83 c0 0c             	add    $0xc,%eax
    e153:	50                   	push   %eax
    e154:	e8 e6 ac ff ff       	call   8e3f <lodepng_get_bpp>
    e159:	83 c4 04             	add    $0x4,%esp
    e15c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    e15f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e163:	75 0a                	jne    e16f <postProcessScanlines+0x2e>
    e165:	b8 1f 00 00 00       	mov    $0x1f,%eax
    e16a:	e9 c3 01 00 00       	jmp    e332 <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    e16f:	8b 45 18             	mov    0x18(%ebp),%eax
    e172:	8b 40 08             	mov    0x8(%eax),%eax
    e175:	85 c0                	test   %eax,%eax
    e177:	0f 85 a8 00 00 00    	jne    e225 <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    e17d:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e181:	77 76                	ja     e1f9 <postProcessScanlines+0xb8>
    e183:	8b 45 10             	mov    0x10(%ebp),%eax
    e186:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e18a:	89 c2                	mov    %eax,%edx
    e18c:	8b 45 10             	mov    0x10(%ebp),%eax
    e18f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e193:	83 c0 07             	add    $0x7,%eax
    e196:	c1 e8 03             	shr    $0x3,%eax
    e199:	c1 e0 03             	shl    $0x3,%eax
    e19c:	39 c2                	cmp    %eax,%edx
    e19e:	74 59                	je     e1f9 <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    e1a0:	ff 75 ec             	pushl  -0x14(%ebp)
    e1a3:	ff 75 14             	pushl  0x14(%ebp)
    e1a6:	ff 75 10             	pushl  0x10(%ebp)
    e1a9:	ff 75 0c             	pushl  0xc(%ebp)
    e1ac:	ff 75 0c             	pushl  0xc(%ebp)
    e1af:	e8 ea fb ff ff       	call   dd9e <unfilter>
    e1b4:	83 c4 14             	add    $0x14,%esp
    e1b7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    e1ba:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e1be:	74 08                	je     e1c8 <postProcessScanlines+0x87>
    e1c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e1c3:	e9 6a 01 00 00       	jmp    e332 <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    e1c8:	8b 45 10             	mov    0x10(%ebp),%eax
    e1cb:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e1cf:	83 c0 07             	add    $0x7,%eax
    e1d2:	c1 e8 03             	shr    $0x3,%eax
    e1d5:	c1 e0 03             	shl    $0x3,%eax
    e1d8:	89 c2                	mov    %eax,%edx
    e1da:	8b 45 10             	mov    0x10(%ebp),%eax
    e1dd:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e1e1:	ff 75 14             	pushl  0x14(%ebp)
    e1e4:	52                   	push   %edx
    e1e5:	50                   	push   %eax
    e1e6:	ff 75 0c             	pushl  0xc(%ebp)
    e1e9:	ff 75 08             	pushl  0x8(%ebp)
    e1ec:	e8 d5 fe ff ff       	call   e0c6 <removePaddingBits>
    e1f1:	83 c4 14             	add    $0x14,%esp
    e1f4:	e9 34 01 00 00       	jmp    e32d <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    e1f9:	ff 75 ec             	pushl  -0x14(%ebp)
    e1fc:	ff 75 14             	pushl  0x14(%ebp)
    e1ff:	ff 75 10             	pushl  0x10(%ebp)
    e202:	ff 75 0c             	pushl  0xc(%ebp)
    e205:	ff 75 08             	pushl  0x8(%ebp)
    e208:	e8 91 fb ff ff       	call   dd9e <unfilter>
    e20d:	83 c4 14             	add    $0x14,%esp
    e210:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e213:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e217:	0f 84 10 01 00 00    	je     e32d <postProcessScanlines+0x1ec>
    e21d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e220:	e9 0d 01 00 00       	jmp    e332 <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e225:	ff 75 ec             	pushl  -0x14(%ebp)
    e228:	ff 75 14             	pushl  0x14(%ebp)
    e22b:	ff 75 10             	pushl  0x10(%ebp)
    e22e:	8d 45 88             	lea    -0x78(%ebp),%eax
    e231:	50                   	push   %eax
    e232:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    e238:	50                   	push   %eax
    e239:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e23f:	50                   	push   %eax
    e240:	8d 45 a8             	lea    -0x58(%ebp),%eax
    e243:	50                   	push   %eax
    e244:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e247:	50                   	push   %eax
    e248:	e8 23 ee ff ff       	call   d070 <Adam7_getpassvalues>
    e24d:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    e250:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e257:	e9 b0 00 00 00       	jmp    e30c <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    e25c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e25f:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    e263:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e266:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    e26a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e26d:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    e274:	89 cb                	mov    %ecx,%ebx
    e276:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e279:	01 cb                	add    %ecx,%ebx
    e27b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e27e:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    e285:	89 ce                	mov    %ecx,%esi
    e287:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e28a:	01 f1                	add    %esi,%ecx
    e28c:	ff 75 ec             	pushl  -0x14(%ebp)
    e28f:	52                   	push   %edx
    e290:	50                   	push   %eax
    e291:	53                   	push   %ebx
    e292:	51                   	push   %ecx
    e293:	e8 06 fb ff ff       	call   dd9e <unfilter>
    e298:	83 c4 14             	add    $0x14,%esp
    e29b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e29e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e2a2:	74 08                	je     e2ac <postProcessScanlines+0x16b>
    e2a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e2a7:	e9 86 00 00 00       	jmp    e332 <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    e2ac:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e2b0:	77 56                	ja     e308 <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e2b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e2b5:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    e2b9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2bc:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e2c0:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e2c4:	83 c2 07             	add    $0x7,%edx
    e2c7:	c1 ea 03             	shr    $0x3,%edx
    e2ca:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e2cd:	89 d6                	mov    %edx,%esi
    e2cf:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2d2:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e2d6:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e2da:	89 d3                	mov    %edx,%ebx
    e2dc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2df:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    e2e6:	89 d1                	mov    %edx,%ecx
    e2e8:	8b 55 0c             	mov    0xc(%ebp),%edx
    e2eb:	01 d1                	add    %edx,%ecx
    e2ed:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2f0:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    e2f4:	89 d7                	mov    %edx,%edi
    e2f6:	8b 55 0c             	mov    0xc(%ebp),%edx
    e2f9:	01 fa                	add    %edi,%edx
    e2fb:	50                   	push   %eax
    e2fc:	56                   	push   %esi
    e2fd:	53                   	push   %ebx
    e2fe:	51                   	push   %ecx
    e2ff:	52                   	push   %edx
    e300:	e8 c1 fd ff ff       	call   e0c6 <removePaddingBits>
    e305:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    e308:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e30c:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    e310:	0f 85 46 ff ff ff    	jne    e25c <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    e316:	ff 75 ec             	pushl  -0x14(%ebp)
    e319:	ff 75 14             	pushl  0x14(%ebp)
    e31c:	ff 75 10             	pushl  0x10(%ebp)
    e31f:	ff 75 0c             	pushl  0xc(%ebp)
    e322:	ff 75 08             	pushl  0x8(%ebp)
    e325:	e8 2c fb ff ff       	call   de56 <Adam7_deinterlace>
    e32a:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    e32d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e332:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e335:	5b                   	pop    %ebx
    e336:	5e                   	pop    %esi
    e337:	5f                   	pop    %edi
    e338:	5d                   	pop    %ebp
    e339:	c3                   	ret    

0000e33a <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e33a:	55                   	push   %ebp
    e33b:	89 e5                	mov    %esp,%ebp
    e33d:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    e340:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    e347:	8b 45 10             	mov    0x10(%ebp),%eax
    e34a:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    e34f:	f7 e2                	mul    %edx
    e351:	89 d0                	mov    %edx,%eax
    e353:	d1 e8                	shr    %eax
    e355:	89 c2                	mov    %eax,%edx
    e357:	8b 45 08             	mov    0x8(%ebp),%eax
    e35a:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    e35d:	8b 45 08             	mov    0x8(%ebp),%eax
    e360:	8b 40 0c             	mov    0xc(%eax),%eax
    e363:	85 c0                	test   %eax,%eax
    e365:	74 0d                	je     e374 <readChunk_PLTE+0x3a>
    e367:	8b 45 08             	mov    0x8(%ebp),%eax
    e36a:	8b 40 0c             	mov    0xc(%eax),%eax
    e36d:	3d 00 01 00 00       	cmp    $0x100,%eax
    e372:	7e 0a                	jle    e37e <readChunk_PLTE+0x44>
    e374:	b8 26 00 00 00       	mov    $0x26,%eax
    e379:	e9 da 00 00 00       	jmp    e458 <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    e37e:	83 ec 0c             	sub    $0xc,%esp
    e381:	ff 75 08             	pushl  0x8(%ebp)
    e384:	e8 02 a7 ff ff       	call   8a8b <lodepng_color_mode_alloc_palette>
    e389:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    e38c:	8b 45 08             	mov    0x8(%ebp),%eax
    e38f:	8b 40 08             	mov    0x8(%eax),%eax
    e392:	85 c0                	test   %eax,%eax
    e394:	75 1e                	jne    e3b4 <readChunk_PLTE+0x7a>
    e396:	8b 45 08             	mov    0x8(%ebp),%eax
    e399:	8b 40 0c             	mov    0xc(%eax),%eax
    e39c:	85 c0                	test   %eax,%eax
    e39e:	74 14                	je     e3b4 <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    e3a0:	8b 45 08             	mov    0x8(%ebp),%eax
    e3a3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    e3aa:	b8 53 00 00 00       	mov    $0x53,%eax
    e3af:	e9 a4 00 00 00       	jmp    e458 <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    e3b4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e3bb:	e9 84 00 00 00       	jmp    e444 <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    e3c0:	8b 45 08             	mov    0x8(%ebp),%eax
    e3c3:	8b 40 08             	mov    0x8(%eax),%eax
    e3c6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e3c9:	c1 e2 02             	shl    $0x2,%edx
    e3cc:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e3cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3d2:	8d 50 01             	lea    0x1(%eax),%edx
    e3d5:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e3d8:	8b 55 0c             	mov    0xc(%ebp),%edx
    e3db:	01 d0                	add    %edx,%eax
    e3dd:	0f b6 00             	movzbl (%eax),%eax
    e3e0:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    e3e2:	8b 45 08             	mov    0x8(%ebp),%eax
    e3e5:	8b 40 08             	mov    0x8(%eax),%eax
    e3e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e3eb:	c1 e2 02             	shl    $0x2,%edx
    e3ee:	83 c2 01             	add    $0x1,%edx
    e3f1:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e3f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3f7:	8d 50 01             	lea    0x1(%eax),%edx
    e3fa:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e3fd:	8b 55 0c             	mov    0xc(%ebp),%edx
    e400:	01 d0                	add    %edx,%eax
    e402:	0f b6 00             	movzbl (%eax),%eax
    e405:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    e407:	8b 45 08             	mov    0x8(%ebp),%eax
    e40a:	8b 40 08             	mov    0x8(%eax),%eax
    e40d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e410:	c1 e2 02             	shl    $0x2,%edx
    e413:	83 c2 02             	add    $0x2,%edx
    e416:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e419:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e41c:	8d 50 01             	lea    0x1(%eax),%edx
    e41f:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e422:	8b 55 0c             	mov    0xc(%ebp),%edx
    e425:	01 d0                	add    %edx,%eax
    e427:	0f b6 00             	movzbl (%eax),%eax
    e42a:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    e42c:	8b 45 08             	mov    0x8(%ebp),%eax
    e42f:	8b 40 08             	mov    0x8(%eax),%eax
    e432:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e435:	c1 e2 02             	shl    $0x2,%edx
    e438:	83 c2 03             	add    $0x3,%edx
    e43b:	01 d0                	add    %edx,%eax
    e43d:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    e440:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e444:	8b 45 08             	mov    0x8(%ebp),%eax
    e447:	8b 40 0c             	mov    0xc(%eax),%eax
    e44a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e44d:	0f 85 6d ff ff ff    	jne    e3c0 <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    e453:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e458:	c9                   	leave  
    e459:	c3                   	ret    

0000e45a <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e45a:	55                   	push   %ebp
    e45b:	89 e5                	mov    %esp,%ebp
    e45d:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    e460:	8b 45 08             	mov    0x8(%ebp),%eax
    e463:	8b 00                	mov    (%eax),%eax
    e465:	83 f8 03             	cmp    $0x3,%eax
    e468:	75 4d                	jne    e4b7 <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    e46a:	8b 45 08             	mov    0x8(%ebp),%eax
    e46d:	8b 40 0c             	mov    0xc(%eax),%eax
    e470:	3b 45 10             	cmp    0x10(%ebp),%eax
    e473:	7d 0a                	jge    e47f <readChunk_tRNS+0x25>
    e475:	b8 27 00 00 00       	mov    $0x27,%eax
    e47a:	e9 3c 01 00 00       	jmp    e5bb <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    e47f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e486:	eb 22                	jmp    e4aa <readChunk_tRNS+0x50>
    e488:	8b 45 08             	mov    0x8(%ebp),%eax
    e48b:	8b 40 08             	mov    0x8(%eax),%eax
    e48e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e491:	c1 e2 02             	shl    $0x2,%edx
    e494:	83 c2 03             	add    $0x3,%edx
    e497:	01 c2                	add    %eax,%edx
    e499:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e49c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e49f:	01 c8                	add    %ecx,%eax
    e4a1:	0f b6 00             	movzbl (%eax),%eax
    e4a4:	88 02                	mov    %al,(%edx)
    e4a6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e4aa:	8b 45 10             	mov    0x10(%ebp),%eax
    e4ad:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    e4b0:	75 d6                	jne    e488 <readChunk_tRNS+0x2e>
    e4b2:	e9 ff 00 00 00       	jmp    e5b6 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    e4b7:	8b 45 08             	mov    0x8(%ebp),%eax
    e4ba:	8b 00                	mov    (%eax),%eax
    e4bc:	85 c0                	test   %eax,%eax
    e4be:	75 59                	jne    e519 <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    e4c0:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e4c4:	74 0a                	je     e4d0 <readChunk_tRNS+0x76>
    e4c6:	b8 1e 00 00 00       	mov    $0x1e,%eax
    e4cb:	e9 eb 00 00 00       	jmp    e5bb <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e4d0:	8b 45 08             	mov    0x8(%ebp),%eax
    e4d3:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    e4da:	8b 45 0c             	mov    0xc(%ebp),%eax
    e4dd:	0f b6 00             	movzbl (%eax),%eax
    e4e0:	0f b6 c0             	movzbl %al,%eax
    e4e3:	c1 e0 08             	shl    $0x8,%eax
    e4e6:	89 c2                	mov    %eax,%edx
    e4e8:	8b 45 0c             	mov    0xc(%ebp),%eax
    e4eb:	83 c0 01             	add    $0x1,%eax
    e4ee:	0f b6 00             	movzbl (%eax),%eax
    e4f1:	0f b6 c0             	movzbl %al,%eax
    e4f4:	01 c2                	add    %eax,%edx
    e4f6:	8b 45 08             	mov    0x8(%ebp),%eax
    e4f9:	89 50 1c             	mov    %edx,0x1c(%eax)
    e4fc:	8b 45 08             	mov    0x8(%ebp),%eax
    e4ff:	8b 50 1c             	mov    0x1c(%eax),%edx
    e502:	8b 45 08             	mov    0x8(%ebp),%eax
    e505:	89 50 18             	mov    %edx,0x18(%eax)
    e508:	8b 45 08             	mov    0x8(%ebp),%eax
    e50b:	8b 50 18             	mov    0x18(%eax),%edx
    e50e:	8b 45 08             	mov    0x8(%ebp),%eax
    e511:	89 50 14             	mov    %edx,0x14(%eax)
    e514:	e9 9d 00 00 00       	jmp    e5b6 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    e519:	8b 45 08             	mov    0x8(%ebp),%eax
    e51c:	8b 00                	mov    (%eax),%eax
    e51e:	83 f8 02             	cmp    $0x2,%eax
    e521:	0f 85 88 00 00 00    	jne    e5af <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    e527:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e52b:	74 0a                	je     e537 <readChunk_tRNS+0xdd>
    e52d:	b8 29 00 00 00       	mov    $0x29,%eax
    e532:	e9 84 00 00 00       	jmp    e5bb <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e537:	8b 45 08             	mov    0x8(%ebp),%eax
    e53a:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    e541:	8b 45 0c             	mov    0xc(%ebp),%eax
    e544:	0f b6 00             	movzbl (%eax),%eax
    e547:	0f b6 c0             	movzbl %al,%eax
    e54a:	c1 e0 08             	shl    $0x8,%eax
    e54d:	89 c2                	mov    %eax,%edx
    e54f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e552:	83 c0 01             	add    $0x1,%eax
    e555:	0f b6 00             	movzbl (%eax),%eax
    e558:	0f b6 c0             	movzbl %al,%eax
    e55b:	01 c2                	add    %eax,%edx
    e55d:	8b 45 08             	mov    0x8(%ebp),%eax
    e560:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    e563:	8b 45 0c             	mov    0xc(%ebp),%eax
    e566:	83 c0 02             	add    $0x2,%eax
    e569:	0f b6 00             	movzbl (%eax),%eax
    e56c:	0f b6 c0             	movzbl %al,%eax
    e56f:	c1 e0 08             	shl    $0x8,%eax
    e572:	89 c2                	mov    %eax,%edx
    e574:	8b 45 0c             	mov    0xc(%ebp),%eax
    e577:	83 c0 03             	add    $0x3,%eax
    e57a:	0f b6 00             	movzbl (%eax),%eax
    e57d:	0f b6 c0             	movzbl %al,%eax
    e580:	01 c2                	add    %eax,%edx
    e582:	8b 45 08             	mov    0x8(%ebp),%eax
    e585:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    e588:	8b 45 0c             	mov    0xc(%ebp),%eax
    e58b:	83 c0 04             	add    $0x4,%eax
    e58e:	0f b6 00             	movzbl (%eax),%eax
    e591:	0f b6 c0             	movzbl %al,%eax
    e594:	c1 e0 08             	shl    $0x8,%eax
    e597:	89 c2                	mov    %eax,%edx
    e599:	8b 45 0c             	mov    0xc(%ebp),%eax
    e59c:	83 c0 05             	add    $0x5,%eax
    e59f:	0f b6 00             	movzbl (%eax),%eax
    e5a2:	0f b6 c0             	movzbl %al,%eax
    e5a5:	01 c2                	add    %eax,%edx
    e5a7:	8b 45 08             	mov    0x8(%ebp),%eax
    e5aa:	89 50 1c             	mov    %edx,0x1c(%eax)
    e5ad:	eb 07                	jmp    e5b6 <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    e5af:	b8 2a 00 00 00       	mov    $0x2a,%eax
    e5b4:	eb 05                	jmp    e5bb <readChunk_tRNS+0x161>

  return 0; /* OK */
    e5b6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e5bb:	c9                   	leave  
    e5bc:	c3                   	ret    

0000e5bd <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e5bd:	55                   	push   %ebp
    e5be:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    e5c0:	8b 45 08             	mov    0x8(%ebp),%eax
    e5c3:	8b 40 0c             	mov    0xc(%eax),%eax
    e5c6:	83 f8 03             	cmp    $0x3,%eax
    e5c9:	75 63                	jne    e62e <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    e5cb:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    e5cf:	74 0a                	je     e5db <readChunk_bKGD+0x1e>
    e5d1:	b8 2b 00 00 00       	mov    $0x2b,%eax
    e5d6:	e9 63 01 00 00       	jmp    e73e <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    e5db:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5de:	0f b6 00             	movzbl (%eax),%eax
    e5e1:	0f b6 d0             	movzbl %al,%edx
    e5e4:	8b 45 08             	mov    0x8(%ebp),%eax
    e5e7:	8b 40 18             	mov    0x18(%eax),%eax
    e5ea:	39 c2                	cmp    %eax,%edx
    e5ec:	7c 0a                	jl     e5f8 <readChunk_bKGD+0x3b>
    e5ee:	b8 67 00 00 00       	mov    $0x67,%eax
    e5f3:	e9 46 01 00 00       	jmp    e73e <readChunk_bKGD+0x181>

    info->background_defined = 1;
    e5f8:	8b 45 08             	mov    0x8(%ebp),%eax
    e5fb:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    e602:	8b 45 0c             	mov    0xc(%ebp),%eax
    e605:	0f b6 00             	movzbl (%eax),%eax
    e608:	0f b6 d0             	movzbl %al,%edx
    e60b:	8b 45 08             	mov    0x8(%ebp),%eax
    e60e:	89 50 38             	mov    %edx,0x38(%eax)
    e611:	8b 45 08             	mov    0x8(%ebp),%eax
    e614:	8b 50 38             	mov    0x38(%eax),%edx
    e617:	8b 45 08             	mov    0x8(%ebp),%eax
    e61a:	89 50 34             	mov    %edx,0x34(%eax)
    e61d:	8b 45 08             	mov    0x8(%ebp),%eax
    e620:	8b 50 34             	mov    0x34(%eax),%edx
    e623:	8b 45 08             	mov    0x8(%ebp),%eax
    e626:	89 50 30             	mov    %edx,0x30(%eax)
    e629:	e9 0b 01 00 00       	jmp    e739 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    e62e:	8b 45 08             	mov    0x8(%ebp),%eax
    e631:	8b 40 0c             	mov    0xc(%eax),%eax
    e634:	85 c0                	test   %eax,%eax
    e636:	74 0b                	je     e643 <readChunk_bKGD+0x86>
    e638:	8b 45 08             	mov    0x8(%ebp),%eax
    e63b:	8b 40 0c             	mov    0xc(%eax),%eax
    e63e:	83 f8 04             	cmp    $0x4,%eax
    e641:	75 59                	jne    e69c <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    e643:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e647:	74 0a                	je     e653 <readChunk_bKGD+0x96>
    e649:	b8 2c 00 00 00       	mov    $0x2c,%eax
    e64e:	e9 eb 00 00 00       	jmp    e73e <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e653:	8b 45 08             	mov    0x8(%ebp),%eax
    e656:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    e65d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e660:	0f b6 00             	movzbl (%eax),%eax
    e663:	0f b6 c0             	movzbl %al,%eax
    e666:	c1 e0 08             	shl    $0x8,%eax
    e669:	89 c2                	mov    %eax,%edx
    e66b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e66e:	83 c0 01             	add    $0x1,%eax
    e671:	0f b6 00             	movzbl (%eax),%eax
    e674:	0f b6 c0             	movzbl %al,%eax
    e677:	01 c2                	add    %eax,%edx
    e679:	8b 45 08             	mov    0x8(%ebp),%eax
    e67c:	89 50 38             	mov    %edx,0x38(%eax)
    e67f:	8b 45 08             	mov    0x8(%ebp),%eax
    e682:	8b 50 38             	mov    0x38(%eax),%edx
    e685:	8b 45 08             	mov    0x8(%ebp),%eax
    e688:	89 50 34             	mov    %edx,0x34(%eax)
    e68b:	8b 45 08             	mov    0x8(%ebp),%eax
    e68e:	8b 50 34             	mov    0x34(%eax),%edx
    e691:	8b 45 08             	mov    0x8(%ebp),%eax
    e694:	89 50 30             	mov    %edx,0x30(%eax)
    e697:	e9 9d 00 00 00       	jmp    e739 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    e69c:	8b 45 08             	mov    0x8(%ebp),%eax
    e69f:	8b 40 0c             	mov    0xc(%eax),%eax
    e6a2:	83 f8 02             	cmp    $0x2,%eax
    e6a5:	74 0f                	je     e6b6 <readChunk_bKGD+0xf9>
    e6a7:	8b 45 08             	mov    0x8(%ebp),%eax
    e6aa:	8b 40 0c             	mov    0xc(%eax),%eax
    e6ad:	83 f8 06             	cmp    $0x6,%eax
    e6b0:	0f 85 83 00 00 00    	jne    e739 <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    e6b6:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e6ba:	74 07                	je     e6c3 <readChunk_bKGD+0x106>
    e6bc:	b8 2d 00 00 00       	mov    $0x2d,%eax
    e6c1:	eb 7b                	jmp    e73e <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e6c3:	8b 45 08             	mov    0x8(%ebp),%eax
    e6c6:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    e6cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6d0:	0f b6 00             	movzbl (%eax),%eax
    e6d3:	0f b6 c0             	movzbl %al,%eax
    e6d6:	c1 e0 08             	shl    $0x8,%eax
    e6d9:	89 c2                	mov    %eax,%edx
    e6db:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6de:	83 c0 01             	add    $0x1,%eax
    e6e1:	0f b6 00             	movzbl (%eax),%eax
    e6e4:	0f b6 c0             	movzbl %al,%eax
    e6e7:	01 c2                	add    %eax,%edx
    e6e9:	8b 45 08             	mov    0x8(%ebp),%eax
    e6ec:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    e6ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6f2:	83 c0 02             	add    $0x2,%eax
    e6f5:	0f b6 00             	movzbl (%eax),%eax
    e6f8:	0f b6 c0             	movzbl %al,%eax
    e6fb:	c1 e0 08             	shl    $0x8,%eax
    e6fe:	89 c2                	mov    %eax,%edx
    e700:	8b 45 0c             	mov    0xc(%ebp),%eax
    e703:	83 c0 03             	add    $0x3,%eax
    e706:	0f b6 00             	movzbl (%eax),%eax
    e709:	0f b6 c0             	movzbl %al,%eax
    e70c:	01 c2                	add    %eax,%edx
    e70e:	8b 45 08             	mov    0x8(%ebp),%eax
    e711:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    e714:	8b 45 0c             	mov    0xc(%ebp),%eax
    e717:	83 c0 04             	add    $0x4,%eax
    e71a:	0f b6 00             	movzbl (%eax),%eax
    e71d:	0f b6 c0             	movzbl %al,%eax
    e720:	c1 e0 08             	shl    $0x8,%eax
    e723:	89 c2                	mov    %eax,%edx
    e725:	8b 45 0c             	mov    0xc(%ebp),%eax
    e728:	83 c0 05             	add    $0x5,%eax
    e72b:	0f b6 00             	movzbl (%eax),%eax
    e72e:	0f b6 c0             	movzbl %al,%eax
    e731:	01 c2                	add    %eax,%edx
    e733:	8b 45 08             	mov    0x8(%ebp),%eax
    e736:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    e739:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e73e:	5d                   	pop    %ebp
    e73f:	c3                   	ret    

0000e740 <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e740:	55                   	push   %ebp
    e741:	89 e5                	mov    %esp,%ebp
    e743:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    e746:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    e74d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e754:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e75b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e75f:	0f 85 06 01 00 00    	jne    e86b <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    e765:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    e76c:	eb 04                	jmp    e772 <readChunk_tEXt+0x32>
    e76e:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e772:	8b 45 10             	mov    0x10(%ebp),%eax
    e775:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e778:	73 0f                	jae    e789 <readChunk_tEXt+0x49>
    e77a:	8b 55 0c             	mov    0xc(%ebp),%edx
    e77d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e780:	01 d0                	add    %edx,%eax
    e782:	0f b6 00             	movzbl (%eax),%eax
    e785:	84 c0                	test   %al,%al
    e787:	75 e5                	jne    e76e <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e789:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e78d:	74 06                	je     e795 <readChunk_tEXt+0x55>
    e78f:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    e793:	76 0c                	jbe    e7a1 <readChunk_tEXt+0x61>
    e795:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e79c:	e9 ca 00 00 00       	jmp    e86b <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    e7a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7a4:	83 c0 01             	add    $0x1,%eax
    e7a7:	83 ec 0c             	sub    $0xc,%esp
    e7aa:	50                   	push   %eax
    e7ab:	e8 73 4b ff ff       	call   3323 <lodepng_malloc>
    e7b0:	83 c4 10             	add    $0x10,%esp
    e7b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e7b6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e7ba:	75 0c                	jne    e7c8 <readChunk_tEXt+0x88>
    e7bc:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e7c3:	e9 a3 00 00 00       	jmp    e86b <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    e7c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7cb:	83 ec 04             	sub    $0x4,%esp
    e7ce:	50                   	push   %eax
    e7cf:	ff 75 0c             	pushl  0xc(%ebp)
    e7d2:	ff 75 f0             	pushl  -0x10(%ebp)
    e7d5:	e8 87 4b ff ff       	call   3361 <lodepng_memcpy>
    e7da:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e7dd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e7e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7e3:	01 d0                	add    %edx,%eax
    e7e5:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    e7e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7eb:	83 c0 01             	add    $0x1,%eax
    e7ee:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    e7f1:	8b 45 10             	mov    0x10(%ebp),%eax
    e7f4:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    e7f7:	72 08                	jb     e801 <readChunk_tEXt+0xc1>
    e7f9:	8b 45 10             	mov    0x10(%ebp),%eax
    e7fc:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    e7ff:	eb 05                	jmp    e806 <readChunk_tEXt+0xc6>
    e801:	b8 00 00 00 00       	mov    $0x0,%eax
    e806:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    e809:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e80c:	83 c0 01             	add    $0x1,%eax
    e80f:	83 ec 0c             	sub    $0xc,%esp
    e812:	50                   	push   %eax
    e813:	e8 0b 4b ff ff       	call   3323 <lodepng_malloc>
    e818:	83 c4 10             	add    $0x10,%esp
    e81b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    e81e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e822:	75 09                	jne    e82d <readChunk_tEXt+0xed>
    e824:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e82b:	eb 3e                	jmp    e86b <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    e82d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e830:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e833:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e836:	01 ca                	add    %ecx,%edx
    e838:	83 ec 04             	sub    $0x4,%esp
    e83b:	50                   	push   %eax
    e83c:	52                   	push   %edx
    e83d:	ff 75 ec             	pushl  -0x14(%ebp)
    e840:	e8 1c 4b ff ff       	call   3361 <lodepng_memcpy>
    e845:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    e848:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e84b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e84e:	01 d0                	add    %edx,%eax
    e850:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    e853:	83 ec 04             	sub    $0x4,%esp
    e856:	ff 75 ec             	pushl  -0x14(%ebp)
    e859:	ff 75 f0             	pushl  -0x10(%ebp)
    e85c:	ff 75 08             	pushl  0x8(%ebp)
    e85f:	e8 3f ac ff ff       	call   94a3 <lodepng_add_text>
    e864:	83 c4 10             	add    $0x10,%esp
    e867:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    e86a:	90                   	nop
  }

  lodepng_free(key);
    e86b:	83 ec 0c             	sub    $0xc,%esp
    e86e:	ff 75 f0             	pushl  -0x10(%ebp)
    e871:	e8 ce 4a ff ff       	call   3344 <lodepng_free>
    e876:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    e879:	83 ec 0c             	sub    $0xc,%esp
    e87c:	ff 75 ec             	pushl  -0x14(%ebp)
    e87f:	e8 c0 4a ff ff       	call   3344 <lodepng_free>
    e884:	83 c4 10             	add    $0x10,%esp

  return error;
    e887:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e88a:	c9                   	leave  
    e88b:	c3                   	ret    

0000e88c <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    e88c:	55                   	push   %ebp
    e88d:	89 e5                	mov    %esp,%ebp
    e88f:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    e892:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    e899:	8b 45 0c             	mov    0xc(%ebp),%eax
    e89c:	8b 10                	mov    (%eax),%edx
    e89e:	89 55 d0             	mov    %edx,-0x30(%ebp)
    e8a1:	8b 50 04             	mov    0x4(%eax),%edx
    e8a4:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    e8a7:	8b 50 08             	mov    0x8(%eax),%edx
    e8aa:	89 55 d8             	mov    %edx,-0x28(%ebp)
    e8ad:	8b 50 0c             	mov    0xc(%eax),%edx
    e8b0:	89 55 dc             	mov    %edx,-0x24(%ebp)
    e8b3:	8b 50 10             	mov    0x10(%eax),%edx
    e8b6:	89 55 e0             	mov    %edx,-0x20(%ebp)
    e8b9:	8b 40 14             	mov    0x14(%eax),%eax
    e8bc:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    e8bf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    e8c6:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    e8cd:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e8d4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e8d8:	0f 85 48 01 00 00    	jne    ea26 <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    e8de:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e8e5:	eb 04                	jmp    e8eb <readChunk_zTXt+0x5f>
    e8e7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e8eb:	8b 45 14             	mov    0x14(%ebp),%eax
    e8ee:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e8f1:	73 0f                	jae    e902 <readChunk_zTXt+0x76>
    e8f3:	8b 55 10             	mov    0x10(%ebp),%edx
    e8f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e8f9:	01 d0                	add    %edx,%eax
    e8fb:	0f b6 00             	movzbl (%eax),%eax
    e8fe:	84 c0                	test   %al,%al
    e900:	75 e5                	jne    e8e7 <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    e902:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e905:	8d 50 02             	lea    0x2(%eax),%edx
    e908:	8b 45 14             	mov    0x14(%ebp),%eax
    e90b:	39 c2                	cmp    %eax,%edx
    e90d:	72 0c                	jb     e91b <readChunk_zTXt+0x8f>
    e90f:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    e916:	e9 0b 01 00 00       	jmp    ea26 <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e91b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e91f:	74 06                	je     e927 <readChunk_zTXt+0x9b>
    e921:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    e925:	76 0c                	jbe    e933 <readChunk_zTXt+0xa7>
    e927:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e92e:	e9 f3 00 00 00       	jmp    ea26 <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    e933:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e936:	83 c0 01             	add    $0x1,%eax
    e939:	83 ec 0c             	sub    $0xc,%esp
    e93c:	50                   	push   %eax
    e93d:	e8 e1 49 ff ff       	call   3323 <lodepng_malloc>
    e942:	83 c4 10             	add    $0x10,%esp
    e945:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e948:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e94c:	75 0c                	jne    e95a <readChunk_zTXt+0xce>
    e94e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e955:	e9 cc 00 00 00       	jmp    ea26 <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    e95a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e95d:	83 ec 04             	sub    $0x4,%esp
    e960:	50                   	push   %eax
    e961:	ff 75 10             	pushl  0x10(%ebp)
    e964:	ff 75 ec             	pushl  -0x14(%ebp)
    e967:	e8 f5 49 ff ff       	call   3361 <lodepng_memcpy>
    e96c:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e96f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e972:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e975:	01 d0                	add    %edx,%eax
    e977:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    e97a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e97d:	8d 50 01             	lea    0x1(%eax),%edx
    e980:	8b 45 10             	mov    0x10(%ebp),%eax
    e983:	01 d0                	add    %edx,%eax
    e985:	0f b6 00             	movzbl (%eax),%eax
    e988:	84 c0                	test   %al,%al
    e98a:	74 0c                	je     e998 <readChunk_zTXt+0x10c>
    e98c:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    e993:	e9 8e 00 00 00       	jmp    ea26 <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    e998:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e99b:	83 c0 02             	add    $0x2,%eax
    e99e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    e9a1:	8b 45 14             	mov    0x14(%ebp),%eax
    e9a4:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e9a7:	76 09                	jbe    e9b2 <readChunk_zTXt+0x126>
    e9a9:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    e9b0:	eb 74                	jmp    ea26 <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    e9b2:	8b 45 14             	mov    0x14(%ebp),%eax
    e9b5:	2b 45 e8             	sub    -0x18(%ebp),%eax
    e9b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    e9bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9be:	8b 40 30             	mov    0x30(%eax),%eax
    e9c1:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    e9c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9c7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    e9ca:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e9cd:	01 d1                	add    %edx,%ecx
    e9cf:	83 ec 08             	sub    $0x8,%esp
    e9d2:	8d 55 d0             	lea    -0x30(%ebp),%edx
    e9d5:	52                   	push   %edx
    e9d6:	50                   	push   %eax
    e9d7:	51                   	push   %ecx
    e9d8:	6a 00                	push   $0x0
    e9da:	8d 45 c8             	lea    -0x38(%ebp),%eax
    e9dd:	50                   	push   %eax
    e9de:	8d 45 cc             	lea    -0x34(%ebp),%eax
    e9e1:	50                   	push   %eax
    e9e2:	e8 f7 93 ff ff       	call   7dde <zlib_decompress>
    e9e7:	83 c4 20             	add    $0x20,%esp
    e9ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    e9ed:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e9f1:	74 11                	je     ea04 <readChunk_zTXt+0x178>
    e9f3:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e9f6:	8b 45 c8             	mov    -0x38(%ebp),%eax
    e9f9:	39 c2                	cmp    %eax,%edx
    e9fb:	7d 07                	jge    ea04 <readChunk_zTXt+0x178>
    e9fd:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    ea04:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ea08:	75 1b                	jne    ea25 <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    ea0a:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ea0d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ea10:	52                   	push   %edx
    ea11:	50                   	push   %eax
    ea12:	ff 75 ec             	pushl  -0x14(%ebp)
    ea15:	ff 75 08             	pushl  0x8(%ebp)
    ea18:	e8 60 a9 ff ff       	call   937d <lodepng_add_text_sized>
    ea1d:	83 c4 10             	add    $0x10,%esp
    ea20:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    ea23:	eb 01                	jmp    ea26 <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    ea25:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    ea26:	83 ec 0c             	sub    $0xc,%esp
    ea29:	ff 75 ec             	pushl  -0x14(%ebp)
    ea2c:	e8 13 49 ff ff       	call   3344 <lodepng_free>
    ea31:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    ea34:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ea37:	83 ec 0c             	sub    $0xc,%esp
    ea3a:	50                   	push   %eax
    ea3b:	e8 04 49 ff ff       	call   3344 <lodepng_free>
    ea40:	83 c4 10             	add    $0x10,%esp

  return error;
    ea43:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ea46:	c9                   	leave  
    ea47:	c3                   	ret    

0000ea48 <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    ea48:	55                   	push   %ebp
    ea49:	89 e5                	mov    %esp,%ebp
    ea4b:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    ea4e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    ea55:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea58:	8b 10                	mov    (%eax),%edx
    ea5a:	89 55 c0             	mov    %edx,-0x40(%ebp)
    ea5d:	8b 50 04             	mov    0x4(%eax),%edx
    ea60:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    ea63:	8b 50 08             	mov    0x8(%eax),%edx
    ea66:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ea69:	8b 50 0c             	mov    0xc(%eax),%edx
    ea6c:	89 55 cc             	mov    %edx,-0x34(%ebp)
    ea6f:	8b 50 10             	mov    0x10(%eax),%edx
    ea72:	89 55 d0             	mov    %edx,-0x30(%ebp)
    ea75:	8b 40 14             	mov    0x14(%eax),%eax
    ea78:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    ea7b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ea82:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    ea89:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ea90:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ea94:	0f 85 d5 02 00 00    	jne    ed6f <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    ea9a:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    ea9e:	7f 0c                	jg     eaac <readChunk_iTXt+0x64>
    eaa0:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    eaa7:	e9 c3 02 00 00       	jmp    ed6f <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    eaac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    eab3:	eb 04                	jmp    eab9 <readChunk_iTXt+0x71>
    eab5:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    eab9:	8b 45 14             	mov    0x14(%ebp),%eax
    eabc:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    eabf:	73 0f                	jae    ead0 <readChunk_iTXt+0x88>
    eac1:	8b 55 10             	mov    0x10(%ebp),%edx
    eac4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eac7:	01 d0                	add    %edx,%eax
    eac9:	0f b6 00             	movzbl (%eax),%eax
    eacc:	84 c0                	test   %al,%al
    eace:	75 e5                	jne    eab5 <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    ead0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ead3:	8d 50 03             	lea    0x3(%eax),%edx
    ead6:	8b 45 14             	mov    0x14(%ebp),%eax
    ead9:	39 c2                	cmp    %eax,%edx
    eadb:	72 0c                	jb     eae9 <readChunk_iTXt+0xa1>
    eadd:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    eae4:	e9 86 02 00 00       	jmp    ed6f <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    eae9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    eaed:	74 06                	je     eaf5 <readChunk_iTXt+0xad>
    eaef:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    eaf3:	76 0c                	jbe    eb01 <readChunk_iTXt+0xb9>
    eaf5:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    eafc:	e9 6e 02 00 00       	jmp    ed6f <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    eb01:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb04:	83 c0 01             	add    $0x1,%eax
    eb07:	83 ec 0c             	sub    $0xc,%esp
    eb0a:	50                   	push   %eax
    eb0b:	e8 13 48 ff ff       	call   3323 <lodepng_malloc>
    eb10:	83 c4 10             	add    $0x10,%esp
    eb13:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    eb16:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    eb1a:	75 0c                	jne    eb28 <readChunk_iTXt+0xe0>
    eb1c:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eb23:	e9 47 02 00 00       	jmp    ed6f <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    eb28:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb2b:	83 ec 04             	sub    $0x4,%esp
    eb2e:	50                   	push   %eax
    eb2f:	ff 75 10             	pushl  0x10(%ebp)
    eb32:	ff 75 e8             	pushl  -0x18(%ebp)
    eb35:	e8 27 48 ff ff       	call   3361 <lodepng_memcpy>
    eb3a:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    eb3d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    eb40:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb43:	01 d0                	add    %edx,%eax
    eb45:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    eb48:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb4b:	8d 50 01             	lea    0x1(%eax),%edx
    eb4e:	8b 45 10             	mov    0x10(%ebp),%eax
    eb51:	01 d0                	add    %edx,%eax
    eb53:	0f b6 00             	movzbl (%eax),%eax
    eb56:	0f b6 c0             	movzbl %al,%eax
    eb59:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    eb5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb5f:	8d 50 02             	lea    0x2(%eax),%edx
    eb62:	8b 45 10             	mov    0x10(%ebp),%eax
    eb65:	01 d0                	add    %edx,%eax
    eb67:	0f b6 00             	movzbl (%eax),%eax
    eb6a:	84 c0                	test   %al,%al
    eb6c:	74 0c                	je     eb7a <readChunk_iTXt+0x132>
    eb6e:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    eb75:	e9 f5 01 00 00       	jmp    ed6f <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    eb7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb7d:	83 c0 03             	add    $0x3,%eax
    eb80:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    eb83:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    eb8a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    eb8d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    eb90:	eb 08                	jmp    eb9a <readChunk_iTXt+0x152>
    eb92:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    eb96:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    eb9a:	8b 45 14             	mov    0x14(%ebp),%eax
    eb9d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    eba0:	73 0f                	jae    ebb1 <readChunk_iTXt+0x169>
    eba2:	8b 55 10             	mov    0x10(%ebp),%edx
    eba5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eba8:	01 d0                	add    %edx,%eax
    ebaa:	0f b6 00             	movzbl (%eax),%eax
    ebad:	84 c0                	test   %al,%al
    ebaf:	75 e1                	jne    eb92 <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    ebb1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebb4:	83 c0 01             	add    $0x1,%eax
    ebb7:	83 ec 0c             	sub    $0xc,%esp
    ebba:	50                   	push   %eax
    ebbb:	e8 63 47 ff ff       	call   3323 <lodepng_malloc>
    ebc0:	83 c4 10             	add    $0x10,%esp
    ebc3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    ebc6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ebca:	75 0c                	jne    ebd8 <readChunk_iTXt+0x190>
    ebcc:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ebd3:	e9 97 01 00 00       	jmp    ed6f <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    ebd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebdb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ebde:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ebe1:	01 ca                	add    %ecx,%edx
    ebe3:	83 ec 04             	sub    $0x4,%esp
    ebe6:	50                   	push   %eax
    ebe7:	52                   	push   %edx
    ebe8:	ff 75 e4             	pushl  -0x1c(%ebp)
    ebeb:	e8 71 47 ff ff       	call   3361 <lodepng_memcpy>
    ebf0:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    ebf3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ebf6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebf9:	01 d0                	add    %edx,%eax
    ebfb:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    ebfe:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ec01:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec04:	01 d0                	add    %edx,%eax
    ec06:	83 c0 01             	add    $0x1,%eax
    ec09:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ec0c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ec13:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec16:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ec19:	eb 08                	jmp    ec23 <readChunk_iTXt+0x1db>
    ec1b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ec1f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ec23:	8b 45 14             	mov    0x14(%ebp),%eax
    ec26:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ec29:	73 0f                	jae    ec3a <readChunk_iTXt+0x1f2>
    ec2b:	8b 55 10             	mov    0x10(%ebp),%edx
    ec2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec31:	01 d0                	add    %edx,%eax
    ec33:	0f b6 00             	movzbl (%eax),%eax
    ec36:	84 c0                	test   %al,%al
    ec38:	75 e1                	jne    ec1b <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    ec3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec3d:	83 c0 01             	add    $0x1,%eax
    ec40:	83 ec 0c             	sub    $0xc,%esp
    ec43:	50                   	push   %eax
    ec44:	e8 da 46 ff ff       	call   3323 <lodepng_malloc>
    ec49:	83 c4 10             	add    $0x10,%esp
    ec4c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    ec4f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ec53:	75 0c                	jne    ec61 <readChunk_iTXt+0x219>
    ec55:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ec5c:	e9 0e 01 00 00       	jmp    ed6f <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    ec61:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec64:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ec67:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ec6a:	01 ca                	add    %ecx,%edx
    ec6c:	83 ec 04             	sub    $0x4,%esp
    ec6f:	50                   	push   %eax
    ec70:	52                   	push   %edx
    ec71:	ff 75 e0             	pushl  -0x20(%ebp)
    ec74:	e8 e8 46 ff ff       	call   3361 <lodepng_memcpy>
    ec79:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    ec7c:	8b 55 e0             	mov    -0x20(%ebp),%edx
    ec7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec82:	01 d0                	add    %edx,%eax
    ec84:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    ec87:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ec8a:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec8d:	01 d0                	add    %edx,%eax
    ec8f:	83 c0 01             	add    $0x1,%eax
    ec92:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    ec95:	8b 45 14             	mov    0x14(%ebp),%eax
    ec98:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ec9b:	72 08                	jb     eca5 <readChunk_iTXt+0x25d>
    ec9d:	8b 45 14             	mov    0x14(%ebp),%eax
    eca0:	2b 45 d8             	sub    -0x28(%ebp),%eax
    eca3:	eb 05                	jmp    ecaa <readChunk_iTXt+0x262>
    eca5:	b8 00 00 00 00       	mov    $0x0,%eax
    ecaa:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    ecad:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    ecb1:	0f 84 90 00 00 00    	je     ed47 <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    ecb7:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    ecbe:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    ecc5:	8b 45 0c             	mov    0xc(%ebp),%eax
    ecc8:	8b 40 30             	mov    0x30(%eax),%eax
    eccb:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    ecce:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ecd1:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ecd4:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ecd7:	01 d1                	add    %edx,%ecx
    ecd9:	83 ec 08             	sub    $0x8,%esp
    ecdc:	8d 55 c0             	lea    -0x40(%ebp),%edx
    ecdf:	52                   	push   %edx
    ece0:	50                   	push   %eax
    ece1:	51                   	push   %ecx
    ece2:	6a 00                	push   $0x0
    ece4:	8d 45 b8             	lea    -0x48(%ebp),%eax
    ece7:	50                   	push   %eax
    ece8:	8d 45 bc             	lea    -0x44(%ebp),%eax
    eceb:	50                   	push   %eax
    ecec:	e8 ed 90 ff ff       	call   7dde <zlib_decompress>
    ecf1:	83 c4 20             	add    $0x20,%esp
    ecf4:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    ecf7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ecfb:	74 11                	je     ed0e <readChunk_iTXt+0x2c6>
    ecfd:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ed00:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ed03:	39 c2                	cmp    %eax,%edx
    ed05:	7d 07                	jge    ed0e <readChunk_iTXt+0x2c6>
    ed07:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    ed0e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ed12:	75 22                	jne    ed36 <readChunk_iTXt+0x2ee>
    ed14:	8b 55 b8             	mov    -0x48(%ebp),%edx
    ed17:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ed1a:	83 ec 08             	sub    $0x8,%esp
    ed1d:	52                   	push   %edx
    ed1e:	50                   	push   %eax
    ed1f:	ff 75 e0             	pushl  -0x20(%ebp)
    ed22:	ff 75 e4             	pushl  -0x1c(%ebp)
    ed25:	ff 75 e8             	pushl  -0x18(%ebp)
    ed28:	ff 75 08             	pushl  0x8(%ebp)
    ed2b:	e8 94 a9 ff ff       	call   96c4 <lodepng_add_itext_sized>
    ed30:	83 c4 20             	add    $0x20,%esp
    ed33:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    ed36:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ed39:	83 ec 0c             	sub    $0xc,%esp
    ed3c:	50                   	push   %eax
    ed3d:	e8 02 46 ff ff       	call   3344 <lodepng_free>
    ed42:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    ed45:	eb 27                	jmp    ed6e <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    ed47:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed4a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ed4d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ed50:	01 ca                	add    %ecx,%edx
    ed52:	83 ec 08             	sub    $0x8,%esp
    ed55:	50                   	push   %eax
    ed56:	52                   	push   %edx
    ed57:	ff 75 e0             	pushl  -0x20(%ebp)
    ed5a:	ff 75 e4             	pushl  -0x1c(%ebp)
    ed5d:	ff 75 e8             	pushl  -0x18(%ebp)
    ed60:	ff 75 08             	pushl  0x8(%ebp)
    ed63:	e8 5c a9 ff ff       	call   96c4 <lodepng_add_itext_sized>
    ed68:	83 c4 20             	add    $0x20,%esp
    ed6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    ed6e:	90                   	nop
  }

  lodepng_free(key);
    ed6f:	83 ec 0c             	sub    $0xc,%esp
    ed72:	ff 75 e8             	pushl  -0x18(%ebp)
    ed75:	e8 ca 45 ff ff       	call   3344 <lodepng_free>
    ed7a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    ed7d:	83 ec 0c             	sub    $0xc,%esp
    ed80:	ff 75 e4             	pushl  -0x1c(%ebp)
    ed83:	e8 bc 45 ff ff       	call   3344 <lodepng_free>
    ed88:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    ed8b:	83 ec 0c             	sub    $0xc,%esp
    ed8e:	ff 75 e0             	pushl  -0x20(%ebp)
    ed91:	e8 ae 45 ff ff       	call   3344 <lodepng_free>
    ed96:	83 c4 10             	add    $0x10,%esp

  return error;
    ed99:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ed9c:	c9                   	leave  
    ed9d:	c3                   	ret    

0000ed9e <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ed9e:	55                   	push   %ebp
    ed9f:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    eda1:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    eda5:	74 0a                	je     edb1 <readChunk_tIME+0x13>
    eda7:	b8 49 00 00 00       	mov    $0x49,%eax
    edac:	e9 8b 00 00 00       	jmp    ee3c <readChunk_tIME+0x9e>

  info->time_defined = 1;
    edb1:	8b 45 08             	mov    0x8(%ebp),%eax
    edb4:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    edbb:	8b 45 0c             	mov    0xc(%ebp),%eax
    edbe:	0f b6 00             	movzbl (%eax),%eax
    edc1:	0f b6 c0             	movzbl %al,%eax
    edc4:	c1 e0 08             	shl    $0x8,%eax
    edc7:	89 c2                	mov    %eax,%edx
    edc9:	8b 45 0c             	mov    0xc(%ebp),%eax
    edcc:	83 c0 01             	add    $0x1,%eax
    edcf:	0f b6 00             	movzbl (%eax),%eax
    edd2:	0f b6 c0             	movzbl %al,%eax
    edd5:	01 c2                	add    %eax,%edx
    edd7:	8b 45 08             	mov    0x8(%ebp),%eax
    edda:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    eddd:	8b 45 0c             	mov    0xc(%ebp),%eax
    ede0:	83 c0 02             	add    $0x2,%eax
    ede3:	0f b6 00             	movzbl (%eax),%eax
    ede6:	0f b6 d0             	movzbl %al,%edx
    ede9:	8b 45 08             	mov    0x8(%ebp),%eax
    edec:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    edef:	8b 45 0c             	mov    0xc(%ebp),%eax
    edf2:	83 c0 03             	add    $0x3,%eax
    edf5:	0f b6 00             	movzbl (%eax),%eax
    edf8:	0f b6 d0             	movzbl %al,%edx
    edfb:	8b 45 08             	mov    0x8(%ebp),%eax
    edfe:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    ee01:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee04:	83 c0 04             	add    $0x4,%eax
    ee07:	0f b6 00             	movzbl (%eax),%eax
    ee0a:	0f b6 d0             	movzbl %al,%edx
    ee0d:	8b 45 08             	mov    0x8(%ebp),%eax
    ee10:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    ee13:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee16:	83 c0 05             	add    $0x5,%eax
    ee19:	0f b6 00             	movzbl (%eax),%eax
    ee1c:	0f b6 d0             	movzbl %al,%edx
    ee1f:	8b 45 08             	mov    0x8(%ebp),%eax
    ee22:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    ee25:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee28:	83 c0 06             	add    $0x6,%eax
    ee2b:	0f b6 00             	movzbl (%eax),%eax
    ee2e:	0f b6 d0             	movzbl %al,%edx
    ee31:	8b 45 08             	mov    0x8(%ebp),%eax
    ee34:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    ee37:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ee3c:	5d                   	pop    %ebp
    ee3d:	c3                   	ret    

0000ee3e <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ee3e:	55                   	push   %ebp
    ee3f:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    ee41:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    ee45:	74 0a                	je     ee51 <readChunk_pHYs+0x13>
    ee47:	b8 4a 00 00 00       	mov    $0x4a,%eax
    ee4c:	e9 ba 00 00 00       	jmp    ef0b <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    ee51:	8b 45 08             	mov    0x8(%ebp),%eax
    ee54:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    ee5b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee5e:	0f b6 00             	movzbl (%eax),%eax
    ee61:	0f b6 c0             	movzbl %al,%eax
    ee64:	c1 e0 08             	shl    $0x8,%eax
    ee67:	89 c2                	mov    %eax,%edx
    ee69:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee6c:	83 c0 01             	add    $0x1,%eax
    ee6f:	0f b6 00             	movzbl (%eax),%eax
    ee72:	0f b6 c0             	movzbl %al,%eax
    ee75:	01 d0                	add    %edx,%eax
    ee77:	c1 e0 08             	shl    $0x8,%eax
    ee7a:	89 c2                	mov    %eax,%edx
    ee7c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee7f:	83 c0 02             	add    $0x2,%eax
    ee82:	0f b6 00             	movzbl (%eax),%eax
    ee85:	0f b6 c0             	movzbl %al,%eax
    ee88:	01 d0                	add    %edx,%eax
    ee8a:	c1 e0 08             	shl    $0x8,%eax
    ee8d:	89 c2                	mov    %eax,%edx
    ee8f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee92:	83 c0 03             	add    $0x3,%eax
    ee95:	0f b6 00             	movzbl (%eax),%eax
    ee98:	0f b6 c0             	movzbl %al,%eax
    ee9b:	01 c2                	add    %eax,%edx
    ee9d:	8b 45 08             	mov    0x8(%ebp),%eax
    eea0:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    eea3:	8b 45 0c             	mov    0xc(%ebp),%eax
    eea6:	83 c0 04             	add    $0x4,%eax
    eea9:	0f b6 00             	movzbl (%eax),%eax
    eeac:	0f b6 c0             	movzbl %al,%eax
    eeaf:	c1 e0 08             	shl    $0x8,%eax
    eeb2:	89 c2                	mov    %eax,%edx
    eeb4:	8b 45 0c             	mov    0xc(%ebp),%eax
    eeb7:	83 c0 05             	add    $0x5,%eax
    eeba:	0f b6 00             	movzbl (%eax),%eax
    eebd:	0f b6 c0             	movzbl %al,%eax
    eec0:	01 d0                	add    %edx,%eax
    eec2:	c1 e0 08             	shl    $0x8,%eax
    eec5:	89 c2                	mov    %eax,%edx
    eec7:	8b 45 0c             	mov    0xc(%ebp),%eax
    eeca:	83 c0 06             	add    $0x6,%eax
    eecd:	0f b6 00             	movzbl (%eax),%eax
    eed0:	0f b6 c0             	movzbl %al,%eax
    eed3:	01 d0                	add    %edx,%eax
    eed5:	c1 e0 08             	shl    $0x8,%eax
    eed8:	89 c2                	mov    %eax,%edx
    eeda:	8b 45 0c             	mov    0xc(%ebp),%eax
    eedd:	83 c0 07             	add    $0x7,%eax
    eee0:	0f b6 00             	movzbl (%eax),%eax
    eee3:	0f b6 c0             	movzbl %al,%eax
    eee6:	01 c2                	add    %eax,%edx
    eee8:	8b 45 08             	mov    0x8(%ebp),%eax
    eeeb:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    eef1:	8b 45 0c             	mov    0xc(%ebp),%eax
    eef4:	83 c0 08             	add    $0x8,%eax
    eef7:	0f b6 00             	movzbl (%eax),%eax
    eefa:	0f b6 d0             	movzbl %al,%edx
    eefd:	8b 45 08             	mov    0x8(%ebp),%eax
    ef00:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    ef06:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ef0b:	5d                   	pop    %ebp
    ef0c:	c3                   	ret    

0000ef0d <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ef0d:	55                   	push   %ebp
    ef0e:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    ef10:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    ef14:	74 07                	je     ef1d <readChunk_gAMA+0x10>
    ef16:	b8 60 00 00 00       	mov    $0x60,%eax
    ef1b:	eb 5d                	jmp    ef7a <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    ef1d:	8b 45 08             	mov    0x8(%ebp),%eax
    ef20:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    ef27:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    ef2a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef2d:	0f b6 00             	movzbl (%eax),%eax
    ef30:	0f b6 c0             	movzbl %al,%eax
    ef33:	c1 e0 08             	shl    $0x8,%eax
    ef36:	89 c2                	mov    %eax,%edx
    ef38:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef3b:	83 c0 01             	add    $0x1,%eax
    ef3e:	0f b6 00             	movzbl (%eax),%eax
    ef41:	0f b6 c0             	movzbl %al,%eax
    ef44:	01 d0                	add    %edx,%eax
    ef46:	c1 e0 08             	shl    $0x8,%eax
    ef49:	89 c2                	mov    %eax,%edx
    ef4b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef4e:	83 c0 02             	add    $0x2,%eax
    ef51:	0f b6 00             	movzbl (%eax),%eax
    ef54:	0f b6 c0             	movzbl %al,%eax
    ef57:	01 d0                	add    %edx,%eax
    ef59:	c1 e0 08             	shl    $0x8,%eax
    ef5c:	89 c2                	mov    %eax,%edx
    ef5e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef61:	83 c0 03             	add    $0x3,%eax
    ef64:	0f b6 00             	movzbl (%eax),%eax
    ef67:	0f b6 c0             	movzbl %al,%eax
    ef6a:	01 c2                	add    %eax,%edx
    ef6c:	8b 45 08             	mov    0x8(%ebp),%eax
    ef6f:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    ef75:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ef7a:	5d                   	pop    %ebp
    ef7b:	c3                   	ret    

0000ef7c <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ef7c:	55                   	push   %ebp
    ef7d:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    ef7f:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    ef83:	74 0a                	je     ef8f <readChunk_cHRM+0x13>
    ef85:	b8 61 00 00 00       	mov    $0x61,%eax
    ef8a:	e9 7f 02 00 00       	jmp    f20e <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    ef8f:	8b 45 08             	mov    0x8(%ebp),%eax
    ef92:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    ef99:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    ef9c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef9f:	0f b6 00             	movzbl (%eax),%eax
    efa2:	0f b6 c0             	movzbl %al,%eax
    efa5:	c1 e0 08             	shl    $0x8,%eax
    efa8:	89 c2                	mov    %eax,%edx
    efaa:	8b 45 0c             	mov    0xc(%ebp),%eax
    efad:	83 c0 01             	add    $0x1,%eax
    efb0:	0f b6 00             	movzbl (%eax),%eax
    efb3:	0f b6 c0             	movzbl %al,%eax
    efb6:	01 d0                	add    %edx,%eax
    efb8:	c1 e0 08             	shl    $0x8,%eax
    efbb:	89 c2                	mov    %eax,%edx
    efbd:	8b 45 0c             	mov    0xc(%ebp),%eax
    efc0:	83 c0 02             	add    $0x2,%eax
    efc3:	0f b6 00             	movzbl (%eax),%eax
    efc6:	0f b6 c0             	movzbl %al,%eax
    efc9:	01 d0                	add    %edx,%eax
    efcb:	c1 e0 08             	shl    $0x8,%eax
    efce:	89 c2                	mov    %eax,%edx
    efd0:	8b 45 0c             	mov    0xc(%ebp),%eax
    efd3:	83 c0 03             	add    $0x3,%eax
    efd6:	0f b6 00             	movzbl (%eax),%eax
    efd9:	0f b6 c0             	movzbl %al,%eax
    efdc:	01 c2                	add    %eax,%edx
    efde:	8b 45 08             	mov    0x8(%ebp),%eax
    efe1:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    efe7:	8b 45 0c             	mov    0xc(%ebp),%eax
    efea:	83 c0 04             	add    $0x4,%eax
    efed:	0f b6 00             	movzbl (%eax),%eax
    eff0:	0f b6 c0             	movzbl %al,%eax
    eff3:	c1 e0 08             	shl    $0x8,%eax
    eff6:	89 c2                	mov    %eax,%edx
    eff8:	8b 45 0c             	mov    0xc(%ebp),%eax
    effb:	83 c0 05             	add    $0x5,%eax
    effe:	0f b6 00             	movzbl (%eax),%eax
    f001:	0f b6 c0             	movzbl %al,%eax
    f004:	01 d0                	add    %edx,%eax
    f006:	c1 e0 08             	shl    $0x8,%eax
    f009:	89 c2                	mov    %eax,%edx
    f00b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f00e:	83 c0 06             	add    $0x6,%eax
    f011:	0f b6 00             	movzbl (%eax),%eax
    f014:	0f b6 c0             	movzbl %al,%eax
    f017:	01 d0                	add    %edx,%eax
    f019:	c1 e0 08             	shl    $0x8,%eax
    f01c:	89 c2                	mov    %eax,%edx
    f01e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f021:	83 c0 07             	add    $0x7,%eax
    f024:	0f b6 00             	movzbl (%eax),%eax
    f027:	0f b6 c0             	movzbl %al,%eax
    f02a:	01 c2                	add    %eax,%edx
    f02c:	8b 45 08             	mov    0x8(%ebp),%eax
    f02f:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    f035:	8b 45 0c             	mov    0xc(%ebp),%eax
    f038:	83 c0 08             	add    $0x8,%eax
    f03b:	0f b6 00             	movzbl (%eax),%eax
    f03e:	0f b6 c0             	movzbl %al,%eax
    f041:	c1 e0 08             	shl    $0x8,%eax
    f044:	89 c2                	mov    %eax,%edx
    f046:	8b 45 0c             	mov    0xc(%ebp),%eax
    f049:	83 c0 09             	add    $0x9,%eax
    f04c:	0f b6 00             	movzbl (%eax),%eax
    f04f:	0f b6 c0             	movzbl %al,%eax
    f052:	01 d0                	add    %edx,%eax
    f054:	c1 e0 08             	shl    $0x8,%eax
    f057:	89 c2                	mov    %eax,%edx
    f059:	8b 45 0c             	mov    0xc(%ebp),%eax
    f05c:	83 c0 0a             	add    $0xa,%eax
    f05f:	0f b6 00             	movzbl (%eax),%eax
    f062:	0f b6 c0             	movzbl %al,%eax
    f065:	01 d0                	add    %edx,%eax
    f067:	c1 e0 08             	shl    $0x8,%eax
    f06a:	89 c2                	mov    %eax,%edx
    f06c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f06f:	83 c0 0b             	add    $0xb,%eax
    f072:	0f b6 00             	movzbl (%eax),%eax
    f075:	0f b6 c0             	movzbl %al,%eax
    f078:	01 c2                	add    %eax,%edx
    f07a:	8b 45 08             	mov    0x8(%ebp),%eax
    f07d:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    f083:	8b 45 0c             	mov    0xc(%ebp),%eax
    f086:	83 c0 0c             	add    $0xc,%eax
    f089:	0f b6 00             	movzbl (%eax),%eax
    f08c:	0f b6 c0             	movzbl %al,%eax
    f08f:	c1 e0 08             	shl    $0x8,%eax
    f092:	89 c2                	mov    %eax,%edx
    f094:	8b 45 0c             	mov    0xc(%ebp),%eax
    f097:	83 c0 0d             	add    $0xd,%eax
    f09a:	0f b6 00             	movzbl (%eax),%eax
    f09d:	0f b6 c0             	movzbl %al,%eax
    f0a0:	01 d0                	add    %edx,%eax
    f0a2:	c1 e0 08             	shl    $0x8,%eax
    f0a5:	89 c2                	mov    %eax,%edx
    f0a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0aa:	83 c0 0e             	add    $0xe,%eax
    f0ad:	0f b6 00             	movzbl (%eax),%eax
    f0b0:	0f b6 c0             	movzbl %al,%eax
    f0b3:	01 d0                	add    %edx,%eax
    f0b5:	c1 e0 08             	shl    $0x8,%eax
    f0b8:	89 c2                	mov    %eax,%edx
    f0ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0bd:	83 c0 0f             	add    $0xf,%eax
    f0c0:	0f b6 00             	movzbl (%eax),%eax
    f0c3:	0f b6 c0             	movzbl %al,%eax
    f0c6:	01 c2                	add    %eax,%edx
    f0c8:	8b 45 08             	mov    0x8(%ebp),%eax
    f0cb:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    f0d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0d4:	83 c0 10             	add    $0x10,%eax
    f0d7:	0f b6 00             	movzbl (%eax),%eax
    f0da:	0f b6 c0             	movzbl %al,%eax
    f0dd:	c1 e0 08             	shl    $0x8,%eax
    f0e0:	89 c2                	mov    %eax,%edx
    f0e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0e5:	83 c0 11             	add    $0x11,%eax
    f0e8:	0f b6 00             	movzbl (%eax),%eax
    f0eb:	0f b6 c0             	movzbl %al,%eax
    f0ee:	01 d0                	add    %edx,%eax
    f0f0:	c1 e0 08             	shl    $0x8,%eax
    f0f3:	89 c2                	mov    %eax,%edx
    f0f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0f8:	83 c0 12             	add    $0x12,%eax
    f0fb:	0f b6 00             	movzbl (%eax),%eax
    f0fe:	0f b6 c0             	movzbl %al,%eax
    f101:	01 d0                	add    %edx,%eax
    f103:	c1 e0 08             	shl    $0x8,%eax
    f106:	89 c2                	mov    %eax,%edx
    f108:	8b 45 0c             	mov    0xc(%ebp),%eax
    f10b:	83 c0 13             	add    $0x13,%eax
    f10e:	0f b6 00             	movzbl (%eax),%eax
    f111:	0f b6 c0             	movzbl %al,%eax
    f114:	01 c2                	add    %eax,%edx
    f116:	8b 45 08             	mov    0x8(%ebp),%eax
    f119:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    f11f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f122:	83 c0 14             	add    $0x14,%eax
    f125:	0f b6 00             	movzbl (%eax),%eax
    f128:	0f b6 c0             	movzbl %al,%eax
    f12b:	c1 e0 08             	shl    $0x8,%eax
    f12e:	89 c2                	mov    %eax,%edx
    f130:	8b 45 0c             	mov    0xc(%ebp),%eax
    f133:	83 c0 15             	add    $0x15,%eax
    f136:	0f b6 00             	movzbl (%eax),%eax
    f139:	0f b6 c0             	movzbl %al,%eax
    f13c:	01 d0                	add    %edx,%eax
    f13e:	c1 e0 08             	shl    $0x8,%eax
    f141:	89 c2                	mov    %eax,%edx
    f143:	8b 45 0c             	mov    0xc(%ebp),%eax
    f146:	83 c0 16             	add    $0x16,%eax
    f149:	0f b6 00             	movzbl (%eax),%eax
    f14c:	0f b6 c0             	movzbl %al,%eax
    f14f:	01 d0                	add    %edx,%eax
    f151:	c1 e0 08             	shl    $0x8,%eax
    f154:	89 c2                	mov    %eax,%edx
    f156:	8b 45 0c             	mov    0xc(%ebp),%eax
    f159:	83 c0 17             	add    $0x17,%eax
    f15c:	0f b6 00             	movzbl (%eax),%eax
    f15f:	0f b6 c0             	movzbl %al,%eax
    f162:	01 c2                	add    %eax,%edx
    f164:	8b 45 08             	mov    0x8(%ebp),%eax
    f167:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    f16d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f170:	83 c0 18             	add    $0x18,%eax
    f173:	0f b6 00             	movzbl (%eax),%eax
    f176:	0f b6 c0             	movzbl %al,%eax
    f179:	c1 e0 08             	shl    $0x8,%eax
    f17c:	89 c2                	mov    %eax,%edx
    f17e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f181:	83 c0 19             	add    $0x19,%eax
    f184:	0f b6 00             	movzbl (%eax),%eax
    f187:	0f b6 c0             	movzbl %al,%eax
    f18a:	01 d0                	add    %edx,%eax
    f18c:	c1 e0 08             	shl    $0x8,%eax
    f18f:	89 c2                	mov    %eax,%edx
    f191:	8b 45 0c             	mov    0xc(%ebp),%eax
    f194:	83 c0 1a             	add    $0x1a,%eax
    f197:	0f b6 00             	movzbl (%eax),%eax
    f19a:	0f b6 c0             	movzbl %al,%eax
    f19d:	01 d0                	add    %edx,%eax
    f19f:	c1 e0 08             	shl    $0x8,%eax
    f1a2:	89 c2                	mov    %eax,%edx
    f1a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1a7:	83 c0 1b             	add    $0x1b,%eax
    f1aa:	0f b6 00             	movzbl (%eax),%eax
    f1ad:	0f b6 c0             	movzbl %al,%eax
    f1b0:	01 c2                	add    %eax,%edx
    f1b2:	8b 45 08             	mov    0x8(%ebp),%eax
    f1b5:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    f1bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1be:	83 c0 1c             	add    $0x1c,%eax
    f1c1:	0f b6 00             	movzbl (%eax),%eax
    f1c4:	0f b6 c0             	movzbl %al,%eax
    f1c7:	c1 e0 08             	shl    $0x8,%eax
    f1ca:	89 c2                	mov    %eax,%edx
    f1cc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1cf:	83 c0 1d             	add    $0x1d,%eax
    f1d2:	0f b6 00             	movzbl (%eax),%eax
    f1d5:	0f b6 c0             	movzbl %al,%eax
    f1d8:	01 d0                	add    %edx,%eax
    f1da:	c1 e0 08             	shl    $0x8,%eax
    f1dd:	89 c2                	mov    %eax,%edx
    f1df:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1e2:	83 c0 1e             	add    $0x1e,%eax
    f1e5:	0f b6 00             	movzbl (%eax),%eax
    f1e8:	0f b6 c0             	movzbl %al,%eax
    f1eb:	01 d0                	add    %edx,%eax
    f1ed:	c1 e0 08             	shl    $0x8,%eax
    f1f0:	89 c2                	mov    %eax,%edx
    f1f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1f5:	83 c0 1f             	add    $0x1f,%eax
    f1f8:	0f b6 00             	movzbl (%eax),%eax
    f1fb:	0f b6 c0             	movzbl %al,%eax
    f1fe:	01 c2                	add    %eax,%edx
    f200:	8b 45 08             	mov    0x8(%ebp),%eax
    f203:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    f209:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f20e:	5d                   	pop    %ebp
    f20f:	c3                   	ret    

0000f210 <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f210:	55                   	push   %ebp
    f211:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    f213:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f217:	74 07                	je     f220 <readChunk_sRGB+0x10>
    f219:	b8 62 00 00 00       	mov    $0x62,%eax
    f21e:	eb 24                	jmp    f244 <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    f220:	8b 45 08             	mov    0x8(%ebp),%eax
    f223:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    f22a:	00 00 00 
  info->srgb_intent = data[0];
    f22d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f230:	0f b6 00             	movzbl (%eax),%eax
    f233:	0f b6 d0             	movzbl %al,%edx
    f236:	8b 45 08             	mov    0x8(%ebp),%eax
    f239:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    f23f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f244:	5d                   	pop    %ebp
    f245:	c3                   	ret    

0000f246 <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f246:	55                   	push   %ebp
    f247:	89 e5                	mov    %esp,%ebp
    f249:	53                   	push   %ebx
    f24a:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    f24d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    f254:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f25b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f25e:	8b 10                	mov    (%eax),%edx
    f260:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f263:	8b 50 04             	mov    0x4(%eax),%edx
    f266:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f269:	8b 50 08             	mov    0x8(%eax),%edx
    f26c:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f26f:	8b 50 0c             	mov    0xc(%eax),%edx
    f272:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f275:	8b 50 10             	mov    0x10(%eax),%edx
    f278:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f27b:	8b 40 14             	mov    0x14(%eax),%eax
    f27e:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    f281:	8b 45 08             	mov    0x8(%ebp),%eax
    f284:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    f28b:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    f28e:	8b 45 08             	mov    0x8(%ebp),%eax
    f291:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f297:	85 c0                	test   %eax,%eax
    f299:	74 0e                	je     f2a9 <readChunk_iCCP+0x63>
    f29b:	83 ec 0c             	sub    $0xc,%esp
    f29e:	ff 75 08             	pushl  0x8(%ebp)
    f2a1:	e8 ca a6 ff ff       	call   9970 <lodepng_clear_icc>
    f2a6:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f2a9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f2b0:	eb 04                	jmp    f2b6 <readChunk_iCCP+0x70>
    f2b2:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f2b6:	8b 45 14             	mov    0x14(%ebp),%eax
    f2b9:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f2bc:	73 0f                	jae    f2cd <readChunk_iCCP+0x87>
    f2be:	8b 55 10             	mov    0x10(%ebp),%edx
    f2c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2c4:	01 d0                	add    %edx,%eax
    f2c6:	0f b6 00             	movzbl (%eax),%eax
    f2c9:	84 c0                	test   %al,%al
    f2cb:	75 e5                	jne    f2b2 <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    f2cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2d0:	8d 50 02             	lea    0x2(%eax),%edx
    f2d3:	8b 45 14             	mov    0x14(%ebp),%eax
    f2d6:	39 c2                	cmp    %eax,%edx
    f2d8:	72 0a                	jb     f2e4 <readChunk_iCCP+0x9e>
    f2da:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f2df:	e9 46 01 00 00       	jmp    f42a <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    f2e4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f2e8:	74 06                	je     f2f0 <readChunk_iCCP+0xaa>
    f2ea:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f2ee:	76 0a                	jbe    f2fa <readChunk_iCCP+0xb4>
    f2f0:	b8 59 00 00 00       	mov    $0x59,%eax
    f2f5:	e9 30 01 00 00       	jmp    f42a <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    f2fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2fd:	83 c0 01             	add    $0x1,%eax
    f300:	83 ec 0c             	sub    $0xc,%esp
    f303:	50                   	push   %eax
    f304:	e8 1a 40 ff ff       	call   3323 <lodepng_malloc>
    f309:	83 c4 10             	add    $0x10,%esp
    f30c:	89 c2                	mov    %eax,%edx
    f30e:	8b 45 08             	mov    0x8(%ebp),%eax
    f311:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    f317:	8b 45 08             	mov    0x8(%ebp),%eax
    f31a:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f320:	85 c0                	test   %eax,%eax
    f322:	75 0a                	jne    f32e <readChunk_iCCP+0xe8>
    f324:	b8 53 00 00 00       	mov    $0x53,%eax
    f329:	e9 fc 00 00 00       	jmp    f42a <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    f32e:	8b 45 08             	mov    0x8(%ebp),%eax
    f331:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f337:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f33a:	01 d0                	add    %edx,%eax
    f33c:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    f33f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f346:	eb 1f                	jmp    f367 <readChunk_iCCP+0x121>
    f348:	8b 45 08             	mov    0x8(%ebp),%eax
    f34b:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f351:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f354:	01 d0                	add    %edx,%eax
    f356:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f359:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f35c:	01 ca                	add    %ecx,%edx
    f35e:	0f b6 12             	movzbl (%edx),%edx
    f361:	88 10                	mov    %dl,(%eax)
    f363:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f367:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f36a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f36d:	75 d9                	jne    f348 <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    f36f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f372:	8d 50 01             	lea    0x1(%eax),%edx
    f375:	8b 45 10             	mov    0x10(%ebp),%eax
    f378:	01 d0                	add    %edx,%eax
    f37a:	0f b6 00             	movzbl (%eax),%eax
    f37d:	84 c0                	test   %al,%al
    f37f:	74 0a                	je     f38b <readChunk_iCCP+0x145>
    f381:	b8 48 00 00 00       	mov    $0x48,%eax
    f386:	e9 9f 00 00 00       	jmp    f42a <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    f38b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f38e:	83 c0 02             	add    $0x2,%eax
    f391:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    f394:	8b 45 14             	mov    0x14(%ebp),%eax
    f397:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f39a:	76 0a                	jbe    f3a6 <readChunk_iCCP+0x160>
    f39c:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f3a1:	e9 84 00 00 00       	jmp    f42a <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    f3a6:	8b 45 14             	mov    0x14(%ebp),%eax
    f3a9:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f3ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    f3af:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3b2:	8b 40 34             	mov    0x34(%eax),%eax
    f3b5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    f3b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f3bb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f3be:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f3c1:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    f3c4:	8b 55 08             	mov    0x8(%ebp),%edx
    f3c7:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    f3cd:	83 ec 08             	sub    $0x8,%esp
    f3d0:	8d 55 cc             	lea    -0x34(%ebp),%edx
    f3d3:	52                   	push   %edx
    f3d4:	50                   	push   %eax
    f3d5:	53                   	push   %ebx
    f3d6:	6a 00                	push   $0x0
    f3d8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    f3db:	50                   	push   %eax
    f3dc:	51                   	push   %ecx
    f3dd:	e8 fc 89 ff ff       	call   7dde <zlib_decompress>
    f3e2:	83 c4 20             	add    $0x20,%esp
    f3e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    f3e8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f3ec:	74 11                	je     f3ff <readChunk_iCCP+0x1b9>
    f3ee:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    f3f1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f3f4:	39 c2                	cmp    %eax,%edx
    f3f6:	7d 07                	jge    f3ff <readChunk_iCCP+0x1b9>
    f3f8:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    f3ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f402:	89 c2                	mov    %eax,%edx
    f404:	8b 45 08             	mov    0x8(%ebp),%eax
    f407:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    f40d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f411:	75 14                	jne    f427 <readChunk_iCCP+0x1e1>
    f413:	8b 45 08             	mov    0x8(%ebp),%eax
    f416:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    f41c:	85 c0                	test   %eax,%eax
    f41e:	75 07                	jne    f427 <readChunk_iCCP+0x1e1>
    f420:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    f427:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f42a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f42d:	c9                   	leave  
    f42e:	c3                   	ret    

0000f42f <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    f42f:	55                   	push   %ebp
    f430:	89 e5                	mov    %esp,%ebp
    f432:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    f435:	8b 55 0c             	mov    0xc(%ebp),%edx
    f438:	8b 45 10             	mov    0x10(%ebp),%eax
    f43b:	01 d0                	add    %edx,%eax
    f43d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    f440:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    f447:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    f44e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f451:	83 c0 04             	add    $0x4,%eax
    f454:	3b 45 14             	cmp    0x14(%ebp),%eax
    f457:	7e 0a                	jle    f463 <lodepng_inspect_chunk+0x34>
    f459:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f45e:	e9 43 03 00 00       	jmp    f7a6 <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    f463:	ff 75 ec             	pushl  -0x14(%ebp)
    f466:	e8 3a 8e ff ff       	call   82a5 <lodepng_chunk_length>
    f46b:	83 c4 04             	add    $0x4,%esp
    f46e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    f471:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f474:	85 c0                	test   %eax,%eax
    f476:	79 0a                	jns    f482 <lodepng_inspect_chunk+0x53>
    f478:	b8 3f 00 00 00       	mov    $0x3f,%eax
    f47d:	e9 24 03 00 00       	jmp    f7a6 <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
    f482:	ff 75 ec             	pushl  -0x14(%ebp)
    f485:	e8 53 8f ff ff       	call   83dd <lodepng_chunk_data_const>
    f48a:	83 c4 04             	add    $0x4,%esp
    f48d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
    f490:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f493:	8d 50 04             	lea    0x4(%eax),%edx
    f496:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f499:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    f49c:	8b 55 14             	mov    0x14(%ebp),%edx
    f49f:	8b 45 10             	mov    0x10(%ebp),%eax
    f4a2:	01 d0                	add    %edx,%eax
    f4a4:	39 c1                	cmp    %eax,%ecx
    f4a6:	76 0a                	jbe    f4b2 <lodepng_inspect_chunk+0x83>
    f4a8:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f4ad:	e9 f4 02 00 00       	jmp    f7a6 <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    f4b2:	68 48 a0 01 00       	push   $0x1a048
    f4b7:	ff 75 ec             	pushl  -0x14(%ebp)
    f4ba:	e8 33 8e ff ff       	call   82f2 <lodepng_chunk_type_equals>
    f4bf:	83 c4 08             	add    $0x8,%esp
    f4c2:	84 c0                	test   %al,%al
    f4c4:	74 24                	je     f4ea <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    f4c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f4c9:	8b 55 08             	mov    0x8(%ebp),%edx
    f4cc:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f4d2:	83 ec 04             	sub    $0x4,%esp
    f4d5:	50                   	push   %eax
    f4d6:	ff 75 e4             	pushl  -0x1c(%ebp)
    f4d9:	52                   	push   %edx
    f4da:	e8 5b ee ff ff       	call   e33a <readChunk_PLTE>
    f4df:	83 c4 10             	add    $0x10,%esp
    f4e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f4e5:	e9 8a 02 00 00       	jmp    f774 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    f4ea:	83 ec 08             	sub    $0x8,%esp
    f4ed:	68 4d a0 01 00       	push   $0x1a04d
    f4f2:	ff 75 ec             	pushl  -0x14(%ebp)
    f4f5:	e8 f8 8d ff ff       	call   82f2 <lodepng_chunk_type_equals>
    f4fa:	83 c4 10             	add    $0x10,%esp
    f4fd:	84 c0                	test   %al,%al
    f4ff:	74 24                	je     f525 <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    f501:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f504:	8b 55 08             	mov    0x8(%ebp),%edx
    f507:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f50d:	83 ec 04             	sub    $0x4,%esp
    f510:	50                   	push   %eax
    f511:	ff 75 e4             	pushl  -0x1c(%ebp)
    f514:	52                   	push   %edx
    f515:	e8 40 ef ff ff       	call   e45a <readChunk_tRNS>
    f51a:	83 c4 10             	add    $0x10,%esp
    f51d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f520:	e9 4f 02 00 00       	jmp    f774 <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    f525:	83 ec 08             	sub    $0x8,%esp
    f528:	68 52 a0 01 00       	push   $0x1a052
    f52d:	ff 75 ec             	pushl  -0x14(%ebp)
    f530:	e8 bd 8d ff ff       	call   82f2 <lodepng_chunk_type_equals>
    f535:	83 c4 10             	add    $0x10,%esp
    f538:	84 c0                	test   %al,%al
    f53a:	74 24                	je     f560 <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
    f53c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f53f:	8b 55 08             	mov    0x8(%ebp),%edx
    f542:	81 c2 98 00 00 00    	add    $0x98,%edx
    f548:	83 ec 04             	sub    $0x4,%esp
    f54b:	50                   	push   %eax
    f54c:	ff 75 e4             	pushl  -0x1c(%ebp)
    f54f:	52                   	push   %edx
    f550:	e8 68 f0 ff ff       	call   e5bd <readChunk_bKGD>
    f555:	83 c4 10             	add    $0x10,%esp
    f558:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f55b:	e9 14 02 00 00       	jmp    f774 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    f560:	83 ec 08             	sub    $0x8,%esp
    f563:	68 57 a0 01 00       	push   $0x1a057
    f568:	ff 75 ec             	pushl  -0x14(%ebp)
    f56b:	e8 82 8d ff ff       	call   82f2 <lodepng_chunk_type_equals>
    f570:	83 c4 10             	add    $0x10,%esp
    f573:	84 c0                	test   %al,%al
    f575:	74 24                	je     f59b <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
    f577:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f57a:	8b 55 08             	mov    0x8(%ebp),%edx
    f57d:	81 c2 98 00 00 00    	add    $0x98,%edx
    f583:	83 ec 04             	sub    $0x4,%esp
    f586:	50                   	push   %eax
    f587:	ff 75 e4             	pushl  -0x1c(%ebp)
    f58a:	52                   	push   %edx
    f58b:	e8 b0 f1 ff ff       	call   e740 <readChunk_tEXt>
    f590:	83 c4 10             	add    $0x10,%esp
    f593:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f596:	e9 d9 01 00 00       	jmp    f774 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    f59b:	83 ec 08             	sub    $0x8,%esp
    f59e:	68 5c a0 01 00       	push   $0x1a05c
    f5a3:	ff 75 ec             	pushl  -0x14(%ebp)
    f5a6:	e8 47 8d ff ff       	call   82f2 <lodepng_chunk_type_equals>
    f5ab:	83 c4 10             	add    $0x10,%esp
    f5ae:	84 c0                	test   %al,%al
    f5b0:	74 25                	je     f5d7 <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    f5b2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f5b5:	8b 45 08             	mov    0x8(%ebp),%eax
    f5b8:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f5bb:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f5c1:	52                   	push   %edx
    f5c2:	ff 75 e4             	pushl  -0x1c(%ebp)
    f5c5:	50                   	push   %eax
    f5c6:	51                   	push   %ecx
    f5c7:	e8 c0 f2 ff ff       	call   e88c <readChunk_zTXt>
    f5cc:	83 c4 10             	add    $0x10,%esp
    f5cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f5d2:	e9 9d 01 00 00       	jmp    f774 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    f5d7:	83 ec 08             	sub    $0x8,%esp
    f5da:	68 61 a0 01 00       	push   $0x1a061
    f5df:	ff 75 ec             	pushl  -0x14(%ebp)
    f5e2:	e8 0b 8d ff ff       	call   82f2 <lodepng_chunk_type_equals>
    f5e7:	83 c4 10             	add    $0x10,%esp
    f5ea:	84 c0                	test   %al,%al
    f5ec:	74 25                	je     f613 <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    f5ee:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f5f1:	8b 45 08             	mov    0x8(%ebp),%eax
    f5f4:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f5f7:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f5fd:	52                   	push   %edx
    f5fe:	ff 75 e4             	pushl  -0x1c(%ebp)
    f601:	50                   	push   %eax
    f602:	51                   	push   %ecx
    f603:	e8 40 f4 ff ff       	call   ea48 <readChunk_iTXt>
    f608:	83 c4 10             	add    $0x10,%esp
    f60b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f60e:	e9 61 01 00 00       	jmp    f774 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    f613:	83 ec 08             	sub    $0x8,%esp
    f616:	68 66 a0 01 00       	push   $0x1a066
    f61b:	ff 75 ec             	pushl  -0x14(%ebp)
    f61e:	e8 cf 8c ff ff       	call   82f2 <lodepng_chunk_type_equals>
    f623:	83 c4 10             	add    $0x10,%esp
    f626:	84 c0                	test   %al,%al
    f628:	74 24                	je     f64e <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
    f62a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f62d:	8b 55 08             	mov    0x8(%ebp),%edx
    f630:	81 c2 98 00 00 00    	add    $0x98,%edx
    f636:	83 ec 04             	sub    $0x4,%esp
    f639:	50                   	push   %eax
    f63a:	ff 75 e4             	pushl  -0x1c(%ebp)
    f63d:	52                   	push   %edx
    f63e:	e8 5b f7 ff ff       	call   ed9e <readChunk_tIME>
    f643:	83 c4 10             	add    $0x10,%esp
    f646:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f649:	e9 26 01 00 00       	jmp    f774 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    f64e:	83 ec 08             	sub    $0x8,%esp
    f651:	68 6b a0 01 00       	push   $0x1a06b
    f656:	ff 75 ec             	pushl  -0x14(%ebp)
    f659:	e8 94 8c ff ff       	call   82f2 <lodepng_chunk_type_equals>
    f65e:	83 c4 10             	add    $0x10,%esp
    f661:	84 c0                	test   %al,%al
    f663:	74 24                	je     f689 <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
    f665:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f668:	8b 55 08             	mov    0x8(%ebp),%edx
    f66b:	81 c2 98 00 00 00    	add    $0x98,%edx
    f671:	83 ec 04             	sub    $0x4,%esp
    f674:	50                   	push   %eax
    f675:	ff 75 e4             	pushl  -0x1c(%ebp)
    f678:	52                   	push   %edx
    f679:	e8 c0 f7 ff ff       	call   ee3e <readChunk_pHYs>
    f67e:	83 c4 10             	add    $0x10,%esp
    f681:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f684:	e9 eb 00 00 00       	jmp    f774 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    f689:	83 ec 08             	sub    $0x8,%esp
    f68c:	68 70 a0 01 00       	push   $0x1a070
    f691:	ff 75 ec             	pushl  -0x14(%ebp)
    f694:	e8 59 8c ff ff       	call   82f2 <lodepng_chunk_type_equals>
    f699:	83 c4 10             	add    $0x10,%esp
    f69c:	84 c0                	test   %al,%al
    f69e:	74 24                	je     f6c4 <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
    f6a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f6a3:	8b 55 08             	mov    0x8(%ebp),%edx
    f6a6:	81 c2 98 00 00 00    	add    $0x98,%edx
    f6ac:	83 ec 04             	sub    $0x4,%esp
    f6af:	50                   	push   %eax
    f6b0:	ff 75 e4             	pushl  -0x1c(%ebp)
    f6b3:	52                   	push   %edx
    f6b4:	e8 54 f8 ff ff       	call   ef0d <readChunk_gAMA>
    f6b9:	83 c4 10             	add    $0x10,%esp
    f6bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6bf:	e9 b0 00 00 00       	jmp    f774 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    f6c4:	83 ec 08             	sub    $0x8,%esp
    f6c7:	68 75 a0 01 00       	push   $0x1a075
    f6cc:	ff 75 ec             	pushl  -0x14(%ebp)
    f6cf:	e8 1e 8c ff ff       	call   82f2 <lodepng_chunk_type_equals>
    f6d4:	83 c4 10             	add    $0x10,%esp
    f6d7:	84 c0                	test   %al,%al
    f6d9:	74 21                	je     f6fc <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
    f6db:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f6de:	8b 55 08             	mov    0x8(%ebp),%edx
    f6e1:	81 c2 98 00 00 00    	add    $0x98,%edx
    f6e7:	83 ec 04             	sub    $0x4,%esp
    f6ea:	50                   	push   %eax
    f6eb:	ff 75 e4             	pushl  -0x1c(%ebp)
    f6ee:	52                   	push   %edx
    f6ef:	e8 88 f8 ff ff       	call   ef7c <readChunk_cHRM>
    f6f4:	83 c4 10             	add    $0x10,%esp
    f6f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6fa:	eb 78                	jmp    f774 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    f6fc:	83 ec 08             	sub    $0x8,%esp
    f6ff:	68 7a a0 01 00       	push   $0x1a07a
    f704:	ff 75 ec             	pushl  -0x14(%ebp)
    f707:	e8 e6 8b ff ff       	call   82f2 <lodepng_chunk_type_equals>
    f70c:	83 c4 10             	add    $0x10,%esp
    f70f:	84 c0                	test   %al,%al
    f711:	74 21                	je     f734 <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
    f713:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f716:	8b 55 08             	mov    0x8(%ebp),%edx
    f719:	81 c2 98 00 00 00    	add    $0x98,%edx
    f71f:	83 ec 04             	sub    $0x4,%esp
    f722:	50                   	push   %eax
    f723:	ff 75 e4             	pushl  -0x1c(%ebp)
    f726:	52                   	push   %edx
    f727:	e8 e4 fa ff ff       	call   f210 <readChunk_sRGB>
    f72c:	83 c4 10             	add    $0x10,%esp
    f72f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f732:	eb 40                	jmp    f774 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    f734:	83 ec 08             	sub    $0x8,%esp
    f737:	68 7f a0 01 00       	push   $0x1a07f
    f73c:	ff 75 ec             	pushl  -0x14(%ebp)
    f73f:	e8 ae 8b ff ff       	call   82f2 <lodepng_chunk_type_equals>
    f744:	83 c4 10             	add    $0x10,%esp
    f747:	84 c0                	test   %al,%al
    f749:	74 22                	je     f76d <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    f74b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f74e:	8b 45 08             	mov    0x8(%ebp),%eax
    f751:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f754:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f75a:	52                   	push   %edx
    f75b:	ff 75 e4             	pushl  -0x1c(%ebp)
    f75e:	50                   	push   %eax
    f75f:	51                   	push   %ecx
    f760:	e8 e1 fa ff ff       	call   f246 <readChunk_iCCP>
    f765:	83 c4 10             	add    $0x10,%esp
    f768:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f76b:	eb 07                	jmp    f774 <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
    f76d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
    f774:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f778:	75 29                	jne    f7a3 <lodepng_inspect_chunk+0x374>
    f77a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f77e:	75 23                	jne    f7a3 <lodepng_inspect_chunk+0x374>
    f780:	8b 45 08             	mov    0x8(%ebp),%eax
    f783:	8b 40 18             	mov    0x18(%eax),%eax
    f786:	85 c0                	test   %eax,%eax
    f788:	75 19                	jne    f7a3 <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
    f78a:	83 ec 0c             	sub    $0xc,%esp
    f78d:	ff 75 ec             	pushl  -0x14(%ebp)
    f790:	e8 53 8c ff ff       	call   83e8 <lodepng_chunk_check_crc>
    f795:	83 c4 10             	add    $0x10,%esp
    f798:	85 c0                	test   %eax,%eax
    f79a:	74 07                	je     f7a3 <lodepng_inspect_chunk+0x374>
    f79c:	b8 39 00 00 00       	mov    $0x39,%eax
    f7a1:	eb 03                	jmp    f7a6 <lodepng_inspect_chunk+0x377>
  }

  return error;
    f7a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    f7a6:	c9                   	leave  
    f7a7:	c3                   	ret    

0000f7a8 <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
    f7a8:	55                   	push   %ebp
    f7a9:	89 e5                	mov    %esp,%ebp
    f7ab:	56                   	push   %esi
    f7ac:	53                   	push   %ebx
    f7ad:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
    f7b0:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
    f7b4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
    f7bb:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
    f7c2:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    f7c9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
    f7d0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
    f7d7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
    f7de:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
    f7e5:	8b 45 08             	mov    0x8(%ebp),%eax
    f7e8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
    f7ee:	8b 45 10             	mov    0x10(%ebp),%eax
    f7f1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    f7f7:	8b 45 10             	mov    0x10(%ebp),%eax
    f7fa:	8b 10                	mov    (%eax),%edx
    f7fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f7ff:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
    f801:	83 ec 0c             	sub    $0xc,%esp
    f804:	ff 75 1c             	pushl  0x1c(%ebp)
    f807:	ff 75 18             	pushl  0x18(%ebp)
    f80a:	ff 75 14             	pushl  0x14(%ebp)
    f80d:	ff 75 10             	pushl  0x10(%ebp)
    f810:	ff 75 0c             	pushl  0xc(%ebp)
    f813:	e8 d3 da ff ff       	call   d2eb <lodepng_inspect>
    f818:	83 c4 20             	add    $0x20,%esp
    f81b:	89 c2                	mov    %eax,%edx
    f81d:	8b 45 14             	mov    0x14(%ebp),%eax
    f820:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
    f826:	8b 45 14             	mov    0x14(%ebp),%eax
    f829:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    f82f:	85 c0                	test   %eax,%eax
    f831:	0f 85 24 0a 00 00    	jne    1025b <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
    f837:	8b 45 14             	mov    0x14(%ebp),%eax
    f83a:	8d 58 78             	lea    0x78(%eax),%ebx
    f83d:	8b 45 14             	mov    0x14(%ebp),%eax
    f840:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
    f846:	8b 45 10             	mov    0x10(%ebp),%eax
    f849:	8b 10                	mov    (%eax),%edx
    f84b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f84e:	8b 00                	mov    (%eax),%eax
    f850:	53                   	push   %ebx
    f851:	51                   	push   %ecx
    f852:	52                   	push   %edx
    f853:	50                   	push   %eax
    f854:	e8 76 97 ff ff       	call   8fcf <lodepng_pixel_overflow>
    f859:	83 c4 10             	add    $0x10,%esp
    f85c:	85 c0                	test   %eax,%eax
    f85e:	74 12                	je     f872 <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
    f860:	8b 45 14             	mov    0x14(%ebp),%eax
    f863:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
    f86a:	00 00 00 
    f86d:	e9 ea 09 00 00       	jmp    1025c <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
    f872:	83 ec 0c             	sub    $0xc,%esp
    f875:	ff 75 1c             	pushl  0x1c(%ebp)
    f878:	e8 a6 3a ff ff       	call   3323 <lodepng_malloc>
    f87d:	83 c4 10             	add    $0x10,%esp
    f880:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
    f883:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    f887:	75 12                	jne    f89b <decodeGeneric+0xf3>
    f889:	8b 45 14             	mov    0x14(%ebp),%eax
    f88c:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
    f893:	00 00 00 
    f896:	e9 c1 09 00 00       	jmp    1025c <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
    f89b:	8b 45 18             	mov    0x18(%ebp),%eax
    f89e:	83 c0 21             	add    $0x21,%eax
    f8a1:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    f8a4:	e9 81 06 00 00       	jmp    ff2a <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
    f8a9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f8ac:	8b 45 18             	mov    0x18(%ebp),%eax
    f8af:	29 c2                	sub    %eax,%edx
    f8b1:	89 d0                	mov    %edx,%eax
    f8b3:	83 c0 0c             	add    $0xc,%eax
    f8b6:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f8b9:	7f 08                	jg     f8c3 <decodeGeneric+0x11b>
    f8bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f8be:	3b 45 18             	cmp    0x18(%ebp),%eax
    f8c1:	73 20                	jae    f8e3 <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f8c3:	8b 45 14             	mov    0x14(%ebp),%eax
    f8c6:	8b 40 20             	mov    0x20(%eax),%eax
    f8c9:	85 c0                	test   %eax,%eax
    f8cb:	0f 85 72 06 00 00    	jne    ff43 <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
    f8d1:	8b 45 14             	mov    0x14(%ebp),%eax
    f8d4:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
    f8db:	00 00 00 
    f8de:	e9 6a 06 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    f8e3:	83 ec 0c             	sub    $0xc,%esp
    f8e6:	ff 75 f0             	pushl  -0x10(%ebp)
    f8e9:	e8 b7 89 ff ff       	call   82a5 <lodepng_chunk_length>
    f8ee:	83 c4 10             	add    $0x10,%esp
    f8f1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
    f8f4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f8f7:	85 c0                	test   %eax,%eax
    f8f9:	79 20                	jns    f91b <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f8fb:	8b 45 14             	mov    0x14(%ebp),%eax
    f8fe:	8b 40 20             	mov    0x20(%eax),%eax
    f901:	85 c0                	test   %eax,%eax
    f903:	0f 85 3d 06 00 00    	jne    ff46 <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
    f909:	8b 45 14             	mov    0x14(%ebp),%eax
    f90c:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
    f913:	00 00 00 
    f916:	e9 32 06 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
    f91b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f91e:	8b 45 18             	mov    0x18(%ebp),%eax
    f921:	29 c2                	sub    %eax,%edx
    f923:	89 d0                	mov    %edx,%eax
    f925:	89 c2                	mov    %eax,%edx
    f927:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f92a:	01 d0                	add    %edx,%eax
    f92c:	83 c0 0c             	add    $0xc,%eax
    f92f:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f932:	7f 10                	jg     f944 <decodeGeneric+0x19c>
    f934:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f937:	8d 50 0c             	lea    0xc(%eax),%edx
    f93a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f93d:	01 d0                	add    %edx,%eax
    f93f:	3b 45 18             	cmp    0x18(%ebp),%eax
    f942:	73 12                	jae    f956 <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    f944:	8b 45 14             	mov    0x14(%ebp),%eax
    f947:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
    f94e:	00 00 00 
    f951:	e9 f7 05 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
    f956:	83 ec 0c             	sub    $0xc,%esp
    f959:	ff 75 f0             	pushl  -0x10(%ebp)
    f95c:	e8 7c 8a ff ff       	call   83dd <lodepng_chunk_data_const>
    f961:	83 c4 10             	add    $0x10,%esp
    f964:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
    f967:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
    f96e:	83 ec 08             	sub    $0x8,%esp
    f971:	68 84 a0 01 00       	push   $0x1a084
    f976:	ff 75 f0             	pushl  -0x10(%ebp)
    f979:	e8 74 89 ff ff       	call   82f2 <lodepng_chunk_type_equals>
    f97e:	83 c4 10             	add    $0x10,%esp
    f981:	84 c0                	test   %al,%al
    f983:	74 79                	je     f9fe <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
    f985:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f988:	83 ec 04             	sub    $0x4,%esp
    f98b:	8d 55 bc             	lea    -0x44(%ebp),%edx
    f98e:	52                   	push   %edx
    f98f:	50                   	push   %eax
    f990:	ff 75 ec             	pushl  -0x14(%ebp)
    f993:	e8 4f 3a ff ff       	call   33e7 <lodepng_addofl>
    f998:	83 c4 10             	add    $0x10,%esp
    f99b:	85 c0                	test   %eax,%eax
    f99d:	74 12                	je     f9b1 <decodeGeneric+0x209>
    f99f:	8b 45 14             	mov    0x14(%ebp),%eax
    f9a2:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    f9a9:	00 00 00 
    f9ac:	e9 9c 05 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
    f9b1:	8b 45 bc             	mov    -0x44(%ebp),%eax
    f9b4:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f9b7:	7e 13                	jle    f9cc <decodeGeneric+0x224>
    f9b9:	8b 45 14             	mov    0x14(%ebp),%eax
    f9bc:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    f9c3:	00 00 00 
    f9c6:	90                   	nop
    f9c7:	e9 81 05 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
    f9cc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9cf:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    f9d2:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f9d5:	01 ca                	add    %ecx,%edx
    f9d7:	83 ec 04             	sub    $0x4,%esp
    f9da:	50                   	push   %eax
    f9db:	ff 75 d0             	pushl  -0x30(%ebp)
    f9de:	52                   	push   %edx
    f9df:	e8 7d 39 ff ff       	call   3361 <lodepng_memcpy>
    f9e4:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
    f9e7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f9ea:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9ed:	01 d0                	add    %edx,%eax
    f9ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
    f9f2:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
    f9f9:	e9 db 04 00 00       	jmp    fed9 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
    f9fe:	83 ec 08             	sub    $0x8,%esp
    fa01:	68 89 a0 01 00       	push   $0x1a089
    fa06:	ff 75 f0             	pushl  -0x10(%ebp)
    fa09:	e8 e4 88 ff ff       	call   82f2 <lodepng_chunk_type_equals>
    fa0e:	83 c4 10             	add    $0x10,%esp
    fa11:	84 c0                	test   %al,%al
    fa13:	74 09                	je     fa1e <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
    fa15:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
    fa19:	e9 bb 04 00 00       	jmp    fed9 <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    fa1e:	83 ec 08             	sub    $0x8,%esp
    fa21:	68 48 a0 01 00       	push   $0x1a048
    fa26:	ff 75 f0             	pushl  -0x10(%ebp)
    fa29:	e8 c4 88 ff ff       	call   82f2 <lodepng_chunk_type_equals>
    fa2e:	83 c4 10             	add    $0x10,%esp
    fa31:	84 c0                	test   %al,%al
    fa33:	74 44                	je     fa79 <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    fa35:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa38:	8b 55 14             	mov    0x14(%ebp),%edx
    fa3b:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fa41:	83 ec 04             	sub    $0x4,%esp
    fa44:	50                   	push   %eax
    fa45:	ff 75 d0             	pushl  -0x30(%ebp)
    fa48:	52                   	push   %edx
    fa49:	e8 ec e8 ff ff       	call   e33a <readChunk_PLTE>
    fa4e:	83 c4 10             	add    $0x10,%esp
    fa51:	89 c2                	mov    %eax,%edx
    fa53:	8b 45 14             	mov    0x14(%ebp),%eax
    fa56:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fa5c:	8b 45 14             	mov    0x14(%ebp),%eax
    fa5f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fa65:	85 c0                	test   %eax,%eax
    fa67:	0f 85 dc 04 00 00    	jne    ff49 <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
    fa6d:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
    fa74:	e9 60 04 00 00       	jmp    fed9 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fa79:	83 ec 08             	sub    $0x8,%esp
    fa7c:	68 4d a0 01 00       	push   $0x1a04d
    fa81:	ff 75 f0             	pushl  -0x10(%ebp)
    fa84:	e8 69 88 ff ff       	call   82f2 <lodepng_chunk_type_equals>
    fa89:	83 c4 10             	add    $0x10,%esp
    fa8c:	84 c0                	test   %al,%al
    fa8e:	74 3d                	je     facd <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    fa90:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa93:	8b 55 14             	mov    0x14(%ebp),%edx
    fa96:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fa9c:	83 ec 04             	sub    $0x4,%esp
    fa9f:	50                   	push   %eax
    faa0:	ff 75 d0             	pushl  -0x30(%ebp)
    faa3:	52                   	push   %edx
    faa4:	e8 b1 e9 ff ff       	call   e45a <readChunk_tRNS>
    faa9:	83 c4 10             	add    $0x10,%esp
    faac:	89 c2                	mov    %eax,%edx
    faae:	8b 45 14             	mov    0x14(%ebp),%eax
    fab1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fab7:	8b 45 14             	mov    0x14(%ebp),%eax
    faba:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fac0:	85 c0                	test   %eax,%eax
    fac2:	0f 84 11 04 00 00    	je     fed9 <decodeGeneric+0x731>
    fac8:	e9 80 04 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    facd:	83 ec 08             	sub    $0x8,%esp
    fad0:	68 52 a0 01 00       	push   $0x1a052
    fad5:	ff 75 f0             	pushl  -0x10(%ebp)
    fad8:	e8 15 88 ff ff       	call   82f2 <lodepng_chunk_type_equals>
    fadd:	83 c4 10             	add    $0x10,%esp
    fae0:	84 c0                	test   %al,%al
    fae2:	74 3d                	je     fb21 <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
    fae4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fae7:	8b 55 14             	mov    0x14(%ebp),%edx
    faea:	81 c2 98 00 00 00    	add    $0x98,%edx
    faf0:	83 ec 04             	sub    $0x4,%esp
    faf3:	50                   	push   %eax
    faf4:	ff 75 d0             	pushl  -0x30(%ebp)
    faf7:	52                   	push   %edx
    faf8:	e8 c0 ea ff ff       	call   e5bd <readChunk_bKGD>
    fafd:	83 c4 10             	add    $0x10,%esp
    fb00:	89 c2                	mov    %eax,%edx
    fb02:	8b 45 14             	mov    0x14(%ebp),%eax
    fb05:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fb0b:	8b 45 14             	mov    0x14(%ebp),%eax
    fb0e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb14:	85 c0                	test   %eax,%eax
    fb16:	0f 84 bd 03 00 00    	je     fed9 <decodeGeneric+0x731>
    fb1c:	e9 2c 04 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    fb21:	83 ec 08             	sub    $0x8,%esp
    fb24:	68 57 a0 01 00       	push   $0x1a057
    fb29:	ff 75 f0             	pushl  -0x10(%ebp)
    fb2c:	e8 c1 87 ff ff       	call   82f2 <lodepng_chunk_type_equals>
    fb31:	83 c4 10             	add    $0x10,%esp
    fb34:	84 c0                	test   %al,%al
    fb36:	74 4b                	je     fb83 <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
    fb38:	8b 45 14             	mov    0x14(%ebp),%eax
    fb3b:	8b 40 28             	mov    0x28(%eax),%eax
    fb3e:	85 c0                	test   %eax,%eax
    fb40:	0f 84 93 03 00 00    	je     fed9 <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
    fb46:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb49:	8b 55 14             	mov    0x14(%ebp),%edx
    fb4c:	81 c2 98 00 00 00    	add    $0x98,%edx
    fb52:	83 ec 04             	sub    $0x4,%esp
    fb55:	50                   	push   %eax
    fb56:	ff 75 d0             	pushl  -0x30(%ebp)
    fb59:	52                   	push   %edx
    fb5a:	e8 e1 eb ff ff       	call   e740 <readChunk_tEXt>
    fb5f:	83 c4 10             	add    $0x10,%esp
    fb62:	89 c2                	mov    %eax,%edx
    fb64:	8b 45 14             	mov    0x14(%ebp),%eax
    fb67:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fb6d:	8b 45 14             	mov    0x14(%ebp),%eax
    fb70:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb76:	85 c0                	test   %eax,%eax
    fb78:	0f 84 5b 03 00 00    	je     fed9 <decodeGeneric+0x731>
    fb7e:	e9 ca 03 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    fb83:	83 ec 08             	sub    $0x8,%esp
    fb86:	68 5c a0 01 00       	push   $0x1a05c
    fb8b:	ff 75 f0             	pushl  -0x10(%ebp)
    fb8e:	e8 5f 87 ff ff       	call   82f2 <lodepng_chunk_type_equals>
    fb93:	83 c4 10             	add    $0x10,%esp
    fb96:	84 c0                	test   %al,%al
    fb98:	74 4c                	je     fbe6 <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
    fb9a:	8b 45 14             	mov    0x14(%ebp),%eax
    fb9d:	8b 40 28             	mov    0x28(%eax),%eax
    fba0:	85 c0                	test   %eax,%eax
    fba2:	0f 84 31 03 00 00    	je     fed9 <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    fba8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fbab:	8b 45 14             	mov    0x14(%ebp),%eax
    fbae:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fbb1:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fbb7:	52                   	push   %edx
    fbb8:	ff 75 d0             	pushl  -0x30(%ebp)
    fbbb:	50                   	push   %eax
    fbbc:	51                   	push   %ecx
    fbbd:	e8 ca ec ff ff       	call   e88c <readChunk_zTXt>
    fbc2:	83 c4 10             	add    $0x10,%esp
    fbc5:	89 c2                	mov    %eax,%edx
    fbc7:	8b 45 14             	mov    0x14(%ebp),%eax
    fbca:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fbd0:	8b 45 14             	mov    0x14(%ebp),%eax
    fbd3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fbd9:	85 c0                	test   %eax,%eax
    fbdb:	0f 84 f8 02 00 00    	je     fed9 <decodeGeneric+0x731>
    fbe1:	e9 67 03 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    fbe6:	83 ec 08             	sub    $0x8,%esp
    fbe9:	68 61 a0 01 00       	push   $0x1a061
    fbee:	ff 75 f0             	pushl  -0x10(%ebp)
    fbf1:	e8 fc 86 ff ff       	call   82f2 <lodepng_chunk_type_equals>
    fbf6:	83 c4 10             	add    $0x10,%esp
    fbf9:	84 c0                	test   %al,%al
    fbfb:	74 4c                	je     fc49 <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
    fbfd:	8b 45 14             	mov    0x14(%ebp),%eax
    fc00:	8b 40 28             	mov    0x28(%eax),%eax
    fc03:	85 c0                	test   %eax,%eax
    fc05:	0f 84 ce 02 00 00    	je     fed9 <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    fc0b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fc0e:	8b 45 14             	mov    0x14(%ebp),%eax
    fc11:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fc14:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fc1a:	52                   	push   %edx
    fc1b:	ff 75 d0             	pushl  -0x30(%ebp)
    fc1e:	50                   	push   %eax
    fc1f:	51                   	push   %ecx
    fc20:	e8 23 ee ff ff       	call   ea48 <readChunk_iTXt>
    fc25:	83 c4 10             	add    $0x10,%esp
    fc28:	89 c2                	mov    %eax,%edx
    fc2a:	8b 45 14             	mov    0x14(%ebp),%eax
    fc2d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fc33:	8b 45 14             	mov    0x14(%ebp),%eax
    fc36:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc3c:	85 c0                	test   %eax,%eax
    fc3e:	0f 84 95 02 00 00    	je     fed9 <decodeGeneric+0x731>
    fc44:	e9 04 03 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    fc49:	83 ec 08             	sub    $0x8,%esp
    fc4c:	68 66 a0 01 00       	push   $0x1a066
    fc51:	ff 75 f0             	pushl  -0x10(%ebp)
    fc54:	e8 99 86 ff ff       	call   82f2 <lodepng_chunk_type_equals>
    fc59:	83 c4 10             	add    $0x10,%esp
    fc5c:	84 c0                	test   %al,%al
    fc5e:	74 3d                	je     fc9d <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
    fc60:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fc63:	8b 55 14             	mov    0x14(%ebp),%edx
    fc66:	81 c2 98 00 00 00    	add    $0x98,%edx
    fc6c:	83 ec 04             	sub    $0x4,%esp
    fc6f:	50                   	push   %eax
    fc70:	ff 75 d0             	pushl  -0x30(%ebp)
    fc73:	52                   	push   %edx
    fc74:	e8 25 f1 ff ff       	call   ed9e <readChunk_tIME>
    fc79:	83 c4 10             	add    $0x10,%esp
    fc7c:	89 c2                	mov    %eax,%edx
    fc7e:	8b 45 14             	mov    0x14(%ebp),%eax
    fc81:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fc87:	8b 45 14             	mov    0x14(%ebp),%eax
    fc8a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc90:	85 c0                	test   %eax,%eax
    fc92:	0f 84 41 02 00 00    	je     fed9 <decodeGeneric+0x731>
    fc98:	e9 b0 02 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    fc9d:	83 ec 08             	sub    $0x8,%esp
    fca0:	68 6b a0 01 00       	push   $0x1a06b
    fca5:	ff 75 f0             	pushl  -0x10(%ebp)
    fca8:	e8 45 86 ff ff       	call   82f2 <lodepng_chunk_type_equals>
    fcad:	83 c4 10             	add    $0x10,%esp
    fcb0:	84 c0                	test   %al,%al
    fcb2:	74 3d                	je     fcf1 <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
    fcb4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fcb7:	8b 55 14             	mov    0x14(%ebp),%edx
    fcba:	81 c2 98 00 00 00    	add    $0x98,%edx
    fcc0:	83 ec 04             	sub    $0x4,%esp
    fcc3:	50                   	push   %eax
    fcc4:	ff 75 d0             	pushl  -0x30(%ebp)
    fcc7:	52                   	push   %edx
    fcc8:	e8 71 f1 ff ff       	call   ee3e <readChunk_pHYs>
    fccd:	83 c4 10             	add    $0x10,%esp
    fcd0:	89 c2                	mov    %eax,%edx
    fcd2:	8b 45 14             	mov    0x14(%ebp),%eax
    fcd5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fcdb:	8b 45 14             	mov    0x14(%ebp),%eax
    fcde:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fce4:	85 c0                	test   %eax,%eax
    fce6:	0f 84 ed 01 00 00    	je     fed9 <decodeGeneric+0x731>
    fcec:	e9 5c 02 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    fcf1:	83 ec 08             	sub    $0x8,%esp
    fcf4:	68 70 a0 01 00       	push   $0x1a070
    fcf9:	ff 75 f0             	pushl  -0x10(%ebp)
    fcfc:	e8 f1 85 ff ff       	call   82f2 <lodepng_chunk_type_equals>
    fd01:	83 c4 10             	add    $0x10,%esp
    fd04:	84 c0                	test   %al,%al
    fd06:	74 3d                	je     fd45 <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
    fd08:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd0b:	8b 55 14             	mov    0x14(%ebp),%edx
    fd0e:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd14:	83 ec 04             	sub    $0x4,%esp
    fd17:	50                   	push   %eax
    fd18:	ff 75 d0             	pushl  -0x30(%ebp)
    fd1b:	52                   	push   %edx
    fd1c:	e8 ec f1 ff ff       	call   ef0d <readChunk_gAMA>
    fd21:	83 c4 10             	add    $0x10,%esp
    fd24:	89 c2                	mov    %eax,%edx
    fd26:	8b 45 14             	mov    0x14(%ebp),%eax
    fd29:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd2f:	8b 45 14             	mov    0x14(%ebp),%eax
    fd32:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd38:	85 c0                	test   %eax,%eax
    fd3a:	0f 84 99 01 00 00    	je     fed9 <decodeGeneric+0x731>
    fd40:	e9 08 02 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    fd45:	83 ec 08             	sub    $0x8,%esp
    fd48:	68 75 a0 01 00       	push   $0x1a075
    fd4d:	ff 75 f0             	pushl  -0x10(%ebp)
    fd50:	e8 9d 85 ff ff       	call   82f2 <lodepng_chunk_type_equals>
    fd55:	83 c4 10             	add    $0x10,%esp
    fd58:	84 c0                	test   %al,%al
    fd5a:	74 3d                	je     fd99 <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
    fd5c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd5f:	8b 55 14             	mov    0x14(%ebp),%edx
    fd62:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd68:	83 ec 04             	sub    $0x4,%esp
    fd6b:	50                   	push   %eax
    fd6c:	ff 75 d0             	pushl  -0x30(%ebp)
    fd6f:	52                   	push   %edx
    fd70:	e8 07 f2 ff ff       	call   ef7c <readChunk_cHRM>
    fd75:	83 c4 10             	add    $0x10,%esp
    fd78:	89 c2                	mov    %eax,%edx
    fd7a:	8b 45 14             	mov    0x14(%ebp),%eax
    fd7d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd83:	8b 45 14             	mov    0x14(%ebp),%eax
    fd86:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd8c:	85 c0                	test   %eax,%eax
    fd8e:	0f 84 45 01 00 00    	je     fed9 <decodeGeneric+0x731>
    fd94:	e9 b4 01 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    fd99:	83 ec 08             	sub    $0x8,%esp
    fd9c:	68 7a a0 01 00       	push   $0x1a07a
    fda1:	ff 75 f0             	pushl  -0x10(%ebp)
    fda4:	e8 49 85 ff ff       	call   82f2 <lodepng_chunk_type_equals>
    fda9:	83 c4 10             	add    $0x10,%esp
    fdac:	84 c0                	test   %al,%al
    fdae:	74 3d                	je     fded <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
    fdb0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fdb3:	8b 55 14             	mov    0x14(%ebp),%edx
    fdb6:	81 c2 98 00 00 00    	add    $0x98,%edx
    fdbc:	83 ec 04             	sub    $0x4,%esp
    fdbf:	50                   	push   %eax
    fdc0:	ff 75 d0             	pushl  -0x30(%ebp)
    fdc3:	52                   	push   %edx
    fdc4:	e8 47 f4 ff ff       	call   f210 <readChunk_sRGB>
    fdc9:	83 c4 10             	add    $0x10,%esp
    fdcc:	89 c2                	mov    %eax,%edx
    fdce:	8b 45 14             	mov    0x14(%ebp),%eax
    fdd1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fdd7:	8b 45 14             	mov    0x14(%ebp),%eax
    fdda:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fde0:	85 c0                	test   %eax,%eax
    fde2:	0f 84 f1 00 00 00    	je     fed9 <decodeGeneric+0x731>
    fde8:	e9 60 01 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    fded:	83 ec 08             	sub    $0x8,%esp
    fdf0:	68 7f a0 01 00       	push   $0x1a07f
    fdf5:	ff 75 f0             	pushl  -0x10(%ebp)
    fdf8:	e8 f5 84 ff ff       	call   82f2 <lodepng_chunk_type_equals>
    fdfd:	83 c4 10             	add    $0x10,%esp
    fe00:	84 c0                	test   %al,%al
    fe02:	74 3e                	je     fe42 <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    fe04:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fe07:	8b 45 14             	mov    0x14(%ebp),%eax
    fe0a:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fe0d:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fe13:	52                   	push   %edx
    fe14:	ff 75 d0             	pushl  -0x30(%ebp)
    fe17:	50                   	push   %eax
    fe18:	51                   	push   %ecx
    fe19:	e8 28 f4 ff ff       	call   f246 <readChunk_iCCP>
    fe1e:	83 c4 10             	add    $0x10,%esp
    fe21:	89 c2                	mov    %eax,%edx
    fe23:	8b 45 14             	mov    0x14(%ebp),%eax
    fe26:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fe2c:	8b 45 14             	mov    0x14(%ebp),%eax
    fe2f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe35:	85 c0                	test   %eax,%eax
    fe37:	0f 84 9c 00 00 00    	je     fed9 <decodeGeneric+0x731>
    fe3d:	e9 0b 01 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
    fe42:	8b 45 14             	mov    0x14(%ebp),%eax
    fe45:	8b 40 1c             	mov    0x1c(%eax),%eax
    fe48:	85 c0                	test   %eax,%eax
    fe4a:	75 24                	jne    fe70 <decodeGeneric+0x6c8>
    fe4c:	83 ec 0c             	sub    $0xc,%esp
    fe4f:	ff 75 f0             	pushl  -0x10(%ebp)
    fe52:	e8 30 85 ff ff       	call   8387 <lodepng_chunk_ancillary>
    fe57:	83 c4 10             	add    $0x10,%esp
    fe5a:	84 c0                	test   %al,%al
    fe5c:	75 12                	jne    fe70 <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
    fe5e:	8b 45 14             	mov    0x14(%ebp),%eax
    fe61:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
    fe68:	00 00 00 
    fe6b:	e9 dd 00 00 00       	jmp    ff4d <decodeGeneric+0x7a5>
      }

      unknown = 1;
    fe70:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
    fe77:	8b 45 14             	mov    0x14(%ebp),%eax
    fe7a:	8b 40 2c             	mov    0x2c(%eax),%eax
    fe7d:	85 c0                	test   %eax,%eax
    fe7f:	74 58                	je     fed9 <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
    fe81:	8b 45 dc             	mov    -0x24(%ebp),%eax
    fe84:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
    fe87:	83 c0 58             	add    $0x58,%eax
    fe8a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    fe91:	8b 45 14             	mov    0x14(%ebp),%eax
    fe94:	01 d0                	add    %edx,%eax
    fe96:	8d 50 10             	lea    0x10(%eax),%edx
    fe99:	8b 45 dc             	mov    -0x24(%ebp),%eax
    fe9c:	83 e8 01             	sub    $0x1,%eax
    fe9f:	83 c0 54             	add    $0x54,%eax
    fea2:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    fea9:	8b 45 14             	mov    0x14(%ebp),%eax
    feac:	01 c8                	add    %ecx,%eax
    feae:	83 c0 14             	add    $0x14,%eax
    feb1:	83 ec 04             	sub    $0x4,%esp
    feb4:	ff 75 f0             	pushl  -0x10(%ebp)
    feb7:	52                   	push   %edx
    feb8:	50                   	push   %eax
    feb9:	e8 15 88 ff ff       	call   86d3 <lodepng_chunk_append>
    febe:	83 c4 10             	add    $0x10,%esp
    fec1:	89 c2                	mov    %eax,%edx
    fec3:	8b 45 14             	mov    0x14(%ebp),%eax
    fec6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    fecc:	8b 45 14             	mov    0x14(%ebp),%eax
    fecf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fed5:	85 c0                	test   %eax,%eax
    fed7:	75 73                	jne    ff4c <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
    fed9:	8b 45 14             	mov    0x14(%ebp),%eax
    fedc:	8b 40 18             	mov    0x18(%eax),%eax
    fedf:	85 c0                	test   %eax,%eax
    fee1:	75 27                	jne    ff0a <decodeGeneric+0x762>
    fee3:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    fee7:	75 21                	jne    ff0a <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
    fee9:	83 ec 0c             	sub    $0xc,%esp
    feec:	ff 75 f0             	pushl  -0x10(%ebp)
    feef:	e8 f4 84 ff ff       	call   83e8 <lodepng_chunk_check_crc>
    fef4:	83 c4 10             	add    $0x10,%esp
    fef7:	85 c0                	test   %eax,%eax
    fef9:	74 0f                	je     ff0a <decodeGeneric+0x762>
    fefb:	8b 45 14             	mov    0x14(%ebp),%eax
    fefe:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    ff05:	00 00 00 
    ff08:	eb 43                	jmp    ff4d <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
    ff0a:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    ff0e:	75 1a                	jne    ff2a <decodeGeneric+0x782>
    ff10:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ff13:	8b 45 18             	mov    0x18(%ebp),%eax
    ff16:	01 d0                	add    %edx,%eax
    ff18:	83 ec 08             	sub    $0x8,%esp
    ff1b:	50                   	push   %eax
    ff1c:	ff 75 f0             	pushl  -0x10(%ebp)
    ff1f:	e8 3f 86 ff ff       	call   8563 <lodepng_chunk_next_const>
    ff24:	83 c4 10             	add    $0x10,%esp
    ff27:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    ff2a:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    ff2e:	75 1d                	jne    ff4d <decodeGeneric+0x7a5>
    ff30:	8b 45 14             	mov    0x14(%ebp),%eax
    ff33:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff39:	85 c0                	test   %eax,%eax
    ff3b:	0f 84 68 f9 ff ff    	je     f8a9 <decodeGeneric+0x101>
    ff41:	eb 0a                	jmp    ff4d <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    ff43:	90                   	nop
    ff44:	eb 07                	jmp    ff4d <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    ff46:	90                   	nop
    ff47:	eb 04                	jmp    ff4d <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
    ff49:	90                   	nop
    ff4a:	eb 01                	jmp    ff4d <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    ff4c:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
    ff4d:	8b 45 14             	mov    0x14(%ebp),%eax
    ff50:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff56:	85 c0                	test   %eax,%eax
    ff58:	75 28                	jne    ff82 <decodeGeneric+0x7da>
    ff5a:	8b 45 14             	mov    0x14(%ebp),%eax
    ff5d:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
    ff63:	83 f8 03             	cmp    $0x3,%eax
    ff66:	75 1a                	jne    ff82 <decodeGeneric+0x7da>
    ff68:	8b 45 14             	mov    0x14(%ebp),%eax
    ff6b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ff71:	85 c0                	test   %eax,%eax
    ff73:	75 0d                	jne    ff82 <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
    ff75:	8b 45 14             	mov    0x14(%ebp),%eax
    ff78:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
    ff7f:	00 00 00 
  }

  if(!state->error) {
    ff82:	8b 45 14             	mov    0x14(%ebp),%eax
    ff85:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff8b:	85 c0                	test   %eax,%eax
    ff8d:	0f 85 d2 01 00 00    	jne    10165 <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
    ff93:	8b 45 14             	mov    0x14(%ebp),%eax
    ff96:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    ff9c:	85 c0                	test   %eax,%eax
    ff9e:	75 3a                	jne    ffda <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
    ffa0:	8b 45 14             	mov    0x14(%ebp),%eax
    ffa3:	05 a4 00 00 00       	add    $0xa4,%eax
    ffa8:	83 ec 0c             	sub    $0xc,%esp
    ffab:	50                   	push   %eax
    ffac:	e8 8e 8e ff ff       	call   8e3f <lodepng_get_bpp>
    ffb1:	83 c4 10             	add    $0x10,%esp
    ffb4:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
    ffb7:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    ffba:	8b 45 10             	mov    0x10(%ebp),%eax
    ffbd:	8b 10                	mov    (%eax),%edx
    ffbf:	8b 45 0c             	mov    0xc(%ebp),%eax
    ffc2:	8b 00                	mov    (%eax),%eax
    ffc4:	83 ec 04             	sub    $0x4,%esp
    ffc7:	51                   	push   %ecx
    ffc8:	52                   	push   %edx
    ffc9:	50                   	push   %eax
    ffca:	e8 cf 8f ff ff       	call   8f9e <lodepng_get_raw_size_idat>
    ffcf:	83 c4 10             	add    $0x10,%esp
    ffd2:	89 45 e8             	mov    %eax,-0x18(%ebp)
    ffd5:	e9 60 01 00 00       	jmp    1013a <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
    ffda:	8b 45 14             	mov    0x14(%ebp),%eax
    ffdd:	05 a4 00 00 00       	add    $0xa4,%eax
    ffe2:	83 ec 0c             	sub    $0xc,%esp
    ffe5:	50                   	push   %eax
    ffe6:	e8 54 8e ff ff       	call   8e3f <lodepng_get_bpp>
    ffeb:	83 c4 10             	add    $0x10,%esp
    ffee:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
    fff1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
    fff8:	8b 45 c8             	mov    -0x38(%ebp),%eax
    fffb:	8b 55 10             	mov    0x10(%ebp),%edx
    fffe:	8b 12                	mov    (%edx),%edx
   10000:	83 c2 07             	add    $0x7,%edx
   10003:	89 d1                	mov    %edx,%ecx
   10005:	c1 e9 03             	shr    $0x3,%ecx
   10008:	8b 55 0c             	mov    0xc(%ebp),%edx
   1000b:	8b 12                	mov    (%edx),%edx
   1000d:	83 c2 07             	add    $0x7,%edx
   10010:	c1 ea 03             	shr    $0x3,%edx
   10013:	83 ec 04             	sub    $0x4,%esp
   10016:	50                   	push   %eax
   10017:	51                   	push   %ecx
   10018:	52                   	push   %edx
   10019:	e8 80 8f ff ff       	call   8f9e <lodepng_get_raw_size_idat>
   1001e:	83 c4 10             	add    $0x10,%esp
   10021:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   10024:	8b 45 0c             	mov    0xc(%ebp),%eax
   10027:	8b 00                	mov    (%eax),%eax
   10029:	83 f8 04             	cmp    $0x4,%eax
   1002c:	76 2c                	jbe    1005a <decodeGeneric+0x8b2>
   1002e:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10031:	8b 55 10             	mov    0x10(%ebp),%edx
   10034:	8b 12                	mov    (%edx),%edx
   10036:	83 c2 07             	add    $0x7,%edx
   10039:	89 d1                	mov    %edx,%ecx
   1003b:	c1 e9 03             	shr    $0x3,%ecx
   1003e:	8b 55 0c             	mov    0xc(%ebp),%edx
   10041:	8b 12                	mov    (%edx),%edx
   10043:	83 c2 03             	add    $0x3,%edx
   10046:	c1 ea 03             	shr    $0x3,%edx
   10049:	83 ec 04             	sub    $0x4,%esp
   1004c:	50                   	push   %eax
   1004d:	51                   	push   %ecx
   1004e:	52                   	push   %edx
   1004f:	e8 4a 8f ff ff       	call   8f9e <lodepng_get_raw_size_idat>
   10054:	83 c4 10             	add    $0x10,%esp
   10057:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   1005a:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1005d:	8b 55 10             	mov    0x10(%ebp),%edx
   10060:	8b 12                	mov    (%edx),%edx
   10062:	83 c2 03             	add    $0x3,%edx
   10065:	89 d1                	mov    %edx,%ecx
   10067:	c1 e9 03             	shr    $0x3,%ecx
   1006a:	8b 55 0c             	mov    0xc(%ebp),%edx
   1006d:	8b 12                	mov    (%edx),%edx
   1006f:	83 c2 03             	add    $0x3,%edx
   10072:	c1 ea 02             	shr    $0x2,%edx
   10075:	83 ec 04             	sub    $0x4,%esp
   10078:	50                   	push   %eax
   10079:	51                   	push   %ecx
   1007a:	52                   	push   %edx
   1007b:	e8 1e 8f ff ff       	call   8f9e <lodepng_get_raw_size_idat>
   10080:	83 c4 10             	add    $0x10,%esp
   10083:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   10086:	8b 45 0c             	mov    0xc(%ebp),%eax
   10089:	8b 00                	mov    (%eax),%eax
   1008b:	83 f8 02             	cmp    $0x2,%eax
   1008e:	76 2c                	jbe    100bc <decodeGeneric+0x914>
   10090:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10093:	8b 55 10             	mov    0x10(%ebp),%edx
   10096:	8b 12                	mov    (%edx),%edx
   10098:	83 c2 03             	add    $0x3,%edx
   1009b:	89 d1                	mov    %edx,%ecx
   1009d:	c1 e9 02             	shr    $0x2,%ecx
   100a0:	8b 55 0c             	mov    0xc(%ebp),%edx
   100a3:	8b 12                	mov    (%edx),%edx
   100a5:	83 c2 01             	add    $0x1,%edx
   100a8:	c1 ea 02             	shr    $0x2,%edx
   100ab:	83 ec 04             	sub    $0x4,%esp
   100ae:	50                   	push   %eax
   100af:	51                   	push   %ecx
   100b0:	52                   	push   %edx
   100b1:	e8 e8 8e ff ff       	call   8f9e <lodepng_get_raw_size_idat>
   100b6:	83 c4 10             	add    $0x10,%esp
   100b9:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   100bc:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100bf:	8b 55 10             	mov    0x10(%ebp),%edx
   100c2:	8b 12                	mov    (%edx),%edx
   100c4:	83 c2 01             	add    $0x1,%edx
   100c7:	89 d1                	mov    %edx,%ecx
   100c9:	c1 e9 02             	shr    $0x2,%ecx
   100cc:	8b 55 0c             	mov    0xc(%ebp),%edx
   100cf:	8b 12                	mov    (%edx),%edx
   100d1:	83 c2 01             	add    $0x1,%edx
   100d4:	d1 ea                	shr    %edx
   100d6:	83 ec 04             	sub    $0x4,%esp
   100d9:	50                   	push   %eax
   100da:	51                   	push   %ecx
   100db:	52                   	push   %edx
   100dc:	e8 bd 8e ff ff       	call   8f9e <lodepng_get_raw_size_idat>
   100e1:	83 c4 10             	add    $0x10,%esp
   100e4:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   100e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   100ea:	8b 00                	mov    (%eax),%eax
   100ec:	83 f8 01             	cmp    $0x1,%eax
   100ef:	76 27                	jbe    10118 <decodeGeneric+0x970>
   100f1:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100f4:	8b 55 10             	mov    0x10(%ebp),%edx
   100f7:	8b 12                	mov    (%edx),%edx
   100f9:	83 c2 01             	add    $0x1,%edx
   100fc:	89 d1                	mov    %edx,%ecx
   100fe:	d1 e9                	shr    %ecx
   10100:	8b 55 0c             	mov    0xc(%ebp),%edx
   10103:	8b 12                	mov    (%edx),%edx
   10105:	d1 ea                	shr    %edx
   10107:	83 ec 04             	sub    $0x4,%esp
   1010a:	50                   	push   %eax
   1010b:	51                   	push   %ecx
   1010c:	52                   	push   %edx
   1010d:	e8 8c 8e ff ff       	call   8f9e <lodepng_get_raw_size_idat>
   10112:	83 c4 10             	add    $0x10,%esp
   10115:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   10118:	8b 55 c8             	mov    -0x38(%ebp),%edx
   1011b:	8b 45 10             	mov    0x10(%ebp),%eax
   1011e:	8b 00                	mov    (%eax),%eax
   10120:	d1 e8                	shr    %eax
   10122:	89 c1                	mov    %eax,%ecx
   10124:	8b 45 0c             	mov    0xc(%ebp),%eax
   10127:	8b 00                	mov    (%eax),%eax
   10129:	83 ec 04             	sub    $0x4,%esp
   1012c:	52                   	push   %edx
   1012d:	51                   	push   %ecx
   1012e:	50                   	push   %eax
   1012f:	e8 6a 8e ff ff       	call   8f9e <lodepng_get_raw_size_idat>
   10134:	83 c4 10             	add    $0x10,%esp
   10137:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   1013a:	8b 45 14             	mov    0x14(%ebp),%eax
   1013d:	83 ec 08             	sub    $0x8,%esp
   10140:	50                   	push   %eax
   10141:	ff 75 ec             	pushl  -0x14(%ebp)
   10144:	ff 75 d8             	pushl  -0x28(%ebp)
   10147:	ff 75 e8             	pushl  -0x18(%ebp)
   1014a:	8d 45 c0             	lea    -0x40(%ebp),%eax
   1014d:	50                   	push   %eax
   1014e:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   10151:	50                   	push   %eax
   10152:	e8 87 7c ff ff       	call   7dde <zlib_decompress>
   10157:	83 c4 20             	add    $0x20,%esp
   1015a:	89 c2                	mov    %eax,%edx
   1015c:	8b 45 14             	mov    0x14(%ebp),%eax
   1015f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   10165:	8b 45 14             	mov    0x14(%ebp),%eax
   10168:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1016e:	85 c0                	test   %eax,%eax
   10170:	75 15                	jne    10187 <decodeGeneric+0x9df>
   10172:	8b 45 c0             	mov    -0x40(%ebp),%eax
   10175:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   10178:	74 0d                	je     10187 <decodeGeneric+0x9df>
   1017a:	8b 45 14             	mov    0x14(%ebp),%eax
   1017d:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   10184:	00 00 00 
  lodepng_free(idat);
   10187:	83 ec 0c             	sub    $0xc,%esp
   1018a:	ff 75 d8             	pushl  -0x28(%ebp)
   1018d:	e8 b2 31 ff ff       	call   3344 <lodepng_free>
   10192:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   10195:	8b 45 14             	mov    0x14(%ebp),%eax
   10198:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1019e:	85 c0                	test   %eax,%eax
   101a0:	75 4f                	jne    101f1 <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   101a2:	8b 45 14             	mov    0x14(%ebp),%eax
   101a5:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   101ab:	8b 45 10             	mov    0x10(%ebp),%eax
   101ae:	8b 10                	mov    (%eax),%edx
   101b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   101b3:	8b 00                	mov    (%eax),%eax
   101b5:	83 ec 04             	sub    $0x4,%esp
   101b8:	51                   	push   %ecx
   101b9:	52                   	push   %edx
   101ba:	50                   	push   %eax
   101bb:	e8 be 8d ff ff       	call   8f7e <lodepng_get_raw_size>
   101c0:	83 c4 10             	add    $0x10,%esp
   101c3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   101c6:	83 ec 0c             	sub    $0xc,%esp
   101c9:	ff 75 e4             	pushl  -0x1c(%ebp)
   101cc:	e8 52 31 ff ff       	call   3323 <lodepng_malloc>
   101d1:	83 c4 10             	add    $0x10,%esp
   101d4:	89 c2                	mov    %eax,%edx
   101d6:	8b 45 08             	mov    0x8(%ebp),%eax
   101d9:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   101db:	8b 45 08             	mov    0x8(%ebp),%eax
   101de:	8b 00                	mov    (%eax),%eax
   101e0:	85 c0                	test   %eax,%eax
   101e2:	75 0d                	jne    101f1 <decodeGeneric+0xa49>
   101e4:	8b 45 14             	mov    0x14(%ebp),%eax
   101e7:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   101ee:	00 00 00 
  }
  if(!state->error) {
   101f1:	8b 45 14             	mov    0x14(%ebp),%eax
   101f4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   101fa:	85 c0                	test   %eax,%eax
   101fc:	75 4c                	jne    1024a <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   101fe:	8b 45 08             	mov    0x8(%ebp),%eax
   10201:	8b 00                	mov    (%eax),%eax
   10203:	83 ec 04             	sub    $0x4,%esp
   10206:	ff 75 e4             	pushl  -0x1c(%ebp)
   10209:	6a 00                	push   $0x0
   1020b:	50                   	push   %eax
   1020c:	e8 83 31 ff ff       	call   3394 <lodepng_memset>
   10211:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   10214:	8b 45 14             	mov    0x14(%ebp),%eax
   10217:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   1021d:	8b 45 10             	mov    0x10(%ebp),%eax
   10220:	8b 18                	mov    (%eax),%ebx
   10222:	8b 45 0c             	mov    0xc(%ebp),%eax
   10225:	8b 08                	mov    (%eax),%ecx
   10227:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1022a:	8b 45 08             	mov    0x8(%ebp),%eax
   1022d:	8b 00                	mov    (%eax),%eax
   1022f:	83 ec 0c             	sub    $0xc,%esp
   10232:	56                   	push   %esi
   10233:	53                   	push   %ebx
   10234:	51                   	push   %ecx
   10235:	52                   	push   %edx
   10236:	50                   	push   %eax
   10237:	e8 05 df ff ff       	call   e141 <postProcessScanlines>
   1023c:	83 c4 20             	add    $0x20,%esp
   1023f:	89 c2                	mov    %eax,%edx
   10241:	8b 45 14             	mov    0x14(%ebp),%eax
   10244:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   1024a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1024d:	83 ec 0c             	sub    $0xc,%esp
   10250:	50                   	push   %eax
   10251:	e8 ee 30 ff ff       	call   3344 <lodepng_free>
   10256:	83 c4 10             	add    $0x10,%esp
   10259:	eb 01                	jmp    1025c <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   1025b:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   1025c:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1025f:	5b                   	pop    %ebx
   10260:	5e                   	pop    %esi
   10261:	5d                   	pop    %ebp
   10262:	c3                   	ret    

00010263 <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   10263:	55                   	push   %ebp
   10264:	89 e5                	mov    %esp,%ebp
   10266:	56                   	push   %esi
   10267:	53                   	push   %ebx
   10268:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   1026b:	8b 45 08             	mov    0x8(%ebp),%eax
   1026e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   10274:	83 ec 08             	sub    $0x8,%esp
   10277:	ff 75 1c             	pushl  0x1c(%ebp)
   1027a:	ff 75 18             	pushl  0x18(%ebp)
   1027d:	ff 75 14             	pushl  0x14(%ebp)
   10280:	ff 75 10             	pushl  0x10(%ebp)
   10283:	ff 75 0c             	pushl  0xc(%ebp)
   10286:	ff 75 08             	pushl  0x8(%ebp)
   10289:	e8 1a f5 ff ff       	call   f7a8 <decodeGeneric>
   1028e:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   10291:	8b 45 14             	mov    0x14(%ebp),%eax
   10294:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1029a:	85 c0                	test   %eax,%eax
   1029c:	74 0e                	je     102ac <lodepng_decode+0x49>
   1029e:	8b 45 14             	mov    0x14(%ebp),%eax
   102a1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   102a7:	e9 55 01 00 00       	jmp    10401 <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   102ac:	8b 45 14             	mov    0x14(%ebp),%eax
   102af:	8b 40 24             	mov    0x24(%eax),%eax
   102b2:	85 c0                	test   %eax,%eax
   102b4:	74 20                	je     102d6 <lodepng_decode+0x73>
   102b6:	8b 45 14             	mov    0x14(%ebp),%eax
   102b9:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   102bf:	8b 45 14             	mov    0x14(%ebp),%eax
   102c2:	83 c0 78             	add    $0x78,%eax
   102c5:	83 ec 08             	sub    $0x8,%esp
   102c8:	52                   	push   %edx
   102c9:	50                   	push   %eax
   102ca:	e8 56 89 ff ff       	call   8c25 <lodepng_color_mode_equal>
   102cf:	83 c4 10             	add    $0x10,%esp
   102d2:	85 c0                	test   %eax,%eax
   102d4:	74 54                	je     1032a <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   102d6:	8b 45 14             	mov    0x14(%ebp),%eax
   102d9:	8b 40 24             	mov    0x24(%eax),%eax
   102dc:	85 c0                	test   %eax,%eax
   102de:	0f 85 13 01 00 00    	jne    103f7 <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   102e4:	8b 45 14             	mov    0x14(%ebp),%eax
   102e7:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   102ed:	8b 45 14             	mov    0x14(%ebp),%eax
   102f0:	83 c0 78             	add    $0x78,%eax
   102f3:	83 ec 08             	sub    $0x8,%esp
   102f6:	52                   	push   %edx
   102f7:	50                   	push   %eax
   102f8:	e8 3f 88 ff ff       	call   8b3c <lodepng_color_mode_copy>
   102fd:	83 c4 10             	add    $0x10,%esp
   10300:	89 c2                	mov    %eax,%edx
   10302:	8b 45 14             	mov    0x14(%ebp),%eax
   10305:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   1030b:	8b 45 14             	mov    0x14(%ebp),%eax
   1030e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10314:	85 c0                	test   %eax,%eax
   10316:	0f 84 db 00 00 00    	je     103f7 <lodepng_decode+0x194>
   1031c:	8b 45 14             	mov    0x14(%ebp),%eax
   1031f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10325:	e9 d7 00 00 00       	jmp    10401 <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   1032a:	8b 45 08             	mov    0x8(%ebp),%eax
   1032d:	8b 00                	mov    (%eax),%eax
   1032f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   10332:	8b 45 14             	mov    0x14(%ebp),%eax
   10335:	8b 40 78             	mov    0x78(%eax),%eax
   10338:	83 f8 02             	cmp    $0x2,%eax
   1033b:	74 20                	je     1035d <lodepng_decode+0xfa>
   1033d:	8b 45 14             	mov    0x14(%ebp),%eax
   10340:	8b 40 78             	mov    0x78(%eax),%eax
   10343:	83 f8 06             	cmp    $0x6,%eax
   10346:	74 15                	je     1035d <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   10348:	8b 45 14             	mov    0x14(%ebp),%eax
   1034b:	8b 40 7c             	mov    0x7c(%eax),%eax
   1034e:	83 f8 08             	cmp    $0x8,%eax
   10351:	74 0a                	je     1035d <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   10353:	b8 38 00 00 00       	mov    $0x38,%eax
   10358:	e9 a4 00 00 00       	jmp    10401 <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   1035d:	8b 45 14             	mov    0x14(%ebp),%eax
   10360:	8d 48 78             	lea    0x78(%eax),%ecx
   10363:	8b 45 10             	mov    0x10(%ebp),%eax
   10366:	8b 10                	mov    (%eax),%edx
   10368:	8b 45 0c             	mov    0xc(%ebp),%eax
   1036b:	8b 00                	mov    (%eax),%eax
   1036d:	83 ec 04             	sub    $0x4,%esp
   10370:	51                   	push   %ecx
   10371:	52                   	push   %edx
   10372:	50                   	push   %eax
   10373:	e8 06 8c ff ff       	call   8f7e <lodepng_get_raw_size>
   10378:	83 c4 10             	add    $0x10,%esp
   1037b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   1037e:	83 ec 0c             	sub    $0xc,%esp
   10381:	ff 75 f0             	pushl  -0x10(%ebp)
   10384:	e8 9a 2f ff ff       	call   3323 <lodepng_malloc>
   10389:	83 c4 10             	add    $0x10,%esp
   1038c:	89 c2                	mov    %eax,%edx
   1038e:	8b 45 08             	mov    0x8(%ebp),%eax
   10391:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   10393:	8b 45 08             	mov    0x8(%ebp),%eax
   10396:	8b 00                	mov    (%eax),%eax
   10398:	85 c0                	test   %eax,%eax
   1039a:	75 0f                	jne    103ab <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   1039c:	8b 45 14             	mov    0x14(%ebp),%eax
   1039f:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   103a6:	00 00 00 
   103a9:	eb 3c                	jmp    103e7 <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   103ab:	8b 45 10             	mov    0x10(%ebp),%eax
   103ae:	8b 08                	mov    (%eax),%ecx
   103b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   103b3:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   103b5:	8b 45 14             	mov    0x14(%ebp),%eax
   103b8:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   103be:	8b 45 14             	mov    0x14(%ebp),%eax
   103c1:	8d 58 78             	lea    0x78(%eax),%ebx
   103c4:	8b 45 08             	mov    0x8(%ebp),%eax
   103c7:	8b 00                	mov    (%eax),%eax
   103c9:	83 ec 08             	sub    $0x8,%esp
   103cc:	51                   	push   %ecx
   103cd:	52                   	push   %edx
   103ce:	56                   	push   %esi
   103cf:	53                   	push   %ebx
   103d0:	ff 75 f4             	pushl  -0xc(%ebp)
   103d3:	50                   	push   %eax
   103d4:	e8 51 b6 ff ff       	call   ba2a <lodepng_convert>
   103d9:	83 c4 20             	add    $0x20,%esp
   103dc:	89 c2                	mov    %eax,%edx
   103de:	8b 45 14             	mov    0x14(%ebp),%eax
   103e1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   103e7:	83 ec 0c             	sub    $0xc,%esp
   103ea:	ff 75 f4             	pushl  -0xc(%ebp)
   103ed:	e8 52 2f ff ff       	call   3344 <lodepng_free>
   103f2:	83 c4 10             	add    $0x10,%esp
   103f5:	eb 01                	jmp    103f8 <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   103f7:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   103f8:	8b 45 14             	mov    0x14(%ebp),%eax
   103fb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   10401:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10404:	5b                   	pop    %ebx
   10405:	5e                   	pop    %esi
   10406:	5d                   	pop    %ebp
   10407:	c3                   	ret    

00010408 <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   10408:	55                   	push   %ebp
   10409:	89 e5                	mov    %esp,%ebp
   1040b:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   10411:	83 ec 0c             	sub    $0xc,%esp
   10414:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1041a:	50                   	push   %eax
   1041b:	e8 d9 01 00 00       	call   105f9 <lodepng_state_init>
   10420:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   10423:	8b 45 1c             	mov    0x1c(%ebp),%eax
   10426:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   1042c:	8b 45 20             	mov    0x20(%ebp),%eax
   1042f:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   10435:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   1043c:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   1043f:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   10446:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   10449:	83 ec 08             	sub    $0x8,%esp
   1044c:	ff 75 18             	pushl  0x18(%ebp)
   1044f:	ff 75 14             	pushl  0x14(%ebp)
   10452:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10458:	50                   	push   %eax
   10459:	ff 75 10             	pushl  0x10(%ebp)
   1045c:	ff 75 0c             	pushl  0xc(%ebp)
   1045f:	ff 75 08             	pushl  0x8(%ebp)
   10462:	e8 fc fd ff ff       	call   10263 <lodepng_decode>
   10467:	83 c4 20             	add    $0x20,%esp
   1046a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   1046d:	83 ec 0c             	sub    $0xc,%esp
   10470:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10476:	50                   	push   %eax
   10477:	e8 d7 01 00 00       	call   10653 <lodepng_state_cleanup>
   1047c:	83 c4 10             	add    $0x10,%esp
  return error;
   1047f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10482:	c9                   	leave  
   10483:	c3                   	ret    

00010484 <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10484:	55                   	push   %ebp
   10485:	89 e5                	mov    %esp,%ebp
   10487:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   1048a:	83 ec 04             	sub    $0x4,%esp
   1048d:	6a 08                	push   $0x8
   1048f:	6a 06                	push   $0x6
   10491:	ff 75 18             	pushl  0x18(%ebp)
   10494:	ff 75 14             	pushl  0x14(%ebp)
   10497:	ff 75 10             	pushl  0x10(%ebp)
   1049a:	ff 75 0c             	pushl  0xc(%ebp)
   1049d:	ff 75 08             	pushl  0x8(%ebp)
   104a0:	e8 63 ff ff ff       	call   10408 <lodepng_decode_memory>
   104a5:	83 c4 20             	add    $0x20,%esp
}
   104a8:	c9                   	leave  
   104a9:	c3                   	ret    

000104aa <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   104aa:	55                   	push   %ebp
   104ab:	89 e5                	mov    %esp,%ebp
   104ad:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   104b0:	83 ec 04             	sub    $0x4,%esp
   104b3:	6a 08                	push   $0x8
   104b5:	6a 02                	push   $0x2
   104b7:	ff 75 18             	pushl  0x18(%ebp)
   104ba:	ff 75 14             	pushl  0x14(%ebp)
   104bd:	ff 75 10             	pushl  0x10(%ebp)
   104c0:	ff 75 0c             	pushl  0xc(%ebp)
   104c3:	ff 75 08             	pushl  0x8(%ebp)
   104c6:	e8 3d ff ff ff       	call   10408 <lodepng_decode_memory>
   104cb:	83 c4 20             	add    $0x20,%esp
}
   104ce:	c9                   	leave  
   104cf:	c3                   	ret    

000104d0 <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   104d0:	55                   	push   %ebp
   104d1:	89 e5                	mov    %esp,%ebp
   104d3:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   104d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   104dd:	8b 45 08             	mov    0x8(%ebp),%eax
   104e0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   104e6:	8b 45 10             	mov    0x10(%ebp),%eax
   104e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   104ef:	8b 45 10             	mov    0x10(%ebp),%eax
   104f2:	8b 10                	mov    (%eax),%edx
   104f4:	8b 45 0c             	mov    0xc(%ebp),%eax
   104f7:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   104f9:	83 ec 04             	sub    $0x4,%esp
   104fc:	ff 75 14             	pushl  0x14(%ebp)
   104ff:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10502:	50                   	push   %eax
   10503:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10506:	50                   	push   %eax
   10507:	e8 70 32 ff ff       	call   377c <lodepng_load_file>
   1050c:	83 c4 10             	add    $0x10,%esp
   1050f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   10512:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10516:	75 25                	jne    1053d <lodepng_decode_file+0x6d>
   10518:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1051b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1051e:	83 ec 04             	sub    $0x4,%esp
   10521:	ff 75 1c             	pushl  0x1c(%ebp)
   10524:	ff 75 18             	pushl  0x18(%ebp)
   10527:	52                   	push   %edx
   10528:	50                   	push   %eax
   10529:	ff 75 10             	pushl  0x10(%ebp)
   1052c:	ff 75 0c             	pushl  0xc(%ebp)
   1052f:	ff 75 08             	pushl  0x8(%ebp)
   10532:	e8 d1 fe ff ff       	call   10408 <lodepng_decode_memory>
   10537:	83 c4 20             	add    $0x20,%esp
   1053a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   1053d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10540:	83 ec 0c             	sub    $0xc,%esp
   10543:	50                   	push   %eax
   10544:	e8 fb 2d ff ff       	call   3344 <lodepng_free>
   10549:	83 c4 10             	add    $0x10,%esp
  return error;
   1054c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1054f:	c9                   	leave  
   10550:	c3                   	ret    

00010551 <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10551:	55                   	push   %ebp
   10552:	89 e5                	mov    %esp,%ebp
   10554:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   10557:	83 ec 08             	sub    $0x8,%esp
   1055a:	6a 08                	push   $0x8
   1055c:	6a 06                	push   $0x6
   1055e:	ff 75 14             	pushl  0x14(%ebp)
   10561:	ff 75 10             	pushl  0x10(%ebp)
   10564:	ff 75 0c             	pushl  0xc(%ebp)
   10567:	ff 75 08             	pushl  0x8(%ebp)
   1056a:	e8 61 ff ff ff       	call   104d0 <lodepng_decode_file>
   1056f:	83 c4 20             	add    $0x20,%esp
}
   10572:	c9                   	leave  
   10573:	c3                   	ret    

00010574 <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10574:	55                   	push   %ebp
   10575:	89 e5                	mov    %esp,%ebp
   10577:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   1057a:	83 ec 08             	sub    $0x8,%esp
   1057d:	6a 08                	push   $0x8
   1057f:	6a 02                	push   $0x2
   10581:	ff 75 14             	pushl  0x14(%ebp)
   10584:	ff 75 10             	pushl  0x10(%ebp)
   10587:	ff 75 0c             	pushl  0xc(%ebp)
   1058a:	ff 75 08             	pushl  0x8(%ebp)
   1058d:	e8 3e ff ff ff       	call   104d0 <lodepng_decode_file>
   10592:	83 c4 20             	add    $0x20,%esp
}
   10595:	c9                   	leave  
   10596:	c3                   	ret    

00010597 <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   10597:	55                   	push   %ebp
   10598:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   1059a:	8b 45 08             	mov    0x8(%ebp),%eax
   1059d:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   105a4:	8b 45 08             	mov    0x8(%ebp),%eax
   105a7:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   105ae:	8b 45 08             	mov    0x8(%ebp),%eax
   105b1:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   105b8:	8b 45 08             	mov    0x8(%ebp),%eax
   105bb:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   105c2:	8b 45 08             	mov    0x8(%ebp),%eax
   105c5:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   105cc:	8b 45 08             	mov    0x8(%ebp),%eax
   105cf:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   105d6:	8b 45 08             	mov    0x8(%ebp),%eax
   105d9:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   105e0:	8b 45 08             	mov    0x8(%ebp),%eax
   105e3:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   105ea:	8b 45 08             	mov    0x8(%ebp),%eax
   105ed:	50                   	push   %eax
   105ee:	e8 ff 7a ff ff       	call   80f2 <lodepng_decompress_settings_init>
   105f3:	83 c4 04             	add    $0x4,%esp
}
   105f6:	90                   	nop
   105f7:	c9                   	leave  
   105f8:	c3                   	ret    

000105f9 <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   105f9:	55                   	push   %ebp
   105fa:	89 e5                	mov    %esp,%ebp
   105fc:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   105ff:	8b 45 08             	mov    0x8(%ebp),%eax
   10602:	50                   	push   %eax
   10603:	e8 8f ff ff ff       	call   10597 <lodepng_decoder_settings_init>
   10608:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   1060b:	8b 45 08             	mov    0x8(%ebp),%eax
   1060e:	83 c0 38             	add    $0x38,%eax
   10611:	83 ec 0c             	sub    $0xc,%esp
   10614:	50                   	push   %eax
   10615:	e8 fc 30 00 00       	call   13716 <lodepng_encoder_settings_init>
   1061a:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   1061d:	8b 45 08             	mov    0x8(%ebp),%eax
   10620:	83 c0 78             	add    $0x78,%eax
   10623:	83 ec 0c             	sub    $0xc,%esp
   10626:	50                   	push   %eax
   10627:	e8 06 84 ff ff       	call   8a32 <lodepng_color_mode_init>
   1062c:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   1062f:	8b 45 08             	mov    0x8(%ebp),%eax
   10632:	05 98 00 00 00       	add    $0x98,%eax
   10637:	83 ec 0c             	sub    $0xc,%esp
   1063a:	50                   	push   %eax
   1063b:	e8 89 93 ff ff       	call   99c9 <lodepng_info_init>
   10640:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   10643:	8b 45 08             	mov    0x8(%ebp),%eax
   10646:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   1064d:	00 00 00 
}
   10650:	90                   	nop
   10651:	c9                   	leave  
   10652:	c3                   	ret    

00010653 <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   10653:	55                   	push   %ebp
   10654:	89 e5                	mov    %esp,%ebp
   10656:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   10659:	8b 45 08             	mov    0x8(%ebp),%eax
   1065c:	83 c0 78             	add    $0x78,%eax
   1065f:	83 ec 0c             	sub    $0xc,%esp
   10662:	50                   	push   %eax
   10663:	e8 bd 84 ff ff       	call   8b25 <lodepng_color_mode_cleanup>
   10668:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   1066b:	8b 45 08             	mov    0x8(%ebp),%eax
   1066e:	05 98 00 00 00       	add    $0x98,%eax
   10673:	83 ec 0c             	sub    $0xc,%esp
   10676:	50                   	push   %eax
   10677:	e8 2e 94 ff ff       	call   9aaa <lodepng_info_cleanup>
   1067c:	83 c4 10             	add    $0x10,%esp
}
   1067f:	90                   	nop
   10680:	c9                   	leave  
   10681:	c3                   	ret    

00010682 <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   10682:	55                   	push   %ebp
   10683:	89 e5                	mov    %esp,%ebp
   10685:	57                   	push   %edi
   10686:	56                   	push   %esi
   10687:	53                   	push   %ebx
   10688:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   1068b:	83 ec 0c             	sub    $0xc,%esp
   1068e:	ff 75 08             	pushl  0x8(%ebp)
   10691:	e8 bd ff ff ff       	call   10653 <lodepng_state_cleanup>
   10696:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   10699:	8b 55 08             	mov    0x8(%ebp),%edx
   1069c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1069f:	89 c3                	mov    %eax,%ebx
   106a1:	b8 60 00 00 00       	mov    $0x60,%eax
   106a6:	89 d7                	mov    %edx,%edi
   106a8:	89 de                	mov    %ebx,%esi
   106aa:	89 c1                	mov    %eax,%ecx
   106ac:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   106ae:	8b 45 08             	mov    0x8(%ebp),%eax
   106b1:	83 c0 78             	add    $0x78,%eax
   106b4:	83 ec 0c             	sub    $0xc,%esp
   106b7:	50                   	push   %eax
   106b8:	e8 75 83 ff ff       	call   8a32 <lodepng_color_mode_init>
   106bd:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   106c0:	8b 45 08             	mov    0x8(%ebp),%eax
   106c3:	05 98 00 00 00       	add    $0x98,%eax
   106c8:	83 ec 0c             	sub    $0xc,%esp
   106cb:	50                   	push   %eax
   106cc:	e8 f8 92 ff ff       	call   99c9 <lodepng_info_init>
   106d1:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   106d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   106d7:	8d 50 78             	lea    0x78(%eax),%edx
   106da:	8b 45 08             	mov    0x8(%ebp),%eax
   106dd:	83 c0 78             	add    $0x78,%eax
   106e0:	83 ec 08             	sub    $0x8,%esp
   106e3:	52                   	push   %edx
   106e4:	50                   	push   %eax
   106e5:	e8 52 84 ff ff       	call   8b3c <lodepng_color_mode_copy>
   106ea:	83 c4 10             	add    $0x10,%esp
   106ed:	89 c2                	mov    %eax,%edx
   106ef:	8b 45 08             	mov    0x8(%ebp),%eax
   106f2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   106f8:	8b 45 08             	mov    0x8(%ebp),%eax
   106fb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10701:	85 c0                	test   %eax,%eax
   10703:	75 36                	jne    1073b <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   10705:	8b 45 0c             	mov    0xc(%ebp),%eax
   10708:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   1070e:	8b 45 08             	mov    0x8(%ebp),%eax
   10711:	05 98 00 00 00       	add    $0x98,%eax
   10716:	83 ec 08             	sub    $0x8,%esp
   10719:	52                   	push   %edx
   1071a:	50                   	push   %eax
   1071b:	e8 dd 93 ff ff       	call   9afd <lodepng_info_copy>
   10720:	83 c4 10             	add    $0x10,%esp
   10723:	89 c2                	mov    %eax,%edx
   10725:	8b 45 08             	mov    0x8(%ebp),%eax
   10728:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   1072e:	8b 45 08             	mov    0x8(%ebp),%eax
   10731:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10737:	85 c0                	test   %eax,%eax
   10739:	eb 01                	jmp    1073c <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   1073b:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   1073c:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1073f:	5b                   	pop    %ebx
   10740:	5e                   	pop    %esi
   10741:	5f                   	pop    %edi
   10742:	5d                   	pop    %ebp
   10743:	c3                   	ret    

00010744 <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   10744:	55                   	push   %ebp
   10745:	89 e5                	mov    %esp,%ebp
   10747:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   1074a:	8b 45 08             	mov    0x8(%ebp),%eax
   1074d:	8b 40 04             	mov    0x4(%eax),%eax
   10750:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   10753:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   10757:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   1075b:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   1075f:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   10763:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   10767:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   1076b:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   1076f:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   10773:	8b 45 08             	mov    0x8(%ebp),%eax
   10776:	8b 40 04             	mov    0x4(%eax),%eax
   10779:	83 c0 08             	add    $0x8,%eax
   1077c:	50                   	push   %eax
   1077d:	ff 75 08             	pushl  0x8(%ebp)
   10780:	e8 f8 2d ff ff       	call   357d <ucvector_resize>
   10785:	83 c4 08             	add    $0x8,%esp
   10788:	85 c0                	test   %eax,%eax
   1078a:	75 07                	jne    10793 <writeSignature+0x4f>
   1078c:	b8 53 00 00 00       	mov    $0x53,%eax
   10791:	eb 1e                	jmp    107b1 <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   10793:	8b 45 08             	mov    0x8(%ebp),%eax
   10796:	8b 10                	mov    (%eax),%edx
   10798:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1079b:	01 c2                	add    %eax,%edx
   1079d:	6a 08                	push   $0x8
   1079f:	8d 45 f4             	lea    -0xc(%ebp),%eax
   107a2:	50                   	push   %eax
   107a3:	52                   	push   %edx
   107a4:	e8 b8 2b ff ff       	call   3361 <lodepng_memcpy>
   107a9:	83 c4 0c             	add    $0xc,%esp
  return 0;
   107ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
   107b1:	c9                   	leave  
   107b2:	c3                   	ret    

000107b3 <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   107b3:	55                   	push   %ebp
   107b4:	89 e5                	mov    %esp,%ebp
   107b6:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   107b9:	68 2c a0 01 00       	push   $0x1a02c
   107be:	6a 0d                	push   $0xd
   107c0:	ff 75 08             	pushl  0x8(%ebp)
   107c3:	8d 45 f4             	lea    -0xc(%ebp),%eax
   107c6:	50                   	push   %eax
   107c7:	e8 cf 7f ff ff       	call   879b <lodepng_chunk_init>
   107cc:	83 c4 10             	add    $0x10,%esp
   107cf:	89 45 fc             	mov    %eax,-0x4(%ebp)
   107d2:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   107d6:	74 05                	je     107dd <addChunk_IHDR+0x2a>
   107d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   107db:	eb 6d                	jmp    1084a <addChunk_IHDR+0x97>
  data = chunk + 8;
   107dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   107e0:	83 c0 08             	add    $0x8,%eax
   107e3:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   107e6:	ff 75 0c             	pushl  0xc(%ebp)
   107e9:	ff 75 f8             	pushl  -0x8(%ebp)
   107ec:	e8 f3 2e ff ff       	call   36e4 <lodepng_set32bitInt>
   107f1:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   107f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
   107f7:	83 c0 04             	add    $0x4,%eax
   107fa:	ff 75 10             	pushl  0x10(%ebp)
   107fd:	50                   	push   %eax
   107fe:	e8 e1 2e ff ff       	call   36e4 <lodepng_set32bitInt>
   10803:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   10806:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10809:	83 c0 08             	add    $0x8,%eax
   1080c:	8b 55 18             	mov    0x18(%ebp),%edx
   1080f:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   10811:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10814:	83 c0 09             	add    $0x9,%eax
   10817:	8b 55 14             	mov    0x14(%ebp),%edx
   1081a:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   1081c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1081f:	83 c0 0a             	add    $0xa,%eax
   10822:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   10825:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10828:	83 c0 0b             	add    $0xb,%eax
   1082b:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   1082e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10831:	83 c0 0c             	add    $0xc,%eax
   10834:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10837:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   10839:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1083c:	50                   	push   %eax
   1083d:	e8 02 7c ff ff       	call   8444 <lodepng_chunk_generate_crc>
   10842:	83 c4 04             	add    $0x4,%esp
  return 0;
   10845:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1084a:	c9                   	leave  
   1084b:	c3                   	ret    

0001084c <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   1084c:	55                   	push   %ebp
   1084d:	89 e5                	mov    %esp,%ebp
   1084f:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   10852:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   10859:	8b 45 0c             	mov    0xc(%ebp),%eax
   1085c:	8b 50 0c             	mov    0xc(%eax),%edx
   1085f:	89 d0                	mov    %edx,%eax
   10861:	01 c0                	add    %eax,%eax
   10863:	01 d0                	add    %edx,%eax
   10865:	68 48 a0 01 00       	push   $0x1a048
   1086a:	50                   	push   %eax
   1086b:	ff 75 08             	pushl  0x8(%ebp)
   1086e:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10871:	50                   	push   %eax
   10872:	e8 24 7f ff ff       	call   879b <lodepng_chunk_init>
   10877:	83 c4 10             	add    $0x10,%esp
   1087a:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1087d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10881:	74 08                	je     1088b <addChunk_PLTE+0x3f>
   10883:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10886:	e9 95 00 00 00       	jmp    10920 <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   1088b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10892:	eb 70                	jmp    10904 <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   10894:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10897:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1089a:	8d 50 01             	lea    0x1(%eax),%edx
   1089d:	89 55 f8             	mov    %edx,-0x8(%ebp)
   108a0:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   108a3:	8b 45 0c             	mov    0xc(%ebp),%eax
   108a6:	8b 40 08             	mov    0x8(%eax),%eax
   108a9:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   108ac:	c1 e1 02             	shl    $0x2,%ecx
   108af:	01 c8                	add    %ecx,%eax
   108b1:	0f b6 00             	movzbl (%eax),%eax
   108b4:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   108b6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   108b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108bc:	8d 50 01             	lea    0x1(%eax),%edx
   108bf:	89 55 f8             	mov    %edx,-0x8(%ebp)
   108c2:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   108c5:	8b 45 0c             	mov    0xc(%ebp),%eax
   108c8:	8b 40 08             	mov    0x8(%eax),%eax
   108cb:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   108ce:	c1 e1 02             	shl    $0x2,%ecx
   108d1:	83 c1 01             	add    $0x1,%ecx
   108d4:	01 c8                	add    %ecx,%eax
   108d6:	0f b6 00             	movzbl (%eax),%eax
   108d9:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   108db:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   108de:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108e1:	8d 50 01             	lea    0x1(%eax),%edx
   108e4:	89 55 f8             	mov    %edx,-0x8(%ebp)
   108e7:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   108ea:	8b 45 0c             	mov    0xc(%ebp),%eax
   108ed:	8b 40 08             	mov    0x8(%eax),%eax
   108f0:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   108f3:	c1 e1 02             	shl    $0x2,%ecx
   108f6:	83 c1 02             	add    $0x2,%ecx
   108f9:	01 c8                	add    %ecx,%eax
   108fb:	0f b6 00             	movzbl (%eax),%eax
   108fe:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   10900:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10904:	8b 45 0c             	mov    0xc(%ebp),%eax
   10907:	8b 40 0c             	mov    0xc(%eax),%eax
   1090a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   1090d:	75 85                	jne    10894 <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   1090f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10912:	50                   	push   %eax
   10913:	e8 2c 7b ff ff       	call   8444 <lodepng_chunk_generate_crc>
   10918:	83 c4 04             	add    $0x4,%esp
  return 0;
   1091b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10920:	c9                   	leave  
   10921:	c3                   	ret    

00010922 <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   10922:	55                   	push   %ebp
   10923:	89 e5                	mov    %esp,%ebp
   10925:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10928:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   1092f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10932:	8b 00                	mov    (%eax),%eax
   10934:	83 f8 03             	cmp    $0x3,%eax
   10937:	0f 85 ae 00 00 00    	jne    109eb <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   1093d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10940:	8b 40 0c             	mov    0xc(%eax),%eax
   10943:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10946:	8b 45 0c             	mov    0xc(%ebp),%eax
   10949:	8b 40 0c             	mov    0xc(%eax),%eax
   1094c:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1094f:	eb 23                	jmp    10974 <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10951:	8b 45 0c             	mov    0xc(%ebp),%eax
   10954:	8b 40 08             	mov    0x8(%eax),%eax
   10957:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1095a:	83 ea 01             	sub    $0x1,%edx
   1095d:	c1 e2 02             	shl    $0x2,%edx
   10960:	83 c2 03             	add    $0x3,%edx
   10963:	01 d0                	add    %edx,%eax
   10965:	0f b6 00             	movzbl (%eax),%eax
   10968:	3c ff                	cmp    $0xff,%al
   1096a:	75 10                	jne    1097c <addChunk_tRNS+0x5a>
      --amount;
   1096c:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10970:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   10974:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10978:	75 d7                	jne    10951 <addChunk_tRNS+0x2f>
   1097a:	eb 01                	jmp    1097d <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   1097c:	90                   	nop
      --amount;
    }
    if(amount) {
   1097d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   10981:	0f 84 63 01 00 00    	je     10aea <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   10987:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1098a:	68 4d a0 01 00       	push   $0x1a04d
   1098f:	50                   	push   %eax
   10990:	ff 75 08             	pushl  0x8(%ebp)
   10993:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10996:	50                   	push   %eax
   10997:	e8 ff 7d ff ff       	call   879b <lodepng_chunk_init>
   1099c:	83 c4 10             	add    $0x10,%esp
   1099f:	89 45 f4             	mov    %eax,-0xc(%ebp)
   109a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   109a6:	74 08                	je     109b0 <addChunk_tRNS+0x8e>
   109a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   109ab:	e9 52 01 00 00       	jmp    10b02 <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   109b0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   109b7:	eb 25                	jmp    109de <addChunk_tRNS+0xbc>
   109b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   109bc:	8b 55 fc             	mov    -0x4(%ebp),%edx
   109bf:	83 c2 08             	add    $0x8,%edx
   109c2:	01 c2                	add    %eax,%edx
   109c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   109c7:	8b 40 08             	mov    0x8(%eax),%eax
   109ca:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   109cd:	c1 e1 02             	shl    $0x2,%ecx
   109d0:	83 c1 03             	add    $0x3,%ecx
   109d3:	01 c8                	add    %ecx,%eax
   109d5:	0f b6 00             	movzbl (%eax),%eax
   109d8:	88 02                	mov    %al,(%edx)
   109da:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   109de:	8b 45 fc             	mov    -0x4(%ebp),%eax
   109e1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   109e4:	75 d3                	jne    109b9 <addChunk_tRNS+0x97>
   109e6:	e9 ff 00 00 00       	jmp    10aea <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   109eb:	8b 45 0c             	mov    0xc(%ebp),%eax
   109ee:	8b 00                	mov    (%eax),%eax
   109f0:	85 c0                	test   %eax,%eax
   109f2:	75 59                	jne    10a4d <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   109f4:	8b 45 0c             	mov    0xc(%ebp),%eax
   109f7:	8b 40 10             	mov    0x10(%eax),%eax
   109fa:	85 c0                	test   %eax,%eax
   109fc:	0f 84 e8 00 00 00    	je     10aea <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   10a02:	68 4d a0 01 00       	push   $0x1a04d
   10a07:	6a 02                	push   $0x2
   10a09:	ff 75 08             	pushl  0x8(%ebp)
   10a0c:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10a0f:	50                   	push   %eax
   10a10:	e8 86 7d ff ff       	call   879b <lodepng_chunk_init>
   10a15:	83 c4 10             	add    $0x10,%esp
   10a18:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10a1b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10a1f:	74 08                	je     10a29 <addChunk_tRNS+0x107>
   10a21:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a24:	e9 d9 00 00 00       	jmp    10b02 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10a29:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a2c:	8d 50 08             	lea    0x8(%eax),%edx
   10a2f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a32:	8b 40 14             	mov    0x14(%eax),%eax
   10a35:	c1 e8 08             	shr    $0x8,%eax
   10a38:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10a3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a3d:	8d 50 09             	lea    0x9(%eax),%edx
   10a40:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a43:	8b 40 14             	mov    0x14(%eax),%eax
   10a46:	88 02                	mov    %al,(%edx)
   10a48:	e9 9d 00 00 00       	jmp    10aea <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   10a4d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a50:	8b 00                	mov    (%eax),%eax
   10a52:	83 f8 02             	cmp    $0x2,%eax
   10a55:	0f 85 8f 00 00 00    	jne    10aea <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   10a5b:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a5e:	8b 40 10             	mov    0x10(%eax),%eax
   10a61:	85 c0                	test   %eax,%eax
   10a63:	0f 84 81 00 00 00    	je     10aea <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   10a69:	68 4d a0 01 00       	push   $0x1a04d
   10a6e:	6a 06                	push   $0x6
   10a70:	ff 75 08             	pushl  0x8(%ebp)
   10a73:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10a76:	50                   	push   %eax
   10a77:	e8 1f 7d ff ff       	call   879b <lodepng_chunk_init>
   10a7c:	83 c4 10             	add    $0x10,%esp
   10a7f:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10a82:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10a86:	74 05                	je     10a8d <addChunk_tRNS+0x16b>
   10a88:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10a8b:	eb 75                	jmp    10b02 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10a8d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a90:	8d 50 08             	lea    0x8(%eax),%edx
   10a93:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a96:	8b 40 14             	mov    0x14(%eax),%eax
   10a99:	c1 e8 08             	shr    $0x8,%eax
   10a9c:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10a9e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10aa1:	8d 50 09             	lea    0x9(%eax),%edx
   10aa4:	8b 45 0c             	mov    0xc(%ebp),%eax
   10aa7:	8b 40 14             	mov    0x14(%eax),%eax
   10aaa:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   10aac:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10aaf:	8d 50 0a             	lea    0xa(%eax),%edx
   10ab2:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ab5:	8b 40 18             	mov    0x18(%eax),%eax
   10ab8:	c1 e8 08             	shr    $0x8,%eax
   10abb:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   10abd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ac0:	8d 50 0b             	lea    0xb(%eax),%edx
   10ac3:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ac6:	8b 40 18             	mov    0x18(%eax),%eax
   10ac9:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   10acb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ace:	8d 50 0c             	lea    0xc(%eax),%edx
   10ad1:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ad4:	8b 40 1c             	mov    0x1c(%eax),%eax
   10ad7:	c1 e8 08             	shr    $0x8,%eax
   10ada:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   10adc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10adf:	8d 50 0d             	lea    0xd(%eax),%edx
   10ae2:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ae5:	8b 40 1c             	mov    0x1c(%eax),%eax
   10ae8:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   10aea:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10aed:	85 c0                	test   %eax,%eax
   10aef:	74 0c                	je     10afd <addChunk_tRNS+0x1db>
   10af1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10af4:	50                   	push   %eax
   10af5:	e8 4a 79 ff ff       	call   8444 <lodepng_chunk_generate_crc>
   10afa:	83 c4 04             	add    $0x4,%esp
  return 0;
   10afd:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10b02:	c9                   	leave  
   10b03:	c3                   	ret    

00010b04 <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   10b04:	55                   	push   %ebp
   10b05:	89 e5                	mov    %esp,%ebp
   10b07:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   10b0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   10b11:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   10b18:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   10b1f:	83 ec 0c             	sub    $0xc,%esp
   10b22:	ff 75 14             	pushl  0x14(%ebp)
   10b25:	ff 75 10             	pushl  0x10(%ebp)
   10b28:	ff 75 0c             	pushl  0xc(%ebp)
   10b2b:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10b2e:	50                   	push   %eax
   10b2f:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10b32:	50                   	push   %eax
   10b33:	e8 fb 74 ff ff       	call   8033 <zlib_compress>
   10b38:	83 c4 20             	add    $0x20,%esp
   10b3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   10b3e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10b42:	75 1b                	jne    10b5f <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   10b44:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b47:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10b4a:	50                   	push   %eax
   10b4b:	68 84 a0 01 00       	push   $0x1a084
   10b50:	52                   	push   %edx
   10b51:	ff 75 08             	pushl  0x8(%ebp)
   10b54:	e8 ea 7c ff ff       	call   8843 <lodepng_chunk_createv>
   10b59:	83 c4 10             	add    $0x10,%esp
   10b5c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   10b5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b62:	83 ec 0c             	sub    $0xc,%esp
   10b65:	50                   	push   %eax
   10b66:	e8 d9 27 ff ff       	call   3344 <lodepng_free>
   10b6b:	83 c4 10             	add    $0x10,%esp
  return error;
   10b6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10b71:	c9                   	leave  
   10b72:	c3                   	ret    

00010b73 <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   10b73:	55                   	push   %ebp
   10b74:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   10b76:	6a 00                	push   $0x0
   10b78:	68 89 a0 01 00       	push   $0x1a089
   10b7d:	6a 00                	push   $0x0
   10b7f:	ff 75 08             	pushl  0x8(%ebp)
   10b82:	e8 bc 7c ff ff       	call   8843 <lodepng_chunk_createv>
   10b87:	83 c4 10             	add    $0x10,%esp
}
   10b8a:	c9                   	leave  
   10b8b:	c3                   	ret    

00010b8c <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   10b8c:	55                   	push   %ebp
   10b8d:	89 e5                	mov    %esp,%ebp
   10b8f:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10b92:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   10b99:	ff 75 0c             	pushl  0xc(%ebp)
   10b9c:	e8 1e 28 ff ff       	call   33bf <lodepng_strlen>
   10ba1:	83 c4 04             	add    $0x4,%esp
   10ba4:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10ba7:	ff 75 10             	pushl  0x10(%ebp)
   10baa:	e8 10 28 ff ff       	call   33bf <lodepng_strlen>
   10baf:	83 c4 04             	add    $0x4,%esp
   10bb2:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   10bb5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10bb8:	8d 50 01             	lea    0x1(%eax),%edx
   10bbb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10bbe:	01 d0                	add    %edx,%eax
   10bc0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10bc3:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10bc7:	7e 06                	jle    10bcf <addChunk_tEXt+0x43>
   10bc9:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   10bcd:	7e 07                	jle    10bd6 <addChunk_tEXt+0x4a>
   10bcf:	b8 59 00 00 00       	mov    $0x59,%eax
   10bd4:	eb 74                	jmp    10c4a <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   10bd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10bd9:	68 57 a0 01 00       	push   $0x1a057
   10bde:	50                   	push   %eax
   10bdf:	ff 75 08             	pushl  0x8(%ebp)
   10be2:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10be5:	50                   	push   %eax
   10be6:	e8 b0 7b ff ff       	call   879b <lodepng_chunk_init>
   10beb:	83 c4 10             	add    $0x10,%esp
   10bee:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10bf1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10bf5:	74 05                	je     10bfc <addChunk_tEXt+0x70>
   10bf7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10bfa:	eb 4e                	jmp    10c4a <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   10bfc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10bff:	83 c0 08             	add    $0x8,%eax
   10c02:	ff 75 fc             	pushl  -0x4(%ebp)
   10c05:	ff 75 0c             	pushl  0xc(%ebp)
   10c08:	50                   	push   %eax
   10c09:	e8 53 27 ff ff       	call   3361 <lodepng_memcpy>
   10c0e:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   10c11:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c14:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10c17:	83 c2 08             	add    $0x8,%edx
   10c1a:	01 d0                	add    %edx,%eax
   10c1c:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   10c1f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c22:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10c25:	83 c2 09             	add    $0x9,%edx
   10c28:	01 d0                	add    %edx,%eax
   10c2a:	ff 75 f8             	pushl  -0x8(%ebp)
   10c2d:	ff 75 10             	pushl  0x10(%ebp)
   10c30:	50                   	push   %eax
   10c31:	e8 2b 27 ff ff       	call   3361 <lodepng_memcpy>
   10c36:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   10c39:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c3c:	50                   	push   %eax
   10c3d:	e8 02 78 ff ff       	call   8444 <lodepng_chunk_generate_crc>
   10c42:	83 c4 04             	add    $0x4,%esp
  return 0;
   10c45:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10c4a:	c9                   	leave  
   10c4b:	c3                   	ret    

00010c4c <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   10c4c:	55                   	push   %ebp
   10c4d:	89 e5                	mov    %esp,%ebp
   10c4f:	53                   	push   %ebx
   10c50:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   10c53:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10c5a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   10c61:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   10c68:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10c6f:	ff 75 10             	pushl  0x10(%ebp)
   10c72:	e8 48 27 ff ff       	call   33bf <lodepng_strlen>
   10c77:	83 c4 04             	add    $0x4,%esp
   10c7a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   10c7d:	ff 75 0c             	pushl  0xc(%ebp)
   10c80:	e8 3a 27 ff ff       	call   33bf <lodepng_strlen>
   10c85:	83 c4 04             	add    $0x4,%esp
   10c88:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10c8b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10c8f:	7e 06                	jle    10c97 <addChunk_zTXt+0x4b>
   10c91:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10c95:	7e 0a                	jle    10ca1 <addChunk_zTXt+0x55>
   10c97:	b8 59 00 00 00       	mov    $0x59,%eax
   10c9c:	e9 c8 00 00 00       	jmp    10d69 <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   10ca1:	83 ec 0c             	sub    $0xc,%esp
   10ca4:	ff 75 14             	pushl  0x14(%ebp)
   10ca7:	ff 75 f0             	pushl  -0x10(%ebp)
   10caa:	ff 75 10             	pushl  0x10(%ebp)
   10cad:	8d 45 dc             	lea    -0x24(%ebp),%eax
   10cb0:	50                   	push   %eax
   10cb1:	8d 45 e0             	lea    -0x20(%ebp),%eax
   10cb4:	50                   	push   %eax
   10cb5:	e8 79 73 ff ff       	call   8033 <zlib_compress>
   10cba:	83 c4 20             	add    $0x20,%esp
   10cbd:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   10cc0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10cc4:	75 29                	jne    10cef <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   10cc6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10cc9:	8d 50 02             	lea    0x2(%eax),%edx
   10ccc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ccf:	01 d0                	add    %edx,%eax
   10cd1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   10cd4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10cd7:	68 5c a0 01 00       	push   $0x1a05c
   10cdc:	50                   	push   %eax
   10cdd:	ff 75 08             	pushl  0x8(%ebp)
   10ce0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   10ce3:	50                   	push   %eax
   10ce4:	e8 b2 7a ff ff       	call   879b <lodepng_chunk_init>
   10ce9:	83 c4 10             	add    $0x10,%esp
   10cec:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10cef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10cf3:	75 62                	jne    10d57 <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   10cf5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10cf8:	83 c0 08             	add    $0x8,%eax
   10cfb:	83 ec 04             	sub    $0x4,%esp
   10cfe:	ff 75 ec             	pushl  -0x14(%ebp)
   10d01:	ff 75 0c             	pushl  0xc(%ebp)
   10d04:	50                   	push   %eax
   10d05:	e8 57 26 ff ff       	call   3361 <lodepng_memcpy>
   10d0a:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   10d0d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d10:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10d13:	83 c2 08             	add    $0x8,%edx
   10d16:	01 d0                	add    %edx,%eax
   10d18:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   10d1b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d1e:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10d21:	83 c2 09             	add    $0x9,%edx
   10d24:	01 d0                	add    %edx,%eax
   10d26:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   10d29:	8b 55 dc             	mov    -0x24(%ebp),%edx
   10d2c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10d2f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   10d32:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   10d35:	83 c3 0a             	add    $0xa,%ebx
   10d38:	01 d9                	add    %ebx,%ecx
   10d3a:	83 ec 04             	sub    $0x4,%esp
   10d3d:	52                   	push   %edx
   10d3e:	50                   	push   %eax
   10d3f:	51                   	push   %ecx
   10d40:	e8 1c 26 ff ff       	call   3361 <lodepng_memcpy>
   10d45:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   10d48:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d4b:	83 ec 0c             	sub    $0xc,%esp
   10d4e:	50                   	push   %eax
   10d4f:	e8 f0 76 ff ff       	call   8444 <lodepng_chunk_generate_crc>
   10d54:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10d57:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10d5a:	83 ec 0c             	sub    $0xc,%esp
   10d5d:	50                   	push   %eax
   10d5e:	e8 e1 25 ff ff       	call   3344 <lodepng_free>
   10d63:	83 c4 10             	add    $0x10,%esp
  return error;
   10d66:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10d69:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10d6c:	c9                   	leave  
   10d6d:	c3                   	ret    

00010d6e <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   10d6e:	55                   	push   %ebp
   10d6f:	89 e5                	mov    %esp,%ebp
   10d71:	53                   	push   %ebx
   10d72:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   10d75:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10d7c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   10d83:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   10d8a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10d91:	ff 75 1c             	pushl  0x1c(%ebp)
   10d94:	e8 26 26 ff ff       	call   33bf <lodepng_strlen>
   10d99:	83 c4 04             	add    $0x4,%esp
   10d9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   10d9f:	ff 75 10             	pushl  0x10(%ebp)
   10da2:	e8 18 26 ff ff       	call   33bf <lodepng_strlen>
   10da7:	83 c4 04             	add    $0x4,%esp
   10daa:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10dad:	ff 75 14             	pushl  0x14(%ebp)
   10db0:	e8 0a 26 ff ff       	call   33bf <lodepng_strlen>
   10db5:	83 c4 04             	add    $0x4,%esp
   10db8:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10dbb:	ff 75 18             	pushl  0x18(%ebp)
   10dbe:	e8 fc 25 ff ff       	call   33bf <lodepng_strlen>
   10dc3:	83 c4 04             	add    $0x4,%esp
   10dc6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10dc9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10dcd:	7e 06                	jle    10dd5 <addChunk_iTXt+0x67>
   10dcf:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10dd3:	7e 0a                	jle    10ddf <addChunk_iTXt+0x71>
   10dd5:	b8 59 00 00 00       	mov    $0x59,%eax
   10dda:	e9 9a 01 00 00       	jmp    10f79 <addChunk_iTXt+0x20b>

  if(compress) {
   10ddf:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10de3:	74 1f                	je     10e04 <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   10de5:	83 ec 0c             	sub    $0xc,%esp
   10de8:	ff 75 20             	pushl  0x20(%ebp)
   10deb:	ff 75 f0             	pushl  -0x10(%ebp)
   10dee:	ff 75 1c             	pushl  0x1c(%ebp)
   10df1:	8d 45 d0             	lea    -0x30(%ebp),%eax
   10df4:	50                   	push   %eax
   10df5:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   10df8:	50                   	push   %eax
   10df9:	e8 35 72 ff ff       	call   8033 <zlib_compress>
   10dfe:	83 c4 20             	add    $0x20,%esp
   10e01:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   10e04:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e08:	75 44                	jne    10e4e <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   10e0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e0d:	8d 50 03             	lea    0x3(%eax),%edx
   10e10:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e13:	01 d0                	add    %edx,%eax
   10e15:	8d 50 01             	lea    0x1(%eax),%edx
   10e18:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10e1b:	01 d0                	add    %edx,%eax
   10e1d:	8d 50 01             	lea    0x1(%eax),%edx
   10e20:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10e24:	74 05                	je     10e2b <addChunk_iTXt+0xbd>
   10e26:	8b 45 d0             	mov    -0x30(%ebp),%eax
   10e29:	eb 03                	jmp    10e2e <addChunk_iTXt+0xc0>
   10e2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10e2e:	01 d0                	add    %edx,%eax
   10e30:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   10e33:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10e36:	68 61 a0 01 00       	push   $0x1a061
   10e3b:	50                   	push   %eax
   10e3c:	ff 75 08             	pushl  0x8(%ebp)
   10e3f:	8d 45 d8             	lea    -0x28(%ebp),%eax
   10e42:	50                   	push   %eax
   10e43:	e8 53 79 ff ff       	call   879b <lodepng_chunk_init>
   10e48:	83 c4 10             	add    $0x10,%esp
   10e4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10e4e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e52:	0f 85 0f 01 00 00    	jne    10f67 <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   10e58:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   10e5f:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10e62:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e65:	01 d0                	add    %edx,%eax
   10e67:	83 ec 04             	sub    $0x4,%esp
   10e6a:	ff 75 ec             	pushl  -0x14(%ebp)
   10e6d:	ff 75 10             	pushl  0x10(%ebp)
   10e70:	50                   	push   %eax
   10e71:	e8 eb 24 ff ff       	call   3361 <lodepng_memcpy>
   10e76:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   10e79:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e7c:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10e7f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10e82:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e85:	8d 50 01             	lea    0x1(%eax),%edx
   10e88:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10e8b:	01 c8                	add    %ecx,%eax
   10e8d:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   10e90:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10e93:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e96:	8d 50 01             	lea    0x1(%eax),%edx
   10e99:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10e9c:	01 c8                	add    %ecx,%eax
   10e9e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10ea2:	0f 95 c2             	setne  %dl
   10ea5:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   10ea7:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10eaa:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ead:	8d 50 01             	lea    0x1(%eax),%edx
   10eb0:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10eb3:	01 c8                	add    %ecx,%eax
   10eb5:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   10eb8:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10ebb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ebe:	01 d0                	add    %edx,%eax
   10ec0:	83 ec 04             	sub    $0x4,%esp
   10ec3:	ff 75 e8             	pushl  -0x18(%ebp)
   10ec6:	ff 75 14             	pushl  0x14(%ebp)
   10ec9:	50                   	push   %eax
   10eca:	e8 92 24 ff ff       	call   3361 <lodepng_memcpy>
   10ecf:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   10ed2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ed5:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10ed8:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10edb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ede:	8d 50 01             	lea    0x1(%eax),%edx
   10ee1:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10ee4:	01 c8                	add    %ecx,%eax
   10ee6:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   10ee9:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10eec:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10eef:	01 d0                	add    %edx,%eax
   10ef1:	83 ec 04             	sub    $0x4,%esp
   10ef4:	ff 75 e4             	pushl  -0x1c(%ebp)
   10ef7:	ff 75 18             	pushl  0x18(%ebp)
   10efa:	50                   	push   %eax
   10efb:	e8 61 24 ff ff       	call   3361 <lodepng_memcpy>
   10f00:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   10f03:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10f06:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10f09:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f0c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f0f:	8d 50 01             	lea    0x1(%eax),%edx
   10f12:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f15:	01 c8                	add    %ecx,%eax
   10f17:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   10f1a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10f1e:	74 1e                	je     10f3e <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   10f20:	8b 55 d0             	mov    -0x30(%ebp),%edx
   10f23:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10f26:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   10f29:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   10f2c:	01 d9                	add    %ebx,%ecx
   10f2e:	83 ec 04             	sub    $0x4,%esp
   10f31:	52                   	push   %edx
   10f32:	50                   	push   %eax
   10f33:	51                   	push   %ecx
   10f34:	e8 28 24 ff ff       	call   3361 <lodepng_memcpy>
   10f39:	83 c4 10             	add    $0x10,%esp
   10f3c:	eb 1a                	jmp    10f58 <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   10f3e:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10f41:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f44:	01 d0                	add    %edx,%eax
   10f46:	83 ec 04             	sub    $0x4,%esp
   10f49:	ff 75 f0             	pushl  -0x10(%ebp)
   10f4c:	ff 75 1c             	pushl  0x1c(%ebp)
   10f4f:	50                   	push   %eax
   10f50:	e8 0c 24 ff ff       	call   3361 <lodepng_memcpy>
   10f55:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   10f58:	8b 45 d8             	mov    -0x28(%ebp),%eax
   10f5b:	83 ec 0c             	sub    $0xc,%esp
   10f5e:	50                   	push   %eax
   10f5f:	e8 e0 74 ff ff       	call   8444 <lodepng_chunk_generate_crc>
   10f64:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10f67:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10f6a:	83 ec 0c             	sub    $0xc,%esp
   10f6d:	50                   	push   %eax
   10f6e:	e8 d1 23 ff ff       	call   3344 <lodepng_free>
   10f73:	83 c4 10             	add    $0x10,%esp
  return error;
   10f76:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10f79:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10f7c:	c9                   	leave  
   10f7d:	c3                   	ret    

00010f7e <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   10f7e:	55                   	push   %ebp
   10f7f:	89 e5                	mov    %esp,%ebp
   10f81:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   10f84:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   10f8b:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f8e:	8b 40 0c             	mov    0xc(%eax),%eax
   10f91:	85 c0                	test   %eax,%eax
   10f93:	74 0b                	je     10fa0 <addChunk_bKGD+0x22>
   10f95:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f98:	8b 40 0c             	mov    0xc(%eax),%eax
   10f9b:	83 f8 04             	cmp    $0x4,%eax
   10f9e:	75 4b                	jne    10feb <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   10fa0:	68 52 a0 01 00       	push   $0x1a052
   10fa5:	6a 02                	push   $0x2
   10fa7:	ff 75 08             	pushl  0x8(%ebp)
   10faa:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10fad:	50                   	push   %eax
   10fae:	e8 e8 77 ff ff       	call   879b <lodepng_chunk_init>
   10fb3:	83 c4 10             	add    $0x10,%esp
   10fb6:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10fb9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10fbd:	74 08                	je     10fc7 <addChunk_bKGD+0x49>
   10fbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10fc2:	e9 19 01 00 00       	jmp    110e0 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   10fc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10fca:	8d 50 08             	lea    0x8(%eax),%edx
   10fcd:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fd0:	8b 40 30             	mov    0x30(%eax),%eax
   10fd3:	c1 e8 08             	shr    $0x8,%eax
   10fd6:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   10fd8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10fdb:	8d 50 09             	lea    0x9(%eax),%edx
   10fde:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fe1:	8b 40 30             	mov    0x30(%eax),%eax
   10fe4:	88 02                	mov    %al,(%edx)
   10fe6:	e9 dd 00 00 00       	jmp    110c8 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   10feb:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fee:	8b 40 0c             	mov    0xc(%eax),%eax
   10ff1:	83 f8 02             	cmp    $0x2,%eax
   10ff4:	74 0f                	je     11005 <addChunk_bKGD+0x87>
   10ff6:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ff9:	8b 40 0c             	mov    0xc(%eax),%eax
   10ffc:	83 f8 06             	cmp    $0x6,%eax
   10fff:	0f 85 86 00 00 00    	jne    1108b <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   11005:	68 52 a0 01 00       	push   $0x1a052
   1100a:	6a 06                	push   $0x6
   1100c:	ff 75 08             	pushl  0x8(%ebp)
   1100f:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11012:	50                   	push   %eax
   11013:	e8 83 77 ff ff       	call   879b <lodepng_chunk_init>
   11018:	83 c4 10             	add    $0x10,%esp
   1101b:	89 45 f8             	mov    %eax,-0x8(%ebp)
   1101e:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   11022:	74 08                	je     1102c <addChunk_bKGD+0xae>
   11024:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11027:	e9 b4 00 00 00       	jmp    110e0 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   1102c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1102f:	8d 50 08             	lea    0x8(%eax),%edx
   11032:	8b 45 0c             	mov    0xc(%ebp),%eax
   11035:	8b 40 30             	mov    0x30(%eax),%eax
   11038:	c1 e8 08             	shr    $0x8,%eax
   1103b:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   1103d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11040:	8d 50 09             	lea    0x9(%eax),%edx
   11043:	8b 45 0c             	mov    0xc(%ebp),%eax
   11046:	8b 40 30             	mov    0x30(%eax),%eax
   11049:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   1104b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1104e:	8d 50 0a             	lea    0xa(%eax),%edx
   11051:	8b 45 0c             	mov    0xc(%ebp),%eax
   11054:	8b 40 34             	mov    0x34(%eax),%eax
   11057:	c1 e8 08             	shr    $0x8,%eax
   1105a:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   1105c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1105f:	8d 50 0b             	lea    0xb(%eax),%edx
   11062:	8b 45 0c             	mov    0xc(%ebp),%eax
   11065:	8b 40 34             	mov    0x34(%eax),%eax
   11068:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   1106a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1106d:	8d 50 0c             	lea    0xc(%eax),%edx
   11070:	8b 45 0c             	mov    0xc(%ebp),%eax
   11073:	8b 40 38             	mov    0x38(%eax),%eax
   11076:	c1 e8 08             	shr    $0x8,%eax
   11079:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   1107b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1107e:	8d 50 0d             	lea    0xd(%eax),%edx
   11081:	8b 45 0c             	mov    0xc(%ebp),%eax
   11084:	8b 40 38             	mov    0x38(%eax),%eax
   11087:	88 02                	mov    %al,(%edx)
   11089:	eb 3d                	jmp    110c8 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   1108b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1108e:	8b 40 0c             	mov    0xc(%eax),%eax
   11091:	83 f8 03             	cmp    $0x3,%eax
   11094:	75 32                	jne    110c8 <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   11096:	68 52 a0 01 00       	push   $0x1a052
   1109b:	6a 01                	push   $0x1
   1109d:	ff 75 08             	pushl  0x8(%ebp)
   110a0:	8d 45 f0             	lea    -0x10(%ebp),%eax
   110a3:	50                   	push   %eax
   110a4:	e8 f2 76 ff ff       	call   879b <lodepng_chunk_init>
   110a9:	83 c4 10             	add    $0x10,%esp
   110ac:	89 45 fc             	mov    %eax,-0x4(%ebp)
   110af:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   110b3:	74 05                	je     110ba <addChunk_bKGD+0x13c>
   110b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   110b8:	eb 26                	jmp    110e0 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   110ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110bd:	8d 50 08             	lea    0x8(%eax),%edx
   110c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   110c3:	8b 40 30             	mov    0x30(%eax),%eax
   110c6:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   110c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110cb:	85 c0                	test   %eax,%eax
   110cd:	74 0c                	je     110db <addChunk_bKGD+0x15d>
   110cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110d2:	50                   	push   %eax
   110d3:	e8 6c 73 ff ff       	call   8444 <lodepng_chunk_generate_crc>
   110d8:	83 c4 04             	add    $0x4,%esp
  return 0;
   110db:	b8 00 00 00 00       	mov    $0x0,%eax
}
   110e0:	c9                   	leave  
   110e1:	c3                   	ret    

000110e2 <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   110e2:	55                   	push   %ebp
   110e3:	89 e5                	mov    %esp,%ebp
   110e5:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   110e8:	68 66 a0 01 00       	push   $0x1a066
   110ed:	6a 07                	push   $0x7
   110ef:	ff 75 08             	pushl  0x8(%ebp)
   110f2:	8d 45 f8             	lea    -0x8(%ebp),%eax
   110f5:	50                   	push   %eax
   110f6:	e8 a0 76 ff ff       	call   879b <lodepng_chunk_init>
   110fb:	83 c4 10             	add    $0x10,%esp
   110fe:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11101:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11105:	74 05                	je     1110c <addChunk_tIME+0x2a>
   11107:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1110a:	eb 74                	jmp    11180 <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   1110c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1110f:	8d 50 08             	lea    0x8(%eax),%edx
   11112:	8b 45 0c             	mov    0xc(%ebp),%eax
   11115:	8b 00                	mov    (%eax),%eax
   11117:	c1 e8 08             	shr    $0x8,%eax
   1111a:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   1111c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1111f:	8d 50 09             	lea    0x9(%eax),%edx
   11122:	8b 45 0c             	mov    0xc(%ebp),%eax
   11125:	8b 00                	mov    (%eax),%eax
   11127:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   11129:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1112c:	8d 50 0a             	lea    0xa(%eax),%edx
   1112f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11132:	8b 40 04             	mov    0x4(%eax),%eax
   11135:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   11137:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1113a:	8d 50 0b             	lea    0xb(%eax),%edx
   1113d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11140:	8b 40 08             	mov    0x8(%eax),%eax
   11143:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   11145:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11148:	8d 50 0c             	lea    0xc(%eax),%edx
   1114b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1114e:	8b 40 0c             	mov    0xc(%eax),%eax
   11151:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   11153:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11156:	8d 50 0d             	lea    0xd(%eax),%edx
   11159:	8b 45 0c             	mov    0xc(%ebp),%eax
   1115c:	8b 40 10             	mov    0x10(%eax),%eax
   1115f:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   11161:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11164:	8d 50 0e             	lea    0xe(%eax),%edx
   11167:	8b 45 0c             	mov    0xc(%ebp),%eax
   1116a:	8b 40 14             	mov    0x14(%eax),%eax
   1116d:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   1116f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11172:	50                   	push   %eax
   11173:	e8 cc 72 ff ff       	call   8444 <lodepng_chunk_generate_crc>
   11178:	83 c4 04             	add    $0x4,%esp
  return 0;
   1117b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11180:	c9                   	leave  
   11181:	c3                   	ret    

00011182 <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   11182:	55                   	push   %ebp
   11183:	89 e5                	mov    %esp,%ebp
   11185:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   11188:	68 6b a0 01 00       	push   $0x1a06b
   1118d:	6a 09                	push   $0x9
   1118f:	ff 75 08             	pushl  0x8(%ebp)
   11192:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11195:	50                   	push   %eax
   11196:	e8 00 76 ff ff       	call   879b <lodepng_chunk_init>
   1119b:	83 c4 10             	add    $0x10,%esp
   1119e:	89 45 fc             	mov    %eax,-0x4(%ebp)
   111a1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   111a5:	74 05                	je     111ac <addChunk_pHYs+0x2a>
   111a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   111aa:	eb 51                	jmp    111fd <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   111ac:	8b 45 0c             	mov    0xc(%ebp),%eax
   111af:	8b 40 7c             	mov    0x7c(%eax),%eax
   111b2:	8b 55 f8             	mov    -0x8(%ebp),%edx
   111b5:	83 c2 08             	add    $0x8,%edx
   111b8:	50                   	push   %eax
   111b9:	52                   	push   %edx
   111ba:	e8 25 25 ff ff       	call   36e4 <lodepng_set32bitInt>
   111bf:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   111c2:	8b 45 0c             	mov    0xc(%ebp),%eax
   111c5:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   111cb:	8b 55 f8             	mov    -0x8(%ebp),%edx
   111ce:	83 c2 0c             	add    $0xc,%edx
   111d1:	50                   	push   %eax
   111d2:	52                   	push   %edx
   111d3:	e8 0c 25 ff ff       	call   36e4 <lodepng_set32bitInt>
   111d8:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   111db:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111de:	8d 50 10             	lea    0x10(%eax),%edx
   111e1:	8b 45 0c             	mov    0xc(%ebp),%eax
   111e4:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   111ea:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   111ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111ef:	50                   	push   %eax
   111f0:	e8 4f 72 ff ff       	call   8444 <lodepng_chunk_generate_crc>
   111f5:	83 c4 04             	add    $0x4,%esp
  return 0;
   111f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   111fd:	c9                   	leave  
   111fe:	c3                   	ret    

000111ff <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   111ff:	55                   	push   %ebp
   11200:	89 e5                	mov    %esp,%ebp
   11202:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   11205:	68 70 a0 01 00       	push   $0x1a070
   1120a:	6a 04                	push   $0x4
   1120c:	ff 75 08             	pushl  0x8(%ebp)
   1120f:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11212:	50                   	push   %eax
   11213:	e8 83 75 ff ff       	call   879b <lodepng_chunk_init>
   11218:	83 c4 10             	add    $0x10,%esp
   1121b:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1121e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11222:	74 05                	je     11229 <addChunk_gAMA+0x2a>
   11224:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11227:	eb 2a                	jmp    11253 <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   11229:	8b 45 0c             	mov    0xc(%ebp),%eax
   1122c:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   11232:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11235:	83 c2 08             	add    $0x8,%edx
   11238:	50                   	push   %eax
   11239:	52                   	push   %edx
   1123a:	e8 a5 24 ff ff       	call   36e4 <lodepng_set32bitInt>
   1123f:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   11242:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11245:	50                   	push   %eax
   11246:	e8 f9 71 ff ff       	call   8444 <lodepng_chunk_generate_crc>
   1124b:	83 c4 04             	add    $0x4,%esp
  return 0;
   1124e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11253:	c9                   	leave  
   11254:	c3                   	ret    

00011255 <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   11255:	55                   	push   %ebp
   11256:	89 e5                	mov    %esp,%ebp
   11258:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   1125b:	68 75 a0 01 00       	push   $0x1a075
   11260:	6a 20                	push   $0x20
   11262:	ff 75 08             	pushl  0x8(%ebp)
   11265:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11268:	50                   	push   %eax
   11269:	e8 2d 75 ff ff       	call   879b <lodepng_chunk_init>
   1126e:	83 c4 10             	add    $0x10,%esp
   11271:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11274:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11278:	74 08                	je     11282 <addChunk_cHRM+0x2d>
   1127a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1127d:	e9 d9 00 00 00       	jmp    1135b <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   11282:	8b 45 0c             	mov    0xc(%ebp),%eax
   11285:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   1128b:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1128e:	83 c2 08             	add    $0x8,%edx
   11291:	50                   	push   %eax
   11292:	52                   	push   %edx
   11293:	e8 4c 24 ff ff       	call   36e4 <lodepng_set32bitInt>
   11298:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   1129b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1129e:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   112a4:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112a7:	83 c2 0c             	add    $0xc,%edx
   112aa:	50                   	push   %eax
   112ab:	52                   	push   %edx
   112ac:	e8 33 24 ff ff       	call   36e4 <lodepng_set32bitInt>
   112b1:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   112b4:	8b 45 0c             	mov    0xc(%ebp),%eax
   112b7:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   112bd:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112c0:	83 c2 10             	add    $0x10,%edx
   112c3:	50                   	push   %eax
   112c4:	52                   	push   %edx
   112c5:	e8 1a 24 ff ff       	call   36e4 <lodepng_set32bitInt>
   112ca:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   112cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   112d0:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   112d6:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112d9:	83 c2 14             	add    $0x14,%edx
   112dc:	50                   	push   %eax
   112dd:	52                   	push   %edx
   112de:	e8 01 24 ff ff       	call   36e4 <lodepng_set32bitInt>
   112e3:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   112e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   112e9:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   112ef:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112f2:	83 c2 18             	add    $0x18,%edx
   112f5:	50                   	push   %eax
   112f6:	52                   	push   %edx
   112f7:	e8 e8 23 ff ff       	call   36e4 <lodepng_set32bitInt>
   112fc:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   112ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   11302:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   11308:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1130b:	83 c2 1c             	add    $0x1c,%edx
   1130e:	50                   	push   %eax
   1130f:	52                   	push   %edx
   11310:	e8 cf 23 ff ff       	call   36e4 <lodepng_set32bitInt>
   11315:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   11318:	8b 45 0c             	mov    0xc(%ebp),%eax
   1131b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   11321:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11324:	83 c2 20             	add    $0x20,%edx
   11327:	50                   	push   %eax
   11328:	52                   	push   %edx
   11329:	e8 b6 23 ff ff       	call   36e4 <lodepng_set32bitInt>
   1132e:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   11331:	8b 45 0c             	mov    0xc(%ebp),%eax
   11334:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   1133a:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1133d:	83 c2 24             	add    $0x24,%edx
   11340:	50                   	push   %eax
   11341:	52                   	push   %edx
   11342:	e8 9d 23 ff ff       	call   36e4 <lodepng_set32bitInt>
   11347:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   1134a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1134d:	50                   	push   %eax
   1134e:	e8 f1 70 ff ff       	call   8444 <lodepng_chunk_generate_crc>
   11353:	83 c4 04             	add    $0x4,%esp
  return 0;
   11356:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1135b:	c9                   	leave  
   1135c:	c3                   	ret    

0001135d <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   1135d:	55                   	push   %ebp
   1135e:	89 e5                	mov    %esp,%ebp
   11360:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   11363:	8b 45 0c             	mov    0xc(%ebp),%eax
   11366:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   1136c:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   1136f:	8d 45 ff             	lea    -0x1(%ebp),%eax
   11372:	50                   	push   %eax
   11373:	68 7a a0 01 00       	push   $0x1a07a
   11378:	6a 01                	push   $0x1
   1137a:	ff 75 08             	pushl  0x8(%ebp)
   1137d:	e8 c1 74 ff ff       	call   8843 <lodepng_chunk_createv>
   11382:	83 c4 10             	add    $0x10,%esp
}
   11385:	c9                   	leave  
   11386:	c3                   	ret    

00011387 <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   11387:	55                   	push   %ebp
   11388:	89 e5                	mov    %esp,%ebp
   1138a:	53                   	push   %ebx
   1138b:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   1138e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11395:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   1139c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   113a3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   113aa:	8b 45 0c             	mov    0xc(%ebp),%eax
   113ad:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   113b3:	50                   	push   %eax
   113b4:	e8 06 20 ff ff       	call   33bf <lodepng_strlen>
   113b9:	83 c4 04             	add    $0x4,%esp
   113bc:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   113bf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   113c3:	7e 06                	jle    113cb <addChunk_iCCP+0x44>
   113c5:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   113c9:	7e 0a                	jle    113d5 <addChunk_iCCP+0x4e>
   113cb:	b8 59 00 00 00       	mov    $0x59,%eax
   113d0:	e9 df 00 00 00       	jmp    114b4 <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   113d5:	8b 45 0c             	mov    0xc(%ebp),%eax
   113d8:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   113de:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   113e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   113e3:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   113e9:	83 ec 0c             	sub    $0xc,%esp
   113ec:	ff 75 10             	pushl  0x10(%ebp)
   113ef:	52                   	push   %edx
   113f0:	50                   	push   %eax
   113f1:	8d 45 e0             	lea    -0x20(%ebp),%eax
   113f4:	50                   	push   %eax
   113f5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   113f8:	50                   	push   %eax
   113f9:	e8 35 6c ff ff       	call   8033 <zlib_compress>
   113fe:	83 c4 20             	add    $0x20,%esp
   11401:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   11404:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11408:	75 29                	jne    11433 <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   1140a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1140d:	8d 50 02             	lea    0x2(%eax),%edx
   11410:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11413:	01 d0                	add    %edx,%eax
   11415:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   11418:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1141b:	68 7f a0 01 00       	push   $0x1a07f
   11420:	50                   	push   %eax
   11421:	ff 75 08             	pushl  0x8(%ebp)
   11424:	8d 45 e8             	lea    -0x18(%ebp),%eax
   11427:	50                   	push   %eax
   11428:	e8 6e 73 ff ff       	call   879b <lodepng_chunk_init>
   1142d:	83 c4 10             	add    $0x10,%esp
   11430:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11433:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11437:	75 69                	jne    114a2 <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   11439:	8b 45 0c             	mov    0xc(%ebp),%eax
   1143c:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11442:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11445:	83 c2 08             	add    $0x8,%edx
   11448:	83 ec 04             	sub    $0x4,%esp
   1144b:	ff 75 f0             	pushl  -0x10(%ebp)
   1144e:	50                   	push   %eax
   1144f:	52                   	push   %edx
   11450:	e8 0c 1f ff ff       	call   3361 <lodepng_memcpy>
   11455:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   11458:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1145b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1145e:	83 c2 08             	add    $0x8,%edx
   11461:	01 d0                	add    %edx,%eax
   11463:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   11466:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11469:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1146c:	83 c2 09             	add    $0x9,%edx
   1146f:	01 d0                	add    %edx,%eax
   11471:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   11474:	8b 55 e0             	mov    -0x20(%ebp),%edx
   11477:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1147a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1147d:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   11480:	83 c3 0a             	add    $0xa,%ebx
   11483:	01 d9                	add    %ebx,%ecx
   11485:	83 ec 04             	sub    $0x4,%esp
   11488:	52                   	push   %edx
   11489:	50                   	push   %eax
   1148a:	51                   	push   %ecx
   1148b:	e8 d1 1e ff ff       	call   3361 <lodepng_memcpy>
   11490:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   11493:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11496:	83 ec 0c             	sub    $0xc,%esp
   11499:	50                   	push   %eax
   1149a:	e8 a5 6f ff ff       	call   8444 <lodepng_chunk_generate_crc>
   1149f:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   114a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   114a5:	83 ec 0c             	sub    $0xc,%esp
   114a8:	50                   	push   %eax
   114a9:	e8 96 1e ff ff       	call   3344 <lodepng_free>
   114ae:	83 c4 10             	add    $0x10,%esp
  return error;
   114b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   114b4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   114b7:	c9                   	leave  
   114b8:	c3                   	ret    

000114b9 <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   114b9:	55                   	push   %ebp
   114ba:	89 e5                	mov    %esp,%ebp
   114bc:	56                   	push   %esi
   114bd:	53                   	push   %ebx
   114be:	83 ec 14             	sub    $0x14,%esp
   114c1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   114c4:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   114c7:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   114cb:	83 f8 04             	cmp    $0x4,%eax
   114ce:	0f 87 41 03 00 00    	ja     11815 <filterScanline+0x35c>
   114d4:	8b 04 85 90 a0 01 00 	mov    0x1a090(,%eax,4),%eax
   114db:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   114dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   114e4:	eb 19                	jmp    114ff <filterScanline+0x46>
   114e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
   114e9:	8b 45 08             	mov    0x8(%ebp),%eax
   114ec:	01 c2                	add    %eax,%edx
   114ee:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   114f1:	8b 45 0c             	mov    0xc(%ebp),%eax
   114f4:	01 c8                	add    %ecx,%eax
   114f6:	0f b6 00             	movzbl (%eax),%eax
   114f9:	88 02                	mov    %al,(%edx)
   114fb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   114ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11502:	3b 45 14             	cmp    0x14(%ebp),%eax
   11505:	75 df                	jne    114e6 <filterScanline+0x2d>
      break;
   11507:	e9 0a 03 00 00       	jmp    11816 <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   1150c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11513:	eb 19                	jmp    1152e <filterScanline+0x75>
   11515:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11518:	8b 45 08             	mov    0x8(%ebp),%eax
   1151b:	01 c2                	add    %eax,%edx
   1151d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11520:	8b 45 0c             	mov    0xc(%ebp),%eax
   11523:	01 c8                	add    %ecx,%eax
   11525:	0f b6 00             	movzbl (%eax),%eax
   11528:	88 02                	mov    %al,(%edx)
   1152a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1152e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11531:	3b 45 18             	cmp    0x18(%ebp),%eax
   11534:	75 df                	jne    11515 <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   11536:	8b 45 18             	mov    0x18(%ebp),%eax
   11539:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1153c:	eb 2d                	jmp    1156b <filterScanline+0xb2>
   1153e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11541:	8b 45 08             	mov    0x8(%ebp),%eax
   11544:	01 c2                	add    %eax,%edx
   11546:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11549:	8b 45 0c             	mov    0xc(%ebp),%eax
   1154c:	01 c8                	add    %ecx,%eax
   1154e:	0f b6 08             	movzbl (%eax),%ecx
   11551:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11554:	2b 45 18             	sub    0x18(%ebp),%eax
   11557:	89 c3                	mov    %eax,%ebx
   11559:	8b 45 0c             	mov    0xc(%ebp),%eax
   1155c:	01 d8                	add    %ebx,%eax
   1155e:	0f b6 00             	movzbl (%eax),%eax
   11561:	29 c1                	sub    %eax,%ecx
   11563:	89 c8                	mov    %ecx,%eax
   11565:	88 02                	mov    %al,(%edx)
   11567:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1156b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1156e:	3b 45 14             	cmp    0x14(%ebp),%eax
   11571:	7c cb                	jl     1153e <filterScanline+0x85>
      break;
   11573:	e9 9e 02 00 00       	jmp    11816 <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   11578:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1157c:	74 3e                	je     115bc <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   1157e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11585:	eb 28                	jmp    115af <filterScanline+0xf6>
   11587:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1158a:	8b 45 08             	mov    0x8(%ebp),%eax
   1158d:	01 d0                	add    %edx,%eax
   1158f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11592:	8b 55 0c             	mov    0xc(%ebp),%edx
   11595:	01 ca                	add    %ecx,%edx
   11597:	0f b6 0a             	movzbl (%edx),%ecx
   1159a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1159d:	8b 55 10             	mov    0x10(%ebp),%edx
   115a0:	01 da                	add    %ebx,%edx
   115a2:	0f b6 12             	movzbl (%edx),%edx
   115a5:	29 d1                	sub    %edx,%ecx
   115a7:	89 ca                	mov    %ecx,%edx
   115a9:	88 10                	mov    %dl,(%eax)
   115ab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   115af:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115b2:	3b 45 14             	cmp    0x14(%ebp),%eax
   115b5:	75 d0                	jne    11587 <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   115b7:	e9 5a 02 00 00       	jmp    11816 <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   115bc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   115c3:	eb 19                	jmp    115de <filterScanline+0x125>
   115c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   115c8:	8b 45 08             	mov    0x8(%ebp),%eax
   115cb:	01 c2                	add    %eax,%edx
   115cd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   115d0:	8b 45 0c             	mov    0xc(%ebp),%eax
   115d3:	01 c8                	add    %ecx,%eax
   115d5:	0f b6 00             	movzbl (%eax),%eax
   115d8:	88 02                	mov    %al,(%edx)
   115da:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   115de:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115e1:	3b 45 14             	cmp    0x14(%ebp),%eax
   115e4:	75 df                	jne    115c5 <filterScanline+0x10c>
      }
      break;
   115e6:	e9 2b 02 00 00       	jmp    11816 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   115eb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   115ef:	0f 84 90 00 00 00    	je     11685 <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   115f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   115fc:	eb 28                	jmp    11626 <filterScanline+0x16d>
   115fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11601:	8b 45 08             	mov    0x8(%ebp),%eax
   11604:	01 d0                	add    %edx,%eax
   11606:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11609:	8b 55 0c             	mov    0xc(%ebp),%edx
   1160c:	01 ca                	add    %ecx,%edx
   1160e:	0f b6 12             	movzbl (%edx),%edx
   11611:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11614:	8b 4d 10             	mov    0x10(%ebp),%ecx
   11617:	01 d9                	add    %ebx,%ecx
   11619:	0f b6 09             	movzbl (%ecx),%ecx
   1161c:	d0 e9                	shr    %cl
   1161e:	29 ca                	sub    %ecx,%edx
   11620:	88 10                	mov    %dl,(%eax)
   11622:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11626:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11629:	3b 45 18             	cmp    0x18(%ebp),%eax
   1162c:	75 d0                	jne    115fe <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   1162e:	8b 45 18             	mov    0x18(%ebp),%eax
   11631:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11634:	eb 42                	jmp    11678 <filterScanline+0x1bf>
   11636:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11639:	8b 45 08             	mov    0x8(%ebp),%eax
   1163c:	01 c2                	add    %eax,%edx
   1163e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11641:	8b 45 0c             	mov    0xc(%ebp),%eax
   11644:	01 c8                	add    %ecx,%eax
   11646:	0f b6 08             	movzbl (%eax),%ecx
   11649:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1164c:	2b 45 18             	sub    0x18(%ebp),%eax
   1164f:	89 c3                	mov    %eax,%ebx
   11651:	8b 45 0c             	mov    0xc(%ebp),%eax
   11654:	01 d8                	add    %ebx,%eax
   11656:	0f b6 00             	movzbl (%eax),%eax
   11659:	0f b6 d8             	movzbl %al,%ebx
   1165c:	8b 75 f4             	mov    -0xc(%ebp),%esi
   1165f:	8b 45 10             	mov    0x10(%ebp),%eax
   11662:	01 f0                	add    %esi,%eax
   11664:	0f b6 00             	movzbl (%eax),%eax
   11667:	0f b6 c0             	movzbl %al,%eax
   1166a:	01 d8                	add    %ebx,%eax
   1166c:	d1 f8                	sar    %eax
   1166e:	29 c1                	sub    %eax,%ecx
   11670:	89 c8                	mov    %ecx,%eax
   11672:	88 02                	mov    %al,(%edx)
   11674:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11678:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1167b:	3b 45 14             	cmp    0x14(%ebp),%eax
   1167e:	7c b6                	jl     11636 <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   11680:	e9 91 01 00 00       	jmp    11816 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11685:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1168c:	eb 19                	jmp    116a7 <filterScanline+0x1ee>
   1168e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11691:	8b 45 08             	mov    0x8(%ebp),%eax
   11694:	01 c2                	add    %eax,%edx
   11696:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11699:	8b 45 0c             	mov    0xc(%ebp),%eax
   1169c:	01 c8                	add    %ecx,%eax
   1169e:	0f b6 00             	movzbl (%eax),%eax
   116a1:	88 02                	mov    %al,(%edx)
   116a3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   116a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116aa:	3b 45 18             	cmp    0x18(%ebp),%eax
   116ad:	75 df                	jne    1168e <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   116af:	8b 45 18             	mov    0x18(%ebp),%eax
   116b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
   116b5:	eb 2f                	jmp    116e6 <filterScanline+0x22d>
   116b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116ba:	8b 45 08             	mov    0x8(%ebp),%eax
   116bd:	01 c2                	add    %eax,%edx
   116bf:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   116c2:	8b 45 0c             	mov    0xc(%ebp),%eax
   116c5:	01 c8                	add    %ecx,%eax
   116c7:	0f b6 08             	movzbl (%eax),%ecx
   116ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116cd:	2b 45 18             	sub    0x18(%ebp),%eax
   116d0:	89 c3                	mov    %eax,%ebx
   116d2:	8b 45 0c             	mov    0xc(%ebp),%eax
   116d5:	01 d8                	add    %ebx,%eax
   116d7:	0f b6 00             	movzbl (%eax),%eax
   116da:	d0 e8                	shr    %al
   116dc:	29 c1                	sub    %eax,%ecx
   116de:	89 c8                	mov    %ecx,%eax
   116e0:	88 02                	mov    %al,(%edx)
   116e2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   116e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116e9:	3b 45 14             	cmp    0x14(%ebp),%eax
   116ec:	7c c9                	jl     116b7 <filterScanline+0x1fe>
      }
      break;
   116ee:	e9 23 01 00 00       	jmp    11816 <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   116f3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   116f7:	0f 84 af 00 00 00    	je     117ac <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   116fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11704:	eb 28                	jmp    1172e <filterScanline+0x275>
   11706:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11709:	8b 45 08             	mov    0x8(%ebp),%eax
   1170c:	01 d0                	add    %edx,%eax
   1170e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11711:	8b 55 0c             	mov    0xc(%ebp),%edx
   11714:	01 ca                	add    %ecx,%edx
   11716:	0f b6 0a             	movzbl (%edx),%ecx
   11719:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1171c:	8b 55 10             	mov    0x10(%ebp),%edx
   1171f:	01 da                	add    %ebx,%edx
   11721:	0f b6 12             	movzbl (%edx),%edx
   11724:	29 d1                	sub    %edx,%ecx
   11726:	89 ca                	mov    %ecx,%edx
   11728:	88 10                	mov    %dl,(%eax)
   1172a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1172e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11731:	3b 45 18             	cmp    0x18(%ebp),%eax
   11734:	75 d0                	jne    11706 <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   11736:	8b 45 18             	mov    0x18(%ebp),%eax
   11739:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1173c:	eb 64                	jmp    117a2 <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   1173e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11741:	8b 45 08             	mov    0x8(%ebp),%eax
   11744:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   11747:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1174a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1174d:	01 d0                	add    %edx,%eax
   1174f:	0f b6 00             	movzbl (%eax),%eax
   11752:	88 45 e7             	mov    %al,-0x19(%ebp)
   11755:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11758:	2b 45 18             	sub    0x18(%ebp),%eax
   1175b:	89 c2                	mov    %eax,%edx
   1175d:	8b 45 10             	mov    0x10(%ebp),%eax
   11760:	01 d0                	add    %edx,%eax
   11762:	0f b6 00             	movzbl (%eax),%eax
   11765:	0f b6 c8             	movzbl %al,%ecx
   11768:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1176b:	8b 45 10             	mov    0x10(%ebp),%eax
   1176e:	01 d0                	add    %edx,%eax
   11770:	0f b6 00             	movzbl (%eax),%eax
   11773:	0f b6 d0             	movzbl %al,%edx
   11776:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11779:	2b 45 18             	sub    0x18(%ebp),%eax
   1177c:	89 c6                	mov    %eax,%esi
   1177e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11781:	01 f0                	add    %esi,%eax
   11783:	0f b6 00             	movzbl (%eax),%eax
   11786:	0f b6 c0             	movzbl %al,%eax
   11789:	51                   	push   %ecx
   1178a:	52                   	push   %edx
   1178b:	50                   	push   %eax
   1178c:	e8 49 b8 ff ff       	call   cfda <paethPredictor>
   11791:	83 c4 0c             	add    $0xc,%esp
   11794:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   11798:	29 c1                	sub    %eax,%ecx
   1179a:	89 c8                	mov    %ecx,%eax
   1179c:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   1179e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117a5:	3b 45 14             	cmp    0x14(%ebp),%eax
   117a8:	7c 94                	jl     1173e <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   117aa:	eb 6a                	jmp    11816 <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   117ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   117b3:	eb 19                	jmp    117ce <filterScanline+0x315>
   117b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117b8:	8b 45 08             	mov    0x8(%ebp),%eax
   117bb:	01 c2                	add    %eax,%edx
   117bd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   117c3:	01 c8                	add    %ecx,%eax
   117c5:	0f b6 00             	movzbl (%eax),%eax
   117c8:	88 02                	mov    %al,(%edx)
   117ca:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117d1:	3b 45 18             	cmp    0x18(%ebp),%eax
   117d4:	75 df                	jne    117b5 <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   117d6:	8b 45 18             	mov    0x18(%ebp),%eax
   117d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
   117dc:	eb 2d                	jmp    1180b <filterScanline+0x352>
   117de:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117e1:	8b 45 08             	mov    0x8(%ebp),%eax
   117e4:	01 c2                	add    %eax,%edx
   117e6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117e9:	8b 45 0c             	mov    0xc(%ebp),%eax
   117ec:	01 c8                	add    %ecx,%eax
   117ee:	0f b6 08             	movzbl (%eax),%ecx
   117f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117f4:	2b 45 18             	sub    0x18(%ebp),%eax
   117f7:	89 c3                	mov    %eax,%ebx
   117f9:	8b 45 0c             	mov    0xc(%ebp),%eax
   117fc:	01 d8                	add    %ebx,%eax
   117fe:	0f b6 00             	movzbl (%eax),%eax
   11801:	29 c1                	sub    %eax,%ecx
   11803:	89 c8                	mov    %ecx,%eax
   11805:	88 02                	mov    %al,(%edx)
   11807:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1180b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1180e:	3b 45 14             	cmp    0x14(%ebp),%eax
   11811:	7c cb                	jl     117de <filterScanline+0x325>
      }
      break;
   11813:	eb 01                	jmp    11816 <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   11815:	90                   	nop
  }
}
   11816:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11819:	5b                   	pop    %ebx
   1181a:	5e                   	pop    %esi
   1181b:	5d                   	pop    %ebp
   1181c:	c3                   	ret    

0001181d <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   1181d:	55                   	push   %ebp
   1181e:	89 e5                	mov    %esp,%ebp
   11820:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   11823:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   1182a:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   11831:	7e 08                	jle    1183b <ilog2+0x1e>
   11833:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   11837:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   1183b:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   11842:	7e 08                	jle    1184c <ilog2+0x2f>
   11844:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   11848:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   1184c:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   11850:	7e 08                	jle    1185a <ilog2+0x3d>
   11852:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   11856:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   1185a:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   1185e:	7e 08                	jle    11868 <ilog2+0x4b>
   11860:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   11864:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   11868:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   1186c:	7e 04                	jle    11872 <ilog2+0x55>
   1186e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   11872:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11875:	c9                   	leave  
   11876:	c3                   	ret    

00011877 <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   11877:	55                   	push   %ebp
   11878:	89 e5                	mov    %esp,%ebp
   1187a:	56                   	push   %esi
   1187b:	53                   	push   %ebx
   1187c:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   1187f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11883:	75 07                	jne    1188c <ilog2i+0x15>
   11885:	b8 00 00 00 00       	mov    $0x0,%eax
   1188a:	eb 30                	jmp    118bc <ilog2i+0x45>
  l = ilog2(i);
   1188c:	ff 75 08             	pushl  0x8(%ebp)
   1188f:	e8 89 ff ff ff       	call   1181d <ilog2>
   11894:	83 c4 04             	add    $0x4,%esp
   11897:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   1189a:	8b 45 08             	mov    0x8(%ebp),%eax
   1189d:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   118a1:	89 c3                	mov    %eax,%ebx
   118a3:	8b 55 08             	mov    0x8(%ebp),%edx
   118a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118a9:	be 01 00 00 00       	mov    $0x1,%esi
   118ae:	89 c1                	mov    %eax,%ecx
   118b0:	d3 e6                	shl    %cl,%esi
   118b2:	89 f0                	mov    %esi,%eax
   118b4:	29 c2                	sub    %eax,%edx
   118b6:	89 d0                	mov    %edx,%eax
   118b8:	01 c0                	add    %eax,%eax
   118ba:	01 d8                	add    %ebx,%eax
}
   118bc:	8d 65 f8             	lea    -0x8(%ebp),%esp
   118bf:	5b                   	pop    %ebx
   118c0:	5e                   	pop    %esi
   118c1:	5d                   	pop    %ebp
   118c2:	c3                   	ret    

000118c3 <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   118c3:	55                   	push   %ebp
   118c4:	89 e5                	mov    %esp,%ebp
   118c6:	53                   	push   %ebx
   118c7:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   118cd:	ff 75 18             	pushl  0x18(%ebp)
   118d0:	e8 6a 75 ff ff       	call   8e3f <lodepng_get_bpp>
   118d5:	83 c4 04             	add    $0x4,%esp
   118d8:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   118db:	ff 75 b8             	pushl  -0x48(%ebp)
   118de:	6a 01                	push   $0x1
   118e0:	ff 75 10             	pushl  0x10(%ebp)
   118e3:	e8 b6 76 ff ff       	call   8f9e <lodepng_get_raw_size_idat>
   118e8:	83 c4 0c             	add    $0xc,%esp
   118eb:	83 e8 01             	sub    $0x1,%eax
   118ee:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   118f1:	8b 45 b8             	mov    -0x48(%ebp),%eax
   118f4:	83 c0 07             	add    $0x7,%eax
   118f7:	c1 e8 03             	shr    $0x3,%eax
   118fa:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   118fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   11904:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   1190b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1190e:	8b 40 2c             	mov    0x2c(%eax),%eax
   11911:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11914:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11917:	8b 40 28             	mov    0x28(%eax),%eax
   1191a:	85 c0                	test   %eax,%eax
   1191c:	74 1c                	je     1193a <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   1191e:	8b 45 18             	mov    0x18(%ebp),%eax
   11921:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11923:	83 f8 03             	cmp    $0x3,%eax
   11926:	74 0b                	je     11933 <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11928:	8b 45 18             	mov    0x18(%ebp),%eax
   1192b:	8b 40 04             	mov    0x4(%eax),%eax
   1192e:	83 f8 07             	cmp    $0x7,%eax
   11931:	77 07                	ja     1193a <filter+0x77>
   11933:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   1193a:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   1193e:	75 0a                	jne    1194a <filter+0x87>
   11940:	b8 1f 00 00 00       	mov    $0x1f,%eax
   11945:	e9 5b 07 00 00       	jmp    120a5 <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   1194a:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   1194e:	77 7b                	ja     119cb <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   11950:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11953:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   11956:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1195d:	eb 5f                	jmp    119be <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   1195f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11962:	83 c0 01             	add    $0x1,%eax
   11965:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11969:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   1196c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1196f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11973:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   11976:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11979:	8b 45 08             	mov    0x8(%ebp),%eax
   1197c:	01 c2                	add    %eax,%edx
   1197e:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11982:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11984:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11988:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   1198b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1198e:	01 d1                	add    %edx,%ecx
   11990:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11993:	8d 5a 01             	lea    0x1(%edx),%ebx
   11996:	8b 55 08             	mov    0x8(%ebp),%edx
   11999:	01 da                	add    %ebx,%edx
   1199b:	50                   	push   %eax
   1199c:	ff 75 b0             	pushl  -0x50(%ebp)
   1199f:	ff 75 b4             	pushl  -0x4c(%ebp)
   119a2:	ff 75 f4             	pushl  -0xc(%ebp)
   119a5:	51                   	push   %ecx
   119a6:	52                   	push   %edx
   119a7:	e8 0d fb ff ff       	call   114b9 <filterScanline>
   119ac:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   119af:	8b 55 98             	mov    -0x68(%ebp),%edx
   119b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   119b5:	01 d0                	add    %edx,%eax
   119b7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   119ba:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   119be:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119c1:	3b 45 14             	cmp    0x14(%ebp),%eax
   119c4:	75 99                	jne    1195f <filter+0x9c>
   119c6:	e9 d7 06 00 00       	jmp    120a2 <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   119cb:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   119cf:	0f 85 e3 01 00 00    	jne    11bb8 <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   119d5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   119dc:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   119e0:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   119e4:	eb 2d                	jmp    11a13 <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   119e6:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   119ea:	83 ec 0c             	sub    $0xc,%esp
   119ed:	ff 75 b4             	pushl  -0x4c(%ebp)
   119f0:	e8 2e 19 ff ff       	call   3323 <lodepng_malloc>
   119f5:	83 c4 10             	add    $0x10,%esp
   119f8:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   119fc:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a00:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11a04:	85 c0                	test   %eax,%eax
   11a06:	75 07                	jne    11a0f <filter+0x14c>
   11a08:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   11a0f:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11a13:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11a17:	75 cd                	jne    119e6 <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11a19:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11a1d:	0f 85 6c 01 00 00    	jne    11b8f <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   11a23:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11a2a:	e9 54 01 00 00       	jmp    11b83 <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11a2f:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11a33:	e9 d5 00 00 00       	jmp    11b0d <filter+0x24a>
          size_t sum = 0;
   11a38:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11a3f:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   11a43:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11a46:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11a4a:	89 c1                	mov    %eax,%ecx
   11a4c:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a4f:	01 c1                	add    %eax,%ecx
   11a51:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a55:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11a59:	83 ec 08             	sub    $0x8,%esp
   11a5c:	52                   	push   %edx
   11a5d:	ff 75 b0             	pushl  -0x50(%ebp)
   11a60:	ff 75 b4             	pushl  -0x4c(%ebp)
   11a63:	ff 75 f4             	pushl  -0xc(%ebp)
   11a66:	51                   	push   %ecx
   11a67:	50                   	push   %eax
   11a68:	e8 4c fa ff ff       	call   114b9 <filterScanline>
   11a6d:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   11a70:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11a74:	75 2d                	jne    11aa3 <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   11a76:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11a7d:	eb 1a                	jmp    11a99 <filter+0x1d6>
   11a7f:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a83:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11a87:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a8a:	01 d0                	add    %edx,%eax
   11a8c:	0f b6 00             	movzbl (%eax),%eax
   11a8f:	0f b6 c0             	movzbl %al,%eax
   11a92:	01 45 d8             	add    %eax,-0x28(%ebp)
   11a95:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11a99:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11a9c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11a9f:	75 de                	jne    11a7f <filter+0x1bc>
   11aa1:	eb 4b                	jmp    11aee <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   11aa3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11aaa:	eb 3a                	jmp    11ae6 <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   11aac:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11ab0:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11ab4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ab7:	01 d0                	add    %edx,%eax
   11ab9:	0f b6 00             	movzbl (%eax),%eax
   11abc:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   11abf:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11ac3:	84 c0                	test   %al,%al
   11ac5:	78 06                	js     11acd <filter+0x20a>
   11ac7:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11acb:	eb 0d                	jmp    11ada <filter+0x217>
   11acd:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11ad1:	ba ff 00 00 00       	mov    $0xff,%edx
   11ad6:	29 c2                	sub    %eax,%edx
   11ad8:	89 d0                	mov    %edx,%eax
   11ada:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11add:	01 d0                	add    %edx,%eax
   11adf:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   11ae2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11ae6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ae9:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11aec:	75 be                	jne    11aac <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   11aee:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11af2:	74 08                	je     11afc <filter+0x239>
   11af4:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11af7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   11afa:	7d 0d                	jge    11b09 <filter+0x246>
            bestType = type;
   11afc:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b00:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   11b03:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11b06:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11b09:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11b0d:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11b11:	0f 85 21 ff ff ff    	jne    11a38 <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   11b17:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b1a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b1e:	89 c2                	mov    %eax,%edx
   11b20:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b23:	01 d0                	add    %edx,%eax
   11b25:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11b28:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b2b:	83 c0 01             	add    $0x1,%eax
   11b2e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b32:	89 c2                	mov    %eax,%edx
   11b34:	8b 45 08             	mov    0x8(%ebp),%eax
   11b37:	01 c2                	add    %eax,%edx
   11b39:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11b3d:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11b3f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11b46:	eb 2f                	jmp    11b77 <filter+0x2b4>
   11b48:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b4b:	83 c0 01             	add    $0x1,%eax
   11b4e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b52:	89 c2                	mov    %eax,%edx
   11b54:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b57:	01 d0                	add    %edx,%eax
   11b59:	8d 50 01             	lea    0x1(%eax),%edx
   11b5c:	8b 45 08             	mov    0x8(%ebp),%eax
   11b5f:	01 c2                	add    %eax,%edx
   11b61:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11b65:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   11b69:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b6c:	01 c8                	add    %ecx,%eax
   11b6e:	0f b6 00             	movzbl (%eax),%eax
   11b71:	88 02                	mov    %al,(%edx)
   11b73:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11b77:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b7a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11b7d:	75 c9                	jne    11b48 <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11b7f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11b83:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b86:	3b 45 14             	cmp    0x14(%ebp),%eax
   11b89:	0f 85 a0 fe ff ff    	jne    11a2f <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11b8f:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11b93:	eb 18                	jmp    11bad <filter+0x2ea>
   11b95:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b99:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11b9d:	83 ec 0c             	sub    $0xc,%esp
   11ba0:	50                   	push   %eax
   11ba1:	e8 9e 17 ff ff       	call   3344 <lodepng_free>
   11ba6:	83 c4 10             	add    $0x10,%esp
   11ba9:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11bad:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11bb1:	75 e2                	jne    11b95 <filter+0x2d2>
   11bb3:	e9 ea 04 00 00       	jmp    120a2 <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   11bb8:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   11bbc:	0f 85 17 02 00 00    	jne    11dd9 <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   11bc2:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   11bc9:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11bd0:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11bd7:	eb 33                	jmp    11c0c <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11bd9:	83 ec 0c             	sub    $0xc,%esp
   11bdc:	ff 75 b4             	pushl  -0x4c(%ebp)
   11bdf:	e8 3f 17 ff ff       	call   3323 <lodepng_malloc>
   11be4:	83 c4 10             	add    $0x10,%esp
   11be7:	89 c2                	mov    %eax,%edx
   11be9:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11bec:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11bf3:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11bf6:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11bfd:	85 c0                	test   %eax,%eax
   11bff:	75 07                	jne    11c08 <filter+0x345>
   11c01:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11c08:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11c0c:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11c10:	75 c7                	jne    11bd9 <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11c12:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11c16:	0f 85 8f 01 00 00    	jne    11dab <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   11c1c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11c23:	e9 77 01 00 00       	jmp    11d9f <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11c28:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11c2f:	e9 f4 00 00 00       	jmp    11d28 <filter+0x465>
          size_t sum = 0;
   11c34:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11c3b:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c3e:	0f b6 d0             	movzbl %al,%edx
   11c41:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c44:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c48:	89 c1                	mov    %eax,%ecx
   11c4a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c4d:	01 c1                	add    %eax,%ecx
   11c4f:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c52:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11c59:	83 ec 08             	sub    $0x8,%esp
   11c5c:	52                   	push   %edx
   11c5d:	ff 75 b0             	pushl  -0x50(%ebp)
   11c60:	ff 75 b4             	pushl  -0x4c(%ebp)
   11c63:	ff 75 f4             	pushl  -0xc(%ebp)
   11c66:	51                   	push   %ecx
   11c67:	50                   	push   %eax
   11c68:	e8 4c f8 ff ff       	call   114b9 <filterScanline>
   11c6d:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   11c70:	83 ec 04             	sub    $0x4,%esp
   11c73:	68 00 04 00 00       	push   $0x400
   11c78:	6a 00                	push   $0x0
   11c7a:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11c80:	50                   	push   %eax
   11c81:	e8 0e 17 ff ff       	call   3394 <lodepng_memset>
   11c86:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   11c89:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11c90:	eb 2a                	jmp    11cbc <filter+0x3f9>
   11c92:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c95:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   11c9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c9f:	01 d0                	add    %edx,%eax
   11ca1:	0f b6 00             	movzbl (%eax),%eax
   11ca4:	0f b6 c0             	movzbl %al,%eax
   11ca7:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   11cae:	83 c2 01             	add    $0x1,%edx
   11cb1:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   11cb8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11cbc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11cbf:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11cc2:	75 ce                	jne    11c92 <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   11cc4:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11cc7:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11cce:	8d 50 01             	lea    0x1(%eax),%edx
   11cd1:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11cd4:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   11cdb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11ce2:	eb 1d                	jmp    11d01 <filter+0x43e>
            sum += ilog2i(count[x]);
   11ce4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ce7:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11cee:	83 ec 0c             	sub    $0xc,%esp
   11cf1:	50                   	push   %eax
   11cf2:	e8 80 fb ff ff       	call   11877 <ilog2i>
   11cf7:	83 c4 10             	add    $0x10,%esp
   11cfa:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   11cfd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d01:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   11d08:	75 da                	jne    11ce4 <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   11d0a:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   11d0e:	74 08                	je     11d18 <filter+0x455>
   11d10:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11d13:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   11d16:	7e 0c                	jle    11d24 <filter+0x461>
            bestType = type;
   11d18:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d1b:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   11d1e:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11d21:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11d24:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11d28:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11d2c:	0f 85 02 ff ff ff    	jne    11c34 <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   11d32:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d35:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d39:	89 c2                	mov    %eax,%edx
   11d3b:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d3e:	01 d0                	add    %edx,%eax
   11d40:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11d43:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d46:	83 c0 01             	add    $0x1,%eax
   11d49:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d4d:	89 c2                	mov    %eax,%edx
   11d4f:	8b 45 08             	mov    0x8(%ebp),%eax
   11d52:	01 d0                	add    %edx,%eax
   11d54:	8b 55 cc             	mov    -0x34(%ebp),%edx
   11d57:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11d59:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d60:	eb 31                	jmp    11d93 <filter+0x4d0>
   11d62:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d65:	83 c0 01             	add    $0x1,%eax
   11d68:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d6c:	89 c2                	mov    %eax,%edx
   11d6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d71:	01 d0                	add    %edx,%eax
   11d73:	8d 50 01             	lea    0x1(%eax),%edx
   11d76:	8b 45 08             	mov    0x8(%ebp),%eax
   11d79:	01 c2                	add    %eax,%edx
   11d7b:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11d7e:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   11d85:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d88:	01 c8                	add    %ecx,%eax
   11d8a:	0f b6 00             	movzbl (%eax),%eax
   11d8d:	88 02                	mov    %al,(%edx)
   11d8f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d93:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d96:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11d99:	75 c7                	jne    11d62 <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11d9b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11d9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11da2:	3b 45 14             	cmp    0x14(%ebp),%eax
   11da5:	0f 85 7d fe ff ff    	jne    11c28 <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11dab:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11db2:	eb 1a                	jmp    11dce <filter+0x50b>
   11db4:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11db7:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11dbe:	83 ec 0c             	sub    $0xc,%esp
   11dc1:	50                   	push   %eax
   11dc2:	e8 7d 15 ff ff       	call   3344 <lodepng_free>
   11dc7:	83 c4 10             	add    $0x10,%esp
   11dca:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11dce:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11dd2:	75 e0                	jne    11db4 <filter+0x4f1>
   11dd4:	e9 c9 02 00 00       	jmp    120a2 <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   11dd9:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   11ddd:	0f 85 89 00 00 00    	jne    11e6c <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   11de3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11dea:	eb 73                	jmp    11e5f <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11dec:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11def:	83 c0 01             	add    $0x1,%eax
   11df2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11df6:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   11df9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11dfc:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e00:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   11e03:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11e06:	8b 50 30             	mov    0x30(%eax),%edx
   11e09:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e0c:	01 d0                	add    %edx,%eax
   11e0e:	0f b6 00             	movzbl (%eax),%eax
   11e11:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   11e14:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11e17:	8b 45 08             	mov    0x8(%ebp),%eax
   11e1a:	01 c2                	add    %eax,%edx
   11e1c:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11e20:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11e22:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11e26:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   11e29:	8b 55 0c             	mov    0xc(%ebp),%edx
   11e2c:	01 d1                	add    %edx,%ecx
   11e2e:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11e31:	8d 5a 01             	lea    0x1(%edx),%ebx
   11e34:	8b 55 08             	mov    0x8(%ebp),%edx
   11e37:	01 da                	add    %ebx,%edx
   11e39:	83 ec 08             	sub    $0x8,%esp
   11e3c:	50                   	push   %eax
   11e3d:	ff 75 b0             	pushl  -0x50(%ebp)
   11e40:	ff 75 b4             	pushl  -0x4c(%ebp)
   11e43:	ff 75 f4             	pushl  -0xc(%ebp)
   11e46:	51                   	push   %ecx
   11e47:	52                   	push   %edx
   11e48:	e8 6c f6 ff ff       	call   114b9 <filterScanline>
   11e4d:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   11e50:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   11e53:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e56:	01 d0                	add    %edx,%eax
   11e58:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   11e5b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11e5f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e62:	3b 45 14             	cmp    0x14(%ebp),%eax
   11e65:	75 85                	jne    11dec <filter+0x529>
   11e67:	e9 36 02 00 00       	jmp    120a2 <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   11e6c:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   11e70:	0f 85 25 02 00 00    	jne    1209b <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11e76:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   11e7d:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11e84:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   11e8b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11e8e:	83 ec 04             	sub    $0x4,%esp
   11e91:	6a 24                	push   $0x24
   11e93:	50                   	push   %eax
   11e94:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11e9a:	50                   	push   %eax
   11e9b:	e8 c1 14 ff ff       	call   3361 <lodepng_memcpy>
   11ea0:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   11ea3:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   11eaa:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   11ead:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   11eb4:	00 00 00 
    zlibsettings.custom_deflate = 0;
   11eb7:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   11ebe:	00 00 00 
    for(type = 0; type != 5; ++type) {
   11ec1:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11ec8:	eb 33                	jmp    11efd <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11eca:	83 ec 0c             	sub    $0xc,%esp
   11ecd:	ff 75 b4             	pushl  -0x4c(%ebp)
   11ed0:	e8 4e 14 ff ff       	call   3323 <lodepng_malloc>
   11ed5:	83 c4 10             	add    $0x10,%esp
   11ed8:	89 c2                	mov    %eax,%edx
   11eda:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11edd:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11ee4:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11ee7:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11eee:	85 c0                	test   %eax,%eax
   11ef0:	75 07                	jne    11ef9 <filter+0x636>
   11ef2:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   11ef9:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   11efd:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   11f01:	75 c7                	jne    11eca <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   11f03:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11f07:	0f 85 63 01 00 00    	jne    12070 <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   11f0d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11f14:	e9 4b 01 00 00       	jmp    12064 <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   11f19:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11f20:	e9 c8 00 00 00       	jmp    11fed <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   11f25:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f28:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11f2b:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f2e:	0f b6 d0             	movzbl %al,%edx
   11f31:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f34:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11f38:	89 c1                	mov    %eax,%ecx
   11f3a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f3d:	01 c1                	add    %eax,%ecx
   11f3f:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f42:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11f49:	83 ec 08             	sub    $0x8,%esp
   11f4c:	52                   	push   %edx
   11f4d:	ff 75 b0             	pushl  -0x50(%ebp)
   11f50:	ff 75 b4             	pushl  -0x4c(%ebp)
   11f53:	ff 75 f4             	pushl  -0xc(%ebp)
   11f56:	51                   	push   %ecx
   11f57:	50                   	push   %eax
   11f58:	e8 5c f5 ff ff       	call   114b9 <filterScanline>
   11f5d:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   11f60:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f63:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   11f6a:	00 00 00 00 
          dummy = 0;
   11f6e:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   11f75:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   11f78:	8b 55 ac             	mov    -0x54(%ebp),%edx
   11f7b:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f7e:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11f85:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   11f8b:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   11f8e:	c1 e3 02             	shl    $0x2,%ebx
   11f91:	01 cb                	add    %ecx,%ebx
   11f93:	83 ec 0c             	sub    $0xc,%esp
   11f96:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   11f9c:	51                   	push   %ecx
   11f9d:	52                   	push   %edx
   11f9e:	50                   	push   %eax
   11f9f:	53                   	push   %ebx
   11fa0:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   11fa6:	50                   	push   %eax
   11fa7:	e8 87 60 ff ff       	call   8033 <zlib_compress>
   11fac:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   11faf:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   11fb5:	83 ec 0c             	sub    $0xc,%esp
   11fb8:	50                   	push   %eax
   11fb9:	e8 86 13 ff ff       	call   3344 <lodepng_free>
   11fbe:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   11fc1:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   11fc5:	74 0f                	je     11fd6 <filter+0x713>
   11fc7:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fca:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   11fd1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   11fd4:	7d 13                	jge    11fe9 <filter+0x726>
            bestType = type;
   11fd6:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fd9:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   11fdc:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fdf:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   11fe6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   11fe9:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   11fed:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   11ff1:	0f 85 2e ff ff ff    	jne    11f25 <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   11ff7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ffa:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ffe:	89 c2                	mov    %eax,%edx
   12000:	8b 45 0c             	mov    0xc(%ebp),%eax
   12003:	01 d0                	add    %edx,%eax
   12005:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   12008:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1200b:	83 c0 01             	add    $0x1,%eax
   1200e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12012:	89 c2                	mov    %eax,%edx
   12014:	8b 45 08             	mov    0x8(%ebp),%eax
   12017:	01 d0                	add    %edx,%eax
   12019:	8b 55 bc             	mov    -0x44(%ebp),%edx
   1201c:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   1201e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12025:	eb 31                	jmp    12058 <filter+0x795>
   12027:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1202a:	83 c0 01             	add    $0x1,%eax
   1202d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12031:	89 c2                	mov    %eax,%edx
   12033:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12036:	01 d0                	add    %edx,%eax
   12038:	8d 50 01             	lea    0x1(%eax),%edx
   1203b:	8b 45 08             	mov    0x8(%ebp),%eax
   1203e:	01 c2                	add    %eax,%edx
   12040:	8b 45 bc             	mov    -0x44(%ebp),%eax
   12043:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   1204a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1204d:	01 c8                	add    %ecx,%eax
   1204f:	0f b6 00             	movzbl (%eax),%eax
   12052:	88 02                	mov    %al,(%edx)
   12054:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12058:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1205b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1205e:	75 c7                	jne    12027 <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   12060:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12064:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12067:	3b 45 14             	cmp    0x14(%ebp),%eax
   1206a:	0f 85 a9 fe ff ff    	jne    11f19 <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   12070:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12077:	eb 1a                	jmp    12093 <filter+0x7d0>
   12079:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1207c:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12083:	83 ec 0c             	sub    $0xc,%esp
   12086:	50                   	push   %eax
   12087:	e8 b8 12 ff ff       	call   3344 <lodepng_free>
   1208c:	83 c4 10             	add    $0x10,%esp
   1208f:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12093:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   12097:	75 e0                	jne    12079 <filter+0x7b6>
   12099:	eb 07                	jmp    120a2 <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   1209b:	b8 58 00 00 00       	mov    $0x58,%eax
   120a0:	eb 03                	jmp    120a5 <filter+0x7e2>

  return error;
   120a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   120a5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   120a8:	c9                   	leave  
   120a9:	c3                   	ret    

000120aa <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   120aa:	55                   	push   %ebp
   120ab:	89 e5                	mov    %esp,%ebp
   120ad:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   120b0:	8b 45 10             	mov    0x10(%ebp),%eax
   120b3:	2b 45 14             	sub    0x14(%ebp),%eax
   120b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   120b9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   120c0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   120c7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   120ce:	eb 65                	jmp    12135 <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   120d0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   120d7:	eb 2a                	jmp    12103 <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   120d9:	ff 75 0c             	pushl  0xc(%ebp)
   120dc:	8d 45 e8             	lea    -0x18(%ebp),%eax
   120df:	50                   	push   %eax
   120e0:	e8 9d 60 ff ff       	call   8182 <readBitFromReversedStream>
   120e5:	83 c4 08             	add    $0x8,%esp
   120e8:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   120eb:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   120ef:	50                   	push   %eax
   120f0:	ff 75 08             	pushl  0x8(%ebp)
   120f3:	8d 45 ec             	lea    -0x14(%ebp),%eax
   120f6:	50                   	push   %eax
   120f7:	e8 08 61 ff ff       	call   8204 <setBitOfReversedStream>
   120fc:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   120ff:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12103:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12106:	3b 45 14             	cmp    0x14(%ebp),%eax
   12109:	7c ce                	jl     120d9 <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   1210b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12112:	eb 15                	jmp    12129 <addPaddingBits+0x7f>
   12114:	6a 00                	push   $0x0
   12116:	ff 75 08             	pushl  0x8(%ebp)
   12119:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1211c:	50                   	push   %eax
   1211d:	e8 e2 60 ff ff       	call   8204 <setBitOfReversedStream>
   12122:	83 c4 0c             	add    $0xc,%esp
   12125:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12129:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1212c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1212f:	75 e3                	jne    12114 <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   12131:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12135:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12138:	3b 45 18             	cmp    0x18(%ebp),%eax
   1213b:	75 93                	jne    120d0 <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   1213d:	90                   	nop
   1213e:	c9                   	leave  
   1213f:	c3                   	ret    

00012140 <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   12140:	55                   	push   %ebp
   12141:	89 e5                	mov    %esp,%ebp
   12143:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   12149:	ff 75 18             	pushl  0x18(%ebp)
   1214c:	ff 75 14             	pushl  0x14(%ebp)
   1214f:	ff 75 10             	pushl  0x10(%ebp)
   12152:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   12158:	50                   	push   %eax
   12159:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   1215f:	50                   	push   %eax
   12160:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   12166:	50                   	push   %eax
   12167:	8d 45 94             	lea    -0x6c(%ebp),%eax
   1216a:	50                   	push   %eax
   1216b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1216e:	50                   	push   %eax
   1216f:	e8 fc ae ff ff       	call   d070 <Adam7_getpassvalues>
   12174:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   12177:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   1217b:	0f 86 0a 01 00 00    	jbe    1228b <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   12181:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12188:	e9 ef 00 00 00       	jmp    1227c <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   1218d:	8b 45 18             	mov    0x18(%ebp),%eax
   12190:	c1 e8 03             	shr    $0x3,%eax
   12193:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   12196:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1219d:	e9 c6 00 00 00       	jmp    12268 <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   121a2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   121a9:	e9 a6 00 00 00       	jmp    12254 <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   121ae:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121b1:	8b 14 85 d8 9f 01 00 	mov    0x19fd8(,%eax,4),%edx
   121b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121bb:	8b 04 85 10 a0 01 00 	mov    0x1a010(,%eax,4),%eax
   121c2:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   121c6:	01 d0                	add    %edx,%eax
   121c8:	0f af 45 10          	imul   0x10(%ebp),%eax
   121cc:	89 c2                	mov    %eax,%edx
   121ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121d1:	8b 04 85 f4 9f 01 00 	mov    0x19ff4(,%eax,4),%eax
   121d8:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   121dc:	01 c2                	add    %eax,%edx
   121de:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121e1:	8b 04 85 bc 9f 01 00 	mov    0x19fbc(,%eax,4),%eax
   121e8:	01 c2                	add    %eax,%edx
   121ea:	8b 45 e0             	mov    -0x20(%ebp),%eax
   121ed:	0f af c2             	imul   %edx,%eax
   121f0:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   121f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121f6:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   121fd:	89 c1                	mov    %eax,%ecx
   121ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12202:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12206:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   1220a:	89 c2                	mov    %eax,%edx
   1220c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1220f:	01 c2                	add    %eax,%edx
   12211:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12214:	0f af c2             	imul   %edx,%eax
   12217:	01 c8                	add    %ecx,%eax
   12219:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   1221c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12223:	eb 23                	jmp    12248 <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   12225:	8b 55 d8             	mov    -0x28(%ebp),%edx
   12228:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1222b:	01 c2                	add    %eax,%edx
   1222d:	8b 45 08             	mov    0x8(%ebp),%eax
   12230:	01 c2                	add    %eax,%edx
   12232:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   12235:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12238:	01 c1                	add    %eax,%ecx
   1223a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1223d:	01 c8                	add    %ecx,%eax
   1223f:	0f b6 00             	movzbl (%eax),%eax
   12242:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   12244:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12248:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1224b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1224e:	72 d5                	jb     12225 <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12250:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12254:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12257:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1225b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   1225e:	0f 87 4a ff ff ff    	ja     121ae <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   12264:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12268:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1226b:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   1226f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12272:	0f 87 2a ff ff ff    	ja     121a2 <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   12278:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1227c:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12280:	0f 85 07 ff ff ff    	jne    1218d <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12286:	e9 22 01 00 00       	jmp    123ad <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   1228b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12292:	e9 0c 01 00 00       	jmp    123a3 <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   12297:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1229a:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1229e:	0f af 45 18          	imul   0x18(%ebp),%eax
   122a2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   122a5:	8b 45 18             	mov    0x18(%ebp),%eax
   122a8:	0f af 45 10          	imul   0x10(%ebp),%eax
   122ac:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   122af:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   122b6:	e9 d4 00 00 00       	jmp    1238f <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   122bb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   122c2:	e9 b4 00 00 00       	jmp    1237b <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   122c7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122ca:	8b 14 85 d8 9f 01 00 	mov    0x19fd8(,%eax,4),%edx
   122d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122d4:	8b 04 85 10 a0 01 00 	mov    0x1a010(,%eax,4),%eax
   122db:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   122df:	01 d0                	add    %edx,%eax
   122e1:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   122e5:	89 c2                	mov    %eax,%edx
   122e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122ea:	8b 0c 85 bc 9f 01 00 	mov    0x19fbc(,%eax,4),%ecx
   122f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122f4:	8b 04 85 f4 9f 01 00 	mov    0x19ff4(,%eax,4),%eax
   122fb:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   122ff:	01 c8                	add    %ecx,%eax
   12301:	0f af 45 18          	imul   0x18(%ebp),%eax
   12305:	01 d0                	add    %edx,%eax
   12307:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   1230d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12310:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   12317:	c1 e0 03             	shl    $0x3,%eax
   1231a:	89 c1                	mov    %eax,%ecx
   1231c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1231f:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   12323:	89 c2                	mov    %eax,%edx
   12325:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12328:	0f af 45 18          	imul   0x18(%ebp),%eax
   1232c:	01 d0                	add    %edx,%eax
   1232e:	01 c8                	add    %ecx,%eax
   12330:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   12336:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1233d:	eb 30                	jmp    1236f <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   1233f:	ff 75 0c             	pushl  0xc(%ebp)
   12342:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   12348:	50                   	push   %eax
   12349:	e8 34 5e ff ff       	call   8182 <readBitFromReversedStream>
   1234e:	83 c4 08             	add    $0x8,%esp
   12351:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   12354:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   12358:	50                   	push   %eax
   12359:	ff 75 08             	pushl  0x8(%ebp)
   1235c:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   12362:	50                   	push   %eax
   12363:	e8 9c 5e ff ff       	call   8204 <setBitOfReversedStream>
   12368:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   1236b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1236f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12372:	3b 45 18             	cmp    0x18(%ebp),%eax
   12375:	72 c8                	jb     1233f <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12377:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1237b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1237e:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12382:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   12385:	0f 87 3c ff ff ff    	ja     122c7 <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   1238b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   1238f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12392:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12396:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   12399:	0f 87 1c ff ff ff    	ja     122bb <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   1239f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   123a3:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   123a7:	0f 85 ea fe ff ff    	jne    12297 <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   123ad:	90                   	nop
   123ae:	c9                   	leave  
   123af:	c3                   	ret    

000123b0 <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   123b0:	55                   	push   %ebp
   123b1:	89 e5                	mov    %esp,%ebp
   123b3:	57                   	push   %edi
   123b4:	56                   	push   %esi
   123b5:	53                   	push   %ebx
   123b6:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   123bc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   123bf:	83 c0 0c             	add    $0xc,%eax
   123c2:	50                   	push   %eax
   123c3:	e8 77 6a ff ff       	call   8e3f <lodepng_get_bpp>
   123c8:	83 c4 04             	add    $0x4,%esp
   123cb:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   123ce:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   123d5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   123d8:	8b 40 08             	mov    0x8(%eax),%eax
   123db:	85 c0                	test   %eax,%eax
   123dd:	0f 85 49 01 00 00    	jne    1252c <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   123e3:	8b 45 14             	mov    0x14(%ebp),%eax
   123e6:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   123ea:	83 c0 07             	add    $0x7,%eax
   123ed:	c1 e8 03             	shr    $0x3,%eax
   123f0:	83 c0 01             	add    $0x1,%eax
   123f3:	0f af 45 18          	imul   0x18(%ebp),%eax
   123f7:	89 c2                	mov    %eax,%edx
   123f9:	8b 45 0c             	mov    0xc(%ebp),%eax
   123fc:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   123fe:	8b 45 0c             	mov    0xc(%ebp),%eax
   12401:	8b 00                	mov    (%eax),%eax
   12403:	83 ec 0c             	sub    $0xc,%esp
   12406:	50                   	push   %eax
   12407:	e8 17 0f ff ff       	call   3323 <lodepng_malloc>
   1240c:	83 c4 10             	add    $0x10,%esp
   1240f:	89 c2                	mov    %eax,%edx
   12411:	8b 45 08             	mov    0x8(%ebp),%eax
   12414:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   12416:	8b 45 08             	mov    0x8(%ebp),%eax
   12419:	8b 00                	mov    (%eax),%eax
   1241b:	85 c0                	test   %eax,%eax
   1241d:	75 10                	jne    1242f <preProcessScanlines+0x7f>
   1241f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12422:	8b 00                	mov    (%eax),%eax
   12424:	85 c0                	test   %eax,%eax
   12426:	74 07                	je     1242f <preProcessScanlines+0x7f>
   12428:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   1242f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12433:	0f 85 fb 02 00 00    	jne    12734 <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   12439:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   1243d:	0f 87 bd 00 00 00    	ja     12500 <preProcessScanlines+0x150>
   12443:	8b 45 14             	mov    0x14(%ebp),%eax
   12446:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1244a:	89 c2                	mov    %eax,%edx
   1244c:	8b 45 14             	mov    0x14(%ebp),%eax
   1244f:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12453:	83 c0 07             	add    $0x7,%eax
   12456:	c1 e8 03             	shr    $0x3,%eax
   12459:	c1 e0 03             	shl    $0x3,%eax
   1245c:	39 c2                	cmp    %eax,%edx
   1245e:	0f 84 9c 00 00 00    	je     12500 <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   12464:	8b 45 14             	mov    0x14(%ebp),%eax
   12467:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1246b:	83 c0 07             	add    $0x7,%eax
   1246e:	c1 e8 03             	shr    $0x3,%eax
   12471:	0f af 45 18          	imul   0x18(%ebp),%eax
   12475:	83 ec 0c             	sub    $0xc,%esp
   12478:	50                   	push   %eax
   12479:	e8 a5 0e ff ff       	call   3323 <lodepng_malloc>
   1247e:	83 c4 10             	add    $0x10,%esp
   12481:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   12484:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12488:	75 07                	jne    12491 <preProcessScanlines+0xe1>
   1248a:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   12491:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12495:	75 56                	jne    124ed <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   12497:	8b 45 14             	mov    0x14(%ebp),%eax
   1249a:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1249e:	89 c2                	mov    %eax,%edx
   124a0:	8b 45 14             	mov    0x14(%ebp),%eax
   124a3:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   124a7:	83 c0 07             	add    $0x7,%eax
   124aa:	c1 e8 03             	shr    $0x3,%eax
   124ad:	c1 e0 03             	shl    $0x3,%eax
   124b0:	83 ec 0c             	sub    $0xc,%esp
   124b3:	ff 75 18             	pushl  0x18(%ebp)
   124b6:	52                   	push   %edx
   124b7:	50                   	push   %eax
   124b8:	ff 75 10             	pushl  0x10(%ebp)
   124bb:	ff 75 d8             	pushl  -0x28(%ebp)
   124be:	e8 e7 fb ff ff       	call   120aa <addPaddingBits>
   124c3:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   124c6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   124c9:	8d 50 0c             	lea    0xc(%eax),%edx
   124cc:	8b 45 08             	mov    0x8(%ebp),%eax
   124cf:	8b 00                	mov    (%eax),%eax
   124d1:	83 ec 08             	sub    $0x8,%esp
   124d4:	ff 75 20             	pushl  0x20(%ebp)
   124d7:	52                   	push   %edx
   124d8:	ff 75 18             	pushl  0x18(%ebp)
   124db:	ff 75 14             	pushl  0x14(%ebp)
   124de:	ff 75 d8             	pushl  -0x28(%ebp)
   124e1:	50                   	push   %eax
   124e2:	e8 dc f3 ff ff       	call   118c3 <filter>
   124e7:	83 c4 20             	add    $0x20,%esp
   124ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   124ed:	83 ec 0c             	sub    $0xc,%esp
   124f0:	ff 75 d8             	pushl  -0x28(%ebp)
   124f3:	e8 4c 0e ff ff       	call   3344 <lodepng_free>
   124f8:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   124fb:	e9 34 02 00 00       	jmp    12734 <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   12500:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12503:	8d 50 0c             	lea    0xc(%eax),%edx
   12506:	8b 45 08             	mov    0x8(%ebp),%eax
   12509:	8b 00                	mov    (%eax),%eax
   1250b:	83 ec 08             	sub    $0x8,%esp
   1250e:	ff 75 20             	pushl  0x20(%ebp)
   12511:	52                   	push   %edx
   12512:	ff 75 18             	pushl  0x18(%ebp)
   12515:	ff 75 14             	pushl  0x14(%ebp)
   12518:	ff 75 10             	pushl  0x10(%ebp)
   1251b:	50                   	push   %eax
   1251c:	e8 a2 f3 ff ff       	call   118c3 <filter>
   12521:	83 c4 20             	add    $0x20,%esp
   12524:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   12527:	e9 08 02 00 00       	jmp    12734 <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   1252c:	ff 75 dc             	pushl  -0x24(%ebp)
   1252f:	ff 75 18             	pushl  0x18(%ebp)
   12532:	ff 75 14             	pushl  0x14(%ebp)
   12535:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   1253b:	50                   	push   %eax
   1253c:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   12542:	50                   	push   %eax
   12543:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   12549:	50                   	push   %eax
   1254a:	8d 45 98             	lea    -0x68(%ebp),%eax
   1254d:	50                   	push   %eax
   1254e:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   12551:	50                   	push   %eax
   12552:	e8 19 ab ff ff       	call   d070 <Adam7_getpassvalues>
   12557:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   1255a:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   12560:	8b 45 0c             	mov    0xc(%ebp),%eax
   12563:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   12565:	8b 45 0c             	mov    0xc(%ebp),%eax
   12568:	8b 00                	mov    (%eax),%eax
   1256a:	83 ec 0c             	sub    $0xc,%esp
   1256d:	50                   	push   %eax
   1256e:	e8 b0 0d ff ff       	call   3323 <lodepng_malloc>
   12573:	83 c4 10             	add    $0x10,%esp
   12576:	89 c2                	mov    %eax,%edx
   12578:	8b 45 08             	mov    0x8(%ebp),%eax
   1257b:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   1257d:	8b 45 08             	mov    0x8(%ebp),%eax
   12580:	8b 00                	mov    (%eax),%eax
   12582:	85 c0                	test   %eax,%eax
   12584:	75 07                	jne    1258d <preProcessScanlines+0x1dd>
   12586:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   1258d:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12590:	83 ec 0c             	sub    $0xc,%esp
   12593:	50                   	push   %eax
   12594:	e8 8a 0d ff ff       	call   3323 <lodepng_malloc>
   12599:	83 c4 10             	add    $0x10,%esp
   1259c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   1259f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   125a3:	75 0e                	jne    125b3 <preProcessScanlines+0x203>
   125a5:	8b 45 94             	mov    -0x6c(%ebp),%eax
   125a8:	85 c0                	test   %eax,%eax
   125aa:	74 07                	je     125b3 <preProcessScanlines+0x203>
   125ac:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   125b3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   125b7:	0f 85 69 01 00 00    	jne    12726 <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   125bd:	83 ec 0c             	sub    $0xc,%esp
   125c0:	ff 75 dc             	pushl  -0x24(%ebp)
   125c3:	ff 75 18             	pushl  0x18(%ebp)
   125c6:	ff 75 14             	pushl  0x14(%ebp)
   125c9:	ff 75 10             	pushl  0x10(%ebp)
   125cc:	ff 75 d4             	pushl  -0x2c(%ebp)
   125cf:	e8 6c fb ff ff       	call   12140 <Adam7_interlace>
   125d4:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   125d7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   125de:	e9 36 01 00 00       	jmp    12719 <preProcessScanlines+0x369>
        if(bpp < 8) {
   125e3:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   125e7:	0f 87 d6 00 00 00    	ja     126c3 <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   125ed:	8b 45 e0             	mov    -0x20(%ebp),%eax
   125f0:	83 c0 01             	add    $0x1,%eax
   125f3:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   125fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
   125fd:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   12604:	29 c2                	sub    %eax,%edx
   12606:	89 d0                	mov    %edx,%eax
   12608:	83 ec 0c             	sub    $0xc,%esp
   1260b:	50                   	push   %eax
   1260c:	e8 12 0d ff ff       	call   3323 <lodepng_malloc>
   12611:	83 c4 10             	add    $0x10,%esp
   12614:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   12617:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   1261b:	75 0c                	jne    12629 <preProcessScanlines+0x279>
   1261d:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   12624:	e9 fd 00 00 00       	jmp    12726 <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   12629:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1262c:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   12630:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12633:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12637:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   1263b:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   1263d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12640:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12644:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   12648:	83 c2 07             	add    $0x7,%edx
   1264b:	c1 ea 03             	shr    $0x3,%edx
   1264e:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   12651:	89 d1                	mov    %edx,%ecx
   12653:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12656:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   1265d:	89 d6                	mov    %edx,%esi
   1265f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   12662:	01 f2                	add    %esi,%edx
   12664:	83 ec 0c             	sub    $0xc,%esp
   12667:	50                   	push   %eax
   12668:	53                   	push   %ebx
   12669:	51                   	push   %ecx
   1266a:	52                   	push   %edx
   1266b:	ff 75 d0             	pushl  -0x30(%ebp)
   1266e:	e8 37 fa ff ff       	call   120aa <addPaddingBits>
   12673:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   12676:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12679:	8d 58 0c             	lea    0xc(%eax),%ebx
   1267c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1267f:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12683:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12686:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   1268a:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1268d:	8b 31                	mov    (%ecx),%esi
   1268f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12692:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12699:	01 f1                	add    %esi,%ecx
   1269b:	83 ec 08             	sub    $0x8,%esp
   1269e:	ff 75 20             	pushl  0x20(%ebp)
   126a1:	53                   	push   %ebx
   126a2:	52                   	push   %edx
   126a3:	50                   	push   %eax
   126a4:	ff 75 d0             	pushl  -0x30(%ebp)
   126a7:	51                   	push   %ecx
   126a8:	e8 16 f2 ff ff       	call   118c3 <filter>
   126ad:	83 c4 20             	add    $0x20,%esp
   126b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   126b3:	83 ec 0c             	sub    $0xc,%esp
   126b6:	ff 75 d0             	pushl  -0x30(%ebp)
   126b9:	e8 86 0c ff ff       	call   3344 <lodepng_free>
   126be:	83 c4 10             	add    $0x10,%esp
   126c1:	eb 4c                	jmp    1270f <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   126c3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   126c6:	8d 70 0c             	lea    0xc(%eax),%esi
   126c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126cc:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   126d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126d3:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   126d7:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   126da:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   126e1:	89 cb                	mov    %ecx,%ebx
   126e3:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   126e6:	01 cb                	add    %ecx,%ebx
   126e8:	8b 4d 08             	mov    0x8(%ebp),%ecx
   126eb:	8b 39                	mov    (%ecx),%edi
   126ed:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   126f0:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   126f7:	01 f9                	add    %edi,%ecx
   126f9:	83 ec 08             	sub    $0x8,%esp
   126fc:	ff 75 20             	pushl  0x20(%ebp)
   126ff:	56                   	push   %esi
   12700:	52                   	push   %edx
   12701:	50                   	push   %eax
   12702:	53                   	push   %ebx
   12703:	51                   	push   %ecx
   12704:	e8 ba f1 ff ff       	call   118c3 <filter>
   12709:	83 c4 20             	add    $0x20,%esp
   1270c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   1270f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12713:	75 10                	jne    12725 <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   12715:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   12719:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   1271d:	0f 85 c0 fe ff ff    	jne    125e3 <preProcessScanlines+0x233>
   12723:	eb 01                	jmp    12726 <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   12725:	90                   	nop
      }
    }

    lodepng_free(adam7);
   12726:	83 ec 0c             	sub    $0xc,%esp
   12729:	ff 75 d4             	pushl  -0x2c(%ebp)
   1272c:	e8 13 0c ff ff       	call   3344 <lodepng_free>
   12731:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   12734:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   12737:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1273a:	5b                   	pop    %ebx
   1273b:	5e                   	pop    %esi
   1273c:	5f                   	pop    %edi
   1273d:	5d                   	pop    %ebp
   1273e:	c3                   	ret    

0001273f <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   1273f:	55                   	push   %ebp
   12740:	89 e5                	mov    %esp,%ebp
   12742:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   12745:	8b 45 0c             	mov    0xc(%ebp),%eax
   12748:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   1274b:	eb 47                	jmp    12794 <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   1274d:	8b 45 08             	mov    0x8(%ebp),%eax
   12750:	8d 50 04             	lea    0x4(%eax),%edx
   12753:	8b 45 08             	mov    0x8(%ebp),%eax
   12756:	ff 75 fc             	pushl  -0x4(%ebp)
   12759:	52                   	push   %edx
   1275a:	50                   	push   %eax
   1275b:	e8 73 5f ff ff       	call   86d3 <lodepng_chunk_append>
   12760:	83 c4 0c             	add    $0xc,%esp
   12763:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12766:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   1276a:	74 05                	je     12771 <addUnknownChunks+0x32>
   1276c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1276f:	eb 37                	jmp    127a8 <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   12771:	8b 45 08             	mov    0x8(%ebp),%eax
   12774:	8b 50 04             	mov    0x4(%eax),%edx
   12777:	8b 45 08             	mov    0x8(%ebp),%eax
   1277a:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   1277d:	8b 55 10             	mov    0x10(%ebp),%edx
   12780:	8b 45 0c             	mov    0xc(%ebp),%eax
   12783:	01 d0                	add    %edx,%eax
   12785:	50                   	push   %eax
   12786:	ff 75 fc             	pushl  -0x4(%ebp)
   12789:	e8 ff 5c ff ff       	call   848d <lodepng_chunk_next>
   1278e:	83 c4 08             	add    $0x8,%esp
   12791:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   12794:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12797:	8b 45 0c             	mov    0xc(%ebp),%eax
   1279a:	29 c2                	sub    %eax,%edx
   1279c:	89 d0                	mov    %edx,%eax
   1279e:	3b 45 10             	cmp    0x10(%ebp),%eax
   127a1:	7c aa                	jl     1274d <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   127a3:	b8 00 00 00 00       	mov    $0x0,%eax
}
   127a8:	c9                   	leave  
   127a9:	c3                   	ret    

000127aa <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   127aa:	55                   	push   %ebp
   127ab:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   127ad:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   127b1:	77 07                	ja     127ba <isGrayICCProfile+0x10>
   127b3:	b8 00 00 00 00       	mov    $0x0,%eax
   127b8:	eb 40                	jmp    127fa <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   127ba:	8b 45 08             	mov    0x8(%ebp),%eax
   127bd:	83 c0 10             	add    $0x10,%eax
   127c0:	0f b6 00             	movzbl (%eax),%eax
   127c3:	3c 47                	cmp    $0x47,%al
   127c5:	75 2e                	jne    127f5 <isGrayICCProfile+0x4b>
   127c7:	8b 45 08             	mov    0x8(%ebp),%eax
   127ca:	83 c0 11             	add    $0x11,%eax
   127cd:	0f b6 00             	movzbl (%eax),%eax
   127d0:	3c 52                	cmp    $0x52,%al
   127d2:	75 21                	jne    127f5 <isGrayICCProfile+0x4b>
   127d4:	8b 45 08             	mov    0x8(%ebp),%eax
   127d7:	83 c0 12             	add    $0x12,%eax
   127da:	0f b6 00             	movzbl (%eax),%eax
   127dd:	3c 41                	cmp    $0x41,%al
   127df:	75 14                	jne    127f5 <isGrayICCProfile+0x4b>
   127e1:	8b 45 08             	mov    0x8(%ebp),%eax
   127e4:	83 c0 13             	add    $0x13,%eax
   127e7:	0f b6 00             	movzbl (%eax),%eax
   127ea:	3c 59                	cmp    $0x59,%al
   127ec:	75 07                	jne    127f5 <isGrayICCProfile+0x4b>
   127ee:	b8 01 00 00 00       	mov    $0x1,%eax
   127f3:	eb 05                	jmp    127fa <isGrayICCProfile+0x50>
   127f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   127fa:	5d                   	pop    %ebp
   127fb:	c3                   	ret    

000127fc <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   127fc:	55                   	push   %ebp
   127fd:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   127ff:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12803:	77 07                	ja     1280c <isRGBICCProfile+0x10>
   12805:	b8 00 00 00 00       	mov    $0x0,%eax
   1280a:	eb 40                	jmp    1284c <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   1280c:	8b 45 08             	mov    0x8(%ebp),%eax
   1280f:	83 c0 10             	add    $0x10,%eax
   12812:	0f b6 00             	movzbl (%eax),%eax
   12815:	3c 52                	cmp    $0x52,%al
   12817:	75 2e                	jne    12847 <isRGBICCProfile+0x4b>
   12819:	8b 45 08             	mov    0x8(%ebp),%eax
   1281c:	83 c0 11             	add    $0x11,%eax
   1281f:	0f b6 00             	movzbl (%eax),%eax
   12822:	3c 47                	cmp    $0x47,%al
   12824:	75 21                	jne    12847 <isRGBICCProfile+0x4b>
   12826:	8b 45 08             	mov    0x8(%ebp),%eax
   12829:	83 c0 12             	add    $0x12,%eax
   1282c:	0f b6 00             	movzbl (%eax),%eax
   1282f:	3c 42                	cmp    $0x42,%al
   12831:	75 14                	jne    12847 <isRGBICCProfile+0x4b>
   12833:	8b 45 08             	mov    0x8(%ebp),%eax
   12836:	83 c0 13             	add    $0x13,%eax
   12839:	0f b6 00             	movzbl (%eax),%eax
   1283c:	3c 20                	cmp    $0x20,%al
   1283e:	75 07                	jne    12847 <isRGBICCProfile+0x4b>
   12840:	b8 01 00 00 00       	mov    $0x1,%eax
   12845:	eb 05                	jmp    1284c <isRGBICCProfile+0x50>
   12847:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1284c:	5d                   	pop    %ebp
   1284d:	c3                   	ret    

0001284e <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   1284e:	55                   	push   %ebp
   1284f:	89 e5                	mov    %esp,%ebp
   12851:	57                   	push   %edi
   12852:	56                   	push   %esi
   12853:	53                   	push   %ebx
   12854:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   1285a:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   12861:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   12868:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1286b:	6a 00                	push   $0x0
   1286d:	6a 00                	push   $0x0
   1286f:	50                   	push   %eax
   12870:	e8 6f 0d ff ff       	call   35e4 <ucvector_init>
   12875:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   12878:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1287b:	05 98 00 00 00       	add    $0x98,%eax
   12880:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   12883:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12889:	50                   	push   %eax
   1288a:	e8 3a 71 ff ff       	call   99c9 <lodepng_info_init>
   1288f:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   12892:	8b 45 08             	mov    0x8(%ebp),%eax
   12895:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   1289b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1289e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   128a4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128a7:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   128ae:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   128b1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128b4:	8b 40 0c             	mov    0xc(%eax),%eax
   128b7:	83 f8 03             	cmp    $0x3,%eax
   128ba:	74 0a                	je     128c6 <lodepng_encode+0x78>
   128bc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128bf:	8b 40 6c             	mov    0x6c(%eax),%eax
   128c2:	85 c0                	test   %eax,%eax
   128c4:	74 29                	je     128ef <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   128c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128c9:	8b 40 18             	mov    0x18(%eax),%eax
   128cc:	85 c0                	test   %eax,%eax
   128ce:	74 0d                	je     128dd <lodepng_encode+0x8f>
   128d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128d3:	8b 40 18             	mov    0x18(%eax),%eax
   128d6:	3d 00 01 00 00       	cmp    $0x100,%eax
   128db:	7e 12                	jle    128ef <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   128dd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128e0:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   128e7:	00 00 00 
    goto cleanup;
   128ea:	e9 78 0c 00 00       	jmp    13567 <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   128ef:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128f2:	8b 40 38             	mov    0x38(%eax),%eax
   128f5:	83 f8 02             	cmp    $0x2,%eax
   128f8:	76 12                	jbe    1290c <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   128fa:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128fd:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   12904:	00 00 00 
    goto cleanup;
   12907:	e9 5b 0c 00 00       	jmp    13567 <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   1290c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1290f:	8b 40 08             	mov    0x8(%eax),%eax
   12912:	83 f8 01             	cmp    $0x1,%eax
   12915:	76 12                	jbe    12929 <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   12917:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1291a:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   12921:	00 00 00 
    goto cleanup;
   12924:	e9 3e 0c 00 00       	jmp    13567 <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   12929:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1292c:	8b 50 10             	mov    0x10(%eax),%edx
   1292f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12932:	8b 40 0c             	mov    0xc(%eax),%eax
   12935:	52                   	push   %edx
   12936:	50                   	push   %eax
   12937:	e8 a4 5f ff ff       	call   88e0 <checkColorValidity>
   1293c:	83 c4 08             	add    $0x8,%esp
   1293f:	89 c2                	mov    %eax,%edx
   12941:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12944:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   1294a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1294d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12953:	85 c0                	test   %eax,%eax
   12955:	0f 85 c6 0b 00 00    	jne    13521 <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   1295b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1295e:	8b 50 7c             	mov    0x7c(%eax),%edx
   12961:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12964:	8b 40 78             	mov    0x78(%eax),%eax
   12967:	52                   	push   %edx
   12968:	50                   	push   %eax
   12969:	e8 72 5f ff ff       	call   88e0 <checkColorValidity>
   1296e:	83 c4 08             	add    $0x8,%esp
   12971:	89 c2                	mov    %eax,%edx
   12973:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12976:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   1297c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1297f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12985:	85 c0                	test   %eax,%eax
   12987:	0f 85 97 0b 00 00    	jne    13524 <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   1298d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12990:	05 98 00 00 00       	add    $0x98,%eax
   12995:	83 ec 08             	sub    $0x8,%esp
   12998:	50                   	push   %eax
   12999:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1299f:	50                   	push   %eax
   129a0:	e8 58 71 ff ff       	call   9afd <lodepng_info_copy>
   129a5:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   129a8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129ab:	8b 40 5c             	mov    0x5c(%eax),%eax
   129ae:	85 c0                	test   %eax,%eax
   129b0:	0f 84 3c 02 00 00    	je     12bf2 <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   129b6:	83 ec 0c             	sub    $0xc,%esp
   129b9:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   129bf:	50                   	push   %eax
   129c0:	e8 5f 96 ff ff       	call   c024 <lodepng_color_stats_init>
   129c5:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   129c8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129cb:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   129d1:	85 c0                	test   %eax,%eax
   129d3:	74 2d                	je     12a02 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   129d5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129d8:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   129de:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129e1:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   129e7:	83 ec 08             	sub    $0x8,%esp
   129ea:	52                   	push   %edx
   129eb:	50                   	push   %eax
   129ec:	e8 b9 fd ff ff       	call   127aa <isGrayICCProfile>
   129f1:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   129f4:	85 c0                	test   %eax,%eax
   129f6:	74 0a                	je     12a02 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   129f8:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   129ff:	00 00 00 
    }
    if(info_png->iccp_defined &&
   12a02:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a05:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12a0b:	85 c0                	test   %eax,%eax
   12a0d:	74 2d                	je     12a3c <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12a0f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a12:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12a18:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a1b:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12a21:	83 ec 08             	sub    $0x8,%esp
   12a24:	52                   	push   %edx
   12a25:	50                   	push   %eax
   12a26:	e8 d1 fd ff ff       	call   127fc <isRGBICCProfile>
   12a2b:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   12a2e:	85 c0                	test   %eax,%eax
   12a30:	74 0a                	je     12a3c <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   12a32:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   12a39:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   12a3c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a3f:	83 c0 78             	add    $0x78,%eax
   12a42:	83 ec 0c             	sub    $0xc,%esp
   12a45:	50                   	push   %eax
   12a46:	ff 75 18             	pushl  0x18(%ebp)
   12a49:	ff 75 14             	pushl  0x14(%ebp)
   12a4c:	ff 75 10             	pushl  0x10(%ebp)
   12a4f:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12a55:	50                   	push   %eax
   12a56:	e8 e0 96 ff ff       	call   c13b <lodepng_compute_color_stats>
   12a5b:	83 c4 20             	add    $0x20,%esp
   12a5e:	89 c2                	mov    %eax,%edx
   12a60:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a63:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12a69:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a6c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12a72:	85 c0                	test   %eax,%eax
   12a74:	0f 85 ad 0a 00 00    	jne    13527 <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   12a7a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a7d:	8b 40 2c             	mov    0x2c(%eax),%eax
   12a80:	85 c0                	test   %eax,%eax
   12a82:	0f 84 be 00 00 00    	je     12b46 <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   12a88:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   12a8f:	00 00 00 
   12a92:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   12a99:	00 00 00 
   12a9c:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   12aa3:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   12aa6:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   12aac:	83 ec 04             	sub    $0x4,%esp
   12aaf:	6a 10                	push   $0x10
   12ab1:	6a 02                	push   $0x2
   12ab3:	50                   	push   %eax
   12ab4:	e8 15 61 ff ff       	call   8bce <lodepng_color_mode_make>
   12ab9:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   12abc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12abf:	8d 58 0c             	lea    0xc(%eax),%ebx
   12ac2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ac5:	8b 48 38             	mov    0x38(%eax),%ecx
   12ac8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12acb:	8b 50 34             	mov    0x34(%eax),%edx
   12ace:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ad1:	8b 40 30             	mov    0x30(%eax),%eax
   12ad4:	53                   	push   %ebx
   12ad5:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   12adb:	53                   	push   %ebx
   12adc:	51                   	push   %ecx
   12add:	52                   	push   %edx
   12ade:	50                   	push   %eax
   12adf:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   12ae5:	50                   	push   %eax
   12ae6:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   12aec:	50                   	push   %eax
   12aed:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   12af3:	50                   	push   %eax
   12af4:	e8 8a 92 ff ff       	call   bd83 <lodepng_convert_rgb>
   12af9:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   12afc:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   12b02:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   12b08:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   12b0e:	83 ec 0c             	sub    $0xc,%esp
   12b11:	68 ff ff 00 00       	push   $0xffff
   12b16:	51                   	push   %ecx
   12b17:	52                   	push   %edx
   12b18:	50                   	push   %eax
   12b19:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12b1f:	50                   	push   %eax
   12b20:	e8 26 a1 ff ff       	call   cc4b <lodepng_color_stats_add>
   12b25:	83 c4 20             	add    $0x20,%esp
   12b28:	89 c2                	mov    %eax,%edx
   12b2a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b2d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12b33:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b36:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12b3c:	85 c0                	test   %eax,%eax
   12b3e:	74 06                	je     12b46 <lodepng_encode+0x2f8>
   12b40:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   12b41:	e9 e1 09 00 00       	jmp    13527 <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   12b46:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b49:	8d 50 78             	lea    0x78(%eax),%edx
   12b4c:	83 ec 04             	sub    $0x4,%esp
   12b4f:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12b55:	50                   	push   %eax
   12b56:	52                   	push   %edx
   12b57:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12b5d:	83 c0 0c             	add    $0xc,%eax
   12b60:	50                   	push   %eax
   12b61:	e8 79 a1 ff ff       	call   ccdf <auto_choose_color>
   12b66:	83 c4 10             	add    $0x10,%esp
   12b69:	89 c2                	mov    %eax,%edx
   12b6b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b6e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12b74:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b77:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12b7d:	85 c0                	test   %eax,%eax
   12b7f:	0f 85 a5 09 00 00    	jne    1352a <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   12b85:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b88:	8b 40 2c             	mov    0x2c(%eax),%eax
   12b8b:	85 c0                	test   %eax,%eax
   12b8d:	74 63                	je     12bf2 <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   12b8f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b92:	8d 58 0c             	lea    0xc(%eax),%ebx
   12b95:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b98:	8b 48 38             	mov    0x38(%eax),%ecx
   12b9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b9e:	8b 50 34             	mov    0x34(%eax),%edx
   12ba1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ba4:	8b 40 30             	mov    0x30(%eax),%eax
   12ba7:	53                   	push   %ebx
   12ba8:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   12bae:	83 c3 0c             	add    $0xc,%ebx
   12bb1:	53                   	push   %ebx
   12bb2:	51                   	push   %ecx
   12bb3:	52                   	push   %edx
   12bb4:	50                   	push   %eax
   12bb5:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12bbb:	83 c0 38             	add    $0x38,%eax
   12bbe:	50                   	push   %eax
   12bbf:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12bc5:	83 c0 34             	add    $0x34,%eax
   12bc8:	50                   	push   %eax
   12bc9:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12bcf:	83 c0 30             	add    $0x30,%eax
   12bd2:	50                   	push   %eax
   12bd3:	e8 ab 91 ff ff       	call   bd83 <lodepng_convert_rgb>
   12bd8:	83 c4 20             	add    $0x20,%esp
   12bdb:	85 c0                	test   %eax,%eax
   12bdd:	74 13                	je     12bf2 <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   12bdf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12be2:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   12be9:	00 00 00 
        goto cleanup;
   12bec:	90                   	nop
   12bed:	e9 75 09 00 00       	jmp    13567 <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   12bf2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bf5:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12bfb:	85 c0                	test   %eax,%eax
   12bfd:	0f 84 b2 00 00 00    	je     12cb5 <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12c03:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c06:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12c0c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c0f:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12c15:	83 ec 08             	sub    $0x8,%esp
   12c18:	52                   	push   %edx
   12c19:	50                   	push   %eax
   12c1a:	e8 8b fb ff ff       	call   127aa <isGrayICCProfile>
   12c1f:	83 c4 10             	add    $0x10,%esp
   12c22:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12c25:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c28:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12c2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c31:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12c37:	83 ec 08             	sub    $0x8,%esp
   12c3a:	52                   	push   %edx
   12c3b:	50                   	push   %eax
   12c3c:	e8 bb fb ff ff       	call   127fc <isRGBICCProfile>
   12c41:	83 c4 10             	add    $0x10,%esp
   12c44:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   12c47:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12c4d:	85 c0                	test   %eax,%eax
   12c4f:	74 0b                	je     12c5c <lodepng_encode+0x40e>
   12c51:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12c57:	83 f8 04             	cmp    $0x4,%eax
   12c5a:	75 07                	jne    12c63 <lodepng_encode+0x415>
   12c5c:	b8 01 00 00 00       	mov    $0x1,%eax
   12c61:	eb 05                	jmp    12c68 <lodepng_encode+0x41a>
   12c63:	b8 00 00 00 00       	mov    $0x0,%eax
   12c68:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   12c6b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12c6f:	75 18                	jne    12c89 <lodepng_encode+0x43b>
   12c71:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12c75:	75 12                	jne    12c89 <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   12c77:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c7a:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   12c81:	00 00 00 
      goto cleanup;
   12c84:	e9 de 08 00 00       	jmp    13567 <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   12c89:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12c8c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   12c8f:	74 24                	je     12cb5 <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   12c91:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c94:	8b 40 5c             	mov    0x5c(%eax),%eax
   12c97:	85 c0                	test   %eax,%eax
   12c99:	74 07                	je     12ca2 <lodepng_encode+0x454>
   12c9b:	ba 66 00 00 00       	mov    $0x66,%edx
   12ca0:	eb 05                	jmp    12ca7 <lodepng_encode+0x459>
   12ca2:	ba 65 00 00 00       	mov    $0x65,%edx
   12ca7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12caa:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   12cb0:	e9 b2 08 00 00       	jmp    13567 <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   12cb5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cb8:	83 c0 78             	add    $0x78,%eax
   12cbb:	83 ec 08             	sub    $0x8,%esp
   12cbe:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   12cc4:	83 c2 0c             	add    $0xc,%edx
   12cc7:	52                   	push   %edx
   12cc8:	50                   	push   %eax
   12cc9:	e8 57 5f ff ff       	call   8c25 <lodepng_color_mode_equal>
   12cce:	83 c4 10             	add    $0x10,%esp
   12cd1:	85 c0                	test   %eax,%eax
   12cd3:	0f 85 f8 00 00 00    	jne    12dd1 <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   12cd9:	8b 55 14             	mov    0x14(%ebp),%edx
   12cdc:	8b 45 18             	mov    0x18(%ebp),%eax
   12cdf:	89 d3                	mov    %edx,%ebx
   12ce1:	0f af d8             	imul   %eax,%ebx
   12ce4:	83 ec 0c             	sub    $0xc,%esp
   12ce7:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12ced:	83 c0 0c             	add    $0xc,%eax
   12cf0:	50                   	push   %eax
   12cf1:	e8 49 61 ff ff       	call   8e3f <lodepng_get_bpp>
   12cf6:	83 c4 10             	add    $0x10,%esp
   12cf9:	0f af c3             	imul   %ebx,%eax
   12cfc:	83 c0 07             	add    $0x7,%eax
   12cff:	c1 e8 03             	shr    $0x3,%eax
   12d02:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   12d05:	83 ec 0c             	sub    $0xc,%esp
   12d08:	ff 75 cc             	pushl  -0x34(%ebp)
   12d0b:	e8 13 06 ff ff       	call   3323 <lodepng_malloc>
   12d10:	83 c4 10             	add    $0x10,%esp
   12d13:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   12d16:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   12d1a:	75 13                	jne    12d2f <lodepng_encode+0x4e1>
   12d1c:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   12d20:	74 0d                	je     12d2f <lodepng_encode+0x4e1>
   12d22:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d25:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   12d2c:	00 00 00 
    if(!state->error) {
   12d2f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d32:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12d38:	85 c0                	test   %eax,%eax
   12d3a:	75 33                	jne    12d6f <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   12d3c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d3f:	83 c0 78             	add    $0x78,%eax
   12d42:	83 ec 08             	sub    $0x8,%esp
   12d45:	ff 75 18             	pushl  0x18(%ebp)
   12d48:	ff 75 14             	pushl  0x14(%ebp)
   12d4b:	50                   	push   %eax
   12d4c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d52:	83 c0 0c             	add    $0xc,%eax
   12d55:	50                   	push   %eax
   12d56:	ff 75 10             	pushl  0x10(%ebp)
   12d59:	ff 75 c8             	pushl  -0x38(%ebp)
   12d5c:	e8 c9 8c ff ff       	call   ba2a <lodepng_convert>
   12d61:	83 c4 20             	add    $0x20,%esp
   12d64:	89 c2                	mov    %eax,%edx
   12d66:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d69:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   12d6f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d72:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12d78:	85 c0                	test   %eax,%eax
   12d7a:	75 35                	jne    12db1 <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   12d7c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d7f:	83 c0 38             	add    $0x38,%eax
   12d82:	83 ec 04             	sub    $0x4,%esp
   12d85:	50                   	push   %eax
   12d86:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d8c:	50                   	push   %eax
   12d8d:	ff 75 18             	pushl  0x18(%ebp)
   12d90:	ff 75 14             	pushl  0x14(%ebp)
   12d93:	ff 75 c8             	pushl  -0x38(%ebp)
   12d96:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12d99:	50                   	push   %eax
   12d9a:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12d9d:	50                   	push   %eax
   12d9e:	e8 0d f6 ff ff       	call   123b0 <preProcessScanlines>
   12da3:	83 c4 20             	add    $0x20,%esp
   12da6:	89 c2                	mov    %eax,%edx
   12da8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dab:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   12db1:	83 ec 0c             	sub    $0xc,%esp
   12db4:	ff 75 c8             	pushl  -0x38(%ebp)
   12db7:	e8 88 05 ff ff       	call   3344 <lodepng_free>
   12dbc:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   12dbf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dc2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12dc8:	85 c0                	test   %eax,%eax
   12dca:	74 4b                	je     12e17 <lodepng_encode+0x5c9>
   12dcc:	e9 96 07 00 00       	jmp    13567 <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   12dd1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dd4:	83 c0 38             	add    $0x38,%eax
   12dd7:	83 ec 04             	sub    $0x4,%esp
   12dda:	50                   	push   %eax
   12ddb:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12de1:	50                   	push   %eax
   12de2:	ff 75 18             	pushl  0x18(%ebp)
   12de5:	ff 75 14             	pushl  0x14(%ebp)
   12de8:	ff 75 10             	pushl  0x10(%ebp)
   12deb:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12dee:	50                   	push   %eax
   12def:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12df2:	50                   	push   %eax
   12df3:	e8 b8 f5 ff ff       	call   123b0 <preProcessScanlines>
   12df8:	83 c4 20             	add    $0x20,%esp
   12dfb:	89 c2                	mov    %eax,%edx
   12dfd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e00:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e06:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e09:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e0f:	85 c0                	test   %eax,%eax
   12e11:	0f 85 16 07 00 00    	jne    1352d <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   12e17:	83 ec 0c             	sub    $0xc,%esp
   12e1a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12e1d:	50                   	push   %eax
   12e1e:	e8 21 d9 ff ff       	call   10744 <writeSignature>
   12e23:	83 c4 10             	add    $0x10,%esp
   12e26:	89 c2                	mov    %eax,%edx
   12e28:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e2b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e31:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e34:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e3a:	85 c0                	test   %eax,%eax
   12e3c:	0f 85 ee 06 00 00    	jne    13530 <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   12e42:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   12e48:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   12e4e:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12e54:	83 ec 08             	sub    $0x8,%esp
   12e57:	51                   	push   %ecx
   12e58:	52                   	push   %edx
   12e59:	50                   	push   %eax
   12e5a:	ff 75 18             	pushl  0x18(%ebp)
   12e5d:	ff 75 14             	pushl  0x14(%ebp)
   12e60:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12e63:	50                   	push   %eax
   12e64:	e8 4a d9 ff ff       	call   107b3 <addChunk_IHDR>
   12e69:	83 c4 20             	add    $0x20,%esp
   12e6c:	89 c2                	mov    %eax,%edx
   12e6e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e71:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e77:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e7a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e80:	85 c0                	test   %eax,%eax
   12e82:	0f 85 ab 06 00 00    	jne    13533 <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   12e88:	8b 45 98             	mov    -0x68(%ebp),%eax
   12e8b:	85 c0                	test   %eax,%eax
   12e8d:	74 33                	je     12ec2 <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   12e8f:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   12e92:	8b 45 98             	mov    -0x68(%ebp),%eax
   12e95:	83 ec 04             	sub    $0x4,%esp
   12e98:	52                   	push   %edx
   12e99:	50                   	push   %eax
   12e9a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12e9d:	50                   	push   %eax
   12e9e:	e8 9c f8 ff ff       	call   1273f <addUnknownChunks>
   12ea3:	83 c4 10             	add    $0x10,%esp
   12ea6:	89 c2                	mov    %eax,%edx
   12ea8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12eab:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12eb1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12eb4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12eba:	85 c0                	test   %eax,%eax
   12ebc:	0f 85 74 06 00 00    	jne    13536 <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   12ec2:	8b 45 88             	mov    -0x78(%ebp),%eax
   12ec5:	85 c0                	test   %eax,%eax
   12ec7:	74 39                	je     12f02 <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   12ec9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ecc:	83 c0 38             	add    $0x38,%eax
   12ecf:	83 ec 04             	sub    $0x4,%esp
   12ed2:	50                   	push   %eax
   12ed3:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12ed9:	50                   	push   %eax
   12eda:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12edd:	50                   	push   %eax
   12ede:	e8 a4 e4 ff ff       	call   11387 <addChunk_iCCP>
   12ee3:	83 c4 10             	add    $0x10,%esp
   12ee6:	89 c2                	mov    %eax,%edx
   12ee8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12eeb:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12ef1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ef4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12efa:	85 c0                	test   %eax,%eax
   12efc:	0f 85 37 06 00 00    	jne    13539 <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   12f02:	8b 45 80             	mov    -0x80(%ebp),%eax
   12f05:	85 c0                	test   %eax,%eax
   12f07:	74 32                	je     12f3b <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   12f09:	83 ec 08             	sub    $0x8,%esp
   12f0c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f12:	50                   	push   %eax
   12f13:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f16:	50                   	push   %eax
   12f17:	e8 41 e4 ff ff       	call   1135d <addChunk_sRGB>
   12f1c:	83 c4 10             	add    $0x10,%esp
   12f1f:	89 c2                	mov    %eax,%edx
   12f21:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f24:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f2a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f2d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f33:	85 c0                	test   %eax,%eax
   12f35:	0f 85 01 06 00 00    	jne    1353c <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   12f3b:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   12f41:	85 c0                	test   %eax,%eax
   12f43:	74 32                	je     12f77 <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   12f45:	83 ec 08             	sub    $0x8,%esp
   12f48:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f4e:	50                   	push   %eax
   12f4f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f52:	50                   	push   %eax
   12f53:	e8 a7 e2 ff ff       	call   111ff <addChunk_gAMA>
   12f58:	83 c4 10             	add    $0x10,%esp
   12f5b:	89 c2                	mov    %eax,%edx
   12f5d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f60:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f66:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f69:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f6f:	85 c0                	test   %eax,%eax
   12f71:	0f 85 c8 05 00 00    	jne    1353f <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   12f77:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   12f7d:	85 c0                	test   %eax,%eax
   12f7f:	74 32                	je     12fb3 <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   12f81:	83 ec 08             	sub    $0x8,%esp
   12f84:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f8a:	50                   	push   %eax
   12f8b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f8e:	50                   	push   %eax
   12f8f:	e8 c1 e2 ff ff       	call   11255 <addChunk_cHRM>
   12f94:	83 c4 10             	add    $0x10,%esp
   12f97:	89 c2                	mov    %eax,%edx
   12f99:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f9c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12fa2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fa5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12fab:	85 c0                	test   %eax,%eax
   12fad:	0f 85 8f 05 00 00    	jne    13542 <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   12fb3:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12fb9:	83 f8 03             	cmp    $0x3,%eax
   12fbc:	75 35                	jne    12ff3 <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   12fbe:	83 ec 08             	sub    $0x8,%esp
   12fc1:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12fc7:	83 c0 0c             	add    $0xc,%eax
   12fca:	50                   	push   %eax
   12fcb:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12fce:	50                   	push   %eax
   12fcf:	e8 78 d8 ff ff       	call   1084c <addChunk_PLTE>
   12fd4:	83 c4 10             	add    $0x10,%esp
   12fd7:	89 c2                	mov    %eax,%edx
   12fd9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fdc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12fe2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fe5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12feb:	85 c0                	test   %eax,%eax
   12fed:	0f 85 52 05 00 00    	jne    13545 <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   12ff3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ff6:	8b 40 6c             	mov    0x6c(%eax),%eax
   12ff9:	85 c0                	test   %eax,%eax
   12ffb:	74 4b                	je     13048 <lodepng_encode+0x7fa>
   12ffd:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13003:	83 f8 02             	cmp    $0x2,%eax
   13006:	74 0b                	je     13013 <lodepng_encode+0x7c5>
   13008:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1300e:	83 f8 06             	cmp    $0x6,%eax
   13011:	75 35                	jne    13048 <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   13013:	83 ec 08             	sub    $0x8,%esp
   13016:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1301c:	83 c0 0c             	add    $0xc,%eax
   1301f:	50                   	push   %eax
   13020:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13023:	50                   	push   %eax
   13024:	e8 23 d8 ff ff       	call   1084c <addChunk_PLTE>
   13029:	83 c4 10             	add    $0x10,%esp
   1302c:	89 c2                	mov    %eax,%edx
   1302e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13031:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13037:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1303a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13040:	85 c0                	test   %eax,%eax
   13042:	0f 85 00 05 00 00    	jne    13548 <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   13048:	83 ec 08             	sub    $0x8,%esp
   1304b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13051:	83 c0 0c             	add    $0xc,%eax
   13054:	50                   	push   %eax
   13055:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13058:	50                   	push   %eax
   13059:	e8 c4 d8 ff ff       	call   10922 <addChunk_tRNS>
   1305e:	83 c4 10             	add    $0x10,%esp
   13061:	89 c2                	mov    %eax,%edx
   13063:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13066:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1306c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1306f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13075:	85 c0                	test   %eax,%eax
   13077:	0f 85 ce 04 00 00    	jne    1354b <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   1307d:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   13083:	85 c0                	test   %eax,%eax
   13085:	74 32                	je     130b9 <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   13087:	83 ec 08             	sub    $0x8,%esp
   1308a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13090:	50                   	push   %eax
   13091:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13094:	50                   	push   %eax
   13095:	e8 e4 de ff ff       	call   10f7e <addChunk_bKGD>
   1309a:	83 c4 10             	add    $0x10,%esp
   1309d:	89 c2                	mov    %eax,%edx
   1309f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130a2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   130a8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130ab:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130b1:	85 c0                	test   %eax,%eax
   130b3:	0f 85 95 04 00 00    	jne    1354e <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   130b9:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   130bf:	85 c0                	test   %eax,%eax
   130c1:	74 32                	je     130f5 <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   130c3:	83 ec 08             	sub    $0x8,%esp
   130c6:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130cc:	50                   	push   %eax
   130cd:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130d0:	50                   	push   %eax
   130d1:	e8 ac e0 ff ff       	call   11182 <addChunk_pHYs>
   130d6:	83 c4 10             	add    $0x10,%esp
   130d9:	89 c2                	mov    %eax,%edx
   130db:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130de:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   130e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130e7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130ed:	85 c0                	test   %eax,%eax
   130ef:	0f 85 5c 04 00 00    	jne    13551 <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   130f5:	8b 45 9c             	mov    -0x64(%ebp),%eax
   130f8:	85 c0                	test   %eax,%eax
   130fa:	74 33                	je     1312f <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   130fc:	8b 55 a8             	mov    -0x58(%ebp),%edx
   130ff:	8b 45 9c             	mov    -0x64(%ebp),%eax
   13102:	83 ec 04             	sub    $0x4,%esp
   13105:	52                   	push   %edx
   13106:	50                   	push   %eax
   13107:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1310a:	50                   	push   %eax
   1310b:	e8 2f f6 ff ff       	call   1273f <addUnknownChunks>
   13110:	83 c4 10             	add    $0x10,%esp
   13113:	89 c2                	mov    %eax,%edx
   13115:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13118:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1311e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13121:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13127:	85 c0                	test   %eax,%eax
   13129:	0f 85 25 04 00 00    	jne    13554 <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   1312f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13132:	8d 48 38             	lea    0x38(%eax),%ecx
   13135:	8b 55 bc             	mov    -0x44(%ebp),%edx
   13138:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1313b:	51                   	push   %ecx
   1313c:	52                   	push   %edx
   1313d:	50                   	push   %eax
   1313e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13141:	50                   	push   %eax
   13142:	e8 bd d9 ff ff       	call   10b04 <addChunk_IDAT>
   13147:	83 c4 10             	add    $0x10,%esp
   1314a:	89 c2                	mov    %eax,%edx
   1314c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1314f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13155:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13158:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1315e:	85 c0                	test   %eax,%eax
   13160:	0f 85 f1 03 00 00    	jne    13557 <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   13166:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   1316c:	85 c0                	test   %eax,%eax
   1316e:	74 35                	je     131a5 <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   13170:	83 ec 08             	sub    $0x8,%esp
   13173:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13179:	83 c0 60             	add    $0x60,%eax
   1317c:	50                   	push   %eax
   1317d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13180:	50                   	push   %eax
   13181:	e8 5c df ff ff       	call   110e2 <addChunk_tIME>
   13186:	83 c4 10             	add    $0x10,%esp
   13189:	89 c2                	mov    %eax,%edx
   1318b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1318e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13194:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13197:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1319d:	85 c0                	test   %eax,%eax
   1319f:	0f 85 b5 03 00 00    	jne    1355a <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   131a5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   131ac:	e9 12 01 00 00       	jmp    132c3 <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   131b1:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   131b7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   131ba:	c1 e2 02             	shl    $0x2,%edx
   131bd:	01 d0                	add    %edx,%eax
   131bf:	8b 00                	mov    (%eax),%eax
   131c1:	83 ec 0c             	sub    $0xc,%esp
   131c4:	50                   	push   %eax
   131c5:	e8 f5 01 ff ff       	call   33bf <lodepng_strlen>
   131ca:	83 c4 10             	add    $0x10,%esp
   131cd:	83 f8 4f             	cmp    $0x4f,%eax
   131d0:	7e 12                	jle    131e4 <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   131d2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131d5:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   131dc:	00 00 00 
        goto cleanup;
   131df:	e9 83 03 00 00       	jmp    13567 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   131e4:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   131ea:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   131ed:	c1 e2 02             	shl    $0x2,%edx
   131f0:	01 d0                	add    %edx,%eax
   131f2:	8b 00                	mov    (%eax),%eax
   131f4:	83 ec 0c             	sub    $0xc,%esp
   131f7:	50                   	push   %eax
   131f8:	e8 c2 01 ff ff       	call   33bf <lodepng_strlen>
   131fd:	83 c4 10             	add    $0x10,%esp
   13200:	85 c0                	test   %eax,%eax
   13202:	7f 12                	jg     13216 <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   13204:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13207:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   1320e:	00 00 00 
        goto cleanup;
   13211:	e9 51 03 00 00       	jmp    13567 <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   13216:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13219:	8b 40 74             	mov    0x74(%eax),%eax
   1321c:	85 c0                	test   %eax,%eax
   1321e:	74 52                	je     13272 <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   13220:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13223:	8d 48 38             	lea    0x38(%eax),%ecx
   13226:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   1322c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1322f:	c1 e2 02             	shl    $0x2,%edx
   13232:	01 d0                	add    %edx,%eax
   13234:	8b 10                	mov    (%eax),%edx
   13236:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1323c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   1323f:	c1 e3 02             	shl    $0x2,%ebx
   13242:	01 d8                	add    %ebx,%eax
   13244:	8b 00                	mov    (%eax),%eax
   13246:	51                   	push   %ecx
   13247:	52                   	push   %edx
   13248:	50                   	push   %eax
   13249:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1324c:	50                   	push   %eax
   1324d:	e8 fa d9 ff ff       	call   10c4c <addChunk_zTXt>
   13252:	83 c4 10             	add    $0x10,%esp
   13255:	89 c2                	mov    %eax,%edx
   13257:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1325a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13260:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13263:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13269:	85 c0                	test   %eax,%eax
   1326b:	74 52                	je     132bf <lodepng_encode+0xa71>
   1326d:	e9 f5 02 00 00       	jmp    13567 <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   13272:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   13278:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1327b:	c1 e2 02             	shl    $0x2,%edx
   1327e:	01 d0                	add    %edx,%eax
   13280:	8b 10                	mov    (%eax),%edx
   13282:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13288:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   1328b:	c1 e1 02             	shl    $0x2,%ecx
   1328e:	01 c8                	add    %ecx,%eax
   13290:	8b 00                	mov    (%eax),%eax
   13292:	83 ec 04             	sub    $0x4,%esp
   13295:	52                   	push   %edx
   13296:	50                   	push   %eax
   13297:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1329a:	50                   	push   %eax
   1329b:	e8 ec d8 ff ff       	call   10b8c <addChunk_tEXt>
   132a0:	83 c4 10             	add    $0x10,%esp
   132a3:	89 c2                	mov    %eax,%edx
   132a5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132a8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   132ae:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132b1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   132b7:	85 c0                	test   %eax,%eax
   132b9:	0f 85 9e 02 00 00    	jne    1355d <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   132bf:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   132c3:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   132c9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   132cc:	0f 85 df fe ff ff    	jne    131b1 <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   132d2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132d5:	8b 40 70             	mov    0x70(%eax),%eax
   132d8:	85 c0                	test   %eax,%eax
   132da:	0f 84 e3 00 00 00    	je     133c3 <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   132e0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   132e7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   132ee:	e9 85 00 00 00       	jmp    13378 <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   132f3:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   132f9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   132fc:	c1 e2 02             	shl    $0x2,%edx
   132ff:	01 d0                	add    %edx,%eax
   13301:	8b 00                	mov    (%eax),%eax
   13303:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13306:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13309:	0f b6 00             	movzbl (%eax),%eax
   1330c:	3c 4c                	cmp    $0x4c,%al
   1330e:	75 64                	jne    13374 <lodepng_encode+0xb26>
   13310:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13313:	83 c0 01             	add    $0x1,%eax
   13316:	0f b6 00             	movzbl (%eax),%eax
   13319:	3c 6f                	cmp    $0x6f,%al
   1331b:	75 57                	jne    13374 <lodepng_encode+0xb26>
   1331d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13320:	83 c0 02             	add    $0x2,%eax
   13323:	0f b6 00             	movzbl (%eax),%eax
   13326:	3c 64                	cmp    $0x64,%al
   13328:	75 4a                	jne    13374 <lodepng_encode+0xb26>
   1332a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1332d:	83 c0 03             	add    $0x3,%eax
   13330:	0f b6 00             	movzbl (%eax),%eax
   13333:	3c 65                	cmp    $0x65,%al
   13335:	75 3d                	jne    13374 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13337:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1333a:	83 c0 04             	add    $0x4,%eax
   1333d:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13340:	3c 50                	cmp    $0x50,%al
   13342:	75 30                	jne    13374 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13344:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13347:	83 c0 05             	add    $0x5,%eax
   1334a:	0f b6 00             	movzbl (%eax),%eax
   1334d:	3c 4e                	cmp    $0x4e,%al
   1334f:	75 23                	jne    13374 <lodepng_encode+0xb26>
   13351:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13354:	83 c0 06             	add    $0x6,%eax
   13357:	0f b6 00             	movzbl (%eax),%eax
   1335a:	3c 47                	cmp    $0x47,%al
   1335c:	75 16                	jne    13374 <lodepng_encode+0xb26>
   1335e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13361:	83 c0 07             	add    $0x7,%eax
   13364:	0f b6 00             	movzbl (%eax),%eax
   13367:	84 c0                	test   %al,%al
   13369:	75 09                	jne    13374 <lodepng_encode+0xb26>
          already_added_id_text = 1;
   1336b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   13372:	eb 13                	jmp    13387 <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   13374:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13378:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   1337e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13381:	0f 85 6c ff ff ff    	jne    132f3 <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   13387:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1338b:	75 36                	jne    133c3 <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   1338d:	a1 e0 e0 01 00       	mov    0x1e0e0,%eax
   13392:	83 ec 04             	sub    $0x4,%esp
   13395:	50                   	push   %eax
   13396:	68 a4 a0 01 00       	push   $0x1a0a4
   1339b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1339e:	50                   	push   %eax
   1339f:	e8 e8 d7 ff ff       	call   10b8c <addChunk_tEXt>
   133a4:	83 c4 10             	add    $0x10,%esp
   133a7:	89 c2                	mov    %eax,%edx
   133a9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133ac:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   133b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133b5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   133bb:	85 c0                	test   %eax,%eax
   133bd:	0f 85 9d 01 00 00    	jne    13560 <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   133c3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   133ca:	e9 e6 00 00 00       	jmp    134b5 <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   133cf:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   133d5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   133d8:	c1 e2 02             	shl    $0x2,%edx
   133db:	01 d0                	add    %edx,%eax
   133dd:	8b 00                	mov    (%eax),%eax
   133df:	83 ec 0c             	sub    $0xc,%esp
   133e2:	50                   	push   %eax
   133e3:	e8 d7 ff fe ff       	call   33bf <lodepng_strlen>
   133e8:	83 c4 10             	add    $0x10,%esp
   133eb:	83 f8 4f             	cmp    $0x4f,%eax
   133ee:	7e 12                	jle    13402 <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   133f0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133f3:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   133fa:	00 00 00 
        goto cleanup;
   133fd:	e9 65 01 00 00       	jmp    13567 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   13402:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13408:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1340b:	c1 e2 02             	shl    $0x2,%edx
   1340e:	01 d0                	add    %edx,%eax
   13410:	8b 00                	mov    (%eax),%eax
   13412:	83 ec 0c             	sub    $0xc,%esp
   13415:	50                   	push   %eax
   13416:	e8 a4 ff fe ff       	call   33bf <lodepng_strlen>
   1341b:	83 c4 10             	add    $0x10,%esp
   1341e:	85 c0                	test   %eax,%eax
   13420:	7f 12                	jg     13434 <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   13422:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13425:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   1342c:	00 00 00 
        goto cleanup;
   1342f:	e9 33 01 00 00       	jmp    13567 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   13434:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13437:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1343a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   13440:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13443:	c1 e2 02             	shl    $0x2,%edx
   13446:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13448:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1344a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   13450:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13453:	c1 e2 02             	shl    $0x2,%edx
   13456:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13458:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1345a:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   13460:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13463:	c1 e2 02             	shl    $0x2,%edx
   13466:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13468:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1346a:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13470:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13473:	c1 e2 02             	shl    $0x2,%edx
   13476:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13478:	8b 10                	mov    (%eax),%edx
   1347a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1347d:	8b 40 74             	mov    0x74(%eax),%eax
   13480:	83 ec 04             	sub    $0x4,%esp
   13483:	57                   	push   %edi
   13484:	56                   	push   %esi
   13485:	53                   	push   %ebx
   13486:	51                   	push   %ecx
   13487:	52                   	push   %edx
   13488:	50                   	push   %eax
   13489:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1348c:	50                   	push   %eax
   1348d:	e8 dc d8 ff ff       	call   10d6e <addChunk_iTXt>
   13492:	83 c4 20             	add    $0x20,%esp
   13495:	89 c2                	mov    %eax,%edx
   13497:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1349a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   134a0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134a3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   134a9:	85 c0                	test   %eax,%eax
   134ab:	0f 85 b2 00 00 00    	jne    13563 <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   134b1:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   134b5:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   134bb:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   134be:	0f 85 0b ff ff ff    	jne    133cf <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   134c4:	8b 45 a0             	mov    -0x60(%ebp),%eax
   134c7:	85 c0                	test   %eax,%eax
   134c9:	74 2f                	je     134fa <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   134cb:	8b 55 ac             	mov    -0x54(%ebp),%edx
   134ce:	8b 45 a0             	mov    -0x60(%ebp),%eax
   134d1:	83 ec 04             	sub    $0x4,%esp
   134d4:	52                   	push   %edx
   134d5:	50                   	push   %eax
   134d6:	8d 45 b0             	lea    -0x50(%ebp),%eax
   134d9:	50                   	push   %eax
   134da:	e8 60 f2 ff ff       	call   1273f <addUnknownChunks>
   134df:	83 c4 10             	add    $0x10,%esp
   134e2:	89 c2                	mov    %eax,%edx
   134e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134e7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   134ed:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134f0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   134f6:	85 c0                	test   %eax,%eax
   134f8:	75 6c                	jne    13566 <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   134fa:	83 ec 0c             	sub    $0xc,%esp
   134fd:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13500:	50                   	push   %eax
   13501:	e8 6d d6 ff ff       	call   10b73 <addChunk_IEND>
   13506:	83 c4 10             	add    $0x10,%esp
   13509:	89 c2                	mov    %eax,%edx
   1350b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1350e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13514:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13517:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1351d:	85 c0                	test   %eax,%eax
   1351f:	eb 46                	jmp    13567 <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13521:	90                   	nop
   13522:	eb 43                	jmp    13567 <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13524:	90                   	nop
   13525:	eb 40                	jmp    13567 <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   13527:	90                   	nop
   13528:	eb 3d                	jmp    13567 <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   1352a:	90                   	nop
   1352b:	eb 3a                	jmp    13567 <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   1352d:	90                   	nop
   1352e:	eb 37                	jmp    13567 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   13530:	90                   	nop
   13531:	eb 34                	jmp    13567 <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   13533:	90                   	nop
   13534:	eb 31                	jmp    13567 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   13536:	90                   	nop
   13537:	eb 2e                	jmp    13567 <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13539:	90                   	nop
   1353a:	eb 2b                	jmp    13567 <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   1353c:	90                   	nop
   1353d:	eb 28                	jmp    13567 <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   1353f:	90                   	nop
   13540:	eb 25                	jmp    13567 <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   13542:	90                   	nop
   13543:	eb 22                	jmp    13567 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13545:	90                   	nop
   13546:	eb 1f                	jmp    13567 <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13548:	90                   	nop
   13549:	eb 1c                	jmp    13567 <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   1354b:	90                   	nop
   1354c:	eb 19                	jmp    13567 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   1354e:	90                   	nop
   1354f:	eb 16                	jmp    13567 <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   13551:	90                   	nop
   13552:	eb 13                	jmp    13567 <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   13554:	90                   	nop
   13555:	eb 10                	jmp    13567 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   13557:	90                   	nop
   13558:	eb 0d                	jmp    13567 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   1355a:	90                   	nop
   1355b:	eb 0a                	jmp    13567 <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   1355d:	90                   	nop
   1355e:	eb 07                	jmp    13567 <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   13560:	90                   	nop
   13561:	eb 04                	jmp    13567 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13563:	90                   	nop
   13564:	eb 01                	jmp    13567 <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   13566:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   13567:	83 ec 0c             	sub    $0xc,%esp
   1356a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13570:	50                   	push   %eax
   13571:	e8 34 65 ff ff       	call   9aaa <lodepng_info_cleanup>
   13576:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   13579:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1357c:	83 ec 0c             	sub    $0xc,%esp
   1357f:	50                   	push   %eax
   13580:	e8 bf fd fe ff       	call   3344 <lodepng_free>
   13585:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   13588:	8b 55 b0             	mov    -0x50(%ebp),%edx
   1358b:	8b 45 08             	mov    0x8(%ebp),%eax
   1358e:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   13590:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   13593:	8b 45 0c             	mov    0xc(%ebp),%eax
   13596:	89 10                	mov    %edx,(%eax)

  return state->error;
   13598:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1359b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   135a1:	8d 65 f4             	lea    -0xc(%ebp),%esp
   135a4:	5b                   	pop    %ebx
   135a5:	5e                   	pop    %esi
   135a6:	5f                   	pop    %edi
   135a7:	5d                   	pop    %ebp
   135a8:	c3                   	ret    

000135a9 <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   135a9:	55                   	push   %ebp
   135aa:	89 e5                	mov    %esp,%ebp
   135ac:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   135b2:	83 ec 0c             	sub    $0xc,%esp
   135b5:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   135bb:	50                   	push   %eax
   135bc:	e8 38 d0 ff ff       	call   105f9 <lodepng_state_init>
   135c1:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   135c4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135c7:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   135cd:	8b 45 20             	mov    0x20(%ebp),%eax
   135d0:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   135d6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135d9:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   135df:	8b 45 20             	mov    0x20(%ebp),%eax
   135e2:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   135e8:	83 ec 08             	sub    $0x8,%esp
   135eb:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   135f1:	50                   	push   %eax
   135f2:	ff 75 18             	pushl  0x18(%ebp)
   135f5:	ff 75 14             	pushl  0x14(%ebp)
   135f8:	ff 75 10             	pushl  0x10(%ebp)
   135fb:	ff 75 0c             	pushl  0xc(%ebp)
   135fe:	ff 75 08             	pushl  0x8(%ebp)
   13601:	e8 48 f2 ff ff       	call   1284e <lodepng_encode>
   13606:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   13609:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1360c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   1360f:	83 ec 0c             	sub    $0xc,%esp
   13612:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   13618:	50                   	push   %eax
   13619:	e8 35 d0 ff ff       	call   10653 <lodepng_state_cleanup>
   1361e:	83 c4 10             	add    $0x10,%esp
  return error;
   13621:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13624:	c9                   	leave  
   13625:	c3                   	ret    

00013626 <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13626:	55                   	push   %ebp
   13627:	89 e5                	mov    %esp,%ebp
   13629:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   1362c:	83 ec 04             	sub    $0x4,%esp
   1362f:	6a 08                	push   $0x8
   13631:	6a 06                	push   $0x6
   13633:	ff 75 18             	pushl  0x18(%ebp)
   13636:	ff 75 14             	pushl  0x14(%ebp)
   13639:	ff 75 10             	pushl  0x10(%ebp)
   1363c:	ff 75 0c             	pushl  0xc(%ebp)
   1363f:	ff 75 08             	pushl  0x8(%ebp)
   13642:	e8 62 ff ff ff       	call   135a9 <lodepng_encode_memory>
   13647:	83 c4 20             	add    $0x20,%esp
}
   1364a:	c9                   	leave  
   1364b:	c3                   	ret    

0001364c <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   1364c:	55                   	push   %ebp
   1364d:	89 e5                	mov    %esp,%ebp
   1364f:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   13652:	83 ec 04             	sub    $0x4,%esp
   13655:	6a 08                	push   $0x8
   13657:	6a 02                	push   $0x2
   13659:	ff 75 18             	pushl  0x18(%ebp)
   1365c:	ff 75 14             	pushl  0x14(%ebp)
   1365f:	ff 75 10             	pushl  0x10(%ebp)
   13662:	ff 75 0c             	pushl  0xc(%ebp)
   13665:	ff 75 08             	pushl  0x8(%ebp)
   13668:	e8 3c ff ff ff       	call   135a9 <lodepng_encode_memory>
   1366d:	83 c4 20             	add    $0x20,%esp
}
   13670:	c9                   	leave  
   13671:	c3                   	ret    

00013672 <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   13672:	55                   	push   %ebp
   13673:	89 e5                	mov    %esp,%ebp
   13675:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   13678:	83 ec 04             	sub    $0x4,%esp
   1367b:	ff 75 1c             	pushl  0x1c(%ebp)
   1367e:	ff 75 18             	pushl  0x18(%ebp)
   13681:	ff 75 14             	pushl  0x14(%ebp)
   13684:	ff 75 10             	pushl  0x10(%ebp)
   13687:	ff 75 0c             	pushl  0xc(%ebp)
   1368a:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1368d:	50                   	push   %eax
   1368e:	8d 45 f0             	lea    -0x10(%ebp),%eax
   13691:	50                   	push   %eax
   13692:	e8 12 ff ff ff       	call   135a9 <lodepng_encode_memory>
   13697:	83 c4 20             	add    $0x20,%esp
   1369a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   1369d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   136a1:	75 19                	jne    136bc <lodepng_encode_file+0x4a>
   136a3:	8b 55 ec             	mov    -0x14(%ebp),%edx
   136a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   136a9:	83 ec 04             	sub    $0x4,%esp
   136ac:	ff 75 08             	pushl  0x8(%ebp)
   136af:	52                   	push   %edx
   136b0:	50                   	push   %eax
   136b1:	e8 36 01 ff ff       	call   37ec <lodepng_save_file>
   136b6:	83 c4 10             	add    $0x10,%esp
   136b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   136bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   136bf:	83 ec 0c             	sub    $0xc,%esp
   136c2:	50                   	push   %eax
   136c3:	e8 7c fc fe ff       	call   3344 <lodepng_free>
   136c8:	83 c4 10             	add    $0x10,%esp
  return error;
   136cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   136ce:	c9                   	leave  
   136cf:	c3                   	ret    

000136d0 <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   136d0:	55                   	push   %ebp
   136d1:	89 e5                	mov    %esp,%ebp
   136d3:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   136d6:	83 ec 08             	sub    $0x8,%esp
   136d9:	6a 08                	push   $0x8
   136db:	6a 06                	push   $0x6
   136dd:	ff 75 14             	pushl  0x14(%ebp)
   136e0:	ff 75 10             	pushl  0x10(%ebp)
   136e3:	ff 75 0c             	pushl  0xc(%ebp)
   136e6:	ff 75 08             	pushl  0x8(%ebp)
   136e9:	e8 84 ff ff ff       	call   13672 <lodepng_encode_file>
   136ee:	83 c4 20             	add    $0x20,%esp
}
   136f1:	c9                   	leave  
   136f2:	c3                   	ret    

000136f3 <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   136f3:	55                   	push   %ebp
   136f4:	89 e5                	mov    %esp,%ebp
   136f6:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   136f9:	83 ec 08             	sub    $0x8,%esp
   136fc:	6a 08                	push   $0x8
   136fe:	6a 02                	push   $0x2
   13700:	ff 75 14             	pushl  0x14(%ebp)
   13703:	ff 75 10             	pushl  0x10(%ebp)
   13706:	ff 75 0c             	pushl  0xc(%ebp)
   13709:	ff 75 08             	pushl  0x8(%ebp)
   1370c:	e8 61 ff ff ff       	call   13672 <lodepng_encode_file>
   13711:	83 c4 20             	add    $0x20,%esp
}
   13714:	c9                   	leave  
   13715:	c3                   	ret    

00013716 <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   13716:	55                   	push   %ebp
   13717:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   13719:	8b 45 08             	mov    0x8(%ebp),%eax
   1371c:	50                   	push   %eax
   1371d:	e8 71 49 ff ff       	call   8093 <lodepng_compress_settings_init>
   13722:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   13725:	8b 45 08             	mov    0x8(%ebp),%eax
   13728:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   1372f:	8b 45 08             	mov    0x8(%ebp),%eax
   13732:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   13739:	8b 45 08             	mov    0x8(%ebp),%eax
   1373c:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   13743:	8b 45 08             	mov    0x8(%ebp),%eax
   13746:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   1374d:	8b 45 08             	mov    0x8(%ebp),%eax
   13750:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   13757:	8b 45 08             	mov    0x8(%ebp),%eax
   1375a:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   13761:	8b 45 08             	mov    0x8(%ebp),%eax
   13764:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   1376b:	90                   	nop
   1376c:	c9                   	leave  
   1376d:	c3                   	ret    

0001376e <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   1376e:	55                   	push   %ebp
   1376f:	89 e5                	mov    %esp,%ebp
  switch(code) {
   13771:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   13775:	0f 87 c1 03 00 00    	ja     13b3c <lodepng_error_text+0x3ce>
   1377b:	8b 45 08             	mov    0x8(%ebp),%eax
   1377e:	c1 e0 02             	shl    $0x2,%eax
   13781:	05 e0 b3 01 00       	add    $0x1b3e0,%eax
   13786:	8b 00                	mov    (%eax),%eax
   13788:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   1378a:	b8 ac a0 01 00       	mov    $0x1a0ac,%eax
   1378f:	e9 ad 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   13794:	b8 c9 a0 01 00       	mov    $0x1a0c9,%eax
   13799:	e9 a3 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   1379e:	b8 dc a0 01 00       	mov    $0x1a0dc,%eax
   137a3:	e9 99 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   137a8:	b8 14 a1 01 00       	mov    $0x1a114,%eax
   137ad:	e9 8f 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   137b2:	b8 4c a1 01 00       	mov    $0x1a14c,%eax
   137b7:	e9 85 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   137bc:	b8 4c a1 01 00       	mov    $0x1a14c,%eax
   137c1:	e9 7b 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   137c6:	b8 4c a1 01 00       	mov    $0x1a14c,%eax
   137cb:	e9 71 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   137d0:	b8 7c a1 01 00       	mov    $0x1a17c,%eax
   137d5:	e9 67 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   137da:	b8 b0 a1 01 00       	mov    $0x1a1b0,%eax
   137df:	e9 5d 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   137e4:	b8 e4 a1 01 00       	mov    $0x1a1e4,%eax
   137e9:	e9 53 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   137ee:	b8 b0 a1 01 00       	mov    $0x1a1b0,%eax
   137f3:	e9 49 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   137f8:	b8 0c a2 01 00       	mov    $0x1a20c,%eax
   137fd:	e9 3f 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   13802:	b8 44 a2 01 00       	mov    $0x1a244,%eax
   13807:	e9 35 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   1380c:	b8 b0 a1 01 00       	mov    $0x1a1b0,%eax
   13811:	e9 2b 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   13816:	b8 7c a2 01 00       	mov    $0x1a27c,%eax
   1381b:	e9 21 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   13820:	b8 ac a2 01 00       	mov    $0x1a2ac,%eax
   13825:	e9 17 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   1382a:	b8 cc a2 01 00       	mov    $0x1a2cc,%eax
   1382f:	e9 0d 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   13834:	b8 f8 a2 01 00       	mov    $0x1a2f8,%eax
   13839:	e9 03 03 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   1383e:	b8 38 a3 01 00       	mov    $0x1a338,%eax
   13843:	e9 f9 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   13848:	b8 60 a3 01 00       	mov    $0x1a360,%eax
   1384d:	e9 ef 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   13852:	b8 94 a3 01 00       	mov    $0x1a394,%eax
   13857:	e9 e5 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   1385c:	b8 b8 a3 01 00       	mov    $0x1a3b8,%eax
   13861:	e9 db 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   13866:	b8 f0 a3 01 00       	mov    $0x1a3f0,%eax
   1386b:	e9 d1 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   13870:	b8 10 a4 01 00       	mov    $0x1a410,%eax
   13875:	e9 c7 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   1387a:	b8 2f a4 01 00       	mov    $0x1a42f,%eax
   1387f:	e9 bd 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   13884:	b8 49 a4 01 00       	mov    $0x1a449,%eax
   13889:	e9 b3 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   1388e:	b8 68 a4 01 00       	mov    $0x1a468,%eax
   13893:	e9 a9 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   13898:	b8 a4 a4 01 00       	mov    $0x1a4a4,%eax
   1389d:	e9 9f 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   138a2:	b8 c8 a4 01 00       	mov    $0x1a4c8,%eax
   138a7:	e9 95 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   138ac:	b8 f4 a4 01 00       	mov    $0x1a4f4,%eax
   138b1:	e9 8b 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   138b6:	b8 18 a5 01 00       	mov    $0x1a518,%eax
   138bb:	e9 81 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   138c0:	b8 58 a5 01 00       	mov    $0x1a558,%eax
   138c5:	e9 77 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   138ca:	b8 88 a5 01 00       	mov    $0x1a588,%eax
   138cf:	e9 6d 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   138d4:	b8 b0 a5 01 00       	mov    $0x1a5b0,%eax
   138d9:	e9 63 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   138de:	b8 f4 a5 01 00       	mov    $0x1a5f4,%eax
   138e3:	e9 59 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   138e8:	b8 20 a6 01 00       	mov    $0x1a620,%eax
   138ed:	e9 4f 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   138f2:	b8 50 a6 01 00       	mov    $0x1a650,%eax
   138f7:	e9 45 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   138fc:	b8 78 a6 01 00       	mov    $0x1a678,%eax
   13901:	e9 3b 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   13906:	b8 c0 a6 01 00       	mov    $0x1a6c0,%eax
   1390b:	e9 31 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   13910:	b8 c0 a6 01 00       	mov    $0x1a6c0,%eax
   13915:	e9 27 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   1391a:	b8 fc a6 01 00       	mov    $0x1a6fc,%eax
   1391f:	e9 1d 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   13924:	b8 30 a7 01 00       	mov    $0x1a730,%eax
   13929:	e9 13 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   1392e:	b8 53 a7 01 00       	mov    $0x1a753,%eax
   13933:	e9 09 02 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   13938:	b8 70 a7 01 00       	mov    $0x1a770,%eax
   1393d:	e9 ff 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   13942:	b8 ac a7 01 00       	mov    $0x1a7ac,%eax
   13947:	e9 f5 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   1394c:	b8 dc a7 01 00       	mov    $0x1a7dc,%eax
   13951:	e9 eb 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   13956:	b8 28 a8 01 00       	mov    $0x1a828,%eax
   1395b:	e9 e1 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   13960:	b8 60 a8 01 00       	mov    $0x1a860,%eax
   13965:	e9 d7 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   1396a:	b8 a0 a8 01 00       	mov    $0x1a8a0,%eax
   1396f:	e9 cd 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   13974:	b8 cc a8 01 00       	mov    $0x1a8cc,%eax
   13979:	e9 c3 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   1397e:	b8 18 a9 01 00       	mov    $0x1a918,%eax
   13983:	e9 b9 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   13988:	b8 6c a9 01 00       	mov    $0x1a96c,%eax
   1398d:	e9 af 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   13992:	b8 a0 a9 01 00       	mov    $0x1a9a0,%eax
   13997:	e9 a5 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   1399c:	b8 f0 a9 01 00       	mov    $0x1a9f0,%eax
   139a1:	e9 9b 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   139a6:	b8 2c aa 01 00       	mov    $0x1aa2c,%eax
   139ab:	e9 91 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   139b0:	b8 8c aa 01 00       	mov    $0x1aa8c,%eax
   139b5:	e9 87 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   139ba:	b8 ec aa 01 00       	mov    $0x1aaec,%eax
   139bf:	e9 7d 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   139c4:	b8 48 ab 01 00       	mov    $0x1ab48,%eax
   139c9:	e9 73 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   139ce:	b8 8c ab 01 00       	mov    $0x1ab8c,%eax
   139d3:	e9 69 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   139d8:	b8 c8 ab 01 00       	mov    $0x1abc8,%eax
   139dd:	e9 5f 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   139e2:	b8 25 ac 01 00       	mov    $0x1ac25,%eax
   139e7:	e9 55 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   139ec:	b8 3d ac 01 00       	mov    $0x1ac3d,%eax
   139f1:	e9 4b 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   139f6:	b8 58 ac 01 00       	mov    $0x1ac58,%eax
   139fb:	e9 41 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   13a00:	b8 94 ac 01 00       	mov    $0x1ac94,%eax
   13a05:	e9 37 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   13a0a:	b8 c4 ac 01 00       	mov    $0x1acc4,%eax
   13a0f:	e9 2d 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   13a14:	b8 e4 ac 01 00       	mov    $0x1ace4,%eax
   13a19:	e9 23 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   13a1e:	b8 04 ad 01 00       	mov    $0x1ad04,%eax
   13a23:	e9 19 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   13a28:	b8 24 ad 01 00       	mov    $0x1ad24,%eax
   13a2d:	e9 0f 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   13a32:	b8 48 ad 01 00       	mov    $0x1ad48,%eax
   13a37:	e9 05 01 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   13a3c:	b8 70 ad 01 00       	mov    $0x1ad70,%eax
   13a41:	e9 fb 00 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   13a46:	b8 cd ad 01 00       	mov    $0x1adcd,%eax
   13a4b:	e9 f1 00 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   13a50:	b8 e8 ad 01 00       	mov    $0x1ade8,%eax
   13a55:	e9 e7 00 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   13a5a:	b8 24 ae 01 00       	mov    $0x1ae24,%eax
   13a5f:	e9 dd 00 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   13a64:	b8 58 ae 01 00       	mov    $0x1ae58,%eax
   13a69:	e9 d3 00 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   13a6e:	b8 ac ae 01 00       	mov    $0x1aeac,%eax
   13a73:	e9 c9 00 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   13a78:	b8 f8 ae 01 00       	mov    $0x1aef8,%eax
   13a7d:	e9 bf 00 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   13a82:	b8 34 af 01 00       	mov    $0x1af34,%eax
   13a87:	e9 b5 00 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   13a8c:	b8 58 af 01 00       	mov    $0x1af58,%eax
   13a91:	e9 ab 00 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   13a96:	b8 78 af 01 00       	mov    $0x1af78,%eax
   13a9b:	e9 a1 00 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   13aa0:	b8 a0 af 01 00       	mov    $0x1afa0,%eax
   13aa5:	e9 97 00 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   13aaa:	b8 c0 af 01 00       	mov    $0x1afc0,%eax
   13aaf:	e9 8d 00 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   13ab4:	b8 ec af 01 00       	mov    $0x1afec,%eax
   13ab9:	e9 83 00 00 00       	jmp    13b41 <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   13abe:	b8 1b b0 01 00       	mov    $0x1b01b,%eax
   13ac3:	eb 7c                	jmp    13b41 <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   13ac5:	b8 33 b0 01 00       	mov    $0x1b033,%eax
   13aca:	eb 75                	jmp    13b41 <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   13acc:	b8 4b b0 01 00       	mov    $0x1b04b,%eax
   13ad1:	eb 6e                	jmp    13b41 <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   13ad3:	b8 63 b0 01 00       	mov    $0x1b063,%eax
   13ad8:	eb 67                	jmp    13b41 <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   13ada:	b8 84 b0 01 00       	mov    $0x1b084,%eax
   13adf:	eb 60                	jmp    13b41 <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   13ae1:	b8 d4 b0 01 00       	mov    $0x1b0d4,%eax
   13ae6:	eb 59                	jmp    13b41 <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   13ae8:	b8 28 b1 01 00       	mov    $0x1b128,%eax
   13aed:	eb 52                	jmp    13b41 <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   13aef:	b8 7c b1 01 00       	mov    $0x1b17c,%eax
   13af4:	eb 4b                	jmp    13b41 <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   13af6:	b8 c4 b1 01 00       	mov    $0x1b1c4,%eax
   13afb:	eb 44                	jmp    13b41 <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   13afd:	b8 08 b2 01 00       	mov    $0x1b208,%eax
   13b02:	eb 3d                	jmp    13b41 <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   13b04:	b8 24 b2 01 00       	mov    $0x1b224,%eax
   13b09:	eb 36                	jmp    13b41 <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   13b0b:	b8 5c b2 01 00       	mov    $0x1b25c,%eax
   13b10:	eb 2f                	jmp    13b41 <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   13b12:	b8 b0 b2 01 00       	mov    $0x1b2b0,%eax
   13b17:	eb 28                	jmp    13b41 <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   13b19:	b8 e0 b2 01 00       	mov    $0x1b2e0,%eax
   13b1e:	eb 21                	jmp    13b41 <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   13b20:	b8 30 b3 01 00       	mov    $0x1b330,%eax
   13b25:	eb 1a                	jmp    13b41 <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   13b27:	b8 5c b3 01 00       	mov    $0x1b35c,%eax
   13b2c:	eb 13                	jmp    13b41 <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   13b2e:	b8 88 b3 01 00       	mov    $0x1b388,%eax
   13b33:	eb 0c                	jmp    13b41 <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   13b35:	b8 ac b3 01 00       	mov    $0x1b3ac,%eax
   13b3a:	eb 05                	jmp    13b41 <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   13b3c:	b8 cb b3 01 00       	mov    $0x1b3cb,%eax
}
   13b41:	5d                   	pop    %ebp
   13b42:	c3                   	ret    

00013b43 <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   13b43:	55                   	push   %ebp
   13b44:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   13b46:	8b 45 08             	mov    0x8(%ebp),%eax
   13b49:	8b 40 28             	mov    0x28(%eax),%eax
   13b4c:	83 f8 01             	cmp    $0x1,%eax
   13b4f:	75 08                	jne    13b59 <GetImage+0x16>
   13b51:	8b 45 08             	mov    0x8(%ebp),%eax
   13b54:	8b 40 54             	mov    0x54(%eax),%eax
   13b57:	eb 09                	jmp    13b62 <GetImage+0x1f>
   13b59:	8b 45 08             	mov    0x8(%ebp),%eax
   13b5c:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   13b62:	5d                   	pop    %ebp
   13b63:	c3                   	ret    

00013b64 <GetWidth>:

int GetWidth(Context* ctx){
   13b64:	55                   	push   %ebp
   13b65:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   13b67:	8b 45 08             	mov    0x8(%ebp),%eax
   13b6a:	8b 40 10             	mov    0x10(%eax),%eax
}
   13b6d:	5d                   	pop    %ebp
   13b6e:	c3                   	ret    

00013b6f <GetHeight>:

int GetHeight(Context* ctx){
   13b6f:	55                   	push   %ebp
   13b70:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   13b72:	8b 45 08             	mov    0x8(%ebp),%eax
   13b75:	8b 40 14             	mov    0x14(%eax),%eax
}
   13b78:	5d                   	pop    %ebp
   13b79:	c3                   	ret    

00013b7a <GetImageSize>:

uint GetImageSize(Context* ctx){
   13b7a:	55                   	push   %ebp
   13b7b:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   13b7d:	8b 45 08             	mov    0x8(%ebp),%eax
   13b80:	8b 50 10             	mov    0x10(%eax),%edx
   13b83:	8b 45 08             	mov    0x8(%ebp),%eax
   13b86:	8b 40 14             	mov    0x14(%eax),%eax
   13b89:	0f af d0             	imul   %eax,%edx
   13b8c:	8b 45 08             	mov    0x8(%ebp),%eax
   13b8f:	8b 40 28             	mov    0x28(%eax),%eax
   13b92:	0f af c2             	imul   %edx,%eax
}
   13b95:	5d                   	pop    %ebp
   13b96:	c3                   	ret    

00013b97 <_Clip>:

uchar _Clip(const int x){
   13b97:	55                   	push   %ebp
   13b98:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   13b9a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13b9e:	78 15                	js     13bb5 <_Clip+0x1e>
   13ba0:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   13ba7:	7f 05                	jg     13bae <_Clip+0x17>
   13ba9:	8b 45 08             	mov    0x8(%ebp),%eax
   13bac:	eb 0c                	jmp    13bba <_Clip+0x23>
   13bae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13bb3:	eb 05                	jmp    13bba <_Clip+0x23>
   13bb5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13bba:	5d                   	pop    %ebp
   13bbb:	c3                   	ret    

00013bbc <_Skip>:

void _Skip(Context* ctx, int c){
   13bbc:	55                   	push   %ebp
   13bbd:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   13bbf:	8b 45 08             	mov    0x8(%ebp),%eax
   13bc2:	8b 50 04             	mov    0x4(%eax),%edx
   13bc5:	8b 45 0c             	mov    0xc(%ebp),%eax
   13bc8:	01 c2                	add    %eax,%edx
   13bca:	8b 45 08             	mov    0x8(%ebp),%eax
   13bcd:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   13bd0:	8b 45 08             	mov    0x8(%ebp),%eax
   13bd3:	8b 40 08             	mov    0x8(%eax),%eax
   13bd6:	2b 45 0c             	sub    0xc(%ebp),%eax
   13bd9:	89 c2                	mov    %eax,%edx
   13bdb:	8b 45 08             	mov    0x8(%ebp),%eax
   13bde:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   13be1:	8b 45 08             	mov    0x8(%ebp),%eax
   13be4:	8b 40 0c             	mov    0xc(%eax),%eax
   13be7:	2b 45 0c             	sub    0xc(%ebp),%eax
   13bea:	89 c2                	mov    %eax,%edx
   13bec:	8b 45 08             	mov    0x8(%ebp),%eax
   13bef:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   13bf2:	8b 45 08             	mov    0x8(%ebp),%eax
   13bf5:	8b 40 08             	mov    0x8(%eax),%eax
   13bf8:	85 c0                	test   %eax,%eax
   13bfa:	79 09                	jns    13c05 <_Skip+0x49>
   13bfc:	8b 45 08             	mov    0x8(%ebp),%eax
   13bff:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   13c05:	90                   	nop
   13c06:	5d                   	pop    %ebp
   13c07:	c3                   	ret    

00013c08 <_DecodeLength>:

void _DecodeLength(Context* ctx){
   13c08:	55                   	push   %ebp
   13c09:	89 e5                	mov    %esp,%ebp
   13c0b:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   13c0e:	8b 45 08             	mov    0x8(%ebp),%eax
   13c11:	8b 40 08             	mov    0x8(%eax),%eax
   13c14:	83 f8 01             	cmp    $0x1,%eax
   13c17:	7f 0b                	jg     13c24 <_DecodeLength+0x1c>
   13c19:	8b 45 08             	mov    0x8(%ebp),%eax
   13c1c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13c22:	eb 45                	jmp    13c69 <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   13c24:	8b 45 08             	mov    0x8(%ebp),%eax
   13c27:	8b 40 04             	mov    0x4(%eax),%eax
   13c2a:	83 ec 0c             	sub    $0xc,%esp
   13c2d:	50                   	push   %eax
   13c2e:	e8 38 00 00 00       	call   13c6b <_Decode2Bytes>
   13c33:	83 c4 10             	add    $0x10,%esp
   13c36:	89 c2                	mov    %eax,%edx
   13c38:	8b 45 08             	mov    0x8(%ebp),%eax
   13c3b:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   13c3e:	8b 45 08             	mov    0x8(%ebp),%eax
   13c41:	8b 50 0c             	mov    0xc(%eax),%edx
   13c44:	8b 45 08             	mov    0x8(%ebp),%eax
   13c47:	8b 40 08             	mov    0x8(%eax),%eax
   13c4a:	39 c2                	cmp    %eax,%edx
   13c4c:	7e 0b                	jle    13c59 <_DecodeLength+0x51>
   13c4e:	8b 45 08             	mov    0x8(%ebp),%eax
   13c51:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13c57:	eb 10                	jmp    13c69 <_DecodeLength+0x61>
    _Skip(ctx, 2);
   13c59:	83 ec 08             	sub    $0x8,%esp
   13c5c:	6a 02                	push   $0x2
   13c5e:	ff 75 08             	pushl  0x8(%ebp)
   13c61:	e8 56 ff ff ff       	call   13bbc <_Skip>
   13c66:	83 c4 10             	add    $0x10,%esp
}
   13c69:	c9                   	leave  
   13c6a:	c3                   	ret    

00013c6b <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   13c6b:	55                   	push   %ebp
   13c6c:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   13c6e:	8b 45 08             	mov    0x8(%ebp),%eax
   13c71:	0f b6 00             	movzbl (%eax),%eax
   13c74:	0f b6 c0             	movzbl %al,%eax
   13c77:	c1 e0 08             	shl    $0x8,%eax
   13c7a:	89 c2                	mov    %eax,%edx
   13c7c:	8b 45 08             	mov    0x8(%ebp),%eax
   13c7f:	83 c0 01             	add    $0x1,%eax
   13c82:	0f b6 00             	movzbl (%eax),%eax
   13c85:	0f b6 c0             	movzbl %al,%eax
   13c88:	09 d0                	or     %edx,%eax
}
   13c8a:	5d                   	pop    %ebp
   13c8b:	c3                   	ret    

00013c8c <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   13c8c:	55                   	push   %ebp
   13c8d:	89 e5                	mov    %esp,%ebp
   13c8f:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   13c92:	8b 45 08             	mov    0x8(%ebp),%eax
   13c95:	8b 55 10             	mov    0x10(%ebp),%edx
   13c98:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   13c9b:	8b 45 14             	mov    0x14(%ebp),%eax
   13c9e:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   13ca3:	89 c2                	mov    %eax,%edx
   13ca5:	8b 45 08             	mov    0x8(%ebp),%eax
   13ca8:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   13cab:	8b 45 08             	mov    0x8(%ebp),%eax
   13cae:	8b 40 08             	mov    0x8(%eax),%eax
   13cb1:	83 f8 01             	cmp    $0x1,%eax
   13cb4:	7e 1d                	jle    13cd3 <_DecodeJPEG+0x47>
   13cb6:	8b 45 08             	mov    0x8(%ebp),%eax
   13cb9:	8b 40 04             	mov    0x4(%eax),%eax
   13cbc:	0f b6 00             	movzbl (%eax),%eax
   13cbf:	3c ff                	cmp    $0xff,%al
   13cc1:	75 10                	jne    13cd3 <_DecodeJPEG+0x47>
   13cc3:	8b 45 08             	mov    0x8(%ebp),%eax
   13cc6:	8b 40 04             	mov    0x4(%eax),%eax
   13cc9:	83 c0 01             	add    $0x1,%eax
   13ccc:	0f b6 00             	movzbl (%eax),%eax
   13ccf:	3c d8                	cmp    $0xd8,%al
   13cd1:	74 0a                	je     13cdd <_DecodeJPEG+0x51>
   13cd3:	b8 01 00 00 00       	mov    $0x1,%eax
   13cd8:	e9 56 01 00 00       	jmp    13e33 <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   13cdd:	6a 02                	push   $0x2
   13cdf:	ff 75 08             	pushl  0x8(%ebp)
   13ce2:	e8 d5 fe ff ff       	call   13bbc <_Skip>
   13ce7:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   13cea:	e9 0a 01 00 00       	jmp    13df9 <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   13cef:	8b 45 08             	mov    0x8(%ebp),%eax
   13cf2:	8b 40 08             	mov    0x8(%eax),%eax
   13cf5:	85 c0                	test   %eax,%eax
   13cf7:	78 0d                	js     13d06 <_DecodeJPEG+0x7a>
   13cf9:	8b 45 08             	mov    0x8(%ebp),%eax
   13cfc:	8b 40 04             	mov    0x4(%eax),%eax
   13cff:	0f b6 00             	movzbl (%eax),%eax
   13d02:	3c ff                	cmp    $0xff,%al
   13d04:	74 0a                	je     13d10 <_DecodeJPEG+0x84>
   13d06:	b8 05 00 00 00       	mov    $0x5,%eax
   13d0b:	e9 23 01 00 00       	jmp    13e33 <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   13d10:	6a 02                	push   $0x2
   13d12:	ff 75 08             	pushl  0x8(%ebp)
   13d15:	e8 a2 fe ff ff       	call   13bbc <_Skip>
   13d1a:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   13d1d:	8b 45 08             	mov    0x8(%ebp),%eax
   13d20:	8b 40 04             	mov    0x4(%eax),%eax
   13d23:	83 e8 01             	sub    $0x1,%eax
   13d26:	0f b6 00             	movzbl (%eax),%eax
   13d29:	0f b6 c0             	movzbl %al,%eax
   13d2c:	3d da 00 00 00       	cmp    $0xda,%eax
   13d31:	74 71                	je     13da4 <_DecodeJPEG+0x118>
   13d33:	3d da 00 00 00       	cmp    $0xda,%eax
   13d38:	7f 10                	jg     13d4a <_DecodeJPEG+0xbe>
   13d3a:	3d c0 00 00 00       	cmp    $0xc0,%eax
   13d3f:	74 20                	je     13d61 <_DecodeJPEG+0xd5>
   13d41:	3d c4 00 00 00       	cmp    $0xc4,%eax
   13d46:	74 2c                	je     13d74 <_DecodeJPEG+0xe8>
   13d48:	eb 7d                	jmp    13dc7 <_DecodeJPEG+0x13b>
   13d4a:	3d dd 00 00 00       	cmp    $0xdd,%eax
   13d4f:	74 43                	je     13d94 <_DecodeJPEG+0x108>
   13d51:	3d fe 00 00 00       	cmp    $0xfe,%eax
   13d56:	74 5f                	je     13db7 <_DecodeJPEG+0x12b>
   13d58:	3d db 00 00 00       	cmp    $0xdb,%eax
   13d5d:	74 25                	je     13d84 <_DecodeJPEG+0xf8>
   13d5f:	eb 66                	jmp    13dc7 <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   13d61:	83 ec 0c             	sub    $0xc,%esp
   13d64:	ff 75 08             	pushl  0x8(%ebp)
   13d67:	e8 c9 00 00 00       	call   13e35 <_DecodeSOF>
   13d6c:	83 c4 10             	add    $0x10,%esp
   13d6f:	e9 85 00 00 00       	jmp    13df9 <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   13d74:	83 ec 0c             	sub    $0xc,%esp
   13d77:	ff 75 08             	pushl  0x8(%ebp)
   13d7a:	e8 28 05 00 00       	call   142a7 <_DecodeDHT>
   13d7f:	83 c4 10             	add    $0x10,%esp
   13d82:	eb 75                	jmp    13df9 <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   13d84:	83 ec 0c             	sub    $0xc,%esp
   13d87:	ff 75 08             	pushl  0x8(%ebp)
   13d8a:	e8 05 07 00 00       	call   14494 <_DecodeDQT>
   13d8f:	83 c4 10             	add    $0x10,%esp
   13d92:	eb 65                	jmp    13df9 <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   13d94:	83 ec 0c             	sub    $0xc,%esp
   13d97:	ff 75 08             	pushl  0x8(%ebp)
   13d9a:	e8 ff 07 00 00       	call   1459e <_DecodeDRI>
   13d9f:	83 c4 10             	add    $0x10,%esp
   13da2:	eb 55                	jmp    13df9 <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   13da4:	83 ec 08             	sub    $0x8,%esp
   13da7:	ff 75 0c             	pushl  0xc(%ebp)
   13daa:	ff 75 08             	pushl  0x8(%ebp)
   13dad:	e8 56 08 00 00       	call   14608 <_DecodeSOS>
   13db2:	83 c4 10             	add    $0x10,%esp
   13db5:	eb 42                	jmp    13df9 <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   13db7:	83 ec 0c             	sub    $0xc,%esp
   13dba:	ff 75 08             	pushl  0x8(%ebp)
   13dbd:	e8 a8 15 00 00       	call   1536a <_SkipMarker>
   13dc2:	83 c4 10             	add    $0x10,%esp
   13dc5:	eb 32                	jmp    13df9 <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   13dc7:	8b 45 08             	mov    0x8(%ebp),%eax
   13dca:	8b 40 04             	mov    0x4(%eax),%eax
   13dcd:	83 e8 01             	sub    $0x1,%eax
   13dd0:	0f b6 00             	movzbl (%eax),%eax
   13dd3:	0f b6 c0             	movzbl %al,%eax
   13dd6:	25 f0 00 00 00       	and    $0xf0,%eax
   13ddb:	3d e0 00 00 00       	cmp    $0xe0,%eax
   13de0:	75 10                	jne    13df2 <_DecodeJPEG+0x166>
   13de2:	83 ec 0c             	sub    $0xc,%esp
   13de5:	ff 75 08             	pushl  0x8(%ebp)
   13de8:	e8 7d 15 00 00       	call   1536a <_SkipMarker>
   13ded:	83 c4 10             	add    $0x10,%esp
   13df0:	eb 07                	jmp    13df9 <_DecodeJPEG+0x16d>
                else return Unsupported;
   13df2:	b8 02 00 00 00       	mov    $0x2,%eax
   13df7:	eb 3a                	jmp    13e33 <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   13df9:	8b 45 08             	mov    0x8(%ebp),%eax
   13dfc:	8b 00                	mov    (%eax),%eax
   13dfe:	85 c0                	test   %eax,%eax
   13e00:	0f 84 e9 fe ff ff    	je     13cef <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   13e06:	8b 45 08             	mov    0x8(%ebp),%eax
   13e09:	8b 00                	mov    (%eax),%eax
   13e0b:	83 f8 06             	cmp    $0x6,%eax
   13e0e:	74 07                	je     13e17 <_DecodeJPEG+0x18b>
   13e10:	8b 45 08             	mov    0x8(%ebp),%eax
   13e13:	8b 00                	mov    (%eax),%eax
   13e15:	eb 1c                	jmp    13e33 <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   13e17:	8b 45 08             	mov    0x8(%ebp),%eax
   13e1a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   13e20:	83 ec 0c             	sub    $0xc,%esp
   13e23:	ff 75 08             	pushl  0x8(%ebp)
   13e26:	e8 6b 15 00 00       	call   15396 <_Convert>
   13e2b:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   13e2e:	8b 45 08             	mov    0x8(%ebp),%eax
   13e31:	8b 00                	mov    (%eax),%eax
 }
   13e33:	c9                   	leave  
   13e34:	c3                   	ret    

00013e35 <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   13e35:	55                   	push   %ebp
   13e36:	89 e5                	mov    %esp,%ebp
   13e38:	53                   	push   %ebx
   13e39:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   13e3c:	83 ec 0c             	sub    $0xc,%esp
   13e3f:	ff 75 08             	pushl  0x8(%ebp)
   13e42:	e8 c1 fd ff ff       	call   13c08 <_DecodeLength>
   13e47:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   13e4a:	8b 45 08             	mov    0x8(%ebp),%eax
   13e4d:	8b 00                	mov    (%eax),%eax
   13e4f:	85 c0                	test   %eax,%eax
   13e51:	0f 85 4a 04 00 00    	jne    142a1 <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   13e57:	8b 45 08             	mov    0x8(%ebp),%eax
   13e5a:	8b 40 0c             	mov    0xc(%eax),%eax
   13e5d:	83 f8 08             	cmp    $0x8,%eax
   13e60:	7f 0e                	jg     13e70 <_DecodeSOF+0x3b>
   13e62:	8b 45 08             	mov    0x8(%ebp),%eax
   13e65:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13e6b:	e9 32 04 00 00       	jmp    142a2 <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   13e70:	8b 45 08             	mov    0x8(%ebp),%eax
   13e73:	8b 40 04             	mov    0x4(%eax),%eax
   13e76:	0f b6 00             	movzbl (%eax),%eax
   13e79:	3c 08                	cmp    $0x8,%al
   13e7b:	74 0e                	je     13e8b <_DecodeSOF+0x56>
   13e7d:	8b 45 08             	mov    0x8(%ebp),%eax
   13e80:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13e86:	e9 17 04 00 00       	jmp    142a2 <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   13e8b:	8b 45 08             	mov    0x8(%ebp),%eax
   13e8e:	8b 40 04             	mov    0x4(%eax),%eax
   13e91:	83 c0 01             	add    $0x1,%eax
   13e94:	83 ec 0c             	sub    $0xc,%esp
   13e97:	50                   	push   %eax
   13e98:	e8 ce fd ff ff       	call   13c6b <_Decode2Bytes>
   13e9d:	83 c4 10             	add    $0x10,%esp
   13ea0:	89 c2                	mov    %eax,%edx
   13ea2:	8b 45 08             	mov    0x8(%ebp),%eax
   13ea5:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   13ea8:	8b 45 08             	mov    0x8(%ebp),%eax
   13eab:	8b 40 04             	mov    0x4(%eax),%eax
   13eae:	83 c0 03             	add    $0x3,%eax
   13eb1:	83 ec 0c             	sub    $0xc,%esp
   13eb4:	50                   	push   %eax
   13eb5:	e8 b1 fd ff ff       	call   13c6b <_Decode2Bytes>
   13eba:	83 c4 10             	add    $0x10,%esp
   13ebd:	89 c2                	mov    %eax,%edx
   13ebf:	8b 45 08             	mov    0x8(%ebp),%eax
   13ec2:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   13ec5:	8b 45 08             	mov    0x8(%ebp),%eax
   13ec8:	8b 40 04             	mov    0x4(%eax),%eax
   13ecb:	83 c0 05             	add    $0x5,%eax
   13ece:	0f b6 00             	movzbl (%eax),%eax
   13ed1:	0f b6 d0             	movzbl %al,%edx
   13ed4:	8b 45 08             	mov    0x8(%ebp),%eax
   13ed7:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   13eda:	83 ec 08             	sub    $0x8,%esp
   13edd:	6a 06                	push   $0x6
   13edf:	ff 75 08             	pushl  0x8(%ebp)
   13ee2:	e8 d5 fc ff ff       	call   13bbc <_Skip>
   13ee7:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   13eea:	8b 45 08             	mov    0x8(%ebp),%eax
   13eed:	8b 40 28             	mov    0x28(%eax),%eax
   13ef0:	83 f8 01             	cmp    $0x1,%eax
   13ef3:	74 13                	je     13f08 <_DecodeSOF+0xd3>
   13ef5:	83 f8 03             	cmp    $0x3,%eax
   13ef8:	74 0e                	je     13f08 <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   13efa:	8b 45 08             	mov    0x8(%ebp),%eax
   13efd:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13f03:	e9 9a 03 00 00       	jmp    142a2 <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   13f08:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   13f09:	8b 45 08             	mov    0x8(%ebp),%eax
   13f0c:	8b 48 0c             	mov    0xc(%eax),%ecx
   13f0f:	8b 45 08             	mov    0x8(%ebp),%eax
   13f12:	8b 50 28             	mov    0x28(%eax),%edx
   13f15:	89 d0                	mov    %edx,%eax
   13f17:	01 c0                	add    %eax,%eax
   13f19:	01 d0                	add    %edx,%eax
   13f1b:	39 c1                	cmp    %eax,%ecx
   13f1d:	7d 0e                	jge    13f2d <_DecodeSOF+0xf8>
   13f1f:	8b 45 08             	mov    0x8(%ebp),%eax
   13f22:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13f28:	e9 75 03 00 00       	jmp    142a2 <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   13f2d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13f34:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   13f3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   13f42:	8b 45 08             	mov    0x8(%ebp),%eax
   13f45:	83 c0 2c             	add    $0x2c,%eax
   13f48:	89 45 e8             	mov    %eax,-0x18(%ebp)
   13f4b:	e9 50 01 00 00       	jmp    140a0 <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   13f50:	8b 45 08             	mov    0x8(%ebp),%eax
   13f53:	8b 40 04             	mov    0x4(%eax),%eax
   13f56:	0f b6 00             	movzbl (%eax),%eax
   13f59:	0f b6 d0             	movzbl %al,%edx
   13f5c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f5f:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   13f61:	8b 45 08             	mov    0x8(%ebp),%eax
   13f64:	8b 40 04             	mov    0x4(%eax),%eax
   13f67:	83 c0 01             	add    $0x1,%eax
   13f6a:	0f b6 00             	movzbl (%eax),%eax
   13f6d:	c0 e8 04             	shr    $0x4,%al
   13f70:	0f b6 d0             	movzbl %al,%edx
   13f73:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f76:	89 50 04             	mov    %edx,0x4(%eax)
   13f79:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f7c:	8b 40 04             	mov    0x4(%eax),%eax
   13f7f:	85 c0                	test   %eax,%eax
   13f81:	75 0e                	jne    13f91 <_DecodeSOF+0x15c>
   13f83:	8b 45 08             	mov    0x8(%ebp),%eax
   13f86:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13f8c:	e9 11 03 00 00       	jmp    142a2 <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   13f91:	8b 45 08             	mov    0x8(%ebp),%eax
   13f94:	8b 40 04             	mov    0x4(%eax),%eax
   13f97:	83 c0 01             	add    $0x1,%eax
   13f9a:	0f b6 00             	movzbl (%eax),%eax
   13f9d:	0f b6 c0             	movzbl %al,%eax
   13fa0:	83 e0 0f             	and    $0xf,%eax
   13fa3:	89 c2                	mov    %eax,%edx
   13fa5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fa8:	89 50 08             	mov    %edx,0x8(%eax)
   13fab:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fae:	8b 40 08             	mov    0x8(%eax),%eax
   13fb1:	85 c0                	test   %eax,%eax
   13fb3:	75 0e                	jne    13fc3 <_DecodeSOF+0x18e>
   13fb5:	8b 45 08             	mov    0x8(%ebp),%eax
   13fb8:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13fbe:	e9 df 02 00 00       	jmp    142a2 <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   13fc3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fc6:	8b 50 04             	mov    0x4(%eax),%edx
   13fc9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fcc:	8b 40 04             	mov    0x4(%eax),%eax
   13fcf:	83 e8 01             	sub    $0x1,%eax
   13fd2:	21 d0                	and    %edx,%eax
   13fd4:	85 c0                	test   %eax,%eax
   13fd6:	74 0e                	je     13fe6 <_DecodeSOF+0x1b1>
   13fd8:	8b 45 08             	mov    0x8(%ebp),%eax
   13fdb:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13fe1:	e9 bc 02 00 00       	jmp    142a2 <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   13fe6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fe9:	8b 50 08             	mov    0x8(%eax),%edx
   13fec:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fef:	8b 40 08             	mov    0x8(%eax),%eax
   13ff2:	83 e8 01             	sub    $0x1,%eax
   13ff5:	21 d0                	and    %edx,%eax
   13ff7:	85 c0                	test   %eax,%eax
   13ff9:	74 0e                	je     14009 <_DecodeSOF+0x1d4>
   13ffb:	8b 45 08             	mov    0x8(%ebp),%eax
   13ffe:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14004:	e9 99 02 00 00       	jmp    142a2 <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   14009:	8b 45 08             	mov    0x8(%ebp),%eax
   1400c:	8b 40 04             	mov    0x4(%eax),%eax
   1400f:	83 c0 02             	add    $0x2,%eax
   14012:	0f b6 00             	movzbl (%eax),%eax
   14015:	0f b6 d0             	movzbl %al,%edx
   14018:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1401b:	89 50 18             	mov    %edx,0x18(%eax)
   1401e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14021:	8b 40 18             	mov    0x18(%eax),%eax
   14024:	25 fc 00 00 00       	and    $0xfc,%eax
   14029:	85 c0                	test   %eax,%eax
   1402b:	74 0e                	je     1403b <_DecodeSOF+0x206>
   1402d:	8b 45 08             	mov    0x8(%ebp),%eax
   14030:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14036:	e9 67 02 00 00       	jmp    142a2 <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   1403b:	83 ec 08             	sub    $0x8,%esp
   1403e:	6a 03                	push   $0x3
   14040:	ff 75 08             	pushl  0x8(%ebp)
   14043:	e8 74 fb ff ff       	call   13bbc <_Skip>
   14048:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   1404b:	8b 45 08             	mov    0x8(%ebp),%eax
   1404e:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   14054:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14057:	8b 40 18             	mov    0x18(%eax),%eax
   1405a:	bb 01 00 00 00       	mov    $0x1,%ebx
   1405f:	89 c1                	mov    %eax,%ecx
   14061:	d3 e3                	shl    %cl,%ebx
   14063:	89 d8                	mov    %ebx,%eax
   14065:	09 c2                	or     %eax,%edx
   14067:	8b 45 08             	mov    0x8(%ebp),%eax
   1406a:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   14070:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14073:	8b 40 04             	mov    0x4(%eax),%eax
   14076:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14079:	7e 09                	jle    14084 <_DecodeSOF+0x24f>
   1407b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1407e:	8b 40 04             	mov    0x4(%eax),%eax
   14081:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   14084:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14087:	8b 40 08             	mov    0x8(%eax),%eax
   1408a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1408d:	7e 09                	jle    14098 <_DecodeSOF+0x263>
   1408f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14092:	8b 40 08             	mov    0x8(%eax),%eax
   14095:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14098:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1409c:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   140a0:	8b 45 08             	mov    0x8(%ebp),%eax
   140a3:	8b 40 28             	mov    0x28(%eax),%eax
   140a6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   140a9:	0f 8f a1 fe ff ff    	jg     13f50 <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   140af:	8b 45 ec             	mov    -0x14(%ebp),%eax
   140b2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   140b9:	8b 45 08             	mov    0x8(%ebp),%eax
   140bc:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   140bf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   140c2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   140c9:	8b 45 08             	mov    0x8(%ebp),%eax
   140cc:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   140cf:	8b 45 08             	mov    0x8(%ebp),%eax
   140d2:	8b 50 10             	mov    0x10(%eax),%edx
   140d5:	8b 45 08             	mov    0x8(%ebp),%eax
   140d8:	8b 40 20             	mov    0x20(%eax),%eax
   140db:	01 d0                	add    %edx,%eax
   140dd:	8d 48 ff             	lea    -0x1(%eax),%ecx
   140e0:	8b 45 08             	mov    0x8(%ebp),%eax
   140e3:	8b 58 20             	mov    0x20(%eax),%ebx
   140e6:	89 c8                	mov    %ecx,%eax
   140e8:	99                   	cltd   
   140e9:	f7 fb                	idiv   %ebx
   140eb:	89 c2                	mov    %eax,%edx
   140ed:	8b 45 08             	mov    0x8(%ebp),%eax
   140f0:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   140f3:	8b 45 08             	mov    0x8(%ebp),%eax
   140f6:	8b 50 14             	mov    0x14(%eax),%edx
   140f9:	8b 45 08             	mov    0x8(%ebp),%eax
   140fc:	8b 40 24             	mov    0x24(%eax),%eax
   140ff:	01 d0                	add    %edx,%eax
   14101:	8d 48 ff             	lea    -0x1(%eax),%ecx
   14104:	8b 45 08             	mov    0x8(%ebp),%eax
   14107:	8b 58 24             	mov    0x24(%eax),%ebx
   1410a:	89 c8                	mov    %ecx,%eax
   1410c:	99                   	cltd   
   1410d:	f7 fb                	idiv   %ebx
   1410f:	89 c2                	mov    %eax,%edx
   14111:	8b 45 08             	mov    0x8(%ebp),%eax
   14114:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   14117:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1411e:	8b 45 08             	mov    0x8(%ebp),%eax
   14121:	83 c0 2c             	add    $0x2c,%eax
   14124:	89 45 e8             	mov    %eax,-0x18(%ebp)
   14127:	e9 fd 00 00 00       	jmp    14229 <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   1412c:	8b 45 08             	mov    0x8(%ebp),%eax
   1412f:	8b 50 10             	mov    0x10(%eax),%edx
   14132:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14135:	8b 40 04             	mov    0x4(%eax),%eax
   14138:	0f af d0             	imul   %eax,%edx
   1413b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1413e:	01 d0                	add    %edx,%eax
   14140:	83 e8 01             	sub    $0x1,%eax
   14143:	99                   	cltd   
   14144:	f7 7d ec             	idivl  -0x14(%ebp)
   14147:	89 c2                	mov    %eax,%edx
   14149:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1414c:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   1414f:	8b 45 08             	mov    0x8(%ebp),%eax
   14152:	8b 50 14             	mov    0x14(%eax),%edx
   14155:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14158:	8b 40 08             	mov    0x8(%eax),%eax
   1415b:	0f af d0             	imul   %eax,%edx
   1415e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14161:	01 d0                	add    %edx,%eax
   14163:	83 e8 01             	sub    $0x1,%eax
   14166:	99                   	cltd   
   14167:	f7 7d f0             	idivl  -0x10(%ebp)
   1416a:	89 c2                	mov    %eax,%edx
   1416c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1416f:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   14172:	8b 45 08             	mov    0x8(%ebp),%eax
   14175:	8b 50 18             	mov    0x18(%eax),%edx
   14178:	8b 45 08             	mov    0x8(%ebp),%eax
   1417b:	8b 40 20             	mov    0x20(%eax),%eax
   1417e:	0f af d0             	imul   %eax,%edx
   14181:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14184:	8b 40 04             	mov    0x4(%eax),%eax
   14187:	0f af c2             	imul   %edx,%eax
   1418a:	99                   	cltd   
   1418b:	f7 7d ec             	idivl  -0x14(%ebp)
   1418e:	89 c2                	mov    %eax,%edx
   14190:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14193:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   14196:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14199:	8b 40 0c             	mov    0xc(%eax),%eax
   1419c:	83 f8 02             	cmp    $0x2,%eax
   1419f:	7f 0b                	jg     141ac <_DecodeSOF+0x377>
   141a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141a4:	8b 40 04             	mov    0x4(%eax),%eax
   141a7:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   141aa:	75 16                	jne    141c2 <_DecodeSOF+0x38d>
   141ac:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141af:	8b 40 10             	mov    0x10(%eax),%eax
   141b2:	83 f8 02             	cmp    $0x2,%eax
   141b5:	7f 19                	jg     141d0 <_DecodeSOF+0x39b>
   141b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141ba:	8b 40 08             	mov    0x8(%eax),%eax
   141bd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   141c0:	74 0e                	je     141d0 <_DecodeSOF+0x39b>
   141c2:	8b 45 08             	mov    0x8(%ebp),%eax
   141c5:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   141cb:	e9 d2 00 00 00       	jmp    142a2 <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   141d0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141d3:	8b 48 14             	mov    0x14(%eax),%ecx
   141d6:	8b 45 08             	mov    0x8(%ebp),%eax
   141d9:	8b 50 1c             	mov    0x1c(%eax),%edx
   141dc:	8b 45 08             	mov    0x8(%ebp),%eax
   141df:	8b 40 24             	mov    0x24(%eax),%eax
   141e2:	0f af d0             	imul   %eax,%edx
   141e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141e8:	8b 40 08             	mov    0x8(%eax),%eax
   141eb:	0f af c2             	imul   %edx,%eax
   141ee:	99                   	cltd   
   141ef:	f7 7d f0             	idivl  -0x10(%ebp)
   141f2:	0f af c1             	imul   %ecx,%eax
   141f5:	83 ec 0c             	sub    $0xc,%esp
   141f8:	50                   	push   %eax
   141f9:	e8 45 c5 fe ff       	call   743 <malloc>
   141fe:	83 c4 10             	add    $0x10,%esp
   14201:	89 c2                	mov    %eax,%edx
   14203:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14206:	89 50 28             	mov    %edx,0x28(%eax)
   14209:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1420c:	8b 40 28             	mov    0x28(%eax),%eax
   1420f:	85 c0                	test   %eax,%eax
   14211:	75 0e                	jne    14221 <_DecodeSOF+0x3ec>
   14213:	8b 45 08             	mov    0x8(%ebp),%eax
   14216:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1421c:	e9 81 00 00 00       	jmp    142a2 <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   14221:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14225:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   14229:	8b 45 08             	mov    0x8(%ebp),%eax
   1422c:	8b 40 28             	mov    0x28(%eax),%eax
   1422f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14232:	0f 8f f4 fe ff ff    	jg     1412c <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   14238:	8b 45 08             	mov    0x8(%ebp),%eax
   1423b:	8b 40 28             	mov    0x28(%eax),%eax
   1423e:	83 f8 03             	cmp    $0x3,%eax
   14241:	75 47                	jne    1428a <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   14243:	8b 45 08             	mov    0x8(%ebp),%eax
   14246:	8b 50 10             	mov    0x10(%eax),%edx
   14249:	8b 45 08             	mov    0x8(%ebp),%eax
   1424c:	8b 40 14             	mov    0x14(%eax),%eax
   1424f:	0f af d0             	imul   %eax,%edx
   14252:	8b 45 08             	mov    0x8(%ebp),%eax
   14255:	8b 40 28             	mov    0x28(%eax),%eax
   14258:	0f af c2             	imul   %edx,%eax
   1425b:	83 ec 0c             	sub    $0xc,%esp
   1425e:	50                   	push   %eax
   1425f:	e8 df c4 fe ff       	call   743 <malloc>
   14264:	83 c4 10             	add    $0x10,%esp
   14267:	89 c2                	mov    %eax,%edx
   14269:	8b 45 08             	mov    0x8(%ebp),%eax
   1426c:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   14272:	8b 45 08             	mov    0x8(%ebp),%eax
   14275:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1427b:	85 c0                	test   %eax,%eax
   1427d:	75 0b                	jne    1428a <_DecodeSOF+0x455>
   1427f:	8b 45 08             	mov    0x8(%ebp),%eax
   14282:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   14288:	eb 18                	jmp    142a2 <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   1428a:	8b 45 08             	mov    0x8(%ebp),%eax
   1428d:	8b 40 0c             	mov    0xc(%eax),%eax
   14290:	83 ec 08             	sub    $0x8,%esp
   14293:	50                   	push   %eax
   14294:	ff 75 08             	pushl  0x8(%ebp)
   14297:	e8 20 f9 ff ff       	call   13bbc <_Skip>
   1429c:	83 c4 10             	add    $0x10,%esp
   1429f:	eb 01                	jmp    142a2 <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   142a1:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   142a2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   142a5:	c9                   	leave  
   142a6:	c3                   	ret    

000142a7 <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   142a7:	55                   	push   %ebp
   142a8:	89 e5                	mov    %esp,%ebp
   142aa:	53                   	push   %ebx
   142ab:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   142ae:	83 ec 0c             	sub    $0xc,%esp
   142b1:	ff 75 08             	pushl  0x8(%ebp)
   142b4:	e8 4f f9 ff ff       	call   13c08 <_DecodeLength>
   142b9:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   142bc:	8b 45 08             	mov    0x8(%ebp),%eax
   142bf:	8b 00                	mov    (%eax),%eax
   142c1:	85 c0                	test   %eax,%eax
   142c3:	0f 85 c5 01 00 00    	jne    1448e <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   142c9:	e9 9c 01 00 00       	jmp    1446a <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   142ce:	8b 45 08             	mov    0x8(%ebp),%eax
   142d1:	8b 40 04             	mov    0x4(%eax),%eax
   142d4:	0f b6 00             	movzbl (%eax),%eax
   142d7:	0f b6 c0             	movzbl %al,%eax
   142da:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   142dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   142e0:	25 ec 00 00 00       	and    $0xec,%eax
   142e5:	85 c0                	test   %eax,%eax
   142e7:	74 0e                	je     142f7 <_DecodeDHT+0x50>
   142e9:	8b 45 08             	mov    0x8(%ebp),%eax
   142ec:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   142f2:	e9 98 01 00 00       	jmp    1448f <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   142f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   142fa:	83 e0 02             	and    $0x2,%eax
   142fd:	85 c0                	test   %eax,%eax
   142ff:	74 0e                	je     1430f <_DecodeDHT+0x68>
   14301:	8b 45 08             	mov    0x8(%ebp),%eax
   14304:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1430a:	e9 80 01 00 00       	jmp    1448f <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   1430f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14312:	c1 f8 03             	sar    $0x3,%eax
   14315:	0b 45 f4             	or     -0xc(%ebp),%eax
   14318:	83 e0 03             	and    $0x3,%eax
   1431b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   1431e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14325:	eb 1c                	jmp    14343 <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   14327:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1432a:	8d 50 ff             	lea    -0x1(%eax),%edx
   1432d:	8b 45 08             	mov    0x8(%ebp),%eax
   14330:	8b 48 04             	mov    0x4(%eax),%ecx
   14333:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14336:	01 c8                	add    %ecx,%eax
   14338:	0f b6 00             	movzbl (%eax),%eax
   1433b:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   1433f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14343:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   14347:	7e de                	jle    14327 <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   14349:	83 ec 08             	sub    $0x8,%esp
   1434c:	6a 11                	push   $0x11
   1434e:	ff 75 08             	pushl  0x8(%ebp)
   14351:	e8 66 f8 ff ff       	call   13bbc <_Skip>
   14356:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   14359:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1435c:	c1 e0 11             	shl    $0x11,%eax
   1435f:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14365:	8b 45 08             	mov    0x8(%ebp),%eax
   14368:	01 d0                	add    %edx,%eax
   1436a:	83 c0 08             	add    $0x8,%eax
   1436d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   14370:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   14377:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1437a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   1437d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14384:	e9 be 00 00 00       	jmp    14447 <_DecodeDHT+0x1a0>
            spread >>= 1;
   14389:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   1438c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1438f:	83 e8 01             	sub    $0x1,%eax
   14392:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   14397:	0f b6 c0             	movzbl %al,%eax
   1439a:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   1439d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   143a1:	0f 84 9b 00 00 00    	je     14442 <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   143a7:	8b 45 08             	mov    0x8(%ebp),%eax
   143aa:	8b 40 0c             	mov    0xc(%eax),%eax
   143ad:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   143b0:	7d 0e                	jge    143c0 <_DecodeDHT+0x119>
   143b2:	8b 45 08             	mov    0x8(%ebp),%eax
   143b5:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   143bb:	e9 cf 00 00 00       	jmp    1448f <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   143c0:	b8 10 00 00 00       	mov    $0x10,%eax
   143c5:	2b 45 f0             	sub    -0x10(%ebp),%eax
   143c8:	8b 55 e0             	mov    -0x20(%ebp),%edx
   143cb:	89 c1                	mov    %eax,%ecx
   143cd:	d3 e2                	shl    %cl,%edx
   143cf:	89 d0                	mov    %edx,%eax
   143d1:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   143d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   143d8:	79 0e                	jns    143e8 <_DecodeDHT+0x141>
   143da:	8b 45 08             	mov    0x8(%ebp),%eax
   143dd:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   143e3:	e9 a7 00 00 00       	jmp    1448f <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   143e8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   143ef:	eb 36                	jmp    14427 <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   143f1:	8b 45 08             	mov    0x8(%ebp),%eax
   143f4:	8b 50 04             	mov    0x4(%eax),%edx
   143f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143fa:	01 d0                	add    %edx,%eax
   143fc:	0f b6 00             	movzbl (%eax),%eax
   143ff:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   14401:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   14404:	eb 14                	jmp    1441a <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   14406:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14409:	89 c2                	mov    %eax,%edx
   1440b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1440e:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   14410:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14413:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   14416:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   1441a:	89 d8                	mov    %ebx,%eax
   1441c:	8d 58 ff             	lea    -0x1(%eax),%ebx
   1441f:	85 c0                	test   %eax,%eax
   14421:	75 e3                	jne    14406 <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   14423:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14427:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1442a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   1442d:	7c c2                	jl     143f1 <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   1442f:	83 ec 08             	sub    $0x8,%esp
   14432:	ff 75 e0             	pushl  -0x20(%ebp)
   14435:	ff 75 08             	pushl  0x8(%ebp)
   14438:	e8 7f f7 ff ff       	call   13bbc <_Skip>
   1443d:	83 c4 10             	add    $0x10,%esp
   14440:	eb 01                	jmp    14443 <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   14442:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   14443:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14447:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   1444b:	0f 8e 38 ff ff ff    	jle    14389 <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14451:	eb 0a                	jmp    1445d <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   14453:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14456:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   14459:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   1445d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14460:	8d 50 ff             	lea    -0x1(%eax),%edx
   14463:	89 55 ec             	mov    %edx,-0x14(%ebp)
   14466:	85 c0                	test   %eax,%eax
   14468:	75 e9                	jne    14453 <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   1446a:	8b 45 08             	mov    0x8(%ebp),%eax
   1446d:	8b 40 0c             	mov    0xc(%eax),%eax
   14470:	83 f8 10             	cmp    $0x10,%eax
   14473:	0f 8f 55 fe ff ff    	jg     142ce <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14479:	8b 45 08             	mov    0x8(%ebp),%eax
   1447c:	8b 40 0c             	mov    0xc(%eax),%eax
   1447f:	85 c0                	test   %eax,%eax
   14481:	74 0c                	je     1448f <_DecodeDHT+0x1e8>
   14483:	8b 45 08             	mov    0x8(%ebp),%eax
   14486:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1448c:	eb 01                	jmp    1448f <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   1448e:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   1448f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14492:	c9                   	leave  
   14493:	c3                   	ret    

00014494 <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   14494:	55                   	push   %ebp
   14495:	89 e5                	mov    %esp,%ebp
   14497:	53                   	push   %ebx
   14498:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   1449b:	83 ec 0c             	sub    $0xc,%esp
   1449e:	ff 75 08             	pushl  0x8(%ebp)
   144a1:	e8 62 f7 ff ff       	call   13c08 <_DecodeLength>
   144a6:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   144a9:	8b 45 08             	mov    0x8(%ebp),%eax
   144ac:	8b 00                	mov    (%eax),%eax
   144ae:	85 c0                	test   %eax,%eax
   144b0:	0f 85 e2 00 00 00    	jne    14598 <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   144b6:	e9 b8 00 00 00       	jmp    14573 <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   144bb:	8b 45 08             	mov    0x8(%ebp),%eax
   144be:	8b 40 04             	mov    0x4(%eax),%eax
   144c1:	0f b6 00             	movzbl (%eax),%eax
   144c4:	0f b6 c0             	movzbl %al,%eax
   144c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   144ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144cd:	25 ec 00 00 00       	and    $0xec,%eax
   144d2:	85 c0                	test   %eax,%eax
   144d4:	74 0e                	je     144e4 <_DecodeDQT+0x50>
   144d6:	8b 45 08             	mov    0x8(%ebp),%eax
   144d9:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   144df:	e9 b5 00 00 00       	jmp    14599 <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   144e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144e7:	83 e0 10             	and    $0x10,%eax
   144ea:	85 c0                	test   %eax,%eax
   144ec:	74 0e                	je     144fc <_DecodeDQT+0x68>
   144ee:	8b 45 08             	mov    0x8(%ebp),%eax
   144f1:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   144f7:	e9 9d 00 00 00       	jmp    14599 <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   144fc:	8b 45 08             	mov    0x8(%ebp),%eax
   144ff:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   14505:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14508:	bb 01 00 00 00       	mov    $0x1,%ebx
   1450d:	89 c1                	mov    %eax,%ecx
   1450f:	d3 e3                	shl    %cl,%ebx
   14511:	89 d8                	mov    %ebx,%eax
   14513:	09 c2                	or     %eax,%edx
   14515:	8b 45 08             	mov    0x8(%ebp),%eax
   14518:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   1451e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14521:	c1 e0 06             	shl    $0x6,%eax
   14524:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   1452a:	8b 45 08             	mov    0x8(%ebp),%eax
   1452d:	01 d0                	add    %edx,%eax
   1452f:	83 c0 08             	add    $0x8,%eax
   14532:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   14535:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1453c:	eb 1f                	jmp    1455d <_DecodeDQT+0xc9>
   1453e:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14541:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14544:	01 c2                	add    %eax,%edx
   14546:	8b 45 08             	mov    0x8(%ebp),%eax
   14549:	8b 40 04             	mov    0x4(%eax),%eax
   1454c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1454f:	83 c1 01             	add    $0x1,%ecx
   14552:	01 c8                	add    %ecx,%eax
   14554:	0f b6 00             	movzbl (%eax),%eax
   14557:	88 02                	mov    %al,(%edx)
   14559:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1455d:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14561:	7e db                	jle    1453e <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   14563:	83 ec 08             	sub    $0x8,%esp
   14566:	6a 41                	push   $0x41
   14568:	ff 75 08             	pushl  0x8(%ebp)
   1456b:	e8 4c f6 ff ff       	call   13bbc <_Skip>
   14570:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   14573:	8b 45 08             	mov    0x8(%ebp),%eax
   14576:	8b 40 0c             	mov    0xc(%eax),%eax
   14579:	83 f8 40             	cmp    $0x40,%eax
   1457c:	0f 8f 39 ff ff ff    	jg     144bb <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14582:	8b 45 08             	mov    0x8(%ebp),%eax
   14585:	8b 40 0c             	mov    0xc(%eax),%eax
   14588:	85 c0                	test   %eax,%eax
   1458a:	74 0d                	je     14599 <_DecodeDQT+0x105>
   1458c:	8b 45 08             	mov    0x8(%ebp),%eax
   1458f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14595:	90                   	nop
   14596:	eb 01                	jmp    14599 <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   14598:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14599:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1459c:	c9                   	leave  
   1459d:	c3                   	ret    

0001459e <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   1459e:	55                   	push   %ebp
   1459f:	89 e5                	mov    %esp,%ebp
   145a1:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   145a4:	83 ec 0c             	sub    $0xc,%esp
   145a7:	ff 75 08             	pushl  0x8(%ebp)
   145aa:	e8 59 f6 ff ff       	call   13c08 <_DecodeLength>
   145af:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   145b2:	8b 45 08             	mov    0x8(%ebp),%eax
   145b5:	8b 00                	mov    (%eax),%eax
   145b7:	85 c0                	test   %eax,%eax
   145b9:	75 4a                	jne    14605 <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   145bb:	8b 45 08             	mov    0x8(%ebp),%eax
   145be:	8b 40 0c             	mov    0xc(%eax),%eax
   145c1:	83 f8 01             	cmp    $0x1,%eax
   145c4:	7f 0b                	jg     145d1 <_DecodeDRI+0x33>
   145c6:	8b 45 08             	mov    0x8(%ebp),%eax
   145c9:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   145cf:	eb 35                	jmp    14606 <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   145d1:	8b 45 08             	mov    0x8(%ebp),%eax
   145d4:	8b 40 04             	mov    0x4(%eax),%eax
   145d7:	83 ec 0c             	sub    $0xc,%esp
   145da:	50                   	push   %eax
   145db:	e8 8b f6 ff ff       	call   13c6b <_Decode2Bytes>
   145e0:	83 c4 10             	add    $0x10,%esp
   145e3:	89 c2                	mov    %eax,%edx
   145e5:	8b 45 08             	mov    0x8(%ebp),%eax
   145e8:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   145ee:	8b 45 08             	mov    0x8(%ebp),%eax
   145f1:	8b 40 0c             	mov    0xc(%eax),%eax
   145f4:	83 ec 08             	sub    $0x8,%esp
   145f7:	50                   	push   %eax
   145f8:	ff 75 08             	pushl  0x8(%ebp)
   145fb:	e8 bc f5 ff ff       	call   13bbc <_Skip>
   14600:	83 c4 10             	add    $0x10,%esp
   14603:	eb 01                	jmp    14606 <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   14605:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   14606:	c9                   	leave  
   14607:	c3                   	ret    

00014608 <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   14608:	55                   	push   %ebp
   14609:	89 e5                	mov    %esp,%ebp
   1460b:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   1460e:	8b 45 08             	mov    0x8(%ebp),%eax
   14611:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14617:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1461a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   14621:	83 ec 0c             	sub    $0xc,%esp
   14624:	ff 75 08             	pushl  0x8(%ebp)
   14627:	e8 dc f5 ff ff       	call   13c08 <_DecodeLength>
   1462c:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1462f:	8b 45 08             	mov    0x8(%ebp),%eax
   14632:	8b 00                	mov    (%eax),%eax
   14634:	85 c0                	test   %eax,%eax
   14636:	0f 85 c2 02 00 00    	jne    148fe <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   1463c:	8b 45 08             	mov    0x8(%ebp),%eax
   1463f:	8b 50 0c             	mov    0xc(%eax),%edx
   14642:	8b 45 08             	mov    0x8(%ebp),%eax
   14645:	8b 40 28             	mov    0x28(%eax),%eax
   14648:	83 c0 02             	add    $0x2,%eax
   1464b:	01 c0                	add    %eax,%eax
   1464d:	39 c2                	cmp    %eax,%edx
   1464f:	7c 16                	jl     14667 <_DecodeSOS+0x5f>
   14651:	8b 45 08             	mov    0x8(%ebp),%eax
   14654:	8b 40 04             	mov    0x4(%eax),%eax
   14657:	0f b6 00             	movzbl (%eax),%eax
   1465a:	0f b6 d0             	movzbl %al,%edx
   1465d:	8b 45 08             	mov    0x8(%ebp),%eax
   14660:	8b 40 28             	mov    0x28(%eax),%eax
   14663:	39 c2                	cmp    %eax,%edx
   14665:	74 0e                	je     14675 <_DecodeSOS+0x6d>
   14667:	8b 45 08             	mov    0x8(%ebp),%eax
   1466a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14670:	e9 8d 02 00 00       	jmp    14902 <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   14675:	83 ec 08             	sub    $0x8,%esp
   14678:	6a 01                	push   $0x1
   1467a:	ff 75 08             	pushl  0x8(%ebp)
   1467d:	e8 3a f5 ff ff       	call   13bbc <_Skip>
   14682:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14685:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1468c:	8b 45 08             	mov    0x8(%ebp),%eax
   1468f:	83 c0 2c             	add    $0x2c,%eax
   14692:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14695:	e9 ba 00 00 00       	jmp    14754 <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   1469a:	8b 45 08             	mov    0x8(%ebp),%eax
   1469d:	8b 40 04             	mov    0x4(%eax),%eax
   146a0:	0f b6 00             	movzbl (%eax),%eax
   146a3:	0f b6 d0             	movzbl %al,%edx
   146a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   146a9:	8b 00                	mov    (%eax),%eax
   146ab:	39 c2                	cmp    %eax,%edx
   146ad:	74 0e                	je     146bd <_DecodeSOS+0xb5>
   146af:	8b 45 08             	mov    0x8(%ebp),%eax
   146b2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146b8:	e9 45 02 00 00       	jmp    14902 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   146bd:	8b 45 08             	mov    0x8(%ebp),%eax
   146c0:	8b 40 04             	mov    0x4(%eax),%eax
   146c3:	83 c0 01             	add    $0x1,%eax
   146c6:	0f b6 00             	movzbl (%eax),%eax
   146c9:	0f b6 c0             	movzbl %al,%eax
   146cc:	25 ec 00 00 00       	and    $0xec,%eax
   146d1:	85 c0                	test   %eax,%eax
   146d3:	74 0e                	je     146e3 <_DecodeSOS+0xdb>
   146d5:	8b 45 08             	mov    0x8(%ebp),%eax
   146d8:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146de:	e9 1f 02 00 00       	jmp    14902 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   146e3:	8b 45 08             	mov    0x8(%ebp),%eax
   146e6:	8b 40 04             	mov    0x4(%eax),%eax
   146e9:	83 c0 01             	add    $0x1,%eax
   146ec:	0f b6 00             	movzbl (%eax),%eax
   146ef:	0f b6 c0             	movzbl %al,%eax
   146f2:	83 e0 02             	and    $0x2,%eax
   146f5:	85 c0                	test   %eax,%eax
   146f7:	74 0e                	je     14707 <_DecodeSOS+0xff>
   146f9:	8b 45 08             	mov    0x8(%ebp),%eax
   146fc:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14702:	e9 fb 01 00 00       	jmp    14902 <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   14707:	8b 45 08             	mov    0x8(%ebp),%eax
   1470a:	8b 40 04             	mov    0x4(%eax),%eax
   1470d:	83 c0 01             	add    $0x1,%eax
   14710:	0f b6 00             	movzbl (%eax),%eax
   14713:	c0 e8 04             	shr    $0x4,%al
   14716:	0f b6 d0             	movzbl %al,%edx
   14719:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1471c:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   1471f:	8b 45 08             	mov    0x8(%ebp),%eax
   14722:	8b 40 04             	mov    0x4(%eax),%eax
   14725:	83 c0 01             	add    $0x1,%eax
   14728:	0f b6 00             	movzbl (%eax),%eax
   1472b:	0f b6 c0             	movzbl %al,%eax
   1472e:	83 e0 01             	and    $0x1,%eax
   14731:	83 c8 02             	or     $0x2,%eax
   14734:	89 c2                	mov    %eax,%edx
   14736:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14739:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   1473c:	83 ec 08             	sub    $0x8,%esp
   1473f:	6a 02                	push   $0x2
   14741:	ff 75 08             	pushl  0x8(%ebp)
   14744:	e8 73 f4 ff ff       	call   13bbc <_Skip>
   14749:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1474c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14750:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14754:	8b 45 08             	mov    0x8(%ebp),%eax
   14757:	8b 40 28             	mov    0x28(%eax),%eax
   1475a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1475d:	0f 8f 37 ff ff ff    	jg     1469a <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   14763:	8b 45 08             	mov    0x8(%ebp),%eax
   14766:	8b 40 04             	mov    0x4(%eax),%eax
   14769:	0f b6 00             	movzbl (%eax),%eax
   1476c:	84 c0                	test   %al,%al
   1476e:	75 10                	jne    14780 <_DecodeSOS+0x178>
   14770:	8b 45 08             	mov    0x8(%ebp),%eax
   14773:	8b 40 04             	mov    0x4(%eax),%eax
   14776:	83 c0 01             	add    $0x1,%eax
   14779:	0f b6 00             	movzbl (%eax),%eax
   1477c:	3c 3f                	cmp    $0x3f,%al
   1477e:	74 0e                	je     1478e <_DecodeSOS+0x186>
   14780:	8b 45 08             	mov    0x8(%ebp),%eax
   14783:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14789:	e9 74 01 00 00       	jmp    14902 <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   1478e:	8b 45 08             	mov    0x8(%ebp),%eax
   14791:	8b 40 04             	mov    0x4(%eax),%eax
   14794:	83 c0 02             	add    $0x2,%eax
   14797:	0f b6 00             	movzbl (%eax),%eax
   1479a:	84 c0                	test   %al,%al
   1479c:	74 0e                	je     147ac <_DecodeSOS+0x1a4>
   1479e:	8b 45 08             	mov    0x8(%ebp),%eax
   147a1:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   147a7:	e9 56 01 00 00       	jmp    14902 <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   147ac:	8b 45 08             	mov    0x8(%ebp),%eax
   147af:	8b 40 0c             	mov    0xc(%eax),%eax
   147b2:	83 ec 08             	sub    $0x8,%esp
   147b5:	50                   	push   %eax
   147b6:	ff 75 08             	pushl  0x8(%ebp)
   147b9:	e8 fe f3 ff ff       	call   13bbc <_Skip>
   147be:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   147c1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   147c8:	e9 17 01 00 00       	jmp    148e4 <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   147cd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   147d4:	e9 f8 00 00 00       	jmp    148d1 <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   147d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   147e0:	8b 45 08             	mov    0x8(%ebp),%eax
   147e3:	83 c0 2c             	add    $0x2c,%eax
   147e6:	89 45 dc             	mov    %eax,-0x24(%ebp)
   147e9:	e9 8d 00 00 00       	jmp    1487b <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   147ee:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   147f5:	eb 71                	jmp    14868 <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   147f7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   147fe:	eb 59                	jmp    14859 <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   14800:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14803:	8b 50 28             	mov    0x28(%eax),%edx
   14806:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14809:	8b 40 08             	mov    0x8(%eax),%eax
   1480c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   14810:	89 c1                	mov    %eax,%ecx
   14812:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14815:	01 c1                	add    %eax,%ecx
   14817:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1481a:	8b 40 14             	mov    0x14(%eax),%eax
   1481d:	0f af c8             	imul   %eax,%ecx
   14820:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14823:	8b 40 04             	mov    0x4(%eax),%eax
   14826:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   1482a:	01 c1                	add    %eax,%ecx
   1482c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1482f:	01 c8                	add    %ecx,%eax
   14831:	c1 e0 03             	shl    $0x3,%eax
   14834:	01 d0                	add    %edx,%eax
   14836:	50                   	push   %eax
   14837:	ff 75 dc             	pushl  -0x24(%ebp)
   1483a:	ff 75 0c             	pushl  0xc(%ebp)
   1483d:	ff 75 08             	pushl  0x8(%ebp)
   14840:	e8 bf 00 00 00       	call   14904 <_DecodeBlock>
   14845:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   14848:	8b 45 08             	mov    0x8(%ebp),%eax
   1484b:	8b 00                	mov    (%eax),%eax
   1484d:	85 c0                	test   %eax,%eax
   1484f:	0f 85 ac 00 00 00    	jne    14901 <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14855:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   14859:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1485c:	8b 40 04             	mov    0x4(%eax),%eax
   1485f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   14862:	7f 9c                	jg     14800 <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   14864:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   14868:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1486b:	8b 40 08             	mov    0x8(%eax),%eax
   1486e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   14871:	7f 84                	jg     147f7 <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14873:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14877:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   1487b:	8b 45 08             	mov    0x8(%ebp),%eax
   1487e:	8b 40 28             	mov    0x28(%eax),%eax
   14881:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14884:	0f 8f 64 ff ff ff    	jg     147ee <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   1488a:	8b 45 08             	mov    0x8(%ebp),%eax
   1488d:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14893:	85 c0                	test   %eax,%eax
   14895:	74 36                	je     148cd <_DecodeSOS+0x2c5>
   14897:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   1489b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1489f:	75 2c                	jne    148cd <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   148a1:	83 ec 0c             	sub    $0xc,%esp
   148a4:	ff 75 08             	pushl  0x8(%ebp)
   148a7:	e8 9f 0a 00 00       	call   1534b <_ByteAlign>
   148ac:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   148af:	83 ec 08             	sub    $0x8,%esp
   148b2:	6a 10                	push   $0x10
   148b4:	ff 75 08             	pushl  0x8(%ebp)
   148b7:	e8 ce 04 00 00       	call   14d8a <_GetBits>
   148bc:	83 c4 10             	add    $0x10,%esp
   148bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   148c2:	8b 45 08             	mov    0x8(%ebp),%eax
   148c5:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   148cb:	eb 35                	jmp    14902 <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   148cd:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   148d1:	8b 45 08             	mov    0x8(%ebp),%eax
   148d4:	8b 40 18             	mov    0x18(%eax),%eax
   148d7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   148da:	0f 8f f9 fe ff ff    	jg     147d9 <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   148e0:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   148e4:	8b 45 08             	mov    0x8(%ebp),%eax
   148e7:	8b 40 1c             	mov    0x1c(%eax),%eax
   148ea:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   148ed:	0f 8f da fe ff ff    	jg     147cd <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   148f3:	8b 45 08             	mov    0x8(%ebp),%eax
   148f6:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   148fc:	eb 04                	jmp    14902 <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   148fe:	90                   	nop
   148ff:	eb 01                	jmp    14902 <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   14901:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   14902:	c9                   	leave  
   14903:	c3                   	ret    

00014904 <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   14904:	55                   	push   %ebp
   14905:	89 e5                	mov    %esp,%ebp
   14907:	53                   	push   %ebx
   14908:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   1490b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   14912:	8b 45 08             	mov    0x8(%ebp),%eax
   14915:	05 c0 01 08 00       	add    $0x801c0,%eax
   1491a:	83 ec 04             	sub    $0x4,%esp
   1491d:	68 00 01 00 00       	push   $0x100
   14922:	6a 00                	push   $0x0
   14924:	50                   	push   %eax
   14925:	e8 04 b8 fe ff       	call   12e <memset>
   1492a:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   1492d:	8b 45 10             	mov    0x10(%ebp),%eax
   14930:	8b 40 20             	mov    0x20(%eax),%eax
   14933:	c1 e0 11             	shl    $0x11,%eax
   14936:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   1493c:	8b 45 08             	mov    0x8(%ebp),%eax
   1493f:	01 d0                	add    %edx,%eax
   14941:	83 c0 08             	add    $0x8,%eax
   14944:	83 ec 04             	sub    $0x4,%esp
   14947:	6a 00                	push   $0x0
   14949:	50                   	push   %eax
   1494a:	ff 75 08             	pushl  0x8(%ebp)
   1494d:	e8 86 01 00 00       	call   14ad8 <_GetVLC>
   14952:	83 c4 10             	add    $0x10,%esp
   14955:	89 c2                	mov    %eax,%edx
   14957:	8b 45 10             	mov    0x10(%ebp),%eax
   1495a:	8b 40 24             	mov    0x24(%eax),%eax
   1495d:	01 c2                	add    %eax,%edx
   1495f:	8b 45 10             	mov    0x10(%ebp),%eax
   14962:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   14965:	8b 45 10             	mov    0x10(%ebp),%eax
   14968:	8b 50 24             	mov    0x24(%eax),%edx
   1496b:	8b 45 10             	mov    0x10(%ebp),%eax
   1496e:	8b 48 18             	mov    0x18(%eax),%ecx
   14971:	8b 45 08             	mov    0x8(%ebp),%eax
   14974:	c1 e1 06             	shl    $0x6,%ecx
   14977:	01 c8                	add    %ecx,%eax
   14979:	05 b8 00 00 00       	add    $0xb8,%eax
   1497e:	0f b6 00             	movzbl (%eax),%eax
   14981:	0f b6 c0             	movzbl %al,%eax
   14984:	0f af d0             	imul   %eax,%edx
   14987:	8b 45 08             	mov    0x8(%ebp),%eax
   1498a:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   14990:	8b 45 10             	mov    0x10(%ebp),%eax
   14993:	8b 40 1c             	mov    0x1c(%eax),%eax
   14996:	c1 e0 11             	shl    $0x11,%eax
   14999:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   1499f:	8b 45 08             	mov    0x8(%ebp),%eax
   149a2:	01 d0                	add    %edx,%eax
   149a4:	8d 50 08             	lea    0x8(%eax),%edx
   149a7:	83 ec 04             	sub    $0x4,%esp
   149aa:	8d 45 ef             	lea    -0x11(%ebp),%eax
   149ad:	50                   	push   %eax
   149ae:	52                   	push   %edx
   149af:	ff 75 08             	pushl  0x8(%ebp)
   149b2:	e8 21 01 00 00       	call   14ad8 <_GetVLC>
   149b7:	83 c4 10             	add    $0x10,%esp
   149ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   149bd:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149c1:	84 c0                	test   %al,%al
   149c3:	0f 84 92 00 00 00    	je     14a5b <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   149c9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149cd:	0f b6 c0             	movzbl %al,%eax
   149d0:	83 e0 0f             	and    $0xf,%eax
   149d3:	85 c0                	test   %eax,%eax
   149d5:	75 16                	jne    149ed <_DecodeBlock+0xe9>
   149d7:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149db:	3c f0                	cmp    $0xf0,%al
   149dd:	74 0e                	je     149ed <_DecodeBlock+0xe9>
   149df:	8b 45 08             	mov    0x8(%ebp),%eax
   149e2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   149e8:	e9 e6 00 00 00       	jmp    14ad3 <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   149ed:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149f1:	c0 e8 04             	shr    $0x4,%al
   149f4:	0f b6 c0             	movzbl %al,%eax
   149f7:	83 c0 01             	add    $0x1,%eax
   149fa:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   149fd:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14a01:	7e 0e                	jle    14a11 <_DecodeBlock+0x10d>
   14a03:	8b 45 08             	mov    0x8(%ebp),%eax
   14a06:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a0c:	e9 c2 00 00 00       	jmp    14ad3 <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   14a11:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14a14:	8b 45 0c             	mov    0xc(%ebp),%eax
   14a17:	01 d0                	add    %edx,%eax
   14a19:	0f b6 00             	movzbl (%eax),%eax
   14a1c:	0f be c8             	movsbl %al,%ecx
   14a1f:	8b 45 10             	mov    0x10(%ebp),%eax
   14a22:	8b 50 18             	mov    0x18(%eax),%edx
   14a25:	8b 45 08             	mov    0x8(%ebp),%eax
   14a28:	c1 e2 06             	shl    $0x6,%edx
   14a2b:	01 c2                	add    %eax,%edx
   14a2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a30:	01 d0                	add    %edx,%eax
   14a32:	05 b8 00 00 00       	add    $0xb8,%eax
   14a37:	0f b6 00             	movzbl (%eax),%eax
   14a3a:	0f b6 c0             	movzbl %al,%eax
   14a3d:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14a41:	89 c2                	mov    %eax,%edx
   14a43:	8b 45 08             	mov    0x8(%ebp),%eax
   14a46:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   14a4c:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   14a4f:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   14a53:	0f 8e 37 ff ff ff    	jle    14990 <_DecodeBlock+0x8c>
   14a59:	eb 01                	jmp    14a5c <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   14a5b:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   14a5c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14a63:	eb 24                	jmp    14a89 <_DecodeBlock+0x185>
   14a65:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a68:	05 70 00 02 00       	add    $0x20070,%eax
   14a6d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14a74:	8b 45 08             	mov    0x8(%ebp),%eax
   14a77:	01 d0                	add    %edx,%eax
   14a79:	83 ec 0c             	sub    $0xc,%esp
   14a7c:	50                   	push   %eax
   14a7d:	e8 32 03 00 00       	call   14db4 <_RowIDCT>
   14a82:	83 c4 10             	add    $0x10,%esp
   14a85:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   14a89:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14a8d:	7e d6                	jle    14a65 <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   14a8f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14a96:	eb 35                	jmp    14acd <_DecodeBlock+0x1c9>
   14a98:	8b 45 10             	mov    0x10(%ebp),%eax
   14a9b:	8b 40 14             	mov    0x14(%eax),%eax
   14a9e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14aa1:	8b 55 14             	mov    0x14(%ebp),%edx
   14aa4:	01 d1                	add    %edx,%ecx
   14aa6:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14aa9:	81 c2 70 00 02 00    	add    $0x20070,%edx
   14aaf:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   14ab6:	8b 55 08             	mov    0x8(%ebp),%edx
   14ab9:	01 da                	add    %ebx,%edx
   14abb:	83 ec 04             	sub    $0x4,%esp
   14abe:	50                   	push   %eax
   14abf:	51                   	push   %ecx
   14ac0:	52                   	push   %edx
   14ac1:	e8 7b 05 00 00       	call   15041 <_ColIDCT>
   14ac6:	83 c4 10             	add    $0x10,%esp
   14ac9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14acd:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14ad1:	7e c5                	jle    14a98 <_DecodeBlock+0x194>
}
   14ad3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14ad6:	c9                   	leave  
   14ad7:	c3                   	ret    

00014ad8 <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   14ad8:	55                   	push   %ebp
   14ad9:	89 e5                	mov    %esp,%ebp
   14adb:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   14ade:	83 ec 08             	sub    $0x8,%esp
   14ae1:	6a 10                	push   $0x10
   14ae3:	ff 75 08             	pushl  0x8(%ebp)
   14ae6:	e8 c2 00 00 00       	call   14bad <_ShowBits>
   14aeb:	83 c4 10             	add    $0x10,%esp
   14aee:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   14af1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14af4:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14af7:	8b 45 0c             	mov    0xc(%ebp),%eax
   14afa:	01 d0                	add    %edx,%eax
   14afc:	0f b6 00             	movzbl (%eax),%eax
   14aff:	0f b6 c0             	movzbl %al,%eax
   14b02:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   14b05:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14b09:	75 13                	jne    14b1e <_GetVLC+0x46>
   14b0b:	8b 45 08             	mov    0x8(%ebp),%eax
   14b0e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14b14:	b8 00 00 00 00       	mov    $0x0,%eax
   14b19:	e9 8d 00 00 00       	jmp    14bab <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   14b1e:	83 ec 08             	sub    $0x8,%esp
   14b21:	ff 75 f0             	pushl  -0x10(%ebp)
   14b24:	ff 75 08             	pushl  0x8(%ebp)
   14b27:	e8 25 02 00 00       	call   14d51 <_SkipBits>
   14b2c:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   14b2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b32:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14b35:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b38:	01 d0                	add    %edx,%eax
   14b3a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   14b3e:	0f b6 c0             	movzbl %al,%eax
   14b41:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   14b44:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14b48:	74 0a                	je     14b54 <_GetVLC+0x7c>
   14b4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b4d:	89 c2                	mov    %eax,%edx
   14b4f:	8b 45 10             	mov    0x10(%ebp),%eax
   14b52:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   14b54:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b57:	83 e0 0f             	and    $0xf,%eax
   14b5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   14b5d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14b61:	75 07                	jne    14b6a <_GetVLC+0x92>
   14b63:	b8 00 00 00 00       	mov    $0x0,%eax
   14b68:	eb 41                	jmp    14bab <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   14b6a:	83 ec 08             	sub    $0x8,%esp
   14b6d:	ff 75 f0             	pushl  -0x10(%ebp)
   14b70:	ff 75 08             	pushl  0x8(%ebp)
   14b73:	e8 12 02 00 00       	call   14d8a <_GetBits>
   14b78:	83 c4 10             	add    $0x10,%esp
   14b7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   14b7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14b81:	83 e8 01             	sub    $0x1,%eax
   14b84:	ba 01 00 00 00       	mov    $0x1,%edx
   14b89:	89 c1                	mov    %eax,%ecx
   14b8b:	d3 e2                	shl    %cl,%edx
   14b8d:	89 d0                	mov    %edx,%eax
   14b8f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14b92:	7e 14                	jle    14ba8 <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   14b94:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14b97:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   14b9c:	89 c1                	mov    %eax,%ecx
   14b9e:	d3 e2                	shl    %cl,%edx
   14ba0:	89 d0                	mov    %edx,%eax
   14ba2:	83 c0 01             	add    $0x1,%eax
   14ba5:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   14ba8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14bab:	c9                   	leave  
   14bac:	c3                   	ret    

00014bad <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   14bad:	55                   	push   %ebp
   14bae:	89 e5                	mov    %esp,%ebp
   14bb0:	53                   	push   %ebx
   14bb1:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   14bb4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14bb8:	0f 85 4f 01 00 00    	jne    14d0d <_ShowBits+0x160>
   14bbe:	b8 00 00 00 00       	mov    $0x0,%eax
   14bc3:	e9 83 01 00 00       	jmp    14d4b <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   14bc8:	8b 45 08             	mov    0x8(%ebp),%eax
   14bcb:	8b 40 08             	mov    0x8(%eax),%eax
   14bce:	85 c0                	test   %eax,%eax
   14bd0:	7f 33                	jg     14c05 <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   14bd2:	8b 45 08             	mov    0x8(%ebp),%eax
   14bd5:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14bdb:	c1 e0 08             	shl    $0x8,%eax
   14bde:	0c ff                	or     $0xff,%al
   14be0:	89 c2                	mov    %eax,%edx
   14be2:	8b 45 08             	mov    0x8(%ebp),%eax
   14be5:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   14beb:	8b 45 08             	mov    0x8(%ebp),%eax
   14bee:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14bf4:	8d 50 08             	lea    0x8(%eax),%edx
   14bf7:	8b 45 08             	mov    0x8(%ebp),%eax
   14bfa:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   14c00:	e9 08 01 00 00       	jmp    14d0d <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   14c05:	8b 45 08             	mov    0x8(%ebp),%eax
   14c08:	8b 40 04             	mov    0x4(%eax),%eax
   14c0b:	8d 48 01             	lea    0x1(%eax),%ecx
   14c0e:	8b 55 08             	mov    0x8(%ebp),%edx
   14c11:	89 4a 04             	mov    %ecx,0x4(%edx)
   14c14:	0f b6 00             	movzbl (%eax),%eax
   14c17:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   14c1a:	8b 45 08             	mov    0x8(%ebp),%eax
   14c1d:	8b 40 08             	mov    0x8(%eax),%eax
   14c20:	8d 50 ff             	lea    -0x1(%eax),%edx
   14c23:	8b 45 08             	mov    0x8(%ebp),%eax
   14c26:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   14c29:	8b 45 08             	mov    0x8(%ebp),%eax
   14c2c:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14c32:	8d 50 08             	lea    0x8(%eax),%edx
   14c35:	8b 45 08             	mov    0x8(%ebp),%eax
   14c38:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   14c3e:	8b 45 08             	mov    0x8(%ebp),%eax
   14c41:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14c47:	c1 e0 08             	shl    $0x8,%eax
   14c4a:	89 c2                	mov    %eax,%edx
   14c4c:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   14c50:	09 c2                	or     %eax,%edx
   14c52:	8b 45 08             	mov    0x8(%ebp),%eax
   14c55:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   14c5b:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   14c5f:	0f 85 a8 00 00 00    	jne    14d0d <_ShowBits+0x160>
            if(ctx->size){
   14c65:	8b 45 08             	mov    0x8(%ebp),%eax
   14c68:	8b 40 08             	mov    0x8(%eax),%eax
   14c6b:	85 c0                	test   %eax,%eax
   14c6d:	0f 84 91 00 00 00    	je     14d04 <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   14c73:	8b 45 08             	mov    0x8(%ebp),%eax
   14c76:	8b 40 04             	mov    0x4(%eax),%eax
   14c79:	8d 48 01             	lea    0x1(%eax),%ecx
   14c7c:	8b 55 08             	mov    0x8(%ebp),%edx
   14c7f:	89 4a 04             	mov    %ecx,0x4(%edx)
   14c82:	0f b6 00             	movzbl (%eax),%eax
   14c85:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   14c88:	8b 45 08             	mov    0x8(%ebp),%eax
   14c8b:	8b 40 08             	mov    0x8(%eax),%eax
   14c8e:	8d 50 ff             	lea    -0x1(%eax),%edx
   14c91:	8b 45 08             	mov    0x8(%ebp),%eax
   14c94:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   14c97:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14c9b:	85 c0                	test   %eax,%eax
   14c9d:	74 62                	je     14d01 <_ShowBits+0x154>
   14c9f:	3d d9 00 00 00       	cmp    $0xd9,%eax
   14ca4:	75 0c                	jne    14cb2 <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   14ca6:	8b 45 08             	mov    0x8(%ebp),%eax
   14ca9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   14cb0:	eb 5b                	jmp    14d0d <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   14cb2:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14cb6:	25 f8 00 00 00       	and    $0xf8,%eax
   14cbb:	3d d0 00 00 00       	cmp    $0xd0,%eax
   14cc0:	74 0b                	je     14ccd <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   14cc2:	8b 45 08             	mov    0x8(%ebp),%eax
   14cc5:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14ccb:	eb 40                	jmp    14d0d <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   14ccd:	8b 45 08             	mov    0x8(%ebp),%eax
   14cd0:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14cd6:	c1 e0 08             	shl    $0x8,%eax
   14cd9:	89 c2                	mov    %eax,%edx
   14cdb:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14cdf:	09 c2                	or     %eax,%edx
   14ce1:	8b 45 08             	mov    0x8(%ebp),%eax
   14ce4:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   14cea:	8b 45 08             	mov    0x8(%ebp),%eax
   14ced:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14cf3:	8d 50 08             	lea    0x8(%eax),%edx
   14cf6:	8b 45 08             	mov    0x8(%ebp),%eax
   14cf9:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   14cff:	eb 0c                	jmp    14d0d <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   14d01:	90                   	nop
   14d02:	eb 09                	jmp    14d0d <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   14d04:	8b 45 08             	mov    0x8(%ebp),%eax
   14d07:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   14d0d:	8b 45 08             	mov    0x8(%ebp),%eax
   14d10:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d16:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14d19:	0f 8c a9 fe ff ff    	jl     14bc8 <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   14d1f:	8b 45 08             	mov    0x8(%ebp),%eax
   14d22:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   14d28:	8b 45 08             	mov    0x8(%ebp),%eax
   14d2b:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d31:	2b 45 0c             	sub    0xc(%ebp),%eax
   14d34:	89 c1                	mov    %eax,%ecx
   14d36:	d3 fa                	sar    %cl,%edx
   14d38:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d3b:	bb 01 00 00 00       	mov    $0x1,%ebx
   14d40:	89 c1                	mov    %eax,%ecx
   14d42:	d3 e3                	shl    %cl,%ebx
   14d44:	89 d8                	mov    %ebx,%eax
   14d46:	83 e8 01             	sub    $0x1,%eax
   14d49:	21 d0                	and    %edx,%eax
}
   14d4b:	83 c4 10             	add    $0x10,%esp
   14d4e:	5b                   	pop    %ebx
   14d4f:	5d                   	pop    %ebp
   14d50:	c3                   	ret    

00014d51 <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   14d51:	55                   	push   %ebp
   14d52:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   14d54:	8b 45 08             	mov    0x8(%ebp),%eax
   14d57:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d5d:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14d60:	7d 0e                	jge    14d70 <_SkipBits+0x1f>
   14d62:	ff 75 0c             	pushl  0xc(%ebp)
   14d65:	ff 75 08             	pushl  0x8(%ebp)
   14d68:	e8 40 fe ff ff       	call   14bad <_ShowBits>
   14d6d:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   14d70:	8b 45 08             	mov    0x8(%ebp),%eax
   14d73:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d79:	2b 45 0c             	sub    0xc(%ebp),%eax
   14d7c:	89 c2                	mov    %eax,%edx
   14d7e:	8b 45 08             	mov    0x8(%ebp),%eax
   14d81:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   14d87:	90                   	nop
   14d88:	c9                   	leave  
   14d89:	c3                   	ret    

00014d8a <_GetBits>:

int _GetBits(Context* ctx, int bits){
   14d8a:	55                   	push   %ebp
   14d8b:	89 e5                	mov    %esp,%ebp
   14d8d:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   14d90:	ff 75 0c             	pushl  0xc(%ebp)
   14d93:	ff 75 08             	pushl  0x8(%ebp)
   14d96:	e8 12 fe ff ff       	call   14bad <_ShowBits>
   14d9b:	83 c4 08             	add    $0x8,%esp
   14d9e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   14da1:	ff 75 0c             	pushl  0xc(%ebp)
   14da4:	ff 75 08             	pushl  0x8(%ebp)
   14da7:	e8 a5 ff ff ff       	call   14d51 <_SkipBits>
   14dac:	83 c4 08             	add    $0x8,%esp
    return res;
   14daf:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   14db2:	c9                   	leave  
   14db3:	c3                   	ret    

00014db4 <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   14db4:	55                   	push   %ebp
   14db5:	89 e5                	mov    %esp,%ebp
   14db7:	57                   	push   %edi
   14db8:	56                   	push   %esi
   14db9:	53                   	push   %ebx
   14dba:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14dbd:	8b 45 08             	mov    0x8(%ebp),%eax
   14dc0:	83 c0 10             	add    $0x10,%eax
   14dc3:	8b 00                	mov    (%eax),%eax
   14dc5:	c1 e0 0b             	shl    $0xb,%eax
   14dc8:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   14dcb:	8b 45 08             	mov    0x8(%ebp),%eax
   14dce:	8b 40 18             	mov    0x18(%eax),%eax
   14dd1:	89 45 ec             	mov    %eax,-0x14(%ebp)
   14dd4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14dd7:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   14dda:	8b 55 08             	mov    0x8(%ebp),%edx
   14ddd:	8b 52 08             	mov    0x8(%edx),%edx
   14de0:	89 55 e8             	mov    %edx,-0x18(%ebp)
   14de3:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   14de6:	8b 55 08             	mov    0x8(%ebp),%edx
   14de9:	8b 52 04             	mov    0x4(%edx),%edx
   14dec:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   14def:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   14df2:	8b 55 08             	mov    0x8(%ebp),%edx
   14df5:	8b 52 1c             	mov    0x1c(%edx),%edx
   14df8:	89 55 e0             	mov    %edx,-0x20(%ebp)
   14dfb:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   14dfe:	8b 55 08             	mov    0x8(%ebp),%edx
   14e01:	8b 52 14             	mov    0x14(%edx),%edx
   14e04:	89 55 dc             	mov    %edx,-0x24(%ebp)
   14e07:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   14e0a:	8b 55 08             	mov    0x8(%ebp),%edx
   14e0d:	8b 52 0c             	mov    0xc(%edx),%edx
   14e10:	89 55 d8             	mov    %edx,-0x28(%ebp)
   14e13:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14e16:	85 c0                	test   %eax,%eax
   14e18:	75 68                	jne    14e82 <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   14e1a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e1d:	8d 48 04             	lea    0x4(%eax),%ecx
   14e20:	8b 45 08             	mov    0x8(%ebp),%eax
   14e23:	8d 58 08             	lea    0x8(%eax),%ebx
   14e26:	8b 45 08             	mov    0x8(%ebp),%eax
   14e29:	8d 70 0c             	lea    0xc(%eax),%esi
   14e2c:	8b 45 08             	mov    0x8(%ebp),%eax
   14e2f:	8d 78 10             	lea    0x10(%eax),%edi
   14e32:	8b 45 08             	mov    0x8(%ebp),%eax
   14e35:	83 c0 14             	add    $0x14,%eax
   14e38:	89 45 c0             	mov    %eax,-0x40(%ebp)
   14e3b:	8b 45 08             	mov    0x8(%ebp),%eax
   14e3e:	83 c0 18             	add    $0x18,%eax
   14e41:	89 45 bc             	mov    %eax,-0x44(%ebp)
   14e44:	8b 45 08             	mov    0x8(%ebp),%eax
   14e47:	8d 50 1c             	lea    0x1c(%eax),%edx
   14e4a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e4d:	8b 00                	mov    (%eax),%eax
   14e4f:	c1 e0 03             	shl    $0x3,%eax
   14e52:	89 02                	mov    %eax,(%edx)
   14e54:	8b 02                	mov    (%edx),%eax
   14e56:	8b 55 bc             	mov    -0x44(%ebp),%edx
   14e59:	89 02                	mov    %eax,(%edx)
   14e5b:	89 d0                	mov    %edx,%eax
   14e5d:	8b 00                	mov    (%eax),%eax
   14e5f:	8b 55 c0             	mov    -0x40(%ebp),%edx
   14e62:	89 02                	mov    %eax,(%edx)
   14e64:	89 d0                	mov    %edx,%eax
   14e66:	8b 00                	mov    (%eax),%eax
   14e68:	89 07                	mov    %eax,(%edi)
   14e6a:	8b 07                	mov    (%edi),%eax
   14e6c:	89 06                	mov    %eax,(%esi)
   14e6e:	8b 06                	mov    (%esi),%eax
   14e70:	89 03                	mov    %eax,(%ebx)
   14e72:	8b 03                	mov    (%ebx),%eax
   14e74:	89 01                	mov    %eax,(%ecx)
   14e76:	8b 11                	mov    (%ecx),%edx
   14e78:	8b 45 08             	mov    0x8(%ebp),%eax
   14e7b:	89 10                	mov    %edx,(%eax)
        return;
   14e7d:	e9 b7 01 00 00       	jmp    15039 <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   14e82:	8b 45 08             	mov    0x8(%ebp),%eax
   14e85:	8b 00                	mov    (%eax),%eax
   14e87:	c1 e0 0b             	shl    $0xb,%eax
   14e8a:	83 e8 80             	sub    $0xffffff80,%eax
   14e8d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   14e90:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14e93:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14e96:	01 d0                	add    %edx,%eax
   14e98:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   14e9e:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   14ea1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14ea4:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   14eaa:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14ead:	01 d0                	add    %edx,%eax
   14eaf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   14eb2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14eb5:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   14ebb:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14ebe:	01 d0                	add    %edx,%eax
   14ec0:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   14ec3:	8b 55 dc             	mov    -0x24(%ebp),%edx
   14ec6:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14ec9:	01 d0                	add    %edx,%eax
   14ecb:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   14ed1:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   14ed4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14ed7:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   14edd:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14ee0:	01 d0                	add    %edx,%eax
   14ee2:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   14ee5:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14ee8:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   14eee:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14ef1:	01 d0                	add    %edx,%eax
   14ef3:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   14ef6:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   14ef9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14efc:	01 d0                	add    %edx,%eax
   14efe:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   14f01:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f04:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   14f07:	8b 55 e8             	mov    -0x18(%ebp),%edx
   14f0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f0d:	01 d0                	add    %edx,%eax
   14f0f:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14f15:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   14f18:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f1b:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   14f21:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f24:	01 d0                	add    %edx,%eax
   14f26:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   14f29:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f2c:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   14f32:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f35:	01 d0                	add    %edx,%eax
   14f37:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   14f3a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14f3d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f40:	01 d0                	add    %edx,%eax
   14f42:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   14f45:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f48:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   14f4b:	8b 55 e0             	mov    -0x20(%ebp),%edx
   14f4e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f51:	01 d0                	add    %edx,%eax
   14f53:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   14f56:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f59:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   14f5c:	8b 55 d0             	mov    -0x30(%ebp),%edx
   14f5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f62:	01 d0                	add    %edx,%eax
   14f64:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   14f67:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f6a:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   14f6d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   14f70:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f73:	01 d0                	add    %edx,%eax
   14f75:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   14f78:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f7b:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   14f7e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14f81:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14f84:	01 d0                	add    %edx,%eax
   14f86:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   14f8c:	83 e8 80             	sub    $0xffffff80,%eax
   14f8f:	c1 f8 08             	sar    $0x8,%eax
   14f92:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   14f95:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14f98:	2b 45 e0             	sub    -0x20(%ebp),%eax
   14f9b:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   14fa1:	83 e8 80             	sub    $0xffffff80,%eax
   14fa4:	c1 f8 08             	sar    $0x8,%eax
   14fa7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   14faa:	8b 55 d8             	mov    -0x28(%ebp),%edx
   14fad:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14fb0:	01 d0                	add    %edx,%eax
   14fb2:	c1 f8 08             	sar    $0x8,%eax
   14fb5:	89 c2                	mov    %eax,%edx
   14fb7:	8b 45 08             	mov    0x8(%ebp),%eax
   14fba:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   14fbc:	8b 45 08             	mov    0x8(%ebp),%eax
   14fbf:	83 c0 04             	add    $0x4,%eax
   14fc2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   14fc5:	8b 55 ec             	mov    -0x14(%ebp),%edx
   14fc8:	01 ca                	add    %ecx,%edx
   14fca:	c1 fa 08             	sar    $0x8,%edx
   14fcd:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   14fcf:	8b 45 08             	mov    0x8(%ebp),%eax
   14fd2:	83 c0 08             	add    $0x8,%eax
   14fd5:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   14fd8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14fdb:	01 ca                	add    %ecx,%edx
   14fdd:	c1 fa 08             	sar    $0x8,%edx
   14fe0:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   14fe2:	8b 45 08             	mov    0x8(%ebp),%eax
   14fe5:	83 c0 0c             	add    $0xc,%eax
   14fe8:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   14feb:	8b 55 dc             	mov    -0x24(%ebp),%edx
   14fee:	01 ca                	add    %ecx,%edx
   14ff0:	c1 fa 08             	sar    $0x8,%edx
   14ff3:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   14ff5:	8b 45 08             	mov    0x8(%ebp),%eax
   14ff8:	8d 50 10             	lea    0x10(%eax),%edx
   14ffb:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14ffe:	2b 45 dc             	sub    -0x24(%ebp),%eax
   15001:	c1 f8 08             	sar    $0x8,%eax
   15004:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   15006:	8b 45 08             	mov    0x8(%ebp),%eax
   15009:	8d 50 14             	lea    0x14(%eax),%edx
   1500c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1500f:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   15012:	c1 f8 08             	sar    $0x8,%eax
   15015:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   15017:	8b 45 08             	mov    0x8(%ebp),%eax
   1501a:	8d 50 18             	lea    0x18(%eax),%edx
   1501d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15020:	2b 45 ec             	sub    -0x14(%ebp),%eax
   15023:	c1 f8 08             	sar    $0x8,%eax
   15026:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   15028:	8b 45 08             	mov    0x8(%ebp),%eax
   1502b:	8d 50 1c             	lea    0x1c(%eax),%edx
   1502e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15031:	2b 45 f0             	sub    -0x10(%ebp),%eax
   15034:	c1 f8 08             	sar    $0x8,%eax
   15037:	89 02                	mov    %eax,(%edx)
}
   15039:	83 c4 38             	add    $0x38,%esp
   1503c:	5b                   	pop    %ebx
   1503d:	5e                   	pop    %esi
   1503e:	5f                   	pop    %edi
   1503f:	5d                   	pop    %ebp
   15040:	c3                   	ret    

00015041 <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   15041:	55                   	push   %ebp
   15042:	89 e5                	mov    %esp,%ebp
   15044:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   15047:	8b 45 08             	mov    0x8(%ebp),%eax
   1504a:	83 e8 80             	sub    $0xffffff80,%eax
   1504d:	8b 00                	mov    (%eax),%eax
   1504f:	c1 e0 08             	shl    $0x8,%eax
   15052:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   15055:	8b 45 08             	mov    0x8(%ebp),%eax
   15058:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   1505e:	89 45 f4             	mov    %eax,-0xc(%ebp)
   15061:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15064:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   15067:	8b 55 08             	mov    0x8(%ebp),%edx
   1506a:	8b 52 40             	mov    0x40(%edx),%edx
   1506d:	89 55 f0             	mov    %edx,-0x10(%ebp)
   15070:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   15073:	8b 55 08             	mov    0x8(%ebp),%edx
   15076:	8b 52 20             	mov    0x20(%edx),%edx
   15079:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1507c:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   1507f:	8b 55 08             	mov    0x8(%ebp),%edx
   15082:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   15088:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1508b:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   1508e:	8b 55 08             	mov    0x8(%ebp),%edx
   15091:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   15097:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   1509a:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   1509d:	8b 55 08             	mov    0x8(%ebp),%edx
   150a0:	8b 52 60             	mov    0x60(%edx),%edx
   150a3:	89 55 e0             	mov    %edx,-0x20(%ebp)
   150a6:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   150a9:	85 c0                	test   %eax,%eax
   150ab:	75 45                	jne    150f2 <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   150ad:	8b 45 08             	mov    0x8(%ebp),%eax
   150b0:	8b 00                	mov    (%eax),%eax
   150b2:	83 c0 20             	add    $0x20,%eax
   150b5:	c1 f8 06             	sar    $0x6,%eax
   150b8:	83 e8 80             	sub    $0xffffff80,%eax
   150bb:	50                   	push   %eax
   150bc:	e8 d6 ea ff ff       	call   13b97 <_Clip>
   150c1:	83 c4 04             	add    $0x4,%esp
   150c4:	0f b6 c0             	movzbl %al,%eax
   150c7:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   150ca:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   150d1:	eb 14                	jmp    150e7 <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   150d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   150d6:	89 c2                	mov    %eax,%edx
   150d8:	8b 45 0c             	mov    0xc(%ebp),%eax
   150db:	88 10                	mov    %dl,(%eax)
            out += stride;
   150dd:	8b 45 10             	mov    0x10(%ebp),%eax
   150e0:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   150e3:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   150e7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   150eb:	75 e6                	jne    150d3 <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   150ed:	e9 57 02 00 00       	jmp    15349 <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   150f2:	8b 45 08             	mov    0x8(%ebp),%eax
   150f5:	8b 00                	mov    (%eax),%eax
   150f7:	c1 e0 08             	shl    $0x8,%eax
   150fa:	05 00 20 00 00       	add    $0x2000,%eax
   150ff:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   15102:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15105:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15108:	01 d0                	add    %edx,%eax
   1510a:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   15110:	83 c0 04             	add    $0x4,%eax
   15113:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   15116:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15119:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   1511f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15122:	01 d0                	add    %edx,%eax
   15124:	c1 f8 03             	sar    $0x3,%eax
   15127:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   1512a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1512d:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   15133:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15136:	01 d0                	add    %edx,%eax
   15138:	c1 f8 03             	sar    $0x3,%eax
   1513b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   1513e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15141:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15144:	01 d0                	add    %edx,%eax
   15146:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   1514c:	83 c0 04             	add    $0x4,%eax
   1514f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   15152:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15155:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   1515b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1515e:	01 d0                	add    %edx,%eax
   15160:	c1 f8 03             	sar    $0x3,%eax
   15163:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   15166:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15169:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   1516f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15172:	01 d0                	add    %edx,%eax
   15174:	c1 f8 03             	sar    $0x3,%eax
   15177:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   1517a:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1517d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15180:	01 d0                	add    %edx,%eax
   15182:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   15185:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15188:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   1518b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1518e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15191:	01 d0                	add    %edx,%eax
   15193:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   15199:	83 c0 04             	add    $0x4,%eax
   1519c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   1519f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151a2:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   151a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   151ab:	01 d0                	add    %edx,%eax
   151ad:	c1 f8 03             	sar    $0x3,%eax
   151b0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   151b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151b6:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   151bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
   151bf:	01 d0                	add    %edx,%eax
   151c1:	c1 f8 03             	sar    $0x3,%eax
   151c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   151c7:	8b 55 ec             	mov    -0x14(%ebp),%edx
   151ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   151cd:	01 d0                	add    %edx,%eax
   151cf:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   151d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   151d5:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   151d8:	8b 55 e8             	mov    -0x18(%ebp),%edx
   151db:	8b 45 e0             	mov    -0x20(%ebp),%eax
   151de:	01 d0                	add    %edx,%eax
   151e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   151e3:	8b 45 e0             	mov    -0x20(%ebp),%eax
   151e6:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   151e9:	8b 55 dc             	mov    -0x24(%ebp),%edx
   151ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151ef:	01 d0                	add    %edx,%eax
   151f1:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   151f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151f7:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   151fa:	8b 55 fc             	mov    -0x4(%ebp),%edx
   151fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15200:	01 d0                	add    %edx,%eax
   15202:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   15205:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15208:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   1520b:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1520e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15211:	01 d0                	add    %edx,%eax
   15213:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15219:	83 e8 80             	sub    $0xffffff80,%eax
   1521c:	c1 f8 08             	sar    $0x8,%eax
   1521f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   15222:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15225:	2b 45 e8             	sub    -0x18(%ebp),%eax
   15228:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1522e:	83 e8 80             	sub    $0xffffff80,%eax
   15231:	c1 f8 08             	sar    $0x8,%eax
   15234:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   15237:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1523a:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1523d:	01 d0                	add    %edx,%eax
   1523f:	c1 f8 0e             	sar    $0xe,%eax
   15242:	83 e8 80             	sub    $0xffffff80,%eax
   15245:	50                   	push   %eax
   15246:	e8 4c e9 ff ff       	call   13b97 <_Clip>
   1524b:	83 c4 04             	add    $0x4,%esp
   1524e:	89 c2                	mov    %eax,%edx
   15250:	8b 45 0c             	mov    0xc(%ebp),%eax
   15253:	88 10                	mov    %dl,(%eax)
   15255:	8b 45 10             	mov    0x10(%ebp),%eax
   15258:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   1525b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1525e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15261:	01 d0                	add    %edx,%eax
   15263:	c1 f8 0e             	sar    $0xe,%eax
   15266:	83 e8 80             	sub    $0xffffff80,%eax
   15269:	50                   	push   %eax
   1526a:	e8 28 e9 ff ff       	call   13b97 <_Clip>
   1526f:	83 c4 04             	add    $0x4,%esp
   15272:	89 c2                	mov    %eax,%edx
   15274:	8b 45 0c             	mov    0xc(%ebp),%eax
   15277:	88 10                	mov    %dl,(%eax)
   15279:	8b 45 10             	mov    0x10(%ebp),%eax
   1527c:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   1527f:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15282:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15285:	01 d0                	add    %edx,%eax
   15287:	c1 f8 0e             	sar    $0xe,%eax
   1528a:	83 e8 80             	sub    $0xffffff80,%eax
   1528d:	50                   	push   %eax
   1528e:	e8 04 e9 ff ff       	call   13b97 <_Clip>
   15293:	83 c4 04             	add    $0x4,%esp
   15296:	89 c2                	mov    %eax,%edx
   15298:	8b 45 0c             	mov    0xc(%ebp),%eax
   1529b:	88 10                	mov    %dl,(%eax)
   1529d:	8b 45 10             	mov    0x10(%ebp),%eax
   152a0:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   152a3:	8b 55 dc             	mov    -0x24(%ebp),%edx
   152a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   152a9:	01 d0                	add    %edx,%eax
   152ab:	c1 f8 0e             	sar    $0xe,%eax
   152ae:	83 e8 80             	sub    $0xffffff80,%eax
   152b1:	50                   	push   %eax
   152b2:	e8 e0 e8 ff ff       	call   13b97 <_Clip>
   152b7:	83 c4 04             	add    $0x4,%esp
   152ba:	89 c2                	mov    %eax,%edx
   152bc:	8b 45 0c             	mov    0xc(%ebp),%eax
   152bf:	88 10                	mov    %dl,(%eax)
   152c1:	8b 45 10             	mov    0x10(%ebp),%eax
   152c4:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   152c7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   152ca:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   152cd:	c1 f8 0e             	sar    $0xe,%eax
   152d0:	83 e8 80             	sub    $0xffffff80,%eax
   152d3:	50                   	push   %eax
   152d4:	e8 be e8 ff ff       	call   13b97 <_Clip>
   152d9:	83 c4 04             	add    $0x4,%esp
   152dc:	89 c2                	mov    %eax,%edx
   152de:	8b 45 0c             	mov    0xc(%ebp),%eax
   152e1:	88 10                	mov    %dl,(%eax)
   152e3:	8b 45 10             	mov    0x10(%ebp),%eax
   152e6:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   152e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   152ec:	2b 45 ec             	sub    -0x14(%ebp),%eax
   152ef:	c1 f8 0e             	sar    $0xe,%eax
   152f2:	83 e8 80             	sub    $0xffffff80,%eax
   152f5:	50                   	push   %eax
   152f6:	e8 9c e8 ff ff       	call   13b97 <_Clip>
   152fb:	83 c4 04             	add    $0x4,%esp
   152fe:	89 c2                	mov    %eax,%edx
   15300:	8b 45 0c             	mov    0xc(%ebp),%eax
   15303:	88 10                	mov    %dl,(%eax)
   15305:	8b 45 10             	mov    0x10(%ebp),%eax
   15308:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   1530b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1530e:	2b 45 f4             	sub    -0xc(%ebp),%eax
   15311:	c1 f8 0e             	sar    $0xe,%eax
   15314:	83 e8 80             	sub    $0xffffff80,%eax
   15317:	50                   	push   %eax
   15318:	e8 7a e8 ff ff       	call   13b97 <_Clip>
   1531d:	83 c4 04             	add    $0x4,%esp
   15320:	89 c2                	mov    %eax,%edx
   15322:	8b 45 0c             	mov    0xc(%ebp),%eax
   15325:	88 10                	mov    %dl,(%eax)
   15327:	8b 45 10             	mov    0x10(%ebp),%eax
   1532a:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   1532d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15330:	2b 45 f8             	sub    -0x8(%ebp),%eax
   15333:	c1 f8 0e             	sar    $0xe,%eax
   15336:	83 e8 80             	sub    $0xffffff80,%eax
   15339:	50                   	push   %eax
   1533a:	e8 58 e8 ff ff       	call   13b97 <_Clip>
   1533f:	83 c4 04             	add    $0x4,%esp
   15342:	89 c2                	mov    %eax,%edx
   15344:	8b 45 0c             	mov    0xc(%ebp),%eax
   15347:	88 10                	mov    %dl,(%eax)
}
   15349:	c9                   	leave  
   1534a:	c3                   	ret    

0001534b <_ByteAlign>:

void _ByteAlign(Context* ctx){
   1534b:	55                   	push   %ebp
   1534c:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   1534e:	8b 45 08             	mov    0x8(%ebp),%eax
   15351:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15357:	25 f8 00 00 00       	and    $0xf8,%eax
   1535c:	89 c2                	mov    %eax,%edx
   1535e:	8b 45 08             	mov    0x8(%ebp),%eax
   15361:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   15367:	90                   	nop
   15368:	5d                   	pop    %ebp
   15369:	c3                   	ret    

0001536a <_SkipMarker>:

void _SkipMarker(Context* ctx){
   1536a:	55                   	push   %ebp
   1536b:	89 e5                	mov    %esp,%ebp
   1536d:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   15370:	83 ec 0c             	sub    $0xc,%esp
   15373:	ff 75 08             	pushl  0x8(%ebp)
   15376:	e8 8d e8 ff ff       	call   13c08 <_DecodeLength>
   1537b:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   1537e:	8b 45 08             	mov    0x8(%ebp),%eax
   15381:	8b 40 0c             	mov    0xc(%eax),%eax
   15384:	83 ec 08             	sub    $0x8,%esp
   15387:	50                   	push   %eax
   15388:	ff 75 08             	pushl  0x8(%ebp)
   1538b:	e8 2c e8 ff ff       	call   13bbc <_Skip>
   15390:	83 c4 10             	add    $0x10,%esp
}
   15393:	90                   	nop
   15394:	c9                   	leave  
   15395:	c3                   	ret    

00015396 <_Convert>:

void _Convert(Context* ctx){
   15396:	55                   	push   %ebp
   15397:	89 e5                	mov    %esp,%ebp
   15399:	57                   	push   %edi
   1539a:	56                   	push   %esi
   1539b:	53                   	push   %ebx
   1539c:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1539f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   153a6:	8b 45 08             	mov    0x8(%ebp),%eax
   153a9:	83 c0 2c             	add    $0x2c,%eax
   153ac:	89 45 e0             	mov    %eax,-0x20(%ebp)
   153af:	e9 b2 00 00 00       	jmp    15466 <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   153b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   153b7:	8b 50 0c             	mov    0xc(%eax),%edx
   153ba:	8b 45 08             	mov    0x8(%ebp),%eax
   153bd:	8b 40 10             	mov    0x10(%eax),%eax
   153c0:	39 c2                	cmp    %eax,%edx
   153c2:	7d 11                	jge    153d5 <_Convert+0x3f>
   153c4:	83 ec 08             	sub    $0x8,%esp
   153c7:	ff 75 e0             	pushl  -0x20(%ebp)
   153ca:	ff 75 08             	pushl  0x8(%ebp)
   153cd:	e8 79 02 00 00       	call   1564b <_UpsampleH>
   153d2:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   153d5:	8b 45 08             	mov    0x8(%ebp),%eax
   153d8:	8b 00                	mov    (%eax),%eax
   153da:	85 c0                	test   %eax,%eax
   153dc:	0f 85 5d 02 00 00    	jne    1563f <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   153e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   153e5:	8b 50 10             	mov    0x10(%eax),%edx
   153e8:	8b 45 08             	mov    0x8(%ebp),%eax
   153eb:	8b 40 14             	mov    0x14(%eax),%eax
   153ee:	39 c2                	cmp    %eax,%edx
   153f0:	7d 11                	jge    15403 <_Convert+0x6d>
   153f2:	83 ec 08             	sub    $0x8,%esp
   153f5:	ff 75 e0             	pushl  -0x20(%ebp)
   153f8:	ff 75 08             	pushl  0x8(%ebp)
   153fb:	e8 db 05 00 00       	call   159db <_UpsampleV>
   15400:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   15403:	8b 45 08             	mov    0x8(%ebp),%eax
   15406:	8b 00                	mov    (%eax),%eax
   15408:	85 c0                	test   %eax,%eax
   1540a:	0f 85 32 02 00 00    	jne    15642 <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   15410:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15413:	8b 50 0c             	mov    0xc(%eax),%edx
   15416:	8b 45 08             	mov    0x8(%ebp),%eax
   15419:	8b 40 10             	mov    0x10(%eax),%eax
   1541c:	39 c2                	cmp    %eax,%edx
   1541e:	7c 94                	jl     153b4 <_Convert+0x1e>
   15420:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15423:	8b 50 10             	mov    0x10(%eax),%edx
   15426:	8b 45 08             	mov    0x8(%ebp),%eax
   15429:	8b 40 14             	mov    0x14(%eax),%eax
   1542c:	39 c2                	cmp    %eax,%edx
   1542e:	7c 84                	jl     153b4 <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   15430:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15433:	8b 50 0c             	mov    0xc(%eax),%edx
   15436:	8b 45 08             	mov    0x8(%ebp),%eax
   15439:	8b 40 10             	mov    0x10(%eax),%eax
   1543c:	39 c2                	cmp    %eax,%edx
   1543e:	7c 10                	jl     15450 <_Convert+0xba>
   15440:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15443:	8b 50 10             	mov    0x10(%eax),%edx
   15446:	8b 45 08             	mov    0x8(%ebp),%eax
   15449:	8b 40 14             	mov    0x14(%eax),%eax
   1544c:	39 c2                	cmp    %eax,%edx
   1544e:	7d 0e                	jge    1545e <_Convert+0xc8>
   15450:	8b 45 08             	mov    0x8(%ebp),%eax
   15453:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   15459:	e9 e5 01 00 00       	jmp    15643 <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1545e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   15462:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   15466:	8b 45 08             	mov    0x8(%ebp),%eax
   15469:	8b 40 28             	mov    0x28(%eax),%eax
   1546c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   1546f:	7f 9f                	jg     15410 <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   15471:	8b 45 08             	mov    0x8(%ebp),%eax
   15474:	8b 40 28             	mov    0x28(%eax),%eax
   15477:	83 f8 03             	cmp    $0x3,%eax
   1547a:	0f 85 3d 01 00 00    	jne    155bd <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   15480:	8b 45 08             	mov    0x8(%ebp),%eax
   15483:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   15489:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   1548c:	8b 45 08             	mov    0x8(%ebp),%eax
   1548f:	8b 40 54             	mov    0x54(%eax),%eax
   15492:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   15495:	8b 45 08             	mov    0x8(%ebp),%eax
   15498:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   1549e:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   154a1:	8b 45 08             	mov    0x8(%ebp),%eax
   154a4:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   154aa:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   154ad:	8b 45 08             	mov    0x8(%ebp),%eax
   154b0:	8b 40 14             	mov    0x14(%eax),%eax
   154b3:	89 45 d8             	mov    %eax,-0x28(%ebp)
   154b6:	e9 f3 00 00 00       	jmp    155ae <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   154bb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   154c2:	e9 b6 00 00 00       	jmp    1557d <_Convert+0x1e7>
                register int y = py[x] << 8;
   154c7:	8b 55 dc             	mov    -0x24(%ebp),%edx
   154ca:	8b 45 d0             	mov    -0x30(%ebp),%eax
   154cd:	01 d0                	add    %edx,%eax
   154cf:	0f b6 00             	movzbl (%eax),%eax
   154d2:	0f b6 c0             	movzbl %al,%eax
   154d5:	c1 e0 08             	shl    $0x8,%eax
   154d8:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   154da:	8b 55 dc             	mov    -0x24(%ebp),%edx
   154dd:	8b 45 cc             	mov    -0x34(%ebp),%eax
   154e0:	01 d0                	add    %edx,%eax
   154e2:	0f b6 00             	movzbl (%eax),%eax
   154e5:	0f b6 c0             	movzbl %al,%eax
   154e8:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   154eb:	8b 55 dc             	mov    -0x24(%ebp),%edx
   154ee:	8b 45 c8             	mov    -0x38(%ebp),%eax
   154f1:	01 d0                	add    %edx,%eax
   154f3:	0f b6 00             	movzbl (%eax),%eax
   154f6:	0f b6 c0             	movzbl %al,%eax
   154f9:	83 c0 80             	add    $0xffffff80,%eax
   154fc:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   154fe:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15501:	8d 46 01             	lea    0x1(%esi),%eax
   15504:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15507:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   1550a:	89 c8                	mov    %ecx,%eax
   1550c:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   15512:	01 d8                	add    %ebx,%eax
   15514:	83 e8 80             	sub    $0xffffff80,%eax
   15517:	c1 f8 08             	sar    $0x8,%eax
   1551a:	83 ec 0c             	sub    $0xc,%esp
   1551d:	50                   	push   %eax
   1551e:	e8 74 e6 ff ff       	call   13b97 <_Clip>
   15523:	83 c4 10             	add    $0x10,%esp
   15526:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   15528:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1552b:	8d 46 01             	lea    0x1(%esi),%eax
   1552e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15531:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   15534:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   15537:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   1553e:	01 d0                	add    %edx,%eax
   15540:	83 e8 80             	sub    $0xffffff80,%eax
   15543:	c1 f8 08             	sar    $0x8,%eax
   15546:	83 ec 0c             	sub    $0xc,%esp
   15549:	50                   	push   %eax
   1554a:	e8 48 e6 ff ff       	call   13b97 <_Clip>
   1554f:	83 c4 10             	add    $0x10,%esp
   15552:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   15554:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15557:	8d 46 01             	lea    0x1(%esi),%eax
   1555a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1555d:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   15563:	01 d8                	add    %ebx,%eax
   15565:	83 e8 80             	sub    $0xffffff80,%eax
   15568:	c1 f8 08             	sar    $0x8,%eax
   1556b:	83 ec 0c             	sub    $0xc,%esp
   1556e:	50                   	push   %eax
   1556f:	e8 23 e6 ff ff       	call   13b97 <_Clip>
   15574:	83 c4 10             	add    $0x10,%esp
   15577:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   15579:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   1557d:	8b 45 08             	mov    0x8(%ebp),%eax
   15580:	8b 40 10             	mov    0x10(%eax),%eax
   15583:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   15586:	0f 8f 3b ff ff ff    	jg     154c7 <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   1558c:	8b 45 08             	mov    0x8(%ebp),%eax
   1558f:	8b 40 40             	mov    0x40(%eax),%eax
   15592:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   15595:	8b 45 08             	mov    0x8(%ebp),%eax
   15598:	8b 40 6c             	mov    0x6c(%eax),%eax
   1559b:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   1559e:	8b 45 08             	mov    0x8(%ebp),%eax
   155a1:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   155a7:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   155aa:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   155ae:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   155b2:	0f 85 03 ff ff ff    	jne    154bb <_Convert+0x125>
   155b8:	e9 86 00 00 00       	jmp    15643 <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   155bd:	8b 45 08             	mov    0x8(%ebp),%eax
   155c0:	8b 50 38             	mov    0x38(%eax),%edx
   155c3:	8b 45 08             	mov    0x8(%ebp),%eax
   155c6:	8b 40 40             	mov    0x40(%eax),%eax
   155c9:	39 c2                	cmp    %eax,%edx
   155cb:	74 76                	je     15643 <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   155cd:	8b 45 08             	mov    0x8(%ebp),%eax
   155d0:	8b 50 54             	mov    0x54(%eax),%edx
   155d3:	8b 45 08             	mov    0x8(%ebp),%eax
   155d6:	8b 40 40             	mov    0x40(%eax),%eax
   155d9:	01 d0                	add    %edx,%eax
   155db:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   155de:	8b 45 08             	mov    0x8(%ebp),%eax
   155e1:	8b 50 54             	mov    0x54(%eax),%edx
   155e4:	8b 45 08             	mov    0x8(%ebp),%eax
   155e7:	8b 40 38             	mov    0x38(%eax),%eax
   155ea:	01 d0                	add    %edx,%eax
   155ec:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   155ef:	8b 45 08             	mov    0x8(%ebp),%eax
   155f2:	8b 40 3c             	mov    0x3c(%eax),%eax
   155f5:	83 e8 01             	sub    $0x1,%eax
   155f8:	89 45 bc             	mov    %eax,-0x44(%ebp)
   155fb:	eb 2e                	jmp    1562b <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   155fd:	8b 45 08             	mov    0x8(%ebp),%eax
   15600:	8b 40 38             	mov    0x38(%eax),%eax
   15603:	83 ec 04             	sub    $0x4,%esp
   15606:	50                   	push   %eax
   15607:	ff 75 c4             	pushl  -0x3c(%ebp)
   1560a:	ff 75 c0             	pushl  -0x40(%ebp)
   1560d:	e8 72 ac fe ff       	call   284 <memmove>
   15612:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   15615:	8b 45 08             	mov    0x8(%ebp),%eax
   15618:	8b 40 40             	mov    0x40(%eax),%eax
   1561b:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   1561e:	8b 45 08             	mov    0x8(%ebp),%eax
   15621:	8b 40 38             	mov    0x38(%eax),%eax
   15624:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   15627:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   1562b:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   1562f:	75 cc                	jne    155fd <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   15631:	8b 45 08             	mov    0x8(%ebp),%eax
   15634:	8b 50 38             	mov    0x38(%eax),%edx
   15637:	8b 45 08             	mov    0x8(%ebp),%eax
   1563a:	89 50 40             	mov    %edx,0x40(%eax)
   1563d:	eb 04                	jmp    15643 <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   1563f:	90                   	nop
   15640:	eb 01                	jmp    15643 <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   15642:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   15643:	8d 65 f4             	lea    -0xc(%ebp),%esp
   15646:	5b                   	pop    %ebx
   15647:	5e                   	pop    %esi
   15648:	5f                   	pop    %edi
   15649:	5d                   	pop    %ebp
   1564a:	c3                   	ret    

0001564b <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   1564b:	55                   	push   %ebp
   1564c:	89 e5                	mov    %esp,%ebp
   1564e:	53                   	push   %ebx
   1564f:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   15652:	8b 45 0c             	mov    0xc(%ebp),%eax
   15655:	8b 40 0c             	mov    0xc(%eax),%eax
   15658:	83 e8 03             	sub    $0x3,%eax
   1565b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   1565e:	8b 45 0c             	mov    0xc(%ebp),%eax
   15661:	8b 50 0c             	mov    0xc(%eax),%edx
   15664:	8b 45 0c             	mov    0xc(%ebp),%eax
   15667:	8b 40 10             	mov    0x10(%eax),%eax
   1566a:	0f af c2             	imul   %edx,%eax
   1566d:	01 c0                	add    %eax,%eax
   1566f:	83 ec 0c             	sub    $0xc,%esp
   15672:	50                   	push   %eax
   15673:	e8 cb b0 fe ff       	call   743 <malloc>
   15678:	83 c4 10             	add    $0x10,%esp
   1567b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   1567e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   15682:	75 0e                	jne    15692 <_UpsampleH+0x47>
   15684:	8b 45 08             	mov    0x8(%ebp),%eax
   15687:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1568d:	e9 44 03 00 00       	jmp    159d6 <_UpsampleH+0x38b>
    lin = c->pixels;
   15692:	8b 45 0c             	mov    0xc(%ebp),%eax
   15695:	8b 40 28             	mov    0x28(%eax),%eax
   15698:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   1569b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1569e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   156a1:	8b 45 0c             	mov    0xc(%ebp),%eax
   156a4:	8b 40 10             	mov    0x10(%eax),%eax
   156a7:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   156aa:	e9 e0 02 00 00       	jmp    1598f <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   156af:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156b2:	0f b6 00             	movzbl (%eax),%eax
   156b5:	0f b6 c0             	movzbl %al,%eax
   156b8:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   156be:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156c1:	83 c0 01             	add    $0x1,%eax
   156c4:	0f b6 00             	movzbl (%eax),%eax
   156c7:	0f b6 c0             	movzbl %al,%eax
   156ca:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   156cd:	01 d0                	add    %edx,%eax
   156cf:	83 ec 0c             	sub    $0xc,%esp
   156d2:	50                   	push   %eax
   156d3:	e8 c4 06 00 00       	call   15d9c <CF>
   156d8:	83 c4 10             	add    $0x10,%esp
   156db:	89 c2                	mov    %eax,%edx
   156dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   156e0:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   156e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   156e5:	8d 58 01             	lea    0x1(%eax),%ebx
   156e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156eb:	0f b6 00             	movzbl (%eax),%eax
   156ee:	0f b6 c0             	movzbl %al,%eax
   156f1:	6b c8 68             	imul   $0x68,%eax,%ecx
   156f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156f7:	83 c0 01             	add    $0x1,%eax
   156fa:	0f b6 00             	movzbl (%eax),%eax
   156fd:	0f b6 d0             	movzbl %al,%edx
   15700:	89 d0                	mov    %edx,%eax
   15702:	01 c0                	add    %eax,%eax
   15704:	01 d0                	add    %edx,%eax
   15706:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1570d:	01 d0                	add    %edx,%eax
   1570f:	01 c1                	add    %eax,%ecx
   15711:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15714:	83 c0 02             	add    $0x2,%eax
   15717:	0f b6 00             	movzbl (%eax),%eax
   1571a:	0f b6 d0             	movzbl %al,%edx
   1571d:	89 d0                	mov    %edx,%eax
   1571f:	01 c0                	add    %eax,%eax
   15721:	01 d0                	add    %edx,%eax
   15723:	f7 d8                	neg    %eax
   15725:	01 c8                	add    %ecx,%eax
   15727:	83 ec 0c             	sub    $0xc,%esp
   1572a:	50                   	push   %eax
   1572b:	e8 6c 06 00 00       	call   15d9c <CF>
   15730:	83 c4 10             	add    $0x10,%esp
   15733:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   15735:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15738:	8d 58 02             	lea    0x2(%eax),%ebx
   1573b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1573e:	0f b6 00             	movzbl (%eax),%eax
   15741:	0f b6 c0             	movzbl %al,%eax
   15744:	c1 e0 02             	shl    $0x2,%eax
   15747:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1574e:	29 c2                	sub    %eax,%edx
   15750:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15753:	83 c0 01             	add    $0x1,%eax
   15756:	0f b6 00             	movzbl (%eax),%eax
   15759:	0f b6 c0             	movzbl %al,%eax
   1575c:	6b c0 6d             	imul   $0x6d,%eax,%eax
   1575f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15762:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15765:	83 c0 02             	add    $0x2,%eax
   15768:	0f b6 00             	movzbl (%eax),%eax
   1576b:	0f b6 d0             	movzbl %al,%edx
   1576e:	89 d0                	mov    %edx,%eax
   15770:	c1 e0 03             	shl    $0x3,%eax
   15773:	01 d0                	add    %edx,%eax
   15775:	f7 d8                	neg    %eax
   15777:	01 c8                	add    %ecx,%eax
   15779:	83 ec 0c             	sub    $0xc,%esp
   1577c:	50                   	push   %eax
   1577d:	e8 1a 06 00 00       	call   15d9c <CF>
   15782:	83 c4 10             	add    $0x10,%esp
   15785:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   15787:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1578e:	e9 fa 00 00 00       	jmp    1588d <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   15793:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15796:	01 c0                	add    %eax,%eax
   15798:	8d 50 03             	lea    0x3(%eax),%edx
   1579b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1579e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   157a1:	8b 55 ec             	mov    -0x14(%ebp),%edx
   157a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157a7:	01 d0                	add    %edx,%eax
   157a9:	0f b6 00             	movzbl (%eax),%eax
   157ac:	0f b6 d0             	movzbl %al,%edx
   157af:	89 d0                	mov    %edx,%eax
   157b1:	c1 e0 03             	shl    $0x3,%eax
   157b4:	01 d0                	add    %edx,%eax
   157b6:	f7 d8                	neg    %eax
   157b8:	8b 55 ec             	mov    -0x14(%ebp),%edx
   157bb:	8d 4a 01             	lea    0x1(%edx),%ecx
   157be:	8b 55 f4             	mov    -0xc(%ebp),%edx
   157c1:	01 ca                	add    %ecx,%edx
   157c3:	0f b6 12             	movzbl (%edx),%edx
   157c6:	0f b6 d2             	movzbl %dl,%edx
   157c9:	6b d2 6f             	imul   $0x6f,%edx,%edx
   157cc:	01 c2                	add    %eax,%edx
   157ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
   157d1:	8d 48 02             	lea    0x2(%eax),%ecx
   157d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157d7:	01 c8                	add    %ecx,%eax
   157d9:	0f b6 00             	movzbl (%eax),%eax
   157dc:	0f b6 c0             	movzbl %al,%eax
   157df:	6b c0 1d             	imul   $0x1d,%eax,%eax
   157e2:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   157e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   157e8:	8d 50 03             	lea    0x3(%eax),%edx
   157eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157ee:	01 d0                	add    %edx,%eax
   157f0:	0f b6 00             	movzbl (%eax),%eax
   157f3:	0f b6 d0             	movzbl %al,%edx
   157f6:	89 d0                	mov    %edx,%eax
   157f8:	01 c0                	add    %eax,%eax
   157fa:	01 d0                	add    %edx,%eax
   157fc:	f7 d8                	neg    %eax
   157fe:	01 c8                	add    %ecx,%eax
   15800:	83 ec 0c             	sub    $0xc,%esp
   15803:	50                   	push   %eax
   15804:	e8 93 05 00 00       	call   15d9c <CF>
   15809:	83 c4 10             	add    $0x10,%esp
   1580c:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   1580e:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15811:	01 c0                	add    %eax,%eax
   15813:	8d 50 04             	lea    0x4(%eax),%edx
   15816:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15819:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1581c:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1581f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15822:	01 d0                	add    %edx,%eax
   15824:	0f b6 00             	movzbl (%eax),%eax
   15827:	0f b6 d0             	movzbl %al,%edx
   1582a:	89 d0                	mov    %edx,%eax
   1582c:	01 c0                	add    %eax,%eax
   1582e:	01 d0                	add    %edx,%eax
   15830:	f7 d8                	neg    %eax
   15832:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15835:	8d 4a 01             	lea    0x1(%edx),%ecx
   15838:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1583b:	01 ca                	add    %ecx,%edx
   1583d:	0f b6 12             	movzbl (%edx),%edx
   15840:	0f b6 d2             	movzbl %dl,%edx
   15843:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15846:	01 c2                	add    %eax,%edx
   15848:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1584b:	8d 48 02             	lea    0x2(%eax),%ecx
   1584e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15851:	01 c8                	add    %ecx,%eax
   15853:	0f b6 00             	movzbl (%eax),%eax
   15856:	0f b6 c0             	movzbl %al,%eax
   15859:	6b c0 6f             	imul   $0x6f,%eax,%eax
   1585c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   1585f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15862:	8d 50 03             	lea    0x3(%eax),%edx
   15865:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15868:	01 d0                	add    %edx,%eax
   1586a:	0f b6 00             	movzbl (%eax),%eax
   1586d:	0f b6 d0             	movzbl %al,%edx
   15870:	89 d0                	mov    %edx,%eax
   15872:	c1 e0 03             	shl    $0x3,%eax
   15875:	01 d0                	add    %edx,%eax
   15877:	f7 d8                	neg    %eax
   15879:	01 c8                	add    %ecx,%eax
   1587b:	83 ec 0c             	sub    $0xc,%esp
   1587e:	50                   	push   %eax
   1587f:	e8 18 05 00 00       	call   15d9c <CF>
   15884:	83 c4 10             	add    $0x10,%esp
   15887:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   15889:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1588d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15890:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15893:	0f 8c fa fe ff ff    	jl     15793 <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   15899:	8b 45 0c             	mov    0xc(%ebp),%eax
   1589c:	8b 40 14             	mov    0x14(%eax),%eax
   1589f:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   158a2:	8b 45 0c             	mov    0xc(%ebp),%eax
   158a5:	8b 40 0c             	mov    0xc(%eax),%eax
   158a8:	01 c0                	add    %eax,%eax
   158aa:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   158ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158b0:	8d 58 fd             	lea    -0x3(%eax),%ebx
   158b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158b6:	83 e8 01             	sub    $0x1,%eax
   158b9:	0f b6 00             	movzbl (%eax),%eax
   158bc:	0f b6 c0             	movzbl %al,%eax
   158bf:	c1 e0 02             	shl    $0x2,%eax
   158c2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   158c9:	29 c2                	sub    %eax,%edx
   158cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158ce:	83 e8 02             	sub    $0x2,%eax
   158d1:	0f b6 00             	movzbl (%eax),%eax
   158d4:	0f b6 c0             	movzbl %al,%eax
   158d7:	6b c0 6d             	imul   $0x6d,%eax,%eax
   158da:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   158dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158e0:	83 e8 03             	sub    $0x3,%eax
   158e3:	0f b6 00             	movzbl (%eax),%eax
   158e6:	0f b6 d0             	movzbl %al,%edx
   158e9:	89 d0                	mov    %edx,%eax
   158eb:	c1 e0 03             	shl    $0x3,%eax
   158ee:	01 d0                	add    %edx,%eax
   158f0:	f7 d8                	neg    %eax
   158f2:	01 c8                	add    %ecx,%eax
   158f4:	83 ec 0c             	sub    $0xc,%esp
   158f7:	50                   	push   %eax
   158f8:	e8 9f 04 00 00       	call   15d9c <CF>
   158fd:	83 c4 10             	add    $0x10,%esp
   15900:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   15902:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15905:	8d 58 fe             	lea    -0x2(%eax),%ebx
   15908:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1590b:	83 e8 01             	sub    $0x1,%eax
   1590e:	0f b6 00             	movzbl (%eax),%eax
   15911:	0f b6 c0             	movzbl %al,%eax
   15914:	6b c8 68             	imul   $0x68,%eax,%ecx
   15917:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1591a:	83 e8 02             	sub    $0x2,%eax
   1591d:	0f b6 00             	movzbl (%eax),%eax
   15920:	0f b6 d0             	movzbl %al,%edx
   15923:	89 d0                	mov    %edx,%eax
   15925:	01 c0                	add    %eax,%eax
   15927:	01 d0                	add    %edx,%eax
   15929:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15930:	01 d0                	add    %edx,%eax
   15932:	01 c1                	add    %eax,%ecx
   15934:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15937:	83 e8 03             	sub    $0x3,%eax
   1593a:	0f b6 00             	movzbl (%eax),%eax
   1593d:	0f b6 d0             	movzbl %al,%edx
   15940:	89 d0                	mov    %edx,%eax
   15942:	01 c0                	add    %eax,%eax
   15944:	01 d0                	add    %edx,%eax
   15946:	f7 d8                	neg    %eax
   15948:	01 c8                	add    %ecx,%eax
   1594a:	83 ec 0c             	sub    $0xc,%esp
   1594d:	50                   	push   %eax
   1594e:	e8 49 04 00 00       	call   15d9c <CF>
   15953:	83 c4 10             	add    $0x10,%esp
   15956:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   15958:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1595b:	8d 58 ff             	lea    -0x1(%eax),%ebx
   1595e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15961:	83 e8 01             	sub    $0x1,%eax
   15964:	0f b6 00             	movzbl (%eax),%eax
   15967:	0f b6 c0             	movzbl %al,%eax
   1596a:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15970:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15973:	83 e8 02             	sub    $0x2,%eax
   15976:	0f b6 00             	movzbl (%eax),%eax
   15979:	0f b6 c0             	movzbl %al,%eax
   1597c:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   1597f:	01 d0                	add    %edx,%eax
   15981:	83 ec 0c             	sub    $0xc,%esp
   15984:	50                   	push   %eax
   15985:	e8 12 04 00 00       	call   15d9c <CF>
   1598a:	83 c4 10             	add    $0x10,%esp
   1598d:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   1598f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15992:	8d 50 ff             	lea    -0x1(%eax),%edx
   15995:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15998:	85 c0                	test   %eax,%eax
   1599a:	0f 85 0f fd ff ff    	jne    156af <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   159a0:	8b 45 0c             	mov    0xc(%ebp),%eax
   159a3:	8b 40 0c             	mov    0xc(%eax),%eax
   159a6:	8d 14 00             	lea    (%eax,%eax,1),%edx
   159a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   159ac:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   159af:	8b 45 0c             	mov    0xc(%ebp),%eax
   159b2:	8b 50 0c             	mov    0xc(%eax),%edx
   159b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   159b8:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   159bb:	8b 45 0c             	mov    0xc(%ebp),%eax
   159be:	8b 40 28             	mov    0x28(%eax),%eax
   159c1:	83 ec 0c             	sub    $0xc,%esp
   159c4:	50                   	push   %eax
   159c5:	e8 37 ac fe ff       	call   601 <free>
   159ca:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   159cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   159d0:	8b 55 e0             	mov    -0x20(%ebp),%edx
   159d3:	89 50 28             	mov    %edx,0x28(%eax)
}
   159d6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   159d9:	c9                   	leave  
   159da:	c3                   	ret    

000159db <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   159db:	55                   	push   %ebp
   159dc:	89 e5                	mov    %esp,%ebp
   159de:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   159e1:	8b 45 0c             	mov    0xc(%ebp),%eax
   159e4:	8b 40 0c             	mov    0xc(%eax),%eax
   159e7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   159ea:	8b 45 0c             	mov    0xc(%ebp),%eax
   159ed:	8b 40 14             	mov    0x14(%eax),%eax
   159f0:	89 45 e0             	mov    %eax,-0x20(%ebp)
   159f3:	8b 45 e0             	mov    -0x20(%ebp),%eax
   159f6:	01 c0                	add    %eax,%eax
   159f8:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   159fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   159fe:	8b 50 0c             	mov    0xc(%eax),%edx
   15a01:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a04:	8b 40 10             	mov    0x10(%eax),%eax
   15a07:	0f af c2             	imul   %edx,%eax
   15a0a:	01 c0                	add    %eax,%eax
   15a0c:	83 ec 0c             	sub    $0xc,%esp
   15a0f:	50                   	push   %eax
   15a10:	e8 2e ad fe ff       	call   743 <malloc>
   15a15:	83 c4 10             	add    $0x10,%esp
   15a18:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15a1b:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15a1f:	75 0e                	jne    15a2f <_UpsampleV+0x54>
   15a21:	8b 45 08             	mov    0x8(%ebp),%eax
   15a24:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15a2a:	e9 6b 03 00 00       	jmp    15d9a <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   15a2f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15a36:	e9 1d 03 00 00       	jmp    15d58 <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   15a3b:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a3e:	8b 50 28             	mov    0x28(%eax),%edx
   15a41:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15a44:	01 d0                	add    %edx,%eax
   15a46:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   15a49:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15a4c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15a4f:	01 d0                	add    %edx,%eax
   15a51:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   15a54:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a57:	0f b6 00             	movzbl (%eax),%eax
   15a5a:	0f b6 c0             	movzbl %al,%eax
   15a5d:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15a63:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   15a66:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a69:	01 c8                	add    %ecx,%eax
   15a6b:	0f b6 00             	movzbl (%eax),%eax
   15a6e:	0f b6 c0             	movzbl %al,%eax
   15a71:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15a74:	01 d0                	add    %edx,%eax
   15a76:	83 ec 0c             	sub    $0xc,%esp
   15a79:	50                   	push   %eax
   15a7a:	e8 1d 03 00 00       	call   15d9c <CF>
   15a7f:	83 c4 10             	add    $0x10,%esp
   15a82:	89 c2                	mov    %eax,%edx
   15a84:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a87:	88 10                	mov    %dl,(%eax)
   15a89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15a8c:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   15a8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a92:	0f b6 00             	movzbl (%eax),%eax
   15a95:	0f b6 c0             	movzbl %al,%eax
   15a98:	6b c8 68             	imul   $0x68,%eax,%ecx
   15a9b:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15a9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15aa1:	01 d0                	add    %edx,%eax
   15aa3:	0f b6 00             	movzbl (%eax),%eax
   15aa6:	0f b6 d0             	movzbl %al,%edx
   15aa9:	89 d0                	mov    %edx,%eax
   15aab:	01 c0                	add    %eax,%eax
   15aad:	01 d0                	add    %edx,%eax
   15aaf:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15ab6:	01 d0                	add    %edx,%eax
   15ab8:	01 c1                	add    %eax,%ecx
   15aba:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15abd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ac0:	01 d0                	add    %edx,%eax
   15ac2:	0f b6 00             	movzbl (%eax),%eax
   15ac5:	0f b6 d0             	movzbl %al,%edx
   15ac8:	89 d0                	mov    %edx,%eax
   15aca:	01 c0                	add    %eax,%eax
   15acc:	01 d0                	add    %edx,%eax
   15ace:	f7 d8                	neg    %eax
   15ad0:	01 c8                	add    %ecx,%eax
   15ad2:	83 ec 0c             	sub    $0xc,%esp
   15ad5:	50                   	push   %eax
   15ad6:	e8 c1 02 00 00       	call   15d9c <CF>
   15adb:	83 c4 10             	add    $0x10,%esp
   15ade:	89 c2                	mov    %eax,%edx
   15ae0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15ae3:	88 10                	mov    %dl,(%eax)
   15ae5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15ae8:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   15aeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15aee:	0f b6 00             	movzbl (%eax),%eax
   15af1:	0f b6 c0             	movzbl %al,%eax
   15af4:	c1 e0 02             	shl    $0x2,%eax
   15af7:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15afe:	89 d1                	mov    %edx,%ecx
   15b00:	29 c1                	sub    %eax,%ecx
   15b02:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15b05:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b08:	01 d0                	add    %edx,%eax
   15b0a:	0f b6 00             	movzbl (%eax),%eax
   15b0d:	0f b6 c0             	movzbl %al,%eax
   15b10:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15b13:	01 c1                	add    %eax,%ecx
   15b15:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15b18:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b1b:	01 d0                	add    %edx,%eax
   15b1d:	0f b6 00             	movzbl (%eax),%eax
   15b20:	0f b6 d0             	movzbl %al,%edx
   15b23:	89 d0                	mov    %edx,%eax
   15b25:	c1 e0 03             	shl    $0x3,%eax
   15b28:	01 d0                	add    %edx,%eax
   15b2a:	f7 d8                	neg    %eax
   15b2c:	01 c8                	add    %ecx,%eax
   15b2e:	83 ec 0c             	sub    $0xc,%esp
   15b31:	50                   	push   %eax
   15b32:	e8 65 02 00 00       	call   15d9c <CF>
   15b37:	83 c4 10             	add    $0x10,%esp
   15b3a:	89 c2                	mov    %eax,%edx
   15b3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b3f:	88 10                	mov    %dl,(%eax)
   15b41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b44:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   15b47:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b4a:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   15b4d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b50:	8b 40 10             	mov    0x10(%eax),%eax
   15b53:	83 e8 03             	sub    $0x3,%eax
   15b56:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15b59:	e9 e6 00 00 00       	jmp    15c44 <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   15b5e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b61:	f7 d8                	neg    %eax
   15b63:	89 c2                	mov    %eax,%edx
   15b65:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b68:	01 d0                	add    %edx,%eax
   15b6a:	0f b6 00             	movzbl (%eax),%eax
   15b6d:	0f b6 d0             	movzbl %al,%edx
   15b70:	89 d0                	mov    %edx,%eax
   15b72:	c1 e0 03             	shl    $0x3,%eax
   15b75:	01 d0                	add    %edx,%eax
   15b77:	f7 d8                	neg    %eax
   15b79:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15b7c:	0f b6 12             	movzbl (%edx),%edx
   15b7f:	0f b6 d2             	movzbl %dl,%edx
   15b82:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15b85:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15b88:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15b8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b8e:	01 d0                	add    %edx,%eax
   15b90:	0f b6 00             	movzbl (%eax),%eax
   15b93:	0f b6 c0             	movzbl %al,%eax
   15b96:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15b99:	01 c1                	add    %eax,%ecx
   15b9b:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15b9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ba1:	01 d0                	add    %edx,%eax
   15ba3:	0f b6 00             	movzbl (%eax),%eax
   15ba6:	0f b6 d0             	movzbl %al,%edx
   15ba9:	89 d0                	mov    %edx,%eax
   15bab:	01 c0                	add    %eax,%eax
   15bad:	01 d0                	add    %edx,%eax
   15baf:	f7 d8                	neg    %eax
   15bb1:	01 c8                	add    %ecx,%eax
   15bb3:	83 ec 0c             	sub    $0xc,%esp
   15bb6:	50                   	push   %eax
   15bb7:	e8 e0 01 00 00       	call   15d9c <CF>
   15bbc:	83 c4 10             	add    $0x10,%esp
   15bbf:	89 c2                	mov    %eax,%edx
   15bc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15bc4:	88 10                	mov    %dl,(%eax)
   15bc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15bc9:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   15bcc:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15bcf:	f7 d8                	neg    %eax
   15bd1:	89 c2                	mov    %eax,%edx
   15bd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bd6:	01 d0                	add    %edx,%eax
   15bd8:	0f b6 00             	movzbl (%eax),%eax
   15bdb:	0f b6 d0             	movzbl %al,%edx
   15bde:	89 d0                	mov    %edx,%eax
   15be0:	01 c0                	add    %eax,%eax
   15be2:	01 d0                	add    %edx,%eax
   15be4:	f7 d8                	neg    %eax
   15be6:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15be9:	0f b6 12             	movzbl (%edx),%edx
   15bec:	0f b6 d2             	movzbl %dl,%edx
   15bef:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15bf2:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15bf5:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15bf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bfb:	01 d0                	add    %edx,%eax
   15bfd:	0f b6 00             	movzbl (%eax),%eax
   15c00:	0f b6 c0             	movzbl %al,%eax
   15c03:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15c06:	01 c1                	add    %eax,%ecx
   15c08:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15c0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c0e:	01 d0                	add    %edx,%eax
   15c10:	0f b6 00             	movzbl (%eax),%eax
   15c13:	0f b6 d0             	movzbl %al,%edx
   15c16:	89 d0                	mov    %edx,%eax
   15c18:	c1 e0 03             	shl    $0x3,%eax
   15c1b:	01 d0                	add    %edx,%eax
   15c1d:	f7 d8                	neg    %eax
   15c1f:	01 c8                	add    %ecx,%eax
   15c21:	83 ec 0c             	sub    $0xc,%esp
   15c24:	50                   	push   %eax
   15c25:	e8 72 01 00 00       	call   15d9c <CF>
   15c2a:	83 c4 10             	add    $0x10,%esp
   15c2d:	89 c2                	mov    %eax,%edx
   15c2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c32:	88 10                	mov    %dl,(%eax)
   15c34:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15c37:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   15c3a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c3d:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   15c40:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   15c44:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15c48:	0f 85 10 ff ff ff    	jne    15b5e <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   15c4e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c51:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   15c54:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c57:	0f b6 00             	movzbl (%eax),%eax
   15c5a:	0f b6 c0             	movzbl %al,%eax
   15c5d:	c1 e0 02             	shl    $0x2,%eax
   15c60:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15c67:	29 c2                	sub    %eax,%edx
   15c69:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c6c:	f7 d8                	neg    %eax
   15c6e:	89 c1                	mov    %eax,%ecx
   15c70:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c73:	01 c8                	add    %ecx,%eax
   15c75:	0f b6 00             	movzbl (%eax),%eax
   15c78:	0f b6 c0             	movzbl %al,%eax
   15c7b:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15c7e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15c81:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15c84:	f7 d8                	neg    %eax
   15c86:	89 c2                	mov    %eax,%edx
   15c88:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c8b:	01 d0                	add    %edx,%eax
   15c8d:	0f b6 00             	movzbl (%eax),%eax
   15c90:	0f b6 d0             	movzbl %al,%edx
   15c93:	89 d0                	mov    %edx,%eax
   15c95:	c1 e0 03             	shl    $0x3,%eax
   15c98:	01 d0                	add    %edx,%eax
   15c9a:	f7 d8                	neg    %eax
   15c9c:	01 c8                	add    %ecx,%eax
   15c9e:	83 ec 0c             	sub    $0xc,%esp
   15ca1:	50                   	push   %eax
   15ca2:	e8 f5 00 00 00       	call   15d9c <CF>
   15ca7:	83 c4 10             	add    $0x10,%esp
   15caa:	89 c2                	mov    %eax,%edx
   15cac:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15caf:	88 10                	mov    %dl,(%eax)
   15cb1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15cb4:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   15cb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cba:	0f b6 00             	movzbl (%eax),%eax
   15cbd:	0f b6 c0             	movzbl %al,%eax
   15cc0:	6b c8 68             	imul   $0x68,%eax,%ecx
   15cc3:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15cc6:	f7 d8                	neg    %eax
   15cc8:	89 c2                	mov    %eax,%edx
   15cca:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ccd:	01 d0                	add    %edx,%eax
   15ccf:	0f b6 00             	movzbl (%eax),%eax
   15cd2:	0f b6 d0             	movzbl %al,%edx
   15cd5:	89 d0                	mov    %edx,%eax
   15cd7:	01 c0                	add    %eax,%eax
   15cd9:	01 d0                	add    %edx,%eax
   15cdb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15ce2:	01 d0                	add    %edx,%eax
   15ce4:	01 c1                	add    %eax,%ecx
   15ce6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15ce9:	f7 d8                	neg    %eax
   15ceb:	89 c2                	mov    %eax,%edx
   15ced:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cf0:	01 d0                	add    %edx,%eax
   15cf2:	0f b6 00             	movzbl (%eax),%eax
   15cf5:	0f b6 d0             	movzbl %al,%edx
   15cf8:	89 d0                	mov    %edx,%eax
   15cfa:	01 c0                	add    %eax,%eax
   15cfc:	01 d0                	add    %edx,%eax
   15cfe:	f7 d8                	neg    %eax
   15d00:	01 c8                	add    %ecx,%eax
   15d02:	83 ec 0c             	sub    $0xc,%esp
   15d05:	50                   	push   %eax
   15d06:	e8 91 00 00 00       	call   15d9c <CF>
   15d0b:	83 c4 10             	add    $0x10,%esp
   15d0e:	89 c2                	mov    %eax,%edx
   15d10:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d13:	88 10                	mov    %dl,(%eax)
   15d15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d18:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   15d1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d1e:	0f b6 00             	movzbl (%eax),%eax
   15d21:	0f b6 c0             	movzbl %al,%eax
   15d24:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15d2a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d2d:	f7 d8                	neg    %eax
   15d2f:	89 c1                	mov    %eax,%ecx
   15d31:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d34:	01 c8                	add    %ecx,%eax
   15d36:	0f b6 00             	movzbl (%eax),%eax
   15d39:	0f b6 c0             	movzbl %al,%eax
   15d3c:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15d3f:	01 d0                	add    %edx,%eax
   15d41:	83 ec 0c             	sub    $0xc,%esp
   15d44:	50                   	push   %eax
   15d45:	e8 52 00 00 00       	call   15d9c <CF>
   15d4a:	83 c4 10             	add    $0x10,%esp
   15d4d:	89 c2                	mov    %eax,%edx
   15d4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d52:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   15d54:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15d58:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15d5b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15d5e:	0f 8c d7 fc ff ff    	jl     15a3b <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   15d64:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d67:	8b 40 10             	mov    0x10(%eax),%eax
   15d6a:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15d6d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d70:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   15d73:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d76:	8b 50 0c             	mov    0xc(%eax),%edx
   15d79:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d7c:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15d7f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d82:	8b 40 28             	mov    0x28(%eax),%eax
   15d85:	83 ec 0c             	sub    $0xc,%esp
   15d88:	50                   	push   %eax
   15d89:	e8 73 a8 fe ff       	call   601 <free>
   15d8e:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15d91:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d94:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15d97:	89 50 28             	mov    %edx,0x28(%eax)
}
   15d9a:	c9                   	leave  
   15d9b:	c3                   	ret    

00015d9c <CF>:

uchar CF(const int x){
   15d9c:	55                   	push   %ebp
   15d9d:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   15d9f:	8b 45 08             	mov    0x8(%ebp),%eax
   15da2:	83 c0 40             	add    $0x40,%eax
   15da5:	c1 f8 07             	sar    $0x7,%eax
   15da8:	50                   	push   %eax
   15da9:	e8 e9 dd ff ff       	call   13b97 <_Clip>
   15dae:	83 c4 04             	add    $0x4,%esp
}
   15db1:	c9                   	leave  
   15db2:	c3                   	ret    
