
_ln：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <main>:
#include "stat.h"
#include "user.h"

int
main(int argc, char *argv[])
{
       0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
       4:	83 e4 f0             	and    $0xfffffff0,%esp
       7:	ff 71 fc             	pushl  -0x4(%ecx)
       a:	55                   	push   %ebp
       b:	89 e5                	mov    %esp,%ebp
       d:	53                   	push   %ebx
       e:	51                   	push   %ecx
       f:	89 cb                	mov    %ecx,%ebx
  if(argc != 3){
      11:	83 3b 03             	cmpl   $0x3,(%ebx)
      14:	74 17                	je     2d <main+0x2d>
    printf(2, "Usage: ln old new\n");
      16:	83 ec 08             	sub    $0x8,%esp
      19:	68 c0 5d 01 00       	push   $0x15dc0
      1e:	6a 02                	push   $0x2
      20:	e8 4d 04 00 00       	call   472 <printf>
      25:	83 c4 10             	add    $0x10,%esp
    exit();
      28:	e8 9e 02 00 00       	call   2cb <exit>
  }
  if(link(argv[1], argv[2]) < 0)
      2d:	8b 43 04             	mov    0x4(%ebx),%eax
      30:	83 c0 08             	add    $0x8,%eax
      33:	8b 10                	mov    (%eax),%edx
      35:	8b 43 04             	mov    0x4(%ebx),%eax
      38:	83 c0 04             	add    $0x4,%eax
      3b:	8b 00                	mov    (%eax),%eax
      3d:	83 ec 08             	sub    $0x8,%esp
      40:	52                   	push   %edx
      41:	50                   	push   %eax
      42:	e8 e4 02 00 00       	call   32b <link>
      47:	83 c4 10             	add    $0x10,%esp
      4a:	85 c0                	test   %eax,%eax
      4c:	79 21                	jns    6f <main+0x6f>
    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
      4e:	8b 43 04             	mov    0x4(%ebx),%eax
      51:	83 c0 08             	add    $0x8,%eax
      54:	8b 10                	mov    (%eax),%edx
      56:	8b 43 04             	mov    0x4(%ebx),%eax
      59:	83 c0 04             	add    $0x4,%eax
      5c:	8b 00                	mov    (%eax),%eax
      5e:	52                   	push   %edx
      5f:	50                   	push   %eax
      60:	68 d3 5d 01 00       	push   $0x15dd3
      65:	6a 02                	push   $0x2
      67:	e8 06 04 00 00       	call   472 <printf>
      6c:	83 c4 10             	add    $0x10,%esp
  exit();
      6f:	e8 57 02 00 00       	call   2cb <exit>

00000074 <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
      74:	55                   	push   %ebp
      75:	89 e5                	mov    %esp,%ebp
      77:	57                   	push   %edi
      78:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
      79:	8b 4d 08             	mov    0x8(%ebp),%ecx
      7c:	8b 55 10             	mov    0x10(%ebp),%edx
      7f:	8b 45 0c             	mov    0xc(%ebp),%eax
      82:	89 cb                	mov    %ecx,%ebx
      84:	89 df                	mov    %ebx,%edi
      86:	89 d1                	mov    %edx,%ecx
      88:	fc                   	cld    
      89:	f3 aa                	rep stos %al,%es:(%edi)
      8b:	89 ca                	mov    %ecx,%edx
      8d:	89 fb                	mov    %edi,%ebx
      8f:	89 5d 08             	mov    %ebx,0x8(%ebp)
      92:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
      95:	90                   	nop
      96:	5b                   	pop    %ebx
      97:	5f                   	pop    %edi
      98:	5d                   	pop    %ebp
      99:	c3                   	ret    

0000009a <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
      9a:	55                   	push   %ebp
      9b:	89 e5                	mov    %esp,%ebp
      9d:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
      a0:	8b 45 08             	mov    0x8(%ebp),%eax
      a3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
      a6:	90                   	nop
      a7:	8b 45 08             	mov    0x8(%ebp),%eax
      aa:	8d 50 01             	lea    0x1(%eax),%edx
      ad:	89 55 08             	mov    %edx,0x8(%ebp)
      b0:	8b 55 0c             	mov    0xc(%ebp),%edx
      b3:	8d 4a 01             	lea    0x1(%edx),%ecx
      b6:	89 4d 0c             	mov    %ecx,0xc(%ebp)
      b9:	0f b6 12             	movzbl (%edx),%edx
      bc:	88 10                	mov    %dl,(%eax)
      be:	0f b6 00             	movzbl (%eax),%eax
      c1:	84 c0                	test   %al,%al
      c3:	75 e2                	jne    a7 <strcpy+0xd>
    ;
  return os;
      c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
      c8:	c9                   	leave  
      c9:	c3                   	ret    

000000ca <strcmp>:

int
strcmp(const char *p, const char *q)
{
      ca:	55                   	push   %ebp
      cb:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
      cd:	eb 08                	jmp    d7 <strcmp+0xd>
    p++, q++;
      cf:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      d3:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
      d7:	8b 45 08             	mov    0x8(%ebp),%eax
      da:	0f b6 00             	movzbl (%eax),%eax
      dd:	84 c0                	test   %al,%al
      df:	74 10                	je     f1 <strcmp+0x27>
      e1:	8b 45 08             	mov    0x8(%ebp),%eax
      e4:	0f b6 10             	movzbl (%eax),%edx
      e7:	8b 45 0c             	mov    0xc(%ebp),%eax
      ea:	0f b6 00             	movzbl (%eax),%eax
      ed:	38 c2                	cmp    %al,%dl
      ef:	74 de                	je     cf <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
      f1:	8b 45 08             	mov    0x8(%ebp),%eax
      f4:	0f b6 00             	movzbl (%eax),%eax
      f7:	0f b6 d0             	movzbl %al,%edx
      fa:	8b 45 0c             	mov    0xc(%ebp),%eax
      fd:	0f b6 00             	movzbl (%eax),%eax
     100:	0f b6 c0             	movzbl %al,%eax
     103:	29 c2                	sub    %eax,%edx
     105:	89 d0                	mov    %edx,%eax
}
     107:	5d                   	pop    %ebp
     108:	c3                   	ret    

00000109 <strlen>:

uint
strlen(char *s)
{
     109:	55                   	push   %ebp
     10a:	89 e5                	mov    %esp,%ebp
     10c:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
     10f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     116:	eb 04                	jmp    11c <strlen+0x13>
     118:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
     11c:	8b 55 fc             	mov    -0x4(%ebp),%edx
     11f:	8b 45 08             	mov    0x8(%ebp),%eax
     122:	01 d0                	add    %edx,%eax
     124:	0f b6 00             	movzbl (%eax),%eax
     127:	84 c0                	test   %al,%al
     129:	75 ed                	jne    118 <strlen+0xf>
    ;
  return n;
     12b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     12e:	c9                   	leave  
     12f:	c3                   	ret    

00000130 <memset>:

void*
memset(void *dst, int c, uint n)
{
     130:	55                   	push   %ebp
     131:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
     133:	8b 45 10             	mov    0x10(%ebp),%eax
     136:	50                   	push   %eax
     137:	ff 75 0c             	pushl  0xc(%ebp)
     13a:	ff 75 08             	pushl  0x8(%ebp)
     13d:	e8 32 ff ff ff       	call   74 <stosb>
     142:	83 c4 0c             	add    $0xc,%esp
  return dst;
     145:	8b 45 08             	mov    0x8(%ebp),%eax
}
     148:	c9                   	leave  
     149:	c3                   	ret    

0000014a <strchr>:

char*
strchr(const char *s, char c)
{
     14a:	55                   	push   %ebp
     14b:	89 e5                	mov    %esp,%ebp
     14d:	83 ec 04             	sub    $0x4,%esp
     150:	8b 45 0c             	mov    0xc(%ebp),%eax
     153:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     156:	eb 14                	jmp    16c <strchr+0x22>
    if(*s == c)
     158:	8b 45 08             	mov    0x8(%ebp),%eax
     15b:	0f b6 00             	movzbl (%eax),%eax
     15e:	3a 45 fc             	cmp    -0x4(%ebp),%al
     161:	75 05                	jne    168 <strchr+0x1e>
      return (char*)s;
     163:	8b 45 08             	mov    0x8(%ebp),%eax
     166:	eb 13                	jmp    17b <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     168:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     16c:	8b 45 08             	mov    0x8(%ebp),%eax
     16f:	0f b6 00             	movzbl (%eax),%eax
     172:	84 c0                	test   %al,%al
     174:	75 e2                	jne    158 <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     176:	b8 00 00 00 00       	mov    $0x0,%eax
}
     17b:	c9                   	leave  
     17c:	c3                   	ret    

0000017d <gets>:

char*
gets(char *buf, int max)
{
     17d:	55                   	push   %ebp
     17e:	89 e5                	mov    %esp,%ebp
     180:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     183:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     18a:	eb 42                	jmp    1ce <gets+0x51>
    cc = read(0, &c, 1);
     18c:	83 ec 04             	sub    $0x4,%esp
     18f:	6a 01                	push   $0x1
     191:	8d 45 ef             	lea    -0x11(%ebp),%eax
     194:	50                   	push   %eax
     195:	6a 00                	push   $0x0
     197:	e8 47 01 00 00       	call   2e3 <read>
     19c:	83 c4 10             	add    $0x10,%esp
     19f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     1a2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     1a6:	7e 33                	jle    1db <gets+0x5e>
      break;
    buf[i++] = c;
     1a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
     1ab:	8d 50 01             	lea    0x1(%eax),%edx
     1ae:	89 55 f4             	mov    %edx,-0xc(%ebp)
     1b1:	89 c2                	mov    %eax,%edx
     1b3:	8b 45 08             	mov    0x8(%ebp),%eax
     1b6:	01 c2                	add    %eax,%edx
     1b8:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     1bc:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     1be:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     1c2:	3c 0a                	cmp    $0xa,%al
     1c4:	74 16                	je     1dc <gets+0x5f>
     1c6:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     1ca:	3c 0d                	cmp    $0xd,%al
     1cc:	74 0e                	je     1dc <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     1ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
     1d1:	83 c0 01             	add    $0x1,%eax
     1d4:	3b 45 0c             	cmp    0xc(%ebp),%eax
     1d7:	7c b3                	jl     18c <gets+0xf>
     1d9:	eb 01                	jmp    1dc <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     1db:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     1dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
     1df:	8b 45 08             	mov    0x8(%ebp),%eax
     1e2:	01 d0                	add    %edx,%eax
     1e4:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     1e7:	8b 45 08             	mov    0x8(%ebp),%eax
}
     1ea:	c9                   	leave  
     1eb:	c3                   	ret    

000001ec <stat>:

int
stat(char *n, struct stat *st)
{
     1ec:	55                   	push   %ebp
     1ed:	89 e5                	mov    %esp,%ebp
     1ef:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     1f2:	83 ec 08             	sub    $0x8,%esp
     1f5:	6a 00                	push   $0x0
     1f7:	ff 75 08             	pushl  0x8(%ebp)
     1fa:	e8 0c 01 00 00       	call   30b <open>
     1ff:	83 c4 10             	add    $0x10,%esp
     202:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     205:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     209:	79 07                	jns    212 <stat+0x26>
    return -1;
     20b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     210:	eb 25                	jmp    237 <stat+0x4b>
  r = fstat(fd, st);
     212:	83 ec 08             	sub    $0x8,%esp
     215:	ff 75 0c             	pushl  0xc(%ebp)
     218:	ff 75 f4             	pushl  -0xc(%ebp)
     21b:	e8 03 01 00 00       	call   323 <fstat>
     220:	83 c4 10             	add    $0x10,%esp
     223:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     226:	83 ec 0c             	sub    $0xc,%esp
     229:	ff 75 f4             	pushl  -0xc(%ebp)
     22c:	e8 c2 00 00 00       	call   2f3 <close>
     231:	83 c4 10             	add    $0x10,%esp
  return r;
     234:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     237:	c9                   	leave  
     238:	c3                   	ret    

00000239 <atoi>:

int
atoi(const char *s)
{
     239:	55                   	push   %ebp
     23a:	89 e5                	mov    %esp,%ebp
     23c:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     23f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     246:	eb 25                	jmp    26d <atoi+0x34>
    n = n*10 + *s++ - '0';
     248:	8b 55 fc             	mov    -0x4(%ebp),%edx
     24b:	89 d0                	mov    %edx,%eax
     24d:	c1 e0 02             	shl    $0x2,%eax
     250:	01 d0                	add    %edx,%eax
     252:	01 c0                	add    %eax,%eax
     254:	89 c1                	mov    %eax,%ecx
     256:	8b 45 08             	mov    0x8(%ebp),%eax
     259:	8d 50 01             	lea    0x1(%eax),%edx
     25c:	89 55 08             	mov    %edx,0x8(%ebp)
     25f:	0f b6 00             	movzbl (%eax),%eax
     262:	0f be c0             	movsbl %al,%eax
     265:	01 c8                	add    %ecx,%eax
     267:	83 e8 30             	sub    $0x30,%eax
     26a:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     26d:	8b 45 08             	mov    0x8(%ebp),%eax
     270:	0f b6 00             	movzbl (%eax),%eax
     273:	3c 2f                	cmp    $0x2f,%al
     275:	7e 0a                	jle    281 <atoi+0x48>
     277:	8b 45 08             	mov    0x8(%ebp),%eax
     27a:	0f b6 00             	movzbl (%eax),%eax
     27d:	3c 39                	cmp    $0x39,%al
     27f:	7e c7                	jle    248 <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     281:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     284:	c9                   	leave  
     285:	c3                   	ret    

00000286 <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     286:	55                   	push   %ebp
     287:	89 e5                	mov    %esp,%ebp
     289:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     28c:	8b 45 08             	mov    0x8(%ebp),%eax
     28f:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     292:	8b 45 0c             	mov    0xc(%ebp),%eax
     295:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     298:	eb 17                	jmp    2b1 <memmove+0x2b>
    *dst++ = *src++;
     29a:	8b 45 fc             	mov    -0x4(%ebp),%eax
     29d:	8d 50 01             	lea    0x1(%eax),%edx
     2a0:	89 55 fc             	mov    %edx,-0x4(%ebp)
     2a3:	8b 55 f8             	mov    -0x8(%ebp),%edx
     2a6:	8d 4a 01             	lea    0x1(%edx),%ecx
     2a9:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     2ac:	0f b6 12             	movzbl (%edx),%edx
     2af:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     2b1:	8b 45 10             	mov    0x10(%ebp),%eax
     2b4:	8d 50 ff             	lea    -0x1(%eax),%edx
     2b7:	89 55 10             	mov    %edx,0x10(%ebp)
     2ba:	85 c0                	test   %eax,%eax
     2bc:	7f dc                	jg     29a <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     2be:	8b 45 08             	mov    0x8(%ebp),%eax
}
     2c1:	c9                   	leave  
     2c2:	c3                   	ret    

000002c3 <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     2c3:	b8 01 00 00 00       	mov    $0x1,%eax
     2c8:	cd 40                	int    $0x40
     2ca:	c3                   	ret    

000002cb <exit>:
SYSCALL(exit)
     2cb:	b8 02 00 00 00       	mov    $0x2,%eax
     2d0:	cd 40                	int    $0x40
     2d2:	c3                   	ret    

000002d3 <wait>:
SYSCALL(wait)
     2d3:	b8 03 00 00 00       	mov    $0x3,%eax
     2d8:	cd 40                	int    $0x40
     2da:	c3                   	ret    

000002db <pipe>:
SYSCALL(pipe)
     2db:	b8 04 00 00 00       	mov    $0x4,%eax
     2e0:	cd 40                	int    $0x40
     2e2:	c3                   	ret    

000002e3 <read>:
SYSCALL(read)
     2e3:	b8 05 00 00 00       	mov    $0x5,%eax
     2e8:	cd 40                	int    $0x40
     2ea:	c3                   	ret    

000002eb <write>:
SYSCALL(write)
     2eb:	b8 10 00 00 00       	mov    $0x10,%eax
     2f0:	cd 40                	int    $0x40
     2f2:	c3                   	ret    

000002f3 <close>:
SYSCALL(close)
     2f3:	b8 15 00 00 00       	mov    $0x15,%eax
     2f8:	cd 40                	int    $0x40
     2fa:	c3                   	ret    

000002fb <kill>:
SYSCALL(kill)
     2fb:	b8 06 00 00 00       	mov    $0x6,%eax
     300:	cd 40                	int    $0x40
     302:	c3                   	ret    

00000303 <exec>:
SYSCALL(exec)
     303:	b8 07 00 00 00       	mov    $0x7,%eax
     308:	cd 40                	int    $0x40
     30a:	c3                   	ret    

0000030b <open>:
SYSCALL(open)
     30b:	b8 0f 00 00 00       	mov    $0xf,%eax
     310:	cd 40                	int    $0x40
     312:	c3                   	ret    

00000313 <mknod>:
SYSCALL(mknod)
     313:	b8 11 00 00 00       	mov    $0x11,%eax
     318:	cd 40                	int    $0x40
     31a:	c3                   	ret    

0000031b <unlink>:
SYSCALL(unlink)
     31b:	b8 12 00 00 00       	mov    $0x12,%eax
     320:	cd 40                	int    $0x40
     322:	c3                   	ret    

00000323 <fstat>:
SYSCALL(fstat)
     323:	b8 08 00 00 00       	mov    $0x8,%eax
     328:	cd 40                	int    $0x40
     32a:	c3                   	ret    

0000032b <link>:
SYSCALL(link)
     32b:	b8 13 00 00 00       	mov    $0x13,%eax
     330:	cd 40                	int    $0x40
     332:	c3                   	ret    

00000333 <mkdir>:
SYSCALL(mkdir)
     333:	b8 14 00 00 00       	mov    $0x14,%eax
     338:	cd 40                	int    $0x40
     33a:	c3                   	ret    

0000033b <chdir>:
SYSCALL(chdir)
     33b:	b8 09 00 00 00       	mov    $0x9,%eax
     340:	cd 40                	int    $0x40
     342:	c3                   	ret    

00000343 <dup>:
SYSCALL(dup)
     343:	b8 0a 00 00 00       	mov    $0xa,%eax
     348:	cd 40                	int    $0x40
     34a:	c3                   	ret    

0000034b <getpid>:
SYSCALL(getpid)
     34b:	b8 0b 00 00 00       	mov    $0xb,%eax
     350:	cd 40                	int    $0x40
     352:	c3                   	ret    

00000353 <sbrk>:
SYSCALL(sbrk)
     353:	b8 0c 00 00 00       	mov    $0xc,%eax
     358:	cd 40                	int    $0x40
     35a:	c3                   	ret    

0000035b <sleep>:
SYSCALL(sleep)
     35b:	b8 0d 00 00 00       	mov    $0xd,%eax
     360:	cd 40                	int    $0x40
     362:	c3                   	ret    

00000363 <uptime>:
SYSCALL(uptime)
     363:	b8 0e 00 00 00       	mov    $0xe,%eax
     368:	cd 40                	int    $0x40
     36a:	c3                   	ret    

0000036b <createwindow>:
SYSCALL(createwindow)
     36b:	b8 16 00 00 00       	mov    $0x16,%eax
     370:	cd 40                	int    $0x40
     372:	c3                   	ret    

00000373 <repaintwindow>:
SYSCALL(repaintwindow)
     373:	b8 17 00 00 00       	mov    $0x17,%eax
     378:	cd 40                	int    $0x40
     37a:	c3                   	ret    

0000037b <getmessage>:
SYSCALL(getmessage)
     37b:	b8 18 00 00 00       	mov    $0x18,%eax
     380:	cd 40                	int    $0x40
     382:	c3                   	ret    

00000383 <settimer>:
SYSCALL(settimer)
     383:	b8 19 00 00 00       	mov    $0x19,%eax
     388:	cd 40                	int    $0x40
     38a:	c3                   	ret    

0000038b <updatewindow>:
SYSCALL(updatewindow)
     38b:	b8 1a 00 00 00       	mov    $0x1a,%eax
     390:	cd 40                	int    $0x40
     392:	c3                   	ret    

00000393 <destroywindow>:
SYSCALL(destroywindow)
     393:	b8 1b 00 00 00       	mov    $0x1b,%eax
     398:	cd 40                	int    $0x40
     39a:	c3                   	ret    

0000039b <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     39b:	55                   	push   %ebp
     39c:	89 e5                	mov    %esp,%ebp
     39e:	83 ec 18             	sub    $0x18,%esp
     3a1:	8b 45 0c             	mov    0xc(%ebp),%eax
     3a4:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     3a7:	83 ec 04             	sub    $0x4,%esp
     3aa:	6a 01                	push   $0x1
     3ac:	8d 45 f4             	lea    -0xc(%ebp),%eax
     3af:	50                   	push   %eax
     3b0:	ff 75 08             	pushl  0x8(%ebp)
     3b3:	e8 33 ff ff ff       	call   2eb <write>
     3b8:	83 c4 10             	add    $0x10,%esp
}
     3bb:	90                   	nop
     3bc:	c9                   	leave  
     3bd:	c3                   	ret    

000003be <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     3be:	55                   	push   %ebp
     3bf:	89 e5                	mov    %esp,%ebp
     3c1:	53                   	push   %ebx
     3c2:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     3c5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     3cc:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     3d0:	74 17                	je     3e9 <printint+0x2b>
     3d2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     3d6:	79 11                	jns    3e9 <printint+0x2b>
    neg = 1;
     3d8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     3df:	8b 45 0c             	mov    0xc(%ebp),%eax
     3e2:	f7 d8                	neg    %eax
     3e4:	89 45 ec             	mov    %eax,-0x14(%ebp)
     3e7:	eb 06                	jmp    3ef <printint+0x31>
  } else {
    x = xx;
     3e9:	8b 45 0c             	mov    0xc(%ebp),%eax
     3ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     3ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     3f6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     3f9:	8d 41 01             	lea    0x1(%ecx),%eax
     3fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
     3ff:	8b 5d 10             	mov    0x10(%ebp),%ebx
     402:	8b 45 ec             	mov    -0x14(%ebp),%eax
     405:	ba 00 00 00 00       	mov    $0x0,%edx
     40a:	f7 f3                	div    %ebx
     40c:	89 d0                	mov    %edx,%eax
     40e:	0f b6 80 e0 e0 01 00 	movzbl 0x1e0e0(%eax),%eax
     415:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     419:	8b 5d 10             	mov    0x10(%ebp),%ebx
     41c:	8b 45 ec             	mov    -0x14(%ebp),%eax
     41f:	ba 00 00 00 00       	mov    $0x0,%edx
     424:	f7 f3                	div    %ebx
     426:	89 45 ec             	mov    %eax,-0x14(%ebp)
     429:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     42d:	75 c7                	jne    3f6 <printint+0x38>
  if(neg)
     42f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     433:	74 2d                	je     462 <printint+0xa4>
    buf[i++] = '-';
     435:	8b 45 f4             	mov    -0xc(%ebp),%eax
     438:	8d 50 01             	lea    0x1(%eax),%edx
     43b:	89 55 f4             	mov    %edx,-0xc(%ebp)
     43e:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     443:	eb 1d                	jmp    462 <printint+0xa4>
    putc(fd, buf[i]);
     445:	8d 55 dc             	lea    -0x24(%ebp),%edx
     448:	8b 45 f4             	mov    -0xc(%ebp),%eax
     44b:	01 d0                	add    %edx,%eax
     44d:	0f b6 00             	movzbl (%eax),%eax
     450:	0f be c0             	movsbl %al,%eax
     453:	83 ec 08             	sub    $0x8,%esp
     456:	50                   	push   %eax
     457:	ff 75 08             	pushl  0x8(%ebp)
     45a:	e8 3c ff ff ff       	call   39b <putc>
     45f:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     462:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     466:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     46a:	79 d9                	jns    445 <printint+0x87>
    putc(fd, buf[i]);
}
     46c:	90                   	nop
     46d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     470:	c9                   	leave  
     471:	c3                   	ret    

00000472 <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     472:	55                   	push   %ebp
     473:	89 e5                	mov    %esp,%ebp
     475:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     478:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
     47f:	8d 45 0c             	lea    0xc(%ebp),%eax
     482:	83 c0 04             	add    $0x4,%eax
     485:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
     488:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     48f:	e9 59 01 00 00       	jmp    5ed <printf+0x17b>
    c = fmt[i] & 0xff;
     494:	8b 55 0c             	mov    0xc(%ebp),%edx
     497:	8b 45 f0             	mov    -0x10(%ebp),%eax
     49a:	01 d0                	add    %edx,%eax
     49c:	0f b6 00             	movzbl (%eax),%eax
     49f:	0f be c0             	movsbl %al,%eax
     4a2:	25 ff 00 00 00       	and    $0xff,%eax
     4a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
     4aa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     4ae:	75 2c                	jne    4dc <printf+0x6a>
      if(c == '%'){
     4b0:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     4b4:	75 0c                	jne    4c2 <printf+0x50>
        state = '%';
     4b6:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
     4bd:	e9 27 01 00 00       	jmp    5e9 <printf+0x177>
      } else {
        putc(fd, c);
     4c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     4c5:	0f be c0             	movsbl %al,%eax
     4c8:	83 ec 08             	sub    $0x8,%esp
     4cb:	50                   	push   %eax
     4cc:	ff 75 08             	pushl  0x8(%ebp)
     4cf:	e8 c7 fe ff ff       	call   39b <putc>
     4d4:	83 c4 10             	add    $0x10,%esp
     4d7:	e9 0d 01 00 00       	jmp    5e9 <printf+0x177>
      }
    } else if(state == '%'){
     4dc:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
     4e0:	0f 85 03 01 00 00    	jne    5e9 <printf+0x177>
      if(c == 'd'){
     4e6:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
     4ea:	75 1e                	jne    50a <printf+0x98>
        printint(fd, *ap, 10, 1);
     4ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
     4ef:	8b 00                	mov    (%eax),%eax
     4f1:	6a 01                	push   $0x1
     4f3:	6a 0a                	push   $0xa
     4f5:	50                   	push   %eax
     4f6:	ff 75 08             	pushl  0x8(%ebp)
     4f9:	e8 c0 fe ff ff       	call   3be <printint>
     4fe:	83 c4 10             	add    $0x10,%esp
        ap++;
     501:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     505:	e9 d8 00 00 00       	jmp    5e2 <printf+0x170>
      } else if(c == 'x' || c == 'p'){
     50a:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
     50e:	74 06                	je     516 <printf+0xa4>
     510:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
     514:	75 1e                	jne    534 <printf+0xc2>
        printint(fd, *ap, 16, 0);
     516:	8b 45 e8             	mov    -0x18(%ebp),%eax
     519:	8b 00                	mov    (%eax),%eax
     51b:	6a 00                	push   $0x0
     51d:	6a 10                	push   $0x10
     51f:	50                   	push   %eax
     520:	ff 75 08             	pushl  0x8(%ebp)
     523:	e8 96 fe ff ff       	call   3be <printint>
     528:	83 c4 10             	add    $0x10,%esp
        ap++;
     52b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     52f:	e9 ae 00 00 00       	jmp    5e2 <printf+0x170>
      } else if(c == 's'){
     534:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
     538:	75 43                	jne    57d <printf+0x10b>
        s = (char*)*ap;
     53a:	8b 45 e8             	mov    -0x18(%ebp),%eax
     53d:	8b 00                	mov    (%eax),%eax
     53f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
     542:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
     546:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     54a:	75 25                	jne    571 <printf+0xff>
          s = "(null)";
     54c:	c7 45 f4 e7 5d 01 00 	movl   $0x15de7,-0xc(%ebp)
        while(*s != 0){
     553:	eb 1c                	jmp    571 <printf+0xff>
          putc(fd, *s);
     555:	8b 45 f4             	mov    -0xc(%ebp),%eax
     558:	0f b6 00             	movzbl (%eax),%eax
     55b:	0f be c0             	movsbl %al,%eax
     55e:	83 ec 08             	sub    $0x8,%esp
     561:	50                   	push   %eax
     562:	ff 75 08             	pushl  0x8(%ebp)
     565:	e8 31 fe ff ff       	call   39b <putc>
     56a:	83 c4 10             	add    $0x10,%esp
          s++;
     56d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
     571:	8b 45 f4             	mov    -0xc(%ebp),%eax
     574:	0f b6 00             	movzbl (%eax),%eax
     577:	84 c0                	test   %al,%al
     579:	75 da                	jne    555 <printf+0xe3>
     57b:	eb 65                	jmp    5e2 <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
     57d:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
     581:	75 1d                	jne    5a0 <printf+0x12e>
        putc(fd, *ap);
     583:	8b 45 e8             	mov    -0x18(%ebp),%eax
     586:	8b 00                	mov    (%eax),%eax
     588:	0f be c0             	movsbl %al,%eax
     58b:	83 ec 08             	sub    $0x8,%esp
     58e:	50                   	push   %eax
     58f:	ff 75 08             	pushl  0x8(%ebp)
     592:	e8 04 fe ff ff       	call   39b <putc>
     597:	83 c4 10             	add    $0x10,%esp
        ap++;
     59a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     59e:	eb 42                	jmp    5e2 <printf+0x170>
      } else if(c == '%'){
     5a0:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     5a4:	75 17                	jne    5bd <printf+0x14b>
        putc(fd, c);
     5a6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     5a9:	0f be c0             	movsbl %al,%eax
     5ac:	83 ec 08             	sub    $0x8,%esp
     5af:	50                   	push   %eax
     5b0:	ff 75 08             	pushl  0x8(%ebp)
     5b3:	e8 e3 fd ff ff       	call   39b <putc>
     5b8:	83 c4 10             	add    $0x10,%esp
     5bb:	eb 25                	jmp    5e2 <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
     5bd:	83 ec 08             	sub    $0x8,%esp
     5c0:	6a 25                	push   $0x25
     5c2:	ff 75 08             	pushl  0x8(%ebp)
     5c5:	e8 d1 fd ff ff       	call   39b <putc>
     5ca:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
     5cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     5d0:	0f be c0             	movsbl %al,%eax
     5d3:	83 ec 08             	sub    $0x8,%esp
     5d6:	50                   	push   %eax
     5d7:	ff 75 08             	pushl  0x8(%ebp)
     5da:	e8 bc fd ff ff       	call   39b <putc>
     5df:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
     5e2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
     5e9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     5ed:	8b 55 0c             	mov    0xc(%ebp),%edx
     5f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
     5f3:	01 d0                	add    %edx,%eax
     5f5:	0f b6 00             	movzbl (%eax),%eax
     5f8:	84 c0                	test   %al,%al
     5fa:	0f 85 94 fe ff ff    	jne    494 <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
     600:	90                   	nop
     601:	c9                   	leave  
     602:	c3                   	ret    

00000603 <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
     603:	55                   	push   %ebp
     604:	89 e5                	mov    %esp,%ebp
     606:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
     609:	8b 45 08             	mov    0x8(%ebp),%eax
     60c:	83 e8 08             	sub    $0x8,%eax
     60f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     612:	a1 28 e5 01 00       	mov    0x1e528,%eax
     617:	89 45 fc             	mov    %eax,-0x4(%ebp)
     61a:	eb 24                	jmp    640 <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
     61c:	8b 45 fc             	mov    -0x4(%ebp),%eax
     61f:	8b 00                	mov    (%eax),%eax
     621:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     624:	77 12                	ja     638 <free+0x35>
     626:	8b 45 f8             	mov    -0x8(%ebp),%eax
     629:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     62c:	77 24                	ja     652 <free+0x4f>
     62e:	8b 45 fc             	mov    -0x4(%ebp),%eax
     631:	8b 00                	mov    (%eax),%eax
     633:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     636:	77 1a                	ja     652 <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     638:	8b 45 fc             	mov    -0x4(%ebp),%eax
     63b:	8b 00                	mov    (%eax),%eax
     63d:	89 45 fc             	mov    %eax,-0x4(%ebp)
     640:	8b 45 f8             	mov    -0x8(%ebp),%eax
     643:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     646:	76 d4                	jbe    61c <free+0x19>
     648:	8b 45 fc             	mov    -0x4(%ebp),%eax
     64b:	8b 00                	mov    (%eax),%eax
     64d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     650:	76 ca                	jbe    61c <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
     652:	8b 45 f8             	mov    -0x8(%ebp),%eax
     655:	8b 40 04             	mov    0x4(%eax),%eax
     658:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     65f:	8b 45 f8             	mov    -0x8(%ebp),%eax
     662:	01 c2                	add    %eax,%edx
     664:	8b 45 fc             	mov    -0x4(%ebp),%eax
     667:	8b 00                	mov    (%eax),%eax
     669:	39 c2                	cmp    %eax,%edx
     66b:	75 24                	jne    691 <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
     66d:	8b 45 f8             	mov    -0x8(%ebp),%eax
     670:	8b 50 04             	mov    0x4(%eax),%edx
     673:	8b 45 fc             	mov    -0x4(%ebp),%eax
     676:	8b 00                	mov    (%eax),%eax
     678:	8b 40 04             	mov    0x4(%eax),%eax
     67b:	01 c2                	add    %eax,%edx
     67d:	8b 45 f8             	mov    -0x8(%ebp),%eax
     680:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
     683:	8b 45 fc             	mov    -0x4(%ebp),%eax
     686:	8b 00                	mov    (%eax),%eax
     688:	8b 10                	mov    (%eax),%edx
     68a:	8b 45 f8             	mov    -0x8(%ebp),%eax
     68d:	89 10                	mov    %edx,(%eax)
     68f:	eb 0a                	jmp    69b <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
     691:	8b 45 fc             	mov    -0x4(%ebp),%eax
     694:	8b 10                	mov    (%eax),%edx
     696:	8b 45 f8             	mov    -0x8(%ebp),%eax
     699:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
     69b:	8b 45 fc             	mov    -0x4(%ebp),%eax
     69e:	8b 40 04             	mov    0x4(%eax),%eax
     6a1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     6a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6ab:	01 d0                	add    %edx,%eax
     6ad:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     6b0:	75 20                	jne    6d2 <free+0xcf>
    p->s.size += bp->s.size;
     6b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6b5:	8b 50 04             	mov    0x4(%eax),%edx
     6b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6bb:	8b 40 04             	mov    0x4(%eax),%eax
     6be:	01 c2                	add    %eax,%edx
     6c0:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6c3:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
     6c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
     6c9:	8b 10                	mov    (%eax),%edx
     6cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6ce:	89 10                	mov    %edx,(%eax)
     6d0:	eb 08                	jmp    6da <free+0xd7>
  } else
    p->s.ptr = bp;
     6d2:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6d5:	8b 55 f8             	mov    -0x8(%ebp),%edx
     6d8:	89 10                	mov    %edx,(%eax)
  freep = p;
     6da:	8b 45 fc             	mov    -0x4(%ebp),%eax
     6dd:	a3 28 e5 01 00       	mov    %eax,0x1e528
}
     6e2:	90                   	nop
     6e3:	c9                   	leave  
     6e4:	c3                   	ret    

000006e5 <morecore>:

static Header*
morecore(uint nu)
{
     6e5:	55                   	push   %ebp
     6e6:	89 e5                	mov    %esp,%ebp
     6e8:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
     6eb:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
     6f2:	77 07                	ja     6fb <morecore+0x16>
    nu = 4096;
     6f4:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
     6fb:	8b 45 08             	mov    0x8(%ebp),%eax
     6fe:	c1 e0 03             	shl    $0x3,%eax
     701:	83 ec 0c             	sub    $0xc,%esp
     704:	50                   	push   %eax
     705:	e8 49 fc ff ff       	call   353 <sbrk>
     70a:	83 c4 10             	add    $0x10,%esp
     70d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
     710:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     714:	75 07                	jne    71d <morecore+0x38>
    return 0;
     716:	b8 00 00 00 00       	mov    $0x0,%eax
     71b:	eb 26                	jmp    743 <morecore+0x5e>
  hp = (Header*)p;
     71d:	8b 45 f4             	mov    -0xc(%ebp),%eax
     720:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
     723:	8b 45 f0             	mov    -0x10(%ebp),%eax
     726:	8b 55 08             	mov    0x8(%ebp),%edx
     729:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
     72c:	8b 45 f0             	mov    -0x10(%ebp),%eax
     72f:	83 c0 08             	add    $0x8,%eax
     732:	83 ec 0c             	sub    $0xc,%esp
     735:	50                   	push   %eax
     736:	e8 c8 fe ff ff       	call   603 <free>
     73b:	83 c4 10             	add    $0x10,%esp
  return freep;
     73e:	a1 28 e5 01 00       	mov    0x1e528,%eax
}
     743:	c9                   	leave  
     744:	c3                   	ret    

00000745 <malloc>:

void*
malloc(uint nbytes)
{
     745:	55                   	push   %ebp
     746:	89 e5                	mov    %esp,%ebp
     748:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
     74b:	8b 45 08             	mov    0x8(%ebp),%eax
     74e:	83 c0 07             	add    $0x7,%eax
     751:	c1 e8 03             	shr    $0x3,%eax
     754:	83 c0 01             	add    $0x1,%eax
     757:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
     75a:	a1 28 e5 01 00       	mov    0x1e528,%eax
     75f:	89 45 f0             	mov    %eax,-0x10(%ebp)
     762:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     766:	75 23                	jne    78b <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
     768:	c7 45 f0 20 e5 01 00 	movl   $0x1e520,-0x10(%ebp)
     76f:	8b 45 f0             	mov    -0x10(%ebp),%eax
     772:	a3 28 e5 01 00       	mov    %eax,0x1e528
     777:	a1 28 e5 01 00       	mov    0x1e528,%eax
     77c:	a3 20 e5 01 00       	mov    %eax,0x1e520
    base.s.size = 0;
     781:	c7 05 24 e5 01 00 00 	movl   $0x0,0x1e524
     788:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     78b:	8b 45 f0             	mov    -0x10(%ebp),%eax
     78e:	8b 00                	mov    (%eax),%eax
     790:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
     793:	8b 45 f4             	mov    -0xc(%ebp),%eax
     796:	8b 40 04             	mov    0x4(%eax),%eax
     799:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     79c:	72 4d                	jb     7eb <malloc+0xa6>
      if(p->s.size == nunits)
     79e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7a1:	8b 40 04             	mov    0x4(%eax),%eax
     7a4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     7a7:	75 0c                	jne    7b5 <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
     7a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7ac:	8b 10                	mov    (%eax),%edx
     7ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
     7b1:	89 10                	mov    %edx,(%eax)
     7b3:	eb 26                	jmp    7db <malloc+0x96>
      else {
        p->s.size -= nunits;
     7b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7b8:	8b 40 04             	mov    0x4(%eax),%eax
     7bb:	2b 45 ec             	sub    -0x14(%ebp),%eax
     7be:	89 c2                	mov    %eax,%edx
     7c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7c3:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
     7c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7c9:	8b 40 04             	mov    0x4(%eax),%eax
     7cc:	c1 e0 03             	shl    $0x3,%eax
     7cf:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
     7d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7d5:	8b 55 ec             	mov    -0x14(%ebp),%edx
     7d8:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
     7db:	8b 45 f0             	mov    -0x10(%ebp),%eax
     7de:	a3 28 e5 01 00       	mov    %eax,0x1e528
      return (void*)(p + 1);
     7e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
     7e6:	83 c0 08             	add    $0x8,%eax
     7e9:	eb 3b                	jmp    826 <malloc+0xe1>
    }
    if(p == freep)
     7eb:	a1 28 e5 01 00       	mov    0x1e528,%eax
     7f0:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     7f3:	75 1e                	jne    813 <malloc+0xce>
      if((p = morecore(nunits)) == 0)
     7f5:	83 ec 0c             	sub    $0xc,%esp
     7f8:	ff 75 ec             	pushl  -0x14(%ebp)
     7fb:	e8 e5 fe ff ff       	call   6e5 <morecore>
     800:	83 c4 10             	add    $0x10,%esp
     803:	89 45 f4             	mov    %eax,-0xc(%ebp)
     806:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     80a:	75 07                	jne    813 <malloc+0xce>
        return 0;
     80c:	b8 00 00 00 00       	mov    $0x0,%eax
     811:	eb 13                	jmp    826 <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     813:	8b 45 f4             	mov    -0xc(%ebp),%eax
     816:	89 45 f0             	mov    %eax,-0x10(%ebp)
     819:	8b 45 f4             	mov    -0xc(%ebp),%eax
     81c:	8b 00                	mov    (%eax),%eax
     81e:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
     821:	e9 6d ff ff ff       	jmp    793 <malloc+0x4e>
}
     826:	c9                   	leave  
     827:	c3                   	ret    

00000828 <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
     828:	55                   	push   %ebp
     829:	89 e5                	mov    %esp,%ebp
    ++g_seed;
     82b:	a1 2c e5 01 00       	mov    0x1e52c,%eax
     830:	83 c0 01             	add    $0x1,%eax
     833:	a3 2c e5 01 00       	mov    %eax,0x1e52c
    g_seed = (214013*g_seed+2531011);
     838:	a1 2c e5 01 00       	mov    0x1e52c,%eax
     83d:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
     843:	05 c3 9e 26 00       	add    $0x269ec3,%eax
     848:	a3 2c e5 01 00       	mov    %eax,0x1e52c
    return (g_seed>>16)&0x7FFF;
     84d:	a1 2c e5 01 00       	mov    0x1e52c,%eax
     852:	c1 e8 10             	shr    $0x10,%eax
     855:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
     85a:	5d                   	pop    %ebp
     85b:	c3                   	ret    

0000085c <abs>:

#define PI 3.1415926536

float abs(float x) 
{
     85c:	55                   	push   %ebp
     85d:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
     85f:	d9 45 08             	flds   0x8(%ebp)
     862:	d9 ee                	fldz   
     864:	d9 c9                	fxch   %st(1)
     866:	df e9                	fucomip %st(1),%st
     868:	dd d8                	fstp   %st(0)
     86a:	76 05                	jbe    871 <abs+0x15>
     86c:	d9 45 08             	flds   0x8(%ebp)
     86f:	eb 05                	jmp    876 <abs+0x1a>
	return -x;
     871:	d9 45 08             	flds   0x8(%ebp)
     874:	d9 e0                	fchs   
}
     876:	5d                   	pop    %ebp
     877:	c3                   	ret    

00000878 <pow>:

float pow(float a, int b)
{
     878:	55                   	push   %ebp
     879:	89 e5                	mov    %esp,%ebp
     87b:	83 ec 10             	sub    $0x10,%esp
	float r = a;
     87e:	d9 45 08             	flds   0x8(%ebp)
     881:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
     884:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     888:	7e 17                	jle    8a1 <pow+0x29>
		while (--b)
     88a:	eb 09                	jmp    895 <pow+0x1d>
			r *= a;
     88c:	d9 45 fc             	flds   -0x4(%ebp)
     88f:	d8 4d 08             	fmuls  0x8(%ebp)
     892:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
     895:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
     899:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     89d:	75 ed                	jne    88c <pow+0x14>
     89f:	eb 2a                	jmp    8cb <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
     8a1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     8a5:	79 1f                	jns    8c6 <pow+0x4e>
		while (++b)
     8a7:	eb 09                	jmp    8b2 <pow+0x3a>
			r *= a;
     8a9:	d9 45 fc             	flds   -0x4(%ebp)
     8ac:	d8 4d 08             	fmuls  0x8(%ebp)
     8af:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
     8b2:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
     8b6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     8ba:	75 ed                	jne    8a9 <pow+0x31>
			r *= a;
		r = 1.0 / r;
     8bc:	d9 e8                	fld1   
     8be:	d8 75 fc             	fdivs  -0x4(%ebp)
     8c1:	d9 5d fc             	fstps  -0x4(%ebp)
     8c4:	eb 05                	jmp    8cb <pow+0x53>
	}
	else r = 0;
     8c6:	d9 ee                	fldz   
     8c8:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
     8cb:	d9 45 fc             	flds   -0x4(%ebp)
}
     8ce:	c9                   	leave  
     8cf:	c3                   	ret    

000008d0 <sqrt>:

float sqrt(float number) {
     8d0:	55                   	push   %ebp
     8d1:	89 e5                	mov    %esp,%ebp
     8d3:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
     8d6:	d9 ee                	fldz   
     8d8:	d9 45 08             	flds   0x8(%ebp)
     8db:	d9 c9                	fxch   %st(1)
     8dd:	df e9                	fucomip %st(1),%st
     8df:	dd d8                	fstp   %st(0)
     8e1:	76 06                	jbe    8e9 <sqrt+0x19>
		return -1;
     8e3:	d9 e8                	fld1   
     8e5:	d9 e0                	fchs   
     8e7:	eb 3a                	jmp    923 <sqrt+0x53>
	}

	new_guess = 1;
     8e9:	d9 e8                	fld1   
     8eb:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
     8ee:	d9 45 fc             	flds   -0x4(%ebp)
     8f1:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
     8f4:	d9 45 08             	flds   0x8(%ebp)
     8f7:	d8 75 f8             	fdivs  -0x8(%ebp)
     8fa:	d8 45 f8             	fadds  -0x8(%ebp)
     8fd:	d9 05 f0 5d 01 00    	flds   0x15df0
     903:	de f9                	fdivrp %st,%st(1)
     905:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
     908:	d9 45 fc             	flds   -0x4(%ebp)
     90b:	d9 45 f8             	flds   -0x8(%ebp)
     90e:	df e9                	fucomip %st(1),%st
     910:	dd d8                	fstp   %st(0)
     912:	7a da                	jp     8ee <sqrt+0x1e>
     914:	d9 45 fc             	flds   -0x4(%ebp)
     917:	d9 45 f8             	flds   -0x8(%ebp)
     91a:	df e9                	fucomip %st(1),%st
     91c:	dd d8                	fstp   %st(0)
     91e:	75 ce                	jne    8ee <sqrt+0x1e>

	return new_guess;
     920:	d9 45 fc             	flds   -0x4(%ebp)
}
     923:	c9                   	leave  
     924:	c3                   	ret    

00000925 <cos>:

float cos(float x)
{
     925:	55                   	push   %ebp
     926:	89 e5                	mov    %esp,%ebp
     928:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     92b:	d9 e8                	fld1   
     92d:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     930:	d9 45 08             	flds   0x8(%ebp)
     933:	dd 05 f8 5d 01 00    	fldl   0x15df8
     939:	d9 c9                	fxch   %st(1)
     93b:	df e9                	fucomip %st(1),%st
     93d:	dd d8                	fstp   %st(0)
     93f:	77 0f                	ja     950 <cos+0x2b>
     941:	d9 45 08             	flds   0x8(%ebp)
     944:	dd 05 00 5e 01 00    	fldl   0x15e00
     94a:	df e9                	fucomip %st(1),%st
     94c:	dd d8                	fstp   %st(0)
     94e:	76 3c                	jbe    98c <cos+0x67>
     950:	d9 45 08             	flds   0x8(%ebp)
     953:	d9 45 08             	flds   0x8(%ebp)
     956:	dd 05 f8 5d 01 00    	fldl   0x15df8
     95c:	de f9                	fdivrp %st,%st(1)
     95e:	d9 7d e2             	fnstcw -0x1e(%ebp)
     961:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     965:	b4 0c                	mov    $0xc,%ah
     967:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     96b:	d9 6d e0             	fldcw  -0x20(%ebp)
     96e:	db 5d dc             	fistpl -0x24(%ebp)
     971:	d9 6d e2             	fldcw  -0x1e(%ebp)
     974:	8b 45 dc             	mov    -0x24(%ebp),%eax
     977:	01 c0                	add    %eax,%eax
     979:	89 45 d8             	mov    %eax,-0x28(%ebp)
     97c:	db 45 d8             	fildl  -0x28(%ebp)
     97f:	dd 05 08 5e 01 00    	fldl   0x15e08
     985:	de c9                	fmulp  %st,%st(1)
     987:	de e9                	fsubrp %st,%st(1)
     989:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     98c:	d9 45 08             	flds   0x8(%ebp)
     98f:	dd 05 08 5e 01 00    	fldl   0x15e08
     995:	d9 c9                	fxch   %st(1)
     997:	df e9                	fucomip %st(1),%st
     999:	dd d8                	fstp   %st(0)
     99b:	76 0e                	jbe    9ab <cos+0x86>
     99d:	d9 45 08             	flds   0x8(%ebp)
     9a0:	dd 05 f8 5d 01 00    	fldl   0x15df8
     9a6:	de e9                	fsubrp %st,%st(1)
     9a8:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     9ab:	d9 45 08             	flds   0x8(%ebp)
     9ae:	dd 05 10 5e 01 00    	fldl   0x15e10
     9b4:	df e9                	fucomip %st(1),%st
     9b6:	dd d8                	fstp   %st(0)
     9b8:	76 0e                	jbe    9c8 <cos+0xa3>
     9ba:	d9 45 08             	flds   0x8(%ebp)
     9bd:	dd 05 f8 5d 01 00    	fldl   0x15df8
     9c3:	de c1                	faddp  %st,%st(1)
     9c5:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     9c8:	d9 45 08             	flds   0x8(%ebp)
     9cb:	dd 05 18 5e 01 00    	fldl   0x15e18
     9d1:	d9 c9                	fxch   %st(1)
     9d3:	df e9                	fucomip %st(1),%st
     9d5:	dd d8                	fstp   %st(0)
     9d7:	76 16                	jbe    9ef <cos+0xca>
    {
        x -= PI;
     9d9:	d9 45 08             	flds   0x8(%ebp)
     9dc:	dd 05 08 5e 01 00    	fldl   0x15e08
     9e2:	de e9                	fsubrp %st,%st(1)
     9e4:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     9e7:	d9 45 f4             	flds   -0xc(%ebp)
     9ea:	d9 e0                	fchs   
     9ec:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     9ef:	d9 45 08             	flds   0x8(%ebp)
     9f2:	dd 05 20 5e 01 00    	fldl   0x15e20
     9f8:	df e9                	fucomip %st(1),%st
     9fa:	dd d8                	fstp   %st(0)
     9fc:	76 16                	jbe    a14 <cos+0xef>
    {
        x += PI;
     9fe:	d9 45 08             	flds   0x8(%ebp)
     a01:	dd 05 08 5e 01 00    	fldl   0x15e08
     a07:	de c1                	faddp  %st,%st(1)
     a09:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     a0c:	d9 45 f4             	flds   -0xc(%ebp)
     a0f:	d9 e0                	fchs   
     a11:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
     a14:	d9 45 08             	flds   0x8(%ebp)
     a17:	dd 05 28 5e 01 00    	fldl   0x15e28
     a1d:	d9 c9                	fxch   %st(1)
     a1f:	df e9                	fucomip %st(1),%st
     a21:	dd d8                	fstp   %st(0)
     a23:	76 28                	jbe    a4d <cos+0x128>
     a25:	d9 45 08             	flds   0x8(%ebp)
     a28:	dd 05 18 5e 01 00    	fldl   0x15e18
     a2e:	de e1                	fsubp  %st,%st(1)
     a30:	d9 5d e4             	fstps  -0x1c(%ebp)
     a33:	d9 45 e4             	flds   -0x1c(%ebp)
     a36:	83 ec 0c             	sub    $0xc,%esp
     a39:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     a3d:	d9 1c 24             	fstps  (%esp)
     a40:	e8 83 00 00 00       	call   ac8 <sin>
     a45:	83 c4 10             	add    $0x10,%esp
     a48:	d8 4d f4             	fmuls  -0xc(%ebp)
     a4b:	eb 79                	jmp    ac6 <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
     a4d:	83 ec 08             	sub    $0x8,%esp
     a50:	6a 02                	push   $0x2
     a52:	ff 75 08             	pushl  0x8(%ebp)
     a55:	e8 1e fe ff ff       	call   878 <pow>
     a5a:	83 c4 10             	add    $0x10,%esp
     a5d:	d9 05 f0 5d 01 00    	flds   0x15df0
     a63:	de f9                	fdivrp %st,%st(1)
     a65:	d9 e8                	fld1   
     a67:	de e1                	fsubp  %st,%st(1)
     a69:	d9 5d d8             	fstps  -0x28(%ebp)
     a6c:	83 ec 08             	sub    $0x8,%esp
     a6f:	6a 04                	push   $0x4
     a71:	ff 75 08             	pushl  0x8(%ebp)
     a74:	e8 ff fd ff ff       	call   878 <pow>
     a79:	83 c4 10             	add    $0x10,%esp
     a7c:	d9 05 30 5e 01 00    	flds   0x15e30
     a82:	de f9                	fdivrp %st,%st(1)
     a84:	d8 45 d8             	fadds  -0x28(%ebp)
     a87:	d9 5d d8             	fstps  -0x28(%ebp)
     a8a:	83 ec 08             	sub    $0x8,%esp
     a8d:	6a 06                	push   $0x6
     a8f:	ff 75 08             	pushl  0x8(%ebp)
     a92:	e8 e1 fd ff ff       	call   878 <pow>
     a97:	83 c4 10             	add    $0x10,%esp
     a9a:	d9 05 34 5e 01 00    	flds   0x15e34
     aa0:	de f9                	fdivrp %st,%st(1)
     aa2:	d8 6d d8             	fsubrs -0x28(%ebp)
     aa5:	d9 5d d8             	fstps  -0x28(%ebp)
     aa8:	83 ec 08             	sub    $0x8,%esp
     aab:	6a 08                	push   $0x8
     aad:	ff 75 08             	pushl  0x8(%ebp)
     ab0:	e8 c3 fd ff ff       	call   878 <pow>
     ab5:	83 c4 10             	add    $0x10,%esp
     ab8:	d9 05 38 5e 01 00    	flds   0x15e38
     abe:	de f9                	fdivrp %st,%st(1)
     ac0:	d8 45 d8             	fadds  -0x28(%ebp)
     ac3:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     ac6:	c9                   	leave  
     ac7:	c3                   	ret    

00000ac8 <sin>:

float sin(float x)
{
     ac8:	55                   	push   %ebp
     ac9:	89 e5                	mov    %esp,%ebp
     acb:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     ace:	d9 e8                	fld1   
     ad0:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     ad3:	d9 45 08             	flds   0x8(%ebp)
     ad6:	dd 05 f8 5d 01 00    	fldl   0x15df8
     adc:	d9 c9                	fxch   %st(1)
     ade:	df e9                	fucomip %st(1),%st
     ae0:	dd d8                	fstp   %st(0)
     ae2:	77 0f                	ja     af3 <sin+0x2b>
     ae4:	d9 45 08             	flds   0x8(%ebp)
     ae7:	dd 05 00 5e 01 00    	fldl   0x15e00
     aed:	df e9                	fucomip %st(1),%st
     aef:	dd d8                	fstp   %st(0)
     af1:	76 3c                	jbe    b2f <sin+0x67>
     af3:	d9 45 08             	flds   0x8(%ebp)
     af6:	d9 45 08             	flds   0x8(%ebp)
     af9:	dd 05 f8 5d 01 00    	fldl   0x15df8
     aff:	de f9                	fdivrp %st,%st(1)
     b01:	d9 7d e2             	fnstcw -0x1e(%ebp)
     b04:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     b08:	b4 0c                	mov    $0xc,%ah
     b0a:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     b0e:	d9 6d e0             	fldcw  -0x20(%ebp)
     b11:	db 5d dc             	fistpl -0x24(%ebp)
     b14:	d9 6d e2             	fldcw  -0x1e(%ebp)
     b17:	8b 45 dc             	mov    -0x24(%ebp),%eax
     b1a:	01 c0                	add    %eax,%eax
     b1c:	89 45 d8             	mov    %eax,-0x28(%ebp)
     b1f:	db 45 d8             	fildl  -0x28(%ebp)
     b22:	dd 05 08 5e 01 00    	fldl   0x15e08
     b28:	de c9                	fmulp  %st,%st(1)
     b2a:	de e9                	fsubrp %st,%st(1)
     b2c:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     b2f:	d9 45 08             	flds   0x8(%ebp)
     b32:	dd 05 08 5e 01 00    	fldl   0x15e08
     b38:	d9 c9                	fxch   %st(1)
     b3a:	df e9                	fucomip %st(1),%st
     b3c:	dd d8                	fstp   %st(0)
     b3e:	76 0e                	jbe    b4e <sin+0x86>
     b40:	d9 45 08             	flds   0x8(%ebp)
     b43:	dd 05 f8 5d 01 00    	fldl   0x15df8
     b49:	de e9                	fsubrp %st,%st(1)
     b4b:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     b4e:	d9 45 08             	flds   0x8(%ebp)
     b51:	dd 05 10 5e 01 00    	fldl   0x15e10
     b57:	df e9                	fucomip %st(1),%st
     b59:	dd d8                	fstp   %st(0)
     b5b:	76 0e                	jbe    b6b <sin+0xa3>
     b5d:	d9 45 08             	flds   0x8(%ebp)
     b60:	dd 05 f8 5d 01 00    	fldl   0x15df8
     b66:	de c1                	faddp  %st,%st(1)
     b68:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     b6b:	d9 45 08             	flds   0x8(%ebp)
     b6e:	dd 05 18 5e 01 00    	fldl   0x15e18
     b74:	d9 c9                	fxch   %st(1)
     b76:	df e9                	fucomip %st(1),%st
     b78:	dd d8                	fstp   %st(0)
     b7a:	76 16                	jbe    b92 <sin+0xca>
    {
        x -= PI;
     b7c:	d9 45 08             	flds   0x8(%ebp)
     b7f:	dd 05 08 5e 01 00    	fldl   0x15e08
     b85:	de e9                	fsubrp %st,%st(1)
     b87:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     b8a:	d9 45 f4             	flds   -0xc(%ebp)
     b8d:	d9 e0                	fchs   
     b8f:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     b92:	d9 45 08             	flds   0x8(%ebp)
     b95:	dd 05 20 5e 01 00    	fldl   0x15e20
     b9b:	df e9                	fucomip %st(1),%st
     b9d:	dd d8                	fstp   %st(0)
     b9f:	76 16                	jbe    bb7 <sin+0xef>
    {
        x += PI;
     ba1:	d9 45 08             	flds   0x8(%ebp)
     ba4:	dd 05 08 5e 01 00    	fldl   0x15e08
     baa:	de c1                	faddp  %st,%st(1)
     bac:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     baf:	d9 45 f4             	flds   -0xc(%ebp)
     bb2:	d9 e0                	fchs   
     bb4:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
     bb7:	d9 ee                	fldz   
     bb9:	d9 45 08             	flds   0x8(%ebp)
     bbc:	d9 c9                	fxch   %st(1)
     bbe:	df e9                	fucomip %st(1),%st
     bc0:	dd d8                	fstp   %st(0)
     bc2:	76 10                	jbe    bd4 <sin+0x10c>
    {
        x *= -1;
     bc4:	d9 45 08             	flds   0x8(%ebp)
     bc7:	d9 e0                	fchs   
     bc9:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     bcc:	d9 45 f4             	flds   -0xc(%ebp)
     bcf:	d9 e0                	fchs   
     bd1:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
     bd4:	d9 45 08             	flds   0x8(%ebp)
     bd7:	dd 05 28 5e 01 00    	fldl   0x15e28
     bdd:	d9 c9                	fxch   %st(1)
     bdf:	df e9                	fucomip %st(1),%st
     be1:	dd d8                	fstp   %st(0)
     be3:	76 28                	jbe    c0d <sin+0x145>
     be5:	d9 45 08             	flds   0x8(%ebp)
     be8:	dd 05 18 5e 01 00    	fldl   0x15e18
     bee:	de e1                	fsubp  %st,%st(1)
     bf0:	d9 5d e4             	fstps  -0x1c(%ebp)
     bf3:	d9 45 e4             	flds   -0x1c(%ebp)
     bf6:	83 ec 0c             	sub    $0xc,%esp
     bf9:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     bfd:	d9 1c 24             	fstps  (%esp)
     c00:	e8 20 fd ff ff       	call   925 <cos>
     c05:	83 c4 10             	add    $0x10,%esp
     c08:	d8 4d f4             	fmuls  -0xc(%ebp)
     c0b:	eb 7a                	jmp    c87 <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
     c0d:	83 ec 08             	sub    $0x8,%esp
     c10:	6a 03                	push   $0x3
     c12:	ff 75 08             	pushl  0x8(%ebp)
     c15:	e8 5e fc ff ff       	call   878 <pow>
     c1a:	83 c4 10             	add    $0x10,%esp
     c1d:	d9 05 3c 5e 01 00    	flds   0x15e3c
     c23:	de f9                	fdivrp %st,%st(1)
     c25:	d9 45 08             	flds   0x8(%ebp)
     c28:	de e1                	fsubp  %st,%st(1)
     c2a:	d9 5d d8             	fstps  -0x28(%ebp)
     c2d:	83 ec 08             	sub    $0x8,%esp
     c30:	6a 05                	push   $0x5
     c32:	ff 75 08             	pushl  0x8(%ebp)
     c35:	e8 3e fc ff ff       	call   878 <pow>
     c3a:	83 c4 10             	add    $0x10,%esp
     c3d:	d9 05 40 5e 01 00    	flds   0x15e40
     c43:	de f9                	fdivrp %st,%st(1)
     c45:	d8 45 d8             	fadds  -0x28(%ebp)
     c48:	d9 5d d8             	fstps  -0x28(%ebp)
     c4b:	83 ec 08             	sub    $0x8,%esp
     c4e:	6a 07                	push   $0x7
     c50:	ff 75 08             	pushl  0x8(%ebp)
     c53:	e8 20 fc ff ff       	call   878 <pow>
     c58:	83 c4 10             	add    $0x10,%esp
     c5b:	d9 05 44 5e 01 00    	flds   0x15e44
     c61:	de f9                	fdivrp %st,%st(1)
     c63:	d8 6d d8             	fsubrs -0x28(%ebp)
     c66:	d9 5d d8             	fstps  -0x28(%ebp)
     c69:	83 ec 08             	sub    $0x8,%esp
     c6c:	6a 09                	push   $0x9
     c6e:	ff 75 08             	pushl  0x8(%ebp)
     c71:	e8 02 fc ff ff       	call   878 <pow>
     c76:	83 c4 10             	add    $0x10,%esp
     c79:	d9 05 48 5e 01 00    	flds   0x15e48
     c7f:	de f9                	fdivrp %st,%st(1)
     c81:	d8 45 d8             	fadds  -0x28(%ebp)
     c84:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     c87:	c9                   	leave  
     c88:	c3                   	ret    

00000c89 <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
     c89:	55                   	push   %ebp
     c8a:	89 e5                	mov    %esp,%ebp
     c8c:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
     c8f:	83 ec 04             	sub    $0x4,%esp
     c92:	6a 0e                	push   $0xe
     c94:	ff 75 0c             	pushl  0xc(%ebp)
     c97:	ff 75 08             	pushl  0x8(%ebp)
     c9a:	e8 44 f6 ff ff       	call   2e3 <read>
     c9f:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
     ca2:	83 ec 04             	sub    $0x4,%esp
     ca5:	6a 28                	push   $0x28
     ca7:	ff 75 10             	pushl  0x10(%ebp)
     caa:	ff 75 08             	pushl  0x8(%ebp)
     cad:	e8 31 f6 ff ff       	call   2e3 <read>
     cb2:	83 c4 10             	add    $0x10,%esp
}
     cb5:	90                   	nop
     cb6:	c9                   	leave  
     cb7:	c3                   	ret    

00000cb8 <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
     cb8:	55                   	push   %ebp
     cb9:	89 e5                	mov    %esp,%ebp
     cbb:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     cc1:	83 ec 08             	sub    $0x8,%esp
     cc4:	6a 00                	push   $0x0
     cc6:	ff 75 08             	pushl  0x8(%ebp)
     cc9:	e8 3d f6 ff ff       	call   30b <open>
     cce:	83 c4 10             	add    $0x10,%esp
     cd1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     cd4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     cd8:	79 0a                	jns    ce4 <readBitmapFile+0x2c>
        return -1;
     cda:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     cdf:	e9 6e 01 00 00       	jmp    e52 <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     ce4:	83 ec 04             	sub    $0x4,%esp
     ce7:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     cea:	50                   	push   %eax
     ceb:	8d 45 ca             	lea    -0x36(%ebp),%eax
     cee:	50                   	push   %eax
     cef:	ff 75 ec             	pushl  -0x14(%ebp)
     cf2:	e8 92 ff ff ff       	call   c89 <readBitmapHeader>
     cf7:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     cfa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     cfd:	83 e8 36             	sub    $0x36,%eax
     d00:	83 ec 04             	sub    $0x4,%esp
     d03:	50                   	push   %eax
     d04:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     d0a:	50                   	push   %eax
     d0b:	ff 75 ec             	pushl  -0x14(%ebp)
     d0e:	e8 d0 f5 ff ff       	call   2e3 <read>
     d13:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     d16:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     d19:	8b 45 14             	mov    0x14(%ebp),%eax
     d1c:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     d1e:	8b 55 aa             	mov    -0x56(%ebp),%edx
     d21:	8b 45 10             	mov    0x10(%ebp),%eax
     d24:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     d26:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     d29:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     d2c:	8b 45 aa             	mov    -0x56(%ebp),%eax
     d2f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     d32:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     d36:	0f b7 c0             	movzwl %ax,%eax
     d39:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
     d3c:	8b 45 e8             	mov    -0x18(%ebp),%eax
     d3f:	0f af 45 e0          	imul   -0x20(%ebp),%eax
     d43:	8d 50 07             	lea    0x7(%eax),%edx
     d46:	85 c0                	test   %eax,%eax
     d48:	0f 48 c2             	cmovs  %edx,%eax
     d4b:	c1 f8 03             	sar    $0x3,%eax
     d4e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     d51:	8b 45 0c             	mov    0xc(%ebp),%eax
     d54:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     d57:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     d5a:	83 e8 01             	sub    $0x1,%eax
     d5d:	89 45 f4             	mov    %eax,-0xc(%ebp)
     d60:	e9 d0 00 00 00       	jmp    e35 <readBitmapFile+0x17d>
        if (bits == 32) {
     d65:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
     d69:	75 22                	jne    d8d <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     d6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     d6e:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     d72:	89 c2                	mov    %eax,%edx
     d74:	8b 45 d8             	mov    -0x28(%ebp),%eax
     d77:	01 d0                	add    %edx,%eax
     d79:	83 ec 04             	sub    $0x4,%esp
     d7c:	ff 75 dc             	pushl  -0x24(%ebp)
     d7f:	50                   	push   %eax
     d80:	ff 75 ec             	pushl  -0x14(%ebp)
     d83:	e8 5b f5 ff ff       	call   2e3 <read>
     d88:	83 c4 10             	add    $0x10,%esp
     d8b:	eb 65                	jmp    df2 <readBitmapFile+0x13a>
        } else {
            int j = 0;
     d8d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     d94:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     d9b:	eb 4d                	jmp    dea <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
     d9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
     da0:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     da4:	c1 e0 02             	shl    $0x2,%eax
     da7:	89 c2                	mov    %eax,%edx
     da9:	8b 45 f0             	mov    -0x10(%ebp),%eax
     dac:	c1 e0 02             	shl    $0x2,%eax
     daf:	01 c2                	add    %eax,%edx
     db1:	8b 45 d8             	mov    -0x28(%ebp),%eax
     db4:	01 d0                	add    %edx,%eax
     db6:	83 ec 04             	sub    $0x4,%esp
     db9:	6a 03                	push   $0x3
     dbb:	50                   	push   %eax
     dbc:	ff 75 ec             	pushl  -0x14(%ebp)
     dbf:	e8 1f f5 ff ff       	call   2e3 <read>
     dc4:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
     dc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
     dca:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     dce:	c1 e0 02             	shl    $0x2,%eax
     dd1:	89 c2                	mov    %eax,%edx
     dd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
     dd6:	c1 e0 02             	shl    $0x2,%eax
     dd9:	01 d0                	add    %edx,%eax
     ddb:	8d 50 03             	lea    0x3(%eax),%edx
     dde:	8b 45 d8             	mov    -0x28(%ebp),%eax
     de1:	01 d0                	add    %edx,%eax
     de3:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
     de6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     dea:	8b 45 f0             	mov    -0x10(%ebp),%eax
     ded:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     df0:	7c ab                	jl     d9d <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
     df2:	8b 45 dc             	mov    -0x24(%ebp),%eax
     df5:	99                   	cltd   
     df6:	c1 ea 1e             	shr    $0x1e,%edx
     df9:	01 d0                	add    %edx,%eax
     dfb:	83 e0 03             	and    $0x3,%eax
     dfe:	29 d0                	sub    %edx,%eax
     e00:	85 c0                	test   %eax,%eax
     e02:	7e 2d                	jle    e31 <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
     e04:	8b 45 dc             	mov    -0x24(%ebp),%eax
     e07:	99                   	cltd   
     e08:	c1 ea 1e             	shr    $0x1e,%edx
     e0b:	01 d0                	add    %edx,%eax
     e0d:	83 e0 03             	and    $0x3,%eax
     e10:	29 d0                	sub    %edx,%eax
     e12:	ba 04 00 00 00       	mov    $0x4,%edx
     e17:	29 c2                	sub    %eax,%edx
     e19:	89 d0                	mov    %edx,%eax
     e1b:	83 ec 04             	sub    $0x4,%esp
     e1e:	50                   	push   %eax
     e1f:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     e25:	50                   	push   %eax
     e26:	ff 75 ec             	pushl  -0x14(%ebp)
     e29:	e8 b5 f4 ff ff       	call   2e3 <read>
     e2e:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
     e31:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     e35:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     e39:	0f 89 26 ff ff ff    	jns    d65 <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
     e3f:	83 ec 0c             	sub    $0xc,%esp
     e42:	ff 75 ec             	pushl  -0x14(%ebp)
     e45:	e8 a9 f4 ff ff       	call   2f3 <close>
     e4a:	83 c4 10             	add    $0x10,%esp
    return 0;
     e4d:	b8 00 00 00 00       	mov    $0x0,%eax
}
     e52:	c9                   	leave  
     e53:	c3                   	ret    

00000e54 <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
     e54:	55                   	push   %ebp
     e55:	89 e5                	mov    %esp,%ebp
     e57:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     e5d:	83 ec 08             	sub    $0x8,%esp
     e60:	6a 00                	push   $0x0
     e62:	ff 75 08             	pushl  0x8(%ebp)
     e65:	e8 a1 f4 ff ff       	call   30b <open>
     e6a:	83 c4 10             	add    $0x10,%esp
     e6d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     e70:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     e74:	79 0a                	jns    e80 <read24BitmapFile+0x2c>
        return -1;
     e76:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     e7b:	e9 66 01 00 00       	jmp    fe6 <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     e80:	83 ec 04             	sub    $0x4,%esp
     e83:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     e86:	50                   	push   %eax
     e87:	8d 45 ca             	lea    -0x36(%ebp),%eax
     e8a:	50                   	push   %eax
     e8b:	ff 75 ec             	pushl  -0x14(%ebp)
     e8e:	e8 f6 fd ff ff       	call   c89 <readBitmapHeader>
     e93:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     e96:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     e99:	83 e8 36             	sub    $0x36,%eax
     e9c:	83 ec 04             	sub    $0x4,%esp
     e9f:	50                   	push   %eax
     ea0:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     ea6:	50                   	push   %eax
     ea7:	ff 75 ec             	pushl  -0x14(%ebp)
     eaa:	e8 34 f4 ff ff       	call   2e3 <read>
     eaf:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     eb2:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     eb5:	8b 45 14             	mov    0x14(%ebp),%eax
     eb8:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     eba:	8b 55 aa             	mov    -0x56(%ebp),%edx
     ebd:	8b 45 10             	mov    0x10(%ebp),%eax
     ec0:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     ec2:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     ec5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     ec8:	8b 45 aa             	mov    -0x56(%ebp),%eax
     ecb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     ece:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     ed2:	0f b7 c0             	movzwl %ax,%eax
     ed5:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
     ed8:	8b 55 e8             	mov    -0x18(%ebp),%edx
     edb:	89 d0                	mov    %edx,%eax
     edd:	01 c0                	add    %eax,%eax
     edf:	01 d0                	add    %edx,%eax
     ee1:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     ee4:	8b 45 0c             	mov    0xc(%ebp),%eax
     ee7:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     eea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     eed:	83 e8 01             	sub    $0x1,%eax
     ef0:	89 45 f4             	mov    %eax,-0xc(%ebp)
     ef3:	e9 d1 00 00 00       	jmp    fc9 <read24BitmapFile+0x175>
        if (bits == 24) {
     ef8:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
     efc:	75 22                	jne    f20 <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     efe:	8b 45 f4             	mov    -0xc(%ebp),%eax
     f01:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     f05:	89 c2                	mov    %eax,%edx
     f07:	8b 45 d8             	mov    -0x28(%ebp),%eax
     f0a:	01 d0                	add    %edx,%eax
     f0c:	83 ec 04             	sub    $0x4,%esp
     f0f:	ff 75 dc             	pushl  -0x24(%ebp)
     f12:	50                   	push   %eax
     f13:	ff 75 ec             	pushl  -0x14(%ebp)
     f16:	e8 c8 f3 ff ff       	call   2e3 <read>
     f1b:	83 c4 10             	add    $0x10,%esp
     f1e:	eb 66                	jmp    f86 <read24BitmapFile+0x132>
        } else {
            int j = 0;
     f20:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     f27:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     f2e:	eb 4e                	jmp    f7e <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
     f30:	8b 45 f4             	mov    -0xc(%ebp),%eax
     f33:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     f37:	89 c2                	mov    %eax,%edx
     f39:	89 d0                	mov    %edx,%eax
     f3b:	01 c0                	add    %eax,%eax
     f3d:	01 d0                	add    %edx,%eax
     f3f:	89 c1                	mov    %eax,%ecx
     f41:	8b 55 f0             	mov    -0x10(%ebp),%edx
     f44:	89 d0                	mov    %edx,%eax
     f46:	01 c0                	add    %eax,%eax
     f48:	01 d0                	add    %edx,%eax
     f4a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
     f4d:	8b 45 d8             	mov    -0x28(%ebp),%eax
     f50:	01 d0                	add    %edx,%eax
     f52:	83 ec 04             	sub    $0x4,%esp
     f55:	6a 03                	push   $0x3
     f57:	50                   	push   %eax
     f58:	ff 75 ec             	pushl  -0x14(%ebp)
     f5b:	e8 83 f3 ff ff       	call   2e3 <read>
     f60:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
     f63:	83 ec 04             	sub    $0x4,%esp
     f66:	6a 01                	push   $0x1
     f68:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     f6e:	50                   	push   %eax
     f6f:	ff 75 ec             	pushl  -0x14(%ebp)
     f72:	e8 6c f3 ff ff       	call   2e3 <read>
     f77:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
     f7a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     f7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
     f81:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     f84:	7c aa                	jl     f30 <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
     f86:	8b 45 dc             	mov    -0x24(%ebp),%eax
     f89:	99                   	cltd   
     f8a:	c1 ea 1e             	shr    $0x1e,%edx
     f8d:	01 d0                	add    %edx,%eax
     f8f:	83 e0 03             	and    $0x3,%eax
     f92:	29 d0                	sub    %edx,%eax
     f94:	85 c0                	test   %eax,%eax
     f96:	7e 2d                	jle    fc5 <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
     f98:	8b 45 dc             	mov    -0x24(%ebp),%eax
     f9b:	99                   	cltd   
     f9c:	c1 ea 1e             	shr    $0x1e,%edx
     f9f:	01 d0                	add    %edx,%eax
     fa1:	83 e0 03             	and    $0x3,%eax
     fa4:	29 d0                	sub    %edx,%eax
     fa6:	ba 04 00 00 00       	mov    $0x4,%edx
     fab:	29 c2                	sub    %eax,%edx
     fad:	89 d0                	mov    %edx,%eax
     faf:	83 ec 04             	sub    $0x4,%esp
     fb2:	50                   	push   %eax
     fb3:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     fb9:	50                   	push   %eax
     fba:	ff 75 ec             	pushl  -0x14(%ebp)
     fbd:	e8 21 f3 ff ff       	call   2e3 <read>
     fc2:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
     fc5:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     fc9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     fcd:	0f 89 25 ff ff ff    	jns    ef8 <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
     fd3:	83 ec 0c             	sub    $0xc,%esp
     fd6:	ff 75 ec             	pushl  -0x14(%ebp)
     fd9:	e8 15 f3 ff ff       	call   2f3 <close>
     fde:	83 c4 10             	add    $0x10,%esp
    return 0;
     fe1:	b8 00 00 00 00       	mov    $0x0,%eax
}
     fe6:	c9                   	leave  
     fe7:	c3                   	ret    

00000fe8 <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
     fe8:	55                   	push   %ebp
     fe9:	89 e5                	mov    %esp,%ebp
     feb:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
     fee:	8b 55 10             	mov    0x10(%ebp),%edx
     ff1:	89 d0                	mov    %edx,%eax
     ff3:	01 c0                	add    %eax,%eax
     ff5:	01 d0                	add    %edx,%eax
     ff7:	c1 e0 03             	shl    $0x3,%eax
     ffa:	83 c0 1f             	add    $0x1f,%eax
     ffd:	8d 50 1f             	lea    0x1f(%eax),%edx
    1000:	85 c0                	test   %eax,%eax
    1002:	0f 48 c2             	cmovs  %edx,%eax
    1005:	c1 f8 05             	sar    $0x5,%eax
    1008:	c1 e0 02             	shl    $0x2,%eax
    100b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    100e:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    1014:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1017:	0f af 45 0c          	imul   0xc(%ebp),%eax
    101b:	83 c0 36             	add    $0x36,%eax
    101e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    1021:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    1027:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    102d:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    1034:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    103b:	8b 45 10             	mov    0x10(%ebp),%eax
    103e:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    1041:	8b 45 0c             	mov    0xc(%ebp),%eax
    1044:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    1047:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    104d:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    1053:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    105a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    105d:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1061:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    1064:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    106b:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    1072:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    1079:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    1080:	83 ec 04             	sub    $0x4,%esp
    1083:	6a 0e                	push   $0xe
    1085:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    1088:	50                   	push   %eax
    1089:	ff 75 08             	pushl  0x8(%ebp)
    108c:	e8 5a f2 ff ff       	call   2eb <write>
    1091:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    1094:	83 ec 04             	sub    $0x4,%esp
    1097:	6a 28                	push   $0x28
    1099:	8d 45 be             	lea    -0x42(%ebp),%eax
    109c:	50                   	push   %eax
    109d:	ff 75 08             	pushl  0x8(%ebp)
    10a0:	e8 46 f2 ff ff       	call   2eb <write>
    10a5:	83 c4 10             	add    $0x10,%esp
}
    10a8:	90                   	nop
    10a9:	c9                   	leave  
    10aa:	c3                   	ret    

000010ab <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    10ab:	55                   	push   %ebp
    10ac:	89 e5                	mov    %esp,%ebp
    10ae:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    10b1:	83 ec 08             	sub    $0x8,%esp
    10b4:	68 02 02 00 00       	push   $0x202
    10b9:	ff 75 08             	pushl  0x8(%ebp)
    10bc:	e8 4a f2 ff ff       	call   30b <open>
    10c1:	83 c4 10             	add    $0x10,%esp
    10c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    10c7:	8b 55 14             	mov    0x14(%ebp),%edx
    10ca:	89 d0                	mov    %edx,%eax
    10cc:	01 c0                	add    %eax,%eax
    10ce:	01 d0                	add    %edx,%eax
    10d0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    10d3:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    10d7:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    10db:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    10df:	83 ec 04             	sub    $0x4,%esp
    10e2:	ff 75 14             	pushl  0x14(%ebp)
    10e5:	ff 75 10             	pushl  0x10(%ebp)
    10e8:	ff 75 f0             	pushl  -0x10(%ebp)
    10eb:	e8 f8 fe ff ff       	call   fe8 <write24BitmapFileHeader>
    10f0:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    10f3:	8b 45 10             	mov    0x10(%ebp),%eax
    10f6:	83 e8 01             	sub    $0x1,%eax
    10f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    10fc:	eb 66                	jmp    1164 <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    10fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1101:	0f af 45 14          	imul   0x14(%ebp),%eax
    1105:	89 c2                	mov    %eax,%edx
    1107:	89 d0                	mov    %edx,%eax
    1109:	01 c0                	add    %eax,%eax
    110b:	01 c2                	add    %eax,%edx
    110d:	8b 45 0c             	mov    0xc(%ebp),%eax
    1110:	01 d0                	add    %edx,%eax
    1112:	83 ec 04             	sub    $0x4,%esp
    1115:	ff 75 ec             	pushl  -0x14(%ebp)
    1118:	50                   	push   %eax
    1119:	ff 75 f0             	pushl  -0x10(%ebp)
    111c:	e8 ca f1 ff ff       	call   2eb <write>
    1121:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    1124:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1127:	99                   	cltd   
    1128:	c1 ea 1e             	shr    $0x1e,%edx
    112b:	01 d0                	add    %edx,%eax
    112d:	83 e0 03             	and    $0x3,%eax
    1130:	29 d0                	sub    %edx,%eax
    1132:	85 c0                	test   %eax,%eax
    1134:	7e 2a                	jle    1160 <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    1136:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1139:	99                   	cltd   
    113a:	c1 ea 1e             	shr    $0x1e,%edx
    113d:	01 d0                	add    %edx,%eax
    113f:	83 e0 03             	and    $0x3,%eax
    1142:	29 d0                	sub    %edx,%eax
    1144:	ba 04 00 00 00       	mov    $0x4,%edx
    1149:	29 c2                	sub    %eax,%edx
    114b:	89 d0                	mov    %edx,%eax
    114d:	83 ec 04             	sub    $0x4,%esp
    1150:	50                   	push   %eax
    1151:	8d 45 e9             	lea    -0x17(%ebp),%eax
    1154:	50                   	push   %eax
    1155:	ff 75 f0             	pushl  -0x10(%ebp)
    1158:	e8 8e f1 ff ff       	call   2eb <write>
    115d:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    1160:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1164:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1168:	79 94                	jns    10fe <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    116a:	83 ec 0c             	sub    $0xc,%esp
    116d:	ff 75 f0             	pushl  -0x10(%ebp)
    1170:	e8 7e f1 ff ff       	call   2f3 <close>
    1175:	83 c4 10             	add    $0x10,%esp
    return 0;
    1178:	b8 00 00 00 00       	mov    $0x0,%eax
    117d:	c9                   	leave  
    117e:	c3                   	ret    

0000117f <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    117f:	55                   	push   %ebp
    1180:	89 e5                	mov    %esp,%ebp
    1182:	57                   	push   %edi
    1183:	56                   	push   %esi
    1184:	53                   	push   %ebx
    1185:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    1188:	8b 45 08             	mov    0x8(%ebp),%eax
    118b:	8b 50 10             	mov    0x10(%eax),%edx
    118e:	8b 40 0c             	mov    0xc(%eax),%eax
    1191:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1194:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    1197:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    119a:	8b 55 e0             	mov    -0x20(%ebp),%edx
    119d:	83 c2 1e             	add    $0x1e,%edx
    11a0:	0f af d0             	imul   %eax,%edx
    11a3:	89 d0                	mov    %edx,%eax
    11a5:	01 c0                	add    %eax,%eax
    11a7:	01 d0                	add    %edx,%eax
    11a9:	83 ec 0c             	sub    $0xc,%esp
    11ac:	50                   	push   %eax
    11ad:	e8 93 f5 ff ff       	call   745 <malloc>
    11b2:	83 c4 10             	add    $0x10,%esp
    11b5:	89 c2                	mov    %eax,%edx
    11b7:	8b 45 08             	mov    0x8(%ebp),%eax
    11ba:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    11bd:	8b 45 08             	mov    0x8(%ebp),%eax
    11c0:	8b 40 1c             	mov    0x1c(%eax),%eax
    11c3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    11c6:	6b d2 5a             	imul   $0x5a,%edx,%edx
    11c9:	01 c2                	add    %eax,%edx
    11cb:	8b 45 08             	mov    0x8(%ebp),%eax
    11ce:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    11d1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    11d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    11d7:	0f af d0             	imul   %eax,%edx
    11da:	89 d0                	mov    %edx,%eax
    11dc:	01 c0                	add    %eax,%eax
    11de:	01 d0                	add    %edx,%eax
    11e0:	89 c2                	mov    %eax,%edx
    11e2:	8b 45 08             	mov    0x8(%ebp),%eax
    11e5:	8b 40 18             	mov    0x18(%eax),%eax
    11e8:	83 ec 04             	sub    $0x4,%esp
    11eb:	52                   	push   %edx
    11ec:	68 ff 00 00 00       	push   $0xff
    11f1:	50                   	push   %eax
    11f2:	e8 39 ef ff ff       	call   130 <memset>
    11f7:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    11fa:	8b 45 08             	mov    0x8(%ebp),%eax
    11fd:	8b 78 1c             	mov    0x1c(%eax),%edi
    1200:	8b 45 08             	mov    0x8(%ebp),%eax
    1203:	8b 70 14             	mov    0x14(%eax),%esi
    1206:	8b 45 08             	mov    0x8(%ebp),%eax
    1209:	8b 58 0c             	mov    0xc(%eax),%ebx
    120c:	8b 45 08             	mov    0x8(%ebp),%eax
    120f:	8b 48 10             	mov    0x10(%eax),%ecx
    1212:	8b 45 08             	mov    0x8(%ebp),%eax
    1215:	8b 50 08             	mov    0x8(%eax),%edx
    1218:	8b 45 08             	mov    0x8(%ebp),%eax
    121b:	8b 40 04             	mov    0x4(%eax),%eax
    121e:	83 ec 08             	sub    $0x8,%esp
    1221:	57                   	push   %edi
    1222:	56                   	push   %esi
    1223:	53                   	push   %ebx
    1224:	51                   	push   %ecx
    1225:	52                   	push   %edx
    1226:	50                   	push   %eax
    1227:	e8 3f f1 ff ff       	call   36b <createwindow>
    122c:	83 c4 20             	add    $0x20,%esp
    122f:	89 c2                	mov    %eax,%edx
    1231:	8b 45 08             	mov    0x8(%ebp),%eax
    1234:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    1236:	8b 45 08             	mov    0x8(%ebp),%eax
    1239:	8b 00                	mov    (%eax),%eax
}
    123b:	8d 65 f4             	lea    -0xc(%ebp),%esp
    123e:	5b                   	pop    %ebx
    123f:	5e                   	pop    %esi
    1240:	5f                   	pop    %edi
    1241:	5d                   	pop    %ebp
    1242:	c3                   	ret    

00001243 <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    1243:	55                   	push   %ebp
    1244:	89 e5                	mov    %esp,%ebp
    1246:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    1249:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1250:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1257:	8b 45 08             	mov    0x8(%ebp),%eax
    125a:	8b 40 18             	mov    0x18(%eax),%eax
    125d:	ff 75 1c             	pushl  0x1c(%ebp)
    1260:	ff 75 18             	pushl  0x18(%ebp)
    1263:	ff 75 1c             	pushl  0x1c(%ebp)
    1266:	ff 75 18             	pushl  0x18(%ebp)
    1269:	8b 55 08             	mov    0x8(%ebp),%edx
    126c:	ff 72 10             	pushl  0x10(%edx)
    126f:	ff 72 0c             	pushl  0xc(%edx)
    1272:	ff 75 f4             	pushl  -0xc(%ebp)
    1275:	ff 75 f0             	pushl  -0x10(%ebp)
    1278:	ff 75 14             	pushl  0x14(%ebp)
    127b:	ff 75 10             	pushl  0x10(%ebp)
    127e:	ff 75 0c             	pushl  0xc(%ebp)
    1281:	50                   	push   %eax
    1282:	e8 d5 07 00 00       	call   1a5c <drawBitmap>
    1287:	83 c4 30             	add    $0x30,%esp
    return 0;
    128a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    128f:	c9                   	leave  
    1290:	c3                   	ret    

00001291 <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    1291:	55                   	push   %ebp
    1292:	89 e5                	mov    %esp,%ebp
    1294:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1297:	8b 45 08             	mov    0x8(%ebp),%eax
    129a:	8b 40 18             	mov    0x18(%eax),%eax
    129d:	ff 75 2c             	pushl  0x2c(%ebp)
    12a0:	ff 75 28             	pushl  0x28(%ebp)
    12a3:	ff 75 24             	pushl  0x24(%ebp)
    12a6:	ff 75 20             	pushl  0x20(%ebp)
    12a9:	8b 55 08             	mov    0x8(%ebp),%edx
    12ac:	ff 72 10             	pushl  0x10(%edx)
    12af:	ff 72 0c             	pushl  0xc(%edx)
    12b2:	ff 75 1c             	pushl  0x1c(%ebp)
    12b5:	ff 75 18             	pushl  0x18(%ebp)
    12b8:	ff 75 14             	pushl  0x14(%ebp)
    12bb:	ff 75 10             	pushl  0x10(%ebp)
    12be:	ff 75 0c             	pushl  0xc(%ebp)
    12c1:	50                   	push   %eax
    12c2:	e8 95 07 00 00       	call   1a5c <drawBitmap>
    12c7:	83 c4 30             	add    $0x30,%esp
    return 0;
    12ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
    12cf:	c9                   	leave  
    12d0:	c3                   	ret    

000012d1 <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    12d1:	55                   	push   %ebp
    12d2:	89 e5                	mov    %esp,%ebp
    12d4:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    12d7:	8b 45 08             	mov    0x8(%ebp),%eax
    12da:	8b 40 18             	mov    0x18(%eax),%eax
    12dd:	ff 75 2c             	pushl  0x2c(%ebp)
    12e0:	ff 75 28             	pushl  0x28(%ebp)
    12e3:	ff 75 24             	pushl  0x24(%ebp)
    12e6:	ff 75 20             	pushl  0x20(%ebp)
    12e9:	8b 55 08             	mov    0x8(%ebp),%edx
    12ec:	ff 72 10             	pushl  0x10(%edx)
    12ef:	ff 72 0c             	pushl  0xc(%edx)
    12f2:	ff 75 1c             	pushl  0x1c(%ebp)
    12f5:	ff 75 18             	pushl  0x18(%ebp)
    12f8:	ff 75 14             	pushl  0x14(%ebp)
    12fb:	ff 75 10             	pushl  0x10(%ebp)
    12fe:	ff 75 0c             	pushl  0xc(%ebp)
    1301:	50                   	push   %eax
    1302:	e8 75 08 00 00       	call   1b7c <drawTransparentBitmap>
    1307:	83 c4 30             	add    $0x30,%esp
    return 0;
    130a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    130f:	c9                   	leave  
    1310:	c3                   	ret    

00001311 <api_repaint>:

int api_repaint(Window* wnd)
{
    1311:	55                   	push   %ebp
    1312:	89 e5                	mov    %esp,%ebp
    1314:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    1317:	8b 45 08             	mov    0x8(%ebp),%eax
    131a:	8b 00                	mov    (%eax),%eax
    131c:	83 ec 0c             	sub    $0xc,%esp
    131f:	50                   	push   %eax
    1320:	e8 4e f0 ff ff       	call   373 <repaintwindow>
    1325:	83 c4 10             	add    $0x10,%esp
    return 0;
    1328:	b8 00 00 00 00       	mov    $0x0,%eax
}
    132d:	c9                   	leave  
    132e:	c3                   	ret    

0000132f <api_update>:

int api_update(Window* wnd, Rect rect)
{
    132f:	55                   	push   %ebp
    1330:	89 e5                	mov    %esp,%ebp
    1332:	56                   	push   %esi
    1333:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    1334:	8b 75 18             	mov    0x18(%ebp),%esi
    1337:	8b 5d 14             	mov    0x14(%ebp),%ebx
    133a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    133d:	8b 55 0c             	mov    0xc(%ebp),%edx
    1340:	8b 45 08             	mov    0x8(%ebp),%eax
    1343:	8b 00                	mov    (%eax),%eax
    1345:	83 ec 0c             	sub    $0xc,%esp
    1348:	56                   	push   %esi
    1349:	53                   	push   %ebx
    134a:	51                   	push   %ecx
    134b:	52                   	push   %edx
    134c:	50                   	push   %eax
    134d:	e8 39 f0 ff ff       	call   38b <updatewindow>
    1352:	83 c4 20             	add    $0x20,%esp
    return 0;
    1355:	b8 00 00 00 00       	mov    $0x0,%eax
}
    135a:	8d 65 f8             	lea    -0x8(%ebp),%esp
    135d:	5b                   	pop    %ebx
    135e:	5e                   	pop    %esi
    135f:	5d                   	pop    %ebp
    1360:	c3                   	ret    

00001361 <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    1361:	55                   	push   %ebp
    1362:	89 e5                	mov    %esp,%ebp
    1364:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    1367:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    136e:	8b 45 08             	mov    0x8(%ebp),%eax
    1371:	8b 00                	mov    (%eax),%eax
    1373:	83 ec 08             	sub    $0x8,%esp
    1376:	8d 55 c8             	lea    -0x38(%ebp),%edx
    1379:	52                   	push   %edx
    137a:	50                   	push   %eax
    137b:	e8 fb ef ff ff       	call   37b <getmessage>
    1380:	83 c4 10             	add    $0x10,%esp
    1383:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    1386:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    138a:	74 e2                	je     136e <api_exec+0xd>
        {
            pf(&msg);
    138c:	83 ec 0c             	sub    $0xc,%esp
    138f:	8d 45 c8             	lea    -0x38(%ebp),%eax
    1392:	50                   	push   %eax
    1393:	8b 45 0c             	mov    0xc(%ebp),%eax
    1396:	ff d0                	call   *%eax
    1398:	83 c4 10             	add    $0x10,%esp
        }
    }
    139b:	eb d1                	jmp    136e <api_exec+0xd>

0000139d <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    139d:	55                   	push   %ebp
    139e:	89 e5                	mov    %esp,%ebp
    13a0:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    13a3:	8b 45 08             	mov    0x8(%ebp),%eax
    13a6:	8b 00                	mov    (%eax),%eax
    13a8:	83 ec 08             	sub    $0x8,%esp
    13ab:	ff 75 0c             	pushl  0xc(%ebp)
    13ae:	50                   	push   %eax
    13af:	e8 cf ef ff ff       	call   383 <settimer>
    13b4:	83 c4 10             	add    $0x10,%esp
    return 0;
    13b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13bc:	c9                   	leave  
    13bd:	c3                   	ret    

000013be <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    13be:	55                   	push   %ebp
    13bf:	89 e5                	mov    %esp,%ebp
    13c1:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    13c4:	8b 45 08             	mov    0x8(%ebp),%eax
    13c7:	8b 50 18             	mov    0x18(%eax),%edx
    13ca:	ff 75 18             	pushl  0x18(%ebp)
    13cd:	ff 75 14             	pushl  0x14(%ebp)
    13d0:	83 ec 04             	sub    $0x4,%esp
    13d3:	89 e0                	mov    %esp,%eax
    13d5:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    13d9:	66 89 08             	mov    %cx,(%eax)
    13dc:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    13e0:	88 48 02             	mov    %cl,0x2(%eax)
    13e3:	8b 45 08             	mov    0x8(%ebp),%eax
    13e6:	ff 70 10             	pushl  0x10(%eax)
    13e9:	ff 70 0c             	pushl  0xc(%eax)
    13ec:	ff 75 10             	pushl  0x10(%ebp)
    13ef:	ff 75 0c             	pushl  0xc(%ebp)
    13f2:	52                   	push   %edx
    13f3:	e8 6f 04 00 00       	call   1867 <drawRect>
    13f8:	83 c4 20             	add    $0x20,%esp
    return 0;
    13fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1400:	c9                   	leave  
    1401:	c3                   	ret    

00001402 <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    1402:	55                   	push   %ebp
    1403:	89 e5                	mov    %esp,%ebp
    1405:	83 ec 28             	sub    $0x28,%esp
    1408:	8b 45 14             	mov    0x14(%ebp),%eax
    140b:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    140e:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    1412:	8b 45 0c             	mov    0xc(%ebp),%eax
    1415:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1418:	8b 45 10             	mov    0x10(%ebp),%eax
    141b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    141e:	8b 45 08             	mov    0x8(%ebp),%eax
    1421:	8b 40 18             	mov    0x18(%eax),%eax
    1424:	83 ec 04             	sub    $0x4,%esp
    1427:	ff 75 18             	pushl  0x18(%ebp)
    142a:	52                   	push   %edx
    142b:	8b 55 08             	mov    0x8(%ebp),%edx
    142e:	ff 72 10             	pushl  0x10(%edx)
    1431:	ff 72 0c             	pushl  0xc(%edx)
    1434:	ff 75 f4             	pushl  -0xc(%ebp)
    1437:	ff 75 f0             	pushl  -0x10(%ebp)
    143a:	50                   	push   %eax
    143b:	e8 d4 02 00 00       	call   1714 <drawCharacter>
    1440:	83 c4 20             	add    $0x20,%esp
    return 0;
    1443:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1448:	c9                   	leave  
    1449:	c3                   	ret    

0000144a <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    144a:	55                   	push   %ebp
    144b:	89 e5                	mov    %esp,%ebp
    144d:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    1450:	8b 45 0c             	mov    0xc(%ebp),%eax
    1453:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1456:	8b 45 10             	mov    0x10(%ebp),%eax
    1459:	89 45 f4             	mov    %eax,-0xc(%ebp)
    145c:	8b 45 08             	mov    0x8(%ebp),%eax
    145f:	8b 40 18             	mov    0x18(%eax),%eax
    1462:	83 ec 04             	sub    $0x4,%esp
    1465:	ff 75 18             	pushl  0x18(%ebp)
    1468:	ff 75 14             	pushl  0x14(%ebp)
    146b:	8b 55 08             	mov    0x8(%ebp),%edx
    146e:	ff 72 10             	pushl  0x10(%edx)
    1471:	ff 72 0c             	pushl  0xc(%edx)
    1474:	ff 75 f4             	pushl  -0xc(%ebp)
    1477:	ff 75 f0             	pushl  -0x10(%ebp)
    147a:	50                   	push   %eax
    147b:	e8 8e 03 00 00       	call   180e <drawString>
    1480:	83 c4 20             	add    $0x20,%esp
    return 0;
    1483:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1488:	c9                   	leave  
    1489:	c3                   	ret    

0000148a <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    148a:	55                   	push   %ebp
    148b:	89 e5                	mov    %esp,%ebp
    148d:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    1490:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    1494:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    1498:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    149c:	83 ec 08             	sub    $0x8,%esp
    149f:	83 ec 04             	sub    $0x4,%esp
    14a2:	89 e0                	mov    %esp,%eax
    14a4:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    14a8:	66 89 10             	mov    %dx,(%eax)
    14ab:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    14af:	88 50 02             	mov    %dl,0x2(%eax)
    14b2:	ff 75 18             	pushl  0x18(%ebp)
    14b5:	ff 75 14             	pushl  0x14(%ebp)
    14b8:	ff 75 10             	pushl  0x10(%ebp)
    14bb:	ff 75 0c             	pushl  0xc(%ebp)
    14be:	ff 75 08             	pushl  0x8(%ebp)
    14c1:	e8 f8 fe ff ff       	call   13be <api_drawRect>
    14c6:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    14c9:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    14cd:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    14d1:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    14d5:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    14d9:	8b 45 10             	mov    0x10(%ebp),%eax
    14dc:	8d 50 0a             	lea    0xa(%eax),%edx
    14df:	8b 45 0c             	mov    0xc(%ebp),%eax
    14e2:	83 c0 0a             	add    $0xa,%eax
    14e5:	83 ec 0c             	sub    $0xc,%esp
    14e8:	ff 75 f4             	pushl  -0xc(%ebp)
    14eb:	ff 75 1c             	pushl  0x1c(%ebp)
    14ee:	52                   	push   %edx
    14ef:	50                   	push   %eax
    14f0:	ff 75 08             	pushl  0x8(%ebp)
    14f3:	e8 52 ff ff ff       	call   144a <api_drawString>
    14f8:	83 c4 20             	add    $0x20,%esp
    return 0;
    14fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1500:	c9                   	leave  
    1501:	c3                   	ret    

00001502 <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    1502:	55                   	push   %ebp
    1503:	89 e5                	mov    %esp,%ebp
    1505:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    1508:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    150f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1516:	8b 45 08             	mov    0x8(%ebp),%eax
    1519:	8b 40 18             	mov    0x18(%eax),%eax
    151c:	ff 75 1c             	pushl  0x1c(%ebp)
    151f:	ff 75 18             	pushl  0x18(%ebp)
    1522:	ff 75 1c             	pushl  0x1c(%ebp)
    1525:	ff 75 18             	pushl  0x18(%ebp)
    1528:	8b 55 08             	mov    0x8(%ebp),%edx
    152b:	ff 72 10             	pushl  0x10(%edx)
    152e:	ff 72 0c             	pushl  0xc(%edx)
    1531:	ff 75 f4             	pushl  -0xc(%ebp)
    1534:	ff 75 f0             	pushl  -0x10(%ebp)
    1537:	ff 75 14             	pushl  0x14(%ebp)
    153a:	ff 75 10             	pushl  0x10(%ebp)
    153d:	ff 75 0c             	pushl  0xc(%ebp)
    1540:	50                   	push   %eax
    1541:	e8 16 05 00 00       	call   1a5c <drawBitmap>
    1546:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    1549:	8b 45 08             	mov    0x8(%ebp),%eax
    154c:	8b 40 18             	mov    0x18(%eax),%eax
    154f:	ff 75 28             	pushl  0x28(%ebp)
    1552:	ff 75 1c             	pushl  0x1c(%ebp)
    1555:	ff 75 18             	pushl  0x18(%ebp)
    1558:	8b 55 08             	mov    0x8(%ebp),%edx
    155b:	ff 72 10             	pushl  0x10(%edx)
    155e:	ff 72 0c             	pushl  0xc(%edx)
    1561:	ff 75 14             	pushl  0x14(%ebp)
    1564:	ff 75 10             	pushl  0x10(%ebp)
    1567:	50                   	push   %eax
    1568:	e8 99 07 00 00       	call   1d06 <colorShift>
    156d:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    1570:	8b 45 08             	mov    0x8(%ebp),%eax
    1573:	8b 50 18             	mov    0x18(%eax),%edx
    1576:	83 ec 0c             	sub    $0xc,%esp
    1579:	ff 75 20             	pushl  0x20(%ebp)
    157c:	ff 75 1c             	pushl  0x1c(%ebp)
    157f:	ff 75 18             	pushl  0x18(%ebp)
    1582:	83 ec 04             	sub    $0x4,%esp
    1585:	89 e0                	mov    %esp,%eax
    1587:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    158b:	66 89 08             	mov    %cx,(%eax)
    158e:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    1592:	88 48 02             	mov    %cl,0x2(%eax)
    1595:	8b 45 08             	mov    0x8(%ebp),%eax
    1598:	ff 70 10             	pushl  0x10(%eax)
    159b:	ff 70 0c             	pushl  0xc(%eax)
    159e:	ff 75 14             	pushl  0x14(%ebp)
    15a1:	ff 75 10             	pushl  0x10(%ebp)
    15a4:	52                   	push   %edx
    15a5:	e8 6d 03 00 00       	call   1917 <drawBorder>
    15aa:	83 c4 30             	add    $0x30,%esp
    return 0;
    15ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
    15b2:	c9                   	leave  
    15b3:	c3                   	ret    

000015b4 <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    15b4:	55                   	push   %ebp
    15b5:	89 e5                	mov    %esp,%ebp
    15b7:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    15ba:	8b 45 08             	mov    0x8(%ebp),%eax
    15bd:	8b 00                	mov    (%eax),%eax
    15bf:	83 ec 0c             	sub    $0xc,%esp
    15c2:	50                   	push   %eax
    15c3:	e8 cb ed ff ff       	call   393 <destroywindow>
    15c8:	83 c4 10             	add    $0x10,%esp
    return 0;
    15cb:	b8 00 00 00 00       	mov    $0x0,%eax
    15d0:	c9                   	leave  
    15d1:	c3                   	ret    

000015d2 <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    15d2:	55                   	push   %ebp
    15d3:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    15d5:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    15d9:	8b 45 08             	mov    0x8(%ebp),%eax
    15dc:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    15df:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    15e3:	8b 45 08             	mov    0x8(%ebp),%eax
    15e6:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    15e9:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    15ed:	8b 45 08             	mov    0x8(%ebp),%eax
    15f0:	88 10                	mov    %dl,(%eax)
}
    15f2:	90                   	nop
    15f3:	5d                   	pop    %ebp
    15f4:	c3                   	ret    

000015f5 <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    15f5:	55                   	push   %ebp
    15f6:	89 e5                	mov    %esp,%ebp
    15f8:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    15fb:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    15ff:	3c ff                	cmp    $0xff,%al
    1601:	75 22                	jne    1625 <drawPointAlpha+0x30>
        color->R = origin.R;
    1603:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    1607:	8b 45 08             	mov    0x8(%ebp),%eax
    160a:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    160d:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    1611:	8b 45 08             	mov    0x8(%ebp),%eax
    1614:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    1617:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    161b:	8b 45 08             	mov    0x8(%ebp),%eax
    161e:	88 10                	mov    %dl,(%eax)
        return;
    1620:	e9 ed 00 00 00       	jmp    1712 <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    1625:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1629:	84 c0                	test   %al,%al
    162b:	0f 84 e0 00 00 00    	je     1711 <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    1631:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1635:	0f b6 c0             	movzbl %al,%eax
    1638:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    163c:	df 45 e4             	fild   -0x1c(%ebp)
    163f:	d9 05 a0 9c 01 00    	flds   0x19ca0
    1645:	de f9                	fdivrp %st,%st(1)
    1647:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    164a:	8b 45 08             	mov    0x8(%ebp),%eax
    164d:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1651:	0f b6 c0             	movzbl %al,%eax
    1654:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1657:	db 45 e4             	fildl  -0x1c(%ebp)
    165a:	d9 e8                	fld1   
    165c:	d8 65 fc             	fsubs  -0x4(%ebp)
    165f:	de c9                	fmulp  %st,%st(1)
    1661:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    1665:	0f b6 c0             	movzbl %al,%eax
    1668:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    166b:	db 45 e4             	fildl  -0x1c(%ebp)
    166e:	d8 4d fc             	fmuls  -0x4(%ebp)
    1671:	de c1                	faddp  %st,%st(1)
    1673:	d9 7d ee             	fnstcw -0x12(%ebp)
    1676:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    167a:	b4 0c                	mov    $0xc,%ah
    167c:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    1680:	d9 6d ec             	fldcw  -0x14(%ebp)
    1683:	df 5d ea             	fistp  -0x16(%ebp)
    1686:	d9 6d ee             	fldcw  -0x12(%ebp)
    1689:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    168d:	89 c2                	mov    %eax,%edx
    168f:	8b 45 08             	mov    0x8(%ebp),%eax
    1692:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    1695:	8b 45 08             	mov    0x8(%ebp),%eax
    1698:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    169c:	0f b6 c0             	movzbl %al,%eax
    169f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16a2:	db 45 e4             	fildl  -0x1c(%ebp)
    16a5:	d9 e8                	fld1   
    16a7:	d8 65 fc             	fsubs  -0x4(%ebp)
    16aa:	de c9                	fmulp  %st,%st(1)
    16ac:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    16b0:	0f b6 c0             	movzbl %al,%eax
    16b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16b6:	db 45 e4             	fildl  -0x1c(%ebp)
    16b9:	d8 4d fc             	fmuls  -0x4(%ebp)
    16bc:	de c1                	faddp  %st,%st(1)
    16be:	d9 6d ec             	fldcw  -0x14(%ebp)
    16c1:	df 5d ea             	fistp  -0x16(%ebp)
    16c4:	d9 6d ee             	fldcw  -0x12(%ebp)
    16c7:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    16cb:	89 c2                	mov    %eax,%edx
    16cd:	8b 45 08             	mov    0x8(%ebp),%eax
    16d0:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    16d3:	8b 45 08             	mov    0x8(%ebp),%eax
    16d6:	0f b6 00             	movzbl (%eax),%eax
    16d9:	0f b6 c0             	movzbl %al,%eax
    16dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16df:	db 45 e4             	fildl  -0x1c(%ebp)
    16e2:	d9 e8                	fld1   
    16e4:	d8 65 fc             	fsubs  -0x4(%ebp)
    16e7:	de c9                	fmulp  %st,%st(1)
    16e9:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    16ed:	0f b6 c0             	movzbl %al,%eax
    16f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    16f3:	db 45 e4             	fildl  -0x1c(%ebp)
    16f6:	d8 4d fc             	fmuls  -0x4(%ebp)
    16f9:	de c1                	faddp  %st,%st(1)
    16fb:	d9 6d ec             	fldcw  -0x14(%ebp)
    16fe:	df 5d ea             	fistp  -0x16(%ebp)
    1701:	d9 6d ee             	fldcw  -0x12(%ebp)
    1704:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1708:	89 c2                	mov    %eax,%edx
    170a:	8b 45 08             	mov    0x8(%ebp),%eax
    170d:	88 10                	mov    %dl,(%eax)
    170f:	eb 01                	jmp    1712 <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    1711:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    1712:	c9                   	leave  
    1713:	c3                   	ret    

00001714 <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    1714:	55                   	push   %ebp
    1715:	89 e5                	mov    %esp,%ebp
    1717:	83 ec 14             	sub    $0x14,%esp
    171a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    171d:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    1720:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    1724:	83 e8 20             	sub    $0x20,%eax
    1727:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    172a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    172e:	0f 88 d7 00 00 00    	js     180b <drawCharacter+0xf7>
    1734:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    1738:	0f 8f cd 00 00 00    	jg     180b <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    173e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1745:	e9 b5 00 00 00       	jmp    17ff <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    174a:	8b 55 10             	mov    0x10(%ebp),%edx
    174d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1750:	01 c2                	add    %eax,%edx
    1752:	8b 45 14             	mov    0x14(%ebp),%eax
    1755:	39 c2                	cmp    %eax,%edx
    1757:	0f 8f af 00 00 00    	jg     180c <drawCharacter+0xf8>
    175d:	8b 55 10             	mov    0x10(%ebp),%edx
    1760:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1763:	01 d0                	add    %edx,%eax
    1765:	85 c0                	test   %eax,%eax
    1767:	0f 88 9f 00 00 00    	js     180c <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    176d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1774:	eb 7b                	jmp    17f1 <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    1776:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1779:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    177c:	89 d0                	mov    %edx,%eax
    177e:	c1 e0 03             	shl    $0x3,%eax
    1781:	01 d0                	add    %edx,%eax
    1783:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    1789:	01 c2                	add    %eax,%edx
    178b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    178e:	01 d0                	add    %edx,%eax
    1790:	05 80 60 01 00       	add    $0x16080,%eax
    1795:	0f b6 00             	movzbl (%eax),%eax
    1798:	3c 01                	cmp    $0x1,%al
    179a:	75 51                	jne    17ed <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    179c:	8b 55 0c             	mov    0xc(%ebp),%edx
    179f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    17a2:	01 c2                	add    %eax,%edx
    17a4:	8b 45 18             	mov    0x18(%ebp),%eax
    17a7:	39 c2                	cmp    %eax,%edx
    17a9:	7f 50                	jg     17fb <drawCharacter+0xe7>
    17ab:	8b 55 0c             	mov    0xc(%ebp),%edx
    17ae:	8b 45 f8             	mov    -0x8(%ebp),%eax
    17b1:	01 d0                	add    %edx,%eax
    17b3:	85 c0                	test   %eax,%eax
    17b5:	78 44                	js     17fb <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    17b7:	8b 55 10             	mov    0x10(%ebp),%edx
    17ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
    17bd:	01 c2                	add    %eax,%edx
    17bf:	8b 45 18             	mov    0x18(%ebp),%eax
    17c2:	0f af c2             	imul   %edx,%eax
    17c5:	89 c2                	mov    %eax,%edx
    17c7:	8b 45 0c             	mov    0xc(%ebp),%eax
    17ca:	01 c2                	add    %eax,%edx
    17cc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    17cf:	01 c2                	add    %eax,%edx
    17d1:	89 d0                	mov    %edx,%eax
    17d3:	01 c0                	add    %eax,%eax
    17d5:	01 c2                	add    %eax,%edx
    17d7:	8b 45 08             	mov    0x8(%ebp),%eax
    17da:	01 d0                	add    %edx,%eax
    17dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    17df:	ff 75 20             	pushl  0x20(%ebp)
    17e2:	ff 75 f0             	pushl  -0x10(%ebp)
    17e5:	e8 0b fe ff ff       	call   15f5 <drawPointAlpha>
    17ea:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    17ed:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    17f1:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    17f5:	0f 8e 7b ff ff ff    	jle    1776 <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    17fb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    17ff:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    1803:	0f 8e 41 ff ff ff    	jle    174a <drawCharacter+0x36>
    1809:	eb 01                	jmp    180c <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    180b:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    180c:	c9                   	leave  
    180d:	c3                   	ret    

0000180e <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    180e:	55                   	push   %ebp
    180f:	89 e5                	mov    %esp,%ebp
    1811:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    1814:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    181b:	eb 3d                	jmp    185a <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    181d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1820:	0f b6 00             	movzbl (%eax),%eax
    1823:	0f be c0             	movsbl %al,%eax
    1826:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1829:	8b 55 fc             	mov    -0x4(%ebp),%edx
    182c:	01 ca                	add    %ecx,%edx
    182e:	89 55 f4             	mov    %edx,-0xc(%ebp)
    1831:	8b 55 10             	mov    0x10(%ebp),%edx
    1834:	89 55 f8             	mov    %edx,-0x8(%ebp)
    1837:	ff 75 20             	pushl  0x20(%ebp)
    183a:	50                   	push   %eax
    183b:	ff 75 18             	pushl  0x18(%ebp)
    183e:	ff 75 14             	pushl  0x14(%ebp)
    1841:	ff 75 f8             	pushl  -0x8(%ebp)
    1844:	ff 75 f4             	pushl  -0xc(%ebp)
    1847:	ff 75 08             	pushl  0x8(%ebp)
    184a:	e8 c5 fe ff ff       	call   1714 <drawCharacter>
    184f:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    1852:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    1856:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    185a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    185d:	0f b6 00             	movzbl (%eax),%eax
    1860:	84 c0                	test   %al,%al
    1862:	75 b9                	jne    181d <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    1864:	90                   	nop
    1865:	c9                   	leave  
    1866:	c3                   	ret    

00001867 <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    1867:	55                   	push   %ebp
    1868:	89 e5                	mov    %esp,%ebp
    186a:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    186d:	8b 45 20             	mov    0x20(%ebp),%eax
    1870:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1873:	8b 45 24             	mov    0x24(%ebp),%eax
    1876:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1879:	8b 55 14             	mov    0x14(%ebp),%edx
    187c:	8b 45 10             	mov    0x10(%ebp),%eax
    187f:	29 c2                	sub    %eax,%edx
    1881:	89 d0                	mov    %edx,%eax
    1883:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1886:	7d 0d                	jge    1895 <drawRect+0x2e>
        draw_h = s.h - p.y;
    1888:	8b 55 14             	mov    0x14(%ebp),%edx
    188b:	8b 45 10             	mov    0x10(%ebp),%eax
    188e:	29 c2                	sub    %eax,%edx
    1890:	89 d0                	mov    %edx,%eax
    1892:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1895:	8b 55 18             	mov    0x18(%ebp),%edx
    1898:	8b 45 0c             	mov    0xc(%ebp),%eax
    189b:	29 c2                	sub    %eax,%edx
    189d:	89 d0                	mov    %edx,%eax
    189f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    18a2:	7d 0d                	jge    18b1 <drawRect+0x4a>
        draw_w = s.w - p.x;
    18a4:	8b 55 18             	mov    0x18(%ebp),%edx
    18a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    18aa:	29 c2                	sub    %eax,%edx
    18ac:	89 d0                	mov    %edx,%eax
    18ae:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    18b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    18b8:	eb 52                	jmp    190c <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    18ba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    18c1:	eb 3d                	jmp    1900 <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    18c3:	8b 55 10             	mov    0x10(%ebp),%edx
    18c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    18c9:	01 c2                	add    %eax,%edx
    18cb:	8b 45 18             	mov    0x18(%ebp),%eax
    18ce:	0f af c2             	imul   %edx,%eax
    18d1:	89 c2                	mov    %eax,%edx
    18d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    18d6:	01 c2                	add    %eax,%edx
    18d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    18db:	01 c2                	add    %eax,%edx
    18dd:	89 d0                	mov    %edx,%eax
    18df:	01 c0                	add    %eax,%eax
    18e1:	01 c2                	add    %eax,%edx
    18e3:	8b 45 08             	mov    0x8(%ebp),%eax
    18e6:	01 d0                	add    %edx,%eax
    18e8:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    18eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    18ee:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    18f2:	66 89 10             	mov    %dx,(%eax)
    18f5:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    18f9:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    18fc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1900:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1903:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1906:	7c bb                	jl     18c3 <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1908:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    190c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    190f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1912:	7c a6                	jl     18ba <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    1914:	90                   	nop
    1915:	c9                   	leave  
    1916:	c3                   	ret    

00001917 <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    1917:	55                   	push   %ebp
    1918:	89 e5                	mov    %esp,%ebp
    191a:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    191d:	8b 45 28             	mov    0x28(%ebp),%eax
    1920:	89 45 c8             	mov    %eax,-0x38(%ebp)
    1923:	8b 45 24             	mov    0x24(%ebp),%eax
    1926:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1929:	ff 75 cc             	pushl  -0x34(%ebp)
    192c:	ff 75 c8             	pushl  -0x38(%ebp)
    192f:	83 ec 04             	sub    $0x4,%esp
    1932:	89 e0                	mov    %esp,%eax
    1934:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1938:	66 89 10             	mov    %dx,(%eax)
    193b:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    193f:	88 50 02             	mov    %dl,0x2(%eax)
    1942:	ff 75 18             	pushl  0x18(%ebp)
    1945:	ff 75 14             	pushl  0x14(%ebp)
    1948:	ff 75 10             	pushl  0x10(%ebp)
    194b:	ff 75 0c             	pushl  0xc(%ebp)
    194e:	ff 75 08             	pushl  0x8(%ebp)
    1951:	e8 11 ff ff ff       	call   1867 <drawRect>
    1956:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    1959:	8b 45 28             	mov    0x28(%ebp),%eax
    195c:	89 45 d0             	mov    %eax,-0x30(%ebp)
    195f:	8b 45 24             	mov    0x24(%ebp),%eax
    1962:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1965:	8b 45 0c             	mov    0xc(%ebp),%eax
    1968:	89 45 d8             	mov    %eax,-0x28(%ebp)
    196b:	8b 55 10             	mov    0x10(%ebp),%edx
    196e:	8b 45 20             	mov    0x20(%ebp),%eax
    1971:	01 d0                	add    %edx,%eax
    1973:	2b 45 28             	sub    0x28(%ebp),%eax
    1976:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1979:	ff 75 d4             	pushl  -0x2c(%ebp)
    197c:	ff 75 d0             	pushl  -0x30(%ebp)
    197f:	83 ec 04             	sub    $0x4,%esp
    1982:	89 e0                	mov    %esp,%eax
    1984:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1988:	66 89 10             	mov    %dx,(%eax)
    198b:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    198f:	88 50 02             	mov    %dl,0x2(%eax)
    1992:	ff 75 18             	pushl  0x18(%ebp)
    1995:	ff 75 14             	pushl  0x14(%ebp)
    1998:	ff 75 dc             	pushl  -0x24(%ebp)
    199b:	ff 75 d8             	pushl  -0x28(%ebp)
    199e:	ff 75 08             	pushl  0x8(%ebp)
    19a1:	e8 c1 fe ff ff       	call   1867 <drawRect>
    19a6:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    19a9:	8b 45 20             	mov    0x20(%ebp),%eax
    19ac:	8b 55 28             	mov    0x28(%ebp),%edx
    19af:	01 d2                	add    %edx,%edx
    19b1:	29 d0                	sub    %edx,%eax
    19b3:	89 45 e0             	mov    %eax,-0x20(%ebp)
    19b6:	8b 45 28             	mov    0x28(%ebp),%eax
    19b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    19bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    19bf:	89 45 e8             	mov    %eax,-0x18(%ebp)
    19c2:	8b 55 10             	mov    0x10(%ebp),%edx
    19c5:	8b 45 28             	mov    0x28(%ebp),%eax
    19c8:	01 d0                	add    %edx,%eax
    19ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
    19cd:	ff 75 e4             	pushl  -0x1c(%ebp)
    19d0:	ff 75 e0             	pushl  -0x20(%ebp)
    19d3:	83 ec 04             	sub    $0x4,%esp
    19d6:	89 e0                	mov    %esp,%eax
    19d8:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    19dc:	66 89 10             	mov    %dx,(%eax)
    19df:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    19e3:	88 50 02             	mov    %dl,0x2(%eax)
    19e6:	ff 75 18             	pushl  0x18(%ebp)
    19e9:	ff 75 14             	pushl  0x14(%ebp)
    19ec:	ff 75 ec             	pushl  -0x14(%ebp)
    19ef:	ff 75 e8             	pushl  -0x18(%ebp)
    19f2:	ff 75 08             	pushl  0x8(%ebp)
    19f5:	e8 6d fe ff ff       	call   1867 <drawRect>
    19fa:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    19fd:	8b 45 20             	mov    0x20(%ebp),%eax
    1a00:	8b 55 28             	mov    0x28(%ebp),%edx
    1a03:	01 d2                	add    %edx,%edx
    1a05:	29 d0                	sub    %edx,%eax
    1a07:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1a0a:	8b 45 28             	mov    0x28(%ebp),%eax
    1a0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1a10:	8b 55 0c             	mov    0xc(%ebp),%edx
    1a13:	8b 45 24             	mov    0x24(%ebp),%eax
    1a16:	01 d0                	add    %edx,%eax
    1a18:	2b 45 28             	sub    0x28(%ebp),%eax
    1a1b:	89 45 f8             	mov    %eax,-0x8(%ebp)
    1a1e:	8b 55 10             	mov    0x10(%ebp),%edx
    1a21:	8b 45 28             	mov    0x28(%ebp),%eax
    1a24:	01 d0                	add    %edx,%eax
    1a26:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1a29:	ff 75 f4             	pushl  -0xc(%ebp)
    1a2c:	ff 75 f0             	pushl  -0x10(%ebp)
    1a2f:	83 ec 04             	sub    $0x4,%esp
    1a32:	89 e0                	mov    %esp,%eax
    1a34:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1a38:	66 89 10             	mov    %dx,(%eax)
    1a3b:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1a3f:	88 50 02             	mov    %dl,0x2(%eax)
    1a42:	ff 75 18             	pushl  0x18(%ebp)
    1a45:	ff 75 14             	pushl  0x14(%ebp)
    1a48:	ff 75 fc             	pushl  -0x4(%ebp)
    1a4b:	ff 75 f8             	pushl  -0x8(%ebp)
    1a4e:	ff 75 08             	pushl  0x8(%ebp)
    1a51:	e8 11 fe ff ff       	call   1867 <drawRect>
    1a56:	83 c4 20             	add    $0x20,%esp
}
    1a59:	90                   	nop
    1a5a:	c9                   	leave  
    1a5b:	c3                   	ret    

00001a5c <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1a5c:	55                   	push   %ebp
    1a5d:	89 e5                	mov    %esp,%ebp
    1a5f:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1a62:	8b 45 30             	mov    0x30(%ebp),%eax
    1a65:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    1a68:	8b 45 34             	mov    0x34(%ebp),%eax
    1a6b:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    1a6e:	8b 55 20             	mov    0x20(%ebp),%edx
    1a71:	8b 45 14             	mov    0x14(%ebp),%eax
    1a74:	29 c2                	sub    %eax,%edx
    1a76:	89 d0                	mov    %edx,%eax
    1a78:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1a7b:	7d 0d                	jge    1a8a <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    1a7d:	8b 55 20             	mov    0x20(%ebp),%edx
    1a80:	8b 45 14             	mov    0x14(%ebp),%eax
    1a83:	29 c2                	sub    %eax,%edx
    1a85:	89 d0                	mov    %edx,%eax
    1a87:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1a8a:	8b 55 28             	mov    0x28(%ebp),%edx
    1a8d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1a90:	29 c2                	sub    %eax,%edx
    1a92:	89 d0                	mov    %edx,%eax
    1a94:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1a97:	7d 0d                	jge    1aa6 <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1a99:	8b 55 28             	mov    0x28(%ebp),%edx
    1a9c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1a9f:	29 c2                	sub    %eax,%edx
    1aa1:	89 d0                	mov    %edx,%eax
    1aa3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1aa6:	8b 55 24             	mov    0x24(%ebp),%edx
    1aa9:	8b 45 10             	mov    0x10(%ebp),%eax
    1aac:	29 c2                	sub    %eax,%edx
    1aae:	89 d0                	mov    %edx,%eax
    1ab0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1ab3:	7d 0d                	jge    1ac2 <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    1ab5:	8b 55 24             	mov    0x24(%ebp),%edx
    1ab8:	8b 45 10             	mov    0x10(%ebp),%eax
    1abb:	29 c2                	sub    %eax,%edx
    1abd:	89 d0                	mov    %edx,%eax
    1abf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1ac2:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1ac5:	8b 45 18             	mov    0x18(%ebp),%eax
    1ac8:	29 c2                	sub    %eax,%edx
    1aca:	89 d0                	mov    %edx,%eax
    1acc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1acf:	7d 0d                	jge    1ade <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    1ad1:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1ad4:	8b 45 18             	mov    0x18(%ebp),%eax
    1ad7:	29 c2                	sub    %eax,%edx
    1ad9:	89 d0                	mov    %edx,%eax
    1adb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1ade:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    1ae5:	e9 83 00 00 00       	jmp    1b6d <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    1aea:	8b 55 14             	mov    0x14(%ebp),%edx
    1aed:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1af0:	01 d0                	add    %edx,%eax
    1af2:	85 c0                	test   %eax,%eax
    1af4:	78 72                	js     1b68 <drawBitmap+0x10c>
    1af6:	8b 55 14             	mov    0x14(%ebp),%edx
    1af9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1afc:	01 c2                	add    %eax,%edx
    1afe:	8b 45 20             	mov    0x20(%ebp),%eax
    1b01:	39 c2                	cmp    %eax,%edx
    1b03:	7d 63                	jge    1b68 <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    1b05:	8b 55 14             	mov    0x14(%ebp),%edx
    1b08:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b0b:	01 c2                	add    %eax,%edx
    1b0d:	8b 45 24             	mov    0x24(%ebp),%eax
    1b10:	0f af c2             	imul   %edx,%eax
    1b13:	89 c2                	mov    %eax,%edx
    1b15:	8b 45 10             	mov    0x10(%ebp),%eax
    1b18:	01 c2                	add    %eax,%edx
    1b1a:	89 d0                	mov    %edx,%eax
    1b1c:	01 c0                	add    %eax,%eax
    1b1e:	01 c2                	add    %eax,%edx
    1b20:	8b 45 08             	mov    0x8(%ebp),%eax
    1b23:	01 d0                	add    %edx,%eax
    1b25:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    1b28:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1b2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b2e:	01 c2                	add    %eax,%edx
    1b30:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1b33:	0f af c2             	imul   %edx,%eax
    1b36:	89 c2                	mov    %eax,%edx
    1b38:	8b 45 18             	mov    0x18(%ebp),%eax
    1b3b:	01 c2                	add    %eax,%edx
    1b3d:	89 d0                	mov    %edx,%eax
    1b3f:	01 c0                	add    %eax,%eax
    1b41:	01 c2                	add    %eax,%edx
    1b43:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b46:	01 d0                	add    %edx,%eax
    1b48:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    1b4b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1b4e:	89 d0                	mov    %edx,%eax
    1b50:	01 c0                	add    %eax,%eax
    1b52:	01 d0                	add    %edx,%eax
    1b54:	83 ec 04             	sub    $0x4,%esp
    1b57:	50                   	push   %eax
    1b58:	ff 75 e4             	pushl  -0x1c(%ebp)
    1b5b:	ff 75 e8             	pushl  -0x18(%ebp)
    1b5e:	e8 23 e7 ff ff       	call   286 <memmove>
    1b63:	83 c4 10             	add    $0x10,%esp
    1b66:	eb 01                	jmp    1b69 <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    1b68:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1b69:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    1b6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1b70:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1b73:	0f 8c 71 ff ff ff    	jl     1aea <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    1b79:	90                   	nop
    1b7a:	c9                   	leave  
    1b7b:	c3                   	ret    

00001b7c <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1b7c:	55                   	push   %ebp
    1b7d:	89 e5                	mov    %esp,%ebp
    1b7f:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1b82:	8b 45 30             	mov    0x30(%ebp),%eax
    1b85:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    1b88:	8b 45 34             	mov    0x34(%ebp),%eax
    1b8b:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    1b8e:	8b 55 20             	mov    0x20(%ebp),%edx
    1b91:	8b 45 14             	mov    0x14(%ebp),%eax
    1b94:	29 c2                	sub    %eax,%edx
    1b96:	89 d0                	mov    %edx,%eax
    1b98:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1b9b:	7d 0d                	jge    1baa <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    1b9d:	8b 55 20             	mov    0x20(%ebp),%edx
    1ba0:	8b 45 14             	mov    0x14(%ebp),%eax
    1ba3:	29 c2                	sub    %eax,%edx
    1ba5:	89 d0                	mov    %edx,%eax
    1ba7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1baa:	8b 55 28             	mov    0x28(%ebp),%edx
    1bad:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1bb0:	29 c2                	sub    %eax,%edx
    1bb2:	89 d0                	mov    %edx,%eax
    1bb4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1bb7:	7d 0d                	jge    1bc6 <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1bb9:	8b 55 28             	mov    0x28(%ebp),%edx
    1bbc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1bbf:	29 c2                	sub    %eax,%edx
    1bc1:	89 d0                	mov    %edx,%eax
    1bc3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1bc6:	8b 55 24             	mov    0x24(%ebp),%edx
    1bc9:	8b 45 10             	mov    0x10(%ebp),%eax
    1bcc:	29 c2                	sub    %eax,%edx
    1bce:	89 d0                	mov    %edx,%eax
    1bd0:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1bd3:	7d 0d                	jge    1be2 <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    1bd5:	8b 55 24             	mov    0x24(%ebp),%edx
    1bd8:	8b 45 10             	mov    0x10(%ebp),%eax
    1bdb:	29 c2                	sub    %eax,%edx
    1bdd:	89 d0                	mov    %edx,%eax
    1bdf:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1be2:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1be5:	8b 45 18             	mov    0x18(%ebp),%eax
    1be8:	29 c2                	sub    %eax,%edx
    1bea:	89 d0                	mov    %edx,%eax
    1bec:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1bef:	7d 0d                	jge    1bfe <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    1bf1:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1bf4:	8b 45 18             	mov    0x18(%ebp),%eax
    1bf7:	29 c2                	sub    %eax,%edx
    1bf9:	89 d0                	mov    %edx,%eax
    1bfb:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    1bfe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1c05:	e9 b8 00 00 00       	jmp    1cc2 <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    1c0a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1c11:	e9 9c 00 00 00       	jmp    1cb2 <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    1c16:	8b 55 14             	mov    0x14(%ebp),%edx
    1c19:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1c1c:	01 c2                	add    %eax,%edx
    1c1e:	8b 45 24             	mov    0x24(%ebp),%eax
    1c21:	0f af c2             	imul   %edx,%eax
    1c24:	89 c2                	mov    %eax,%edx
    1c26:	8b 45 10             	mov    0x10(%ebp),%eax
    1c29:	01 c2                	add    %eax,%edx
    1c2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1c2e:	01 c2                	add    %eax,%edx
    1c30:	89 d0                	mov    %edx,%eax
    1c32:	01 c0                	add    %eax,%eax
    1c34:	01 c2                	add    %eax,%edx
    1c36:	8b 45 08             	mov    0x8(%ebp),%eax
    1c39:	01 d0                	add    %edx,%eax
    1c3b:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    1c3e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1c41:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1c44:	01 c2                	add    %eax,%edx
    1c46:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1c49:	0f af c2             	imul   %edx,%eax
    1c4c:	89 c2                	mov    %eax,%edx
    1c4e:	8b 45 18             	mov    0x18(%ebp),%eax
    1c51:	01 c2                	add    %eax,%edx
    1c53:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1c56:	01 c2                	add    %eax,%edx
    1c58:	89 d0                	mov    %edx,%eax
    1c5a:	01 c0                	add    %eax,%eax
    1c5c:	01 c2                	add    %eax,%edx
    1c5e:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c61:	01 d0                	add    %edx,%eax
    1c63:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    1c66:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c69:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1c6d:	3c ff                	cmp    $0xff,%al
    1c6f:	75 15                	jne    1c86 <drawTransparentBitmap+0x10a>
    1c71:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c74:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1c78:	3c ff                	cmp    $0xff,%al
    1c7a:	75 0a                	jne    1c86 <drawTransparentBitmap+0x10a>
    1c7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c7f:	0f b6 00             	movzbl (%eax),%eax
    1c82:	3c ff                	cmp    $0xff,%al
    1c84:	74 27                	je     1cad <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    1c86:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c89:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    1c8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c90:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    1c93:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1c96:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    1c9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c9d:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    1ca0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1ca3:	0f b6 10             	movzbl (%eax),%edx
    1ca6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ca9:	88 10                	mov    %dl,(%eax)
    1cab:	eb 01                	jmp    1cae <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    1cad:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    1cae:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1cb2:	8b 45 34             	mov    0x34(%ebp),%eax
    1cb5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1cb8:	0f 8f 58 ff ff ff    	jg     1c16 <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    1cbe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1cc2:	8b 45 30             	mov    0x30(%ebp),%eax
    1cc5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1cc8:	0f 8f 3c ff ff ff    	jg     1c0a <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    1cce:	90                   	nop
    1ccf:	c9                   	leave  
    1cd0:	c3                   	ret    

00001cd1 <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    1cd1:	55                   	push   %ebp
    1cd2:	89 e5                	mov    %esp,%ebp
    1cd4:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    1cd7:	ff 75 24             	pushl  0x24(%ebp)
    1cda:	ff 75 20             	pushl  0x20(%ebp)
    1cdd:	ff 75 1c             	pushl  0x1c(%ebp)
    1ce0:	ff 75 18             	pushl  0x18(%ebp)
    1ce3:	ff 75 1c             	pushl  0x1c(%ebp)
    1ce6:	ff 75 18             	pushl  0x18(%ebp)
    1ce9:	ff 75 14             	pushl  0x14(%ebp)
    1cec:	ff 75 10             	pushl  0x10(%ebp)
    1cef:	ff 75 14             	pushl  0x14(%ebp)
    1cf2:	ff 75 10             	pushl  0x10(%ebp)
    1cf5:	ff 75 0c             	pushl  0xc(%ebp)
    1cf8:	ff 75 08             	pushl  0x8(%ebp)
    1cfb:	e8 5c fd ff ff       	call   1a5c <drawBitmap>
    1d00:	83 c4 30             	add    $0x30,%esp
}
    1d03:	90                   	nop
    1d04:	c9                   	leave  
    1d05:	c3                   	ret    

00001d06 <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    1d06:	55                   	push   %ebp
    1d07:	89 e5                	mov    %esp,%ebp
    1d09:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1d0c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1d0f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1d12:	8b 45 20             	mov    0x20(%ebp),%eax
    1d15:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1d18:	8b 55 14             	mov    0x14(%ebp),%edx
    1d1b:	8b 45 10             	mov    0x10(%ebp),%eax
    1d1e:	29 c2                	sub    %eax,%edx
    1d20:	89 d0                	mov    %edx,%eax
    1d22:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1d25:	7d 0d                	jge    1d34 <colorShift+0x2e>
        draw_h = s.h - p.y;
    1d27:	8b 55 14             	mov    0x14(%ebp),%edx
    1d2a:	8b 45 10             	mov    0x10(%ebp),%eax
    1d2d:	29 c2                	sub    %eax,%edx
    1d2f:	89 d0                	mov    %edx,%eax
    1d31:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1d34:	8b 55 18             	mov    0x18(%ebp),%edx
    1d37:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d3a:	29 c2                	sub    %eax,%edx
    1d3c:	89 d0                	mov    %edx,%eax
    1d3e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1d41:	7d 0d                	jge    1d50 <colorShift+0x4a>
        draw_w = s.w - p.x;
    1d43:	8b 55 18             	mov    0x18(%ebp),%edx
    1d46:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d49:	29 c2                	sub    %eax,%edx
    1d4b:	89 d0                	mov    %edx,%eax
    1d4d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1d50:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1d57:	e9 fc 00 00 00       	jmp    1e58 <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    1d5c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1d63:	e9 e0 00 00 00       	jmp    1e48 <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    1d68:	8b 55 10             	mov    0x10(%ebp),%edx
    1d6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1d6e:	01 c2                	add    %eax,%edx
    1d70:	8b 45 18             	mov    0x18(%ebp),%eax
    1d73:	0f af c2             	imul   %edx,%eax
    1d76:	89 c2                	mov    %eax,%edx
    1d78:	8b 45 0c             	mov    0xc(%ebp),%eax
    1d7b:	01 c2                	add    %eax,%edx
    1d7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1d80:	01 c2                	add    %eax,%edx
    1d82:	89 d0                	mov    %edx,%eax
    1d84:	01 c0                	add    %eax,%eax
    1d86:	01 c2                	add    %eax,%edx
    1d88:	8b 45 08             	mov    0x8(%ebp),%eax
    1d8b:	01 d0                	add    %edx,%eax
    1d8d:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    1d90:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1d93:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1d97:	3c c8                	cmp    $0xc8,%al
    1d99:	0f 86 a5 00 00 00    	jbe    1e44 <colorShift+0x13e>
    1d9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1da2:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1da6:	3c c8                	cmp    $0xc8,%al
    1da8:	0f 86 96 00 00 00    	jbe    1e44 <colorShift+0x13e>
    1dae:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1db1:	0f b6 00             	movzbl (%eax),%eax
    1db4:	3c c8                	cmp    $0xc8,%al
    1db6:	0f 86 88 00 00 00    	jbe    1e44 <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    1dbc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1dbf:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1dc3:	0f b6 d0             	movzbl %al,%edx
    1dc6:	8b 45 24             	mov    0x24(%ebp),%eax
    1dc9:	01 d0                	add    %edx,%eax
    1dcb:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1dd1:	89 d0                	mov    %edx,%eax
    1dd3:	c1 f8 1f             	sar    $0x1f,%eax
    1dd6:	c1 e8 18             	shr    $0x18,%eax
    1dd9:	01 c2                	add    %eax,%edx
    1ddb:	0f b6 d2             	movzbl %dl,%edx
    1dde:	29 c2                	sub    %eax,%edx
    1de0:	89 d0                	mov    %edx,%eax
    1de2:	89 c2                	mov    %eax,%edx
    1de4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1de7:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    1dea:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1ded:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1df1:	0f b6 d0             	movzbl %al,%edx
    1df4:	8b 45 24             	mov    0x24(%ebp),%eax
    1df7:	01 d0                	add    %edx,%eax
    1df9:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1dff:	89 d0                	mov    %edx,%eax
    1e01:	c1 f8 1f             	sar    $0x1f,%eax
    1e04:	c1 e8 18             	shr    $0x18,%eax
    1e07:	01 c2                	add    %eax,%edx
    1e09:	0f b6 d2             	movzbl %dl,%edx
    1e0c:	29 c2                	sub    %eax,%edx
    1e0e:	89 d0                	mov    %edx,%eax
    1e10:	89 c2                	mov    %eax,%edx
    1e12:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e15:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    1e18:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e1b:	0f b6 00             	movzbl (%eax),%eax
    1e1e:	0f b6 d0             	movzbl %al,%edx
    1e21:	8b 45 24             	mov    0x24(%ebp),%eax
    1e24:	01 d0                	add    %edx,%eax
    1e26:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1e2c:	89 d0                	mov    %edx,%eax
    1e2e:	c1 f8 1f             	sar    $0x1f,%eax
    1e31:	c1 e8 18             	shr    $0x18,%eax
    1e34:	01 c2                	add    %eax,%edx
    1e36:	0f b6 d2             	movzbl %dl,%edx
    1e39:	29 c2                	sub    %eax,%edx
    1e3b:	89 d0                	mov    %edx,%eax
    1e3d:	89 c2                	mov    %eax,%edx
    1e3f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e42:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1e44:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1e48:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1e4b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1e4e:	0f 8c 14 ff ff ff    	jl     1d68 <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1e54:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1e58:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1e5b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1e5e:	0f 8c f8 fe ff ff    	jl     1d5c <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    1e64:	90                   	nop
    1e65:	c9                   	leave  
    1e66:	c3                   	ret    

00001e67 <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    1e67:	55                   	push   %ebp
    1e68:	89 e5                	mov    %esp,%ebp
    1e6a:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1e6d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1e74:	e9 fb 00 00 00       	jmp    1f74 <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    1e79:	8b 55 14             	mov    0x14(%ebp),%edx
    1e7c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1e7f:	01 c2                	add    %eax,%edx
    1e81:	0f b7 05 36 e5 01 00 	movzwl 0x1e536,%eax
    1e88:	0f b7 c0             	movzwl %ax,%eax
    1e8b:	39 c2                	cmp    %eax,%edx
    1e8d:	0f 8f eb 00 00 00    	jg     1f7e <drawMouse+0x117>
    1e93:	8b 55 14             	mov    0x14(%ebp),%edx
    1e96:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1e99:	01 d0                	add    %edx,%eax
    1e9b:	85 c0                	test   %eax,%eax
    1e9d:	0f 88 db 00 00 00    	js     1f7e <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1ea3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1eaa:	e9 b7 00 00 00       	jmp    1f66 <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    1eaf:	8b 55 10             	mov    0x10(%ebp),%edx
    1eb2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1eb5:	01 c2                	add    %eax,%edx
    1eb7:	0f b7 05 34 e5 01 00 	movzwl 0x1e534,%eax
    1ebe:	0f b7 c0             	movzwl %ax,%eax
    1ec1:	39 c2                	cmp    %eax,%edx
    1ec3:	0f 8f a7 00 00 00    	jg     1f70 <drawMouse+0x109>
    1ec9:	8b 55 10             	mov    0x10(%ebp),%edx
    1ecc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1ecf:	01 d0                	add    %edx,%eax
    1ed1:	85 c0                	test   %eax,%eax
    1ed3:	0f 88 97 00 00 00    	js     1f70 <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    1ed9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1edc:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1edf:	89 d0                	mov    %edx,%eax
    1ee1:	c1 e0 04             	shl    $0x4,%eax
    1ee4:	29 d0                	sub    %edx,%eax
    1ee6:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    1eec:	01 c2                	add    %eax,%edx
    1eee:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1ef1:	01 d0                	add    %edx,%eax
    1ef3:	05 60 5e 01 00       	add    $0x15e60,%eax
    1ef8:	0f b6 00             	movzbl (%eax),%eax
    1efb:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    1efe:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    1f02:	74 5e                	je     1f62 <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    1f04:	8b 55 14             	mov    0x14(%ebp),%edx
    1f07:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1f0a:	01 c2                	add    %eax,%edx
    1f0c:	0f b7 05 34 e5 01 00 	movzwl 0x1e534,%eax
    1f13:	0f b7 c0             	movzwl %ax,%eax
    1f16:	0f af c2             	imul   %edx,%eax
    1f19:	89 c2                	mov    %eax,%edx
    1f1b:	8b 45 10             	mov    0x10(%ebp),%eax
    1f1e:	01 c2                	add    %eax,%edx
    1f20:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1f23:	01 c2                	add    %eax,%edx
    1f25:	89 d0                	mov    %edx,%eax
    1f27:	01 c0                	add    %eax,%eax
    1f29:	01 c2                	add    %eax,%edx
    1f2b:	8b 45 08             	mov    0x8(%ebp),%eax
    1f2e:	01 d0                	add    %edx,%eax
    1f30:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    1f33:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    1f37:	8d 50 ff             	lea    -0x1(%eax),%edx
    1f3a:	89 d0                	mov    %edx,%eax
    1f3c:	01 c0                	add    %eax,%eax
    1f3e:	01 d0                	add    %edx,%eax
    1f40:	05 3c e5 01 00       	add    $0x1e53c,%eax
    1f45:	83 ec 04             	sub    $0x4,%esp
    1f48:	89 e2                	mov    %esp,%edx
    1f4a:	0f b7 08             	movzwl (%eax),%ecx
    1f4d:	66 89 0a             	mov    %cx,(%edx)
    1f50:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1f54:	88 42 02             	mov    %al,0x2(%edx)
    1f57:	ff 75 f0             	pushl  -0x10(%ebp)
    1f5a:	e8 73 f6 ff ff       	call   15d2 <drawPoint>
    1f5f:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1f62:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    1f66:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    1f6a:	0f 8e 3f ff ff ff    	jle    1eaf <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1f70:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    1f74:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    1f78:	0f 8e fb fe ff ff    	jle    1e79 <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    1f7e:	90                   	nop
    1f7f:	c9                   	leave  
    1f80:	c3                   	ret    

00001f81 <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    1f81:	55                   	push   %ebp
    1f82:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    1f84:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    1f88:	78 1b                	js     1fa5 <getColor+0x24>
    1f8a:	8b 45 08             	mov    0x8(%ebp),%eax
    1f8d:	8b 40 04             	mov    0x4(%eax),%eax
    1f90:	3b 45 0c             	cmp    0xc(%ebp),%eax
    1f93:	7c 10                	jl     1fa5 <getColor+0x24>
    1f95:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    1f99:	78 0a                	js     1fa5 <getColor+0x24>
    1f9b:	8b 45 08             	mov    0x8(%ebp),%eax
    1f9e:	8b 00                	mov    (%eax),%eax
    1fa0:	3b 45 10             	cmp    0x10(%ebp),%eax
    1fa3:	7d 10                	jge    1fb5 <getColor+0x34>
    {
        *isInPic = 1;
    1fa5:	8b 45 14             	mov    0x14(%ebp),%eax
    1fa8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    1fae:	b8 f1 e0 01 00       	mov    $0x1e0f1,%eax
    1fb3:	eb 44                	jmp    1ff9 <getColor+0x78>
    }

    if (y == pic->height)
    1fb5:	8b 45 08             	mov    0x8(%ebp),%eax
    1fb8:	8b 40 04             	mov    0x4(%eax),%eax
    1fbb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    1fbe:	75 04                	jne    1fc4 <getColor+0x43>
        y--;
    1fc0:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    1fc4:	8b 45 08             	mov    0x8(%ebp),%eax
    1fc7:	8b 00                	mov    (%eax),%eax
    1fc9:	3b 45 10             	cmp    0x10(%ebp),%eax
    1fcc:	75 04                	jne    1fd2 <getColor+0x51>
        x--;
    1fce:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    1fd2:	8b 45 14             	mov    0x14(%ebp),%eax
    1fd5:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    1fdb:	8b 45 08             	mov    0x8(%ebp),%eax
    1fde:	8b 48 08             	mov    0x8(%eax),%ecx
    1fe1:	8b 45 08             	mov    0x8(%ebp),%eax
    1fe4:	8b 00                	mov    (%eax),%eax
    1fe6:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1fea:	89 c2                	mov    %eax,%edx
    1fec:	8b 45 10             	mov    0x10(%ebp),%eax
    1fef:	01 c2                	add    %eax,%edx
    1ff1:	89 d0                	mov    %edx,%eax
    1ff3:	01 c0                	add    %eax,%eax
    1ff5:	01 d0                	add    %edx,%eax
    1ff7:	01 c8                	add    %ecx,%eax
}
    1ff9:	5d                   	pop    %ebp
    1ffa:	c3                   	ret    

00001ffb <setColor>:

int setColor(RGB *src, RGB *dst)
{
    1ffb:	55                   	push   %ebp
    1ffc:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    1ffe:	8b 45 08             	mov    0x8(%ebp),%eax
    2001:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    2005:	8b 45 0c             	mov    0xc(%ebp),%eax
    2008:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    200b:	8b 45 08             	mov    0x8(%ebp),%eax
    200e:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    2012:	8b 45 0c             	mov    0xc(%ebp),%eax
    2015:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    2018:	8b 45 08             	mov    0x8(%ebp),%eax
    201b:	0f b6 10             	movzbl (%eax),%edx
    201e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2021:	88 10                	mov    %dl,(%eax)

    return 1;
    2023:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2028:	5d                   	pop    %ebp
    2029:	c3                   	ret    

0000202a <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    202a:	55                   	push   %ebp
    202b:	89 e5                	mov    %esp,%ebp
    202d:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    2030:	d9 45 10             	flds   0x10(%ebp)
    2033:	d9 7d be             	fnstcw -0x42(%ebp)
    2036:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    203a:	b4 0c                	mov    $0xc,%ah
    203c:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    2040:	d9 6d bc             	fldcw  -0x44(%ebp)
    2043:	db 5d fc             	fistpl -0x4(%ebp)
    2046:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    2049:	d9 45 0c             	flds   0xc(%ebp)
    204c:	d9 6d bc             	fldcw  -0x44(%ebp)
    204f:	db 5d f8             	fistpl -0x8(%ebp)
    2052:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    2055:	db 45 fc             	fildl  -0x4(%ebp)
    2058:	d9 45 10             	flds   0x10(%ebp)
    205b:	d9 c9                	fxch   %st(1)
    205d:	df e9                	fucomip %st(1),%st
    205f:	dd d8                	fstp   %st(0)
    2061:	76 04                	jbe    2067 <mixColor+0x3d>
        x--;
    2063:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    2067:	db 45 f8             	fildl  -0x8(%ebp)
    206a:	d9 45 0c             	flds   0xc(%ebp)
    206d:	d9 c9                	fxch   %st(1)
    206f:	df e9                	fucomip %st(1),%st
    2071:	dd d8                	fstp   %st(0)
    2073:	76 04                	jbe    2079 <mixColor+0x4f>
        y--;
    2075:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2079:	8d 45 c0             	lea    -0x40(%ebp),%eax
    207c:	50                   	push   %eax
    207d:	ff 75 fc             	pushl  -0x4(%ebp)
    2080:	ff 75 f8             	pushl  -0x8(%ebp)
    2083:	ff 75 08             	pushl  0x8(%ebp)
    2086:	e8 f6 fe ff ff       	call   1f81 <getColor>
    208b:	83 c4 10             	add    $0x10,%esp
    208e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    2091:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2094:	83 c0 01             	add    $0x1,%eax
    2097:	8d 55 c0             	lea    -0x40(%ebp),%edx
    209a:	83 c2 04             	add    $0x4,%edx
    209d:	52                   	push   %edx
    209e:	ff 75 fc             	pushl  -0x4(%ebp)
    20a1:	50                   	push   %eax
    20a2:	ff 75 08             	pushl  0x8(%ebp)
    20a5:	e8 d7 fe ff ff       	call   1f81 <getColor>
    20aa:	83 c4 10             	add    $0x10,%esp
    20ad:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    20b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    20b3:	83 c0 01             	add    $0x1,%eax
    20b6:	8d 55 c0             	lea    -0x40(%ebp),%edx
    20b9:	83 c2 08             	add    $0x8,%edx
    20bc:	52                   	push   %edx
    20bd:	50                   	push   %eax
    20be:	ff 75 f8             	pushl  -0x8(%ebp)
    20c1:	ff 75 08             	pushl  0x8(%ebp)
    20c4:	e8 b8 fe ff ff       	call   1f81 <getColor>
    20c9:	83 c4 10             	add    $0x10,%esp
    20cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    20cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    20d2:	8d 50 01             	lea    0x1(%eax),%edx
    20d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    20d8:	83 c0 01             	add    $0x1,%eax
    20db:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    20de:	83 c1 0c             	add    $0xc,%ecx
    20e1:	51                   	push   %ecx
    20e2:	52                   	push   %edx
    20e3:	50                   	push   %eax
    20e4:	ff 75 08             	pushl  0x8(%ebp)
    20e7:	e8 95 fe ff ff       	call   1f81 <getColor>
    20ec:	83 c4 10             	add    $0x10,%esp
    20ef:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    20f2:	db 45 fc             	fildl  -0x4(%ebp)
    20f5:	d9 45 10             	flds   0x10(%ebp)
    20f8:	de e1                	fsubp  %st,%st(1)
    20fa:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    20fd:	db 45 f8             	fildl  -0x8(%ebp)
    2100:	d9 45 0c             	flds   0xc(%ebp)
    2103:	de e1                	fsubp  %st,%st(1)
    2105:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    2108:	d9 45 e4             	flds   -0x1c(%ebp)
    210b:	d8 4d e0             	fmuls  -0x20(%ebp)
    210e:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    2111:	d9 e8                	fld1   
    2113:	d8 65 e0             	fsubs  -0x20(%ebp)
    2116:	d8 4d e4             	fmuls  -0x1c(%ebp)
    2119:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    211c:	d9 e8                	fld1   
    211e:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2121:	d8 4d e0             	fmuls  -0x20(%ebp)
    2124:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    2127:	d9 e8                	fld1   
    2129:	d8 65 e4             	fsubs  -0x1c(%ebp)
    212c:	d9 e8                	fld1   
    212e:	d8 65 e0             	fsubs  -0x20(%ebp)
    2131:	de c9                	fmulp  %st,%st(1)
    2133:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    2136:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2139:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    213d:	0f b6 c0             	movzbl %al,%eax
    2140:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2143:	db 45 b4             	fildl  -0x4c(%ebp)
    2146:	d8 4d d0             	fmuls  -0x30(%ebp)
    2149:	8b 45 c0             	mov    -0x40(%ebp),%eax
    214c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    214f:	db 45 b4             	fildl  -0x4c(%ebp)
    2152:	de c9                	fmulp  %st,%st(1)
    2154:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2157:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    215b:	0f b6 c0             	movzbl %al,%eax
    215e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2161:	db 45 b4             	fildl  -0x4c(%ebp)
    2164:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2167:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    216a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    216d:	db 45 b4             	fildl  -0x4c(%ebp)
    2170:	de c9                	fmulp  %st,%st(1)
    2172:	de c1                	faddp  %st,%st(1)
    2174:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2177:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    217b:	0f b6 c0             	movzbl %al,%eax
    217e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2181:	db 45 b4             	fildl  -0x4c(%ebp)
    2184:	d8 4d d8             	fmuls  -0x28(%ebp)
    2187:	8b 45 c8             	mov    -0x38(%ebp),%eax
    218a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    218d:	db 45 b4             	fildl  -0x4c(%ebp)
    2190:	de c9                	fmulp  %st,%st(1)
    2192:	de c1                	faddp  %st,%st(1)
    2194:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2197:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    219b:	0f b6 c0             	movzbl %al,%eax
    219e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21a1:	db 45 b4             	fildl  -0x4c(%ebp)
    21a4:	d8 4d dc             	fmuls  -0x24(%ebp)
    21a7:	8b 45 cc             	mov    -0x34(%ebp),%eax
    21aa:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21ad:	db 45 b4             	fildl  -0x4c(%ebp)
    21b0:	de c9                	fmulp  %st,%st(1)
    21b2:	de c1                	faddp  %st,%st(1)
    21b4:	d9 7d be             	fnstcw -0x42(%ebp)
    21b7:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    21bb:	b4 0c                	mov    $0xc,%ah
    21bd:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    21c1:	d9 6d bc             	fldcw  -0x44(%ebp)
    21c4:	db 5d b8             	fistpl -0x48(%ebp)
    21c7:	d9 6d be             	fldcw  -0x42(%ebp)
    21ca:	8b 45 b8             	mov    -0x48(%ebp),%eax
    21cd:	89 c2                	mov    %eax,%edx
    21cf:	8b 45 14             	mov    0x14(%ebp),%eax
    21d2:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    21d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    21d8:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    21dc:	0f b6 c0             	movzbl %al,%eax
    21df:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21e2:	db 45 b4             	fildl  -0x4c(%ebp)
    21e5:	d8 4d d0             	fmuls  -0x30(%ebp)
    21e8:	8b 45 c0             	mov    -0x40(%ebp),%eax
    21eb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    21ee:	db 45 b4             	fildl  -0x4c(%ebp)
    21f1:	de c9                	fmulp  %st,%st(1)
    21f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    21f6:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    21fa:	0f b6 c0             	movzbl %al,%eax
    21fd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2200:	db 45 b4             	fildl  -0x4c(%ebp)
    2203:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2206:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2209:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    220c:	db 45 b4             	fildl  -0x4c(%ebp)
    220f:	de c9                	fmulp  %st,%st(1)
    2211:	de c1                	faddp  %st,%st(1)
    2213:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2216:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    221a:	0f b6 c0             	movzbl %al,%eax
    221d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2220:	db 45 b4             	fildl  -0x4c(%ebp)
    2223:	d8 4d d8             	fmuls  -0x28(%ebp)
    2226:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2229:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    222c:	db 45 b4             	fildl  -0x4c(%ebp)
    222f:	de c9                	fmulp  %st,%st(1)
    2231:	de c1                	faddp  %st,%st(1)
    2233:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2236:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    223a:	0f b6 c0             	movzbl %al,%eax
    223d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2240:	db 45 b4             	fildl  -0x4c(%ebp)
    2243:	d8 4d dc             	fmuls  -0x24(%ebp)
    2246:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2249:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    224c:	db 45 b4             	fildl  -0x4c(%ebp)
    224f:	de c9                	fmulp  %st,%st(1)
    2251:	de c1                	faddp  %st,%st(1)
    2253:	d9 6d bc             	fldcw  -0x44(%ebp)
    2256:	db 5d b8             	fistpl -0x48(%ebp)
    2259:	d9 6d be             	fldcw  -0x42(%ebp)
    225c:	8b 45 b8             	mov    -0x48(%ebp),%eax
    225f:	89 c2                	mov    %eax,%edx
    2261:	8b 45 14             	mov    0x14(%ebp),%eax
    2264:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    2267:	8b 45 f4             	mov    -0xc(%ebp),%eax
    226a:	0f b6 00             	movzbl (%eax),%eax
    226d:	0f b6 c0             	movzbl %al,%eax
    2270:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2273:	db 45 b4             	fildl  -0x4c(%ebp)
    2276:	d8 4d d0             	fmuls  -0x30(%ebp)
    2279:	8b 45 c0             	mov    -0x40(%ebp),%eax
    227c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    227f:	db 45 b4             	fildl  -0x4c(%ebp)
    2282:	de c9                	fmulp  %st,%st(1)
    2284:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2287:	0f b6 00             	movzbl (%eax),%eax
    228a:	0f b6 c0             	movzbl %al,%eax
    228d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2290:	db 45 b4             	fildl  -0x4c(%ebp)
    2293:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2296:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2299:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    229c:	db 45 b4             	fildl  -0x4c(%ebp)
    229f:	de c9                	fmulp  %st,%st(1)
    22a1:	de c1                	faddp  %st,%st(1)
    22a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    22a6:	0f b6 00             	movzbl (%eax),%eax
    22a9:	0f b6 c0             	movzbl %al,%eax
    22ac:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22af:	db 45 b4             	fildl  -0x4c(%ebp)
    22b2:	d8 4d d8             	fmuls  -0x28(%ebp)
    22b5:	8b 45 c8             	mov    -0x38(%ebp),%eax
    22b8:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22bb:	db 45 b4             	fildl  -0x4c(%ebp)
    22be:	de c9                	fmulp  %st,%st(1)
    22c0:	de c1                	faddp  %st,%st(1)
    22c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    22c5:	0f b6 00             	movzbl (%eax),%eax
    22c8:	0f b6 c0             	movzbl %al,%eax
    22cb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22ce:	db 45 b4             	fildl  -0x4c(%ebp)
    22d1:	d8 4d dc             	fmuls  -0x24(%ebp)
    22d4:	8b 45 cc             	mov    -0x34(%ebp),%eax
    22d7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22da:	db 45 b4             	fildl  -0x4c(%ebp)
    22dd:	de c9                	fmulp  %st,%st(1)
    22df:	de c1                	faddp  %st,%st(1)
    22e1:	d9 6d bc             	fldcw  -0x44(%ebp)
    22e4:	db 5d b8             	fistpl -0x48(%ebp)
    22e7:	d9 6d be             	fldcw  -0x42(%ebp)
    22ea:	8b 45 b8             	mov    -0x48(%ebp),%eax
    22ed:	89 c2                	mov    %eax,%edx
    22ef:	8b 45 14             	mov    0x14(%ebp),%eax
    22f2:	88 10                	mov    %dl,(%eax)

    return 1;
    22f4:	b8 01 00 00 00       	mov    $0x1,%eax
}
    22f9:	c9                   	leave  
    22fa:	c3                   	ret    

000022fb <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    22fb:	55                   	push   %ebp
    22fc:	89 e5                	mov    %esp,%ebp
    22fe:	53                   	push   %ebx
    22ff:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    2302:	8b 45 10             	mov    0x10(%ebp),%eax
    2305:	c1 f8 10             	sar    $0x10,%eax
    2308:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    230b:	8b 45 0c             	mov    0xc(%ebp),%eax
    230e:	c1 f8 10             	sar    $0x10,%eax
    2311:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    2314:	8d 45 bc             	lea    -0x44(%ebp),%eax
    2317:	50                   	push   %eax
    2318:	ff 75 f8             	pushl  -0x8(%ebp)
    231b:	ff 75 f4             	pushl  -0xc(%ebp)
    231e:	ff 75 08             	pushl  0x8(%ebp)
    2321:	e8 5b fc ff ff       	call   1f81 <getColor>
    2326:	83 c4 10             	add    $0x10,%esp
    2329:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    232c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    232f:	83 c0 01             	add    $0x1,%eax
    2332:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2335:	83 c2 04             	add    $0x4,%edx
    2338:	52                   	push   %edx
    2339:	ff 75 f8             	pushl  -0x8(%ebp)
    233c:	50                   	push   %eax
    233d:	ff 75 08             	pushl  0x8(%ebp)
    2340:	e8 3c fc ff ff       	call   1f81 <getColor>
    2345:	83 c4 10             	add    $0x10,%esp
    2348:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    234b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    234e:	83 c0 01             	add    $0x1,%eax
    2351:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2354:	83 c2 08             	add    $0x8,%edx
    2357:	52                   	push   %edx
    2358:	50                   	push   %eax
    2359:	ff 75 f4             	pushl  -0xc(%ebp)
    235c:	ff 75 08             	pushl  0x8(%ebp)
    235f:	e8 1d fc ff ff       	call   1f81 <getColor>
    2364:	83 c4 10             	add    $0x10,%esp
    2367:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    236a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    236d:	8d 50 01             	lea    0x1(%eax),%edx
    2370:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2373:	83 c0 01             	add    $0x1,%eax
    2376:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    2379:	83 c1 0c             	add    $0xc,%ecx
    237c:	51                   	push   %ecx
    237d:	52                   	push   %edx
    237e:	50                   	push   %eax
    237f:	ff 75 08             	pushl  0x8(%ebp)
    2382:	e8 fa fb ff ff       	call   1f81 <getColor>
    2387:	83 c4 10             	add    $0x10,%esp
    238a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    238d:	8b 45 10             	mov    0x10(%ebp),%eax
    2390:	0f b7 c0             	movzwl %ax,%eax
    2393:	c1 f8 08             	sar    $0x8,%eax
    2396:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    2399:	8b 45 0c             	mov    0xc(%ebp),%eax
    239c:	0f b7 c0             	movzwl %ax,%eax
    239f:	c1 f8 08             	sar    $0x8,%eax
    23a2:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    23a5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    23a8:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    23ac:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    23af:	b8 ff 00 00 00       	mov    $0xff,%eax
    23b4:	2b 45 dc             	sub    -0x24(%ebp),%eax
    23b7:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    23bb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    23be:	b8 ff 00 00 00       	mov    $0xff,%eax
    23c3:	2b 45 e0             	sub    -0x20(%ebp),%eax
    23c6:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    23ca:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    23cd:	b8 ff 00 00 00       	mov    $0xff,%eax
    23d2:	2b 45 e0             	sub    -0x20(%ebp),%eax
    23d5:	89 c2                	mov    %eax,%edx
    23d7:	b8 ff 00 00 00       	mov    $0xff,%eax
    23dc:	2b 45 dc             	sub    -0x24(%ebp),%eax
    23df:	0f af c2             	imul   %edx,%eax
    23e2:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    23e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    23e8:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    23ec:	0f b6 c0             	movzbl %al,%eax
    23ef:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    23f3:	8b 55 bc             	mov    -0x44(%ebp),%edx
    23f6:	0f af d0             	imul   %eax,%edx
    23f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    23fc:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2400:	0f b6 c0             	movzbl %al,%eax
    2403:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2407:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    240a:	0f af c1             	imul   %ecx,%eax
    240d:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2410:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2413:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2417:	0f b6 c0             	movzbl %al,%eax
    241a:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    241e:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2421:	0f af d0             	imul   %eax,%edx
    2424:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2427:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    242b:	0f b6 c0             	movzbl %al,%eax
    242e:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2432:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2435:	0f af c1             	imul   %ecx,%eax
    2438:	01 d0                	add    %edx,%eax
    243a:	01 d8                	add    %ebx,%eax
    243c:	c1 e8 10             	shr    $0x10,%eax
    243f:	89 c2                	mov    %eax,%edx
    2441:	8b 45 14             	mov    0x14(%ebp),%eax
    2444:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    2447:	8b 45 f0             	mov    -0x10(%ebp),%eax
    244a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    244e:	0f b6 c0             	movzbl %al,%eax
    2451:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2455:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2458:	0f af d0             	imul   %eax,%edx
    245b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    245e:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2462:	0f b6 c0             	movzbl %al,%eax
    2465:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2469:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    246c:	0f af c1             	imul   %ecx,%eax
    246f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2472:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2475:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2479:	0f b6 c0             	movzbl %al,%eax
    247c:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2480:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2483:	0f af d0             	imul   %eax,%edx
    2486:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2489:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    248d:	0f b6 c0             	movzbl %al,%eax
    2490:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2494:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2497:	0f af c1             	imul   %ecx,%eax
    249a:	01 d0                	add    %edx,%eax
    249c:	01 d8                	add    %ebx,%eax
    249e:	c1 e8 10             	shr    $0x10,%eax
    24a1:	89 c2                	mov    %eax,%edx
    24a3:	8b 45 14             	mov    0x14(%ebp),%eax
    24a6:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    24a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    24ac:	0f b6 00             	movzbl (%eax),%eax
    24af:	0f b6 c0             	movzbl %al,%eax
    24b2:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    24b6:	8b 55 bc             	mov    -0x44(%ebp),%edx
    24b9:	0f af d0             	imul   %eax,%edx
    24bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    24bf:	0f b6 00             	movzbl (%eax),%eax
    24c2:	0f b6 c0             	movzbl %al,%eax
    24c5:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    24c9:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    24cc:	0f af c1             	imul   %ecx,%eax
    24cf:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    24d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    24d5:	0f b6 00             	movzbl (%eax),%eax
    24d8:	0f b6 c0             	movzbl %al,%eax
    24db:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    24df:	8b 55 c8             	mov    -0x38(%ebp),%edx
    24e2:	0f af d0             	imul   %eax,%edx
    24e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    24e8:	0f b6 00             	movzbl (%eax),%eax
    24eb:	0f b6 c0             	movzbl %al,%eax
    24ee:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    24f2:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    24f5:	0f af c1             	imul   %ecx,%eax
    24f8:	01 d0                	add    %edx,%eax
    24fa:	01 d8                	add    %ebx,%eax
    24fc:	c1 e8 10             	shr    $0x10,%eax
    24ff:	89 c2                	mov    %eax,%edx
    2501:	8b 45 14             	mov    0x14(%ebp),%eax
    2504:	88 10                	mov    %dl,(%eax)
}
    2506:	90                   	nop
    2507:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    250a:	c9                   	leave  
    250b:	c3                   	ret    

0000250c <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    250c:	55                   	push   %ebp
    250d:	89 e5                	mov    %esp,%ebp
    250f:	53                   	push   %ebx
    2510:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    2513:	8b 45 08             	mov    0x8(%ebp),%eax
    2516:	8b 00                	mov    (%eax),%eax
    2518:	c1 e0 10             	shl    $0x10,%eax
    251b:	89 c1                	mov    %eax,%ecx
    251d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2520:	8b 18                	mov    (%eax),%ebx
    2522:	89 c8                	mov    %ecx,%eax
    2524:	99                   	cltd   
    2525:	f7 fb                	idiv   %ebx
    2527:	83 c0 01             	add    $0x1,%eax
    252a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    252d:	8b 45 08             	mov    0x8(%ebp),%eax
    2530:	8b 40 04             	mov    0x4(%eax),%eax
    2533:	c1 e0 10             	shl    $0x10,%eax
    2536:	89 c1                	mov    %eax,%ecx
    2538:	8b 45 0c             	mov    0xc(%ebp),%eax
    253b:	8b 58 04             	mov    0x4(%eax),%ebx
    253e:	89 c8                	mov    %ecx,%eax
    2540:	99                   	cltd   
    2541:	f7 fb                	idiv   %ebx
    2543:	83 c0 01             	add    $0x1,%eax
    2546:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    2549:	8b 45 e8             	mov    -0x18(%ebp),%eax
    254c:	d1 f8                	sar    %eax
    254e:	2d 00 80 00 00       	sub    $0x8000,%eax
    2553:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    2556:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2559:	d1 f8                	sar    %eax
    255b:	2d 00 80 00 00       	sub    $0x8000,%eax
    2560:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    2563:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2566:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    2569:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2570:	eb 5d                	jmp    25cf <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    2572:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2575:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    2578:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    257f:	eb 3a                	jmp    25bb <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    2581:	8b 45 0c             	mov    0xc(%ebp),%eax
    2584:	8b 48 08             	mov    0x8(%eax),%ecx
    2587:	8b 45 0c             	mov    0xc(%ebp),%eax
    258a:	8b 00                	mov    (%eax),%eax
    258c:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2590:	89 c2                	mov    %eax,%edx
    2592:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2595:	01 c2                	add    %eax,%edx
    2597:	89 d0                	mov    %edx,%eax
    2599:	01 c0                	add    %eax,%eax
    259b:	01 d0                	add    %edx,%eax
    259d:	01 c8                	add    %ecx,%eax
    259f:	50                   	push   %eax
    25a0:	ff 75 f0             	pushl  -0x10(%ebp)
    25a3:	ff 75 f8             	pushl  -0x8(%ebp)
    25a6:	ff 75 08             	pushl  0x8(%ebp)
    25a9:	e8 4d fd ff ff       	call   22fb <mixColorInt>
    25ae:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    25b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    25b4:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    25b7:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    25bb:	8b 45 0c             	mov    0xc(%ebp),%eax
    25be:	8b 00                	mov    (%eax),%eax
    25c0:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    25c3:	7f bc                	jg     2581 <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    25c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    25c8:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    25cb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    25cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    25d2:	8b 40 04             	mov    0x4(%eax),%eax
    25d5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    25d8:	7f 98                	jg     2572 <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    25da:	b8 01 00 00 00       	mov    $0x1,%eax
}
    25df:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    25e2:	c9                   	leave  
    25e3:	c3                   	ret    

000025e4 <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    25e4:	55                   	push   %ebp
    25e5:	89 e5                	mov    %esp,%ebp
    25e7:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    25ea:	8b 45 08             	mov    0x8(%ebp),%eax
    25ed:	8b 00                	mov    (%eax),%eax
    25ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    25f2:	db 45 e4             	fildl  -0x1c(%ebp)
    25f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    25f8:	8b 00                	mov    (%eax),%eax
    25fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    25fd:	db 45 e4             	fildl  -0x1c(%ebp)
    2600:	de f9                	fdivrp %st,%st(1)
    2602:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    2605:	8b 45 08             	mov    0x8(%ebp),%eax
    2608:	8b 40 04             	mov    0x4(%eax),%eax
    260b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    260e:	db 45 e4             	fildl  -0x1c(%ebp)
    2611:	8b 45 0c             	mov    0xc(%ebp),%eax
    2614:	8b 40 04             	mov    0x4(%eax),%eax
    2617:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    261a:	db 45 e4             	fildl  -0x1c(%ebp)
    261d:	de f9                	fdivrp %st,%st(1)
    261f:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    2622:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    2629:	eb 5e                	jmp    2689 <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    262b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2632:	eb 47                	jmp    267b <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    2634:	db 45 f8             	fildl  -0x8(%ebp)
    2637:	d8 4d f4             	fmuls  -0xc(%ebp)
    263a:	d9 7d ee             	fnstcw -0x12(%ebp)
    263d:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    2641:	b4 0c                	mov    $0xc,%ah
    2643:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    2647:	d9 6d ec             	fldcw  -0x14(%ebp)
    264a:	db 5d e8             	fistpl -0x18(%ebp)
    264d:	d9 6d ee             	fldcw  -0x12(%ebp)
    2650:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2653:	db 45 fc             	fildl  -0x4(%ebp)
    2656:	d8 4d f0             	fmuls  -0x10(%ebp)
    2659:	d9 6d ec             	fldcw  -0x14(%ebp)
    265c:	db 5d e8             	fistpl -0x18(%ebp)
    265f:	d9 6d ee             	fldcw  -0x12(%ebp)
    2662:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2665:	6a 00                	push   $0x0
    2667:	52                   	push   %edx
    2668:	50                   	push   %eax
    2669:	ff 75 08             	pushl  0x8(%ebp)
    266c:	e8 10 f9 ff ff       	call   1f81 <getColor>
    2671:	83 c4 10             	add    $0x10,%esp
    2674:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    2677:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    267b:	8b 45 0c             	mov    0xc(%ebp),%eax
    267e:	8b 00                	mov    (%eax),%eax
    2680:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2683:	7f af                	jg     2634 <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    2685:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2689:	8b 45 0c             	mov    0xc(%ebp),%eax
    268c:	8b 40 04             	mov    0x4(%eax),%eax
    268f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2692:	7f 97                	jg     262b <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    2694:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2699:	c9                   	leave  
    269a:	c3                   	ret    

0000269b <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    269b:	55                   	push   %ebp
    269c:	89 e5                	mov    %esp,%ebp
    269e:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    26a1:	8b 45 08             	mov    0x8(%ebp),%eax
    26a4:	8b 00                	mov    (%eax),%eax
    26a6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    26a9:	db 45 e0             	fildl  -0x20(%ebp)
    26ac:	d9 5d e0             	fstps  -0x20(%ebp)
    26af:	83 ec 0c             	sub    $0xc,%esp
    26b2:	ff 75 10             	pushl  0x10(%ebp)
    26b5:	e8 6b e2 ff ff       	call   925 <cos>
    26ba:	83 c4 10             	add    $0x10,%esp
    26bd:	d9 5d dc             	fstps  -0x24(%ebp)
    26c0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    26c3:	83 ec 0c             	sub    $0xc,%esp
    26c6:	50                   	push   %eax
    26c7:	e8 90 e1 ff ff       	call   85c <abs>
    26cc:	83 c4 10             	add    $0x10,%esp
    26cf:	d8 4d e0             	fmuls  -0x20(%ebp)
    26d2:	d9 5d e0             	fstps  -0x20(%ebp)
    26d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    26d8:	8b 00                	mov    (%eax),%eax
    26da:	89 45 dc             	mov    %eax,-0x24(%ebp)
    26dd:	db 45 dc             	fildl  -0x24(%ebp)
    26e0:	d9 5d dc             	fstps  -0x24(%ebp)
    26e3:	83 ec 0c             	sub    $0xc,%esp
    26e6:	ff 75 10             	pushl  0x10(%ebp)
    26e9:	e8 da e3 ff ff       	call   ac8 <sin>
    26ee:	83 c4 10             	add    $0x10,%esp
    26f1:	d9 5d d8             	fstps  -0x28(%ebp)
    26f4:	8b 45 d8             	mov    -0x28(%ebp),%eax
    26f7:	83 ec 0c             	sub    $0xc,%esp
    26fa:	50                   	push   %eax
    26fb:	e8 5c e1 ff ff       	call   85c <abs>
    2700:	83 c4 10             	add    $0x10,%esp
    2703:	d8 4d dc             	fmuls  -0x24(%ebp)
    2706:	d8 45 e0             	fadds  -0x20(%ebp)
    2709:	d9 7d e6             	fnstcw -0x1a(%ebp)
    270c:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    2710:	b4 0c                	mov    $0xc,%ah
    2712:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2716:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2719:	db 5d f4             	fistpl -0xc(%ebp)
    271c:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    271f:	8b 45 08             	mov    0x8(%ebp),%eax
    2722:	8b 00                	mov    (%eax),%eax
    2724:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2727:	db 45 e0             	fildl  -0x20(%ebp)
    272a:	d9 5d e0             	fstps  -0x20(%ebp)
    272d:	83 ec 0c             	sub    $0xc,%esp
    2730:	ff 75 10             	pushl  0x10(%ebp)
    2733:	e8 90 e3 ff ff       	call   ac8 <sin>
    2738:	83 c4 10             	add    $0x10,%esp
    273b:	d9 5d dc             	fstps  -0x24(%ebp)
    273e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2741:	83 ec 0c             	sub    $0xc,%esp
    2744:	50                   	push   %eax
    2745:	e8 12 e1 ff ff       	call   85c <abs>
    274a:	83 c4 10             	add    $0x10,%esp
    274d:	d8 4d e0             	fmuls  -0x20(%ebp)
    2750:	d9 5d e0             	fstps  -0x20(%ebp)
    2753:	8b 45 0c             	mov    0xc(%ebp),%eax
    2756:	8b 00                	mov    (%eax),%eax
    2758:	89 45 dc             	mov    %eax,-0x24(%ebp)
    275b:	db 45 dc             	fildl  -0x24(%ebp)
    275e:	d9 5d dc             	fstps  -0x24(%ebp)
    2761:	83 ec 0c             	sub    $0xc,%esp
    2764:	ff 75 10             	pushl  0x10(%ebp)
    2767:	e8 b9 e1 ff ff       	call   925 <cos>
    276c:	83 c4 10             	add    $0x10,%esp
    276f:	d9 5d d8             	fstps  -0x28(%ebp)
    2772:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2775:	83 ec 0c             	sub    $0xc,%esp
    2778:	50                   	push   %eax
    2779:	e8 de e0 ff ff       	call   85c <abs>
    277e:	83 c4 10             	add    $0x10,%esp
    2781:	d8 4d dc             	fmuls  -0x24(%ebp)
    2784:	d8 45 e0             	fadds  -0x20(%ebp)
    2787:	d9 7d e6             	fnstcw -0x1a(%ebp)
    278a:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    278e:	b4 0c                	mov    $0xc,%ah
    2790:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2794:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2797:	db 5d f0             	fistpl -0x10(%ebp)
    279a:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    279d:	8b 45 0c             	mov    0xc(%ebp),%eax
    27a0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    27a3:	89 10                	mov    %edx,(%eax)
    *width = w;
    27a5:	8b 45 08             	mov    0x8(%ebp),%eax
    27a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    27ab:	89 10                	mov    %edx,(%eax)
    return 1;
    27ad:	b8 01 00 00 00       	mov    $0x1,%eax
}
    27b2:	c9                   	leave  
    27b3:	c3                   	ret    

000027b4 <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    27b4:	55                   	push   %ebp
    27b5:	89 e5                	mov    %esp,%ebp
    27b7:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    27ba:	8b 45 08             	mov    0x8(%ebp),%eax
    27bd:	8b 40 04             	mov    0x4(%eax),%eax
    27c0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    27c3:	db 45 c4             	fildl  -0x3c(%ebp)
    27c6:	d9 05 a4 9c 01 00    	flds   0x19ca4
    27cc:	de f9                	fdivrp %st,%st(1)
    27ce:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    27d1:	8b 45 08             	mov    0x8(%ebp),%eax
    27d4:	8b 00                	mov    (%eax),%eax
    27d6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    27d9:	db 45 c4             	fildl  -0x3c(%ebp)
    27dc:	d9 05 a4 9c 01 00    	flds   0x19ca4
    27e2:	de f9                	fdivrp %st,%st(1)
    27e4:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    27e7:	8b 45 0c             	mov    0xc(%ebp),%eax
    27ea:	8b 50 04             	mov    0x4(%eax),%edx
    27ed:	8b 45 08             	mov    0x8(%ebp),%eax
    27f0:	8b 40 04             	mov    0x4(%eax),%eax
    27f3:	29 c2                	sub    %eax,%edx
    27f5:	89 d0                	mov    %edx,%eax
    27f7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    27fa:	db 45 c4             	fildl  -0x3c(%ebp)
    27fd:	d9 05 a4 9c 01 00    	flds   0x19ca4
    2803:	de f9                	fdivrp %st,%st(1)
    2805:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    2808:	8b 45 0c             	mov    0xc(%ebp),%eax
    280b:	8b 10                	mov    (%eax),%edx
    280d:	8b 45 08             	mov    0x8(%ebp),%eax
    2810:	8b 00                	mov    (%eax),%eax
    2812:	29 c2                	sub    %eax,%edx
    2814:	89 d0                	mov    %edx,%eax
    2816:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2819:	db 45 c4             	fildl  -0x3c(%ebp)
    281c:	d9 05 a4 9c 01 00    	flds   0x19ca4
    2822:	de f9                	fdivrp %st,%st(1)
    2824:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    2827:	d9 45 10             	flds   0x10(%ebp)
    282a:	d9 e0                	fchs   
    282c:	83 ec 0c             	sub    $0xc,%esp
    282f:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2833:	d9 1c 24             	fstps  (%esp)
    2836:	e8 ea e0 ff ff       	call   925 <cos>
    283b:	83 c4 10             	add    $0x10,%esp
    283e:	d9 5d c4             	fstps  -0x3c(%ebp)
    2841:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2844:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    2847:	d9 45 10             	flds   0x10(%ebp)
    284a:	d9 e0                	fchs   
    284c:	83 ec 0c             	sub    $0xc,%esp
    284f:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2853:	d9 1c 24             	fstps  (%esp)
    2856:	e8 6d e2 ff ff       	call   ac8 <sin>
    285b:	83 c4 10             	add    $0x10,%esp
    285e:	d9 5d c4             	fstps  -0x3c(%ebp)
    2861:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2864:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    2867:	d9 ee                	fldz   
    2869:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    286c:	d9 ee                	fldz   
    286e:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    2871:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2878:	e9 28 01 00 00       	jmp    29a5 <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    287d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2884:	e9 0a 01 00 00       	jmp    2993 <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    2889:	db 45 f4             	fildl  -0xc(%ebp)
    288c:	d8 65 e4             	fsubs  -0x1c(%ebp)
    288f:	d8 65 ec             	fsubs  -0x14(%ebp)
    2892:	d8 4d dc             	fmuls  -0x24(%ebp)
    2895:	db 45 f0             	fildl  -0x10(%ebp)
    2898:	d8 65 e0             	fsubs  -0x20(%ebp)
    289b:	d8 65 e8             	fsubs  -0x18(%ebp)
    289e:	d8 4d d8             	fmuls  -0x28(%ebp)
    28a1:	de c1                	faddp  %st,%st(1)
    28a3:	d8 45 ec             	fadds  -0x14(%ebp)
    28a6:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    28a9:	db 45 f0             	fildl  -0x10(%ebp)
    28ac:	d8 65 e0             	fsubs  -0x20(%ebp)
    28af:	d8 65 e8             	fsubs  -0x18(%ebp)
    28b2:	d8 4d dc             	fmuls  -0x24(%ebp)
    28b5:	db 45 f4             	fildl  -0xc(%ebp)
    28b8:	d8 65 e4             	fsubs  -0x1c(%ebp)
    28bb:	d8 65 ec             	fsubs  -0x14(%ebp)
    28be:	d8 4d d8             	fmuls  -0x28(%ebp)
    28c1:	de e9                	fsubrp %st,%st(1)
    28c3:	d8 45 e8             	fadds  -0x18(%ebp)
    28c6:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    28c9:	d9 45 d4             	flds   -0x2c(%ebp)
    28cc:	d9 ee                	fldz   
    28ce:	d9 c9                	fxch   %st(1)
    28d0:	df e9                	fucomip %st(1),%st
    28d2:	dd d8                	fstp   %st(0)
    28d4:	0f 93 c0             	setae  %al
    28d7:	83 f0 01             	xor    $0x1,%eax
    28da:	84 c0                	test   %al,%al
    28dc:	75 52                	jne    2930 <picTurn+0x17c>
    28de:	8b 45 08             	mov    0x8(%ebp),%eax
    28e1:	8b 40 04             	mov    0x4(%eax),%eax
    28e4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    28e7:	db 45 c4             	fildl  -0x3c(%ebp)
    28ea:	d9 45 d4             	flds   -0x2c(%ebp)
    28ed:	d9 c9                	fxch   %st(1)
    28ef:	df e9                	fucomip %st(1),%st
    28f1:	dd d8                	fstp   %st(0)
    28f3:	0f 97 c0             	seta   %al
    28f6:	83 f0 01             	xor    $0x1,%eax
    28f9:	84 c0                	test   %al,%al
    28fb:	75 33                	jne    2930 <picTurn+0x17c>
    28fd:	d9 45 d0             	flds   -0x30(%ebp)
    2900:	d9 ee                	fldz   
    2902:	d9 c9                	fxch   %st(1)
    2904:	df e9                	fucomip %st(1),%st
    2906:	dd d8                	fstp   %st(0)
    2908:	0f 93 c0             	setae  %al
    290b:	83 f0 01             	xor    $0x1,%eax
    290e:	84 c0                	test   %al,%al
    2910:	75 1e                	jne    2930 <picTurn+0x17c>
    2912:	8b 45 08             	mov    0x8(%ebp),%eax
    2915:	8b 00                	mov    (%eax),%eax
    2917:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    291a:	db 45 c4             	fildl  -0x3c(%ebp)
    291d:	d9 45 d0             	flds   -0x30(%ebp)
    2920:	d9 c9                	fxch   %st(1)
    2922:	df e9                	fucomip %st(1),%st
    2924:	dd d8                	fstp   %st(0)
    2926:	0f 97 c0             	seta   %al
    2929:	83 f0 01             	xor    $0x1,%eax
    292c:	84 c0                	test   %al,%al
    292e:	74 2f                	je     295f <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    2930:	8b 45 0c             	mov    0xc(%ebp),%eax
    2933:	8b 48 08             	mov    0x8(%eax),%ecx
    2936:	8b 45 0c             	mov    0xc(%ebp),%eax
    2939:	8b 00                	mov    (%eax),%eax
    293b:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    293f:	89 c2                	mov    %eax,%edx
    2941:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2944:	01 c2                	add    %eax,%edx
    2946:	89 d0                	mov    %edx,%eax
    2948:	01 c0                	add    %eax,%eax
    294a:	01 d0                	add    %edx,%eax
    294c:	01 c8                	add    %ecx,%eax
    294e:	83 ec 08             	sub    $0x8,%esp
    2951:	50                   	push   %eax
    2952:	68 f1 e0 01 00       	push   $0x1e0f1
    2957:	e8 9f f6 ff ff       	call   1ffb <setColor>
    295c:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    295f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2962:	8b 48 08             	mov    0x8(%eax),%ecx
    2965:	8b 45 0c             	mov    0xc(%ebp),%eax
    2968:	8b 00                	mov    (%eax),%eax
    296a:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    296e:	89 c2                	mov    %eax,%edx
    2970:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2973:	01 c2                	add    %eax,%edx
    2975:	89 d0                	mov    %edx,%eax
    2977:	01 c0                	add    %eax,%eax
    2979:	01 d0                	add    %edx,%eax
    297b:	01 c8                	add    %ecx,%eax
    297d:	50                   	push   %eax
    297e:	ff 75 d0             	pushl  -0x30(%ebp)
    2981:	ff 75 d4             	pushl  -0x2c(%ebp)
    2984:	ff 75 08             	pushl  0x8(%ebp)
    2987:	e8 9e f6 ff ff       	call   202a <mixColor>
    298c:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    298f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2993:	8b 45 0c             	mov    0xc(%ebp),%eax
    2996:	8b 00                	mov    (%eax),%eax
    2998:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    299b:	0f 8f e8 fe ff ff    	jg     2889 <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    29a1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    29a5:	8b 45 0c             	mov    0xc(%ebp),%eax
    29a8:	8b 40 04             	mov    0x4(%eax),%eax
    29ab:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    29ae:	0f 8f c9 fe ff ff    	jg     287d <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    29b4:	b8 01 00 00 00       	mov    $0x1,%eax
}
    29b9:	c9                   	leave  
    29ba:	c3                   	ret    

000029bb <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    29bb:	55                   	push   %ebp
    29bc:	89 e5                	mov    %esp,%ebp
    29be:	53                   	push   %ebx
    29bf:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    29c2:	8b 45 08             	mov    0x8(%ebp),%eax
    29c5:	8b 10                	mov    (%eax),%edx
    29c7:	8b 45 0c             	mov    0xc(%ebp),%eax
    29ca:	8b 00                	mov    (%eax),%eax
    29cc:	39 c2                	cmp    %eax,%edx
    29ce:	75 10                	jne    29e0 <picRollingOver+0x25>
    29d0:	8b 45 08             	mov    0x8(%ebp),%eax
    29d3:	8b 50 04             	mov    0x4(%eax),%edx
    29d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    29d9:	8b 40 04             	mov    0x4(%eax),%eax
    29dc:	39 c2                	cmp    %eax,%edx
    29de:	74 0a                	je     29ea <picRollingOver+0x2f>
        return 0;
    29e0:	b8 00 00 00 00       	mov    $0x0,%eax
    29e5:	e9 88 00 00 00       	jmp    2a72 <picRollingOver+0xb7>

    int h = src->height;
    29ea:	8b 45 08             	mov    0x8(%ebp),%eax
    29ed:	8b 40 04             	mov    0x4(%eax),%eax
    29f0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    29f3:	8b 45 08             	mov    0x8(%ebp),%eax
    29f6:	8b 00                	mov    (%eax),%eax
    29f8:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    29fb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2a02:	eb 61                	jmp    2a65 <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    2a04:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2a0b:	eb 4c                	jmp    2a59 <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    2a0d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a10:	8b 48 08             	mov    0x8(%eax),%ecx
    2a13:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2a16:	2b 45 f8             	sub    -0x8(%ebp),%eax
    2a19:	83 e8 01             	sub    $0x1,%eax
    2a1c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2a20:	89 c2                	mov    %eax,%edx
    2a22:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a25:	01 c2                	add    %eax,%edx
    2a27:	89 d0                	mov    %edx,%eax
    2a29:	01 c0                	add    %eax,%eax
    2a2b:	01 d0                	add    %edx,%eax
    2a2d:	01 c1                	add    %eax,%ecx
    2a2f:	8b 45 08             	mov    0x8(%ebp),%eax
    2a32:	8b 58 08             	mov    0x8(%eax),%ebx
    2a35:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a38:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2a3c:	89 c2                	mov    %eax,%edx
    2a3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a41:	01 c2                	add    %eax,%edx
    2a43:	89 d0                	mov    %edx,%eax
    2a45:	01 c0                	add    %eax,%eax
    2a47:	01 d0                	add    %edx,%eax
    2a49:	01 d8                	add    %ebx,%eax
    2a4b:	51                   	push   %ecx
    2a4c:	50                   	push   %eax
    2a4d:	e8 a9 f5 ff ff       	call   1ffb <setColor>
    2a52:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2a55:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2a59:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2a5c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2a5f:	7c ac                	jl     2a0d <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2a61:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2a65:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2a68:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2a6b:	7c 97                	jl     2a04 <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    2a6d:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2a72:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2a75:	c9                   	leave  
    2a76:	c3                   	ret    

00002a77 <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    2a77:	55                   	push   %ebp
    2a78:	89 e5                	mov    %esp,%ebp
    2a7a:	53                   	push   %ebx
    2a7b:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2a7e:	8b 45 08             	mov    0x8(%ebp),%eax
    2a81:	8b 10                	mov    (%eax),%edx
    2a83:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a86:	8b 00                	mov    (%eax),%eax
    2a88:	39 c2                	cmp    %eax,%edx
    2a8a:	75 10                	jne    2a9c <picTurnAround+0x25>
    2a8c:	8b 45 08             	mov    0x8(%ebp),%eax
    2a8f:	8b 50 04             	mov    0x4(%eax),%edx
    2a92:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a95:	8b 40 04             	mov    0x4(%eax),%eax
    2a98:	39 c2                	cmp    %eax,%edx
    2a9a:	74 0a                	je     2aa6 <picTurnAround+0x2f>
        return 0;
    2a9c:	b8 00 00 00 00       	mov    $0x0,%eax
    2aa1:	e9 88 00 00 00       	jmp    2b2e <picTurnAround+0xb7>

    int h = src->height;
    2aa6:	8b 45 08             	mov    0x8(%ebp),%eax
    2aa9:	8b 40 04             	mov    0x4(%eax),%eax
    2aac:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2aaf:	8b 45 08             	mov    0x8(%ebp),%eax
    2ab2:	8b 00                	mov    (%eax),%eax
    2ab4:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2ab7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2abe:	eb 61                	jmp    2b21 <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    2ac0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2ac7:	eb 4c                	jmp    2b15 <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    2ac9:	8b 45 0c             	mov    0xc(%ebp),%eax
    2acc:	8b 48 08             	mov    0x8(%eax),%ecx
    2acf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2ad2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2ad6:	89 c2                	mov    %eax,%edx
    2ad8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2adb:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2ade:	01 c2                	add    %eax,%edx
    2ae0:	89 d0                	mov    %edx,%eax
    2ae2:	01 c0                	add    %eax,%eax
    2ae4:	01 d0                	add    %edx,%eax
    2ae6:	83 e8 03             	sub    $0x3,%eax
    2ae9:	01 c1                	add    %eax,%ecx
    2aeb:	8b 45 08             	mov    0x8(%ebp),%eax
    2aee:	8b 58 08             	mov    0x8(%eax),%ebx
    2af1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2af4:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2af8:	89 c2                	mov    %eax,%edx
    2afa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2afd:	01 c2                	add    %eax,%edx
    2aff:	89 d0                	mov    %edx,%eax
    2b01:	01 c0                	add    %eax,%eax
    2b03:	01 d0                	add    %edx,%eax
    2b05:	01 d8                	add    %ebx,%eax
    2b07:	51                   	push   %ecx
    2b08:	50                   	push   %eax
    2b09:	e8 ed f4 ff ff       	call   1ffb <setColor>
    2b0e:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2b11:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2b15:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b18:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2b1b:	7c ac                	jl     2ac9 <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2b1d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2b21:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2b24:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2b27:	7c 97                	jl     2ac0 <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    2b29:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2b2e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2b31:	c9                   	leave  
    2b32:	c3                   	ret    

00002b33 <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    2b33:	55                   	push   %ebp
    2b34:	89 e5                	mov    %esp,%ebp
    2b36:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    2b39:	83 ec 0c             	sub    $0xc,%esp
    2b3c:	ff 75 08             	pushl  0x8(%ebp)
    2b3f:	e8 c5 d5 ff ff       	call   109 <strlen>
    2b44:	83 c4 10             	add    $0x10,%esp
    2b47:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    2b4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b4d:	8d 50 ff             	lea    -0x1(%eax),%edx
    2b50:	8b 45 08             	mov    0x8(%ebp),%eax
    2b53:	01 d0                	add    %edx,%eax
    2b55:	0f b6 00             	movzbl (%eax),%eax
    2b58:	3c 67                	cmp    $0x67,%al
    2b5a:	75 2b                	jne    2b87 <type+0x54>
    2b5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b5f:	8d 50 fe             	lea    -0x2(%eax),%edx
    2b62:	8b 45 08             	mov    0x8(%ebp),%eax
    2b65:	01 d0                	add    %edx,%eax
    2b67:	0f b6 00             	movzbl (%eax),%eax
    2b6a:	3c 70                	cmp    $0x70,%al
    2b6c:	75 19                	jne    2b87 <type+0x54>
    2b6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b71:	8d 50 fd             	lea    -0x3(%eax),%edx
    2b74:	8b 45 08             	mov    0x8(%ebp),%eax
    2b77:	01 d0                	add    %edx,%eax
    2b79:	0f b6 00             	movzbl (%eax),%eax
    2b7c:	3c 6a                	cmp    $0x6a,%al
    2b7e:	75 07                	jne    2b87 <type+0x54>
    2b80:	b8 00 00 00 00       	mov    $0x0,%eax
    2b85:	eb 7f                	jmp    2c06 <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    2b87:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b8a:	8d 50 ff             	lea    -0x1(%eax),%edx
    2b8d:	8b 45 08             	mov    0x8(%ebp),%eax
    2b90:	01 d0                	add    %edx,%eax
    2b92:	0f b6 00             	movzbl (%eax),%eax
    2b95:	3c 70                	cmp    $0x70,%al
    2b97:	75 2b                	jne    2bc4 <type+0x91>
    2b99:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b9c:	8d 50 fe             	lea    -0x2(%eax),%edx
    2b9f:	8b 45 08             	mov    0x8(%ebp),%eax
    2ba2:	01 d0                	add    %edx,%eax
    2ba4:	0f b6 00             	movzbl (%eax),%eax
    2ba7:	3c 6d                	cmp    $0x6d,%al
    2ba9:	75 19                	jne    2bc4 <type+0x91>
    2bab:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bae:	8d 50 fd             	lea    -0x3(%eax),%edx
    2bb1:	8b 45 08             	mov    0x8(%ebp),%eax
    2bb4:	01 d0                	add    %edx,%eax
    2bb6:	0f b6 00             	movzbl (%eax),%eax
    2bb9:	3c 62                	cmp    $0x62,%al
    2bbb:	75 07                	jne    2bc4 <type+0x91>
    2bbd:	b8 01 00 00 00       	mov    $0x1,%eax
    2bc2:	eb 42                	jmp    2c06 <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    2bc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bc7:	8d 50 ff             	lea    -0x1(%eax),%edx
    2bca:	8b 45 08             	mov    0x8(%ebp),%eax
    2bcd:	01 d0                	add    %edx,%eax
    2bcf:	0f b6 00             	movzbl (%eax),%eax
    2bd2:	3c 67                	cmp    $0x67,%al
    2bd4:	75 2b                	jne    2c01 <type+0xce>
    2bd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2bd9:	8d 50 fe             	lea    -0x2(%eax),%edx
    2bdc:	8b 45 08             	mov    0x8(%ebp),%eax
    2bdf:	01 d0                	add    %edx,%eax
    2be1:	0f b6 00             	movzbl (%eax),%eax
    2be4:	3c 6e                	cmp    $0x6e,%al
    2be6:	75 19                	jne    2c01 <type+0xce>
    2be8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2beb:	8d 50 fd             	lea    -0x3(%eax),%edx
    2bee:	8b 45 08             	mov    0x8(%ebp),%eax
    2bf1:	01 d0                	add    %edx,%eax
    2bf3:	0f b6 00             	movzbl (%eax),%eax
    2bf6:	3c 70                	cmp    $0x70,%al
    2bf8:	75 07                	jne    2c01 <type+0xce>
    2bfa:	b8 02 00 00 00       	mov    $0x2,%eax
    2bff:	eb 05                	jmp    2c06 <type+0xd3>
    else return NONE;
    2c01:	b8 03 00 00 00       	mov    $0x3,%eax
}
    2c06:	c9                   	leave  
    2c07:	c3                   	ret    

00002c08 <LoadBmp>:

PBitmap LoadBmp(char* filename){
    2c08:	55                   	push   %ebp
    2c09:	89 e5                	mov    %esp,%ebp
    2c0b:	56                   	push   %esi
    2c0c:	53                   	push   %ebx
    2c0d:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    2c10:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    2c17:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    2c1e:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    2c25:	83 ec 08             	sub    $0x8,%esp
    2c28:	6a 00                	push   $0x0
    2c2a:	ff 75 0c             	pushl  0xc(%ebp)
    2c2d:	e8 d9 d6 ff ff       	call   30b <open>
    2c32:	83 c4 10             	add    $0x10,%esp
    2c35:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2c38:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2c3c:	79 2c                	jns    2c6a <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    2c3e:	83 ec 08             	sub    $0x8,%esp
    2c41:	ff 75 0c             	pushl  0xc(%ebp)
    2c44:	68 a8 9c 01 00       	push   $0x19ca8
    2c49:	e8 24 d8 ff ff       	call   472 <printf>
    2c4e:	83 c4 10             	add    $0x10,%esp
        return bmp;
    2c51:	8b 45 08             	mov    0x8(%ebp),%eax
    2c54:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2c57:	89 10                	mov    %edx,(%eax)
    2c59:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2c5c:	89 50 04             	mov    %edx,0x4(%eax)
    2c5f:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2c62:	89 50 08             	mov    %edx,0x8(%eax)
    2c65:	e9 2d 02 00 00       	jmp    2e97 <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    2c6a:	83 ec 04             	sub    $0x4,%esp
    2c6d:	6a 0e                	push   $0xe
    2c6f:	8d 45 aa             	lea    -0x56(%ebp),%eax
    2c72:	50                   	push   %eax
    2c73:	ff 75 ec             	pushl  -0x14(%ebp)
    2c76:	e8 68 d6 ff ff       	call   2e3 <read>
    2c7b:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    2c7e:	83 ec 04             	sub    $0x4,%esp
    2c81:	6a 28                	push   $0x28
    2c83:	8d 45 82             	lea    -0x7e(%ebp),%eax
    2c86:	50                   	push   %eax
    2c87:	ff 75 ec             	pushl  -0x14(%ebp)
    2c8a:	e8 54 d6 ff ff       	call   2e3 <read>
    2c8f:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2c92:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2c96:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2c99:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2c9d:	0f b7 d8             	movzwl %ax,%ebx
    2ca0:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    2ca3:	8b 55 ac             	mov    -0x54(%ebp),%edx
    2ca6:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    2caa:	0f b7 c0             	movzwl %ax,%eax
    2cad:	83 ec 04             	sub    $0x4,%esp
    2cb0:	6a 36                	push   $0x36
    2cb2:	56                   	push   %esi
    2cb3:	53                   	push   %ebx
    2cb4:	51                   	push   %ecx
    2cb5:	52                   	push   %edx
    2cb6:	50                   	push   %eax
    2cb7:	68 b8 9c 01 00       	push   $0x19cb8
    2cbc:	e8 b1 d7 ff ff       	call   472 <printf>
    2cc1:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    2cc4:	8b 45 86             	mov    -0x7a(%ebp),%eax
    2cc7:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    2cca:	8b 45 8a             	mov    -0x76(%ebp),%eax
    2ccd:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    2cd0:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2cd3:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2cd6:	0f af c2             	imul   %edx,%eax
    2cd9:	89 c2                	mov    %eax,%edx
    2cdb:	89 d0                	mov    %edx,%eax
    2cdd:	01 c0                	add    %eax,%eax
    2cdf:	01 d0                	add    %edx,%eax
    2ce1:	83 ec 0c             	sub    $0xc,%esp
    2ce4:	50                   	push   %eax
    2ce5:	e8 5b da ff ff       	call   745 <malloc>
    2cea:	83 c4 10             	add    $0x10,%esp
    2ced:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    2cf0:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2cf4:	0f b7 c0             	movzwl %ax,%eax
    2cf7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    2cfa:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2cfd:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    2d01:	83 c0 1f             	add    $0x1f,%eax
    2d04:	c1 f8 05             	sar    $0x5,%eax
    2d07:	c1 e0 02             	shl    $0x2,%eax
    2d0a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    2d0d:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2d10:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2d14:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    2d17:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2d1a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2d1d:	83 ec 08             	sub    $0x8,%esp
    2d20:	52                   	push   %edx
    2d21:	50                   	push   %eax
    2d22:	ff 75 e8             	pushl  -0x18(%ebp)
    2d25:	ff 75 e0             	pushl  -0x20(%ebp)
    2d28:	ff 75 e4             	pushl  -0x1c(%ebp)
    2d2b:	68 e0 9c 01 00       	push   $0x19ce0
    2d30:	e8 3d d7 ff ff       	call   472 <printf>
    2d35:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    2d38:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    2d3b:	83 e8 36             	sub    $0x36,%eax
    2d3e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    2d41:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2d44:	83 ec 0c             	sub    $0xc,%esp
    2d47:	50                   	push   %eax
    2d48:	e8 f8 d9 ff ff       	call   745 <malloc>
    2d4d:	83 c4 10             	add    $0x10,%esp
    2d50:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    2d53:	83 ec 04             	sub    $0x4,%esp
    2d56:	ff 75 dc             	pushl  -0x24(%ebp)
    2d59:	ff 75 d8             	pushl  -0x28(%ebp)
    2d5c:	ff 75 ec             	pushl  -0x14(%ebp)
    2d5f:	e8 7f d5 ff ff       	call   2e3 <read>
    2d64:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    2d67:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2d6a:	83 ec 0c             	sub    $0xc,%esp
    2d6d:	50                   	push   %eax
    2d6e:	e8 d2 d9 ff ff       	call   745 <malloc>
    2d73:	83 c4 10             	add    $0x10,%esp
    2d76:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    2d79:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2d7c:	83 ec 04             	sub    $0x4,%esp
    2d7f:	50                   	push   %eax
    2d80:	ff 75 d4             	pushl  -0x2c(%ebp)
    2d83:	ff 75 ec             	pushl  -0x14(%ebp)
    2d86:	e8 58 d5 ff ff       	call   2e3 <read>
    2d8b:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    2d8e:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2d92:	66 c1 e8 03          	shr    $0x3,%ax
    2d96:	0f b7 c0             	movzwl %ax,%eax
    2d99:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    2d9c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2da3:	e9 c1 00 00 00       	jmp    2e69 <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    2da8:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2dab:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2dae:	8d 50 ff             	lea    -0x1(%eax),%edx
    2db1:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2db4:	0f af c2             	imul   %edx,%eax
    2db7:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    2dba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2dbd:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2dc1:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    2dc4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2dcb:	e9 89 00 00 00       	jmp    2e59 <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    2dd0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2dd3:	83 c0 01             	add    $0x1,%eax
    2dd6:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2dda:	89 c2                	mov    %eax,%edx
    2ddc:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2ddf:	01 d0                	add    %edx,%eax
    2de1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    2de4:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2de7:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2dea:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2ded:	01 c8                	add    %ecx,%eax
    2def:	89 c1                	mov    %eax,%ecx
    2df1:	89 c8                	mov    %ecx,%eax
    2df3:	01 c0                	add    %eax,%eax
    2df5:	01 c8                	add    %ecx,%eax
    2df7:	01 c2                	add    %eax,%edx
    2df9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2dfc:	8d 48 ff             	lea    -0x1(%eax),%ecx
    2dff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2e02:	01 c8                	add    %ecx,%eax
    2e04:	0f b6 00             	movzbl (%eax),%eax
    2e07:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    2e0a:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e0d:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2e10:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e13:	01 c8                	add    %ecx,%eax
    2e15:	89 c1                	mov    %eax,%ecx
    2e17:	89 c8                	mov    %ecx,%eax
    2e19:	01 c0                	add    %eax,%eax
    2e1b:	01 c8                	add    %ecx,%eax
    2e1d:	01 c2                	add    %eax,%edx
    2e1f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2e22:	8d 48 fe             	lea    -0x2(%eax),%ecx
    2e25:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2e28:	01 c8                	add    %ecx,%eax
    2e2a:	0f b6 00             	movzbl (%eax),%eax
    2e2d:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    2e30:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e33:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2e36:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2e39:	01 c8                	add    %ecx,%eax
    2e3b:	89 c1                	mov    %eax,%ecx
    2e3d:	89 c8                	mov    %ecx,%eax
    2e3f:	01 c0                	add    %eax,%eax
    2e41:	01 c8                	add    %ecx,%eax
    2e43:	01 c2                	add    %eax,%edx
    2e45:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2e48:	8d 48 fd             	lea    -0x3(%eax),%ecx
    2e4b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2e4e:	01 c8                	add    %ecx,%eax
    2e50:	0f b6 00             	movzbl (%eax),%eax
    2e53:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    2e55:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2e59:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2e5c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2e5f:	0f 8f 6b ff ff ff    	jg     2dd0 <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    2e65:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2e69:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2e6c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2e6f:	0f 8f 33 ff ff ff    	jg     2da8 <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    2e75:	83 ec 0c             	sub    $0xc,%esp
    2e78:	ff 75 ec             	pushl  -0x14(%ebp)
    2e7b:	e8 73 d4 ff ff       	call   2f3 <close>
    2e80:	83 c4 10             	add    $0x10,%esp
    return bmp;
    2e83:	8b 45 08             	mov    0x8(%ebp),%eax
    2e86:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2e89:	89 10                	mov    %edx,(%eax)
    2e8b:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2e8e:	89 50 04             	mov    %edx,0x4(%eax)
    2e91:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2e94:	89 50 08             	mov    %edx,0x8(%eax)
}
    2e97:	8b 45 08             	mov    0x8(%ebp),%eax
    2e9a:	8d 65 f8             	lea    -0x8(%ebp),%esp
    2e9d:	5b                   	pop    %ebx
    2e9e:	5e                   	pop    %esi
    2e9f:	5d                   	pop    %ebp
    2ea0:	c2 04 00             	ret    $0x4

00002ea3 <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    2ea3:	55                   	push   %ebp
    2ea4:	89 e5                	mov    %esp,%ebp
    2ea6:	53                   	push   %ebx
    2ea7:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    2eaa:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    2eae:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    2eb2:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    2eb6:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    2eba:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    2ebe:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    2ec2:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    2ec6:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    2eca:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    2ece:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    2ed2:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    2ed6:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    2eda:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    2ede:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    2ee2:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    2ee6:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    2eea:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    2eee:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    2ef2:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    2ef6:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    2efa:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    2efe:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    2f02:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    2f06:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    2f0a:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    2f0e:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    2f12:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    2f16:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    2f1a:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    2f1e:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    2f22:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    2f26:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    2f2a:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    2f2e:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    2f32:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    2f36:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    2f3a:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    2f3e:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    2f42:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    2f46:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    2f4a:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    2f4e:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    2f52:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    2f56:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    2f5a:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    2f5e:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    2f62:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    2f66:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    2f6a:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    2f6e:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    2f72:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    2f76:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    2f7a:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    2f7e:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    2f82:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    2f86:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    2f8a:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    2f8e:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    2f92:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    2f96:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    2f9a:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    2f9e:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    2fa2:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    2fa6:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    2faa:	83 ec 0c             	sub    $0xc,%esp
    2fad:	68 c8 02 08 00       	push   $0x802c8
    2fb2:	e8 8e d7 ff ff       	call   745 <malloc>
    2fb7:	83 c4 10             	add    $0x10,%esp
    2fba:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    2fbd:	83 ec 04             	sub    $0x4,%esp
    2fc0:	68 c8 02 08 00       	push   $0x802c8
    2fc5:	6a 00                	push   $0x0
    2fc7:	ff 75 f0             	pushl  -0x10(%ebp)
    2fca:	e8 61 d1 ff ff       	call   130 <memset>
    2fcf:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    2fd2:	83 ec 08             	sub    $0x8,%esp
    2fd5:	6a 00                	push   $0x0
    2fd7:	ff 75 0c             	pushl  0xc(%ebp)
    2fda:	e8 2c d3 ff ff       	call   30b <open>
    2fdf:	83 c4 10             	add    $0x10,%esp
    2fe2:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    2fe5:	83 ec 0c             	sub    $0xc,%esp
    2fe8:	68 40 42 0f 00       	push   $0xf4240
    2fed:	e8 53 d7 ff ff       	call   745 <malloc>
    2ff2:	83 c4 10             	add    $0x10,%esp
    2ff5:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    2ff8:	83 ec 04             	sub    $0x4,%esp
    2ffb:	68 40 42 0f 00       	push   $0xf4240
    3000:	ff 75 e8             	pushl  -0x18(%ebp)
    3003:	ff 75 ec             	pushl  -0x14(%ebp)
    3006:	e8 d8 d2 ff ff       	call   2e3 <read>
    300b:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    300e:	83 ec 0c             	sub    $0xc,%esp
    3011:	ff 75 ec             	pushl  -0x14(%ebp)
    3014:	e8 da d2 ff ff       	call   2f3 <close>
    3019:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    301c:	68 40 42 0f 00       	push   $0xf4240
    3021:	ff 75 e8             	pushl  -0x18(%ebp)
    3024:	8d 45 9c             	lea    -0x64(%ebp),%eax
    3027:	50                   	push   %eax
    3028:	ff 75 f0             	pushl  -0x10(%ebp)
    302b:	e8 5e 0c 01 00       	call   13c8e <_DecodeJPEG>
    3030:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    3033:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    303a:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    3041:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    3048:	83 ec 0c             	sub    $0xc,%esp
    304b:	ff 75 f0             	pushl  -0x10(%ebp)
    304e:	e8 29 0b 01 00       	call   13b7c <GetImageSize>
    3053:	83 c4 10             	add    $0x10,%esp
    3056:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    3059:	83 ec 0c             	sub    $0xc,%esp
    305c:	ff 75 f0             	pushl  -0x10(%ebp)
    305f:	e8 e1 0a 01 00       	call   13b45 <GetImage>
    3064:	83 c4 10             	add    $0x10,%esp
    3067:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    306a:	83 ec 0c             	sub    $0xc,%esp
    306d:	ff 75 f0             	pushl  -0x10(%ebp)
    3070:	e8 f1 0a 01 00       	call   13b66 <GetWidth>
    3075:	83 c4 10             	add    $0x10,%esp
    3078:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    307b:	83 ec 0c             	sub    $0xc,%esp
    307e:	ff 75 f0             	pushl  -0x10(%ebp)
    3081:	e8 eb 0a 01 00       	call   13b71 <GetHeight>
    3086:	83 c4 10             	add    $0x10,%esp
    3089:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    308c:	8b 55 90             	mov    -0x70(%ebp),%edx
    308f:	8b 45 94             	mov    -0x6c(%ebp),%eax
    3092:	0f af c2             	imul   %edx,%eax
    3095:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    3098:	8b 55 dc             	mov    -0x24(%ebp),%edx
    309b:	89 d0                	mov    %edx,%eax
    309d:	01 c0                	add    %eax,%eax
    309f:	01 d0                	add    %edx,%eax
    30a1:	83 ec 0c             	sub    $0xc,%esp
    30a4:	50                   	push   %eax
    30a5:	e8 9b d6 ff ff       	call   745 <malloc>
    30aa:	83 c4 10             	add    $0x10,%esp
    30ad:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    30b0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    30b7:	e9 9c 00 00 00       	jmp    3158 <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    30bc:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    30bf:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    30c2:	ba 56 55 55 55       	mov    $0x55555556,%edx
    30c7:	89 c8                	mov    %ecx,%eax
    30c9:	f7 ea                	imul   %edx
    30cb:	89 c8                	mov    %ecx,%eax
    30cd:	c1 f8 1f             	sar    $0x1f,%eax
    30d0:	29 c2                	sub    %eax,%edx
    30d2:	89 d0                	mov    %edx,%eax
    30d4:	89 c2                	mov    %eax,%edx
    30d6:	89 d0                	mov    %edx,%eax
    30d8:	01 c0                	add    %eax,%eax
    30da:	01 d0                	add    %edx,%eax
    30dc:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    30df:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    30e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
    30e5:	01 c8                	add    %ecx,%eax
    30e7:	0f b6 00             	movzbl (%eax),%eax
    30ea:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    30ed:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    30f0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    30f3:	ba 56 55 55 55       	mov    $0x55555556,%edx
    30f8:	89 c8                	mov    %ecx,%eax
    30fa:	f7 ea                	imul   %edx
    30fc:	89 c8                	mov    %ecx,%eax
    30fe:	c1 f8 1f             	sar    $0x1f,%eax
    3101:	29 c2                	sub    %eax,%edx
    3103:	89 d0                	mov    %edx,%eax
    3105:	89 c2                	mov    %eax,%edx
    3107:	89 d0                	mov    %edx,%eax
    3109:	01 c0                	add    %eax,%eax
    310b:	01 d0                	add    %edx,%eax
    310d:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3110:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3113:	8d 48 01             	lea    0x1(%eax),%ecx
    3116:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3119:	01 c8                	add    %ecx,%eax
    311b:	0f b6 00             	movzbl (%eax),%eax
    311e:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    3121:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3124:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3127:	ba 56 55 55 55       	mov    $0x55555556,%edx
    312c:	89 c8                	mov    %ecx,%eax
    312e:	f7 ea                	imul   %edx
    3130:	89 c8                	mov    %ecx,%eax
    3132:	c1 f8 1f             	sar    $0x1f,%eax
    3135:	29 c2                	sub    %eax,%edx
    3137:	89 d0                	mov    %edx,%eax
    3139:	89 c2                	mov    %eax,%edx
    313b:	89 d0                	mov    %edx,%eax
    313d:	01 c0                	add    %eax,%eax
    313f:	01 d0                	add    %edx,%eax
    3141:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3144:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3147:	8d 48 02             	lea    0x2(%eax),%ecx
    314a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    314d:	01 c8                	add    %ecx,%eax
    314f:	0f b6 00             	movzbl (%eax),%eax
    3152:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    3154:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    3158:	8b 45 f4             	mov    -0xc(%ebp),%eax
    315b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    315e:	0f 8c 58 ff ff ff    	jl     30bc <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    3164:	8b 45 08             	mov    0x8(%ebp),%eax
    3167:	8b 55 90             	mov    -0x70(%ebp),%edx
    316a:	89 10                	mov    %edx,(%eax)
    316c:	8b 55 94             	mov    -0x6c(%ebp),%edx
    316f:	89 50 04             	mov    %edx,0x4(%eax)
    3172:	8b 55 98             	mov    -0x68(%ebp),%edx
    3175:	89 50 08             	mov    %edx,0x8(%eax)
}
    3178:	8b 45 08             	mov    0x8(%ebp),%eax
    317b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    317e:	c9                   	leave  
    317f:	c2 04 00             	ret    $0x4

00003182 <LoadPng>:

PBitmap LoadPng(char* filename){
    3182:	55                   	push   %ebp
    3183:	89 e5                	mov    %esp,%ebp
    3185:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    3188:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    318f:	ff 75 0c             	pushl  0xc(%ebp)
    3192:	8d 45 e0             	lea    -0x20(%ebp),%eax
    3195:	50                   	push   %eax
    3196:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    3199:	50                   	push   %eax
    319a:	8d 45 e8             	lea    -0x18(%ebp),%eax
    319d:	50                   	push   %eax
    319e:	e8 d3 d3 00 00       	call   10576 <lodepng_decode24_file>
    31a3:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    31a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    31a9:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    31ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    31af:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    31b2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    31b9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    31bc:	8b 45 d8             	mov    -0x28(%ebp),%eax
    31bf:	0f af c2             	imul   %edx,%eax
    31c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    31c5:	8b 55 f0             	mov    -0x10(%ebp),%edx
    31c8:	89 d0                	mov    %edx,%eax
    31ca:	01 c0                	add    %eax,%eax
    31cc:	01 d0                	add    %edx,%eax
    31ce:	83 ec 0c             	sub    $0xc,%esp
    31d1:	50                   	push   %eax
    31d2:	e8 6e d5 ff ff       	call   745 <malloc>
    31d7:	83 c4 10             	add    $0x10,%esp
    31da:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    31dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    31e4:	e9 87 00 00 00       	jmp    3270 <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    31e9:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    31ec:	8b 55 f4             	mov    -0xc(%ebp),%edx
    31ef:	89 d0                	mov    %edx,%eax
    31f1:	01 c0                	add    %eax,%eax
    31f3:	01 d0                	add    %edx,%eax
    31f5:	01 c8                	add    %ecx,%eax
    31f7:	0f b6 00             	movzbl (%eax),%eax
    31fa:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    31fd:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3200:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3203:	89 d0                	mov    %edx,%eax
    3205:	01 c0                	add    %eax,%eax
    3207:	01 d0                	add    %edx,%eax
    3209:	83 c0 01             	add    $0x1,%eax
    320c:	01 c8                	add    %ecx,%eax
    320e:	0f b6 00             	movzbl (%eax),%eax
    3211:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    3214:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3217:	8b 55 f4             	mov    -0xc(%ebp),%edx
    321a:	89 d0                	mov    %edx,%eax
    321c:	01 c0                	add    %eax,%eax
    321e:	01 d0                	add    %edx,%eax
    3220:	83 c0 02             	add    $0x2,%eax
    3223:	01 c8                	add    %ecx,%eax
    3225:	0f b6 00             	movzbl (%eax),%eax
    3228:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    322b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    322e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3231:	89 d0                	mov    %edx,%eax
    3233:	01 c0                	add    %eax,%eax
    3235:	01 d0                	add    %edx,%eax
    3237:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    323a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    323e:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    3241:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3244:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3247:	89 d0                	mov    %edx,%eax
    3249:	01 c0                	add    %eax,%eax
    324b:	01 d0                	add    %edx,%eax
    324d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3250:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    3254:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    3257:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    325a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    325d:	89 d0                	mov    %edx,%eax
    325f:	01 c0                	add    %eax,%eax
    3261:	01 d0                	add    %edx,%eax
    3263:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3266:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    326a:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    326c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3270:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3273:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3276:	0f 8c 6d ff ff ff    	jl     31e9 <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    327c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    327f:	83 ec 0c             	sub    $0xc,%esp
    3282:	50                   	push   %eax
    3283:	e8 7b d3 ff ff       	call   603 <free>
    3288:	83 c4 10             	add    $0x10,%esp
    return bmp;
    328b:	8b 45 08             	mov    0x8(%ebp),%eax
    328e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    3291:	89 10                	mov    %edx,(%eax)
    3293:	8b 55 d8             	mov    -0x28(%ebp),%edx
    3296:	89 50 04             	mov    %edx,0x4(%eax)
    3299:	8b 55 dc             	mov    -0x24(%ebp),%edx
    329c:	89 50 08             	mov    %edx,0x8(%eax)

}
    329f:	8b 45 08             	mov    0x8(%ebp),%eax
    32a2:	c9                   	leave  
    32a3:	c2 04 00             	ret    $0x4

000032a6 <LoadImg>:

PBitmap LoadImg(char* filename){
    32a6:	55                   	push   %ebp
    32a7:	89 e5                	mov    %esp,%ebp
    32a9:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    32ac:	83 ec 0c             	sub    $0xc,%esp
    32af:	ff 75 0c             	pushl  0xc(%ebp)
    32b2:	e8 7c f8 ff ff       	call   2b33 <type>
    32b7:	83 c4 10             	add    $0x10,%esp
    32ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    32bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    32c0:	83 f8 01             	cmp    $0x1,%eax
    32c3:	74 1d                	je     32e2 <LoadImg+0x3c>
    32c5:	83 f8 02             	cmp    $0x2,%eax
    32c8:	74 2c                	je     32f6 <LoadImg+0x50>
    32ca:	85 c0                	test   %eax,%eax
    32cc:	75 3c                	jne    330a <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    32ce:	8b 45 08             	mov    0x8(%ebp),%eax
    32d1:	83 ec 08             	sub    $0x8,%esp
    32d4:	ff 75 0c             	pushl  0xc(%ebp)
    32d7:	50                   	push   %eax
    32d8:	e8 c6 fb ff ff       	call   2ea3 <LoadJpeg>
    32dd:	83 c4 0c             	add    $0xc,%esp
    32e0:	eb 3c                	jmp    331e <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    32e2:	8b 45 08             	mov    0x8(%ebp),%eax
    32e5:	83 ec 08             	sub    $0x8,%esp
    32e8:	ff 75 0c             	pushl  0xc(%ebp)
    32eb:	50                   	push   %eax
    32ec:	e8 17 f9 ff ff       	call   2c08 <LoadBmp>
    32f1:	83 c4 0c             	add    $0xc,%esp
    32f4:	eb 28                	jmp    331e <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    32f6:	8b 45 08             	mov    0x8(%ebp),%eax
    32f9:	83 ec 08             	sub    $0x8,%esp
    32fc:	ff 75 0c             	pushl  0xc(%ebp)
    32ff:	50                   	push   %eax
    3300:	e8 7d fe ff ff       	call   3182 <LoadPng>
    3305:	83 c4 0c             	add    $0xc,%esp
    3308:	eb 14                	jmp    331e <LoadImg+0x78>

        default: return bmp;
    330a:	8b 45 08             	mov    0x8(%ebp),%eax
    330d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    3310:	89 10                	mov    %edx,(%eax)
    3312:	8b 55 ec             	mov    -0x14(%ebp),%edx
    3315:	89 50 04             	mov    %edx,0x4(%eax)
    3318:	8b 55 f0             	mov    -0x10(%ebp),%edx
    331b:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    331e:	8b 45 08             	mov    0x8(%ebp),%eax
    3321:	c9                   	leave  
    3322:	c2 04 00             	ret    $0x4

00003325 <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    3325:	55                   	push   %ebp
    3326:	89 e5                	mov    %esp,%ebp
    3328:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    332b:	8b 45 08             	mov    0x8(%ebp),%eax
    332e:	83 ec 0c             	sub    $0xc,%esp
    3331:	50                   	push   %eax
    3332:	e8 0e d4 ff ff       	call   745 <malloc>
    3337:	83 c4 10             	add    $0x10,%esp
}
    333a:	c9                   	leave  
    333b:	c3                   	ret    

0000333c <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    333c:	55                   	push   %ebp
    333d:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    333f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3344:	5d                   	pop    %ebp
    3345:	c3                   	ret    

00003346 <lodepng_free>:

static void lodepng_free(void* ptr) {
    3346:	55                   	push   %ebp
    3347:	89 e5                	mov    %esp,%ebp
    3349:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    334c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    3350:	74 0e                	je     3360 <lodepng_free+0x1a>
    free(ptr);
    3352:	83 ec 0c             	sub    $0xc,%esp
    3355:	ff 75 08             	pushl  0x8(%ebp)
    3358:	e8 a6 d2 ff ff       	call   603 <free>
    335d:	83 c4 10             	add    $0x10,%esp
}
    3360:	90                   	nop
    3361:	c9                   	leave  
    3362:	c3                   	ret    

00003363 <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    3363:	55                   	push   %ebp
    3364:	89 e5                	mov    %esp,%ebp
    3366:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    3369:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3370:	eb 19                	jmp    338b <lodepng_memcpy+0x28>
    3372:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3375:	8b 45 08             	mov    0x8(%ebp),%eax
    3378:	01 c2                	add    %eax,%edx
    337a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    337d:	8b 45 0c             	mov    0xc(%ebp),%eax
    3380:	01 c8                	add    %ecx,%eax
    3382:	0f b6 00             	movzbl (%eax),%eax
    3385:	88 02                	mov    %al,(%edx)
    3387:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    338b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    338e:	3b 45 10             	cmp    0x10(%ebp),%eax
    3391:	7c df                	jl     3372 <lodepng_memcpy+0xf>
}
    3393:	90                   	nop
    3394:	c9                   	leave  
    3395:	c3                   	ret    

00003396 <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    3396:	55                   	push   %ebp
    3397:	89 e5                	mov    %esp,%ebp
    3399:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    339c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    33a3:	eb 11                	jmp    33b6 <lodepng_memset+0x20>
    33a5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    33a8:	8b 45 08             	mov    0x8(%ebp),%eax
    33ab:	01 d0                	add    %edx,%eax
    33ad:	8b 55 0c             	mov    0xc(%ebp),%edx
    33b0:	88 10                	mov    %dl,(%eax)
    33b2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    33b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    33b9:	3b 45 10             	cmp    0x10(%ebp),%eax
    33bc:	7c e7                	jl     33a5 <lodepng_memset+0xf>
}
    33be:	90                   	nop
    33bf:	c9                   	leave  
    33c0:	c3                   	ret    

000033c1 <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    33c1:	55                   	push   %ebp
    33c2:	89 e5                	mov    %esp,%ebp
    33c4:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    33c7:	8b 45 08             	mov    0x8(%ebp),%eax
    33ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    33cd:	eb 04                	jmp    33d3 <lodepng_strlen+0x12>
    33cf:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    33d3:	8b 45 08             	mov    0x8(%ebp),%eax
    33d6:	0f b6 00             	movzbl (%eax),%eax
    33d9:	84 c0                	test   %al,%al
    33db:	75 f2                	jne    33cf <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    33dd:	8b 55 08             	mov    0x8(%ebp),%edx
    33e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    33e3:	29 c2                	sub    %eax,%edx
    33e5:	89 d0                	mov    %edx,%eax
}
    33e7:	c9                   	leave  
    33e8:	c3                   	ret    

000033e9 <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    33e9:	55                   	push   %ebp
    33ea:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    33ec:	8b 55 08             	mov    0x8(%ebp),%edx
    33ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    33f2:	01 c2                	add    %eax,%edx
    33f4:	8b 45 10             	mov    0x10(%ebp),%eax
    33f7:	89 10                	mov    %edx,(%eax)
  return *result < a;
    33f9:	8b 45 10             	mov    0x10(%ebp),%eax
    33fc:	8b 00                	mov    (%eax),%eax
    33fe:	3b 45 08             	cmp    0x8(%ebp),%eax
    3401:	0f 9c c0             	setl   %al
    3404:	0f b6 c0             	movzbl %al,%eax
}
    3407:	5d                   	pop    %ebp
    3408:	c3                   	ret    

00003409 <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    3409:	55                   	push   %ebp
    340a:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    340c:	8b 45 08             	mov    0x8(%ebp),%eax
    340f:	0f af 45 0c          	imul   0xc(%ebp),%eax
    3413:	89 c2                	mov    %eax,%edx
    3415:	8b 45 10             	mov    0x10(%ebp),%eax
    3418:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    341a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    341e:	74 15                	je     3435 <lodepng_mulofl+0x2c>
    3420:	8b 45 10             	mov    0x10(%ebp),%eax
    3423:	8b 00                	mov    (%eax),%eax
    3425:	99                   	cltd   
    3426:	f7 7d 08             	idivl  0x8(%ebp)
    3429:	3b 45 0c             	cmp    0xc(%ebp),%eax
    342c:	74 07                	je     3435 <lodepng_mulofl+0x2c>
    342e:	b8 01 00 00 00       	mov    $0x1,%eax
    3433:	eb 05                	jmp    343a <lodepng_mulofl+0x31>
    3435:	b8 00 00 00 00       	mov    $0x0,%eax
}
    343a:	5d                   	pop    %ebp
    343b:	c3                   	ret    

0000343c <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    343c:	55                   	push   %ebp
    343d:	89 e5                	mov    %esp,%ebp
    343f:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    3442:	8d 45 fc             	lea    -0x4(%ebp),%eax
    3445:	50                   	push   %eax
    3446:	ff 75 0c             	pushl  0xc(%ebp)
    3449:	ff 75 08             	pushl  0x8(%ebp)
    344c:	e8 98 ff ff ff       	call   33e9 <lodepng_addofl>
    3451:	83 c4 0c             	add    $0xc,%esp
    3454:	85 c0                	test   %eax,%eax
    3456:	74 07                	je     345f <lodepng_gtofl+0x23>
    3458:	b8 01 00 00 00       	mov    $0x1,%eax
    345d:	eb 0c                	jmp    346b <lodepng_gtofl+0x2f>
  return d > c;
    345f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3462:	3b 45 10             	cmp    0x10(%ebp),%eax
    3465:	0f 9f c0             	setg   %al
    3468:	0f b6 c0             	movzbl %al,%eax
}
    346b:	c9                   	leave  
    346c:	c3                   	ret    

0000346d <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    346d:	55                   	push   %ebp
    346e:	89 e5                	mov    %esp,%ebp
    3470:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    3473:	8b 45 08             	mov    0x8(%ebp),%eax
    3476:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    347d:	8b 45 08             	mov    0x8(%ebp),%eax
    3480:	8b 50 08             	mov    0x8(%eax),%edx
    3483:	8b 45 08             	mov    0x8(%ebp),%eax
    3486:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    3489:	8b 45 08             	mov    0x8(%ebp),%eax
    348c:	8b 00                	mov    (%eax),%eax
    348e:	83 ec 0c             	sub    $0xc,%esp
    3491:	50                   	push   %eax
    3492:	e8 af fe ff ff       	call   3346 <lodepng_free>
    3497:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    349a:	8b 45 08             	mov    0x8(%ebp),%eax
    349d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    34a3:	90                   	nop
    34a4:	c9                   	leave  
    34a5:	c3                   	ret    

000034a6 <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    34a6:	55                   	push   %ebp
    34a7:	89 e5                	mov    %esp,%ebp
    34a9:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    34ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    34af:	c1 e0 02             	shl    $0x2,%eax
    34b2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    34b5:	8b 45 08             	mov    0x8(%ebp),%eax
    34b8:	8b 40 08             	mov    0x8(%eax),%eax
    34bb:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    34be:	7d 46                	jge    3506 <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    34c0:	8b 45 08             	mov    0x8(%ebp),%eax
    34c3:	8b 40 08             	mov    0x8(%eax),%eax
    34c6:	d1 f8                	sar    %eax
    34c8:	89 c2                	mov    %eax,%edx
    34ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
    34cd:	01 d0                	add    %edx,%eax
    34cf:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    34d2:	8b 45 08             	mov    0x8(%ebp),%eax
    34d5:	8b 00                	mov    (%eax),%eax
    34d7:	ff 75 f8             	pushl  -0x8(%ebp)
    34da:	50                   	push   %eax
    34db:	e8 5c fe ff ff       	call   333c <lodepng_realloc>
    34e0:	83 c4 08             	add    $0x8,%esp
    34e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    34e6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    34ea:	74 13                	je     34ff <uivector_resize+0x59>
      p->allocsize = newsize;
    34ec:	8b 45 08             	mov    0x8(%ebp),%eax
    34ef:	8b 55 f8             	mov    -0x8(%ebp),%edx
    34f2:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    34f5:	8b 45 08             	mov    0x8(%ebp),%eax
    34f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    34fb:	89 10                	mov    %edx,(%eax)
    34fd:	eb 07                	jmp    3506 <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    34ff:	b8 00 00 00 00       	mov    $0x0,%eax
    3504:	eb 0e                	jmp    3514 <uivector_resize+0x6e>
  }
  p->size = size;
    3506:	8b 45 08             	mov    0x8(%ebp),%eax
    3509:	8b 55 0c             	mov    0xc(%ebp),%edx
    350c:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    350f:	b8 01 00 00 00       	mov    $0x1,%eax
}
    3514:	c9                   	leave  
    3515:	c3                   	ret    

00003516 <uivector_init>:

static void uivector_init(uivector* p) {
    3516:	55                   	push   %ebp
    3517:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    3519:	8b 45 08             	mov    0x8(%ebp),%eax
    351c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    3522:	8b 45 08             	mov    0x8(%ebp),%eax
    3525:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    352c:	8b 45 08             	mov    0x8(%ebp),%eax
    352f:	8b 50 08             	mov    0x8(%eax),%edx
    3532:	8b 45 08             	mov    0x8(%ebp),%eax
    3535:	89 50 04             	mov    %edx,0x4(%eax)
}
    3538:	90                   	nop
    3539:	5d                   	pop    %ebp
    353a:	c3                   	ret    

0000353b <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    353b:	55                   	push   %ebp
    353c:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    353e:	8b 45 08             	mov    0x8(%ebp),%eax
    3541:	8b 40 04             	mov    0x4(%eax),%eax
    3544:	83 c0 01             	add    $0x1,%eax
    3547:	50                   	push   %eax
    3548:	ff 75 08             	pushl  0x8(%ebp)
    354b:	e8 56 ff ff ff       	call   34a6 <uivector_resize>
    3550:	83 c4 08             	add    $0x8,%esp
    3553:	85 c0                	test   %eax,%eax
    3555:	75 07                	jne    355e <uivector_push_back+0x23>
    3557:	b8 00 00 00 00       	mov    $0x0,%eax
    355c:	eb 1f                	jmp    357d <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    355e:	8b 45 08             	mov    0x8(%ebp),%eax
    3561:	8b 10                	mov    (%eax),%edx
    3563:	8b 45 08             	mov    0x8(%ebp),%eax
    3566:	8b 40 04             	mov    0x4(%eax),%eax
    3569:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    356e:	c1 e0 02             	shl    $0x2,%eax
    3571:	01 c2                	add    %eax,%edx
    3573:	8b 45 0c             	mov    0xc(%ebp),%eax
    3576:	89 02                	mov    %eax,(%edx)
  return 1;
    3578:	b8 01 00 00 00       	mov    $0x1,%eax
}
    357d:	c9                   	leave  
    357e:	c3                   	ret    

0000357f <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    357f:	55                   	push   %ebp
    3580:	89 e5                	mov    %esp,%ebp
    3582:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    3585:	8b 45 08             	mov    0x8(%ebp),%eax
    3588:	8b 40 08             	mov    0x8(%eax),%eax
    358b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    358e:	7d 46                	jge    35d6 <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    3590:	8b 45 08             	mov    0x8(%ebp),%eax
    3593:	8b 40 08             	mov    0x8(%eax),%eax
    3596:	d1 f8                	sar    %eax
    3598:	89 c2                	mov    %eax,%edx
    359a:	8b 45 0c             	mov    0xc(%ebp),%eax
    359d:	01 d0                	add    %edx,%eax
    359f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    35a2:	8b 45 08             	mov    0x8(%ebp),%eax
    35a5:	8b 00                	mov    (%eax),%eax
    35a7:	ff 75 fc             	pushl  -0x4(%ebp)
    35aa:	50                   	push   %eax
    35ab:	e8 8c fd ff ff       	call   333c <lodepng_realloc>
    35b0:	83 c4 08             	add    $0x8,%esp
    35b3:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    35b6:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    35ba:	74 13                	je     35cf <ucvector_resize+0x50>
      p->allocsize = newsize;
    35bc:	8b 45 08             	mov    0x8(%ebp),%eax
    35bf:	8b 55 fc             	mov    -0x4(%ebp),%edx
    35c2:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    35c5:	8b 45 08             	mov    0x8(%ebp),%eax
    35c8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    35cb:	89 10                	mov    %edx,(%eax)
    35cd:	eb 07                	jmp    35d6 <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    35cf:	b8 00 00 00 00       	mov    $0x0,%eax
    35d4:	eb 0e                	jmp    35e4 <ucvector_resize+0x65>
  }
  p->size = size;
    35d6:	8b 45 08             	mov    0x8(%ebp),%eax
    35d9:	8b 55 0c             	mov    0xc(%ebp),%edx
    35dc:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    35df:	b8 01 00 00 00       	mov    $0x1,%eax
}
    35e4:	c9                   	leave  
    35e5:	c3                   	ret    

000035e6 <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    35e6:	55                   	push   %ebp
    35e7:	89 e5                	mov    %esp,%ebp
    35e9:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    35ec:	8b 45 0c             	mov    0xc(%ebp),%eax
    35ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    35f2:	8b 45 10             	mov    0x10(%ebp),%eax
    35f5:	89 45 f8             	mov    %eax,-0x8(%ebp)
    35f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    35fb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    35fe:	8b 45 08             	mov    0x8(%ebp),%eax
    3601:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3604:	89 10                	mov    %edx,(%eax)
    3606:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3609:	89 50 04             	mov    %edx,0x4(%eax)
    360c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    360f:	89 50 08             	mov    %edx,0x8(%eax)
}
    3612:	8b 45 08             	mov    0x8(%ebp),%eax
    3615:	c9                   	leave  
    3616:	c2 04 00             	ret    $0x4

00003619 <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    3619:	55                   	push   %ebp
    361a:	89 e5                	mov    %esp,%ebp
    361c:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    361f:	8b 45 08             	mov    0x8(%ebp),%eax
    3622:	8b 00                	mov    (%eax),%eax
    3624:	83 ec 0c             	sub    $0xc,%esp
    3627:	50                   	push   %eax
    3628:	e8 19 fd ff ff       	call   3346 <lodepng_free>
    362d:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    3630:	8b 45 08             	mov    0x8(%ebp),%eax
    3633:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3639:	90                   	nop
    363a:	c9                   	leave  
    363b:	c3                   	ret    

0000363c <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    363c:	55                   	push   %ebp
    363d:	89 e5                	mov    %esp,%ebp
    363f:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    3642:	8b 45 0c             	mov    0xc(%ebp),%eax
    3645:	83 c0 01             	add    $0x1,%eax
    3648:	83 ec 0c             	sub    $0xc,%esp
    364b:	50                   	push   %eax
    364c:	e8 d4 fc ff ff       	call   3325 <lodepng_malloc>
    3651:	83 c4 10             	add    $0x10,%esp
    3654:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    3657:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    365b:	74 1f                	je     367c <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    365d:	83 ec 04             	sub    $0x4,%esp
    3660:	ff 75 0c             	pushl  0xc(%ebp)
    3663:	ff 75 08             	pushl  0x8(%ebp)
    3666:	ff 75 f4             	pushl  -0xc(%ebp)
    3669:	e8 f5 fc ff ff       	call   3363 <lodepng_memcpy>
    366e:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    3671:	8b 55 0c             	mov    0xc(%ebp),%edx
    3674:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3677:	01 d0                	add    %edx,%eax
    3679:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    367c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    367f:	c9                   	leave  
    3680:	c3                   	ret    

00003681 <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    3681:	55                   	push   %ebp
    3682:	89 e5                	mov    %esp,%ebp
    3684:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    3687:	ff 75 08             	pushl  0x8(%ebp)
    368a:	e8 32 fd ff ff       	call   33c1 <lodepng_strlen>
    368f:	83 c4 04             	add    $0x4,%esp
    3692:	83 ec 08             	sub    $0x8,%esp
    3695:	50                   	push   %eax
    3696:	ff 75 08             	pushl  0x8(%ebp)
    3699:	e8 9e ff ff ff       	call   363c <alloc_string_sized>
    369e:	83 c4 10             	add    $0x10,%esp
}
    36a1:	c9                   	leave  
    36a2:	c3                   	ret    

000036a3 <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    36a3:	55                   	push   %ebp
    36a4:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    36a6:	8b 45 08             	mov    0x8(%ebp),%eax
    36a9:	0f b6 00             	movzbl (%eax),%eax
    36ac:	0f b6 c0             	movzbl %al,%eax
    36af:	c1 e0 18             	shl    $0x18,%eax
    36b2:	89 c2                	mov    %eax,%edx
    36b4:	8b 45 08             	mov    0x8(%ebp),%eax
    36b7:	83 c0 01             	add    $0x1,%eax
    36ba:	0f b6 00             	movzbl (%eax),%eax
    36bd:	0f b6 c0             	movzbl %al,%eax
    36c0:	c1 e0 10             	shl    $0x10,%eax
    36c3:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    36c5:	8b 45 08             	mov    0x8(%ebp),%eax
    36c8:	83 c0 02             	add    $0x2,%eax
    36cb:	0f b6 00             	movzbl (%eax),%eax
    36ce:	0f b6 c0             	movzbl %al,%eax
    36d1:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    36d4:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    36d6:	8b 45 08             	mov    0x8(%ebp),%eax
    36d9:	83 c0 03             	add    $0x3,%eax
    36dc:	0f b6 00             	movzbl (%eax),%eax
    36df:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    36e2:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    36e4:	5d                   	pop    %ebp
    36e5:	c3                   	ret    

000036e6 <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    36e6:	55                   	push   %ebp
    36e7:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    36e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    36ec:	c1 e8 18             	shr    $0x18,%eax
    36ef:	89 c2                	mov    %eax,%edx
    36f1:	8b 45 08             	mov    0x8(%ebp),%eax
    36f4:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    36f6:	8b 45 08             	mov    0x8(%ebp),%eax
    36f9:	83 c0 01             	add    $0x1,%eax
    36fc:	8b 55 0c             	mov    0xc(%ebp),%edx
    36ff:	c1 ea 10             	shr    $0x10,%edx
    3702:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    3704:	8b 45 08             	mov    0x8(%ebp),%eax
    3707:	83 c0 02             	add    $0x2,%eax
    370a:	8b 55 0c             	mov    0xc(%ebp),%edx
    370d:	c1 ea 08             	shr    $0x8,%edx
    3710:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    3712:	8b 45 08             	mov    0x8(%ebp),%eax
    3715:	83 c0 03             	add    $0x3,%eax
    3718:	8b 55 0c             	mov    0xc(%ebp),%edx
    371b:	88 10                	mov    %dl,(%eax)
}
    371d:	90                   	nop
    371e:	5d                   	pop    %ebp
    371f:	c3                   	ret    

00003720 <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    3720:	55                   	push   %ebp
    3721:	89 e5                	mov    %esp,%ebp
    3723:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    3726:	83 ec 08             	sub    $0x8,%esp
    3729:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    372c:	50                   	push   %eax
    372d:	ff 75 08             	pushl  0x8(%ebp)
    3730:	e8 b7 ca ff ff       	call   1ec <stat>
    3735:	83 c4 10             	add    $0x10,%esp
  return s.size;
    3738:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    373b:	c9                   	leave  
    373c:	c3                   	ret    

0000373d <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    373d:	55                   	push   %ebp
    373e:	89 e5                	mov    %esp,%ebp
    3740:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    3743:	83 ec 08             	sub    $0x8,%esp
    3746:	6a 00                	push   $0x0
    3748:	ff 75 10             	pushl  0x10(%ebp)
    374b:	e8 bb cb ff ff       	call   30b <open>
    3750:	83 c4 10             	add    $0x10,%esp
    3753:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    3756:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    375a:	79 07                	jns    3763 <lodepng_buffer_file+0x26>
  {
      return -1;
    375c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    3761:	eb 19                	jmp    377c <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    3763:	83 ec 04             	sub    $0x4,%esp
    3766:	ff 75 0c             	pushl  0xc(%ebp)
    3769:	ff 75 08             	pushl  0x8(%ebp)
    376c:	ff 75 f4             	pushl  -0xc(%ebp)
    376f:	e8 6f cb ff ff       	call   2e3 <read>
    3774:	83 c4 10             	add    $0x10,%esp
  return 0;
    3777:	b8 00 00 00 00       	mov    $0x0,%eax
}
    377c:	c9                   	leave  
    377d:	c3                   	ret    

0000377e <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    377e:	55                   	push   %ebp
    377f:	89 e5                	mov    %esp,%ebp
    3781:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    3784:	83 ec 0c             	sub    $0xc,%esp
    3787:	ff 75 10             	pushl  0x10(%ebp)
    378a:	e8 91 ff ff ff       	call   3720 <lodepng_filesize>
    378f:	83 c4 10             	add    $0x10,%esp
    3792:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    3795:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3799:	79 07                	jns    37a2 <lodepng_load_file+0x24>
    379b:	b8 4e 00 00 00       	mov    $0x4e,%eax
    37a0:	eb 4a                	jmp    37ec <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    37a2:	8b 45 0c             	mov    0xc(%ebp),%eax
    37a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    37a8:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    37aa:	83 ec 0c             	sub    $0xc,%esp
    37ad:	ff 75 f4             	pushl  -0xc(%ebp)
    37b0:	e8 70 fb ff ff       	call   3325 <lodepng_malloc>
    37b5:	83 c4 10             	add    $0x10,%esp
    37b8:	89 c2                	mov    %eax,%edx
    37ba:	8b 45 08             	mov    0x8(%ebp),%eax
    37bd:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    37bf:	8b 45 08             	mov    0x8(%ebp),%eax
    37c2:	8b 00                	mov    (%eax),%eax
    37c4:	85 c0                	test   %eax,%eax
    37c6:	75 0d                	jne    37d5 <lodepng_load_file+0x57>
    37c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    37cc:	7e 07                	jle    37d5 <lodepng_load_file+0x57>
    37ce:	b8 53 00 00 00       	mov    $0x53,%eax
    37d3:	eb 17                	jmp    37ec <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    37d5:	8b 45 08             	mov    0x8(%ebp),%eax
    37d8:	8b 00                	mov    (%eax),%eax
    37da:	83 ec 04             	sub    $0x4,%esp
    37dd:	ff 75 10             	pushl  0x10(%ebp)
    37e0:	ff 75 f4             	pushl  -0xc(%ebp)
    37e3:	50                   	push   %eax
    37e4:	e8 54 ff ff ff       	call   373d <lodepng_buffer_file>
    37e9:	83 c4 10             	add    $0x10,%esp
}
    37ec:	c9                   	leave  
    37ed:	c3                   	ret    

000037ee <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    37ee:	55                   	push   %ebp
    37ef:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    37f1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    37f6:	5d                   	pop    %ebp
    37f7:	c3                   	ret    

000037f8 <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    37f8:	55                   	push   %ebp
    37f9:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    37fb:	8b 45 08             	mov    0x8(%ebp),%eax
    37fe:	8b 55 0c             	mov    0xc(%ebp),%edx
    3801:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    3803:	8b 45 08             	mov    0x8(%ebp),%eax
    3806:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    380a:	90                   	nop
    380b:	5d                   	pop    %ebp
    380c:	c3                   	ret    

0000380d <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    380d:	55                   	push   %ebp
    380e:	89 e5                	mov    %esp,%ebp
    3810:	56                   	push   %esi
    3811:	53                   	push   %ebx
    3812:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    3815:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    3819:	0f 85 aa 00 00 00    	jne    38c9 <writeBits+0xbc>
    WRITEBIT(writer, value);
    381f:	8b 45 08             	mov    0x8(%ebp),%eax
    3822:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3826:	0f b6 c0             	movzbl %al,%eax
    3829:	83 e0 07             	and    $0x7,%eax
    382c:	85 c0                	test   %eax,%eax
    382e:	75 39                	jne    3869 <writeBits+0x5c>
    3830:	8b 45 08             	mov    0x8(%ebp),%eax
    3833:	8b 00                	mov    (%eax),%eax
    3835:	8b 40 04             	mov    0x4(%eax),%eax
    3838:	8d 50 01             	lea    0x1(%eax),%edx
    383b:	8b 45 08             	mov    0x8(%ebp),%eax
    383e:	8b 00                	mov    (%eax),%eax
    3840:	52                   	push   %edx
    3841:	50                   	push   %eax
    3842:	e8 38 fd ff ff       	call   357f <ucvector_resize>
    3847:	83 c4 08             	add    $0x8,%esp
    384a:	85 c0                	test   %eax,%eax
    384c:	0f 84 44 01 00 00    	je     3996 <writeBits+0x189>
    3852:	8b 45 08             	mov    0x8(%ebp),%eax
    3855:	8b 00                	mov    (%eax),%eax
    3857:	8b 10                	mov    (%eax),%edx
    3859:	8b 45 08             	mov    0x8(%ebp),%eax
    385c:	8b 00                	mov    (%eax),%eax
    385e:	8b 40 04             	mov    0x4(%eax),%eax
    3861:	83 e8 01             	sub    $0x1,%eax
    3864:	01 d0                	add    %edx,%eax
    3866:	c6 00 00             	movb   $0x0,(%eax)
    3869:	8b 45 08             	mov    0x8(%ebp),%eax
    386c:	8b 00                	mov    (%eax),%eax
    386e:	8b 10                	mov    (%eax),%edx
    3870:	8b 45 08             	mov    0x8(%ebp),%eax
    3873:	8b 00                	mov    (%eax),%eax
    3875:	8b 40 04             	mov    0x4(%eax),%eax
    3878:	83 e8 01             	sub    $0x1,%eax
    387b:	01 c2                	add    %eax,%edx
    387d:	8b 45 08             	mov    0x8(%ebp),%eax
    3880:	8b 00                	mov    (%eax),%eax
    3882:	8b 08                	mov    (%eax),%ecx
    3884:	8b 45 08             	mov    0x8(%ebp),%eax
    3887:	8b 00                	mov    (%eax),%eax
    3889:	8b 40 04             	mov    0x4(%eax),%eax
    388c:	83 e8 01             	sub    $0x1,%eax
    388f:	01 c8                	add    %ecx,%eax
    3891:	0f b6 00             	movzbl (%eax),%eax
    3894:	88 45 e7             	mov    %al,-0x19(%ebp)
    3897:	8b 45 08             	mov    0x8(%ebp),%eax
    389a:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    389e:	0f b6 c0             	movzbl %al,%eax
    38a1:	83 e0 07             	and    $0x7,%eax
    38a4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    38a7:	89 de                	mov    %ebx,%esi
    38a9:	89 c1                	mov    %eax,%ecx
    38ab:	d3 e6                	shl    %cl,%esi
    38ad:	89 f0                	mov    %esi,%eax
    38af:	0a 45 e7             	or     -0x19(%ebp),%al
    38b2:	88 02                	mov    %al,(%edx)
    38b4:	8b 45 08             	mov    0x8(%ebp),%eax
    38b7:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    38bb:	8d 50 01             	lea    0x1(%eax),%edx
    38be:	8b 45 08             	mov    0x8(%ebp),%eax
    38c1:	88 50 04             	mov    %dl,0x4(%eax)
    38c4:	e9 d1 00 00 00       	jmp    399a <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    38c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    38d0:	e9 b3 00 00 00       	jmp    3988 <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    38d5:	8b 45 08             	mov    0x8(%ebp),%eax
    38d8:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    38dc:	0f b6 c0             	movzbl %al,%eax
    38df:	83 e0 07             	and    $0x7,%eax
    38e2:	85 c0                	test   %eax,%eax
    38e4:	75 39                	jne    391f <writeBits+0x112>
    38e6:	8b 45 08             	mov    0x8(%ebp),%eax
    38e9:	8b 00                	mov    (%eax),%eax
    38eb:	8b 40 04             	mov    0x4(%eax),%eax
    38ee:	8d 50 01             	lea    0x1(%eax),%edx
    38f1:	8b 45 08             	mov    0x8(%ebp),%eax
    38f4:	8b 00                	mov    (%eax),%eax
    38f6:	52                   	push   %edx
    38f7:	50                   	push   %eax
    38f8:	e8 82 fc ff ff       	call   357f <ucvector_resize>
    38fd:	83 c4 08             	add    $0x8,%esp
    3900:	85 c0                	test   %eax,%eax
    3902:	0f 84 91 00 00 00    	je     3999 <writeBits+0x18c>
    3908:	8b 45 08             	mov    0x8(%ebp),%eax
    390b:	8b 00                	mov    (%eax),%eax
    390d:	8b 10                	mov    (%eax),%edx
    390f:	8b 45 08             	mov    0x8(%ebp),%eax
    3912:	8b 00                	mov    (%eax),%eax
    3914:	8b 40 04             	mov    0x4(%eax),%eax
    3917:	83 e8 01             	sub    $0x1,%eax
    391a:	01 d0                	add    %edx,%eax
    391c:	c6 00 00             	movb   $0x0,(%eax)
    391f:	8b 45 08             	mov    0x8(%ebp),%eax
    3922:	8b 00                	mov    (%eax),%eax
    3924:	8b 10                	mov    (%eax),%edx
    3926:	8b 45 08             	mov    0x8(%ebp),%eax
    3929:	8b 00                	mov    (%eax),%eax
    392b:	8b 40 04             	mov    0x4(%eax),%eax
    392e:	83 e8 01             	sub    $0x1,%eax
    3931:	01 c2                	add    %eax,%edx
    3933:	8b 45 08             	mov    0x8(%ebp),%eax
    3936:	8b 00                	mov    (%eax),%eax
    3938:	8b 08                	mov    (%eax),%ecx
    393a:	8b 45 08             	mov    0x8(%ebp),%eax
    393d:	8b 00                	mov    (%eax),%eax
    393f:	8b 40 04             	mov    0x4(%eax),%eax
    3942:	83 e8 01             	sub    $0x1,%eax
    3945:	01 c8                	add    %ecx,%eax
    3947:	0f b6 00             	movzbl (%eax),%eax
    394a:	89 c6                	mov    %eax,%esi
    394c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    394f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3952:	89 c1                	mov    %eax,%ecx
    3954:	d3 eb                	shr    %cl,%ebx
    3956:	89 d8                	mov    %ebx,%eax
    3958:	83 e0 01             	and    $0x1,%eax
    395b:	89 c3                	mov    %eax,%ebx
    395d:	8b 45 08             	mov    0x8(%ebp),%eax
    3960:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3964:	0f b6 c0             	movzbl %al,%eax
    3967:	83 e0 07             	and    $0x7,%eax
    396a:	89 c1                	mov    %eax,%ecx
    396c:	d3 e3                	shl    %cl,%ebx
    396e:	89 d8                	mov    %ebx,%eax
    3970:	09 f0                	or     %esi,%eax
    3972:	88 02                	mov    %al,(%edx)
    3974:	8b 45 08             	mov    0x8(%ebp),%eax
    3977:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    397b:	8d 50 01             	lea    0x1(%eax),%edx
    397e:	8b 45 08             	mov    0x8(%ebp),%eax
    3981:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3984:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3988:	8b 45 f4             	mov    -0xc(%ebp),%eax
    398b:	3b 45 10             	cmp    0x10(%ebp),%eax
    398e:	0f 85 41 ff ff ff    	jne    38d5 <writeBits+0xc8>
    3994:	eb 04                	jmp    399a <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    3996:	90                   	nop
    3997:	eb 01                	jmp    399a <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3999:	90                   	nop
    }
  }
}
    399a:	8d 65 f8             	lea    -0x8(%ebp),%esp
    399d:	5b                   	pop    %ebx
    399e:	5e                   	pop    %esi
    399f:	5d                   	pop    %ebp
    39a0:	c3                   	ret    

000039a1 <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    39a1:	55                   	push   %ebp
    39a2:	89 e5                	mov    %esp,%ebp
    39a4:	56                   	push   %esi
    39a5:	53                   	push   %ebx
    39a6:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    39a9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    39b0:	e9 bd 00 00 00       	jmp    3a72 <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    39b5:	8b 45 08             	mov    0x8(%ebp),%eax
    39b8:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    39bc:	0f b6 c0             	movzbl %al,%eax
    39bf:	83 e0 07             	and    $0x7,%eax
    39c2:	85 c0                	test   %eax,%eax
    39c4:	75 39                	jne    39ff <writeBitsReversed+0x5e>
    39c6:	8b 45 08             	mov    0x8(%ebp),%eax
    39c9:	8b 00                	mov    (%eax),%eax
    39cb:	8b 40 04             	mov    0x4(%eax),%eax
    39ce:	8d 50 01             	lea    0x1(%eax),%edx
    39d1:	8b 45 08             	mov    0x8(%ebp),%eax
    39d4:	8b 00                	mov    (%eax),%eax
    39d6:	52                   	push   %edx
    39d7:	50                   	push   %eax
    39d8:	e8 a2 fb ff ff       	call   357f <ucvector_resize>
    39dd:	83 c4 08             	add    $0x8,%esp
    39e0:	85 c0                	test   %eax,%eax
    39e2:	0f 84 98 00 00 00    	je     3a80 <writeBitsReversed+0xdf>
    39e8:	8b 45 08             	mov    0x8(%ebp),%eax
    39eb:	8b 00                	mov    (%eax),%eax
    39ed:	8b 10                	mov    (%eax),%edx
    39ef:	8b 45 08             	mov    0x8(%ebp),%eax
    39f2:	8b 00                	mov    (%eax),%eax
    39f4:	8b 40 04             	mov    0x4(%eax),%eax
    39f7:	83 e8 01             	sub    $0x1,%eax
    39fa:	01 d0                	add    %edx,%eax
    39fc:	c6 00 00             	movb   $0x0,(%eax)
    39ff:	8b 45 08             	mov    0x8(%ebp),%eax
    3a02:	8b 00                	mov    (%eax),%eax
    3a04:	8b 10                	mov    (%eax),%edx
    3a06:	8b 45 08             	mov    0x8(%ebp),%eax
    3a09:	8b 00                	mov    (%eax),%eax
    3a0b:	8b 40 04             	mov    0x4(%eax),%eax
    3a0e:	83 e8 01             	sub    $0x1,%eax
    3a11:	01 c2                	add    %eax,%edx
    3a13:	8b 45 08             	mov    0x8(%ebp),%eax
    3a16:	8b 00                	mov    (%eax),%eax
    3a18:	8b 08                	mov    (%eax),%ecx
    3a1a:	8b 45 08             	mov    0x8(%ebp),%eax
    3a1d:	8b 00                	mov    (%eax),%eax
    3a1f:	8b 40 04             	mov    0x4(%eax),%eax
    3a22:	83 e8 01             	sub    $0x1,%eax
    3a25:	01 c8                	add    %ecx,%eax
    3a27:	0f b6 00             	movzbl (%eax),%eax
    3a2a:	89 c6                	mov    %eax,%esi
    3a2c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    3a2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a32:	29 c1                	sub    %eax,%ecx
    3a34:	89 c8                	mov    %ecx,%eax
    3a36:	83 e8 01             	sub    $0x1,%eax
    3a39:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3a3c:	89 c1                	mov    %eax,%ecx
    3a3e:	d3 eb                	shr    %cl,%ebx
    3a40:	89 d8                	mov    %ebx,%eax
    3a42:	83 e0 01             	and    $0x1,%eax
    3a45:	89 c3                	mov    %eax,%ebx
    3a47:	8b 45 08             	mov    0x8(%ebp),%eax
    3a4a:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a4e:	0f b6 c0             	movzbl %al,%eax
    3a51:	83 e0 07             	and    $0x7,%eax
    3a54:	89 c1                	mov    %eax,%ecx
    3a56:	d3 e3                	shl    %cl,%ebx
    3a58:	89 d8                	mov    %ebx,%eax
    3a5a:	09 f0                	or     %esi,%eax
    3a5c:	88 02                	mov    %al,(%edx)
    3a5e:	8b 45 08             	mov    0x8(%ebp),%eax
    3a61:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a65:	8d 50 01             	lea    0x1(%eax),%edx
    3a68:	8b 45 08             	mov    0x8(%ebp),%eax
    3a6b:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3a6e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3a72:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a75:	3b 45 10             	cmp    0x10(%ebp),%eax
    3a78:	0f 85 37 ff ff ff    	jne    39b5 <writeBitsReversed+0x14>
    3a7e:	eb 01                	jmp    3a81 <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3a80:	90                   	nop
  }
}
    3a81:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3a84:	5b                   	pop    %ebx
    3a85:	5e                   	pop    %esi
    3a86:	5d                   	pop    %ebp
    3a87:	c3                   	ret    

00003a88 <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    3a88:	55                   	push   %ebp
    3a89:	89 e5                	mov    %esp,%ebp
    3a8b:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    3a8e:	8b 45 08             	mov    0x8(%ebp),%eax
    3a91:	8b 55 0c             	mov    0xc(%ebp),%edx
    3a94:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    3a96:	8b 45 08             	mov    0x8(%ebp),%eax
    3a99:	8b 55 10             	mov    0x10(%ebp),%edx
    3a9c:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    3a9f:	8b 45 08             	mov    0x8(%ebp),%eax
    3aa2:	83 c0 08             	add    $0x8,%eax
    3aa5:	50                   	push   %eax
    3aa6:	6a 08                	push   $0x8
    3aa8:	ff 75 10             	pushl  0x10(%ebp)
    3aab:	e8 59 f9 ff ff       	call   3409 <lodepng_mulofl>
    3ab0:	83 c4 0c             	add    $0xc,%esp
    3ab3:	85 c0                	test   %eax,%eax
    3ab5:	74 07                	je     3abe <LodePNGBitReader_init+0x36>
    3ab7:	b8 69 00 00 00       	mov    $0x69,%eax
    3abc:	eb 39                	jmp    3af7 <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    3abe:	8b 45 08             	mov    0x8(%ebp),%eax
    3ac1:	8b 40 08             	mov    0x8(%eax),%eax
    3ac4:	8d 55 fc             	lea    -0x4(%ebp),%edx
    3ac7:	52                   	push   %edx
    3ac8:	6a 40                	push   $0x40
    3aca:	50                   	push   %eax
    3acb:	e8 19 f9 ff ff       	call   33e9 <lodepng_addofl>
    3ad0:	83 c4 0c             	add    $0xc,%esp
    3ad3:	85 c0                	test   %eax,%eax
    3ad5:	74 07                	je     3ade <LodePNGBitReader_init+0x56>
    3ad7:	b8 69 00 00 00       	mov    $0x69,%eax
    3adc:	eb 19                	jmp    3af7 <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    3ade:	8b 45 08             	mov    0x8(%ebp),%eax
    3ae1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    3ae8:	8b 45 08             	mov    0x8(%ebp),%eax
    3aeb:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    3af2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3af7:	c9                   	leave  
    3af8:	c3                   	ret    

00003af9 <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    3af9:	55                   	push   %ebp
    3afa:	89 e5                	mov    %esp,%ebp
    3afc:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3aff:	8b 45 08             	mov    0x8(%ebp),%eax
    3b02:	8b 40 0c             	mov    0xc(%eax),%eax
    3b05:	c1 f8 03             	sar    $0x3,%eax
    3b08:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3b0b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b0e:	8b 40 04             	mov    0x4(%eax),%eax
    3b11:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    3b14:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3b17:	8d 50 01             	lea    0x1(%eax),%edx
    3b1a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3b1d:	39 c2                	cmp    %eax,%edx
    3b1f:	73 4e                	jae    3b6f <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    3b21:	8b 45 08             	mov    0x8(%ebp),%eax
    3b24:	8b 10                	mov    (%eax),%edx
    3b26:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3b29:	01 d0                	add    %edx,%eax
    3b2b:	0f b6 00             	movzbl (%eax),%eax
    3b2e:	0f b6 d0             	movzbl %al,%edx
    3b31:	8b 45 08             	mov    0x8(%ebp),%eax
    3b34:	8b 00                	mov    (%eax),%eax
    3b36:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3b39:	83 c1 01             	add    $0x1,%ecx
    3b3c:	01 c8                	add    %ecx,%eax
    3b3e:	0f b6 00             	movzbl (%eax),%eax
    3b41:	0f b6 c0             	movzbl %al,%eax
    3b44:	c1 e0 08             	shl    $0x8,%eax
    3b47:	09 c2                	or     %eax,%edx
    3b49:	8b 45 08             	mov    0x8(%ebp),%eax
    3b4c:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3b4f:	8b 45 08             	mov    0x8(%ebp),%eax
    3b52:	8b 50 10             	mov    0x10(%eax),%edx
    3b55:	8b 45 08             	mov    0x8(%ebp),%eax
    3b58:	8b 40 0c             	mov    0xc(%eax),%eax
    3b5b:	83 e0 07             	and    $0x7,%eax
    3b5e:	89 c1                	mov    %eax,%ecx
    3b60:	d3 ea                	shr    %cl,%edx
    3b62:	8b 45 08             	mov    0x8(%ebp),%eax
    3b65:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3b68:	b8 01 00 00 00       	mov    $0x1,%eax
    3b6d:	eb 64                	jmp    3bd3 <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    3b6f:	8b 45 08             	mov    0x8(%ebp),%eax
    3b72:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3b79:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3b7c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3b7f:	39 c2                	cmp    %eax,%edx
    3b81:	73 1e                	jae    3ba1 <ensureBits9+0xa8>
    3b83:	8b 45 08             	mov    0x8(%ebp),%eax
    3b86:	8b 50 10             	mov    0x10(%eax),%edx
    3b89:	8b 45 08             	mov    0x8(%ebp),%eax
    3b8c:	8b 08                	mov    (%eax),%ecx
    3b8e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3b91:	01 c8                	add    %ecx,%eax
    3b93:	0f b6 00             	movzbl (%eax),%eax
    3b96:	0f b6 c0             	movzbl %al,%eax
    3b99:	09 c2                	or     %eax,%edx
    3b9b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b9e:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3ba1:	8b 45 08             	mov    0x8(%ebp),%eax
    3ba4:	8b 50 10             	mov    0x10(%eax),%edx
    3ba7:	8b 45 08             	mov    0x8(%ebp),%eax
    3baa:	8b 40 0c             	mov    0xc(%eax),%eax
    3bad:	83 e0 07             	and    $0x7,%eax
    3bb0:	89 c1                	mov    %eax,%ecx
    3bb2:	d3 ea                	shr    %cl,%edx
    3bb4:	8b 45 08             	mov    0x8(%ebp),%eax
    3bb7:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3bba:	8b 45 08             	mov    0x8(%ebp),%eax
    3bbd:	8b 50 0c             	mov    0xc(%eax),%edx
    3bc0:	8b 45 0c             	mov    0xc(%ebp),%eax
    3bc3:	01 c2                	add    %eax,%edx
    3bc5:	8b 45 08             	mov    0x8(%ebp),%eax
    3bc8:	8b 40 08             	mov    0x8(%eax),%eax
    3bcb:	39 c2                	cmp    %eax,%edx
    3bcd:	0f 9e c0             	setle  %al
    3bd0:	0f b6 c0             	movzbl %al,%eax
  }
}
    3bd3:	c9                   	leave  
    3bd4:	c3                   	ret    

00003bd5 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    3bd5:	55                   	push   %ebp
    3bd6:	89 e5                	mov    %esp,%ebp
    3bd8:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3bdb:	8b 45 08             	mov    0x8(%ebp),%eax
    3bde:	8b 40 0c             	mov    0xc(%eax),%eax
    3be1:	c1 f8 03             	sar    $0x3,%eax
    3be4:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3be7:	8b 45 08             	mov    0x8(%ebp),%eax
    3bea:	8b 40 04             	mov    0x4(%eax),%eax
    3bed:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    3bf0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3bf3:	8d 50 02             	lea    0x2(%eax),%edx
    3bf6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3bf9:	39 c2                	cmp    %eax,%edx
    3bfb:	73 6d                	jae    3c6a <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3bfd:	8b 45 08             	mov    0x8(%ebp),%eax
    3c00:	8b 10                	mov    (%eax),%edx
    3c02:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c05:	01 d0                	add    %edx,%eax
    3c07:	0f b6 00             	movzbl (%eax),%eax
    3c0a:	0f b6 d0             	movzbl %al,%edx
    3c0d:	8b 45 08             	mov    0x8(%ebp),%eax
    3c10:	8b 00                	mov    (%eax),%eax
    3c12:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3c15:	83 c1 01             	add    $0x1,%ecx
    3c18:	01 c8                	add    %ecx,%eax
    3c1a:	0f b6 00             	movzbl (%eax),%eax
    3c1d:	0f b6 c0             	movzbl %al,%eax
    3c20:	c1 e0 08             	shl    $0x8,%eax
    3c23:	89 d1                	mov    %edx,%ecx
    3c25:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    3c27:	8b 45 08             	mov    0x8(%ebp),%eax
    3c2a:	8b 00                	mov    (%eax),%eax
    3c2c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3c2f:	83 c2 02             	add    $0x2,%edx
    3c32:	01 d0                	add    %edx,%eax
    3c34:	0f b6 00             	movzbl (%eax),%eax
    3c37:	0f b6 c0             	movzbl %al,%eax
    3c3a:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3c3d:	09 c1                	or     %eax,%ecx
    3c3f:	89 ca                	mov    %ecx,%edx
    3c41:	8b 45 08             	mov    0x8(%ebp),%eax
    3c44:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    3c47:	8b 45 08             	mov    0x8(%ebp),%eax
    3c4a:	8b 50 10             	mov    0x10(%eax),%edx
    3c4d:	8b 45 08             	mov    0x8(%ebp),%eax
    3c50:	8b 40 0c             	mov    0xc(%eax),%eax
    3c53:	83 e0 07             	and    $0x7,%eax
    3c56:	89 c1                	mov    %eax,%ecx
    3c58:	d3 ea                	shr    %cl,%edx
    3c5a:	8b 45 08             	mov    0x8(%ebp),%eax
    3c5d:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3c60:	b8 01 00 00 00       	mov    $0x1,%eax
    3c65:	e9 95 00 00 00       	jmp    3cff <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    3c6a:	8b 45 08             	mov    0x8(%ebp),%eax
    3c6d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3c74:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3c77:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c7a:	39 c2                	cmp    %eax,%edx
    3c7c:	73 1e                	jae    3c9c <ensureBits17+0xc7>
    3c7e:	8b 45 08             	mov    0x8(%ebp),%eax
    3c81:	8b 50 10             	mov    0x10(%eax),%edx
    3c84:	8b 45 08             	mov    0x8(%ebp),%eax
    3c87:	8b 08                	mov    (%eax),%ecx
    3c89:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c8c:	01 c8                	add    %ecx,%eax
    3c8e:	0f b6 00             	movzbl (%eax),%eax
    3c91:	0f b6 c0             	movzbl %al,%eax
    3c94:	09 c2                	or     %eax,%edx
    3c96:	8b 45 08             	mov    0x8(%ebp),%eax
    3c99:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3c9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c9f:	8d 50 01             	lea    0x1(%eax),%edx
    3ca2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ca5:	39 c2                	cmp    %eax,%edx
    3ca7:	73 24                	jae    3ccd <ensureBits17+0xf8>
    3ca9:	8b 45 08             	mov    0x8(%ebp),%eax
    3cac:	8b 50 10             	mov    0x10(%eax),%edx
    3caf:	8b 45 08             	mov    0x8(%ebp),%eax
    3cb2:	8b 00                	mov    (%eax),%eax
    3cb4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3cb7:	83 c1 01             	add    $0x1,%ecx
    3cba:	01 c8                	add    %ecx,%eax
    3cbc:	0f b6 00             	movzbl (%eax),%eax
    3cbf:	0f b6 c0             	movzbl %al,%eax
    3cc2:	c1 e0 08             	shl    $0x8,%eax
    3cc5:	09 c2                	or     %eax,%edx
    3cc7:	8b 45 08             	mov    0x8(%ebp),%eax
    3cca:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3ccd:	8b 45 08             	mov    0x8(%ebp),%eax
    3cd0:	8b 50 10             	mov    0x10(%eax),%edx
    3cd3:	8b 45 08             	mov    0x8(%ebp),%eax
    3cd6:	8b 40 0c             	mov    0xc(%eax),%eax
    3cd9:	83 e0 07             	and    $0x7,%eax
    3cdc:	89 c1                	mov    %eax,%ecx
    3cde:	d3 ea                	shr    %cl,%edx
    3ce0:	8b 45 08             	mov    0x8(%ebp),%eax
    3ce3:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3ce6:	8b 45 08             	mov    0x8(%ebp),%eax
    3ce9:	8b 50 0c             	mov    0xc(%eax),%edx
    3cec:	8b 45 0c             	mov    0xc(%ebp),%eax
    3cef:	01 c2                	add    %eax,%edx
    3cf1:	8b 45 08             	mov    0x8(%ebp),%eax
    3cf4:	8b 40 08             	mov    0x8(%eax),%eax
    3cf7:	39 c2                	cmp    %eax,%edx
    3cf9:	0f 9e c0             	setle  %al
    3cfc:	0f b6 c0             	movzbl %al,%eax
  }
}
    3cff:	c9                   	leave  
    3d00:	c3                   	ret    

00003d01 <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    3d01:	55                   	push   %ebp
    3d02:	89 e5                	mov    %esp,%ebp
    3d04:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3d07:	8b 45 08             	mov    0x8(%ebp),%eax
    3d0a:	8b 40 0c             	mov    0xc(%eax),%eax
    3d0d:	c1 f8 03             	sar    $0x3,%eax
    3d10:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3d13:	8b 45 08             	mov    0x8(%ebp),%eax
    3d16:	8b 40 04             	mov    0x4(%eax),%eax
    3d19:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    3d1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d1f:	8d 50 03             	lea    0x3(%eax),%edx
    3d22:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3d25:	39 c2                	cmp    %eax,%edx
    3d27:	0f 83 85 00 00 00    	jae    3db2 <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d2d:	8b 45 08             	mov    0x8(%ebp),%eax
    3d30:	8b 10                	mov    (%eax),%edx
    3d32:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d35:	01 d0                	add    %edx,%eax
    3d37:	0f b6 00             	movzbl (%eax),%eax
    3d3a:	0f b6 d0             	movzbl %al,%edx
    3d3d:	8b 45 08             	mov    0x8(%ebp),%eax
    3d40:	8b 00                	mov    (%eax),%eax
    3d42:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3d45:	83 c1 01             	add    $0x1,%ecx
    3d48:	01 c8                	add    %ecx,%eax
    3d4a:	0f b6 00             	movzbl (%eax),%eax
    3d4d:	0f b6 c0             	movzbl %al,%eax
    3d50:	c1 e0 08             	shl    $0x8,%eax
    3d53:	89 d1                	mov    %edx,%ecx
    3d55:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3d57:	8b 45 08             	mov    0x8(%ebp),%eax
    3d5a:	8b 00                	mov    (%eax),%eax
    3d5c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d5f:	83 c2 02             	add    $0x2,%edx
    3d62:	01 d0                	add    %edx,%eax
    3d64:	0f b6 00             	movzbl (%eax),%eax
    3d67:	0f b6 c0             	movzbl %al,%eax
    3d6a:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d6d:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3d6f:	8b 45 08             	mov    0x8(%ebp),%eax
    3d72:	8b 00                	mov    (%eax),%eax
    3d74:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d77:	83 c2 03             	add    $0x3,%edx
    3d7a:	01 d0                	add    %edx,%eax
    3d7c:	0f b6 00             	movzbl (%eax),%eax
    3d7f:	0f b6 c0             	movzbl %al,%eax
    3d82:	c1 e0 18             	shl    $0x18,%eax
    3d85:	09 c1                	or     %eax,%ecx
    3d87:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d89:	8b 45 08             	mov    0x8(%ebp),%eax
    3d8c:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3d8f:	8b 45 08             	mov    0x8(%ebp),%eax
    3d92:	8b 50 10             	mov    0x10(%eax),%edx
    3d95:	8b 45 08             	mov    0x8(%ebp),%eax
    3d98:	8b 40 0c             	mov    0xc(%eax),%eax
    3d9b:	83 e0 07             	and    $0x7,%eax
    3d9e:	89 c1                	mov    %eax,%ecx
    3da0:	d3 ea                	shr    %cl,%edx
    3da2:	8b 45 08             	mov    0x8(%ebp),%eax
    3da5:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3da8:	b8 01 00 00 00       	mov    $0x1,%eax
    3dad:	e9 c6 00 00 00       	jmp    3e78 <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    3db2:	8b 45 08             	mov    0x8(%ebp),%eax
    3db5:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3dbc:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3dbf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3dc2:	39 c2                	cmp    %eax,%edx
    3dc4:	73 1e                	jae    3de4 <ensureBits25+0xe3>
    3dc6:	8b 45 08             	mov    0x8(%ebp),%eax
    3dc9:	8b 50 10             	mov    0x10(%eax),%edx
    3dcc:	8b 45 08             	mov    0x8(%ebp),%eax
    3dcf:	8b 08                	mov    (%eax),%ecx
    3dd1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3dd4:	01 c8                	add    %ecx,%eax
    3dd6:	0f b6 00             	movzbl (%eax),%eax
    3dd9:	0f b6 c0             	movzbl %al,%eax
    3ddc:	09 c2                	or     %eax,%edx
    3dde:	8b 45 08             	mov    0x8(%ebp),%eax
    3de1:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3de4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3de7:	8d 50 01             	lea    0x1(%eax),%edx
    3dea:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ded:	39 c2                	cmp    %eax,%edx
    3def:	73 24                	jae    3e15 <ensureBits25+0x114>
    3df1:	8b 45 08             	mov    0x8(%ebp),%eax
    3df4:	8b 50 10             	mov    0x10(%eax),%edx
    3df7:	8b 45 08             	mov    0x8(%ebp),%eax
    3dfa:	8b 00                	mov    (%eax),%eax
    3dfc:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3dff:	83 c1 01             	add    $0x1,%ecx
    3e02:	01 c8                	add    %ecx,%eax
    3e04:	0f b6 00             	movzbl (%eax),%eax
    3e07:	0f b6 c0             	movzbl %al,%eax
    3e0a:	c1 e0 08             	shl    $0x8,%eax
    3e0d:	09 c2                	or     %eax,%edx
    3e0f:	8b 45 08             	mov    0x8(%ebp),%eax
    3e12:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    3e15:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3e18:	8d 50 02             	lea    0x2(%eax),%edx
    3e1b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e1e:	39 c2                	cmp    %eax,%edx
    3e20:	73 24                	jae    3e46 <ensureBits25+0x145>
    3e22:	8b 45 08             	mov    0x8(%ebp),%eax
    3e25:	8b 50 10             	mov    0x10(%eax),%edx
    3e28:	8b 45 08             	mov    0x8(%ebp),%eax
    3e2b:	8b 00                	mov    (%eax),%eax
    3e2d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3e30:	83 c1 02             	add    $0x2,%ecx
    3e33:	01 c8                	add    %ecx,%eax
    3e35:	0f b6 00             	movzbl (%eax),%eax
    3e38:	0f b6 c0             	movzbl %al,%eax
    3e3b:	c1 e0 10             	shl    $0x10,%eax
    3e3e:	09 c2                	or     %eax,%edx
    3e40:	8b 45 08             	mov    0x8(%ebp),%eax
    3e43:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3e46:	8b 45 08             	mov    0x8(%ebp),%eax
    3e49:	8b 50 10             	mov    0x10(%eax),%edx
    3e4c:	8b 45 08             	mov    0x8(%ebp),%eax
    3e4f:	8b 40 0c             	mov    0xc(%eax),%eax
    3e52:	83 e0 07             	and    $0x7,%eax
    3e55:	89 c1                	mov    %eax,%ecx
    3e57:	d3 ea                	shr    %cl,%edx
    3e59:	8b 45 08             	mov    0x8(%ebp),%eax
    3e5c:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3e5f:	8b 45 08             	mov    0x8(%ebp),%eax
    3e62:	8b 50 0c             	mov    0xc(%eax),%edx
    3e65:	8b 45 0c             	mov    0xc(%ebp),%eax
    3e68:	01 c2                	add    %eax,%edx
    3e6a:	8b 45 08             	mov    0x8(%ebp),%eax
    3e6d:	8b 40 08             	mov    0x8(%eax),%eax
    3e70:	39 c2                	cmp    %eax,%edx
    3e72:	0f 9e c0             	setle  %al
    3e75:	0f b6 c0             	movzbl %al,%eax
  }
}
    3e78:	c9                   	leave  
    3e79:	c3                   	ret    

00003e7a <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    3e7a:	55                   	push   %ebp
    3e7b:	89 e5                	mov    %esp,%ebp
    3e7d:	53                   	push   %ebx
    3e7e:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3e81:	8b 45 08             	mov    0x8(%ebp),%eax
    3e84:	8b 40 0c             	mov    0xc(%eax),%eax
    3e87:	c1 f8 03             	sar    $0x3,%eax
    3e8a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    3e8d:	8b 45 08             	mov    0x8(%ebp),%eax
    3e90:	8b 40 04             	mov    0x4(%eax),%eax
    3e93:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    3e96:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e99:	8d 50 04             	lea    0x4(%eax),%edx
    3e9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3e9f:	39 c2                	cmp    %eax,%edx
    3ea1:	0f 83 c3 00 00 00    	jae    3f6a <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3ea7:	8b 45 08             	mov    0x8(%ebp),%eax
    3eaa:	8b 10                	mov    (%eax),%edx
    3eac:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3eaf:	01 d0                	add    %edx,%eax
    3eb1:	0f b6 00             	movzbl (%eax),%eax
    3eb4:	0f b6 d0             	movzbl %al,%edx
    3eb7:	8b 45 08             	mov    0x8(%ebp),%eax
    3eba:	8b 00                	mov    (%eax),%eax
    3ebc:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3ebf:	83 c1 01             	add    $0x1,%ecx
    3ec2:	01 c8                	add    %ecx,%eax
    3ec4:	0f b6 00             	movzbl (%eax),%eax
    3ec7:	0f b6 c0             	movzbl %al,%eax
    3eca:	c1 e0 08             	shl    $0x8,%eax
    3ecd:	89 d1                	mov    %edx,%ecx
    3ecf:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3ed1:	8b 45 08             	mov    0x8(%ebp),%eax
    3ed4:	8b 00                	mov    (%eax),%eax
    3ed6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3ed9:	83 c2 02             	add    $0x2,%edx
    3edc:	01 d0                	add    %edx,%eax
    3ede:	0f b6 00             	movzbl (%eax),%eax
    3ee1:	0f b6 c0             	movzbl %al,%eax
    3ee4:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3ee7:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3ee9:	8b 45 08             	mov    0x8(%ebp),%eax
    3eec:	8b 00                	mov    (%eax),%eax
    3eee:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3ef1:	83 c2 03             	add    $0x3,%edx
    3ef4:	01 d0                	add    %edx,%eax
    3ef6:	0f b6 00             	movzbl (%eax),%eax
    3ef9:	0f b6 c0             	movzbl %al,%eax
    3efc:	c1 e0 18             	shl    $0x18,%eax
    3eff:	09 c1                	or     %eax,%ecx
    3f01:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3f03:	8b 45 08             	mov    0x8(%ebp),%eax
    3f06:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3f09:	8b 45 08             	mov    0x8(%ebp),%eax
    3f0c:	8b 50 10             	mov    0x10(%eax),%edx
    3f0f:	8b 45 08             	mov    0x8(%ebp),%eax
    3f12:	8b 40 0c             	mov    0xc(%eax),%eax
    3f15:	83 e0 07             	and    $0x7,%eax
    3f18:	89 c1                	mov    %eax,%ecx
    3f1a:	d3 ea                	shr    %cl,%edx
    3f1c:	8b 45 08             	mov    0x8(%ebp),%eax
    3f1f:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    3f22:	8b 45 08             	mov    0x8(%ebp),%eax
    3f25:	8b 50 10             	mov    0x10(%eax),%edx
    3f28:	8b 45 08             	mov    0x8(%ebp),%eax
    3f2b:	8b 00                	mov    (%eax),%eax
    3f2d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3f30:	83 c1 04             	add    $0x4,%ecx
    3f33:	01 c8                	add    %ecx,%eax
    3f35:	0f b6 00             	movzbl (%eax),%eax
    3f38:	0f b6 c0             	movzbl %al,%eax
    3f3b:	c1 e0 18             	shl    $0x18,%eax
    3f3e:	89 c3                	mov    %eax,%ebx
    3f40:	8b 45 08             	mov    0x8(%ebp),%eax
    3f43:	8b 40 0c             	mov    0xc(%eax),%eax
    3f46:	83 e0 07             	and    $0x7,%eax
    3f49:	b9 08 00 00 00       	mov    $0x8,%ecx
    3f4e:	29 c1                	sub    %eax,%ecx
    3f50:	89 c8                	mov    %ecx,%eax
    3f52:	89 c1                	mov    %eax,%ecx
    3f54:	d3 e3                	shl    %cl,%ebx
    3f56:	89 d8                	mov    %ebx,%eax
    3f58:	09 c2                	or     %eax,%edx
    3f5a:	8b 45 08             	mov    0x8(%ebp),%eax
    3f5d:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3f60:	b8 01 00 00 00       	mov    $0x1,%eax
    3f65:	e9 f7 00 00 00       	jmp    4061 <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    3f6a:	8b 45 08             	mov    0x8(%ebp),%eax
    3f6d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3f74:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3f77:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3f7a:	39 c2                	cmp    %eax,%edx
    3f7c:	73 1e                	jae    3f9c <ensureBits32+0x122>
    3f7e:	8b 45 08             	mov    0x8(%ebp),%eax
    3f81:	8b 50 10             	mov    0x10(%eax),%edx
    3f84:	8b 45 08             	mov    0x8(%ebp),%eax
    3f87:	8b 08                	mov    (%eax),%ecx
    3f89:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f8c:	01 c8                	add    %ecx,%eax
    3f8e:	0f b6 00             	movzbl (%eax),%eax
    3f91:	0f b6 c0             	movzbl %al,%eax
    3f94:	09 c2                	or     %eax,%edx
    3f96:	8b 45 08             	mov    0x8(%ebp),%eax
    3f99:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3f9c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f9f:	8d 50 01             	lea    0x1(%eax),%edx
    3fa2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3fa5:	39 c2                	cmp    %eax,%edx
    3fa7:	73 24                	jae    3fcd <ensureBits32+0x153>
    3fa9:	8b 45 08             	mov    0x8(%ebp),%eax
    3fac:	8b 50 10             	mov    0x10(%eax),%edx
    3faf:	8b 45 08             	mov    0x8(%ebp),%eax
    3fb2:	8b 00                	mov    (%eax),%eax
    3fb4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3fb7:	83 c1 01             	add    $0x1,%ecx
    3fba:	01 c8                	add    %ecx,%eax
    3fbc:	0f b6 00             	movzbl (%eax),%eax
    3fbf:	0f b6 c0             	movzbl %al,%eax
    3fc2:	c1 e0 08             	shl    $0x8,%eax
    3fc5:	09 c2                	or     %eax,%edx
    3fc7:	8b 45 08             	mov    0x8(%ebp),%eax
    3fca:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    3fcd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3fd0:	8d 50 02             	lea    0x2(%eax),%edx
    3fd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3fd6:	39 c2                	cmp    %eax,%edx
    3fd8:	73 24                	jae    3ffe <ensureBits32+0x184>
    3fda:	8b 45 08             	mov    0x8(%ebp),%eax
    3fdd:	8b 50 10             	mov    0x10(%eax),%edx
    3fe0:	8b 45 08             	mov    0x8(%ebp),%eax
    3fe3:	8b 00                	mov    (%eax),%eax
    3fe5:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    3fe8:	83 c1 02             	add    $0x2,%ecx
    3feb:	01 c8                	add    %ecx,%eax
    3fed:	0f b6 00             	movzbl (%eax),%eax
    3ff0:	0f b6 c0             	movzbl %al,%eax
    3ff3:	c1 e0 10             	shl    $0x10,%eax
    3ff6:	09 c2                	or     %eax,%edx
    3ff8:	8b 45 08             	mov    0x8(%ebp),%eax
    3ffb:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    3ffe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4001:	8d 50 03             	lea    0x3(%eax),%edx
    4004:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4007:	39 c2                	cmp    %eax,%edx
    4009:	73 24                	jae    402f <ensureBits32+0x1b5>
    400b:	8b 45 08             	mov    0x8(%ebp),%eax
    400e:	8b 50 10             	mov    0x10(%eax),%edx
    4011:	8b 45 08             	mov    0x8(%ebp),%eax
    4014:	8b 00                	mov    (%eax),%eax
    4016:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4019:	83 c1 03             	add    $0x3,%ecx
    401c:	01 c8                	add    %ecx,%eax
    401e:	0f b6 00             	movzbl (%eax),%eax
    4021:	0f b6 c0             	movzbl %al,%eax
    4024:	c1 e0 18             	shl    $0x18,%eax
    4027:	09 c2                	or     %eax,%edx
    4029:	8b 45 08             	mov    0x8(%ebp),%eax
    402c:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    402f:	8b 45 08             	mov    0x8(%ebp),%eax
    4032:	8b 50 10             	mov    0x10(%eax),%edx
    4035:	8b 45 08             	mov    0x8(%ebp),%eax
    4038:	8b 40 0c             	mov    0xc(%eax),%eax
    403b:	83 e0 07             	and    $0x7,%eax
    403e:	89 c1                	mov    %eax,%ecx
    4040:	d3 ea                	shr    %cl,%edx
    4042:	8b 45 08             	mov    0x8(%ebp),%eax
    4045:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4048:	8b 45 08             	mov    0x8(%ebp),%eax
    404b:	8b 50 0c             	mov    0xc(%eax),%edx
    404e:	8b 45 0c             	mov    0xc(%ebp),%eax
    4051:	01 c2                	add    %eax,%edx
    4053:	8b 45 08             	mov    0x8(%ebp),%eax
    4056:	8b 40 08             	mov    0x8(%eax),%eax
    4059:	39 c2                	cmp    %eax,%edx
    405b:	0f 9e c0             	setle  %al
    405e:	0f b6 c0             	movzbl %al,%eax
  }
}
    4061:	83 c4 10             	add    $0x10,%esp
    4064:	5b                   	pop    %ebx
    4065:	5d                   	pop    %ebp
    4066:	c3                   	ret    

00004067 <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    4067:	55                   	push   %ebp
    4068:	89 e5                	mov    %esp,%ebp
    406a:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    406b:	8b 45 08             	mov    0x8(%ebp),%eax
    406e:	8b 50 10             	mov    0x10(%eax),%edx
    4071:	8b 45 0c             	mov    0xc(%ebp),%eax
    4074:	bb 01 00 00 00       	mov    $0x1,%ebx
    4079:	89 c1                	mov    %eax,%ecx
    407b:	d3 e3                	shl    %cl,%ebx
    407d:	89 d8                	mov    %ebx,%eax
    407f:	83 e8 01             	sub    $0x1,%eax
    4082:	21 d0                	and    %edx,%eax
}
    4084:	5b                   	pop    %ebx
    4085:	5d                   	pop    %ebp
    4086:	c3                   	ret    

00004087 <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    4087:	55                   	push   %ebp
    4088:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    408a:	8b 45 08             	mov    0x8(%ebp),%eax
    408d:	8b 50 10             	mov    0x10(%eax),%edx
    4090:	8b 45 0c             	mov    0xc(%ebp),%eax
    4093:	89 c1                	mov    %eax,%ecx
    4095:	d3 ea                	shr    %cl,%edx
    4097:	8b 45 08             	mov    0x8(%ebp),%eax
    409a:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    409d:	8b 45 08             	mov    0x8(%ebp),%eax
    40a0:	8b 50 0c             	mov    0xc(%eax),%edx
    40a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    40a6:	01 c2                	add    %eax,%edx
    40a8:	8b 45 08             	mov    0x8(%ebp),%eax
    40ab:	89 50 0c             	mov    %edx,0xc(%eax)
}
    40ae:	90                   	nop
    40af:	5d                   	pop    %ebp
    40b0:	c3                   	ret    

000040b1 <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    40b1:	55                   	push   %ebp
    40b2:	89 e5                	mov    %esp,%ebp
    40b4:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    40b7:	ff 75 0c             	pushl  0xc(%ebp)
    40ba:	ff 75 08             	pushl  0x8(%ebp)
    40bd:	e8 a5 ff ff ff       	call   4067 <peekBits>
    40c2:	83 c4 08             	add    $0x8,%esp
    40c5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    40c8:	ff 75 0c             	pushl  0xc(%ebp)
    40cb:	ff 75 08             	pushl  0x8(%ebp)
    40ce:	e8 b4 ff ff ff       	call   4087 <advanceBits>
    40d3:	83 c4 08             	add    $0x8,%esp
  return result;
    40d6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    40d9:	c9                   	leave  
    40da:	c3                   	ret    

000040db <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    40db:	55                   	push   %ebp
    40dc:	89 e5                	mov    %esp,%ebp
    40de:	53                   	push   %ebx
    40df:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    40e2:	ff 75 0c             	pushl  0xc(%ebp)
    40e5:	ff 75 08             	pushl  0x8(%ebp)
    40e8:	8d 45 d8             	lea    -0x28(%ebp),%eax
    40eb:	50                   	push   %eax
    40ec:	e8 97 f9 ff ff       	call   3a88 <LodePNGBitReader_init>
    40f1:	83 c4 0c             	add    $0xc,%esp
    40f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    40f7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    40fb:	74 0a                	je     4107 <lode_png_test_bitreader+0x2c>
    40fd:	b8 00 00 00 00       	mov    $0x0,%eax
    4102:	e9 c3 00 00 00       	jmp    41ca <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    4107:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    410e:	e9 a6 00 00 00       	jmp    41b9 <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    4113:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4116:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    411d:	8b 45 14             	mov    0x14(%ebp),%eax
    4120:	01 d0                	add    %edx,%eax
    4122:	8b 00                	mov    (%eax),%eax
    4124:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    4127:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    412b:	7e 14                	jle    4141 <lode_png_test_bitreader+0x66>
    412d:	ff 75 ec             	pushl  -0x14(%ebp)
    4130:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4133:	50                   	push   %eax
    4134:	e8 41 fd ff ff       	call   3e7a <ensureBits32>
    4139:	83 c4 08             	add    $0x8,%esp
    413c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    413f:	eb 46                	jmp    4187 <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    4141:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    4145:	7e 14                	jle    415b <lode_png_test_bitreader+0x80>
    4147:	ff 75 ec             	pushl  -0x14(%ebp)
    414a:	8d 45 d8             	lea    -0x28(%ebp),%eax
    414d:	50                   	push   %eax
    414e:	e8 ae fb ff ff       	call   3d01 <ensureBits25>
    4153:	83 c4 08             	add    $0x8,%esp
    4156:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4159:	eb 2c                	jmp    4187 <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    415b:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    415f:	7e 14                	jle    4175 <lode_png_test_bitreader+0x9a>
    4161:	ff 75 ec             	pushl  -0x14(%ebp)
    4164:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4167:	50                   	push   %eax
    4168:	e8 68 fa ff ff       	call   3bd5 <ensureBits17>
    416d:	83 c4 08             	add    $0x8,%esp
    4170:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4173:	eb 12                	jmp    4187 <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    4175:	ff 75 ec             	pushl  -0x14(%ebp)
    4178:	8d 45 d8             	lea    -0x28(%ebp),%eax
    417b:	50                   	push   %eax
    417c:	e8 78 f9 ff ff       	call   3af9 <ensureBits9>
    4181:	83 c4 08             	add    $0x8,%esp
    4184:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    4187:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    418b:	75 07                	jne    4194 <lode_png_test_bitreader+0xb9>
    418d:	b8 00 00 00 00       	mov    $0x0,%eax
    4192:	eb 36                	jmp    41ca <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    4194:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4197:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    419e:	8b 45 18             	mov    0x18(%ebp),%eax
    41a1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    41a4:	ff 75 ec             	pushl  -0x14(%ebp)
    41a7:	8d 45 d8             	lea    -0x28(%ebp),%eax
    41aa:	50                   	push   %eax
    41ab:	e8 01 ff ff ff       	call   40b1 <readBits>
    41b0:	83 c4 08             	add    $0x8,%esp
    41b3:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    41b5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    41b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    41bc:	3b 45 10             	cmp    0x10(%ebp),%eax
    41bf:	0f 8c 4e ff ff ff    	jl     4113 <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    41c5:	b8 01 00 00 00       	mov    $0x1,%eax
}
    41ca:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    41cd:	c9                   	leave  
    41ce:	c3                   	ret    

000041cf <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    41cf:	55                   	push   %ebp
    41d0:	89 e5                	mov    %esp,%ebp
    41d2:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    41d5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    41dc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    41e3:	eb 27                	jmp    420c <reverseBits+0x3d>
    41e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    41e8:	2b 45 fc             	sub    -0x4(%ebp),%eax
    41eb:	83 e8 01             	sub    $0x1,%eax
    41ee:	8b 55 08             	mov    0x8(%ebp),%edx
    41f1:	89 c1                	mov    %eax,%ecx
    41f3:	d3 ea                	shr    %cl,%edx
    41f5:	89 d0                	mov    %edx,%eax
    41f7:	83 e0 01             	and    $0x1,%eax
    41fa:	89 c2                	mov    %eax,%edx
    41fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    41ff:	89 c1                	mov    %eax,%ecx
    4201:	d3 e2                	shl    %cl,%edx
    4203:	89 d0                	mov    %edx,%eax
    4205:	09 45 f8             	or     %eax,-0x8(%ebp)
    4208:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    420c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    420f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4212:	72 d1                	jb     41e5 <reverseBits+0x16>
  return result;
    4214:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    4217:	c9                   	leave  
    4218:	c3                   	ret    

00004219 <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    4219:	55                   	push   %ebp
    421a:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    421c:	8b 45 08             	mov    0x8(%ebp),%eax
    421f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    4225:	8b 45 08             	mov    0x8(%ebp),%eax
    4228:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    422f:	8b 45 08             	mov    0x8(%ebp),%eax
    4232:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    4239:	8b 45 08             	mov    0x8(%ebp),%eax
    423c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    4243:	90                   	nop
    4244:	5d                   	pop    %ebp
    4245:	c3                   	ret    

00004246 <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    4246:	55                   	push   %ebp
    4247:	89 e5                	mov    %esp,%ebp
    4249:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    424c:	8b 45 08             	mov    0x8(%ebp),%eax
    424f:	8b 00                	mov    (%eax),%eax
    4251:	83 ec 0c             	sub    $0xc,%esp
    4254:	50                   	push   %eax
    4255:	e8 ec f0 ff ff       	call   3346 <lodepng_free>
    425a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    425d:	8b 45 08             	mov    0x8(%ebp),%eax
    4260:	8b 40 04             	mov    0x4(%eax),%eax
    4263:	83 ec 0c             	sub    $0xc,%esp
    4266:	50                   	push   %eax
    4267:	e8 da f0 ff ff       	call   3346 <lodepng_free>
    426c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    426f:	8b 45 08             	mov    0x8(%ebp),%eax
    4272:	8b 40 10             	mov    0x10(%eax),%eax
    4275:	83 ec 0c             	sub    $0xc,%esp
    4278:	50                   	push   %eax
    4279:	e8 c8 f0 ff ff       	call   3346 <lodepng_free>
    427e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    4281:	8b 45 08             	mov    0x8(%ebp),%eax
    4284:	8b 40 14             	mov    0x14(%eax),%eax
    4287:	83 ec 0c             	sub    $0xc,%esp
    428a:	50                   	push   %eax
    428b:	e8 b6 f0 ff ff       	call   3346 <lodepng_free>
    4290:	83 c4 10             	add    $0x10,%esp
}
    4293:	90                   	nop
    4294:	c9                   	leave  
    4295:	c3                   	ret    

00004296 <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    4296:	55                   	push   %ebp
    4297:	89 e5                	mov    %esp,%ebp
    4299:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    429c:	a1 c8 b5 01 00       	mov    0x1b5c8,%eax
    42a1:	c1 e0 02             	shl    $0x2,%eax
    42a4:	83 ec 0c             	sub    $0xc,%esp
    42a7:	50                   	push   %eax
    42a8:	e8 78 f0 ff ff       	call   3325 <lodepng_malloc>
    42ad:	83 c4 10             	add    $0x10,%esp
    42b0:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    42b3:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    42b7:	75 0a                	jne    42c3 <HuffmanTree_makeTable+0x2d>
    42b9:	b8 53 00 00 00       	mov    $0x53,%eax
    42be:	e9 61 04 00 00       	jmp    4724 <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    42c3:	a1 c8 b5 01 00       	mov    0x1b5c8,%eax
    42c8:	c1 e0 02             	shl    $0x2,%eax
    42cb:	83 ec 04             	sub    $0x4,%esp
    42ce:	50                   	push   %eax
    42cf:	6a 00                	push   $0x0
    42d1:	ff 75 dc             	pushl  -0x24(%ebp)
    42d4:	e8 bd f0 ff ff       	call   3396 <lodepng_memset>
    42d9:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    42dc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    42e3:	eb 7d                	jmp    4362 <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    42e5:	8b 45 08             	mov    0x8(%ebp),%eax
    42e8:	8b 00                	mov    (%eax),%eax
    42ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
    42ed:	c1 e2 02             	shl    $0x2,%edx
    42f0:	01 d0                	add    %edx,%eax
    42f2:	8b 00                	mov    (%eax),%eax
    42f4:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    42f7:	8b 45 08             	mov    0x8(%ebp),%eax
    42fa:	8b 40 04             	mov    0x4(%eax),%eax
    42fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4300:	c1 e2 02             	shl    $0x2,%edx
    4303:	01 d0                	add    %edx,%eax
    4305:	8b 00                	mov    (%eax),%eax
    4307:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    430a:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    430e:	76 4d                	jbe    435d <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    4310:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4313:	83 e8 09             	sub    $0x9,%eax
    4316:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4319:	89 c1                	mov    %eax,%ecx
    431b:	d3 ea                	shr    %cl,%edx
    431d:	89 d0                	mov    %edx,%eax
    431f:	83 ec 08             	sub    $0x8,%esp
    4322:	6a 09                	push   $0x9
    4324:	50                   	push   %eax
    4325:	e8 a5 fe ff ff       	call   41cf <reverseBits>
    432a:	83 c4 10             	add    $0x10,%esp
    432d:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    4330:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4333:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    433a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    433d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    4340:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4343:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    434a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    434d:	01 d0                	add    %edx,%eax
    434f:	8b 10                	mov    (%eax),%edx
    4351:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4354:	39 c2                	cmp    %eax,%edx
    4356:	0f 43 c2             	cmovae %edx,%eax
    4359:	89 01                	mov    %eax,(%ecx)
    435b:	eb 01                	jmp    435e <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    435d:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    435e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4362:	8b 45 08             	mov    0x8(%ebp),%eax
    4365:	8b 50 0c             	mov    0xc(%eax),%edx
    4368:	8b 45 f4             	mov    -0xc(%ebp),%eax
    436b:	39 c2                	cmp    %eax,%edx
    436d:	0f 87 72 ff ff ff    	ja     42e5 <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    4373:	a1 c8 b5 01 00       	mov    0x1b5c8,%eax
    4378:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    437b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4382:	eb 35                	jmp    43b9 <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    4384:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4387:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    438e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4391:	01 d0                	add    %edx,%eax
    4393:	8b 00                	mov    (%eax),%eax
    4395:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    4398:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    439c:	76 17                	jbe    43b5 <HuffmanTree_makeTable+0x11f>
    439e:	8b 45 cc             	mov    -0x34(%ebp),%eax
    43a1:	83 e8 09             	sub    $0x9,%eax
    43a4:	ba 01 00 00 00       	mov    $0x1,%edx
    43a9:	89 c1                	mov    %eax,%ecx
    43ab:	d3 e2                	shl    %cl,%edx
    43ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
    43b0:	01 d0                	add    %edx,%eax
    43b2:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    43b5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    43b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    43bc:	a1 c8 b5 01 00       	mov    0x1b5c8,%eax
    43c1:	39 c2                	cmp    %eax,%edx
    43c3:	72 bf                	jb     4384 <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    43c5:	83 ec 0c             	sub    $0xc,%esp
    43c8:	ff 75 e8             	pushl  -0x18(%ebp)
    43cb:	e8 55 ef ff ff       	call   3325 <lodepng_malloc>
    43d0:	83 c4 10             	add    $0x10,%esp
    43d3:	89 c2                	mov    %eax,%edx
    43d5:	8b 45 08             	mov    0x8(%ebp),%eax
    43d8:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    43db:	8b 45 e8             	mov    -0x18(%ebp),%eax
    43de:	01 c0                	add    %eax,%eax
    43e0:	83 ec 0c             	sub    $0xc,%esp
    43e3:	50                   	push   %eax
    43e4:	e8 3c ef ff ff       	call   3325 <lodepng_malloc>
    43e9:	83 c4 10             	add    $0x10,%esp
    43ec:	89 c2                	mov    %eax,%edx
    43ee:	8b 45 08             	mov    0x8(%ebp),%eax
    43f1:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    43f4:	8b 45 08             	mov    0x8(%ebp),%eax
    43f7:	8b 40 10             	mov    0x10(%eax),%eax
    43fa:	85 c0                	test   %eax,%eax
    43fc:	74 0a                	je     4408 <HuffmanTree_makeTable+0x172>
    43fe:	8b 45 08             	mov    0x8(%ebp),%eax
    4401:	8b 40 14             	mov    0x14(%eax),%eax
    4404:	85 c0                	test   %eax,%eax
    4406:	75 18                	jne    4420 <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    4408:	83 ec 0c             	sub    $0xc,%esp
    440b:	ff 75 dc             	pushl  -0x24(%ebp)
    440e:	e8 33 ef ff ff       	call   3346 <lodepng_free>
    4413:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    4416:	b8 53 00 00 00       	mov    $0x53,%eax
    441b:	e9 04 03 00 00       	jmp    4724 <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    4420:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4427:	eb 12                	jmp    443b <HuffmanTree_makeTable+0x1a5>
    4429:	8b 45 08             	mov    0x8(%ebp),%eax
    442c:	8b 50 10             	mov    0x10(%eax),%edx
    442f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4432:	01 d0                	add    %edx,%eax
    4434:	c6 00 10             	movb   $0x10,(%eax)
    4437:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    443b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    443e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4441:	7c e6                	jl     4429 <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    4443:	a1 c8 b5 01 00       	mov    0x1b5c8,%eax
    4448:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    444b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4452:	eb 5b                	jmp    44af <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    4454:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4457:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    445e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4461:	01 d0                	add    %edx,%eax
    4463:	8b 00                	mov    (%eax),%eax
    4465:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    4468:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    446c:	76 3c                	jbe    44aa <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    446e:	8b 45 08             	mov    0x8(%ebp),%eax
    4471:	8b 50 10             	mov    0x10(%eax),%edx
    4474:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4477:	01 d0                	add    %edx,%eax
    4479:	8b 55 c8             	mov    -0x38(%ebp),%edx
    447c:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    447e:	8b 45 08             	mov    0x8(%ebp),%eax
    4481:	8b 40 14             	mov    0x14(%eax),%eax
    4484:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4487:	01 d2                	add    %edx,%edx
    4489:	01 d0                	add    %edx,%eax
    448b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    448e:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    4491:	8b 45 c8             	mov    -0x38(%ebp),%eax
    4494:	83 e8 09             	sub    $0x9,%eax
    4497:	ba 01 00 00 00       	mov    $0x1,%edx
    449c:	89 c1                	mov    %eax,%ecx
    449e:	d3 e2                	shl    %cl,%edx
    44a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    44a3:	01 d0                	add    %edx,%eax
    44a5:	89 45 ec             	mov    %eax,-0x14(%ebp)
    44a8:	eb 01                	jmp    44ab <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    44aa:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    44ab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    44af:	8b 55 f4             	mov    -0xc(%ebp),%edx
    44b2:	a1 c8 b5 01 00       	mov    0x1b5c8,%eax
    44b7:	39 c2                	cmp    %eax,%edx
    44b9:	72 99                	jb     4454 <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    44bb:	83 ec 0c             	sub    $0xc,%esp
    44be:	ff 75 dc             	pushl  -0x24(%ebp)
    44c1:	e8 80 ee ff ff       	call   3346 <lodepng_free>
    44c6:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    44c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    44d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    44d7:	e9 9d 01 00 00       	jmp    4679 <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    44dc:	8b 45 08             	mov    0x8(%ebp),%eax
    44df:	8b 40 04             	mov    0x4(%eax),%eax
    44e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    44e5:	c1 e2 02             	shl    $0x2,%edx
    44e8:	01 d0                	add    %edx,%eax
    44ea:	8b 00                	mov    (%eax),%eax
    44ec:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    44ef:	8b 45 08             	mov    0x8(%ebp),%eax
    44f2:	8b 00                	mov    (%eax),%eax
    44f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    44f7:	c1 e2 02             	shl    $0x2,%edx
    44fa:	01 d0                	add    %edx,%eax
    44fc:	8b 00                	mov    (%eax),%eax
    44fe:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    4501:	83 ec 08             	sub    $0x8,%esp
    4504:	ff 75 c4             	pushl  -0x3c(%ebp)
    4507:	ff 75 c0             	pushl  -0x40(%ebp)
    450a:	e8 c0 fc ff ff       	call   41cf <reverseBits>
    450f:	83 c4 10             	add    $0x10,%esp
    4512:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    4515:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    4519:	0f 84 55 01 00 00    	je     4674 <HuffmanTree_makeTable+0x3de>
    numpresent++;
    451f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    4523:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    4527:	0f 87 81 00 00 00    	ja     45ae <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    452d:	b8 09 00 00 00       	mov    $0x9,%eax
    4532:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    4535:	ba 01 00 00 00       	mov    $0x1,%edx
    453a:	89 c1                	mov    %eax,%ecx
    453c:	d3 e2                	shl    %cl,%edx
    453e:	89 d0                	mov    %edx,%eax
    4540:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    4543:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    454a:	eb 55                	jmp    45a1 <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    454c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    454f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4552:	89 c1                	mov    %eax,%ecx
    4554:	d3 e2                	shl    %cl,%edx
    4556:	89 d0                	mov    %edx,%eax
    4558:	0b 45 bc             	or     -0x44(%ebp),%eax
    455b:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    455e:	8b 45 08             	mov    0x8(%ebp),%eax
    4561:	8b 50 10             	mov    0x10(%eax),%edx
    4564:	8b 45 98             	mov    -0x68(%ebp),%eax
    4567:	01 d0                	add    %edx,%eax
    4569:	0f b6 00             	movzbl (%eax),%eax
    456c:	3c 10                	cmp    $0x10,%al
    456e:	74 0a                	je     457a <HuffmanTree_makeTable+0x2e4>
    4570:	b8 37 00 00 00       	mov    $0x37,%eax
    4575:	e9 aa 01 00 00       	jmp    4724 <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    457a:	8b 45 08             	mov    0x8(%ebp),%eax
    457d:	8b 50 10             	mov    0x10(%eax),%edx
    4580:	8b 45 98             	mov    -0x68(%ebp),%eax
    4583:	01 d0                	add    %edx,%eax
    4585:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4588:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    458a:	8b 45 08             	mov    0x8(%ebp),%eax
    458d:	8b 40 14             	mov    0x14(%eax),%eax
    4590:	8b 55 98             	mov    -0x68(%ebp),%edx
    4593:	01 d2                	add    %edx,%edx
    4595:	01 d0                	add    %edx,%eax
    4597:	8b 55 f4             	mov    -0xc(%ebp),%edx
    459a:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    459d:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    45a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    45a4:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    45a7:	72 a3                	jb     454c <HuffmanTree_makeTable+0x2b6>
    45a9:	e9 c7 00 00 00       	jmp    4675 <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    45ae:	a1 cc b5 01 00       	mov    0x1b5cc,%eax
    45b3:	23 45 bc             	and    -0x44(%ebp),%eax
    45b6:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    45b9:	8b 45 08             	mov    0x8(%ebp),%eax
    45bc:	8b 50 10             	mov    0x10(%eax),%edx
    45bf:	8b 45 b8             	mov    -0x48(%ebp),%eax
    45c2:	01 d0                	add    %edx,%eax
    45c4:	0f b6 00             	movzbl (%eax),%eax
    45c7:	0f b6 c0             	movzbl %al,%eax
    45ca:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    45cd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    45d0:	83 e8 09             	sub    $0x9,%eax
    45d3:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    45d6:	8b 45 08             	mov    0x8(%ebp),%eax
    45d9:	8b 40 14             	mov    0x14(%eax),%eax
    45dc:	8b 55 b8             	mov    -0x48(%ebp),%edx
    45df:	01 d2                	add    %edx,%edx
    45e1:	01 d0                	add    %edx,%eax
    45e3:	0f b7 00             	movzwl (%eax),%eax
    45e6:	0f b7 c0             	movzwl %ax,%eax
    45e9:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    45ec:	8b 45 b0             	mov    -0x50(%ebp),%eax
    45ef:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    45f2:	83 c0 09             	add    $0x9,%eax
    45f5:	ba 01 00 00 00       	mov    $0x1,%edx
    45fa:	89 c1                	mov    %eax,%ecx
    45fc:	d3 e2                	shl    %cl,%edx
    45fe:	89 d0                	mov    %edx,%eax
    4600:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    4603:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    4606:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    4609:	73 0a                	jae    4615 <HuffmanTree_makeTable+0x37f>
    460b:	b8 37 00 00 00       	mov    $0x37,%eax
    4610:	e9 0f 01 00 00       	jmp    4724 <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    4615:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    461c:	eb 4c                	jmp    466a <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    461e:	8b 45 bc             	mov    -0x44(%ebp),%eax
    4621:	c1 e8 09             	shr    $0x9,%eax
    4624:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    4627:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    462a:	83 e8 09             	sub    $0x9,%eax
    462d:	8b 55 e0             	mov    -0x20(%ebp),%edx
    4630:	89 c1                	mov    %eax,%ecx
    4632:	d3 e2                	shl    %cl,%edx
    4634:	89 d0                	mov    %edx,%eax
    4636:	0b 45 a4             	or     -0x5c(%ebp),%eax
    4639:	89 c2                	mov    %eax,%edx
    463b:	8b 45 ac             	mov    -0x54(%ebp),%eax
    463e:	01 d0                	add    %edx,%eax
    4640:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    4643:	8b 45 08             	mov    0x8(%ebp),%eax
    4646:	8b 50 10             	mov    0x10(%eax),%edx
    4649:	8b 45 a0             	mov    -0x60(%ebp),%eax
    464c:	01 d0                	add    %edx,%eax
    464e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4651:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    4653:	8b 45 08             	mov    0x8(%ebp),%eax
    4656:	8b 40 14             	mov    0x14(%eax),%eax
    4659:	8b 55 a0             	mov    -0x60(%ebp),%edx
    465c:	01 d2                	add    %edx,%edx
    465e:	01 d0                	add    %edx,%eax
    4660:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4663:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    4666:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    466a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    466d:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    4670:	72 ac                	jb     461e <HuffmanTree_makeTable+0x388>
    4672:	eb 01                	jmp    4675 <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    4674:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    4675:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4679:	8b 45 08             	mov    0x8(%ebp),%eax
    467c:	8b 50 0c             	mov    0xc(%eax),%edx
    467f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4682:	39 c2                	cmp    %eax,%edx
    4684:	0f 87 52 fe ff ff    	ja     44dc <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    468a:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    468e:	7f 61                	jg     46f1 <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    4690:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4697:	eb 4e                	jmp    46e7 <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    4699:	8b 45 08             	mov    0x8(%ebp),%eax
    469c:	8b 50 10             	mov    0x10(%eax),%edx
    469f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46a2:	01 d0                	add    %edx,%eax
    46a4:	0f b6 00             	movzbl (%eax),%eax
    46a7:	3c 10                	cmp    $0x10,%al
    46a9:	75 38                	jne    46e3 <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    46ab:	8b 45 08             	mov    0x8(%ebp),%eax
    46ae:	8b 50 10             	mov    0x10(%eax),%edx
    46b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46b4:	01 d0                	add    %edx,%eax
    46b6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    46b9:	8b 15 c8 b5 01 00    	mov    0x1b5c8,%edx
    46bf:	39 d1                	cmp    %edx,%ecx
    46c1:	73 07                	jae    46ca <HuffmanTree_makeTable+0x434>
    46c3:	ba 01 00 00 00       	mov    $0x1,%edx
    46c8:	eb 05                	jmp    46cf <HuffmanTree_makeTable+0x439>
    46ca:	ba 0a 00 00 00       	mov    $0xa,%edx
    46cf:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    46d1:	8b 45 08             	mov    0x8(%ebp),%eax
    46d4:	8b 40 14             	mov    0x14(%eax),%eax
    46d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    46da:	01 d2                	add    %edx,%edx
    46dc:	01 d0                	add    %edx,%eax
    46de:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    46e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    46e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46ea:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    46ed:	7c aa                	jl     4699 <HuffmanTree_makeTable+0x403>
    46ef:	eb 2e                	jmp    471f <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    46f1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    46f8:	eb 1d                	jmp    4717 <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    46fa:	8b 45 08             	mov    0x8(%ebp),%eax
    46fd:	8b 50 10             	mov    0x10(%eax),%edx
    4700:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4703:	01 d0                	add    %edx,%eax
    4705:	0f b6 00             	movzbl (%eax),%eax
    4708:	3c 10                	cmp    $0x10,%al
    470a:	75 07                	jne    4713 <HuffmanTree_makeTable+0x47d>
    470c:	b8 37 00 00 00       	mov    $0x37,%eax
    4711:	eb 11                	jmp    4724 <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    4713:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4717:	8b 45 f4             	mov    -0xc(%ebp),%eax
    471a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    471d:	7c db                	jl     46fa <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    471f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    4724:	c9                   	leave  
    4725:	c3                   	ret    

00004726 <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    4726:	55                   	push   %ebp
    4727:	89 e5                	mov    %esp,%ebp
    4729:	56                   	push   %esi
    472a:	53                   	push   %ebx
    472b:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    472e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    4735:	8b 45 08             	mov    0x8(%ebp),%eax
    4738:	8b 40 0c             	mov    0xc(%eax),%eax
    473b:	c1 e0 02             	shl    $0x2,%eax
    473e:	83 ec 0c             	sub    $0xc,%esp
    4741:	50                   	push   %eax
    4742:	e8 de eb ff ff       	call   3325 <lodepng_malloc>
    4747:	83 c4 10             	add    $0x10,%esp
    474a:	89 c2                	mov    %eax,%edx
    474c:	8b 45 08             	mov    0x8(%ebp),%eax
    474f:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4751:	8b 45 08             	mov    0x8(%ebp),%eax
    4754:	8b 40 08             	mov    0x8(%eax),%eax
    4757:	83 c0 01             	add    $0x1,%eax
    475a:	c1 e0 02             	shl    $0x2,%eax
    475d:	83 ec 0c             	sub    $0xc,%esp
    4760:	50                   	push   %eax
    4761:	e8 bf eb ff ff       	call   3325 <lodepng_malloc>
    4766:	83 c4 10             	add    $0x10,%esp
    4769:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    476c:	8b 45 08             	mov    0x8(%ebp),%eax
    476f:	8b 40 08             	mov    0x8(%eax),%eax
    4772:	83 c0 01             	add    $0x1,%eax
    4775:	c1 e0 02             	shl    $0x2,%eax
    4778:	83 ec 0c             	sub    $0xc,%esp
    477b:	50                   	push   %eax
    477c:	e8 a4 eb ff ff       	call   3325 <lodepng_malloc>
    4781:	83 c4 10             	add    $0x10,%esp
    4784:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    4787:	8b 45 08             	mov    0x8(%ebp),%eax
    478a:	8b 00                	mov    (%eax),%eax
    478c:	85 c0                	test   %eax,%eax
    478e:	74 0c                	je     479c <HuffmanTree_makeFromLengths2+0x76>
    4790:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    4794:	74 06                	je     479c <HuffmanTree_makeFromLengths2+0x76>
    4796:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    479a:	75 07                	jne    47a3 <HuffmanTree_makeFromLengths2+0x7d>
    479c:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    47a3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    47a7:	0f 85 7d 01 00 00    	jne    492a <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    47ad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    47b4:	eb 2c                	jmp    47e2 <HuffmanTree_makeFromLengths2+0xbc>
    47b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    47b9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    47c0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    47c3:	01 c2                	add    %eax,%edx
    47c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    47c8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    47cf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    47d2:	01 c8                	add    %ecx,%eax
    47d4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    47da:	8b 00                	mov    (%eax),%eax
    47dc:	89 02                	mov    %eax,(%edx)
    47de:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    47e2:	8b 45 08             	mov    0x8(%ebp),%eax
    47e5:	8b 40 08             	mov    0x8(%eax),%eax
    47e8:	83 c0 01             	add    $0x1,%eax
    47eb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    47ee:	75 c6                	jne    47b6 <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    47f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    47f7:	eb 27                	jmp    4820 <HuffmanTree_makeFromLengths2+0xfa>
    47f9:	8b 45 08             	mov    0x8(%ebp),%eax
    47fc:	8b 40 04             	mov    0x4(%eax),%eax
    47ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4802:	c1 e2 02             	shl    $0x2,%edx
    4805:	01 d0                	add    %edx,%eax
    4807:	8b 00                	mov    (%eax),%eax
    4809:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4810:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4813:	01 d0                	add    %edx,%eax
    4815:	8b 10                	mov    (%eax),%edx
    4817:	83 c2 01             	add    $0x1,%edx
    481a:	89 10                	mov    %edx,(%eax)
    481c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4820:	8b 45 08             	mov    0x8(%ebp),%eax
    4823:	8b 40 0c             	mov    0xc(%eax),%eax
    4826:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4829:	75 ce                	jne    47f9 <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    482b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    4832:	eb 47                	jmp    487b <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    4834:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4837:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    483e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4841:	01 d0                	add    %edx,%eax
    4843:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4846:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    484c:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    4853:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4856:	01 ca                	add    %ecx,%edx
    4858:	8b 0a                	mov    (%edx),%ecx
    485a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    485d:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4863:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    486a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    486d:	01 da                	add    %ebx,%edx
    486f:	8b 12                	mov    (%edx),%edx
    4871:	01 ca                	add    %ecx,%edx
    4873:	01 d2                	add    %edx,%edx
    4875:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4877:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    487b:	8b 45 08             	mov    0x8(%ebp),%eax
    487e:	8b 40 08             	mov    0x8(%eax),%eax
    4881:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4884:	73 ae                	jae    4834 <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4886:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    488d:	e9 89 00 00 00       	jmp    491b <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    4892:	8b 45 08             	mov    0x8(%ebp),%eax
    4895:	8b 40 04             	mov    0x4(%eax),%eax
    4898:	8b 55 ec             	mov    -0x14(%ebp),%edx
    489b:	c1 e2 02             	shl    $0x2,%edx
    489e:	01 d0                	add    %edx,%eax
    48a0:	8b 00                	mov    (%eax),%eax
    48a2:	85 c0                	test   %eax,%eax
    48a4:	74 71                	je     4917 <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    48a6:	8b 45 08             	mov    0x8(%ebp),%eax
    48a9:	8b 00                	mov    (%eax),%eax
    48ab:	8b 55 ec             	mov    -0x14(%ebp),%edx
    48ae:	c1 e2 02             	shl    $0x2,%edx
    48b1:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    48b4:	8b 45 08             	mov    0x8(%ebp),%eax
    48b7:	8b 40 04             	mov    0x4(%eax),%eax
    48ba:	8b 55 ec             	mov    -0x14(%ebp),%edx
    48bd:	c1 e2 02             	shl    $0x2,%edx
    48c0:	01 d0                	add    %edx,%eax
    48c2:	8b 00                	mov    (%eax),%eax
    48c4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    48cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    48ce:	01 c2                	add    %eax,%edx
    48d0:	8b 02                	mov    (%edx),%eax
    48d2:	8d 48 01             	lea    0x1(%eax),%ecx
    48d5:	89 0a                	mov    %ecx,(%edx)
    48d7:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    48d9:	8b 45 08             	mov    0x8(%ebp),%eax
    48dc:	8b 00                	mov    (%eax),%eax
    48de:	8b 55 ec             	mov    -0x14(%ebp),%edx
    48e1:	c1 e2 02             	shl    $0x2,%edx
    48e4:	01 c2                	add    %eax,%edx
    48e6:	8b 45 08             	mov    0x8(%ebp),%eax
    48e9:	8b 00                	mov    (%eax),%eax
    48eb:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    48ee:	c1 e1 02             	shl    $0x2,%ecx
    48f1:	01 c8                	add    %ecx,%eax
    48f3:	8b 18                	mov    (%eax),%ebx
    48f5:	8b 45 08             	mov    0x8(%ebp),%eax
    48f8:	8b 40 04             	mov    0x4(%eax),%eax
    48fb:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    48fe:	c1 e1 02             	shl    $0x2,%ecx
    4901:	01 c8                	add    %ecx,%eax
    4903:	8b 00                	mov    (%eax),%eax
    4905:	be 01 00 00 00       	mov    $0x1,%esi
    490a:	89 c1                	mov    %eax,%ecx
    490c:	d3 e6                	shl    %cl,%esi
    490e:	89 f0                	mov    %esi,%eax
    4910:	83 e8 01             	sub    $0x1,%eax
    4913:	21 d8                	and    %ebx,%eax
    4915:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4917:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    491b:	8b 45 08             	mov    0x8(%ebp),%eax
    491e:	8b 40 0c             	mov    0xc(%eax),%eax
    4921:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4924:	0f 85 68 ff ff ff    	jne    4892 <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    492a:	83 ec 0c             	sub    $0xc,%esp
    492d:	ff 75 e8             	pushl  -0x18(%ebp)
    4930:	e8 11 ea ff ff       	call   3346 <lodepng_free>
    4935:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    4938:	83 ec 0c             	sub    $0xc,%esp
    493b:	ff 75 e4             	pushl  -0x1c(%ebp)
    493e:	e8 03 ea ff ff       	call   3346 <lodepng_free>
    4943:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    4946:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    494a:	75 11                	jne    495d <HuffmanTree_makeFromLengths2+0x237>
    494c:	83 ec 0c             	sub    $0xc,%esp
    494f:	ff 75 08             	pushl  0x8(%ebp)
    4952:	e8 3f f9 ff ff       	call   4296 <HuffmanTree_makeTable>
    4957:	83 c4 10             	add    $0x10,%esp
    495a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    495d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    4960:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4963:	5b                   	pop    %ebx
    4964:	5e                   	pop    %esi
    4965:	5d                   	pop    %ebp
    4966:	c3                   	ret    

00004967 <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    4967:	55                   	push   %ebp
    4968:	89 e5                	mov    %esp,%ebp
    496a:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    496d:	8b 45 10             	mov    0x10(%ebp),%eax
    4970:	c1 e0 02             	shl    $0x2,%eax
    4973:	83 ec 0c             	sub    $0xc,%esp
    4976:	50                   	push   %eax
    4977:	e8 a9 e9 ff ff       	call   3325 <lodepng_malloc>
    497c:	83 c4 10             	add    $0x10,%esp
    497f:	89 c2                	mov    %eax,%edx
    4981:	8b 45 08             	mov    0x8(%ebp),%eax
    4984:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    4987:	8b 45 08             	mov    0x8(%ebp),%eax
    498a:	8b 40 04             	mov    0x4(%eax),%eax
    498d:	85 c0                	test   %eax,%eax
    498f:	75 07                	jne    4998 <HuffmanTree_makeFromLengths+0x31>
    4991:	b8 53 00 00 00       	mov    $0x53,%eax
    4996:	eb 56                	jmp    49ee <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    4998:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    499f:	eb 25                	jmp    49c6 <HuffmanTree_makeFromLengths+0x5f>
    49a1:	8b 45 08             	mov    0x8(%ebp),%eax
    49a4:	8b 40 04             	mov    0x4(%eax),%eax
    49a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    49aa:	c1 e2 02             	shl    $0x2,%edx
    49ad:	01 c2                	add    %eax,%edx
    49af:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49b2:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    49b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    49bc:	01 c8                	add    %ecx,%eax
    49be:	8b 00                	mov    (%eax),%eax
    49c0:	89 02                	mov    %eax,(%edx)
    49c2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    49c6:	8b 45 10             	mov    0x10(%ebp),%eax
    49c9:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    49cc:	75 d3                	jne    49a1 <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    49ce:	8b 55 10             	mov    0x10(%ebp),%edx
    49d1:	8b 45 08             	mov    0x8(%ebp),%eax
    49d4:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    49d7:	8b 45 08             	mov    0x8(%ebp),%eax
    49da:	8b 55 14             	mov    0x14(%ebp),%edx
    49dd:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    49e0:	83 ec 0c             	sub    $0xc,%esp
    49e3:	ff 75 08             	pushl  0x8(%ebp)
    49e6:	e8 3b fd ff ff       	call   4726 <HuffmanTree_makeFromLengths2>
    49eb:	83 c4 10             	add    $0x10,%esp
}
    49ee:	c9                   	leave  
    49ef:	c3                   	ret    

000049f0 <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    49f0:	55                   	push   %ebp
    49f1:	89 e5                	mov    %esp,%ebp
    49f3:	53                   	push   %ebx
    49f4:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    49f7:	8b 45 08             	mov    0x8(%ebp),%eax
    49fa:	8b 50 0c             	mov    0xc(%eax),%edx
    49fd:	8b 45 08             	mov    0x8(%ebp),%eax
    4a00:	8b 40 08             	mov    0x8(%eax),%eax
    4a03:	39 c2                	cmp    %eax,%edx
    4a05:	0f 82 0b 01 00 00    	jb     4b16 <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    4a0b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4a12:	eb 19                	jmp    4a2d <bpmnode_create+0x3d>
    4a14:	8b 45 08             	mov    0x8(%ebp),%eax
    4a17:	8b 40 04             	mov    0x4(%eax),%eax
    4a1a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a1d:	c1 e2 04             	shl    $0x4,%edx
    4a20:	01 d0                	add    %edx,%eax
    4a22:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    4a29:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4a2d:	8b 45 08             	mov    0x8(%ebp),%eax
    4a30:	8b 00                	mov    (%eax),%eax
    4a32:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4a35:	75 dd                	jne    4a14 <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    4a37:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4a3e:	eb 60                	jmp    4aa0 <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    4a40:	8b 45 08             	mov    0x8(%ebp),%eax
    4a43:	8b 40 18             	mov    0x18(%eax),%eax
    4a46:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a49:	c1 e2 02             	shl    $0x2,%edx
    4a4c:	01 d0                	add    %edx,%eax
    4a4e:	8b 00                	mov    (%eax),%eax
    4a50:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a53:	eb 13                	jmp    4a68 <bpmnode_create+0x78>
    4a55:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a58:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4a5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a62:	8b 40 08             	mov    0x8(%eax),%eax
    4a65:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a68:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4a6c:	75 e7                	jne    4a55 <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    4a6e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a71:	8b 40 1c             	mov    0x1c(%eax),%eax
    4a74:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4a77:	c1 e2 02             	shl    $0x2,%edx
    4a7a:	01 d0                	add    %edx,%eax
    4a7c:	8b 00                	mov    (%eax),%eax
    4a7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a81:	eb 13                	jmp    4a96 <bpmnode_create+0xa6>
    4a83:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a86:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4a8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4a90:	8b 40 08             	mov    0x8(%eax),%eax
    4a93:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4a96:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4a9a:	75 e7                	jne    4a83 <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    4a9c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4aa0:	8b 45 08             	mov    0x8(%ebp),%eax
    4aa3:	8b 40 14             	mov    0x14(%eax),%eax
    4aa6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4aa9:	75 95                	jne    4a40 <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    4aab:	8b 45 08             	mov    0x8(%ebp),%eax
    4aae:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    4ab5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4abc:	eb 44                	jmp    4b02 <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    4abe:	8b 45 08             	mov    0x8(%ebp),%eax
    4ac1:	8b 40 04             	mov    0x4(%eax),%eax
    4ac4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4ac7:	c1 e2 04             	shl    $0x4,%edx
    4aca:	01 d0                	add    %edx,%eax
    4acc:	8b 40 0c             	mov    0xc(%eax),%eax
    4acf:	85 c0                	test   %eax,%eax
    4ad1:	75 2b                	jne    4afe <bpmnode_create+0x10e>
    4ad3:	8b 45 08             	mov    0x8(%ebp),%eax
    4ad6:	8b 58 10             	mov    0x10(%eax),%ebx
    4ad9:	8b 45 08             	mov    0x8(%ebp),%eax
    4adc:	8b 40 08             	mov    0x8(%eax),%eax
    4adf:	8d 48 01             	lea    0x1(%eax),%ecx
    4ae2:	8b 55 08             	mov    0x8(%ebp),%edx
    4ae5:	89 4a 08             	mov    %ecx,0x8(%edx)
    4ae8:	c1 e0 02             	shl    $0x2,%eax
    4aeb:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    4aee:	8b 45 08             	mov    0x8(%ebp),%eax
    4af1:	8b 40 04             	mov    0x4(%eax),%eax
    4af4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4af7:	c1 e1 04             	shl    $0x4,%ecx
    4afa:	01 c8                	add    %ecx,%eax
    4afc:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    4afe:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4b02:	8b 45 08             	mov    0x8(%ebp),%eax
    4b05:	8b 00                	mov    (%eax),%eax
    4b07:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4b0a:	75 b2                	jne    4abe <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    4b0c:	8b 45 08             	mov    0x8(%ebp),%eax
    4b0f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    4b16:	8b 45 08             	mov    0x8(%ebp),%eax
    4b19:	8b 58 10             	mov    0x10(%eax),%ebx
    4b1c:	8b 45 08             	mov    0x8(%ebp),%eax
    4b1f:	8b 40 0c             	mov    0xc(%eax),%eax
    4b22:	8d 48 01             	lea    0x1(%eax),%ecx
    4b25:	8b 55 08             	mov    0x8(%ebp),%edx
    4b28:	89 4a 0c             	mov    %ecx,0xc(%edx)
    4b2b:	c1 e0 02             	shl    $0x2,%eax
    4b2e:	01 d8                	add    %ebx,%eax
    4b30:	8b 00                	mov    (%eax),%eax
    4b32:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    4b35:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b38:	8b 55 0c             	mov    0xc(%ebp),%edx
    4b3b:	89 10                	mov    %edx,(%eax)
  result->index = index;
    4b3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b40:	8b 55 10             	mov    0x10(%ebp),%edx
    4b43:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    4b46:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b49:	8b 55 14             	mov    0x14(%ebp),%edx
    4b4c:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    4b4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    4b52:	83 c4 10             	add    $0x10,%esp
    4b55:	5b                   	pop    %ebx
    4b56:	5d                   	pop    %ebp
    4b57:	c3                   	ret    

00004b58 <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    4b58:	55                   	push   %ebp
    4b59:	89 e5                	mov    %esp,%ebp
    4b5b:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    4b5e:	8b 45 0c             	mov    0xc(%ebp),%eax
    4b61:	c1 e0 04             	shl    $0x4,%eax
    4b64:	83 ec 0c             	sub    $0xc,%esp
    4b67:	50                   	push   %eax
    4b68:	e8 b8 e7 ff ff       	call   3325 <lodepng_malloc>
    4b6d:	83 c4 10             	add    $0x10,%esp
    4b70:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    4b73:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    4b7a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    4b81:	e9 41 01 00 00       	jmp    4cc7 <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    4b86:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b89:	83 e0 01             	and    $0x1,%eax
    4b8c:	85 c0                	test   %eax,%eax
    4b8e:	74 05                	je     4b95 <bpmnode_sort+0x3d>
    4b90:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4b93:	eb 03                	jmp    4b98 <bpmnode_sort+0x40>
    4b95:	8b 45 08             	mov    0x8(%ebp),%eax
    4b98:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    4b9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4b9e:	83 e0 01             	and    $0x1,%eax
    4ba1:	85 c0                	test   %eax,%eax
    4ba3:	74 05                	je     4baa <bpmnode_sort+0x52>
    4ba5:	8b 45 08             	mov    0x8(%ebp),%eax
    4ba8:	eb 03                	jmp    4bad <bpmnode_sort+0x55>
    4baa:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4bad:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4bb0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4bb7:	e9 f8 00 00 00       	jmp    4cb4 <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    4bbc:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4bbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4bc2:	01 c2                	add    %eax,%edx
    4bc4:	8b 45 0c             	mov    0xc(%ebp),%eax
    4bc7:	39 c2                	cmp    %eax,%edx
    4bc9:	0f 4e c2             	cmovle %edx,%eax
    4bcc:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    4bcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4bd2:	8d 14 00             	lea    (%eax,%eax,1),%edx
    4bd5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4bd8:	01 c2                	add    %eax,%edx
    4bda:	8b 45 0c             	mov    0xc(%ebp),%eax
    4bdd:	39 c2                	cmp    %eax,%edx
    4bdf:	0f 4e c2             	cmovle %edx,%eax
    4be2:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    4be5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4be8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    4beb:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4bee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    4bf1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4bf4:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4bf7:	e9 a4 00 00 00       	jmp    4ca0 <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    4bfc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4bff:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    4c02:	7d 62                	jge    4c66 <bpmnode_sort+0x10e>
    4c04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c07:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4c0a:	7d 22                	jge    4c2e <bpmnode_sort+0xd6>
    4c0c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4c0f:	c1 e0 04             	shl    $0x4,%eax
    4c12:	89 c2                	mov    %eax,%edx
    4c14:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4c17:	01 d0                	add    %edx,%eax
    4c19:	8b 10                	mov    (%eax),%edx
    4c1b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4c1e:	c1 e0 04             	shl    $0x4,%eax
    4c21:	89 c1                	mov    %eax,%ecx
    4c23:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4c26:	01 c8                	add    %ecx,%eax
    4c28:	8b 00                	mov    (%eax),%eax
    4c2a:	39 c2                	cmp    %eax,%edx
    4c2c:	7f 38                	jg     4c66 <bpmnode_sort+0x10e>
    4c2e:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4c31:	c1 e0 04             	shl    $0x4,%eax
    4c34:	89 c2                	mov    %eax,%edx
    4c36:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4c39:	01 d0                	add    %edx,%eax
    4c3b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4c3e:	8d 4a 01             	lea    0x1(%edx),%ecx
    4c41:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    4c44:	89 d1                	mov    %edx,%ecx
    4c46:	c1 e1 04             	shl    $0x4,%ecx
    4c49:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4c4c:	01 ca                	add    %ecx,%edx
    4c4e:	8b 0a                	mov    (%edx),%ecx
    4c50:	89 08                	mov    %ecx,(%eax)
    4c52:	8b 4a 04             	mov    0x4(%edx),%ecx
    4c55:	89 48 04             	mov    %ecx,0x4(%eax)
    4c58:	8b 4a 08             	mov    0x8(%edx),%ecx
    4c5b:	89 48 08             	mov    %ecx,0x8(%eax)
    4c5e:	8b 52 0c             	mov    0xc(%edx),%edx
    4c61:	89 50 0c             	mov    %edx,0xc(%eax)
    4c64:	eb 36                	jmp    4c9c <bpmnode_sort+0x144>
        else b[k] = a[j++];
    4c66:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4c69:	c1 e0 04             	shl    $0x4,%eax
    4c6c:	89 c2                	mov    %eax,%edx
    4c6e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4c71:	01 d0                	add    %edx,%eax
    4c73:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4c76:	8d 4a 01             	lea    0x1(%edx),%ecx
    4c79:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    4c7c:	89 d1                	mov    %edx,%ecx
    4c7e:	c1 e1 04             	shl    $0x4,%ecx
    4c81:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4c84:	01 ca                	add    %ecx,%edx
    4c86:	8b 0a                	mov    (%edx),%ecx
    4c88:	89 08                	mov    %ecx,(%eax)
    4c8a:	8b 4a 04             	mov    0x4(%edx),%ecx
    4c8d:	89 48 04             	mov    %ecx,0x4(%eax)
    4c90:	8b 4a 08             	mov    0x8(%edx),%ecx
    4c93:	89 48 08             	mov    %ecx,0x8(%eax)
    4c96:	8b 52 0c             	mov    0xc(%edx),%edx
    4c99:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    4c9c:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4ca0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4ca3:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4ca6:	0f 8c 50 ff ff ff    	jl     4bfc <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4cac:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4caf:	01 c0                	add    %eax,%eax
    4cb1:	01 45 ec             	add    %eax,-0x14(%ebp)
    4cb4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4cb7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4cba:	0f 8c fc fe ff ff    	jl     4bbc <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    4cc0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    4cc4:	d1 65 f4             	shll   -0xc(%ebp)
    4cc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4cca:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4ccd:	0f 8c b3 fe ff ff    	jl     4b86 <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    4cd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4cd6:	83 e0 01             	and    $0x1,%eax
    4cd9:	85 c0                	test   %eax,%eax
    4cdb:	74 18                	je     4cf5 <bpmnode_sort+0x19d>
    4cdd:	8b 45 0c             	mov    0xc(%ebp),%eax
    4ce0:	c1 e0 04             	shl    $0x4,%eax
    4ce3:	83 ec 04             	sub    $0x4,%esp
    4ce6:	50                   	push   %eax
    4ce7:	ff 75 dc             	pushl  -0x24(%ebp)
    4cea:	ff 75 08             	pushl  0x8(%ebp)
    4ced:	e8 71 e6 ff ff       	call   3363 <lodepng_memcpy>
    4cf2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    4cf5:	83 ec 0c             	sub    $0xc,%esp
    4cf8:	ff 75 dc             	pushl  -0x24(%ebp)
    4cfb:	e8 46 e6 ff ff       	call   3346 <lodepng_free>
    4d00:	83 c4 10             	add    $0x10,%esp
}
    4d03:	90                   	nop
    4d04:	c9                   	leave  
    4d05:	c3                   	ret    

00004d06 <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    4d06:	55                   	push   %ebp
    4d07:	89 e5                	mov    %esp,%ebp
    4d09:	56                   	push   %esi
    4d0a:	53                   	push   %ebx
    4d0b:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    4d0e:	8b 45 08             	mov    0x8(%ebp),%eax
    4d11:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d14:	8b 55 14             	mov    0x14(%ebp),%edx
    4d17:	c1 e2 02             	shl    $0x2,%edx
    4d1a:	01 d0                	add    %edx,%eax
    4d1c:	8b 00                	mov    (%eax),%eax
    4d1e:	8b 40 04             	mov    0x4(%eax),%eax
    4d21:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    4d24:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    4d28:	75 66                	jne    4d90 <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    4d2a:	8b 45 10             	mov    0x10(%ebp),%eax
    4d2d:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4d30:	0f 83 a0 01 00 00    	jae    4ed6 <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    4d36:	8b 45 08             	mov    0x8(%ebp),%eax
    4d39:	8b 40 18             	mov    0x18(%eax),%eax
    4d3c:	8b 55 14             	mov    0x14(%ebp),%edx
    4d3f:	c1 e2 02             	shl    $0x2,%edx
    4d42:	01 c2                	add    %eax,%edx
    4d44:	8b 45 08             	mov    0x8(%ebp),%eax
    4d47:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d4a:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4d4d:	c1 e1 02             	shl    $0x2,%ecx
    4d50:	01 c8                	add    %ecx,%eax
    4d52:	8b 00                	mov    (%eax),%eax
    4d54:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    4d56:	8b 45 08             	mov    0x8(%ebp),%eax
    4d59:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d5c:	8b 55 14             	mov    0x14(%ebp),%edx
    4d5f:	c1 e2 02             	shl    $0x2,%edx
    4d62:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4d65:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d68:	8d 50 01             	lea    0x1(%eax),%edx
    4d6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d6e:	c1 e0 04             	shl    $0x4,%eax
    4d71:	89 c1                	mov    %eax,%ecx
    4d73:	8b 45 0c             	mov    0xc(%ebp),%eax
    4d76:	01 c8                	add    %ecx,%eax
    4d78:	8b 00                	mov    (%eax),%eax
    4d7a:	6a 00                	push   $0x0
    4d7c:	52                   	push   %edx
    4d7d:	50                   	push   %eax
    4d7e:	ff 75 08             	pushl  0x8(%ebp)
    4d81:	e8 6a fc ff ff       	call   49f0 <bpmnode_create>
    4d86:	83 c4 10             	add    $0x10,%esp
    4d89:	89 03                	mov    %eax,(%ebx)
    4d8b:	e9 47 01 00 00       	jmp    4ed7 <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    4d90:	8b 45 08             	mov    0x8(%ebp),%eax
    4d93:	8b 40 18             	mov    0x18(%eax),%eax
    4d96:	8b 55 14             	mov    0x14(%ebp),%edx
    4d99:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4d9f:	c1 e2 02             	shl    $0x2,%edx
    4da2:	01 d0                	add    %edx,%eax
    4da4:	8b 00                	mov    (%eax),%eax
    4da6:	8b 10                	mov    (%eax),%edx
    4da8:	8b 45 08             	mov    0x8(%ebp),%eax
    4dab:	8b 40 1c             	mov    0x1c(%eax),%eax
    4dae:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4db1:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    4db7:	c1 e1 02             	shl    $0x2,%ecx
    4dba:	01 c8                	add    %ecx,%eax
    4dbc:	8b 00                	mov    (%eax),%eax
    4dbe:	8b 00                	mov    (%eax),%eax
    4dc0:	01 d0                	add    %edx,%eax
    4dc2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    4dc5:	8b 45 08             	mov    0x8(%ebp),%eax
    4dc8:	8b 40 18             	mov    0x18(%eax),%eax
    4dcb:	8b 55 14             	mov    0x14(%ebp),%edx
    4dce:	c1 e2 02             	shl    $0x2,%edx
    4dd1:	01 c2                	add    %eax,%edx
    4dd3:	8b 45 08             	mov    0x8(%ebp),%eax
    4dd6:	8b 40 1c             	mov    0x1c(%eax),%eax
    4dd9:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4ddc:	c1 e1 02             	shl    $0x2,%ecx
    4ddf:	01 c8                	add    %ecx,%eax
    4de1:	8b 00                	mov    (%eax),%eax
    4de3:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    4de5:	8b 45 10             	mov    0x10(%ebp),%eax
    4de8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4deb:	73 60                	jae    4e4d <boundaryPM+0x147>
    4ded:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4df0:	c1 e0 04             	shl    $0x4,%eax
    4df3:	89 c2                	mov    %eax,%edx
    4df5:	8b 45 0c             	mov    0xc(%ebp),%eax
    4df8:	01 d0                	add    %edx,%eax
    4dfa:	8b 00                	mov    (%eax),%eax
    4dfc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4dff:	7d 4c                	jge    4e4d <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    4e01:	8b 45 08             	mov    0x8(%ebp),%eax
    4e04:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e07:	8b 55 14             	mov    0x14(%ebp),%edx
    4e0a:	c1 e2 02             	shl    $0x2,%edx
    4e0d:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4e10:	8b 45 08             	mov    0x8(%ebp),%eax
    4e13:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e16:	8b 55 14             	mov    0x14(%ebp),%edx
    4e19:	c1 e2 02             	shl    $0x2,%edx
    4e1c:	01 d0                	add    %edx,%eax
    4e1e:	8b 00                	mov    (%eax),%eax
    4e20:	8b 50 08             	mov    0x8(%eax),%edx
    4e23:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e26:	8d 48 01             	lea    0x1(%eax),%ecx
    4e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e2c:	c1 e0 04             	shl    $0x4,%eax
    4e2f:	89 c6                	mov    %eax,%esi
    4e31:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e34:	01 f0                	add    %esi,%eax
    4e36:	8b 00                	mov    (%eax),%eax
    4e38:	52                   	push   %edx
    4e39:	51                   	push   %ecx
    4e3a:	50                   	push   %eax
    4e3b:	ff 75 08             	pushl  0x8(%ebp)
    4e3e:	e8 ad fb ff ff       	call   49f0 <bpmnode_create>
    4e43:	83 c4 10             	add    $0x10,%esp
    4e46:	89 03                	mov    %eax,(%ebx)
      return;
    4e48:	e9 8a 00 00 00       	jmp    4ed7 <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    4e4d:	8b 45 08             	mov    0x8(%ebp),%eax
    4e50:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e53:	8b 55 14             	mov    0x14(%ebp),%edx
    4e56:	c1 e2 02             	shl    $0x2,%edx
    4e59:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4e5c:	8b 45 08             	mov    0x8(%ebp),%eax
    4e5f:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e62:	8b 55 14             	mov    0x14(%ebp),%edx
    4e65:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4e6b:	c1 e2 02             	shl    $0x2,%edx
    4e6e:	01 d0                	add    %edx,%eax
    4e70:	8b 00                	mov    (%eax),%eax
    4e72:	50                   	push   %eax
    4e73:	ff 75 f4             	pushl  -0xc(%ebp)
    4e76:	ff 75 f0             	pushl  -0x10(%ebp)
    4e79:	ff 75 08             	pushl  0x8(%ebp)
    4e7c:	e8 6f fb ff ff       	call   49f0 <bpmnode_create>
    4e81:	83 c4 10             	add    $0x10,%esp
    4e84:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    4e86:	8b 45 18             	mov    0x18(%ebp),%eax
    4e89:	8d 50 01             	lea    0x1(%eax),%edx
    4e8c:	8b 45 10             	mov    0x10(%ebp),%eax
    4e8f:	83 e8 01             	sub    $0x1,%eax
    4e92:	01 c0                	add    %eax,%eax
    4e94:	39 c2                	cmp    %eax,%edx
    4e96:	7d 3f                	jge    4ed7 <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4e98:	8b 45 14             	mov    0x14(%ebp),%eax
    4e9b:	83 e8 01             	sub    $0x1,%eax
    4e9e:	83 ec 0c             	sub    $0xc,%esp
    4ea1:	ff 75 18             	pushl  0x18(%ebp)
    4ea4:	50                   	push   %eax
    4ea5:	ff 75 10             	pushl  0x10(%ebp)
    4ea8:	ff 75 0c             	pushl  0xc(%ebp)
    4eab:	ff 75 08             	pushl  0x8(%ebp)
    4eae:	e8 53 fe ff ff       	call   4d06 <boundaryPM>
    4eb3:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4eb6:	8b 45 14             	mov    0x14(%ebp),%eax
    4eb9:	83 e8 01             	sub    $0x1,%eax
    4ebc:	83 ec 0c             	sub    $0xc,%esp
    4ebf:	ff 75 18             	pushl  0x18(%ebp)
    4ec2:	50                   	push   %eax
    4ec3:	ff 75 10             	pushl  0x10(%ebp)
    4ec6:	ff 75 0c             	pushl  0xc(%ebp)
    4ec9:	ff 75 08             	pushl  0x8(%ebp)
    4ecc:	e8 35 fe ff ff       	call   4d06 <boundaryPM>
    4ed1:	83 c4 20             	add    $0x20,%esp
    4ed4:	eb 01                	jmp    4ed7 <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    4ed6:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    4ed7:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4eda:	5b                   	pop    %ebx
    4edb:	5e                   	pop    %esi
    4edc:	5d                   	pop    %ebp
    4edd:	c3                   	ret    

00004ede <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    4ede:	55                   	push   %ebp
    4edf:	89 e5                	mov    %esp,%ebp
    4ee1:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    4ee4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    4eeb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    4ef2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    4ef6:	75 0a                	jne    4f02 <lodepng_huffman_code_lengths+0x24>
    4ef8:	b8 50 00 00 00       	mov    $0x50,%eax
    4efd:	e9 4d 03 00 00       	jmp    524f <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    4f02:	8b 45 14             	mov    0x14(%ebp),%eax
    4f05:	ba 01 00 00 00       	mov    $0x1,%edx
    4f0a:	89 c1                	mov    %eax,%ecx
    4f0c:	d3 e2                	shl    %cl,%edx
    4f0e:	8b 45 10             	mov    0x10(%ebp),%eax
    4f11:	39 c2                	cmp    %eax,%edx
    4f13:	73 0a                	jae    4f1f <lodepng_huffman_code_lengths+0x41>
    4f15:	b8 50 00 00 00       	mov    $0x50,%eax
    4f1a:	e9 30 03 00 00       	jmp    524f <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    4f1f:	8b 45 10             	mov    0x10(%ebp),%eax
    4f22:	c1 e0 04             	shl    $0x4,%eax
    4f25:	83 ec 0c             	sub    $0xc,%esp
    4f28:	50                   	push   %eax
    4f29:	e8 f7 e3 ff ff       	call   3325 <lodepng_malloc>
    4f2e:	83 c4 10             	add    $0x10,%esp
    4f31:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    4f34:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4f38:	75 0a                	jne    4f44 <lodepng_huffman_code_lengths+0x66>
    4f3a:	b8 53 00 00 00       	mov    $0x53,%eax
    4f3f:	e9 0b 03 00 00       	jmp    524f <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    4f44:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4f4b:	eb 50                	jmp    4f9d <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    4f4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4f50:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4f57:	8b 45 0c             	mov    0xc(%ebp),%eax
    4f5a:	01 d0                	add    %edx,%eax
    4f5c:	8b 00                	mov    (%eax),%eax
    4f5e:	85 c0                	test   %eax,%eax
    4f60:	74 37                	je     4f99 <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    4f62:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f65:	c1 e0 04             	shl    $0x4,%eax
    4f68:	89 c2                	mov    %eax,%edx
    4f6a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4f6d:	01 d0                	add    %edx,%eax
    4f6f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4f72:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    4f79:	8b 55 0c             	mov    0xc(%ebp),%edx
    4f7c:	01 ca                	add    %ecx,%edx
    4f7e:	8b 12                	mov    (%edx),%edx
    4f80:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    4f82:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f85:	c1 e0 04             	shl    $0x4,%eax
    4f88:	89 c2                	mov    %eax,%edx
    4f8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4f8d:	01 c2                	add    %eax,%edx
    4f8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4f92:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    4f95:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    4f99:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4f9d:	8b 45 10             	mov    0x10(%ebp),%eax
    4fa0:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    4fa3:	75 a8                	jne    4f4d <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    4fa5:	8b 45 10             	mov    0x10(%ebp),%eax
    4fa8:	c1 e0 02             	shl    $0x2,%eax
    4fab:	83 ec 04             	sub    $0x4,%esp
    4fae:	50                   	push   %eax
    4faf:	6a 00                	push   $0x0
    4fb1:	ff 75 08             	pushl  0x8(%ebp)
    4fb4:	e8 dd e3 ff ff       	call   3396 <lodepng_memset>
    4fb9:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    4fbc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    4fc0:	75 18                	jne    4fda <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    4fc2:	8b 45 08             	mov    0x8(%ebp),%eax
    4fc5:	83 c0 04             	add    $0x4,%eax
    4fc8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    4fce:	8b 10                	mov    (%eax),%edx
    4fd0:	8b 45 08             	mov    0x8(%ebp),%eax
    4fd3:	89 10                	mov    %edx,(%eax)
    4fd5:	e9 64 02 00 00       	jmp    523e <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    4fda:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    4fde:	75 3e                	jne    501e <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    4fe0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4fe3:	8b 40 04             	mov    0x4(%eax),%eax
    4fe6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4fed:	8b 45 08             	mov    0x8(%ebp),%eax
    4ff0:	01 d0                	add    %edx,%eax
    4ff2:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    4ff8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4ffb:	8b 40 04             	mov    0x4(%eax),%eax
    4ffe:	85 c0                	test   %eax,%eax
    5000:	75 07                	jne    5009 <lodepng_huffman_code_lengths+0x12b>
    5002:	ba 04 00 00 00       	mov    $0x4,%edx
    5007:	eb 05                	jmp    500e <lodepng_huffman_code_lengths+0x130>
    5009:	ba 00 00 00 00       	mov    $0x0,%edx
    500e:	8b 45 08             	mov    0x8(%ebp),%eax
    5011:	01 d0                	add    %edx,%eax
    5013:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    5019:	e9 20 02 00 00       	jmp    523e <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    501e:	83 ec 08             	sub    $0x8,%esp
    5021:	ff 75 ec             	pushl  -0x14(%ebp)
    5024:	ff 75 e4             	pushl  -0x1c(%ebp)
    5027:	e8 2c fb ff ff       	call   4b58 <bpmnode_sort>
    502c:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    502f:	8b 45 14             	mov    0x14(%ebp),%eax
    5032:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    5035:	8b 45 14             	mov    0x14(%ebp),%eax
    5038:	83 c0 01             	add    $0x1,%eax
    503b:	0f af 45 14          	imul   0x14(%ebp),%eax
    503f:	01 c0                	add    %eax,%eax
    5041:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    5044:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    504b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    504e:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    5051:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5054:	c1 e0 04             	shl    $0x4,%eax
    5057:	83 ec 0c             	sub    $0xc,%esp
    505a:	50                   	push   %eax
    505b:	e8 c5 e2 ff ff       	call   3325 <lodepng_malloc>
    5060:	83 c4 10             	add    $0x10,%esp
    5063:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    5066:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5069:	c1 e0 02             	shl    $0x2,%eax
    506c:	83 ec 0c             	sub    $0xc,%esp
    506f:	50                   	push   %eax
    5070:	e8 b0 e2 ff ff       	call   3325 <lodepng_malloc>
    5075:	83 c4 10             	add    $0x10,%esp
    5078:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    507b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    507e:	c1 e0 02             	shl    $0x2,%eax
    5081:	83 ec 0c             	sub    $0xc,%esp
    5084:	50                   	push   %eax
    5085:	e8 9b e2 ff ff       	call   3325 <lodepng_malloc>
    508a:	83 c4 10             	add    $0x10,%esp
    508d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5090:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5093:	c1 e0 02             	shl    $0x2,%eax
    5096:	83 ec 0c             	sub    $0xc,%esp
    5099:	50                   	push   %eax
    509a:	e8 86 e2 ff ff       	call   3325 <lodepng_malloc>
    509f:	83 c4 10             	add    $0x10,%esp
    50a2:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    50a5:	8b 45 c8             	mov    -0x38(%ebp),%eax
    50a8:	85 c0                	test   %eax,%eax
    50aa:	74 15                	je     50c1 <lodepng_huffman_code_lengths+0x1e3>
    50ac:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    50af:	85 c0                	test   %eax,%eax
    50b1:	74 0e                	je     50c1 <lodepng_huffman_code_lengths+0x1e3>
    50b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
    50b6:	85 c0                	test   %eax,%eax
    50b8:	74 07                	je     50c1 <lodepng_huffman_code_lengths+0x1e3>
    50ba:	8b 45 e0             	mov    -0x20(%ebp),%eax
    50bd:	85 c0                	test   %eax,%eax
    50bf:	75 07                	jne    50c8 <lodepng_huffman_code_lengths+0x1ea>
    50c1:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    50c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    50cc:	0f 85 30 01 00 00    	jne    5202 <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    50d2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    50d9:	eb 1c                	jmp    50f7 <lodepng_huffman_code_lengths+0x219>
    50db:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    50de:	8b 55 f0             	mov    -0x10(%ebp),%edx
    50e1:	c1 e2 02             	shl    $0x2,%edx
    50e4:	01 d0                	add    %edx,%eax
    50e6:	8b 55 c8             	mov    -0x38(%ebp),%edx
    50e9:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    50ec:	c1 e1 04             	shl    $0x4,%ecx
    50ef:	01 ca                	add    %ecx,%edx
    50f1:	89 10                	mov    %edx,(%eax)
    50f3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    50f7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    50fa:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    50fd:	75 dc                	jne    50db <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    50ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5102:	8b 00                	mov    (%eax),%eax
    5104:	6a 00                	push   $0x0
    5106:	6a 01                	push   $0x1
    5108:	50                   	push   %eax
    5109:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    510c:	50                   	push   %eax
    510d:	e8 de f8 ff ff       	call   49f0 <bpmnode_create>
    5112:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    5115:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5118:	83 c0 10             	add    $0x10,%eax
    511b:	8b 00                	mov    (%eax),%eax
    511d:	6a 00                	push   $0x0
    511f:	6a 02                	push   $0x2
    5121:	50                   	push   %eax
    5122:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5125:	50                   	push   %eax
    5126:	e8 c5 f8 ff ff       	call   49f0 <bpmnode_create>
    512b:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    512e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5135:	eb 27                	jmp    515e <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    5137:	8b 45 dc             	mov    -0x24(%ebp),%eax
    513a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    513d:	c1 e2 02             	shl    $0x2,%edx
    5140:	01 c2                	add    %eax,%edx
    5142:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5145:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    5147:	8b 45 e0             	mov    -0x20(%ebp),%eax
    514a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    514d:	c1 e2 02             	shl    $0x2,%edx
    5150:	01 d0                	add    %edx,%eax
    5152:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5155:	83 c2 10             	add    $0x10,%edx
    5158:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    515a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    515e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5161:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5164:	75 d1                	jne    5137 <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    5166:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    516d:	eb 24                	jmp    5193 <lodepng_huffman_code_lengths+0x2b5>
    516f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5172:	8b 55 14             	mov    0x14(%ebp),%edx
    5175:	83 ea 01             	sub    $0x1,%edx
    5178:	83 ec 0c             	sub    $0xc,%esp
    517b:	50                   	push   %eax
    517c:	52                   	push   %edx
    517d:	ff 75 ec             	pushl  -0x14(%ebp)
    5180:	ff 75 e4             	pushl  -0x1c(%ebp)
    5183:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5186:	50                   	push   %eax
    5187:	e8 7a fb ff ff       	call   4d06 <boundaryPM>
    518c:	83 c4 20             	add    $0x20,%esp
    518f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5193:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5196:	83 e8 01             	sub    $0x1,%eax
    5199:	01 c0                	add    %eax,%eax
    519b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    519e:	75 cf                	jne    516f <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    51a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    51a3:	8b 55 14             	mov    0x14(%ebp),%edx
    51a6:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    51ac:	c1 e2 02             	shl    $0x2,%edx
    51af:	01 d0                	add    %edx,%eax
    51b1:	8b 00                	mov    (%eax),%eax
    51b3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    51b6:	eb 44                	jmp    51fc <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    51b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    51bf:	eb 27                	jmp    51e8 <lodepng_huffman_code_lengths+0x30a>
    51c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    51c4:	c1 e0 04             	shl    $0x4,%eax
    51c7:	89 c2                	mov    %eax,%edx
    51c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    51cc:	01 d0                	add    %edx,%eax
    51ce:	8b 40 04             	mov    0x4(%eax),%eax
    51d1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    51d8:	8b 45 08             	mov    0x8(%ebp),%eax
    51db:	01 d0                	add    %edx,%eax
    51dd:	8b 10                	mov    (%eax),%edx
    51df:	83 c2 01             	add    $0x1,%edx
    51e2:	89 10                	mov    %edx,(%eax)
    51e4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    51e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    51eb:	8b 40 04             	mov    0x4(%eax),%eax
    51ee:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    51f1:	75 ce                	jne    51c1 <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    51f3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    51f6:	8b 40 08             	mov    0x8(%eax),%eax
    51f9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    51fc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    5200:	75 b6                	jne    51b8 <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    5202:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5205:	83 ec 0c             	sub    $0xc,%esp
    5208:	50                   	push   %eax
    5209:	e8 38 e1 ff ff       	call   3346 <lodepng_free>
    520e:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    5211:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5214:	83 ec 0c             	sub    $0xc,%esp
    5217:	50                   	push   %eax
    5218:	e8 29 e1 ff ff       	call   3346 <lodepng_free>
    521d:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    5220:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5223:	83 ec 0c             	sub    $0xc,%esp
    5226:	50                   	push   %eax
    5227:	e8 1a e1 ff ff       	call   3346 <lodepng_free>
    522c:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    522f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5232:	83 ec 0c             	sub    $0xc,%esp
    5235:	50                   	push   %eax
    5236:	e8 0b e1 ff ff       	call   3346 <lodepng_free>
    523b:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    523e:	83 ec 0c             	sub    $0xc,%esp
    5241:	ff 75 e4             	pushl  -0x1c(%ebp)
    5244:	e8 fd e0 ff ff       	call   3346 <lodepng_free>
    5249:	83 c4 10             	add    $0x10,%esp
  return error;
    524c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    524f:	c9                   	leave  
    5250:	c3                   	ret    

00005251 <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    5251:	55                   	push   %ebp
    5252:	89 e5                	mov    %esp,%ebp
    5254:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    5257:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    525e:	eb 04                	jmp    5264 <HuffmanTree_makeFromFrequencies+0x13>
    5260:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    5264:	8b 45 14             	mov    0x14(%ebp),%eax
    5267:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    526c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5273:	8b 45 0c             	mov    0xc(%ebp),%eax
    5276:	01 d0                	add    %edx,%eax
    5278:	8b 00                	mov    (%eax),%eax
    527a:	85 c0                	test   %eax,%eax
    527c:	75 08                	jne    5286 <HuffmanTree_makeFromFrequencies+0x35>
    527e:	8b 45 14             	mov    0x14(%ebp),%eax
    5281:	3b 45 10             	cmp    0x10(%ebp),%eax
    5284:	7f da                	jg     5260 <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    5286:	8b 45 14             	mov    0x14(%ebp),%eax
    5289:	c1 e0 02             	shl    $0x2,%eax
    528c:	83 ec 0c             	sub    $0xc,%esp
    528f:	50                   	push   %eax
    5290:	e8 90 e0 ff ff       	call   3325 <lodepng_malloc>
    5295:	83 c4 10             	add    $0x10,%esp
    5298:	89 c2                	mov    %eax,%edx
    529a:	8b 45 08             	mov    0x8(%ebp),%eax
    529d:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    52a0:	8b 45 08             	mov    0x8(%ebp),%eax
    52a3:	8b 40 04             	mov    0x4(%eax),%eax
    52a6:	85 c0                	test   %eax,%eax
    52a8:	75 07                	jne    52b1 <HuffmanTree_makeFromFrequencies+0x60>
    52aa:	b8 53 00 00 00       	mov    $0x53,%eax
    52af:	eb 47                	jmp    52f8 <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    52b1:	8b 45 08             	mov    0x8(%ebp),%eax
    52b4:	8b 55 18             	mov    0x18(%ebp),%edx
    52b7:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    52ba:	8b 55 14             	mov    0x14(%ebp),%edx
    52bd:	8b 45 08             	mov    0x8(%ebp),%eax
    52c0:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    52c3:	8b 45 08             	mov    0x8(%ebp),%eax
    52c6:	8b 40 04             	mov    0x4(%eax),%eax
    52c9:	ff 75 18             	pushl  0x18(%ebp)
    52cc:	ff 75 14             	pushl  0x14(%ebp)
    52cf:	ff 75 0c             	pushl  0xc(%ebp)
    52d2:	50                   	push   %eax
    52d3:	e8 06 fc ff ff       	call   4ede <lodepng_huffman_code_lengths>
    52d8:	83 c4 10             	add    $0x10,%esp
    52db:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    52de:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    52e2:	75 11                	jne    52f5 <HuffmanTree_makeFromFrequencies+0xa4>
    52e4:	83 ec 0c             	sub    $0xc,%esp
    52e7:	ff 75 08             	pushl  0x8(%ebp)
    52ea:	e8 37 f4 ff ff       	call   4726 <HuffmanTree_makeFromLengths2>
    52ef:	83 c4 10             	add    $0x10,%esp
    52f2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    52f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    52f8:	c9                   	leave  
    52f9:	c3                   	ret    

000052fa <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    52fa:	55                   	push   %ebp
    52fb:	89 e5                	mov    %esp,%ebp
    52fd:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    5300:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    5307:	83 ec 0c             	sub    $0xc,%esp
    530a:	68 80 04 00 00       	push   $0x480
    530f:	e8 11 e0 ff ff       	call   3325 <lodepng_malloc>
    5314:	83 c4 10             	add    $0x10,%esp
    5317:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    531a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    531e:	75 0a                	jne    532a <generateFixedLitLenTree+0x30>
    5320:	b8 53 00 00 00       	mov    $0x53,%eax
    5325:	e9 d5 00 00 00       	jmp    53ff <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    532a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5331:	eb 19                	jmp    534c <generateFixedLitLenTree+0x52>
    5333:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5336:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    533d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5340:	01 d0                	add    %edx,%eax
    5342:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5348:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    534c:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    5353:	76 de                	jbe    5333 <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    5355:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    535c:	eb 19                	jmp    5377 <generateFixedLitLenTree+0x7d>
    535e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5361:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5368:	8b 45 ec             	mov    -0x14(%ebp),%eax
    536b:	01 d0                	add    %edx,%eax
    536d:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    5373:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5377:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    537e:	76 de                	jbe    535e <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    5380:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    5387:	eb 19                	jmp    53a2 <generateFixedLitLenTree+0xa8>
    5389:	8b 45 f4             	mov    -0xc(%ebp),%eax
    538c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5393:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5396:	01 d0                	add    %edx,%eax
    5398:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    539e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    53a2:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    53a9:	76 de                	jbe    5389 <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    53ab:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    53b2:	eb 19                	jmp    53cd <generateFixedLitLenTree+0xd3>
    53b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    53b7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    53be:	8b 45 ec             	mov    -0x14(%ebp),%eax
    53c1:	01 d0                	add    %edx,%eax
    53c3:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    53c9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    53cd:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    53d4:	76 de                	jbe    53b4 <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    53d6:	6a 0f                	push   $0xf
    53d8:	68 20 01 00 00       	push   $0x120
    53dd:	ff 75 ec             	pushl  -0x14(%ebp)
    53e0:	ff 75 08             	pushl  0x8(%ebp)
    53e3:	e8 7f f5 ff ff       	call   4967 <HuffmanTree_makeFromLengths>
    53e8:	83 c4 10             	add    $0x10,%esp
    53eb:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    53ee:	83 ec 0c             	sub    $0xc,%esp
    53f1:	ff 75 ec             	pushl  -0x14(%ebp)
    53f4:	e8 4d df ff ff       	call   3346 <lodepng_free>
    53f9:	83 c4 10             	add    $0x10,%esp
  return error;
    53fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    53ff:	c9                   	leave  
    5400:	c3                   	ret    

00005401 <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    5401:	55                   	push   %ebp
    5402:	89 e5                	mov    %esp,%ebp
    5404:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    5407:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    540e:	83 ec 0c             	sub    $0xc,%esp
    5411:	68 80 00 00 00       	push   $0x80
    5416:	e8 0a df ff ff       	call   3325 <lodepng_malloc>
    541b:	83 c4 10             	add    $0x10,%esp
    541e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    5421:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5425:	75 07                	jne    542e <generateFixedDistanceTree+0x2d>
    5427:	b8 53 00 00 00       	mov    $0x53,%eax
    542c:	eb 4e                	jmp    547c <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    542e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    5435:	eb 19                	jmp    5450 <generateFixedDistanceTree+0x4f>
    5437:	8b 45 f4             	mov    -0xc(%ebp),%eax
    543a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5441:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5444:	01 d0                	add    %edx,%eax
    5446:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    544c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5450:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    5454:	75 e1                	jne    5437 <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    5456:	6a 0f                	push   $0xf
    5458:	6a 20                	push   $0x20
    545a:	ff 75 ec             	pushl  -0x14(%ebp)
    545d:	ff 75 08             	pushl  0x8(%ebp)
    5460:	e8 02 f5 ff ff       	call   4967 <HuffmanTree_makeFromLengths>
    5465:	83 c4 10             	add    $0x10,%esp
    5468:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    546b:	83 ec 0c             	sub    $0xc,%esp
    546e:	ff 75 ec             	pushl  -0x14(%ebp)
    5471:	e8 d0 de ff ff       	call   3346 <lodepng_free>
    5476:	83 c4 10             	add    $0x10,%esp
  return error;
    5479:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    547c:	c9                   	leave  
    547d:	c3                   	ret    

0000547e <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    547e:	55                   	push   %ebp
    547f:	89 e5                	mov    %esp,%ebp
    5481:	53                   	push   %ebx
    5482:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    5485:	6a 09                	push   $0x9
    5487:	ff 75 08             	pushl  0x8(%ebp)
    548a:	e8 d8 eb ff ff       	call   4067 <peekBits>
    548f:	83 c4 08             	add    $0x8,%esp
    5492:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    5496:	8b 45 0c             	mov    0xc(%ebp),%eax
    5499:	8b 50 10             	mov    0x10(%eax),%edx
    549c:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    54a0:	01 d0                	add    %edx,%eax
    54a2:	0f b6 00             	movzbl (%eax),%eax
    54a5:	0f b6 c0             	movzbl %al,%eax
    54a8:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    54ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    54af:	8b 40 14             	mov    0x14(%eax),%eax
    54b2:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    54b6:	01 d2                	add    %edx,%edx
    54b8:	01 d0                	add    %edx,%eax
    54ba:	0f b7 00             	movzwl (%eax),%eax
    54bd:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    54c1:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    54c6:	77 16                	ja     54de <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    54c8:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    54cc:	50                   	push   %eax
    54cd:	ff 75 08             	pushl  0x8(%ebp)
    54d0:	e8 b2 eb ff ff       	call   4087 <advanceBits>
    54d5:	83 c4 08             	add    $0x8,%esp
    return value;
    54d8:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    54dc:	eb 5c                	jmp    553a <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    54de:	6a 09                	push   $0x9
    54e0:	ff 75 08             	pushl  0x8(%ebp)
    54e3:	e8 9f eb ff ff       	call   4087 <advanceBits>
    54e8:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    54eb:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    54ef:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    54f3:	83 e8 09             	sub    $0x9,%eax
    54f6:	50                   	push   %eax
    54f7:	ff 75 08             	pushl  0x8(%ebp)
    54fa:	e8 68 eb ff ff       	call   4067 <peekBits>
    54ff:	83 c4 08             	add    $0x8,%esp
    5502:	01 d8                	add    %ebx,%eax
    5504:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    5507:	8b 45 0c             	mov    0xc(%ebp),%eax
    550a:	8b 50 10             	mov    0x10(%eax),%edx
    550d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5510:	01 d0                	add    %edx,%eax
    5512:	0f b6 00             	movzbl (%eax),%eax
    5515:	0f b6 c0             	movzbl %al,%eax
    5518:	83 e8 09             	sub    $0x9,%eax
    551b:	50                   	push   %eax
    551c:	ff 75 08             	pushl  0x8(%ebp)
    551f:	e8 63 eb ff ff       	call   4087 <advanceBits>
    5524:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    5527:	8b 45 0c             	mov    0xc(%ebp),%eax
    552a:	8b 40 14             	mov    0x14(%eax),%eax
    552d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5530:	01 d2                	add    %edx,%edx
    5532:	01 d0                	add    %edx,%eax
    5534:	0f b7 00             	movzwl (%eax),%eax
    5537:	0f b7 c0             	movzwl %ax,%eax
  }
}
    553a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    553d:	c9                   	leave  
    553e:	c3                   	ret    

0000553f <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    553f:	55                   	push   %ebp
    5540:	89 e5                	mov    %esp,%ebp
    5542:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    5545:	83 ec 0c             	sub    $0xc,%esp
    5548:	ff 75 08             	pushl  0x8(%ebp)
    554b:	e8 aa fd ff ff       	call   52fa <generateFixedLitLenTree>
    5550:	83 c4 10             	add    $0x10,%esp
    5553:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    5556:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    555a:	74 05                	je     5561 <getTreeInflateFixed+0x22>
    555c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    555f:	eb 0e                	jmp    556f <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    5561:	83 ec 0c             	sub    $0xc,%esp
    5564:	ff 75 0c             	pushl  0xc(%ebp)
    5567:	e8 95 fe ff ff       	call   5401 <generateFixedDistanceTree>
    556c:	83 c4 10             	add    $0x10,%esp
}
    556f:	c9                   	leave  
    5570:	c3                   	ret    

00005571 <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    5571:	55                   	push   %ebp
    5572:	89 e5                	mov    %esp,%ebp
    5574:	53                   	push   %ebx
    5575:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    5578:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    557f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    5586:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    558d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    5594:	6a 0e                	push   $0xe
    5596:	ff 75 10             	pushl  0x10(%ebp)
    5599:	e8 37 e6 ff ff       	call   3bd5 <ensureBits17>
    559e:	83 c4 08             	add    $0x8,%esp
    55a1:	85 c0                	test   %eax,%eax
    55a3:	75 0a                	jne    55af <getTreeInflateDynamic+0x3e>
    55a5:	b8 31 00 00 00       	mov    $0x31,%eax
    55aa:	e9 ec 04 00 00       	jmp    5a9b <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    55af:	6a 05                	push   $0x5
    55b1:	ff 75 10             	pushl  0x10(%ebp)
    55b4:	e8 f8 ea ff ff       	call   40b1 <readBits>
    55b9:	83 c4 08             	add    $0x8,%esp
    55bc:	05 01 01 00 00       	add    $0x101,%eax
    55c1:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    55c4:	6a 05                	push   $0x5
    55c6:	ff 75 10             	pushl  0x10(%ebp)
    55c9:	e8 e3 ea ff ff       	call   40b1 <readBits>
    55ce:	83 c4 08             	add    $0x8,%esp
    55d1:	83 c0 01             	add    $0x1,%eax
    55d4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    55d7:	6a 04                	push   $0x4
    55d9:	ff 75 10             	pushl  0x10(%ebp)
    55dc:	e8 d0 ea ff ff       	call   40b1 <readBits>
    55e1:	83 c4 08             	add    $0x8,%esp
    55e4:	83 c0 04             	add    $0x4,%eax
    55e7:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    55ea:	83 ec 0c             	sub    $0xc,%esp
    55ed:	6a 4c                	push   $0x4c
    55ef:	e8 31 dd ff ff       	call   3325 <lodepng_malloc>
    55f4:	83 c4 10             	add    $0x10,%esp
    55f7:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    55fa:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    55fe:	75 0a                	jne    560a <getTreeInflateDynamic+0x99>
    5600:	b8 53 00 00 00       	mov    $0x53,%eax
    5605:	e9 91 04 00 00       	jmp    5a9b <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    560a:	83 ec 0c             	sub    $0xc,%esp
    560d:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5610:	50                   	push   %eax
    5611:	e8 03 ec ff ff       	call   4219 <HuffmanTree_init>
    5616:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    5619:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    561d:	0f 85 3c 04 00 00    	jne    5a5f <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    5623:	8b 45 10             	mov    0x10(%ebp),%eax
    5626:	8b 48 08             	mov    0x8(%eax),%ecx
    5629:	8b 55 d0             	mov    -0x30(%ebp),%edx
    562c:	89 d0                	mov    %edx,%eax
    562e:	01 c0                	add    %eax,%eax
    5630:	01 d0                	add    %edx,%eax
    5632:	89 c2                	mov    %eax,%edx
    5634:	8b 45 10             	mov    0x10(%ebp),%eax
    5637:	8b 40 0c             	mov    0xc(%eax),%eax
    563a:	83 ec 04             	sub    $0x4,%esp
    563d:	51                   	push   %ecx
    563e:	52                   	push   %edx
    563f:	50                   	push   %eax
    5640:	e8 f7 dd ff ff       	call   343c <lodepng_gtofl>
    5645:	83 c4 10             	add    $0x10,%esp
    5648:	85 c0                	test   %eax,%eax
    564a:	74 0c                	je     5658 <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    564c:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5653:	e9 07 04 00 00       	jmp    5a5f <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    5658:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    565f:	eb 3d                	jmp    569e <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    5661:	83 ec 08             	sub    $0x8,%esp
    5664:	6a 03                	push   $0x3
    5666:	ff 75 10             	pushl  0x10(%ebp)
    5669:	e8 8b e4 ff ff       	call   3af9 <ensureBits9>
    566e:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    5671:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5674:	8b 04 85 40 9f 01 00 	mov    0x19f40(,%eax,4),%eax
    567b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5682:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5685:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    5688:	83 ec 08             	sub    $0x8,%esp
    568b:	6a 03                	push   $0x3
    568d:	ff 75 10             	pushl  0x10(%ebp)
    5690:	e8 1c ea ff ff       	call   40b1 <readBits>
    5695:	83 c4 10             	add    $0x10,%esp
    5698:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    569a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    569e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    56a1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    56a4:	75 bb                	jne    5661 <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    56a6:	8b 45 d0             	mov    -0x30(%ebp),%eax
    56a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    56ac:	eb 20                	jmp    56ce <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    56ae:	8b 45 ec             	mov    -0x14(%ebp),%eax
    56b1:	8b 04 85 40 9f 01 00 	mov    0x19f40(,%eax,4),%eax
    56b8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    56bf:	8b 45 dc             	mov    -0x24(%ebp),%eax
    56c2:	01 d0                	add    %edx,%eax
    56c4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    56ca:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    56ce:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    56d2:	75 da                	jne    56ae <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    56d4:	6a 07                	push   $0x7
    56d6:	6a 13                	push   $0x13
    56d8:	ff 75 dc             	pushl  -0x24(%ebp)
    56db:	8d 45 a8             	lea    -0x58(%ebp),%eax
    56de:	50                   	push   %eax
    56df:	e8 83 f2 ff ff       	call   4967 <HuffmanTree_makeFromLengths>
    56e4:	83 c4 10             	add    $0x10,%esp
    56e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    56ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    56ee:	0f 85 64 03 00 00    	jne    5a58 <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    56f4:	83 ec 0c             	sub    $0xc,%esp
    56f7:	68 80 04 00 00       	push   $0x480
    56fc:	e8 24 dc ff ff       	call   3325 <lodepng_malloc>
    5701:	83 c4 10             	add    $0x10,%esp
    5704:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    5707:	83 ec 0c             	sub    $0xc,%esp
    570a:	68 80 00 00 00       	push   $0x80
    570f:	e8 11 dc ff ff       	call   3325 <lodepng_malloc>
    5714:	83 c4 10             	add    $0x10,%esp
    5717:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    571a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    571e:	74 06                	je     5726 <getTreeInflateDynamic+0x1b5>
    5720:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5724:	75 0c                	jne    5732 <getTreeInflateDynamic+0x1c1>
    5726:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    572d:	e9 2d 03 00 00       	jmp    5a5f <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    5732:	83 ec 04             	sub    $0x4,%esp
    5735:	68 80 04 00 00       	push   $0x480
    573a:	6a 00                	push   $0x0
    573c:	ff 75 e8             	pushl  -0x18(%ebp)
    573f:	e8 52 dc ff ff       	call   3396 <lodepng_memset>
    5744:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    5747:	83 ec 04             	sub    $0x4,%esp
    574a:	68 80 00 00 00       	push   $0x80
    574f:	6a 00                	push   $0x0
    5751:	ff 75 e4             	pushl  -0x1c(%ebp)
    5754:	e8 3d dc ff ff       	call   3396 <lodepng_memset>
    5759:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    575c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    5763:	e9 8d 02 00 00       	jmp    59f5 <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    5768:	83 ec 08             	sub    $0x8,%esp
    576b:	6a 16                	push   $0x16
    576d:	ff 75 10             	pushl  0x10(%ebp)
    5770:	e8 8c e5 ff ff       	call   3d01 <ensureBits25>
    5775:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    5778:	83 ec 08             	sub    $0x8,%esp
    577b:	8d 45 a8             	lea    -0x58(%ebp),%eax
    577e:	50                   	push   %eax
    577f:	ff 75 10             	pushl  0x10(%ebp)
    5782:	e8 f7 fc ff ff       	call   547e <huffmanDecodeSymbol>
    5787:	83 c4 10             	add    $0x10,%esp
    578a:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    578d:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    5791:	77 3e                	ja     57d1 <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    5793:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5796:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5799:	73 16                	jae    57b1 <getTreeInflateDynamic+0x240>
    579b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    579e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    57a5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    57a8:	01 c2                	add    %eax,%edx
    57aa:	8b 45 cc             	mov    -0x34(%ebp),%eax
    57ad:	89 02                	mov    %eax,(%edx)
    57af:	eb 17                	jmp    57c8 <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    57b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    57b4:	2b 45 d8             	sub    -0x28(%ebp),%eax
    57b7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    57be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    57c1:	01 c2                	add    %eax,%edx
    57c3:	8b 45 cc             	mov    -0x34(%ebp),%eax
    57c6:	89 02                	mov    %eax,(%edx)
        ++i;
    57c8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    57cc:	e9 0b 02 00 00       	jmp    59dc <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    57d1:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    57d5:	0f 85 da 00 00 00    	jne    58b5 <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    57db:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    57e2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    57e6:	75 0c                	jne    57f4 <getTreeInflateDynamic+0x283>
    57e8:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    57ef:	e9 12 02 00 00       	jmp    5a06 <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    57f4:	83 ec 08             	sub    $0x8,%esp
    57f7:	6a 02                	push   $0x2
    57f9:	ff 75 10             	pushl  0x10(%ebp)
    57fc:	e8 b0 e8 ff ff       	call   40b1 <readBits>
    5801:	83 c4 10             	add    $0x10,%esp
    5804:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    5807:	8b 45 d8             	mov    -0x28(%ebp),%eax
    580a:	83 c0 01             	add    $0x1,%eax
    580d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5810:	76 1b                	jbe    582d <getTreeInflateDynamic+0x2bc>
    5812:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5815:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    581a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5821:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5824:	01 d0                	add    %edx,%eax
    5826:	8b 00                	mov    (%eax),%eax
    5828:	89 45 e0             	mov    %eax,-0x20(%ebp)
    582b:	eb 1c                	jmp    5849 <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    582d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5830:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5833:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5838:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    583f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5842:	01 d0                	add    %edx,%eax
    5844:	8b 00                	mov    (%eax),%eax
    5846:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5849:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5850:	eb 56                	jmp    58a8 <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    5852:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5855:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5858:	01 d0                	add    %edx,%eax
    585a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    585d:	77 0c                	ja     586b <getTreeInflateDynamic+0x2fa>
    585f:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    5866:	e9 71 01 00 00       	jmp    59dc <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    586b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    586e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5871:	73 16                	jae    5889 <getTreeInflateDynamic+0x318>
    5873:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5876:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    587d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5880:	01 c2                	add    %eax,%edx
    5882:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5885:	89 02                	mov    %eax,(%edx)
    5887:	eb 17                	jmp    58a0 <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    5889:	8b 45 ec             	mov    -0x14(%ebp),%eax
    588c:	2b 45 d8             	sub    -0x28(%ebp),%eax
    588f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5896:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5899:	01 c2                	add    %eax,%edx
    589b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    589e:	89 02                	mov    %eax,(%edx)
          ++i;
    58a0:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    58a4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    58a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    58ab:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    58ae:	72 a2                	jb     5852 <getTreeInflateDynamic+0x2e1>
    58b0:	e9 27 01 00 00       	jmp    59dc <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    58b5:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    58b9:	0f 85 88 00 00 00    	jne    5947 <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    58bf:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    58c6:	83 ec 08             	sub    $0x8,%esp
    58c9:	6a 03                	push   $0x3
    58cb:	ff 75 10             	pushl  0x10(%ebp)
    58ce:	e8 de e7 ff ff       	call   40b1 <readBits>
    58d3:	83 c4 10             	add    $0x10,%esp
    58d6:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    58d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    58e0:	eb 58                	jmp    593a <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    58e2:	8b 55 d8             	mov    -0x28(%ebp),%edx
    58e5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    58e8:	01 d0                	add    %edx,%eax
    58ea:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    58ed:	77 0c                	ja     58fb <getTreeInflateDynamic+0x38a>
    58ef:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    58f6:	e9 e1 00 00 00       	jmp    59dc <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    58fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58fe:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5901:	73 17                	jae    591a <getTreeInflateDynamic+0x3a9>
    5903:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5906:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    590d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5910:	01 d0                	add    %edx,%eax
    5912:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5918:	eb 18                	jmp    5932 <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    591a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    591d:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5920:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5927:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    592a:	01 d0                	add    %edx,%eax
    592c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5932:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5936:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    593a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    593d:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    5940:	72 a0                	jb     58e2 <getTreeInflateDynamic+0x371>
    5942:	e9 95 00 00 00       	jmp    59dc <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    5947:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    594b:	0f 85 82 00 00 00    	jne    59d3 <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    5951:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    5958:	83 ec 08             	sub    $0x8,%esp
    595b:	6a 07                	push   $0x7
    595d:	ff 75 10             	pushl  0x10(%ebp)
    5960:	e8 4c e7 ff ff       	call   40b1 <readBits>
    5965:	83 c4 10             	add    $0x10,%esp
    5968:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    596b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5972:	eb 55                	jmp    59c9 <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    5974:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5977:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    597a:	01 d0                	add    %edx,%eax
    597c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    597f:	77 09                	ja     598a <getTreeInflateDynamic+0x419>
    5981:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    5988:	eb 52                	jmp    59dc <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    598a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    598d:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5990:	73 17                	jae    59a9 <getTreeInflateDynamic+0x438>
    5992:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5995:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    599c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    599f:	01 d0                	add    %edx,%eax
    59a1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    59a7:	eb 18                	jmp    59c1 <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    59a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59ac:	2b 45 d8             	sub    -0x28(%ebp),%eax
    59af:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    59b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    59b9:	01 d0                	add    %edx,%eax
    59bb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    59c1:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    59c5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    59c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    59cc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    59cf:	72 a3                	jb     5974 <getTreeInflateDynamic+0x403>
    59d1:	eb 09                	jmp    59dc <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    59d3:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    59da:	eb 2a                	jmp    5a06 <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    59dc:	8b 45 10             	mov    0x10(%ebp),%eax
    59df:	8b 50 0c             	mov    0xc(%eax),%edx
    59e2:	8b 45 10             	mov    0x10(%ebp),%eax
    59e5:	8b 40 08             	mov    0x8(%eax),%eax
    59e8:	39 c2                	cmp    %eax,%edx
    59ea:	7e 09                	jle    59f5 <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    59ec:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    59f3:	eb 11                	jmp    5a06 <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    59f5:	8b 55 d8             	mov    -0x28(%ebp),%edx
    59f8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    59fb:	01 d0                	add    %edx,%eax
    59fd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5a00:	0f 87 62 fd ff ff    	ja     5768 <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5a06:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5a0a:	75 4f                	jne    5a5b <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    5a0c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5a0f:	05 00 04 00 00       	add    $0x400,%eax
    5a14:	8b 00                	mov    (%eax),%eax
    5a16:	85 c0                	test   %eax,%eax
    5a18:	75 09                	jne    5a23 <getTreeInflateDynamic+0x4b2>
    5a1a:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    5a21:	eb 3c                	jmp    5a5f <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5a23:	6a 0f                	push   $0xf
    5a25:	68 20 01 00 00       	push   $0x120
    5a2a:	ff 75 e8             	pushl  -0x18(%ebp)
    5a2d:	ff 75 08             	pushl  0x8(%ebp)
    5a30:	e8 32 ef ff ff       	call   4967 <HuffmanTree_makeFromLengths>
    5a35:	83 c4 10             	add    $0x10,%esp
    5a38:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5a3b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5a3f:	75 1d                	jne    5a5e <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    5a41:	6a 0f                	push   $0xf
    5a43:	6a 20                	push   $0x20
    5a45:	ff 75 e4             	pushl  -0x1c(%ebp)
    5a48:	ff 75 0c             	pushl  0xc(%ebp)
    5a4b:	e8 17 ef ff ff       	call   4967 <HuffmanTree_makeFromLengths>
    5a50:	83 c4 10             	add    $0x10,%esp
    5a53:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    5a56:	eb 07                	jmp    5a5f <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    5a58:	90                   	nop
    5a59:	eb 04                	jmp    5a5f <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5a5b:	90                   	nop
    5a5c:	eb 01                	jmp    5a5f <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    5a5e:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    5a5f:	83 ec 0c             	sub    $0xc,%esp
    5a62:	ff 75 dc             	pushl  -0x24(%ebp)
    5a65:	e8 dc d8 ff ff       	call   3346 <lodepng_free>
    5a6a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    5a6d:	83 ec 0c             	sub    $0xc,%esp
    5a70:	ff 75 e8             	pushl  -0x18(%ebp)
    5a73:	e8 ce d8 ff ff       	call   3346 <lodepng_free>
    5a78:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    5a7b:	83 ec 0c             	sub    $0xc,%esp
    5a7e:	ff 75 e4             	pushl  -0x1c(%ebp)
    5a81:	e8 c0 d8 ff ff       	call   3346 <lodepng_free>
    5a86:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    5a89:	83 ec 0c             	sub    $0xc,%esp
    5a8c:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5a8f:	50                   	push   %eax
    5a90:	e8 b1 e7 ff ff       	call   4246 <HuffmanTree_cleanup>
    5a95:	83 c4 10             	add    $0x10,%esp

  return error;
    5a98:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5a9b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5a9e:	c9                   	leave  
    5a9f:	c3                   	ret    

00005aa0 <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    5aa0:	55                   	push   %ebp
    5aa1:	89 e5                	mov    %esp,%ebp
    5aa3:	53                   	push   %ebx
    5aa4:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    5aa7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    5aae:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5ab1:	50                   	push   %eax
    5ab2:	e8 62 e7 ff ff       	call   4219 <HuffmanTree_init>
    5ab7:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    5aba:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5abd:	50                   	push   %eax
    5abe:	e8 56 e7 ff ff       	call   4219 <HuffmanTree_init>
    5ac3:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    5ac6:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    5aca:	75 1b                	jne    5ae7 <inflateHuffmanBlock+0x47>
    5acc:	83 ec 08             	sub    $0x8,%esp
    5acf:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5ad2:	50                   	push   %eax
    5ad3:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5ad6:	50                   	push   %eax
    5ad7:	e8 63 fa ff ff       	call   553f <getTreeInflateFixed>
    5adc:	83 c4 10             	add    $0x10,%esp
    5adf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5ae2:	e9 9a 02 00 00       	jmp    5d81 <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    5ae7:	83 ec 04             	sub    $0x4,%esp
    5aea:	ff 75 0c             	pushl  0xc(%ebp)
    5aed:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5af0:	50                   	push   %eax
    5af1:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5af4:	50                   	push   %eax
    5af5:	e8 77 fa ff ff       	call   5571 <getTreeInflateDynamic>
    5afa:	83 c4 10             	add    $0x10,%esp
    5afd:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5b00:	e9 7c 02 00 00       	jmp    5d81 <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    5b05:	83 ec 08             	sub    $0x8,%esp
    5b08:	6a 14                	push   $0x14
    5b0a:	ff 75 0c             	pushl  0xc(%ebp)
    5b0d:	e8 ef e1 ff ff       	call   3d01 <ensureBits25>
    5b12:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    5b15:	83 ec 08             	sub    $0x8,%esp
    5b18:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5b1b:	50                   	push   %eax
    5b1c:	ff 75 0c             	pushl  0xc(%ebp)
    5b1f:	e8 5a f9 ff ff       	call   547e <huffmanDecodeSymbol>
    5b24:	83 c4 10             	add    $0x10,%esp
    5b27:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    5b2a:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    5b31:	77 42                	ja     5b75 <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    5b33:	8b 45 08             	mov    0x8(%ebp),%eax
    5b36:	8b 40 04             	mov    0x4(%eax),%eax
    5b39:	83 c0 01             	add    $0x1,%eax
    5b3c:	83 ec 08             	sub    $0x8,%esp
    5b3f:	50                   	push   %eax
    5b40:	ff 75 08             	pushl  0x8(%ebp)
    5b43:	e8 37 da ff ff       	call   357f <ucvector_resize>
    5b48:	83 c4 10             	add    $0x10,%esp
    5b4b:	85 c0                	test   %eax,%eax
    5b4d:	75 0c                	jne    5b5b <inflateHuffmanBlock+0xbb>
    5b4f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5b56:	e9 33 02 00 00       	jmp    5d8e <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    5b5b:	8b 45 08             	mov    0x8(%ebp),%eax
    5b5e:	8b 10                	mov    (%eax),%edx
    5b60:	8b 45 08             	mov    0x8(%ebp),%eax
    5b63:	8b 40 04             	mov    0x4(%eax),%eax
    5b66:	83 e8 01             	sub    $0x1,%eax
    5b69:	01 d0                	add    %edx,%eax
    5b6b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    5b6e:	88 10                	mov    %dl,(%eax)
    5b70:	e9 d9 01 00 00       	jmp    5d4e <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5b75:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5b7c:	0f 86 ba 01 00 00    	jbe    5d3c <inflateHuffmanBlock+0x29c>
    5b82:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    5b89:	0f 87 ad 01 00 00    	ja     5d3c <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    5b8f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5b92:	2d 01 01 00 00       	sub    $0x101,%eax
    5b97:	8b 04 85 40 9d 01 00 	mov    0x19d40(,%eax,4),%eax
    5b9e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    5ba1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5ba4:	2d 01 01 00 00       	sub    $0x101,%eax
    5ba9:	8b 04 85 c0 9d 01 00 	mov    0x19dc0(,%eax,4),%eax
    5bb0:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    5bb3:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    5bb7:	74 1c                	je     5bd5 <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    5bb9:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5bbc:	83 ec 08             	sub    $0x8,%esp
    5bbf:	50                   	push   %eax
    5bc0:	ff 75 0c             	pushl  0xc(%ebp)
    5bc3:	e8 e9 e4 ff ff       	call   40b1 <readBits>
    5bc8:	83 c4 10             	add    $0x10,%esp
    5bcb:	89 c2                	mov    %eax,%edx
    5bcd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5bd0:	01 d0                	add    %edx,%eax
    5bd2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    5bd5:	83 ec 08             	sub    $0x8,%esp
    5bd8:	6a 1c                	push   $0x1c
    5bda:	ff 75 0c             	pushl  0xc(%ebp)
    5bdd:	e8 98 e2 ff ff       	call   3e7a <ensureBits32>
    5be2:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    5be5:	83 ec 08             	sub    $0x8,%esp
    5be8:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5beb:	50                   	push   %eax
    5bec:	ff 75 0c             	pushl  0xc(%ebp)
    5bef:	e8 8a f8 ff ff       	call   547e <huffmanDecodeSymbol>
    5bf4:	83 c4 10             	add    $0x10,%esp
    5bf7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    5bfa:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    5bfe:	76 1e                	jbe    5c1e <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    5c00:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    5c04:	77 0c                	ja     5c12 <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    5c06:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    5c0d:	e9 7c 01 00 00       	jmp    5d8e <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5c12:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5c19:	e9 70 01 00 00       	jmp    5d8e <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    5c1e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5c21:	8b 04 85 40 9e 01 00 	mov    0x19e40(,%eax,4),%eax
    5c28:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    5c2b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5c2e:	8b 04 85 c0 9e 01 00 	mov    0x19ec0(,%eax,4),%eax
    5c35:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    5c38:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    5c3c:	74 15                	je     5c53 <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    5c3e:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5c41:	83 ec 08             	sub    $0x8,%esp
    5c44:	50                   	push   %eax
    5c45:	ff 75 0c             	pushl  0xc(%ebp)
    5c48:	e8 64 e4 ff ff       	call   40b1 <readBits>
    5c4d:	83 c4 10             	add    $0x10,%esp
    5c50:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    5c53:	8b 45 08             	mov    0x8(%ebp),%eax
    5c56:	8b 40 04             	mov    0x4(%eax),%eax
    5c59:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    5c5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c5f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5c62:	76 0c                	jbe    5c70 <inflateHuffmanBlock+0x1d0>
    5c64:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    5c6b:	e9 1e 01 00 00       	jmp    5d8e <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    5c70:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c73:	2b 45 f0             	sub    -0x10(%ebp),%eax
    5c76:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    5c79:	8b 45 08             	mov    0x8(%ebp),%eax
    5c7c:	8b 50 04             	mov    0x4(%eax),%edx
    5c7f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c82:	01 d0                	add    %edx,%eax
    5c84:	83 ec 08             	sub    $0x8,%esp
    5c87:	50                   	push   %eax
    5c88:	ff 75 08             	pushl  0x8(%ebp)
    5c8b:	e8 ef d8 ff ff       	call   357f <ucvector_resize>
    5c90:	83 c4 10             	add    $0x10,%esp
    5c93:	85 c0                	test   %eax,%eax
    5c95:	75 0c                	jne    5ca3 <inflateHuffmanBlock+0x203>
    5c97:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5c9e:	e9 eb 00 00 00       	jmp    5d8e <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    5ca3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5ca6:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5ca9:	73 6b                	jae    5d16 <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    5cab:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5cae:	8b 55 08             	mov    0x8(%ebp),%edx
    5cb1:	8b 0a                	mov    (%edx),%ecx
    5cb3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5cb6:	01 d1                	add    %edx,%ecx
    5cb8:	8b 55 08             	mov    0x8(%ebp),%edx
    5cbb:	8b 1a                	mov    (%edx),%ebx
    5cbd:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5cc0:	01 da                	add    %ebx,%edx
    5cc2:	83 ec 04             	sub    $0x4,%esp
    5cc5:	50                   	push   %eax
    5cc6:	51                   	push   %ecx
    5cc7:	52                   	push   %edx
    5cc8:	e8 96 d6 ff ff       	call   3363 <lodepng_memcpy>
    5ccd:	83 c4 10             	add    $0x10,%esp
        start += distance;
    5cd0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5cd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5cd6:	01 d0                	add    %edx,%eax
    5cd8:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    5cdb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5cde:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5ce1:	eb 29                	jmp    5d0c <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    5ce3:	8b 45 08             	mov    0x8(%ebp),%eax
    5ce6:	8b 08                	mov    (%eax),%ecx
    5ce8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ceb:	8d 50 01             	lea    0x1(%eax),%edx
    5cee:	89 55 ec             	mov    %edx,-0x14(%ebp)
    5cf1:	01 c1                	add    %eax,%ecx
    5cf3:	8b 45 08             	mov    0x8(%ebp),%eax
    5cf6:	8b 18                	mov    (%eax),%ebx
    5cf8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5cfb:	8d 50 01             	lea    0x1(%eax),%edx
    5cfe:	89 55 e8             	mov    %edx,-0x18(%ebp)
    5d01:	01 d8                	add    %ebx,%eax
    5d03:	0f b6 00             	movzbl (%eax),%eax
    5d06:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    5d08:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5d0c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5d0f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    5d12:	7c cf                	jl     5ce3 <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5d14:	eb 38                	jmp    5d4e <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    5d16:	8b 45 08             	mov    0x8(%ebp),%eax
    5d19:	8b 10                	mov    (%eax),%edx
    5d1b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5d1e:	01 c2                	add    %eax,%edx
    5d20:	8b 45 08             	mov    0x8(%ebp),%eax
    5d23:	8b 08                	mov    (%eax),%ecx
    5d25:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5d28:	01 c8                	add    %ecx,%eax
    5d2a:	83 ec 04             	sub    $0x4,%esp
    5d2d:	ff 75 e4             	pushl  -0x1c(%ebp)
    5d30:	52                   	push   %edx
    5d31:	50                   	push   %eax
    5d32:	e8 2c d6 ff ff       	call   3363 <lodepng_memcpy>
    5d37:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5d3a:	eb 12                	jmp    5d4e <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    5d3c:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5d43:	74 48                	je     5d8d <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5d45:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5d4c:	eb 40                	jmp    5d8e <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    5d4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    5d51:	8b 50 0c             	mov    0xc(%eax),%edx
    5d54:	8b 45 0c             	mov    0xc(%ebp),%eax
    5d57:	8b 40 08             	mov    0x8(%eax),%eax
    5d5a:	39 c2                	cmp    %eax,%edx
    5d5c:	7e 09                	jle    5d67 <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    5d5e:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    5d65:	eb 27                	jmp    5d8e <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    5d67:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    5d6b:	74 14                	je     5d81 <inflateHuffmanBlock+0x2e1>
    5d6d:	8b 45 08             	mov    0x8(%ebp),%eax
    5d70:	8b 40 04             	mov    0x4(%eax),%eax
    5d73:	3b 45 14             	cmp    0x14(%ebp),%eax
    5d76:	7e 09                	jle    5d81 <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    5d78:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    5d7f:	eb 0d                	jmp    5d8e <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5d81:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5d85:	0f 84 7a fd ff ff    	je     5b05 <inflateHuffmanBlock+0x65>
    5d8b:	eb 01                	jmp    5d8e <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    5d8d:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    5d8e:	83 ec 0c             	sub    $0xc,%esp
    5d91:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5d94:	50                   	push   %eax
    5d95:	e8 ac e4 ff ff       	call   4246 <HuffmanTree_cleanup>
    5d9a:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    5d9d:	83 ec 0c             	sub    $0xc,%esp
    5da0:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5da3:	50                   	push   %eax
    5da4:	e8 9d e4 ff ff       	call   4246 <HuffmanTree_cleanup>
    5da9:	83 c4 10             	add    $0x10,%esp

  return error;
    5dac:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5daf:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5db2:	c9                   	leave  
    5db3:	c3                   	ret    

00005db4 <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    5db4:	55                   	push   %ebp
    5db5:	89 e5                	mov    %esp,%ebp
    5db7:	53                   	push   %ebx
    5db8:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    5dbb:	8b 45 0c             	mov    0xc(%ebp),%eax
    5dbe:	8b 40 04             	mov    0x4(%eax),%eax
    5dc1:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    5dc4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    5dcb:	8b 45 0c             	mov    0xc(%ebp),%eax
    5dce:	8b 40 0c             	mov    0xc(%eax),%eax
    5dd1:	83 c0 07             	add    $0x7,%eax
    5dd4:	c1 e8 03             	shr    $0x3,%eax
    5dd7:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    5dda:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5ddd:	83 c0 04             	add    $0x4,%eax
    5de0:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5de3:	7c 0a                	jl     5def <inflateNoCompression+0x3b>
    5de5:	b8 34 00 00 00       	mov    $0x34,%eax
    5dea:	e9 01 01 00 00       	jmp    5ef0 <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5def:	8b 45 0c             	mov    0xc(%ebp),%eax
    5df2:	8b 10                	mov    (%eax),%edx
    5df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5df7:	01 d0                	add    %edx,%eax
    5df9:	0f b6 00             	movzbl (%eax),%eax
    5dfc:	0f b6 d0             	movzbl %al,%edx
    5dff:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e02:	8b 00                	mov    (%eax),%eax
    5e04:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5e07:	83 c1 01             	add    $0x1,%ecx
    5e0a:	01 c8                	add    %ecx,%eax
    5e0c:	0f b6 00             	movzbl (%eax),%eax
    5e0f:	0f b6 c0             	movzbl %al,%eax
    5e12:	c1 e0 08             	shl    $0x8,%eax
    5e15:	01 d0                	add    %edx,%eax
    5e17:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5e1a:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5e1e:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e21:	8b 10                	mov    (%eax),%edx
    5e23:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5e26:	01 d0                	add    %edx,%eax
    5e28:	0f b6 00             	movzbl (%eax),%eax
    5e2b:	0f b6 d0             	movzbl %al,%edx
    5e2e:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e31:	8b 00                	mov    (%eax),%eax
    5e33:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5e36:	83 c1 01             	add    $0x1,%ecx
    5e39:	01 c8                	add    %ecx,%eax
    5e3b:	0f b6 00             	movzbl (%eax),%eax
    5e3e:	0f b6 c0             	movzbl %al,%eax
    5e41:	c1 e0 08             	shl    $0x8,%eax
    5e44:	01 d0                	add    %edx,%eax
    5e46:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5e49:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    5e4d:	8b 45 10             	mov    0x10(%ebp),%eax
    5e50:	8b 40 04             	mov    0x4(%eax),%eax
    5e53:	85 c0                	test   %eax,%eax
    5e55:	75 19                	jne    5e70 <inflateNoCompression+0xbc>
    5e57:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5e5a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5e5d:	01 d0                	add    %edx,%eax
    5e5f:	3d ff ff 00 00       	cmp    $0xffff,%eax
    5e64:	74 0a                	je     5e70 <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    5e66:	b8 15 00 00 00       	mov    $0x15,%eax
    5e6b:	e9 80 00 00 00       	jmp    5ef0 <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    5e70:	8b 45 08             	mov    0x8(%ebp),%eax
    5e73:	8b 40 04             	mov    0x4(%eax),%eax
    5e76:	89 c2                	mov    %eax,%edx
    5e78:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e7b:	01 d0                	add    %edx,%eax
    5e7d:	50                   	push   %eax
    5e7e:	ff 75 08             	pushl  0x8(%ebp)
    5e81:	e8 f9 d6 ff ff       	call   357f <ucvector_resize>
    5e86:	83 c4 08             	add    $0x8,%esp
    5e89:	85 c0                	test   %eax,%eax
    5e8b:	75 07                	jne    5e94 <inflateNoCompression+0xe0>
    5e8d:	b8 53 00 00 00       	mov    $0x53,%eax
    5e92:	eb 5c                	jmp    5ef0 <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    5e94:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5e97:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e9a:	01 c2                	add    %eax,%edx
    5e9c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5e9f:	39 c2                	cmp    %eax,%edx
    5ea1:	76 07                	jbe    5eaa <inflateNoCompression+0xf6>
    5ea3:	b8 17 00 00 00       	mov    $0x17,%eax
    5ea8:	eb 46                	jmp    5ef0 <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    5eaa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ead:	8b 55 0c             	mov    0xc(%ebp),%edx
    5eb0:	8b 0a                	mov    (%edx),%ecx
    5eb2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5eb5:	01 d1                	add    %edx,%ecx
    5eb7:	8b 55 08             	mov    0x8(%ebp),%edx
    5eba:	8b 1a                	mov    (%edx),%ebx
    5ebc:	8b 55 08             	mov    0x8(%ebp),%edx
    5ebf:	8b 52 04             	mov    0x4(%edx),%edx
    5ec2:	2b 55 ec             	sub    -0x14(%ebp),%edx
    5ec5:	01 da                	add    %ebx,%edx
    5ec7:	50                   	push   %eax
    5ec8:	51                   	push   %ecx
    5ec9:	52                   	push   %edx
    5eca:	e8 94 d4 ff ff       	call   3363 <lodepng_memcpy>
    5ecf:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    5ed2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5ed5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ed8:	01 d0                	add    %edx,%eax
    5eda:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    5edd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5ee0:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    5ee7:	8b 45 0c             	mov    0xc(%ebp),%eax
    5eea:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    5eed:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5ef0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5ef3:	c9                   	leave  
    5ef4:	c3                   	ret    

00005ef5 <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    5ef5:	55                   	push   %ebp
    5ef6:	89 e5                	mov    %esp,%ebp
    5ef8:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    5efb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    5f02:	ff 75 10             	pushl  0x10(%ebp)
    5f05:	ff 75 0c             	pushl  0xc(%ebp)
    5f08:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f0b:	50                   	push   %eax
    5f0c:	e8 77 db ff ff       	call   3a88 <LodePNGBitReader_init>
    5f11:	83 c4 0c             	add    $0xc,%esp
    5f14:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    5f17:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5f1b:	0f 84 b9 00 00 00    	je     5fda <lodepng_inflatev+0xe5>
    5f21:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f24:	e9 c1 00 00 00       	jmp    5fea <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    5f29:	6a 03                	push   $0x3
    5f2b:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f2e:	50                   	push   %eax
    5f2f:	e8 c5 db ff ff       	call   3af9 <ensureBits9>
    5f34:	83 c4 08             	add    $0x8,%esp
    5f37:	85 c0                	test   %eax,%eax
    5f39:	75 0a                	jne    5f45 <lodepng_inflatev+0x50>
    5f3b:	b8 34 00 00 00       	mov    $0x34,%eax
    5f40:	e9 a5 00 00 00       	jmp    5fea <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    5f45:	6a 01                	push   $0x1
    5f47:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f4a:	50                   	push   %eax
    5f4b:	e8 61 e1 ff ff       	call   40b1 <readBits>
    5f50:	83 c4 08             	add    $0x8,%esp
    5f53:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    5f56:	6a 02                	push   $0x2
    5f58:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f5b:	50                   	push   %eax
    5f5c:	e8 50 e1 ff ff       	call   40b1 <readBits>
    5f61:	83 c4 08             	add    $0x8,%esp
    5f64:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    5f67:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    5f6b:	75 07                	jne    5f74 <lodepng_inflatev+0x7f>
    5f6d:	b8 14 00 00 00       	mov    $0x14,%eax
    5f72:	eb 76                	jmp    5fea <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    5f74:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5f78:	75 17                	jne    5f91 <lodepng_inflatev+0x9c>
    5f7a:	ff 75 14             	pushl  0x14(%ebp)
    5f7d:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f80:	50                   	push   %eax
    5f81:	ff 75 08             	pushl  0x8(%ebp)
    5f84:	e8 2b fe ff ff       	call   5db4 <inflateNoCompression>
    5f89:	83 c4 0c             	add    $0xc,%esp
    5f8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    5f8f:	eb 1c                	jmp    5fad <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    5f91:	8b 45 14             	mov    0x14(%ebp),%eax
    5f94:	8b 40 08             	mov    0x8(%eax),%eax
    5f97:	50                   	push   %eax
    5f98:	ff 75 ec             	pushl  -0x14(%ebp)
    5f9b:	8d 45 d8             	lea    -0x28(%ebp),%eax
    5f9e:	50                   	push   %eax
    5f9f:	ff 75 08             	pushl  0x8(%ebp)
    5fa2:	e8 f9 fa ff ff       	call   5aa0 <inflateHuffmanBlock>
    5fa7:	83 c4 10             	add    $0x10,%esp
    5faa:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    5fad:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5fb1:	75 21                	jne    5fd4 <lodepng_inflatev+0xdf>
    5fb3:	8b 45 14             	mov    0x14(%ebp),%eax
    5fb6:	8b 40 08             	mov    0x8(%eax),%eax
    5fb9:	85 c0                	test   %eax,%eax
    5fbb:	74 17                	je     5fd4 <lodepng_inflatev+0xdf>
    5fbd:	8b 45 08             	mov    0x8(%ebp),%eax
    5fc0:	8b 50 04             	mov    0x4(%eax),%edx
    5fc3:	8b 45 14             	mov    0x14(%ebp),%eax
    5fc6:	8b 40 08             	mov    0x8(%eax),%eax
    5fc9:	39 c2                	cmp    %eax,%edx
    5fcb:	7e 07                	jle    5fd4 <lodepng_inflatev+0xdf>
    5fcd:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    5fd4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    5fd8:	75 0c                	jne    5fe6 <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    5fda:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5fde:	0f 84 45 ff ff ff    	je     5f29 <lodepng_inflatev+0x34>
    5fe4:	eb 01                	jmp    5fe7 <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    5fe6:	90                   	nop
  }

  return error;
    5fe7:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    5fea:	c9                   	leave  
    5feb:	c3                   	ret    

00005fec <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    5fec:	55                   	push   %ebp
    5fed:	89 e5                	mov    %esp,%ebp
    5fef:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    5ff2:	8b 45 0c             	mov    0xc(%ebp),%eax
    5ff5:	8b 08                	mov    (%eax),%ecx
    5ff7:	8b 45 08             	mov    0x8(%ebp),%eax
    5ffa:	8b 10                	mov    (%eax),%edx
    5ffc:	8d 45 e8             	lea    -0x18(%ebp),%eax
    5fff:	51                   	push   %ecx
    6000:	52                   	push   %edx
    6001:	50                   	push   %eax
    6002:	e8 df d5 ff ff       	call   35e6 <ucvector_init>
    6007:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    600a:	ff 75 18             	pushl  0x18(%ebp)
    600d:	ff 75 14             	pushl  0x14(%ebp)
    6010:	ff 75 10             	pushl  0x10(%ebp)
    6013:	8d 45 e8             	lea    -0x18(%ebp),%eax
    6016:	50                   	push   %eax
    6017:	e8 d9 fe ff ff       	call   5ef5 <lodepng_inflatev>
    601c:	83 c4 10             	add    $0x10,%esp
    601f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    6022:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6025:	8b 45 08             	mov    0x8(%ebp),%eax
    6028:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    602a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    602d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6030:	89 10                	mov    %edx,(%eax)
  return error;
    6032:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6035:	c9                   	leave  
    6036:	c3                   	ret    

00006037 <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    6037:	55                   	push   %ebp
    6038:	89 e5                	mov    %esp,%ebp
    603a:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    603d:	8b 45 14             	mov    0x14(%ebp),%eax
    6040:	8b 40 10             	mov    0x10(%eax),%eax
    6043:	85 c0                	test   %eax,%eax
    6045:	74 64                	je     60ab <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    6047:	8b 45 14             	mov    0x14(%ebp),%eax
    604a:	8b 40 10             	mov    0x10(%eax),%eax
    604d:	8b 55 08             	mov    0x8(%ebp),%edx
    6050:	8d 4a 04             	lea    0x4(%edx),%ecx
    6053:	8b 55 08             	mov    0x8(%ebp),%edx
    6056:	83 ec 0c             	sub    $0xc,%esp
    6059:	ff 75 14             	pushl  0x14(%ebp)
    605c:	ff 75 10             	pushl  0x10(%ebp)
    605f:	ff 75 0c             	pushl  0xc(%ebp)
    6062:	51                   	push   %ecx
    6063:	52                   	push   %edx
    6064:	ff d0                	call   *%eax
    6066:	83 c4 20             	add    $0x20,%esp
    6069:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    606c:	8b 45 08             	mov    0x8(%ebp),%eax
    606f:	8b 50 04             	mov    0x4(%eax),%edx
    6072:	8b 45 08             	mov    0x8(%ebp),%eax
    6075:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    6078:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    607c:	74 28                	je     60a6 <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    607e:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    6085:	8b 45 14             	mov    0x14(%ebp),%eax
    6088:	8b 40 08             	mov    0x8(%eax),%eax
    608b:	85 c0                	test   %eax,%eax
    608d:	74 17                	je     60a6 <inflatev+0x6f>
    608f:	8b 45 08             	mov    0x8(%ebp),%eax
    6092:	8b 50 04             	mov    0x4(%eax),%edx
    6095:	8b 45 14             	mov    0x14(%ebp),%eax
    6098:	8b 40 08             	mov    0x8(%eax),%eax
    609b:	39 c2                	cmp    %eax,%edx
    609d:	7e 07                	jle    60a6 <inflatev+0x6f>
    609f:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    60a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    60a9:	eb 14                	jmp    60bf <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    60ab:	ff 75 14             	pushl  0x14(%ebp)
    60ae:	ff 75 10             	pushl  0x10(%ebp)
    60b1:	ff 75 0c             	pushl  0xc(%ebp)
    60b4:	ff 75 08             	pushl  0x8(%ebp)
    60b7:	e8 39 fe ff ff       	call   5ef5 <lodepng_inflatev>
    60bc:	83 c4 10             	add    $0x10,%esp
  }
}
    60bf:	c9                   	leave  
    60c0:	c3                   	ret    

000060c1 <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    60c1:	55                   	push   %ebp
    60c2:	89 e5                	mov    %esp,%ebp
    60c4:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    60c7:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    60ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    60d1:	83 e8 01             	sub    $0x1,%eax
    60d4:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    60d7:	eb 39                	jmp    6112 <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    60d9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    60dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    60df:	01 d0                	add    %edx,%eax
    60e1:	d1 f8                	sar    %eax
    60e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    60e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    60e9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    60f0:	8b 45 08             	mov    0x8(%ebp),%eax
    60f3:	01 d0                	add    %edx,%eax
    60f5:	8b 10                	mov    (%eax),%edx
    60f7:	8b 45 10             	mov    0x10(%ebp),%eax
    60fa:	39 c2                	cmp    %eax,%edx
    60fc:	72 0b                	jb     6109 <searchCodeIndex+0x48>
    60fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6101:	83 e8 01             	sub    $0x1,%eax
    6104:	89 45 f8             	mov    %eax,-0x8(%ebp)
    6107:	eb 09                	jmp    6112 <searchCodeIndex+0x51>
    else left = mid + 1;
    6109:	8b 45 f4             	mov    -0xc(%ebp),%eax
    610c:	83 c0 01             	add    $0x1,%eax
    610f:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    6112:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6115:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6118:	7e bf                	jle    60d9 <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    611a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    611d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6120:	7d 18                	jge    613a <searchCodeIndex+0x79>
    6122:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6125:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    612c:	8b 45 08             	mov    0x8(%ebp),%eax
    612f:	01 d0                	add    %edx,%eax
    6131:	8b 10                	mov    (%eax),%edx
    6133:	8b 45 10             	mov    0x10(%ebp),%eax
    6136:	39 c2                	cmp    %eax,%edx
    6138:	76 04                	jbe    613e <searchCodeIndex+0x7d>
    613a:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    613e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    6141:	c9                   	leave  
    6142:	c3                   	ret    

00006143 <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    6143:	55                   	push   %ebp
    6144:	89 e5                	mov    %esp,%ebp
    6146:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    6149:	ff 75 0c             	pushl  0xc(%ebp)
    614c:	6a 1d                	push   $0x1d
    614e:	68 40 9d 01 00       	push   $0x19d40
    6153:	e8 69 ff ff ff       	call   60c1 <searchCodeIndex>
    6158:	83 c4 0c             	add    $0xc,%esp
    615b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    615e:	8b 55 0c             	mov    0xc(%ebp),%edx
    6161:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6164:	8b 04 85 40 9d 01 00 	mov    0x19d40(,%eax,4),%eax
    616b:	29 c2                	sub    %eax,%edx
    616d:	89 d0                	mov    %edx,%eax
    616f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    6172:	ff 75 10             	pushl  0x10(%ebp)
    6175:	6a 1e                	push   $0x1e
    6177:	68 40 9e 01 00       	push   $0x19e40
    617c:	e8 40 ff ff ff       	call   60c1 <searchCodeIndex>
    6181:	83 c4 0c             	add    $0xc,%esp
    6184:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    6187:	8b 55 10             	mov    0x10(%ebp),%edx
    618a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    618d:	8b 04 85 40 9e 01 00 	mov    0x19e40(,%eax,4),%eax
    6194:	29 c2                	sub    %eax,%edx
    6196:	89 d0                	mov    %edx,%eax
    6198:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    619b:	8b 45 08             	mov    0x8(%ebp),%eax
    619e:	8b 40 04             	mov    0x4(%eax),%eax
    61a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    61a4:	8b 45 08             	mov    0x8(%ebp),%eax
    61a7:	8b 40 04             	mov    0x4(%eax),%eax
    61aa:	83 c0 04             	add    $0x4,%eax
    61ad:	50                   	push   %eax
    61ae:	ff 75 08             	pushl  0x8(%ebp)
    61b1:	e8 f0 d2 ff ff       	call   34a6 <uivector_resize>
    61b6:	83 c4 08             	add    $0x8,%esp
    61b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    61bc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    61c0:	74 57                	je     6219 <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    61c2:	8b 45 08             	mov    0x8(%ebp),%eax
    61c5:	8b 00                	mov    (%eax),%eax
    61c7:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61ca:	c1 e2 02             	shl    $0x2,%edx
    61cd:	01 d0                	add    %edx,%eax
    61cf:	8b 55 fc             	mov    -0x4(%ebp),%edx
    61d2:	81 c2 01 01 00 00    	add    $0x101,%edx
    61d8:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    61da:	8b 45 08             	mov    0x8(%ebp),%eax
    61dd:	8b 00                	mov    (%eax),%eax
    61df:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61e2:	83 c2 01             	add    $0x1,%edx
    61e5:	c1 e2 02             	shl    $0x2,%edx
    61e8:	01 c2                	add    %eax,%edx
    61ea:	8b 45 f8             	mov    -0x8(%ebp),%eax
    61ed:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    61ef:	8b 45 08             	mov    0x8(%ebp),%eax
    61f2:	8b 00                	mov    (%eax),%eax
    61f4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    61f7:	83 c2 02             	add    $0x2,%edx
    61fa:	c1 e2 02             	shl    $0x2,%edx
    61fd:	01 c2                	add    %eax,%edx
    61ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6202:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    6204:	8b 45 08             	mov    0x8(%ebp),%eax
    6207:	8b 00                	mov    (%eax),%eax
    6209:	8b 55 ec             	mov    -0x14(%ebp),%edx
    620c:	83 c2 03             	add    $0x3,%edx
    620f:	c1 e2 02             	shl    $0x2,%edx
    6212:	01 c2                	add    %eax,%edx
    6214:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6217:	89 02                	mov    %eax,(%edx)
  }
}
    6219:	90                   	nop
    621a:	c9                   	leave  
    621b:	c3                   	ret    

0000621c <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    621c:	55                   	push   %ebp
    621d:	89 e5                	mov    %esp,%ebp
    621f:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    6222:	b8 00 00 01 00       	mov    $0x10000,%eax
    6227:	c1 e0 02             	shl    $0x2,%eax
    622a:	83 ec 0c             	sub    $0xc,%esp
    622d:	50                   	push   %eax
    622e:	e8 f2 d0 ff ff       	call   3325 <lodepng_malloc>
    6233:	83 c4 10             	add    $0x10,%esp
    6236:	89 c2                	mov    %eax,%edx
    6238:	8b 45 08             	mov    0x8(%ebp),%eax
    623b:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    623d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6240:	c1 e0 02             	shl    $0x2,%eax
    6243:	83 ec 0c             	sub    $0xc,%esp
    6246:	50                   	push   %eax
    6247:	e8 d9 d0 ff ff       	call   3325 <lodepng_malloc>
    624c:	83 c4 10             	add    $0x10,%esp
    624f:	89 c2                	mov    %eax,%edx
    6251:	8b 45 08             	mov    0x8(%ebp),%eax
    6254:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6257:	8b 45 0c             	mov    0xc(%ebp),%eax
    625a:	01 c0                	add    %eax,%eax
    625c:	83 ec 0c             	sub    $0xc,%esp
    625f:	50                   	push   %eax
    6260:	e8 c0 d0 ff ff       	call   3325 <lodepng_malloc>
    6265:	83 c4 10             	add    $0x10,%esp
    6268:	89 c2                	mov    %eax,%edx
    626a:	8b 45 08             	mov    0x8(%ebp),%eax
    626d:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6270:	8b 45 0c             	mov    0xc(%ebp),%eax
    6273:	01 c0                	add    %eax,%eax
    6275:	83 ec 0c             	sub    $0xc,%esp
    6278:	50                   	push   %eax
    6279:	e8 a7 d0 ff ff       	call   3325 <lodepng_malloc>
    627e:	83 c4 10             	add    $0x10,%esp
    6281:	89 c2                	mov    %eax,%edx
    6283:	8b 45 08             	mov    0x8(%ebp),%eax
    6286:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    6289:	b8 02 01 00 00       	mov    $0x102,%eax
    628e:	83 c0 01             	add    $0x1,%eax
    6291:	c1 e0 02             	shl    $0x2,%eax
    6294:	83 ec 0c             	sub    $0xc,%esp
    6297:	50                   	push   %eax
    6298:	e8 88 d0 ff ff       	call   3325 <lodepng_malloc>
    629d:	83 c4 10             	add    $0x10,%esp
    62a0:	89 c2                	mov    %eax,%edx
    62a2:	8b 45 08             	mov    0x8(%ebp),%eax
    62a5:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    62a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    62ab:	01 c0                	add    %eax,%eax
    62ad:	83 ec 0c             	sub    $0xc,%esp
    62b0:	50                   	push   %eax
    62b1:	e8 6f d0 ff ff       	call   3325 <lodepng_malloc>
    62b6:	83 c4 10             	add    $0x10,%esp
    62b9:	89 c2                	mov    %eax,%edx
    62bb:	8b 45 08             	mov    0x8(%ebp),%eax
    62be:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    62c1:	8b 45 08             	mov    0x8(%ebp),%eax
    62c4:	8b 00                	mov    (%eax),%eax
    62c6:	85 c0                	test   %eax,%eax
    62c8:	74 32                	je     62fc <hash_init+0xe0>
    62ca:	8b 45 08             	mov    0x8(%ebp),%eax
    62cd:	8b 40 04             	mov    0x4(%eax),%eax
    62d0:	85 c0                	test   %eax,%eax
    62d2:	74 28                	je     62fc <hash_init+0xe0>
    62d4:	8b 45 08             	mov    0x8(%ebp),%eax
    62d7:	8b 40 08             	mov    0x8(%eax),%eax
    62da:	85 c0                	test   %eax,%eax
    62dc:	74 1e                	je     62fc <hash_init+0xe0>
    62de:	8b 45 08             	mov    0x8(%ebp),%eax
    62e1:	8b 40 0c             	mov    0xc(%eax),%eax
    62e4:	85 c0                	test   %eax,%eax
    62e6:	74 14                	je     62fc <hash_init+0xe0>
    62e8:	8b 45 08             	mov    0x8(%ebp),%eax
    62eb:	8b 40 10             	mov    0x10(%eax),%eax
    62ee:	85 c0                	test   %eax,%eax
    62f0:	74 0a                	je     62fc <hash_init+0xe0>
    62f2:	8b 45 08             	mov    0x8(%ebp),%eax
    62f5:	8b 40 14             	mov    0x14(%eax),%eax
    62f8:	85 c0                	test   %eax,%eax
    62fa:	75 0a                	jne    6306 <hash_init+0xea>
    return 83; /*alloc fail*/
    62fc:	b8 53 00 00 00       	mov    $0x53,%eax
    6301:	e9 d3 00 00 00       	jmp    63d9 <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    6306:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    630d:	eb 17                	jmp    6326 <hash_init+0x10a>
    630f:	8b 45 08             	mov    0x8(%ebp),%eax
    6312:	8b 00                	mov    (%eax),%eax
    6314:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6317:	c1 e2 02             	shl    $0x2,%edx
    631a:	01 d0                	add    %edx,%eax
    631c:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6322:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6326:	b8 00 00 01 00       	mov    $0x10000,%eax
    632b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    632e:	75 df                	jne    630f <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    6330:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6337:	eb 18                	jmp    6351 <hash_init+0x135>
    6339:	8b 45 08             	mov    0x8(%ebp),%eax
    633c:	8b 40 08             	mov    0x8(%eax),%eax
    633f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6342:	c1 e2 02             	shl    $0x2,%edx
    6345:	01 d0                	add    %edx,%eax
    6347:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    634d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6351:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6354:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6357:	75 e0                	jne    6339 <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    6359:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6360:	eb 17                	jmp    6379 <hash_init+0x15d>
    6362:	8b 45 08             	mov    0x8(%ebp),%eax
    6365:	8b 40 04             	mov    0x4(%eax),%eax
    6368:	8b 55 f4             	mov    -0xc(%ebp),%edx
    636b:	01 d2                	add    %edx,%edx
    636d:	01 d0                	add    %edx,%eax
    636f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6372:	66 89 10             	mov    %dx,(%eax)
    6375:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6379:	8b 45 f4             	mov    -0xc(%ebp),%eax
    637c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    637f:	75 e1                	jne    6362 <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    6381:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6388:	eb 18                	jmp    63a2 <hash_init+0x186>
    638a:	8b 45 08             	mov    0x8(%ebp),%eax
    638d:	8b 40 0c             	mov    0xc(%eax),%eax
    6390:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6393:	c1 e2 02             	shl    $0x2,%edx
    6396:	01 d0                	add    %edx,%eax
    6398:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    639e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    63a2:	b8 02 01 00 00       	mov    $0x102,%eax
    63a7:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    63aa:	76 de                	jbe    638a <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    63ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    63b3:	eb 17                	jmp    63cc <hash_init+0x1b0>
    63b5:	8b 45 08             	mov    0x8(%ebp),%eax
    63b8:	8b 40 10             	mov    0x10(%eax),%eax
    63bb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63be:	01 d2                	add    %edx,%edx
    63c0:	01 d0                	add    %edx,%eax
    63c2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    63c5:	66 89 10             	mov    %dx,(%eax)
    63c8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    63cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    63cf:	3b 45 0c             	cmp    0xc(%ebp),%eax
    63d2:	75 e1                	jne    63b5 <hash_init+0x199>

  return 0;
    63d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    63d9:	c9                   	leave  
    63da:	c3                   	ret    

000063db <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    63db:	55                   	push   %ebp
    63dc:	89 e5                	mov    %esp,%ebp
    63de:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    63e1:	8b 45 08             	mov    0x8(%ebp),%eax
    63e4:	8b 00                	mov    (%eax),%eax
    63e6:	83 ec 0c             	sub    $0xc,%esp
    63e9:	50                   	push   %eax
    63ea:	e8 57 cf ff ff       	call   3346 <lodepng_free>
    63ef:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    63f2:	8b 45 08             	mov    0x8(%ebp),%eax
    63f5:	8b 40 08             	mov    0x8(%eax),%eax
    63f8:	83 ec 0c             	sub    $0xc,%esp
    63fb:	50                   	push   %eax
    63fc:	e8 45 cf ff ff       	call   3346 <lodepng_free>
    6401:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    6404:	8b 45 08             	mov    0x8(%ebp),%eax
    6407:	8b 40 04             	mov    0x4(%eax),%eax
    640a:	83 ec 0c             	sub    $0xc,%esp
    640d:	50                   	push   %eax
    640e:	e8 33 cf ff ff       	call   3346 <lodepng_free>
    6413:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    6416:	8b 45 08             	mov    0x8(%ebp),%eax
    6419:	8b 40 14             	mov    0x14(%eax),%eax
    641c:	83 ec 0c             	sub    $0xc,%esp
    641f:	50                   	push   %eax
    6420:	e8 21 cf ff ff       	call   3346 <lodepng_free>
    6425:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    6428:	8b 45 08             	mov    0x8(%ebp),%eax
    642b:	8b 40 0c             	mov    0xc(%eax),%eax
    642e:	83 ec 0c             	sub    $0xc,%esp
    6431:	50                   	push   %eax
    6432:	e8 0f cf ff ff       	call   3346 <lodepng_free>
    6437:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    643a:	8b 45 08             	mov    0x8(%ebp),%eax
    643d:	8b 40 10             	mov    0x10(%eax),%eax
    6440:	83 ec 0c             	sub    $0xc,%esp
    6443:	50                   	push   %eax
    6444:	e8 fd ce ff ff       	call   3346 <lodepng_free>
    6449:	83 c4 10             	add    $0x10,%esp
}
    644c:	90                   	nop
    644d:	c9                   	leave  
    644e:	c3                   	ret    

0000644f <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    644f:	55                   	push   %ebp
    6450:	89 e5                	mov    %esp,%ebp
    6452:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    6455:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    645c:	8b 45 10             	mov    0x10(%ebp),%eax
    645f:	83 c0 02             	add    $0x2,%eax
    6462:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6465:	7d 41                	jge    64a8 <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    6467:	8b 55 10             	mov    0x10(%ebp),%edx
    646a:	8b 45 08             	mov    0x8(%ebp),%eax
    646d:	01 d0                	add    %edx,%eax
    646f:	0f b6 00             	movzbl (%eax),%eax
    6472:	0f b6 c0             	movzbl %al,%eax
    6475:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    6478:	8b 45 10             	mov    0x10(%ebp),%eax
    647b:	8d 50 01             	lea    0x1(%eax),%edx
    647e:	8b 45 08             	mov    0x8(%ebp),%eax
    6481:	01 d0                	add    %edx,%eax
    6483:	0f b6 00             	movzbl (%eax),%eax
    6486:	0f b6 c0             	movzbl %al,%eax
    6489:	c1 e0 04             	shl    $0x4,%eax
    648c:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    648f:	8b 45 10             	mov    0x10(%ebp),%eax
    6492:	8d 50 02             	lea    0x2(%eax),%edx
    6495:	8b 45 08             	mov    0x8(%ebp),%eax
    6498:	01 d0                	add    %edx,%eax
    649a:	0f b6 00             	movzbl (%eax),%eax
    649d:	0f b6 c0             	movzbl %al,%eax
    64a0:	c1 e0 08             	shl    $0x8,%eax
    64a3:	31 45 fc             	xor    %eax,-0x4(%ebp)
    64a6:	eb 51                	jmp    64f9 <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    64a8:	8b 45 10             	mov    0x10(%ebp),%eax
    64ab:	3b 45 0c             	cmp    0xc(%ebp),%eax
    64ae:	7c 07                	jl     64b7 <getHash+0x68>
    64b0:	b8 00 00 00 00       	mov    $0x0,%eax
    64b5:	eb 4a                	jmp    6501 <getHash+0xb2>
    amount = size - pos;
    64b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    64ba:	2b 45 10             	sub    0x10(%ebp),%eax
    64bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    64c0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    64c7:	eb 28                	jmp    64f1 <getHash+0xa2>
    64c9:	8b 55 10             	mov    0x10(%ebp),%edx
    64cc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64cf:	01 d0                	add    %edx,%eax
    64d1:	89 c2                	mov    %eax,%edx
    64d3:	8b 45 08             	mov    0x8(%ebp),%eax
    64d6:	01 d0                	add    %edx,%eax
    64d8:	0f b6 00             	movzbl (%eax),%eax
    64db:	0f b6 d0             	movzbl %al,%edx
    64de:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64e1:	c1 e0 03             	shl    $0x3,%eax
    64e4:	89 c1                	mov    %eax,%ecx
    64e6:	d3 e2                	shl    %cl,%edx
    64e8:	89 d0                	mov    %edx,%eax
    64ea:	31 45 fc             	xor    %eax,-0x4(%ebp)
    64ed:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    64f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64f4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    64f7:	75 d0                	jne    64c9 <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    64f9:	b8 ff ff 00 00       	mov    $0xffff,%eax
    64fe:	23 45 fc             	and    -0x4(%ebp),%eax
}
    6501:	c9                   	leave  
    6502:	c3                   	ret    

00006503 <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    6503:	55                   	push   %ebp
    6504:	89 e5                	mov    %esp,%ebp
    6506:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    6509:	8b 55 10             	mov    0x10(%ebp),%edx
    650c:	8b 45 08             	mov    0x8(%ebp),%eax
    650f:	01 d0                	add    %edx,%eax
    6511:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    6514:	b8 02 01 00 00       	mov    $0x102,%eax
    6519:	89 c2                	mov    %eax,%edx
    651b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    651e:	01 d0                	add    %edx,%eax
    6520:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    6523:	8b 55 0c             	mov    0xc(%ebp),%edx
    6526:	8b 45 08             	mov    0x8(%ebp),%eax
    6529:	01 d0                	add    %edx,%eax
    652b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    652e:	73 0b                	jae    653b <countZeros+0x38>
    6530:	8b 55 0c             	mov    0xc(%ebp),%edx
    6533:	8b 45 08             	mov    0x8(%ebp),%eax
    6536:	01 d0                	add    %edx,%eax
    6538:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    653b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    653e:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    6541:	eb 04                	jmp    6547 <countZeros+0x44>
    6543:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    6547:	8b 45 08             	mov    0x8(%ebp),%eax
    654a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    654d:	74 0a                	je     6559 <countZeros+0x56>
    654f:	8b 45 08             	mov    0x8(%ebp),%eax
    6552:	0f b6 00             	movzbl (%eax),%eax
    6555:	84 c0                	test   %al,%al
    6557:	74 ea                	je     6543 <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    6559:	8b 55 08             	mov    0x8(%ebp),%edx
    655c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    655f:	29 c2                	sub    %eax,%edx
    6561:	89 d0                	mov    %edx,%eax
}
    6563:	c9                   	leave  
    6564:	c3                   	ret    

00006565 <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    6565:	55                   	push   %ebp
    6566:	89 e5                	mov    %esp,%ebp
    6568:	83 ec 04             	sub    $0x4,%esp
    656b:	8b 45 14             	mov    0x14(%ebp),%eax
    656e:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    6572:	8b 45 08             	mov    0x8(%ebp),%eax
    6575:	8b 40 08             	mov    0x8(%eax),%eax
    6578:	8b 55 0c             	mov    0xc(%ebp),%edx
    657b:	c1 e2 02             	shl    $0x2,%edx
    657e:	01 c2                	add    %eax,%edx
    6580:	8b 45 10             	mov    0x10(%ebp),%eax
    6583:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    6585:	8b 45 08             	mov    0x8(%ebp),%eax
    6588:	8b 00                	mov    (%eax),%eax
    658a:	8b 55 10             	mov    0x10(%ebp),%edx
    658d:	c1 e2 02             	shl    $0x2,%edx
    6590:	01 d0                	add    %edx,%eax
    6592:	8b 00                	mov    (%eax),%eax
    6594:	83 f8 ff             	cmp    $0xffffffff,%eax
    6597:	74 1f                	je     65b8 <updateHashChain+0x53>
    6599:	8b 45 08             	mov    0x8(%ebp),%eax
    659c:	8b 40 04             	mov    0x4(%eax),%eax
    659f:	8b 55 0c             	mov    0xc(%ebp),%edx
    65a2:	01 d2                	add    %edx,%edx
    65a4:	01 c2                	add    %eax,%edx
    65a6:	8b 45 08             	mov    0x8(%ebp),%eax
    65a9:	8b 00                	mov    (%eax),%eax
    65ab:	8b 4d 10             	mov    0x10(%ebp),%ecx
    65ae:	c1 e1 02             	shl    $0x2,%ecx
    65b1:	01 c8                	add    %ecx,%eax
    65b3:	8b 00                	mov    (%eax),%eax
    65b5:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    65b8:	8b 45 08             	mov    0x8(%ebp),%eax
    65bb:	8b 00                	mov    (%eax),%eax
    65bd:	8b 55 10             	mov    0x10(%ebp),%edx
    65c0:	c1 e2 02             	shl    $0x2,%edx
    65c3:	01 c2                	add    %eax,%edx
    65c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    65c8:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    65ca:	8b 45 08             	mov    0x8(%ebp),%eax
    65cd:	8b 40 14             	mov    0x14(%eax),%eax
    65d0:	8b 55 0c             	mov    0xc(%ebp),%edx
    65d3:	01 d2                	add    %edx,%edx
    65d5:	01 c2                	add    %eax,%edx
    65d7:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    65db:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    65de:	8b 45 08             	mov    0x8(%ebp),%eax
    65e1:	8b 40 0c             	mov    0xc(%eax),%eax
    65e4:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    65e8:	c1 e2 02             	shl    $0x2,%edx
    65eb:	01 d0                	add    %edx,%eax
    65ed:	8b 00                	mov    (%eax),%eax
    65ef:	83 f8 ff             	cmp    $0xffffffff,%eax
    65f2:	74 21                	je     6615 <updateHashChain+0xb0>
    65f4:	8b 45 08             	mov    0x8(%ebp),%eax
    65f7:	8b 40 10             	mov    0x10(%eax),%eax
    65fa:	8b 55 0c             	mov    0xc(%ebp),%edx
    65fd:	01 d2                	add    %edx,%edx
    65ff:	01 c2                	add    %eax,%edx
    6601:	8b 45 08             	mov    0x8(%ebp),%eax
    6604:	8b 40 0c             	mov    0xc(%eax),%eax
    6607:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    660b:	c1 e1 02             	shl    $0x2,%ecx
    660e:	01 c8                	add    %ecx,%eax
    6610:	8b 00                	mov    (%eax),%eax
    6612:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    6615:	8b 45 08             	mov    0x8(%ebp),%eax
    6618:	8b 40 0c             	mov    0xc(%eax),%eax
    661b:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    661f:	c1 e2 02             	shl    $0x2,%edx
    6622:	01 c2                	add    %eax,%edx
    6624:	8b 45 0c             	mov    0xc(%ebp),%eax
    6627:	89 02                	mov    %eax,(%edx)
}
    6629:	90                   	nop
    662a:	c9                   	leave  
    662b:	c3                   	ret    

0000662c <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    662c:	55                   	push   %ebp
    662d:	89 e5                	mov    %esp,%ebp
    662f:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    6632:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    6639:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6640:	77 08                	ja     664a <encodeLZ77+0x1e>
    6642:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6645:	c1 e8 03             	shr    $0x3,%eax
    6648:	eb 03                	jmp    664d <encodeLZ77+0x21>
    664a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    664d:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    6650:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6657:	76 07                	jbe    6660 <encodeLZ77+0x34>
    6659:	b8 02 01 00 00       	mov    $0x102,%eax
    665e:	eb 05                	jmp    6665 <encodeLZ77+0x39>
    6660:	b8 40 00 00 00       	mov    $0x40,%eax
    6665:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    6668:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    666f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    6676:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    667d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    6684:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    668b:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    668f:	74 09                	je     669a <encodeLZ77+0x6e>
    6691:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    6698:	76 0a                	jbe    66a4 <encodeLZ77+0x78>
    669a:	b8 3c 00 00 00       	mov    $0x3c,%eax
    669f:	e9 e3 04 00 00       	jmp    6b87 <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    66a4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    66a7:	83 e8 01             	sub    $0x1,%eax
    66aa:	23 45 1c             	and    0x1c(%ebp),%eax
    66ad:	85 c0                	test   %eax,%eax
    66af:	74 0a                	je     66bb <encodeLZ77+0x8f>
    66b1:	b8 5a 00 00 00       	mov    $0x5a,%eax
    66b6:	e9 cc 04 00 00       	jmp    6b87 <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    66bb:	b8 02 01 00 00       	mov    $0x102,%eax
    66c0:	39 45 24             	cmp    %eax,0x24(%ebp)
    66c3:	76 08                	jbe    66cd <encodeLZ77+0xa1>
    66c5:	b8 02 01 00 00       	mov    $0x102,%eax
    66ca:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    66cd:	8b 45 14             	mov    0x14(%ebp),%eax
    66d0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    66d3:	e9 a0 04 00 00       	jmp    6b78 <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    66d8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    66db:	8d 50 ff             	lea    -0x1(%eax),%edx
    66de:	8b 45 fc             	mov    -0x4(%ebp),%eax
    66e1:	21 d0                	and    %edx,%eax
    66e3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    66e6:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    66ed:	ff 75 fc             	pushl  -0x4(%ebp)
    66f0:	ff 75 18             	pushl  0x18(%ebp)
    66f3:	ff 75 10             	pushl  0x10(%ebp)
    66f6:	e8 54 fd ff ff       	call   644f <getHash>
    66fb:	83 c4 0c             	add    $0xc,%esp
    66fe:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    6701:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6705:	74 4e                	je     6755 <encodeLZ77+0x129>
    6707:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    670b:	75 48                	jne    6755 <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    670d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6711:	75 16                	jne    6729 <encodeLZ77+0xfd>
    6713:	ff 75 fc             	pushl  -0x4(%ebp)
    6716:	ff 75 18             	pushl  0x18(%ebp)
    6719:	ff 75 10             	pushl  0x10(%ebp)
    671c:	e8 e2 fd ff ff       	call   6503 <countZeros>
    6721:	83 c4 0c             	add    $0xc,%esp
    6724:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6727:	eb 35                	jmp    675e <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6729:	8b 55 fc             	mov    -0x4(%ebp),%edx
    672c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    672f:	01 c2                	add    %eax,%edx
    6731:	8b 45 18             	mov    0x18(%ebp),%eax
    6734:	39 c2                	cmp    %eax,%edx
    6736:	77 17                	ja     674f <encodeLZ77+0x123>
    6738:	8b 55 fc             	mov    -0x4(%ebp),%edx
    673b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    673e:	01 d0                	add    %edx,%eax
    6740:	8d 50 ff             	lea    -0x1(%eax),%edx
    6743:	8b 45 10             	mov    0x10(%ebp),%eax
    6746:	01 d0                	add    %edx,%eax
    6748:	0f b6 00             	movzbl (%eax),%eax
    674b:	84 c0                	test   %al,%al
    674d:	74 0f                	je     675e <encodeLZ77+0x132>
    674f:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6753:	eb 09                	jmp    675e <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    6755:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    675c:	eb 01                	jmp    675f <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    675e:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    675f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6762:	0f b7 c0             	movzwl %ax,%eax
    6765:	50                   	push   %eax
    6766:	ff 75 b0             	pushl  -0x50(%ebp)
    6769:	ff 75 b4             	pushl  -0x4c(%ebp)
    676c:	ff 75 0c             	pushl  0xc(%ebp)
    676f:	e8 f1 fd ff ff       	call   6565 <updateHashChain>
    6774:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    6777:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    677e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    6785:	8b 45 0c             	mov    0xc(%ebp),%eax
    6788:	8b 40 04             	mov    0x4(%eax),%eax
    678b:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    678e:	01 d2                	add    %edx,%edx
    6790:	01 d0                	add    %edx,%eax
    6792:	0f b7 00             	movzwl (%eax),%eax
    6795:	0f b7 c0             	movzwl %ax,%eax
    6798:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    679b:	ba 02 01 00 00       	mov    $0x102,%edx
    67a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    67a3:	01 c2                	add    %eax,%edx
    67a5:	8b 45 18             	mov    0x18(%ebp),%eax
    67a8:	39 c2                	cmp    %eax,%edx
    67aa:	0f 4e c2             	cmovle %edx,%eax
    67ad:	89 c2                	mov    %eax,%edx
    67af:	8b 45 10             	mov    0x10(%ebp),%eax
    67b2:	01 d0                	add    %edx,%eax
    67b4:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    67b7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    67be:	8b 45 c8             	mov    -0x38(%ebp),%eax
    67c1:	8d 50 01             	lea    0x1(%eax),%edx
    67c4:	89 55 c8             	mov    %edx,-0x38(%ebp)
    67c7:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    67ca:	0f 83 67 01 00 00    	jae    6937 <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    67d0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    67d3:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    67d6:	77 08                	ja     67e0 <encodeLZ77+0x1b4>
    67d8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    67db:	2b 45 cc             	sub    -0x34(%ebp),%eax
    67de:	eb 0d                	jmp    67ed <encodeLZ77+0x1c1>
    67e0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    67e3:	2b 45 cc             	sub    -0x34(%ebp),%eax
    67e6:	89 c2                	mov    %eax,%edx
    67e8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    67eb:	01 d0                	add    %edx,%eax
    67ed:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    67f0:	8b 45 a8             	mov    -0x58(%ebp),%eax
    67f3:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    67f6:	0f 82 3e 01 00 00    	jb     693a <encodeLZ77+0x30e>
      prev_offset = current_offset;
    67fc:	8b 45 a8             	mov    -0x58(%ebp),%eax
    67ff:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    6802:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    6806:	0f 84 a3 00 00 00    	je     68af <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    680c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    680f:	8b 45 10             	mov    0x10(%ebp),%eax
    6812:	01 d0                	add    %edx,%eax
    6814:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    6817:	8b 45 fc             	mov    -0x4(%ebp),%eax
    681a:	2b 45 a8             	sub    -0x58(%ebp),%eax
    681d:	89 c2                	mov    %eax,%edx
    681f:	8b 45 10             	mov    0x10(%ebp),%eax
    6822:	01 d0                	add    %edx,%eax
    6824:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    6827:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    682b:	76 3a                	jbe    6867 <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    682d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6830:	8b 40 14             	mov    0x14(%eax),%eax
    6833:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6836:	01 d2                	add    %edx,%edx
    6838:	01 d0                	add    %edx,%eax
    683a:	0f b7 00             	movzwl (%eax),%eax
    683d:	0f b7 c0             	movzwl %ax,%eax
    6840:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    6843:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6846:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6849:	76 06                	jbe    6851 <encodeLZ77+0x225>
    684b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    684e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    6851:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6854:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    6857:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    685a:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    685d:	eb 08                	jmp    6867 <encodeLZ77+0x23b>
          ++backptr;
    685f:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    6863:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6867:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    686a:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    686d:	74 10                	je     687f <encodeLZ77+0x253>
    686f:	8b 45 d0             	mov    -0x30(%ebp),%eax
    6872:	0f b6 10             	movzbl (%eax),%edx
    6875:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6878:	0f b6 00             	movzbl (%eax),%eax
    687b:	38 c2                	cmp    %al,%dl
    687d:	74 e0                	je     685f <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    687f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6882:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    6885:	8b 55 10             	mov    0x10(%ebp),%edx
    6888:	01 ca                	add    %ecx,%edx
    688a:	29 d0                	sub    %edx,%eax
    688c:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    688f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6892:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6895:	76 18                	jbe    68af <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    6897:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    689a:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    689d:	8b 45 a8             	mov    -0x58(%ebp),%eax
    68a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    68a3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    68a6:	3b 45 24             	cmp    0x24(%ebp),%eax
    68a9:	0f 83 8e 00 00 00    	jae    693d <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    68af:	8b 45 0c             	mov    0xc(%ebp),%eax
    68b2:	8b 40 04             	mov    0x4(%eax),%eax
    68b5:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68b8:	01 d2                	add    %edx,%edx
    68ba:	01 d0                	add    %edx,%eax
    68bc:	0f b7 00             	movzwl (%eax),%eax
    68bf:	0f b7 c0             	movzwl %ax,%eax
    68c2:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    68c5:	74 79                	je     6940 <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    68c7:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    68cb:	76 38                	jbe    6905 <encodeLZ77+0x2d9>
    68cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    68d0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    68d3:	76 30                	jbe    6905 <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    68d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    68d8:	8b 40 10             	mov    0x10(%eax),%eax
    68db:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68de:	01 d2                	add    %edx,%edx
    68e0:	01 d0                	add    %edx,%eax
    68e2:	0f b7 00             	movzwl (%eax),%eax
    68e5:	0f b7 c0             	movzwl %ax,%eax
    68e8:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    68eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    68ee:	8b 40 14             	mov    0x14(%eax),%eax
    68f1:	8b 55 cc             	mov    -0x34(%ebp),%edx
    68f4:	01 d2                	add    %edx,%edx
    68f6:	01 d0                	add    %edx,%eax
    68f8:	0f b7 00             	movzwl (%eax),%eax
    68fb:	0f b7 c0             	movzwl %ax,%eax
    68fe:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6901:	74 2f                	je     6932 <encodeLZ77+0x306>
    6903:	eb 3f                	jmp    6944 <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    6905:	8b 45 0c             	mov    0xc(%ebp),%eax
    6908:	8b 40 04             	mov    0x4(%eax),%eax
    690b:	8b 55 cc             	mov    -0x34(%ebp),%edx
    690e:	01 d2                	add    %edx,%edx
    6910:	01 d0                	add    %edx,%eax
    6912:	0f b7 00             	movzwl (%eax),%eax
    6915:	0f b7 c0             	movzwl %ax,%eax
    6918:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    691b:	8b 45 0c             	mov    0xc(%ebp),%eax
    691e:	8b 40 08             	mov    0x8(%eax),%eax
    6921:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6924:	c1 e2 02             	shl    $0x2,%edx
    6927:	01 d0                	add    %edx,%eax
    6929:	8b 10                	mov    (%eax),%edx
    692b:	8b 45 b0             	mov    -0x50(%ebp),%eax
    692e:	39 c2                	cmp    %eax,%edx
    6930:	75 11                	jne    6943 <encodeLZ77+0x317>
      }
    }
    6932:	e9 87 fe ff ff       	jmp    67be <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6937:	90                   	nop
    6938:	eb 0a                	jmp    6944 <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    693a:	90                   	nop
    693b:	eb 07                	jmp    6944 <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    693d:	90                   	nop
    693e:	eb 04                	jmp    6944 <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    6940:	90                   	nop
    6941:	eb 01                	jmp    6944 <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6943:	90                   	nop
      }
    }

    if(lazymatching) {
    6944:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    6948:	0f 84 c8 00 00 00    	je     6a16 <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    694e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6952:	75 30                	jne    6984 <encodeLZ77+0x358>
    6954:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6958:	76 2a                	jbe    6984 <encodeLZ77+0x358>
    695a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    695d:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    6960:	77 22                	ja     6984 <encodeLZ77+0x358>
    6962:	b8 02 01 00 00       	mov    $0x102,%eax
    6967:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    696a:	73 18                	jae    6984 <encodeLZ77+0x358>
        lazy = 1;
    696c:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    6973:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6976:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    6979:	8b 45 ec             	mov    -0x14(%ebp),%eax
    697c:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    697f:	e9 f0 01 00 00       	jmp    6b74 <encodeLZ77+0x548>
      }
      if(lazy) {
    6984:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6988:	0f 84 88 00 00 00    	je     6a16 <encodeLZ77+0x3ea>
        lazy = 0;
    698e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    6995:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    6999:	75 0c                	jne    69a7 <encodeLZ77+0x37b>
    699b:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    69a2:	e9 dd 01 00 00       	jmp    6b84 <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    69a7:	8b 45 e0             	mov    -0x20(%ebp),%eax
    69aa:	83 c0 01             	add    $0x1,%eax
    69ad:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    69b0:	73 2d                	jae    69df <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    69b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    69b5:	8d 50 ff             	lea    -0x1(%eax),%edx
    69b8:	8b 45 10             	mov    0x10(%ebp),%eax
    69bb:	01 d0                	add    %edx,%eax
    69bd:	0f b6 00             	movzbl (%eax),%eax
    69c0:	0f b6 c0             	movzbl %al,%eax
    69c3:	50                   	push   %eax
    69c4:	ff 75 08             	pushl  0x8(%ebp)
    69c7:	e8 6f cb ff ff       	call   353b <uivector_push_back>
    69cc:	83 c4 08             	add    $0x8,%esp
    69cf:	85 c0                	test   %eax,%eax
    69d1:	75 43                	jne    6a16 <encodeLZ77+0x3ea>
    69d3:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    69da:	e9 a5 01 00 00       	jmp    6b84 <encodeLZ77+0x558>
        } else {
          length = lazylength;
    69df:	8b 45 e0             	mov    -0x20(%ebp),%eax
    69e2:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    69e5:	8b 45 dc             	mov    -0x24(%ebp),%eax
    69e8:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    69eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    69ee:	8b 00                	mov    (%eax),%eax
    69f0:	8b 55 b0             	mov    -0x50(%ebp),%edx
    69f3:	c1 e2 02             	shl    $0x2,%edx
    69f6:	01 d0                	add    %edx,%eax
    69f8:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    69fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a01:	8b 40 0c             	mov    0xc(%eax),%eax
    6a04:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6a07:	c1 e2 02             	shl    $0x2,%edx
    6a0a:	01 d0                	add    %edx,%eax
    6a0c:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    6a12:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    6a16:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6a1a:	76 14                	jbe    6a30 <encodeLZ77+0x404>
    6a1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6a1f:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    6a22:	76 0c                	jbe    6a30 <encodeLZ77+0x404>
    6a24:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    6a2b:	e9 54 01 00 00       	jmp    6b84 <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    6a30:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6a34:	77 2e                	ja     6a64 <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6a36:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6a39:	8b 45 10             	mov    0x10(%ebp),%eax
    6a3c:	01 d0                	add    %edx,%eax
    6a3e:	0f b6 00             	movzbl (%eax),%eax
    6a41:	0f b6 c0             	movzbl %al,%eax
    6a44:	50                   	push   %eax
    6a45:	ff 75 08             	pushl  0x8(%ebp)
    6a48:	e8 ee ca ff ff       	call   353b <uivector_push_back>
    6a4d:	83 c4 08             	add    $0x8,%esp
    6a50:	85 c0                	test   %eax,%eax
    6a52:	0f 85 1c 01 00 00    	jne    6b74 <encodeLZ77+0x548>
    6a58:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6a5f:	e9 20 01 00 00       	jmp    6b84 <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    6a64:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6a67:	3b 45 20             	cmp    0x20(%ebp),%eax
    6a6a:	72 0f                	jb     6a7b <encodeLZ77+0x44f>
    6a6c:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    6a70:	75 37                	jne    6aa9 <encodeLZ77+0x47d>
    6a72:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    6a79:	76 2e                	jbe    6aa9 <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6a7b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6a7e:	8b 45 10             	mov    0x10(%ebp),%eax
    6a81:	01 d0                	add    %edx,%eax
    6a83:	0f b6 00             	movzbl (%eax),%eax
    6a86:	0f b6 c0             	movzbl %al,%eax
    6a89:	50                   	push   %eax
    6a8a:	ff 75 08             	pushl  0x8(%ebp)
    6a8d:	e8 a9 ca ff ff       	call   353b <uivector_push_back>
    6a92:	83 c4 08             	add    $0x8,%esp
    6a95:	85 c0                	test   %eax,%eax
    6a97:	0f 85 d7 00 00 00    	jne    6b74 <encodeLZ77+0x548>
    6a9d:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6aa4:	e9 db 00 00 00       	jmp    6b84 <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    6aa9:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6aac:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6aaf:	52                   	push   %edx
    6ab0:	50                   	push   %eax
    6ab1:	ff 75 08             	pushl  0x8(%ebp)
    6ab4:	e8 8a f6 ff ff       	call   6143 <addLengthDistance>
    6ab9:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    6abc:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    6ac3:	e9 a0 00 00 00       	jmp    6b68 <encodeLZ77+0x53c>
        ++pos;
    6ac8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    6acc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6acf:	8d 50 ff             	lea    -0x1(%eax),%edx
    6ad2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6ad5:	21 d0                	and    %edx,%eax
    6ad7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    6ada:	ff 75 fc             	pushl  -0x4(%ebp)
    6add:	ff 75 18             	pushl  0x18(%ebp)
    6ae0:	ff 75 10             	pushl  0x10(%ebp)
    6ae3:	e8 67 f9 ff ff       	call   644f <getHash>
    6ae8:	83 c4 0c             	add    $0xc,%esp
    6aeb:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    6aee:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6af2:	74 4e                	je     6b42 <encodeLZ77+0x516>
    6af4:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6af8:	75 48                	jne    6b42 <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6afa:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6afe:	75 16                	jne    6b16 <encodeLZ77+0x4ea>
    6b00:	ff 75 fc             	pushl  -0x4(%ebp)
    6b03:	ff 75 18             	pushl  0x18(%ebp)
    6b06:	ff 75 10             	pushl  0x10(%ebp)
    6b09:	e8 f5 f9 ff ff       	call   6503 <countZeros>
    6b0e:	83 c4 0c             	add    $0xc,%esp
    6b11:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6b14:	eb 35                	jmp    6b4b <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6b16:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6b19:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b1c:	01 c2                	add    %eax,%edx
    6b1e:	8b 45 18             	mov    0x18(%ebp),%eax
    6b21:	39 c2                	cmp    %eax,%edx
    6b23:	77 17                	ja     6b3c <encodeLZ77+0x510>
    6b25:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6b28:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b2b:	01 d0                	add    %edx,%eax
    6b2d:	8d 50 ff             	lea    -0x1(%eax),%edx
    6b30:	8b 45 10             	mov    0x10(%ebp),%eax
    6b33:	01 d0                	add    %edx,%eax
    6b35:	0f b6 00             	movzbl (%eax),%eax
    6b38:	84 c0                	test   %al,%al
    6b3a:	74 0f                	je     6b4b <encodeLZ77+0x51f>
    6b3c:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6b40:	eb 09                	jmp    6b4b <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    6b42:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6b49:	eb 01                	jmp    6b4c <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6b4b:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    6b4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b4f:	0f b7 c0             	movzwl %ax,%eax
    6b52:	50                   	push   %eax
    6b53:	ff 75 b0             	pushl  -0x50(%ebp)
    6b56:	ff 75 b4             	pushl  -0x4c(%ebp)
    6b59:	ff 75 0c             	pushl  0xc(%ebp)
    6b5c:	e8 04 fa ff ff       	call   6565 <updateHashChain>
    6b61:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    6b64:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6b68:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6b6b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6b6e:	0f 82 54 ff ff ff    	jb     6ac8 <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    6b74:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6b78:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6b7b:	3b 45 18             	cmp    0x18(%ebp),%eax
    6b7e:	0f 8c 54 fb ff ff    	jl     66d8 <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    6b84:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6b87:	c9                   	leave  
    6b88:	c3                   	ret    

00006b89 <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    6b89:	55                   	push   %ebp
    6b8a:	89 e5                	mov    %esp,%ebp
    6b8c:	53                   	push   %ebx
    6b8d:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    6b90:	8b 45 10             	mov    0x10(%ebp),%eax
    6b93:	05 fe ff 00 00       	add    $0xfffe,%eax
    6b98:	ba 01 80 00 80       	mov    $0x80008001,%edx
    6b9d:	f7 e2                	mul    %edx
    6b9f:	89 d0                	mov    %edx,%eax
    6ba1:	c1 e8 0f             	shr    $0xf,%eax
    6ba4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    6ba7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    6bae:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6bb5:	e9 1b 01 00 00       	jmp    6cd5 <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    6bba:	8b 45 08             	mov    0x8(%ebp),%eax
    6bbd:	8b 40 04             	mov    0x4(%eax),%eax
    6bc0:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    6bc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6bc6:	83 e8 01             	sub    $0x1,%eax
    6bc9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6bcc:	0f 94 c0             	sete   %al
    6bcf:	0f b6 c0             	movzbl %al,%eax
    6bd2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    6bd5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    6bdc:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    6be3:	8b 45 10             	mov    0x10(%ebp),%eax
    6be6:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6be9:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    6bee:	77 09                	ja     6bf9 <deflateNoCompression+0x70>
    6bf0:	8b 45 10             	mov    0x10(%ebp),%eax
    6bf3:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6bf6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    6bf9:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6bfe:	2b 45 f0             	sub    -0x10(%ebp),%eax
    6c01:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    6c04:	8b 45 08             	mov    0x8(%ebp),%eax
    6c07:	8b 40 04             	mov    0x4(%eax),%eax
    6c0a:	89 c2                	mov    %eax,%edx
    6c0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c0f:	01 d0                	add    %edx,%eax
    6c11:	83 c0 05             	add    $0x5,%eax
    6c14:	50                   	push   %eax
    6c15:	ff 75 08             	pushl  0x8(%ebp)
    6c18:	e8 62 c9 ff ff       	call   357f <ucvector_resize>
    6c1d:	83 c4 08             	add    $0x8,%esp
    6c20:	85 c0                	test   %eax,%eax
    6c22:	75 0a                	jne    6c2e <deflateNoCompression+0xa5>
    6c24:	b8 53 00 00 00       	mov    $0x53,%eax
    6c29:	e9 b8 00 00 00       	jmp    6ce6 <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    6c2e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6c31:	89 c2                	mov    %eax,%edx
    6c33:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6c36:	83 e0 01             	and    $0x1,%eax
    6c39:	01 c0                	add    %eax,%eax
    6c3b:	01 c2                	add    %eax,%edx
    6c3d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6c40:	83 e0 02             	and    $0x2,%eax
    6c43:	01 c0                	add    %eax,%eax
    6c45:	01 d0                	add    %edx,%eax
    6c47:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    6c4a:	8b 45 08             	mov    0x8(%ebp),%eax
    6c4d:	8b 10                	mov    (%eax),%edx
    6c4f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6c52:	01 c2                	add    %eax,%edx
    6c54:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    6c58:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    6c5a:	8b 45 08             	mov    0x8(%ebp),%eax
    6c5d:	8b 00                	mov    (%eax),%eax
    6c5f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c62:	83 c2 01             	add    $0x1,%edx
    6c65:	01 d0                	add    %edx,%eax
    6c67:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6c6a:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    6c6c:	8b 45 08             	mov    0x8(%ebp),%eax
    6c6f:	8b 00                	mov    (%eax),%eax
    6c71:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c74:	83 c2 02             	add    $0x2,%edx
    6c77:	01 d0                	add    %edx,%eax
    6c79:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6c7c:	c1 ea 08             	shr    $0x8,%edx
    6c7f:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    6c81:	8b 45 08             	mov    0x8(%ebp),%eax
    6c84:	8b 00                	mov    (%eax),%eax
    6c86:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c89:	83 c2 03             	add    $0x3,%edx
    6c8c:	01 d0                	add    %edx,%eax
    6c8e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6c91:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    6c93:	8b 45 08             	mov    0x8(%ebp),%eax
    6c96:	8b 00                	mov    (%eax),%eax
    6c98:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6c9b:	83 c2 04             	add    $0x4,%edx
    6c9e:	01 d0                	add    %edx,%eax
    6ca0:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6ca3:	c1 ea 08             	shr    $0x8,%edx
    6ca6:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    6ca8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6cab:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    6cae:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6cb1:	01 d1                	add    %edx,%ecx
    6cb3:	8b 55 08             	mov    0x8(%ebp),%edx
    6cb6:	8b 12                	mov    (%edx),%edx
    6cb8:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6cbb:	83 c3 05             	add    $0x5,%ebx
    6cbe:	01 da                	add    %ebx,%edx
    6cc0:	50                   	push   %eax
    6cc1:	51                   	push   %ecx
    6cc2:	52                   	push   %edx
    6cc3:	e8 9b c6 ff ff       	call   3363 <lodepng_memcpy>
    6cc8:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    6ccb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6cce:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    6cd1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6cd5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6cd8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6cdb:	0f 85 d9 fe ff ff    	jne    6bba <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    6ce1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6ce6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6ce9:	c9                   	leave  
    6cea:	c3                   	ret    

00006ceb <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    6ceb:	55                   	push   %ebp
    6cec:	89 e5                	mov    %esp,%ebp
    6cee:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    6cf1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    6cf8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    6cff:	e9 10 01 00 00       	jmp    6e14 <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    6d04:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d07:	8b 00                	mov    (%eax),%eax
    6d09:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d0c:	c1 e2 02             	shl    $0x2,%edx
    6d0f:	01 d0                	add    %edx,%eax
    6d11:	8b 00                	mov    (%eax),%eax
    6d13:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    6d16:	8b 45 10             	mov    0x10(%ebp),%eax
    6d19:	8b 40 04             	mov    0x4(%eax),%eax
    6d1c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6d1f:	c1 e2 02             	shl    $0x2,%edx
    6d22:	01 d0                	add    %edx,%eax
    6d24:	8b 00                	mov    (%eax),%eax
    6d26:	89 c1                	mov    %eax,%ecx
    6d28:	8b 45 10             	mov    0x10(%ebp),%eax
    6d2b:	8b 00                	mov    (%eax),%eax
    6d2d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6d30:	c1 e2 02             	shl    $0x2,%edx
    6d33:	01 d0                	add    %edx,%eax
    6d35:	8b 00                	mov    (%eax),%eax
    6d37:	51                   	push   %ecx
    6d38:	50                   	push   %eax
    6d39:	ff 75 08             	pushl  0x8(%ebp)
    6d3c:	e8 60 cc ff ff       	call   39a1 <writeBitsReversed>
    6d41:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    6d44:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    6d4b:	0f 86 bf 00 00 00    	jbe    6e10 <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    6d51:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6d54:	2d 01 01 00 00       	sub    $0x101,%eax
    6d59:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    6d5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6d5f:	8b 04 85 c0 9d 01 00 	mov    0x19dc0(,%eax,4),%eax
    6d66:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    6d69:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d6c:	8b 00                	mov    (%eax),%eax
    6d6e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6d72:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d75:	c1 e2 02             	shl    $0x2,%edx
    6d78:	01 d0                	add    %edx,%eax
    6d7a:	8b 00                	mov    (%eax),%eax
    6d7c:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    6d7f:	8b 45 0c             	mov    0xc(%ebp),%eax
    6d82:	8b 00                	mov    (%eax),%eax
    6d84:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6d88:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d8b:	c1 e2 02             	shl    $0x2,%edx
    6d8e:	01 d0                	add    %edx,%eax
    6d90:	8b 00                	mov    (%eax),%eax
    6d92:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    6d95:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6d98:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    6d9b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6d9e:	8b 04 85 c0 9e 01 00 	mov    0x19ec0(,%eax,4),%eax
    6da5:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    6da8:	8b 45 0c             	mov    0xc(%ebp),%eax
    6dab:	8b 00                	mov    (%eax),%eax
    6dad:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6db1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6db4:	c1 e2 02             	shl    $0x2,%edx
    6db7:	01 d0                	add    %edx,%eax
    6db9:	8b 00                	mov    (%eax),%eax
    6dbb:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    6dbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6dc1:	50                   	push   %eax
    6dc2:	ff 75 ec             	pushl  -0x14(%ebp)
    6dc5:	ff 75 08             	pushl  0x8(%ebp)
    6dc8:	e8 40 ca ff ff       	call   380d <writeBits>
    6dcd:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    6dd0:	8b 45 14             	mov    0x14(%ebp),%eax
    6dd3:	8b 40 04             	mov    0x4(%eax),%eax
    6dd6:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6dd9:	c1 e2 02             	shl    $0x2,%edx
    6ddc:	01 d0                	add    %edx,%eax
    6dde:	8b 00                	mov    (%eax),%eax
    6de0:	89 c1                	mov    %eax,%ecx
    6de2:	8b 45 14             	mov    0x14(%ebp),%eax
    6de5:	8b 00                	mov    (%eax),%eax
    6de7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6dea:	c1 e2 02             	shl    $0x2,%edx
    6ded:	01 d0                	add    %edx,%eax
    6def:	8b 00                	mov    (%eax),%eax
    6df1:	51                   	push   %ecx
    6df2:	50                   	push   %eax
    6df3:	ff 75 08             	pushl  0x8(%ebp)
    6df6:	e8 a6 cb ff ff       	call   39a1 <writeBitsReversed>
    6dfb:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    6dfe:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6e01:	50                   	push   %eax
    6e02:	ff 75 dc             	pushl  -0x24(%ebp)
    6e05:	ff 75 08             	pushl  0x8(%ebp)
    6e08:	e8 00 ca ff ff       	call   380d <writeBits>
    6e0d:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    6e10:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6e14:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e17:	8b 40 04             	mov    0x4(%eax),%eax
    6e1a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6e1d:	0f 85 e1 fe ff ff    	jne    6d04 <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    6e23:	90                   	nop
    6e24:	c9                   	leave  
    6e25:	c3                   	ret    

00006e26 <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    6e26:	55                   	push   %ebp
    6e27:	89 e5                	mov    %esp,%ebp
    6e29:	53                   	push   %ebx
    6e2a:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    6e30:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    6e37:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    6e3e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    6e45:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    6e4c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    6e53:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    6e5a:	8b 45 18             	mov    0x18(%ebp),%eax
    6e5d:	2b 45 14             	sub    0x14(%ebp),%eax
    6e60:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    6e63:	8b 45 20             	mov    0x20(%ebp),%eax
    6e66:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    6e69:	8d 45 90             	lea    -0x70(%ebp),%eax
    6e6c:	50                   	push   %eax
    6e6d:	e8 a4 c6 ff ff       	call   3516 <uivector_init>
    6e72:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    6e75:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    6e7b:	50                   	push   %eax
    6e7c:	e8 98 d3 ff ff       	call   4219 <HuffmanTree_init>
    6e81:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    6e84:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    6e8a:	50                   	push   %eax
    6e8b:	e8 89 d3 ff ff       	call   4219 <HuffmanTree_init>
    6e90:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    6e93:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    6e99:	50                   	push   %eax
    6e9a:	e8 7a d3 ff ff       	call   4219 <HuffmanTree_init>
    6e9f:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    6ea2:	83 ec 0c             	sub    $0xc,%esp
    6ea5:	68 78 04 00 00       	push   $0x478
    6eaa:	e8 76 c4 ff ff       	call   3325 <lodepng_malloc>
    6eaf:	83 c4 10             	add    $0x10,%esp
    6eb2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    6eb5:	83 ec 0c             	sub    $0xc,%esp
    6eb8:	6a 78                	push   $0x78
    6eba:	e8 66 c4 ff ff       	call   3325 <lodepng_malloc>
    6ebf:	83 c4 10             	add    $0x10,%esp
    6ec2:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6ec5:	83 ec 0c             	sub    $0xc,%esp
    6ec8:	6a 4c                	push   $0x4c
    6eca:	e8 56 c4 ff ff       	call   3325 <lodepng_malloc>
    6ecf:	83 c4 10             	add    $0x10,%esp
    6ed2:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    6ed5:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    6ed9:	74 0c                	je     6ee7 <deflateDynamic+0xc1>
    6edb:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    6edf:	74 06                	je     6ee7 <deflateDynamic+0xc1>
    6ee1:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    6ee5:	75 07                	jne    6eee <deflateDynamic+0xc8>
    6ee7:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    6eee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6ef2:	0f 85 f6 07 00 00    	jne    76ee <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    6ef8:	83 ec 04             	sub    $0x4,%esp
    6efb:	68 78 04 00 00       	push   $0x478
    6f00:	6a 00                	push   $0x0
    6f02:	ff 75 d4             	pushl  -0x2c(%ebp)
    6f05:	e8 8c c4 ff ff       	call   3396 <lodepng_memset>
    6f0a:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    6f0d:	83 ec 04             	sub    $0x4,%esp
    6f10:	6a 78                	push   $0x78
    6f12:	6a 00                	push   $0x0
    6f14:	ff 75 d0             	pushl  -0x30(%ebp)
    6f17:	e8 7a c4 ff ff       	call   3396 <lodepng_memset>
    6f1c:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    6f1f:	83 ec 04             	sub    $0x4,%esp
    6f22:	6a 4c                	push   $0x4c
    6f24:	6a 00                	push   $0x0
    6f26:	ff 75 cc             	pushl  -0x34(%ebp)
    6f29:	e8 68 c4 ff ff       	call   3396 <lodepng_memset>
    6f2e:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    6f31:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f34:	8b 40 04             	mov    0x4(%eax),%eax
    6f37:	85 c0                	test   %eax,%eax
    6f39:	74 45                	je     6f80 <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    6f3b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f3e:	8b 58 14             	mov    0x14(%eax),%ebx
    6f41:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f44:	8b 48 10             	mov    0x10(%eax),%ecx
    6f47:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f4a:	8b 50 0c             	mov    0xc(%eax),%edx
    6f4d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6f50:	8b 40 08             	mov    0x8(%eax),%eax
    6f53:	83 ec 0c             	sub    $0xc,%esp
    6f56:	53                   	push   %ebx
    6f57:	51                   	push   %ecx
    6f58:	52                   	push   %edx
    6f59:	50                   	push   %eax
    6f5a:	ff 75 18             	pushl  0x18(%ebp)
    6f5d:	ff 75 14             	pushl  0x14(%ebp)
    6f60:	ff 75 10             	pushl  0x10(%ebp)
    6f63:	ff 75 0c             	pushl  0xc(%ebp)
    6f66:	8d 45 90             	lea    -0x70(%ebp),%eax
    6f69:	50                   	push   %eax
    6f6a:	e8 bd f6 ff ff       	call   662c <encodeLZ77>
    6f6f:	83 c4 30             	add    $0x30,%esp
    6f72:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    6f75:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6f79:	74 59                	je     6fd4 <deflateDynamic+0x1ae>
    6f7b:	e9 6e 07 00 00       	jmp    76ee <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    6f80:	83 ec 08             	sub    $0x8,%esp
    6f83:	ff 75 c8             	pushl  -0x38(%ebp)
    6f86:	8d 45 90             	lea    -0x70(%ebp),%eax
    6f89:	50                   	push   %eax
    6f8a:	e8 17 c5 ff ff       	call   34a6 <uivector_resize>
    6f8f:	83 c4 10             	add    $0x10,%esp
    6f92:	85 c0                	test   %eax,%eax
    6f94:	75 0c                	jne    6fa2 <deflateDynamic+0x17c>
    6f96:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6f9d:	e9 4c 07 00 00       	jmp    76ee <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    6fa2:	8b 45 14             	mov    0x14(%ebp),%eax
    6fa5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    6fa8:	eb 22                	jmp    6fcc <deflateDynamic+0x1a6>
    6faa:	8b 55 90             	mov    -0x70(%ebp),%edx
    6fad:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6fb0:	2b 45 14             	sub    0x14(%ebp),%eax
    6fb3:	c1 e0 02             	shl    $0x2,%eax
    6fb6:	01 c2                	add    %eax,%edx
    6fb8:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    6fbb:	8b 45 10             	mov    0x10(%ebp),%eax
    6fbe:	01 c8                	add    %ecx,%eax
    6fc0:	0f b6 00             	movzbl (%eax),%eax
    6fc3:	0f b6 c0             	movzbl %al,%eax
    6fc6:	89 02                	mov    %eax,(%edx)
    6fc8:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    6fcc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6fcf:	3b 45 18             	cmp    0x18(%ebp),%eax
    6fd2:	7c d6                	jl     6faa <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    6fd4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    6fdb:	eb 60                	jmp    703d <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    6fdd:	8b 45 90             	mov    -0x70(%ebp),%eax
    6fe0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6fe3:	c1 e2 02             	shl    $0x2,%edx
    6fe6:	01 d0                	add    %edx,%eax
    6fe8:	8b 00                	mov    (%eax),%eax
    6fea:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    6fed:	8b 45 c0             	mov    -0x40(%ebp),%eax
    6ff0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6ff7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6ffa:	01 d0                	add    %edx,%eax
    6ffc:	8b 10                	mov    (%eax),%edx
    6ffe:	83 c2 01             	add    $0x1,%edx
    7001:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    7003:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    700a:	76 2d                	jbe    7039 <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    700c:	8b 45 90             	mov    -0x70(%ebp),%eax
    700f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7012:	83 c2 02             	add    $0x2,%edx
    7015:	c1 e2 02             	shl    $0x2,%edx
    7018:	01 d0                	add    %edx,%eax
    701a:	8b 00                	mov    (%eax),%eax
    701c:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    701f:	8b 45 bc             	mov    -0x44(%ebp),%eax
    7022:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7029:	8b 45 d0             	mov    -0x30(%ebp),%eax
    702c:	01 d0                	add    %edx,%eax
    702e:	8b 10                	mov    (%eax),%edx
    7030:	83 c2 01             	add    $0x1,%edx
    7033:	89 10                	mov    %edx,(%eax)
        i += 3;
    7035:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    7039:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    703d:	8b 45 94             	mov    -0x6c(%ebp),%eax
    7040:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7043:	75 98                	jne    6fdd <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    7045:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7048:	05 00 04 00 00       	add    $0x400,%eax
    704d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    7053:	83 ec 0c             	sub    $0xc,%esp
    7056:	6a 0f                	push   $0xf
    7058:	68 1e 01 00 00       	push   $0x11e
    705d:	68 01 01 00 00       	push   $0x101
    7062:	ff 75 d4             	pushl  -0x2c(%ebp)
    7065:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    706b:	50                   	push   %eax
    706c:	e8 e0 e1 ff ff       	call   5251 <HuffmanTree_makeFromFrequencies>
    7071:	83 c4 20             	add    $0x20,%esp
    7074:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7077:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    707b:	0f 85 66 06 00 00    	jne    76e7 <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    7081:	83 ec 0c             	sub    $0xc,%esp
    7084:	6a 0f                	push   $0xf
    7086:	6a 1e                	push   $0x1e
    7088:	6a 02                	push   $0x2
    708a:	ff 75 d0             	pushl  -0x30(%ebp)
    708d:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7093:	50                   	push   %eax
    7094:	e8 b8 e1 ff ff       	call   5251 <HuffmanTree_makeFromFrequencies>
    7099:	83 c4 20             	add    $0x20,%esp
    709c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    709f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    70a3:	0f 85 41 06 00 00    	jne    76ea <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    70a9:	8b 45 84             	mov    -0x7c(%ebp),%eax
    70ac:	ba 1e 01 00 00       	mov    $0x11e,%edx
    70b1:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    70b6:	0f 47 c2             	cmova  %edx,%eax
    70b9:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    70bc:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    70c2:	ba 1e 00 00 00       	mov    $0x1e,%edx
    70c7:	83 f8 1e             	cmp    $0x1e,%eax
    70ca:	0f 47 c2             	cmova  %edx,%eax
    70cd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    70d0:	8b 55 b8             	mov    -0x48(%ebp),%edx
    70d3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    70d6:	01 d0                	add    %edx,%eax
    70d8:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    70db:	8b 45 b0             	mov    -0x50(%ebp),%eax
    70de:	c1 e0 02             	shl    $0x2,%eax
    70e1:	83 ec 0c             	sub    $0xc,%esp
    70e4:	50                   	push   %eax
    70e5:	e8 3b c2 ff ff       	call   3325 <lodepng_malloc>
    70ea:	83 c4 10             	add    $0x10,%esp
    70ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    70f0:	8b 45 b0             	mov    -0x50(%ebp),%eax
    70f3:	c1 e0 02             	shl    $0x2,%eax
    70f6:	83 ec 0c             	sub    $0xc,%esp
    70f9:	50                   	push   %eax
    70fa:	e8 26 c2 ff ff       	call   3325 <lodepng_malloc>
    70ff:	83 c4 10             	add    $0x10,%esp
    7102:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    7105:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7109:	74 06                	je     7111 <deflateDynamic+0x2eb>
    710b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    710f:	75 0c                	jne    711d <deflateDynamic+0x2f7>
    7111:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7118:	e9 d1 05 00 00       	jmp    76ee <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    711d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    7124:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    712b:	eb 25                	jmp    7152 <deflateDynamic+0x32c>
    712d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7130:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7137:	8b 45 f0             	mov    -0x10(%ebp),%eax
    713a:	01 c2                	add    %eax,%edx
    713c:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7142:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7145:	c1 e1 02             	shl    $0x2,%ecx
    7148:	01 c8                	add    %ecx,%eax
    714a:	8b 00                	mov    (%eax),%eax
    714c:	89 02                	mov    %eax,(%edx)
    714e:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7152:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7155:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    7158:	75 d3                	jne    712d <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    715a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7161:	eb 2a                	jmp    718d <deflateDynamic+0x367>
    7163:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7166:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7169:	01 d0                	add    %edx,%eax
    716b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7172:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7175:	01 c2                	add    %eax,%edx
    7177:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    717d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7180:	c1 e1 02             	shl    $0x2,%ecx
    7183:	01 c8                	add    %ecx,%eax
    7185:	8b 00                	mov    (%eax),%eax
    7187:	89 02                	mov    %eax,(%edx)
    7189:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    718d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7190:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    7193:	75 ce                	jne    7163 <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7195:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    719c:	e9 3b 02 00 00       	jmp    73dc <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    71a1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    71a8:	eb 04                	jmp    71ae <deflateDynamic+0x388>
    71aa:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    71ae:	8b 55 e8             	mov    -0x18(%ebp),%edx
    71b1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    71b4:	01 d0                	add    %edx,%eax
    71b6:	8d 50 01             	lea    0x1(%eax),%edx
    71b9:	8b 45 b0             	mov    -0x50(%ebp),%eax
    71bc:	39 c2                	cmp    %eax,%edx
    71be:	73 2e                	jae    71ee <deflateDynamic+0x3c8>
    71c0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    71c3:	8b 45 dc             	mov    -0x24(%ebp),%eax
    71c6:	01 d0                	add    %edx,%eax
    71c8:	83 c0 01             	add    $0x1,%eax
    71cb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    71d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    71d5:	01 d0                	add    %edx,%eax
    71d7:	8b 10                	mov    (%eax),%edx
    71d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71dc:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    71e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    71e6:	01 c8                	add    %ecx,%eax
    71e8:	8b 00                	mov    (%eax),%eax
    71ea:	39 c2                	cmp    %eax,%edx
    71ec:	74 bc                	je     71aa <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    71ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
    71f1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    71f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    71fb:	01 d0                	add    %edx,%eax
    71fd:	8b 00                	mov    (%eax),%eax
    71ff:	85 c0                	test   %eax,%eax
    7201:	0f 85 a9 00 00 00    	jne    72b0 <deflateDynamic+0x48a>
    7207:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    720b:	0f 86 9f 00 00 00    	jbe    72b0 <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    7211:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    7215:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    7219:	77 3a                	ja     7255 <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    721b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    721e:	8d 50 01             	lea    0x1(%eax),%edx
    7221:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7224:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    722b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    722e:	01 d0                	add    %edx,%eax
    7230:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    7236:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7239:	8d 50 01             	lea    0x1(%eax),%edx
    723c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    723f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7246:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7249:	01 d0                	add    %edx,%eax
    724b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    724e:	83 ea 03             	sub    $0x3,%edx
    7251:	89 10                	mov    %edx,(%eax)
    7253:	eb 48                	jmp    729d <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    7255:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    725c:	76 07                	jbe    7265 <deflateDynamic+0x43f>
    725e:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    7265:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7268:	8d 50 01             	lea    0x1(%eax),%edx
    726b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    726e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7275:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7278:	01 d0                	add    %edx,%eax
    727a:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    7280:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7283:	8d 50 01             	lea    0x1(%eax),%edx
    7286:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7289:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7290:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7293:	01 d0                	add    %edx,%eax
    7295:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7298:	83 ea 0b             	sub    $0xb,%edx
    729b:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    729d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    72a0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    72a3:	01 d0                	add    %edx,%eax
    72a5:	83 e8 01             	sub    $0x1,%eax
    72a8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    72ab:	e9 28 01 00 00       	jmp    73d8 <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    72b0:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    72b4:	0f 86 f6 00 00 00    	jbe    73b0 <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    72ba:	8b 45 dc             	mov    -0x24(%ebp),%eax
    72bd:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    72c2:	f7 e2                	mul    %edx
    72c4:	89 d0                	mov    %edx,%eax
    72c6:	c1 e8 02             	shr    $0x2,%eax
    72c9:	89 45 ac             	mov    %eax,-0x54(%ebp)
    72cc:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    72cf:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    72d4:	89 c8                	mov    %ecx,%eax
    72d6:	f7 e2                	mul    %edx
    72d8:	c1 ea 02             	shr    $0x2,%edx
    72db:	89 d0                	mov    %edx,%eax
    72dd:	01 c0                	add    %eax,%eax
    72df:	01 d0                	add    %edx,%eax
    72e1:	01 c0                	add    %eax,%eax
    72e3:	29 c1                	sub    %eax,%ecx
    72e5:	89 c8                	mov    %ecx,%eax
    72e7:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    72ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    72ed:	8d 50 01             	lea    0x1(%eax),%edx
    72f0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    72f3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    72fd:	01 c2                	add    %eax,%edx
    72ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7302:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7309:	8b 45 f0             	mov    -0x10(%ebp),%eax
    730c:	01 c8                	add    %ecx,%eax
    730e:	8b 00                	mov    (%eax),%eax
    7310:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    7312:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    7319:	eb 3a                	jmp    7355 <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    731b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    731e:	8d 50 01             	lea    0x1(%eax),%edx
    7321:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7324:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    732b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    732e:	01 d0                	add    %edx,%eax
    7330:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    7336:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7339:	8d 50 01             	lea    0x1(%eax),%edx
    733c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    733f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7346:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7349:	01 d0                	add    %edx,%eax
    734b:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    7351:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    7355:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7358:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    735b:	72 be                	jb     731b <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    735d:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    7361:	76 3a                	jbe    739d <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    7363:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7366:	8d 50 01             	lea    0x1(%eax),%edx
    7369:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    736c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7373:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7376:	01 d0                	add    %edx,%eax
    7378:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    737e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7381:	8d 50 01             	lea    0x1(%eax),%edx
    7384:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7387:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    738e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7391:	01 d0                	add    %edx,%eax
    7393:	8b 55 a8             	mov    -0x58(%ebp),%edx
    7396:	83 ea 03             	sub    $0x3,%edx
    7399:	89 10                	mov    %edx,(%eax)
    739b:	eb 06                	jmp    73a3 <deflateDynamic+0x57d>
        }
        else j -= rest;
    739d:	8b 45 a8             	mov    -0x58(%ebp),%eax
    73a0:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    73a3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    73a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    73a9:	01 d0                	add    %edx,%eax
    73ab:	89 45 e8             	mov    %eax,-0x18(%ebp)
    73ae:	eb 28                	jmp    73d8 <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    73b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73b3:	8d 50 01             	lea    0x1(%eax),%edx
    73b6:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    73b9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73c3:	01 c2                	add    %eax,%edx
    73c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73c8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    73cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    73d2:	01 c8                	add    %ecx,%eax
    73d4:	8b 00                	mov    (%eax),%eax
    73d6:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    73d8:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    73dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73df:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    73e2:	0f 85 b9 fd ff ff    	jne    71a1 <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    73e8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    73ef:	eb 42                	jmp    7433 <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    73f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73f4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73fe:	01 d0                	add    %edx,%eax
    7400:	8b 00                	mov    (%eax),%eax
    7402:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7409:	8b 45 cc             	mov    -0x34(%ebp),%eax
    740c:	01 d0                	add    %edx,%eax
    740e:	8b 10                	mov    (%eax),%edx
    7410:	83 c2 01             	add    $0x1,%edx
    7413:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    7415:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7418:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    741f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7422:	01 d0                	add    %edx,%eax
    7424:	8b 00                	mov    (%eax),%eax
    7426:	83 f8 0f             	cmp    $0xf,%eax
    7429:	76 04                	jbe    742f <deflateDynamic+0x609>
    742b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    742f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7433:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7436:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7439:	75 b6                	jne    73f1 <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    743b:	83 ec 0c             	sub    $0xc,%esp
    743e:	6a 07                	push   $0x7
    7440:	6a 13                	push   $0x13
    7442:	6a 13                	push   $0x13
    7444:	ff 75 cc             	pushl  -0x34(%ebp)
    7447:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    744d:	50                   	push   %eax
    744e:	e8 fe dd ff ff       	call   5251 <HuffmanTree_makeFromFrequencies>
    7453:	83 c4 20             	add    $0x20,%esp
    7456:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    7459:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    745d:	0f 85 8a 02 00 00    	jne    76ed <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    7463:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    746a:	eb 04                	jmp    7470 <deflateDynamic+0x64a>
      numcodes_cl--;
    746c:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7470:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7473:	83 f8 04             	cmp    $0x4,%eax
    7476:	76 1e                	jbe    7496 <deflateDynamic+0x670>
    7478:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    747e:	8b 55 e0             	mov    -0x20(%ebp),%edx
    7481:	83 ea 01             	sub    $0x1,%edx
    7484:	8b 14 95 40 9f 01 00 	mov    0x19f40(,%edx,4),%edx
    748b:	c1 e2 02             	shl    $0x2,%edx
    748e:	01 d0                	add    %edx,%eax
    7490:	8b 00                	mov    (%eax),%eax
    7492:	85 c0                	test   %eax,%eax
    7494:	74 d6                	je     746c <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    7496:	83 ec 04             	sub    $0x4,%esp
    7499:	6a 01                	push   $0x1
    749b:	ff 75 c4             	pushl  -0x3c(%ebp)
    749e:	ff 75 08             	pushl  0x8(%ebp)
    74a1:	e8 67 c3 ff ff       	call   380d <writeBits>
    74a6:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    74a9:	83 ec 04             	sub    $0x4,%esp
    74ac:	6a 01                	push   $0x1
    74ae:	6a 00                	push   $0x0
    74b0:	ff 75 08             	pushl  0x8(%ebp)
    74b3:	e8 55 c3 ff ff       	call   380d <writeBits>
    74b8:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    74bb:	83 ec 04             	sub    $0x4,%esp
    74be:	6a 01                	push   $0x1
    74c0:	6a 01                	push   $0x1
    74c2:	ff 75 08             	pushl  0x8(%ebp)
    74c5:	e8 43 c3 ff ff       	call   380d <writeBits>
    74ca:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    74cd:	8b 45 b8             	mov    -0x48(%ebp),%eax
    74d0:	2d 01 01 00 00       	sub    $0x101,%eax
    74d5:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    74d8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    74db:	83 e8 01             	sub    $0x1,%eax
    74de:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    74e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    74e4:	83 e8 04             	sub    $0x4,%eax
    74e7:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    74ea:	83 ec 04             	sub    $0x4,%esp
    74ed:	6a 05                	push   $0x5
    74ef:	ff 75 a4             	pushl  -0x5c(%ebp)
    74f2:	ff 75 08             	pushl  0x8(%ebp)
    74f5:	e8 13 c3 ff ff       	call   380d <writeBits>
    74fa:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    74fd:	83 ec 04             	sub    $0x4,%esp
    7500:	6a 05                	push   $0x5
    7502:	ff 75 a0             	pushl  -0x60(%ebp)
    7505:	ff 75 08             	pushl  0x8(%ebp)
    7508:	e8 00 c3 ff ff       	call   380d <writeBits>
    750d:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    7510:	83 ec 04             	sub    $0x4,%esp
    7513:	6a 04                	push   $0x4
    7515:	ff 75 9c             	pushl  -0x64(%ebp)
    7518:	ff 75 08             	pushl  0x8(%ebp)
    751b:	e8 ed c2 ff ff       	call   380d <writeBits>
    7520:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    7523:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    752a:	eb 2c                	jmp    7558 <deflateDynamic+0x732>
    752c:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    7532:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7535:	8b 04 85 40 9f 01 00 	mov    0x19f40(,%eax,4),%eax
    753c:	c1 e0 02             	shl    $0x2,%eax
    753f:	01 d0                	add    %edx,%eax
    7541:	8b 00                	mov    (%eax),%eax
    7543:	83 ec 04             	sub    $0x4,%esp
    7546:	6a 03                	push   $0x3
    7548:	50                   	push   %eax
    7549:	ff 75 08             	pushl  0x8(%ebp)
    754c:	e8 bc c2 ff ff       	call   380d <writeBits>
    7551:	83 c4 10             	add    $0x10,%esp
    7554:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7558:	8b 45 e8             	mov    -0x18(%ebp),%eax
    755b:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    755e:	75 cc                	jne    752c <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7560:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7567:	e9 0a 01 00 00       	jmp    7676 <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    756c:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7572:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7575:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    757c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    757f:	01 ca                	add    %ecx,%edx
    7581:	8b 12                	mov    (%edx),%edx
    7583:	c1 e2 02             	shl    $0x2,%edx
    7586:	01 d0                	add    %edx,%eax
    7588:	8b 00                	mov    (%eax),%eax
    758a:	89 c3                	mov    %eax,%ebx
    758c:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    7592:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7595:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    759c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    759f:	01 ca                	add    %ecx,%edx
    75a1:	8b 12                	mov    (%edx),%edx
    75a3:	c1 e2 02             	shl    $0x2,%edx
    75a6:	01 d0                	add    %edx,%eax
    75a8:	8b 00                	mov    (%eax),%eax
    75aa:	83 ec 04             	sub    $0x4,%esp
    75ad:	53                   	push   %ebx
    75ae:	50                   	push   %eax
    75af:	ff 75 08             	pushl  0x8(%ebp)
    75b2:	e8 ea c3 ff ff       	call   39a1 <writeBitsReversed>
    75b7:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    75ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75bd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75c7:	01 d0                	add    %edx,%eax
    75c9:	8b 00                	mov    (%eax),%eax
    75cb:	83 f8 10             	cmp    $0x10,%eax
    75ce:	75 28                	jne    75f8 <deflateDynamic+0x7d2>
    75d0:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    75d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75d7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75de:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75e1:	01 d0                	add    %edx,%eax
    75e3:	8b 00                	mov    (%eax),%eax
    75e5:	83 ec 04             	sub    $0x4,%esp
    75e8:	6a 02                	push   $0x2
    75ea:	50                   	push   %eax
    75eb:	ff 75 08             	pushl  0x8(%ebp)
    75ee:	e8 1a c2 ff ff       	call   380d <writeBits>
    75f3:	83 c4 10             	add    $0x10,%esp
    75f6:	eb 7a                	jmp    7672 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    75f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75fb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7602:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7605:	01 d0                	add    %edx,%eax
    7607:	8b 00                	mov    (%eax),%eax
    7609:	83 f8 11             	cmp    $0x11,%eax
    760c:	75 28                	jne    7636 <deflateDynamic+0x810>
    760e:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7612:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7615:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    761c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    761f:	01 d0                	add    %edx,%eax
    7621:	8b 00                	mov    (%eax),%eax
    7623:	83 ec 04             	sub    $0x4,%esp
    7626:	6a 03                	push   $0x3
    7628:	50                   	push   %eax
    7629:	ff 75 08             	pushl  0x8(%ebp)
    762c:	e8 dc c1 ff ff       	call   380d <writeBits>
    7631:	83 c4 10             	add    $0x10,%esp
    7634:	eb 3c                	jmp    7672 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    7636:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7639:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7640:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7643:	01 d0                	add    %edx,%eax
    7645:	8b 00                	mov    (%eax),%eax
    7647:	83 f8 12             	cmp    $0x12,%eax
    764a:	75 26                	jne    7672 <deflateDynamic+0x84c>
    764c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7650:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7653:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    765a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    765d:	01 d0                	add    %edx,%eax
    765f:	8b 00                	mov    (%eax),%eax
    7661:	83 ec 04             	sub    $0x4,%esp
    7664:	6a 07                	push   $0x7
    7666:	50                   	push   %eax
    7667:	ff 75 08             	pushl  0x8(%ebp)
    766a:	e8 9e c1 ff ff       	call   380d <writeBits>
    766f:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7672:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7676:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7679:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    767c:	0f 85 ea fe ff ff    	jne    756c <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7682:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7688:	50                   	push   %eax
    7689:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    768f:	50                   	push   %eax
    7690:	8d 45 90             	lea    -0x70(%ebp),%eax
    7693:	50                   	push   %eax
    7694:	ff 75 08             	pushl  0x8(%ebp)
    7697:	e8 4f f6 ff ff       	call   6ceb <writeLZ77data>
    769c:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    769f:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    76a5:	05 00 04 00 00       	add    $0x400,%eax
    76aa:	8b 00                	mov    (%eax),%eax
    76ac:	85 c0                	test   %eax,%eax
    76ae:	75 09                	jne    76b9 <deflateDynamic+0x893>
    76b0:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    76b7:	eb 35                	jmp    76ee <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    76b9:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    76bf:	05 00 04 00 00       	add    $0x400,%eax
    76c4:	8b 00                	mov    (%eax),%eax
    76c6:	89 c2                	mov    %eax,%edx
    76c8:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    76ce:	05 00 04 00 00       	add    $0x400,%eax
    76d3:	8b 00                	mov    (%eax),%eax
    76d5:	83 ec 04             	sub    $0x4,%esp
    76d8:	52                   	push   %edx
    76d9:	50                   	push   %eax
    76da:	ff 75 08             	pushl  0x8(%ebp)
    76dd:	e8 bf c2 ff ff       	call   39a1 <writeBitsReversed>
    76e2:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    76e5:	eb 07                	jmp    76ee <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    76e7:	90                   	nop
    76e8:	eb 04                	jmp    76ee <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    76ea:	90                   	nop
    76eb:	eb 01                	jmp    76ee <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    76ed:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    76ee:	83 ec 0c             	sub    $0xc,%esp
    76f1:	8d 45 90             	lea    -0x70(%ebp),%eax
    76f4:	50                   	push   %eax
    76f5:	e8 73 bd ff ff       	call   346d <uivector_cleanup>
    76fa:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    76fd:	83 ec 0c             	sub    $0xc,%esp
    7700:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7706:	50                   	push   %eax
    7707:	e8 3a cb ff ff       	call   4246 <HuffmanTree_cleanup>
    770c:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    770f:	83 ec 0c             	sub    $0xc,%esp
    7712:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7718:	50                   	push   %eax
    7719:	e8 28 cb ff ff       	call   4246 <HuffmanTree_cleanup>
    771e:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    7721:	83 ec 0c             	sub    $0xc,%esp
    7724:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    772a:	50                   	push   %eax
    772b:	e8 16 cb ff ff       	call   4246 <HuffmanTree_cleanup>
    7730:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    7733:	83 ec 0c             	sub    $0xc,%esp
    7736:	ff 75 d4             	pushl  -0x2c(%ebp)
    7739:	e8 08 bc ff ff       	call   3346 <lodepng_free>
    773e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    7741:	83 ec 0c             	sub    $0xc,%esp
    7744:	ff 75 d0             	pushl  -0x30(%ebp)
    7747:	e8 fa bb ff ff       	call   3346 <lodepng_free>
    774c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    774f:	83 ec 0c             	sub    $0xc,%esp
    7752:	ff 75 cc             	pushl  -0x34(%ebp)
    7755:	e8 ec bb ff ff       	call   3346 <lodepng_free>
    775a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    775d:	83 ec 0c             	sub    $0xc,%esp
    7760:	ff 75 f0             	pushl  -0x10(%ebp)
    7763:	e8 de bb ff ff       	call   3346 <lodepng_free>
    7768:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    776b:	83 ec 0c             	sub    $0xc,%esp
    776e:	ff 75 ec             	pushl  -0x14(%ebp)
    7771:	e8 d0 bb ff ff       	call   3346 <lodepng_free>
    7776:	83 c4 10             	add    $0x10,%esp

  return error;
    7779:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    777c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    777f:	c9                   	leave  
    7780:	c3                   	ret    

00007781 <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    7781:	55                   	push   %ebp
    7782:	89 e5                	mov    %esp,%ebp
    7784:	53                   	push   %ebx
    7785:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    7788:	8b 45 20             	mov    0x20(%ebp),%eax
    778b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    778e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    7795:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7798:	50                   	push   %eax
    7799:	e8 7b ca ff ff       	call   4219 <HuffmanTree_init>
    779e:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    77a1:	8d 45 bc             	lea    -0x44(%ebp),%eax
    77a4:	50                   	push   %eax
    77a5:	e8 6f ca ff ff       	call   4219 <HuffmanTree_init>
    77aa:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    77ad:	83 ec 0c             	sub    $0xc,%esp
    77b0:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    77b3:	50                   	push   %eax
    77b4:	e8 41 db ff ff       	call   52fa <generateFixedLitLenTree>
    77b9:	83 c4 10             	add    $0x10,%esp
    77bc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    77bf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    77c3:	75 12                	jne    77d7 <deflateFixed+0x56>
    77c5:	83 ec 0c             	sub    $0xc,%esp
    77c8:	8d 45 bc             	lea    -0x44(%ebp),%eax
    77cb:	50                   	push   %eax
    77cc:	e8 30 dc ff ff       	call   5401 <generateFixedDistanceTree>
    77d1:	83 c4 10             	add    $0x10,%esp
    77d4:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    77d7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    77db:	0f 85 3a 01 00 00    	jne    791b <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    77e1:	83 ec 04             	sub    $0x4,%esp
    77e4:	6a 01                	push   $0x1
    77e6:	ff 75 ec             	pushl  -0x14(%ebp)
    77e9:	ff 75 08             	pushl  0x8(%ebp)
    77ec:	e8 1c c0 ff ff       	call   380d <writeBits>
    77f1:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    77f4:	83 ec 04             	sub    $0x4,%esp
    77f7:	6a 01                	push   $0x1
    77f9:	6a 01                	push   $0x1
    77fb:	ff 75 08             	pushl  0x8(%ebp)
    77fe:	e8 0a c0 ff ff       	call   380d <writeBits>
    7803:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    7806:	83 ec 04             	sub    $0x4,%esp
    7809:	6a 01                	push   $0x1
    780b:	6a 00                	push   $0x0
    780d:	ff 75 08             	pushl  0x8(%ebp)
    7810:	e8 f8 bf ff ff       	call   380d <writeBits>
    7815:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    7818:	8b 45 1c             	mov    0x1c(%ebp),%eax
    781b:	8b 40 04             	mov    0x4(%eax),%eax
    781e:	85 c0                	test   %eax,%eax
    7820:	74 77                	je     7899 <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    7822:	83 ec 0c             	sub    $0xc,%esp
    7825:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7828:	50                   	push   %eax
    7829:	e8 e8 bc ff ff       	call   3516 <uivector_init>
    782e:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    7831:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7834:	8b 58 14             	mov    0x14(%eax),%ebx
    7837:	8b 45 1c             	mov    0x1c(%ebp),%eax
    783a:	8b 48 10             	mov    0x10(%eax),%ecx
    783d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7840:	8b 50 0c             	mov    0xc(%eax),%edx
    7843:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7846:	8b 40 08             	mov    0x8(%eax),%eax
    7849:	83 ec 0c             	sub    $0xc,%esp
    784c:	53                   	push   %ebx
    784d:	51                   	push   %ecx
    784e:	52                   	push   %edx
    784f:	50                   	push   %eax
    7850:	ff 75 18             	pushl  0x18(%ebp)
    7853:	ff 75 14             	pushl  0x14(%ebp)
    7856:	ff 75 10             	pushl  0x10(%ebp)
    7859:	ff 75 0c             	pushl  0xc(%ebp)
    785c:	8d 45 b0             	lea    -0x50(%ebp),%eax
    785f:	50                   	push   %eax
    7860:	e8 c7 ed ff ff       	call   662c <encodeLZ77>
    7865:	83 c4 30             	add    $0x30,%esp
    7868:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    786b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    786f:	75 17                	jne    7888 <deflateFixed+0x107>
    7871:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7874:	50                   	push   %eax
    7875:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7878:	50                   	push   %eax
    7879:	8d 45 b0             	lea    -0x50(%ebp),%eax
    787c:	50                   	push   %eax
    787d:	ff 75 08             	pushl  0x8(%ebp)
    7880:	e8 66 f4 ff ff       	call   6ceb <writeLZ77data>
    7885:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    7888:	83 ec 0c             	sub    $0xc,%esp
    788b:	8d 45 b0             	lea    -0x50(%ebp),%eax
    788e:	50                   	push   %eax
    788f:	e8 d9 bb ff ff       	call   346d <uivector_cleanup>
    7894:	83 c4 10             	add    $0x10,%esp
    7897:	eb 56                	jmp    78ef <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7899:	8b 45 14             	mov    0x14(%ebp),%eax
    789c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    789f:	eb 46                	jmp    78e7 <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    78a1:	8b 45 d8             	mov    -0x28(%ebp),%eax
    78a4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    78a7:	8b 55 10             	mov    0x10(%ebp),%edx
    78aa:	01 ca                	add    %ecx,%edx
    78ac:	0f b6 12             	movzbl (%edx),%edx
    78af:	0f b6 d2             	movzbl %dl,%edx
    78b2:	c1 e2 02             	shl    $0x2,%edx
    78b5:	01 d0                	add    %edx,%eax
    78b7:	8b 00                	mov    (%eax),%eax
    78b9:	89 c3                	mov    %eax,%ebx
    78bb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    78be:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    78c1:	8b 55 10             	mov    0x10(%ebp),%edx
    78c4:	01 ca                	add    %ecx,%edx
    78c6:	0f b6 12             	movzbl (%edx),%edx
    78c9:	0f b6 d2             	movzbl %dl,%edx
    78cc:	c1 e2 02             	shl    $0x2,%edx
    78cf:	01 d0                	add    %edx,%eax
    78d1:	8b 00                	mov    (%eax),%eax
    78d3:	83 ec 04             	sub    $0x4,%esp
    78d6:	53                   	push   %ebx
    78d7:	50                   	push   %eax
    78d8:	ff 75 08             	pushl  0x8(%ebp)
    78db:	e8 c1 c0 ff ff       	call   39a1 <writeBitsReversed>
    78e0:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    78e3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    78e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    78ea:	3b 45 18             	cmp    0x18(%ebp),%eax
    78ed:	7c b2                	jl     78a1 <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    78ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    78f3:	75 26                	jne    791b <deflateFixed+0x19a>
    78f5:	8b 45 d8             	mov    -0x28(%ebp),%eax
    78f8:	05 00 04 00 00       	add    $0x400,%eax
    78fd:	8b 00                	mov    (%eax),%eax
    78ff:	89 c2                	mov    %eax,%edx
    7901:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7904:	05 00 04 00 00       	add    $0x400,%eax
    7909:	8b 00                	mov    (%eax),%eax
    790b:	83 ec 04             	sub    $0x4,%esp
    790e:	52                   	push   %edx
    790f:	50                   	push   %eax
    7910:	ff 75 08             	pushl  0x8(%ebp)
    7913:	e8 89 c0 ff ff       	call   39a1 <writeBitsReversed>
    7918:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    791b:	83 ec 0c             	sub    $0xc,%esp
    791e:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7921:	50                   	push   %eax
    7922:	e8 1f c9 ff ff       	call   4246 <HuffmanTree_cleanup>
    7927:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    792a:	83 ec 0c             	sub    $0xc,%esp
    792d:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7930:	50                   	push   %eax
    7931:	e8 10 c9 ff ff       	call   4246 <HuffmanTree_cleanup>
    7936:	83 c4 10             	add    $0x10,%esp

  return error;
    7939:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    793c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    793f:	c9                   	leave  
    7940:	c3                   	ret    

00007941 <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    7941:	55                   	push   %ebp
    7942:	89 e5                	mov    %esp,%ebp
    7944:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    7947:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    794e:	ff 75 08             	pushl  0x8(%ebp)
    7951:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7954:	50                   	push   %eax
    7955:	e8 9e be ff ff       	call   37f8 <LodePNGBitWriter_init>
    795a:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    795d:	8b 45 14             	mov    0x14(%ebp),%eax
    7960:	8b 00                	mov    (%eax),%eax
    7962:	83 f8 02             	cmp    $0x2,%eax
    7965:	76 0a                	jbe    7971 <lodepng_deflatev+0x30>
    7967:	b8 3d 00 00 00       	mov    $0x3d,%eax
    796c:	e9 68 01 00 00       	jmp    7ad9 <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    7971:	8b 45 14             	mov    0x14(%ebp),%eax
    7974:	8b 00                	mov    (%eax),%eax
    7976:	85 c0                	test   %eax,%eax
    7978:	75 16                	jne    7990 <lodepng_deflatev+0x4f>
    797a:	ff 75 10             	pushl  0x10(%ebp)
    797d:	ff 75 0c             	pushl  0xc(%ebp)
    7980:	ff 75 08             	pushl  0x8(%ebp)
    7983:	e8 01 f2 ff ff       	call   6b89 <deflateNoCompression>
    7988:	83 c4 0c             	add    $0xc,%esp
    798b:	e9 49 01 00 00       	jmp    7ad9 <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    7990:	8b 45 14             	mov    0x14(%ebp),%eax
    7993:	8b 00                	mov    (%eax),%eax
    7995:	83 f8 01             	cmp    $0x1,%eax
    7998:	75 08                	jne    79a2 <lodepng_deflatev+0x61>
    799a:	8b 45 10             	mov    0x10(%ebp),%eax
    799d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    79a0:	eb 2c                	jmp    79ce <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    79a2:	8b 45 10             	mov    0x10(%ebp),%eax
    79a5:	c1 e8 03             	shr    $0x3,%eax
    79a8:	83 c0 08             	add    $0x8,%eax
    79ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    79ae:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    79b5:	7f 07                	jg     79be <lodepng_deflatev+0x7d>
    79b7:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    79be:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    79c5:	7e 07                	jle    79ce <lodepng_deflatev+0x8d>
    79c7:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    79ce:	8b 55 10             	mov    0x10(%ebp),%edx
    79d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    79d4:	01 d0                	add    %edx,%eax
    79d6:	83 e8 01             	sub    $0x1,%eax
    79d9:	99                   	cltd   
    79da:	f7 7d ec             	idivl  -0x14(%ebp)
    79dd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    79e0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    79e4:	75 07                	jne    79ed <lodepng_deflatev+0xac>
    79e6:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    79ed:	8b 45 14             	mov    0x14(%ebp),%eax
    79f0:	8b 40 08             	mov    0x8(%eax),%eax
    79f3:	83 ec 08             	sub    $0x8,%esp
    79f6:	50                   	push   %eax
    79f7:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    79fa:	50                   	push   %eax
    79fb:	e8 1c e8 ff ff       	call   621c <hash_init>
    7a00:	83 c4 10             	add    $0x10,%esp
    7a03:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7a06:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7a0a:	0f 85 b7 00 00 00    	jne    7ac7 <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7a10:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7a17:	e9 99 00 00 00       	jmp    7ab5 <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    7a1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7a1f:	83 e8 01             	sub    $0x1,%eax
    7a22:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7a25:	0f 94 c0             	sete   %al
    7a28:	0f b6 c0             	movzbl %al,%eax
    7a2b:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    7a2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7a31:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    7a35:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    7a38:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7a3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7a3e:	01 d0                	add    %edx,%eax
    7a40:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    7a43:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7a46:	3b 45 10             	cmp    0x10(%ebp),%eax
    7a49:	7e 06                	jle    7a51 <lodepng_deflatev+0x110>
    7a4b:	8b 45 10             	mov    0x10(%ebp),%eax
    7a4e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    7a51:	8b 45 14             	mov    0x14(%ebp),%eax
    7a54:	8b 00                	mov    (%eax),%eax
    7a56:	83 f8 01             	cmp    $0x1,%eax
    7a59:	75 27                	jne    7a82 <lodepng_deflatev+0x141>
    7a5b:	83 ec 04             	sub    $0x4,%esp
    7a5e:	ff 75 e0             	pushl  -0x20(%ebp)
    7a61:	ff 75 14             	pushl  0x14(%ebp)
    7a64:	ff 75 e4             	pushl  -0x1c(%ebp)
    7a67:	ff 75 dc             	pushl  -0x24(%ebp)
    7a6a:	ff 75 0c             	pushl  0xc(%ebp)
    7a6d:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7a70:	50                   	push   %eax
    7a71:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a74:	50                   	push   %eax
    7a75:	e8 07 fd ff ff       	call   7781 <deflateFixed>
    7a7a:	83 c4 20             	add    $0x20,%esp
    7a7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7a80:	eb 2f                	jmp    7ab1 <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    7a82:	8b 45 14             	mov    0x14(%ebp),%eax
    7a85:	8b 00                	mov    (%eax),%eax
    7a87:	83 f8 02             	cmp    $0x2,%eax
    7a8a:	75 25                	jne    7ab1 <lodepng_deflatev+0x170>
    7a8c:	83 ec 04             	sub    $0x4,%esp
    7a8f:	ff 75 e0             	pushl  -0x20(%ebp)
    7a92:	ff 75 14             	pushl  0x14(%ebp)
    7a95:	ff 75 e4             	pushl  -0x1c(%ebp)
    7a98:	ff 75 dc             	pushl  -0x24(%ebp)
    7a9b:	ff 75 0c             	pushl  0xc(%ebp)
    7a9e:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7aa1:	50                   	push   %eax
    7aa2:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7aa5:	50                   	push   %eax
    7aa6:	e8 7b f3 ff ff       	call   6e26 <deflateDynamic>
    7aab:	83 c4 20             	add    $0x20,%esp
    7aae:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7ab1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7ab5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7ab8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7abb:	74 0a                	je     7ac7 <lodepng_deflatev+0x186>
    7abd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7ac1:	0f 84 55 ff ff ff    	je     7a1c <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    7ac7:	83 ec 0c             	sub    $0xc,%esp
    7aca:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7acd:	50                   	push   %eax
    7ace:	e8 08 e9 ff ff       	call   63db <hash_cleanup>
    7ad3:	83 c4 10             	add    $0x10,%esp

  return error;
    7ad6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7ad9:	c9                   	leave  
    7ada:	c3                   	ret    

00007adb <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    7adb:	55                   	push   %ebp
    7adc:	89 e5                	mov    %esp,%ebp
    7ade:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7ae1:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ae4:	8b 08                	mov    (%eax),%ecx
    7ae6:	8b 45 08             	mov    0x8(%ebp),%eax
    7ae9:	8b 10                	mov    (%eax),%edx
    7aeb:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7aee:	51                   	push   %ecx
    7aef:	52                   	push   %edx
    7af0:	50                   	push   %eax
    7af1:	e8 f0 ba ff ff       	call   35e6 <ucvector_init>
    7af6:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    7af9:	ff 75 18             	pushl  0x18(%ebp)
    7afc:	ff 75 14             	pushl  0x14(%ebp)
    7aff:	ff 75 10             	pushl  0x10(%ebp)
    7b02:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7b05:	50                   	push   %eax
    7b06:	e8 36 fe ff ff       	call   7941 <lodepng_deflatev>
    7b0b:	83 c4 10             	add    $0x10,%esp
    7b0e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7b11:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7b14:	8b 45 08             	mov    0x8(%ebp),%eax
    7b17:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7b19:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7b1c:	8b 45 0c             	mov    0xc(%ebp),%eax
    7b1f:	89 10                	mov    %edx,(%eax)
  return error;
    7b21:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7b24:	c9                   	leave  
    7b25:	c3                   	ret    

00007b26 <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    7b26:	55                   	push   %ebp
    7b27:	89 e5                	mov    %esp,%ebp
    7b29:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    7b2c:	8b 45 18             	mov    0x18(%ebp),%eax
    7b2f:	8b 40 1c             	mov    0x1c(%eax),%eax
    7b32:	85 c0                	test   %eax,%eax
    7b34:	74 34                	je     7b6a <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    7b36:	8b 45 18             	mov    0x18(%ebp),%eax
    7b39:	8b 40 1c             	mov    0x1c(%eax),%eax
    7b3c:	83 ec 0c             	sub    $0xc,%esp
    7b3f:	ff 75 18             	pushl  0x18(%ebp)
    7b42:	ff 75 14             	pushl  0x14(%ebp)
    7b45:	ff 75 10             	pushl  0x10(%ebp)
    7b48:	ff 75 0c             	pushl  0xc(%ebp)
    7b4b:	ff 75 08             	pushl  0x8(%ebp)
    7b4e:	ff d0                	call   *%eax
    7b50:	83 c4 20             	add    $0x20,%esp
    7b53:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    7b56:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7b5a:	74 07                	je     7b63 <deflate+0x3d>
    7b5c:	b8 6f 00 00 00       	mov    $0x6f,%eax
    7b61:	eb 21                	jmp    7b84 <deflate+0x5e>
    7b63:	b8 00 00 00 00       	mov    $0x0,%eax
    7b68:	eb 1a                	jmp    7b84 <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    7b6a:	83 ec 0c             	sub    $0xc,%esp
    7b6d:	ff 75 18             	pushl  0x18(%ebp)
    7b70:	ff 75 14             	pushl  0x14(%ebp)
    7b73:	ff 75 10             	pushl  0x10(%ebp)
    7b76:	ff 75 0c             	pushl  0xc(%ebp)
    7b79:	ff 75 08             	pushl  0x8(%ebp)
    7b7c:	e8 5a ff ff ff       	call   7adb <lodepng_deflate>
    7b81:	83 c4 20             	add    $0x20,%esp
  }
}
    7b84:	c9                   	leave  
    7b85:	c3                   	ret    

00007b86 <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    7b86:	55                   	push   %ebp
    7b87:	89 e5                	mov    %esp,%ebp
    7b89:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    7b8c:	8b 45 08             	mov    0x8(%ebp),%eax
    7b8f:	0f b7 c0             	movzwl %ax,%eax
    7b92:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    7b95:	8b 45 08             	mov    0x8(%ebp),%eax
    7b98:	c1 e8 10             	shr    $0x10,%eax
    7b9b:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    7b9e:	e9 82 00 00 00       	jmp    7c25 <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    7ba3:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    7ba8:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    7baf:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    7bb3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    7bb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7bb9:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    7bbc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7bc3:	eb 1c                	jmp    7be1 <update_adler32+0x5b>
      s1 += (*data++);
    7bc5:	8b 45 0c             	mov    0xc(%ebp),%eax
    7bc8:	8d 50 01             	lea    0x1(%eax),%edx
    7bcb:	89 55 0c             	mov    %edx,0xc(%ebp)
    7bce:	0f b6 00             	movzbl (%eax),%eax
    7bd1:	0f b6 c0             	movzbl %al,%eax
    7bd4:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    7bd7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7bda:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    7bdd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7be1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7be4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7be7:	75 dc                	jne    7bc5 <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    7be9:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7bec:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7bf1:	89 c8                	mov    %ecx,%eax
    7bf3:	f7 e2                	mul    %edx
    7bf5:	89 d0                	mov    %edx,%eax
    7bf7:	c1 e8 0f             	shr    $0xf,%eax
    7bfa:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7c00:	29 c1                	sub    %eax,%ecx
    7c02:	89 c8                	mov    %ecx,%eax
    7c04:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    7c07:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7c0a:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7c0f:	89 c8                	mov    %ecx,%eax
    7c11:	f7 e2                	mul    %edx
    7c13:	89 d0                	mov    %edx,%eax
    7c15:	c1 e8 0f             	shr    $0xf,%eax
    7c18:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7c1e:	29 c1                	sub    %eax,%ecx
    7c20:	89 c8                	mov    %ecx,%eax
    7c22:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    7c25:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7c29:	0f 85 74 ff ff ff    	jne    7ba3 <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    7c2f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7c32:	c1 e0 10             	shl    $0x10,%eax
    7c35:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    7c38:	c9                   	leave  
    7c39:	c3                   	ret    

00007c3a <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    7c3a:	55                   	push   %ebp
    7c3b:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    7c3d:	ff 75 0c             	pushl  0xc(%ebp)
    7c40:	ff 75 08             	pushl  0x8(%ebp)
    7c43:	6a 01                	push   $0x1
    7c45:	e8 3c ff ff ff       	call   7b86 <update_adler32>
    7c4a:	83 c4 0c             	add    $0xc,%esp
}
    7c4d:	c9                   	leave  
    7c4e:	c3                   	ret    

00007c4f <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    7c4f:	55                   	push   %ebp
    7c50:	89 e5                	mov    %esp,%ebp
    7c52:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    7c55:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    7c5c:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    7c60:	7f 0a                	jg     7c6c <lodepng_zlib_decompressv+0x1d>
    7c62:	b8 35 00 00 00       	mov    $0x35,%eax
    7c67:	e9 27 01 00 00       	jmp    7d93 <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    7c6c:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c6f:	0f b6 00             	movzbl (%eax),%eax
    7c72:	0f b6 c0             	movzbl %al,%eax
    7c75:	c1 e0 08             	shl    $0x8,%eax
    7c78:	89 c2                	mov    %eax,%edx
    7c7a:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c7d:	83 c0 01             	add    $0x1,%eax
    7c80:	0f b6 00             	movzbl (%eax),%eax
    7c83:	0f b6 c0             	movzbl %al,%eax
    7c86:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    7c89:	ba 43 08 21 84       	mov    $0x84210843,%edx
    7c8e:	89 c8                	mov    %ecx,%eax
    7c90:	f7 ea                	imul   %edx
    7c92:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    7c95:	c1 f8 04             	sar    $0x4,%eax
    7c98:	89 c2                	mov    %eax,%edx
    7c9a:	89 c8                	mov    %ecx,%eax
    7c9c:	c1 f8 1f             	sar    $0x1f,%eax
    7c9f:	29 c2                	sub    %eax,%edx
    7ca1:	89 d0                	mov    %edx,%eax
    7ca3:	89 c2                	mov    %eax,%edx
    7ca5:	c1 e2 05             	shl    $0x5,%edx
    7ca8:	29 c2                	sub    %eax,%edx
    7caa:	89 c8                	mov    %ecx,%eax
    7cac:	29 d0                	sub    %edx,%eax
    7cae:	85 c0                	test   %eax,%eax
    7cb0:	74 0a                	je     7cbc <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    7cb2:	b8 18 00 00 00       	mov    $0x18,%eax
    7cb7:	e9 d7 00 00 00       	jmp    7d93 <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    7cbc:	8b 45 0c             	mov    0xc(%ebp),%eax
    7cbf:	0f b6 00             	movzbl (%eax),%eax
    7cc2:	0f b6 c0             	movzbl %al,%eax
    7cc5:	83 e0 0f             	and    $0xf,%eax
    7cc8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    7ccb:	8b 45 0c             	mov    0xc(%ebp),%eax
    7cce:	0f b6 00             	movzbl (%eax),%eax
    7cd1:	c0 e8 04             	shr    $0x4,%al
    7cd4:	0f b6 c0             	movzbl %al,%eax
    7cd7:	83 e0 0f             	and    $0xf,%eax
    7cda:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    7cdd:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ce0:	83 c0 01             	add    $0x1,%eax
    7ce3:	0f b6 00             	movzbl (%eax),%eax
    7ce6:	c0 e8 05             	shr    $0x5,%al
    7ce9:	0f b6 c0             	movzbl %al,%eax
    7cec:	83 e0 01             	and    $0x1,%eax
    7cef:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    7cf2:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    7cf6:	75 06                	jne    7cfe <lodepng_zlib_decompressv+0xaf>
    7cf8:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    7cfc:	76 0a                	jbe    7d08 <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    7cfe:	b8 19 00 00 00       	mov    $0x19,%eax
    7d03:	e9 8b 00 00 00       	jmp    7d93 <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    7d08:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7d0c:	74 07                	je     7d15 <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    7d0e:	b8 1a 00 00 00       	mov    $0x1a,%eax
    7d13:	eb 7e                	jmp    7d93 <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    7d15:	8b 45 10             	mov    0x10(%ebp),%eax
    7d18:	8d 50 fe             	lea    -0x2(%eax),%edx
    7d1b:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d1e:	83 c0 02             	add    $0x2,%eax
    7d21:	ff 75 14             	pushl  0x14(%ebp)
    7d24:	52                   	push   %edx
    7d25:	50                   	push   %eax
    7d26:	ff 75 08             	pushl  0x8(%ebp)
    7d29:	e8 09 e3 ff ff       	call   6037 <inflatev>
    7d2e:	83 c4 10             	add    $0x10,%esp
    7d31:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    7d34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7d38:	74 05                	je     7d3f <lodepng_zlib_decompressv+0xf0>
    7d3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7d3d:	eb 54                	jmp    7d93 <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    7d3f:	8b 45 14             	mov    0x14(%ebp),%eax
    7d42:	8b 00                	mov    (%eax),%eax
    7d44:	85 c0                	test   %eax,%eax
    7d46:	75 46                	jne    7d8e <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    7d48:	8b 45 10             	mov    0x10(%ebp),%eax
    7d4b:	8d 50 fc             	lea    -0x4(%eax),%edx
    7d4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d51:	01 d0                	add    %edx,%eax
    7d53:	83 ec 0c             	sub    $0xc,%esp
    7d56:	50                   	push   %eax
    7d57:	e8 47 b9 ff ff       	call   36a3 <lodepng_read32bitInt>
    7d5c:	83 c4 10             	add    $0x10,%esp
    7d5f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    7d62:	8b 45 08             	mov    0x8(%ebp),%eax
    7d65:	8b 40 04             	mov    0x4(%eax),%eax
    7d68:	89 c2                	mov    %eax,%edx
    7d6a:	8b 45 08             	mov    0x8(%ebp),%eax
    7d6d:	8b 00                	mov    (%eax),%eax
    7d6f:	83 ec 08             	sub    $0x8,%esp
    7d72:	52                   	push   %edx
    7d73:	50                   	push   %eax
    7d74:	e8 c1 fe ff ff       	call   7c3a <adler32>
    7d79:	83 c4 10             	add    $0x10,%esp
    7d7c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    7d7f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7d82:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7d85:	74 07                	je     7d8e <lodepng_zlib_decompressv+0x13f>
    7d87:	b8 3a 00 00 00       	mov    $0x3a,%eax
    7d8c:	eb 05                	jmp    7d93 <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    7d8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7d93:	c9                   	leave  
    7d94:	c3                   	ret    

00007d95 <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    7d95:	55                   	push   %ebp
    7d96:	89 e5                	mov    %esp,%ebp
    7d98:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7d9b:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d9e:	8b 08                	mov    (%eax),%ecx
    7da0:	8b 45 08             	mov    0x8(%ebp),%eax
    7da3:	8b 10                	mov    (%eax),%edx
    7da5:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7da8:	51                   	push   %ecx
    7da9:	52                   	push   %edx
    7daa:	50                   	push   %eax
    7dab:	e8 36 b8 ff ff       	call   35e6 <ucvector_init>
    7db0:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7db3:	ff 75 18             	pushl  0x18(%ebp)
    7db6:	ff 75 14             	pushl  0x14(%ebp)
    7db9:	ff 75 10             	pushl  0x10(%ebp)
    7dbc:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7dbf:	50                   	push   %eax
    7dc0:	e8 8a fe ff ff       	call   7c4f <lodepng_zlib_decompressv>
    7dc5:	83 c4 10             	add    $0x10,%esp
    7dc8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7dcb:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7dce:	8b 45 08             	mov    0x8(%ebp),%eax
    7dd1:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7dd3:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7dd6:	8b 45 0c             	mov    0xc(%ebp),%eax
    7dd9:	89 10                	mov    %edx,(%eax)
  return error;
    7ddb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7dde:	c9                   	leave  
    7ddf:	c3                   	ret    

00007de0 <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    7de0:	55                   	push   %ebp
    7de1:	89 e5                	mov    %esp,%ebp
    7de3:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    7de6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7de9:	8b 40 0c             	mov    0xc(%eax),%eax
    7dec:	85 c0                	test   %eax,%eax
    7dee:	74 57                	je     7e47 <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    7df0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7df3:	8b 40 0c             	mov    0xc(%eax),%eax
    7df6:	83 ec 0c             	sub    $0xc,%esp
    7df9:	ff 75 1c             	pushl  0x1c(%ebp)
    7dfc:	ff 75 18             	pushl  0x18(%ebp)
    7dff:	ff 75 14             	pushl  0x14(%ebp)
    7e02:	ff 75 0c             	pushl  0xc(%ebp)
    7e05:	ff 75 08             	pushl  0x8(%ebp)
    7e08:	ff d0                	call   *%eax
    7e0a:	83 c4 20             	add    $0x20,%esp
    7e0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    7e10:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7e14:	0f 84 98 00 00 00    	je     7eb2 <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    7e1a:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    7e21:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7e24:	8b 40 08             	mov    0x8(%eax),%eax
    7e27:	85 c0                	test   %eax,%eax
    7e29:	0f 84 83 00 00 00    	je     7eb2 <zlib_decompress+0xd2>
    7e2f:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e32:	8b 10                	mov    (%eax),%edx
    7e34:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7e37:	8b 40 08             	mov    0x8(%eax),%eax
    7e3a:	39 c2                	cmp    %eax,%edx
    7e3c:	7e 74                	jle    7eb2 <zlib_decompress+0xd2>
    7e3e:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    7e45:	eb 6b                	jmp    7eb2 <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    7e47:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e4a:	8b 08                	mov    (%eax),%ecx
    7e4c:	8b 45 08             	mov    0x8(%ebp),%eax
    7e4f:	8b 10                	mov    (%eax),%edx
    7e51:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e54:	83 ec 04             	sub    $0x4,%esp
    7e57:	51                   	push   %ecx
    7e58:	52                   	push   %edx
    7e59:	50                   	push   %eax
    7e5a:	e8 87 b7 ff ff       	call   35e6 <ucvector_init>
    7e5f:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    7e62:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7e66:	74 22                	je     7e8a <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    7e68:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e6b:	8b 10                	mov    (%eax),%edx
    7e6d:	8b 45 10             	mov    0x10(%ebp),%eax
    7e70:	01 d0                	add    %edx,%eax
    7e72:	83 ec 08             	sub    $0x8,%esp
    7e75:	50                   	push   %eax
    7e76:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e79:	50                   	push   %eax
    7e7a:	e8 00 b7 ff ff       	call   357f <ucvector_resize>
    7e7f:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    7e82:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e85:	8b 00                	mov    (%eax),%eax
    7e87:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7e8a:	ff 75 1c             	pushl  0x1c(%ebp)
    7e8d:	ff 75 18             	pushl  0x18(%ebp)
    7e90:	ff 75 14             	pushl  0x14(%ebp)
    7e93:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7e96:	50                   	push   %eax
    7e97:	e8 b3 fd ff ff       	call   7c4f <lodepng_zlib_decompressv>
    7e9c:	83 c4 10             	add    $0x10,%esp
    7e9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    7ea2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7ea5:	8b 45 08             	mov    0x8(%ebp),%eax
    7ea8:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    7eaa:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7ead:	8b 45 0c             	mov    0xc(%ebp),%eax
    7eb0:	89 10                	mov    %edx,(%eax)
  }
  return error;
    7eb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7eb5:	c9                   	leave  
    7eb6:	c3                   	ret    

00007eb7 <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    7eb7:	55                   	push   %ebp
    7eb8:	89 e5                	mov    %esp,%ebp
    7eba:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    7ebd:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    7ec4:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    7ecb:	83 ec 0c             	sub    $0xc,%esp
    7ece:	ff 75 18             	pushl  0x18(%ebp)
    7ed1:	ff 75 14             	pushl  0x14(%ebp)
    7ed4:	ff 75 10             	pushl  0x10(%ebp)
    7ed7:	8d 45 d0             	lea    -0x30(%ebp),%eax
    7eda:	50                   	push   %eax
    7edb:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7ede:	50                   	push   %eax
    7edf:	e8 42 fc ff ff       	call   7b26 <deflate>
    7ee4:	83 c4 20             	add    $0x20,%esp
    7ee7:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    7eea:	8b 45 08             	mov    0x8(%ebp),%eax
    7eed:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    7ef3:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ef6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    7efc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7f00:	75 33                	jne    7f35 <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    7f02:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7f05:	8d 50 06             	lea    0x6(%eax),%edx
    7f08:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f0b:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    7f0d:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f10:	8b 00                	mov    (%eax),%eax
    7f12:	83 ec 0c             	sub    $0xc,%esp
    7f15:	50                   	push   %eax
    7f16:	e8 0a b4 ff ff       	call   3325 <lodepng_malloc>
    7f1b:	83 c4 10             	add    $0x10,%esp
    7f1e:	89 c2                	mov    %eax,%edx
    7f20:	8b 45 08             	mov    0x8(%ebp),%eax
    7f23:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    7f25:	8b 45 08             	mov    0x8(%ebp),%eax
    7f28:	8b 00                	mov    (%eax),%eax
    7f2a:	85 c0                	test   %eax,%eax
    7f2c:	75 07                	jne    7f35 <lodepng_zlib_compress+0x7e>
    7f2e:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    7f35:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7f39:	0f 85 e2 00 00 00    	jne    8021 <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    7f3f:	8b 45 14             	mov    0x14(%ebp),%eax
    7f42:	83 ec 08             	sub    $0x8,%esp
    7f45:	50                   	push   %eax
    7f46:	ff 75 10             	pushl  0x10(%ebp)
    7f49:	e8 ec fc ff ff       	call   7c3a <adler32>
    7f4e:	83 c4 10             	add    $0x10,%esp
    7f51:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    7f54:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    7f5b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    7f62:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    7f69:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7f6c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7f73:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7f76:	01 d0                	add    %edx,%eax
    7f78:	8d 14 00             	lea    (%eax,%eax,1),%edx
    7f7b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7f7e:	01 d0                	add    %edx,%eax
    7f80:	c1 e0 05             	shl    $0x5,%eax
    7f83:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    7f86:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7f89:	ba 85 10 42 08       	mov    $0x8421085,%edx
    7f8e:	89 c8                	mov    %ecx,%eax
    7f90:	f7 e2                	mul    %edx
    7f92:	89 c8                	mov    %ecx,%eax
    7f94:	29 d0                	sub    %edx,%eax
    7f96:	d1 e8                	shr    %eax
    7f98:	01 d0                	add    %edx,%eax
    7f9a:	c1 e8 04             	shr    $0x4,%eax
    7f9d:	89 c2                	mov    %eax,%edx
    7f9f:	c1 e2 05             	shl    $0x5,%edx
    7fa2:	29 c2                	sub    %eax,%edx
    7fa4:	89 c8                	mov    %ecx,%eax
    7fa6:	29 d0                	sub    %edx,%eax
    7fa8:	ba 1f 00 00 00       	mov    $0x1f,%edx
    7fad:	29 c2                	sub    %eax,%edx
    7faf:	89 d0                	mov    %edx,%eax
    7fb1:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    7fb4:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7fb7:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    7fba:	8b 45 08             	mov    0x8(%ebp),%eax
    7fbd:	8b 00                	mov    (%eax),%eax
    7fbf:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7fc2:	c1 ea 08             	shr    $0x8,%edx
    7fc5:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    7fc7:	8b 45 08             	mov    0x8(%ebp),%eax
    7fca:	8b 00                	mov    (%eax),%eax
    7fcc:	83 c0 01             	add    $0x1,%eax
    7fcf:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7fd2:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    7fd4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7fdb:	eb 1e                	jmp    7ffb <lodepng_zlib_compress+0x144>
    7fdd:	8b 45 08             	mov    0x8(%ebp),%eax
    7fe0:	8b 00                	mov    (%eax),%eax
    7fe2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    7fe5:	83 c2 02             	add    $0x2,%edx
    7fe8:	01 c2                	add    %eax,%edx
    7fea:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    7fed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7ff0:	01 c8                	add    %ecx,%eax
    7ff2:	0f b6 00             	movzbl (%eax),%eax
    7ff5:	88 02                	mov    %al,(%edx)
    7ff7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7ffb:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7ffe:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    8001:	75 da                	jne    7fdd <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    8003:	8b 45 08             	mov    0x8(%ebp),%eax
    8006:	8b 10                	mov    (%eax),%edx
    8008:	8b 45 0c             	mov    0xc(%ebp),%eax
    800b:	8b 00                	mov    (%eax),%eax
    800d:	83 e8 04             	sub    $0x4,%eax
    8010:	01 d0                	add    %edx,%eax
    8012:	83 ec 08             	sub    $0x8,%esp
    8015:	ff 75 ec             	pushl  -0x14(%ebp)
    8018:	50                   	push   %eax
    8019:	e8 c8 b6 ff ff       	call   36e6 <lodepng_set32bitInt>
    801e:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    8021:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    8024:	83 ec 0c             	sub    $0xc,%esp
    8027:	50                   	push   %eax
    8028:	e8 19 b3 ff ff       	call   3346 <lodepng_free>
    802d:	83 c4 10             	add    $0x10,%esp
  return error;
    8030:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    8033:	c9                   	leave  
    8034:	c3                   	ret    

00008035 <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    8035:	55                   	push   %ebp
    8036:	89 e5                	mov    %esp,%ebp
    8038:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    803b:	8b 45 18             	mov    0x18(%ebp),%eax
    803e:	8b 40 18             	mov    0x18(%eax),%eax
    8041:	85 c0                	test   %eax,%eax
    8043:	74 34                	je     8079 <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    8045:	8b 45 18             	mov    0x18(%ebp),%eax
    8048:	8b 40 18             	mov    0x18(%eax),%eax
    804b:	83 ec 0c             	sub    $0xc,%esp
    804e:	ff 75 18             	pushl  0x18(%ebp)
    8051:	ff 75 14             	pushl  0x14(%ebp)
    8054:	ff 75 10             	pushl  0x10(%ebp)
    8057:	ff 75 0c             	pushl  0xc(%ebp)
    805a:	ff 75 08             	pushl  0x8(%ebp)
    805d:	ff d0                	call   *%eax
    805f:	83 c4 20             	add    $0x20,%esp
    8062:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    8065:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    8069:	74 07                	je     8072 <zlib_compress+0x3d>
    806b:	b8 6f 00 00 00       	mov    $0x6f,%eax
    8070:	eb 21                	jmp    8093 <zlib_compress+0x5e>
    8072:	b8 00 00 00 00       	mov    $0x0,%eax
    8077:	eb 1a                	jmp    8093 <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    8079:	83 ec 0c             	sub    $0xc,%esp
    807c:	ff 75 18             	pushl  0x18(%ebp)
    807f:	ff 75 14             	pushl  0x14(%ebp)
    8082:	ff 75 10             	pushl  0x10(%ebp)
    8085:	ff 75 0c             	pushl  0xc(%ebp)
    8088:	ff 75 08             	pushl  0x8(%ebp)
    808b:	e8 27 fe ff ff       	call   7eb7 <lodepng_zlib_compress>
    8090:	83 c4 20             	add    $0x20,%esp
  }
}
    8093:	c9                   	leave  
    8094:	c3                   	ret    

00008095 <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    8095:	55                   	push   %ebp
    8096:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    8098:	8b 45 08             	mov    0x8(%ebp),%eax
    809b:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    80a1:	8b 45 08             	mov    0x8(%ebp),%eax
    80a4:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    80ab:	8b 45 08             	mov    0x8(%ebp),%eax
    80ae:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    80b5:	8b 45 08             	mov    0x8(%ebp),%eax
    80b8:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    80bf:	8b 45 08             	mov    0x8(%ebp),%eax
    80c2:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    80c9:	8b 45 08             	mov    0x8(%ebp),%eax
    80cc:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    80d3:	8b 45 08             	mov    0x8(%ebp),%eax
    80d6:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    80dd:	8b 45 08             	mov    0x8(%ebp),%eax
    80e0:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    80e7:	8b 45 08             	mov    0x8(%ebp),%eax
    80ea:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    80f1:	90                   	nop
    80f2:	5d                   	pop    %ebp
    80f3:	c3                   	ret    

000080f4 <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    80f4:	55                   	push   %ebp
    80f5:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    80f7:	8b 45 08             	mov    0x8(%ebp),%eax
    80fa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    8100:	8b 45 08             	mov    0x8(%ebp),%eax
    8103:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    810a:	8b 45 08             	mov    0x8(%ebp),%eax
    810d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    8114:	8b 45 08             	mov    0x8(%ebp),%eax
    8117:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    811e:	8b 45 08             	mov    0x8(%ebp),%eax
    8121:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    8128:	8b 45 08             	mov    0x8(%ebp),%eax
    812b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    8132:	90                   	nop
    8133:	5d                   	pop    %ebp
    8134:	c3                   	ret    

00008135 <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    8135:	55                   	push   %ebp
    8136:	89 e5                	mov    %esp,%ebp
    8138:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    813b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    8142:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8149:	eb 2a                	jmp    8175 <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    814b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    814e:	8b 45 08             	mov    0x8(%ebp),%eax
    8151:	01 d0                	add    %edx,%eax
    8153:	0f b6 00             	movzbl (%eax),%eax
    8156:	0f b6 c0             	movzbl %al,%eax
    8159:	33 45 fc             	xor    -0x4(%ebp),%eax
    815c:	0f b6 c0             	movzbl %al,%eax
    815f:	8b 04 85 20 e1 01 00 	mov    0x1e120(,%eax,4),%eax
    8166:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8169:	c1 ea 08             	shr    $0x8,%edx
    816c:	31 d0                	xor    %edx,%eax
    816e:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    8171:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8175:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8178:	3b 45 0c             	cmp    0xc(%ebp),%eax
    817b:	7c ce                	jl     814b <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    817d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8180:	f7 d0                	not    %eax
}
    8182:	c9                   	leave  
    8183:	c3                   	ret    

00008184 <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    8184:	55                   	push   %ebp
    8185:	89 e5                	mov    %esp,%ebp
    8187:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    818a:	8b 45 08             	mov    0x8(%ebp),%eax
    818d:	8b 00                	mov    (%eax),%eax
    818f:	c1 f8 03             	sar    $0x3,%eax
    8192:	89 c2                	mov    %eax,%edx
    8194:	8b 45 0c             	mov    0xc(%ebp),%eax
    8197:	01 d0                	add    %edx,%eax
    8199:	0f b6 00             	movzbl (%eax),%eax
    819c:	0f b6 d0             	movzbl %al,%edx
    819f:	8b 45 08             	mov    0x8(%ebp),%eax
    81a2:	8b 00                	mov    (%eax),%eax
    81a4:	f7 d0                	not    %eax
    81a6:	83 e0 07             	and    $0x7,%eax
    81a9:	89 c1                	mov    %eax,%ecx
    81ab:	d3 fa                	sar    %cl,%edx
    81ad:	89 d0                	mov    %edx,%eax
    81af:	83 e0 01             	and    $0x1,%eax
    81b2:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    81b5:	8b 45 08             	mov    0x8(%ebp),%eax
    81b8:	8b 00                	mov    (%eax),%eax
    81ba:	8d 50 01             	lea    0x1(%eax),%edx
    81bd:	8b 45 08             	mov    0x8(%ebp),%eax
    81c0:	89 10                	mov    %edx,(%eax)
  return result;
    81c2:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    81c6:	c9                   	leave  
    81c7:	c3                   	ret    

000081c8 <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    81c8:	55                   	push   %ebp
    81c9:	89 e5                	mov    %esp,%ebp
    81cb:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    81ce:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    81d5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    81dc:	eb 1b                	jmp    81f9 <readBitsFromReversedStream+0x31>
    result <<= 1u;
    81de:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    81e1:	ff 75 0c             	pushl  0xc(%ebp)
    81e4:	ff 75 08             	pushl  0x8(%ebp)
    81e7:	e8 98 ff ff ff       	call   8184 <readBitFromReversedStream>
    81ec:	83 c4 08             	add    $0x8,%esp
    81ef:	0f b6 c0             	movzbl %al,%eax
    81f2:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    81f5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    81f9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    81fc:	3b 45 10             	cmp    0x10(%ebp),%eax
    81ff:	7c dd                	jl     81de <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    8201:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    8204:	c9                   	leave  
    8205:	c3                   	ret    

00008206 <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    8206:	55                   	push   %ebp
    8207:	89 e5                	mov    %esp,%ebp
    8209:	56                   	push   %esi
    820a:	53                   	push   %ebx
    820b:	83 ec 04             	sub    $0x4,%esp
    820e:	8b 45 10             	mov    0x10(%ebp),%eax
    8211:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    8214:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    8218:	75 3e                	jne    8258 <setBitOfReversedStream+0x52>
    821a:	8b 45 08             	mov    0x8(%ebp),%eax
    821d:	8b 00                	mov    (%eax),%eax
    821f:	c1 f8 03             	sar    $0x3,%eax
    8222:	89 c2                	mov    %eax,%edx
    8224:	8b 45 0c             	mov    0xc(%ebp),%eax
    8227:	01 c2                	add    %eax,%edx
    8229:	8b 45 08             	mov    0x8(%ebp),%eax
    822c:	8b 00                	mov    (%eax),%eax
    822e:	c1 f8 03             	sar    $0x3,%eax
    8231:	89 c1                	mov    %eax,%ecx
    8233:	8b 45 0c             	mov    0xc(%ebp),%eax
    8236:	01 c8                	add    %ecx,%eax
    8238:	0f b6 18             	movzbl (%eax),%ebx
    823b:	8b 45 08             	mov    0x8(%ebp),%eax
    823e:	8b 00                	mov    (%eax),%eax
    8240:	f7 d0                	not    %eax
    8242:	83 e0 07             	and    $0x7,%eax
    8245:	be 01 00 00 00       	mov    $0x1,%esi
    824a:	89 c1                	mov    %eax,%ecx
    824c:	d3 e6                	shl    %cl,%esi
    824e:	89 f0                	mov    %esi,%eax
    8250:	f7 d0                	not    %eax
    8252:	21 d8                	and    %ebx,%eax
    8254:	88 02                	mov    %al,(%edx)
    8256:	eb 3a                	jmp    8292 <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    8258:	8b 45 08             	mov    0x8(%ebp),%eax
    825b:	8b 00                	mov    (%eax),%eax
    825d:	c1 f8 03             	sar    $0x3,%eax
    8260:	89 c2                	mov    %eax,%edx
    8262:	8b 45 0c             	mov    0xc(%ebp),%eax
    8265:	01 c2                	add    %eax,%edx
    8267:	8b 45 08             	mov    0x8(%ebp),%eax
    826a:	8b 00                	mov    (%eax),%eax
    826c:	c1 f8 03             	sar    $0x3,%eax
    826f:	89 c1                	mov    %eax,%ecx
    8271:	8b 45 0c             	mov    0xc(%ebp),%eax
    8274:	01 c8                	add    %ecx,%eax
    8276:	0f b6 18             	movzbl (%eax),%ebx
    8279:	8b 45 08             	mov    0x8(%ebp),%eax
    827c:	8b 00                	mov    (%eax),%eax
    827e:	f7 d0                	not    %eax
    8280:	83 e0 07             	and    $0x7,%eax
    8283:	be 01 00 00 00       	mov    $0x1,%esi
    8288:	89 c1                	mov    %eax,%ecx
    828a:	d3 e6                	shl    %cl,%esi
    828c:	89 f0                	mov    %esi,%eax
    828e:	09 d8                	or     %ebx,%eax
    8290:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    8292:	8b 45 08             	mov    0x8(%ebp),%eax
    8295:	8b 00                	mov    (%eax),%eax
    8297:	8d 50 01             	lea    0x1(%eax),%edx
    829a:	8b 45 08             	mov    0x8(%ebp),%eax
    829d:	89 10                	mov    %edx,(%eax)
}
    829f:	90                   	nop
    82a0:	83 c4 04             	add    $0x4,%esp
    82a3:	5b                   	pop    %ebx
    82a4:	5e                   	pop    %esi
    82a5:	5d                   	pop    %ebp
    82a6:	c3                   	ret    

000082a7 <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    82a7:	55                   	push   %ebp
    82a8:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    82aa:	ff 75 08             	pushl  0x8(%ebp)
    82ad:	e8 f1 b3 ff ff       	call   36a3 <lodepng_read32bitInt>
    82b2:	83 c4 04             	add    $0x4,%esp
}
    82b5:	c9                   	leave  
    82b6:	c3                   	ret    

000082b7 <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    82b7:	55                   	push   %ebp
    82b8:	89 e5                	mov    %esp,%ebp
    82ba:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    82bd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    82c4:	eb 1c                	jmp    82e2 <lodepng_chunk_type+0x2b>
    82c6:	8b 55 08             	mov    0x8(%ebp),%edx
    82c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    82cc:	01 d0                	add    %edx,%eax
    82ce:	8b 55 fc             	mov    -0x4(%ebp),%edx
    82d1:	8d 4a 04             	lea    0x4(%edx),%ecx
    82d4:	8b 55 0c             	mov    0xc(%ebp),%edx
    82d7:	01 ca                	add    %ecx,%edx
    82d9:	0f b6 12             	movzbl (%edx),%edx
    82dc:	88 10                	mov    %dl,(%eax)
    82de:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    82e2:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    82e6:	75 de                	jne    82c6 <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    82e8:	8b 45 08             	mov    0x8(%ebp),%eax
    82eb:	83 c0 04             	add    $0x4,%eax
    82ee:	c6 00 00             	movb   $0x0,(%eax)
}
    82f1:	90                   	nop
    82f2:	c9                   	leave  
    82f3:	c3                   	ret    

000082f4 <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    82f4:	55                   	push   %ebp
    82f5:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    82f7:	ff 75 0c             	pushl  0xc(%ebp)
    82fa:	e8 c2 b0 ff ff       	call   33c1 <lodepng_strlen>
    82ff:	83 c4 04             	add    $0x4,%esp
    8302:	83 f8 04             	cmp    $0x4,%eax
    8305:	74 07                	je     830e <lodepng_chunk_type_equals+0x1a>
    8307:	b8 00 00 00 00       	mov    $0x0,%eax
    830c:	eb 79                	jmp    8387 <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    830e:	8b 45 08             	mov    0x8(%ebp),%eax
    8311:	83 c0 04             	add    $0x4,%eax
    8314:	0f b6 00             	movzbl (%eax),%eax
    8317:	0f b6 d0             	movzbl %al,%edx
    831a:	8b 45 0c             	mov    0xc(%ebp),%eax
    831d:	0f b6 00             	movzbl (%eax),%eax
    8320:	0f be c0             	movsbl %al,%eax
    8323:	39 c2                	cmp    %eax,%edx
    8325:	75 5b                	jne    8382 <lodepng_chunk_type_equals+0x8e>
    8327:	8b 45 08             	mov    0x8(%ebp),%eax
    832a:	83 c0 05             	add    $0x5,%eax
    832d:	0f b6 00             	movzbl (%eax),%eax
    8330:	0f b6 d0             	movzbl %al,%edx
    8333:	8b 45 0c             	mov    0xc(%ebp),%eax
    8336:	83 c0 01             	add    $0x1,%eax
    8339:	0f b6 00             	movzbl (%eax),%eax
    833c:	0f be c0             	movsbl %al,%eax
    833f:	39 c2                	cmp    %eax,%edx
    8341:	75 3f                	jne    8382 <lodepng_chunk_type_equals+0x8e>
    8343:	8b 45 08             	mov    0x8(%ebp),%eax
    8346:	83 c0 06             	add    $0x6,%eax
    8349:	0f b6 00             	movzbl (%eax),%eax
    834c:	0f b6 d0             	movzbl %al,%edx
    834f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8352:	83 c0 02             	add    $0x2,%eax
    8355:	0f b6 00             	movzbl (%eax),%eax
    8358:	0f be c0             	movsbl %al,%eax
    835b:	39 c2                	cmp    %eax,%edx
    835d:	75 23                	jne    8382 <lodepng_chunk_type_equals+0x8e>
    835f:	8b 45 08             	mov    0x8(%ebp),%eax
    8362:	83 c0 07             	add    $0x7,%eax
    8365:	0f b6 00             	movzbl (%eax),%eax
    8368:	0f b6 d0             	movzbl %al,%edx
    836b:	8b 45 0c             	mov    0xc(%ebp),%eax
    836e:	83 c0 03             	add    $0x3,%eax
    8371:	0f b6 00             	movzbl (%eax),%eax
    8374:	0f be c0             	movsbl %al,%eax
    8377:	39 c2                	cmp    %eax,%edx
    8379:	75 07                	jne    8382 <lodepng_chunk_type_equals+0x8e>
    837b:	b8 01 00 00 00       	mov    $0x1,%eax
    8380:	eb 05                	jmp    8387 <lodepng_chunk_type_equals+0x93>
    8382:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8387:	c9                   	leave  
    8388:	c3                   	ret    

00008389 <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    8389:	55                   	push   %ebp
    838a:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    838c:	8b 45 08             	mov    0x8(%ebp),%eax
    838f:	83 c0 04             	add    $0x4,%eax
    8392:	0f b6 00             	movzbl (%eax),%eax
    8395:	0f b6 c0             	movzbl %al,%eax
    8398:	83 e0 20             	and    $0x20,%eax
    839b:	85 c0                	test   %eax,%eax
    839d:	0f 95 c0             	setne  %al
}
    83a0:	5d                   	pop    %ebp
    83a1:	c3                   	ret    

000083a2 <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    83a2:	55                   	push   %ebp
    83a3:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    83a5:	8b 45 08             	mov    0x8(%ebp),%eax
    83a8:	83 c0 06             	add    $0x6,%eax
    83ab:	0f b6 00             	movzbl (%eax),%eax
    83ae:	0f b6 c0             	movzbl %al,%eax
    83b1:	83 e0 20             	and    $0x20,%eax
    83b4:	85 c0                	test   %eax,%eax
    83b6:	0f 95 c0             	setne  %al
}
    83b9:	5d                   	pop    %ebp
    83ba:	c3                   	ret    

000083bb <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    83bb:	55                   	push   %ebp
    83bc:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    83be:	8b 45 08             	mov    0x8(%ebp),%eax
    83c1:	83 c0 07             	add    $0x7,%eax
    83c4:	0f b6 00             	movzbl (%eax),%eax
    83c7:	0f b6 c0             	movzbl %al,%eax
    83ca:	83 e0 20             	and    $0x20,%eax
    83cd:	85 c0                	test   %eax,%eax
    83cf:	0f 95 c0             	setne  %al
}
    83d2:	5d                   	pop    %ebp
    83d3:	c3                   	ret    

000083d4 <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    83d4:	55                   	push   %ebp
    83d5:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    83d7:	8b 45 08             	mov    0x8(%ebp),%eax
    83da:	83 c0 08             	add    $0x8,%eax
}
    83dd:	5d                   	pop    %ebp
    83de:	c3                   	ret    

000083df <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    83df:	55                   	push   %ebp
    83e0:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    83e2:	8b 45 08             	mov    0x8(%ebp),%eax
    83e5:	83 c0 08             	add    $0x8,%eax
}
    83e8:	5d                   	pop    %ebp
    83e9:	c3                   	ret    

000083ea <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    83ea:	55                   	push   %ebp
    83eb:	89 e5                	mov    %esp,%ebp
    83ed:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    83f0:	ff 75 08             	pushl  0x8(%ebp)
    83f3:	e8 af fe ff ff       	call   82a7 <lodepng_chunk_length>
    83f8:	83 c4 04             	add    $0x4,%esp
    83fb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    83fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8401:	8d 50 08             	lea    0x8(%eax),%edx
    8404:	8b 45 08             	mov    0x8(%ebp),%eax
    8407:	01 d0                	add    %edx,%eax
    8409:	50                   	push   %eax
    840a:	e8 94 b2 ff ff       	call   36a3 <lodepng_read32bitInt>
    840f:	83 c4 04             	add    $0x4,%esp
    8412:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    8415:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8418:	83 c0 04             	add    $0x4,%eax
    841b:	89 c2                	mov    %eax,%edx
    841d:	8b 45 08             	mov    0x8(%ebp),%eax
    8420:	83 c0 04             	add    $0x4,%eax
    8423:	52                   	push   %edx
    8424:	50                   	push   %eax
    8425:	e8 0b fd ff ff       	call   8135 <lodepng_crc32>
    842a:	83 c4 08             	add    $0x8,%esp
    842d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    8430:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8433:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    8436:	74 07                	je     843f <lodepng_chunk_check_crc+0x55>
    8438:	b8 01 00 00 00       	mov    $0x1,%eax
    843d:	eb 05                	jmp    8444 <lodepng_chunk_check_crc+0x5a>
  else return 0;
    843f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8444:	c9                   	leave  
    8445:	c3                   	ret    

00008446 <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    8446:	55                   	push   %ebp
    8447:	89 e5                	mov    %esp,%ebp
    8449:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    844c:	ff 75 08             	pushl  0x8(%ebp)
    844f:	e8 53 fe ff ff       	call   82a7 <lodepng_chunk_length>
    8454:	83 c4 04             	add    $0x4,%esp
    8457:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    845a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    845d:	83 c0 04             	add    $0x4,%eax
    8460:	89 c2                	mov    %eax,%edx
    8462:	8b 45 08             	mov    0x8(%ebp),%eax
    8465:	83 c0 04             	add    $0x4,%eax
    8468:	52                   	push   %edx
    8469:	50                   	push   %eax
    846a:	e8 c6 fc ff ff       	call   8135 <lodepng_crc32>
    846f:	83 c4 08             	add    $0x8,%esp
    8472:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    8475:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8478:	8d 50 08             	lea    0x8(%eax),%edx
    847b:	8b 45 08             	mov    0x8(%ebp),%eax
    847e:	01 d0                	add    %edx,%eax
    8480:	ff 75 f8             	pushl  -0x8(%ebp)
    8483:	50                   	push   %eax
    8484:	e8 5d b2 ff ff       	call   36e6 <lodepng_set32bitInt>
    8489:	83 c4 08             	add    $0x8,%esp
}
    848c:	90                   	nop
    848d:	c9                   	leave  
    848e:	c3                   	ret    

0000848f <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    848f:	55                   	push   %ebp
    8490:	89 e5                	mov    %esp,%ebp
    8492:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8495:	8b 45 08             	mov    0x8(%ebp),%eax
    8498:	3b 45 0c             	cmp    0xc(%ebp),%eax
    849b:	73 0f                	jae    84ac <lodepng_chunk_next+0x1d>
    849d:	8b 55 0c             	mov    0xc(%ebp),%edx
    84a0:	8b 45 08             	mov    0x8(%ebp),%eax
    84a3:	29 c2                	sub    %eax,%edx
    84a5:	89 d0                	mov    %edx,%eax
    84a7:	83 f8 0b             	cmp    $0xb,%eax
    84aa:	7f 08                	jg     84b4 <lodepng_chunk_next+0x25>
    84ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    84af:	e9 af 00 00 00       	jmp    8563 <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    84b4:	8b 45 08             	mov    0x8(%ebp),%eax
    84b7:	0f b6 00             	movzbl (%eax),%eax
    84ba:	3c 89                	cmp    $0x89,%al
    84bc:	75 63                	jne    8521 <lodepng_chunk_next+0x92>
    84be:	8b 45 08             	mov    0x8(%ebp),%eax
    84c1:	83 c0 01             	add    $0x1,%eax
    84c4:	0f b6 00             	movzbl (%eax),%eax
    84c7:	3c 50                	cmp    $0x50,%al
    84c9:	75 56                	jne    8521 <lodepng_chunk_next+0x92>
    84cb:	8b 45 08             	mov    0x8(%ebp),%eax
    84ce:	83 c0 02             	add    $0x2,%eax
    84d1:	0f b6 00             	movzbl (%eax),%eax
    84d4:	3c 4e                	cmp    $0x4e,%al
    84d6:	75 49                	jne    8521 <lodepng_chunk_next+0x92>
    84d8:	8b 45 08             	mov    0x8(%ebp),%eax
    84db:	83 c0 03             	add    $0x3,%eax
    84de:	0f b6 00             	movzbl (%eax),%eax
    84e1:	3c 47                	cmp    $0x47,%al
    84e3:	75 3c                	jne    8521 <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    84e5:	8b 45 08             	mov    0x8(%ebp),%eax
    84e8:	83 c0 04             	add    $0x4,%eax
    84eb:	0f b6 00             	movzbl (%eax),%eax
    84ee:	3c 0d                	cmp    $0xd,%al
    84f0:	75 2f                	jne    8521 <lodepng_chunk_next+0x92>
    84f2:	8b 45 08             	mov    0x8(%ebp),%eax
    84f5:	83 c0 05             	add    $0x5,%eax
    84f8:	0f b6 00             	movzbl (%eax),%eax
    84fb:	3c 0a                	cmp    $0xa,%al
    84fd:	75 22                	jne    8521 <lodepng_chunk_next+0x92>
    84ff:	8b 45 08             	mov    0x8(%ebp),%eax
    8502:	83 c0 06             	add    $0x6,%eax
    8505:	0f b6 00             	movzbl (%eax),%eax
    8508:	3c 1a                	cmp    $0x1a,%al
    850a:	75 15                	jne    8521 <lodepng_chunk_next+0x92>
    850c:	8b 45 08             	mov    0x8(%ebp),%eax
    850f:	83 c0 07             	add    $0x7,%eax
    8512:	0f b6 00             	movzbl (%eax),%eax
    8515:	3c 0a                	cmp    $0xa,%al
    8517:	75 08                	jne    8521 <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    8519:	8b 45 08             	mov    0x8(%ebp),%eax
    851c:	83 c0 08             	add    $0x8,%eax
    851f:	eb 42                	jmp    8563 <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    8521:	ff 75 08             	pushl  0x8(%ebp)
    8524:	e8 7e fd ff ff       	call   82a7 <lodepng_chunk_length>
    8529:	83 c4 04             	add    $0x4,%esp
    852c:	89 c2                	mov    %eax,%edx
    852e:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8531:	50                   	push   %eax
    8532:	6a 0c                	push   $0xc
    8534:	52                   	push   %edx
    8535:	e8 af ae ff ff       	call   33e9 <lodepng_addofl>
    853a:	83 c4 0c             	add    $0xc,%esp
    853d:	85 c0                	test   %eax,%eax
    853f:	74 05                	je     8546 <lodepng_chunk_next+0xb7>
    8541:	8b 45 0c             	mov    0xc(%ebp),%eax
    8544:	eb 1d                	jmp    8563 <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    8546:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8549:	89 c2                	mov    %eax,%edx
    854b:	8b 45 08             	mov    0x8(%ebp),%eax
    854e:	01 d0                	add    %edx,%eax
    8550:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8553:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8556:	3b 45 08             	cmp    0x8(%ebp),%eax
    8559:	73 05                	jae    8560 <lodepng_chunk_next+0xd1>
    855b:	8b 45 0c             	mov    0xc(%ebp),%eax
    855e:	eb 03                	jmp    8563 <lodepng_chunk_next+0xd4>
    return result;
    8560:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8563:	c9                   	leave  
    8564:	c3                   	ret    

00008565 <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    8565:	55                   	push   %ebp
    8566:	89 e5                	mov    %esp,%ebp
    8568:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    856b:	8b 45 08             	mov    0x8(%ebp),%eax
    856e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8571:	73 0f                	jae    8582 <lodepng_chunk_next_const+0x1d>
    8573:	8b 55 0c             	mov    0xc(%ebp),%edx
    8576:	8b 45 08             	mov    0x8(%ebp),%eax
    8579:	29 c2                	sub    %eax,%edx
    857b:	89 d0                	mov    %edx,%eax
    857d:	83 f8 0b             	cmp    $0xb,%eax
    8580:	7f 08                	jg     858a <lodepng_chunk_next_const+0x25>
    8582:	8b 45 0c             	mov    0xc(%ebp),%eax
    8585:	e9 af 00 00 00       	jmp    8639 <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    858a:	8b 45 08             	mov    0x8(%ebp),%eax
    858d:	0f b6 00             	movzbl (%eax),%eax
    8590:	3c 89                	cmp    $0x89,%al
    8592:	75 63                	jne    85f7 <lodepng_chunk_next_const+0x92>
    8594:	8b 45 08             	mov    0x8(%ebp),%eax
    8597:	83 c0 01             	add    $0x1,%eax
    859a:	0f b6 00             	movzbl (%eax),%eax
    859d:	3c 50                	cmp    $0x50,%al
    859f:	75 56                	jne    85f7 <lodepng_chunk_next_const+0x92>
    85a1:	8b 45 08             	mov    0x8(%ebp),%eax
    85a4:	83 c0 02             	add    $0x2,%eax
    85a7:	0f b6 00             	movzbl (%eax),%eax
    85aa:	3c 4e                	cmp    $0x4e,%al
    85ac:	75 49                	jne    85f7 <lodepng_chunk_next_const+0x92>
    85ae:	8b 45 08             	mov    0x8(%ebp),%eax
    85b1:	83 c0 03             	add    $0x3,%eax
    85b4:	0f b6 00             	movzbl (%eax),%eax
    85b7:	3c 47                	cmp    $0x47,%al
    85b9:	75 3c                	jne    85f7 <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    85bb:	8b 45 08             	mov    0x8(%ebp),%eax
    85be:	83 c0 04             	add    $0x4,%eax
    85c1:	0f b6 00             	movzbl (%eax),%eax
    85c4:	3c 0d                	cmp    $0xd,%al
    85c6:	75 2f                	jne    85f7 <lodepng_chunk_next_const+0x92>
    85c8:	8b 45 08             	mov    0x8(%ebp),%eax
    85cb:	83 c0 05             	add    $0x5,%eax
    85ce:	0f b6 00             	movzbl (%eax),%eax
    85d1:	3c 0a                	cmp    $0xa,%al
    85d3:	75 22                	jne    85f7 <lodepng_chunk_next_const+0x92>
    85d5:	8b 45 08             	mov    0x8(%ebp),%eax
    85d8:	83 c0 06             	add    $0x6,%eax
    85db:	0f b6 00             	movzbl (%eax),%eax
    85de:	3c 1a                	cmp    $0x1a,%al
    85e0:	75 15                	jne    85f7 <lodepng_chunk_next_const+0x92>
    85e2:	8b 45 08             	mov    0x8(%ebp),%eax
    85e5:	83 c0 07             	add    $0x7,%eax
    85e8:	0f b6 00             	movzbl (%eax),%eax
    85eb:	3c 0a                	cmp    $0xa,%al
    85ed:	75 08                	jne    85f7 <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    85ef:	8b 45 08             	mov    0x8(%ebp),%eax
    85f2:	83 c0 08             	add    $0x8,%eax
    85f5:	eb 42                	jmp    8639 <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    85f7:	ff 75 08             	pushl  0x8(%ebp)
    85fa:	e8 a8 fc ff ff       	call   82a7 <lodepng_chunk_length>
    85ff:	83 c4 04             	add    $0x4,%esp
    8602:	89 c2                	mov    %eax,%edx
    8604:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8607:	50                   	push   %eax
    8608:	6a 0c                	push   $0xc
    860a:	52                   	push   %edx
    860b:	e8 d9 ad ff ff       	call   33e9 <lodepng_addofl>
    8610:	83 c4 0c             	add    $0xc,%esp
    8613:	85 c0                	test   %eax,%eax
    8615:	74 05                	je     861c <lodepng_chunk_next_const+0xb7>
    8617:	8b 45 0c             	mov    0xc(%ebp),%eax
    861a:	eb 1d                	jmp    8639 <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    861c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    861f:	89 c2                	mov    %eax,%edx
    8621:	8b 45 08             	mov    0x8(%ebp),%eax
    8624:	01 d0                	add    %edx,%eax
    8626:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8629:	8b 45 fc             	mov    -0x4(%ebp),%eax
    862c:	3b 45 08             	cmp    0x8(%ebp),%eax
    862f:	73 05                	jae    8636 <lodepng_chunk_next_const+0xd1>
    8631:	8b 45 0c             	mov    0xc(%ebp),%eax
    8634:	eb 03                	jmp    8639 <lodepng_chunk_next_const+0xd4>
    return result;
    8636:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8639:	c9                   	leave  
    863a:	c3                   	ret    

0000863b <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    863b:	55                   	push   %ebp
    863c:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    863e:	8b 45 08             	mov    0x8(%ebp),%eax
    8641:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8644:	73 0f                	jae    8655 <lodepng_chunk_find+0x1a>
    8646:	8b 55 0c             	mov    0xc(%ebp),%edx
    8649:	8b 45 08             	mov    0x8(%ebp),%eax
    864c:	29 c2                	sub    %eax,%edx
    864e:	89 d0                	mov    %edx,%eax
    8650:	83 f8 0b             	cmp    $0xb,%eax
    8653:	7f 07                	jg     865c <lodepng_chunk_find+0x21>
    8655:	b8 00 00 00 00       	mov    $0x0,%eax
    865a:	eb 2a                	jmp    8686 <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    865c:	ff 75 10             	pushl  0x10(%ebp)
    865f:	ff 75 08             	pushl  0x8(%ebp)
    8662:	e8 8d fc ff ff       	call   82f4 <lodepng_chunk_type_equals>
    8667:	83 c4 08             	add    $0x8,%esp
    866a:	84 c0                	test   %al,%al
    866c:	74 05                	je     8673 <lodepng_chunk_find+0x38>
    866e:	8b 45 08             	mov    0x8(%ebp),%eax
    8671:	eb 13                	jmp    8686 <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    8673:	ff 75 0c             	pushl  0xc(%ebp)
    8676:	ff 75 08             	pushl  0x8(%ebp)
    8679:	e8 11 fe ff ff       	call   848f <lodepng_chunk_next>
    867e:	83 c4 08             	add    $0x8,%esp
    8681:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8684:	eb b8                	jmp    863e <lodepng_chunk_find+0x3>
}
    8686:	c9                   	leave  
    8687:	c3                   	ret    

00008688 <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    8688:	55                   	push   %ebp
    8689:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    868b:	8b 45 08             	mov    0x8(%ebp),%eax
    868e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8691:	73 0f                	jae    86a2 <lodepng_chunk_find_const+0x1a>
    8693:	8b 55 0c             	mov    0xc(%ebp),%edx
    8696:	8b 45 08             	mov    0x8(%ebp),%eax
    8699:	29 c2                	sub    %eax,%edx
    869b:	89 d0                	mov    %edx,%eax
    869d:	83 f8 0b             	cmp    $0xb,%eax
    86a0:	7f 07                	jg     86a9 <lodepng_chunk_find_const+0x21>
    86a2:	b8 00 00 00 00       	mov    $0x0,%eax
    86a7:	eb 2a                	jmp    86d3 <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    86a9:	ff 75 10             	pushl  0x10(%ebp)
    86ac:	ff 75 08             	pushl  0x8(%ebp)
    86af:	e8 40 fc ff ff       	call   82f4 <lodepng_chunk_type_equals>
    86b4:	83 c4 08             	add    $0x8,%esp
    86b7:	84 c0                	test   %al,%al
    86b9:	74 05                	je     86c0 <lodepng_chunk_find_const+0x38>
    86bb:	8b 45 08             	mov    0x8(%ebp),%eax
    86be:	eb 13                	jmp    86d3 <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    86c0:	ff 75 0c             	pushl  0xc(%ebp)
    86c3:	ff 75 08             	pushl  0x8(%ebp)
    86c6:	e8 9a fe ff ff       	call   8565 <lodepng_chunk_next_const>
    86cb:	83 c4 08             	add    $0x8,%esp
    86ce:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    86d1:	eb b8                	jmp    868b <lodepng_chunk_find_const+0x3>
}
    86d3:	c9                   	leave  
    86d4:	c3                   	ret    

000086d5 <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    86d5:	55                   	push   %ebp
    86d6:	89 e5                	mov    %esp,%ebp
    86d8:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    86db:	ff 75 10             	pushl  0x10(%ebp)
    86de:	e8 c4 fb ff ff       	call   82a7 <lodepng_chunk_length>
    86e3:	83 c4 04             	add    $0x4,%esp
    86e6:	89 c2                	mov    %eax,%edx
    86e8:	8d 45 f0             	lea    -0x10(%ebp),%eax
    86eb:	50                   	push   %eax
    86ec:	6a 0c                	push   $0xc
    86ee:	52                   	push   %edx
    86ef:	e8 f5 ac ff ff       	call   33e9 <lodepng_addofl>
    86f4:	83 c4 0c             	add    $0xc,%esp
    86f7:	85 c0                	test   %eax,%eax
    86f9:	74 0a                	je     8705 <lodepng_chunk_append+0x30>
    86fb:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8700:	e9 96 00 00 00       	jmp    879b <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    8705:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8708:	8b 45 0c             	mov    0xc(%ebp),%eax
    870b:	8b 00                	mov    (%eax),%eax
    870d:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    8710:	51                   	push   %ecx
    8711:	52                   	push   %edx
    8712:	50                   	push   %eax
    8713:	e8 d1 ac ff ff       	call   33e9 <lodepng_addofl>
    8718:	83 c4 0c             	add    $0xc,%esp
    871b:	85 c0                	test   %eax,%eax
    871d:	74 07                	je     8726 <lodepng_chunk_append+0x51>
    871f:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8724:	eb 75                	jmp    879b <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    8726:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8729:	8b 45 08             	mov    0x8(%ebp),%eax
    872c:	8b 00                	mov    (%eax),%eax
    872e:	52                   	push   %edx
    872f:	50                   	push   %eax
    8730:	e8 07 ac ff ff       	call   333c <lodepng_realloc>
    8735:	83 c4 08             	add    $0x8,%esp
    8738:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    873b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    873f:	75 07                	jne    8748 <lodepng_chunk_append+0x73>
    8741:	b8 53 00 00 00       	mov    $0x53,%eax
    8746:	eb 53                	jmp    879b <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    8748:	8b 45 08             	mov    0x8(%ebp),%eax
    874b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    874e:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    8750:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8753:	8b 45 0c             	mov    0xc(%ebp),%eax
    8756:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    8758:	8b 45 08             	mov    0x8(%ebp),%eax
    875b:	8b 00                	mov    (%eax),%eax
    875d:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    8760:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8763:	29 d1                	sub    %edx,%ecx
    8765:	89 ca                	mov    %ecx,%edx
    8767:	01 d0                	add    %edx,%eax
    8769:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    876c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8773:	eb 19                	jmp    878e <lodepng_chunk_append+0xb9>
    8775:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8778:	8b 45 fc             	mov    -0x4(%ebp),%eax
    877b:	01 c2                	add    %eax,%edx
    877d:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8780:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8783:	01 c8                	add    %ecx,%eax
    8785:	0f b6 00             	movzbl (%eax),%eax
    8788:	88 02                	mov    %al,(%edx)
    878a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    878e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8791:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    8794:	75 df                	jne    8775 <lodepng_chunk_append+0xa0>

  return 0;
    8796:	b8 00 00 00 00       	mov    $0x0,%eax
}
    879b:	c9                   	leave  
    879c:	c3                   	ret    

0000879d <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    879d:	55                   	push   %ebp
    879e:	89 e5                	mov    %esp,%ebp
    87a0:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    87a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    87a6:	8b 40 04             	mov    0x4(%eax),%eax
    87a9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    87ac:	8b 55 10             	mov    0x10(%ebp),%edx
    87af:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87b2:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    87b5:	51                   	push   %ecx
    87b6:	52                   	push   %edx
    87b7:	50                   	push   %eax
    87b8:	e8 2c ac ff ff       	call   33e9 <lodepng_addofl>
    87bd:	83 c4 0c             	add    $0xc,%esp
    87c0:	85 c0                	test   %eax,%eax
    87c2:	74 07                	je     87cb <lodepng_chunk_init+0x2e>
    87c4:	b8 4d 00 00 00       	mov    $0x4d,%eax
    87c9:	eb 78                	jmp    8843 <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    87cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87ce:	8d 55 fc             	lea    -0x4(%ebp),%edx
    87d1:	52                   	push   %edx
    87d2:	6a 0c                	push   $0xc
    87d4:	50                   	push   %eax
    87d5:	e8 0f ac ff ff       	call   33e9 <lodepng_addofl>
    87da:	83 c4 0c             	add    $0xc,%esp
    87dd:	85 c0                	test   %eax,%eax
    87df:	74 07                	je     87e8 <lodepng_chunk_init+0x4b>
    87e1:	b8 4d 00 00 00       	mov    $0x4d,%eax
    87e6:	eb 5b                	jmp    8843 <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    87e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    87eb:	50                   	push   %eax
    87ec:	ff 75 0c             	pushl  0xc(%ebp)
    87ef:	e8 8b ad ff ff       	call   357f <ucvector_resize>
    87f4:	83 c4 08             	add    $0x8,%esp
    87f7:	85 c0                	test   %eax,%eax
    87f9:	75 07                	jne    8802 <lodepng_chunk_init+0x65>
    87fb:	b8 53 00 00 00       	mov    $0x53,%eax
    8800:	eb 41                	jmp    8843 <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    8802:	8b 45 0c             	mov    0xc(%ebp),%eax
    8805:	8b 00                	mov    (%eax),%eax
    8807:	8b 55 fc             	mov    -0x4(%ebp),%edx
    880a:	2b 55 10             	sub    0x10(%ebp),%edx
    880d:	83 ea 0c             	sub    $0xc,%edx
    8810:	01 c2                	add    %eax,%edx
    8812:	8b 45 08             	mov    0x8(%ebp),%eax
    8815:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    8817:	8b 45 08             	mov    0x8(%ebp),%eax
    881a:	8b 00                	mov    (%eax),%eax
    881c:	ff 75 10             	pushl  0x10(%ebp)
    881f:	50                   	push   %eax
    8820:	e8 c1 ae ff ff       	call   36e6 <lodepng_set32bitInt>
    8825:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    8828:	8b 45 08             	mov    0x8(%ebp),%eax
    882b:	8b 00                	mov    (%eax),%eax
    882d:	83 c0 04             	add    $0x4,%eax
    8830:	6a 04                	push   $0x4
    8832:	ff 75 14             	pushl  0x14(%ebp)
    8835:	50                   	push   %eax
    8836:	e8 28 ab ff ff       	call   3363 <lodepng_memcpy>
    883b:	83 c4 0c             	add    $0xc,%esp

  return 0;
    883e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8843:	c9                   	leave  
    8844:	c3                   	ret    

00008845 <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    8845:	55                   	push   %ebp
    8846:	89 e5                	mov    %esp,%ebp
    8848:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    884b:	ff 75 10             	pushl  0x10(%ebp)
    884e:	ff 75 0c             	pushl  0xc(%ebp)
    8851:	ff 75 08             	pushl  0x8(%ebp)
    8854:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8857:	50                   	push   %eax
    8858:	e8 40 ff ff ff       	call   879d <lodepng_chunk_init>
    885d:	83 c4 10             	add    $0x10,%esp
    8860:	89 45 fc             	mov    %eax,-0x4(%ebp)
    8863:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    8867:	74 05                	je     886e <lodepng_chunk_createv+0x29>
    8869:	8b 45 fc             	mov    -0x4(%ebp),%eax
    886c:	eb 27                	jmp    8895 <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    886e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8871:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8874:	83 c2 08             	add    $0x8,%edx
    8877:	50                   	push   %eax
    8878:	ff 75 14             	pushl  0x14(%ebp)
    887b:	52                   	push   %edx
    887c:	e8 e2 aa ff ff       	call   3363 <lodepng_memcpy>
    8881:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    8884:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8887:	50                   	push   %eax
    8888:	e8 b9 fb ff ff       	call   8446 <lodepng_chunk_generate_crc>
    888d:	83 c4 04             	add    $0x4,%esp

  return 0;
    8890:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8895:	c9                   	leave  
    8896:	c3                   	ret    

00008897 <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    8897:	55                   	push   %ebp
    8898:	89 e5                	mov    %esp,%ebp
    889a:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    889d:	8b 45 0c             	mov    0xc(%ebp),%eax
    88a0:	8b 08                	mov    (%eax),%ecx
    88a2:	8b 45 08             	mov    0x8(%ebp),%eax
    88a5:	8b 10                	mov    (%eax),%edx
    88a7:	8d 45 f0             	lea    -0x10(%ebp),%eax
    88aa:	51                   	push   %ecx
    88ab:	52                   	push   %edx
    88ac:	50                   	push   %eax
    88ad:	e8 34 ad ff ff       	call   35e6 <ucvector_init>
    88b2:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    88b5:	ff 75 18             	pushl  0x18(%ebp)
    88b8:	ff 75 14             	pushl  0x14(%ebp)
    88bb:	ff 75 10             	pushl  0x10(%ebp)
    88be:	8d 45 f0             	lea    -0x10(%ebp),%eax
    88c1:	50                   	push   %eax
    88c2:	e8 7e ff ff ff       	call   8845 <lodepng_chunk_createv>
    88c7:	83 c4 10             	add    $0x10,%esp
    88ca:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    88cd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    88d0:	8b 45 08             	mov    0x8(%ebp),%eax
    88d3:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    88d5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    88d8:	8b 45 0c             	mov    0xc(%ebp),%eax
    88db:	89 10                	mov    %edx,(%eax)
  return error;
    88dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    88e0:	c9                   	leave  
    88e1:	c3                   	ret    

000088e2 <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    88e2:	55                   	push   %ebp
    88e3:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    88e5:	8b 45 08             	mov    0x8(%ebp),%eax
    88e8:	83 f8 03             	cmp    $0x3,%eax
    88eb:	74 6d                	je     895a <checkColorValidity+0x78>
    88ed:	83 f8 03             	cmp    $0x3,%eax
    88f0:	77 0e                	ja     8900 <checkColorValidity+0x1e>
    88f2:	85 c0                	test   %eax,%eax
    88f4:	74 28                	je     891e <checkColorValidity+0x3c>
    88f6:	83 f8 02             	cmp    $0x2,%eax
    88f9:	74 4c                	je     8947 <checkColorValidity+0x65>
    88fb:	e9 a6 00 00 00       	jmp    89a6 <checkColorValidity+0xc4>
    8900:	83 f8 06             	cmp    $0x6,%eax
    8903:	0f 84 83 00 00 00    	je     898c <checkColorValidity+0xaa>
    8909:	3d ff 00 00 00       	cmp    $0xff,%eax
    890e:	0f 84 8b 00 00 00    	je     899f <checkColorValidity+0xbd>
    8914:	83 f8 04             	cmp    $0x4,%eax
    8917:	74 60                	je     8979 <checkColorValidity+0x97>
    8919:	e9 88 00 00 00       	jmp    89a6 <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    891e:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8922:	0f 84 85 00 00 00    	je     89ad <checkColorValidity+0xcb>
    8928:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    892c:	74 7f                	je     89ad <checkColorValidity+0xcb>
    892e:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8932:	74 79                	je     89ad <checkColorValidity+0xcb>
    8934:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8938:	74 73                	je     89ad <checkColorValidity+0xcb>
    893a:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    893e:	74 6d                	je     89ad <checkColorValidity+0xcb>
    8940:	b8 25 00 00 00       	mov    $0x25,%eax
    8945:	eb 78                	jmp    89bf <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8947:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    894b:	74 63                	je     89b0 <checkColorValidity+0xce>
    894d:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8951:	74 5d                	je     89b0 <checkColorValidity+0xce>
    8953:	b8 25 00 00 00       	mov    $0x25,%eax
    8958:	eb 65                	jmp    89bf <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    895a:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    895e:	74 53                	je     89b3 <checkColorValidity+0xd1>
    8960:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8964:	74 4d                	je     89b3 <checkColorValidity+0xd1>
    8966:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    896a:	74 47                	je     89b3 <checkColorValidity+0xd1>
    896c:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8970:	74 41                	je     89b3 <checkColorValidity+0xd1>
    8972:	b8 25 00 00 00       	mov    $0x25,%eax
    8977:	eb 46                	jmp    89bf <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8979:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    897d:	74 37                	je     89b6 <checkColorValidity+0xd4>
    897f:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8983:	74 31                	je     89b6 <checkColorValidity+0xd4>
    8985:	b8 25 00 00 00       	mov    $0x25,%eax
    898a:	eb 33                	jmp    89bf <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    898c:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8990:	74 27                	je     89b9 <checkColorValidity+0xd7>
    8992:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8996:	74 21                	je     89b9 <checkColorValidity+0xd7>
    8998:	b8 25 00 00 00       	mov    $0x25,%eax
    899d:	eb 20                	jmp    89bf <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    899f:	b8 1f 00 00 00       	mov    $0x1f,%eax
    89a4:	eb 19                	jmp    89bf <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    89a6:	b8 1f 00 00 00       	mov    $0x1f,%eax
    89ab:	eb 12                	jmp    89bf <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    89ad:	90                   	nop
    89ae:	eb 0a                	jmp    89ba <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89b0:	90                   	nop
    89b1:	eb 07                	jmp    89ba <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    89b3:	90                   	nop
    89b4:	eb 04                	jmp    89ba <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89b6:	90                   	nop
    89b7:	eb 01                	jmp    89ba <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    89b9:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    89ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
    89bf:	5d                   	pop    %ebp
    89c0:	c3                   	ret    

000089c1 <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    89c1:	55                   	push   %ebp
    89c2:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    89c4:	8b 45 08             	mov    0x8(%ebp),%eax
    89c7:	83 f8 03             	cmp    $0x3,%eax
    89ca:	74 31                	je     89fd <getNumColorChannels+0x3c>
    89cc:	83 f8 03             	cmp    $0x3,%eax
    89cf:	77 0b                	ja     89dc <getNumColorChannels+0x1b>
    89d1:	85 c0                	test   %eax,%eax
    89d3:	74 1a                	je     89ef <getNumColorChannels+0x2e>
    89d5:	83 f8 02             	cmp    $0x2,%eax
    89d8:	74 1c                	je     89f6 <getNumColorChannels+0x35>
    89da:	eb 3d                	jmp    8a19 <getNumColorChannels+0x58>
    89dc:	83 f8 06             	cmp    $0x6,%eax
    89df:	74 2a                	je     8a0b <getNumColorChannels+0x4a>
    89e1:	3d ff 00 00 00       	cmp    $0xff,%eax
    89e6:	74 2a                	je     8a12 <getNumColorChannels+0x51>
    89e8:	83 f8 04             	cmp    $0x4,%eax
    89eb:	74 17                	je     8a04 <getNumColorChannels+0x43>
    89ed:	eb 2a                	jmp    8a19 <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    89ef:	b8 01 00 00 00       	mov    $0x1,%eax
    89f4:	eb 28                	jmp    8a1e <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    89f6:	b8 03 00 00 00       	mov    $0x3,%eax
    89fb:	eb 21                	jmp    8a1e <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    89fd:	b8 01 00 00 00       	mov    $0x1,%eax
    8a02:	eb 1a                	jmp    8a1e <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    8a04:	b8 02 00 00 00       	mov    $0x2,%eax
    8a09:	eb 13                	jmp    8a1e <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    8a0b:	b8 04 00 00 00       	mov    $0x4,%eax
    8a10:	eb 0c                	jmp    8a1e <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    8a12:	b8 00 00 00 00       	mov    $0x0,%eax
    8a17:	eb 05                	jmp    8a1e <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    8a19:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    8a1e:	5d                   	pop    %ebp
    8a1f:	c3                   	ret    

00008a20 <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    8a20:	55                   	push   %ebp
    8a21:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    8a23:	ff 75 08             	pushl  0x8(%ebp)
    8a26:	e8 96 ff ff ff       	call   89c1 <getNumColorChannels>
    8a2b:	83 c4 04             	add    $0x4,%esp
    8a2e:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    8a32:	c9                   	leave  
    8a33:	c3                   	ret    

00008a34 <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    8a34:	55                   	push   %ebp
    8a35:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    8a37:	8b 45 08             	mov    0x8(%ebp),%eax
    8a3a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    8a41:	8b 45 08             	mov    0x8(%ebp),%eax
    8a44:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    8a4b:	8b 45 08             	mov    0x8(%ebp),%eax
    8a4e:	8b 50 1c             	mov    0x1c(%eax),%edx
    8a51:	8b 45 08             	mov    0x8(%ebp),%eax
    8a54:	89 50 18             	mov    %edx,0x18(%eax)
    8a57:	8b 45 08             	mov    0x8(%ebp),%eax
    8a5a:	8b 50 18             	mov    0x18(%eax),%edx
    8a5d:	8b 45 08             	mov    0x8(%ebp),%eax
    8a60:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    8a63:	8b 45 08             	mov    0x8(%ebp),%eax
    8a66:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    8a6c:	8b 45 08             	mov    0x8(%ebp),%eax
    8a6f:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    8a76:	8b 45 08             	mov    0x8(%ebp),%eax
    8a79:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8a80:	8b 45 08             	mov    0x8(%ebp),%eax
    8a83:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8a8a:	90                   	nop
    8a8b:	5d                   	pop    %ebp
    8a8c:	c3                   	ret    

00008a8d <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    8a8d:	55                   	push   %ebp
    8a8e:	89 e5                	mov    %esp,%ebp
    8a90:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    8a93:	8b 45 08             	mov    0x8(%ebp),%eax
    8a96:	8b 40 08             	mov    0x8(%eax),%eax
    8a99:	85 c0                	test   %eax,%eax
    8a9b:	75 18                	jne    8ab5 <lodepng_color_mode_alloc_palette+0x28>
    8a9d:	83 ec 0c             	sub    $0xc,%esp
    8aa0:	68 00 04 00 00       	push   $0x400
    8aa5:	e8 7b a8 ff ff       	call   3325 <lodepng_malloc>
    8aaa:	83 c4 10             	add    $0x10,%esp
    8aad:	89 c2                	mov    %eax,%edx
    8aaf:	8b 45 08             	mov    0x8(%ebp),%eax
    8ab2:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    8ab5:	8b 45 08             	mov    0x8(%ebp),%eax
    8ab8:	8b 40 08             	mov    0x8(%eax),%eax
    8abb:	85 c0                	test   %eax,%eax
    8abd:	74 65                	je     8b24 <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    8abf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8ac6:	eb 51                	jmp    8b19 <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    8ac8:	8b 45 08             	mov    0x8(%ebp),%eax
    8acb:	8b 40 08             	mov    0x8(%eax),%eax
    8ace:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8ad1:	c1 e2 02             	shl    $0x2,%edx
    8ad4:	01 d0                	add    %edx,%eax
    8ad6:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    8ad9:	8b 45 08             	mov    0x8(%ebp),%eax
    8adc:	8b 40 08             	mov    0x8(%eax),%eax
    8adf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8ae2:	c1 e2 02             	shl    $0x2,%edx
    8ae5:	83 c2 01             	add    $0x1,%edx
    8ae8:	01 d0                	add    %edx,%eax
    8aea:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    8aed:	8b 45 08             	mov    0x8(%ebp),%eax
    8af0:	8b 40 08             	mov    0x8(%eax),%eax
    8af3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8af6:	c1 e2 02             	shl    $0x2,%edx
    8af9:	83 c2 02             	add    $0x2,%edx
    8afc:	01 d0                	add    %edx,%eax
    8afe:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    8b01:	8b 45 08             	mov    0x8(%ebp),%eax
    8b04:	8b 40 08             	mov    0x8(%eax),%eax
    8b07:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8b0a:	c1 e2 02             	shl    $0x2,%edx
    8b0d:	83 c2 03             	add    $0x3,%edx
    8b10:	01 d0                	add    %edx,%eax
    8b12:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    8b15:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8b19:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    8b20:	75 a6                	jne    8ac8 <lodepng_color_mode_alloc_palette+0x3b>
    8b22:	eb 01                	jmp    8b25 <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    8b24:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    8b25:	c9                   	leave  
    8b26:	c3                   	ret    

00008b27 <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    8b27:	55                   	push   %ebp
    8b28:	89 e5                	mov    %esp,%ebp
    8b2a:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    8b2d:	83 ec 0c             	sub    $0xc,%esp
    8b30:	ff 75 08             	pushl  0x8(%ebp)
    8b33:	e8 f3 01 00 00       	call   8d2b <lodepng_palette_clear>
    8b38:	83 c4 10             	add    $0x10,%esp
}
    8b3b:	90                   	nop
    8b3c:	c9                   	leave  
    8b3d:	c3                   	ret    

00008b3e <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    8b3e:	55                   	push   %ebp
    8b3f:	89 e5                	mov    %esp,%ebp
    8b41:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    8b44:	83 ec 0c             	sub    $0xc,%esp
    8b47:	ff 75 08             	pushl  0x8(%ebp)
    8b4a:	e8 d8 ff ff ff       	call   8b27 <lodepng_color_mode_cleanup>
    8b4f:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    8b52:	83 ec 04             	sub    $0x4,%esp
    8b55:	6a 20                	push   $0x20
    8b57:	ff 75 0c             	pushl  0xc(%ebp)
    8b5a:	ff 75 08             	pushl  0x8(%ebp)
    8b5d:	e8 01 a8 ff ff       	call   3363 <lodepng_memcpy>
    8b62:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    8b65:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b68:	8b 40 08             	mov    0x8(%eax),%eax
    8b6b:	85 c0                	test   %eax,%eax
    8b6d:	74 5a                	je     8bc9 <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    8b6f:	83 ec 0c             	sub    $0xc,%esp
    8b72:	68 00 04 00 00       	push   $0x400
    8b77:	e8 a9 a7 ff ff       	call   3325 <lodepng_malloc>
    8b7c:	83 c4 10             	add    $0x10,%esp
    8b7f:	89 c2                	mov    %eax,%edx
    8b81:	8b 45 08             	mov    0x8(%ebp),%eax
    8b84:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    8b87:	8b 45 08             	mov    0x8(%ebp),%eax
    8b8a:	8b 40 08             	mov    0x8(%eax),%eax
    8b8d:	85 c0                	test   %eax,%eax
    8b8f:	75 11                	jne    8ba2 <lodepng_color_mode_copy+0x64>
    8b91:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b94:	8b 40 0c             	mov    0xc(%eax),%eax
    8b97:	85 c0                	test   %eax,%eax
    8b99:	74 07                	je     8ba2 <lodepng_color_mode_copy+0x64>
    8b9b:	b8 53 00 00 00       	mov    $0x53,%eax
    8ba0:	eb 2c                	jmp    8bce <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    8ba2:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ba5:	8b 40 0c             	mov    0xc(%eax),%eax
    8ba8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    8baf:	8b 45 0c             	mov    0xc(%ebp),%eax
    8bb2:	8b 50 08             	mov    0x8(%eax),%edx
    8bb5:	8b 45 08             	mov    0x8(%ebp),%eax
    8bb8:	8b 40 08             	mov    0x8(%eax),%eax
    8bbb:	83 ec 04             	sub    $0x4,%esp
    8bbe:	51                   	push   %ecx
    8bbf:	52                   	push   %edx
    8bc0:	50                   	push   %eax
    8bc1:	e8 9d a7 ff ff       	call   3363 <lodepng_memcpy>
    8bc6:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    8bc9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8bce:	c9                   	leave  
    8bcf:	c3                   	ret    

00008bd0 <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    8bd0:	55                   	push   %ebp
    8bd1:	89 e5                	mov    %esp,%ebp
    8bd3:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    8bd6:	8d 45 e0             	lea    -0x20(%ebp),%eax
    8bd9:	50                   	push   %eax
    8bda:	e8 55 fe ff ff       	call   8a34 <lodepng_color_mode_init>
    8bdf:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    8be2:	8b 45 0c             	mov    0xc(%ebp),%eax
    8be5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    8be8:	8b 45 10             	mov    0x10(%ebp),%eax
    8beb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    8bee:	8b 45 08             	mov    0x8(%ebp),%eax
    8bf1:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8bf4:	89 10                	mov    %edx,(%eax)
    8bf6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8bf9:	89 50 04             	mov    %edx,0x4(%eax)
    8bfc:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8bff:	89 50 08             	mov    %edx,0x8(%eax)
    8c02:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8c05:	89 50 0c             	mov    %edx,0xc(%eax)
    8c08:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8c0b:	89 50 10             	mov    %edx,0x10(%eax)
    8c0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8c11:	89 50 14             	mov    %edx,0x14(%eax)
    8c14:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8c17:	89 50 18             	mov    %edx,0x18(%eax)
    8c1a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8c1d:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    8c20:	8b 45 08             	mov    0x8(%ebp),%eax
    8c23:	c9                   	leave  
    8c24:	c2 04 00             	ret    $0x4

00008c27 <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    8c27:	55                   	push   %ebp
    8c28:	89 e5                	mov    %esp,%ebp
    8c2a:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    8c2d:	8b 45 08             	mov    0x8(%ebp),%eax
    8c30:	8b 10                	mov    (%eax),%edx
    8c32:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c35:	8b 00                	mov    (%eax),%eax
    8c37:	39 c2                	cmp    %eax,%edx
    8c39:	74 0a                	je     8c45 <lodepng_color_mode_equal+0x1e>
    8c3b:	b8 00 00 00 00       	mov    $0x0,%eax
    8c40:	e9 e4 00 00 00       	jmp    8d29 <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    8c45:	8b 45 08             	mov    0x8(%ebp),%eax
    8c48:	8b 50 04             	mov    0x4(%eax),%edx
    8c4b:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c4e:	8b 40 04             	mov    0x4(%eax),%eax
    8c51:	39 c2                	cmp    %eax,%edx
    8c53:	74 0a                	je     8c5f <lodepng_color_mode_equal+0x38>
    8c55:	b8 00 00 00 00       	mov    $0x0,%eax
    8c5a:	e9 ca 00 00 00       	jmp    8d29 <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    8c5f:	8b 45 08             	mov    0x8(%ebp),%eax
    8c62:	8b 50 10             	mov    0x10(%eax),%edx
    8c65:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c68:	8b 40 10             	mov    0x10(%eax),%eax
    8c6b:	39 c2                	cmp    %eax,%edx
    8c6d:	74 0a                	je     8c79 <lodepng_color_mode_equal+0x52>
    8c6f:	b8 00 00 00 00       	mov    $0x0,%eax
    8c74:	e9 b0 00 00 00       	jmp    8d29 <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    8c79:	8b 45 08             	mov    0x8(%ebp),%eax
    8c7c:	8b 40 10             	mov    0x10(%eax),%eax
    8c7f:	85 c0                	test   %eax,%eax
    8c81:	74 48                	je     8ccb <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    8c83:	8b 45 08             	mov    0x8(%ebp),%eax
    8c86:	8b 50 14             	mov    0x14(%eax),%edx
    8c89:	8b 45 0c             	mov    0xc(%ebp),%eax
    8c8c:	8b 40 14             	mov    0x14(%eax),%eax
    8c8f:	39 c2                	cmp    %eax,%edx
    8c91:	74 0a                	je     8c9d <lodepng_color_mode_equal+0x76>
    8c93:	b8 00 00 00 00       	mov    $0x0,%eax
    8c98:	e9 8c 00 00 00       	jmp    8d29 <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    8c9d:	8b 45 08             	mov    0x8(%ebp),%eax
    8ca0:	8b 50 18             	mov    0x18(%eax),%edx
    8ca3:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ca6:	8b 40 18             	mov    0x18(%eax),%eax
    8ca9:	39 c2                	cmp    %eax,%edx
    8cab:	74 07                	je     8cb4 <lodepng_color_mode_equal+0x8d>
    8cad:	b8 00 00 00 00       	mov    $0x0,%eax
    8cb2:	eb 75                	jmp    8d29 <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    8cb4:	8b 45 08             	mov    0x8(%ebp),%eax
    8cb7:	8b 50 1c             	mov    0x1c(%eax),%edx
    8cba:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cbd:	8b 40 1c             	mov    0x1c(%eax),%eax
    8cc0:	39 c2                	cmp    %eax,%edx
    8cc2:	74 07                	je     8ccb <lodepng_color_mode_equal+0xa4>
    8cc4:	b8 00 00 00 00       	mov    $0x0,%eax
    8cc9:	eb 5e                	jmp    8d29 <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    8ccb:	8b 45 08             	mov    0x8(%ebp),%eax
    8cce:	8b 50 0c             	mov    0xc(%eax),%edx
    8cd1:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cd4:	8b 40 0c             	mov    0xc(%eax),%eax
    8cd7:	39 c2                	cmp    %eax,%edx
    8cd9:	74 07                	je     8ce2 <lodepng_color_mode_equal+0xbb>
    8cdb:	b8 00 00 00 00       	mov    $0x0,%eax
    8ce0:	eb 47                	jmp    8d29 <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    8ce2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8ce9:	eb 2b                	jmp    8d16 <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    8ceb:	8b 45 08             	mov    0x8(%ebp),%eax
    8cee:	8b 50 08             	mov    0x8(%eax),%edx
    8cf1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8cf4:	01 d0                	add    %edx,%eax
    8cf6:	0f b6 10             	movzbl (%eax),%edx
    8cf9:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cfc:	8b 48 08             	mov    0x8(%eax),%ecx
    8cff:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8d02:	01 c8                	add    %ecx,%eax
    8d04:	0f b6 00             	movzbl (%eax),%eax
    8d07:	38 c2                	cmp    %al,%dl
    8d09:	74 07                	je     8d12 <lodepng_color_mode_equal+0xeb>
    8d0b:	b8 00 00 00 00       	mov    $0x0,%eax
    8d10:	eb 17                	jmp    8d29 <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    8d12:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8d16:	8b 45 08             	mov    0x8(%ebp),%eax
    8d19:	8b 40 0c             	mov    0xc(%eax),%eax
    8d1c:	c1 e0 02             	shl    $0x2,%eax
    8d1f:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8d22:	75 c7                	jne    8ceb <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    8d24:	b8 01 00 00 00       	mov    $0x1,%eax
}
    8d29:	c9                   	leave  
    8d2a:	c3                   	ret    

00008d2b <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    8d2b:	55                   	push   %ebp
    8d2c:	89 e5                	mov    %esp,%ebp
    8d2e:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    8d31:	8b 45 08             	mov    0x8(%ebp),%eax
    8d34:	8b 40 08             	mov    0x8(%eax),%eax
    8d37:	85 c0                	test   %eax,%eax
    8d39:	74 12                	je     8d4d <lodepng_palette_clear+0x22>
    8d3b:	8b 45 08             	mov    0x8(%ebp),%eax
    8d3e:	8b 40 08             	mov    0x8(%eax),%eax
    8d41:	83 ec 0c             	sub    $0xc,%esp
    8d44:	50                   	push   %eax
    8d45:	e8 fc a5 ff ff       	call   3346 <lodepng_free>
    8d4a:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    8d4d:	8b 45 08             	mov    0x8(%ebp),%eax
    8d50:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8d57:	8b 45 08             	mov    0x8(%ebp),%eax
    8d5a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8d61:	90                   	nop
    8d62:	c9                   	leave  
    8d63:	c3                   	ret    

00008d64 <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    8d64:	55                   	push   %ebp
    8d65:	89 e5                	mov    %esp,%ebp
    8d67:	53                   	push   %ebx
    8d68:	83 ec 14             	sub    $0x14,%esp
    8d6b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    8d6e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8d71:	8b 55 14             	mov    0x14(%ebp),%edx
    8d74:	8b 45 18             	mov    0x18(%ebp),%eax
    8d77:	88 5d f4             	mov    %bl,-0xc(%ebp)
    8d7a:	88 4d f0             	mov    %cl,-0x10(%ebp)
    8d7d:	88 55 ec             	mov    %dl,-0x14(%ebp)
    8d80:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    8d83:	8b 45 08             	mov    0x8(%ebp),%eax
    8d86:	8b 40 08             	mov    0x8(%eax),%eax
    8d89:	85 c0                	test   %eax,%eax
    8d8b:	75 22                	jne    8daf <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    8d8d:	83 ec 0c             	sub    $0xc,%esp
    8d90:	ff 75 08             	pushl  0x8(%ebp)
    8d93:	e8 f5 fc ff ff       	call   8a8d <lodepng_color_mode_alloc_palette>
    8d98:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    8d9b:	8b 45 08             	mov    0x8(%ebp),%eax
    8d9e:	8b 40 08             	mov    0x8(%eax),%eax
    8da1:	85 c0                	test   %eax,%eax
    8da3:	75 0a                	jne    8daf <lodepng_palette_add+0x4b>
    8da5:	b8 53 00 00 00       	mov    $0x53,%eax
    8daa:	e9 8d 00 00 00       	jmp    8e3c <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    8daf:	8b 45 08             	mov    0x8(%ebp),%eax
    8db2:	8b 40 0c             	mov    0xc(%eax),%eax
    8db5:	3d ff 00 00 00       	cmp    $0xff,%eax
    8dba:	7e 07                	jle    8dc3 <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    8dbc:	b8 6c 00 00 00       	mov    $0x6c,%eax
    8dc1:	eb 79                	jmp    8e3c <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    8dc3:	8b 45 08             	mov    0x8(%ebp),%eax
    8dc6:	8b 50 08             	mov    0x8(%eax),%edx
    8dc9:	8b 45 08             	mov    0x8(%ebp),%eax
    8dcc:	8b 40 0c             	mov    0xc(%eax),%eax
    8dcf:	c1 e0 02             	shl    $0x2,%eax
    8dd2:	01 c2                	add    %eax,%edx
    8dd4:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    8dd8:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    8dda:	8b 45 08             	mov    0x8(%ebp),%eax
    8ddd:	8b 50 08             	mov    0x8(%eax),%edx
    8de0:	8b 45 08             	mov    0x8(%ebp),%eax
    8de3:	8b 40 0c             	mov    0xc(%eax),%eax
    8de6:	c1 e0 02             	shl    $0x2,%eax
    8de9:	83 c0 01             	add    $0x1,%eax
    8dec:	01 c2                	add    %eax,%edx
    8dee:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    8df2:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    8df4:	8b 45 08             	mov    0x8(%ebp),%eax
    8df7:	8b 50 08             	mov    0x8(%eax),%edx
    8dfa:	8b 45 08             	mov    0x8(%ebp),%eax
    8dfd:	8b 40 0c             	mov    0xc(%eax),%eax
    8e00:	c1 e0 02             	shl    $0x2,%eax
    8e03:	83 c0 02             	add    $0x2,%eax
    8e06:	01 c2                	add    %eax,%edx
    8e08:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    8e0c:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    8e0e:	8b 45 08             	mov    0x8(%ebp),%eax
    8e11:	8b 50 08             	mov    0x8(%eax),%edx
    8e14:	8b 45 08             	mov    0x8(%ebp),%eax
    8e17:	8b 40 0c             	mov    0xc(%eax),%eax
    8e1a:	c1 e0 02             	shl    $0x2,%eax
    8e1d:	83 c0 03             	add    $0x3,%eax
    8e20:	01 c2                	add    %eax,%edx
    8e22:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    8e26:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    8e28:	8b 45 08             	mov    0x8(%ebp),%eax
    8e2b:	8b 40 0c             	mov    0xc(%eax),%eax
    8e2e:	8d 50 01             	lea    0x1(%eax),%edx
    8e31:	8b 45 08             	mov    0x8(%ebp),%eax
    8e34:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    8e37:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8e3c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8e3f:	c9                   	leave  
    8e40:	c3                   	ret    

00008e41 <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    8e41:	55                   	push   %ebp
    8e42:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    8e44:	8b 45 08             	mov    0x8(%ebp),%eax
    8e47:	8b 50 04             	mov    0x4(%eax),%edx
    8e4a:	8b 45 08             	mov    0x8(%ebp),%eax
    8e4d:	8b 00                	mov    (%eax),%eax
    8e4f:	52                   	push   %edx
    8e50:	50                   	push   %eax
    8e51:	e8 ca fb ff ff       	call   8a20 <lodepng_get_bpp_lct>
    8e56:	83 c4 08             	add    $0x8,%esp
}
    8e59:	c9                   	leave  
    8e5a:	c3                   	ret    

00008e5b <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    8e5b:	55                   	push   %ebp
    8e5c:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    8e5e:	8b 45 08             	mov    0x8(%ebp),%eax
    8e61:	8b 00                	mov    (%eax),%eax
    8e63:	50                   	push   %eax
    8e64:	e8 58 fb ff ff       	call   89c1 <getNumColorChannels>
    8e69:	83 c4 04             	add    $0x4,%esp
}
    8e6c:	c9                   	leave  
    8e6d:	c3                   	ret    

00008e6e <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    8e6e:	55                   	push   %ebp
    8e6f:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    8e71:	8b 45 08             	mov    0x8(%ebp),%eax
    8e74:	8b 00                	mov    (%eax),%eax
    8e76:	85 c0                	test   %eax,%eax
    8e78:	74 0a                	je     8e84 <lodepng_is_greyscale_type+0x16>
    8e7a:	8b 45 08             	mov    0x8(%ebp),%eax
    8e7d:	8b 00                	mov    (%eax),%eax
    8e7f:	83 f8 04             	cmp    $0x4,%eax
    8e82:	75 07                	jne    8e8b <lodepng_is_greyscale_type+0x1d>
    8e84:	b8 01 00 00 00       	mov    $0x1,%eax
    8e89:	eb 05                	jmp    8e90 <lodepng_is_greyscale_type+0x22>
    8e8b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8e90:	5d                   	pop    %ebp
    8e91:	c3                   	ret    

00008e92 <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    8e92:	55                   	push   %ebp
    8e93:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    8e95:	8b 45 08             	mov    0x8(%ebp),%eax
    8e98:	8b 00                	mov    (%eax),%eax
    8e9a:	83 e0 04             	and    $0x4,%eax
    8e9d:	85 c0                	test   %eax,%eax
    8e9f:	0f 95 c0             	setne  %al
    8ea2:	0f b6 c0             	movzbl %al,%eax
}
    8ea5:	5d                   	pop    %ebp
    8ea6:	c3                   	ret    

00008ea7 <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    8ea7:	55                   	push   %ebp
    8ea8:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    8eaa:	8b 45 08             	mov    0x8(%ebp),%eax
    8ead:	8b 00                	mov    (%eax),%eax
    8eaf:	83 f8 03             	cmp    $0x3,%eax
    8eb2:	0f 94 c0             	sete   %al
    8eb5:	0f b6 c0             	movzbl %al,%eax
}
    8eb8:	5d                   	pop    %ebp
    8eb9:	c3                   	ret    

00008eba <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    8eba:	55                   	push   %ebp
    8ebb:	89 e5                	mov    %esp,%ebp
    8ebd:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8ec0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8ec7:	eb 23                	jmp    8eec <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    8ec9:	8b 45 08             	mov    0x8(%ebp),%eax
    8ecc:	8b 40 08             	mov    0x8(%eax),%eax
    8ecf:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8ed2:	c1 e2 02             	shl    $0x2,%edx
    8ed5:	83 c2 03             	add    $0x3,%edx
    8ed8:	01 d0                	add    %edx,%eax
    8eda:	0f b6 00             	movzbl (%eax),%eax
    8edd:	3c ff                	cmp    $0xff,%al
    8edf:	74 07                	je     8ee8 <lodepng_has_palette_alpha+0x2e>
    8ee1:	b8 01 00 00 00       	mov    $0x1,%eax
    8ee6:	eb 14                	jmp    8efc <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    8ee8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8eec:	8b 45 08             	mov    0x8(%ebp),%eax
    8eef:	8b 40 0c             	mov    0xc(%eax),%eax
    8ef2:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8ef5:	75 d2                	jne    8ec9 <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    8ef7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8efc:	c9                   	leave  
    8efd:	c3                   	ret    

00008efe <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    8efe:	55                   	push   %ebp
    8eff:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    8f01:	8b 45 08             	mov    0x8(%ebp),%eax
    8f04:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    8f07:	85 c0                	test   %eax,%eax
    8f09:	75 1e                	jne    8f29 <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    8f0b:	ff 75 08             	pushl  0x8(%ebp)
    8f0e:	e8 7f ff ff ff       	call   8e92 <lodepng_is_alpha_type>
    8f13:	83 c4 04             	add    $0x4,%esp
    8f16:	85 c0                	test   %eax,%eax
    8f18:	75 0f                	jne    8f29 <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    8f1a:	ff 75 08             	pushl  0x8(%ebp)
    8f1d:	e8 98 ff ff ff       	call   8eba <lodepng_has_palette_alpha>
    8f22:	83 c4 04             	add    $0x4,%esp
    8f25:	85 c0                	test   %eax,%eax
    8f27:	74 07                	je     8f30 <lodepng_can_have_alpha+0x32>
    8f29:	b8 01 00 00 00       	mov    $0x1,%eax
    8f2e:	eb 05                	jmp    8f35 <lodepng_can_have_alpha+0x37>
    8f30:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f35:	c9                   	leave  
    8f36:	c3                   	ret    

00008f37 <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    8f37:	55                   	push   %ebp
    8f38:	89 e5                	mov    %esp,%ebp
    8f3a:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    8f3d:	ff 75 14             	pushl  0x14(%ebp)
    8f40:	ff 75 10             	pushl  0x10(%ebp)
    8f43:	e8 d8 fa ff ff       	call   8a20 <lodepng_get_bpp_lct>
    8f48:	83 c4 08             	add    $0x8,%esp
    8f4b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    8f4e:	8b 55 08             	mov    0x8(%ebp),%edx
    8f51:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f54:	0f af c2             	imul   %edx,%eax
    8f57:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    8f5a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8f5d:	c1 e8 03             	shr    $0x3,%eax
    8f60:	89 c2                	mov    %eax,%edx
    8f62:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8f65:	0f af c2             	imul   %edx,%eax
    8f68:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8f6b:	89 d1                	mov    %edx,%ecx
    8f6d:	83 e1 07             	and    $0x7,%ecx
    8f70:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8f73:	0f af d1             	imul   %ecx,%edx
    8f76:	83 c2 07             	add    $0x7,%edx
    8f79:	c1 ea 03             	shr    $0x3,%edx
    8f7c:	01 d0                	add    %edx,%eax
}
    8f7e:	c9                   	leave  
    8f7f:	c3                   	ret    

00008f80 <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    8f80:	55                   	push   %ebp
    8f81:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    8f83:	8b 45 10             	mov    0x10(%ebp),%eax
    8f86:	8b 50 04             	mov    0x4(%eax),%edx
    8f89:	8b 45 10             	mov    0x10(%ebp),%eax
    8f8c:	8b 00                	mov    (%eax),%eax
    8f8e:	52                   	push   %edx
    8f8f:	50                   	push   %eax
    8f90:	ff 75 0c             	pushl  0xc(%ebp)
    8f93:	ff 75 08             	pushl  0x8(%ebp)
    8f96:	e8 9c ff ff ff       	call   8f37 <lodepng_get_raw_size_lct>
    8f9b:	83 c4 10             	add    $0x10,%esp
}
    8f9e:	c9                   	leave  
    8f9f:	c3                   	ret    

00008fa0 <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    8fa0:	55                   	push   %ebp
    8fa1:	89 e5                	mov    %esp,%ebp
    8fa3:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    8fa6:	8b 45 08             	mov    0x8(%ebp),%eax
    8fa9:	c1 e8 03             	shr    $0x3,%eax
    8fac:	0f af 45 10          	imul   0x10(%ebp),%eax
    8fb0:	8b 55 08             	mov    0x8(%ebp),%edx
    8fb3:	83 e2 07             	and    $0x7,%edx
    8fb6:	0f af 55 10          	imul   0x10(%ebp),%edx
    8fba:	83 c2 07             	add    $0x7,%edx
    8fbd:	c1 ea 03             	shr    $0x3,%edx
    8fc0:	01 d0                	add    %edx,%eax
    8fc2:	83 c0 01             	add    $0x1,%eax
    8fc5:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    8fc8:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fcb:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    8fcf:	c9                   	leave  
    8fd0:	c3                   	ret    

00008fd1 <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    8fd1:	55                   	push   %ebp
    8fd2:	89 e5                	mov    %esp,%ebp
    8fd4:	53                   	push   %ebx
    8fd5:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    8fd8:	ff 75 10             	pushl  0x10(%ebp)
    8fdb:	e8 61 fe ff ff       	call   8e41 <lodepng_get_bpp>
    8fe0:	83 c4 04             	add    $0x4,%esp
    8fe3:	89 c3                	mov    %eax,%ebx
    8fe5:	ff 75 14             	pushl  0x14(%ebp)
    8fe8:	e8 54 fe ff ff       	call   8e41 <lodepng_get_bpp>
    8fed:	83 c4 04             	add    $0x4,%esp
    8ff0:	39 c3                	cmp    %eax,%ebx
    8ff2:	76 0d                	jbe    9001 <lodepng_pixel_overflow+0x30>
    8ff4:	ff 75 10             	pushl  0x10(%ebp)
    8ff7:	e8 45 fe ff ff       	call   8e41 <lodepng_get_bpp>
    8ffc:	83 c4 04             	add    $0x4,%esp
    8fff:	eb 0b                	jmp    900c <lodepng_pixel_overflow+0x3b>
    9001:	ff 75 14             	pushl  0x14(%ebp)
    9004:	e8 38 fe ff ff       	call   8e41 <lodepng_get_bpp>
    9009:	83 c4 04             	add    $0x4,%esp
    900c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    900f:	8b 55 0c             	mov    0xc(%ebp),%edx
    9012:	8b 45 08             	mov    0x8(%ebp),%eax
    9015:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    9018:	51                   	push   %ecx
    9019:	52                   	push   %edx
    901a:	50                   	push   %eax
    901b:	e8 e9 a3 ff ff       	call   3409 <lodepng_mulofl>
    9020:	83 c4 0c             	add    $0xc,%esp
    9023:	85 c0                	test   %eax,%eax
    9025:	74 0a                	je     9031 <lodepng_pixel_overflow+0x60>
    9027:	b8 01 00 00 00       	mov    $0x1,%eax
    902c:	e9 b6 00 00 00       	jmp    90e7 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    9031:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9034:	8d 55 f0             	lea    -0x10(%ebp),%edx
    9037:	52                   	push   %edx
    9038:	6a 08                	push   $0x8
    903a:	50                   	push   %eax
    903b:	e8 c9 a3 ff ff       	call   3409 <lodepng_mulofl>
    9040:	83 c4 0c             	add    $0xc,%esp
    9043:	85 c0                	test   %eax,%eax
    9045:	74 0a                	je     9051 <lodepng_pixel_overflow+0x80>
    9047:	b8 01 00 00 00       	mov    $0x1,%eax
    904c:	e9 96 00 00 00       	jmp    90e7 <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    9051:	8b 45 08             	mov    0x8(%ebp),%eax
    9054:	c1 e8 03             	shr    $0x3,%eax
    9057:	89 c2                	mov    %eax,%edx
    9059:	8d 45 ec             	lea    -0x14(%ebp),%eax
    905c:	50                   	push   %eax
    905d:	ff 75 f8             	pushl  -0x8(%ebp)
    9060:	52                   	push   %edx
    9061:	e8 a3 a3 ff ff       	call   3409 <lodepng_mulofl>
    9066:	83 c4 0c             	add    $0xc,%esp
    9069:	85 c0                	test   %eax,%eax
    906b:	74 07                	je     9074 <lodepng_pixel_overflow+0xa3>
    906d:	b8 01 00 00 00       	mov    $0x1,%eax
    9072:	eb 73                	jmp    90e7 <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    9074:	8b 45 08             	mov    0x8(%ebp),%eax
    9077:	83 e0 07             	and    $0x7,%eax
    907a:	89 c2                	mov    %eax,%edx
    907c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    907f:	0f af c2             	imul   %edx,%eax
    9082:	83 c0 07             	add    $0x7,%eax
    9085:	c1 e8 03             	shr    $0x3,%eax
    9088:	89 c1                	mov    %eax,%ecx
    908a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    908d:	8d 55 ec             	lea    -0x14(%ebp),%edx
    9090:	52                   	push   %edx
    9091:	51                   	push   %ecx
    9092:	50                   	push   %eax
    9093:	e8 51 a3 ff ff       	call   33e9 <lodepng_addofl>
    9098:	83 c4 0c             	add    $0xc,%esp
    909b:	85 c0                	test   %eax,%eax
    909d:	74 07                	je     90a6 <lodepng_pixel_overflow+0xd5>
    909f:	b8 01 00 00 00       	mov    $0x1,%eax
    90a4:	eb 41                	jmp    90e7 <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    90a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    90a9:	8d 55 ec             	lea    -0x14(%ebp),%edx
    90ac:	52                   	push   %edx
    90ad:	6a 05                	push   $0x5
    90af:	50                   	push   %eax
    90b0:	e8 34 a3 ff ff       	call   33e9 <lodepng_addofl>
    90b5:	83 c4 0c             	add    $0xc,%esp
    90b8:	85 c0                	test   %eax,%eax
    90ba:	74 07                	je     90c3 <lodepng_pixel_overflow+0xf2>
    90bc:	b8 01 00 00 00       	mov    $0x1,%eax
    90c1:	eb 24                	jmp    90e7 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    90c3:	8b 55 0c             	mov    0xc(%ebp),%edx
    90c6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    90c9:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    90cc:	51                   	push   %ecx
    90cd:	52                   	push   %edx
    90ce:	50                   	push   %eax
    90cf:	e8 35 a3 ff ff       	call   3409 <lodepng_mulofl>
    90d4:	83 c4 0c             	add    $0xc,%esp
    90d7:	85 c0                	test   %eax,%eax
    90d9:	74 07                	je     90e2 <lodepng_pixel_overflow+0x111>
    90db:	b8 01 00 00 00       	mov    $0x1,%eax
    90e0:	eb 05                	jmp    90e7 <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    90e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    90e7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    90ea:	c9                   	leave  
    90eb:	c3                   	ret    

000090ec <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    90ec:	55                   	push   %ebp
    90ed:	89 e5                	mov    %esp,%ebp
    90ef:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    90f2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    90f9:	eb 15                	jmp    9110 <LodePNGUnknownChunks_init+0x24>
    90fb:	8b 45 08             	mov    0x8(%ebp),%eax
    90fe:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9101:	83 c2 30             	add    $0x30,%edx
    9104:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    910b:	00 
    910c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9110:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    9114:	75 e5                	jne    90fb <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    9116:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    911d:	eb 15                	jmp    9134 <LodePNGUnknownChunks_init+0x48>
    911f:	8b 45 08             	mov    0x8(%ebp),%eax
    9122:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9125:	83 c2 34             	add    $0x34,%edx
    9128:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    912f:	00 
    9130:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9134:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    9138:	75 e5                	jne    911f <LodePNGUnknownChunks_init+0x33>
}
    913a:	90                   	nop
    913b:	c9                   	leave  
    913c:	c3                   	ret    

0000913d <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    913d:	55                   	push   %ebp
    913e:	89 e5                	mov    %esp,%ebp
    9140:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    9143:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    914a:	eb 1d                	jmp    9169 <LodePNGUnknownChunks_cleanup+0x2c>
    914c:	8b 45 08             	mov    0x8(%ebp),%eax
    914f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9152:	83 c2 30             	add    $0x30,%edx
    9155:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    9159:	83 ec 0c             	sub    $0xc,%esp
    915c:	50                   	push   %eax
    915d:	e8 e4 a1 ff ff       	call   3346 <lodepng_free>
    9162:	83 c4 10             	add    $0x10,%esp
    9165:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9169:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    916d:	75 dd                	jne    914c <LodePNGUnknownChunks_cleanup+0xf>
}
    916f:	90                   	nop
    9170:	c9                   	leave  
    9171:	c3                   	ret    

00009172 <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    9172:	55                   	push   %ebp
    9173:	89 e5                	mov    %esp,%ebp
    9175:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    9178:	83 ec 0c             	sub    $0xc,%esp
    917b:	ff 75 08             	pushl  0x8(%ebp)
    917e:	e8 ba ff ff ff       	call   913d <LodePNGUnknownChunks_cleanup>
    9183:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    9186:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    918d:	e9 b7 00 00 00       	jmp    9249 <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    9192:	8b 45 0c             	mov    0xc(%ebp),%eax
    9195:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9198:	83 c2 34             	add    $0x34,%edx
    919b:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    919f:	8b 45 08             	mov    0x8(%ebp),%eax
    91a2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    91a5:	83 c1 34             	add    $0x34,%ecx
    91a8:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    91ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    91af:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91b2:	83 c2 34             	add    $0x34,%edx
    91b5:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    91b9:	83 ec 0c             	sub    $0xc,%esp
    91bc:	50                   	push   %eax
    91bd:	e8 63 a1 ff ff       	call   3325 <lodepng_malloc>
    91c2:	83 c4 10             	add    $0x10,%esp
    91c5:	89 c1                	mov    %eax,%ecx
    91c7:	8b 45 08             	mov    0x8(%ebp),%eax
    91ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91cd:	83 c2 30             	add    $0x30,%edx
    91d0:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    91d4:	8b 45 08             	mov    0x8(%ebp),%eax
    91d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91da:	83 c2 30             	add    $0x30,%edx
    91dd:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    91e1:	85 c0                	test   %eax,%eax
    91e3:	75 18                	jne    91fd <LodePNGUnknownChunks_copy+0x8b>
    91e5:	8b 45 08             	mov    0x8(%ebp),%eax
    91e8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    91eb:	83 c2 34             	add    $0x34,%edx
    91ee:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    91f2:	85 c0                	test   %eax,%eax
    91f4:	74 07                	je     91fd <LodePNGUnknownChunks_copy+0x8b>
    91f6:	b8 53 00 00 00       	mov    $0x53,%eax
    91fb:	eb 5b                	jmp    9258 <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    91fd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    9204:	eb 2d                	jmp    9233 <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    9206:	8b 45 08             	mov    0x8(%ebp),%eax
    9209:	8b 55 f4             	mov    -0xc(%ebp),%edx
    920c:	83 c2 30             	add    $0x30,%edx
    920f:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    9213:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9216:	01 c2                	add    %eax,%edx
    9218:	8b 45 0c             	mov    0xc(%ebp),%eax
    921b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    921e:	83 c1 30             	add    $0x30,%ecx
    9221:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    9225:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9228:	01 c8                	add    %ecx,%eax
    922a:	0f b6 00             	movzbl (%eax),%eax
    922d:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    922f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    9233:	8b 45 0c             	mov    0xc(%ebp),%eax
    9236:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9239:	83 c2 34             	add    $0x34,%edx
    923c:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9240:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    9243:	7f c1                	jg     9206 <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    9245:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9249:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    924d:	0f 85 3f ff ff ff    	jne    9192 <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    9253:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9258:	c9                   	leave  
    9259:	c3                   	ret    

0000925a <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    925a:	55                   	push   %ebp
    925b:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    925d:	8b 45 08             	mov    0x8(%ebp),%eax
    9260:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    9267:	8b 45 08             	mov    0x8(%ebp),%eax
    926a:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    9271:	8b 45 08             	mov    0x8(%ebp),%eax
    9274:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    927b:	90                   	nop
    927c:	5d                   	pop    %ebp
    927d:	c3                   	ret    

0000927e <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    927e:	55                   	push   %ebp
    927f:	89 e5                	mov    %esp,%ebp
    9281:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9284:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    928b:	eb 38                	jmp    92c5 <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    928d:	8b 45 08             	mov    0x8(%ebp),%eax
    9290:	8b 40 40             	mov    0x40(%eax),%eax
    9293:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9296:	c1 e2 02             	shl    $0x2,%edx
    9299:	01 d0                	add    %edx,%eax
    929b:	83 ec 0c             	sub    $0xc,%esp
    929e:	50                   	push   %eax
    929f:	e8 75 a3 ff ff       	call   3619 <string_cleanup>
    92a4:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    92a7:	8b 45 08             	mov    0x8(%ebp),%eax
    92aa:	8b 40 44             	mov    0x44(%eax),%eax
    92ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92b0:	c1 e2 02             	shl    $0x2,%edx
    92b3:	01 d0                	add    %edx,%eax
    92b5:	83 ec 0c             	sub    $0xc,%esp
    92b8:	50                   	push   %eax
    92b9:	e8 5b a3 ff ff       	call   3619 <string_cleanup>
    92be:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    92c1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    92c5:	8b 45 08             	mov    0x8(%ebp),%eax
    92c8:	8b 40 3c             	mov    0x3c(%eax),%eax
    92cb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    92ce:	75 bd                	jne    928d <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    92d0:	8b 45 08             	mov    0x8(%ebp),%eax
    92d3:	8b 40 40             	mov    0x40(%eax),%eax
    92d6:	83 ec 0c             	sub    $0xc,%esp
    92d9:	50                   	push   %eax
    92da:	e8 67 a0 ff ff       	call   3346 <lodepng_free>
    92df:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    92e2:	8b 45 08             	mov    0x8(%ebp),%eax
    92e5:	8b 40 44             	mov    0x44(%eax),%eax
    92e8:	83 ec 0c             	sub    $0xc,%esp
    92eb:	50                   	push   %eax
    92ec:	e8 55 a0 ff ff       	call   3346 <lodepng_free>
    92f1:	83 c4 10             	add    $0x10,%esp
}
    92f4:	90                   	nop
    92f5:	c9                   	leave  
    92f6:	c3                   	ret    

000092f7 <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    92f7:	55                   	push   %ebp
    92f8:	89 e5                	mov    %esp,%ebp
    92fa:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    92fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    9304:	8b 45 08             	mov    0x8(%ebp),%eax
    9307:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    930e:	8b 45 08             	mov    0x8(%ebp),%eax
    9311:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    9318:	8b 45 08             	mov    0x8(%ebp),%eax
    931b:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    9322:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9329:	eb 42                	jmp    936d <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    932b:	8b 45 0c             	mov    0xc(%ebp),%eax
    932e:	8b 40 44             	mov    0x44(%eax),%eax
    9331:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9334:	c1 e2 02             	shl    $0x2,%edx
    9337:	01 d0                	add    %edx,%eax
    9339:	8b 10                	mov    (%eax),%edx
    933b:	8b 45 0c             	mov    0xc(%ebp),%eax
    933e:	8b 40 40             	mov    0x40(%eax),%eax
    9341:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9344:	c1 e1 02             	shl    $0x2,%ecx
    9347:	01 c8                	add    %ecx,%eax
    9349:	8b 00                	mov    (%eax),%eax
    934b:	83 ec 04             	sub    $0x4,%esp
    934e:	52                   	push   %edx
    934f:	50                   	push   %eax
    9350:	ff 75 08             	pushl  0x8(%ebp)
    9353:	e8 4d 01 00 00       	call   94a5 <lodepng_add_text>
    9358:	83 c4 10             	add    $0x10,%esp
    935b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    935e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9362:	74 05                	je     9369 <LodePNGText_copy+0x72>
    9364:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9367:	eb 14                	jmp    937d <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    9369:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    936d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9370:	8b 40 3c             	mov    0x3c(%eax),%eax
    9373:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9376:	75 b3                	jne    932b <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    9378:	b8 00 00 00 00       	mov    $0x0,%eax
}
    937d:	c9                   	leave  
    937e:	c3                   	ret    

0000937f <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    937f:	55                   	push   %ebp
    9380:	89 e5                	mov    %esp,%ebp
    9382:	53                   	push   %ebx
    9383:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    9386:	8b 45 08             	mov    0x8(%ebp),%eax
    9389:	8b 40 3c             	mov    0x3c(%eax),%eax
    938c:	83 c0 01             	add    $0x1,%eax
    938f:	c1 e0 02             	shl    $0x2,%eax
    9392:	89 c2                	mov    %eax,%edx
    9394:	8b 45 08             	mov    0x8(%ebp),%eax
    9397:	8b 40 40             	mov    0x40(%eax),%eax
    939a:	52                   	push   %edx
    939b:	50                   	push   %eax
    939c:	e8 9b 9f ff ff       	call   333c <lodepng_realloc>
    93a1:	83 c4 08             	add    $0x8,%esp
    93a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    93a7:	8b 45 08             	mov    0x8(%ebp),%eax
    93aa:	8b 40 3c             	mov    0x3c(%eax),%eax
    93ad:	83 c0 01             	add    $0x1,%eax
    93b0:	c1 e0 02             	shl    $0x2,%eax
    93b3:	89 c2                	mov    %eax,%edx
    93b5:	8b 45 08             	mov    0x8(%ebp),%eax
    93b8:	8b 40 44             	mov    0x44(%eax),%eax
    93bb:	52                   	push   %edx
    93bc:	50                   	push   %eax
    93bd:	e8 7a 9f ff ff       	call   333c <lodepng_realloc>
    93c2:	83 c4 08             	add    $0x8,%esp
    93c5:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    93c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    93cc:	74 09                	je     93d7 <lodepng_add_text_sized+0x58>
    93ce:	8b 45 08             	mov    0x8(%ebp),%eax
    93d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    93d4:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    93d7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    93db:	74 09                	je     93e6 <lodepng_add_text_sized+0x67>
    93dd:	8b 45 08             	mov    0x8(%ebp),%eax
    93e0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    93e3:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    93e6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    93ea:	74 06                	je     93f2 <lodepng_add_text_sized+0x73>
    93ec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    93f0:	75 0a                	jne    93fc <lodepng_add_text_sized+0x7d>
    93f2:	b8 53 00 00 00       	mov    $0x53,%eax
    93f7:	e9 a4 00 00 00       	jmp    94a0 <lodepng_add_text_sized+0x121>

  ++info->text_num;
    93fc:	8b 45 08             	mov    0x8(%ebp),%eax
    93ff:	8b 40 3c             	mov    0x3c(%eax),%eax
    9402:	8d 50 01             	lea    0x1(%eax),%edx
    9405:	8b 45 08             	mov    0x8(%ebp),%eax
    9408:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    940b:	8b 45 08             	mov    0x8(%ebp),%eax
    940e:	8b 50 40             	mov    0x40(%eax),%edx
    9411:	8b 45 08             	mov    0x8(%ebp),%eax
    9414:	8b 40 3c             	mov    0x3c(%eax),%eax
    9417:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    941c:	c1 e0 02             	shl    $0x2,%eax
    941f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9422:	83 ec 0c             	sub    $0xc,%esp
    9425:	ff 75 0c             	pushl  0xc(%ebp)
    9428:	e8 54 a2 ff ff       	call   3681 <alloc_string>
    942d:	83 c4 10             	add    $0x10,%esp
    9430:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    9432:	8b 45 08             	mov    0x8(%ebp),%eax
    9435:	8b 50 44             	mov    0x44(%eax),%edx
    9438:	8b 45 08             	mov    0x8(%ebp),%eax
    943b:	8b 40 3c             	mov    0x3c(%eax),%eax
    943e:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9443:	c1 e0 02             	shl    $0x2,%eax
    9446:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9449:	83 ec 08             	sub    $0x8,%esp
    944c:	ff 75 14             	pushl  0x14(%ebp)
    944f:	ff 75 10             	pushl  0x10(%ebp)
    9452:	e8 e5 a1 ff ff       	call   363c <alloc_string_sized>
    9457:	83 c4 10             	add    $0x10,%esp
    945a:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    945c:	8b 45 08             	mov    0x8(%ebp),%eax
    945f:	8b 50 40             	mov    0x40(%eax),%edx
    9462:	8b 45 08             	mov    0x8(%ebp),%eax
    9465:	8b 40 3c             	mov    0x3c(%eax),%eax
    9468:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    946d:	c1 e0 02             	shl    $0x2,%eax
    9470:	01 d0                	add    %edx,%eax
    9472:	8b 00                	mov    (%eax),%eax
    9474:	85 c0                	test   %eax,%eax
    9476:	74 1c                	je     9494 <lodepng_add_text_sized+0x115>
    9478:	8b 45 08             	mov    0x8(%ebp),%eax
    947b:	8b 50 44             	mov    0x44(%eax),%edx
    947e:	8b 45 08             	mov    0x8(%ebp),%eax
    9481:	8b 40 3c             	mov    0x3c(%eax),%eax
    9484:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9489:	c1 e0 02             	shl    $0x2,%eax
    948c:	01 d0                	add    %edx,%eax
    948e:	8b 00                	mov    (%eax),%eax
    9490:	85 c0                	test   %eax,%eax
    9492:	75 07                	jne    949b <lodepng_add_text_sized+0x11c>
    9494:	b8 53 00 00 00       	mov    $0x53,%eax
    9499:	eb 05                	jmp    94a0 <lodepng_add_text_sized+0x121>

  return 0;
    949b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    94a0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    94a3:	c9                   	leave  
    94a4:	c3                   	ret    

000094a5 <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    94a5:	55                   	push   %ebp
    94a6:	89 e5                	mov    %esp,%ebp
    94a8:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    94ab:	ff 75 10             	pushl  0x10(%ebp)
    94ae:	e8 0e 9f ff ff       	call   33c1 <lodepng_strlen>
    94b3:	83 c4 04             	add    $0x4,%esp
    94b6:	50                   	push   %eax
    94b7:	ff 75 10             	pushl  0x10(%ebp)
    94ba:	ff 75 0c             	pushl  0xc(%ebp)
    94bd:	ff 75 08             	pushl  0x8(%ebp)
    94c0:	e8 ba fe ff ff       	call   937f <lodepng_add_text_sized>
    94c5:	83 c4 10             	add    $0x10,%esp
}
    94c8:	c9                   	leave  
    94c9:	c3                   	ret    

000094ca <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    94ca:	55                   	push   %ebp
    94cb:	89 e5                	mov    %esp,%ebp
    94cd:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    94d0:	83 ec 0c             	sub    $0xc,%esp
    94d3:	ff 75 08             	pushl  0x8(%ebp)
    94d6:	e8 a3 fd ff ff       	call   927e <LodePNGText_cleanup>
    94db:	83 c4 10             	add    $0x10,%esp
}
    94de:	90                   	nop
    94df:	c9                   	leave  
    94e0:	c3                   	ret    

000094e1 <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    94e1:	55                   	push   %ebp
    94e2:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    94e4:	8b 45 08             	mov    0x8(%ebp),%eax
    94e7:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    94ee:	8b 45 08             	mov    0x8(%ebp),%eax
    94f1:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    94f8:	8b 45 08             	mov    0x8(%ebp),%eax
    94fb:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    9502:	8b 45 08             	mov    0x8(%ebp),%eax
    9505:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    950c:	8b 45 08             	mov    0x8(%ebp),%eax
    950f:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    9516:	90                   	nop
    9517:	5d                   	pop    %ebp
    9518:	c3                   	ret    

00009519 <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    9519:	55                   	push   %ebp
    951a:	89 e5                	mov    %esp,%ebp
    951c:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    951f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9526:	eb 6c                	jmp    9594 <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    9528:	8b 45 08             	mov    0x8(%ebp),%eax
    952b:	8b 40 4c             	mov    0x4c(%eax),%eax
    952e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9531:	c1 e2 02             	shl    $0x2,%edx
    9534:	01 d0                	add    %edx,%eax
    9536:	83 ec 0c             	sub    $0xc,%esp
    9539:	50                   	push   %eax
    953a:	e8 da a0 ff ff       	call   3619 <string_cleanup>
    953f:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    9542:	8b 45 08             	mov    0x8(%ebp),%eax
    9545:	8b 40 50             	mov    0x50(%eax),%eax
    9548:	8b 55 f4             	mov    -0xc(%ebp),%edx
    954b:	c1 e2 02             	shl    $0x2,%edx
    954e:	01 d0                	add    %edx,%eax
    9550:	83 ec 0c             	sub    $0xc,%esp
    9553:	50                   	push   %eax
    9554:	e8 c0 a0 ff ff       	call   3619 <string_cleanup>
    9559:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    955c:	8b 45 08             	mov    0x8(%ebp),%eax
    955f:	8b 40 54             	mov    0x54(%eax),%eax
    9562:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9565:	c1 e2 02             	shl    $0x2,%edx
    9568:	01 d0                	add    %edx,%eax
    956a:	83 ec 0c             	sub    $0xc,%esp
    956d:	50                   	push   %eax
    956e:	e8 a6 a0 ff ff       	call   3619 <string_cleanup>
    9573:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    9576:	8b 45 08             	mov    0x8(%ebp),%eax
    9579:	8b 40 58             	mov    0x58(%eax),%eax
    957c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    957f:	c1 e2 02             	shl    $0x2,%edx
    9582:	01 d0                	add    %edx,%eax
    9584:	83 ec 0c             	sub    $0xc,%esp
    9587:	50                   	push   %eax
    9588:	e8 8c a0 ff ff       	call   3619 <string_cleanup>
    958d:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    9590:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9594:	8b 45 08             	mov    0x8(%ebp),%eax
    9597:	8b 40 48             	mov    0x48(%eax),%eax
    959a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    959d:	75 89                	jne    9528 <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    959f:	8b 45 08             	mov    0x8(%ebp),%eax
    95a2:	8b 40 4c             	mov    0x4c(%eax),%eax
    95a5:	83 ec 0c             	sub    $0xc,%esp
    95a8:	50                   	push   %eax
    95a9:	e8 98 9d ff ff       	call   3346 <lodepng_free>
    95ae:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    95b1:	8b 45 08             	mov    0x8(%ebp),%eax
    95b4:	8b 40 50             	mov    0x50(%eax),%eax
    95b7:	83 ec 0c             	sub    $0xc,%esp
    95ba:	50                   	push   %eax
    95bb:	e8 86 9d ff ff       	call   3346 <lodepng_free>
    95c0:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    95c3:	8b 45 08             	mov    0x8(%ebp),%eax
    95c6:	8b 40 54             	mov    0x54(%eax),%eax
    95c9:	83 ec 0c             	sub    $0xc,%esp
    95cc:	50                   	push   %eax
    95cd:	e8 74 9d ff ff       	call   3346 <lodepng_free>
    95d2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    95d5:	8b 45 08             	mov    0x8(%ebp),%eax
    95d8:	8b 40 58             	mov    0x58(%eax),%eax
    95db:	83 ec 0c             	sub    $0xc,%esp
    95de:	50                   	push   %eax
    95df:	e8 62 9d ff ff       	call   3346 <lodepng_free>
    95e4:	83 c4 10             	add    $0x10,%esp
}
    95e7:	90                   	nop
    95e8:	c9                   	leave  
    95e9:	c3                   	ret    

000095ea <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    95ea:	55                   	push   %ebp
    95eb:	89 e5                	mov    %esp,%ebp
    95ed:	56                   	push   %esi
    95ee:	53                   	push   %ebx
    95ef:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    95f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    95f9:	8b 45 08             	mov    0x8(%ebp),%eax
    95fc:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    9603:	8b 45 08             	mov    0x8(%ebp),%eax
    9606:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    960d:	8b 45 08             	mov    0x8(%ebp),%eax
    9610:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    9617:	8b 45 08             	mov    0x8(%ebp),%eax
    961a:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    9621:	8b 45 08             	mov    0x8(%ebp),%eax
    9624:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    962b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9632:	eb 64                	jmp    9698 <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    9634:	8b 45 0c             	mov    0xc(%ebp),%eax
    9637:	8b 40 58             	mov    0x58(%eax),%eax
    963a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    963d:	c1 e2 02             	shl    $0x2,%edx
    9640:	01 d0                	add    %edx,%eax
    9642:	8b 18                	mov    (%eax),%ebx
    9644:	8b 45 0c             	mov    0xc(%ebp),%eax
    9647:	8b 40 54             	mov    0x54(%eax),%eax
    964a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    964d:	c1 e2 02             	shl    $0x2,%edx
    9650:	01 d0                	add    %edx,%eax
    9652:	8b 08                	mov    (%eax),%ecx
    9654:	8b 45 0c             	mov    0xc(%ebp),%eax
    9657:	8b 40 50             	mov    0x50(%eax),%eax
    965a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    965d:	c1 e2 02             	shl    $0x2,%edx
    9660:	01 d0                	add    %edx,%eax
    9662:	8b 10                	mov    (%eax),%edx
    9664:	8b 45 0c             	mov    0xc(%ebp),%eax
    9667:	8b 40 4c             	mov    0x4c(%eax),%eax
    966a:	8b 75 f4             	mov    -0xc(%ebp),%esi
    966d:	c1 e6 02             	shl    $0x2,%esi
    9670:	01 f0                	add    %esi,%eax
    9672:	8b 00                	mov    (%eax),%eax
    9674:	83 ec 0c             	sub    $0xc,%esp
    9677:	53                   	push   %ebx
    9678:	51                   	push   %ecx
    9679:	52                   	push   %edx
    967a:	50                   	push   %eax
    967b:	ff 75 08             	pushl  0x8(%ebp)
    967e:	e8 e4 01 00 00       	call   9867 <lodepng_add_itext>
    9683:	83 c4 20             	add    $0x20,%esp
    9686:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9689:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    968d:	74 05                	je     9694 <LodePNGIText_copy+0xaa>
    968f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9692:	eb 14                	jmp    96a8 <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    9694:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9698:	8b 45 0c             	mov    0xc(%ebp),%eax
    969b:	8b 40 48             	mov    0x48(%eax),%eax
    969e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    96a1:	75 91                	jne    9634 <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    96a3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    96a8:	8d 65 f8             	lea    -0x8(%ebp),%esp
    96ab:	5b                   	pop    %ebx
    96ac:	5e                   	pop    %esi
    96ad:	5d                   	pop    %ebp
    96ae:	c3                   	ret    

000096af <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    96af:	55                   	push   %ebp
    96b0:	89 e5                	mov    %esp,%ebp
    96b2:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    96b5:	83 ec 0c             	sub    $0xc,%esp
    96b8:	ff 75 08             	pushl  0x8(%ebp)
    96bb:	e8 59 fe ff ff       	call   9519 <LodePNGIText_cleanup>
    96c0:	83 c4 10             	add    $0x10,%esp
}
    96c3:	90                   	nop
    96c4:	c9                   	leave  
    96c5:	c3                   	ret    

000096c6 <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    96c6:	55                   	push   %ebp
    96c7:	89 e5                	mov    %esp,%ebp
    96c9:	53                   	push   %ebx
    96ca:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    96cd:	8b 45 08             	mov    0x8(%ebp),%eax
    96d0:	8b 40 48             	mov    0x48(%eax),%eax
    96d3:	83 c0 01             	add    $0x1,%eax
    96d6:	c1 e0 02             	shl    $0x2,%eax
    96d9:	89 c2                	mov    %eax,%edx
    96db:	8b 45 08             	mov    0x8(%ebp),%eax
    96de:	8b 40 4c             	mov    0x4c(%eax),%eax
    96e1:	52                   	push   %edx
    96e2:	50                   	push   %eax
    96e3:	e8 54 9c ff ff       	call   333c <lodepng_realloc>
    96e8:	83 c4 08             	add    $0x8,%esp
    96eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    96ee:	8b 45 08             	mov    0x8(%ebp),%eax
    96f1:	8b 40 48             	mov    0x48(%eax),%eax
    96f4:	83 c0 01             	add    $0x1,%eax
    96f7:	c1 e0 02             	shl    $0x2,%eax
    96fa:	89 c2                	mov    %eax,%edx
    96fc:	8b 45 08             	mov    0x8(%ebp),%eax
    96ff:	8b 40 50             	mov    0x50(%eax),%eax
    9702:	52                   	push   %edx
    9703:	50                   	push   %eax
    9704:	e8 33 9c ff ff       	call   333c <lodepng_realloc>
    9709:	83 c4 08             	add    $0x8,%esp
    970c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    970f:	8b 45 08             	mov    0x8(%ebp),%eax
    9712:	8b 40 48             	mov    0x48(%eax),%eax
    9715:	83 c0 01             	add    $0x1,%eax
    9718:	c1 e0 02             	shl    $0x2,%eax
    971b:	89 c2                	mov    %eax,%edx
    971d:	8b 45 08             	mov    0x8(%ebp),%eax
    9720:	8b 40 54             	mov    0x54(%eax),%eax
    9723:	52                   	push   %edx
    9724:	50                   	push   %eax
    9725:	e8 12 9c ff ff       	call   333c <lodepng_realloc>
    972a:	83 c4 08             	add    $0x8,%esp
    972d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    9730:	8b 45 08             	mov    0x8(%ebp),%eax
    9733:	8b 40 48             	mov    0x48(%eax),%eax
    9736:	83 c0 01             	add    $0x1,%eax
    9739:	c1 e0 02             	shl    $0x2,%eax
    973c:	89 c2                	mov    %eax,%edx
    973e:	8b 45 08             	mov    0x8(%ebp),%eax
    9741:	8b 40 58             	mov    0x58(%eax),%eax
    9744:	52                   	push   %edx
    9745:	50                   	push   %eax
    9746:	e8 f1 9b ff ff       	call   333c <lodepng_realloc>
    974b:	83 c4 08             	add    $0x8,%esp
    974e:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    9751:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9755:	74 09                	je     9760 <lodepng_add_itext_sized+0x9a>
    9757:	8b 45 08             	mov    0x8(%ebp),%eax
    975a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    975d:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    9760:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9764:	74 09                	je     976f <lodepng_add_itext_sized+0xa9>
    9766:	8b 45 08             	mov    0x8(%ebp),%eax
    9769:	8b 55 f0             	mov    -0x10(%ebp),%edx
    976c:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    976f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9773:	74 09                	je     977e <lodepng_add_itext_sized+0xb8>
    9775:	8b 45 08             	mov    0x8(%ebp),%eax
    9778:	8b 55 ec             	mov    -0x14(%ebp),%edx
    977b:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    977e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9782:	74 09                	je     978d <lodepng_add_itext_sized+0xc7>
    9784:	8b 45 08             	mov    0x8(%ebp),%eax
    9787:	8b 55 e8             	mov    -0x18(%ebp),%edx
    978a:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    978d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9791:	74 12                	je     97a5 <lodepng_add_itext_sized+0xdf>
    9793:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9797:	74 0c                	je     97a5 <lodepng_add_itext_sized+0xdf>
    9799:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    979d:	74 06                	je     97a5 <lodepng_add_itext_sized+0xdf>
    979f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    97a3:	75 0a                	jne    97af <lodepng_add_itext_sized+0xe9>
    97a5:	b8 53 00 00 00       	mov    $0x53,%eax
    97aa:	e9 b3 00 00 00       	jmp    9862 <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    97af:	8b 45 08             	mov    0x8(%ebp),%eax
    97b2:	8b 40 48             	mov    0x48(%eax),%eax
    97b5:	8d 50 01             	lea    0x1(%eax),%edx
    97b8:	8b 45 08             	mov    0x8(%ebp),%eax
    97bb:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    97be:	8b 45 08             	mov    0x8(%ebp),%eax
    97c1:	8b 50 4c             	mov    0x4c(%eax),%edx
    97c4:	8b 45 08             	mov    0x8(%ebp),%eax
    97c7:	8b 40 48             	mov    0x48(%eax),%eax
    97ca:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    97cf:	c1 e0 02             	shl    $0x2,%eax
    97d2:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    97d5:	83 ec 0c             	sub    $0xc,%esp
    97d8:	ff 75 0c             	pushl  0xc(%ebp)
    97db:	e8 a1 9e ff ff       	call   3681 <alloc_string>
    97e0:	83 c4 10             	add    $0x10,%esp
    97e3:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    97e5:	8b 45 08             	mov    0x8(%ebp),%eax
    97e8:	8b 50 50             	mov    0x50(%eax),%edx
    97eb:	8b 45 08             	mov    0x8(%ebp),%eax
    97ee:	8b 40 48             	mov    0x48(%eax),%eax
    97f1:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    97f6:	c1 e0 02             	shl    $0x2,%eax
    97f9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    97fc:	83 ec 0c             	sub    $0xc,%esp
    97ff:	ff 75 10             	pushl  0x10(%ebp)
    9802:	e8 7a 9e ff ff       	call   3681 <alloc_string>
    9807:	83 c4 10             	add    $0x10,%esp
    980a:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    980c:	8b 45 08             	mov    0x8(%ebp),%eax
    980f:	8b 50 54             	mov    0x54(%eax),%edx
    9812:	8b 45 08             	mov    0x8(%ebp),%eax
    9815:	8b 40 48             	mov    0x48(%eax),%eax
    9818:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    981d:	c1 e0 02             	shl    $0x2,%eax
    9820:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9823:	83 ec 0c             	sub    $0xc,%esp
    9826:	ff 75 14             	pushl  0x14(%ebp)
    9829:	e8 53 9e ff ff       	call   3681 <alloc_string>
    982e:	83 c4 10             	add    $0x10,%esp
    9831:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    9833:	8b 45 08             	mov    0x8(%ebp),%eax
    9836:	8b 50 58             	mov    0x58(%eax),%edx
    9839:	8b 45 08             	mov    0x8(%ebp),%eax
    983c:	8b 40 48             	mov    0x48(%eax),%eax
    983f:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9844:	c1 e0 02             	shl    $0x2,%eax
    9847:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    984a:	83 ec 08             	sub    $0x8,%esp
    984d:	ff 75 1c             	pushl  0x1c(%ebp)
    9850:	ff 75 18             	pushl  0x18(%ebp)
    9853:	e8 e4 9d ff ff       	call   363c <alloc_string_sized>
    9858:	83 c4 10             	add    $0x10,%esp
    985b:	89 03                	mov    %eax,(%ebx)

  return 0;
    985d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9862:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9865:	c9                   	leave  
    9866:	c3                   	ret    

00009867 <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    9867:	55                   	push   %ebp
    9868:	89 e5                	mov    %esp,%ebp
    986a:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    986d:	ff 75 18             	pushl  0x18(%ebp)
    9870:	e8 4c 9b ff ff       	call   33c1 <lodepng_strlen>
    9875:	83 c4 04             	add    $0x4,%esp
    9878:	83 ec 08             	sub    $0x8,%esp
    987b:	50                   	push   %eax
    987c:	ff 75 18             	pushl  0x18(%ebp)
    987f:	ff 75 14             	pushl  0x14(%ebp)
    9882:	ff 75 10             	pushl  0x10(%ebp)
    9885:	ff 75 0c             	pushl  0xc(%ebp)
    9888:	ff 75 08             	pushl  0x8(%ebp)
    988b:	e8 36 fe ff ff       	call   96c6 <lodepng_add_itext_sized>
    9890:	83 c4 20             	add    $0x20,%esp
}
    9893:	c9                   	leave  
    9894:	c3                   	ret    

00009895 <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9895:	55                   	push   %ebp
    9896:	89 e5                	mov    %esp,%ebp
    9898:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    989b:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    989f:	75 0a                	jne    98ab <lodepng_assign_icc+0x16>
    98a1:	b8 64 00 00 00       	mov    $0x64,%eax
    98a6:	e9 81 00 00 00       	jmp    992c <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    98ab:	83 ec 0c             	sub    $0xc,%esp
    98ae:	ff 75 0c             	pushl  0xc(%ebp)
    98b1:	e8 cb 9d ff ff       	call   3681 <alloc_string>
    98b6:	83 c4 10             	add    $0x10,%esp
    98b9:	89 c2                	mov    %eax,%edx
    98bb:	8b 45 08             	mov    0x8(%ebp),%eax
    98be:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    98c4:	8b 45 14             	mov    0x14(%ebp),%eax
    98c7:	83 ec 0c             	sub    $0xc,%esp
    98ca:	50                   	push   %eax
    98cb:	e8 55 9a ff ff       	call   3325 <lodepng_malloc>
    98d0:	83 c4 10             	add    $0x10,%esp
    98d3:	89 c2                	mov    %eax,%edx
    98d5:	8b 45 08             	mov    0x8(%ebp),%eax
    98d8:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    98de:	8b 45 08             	mov    0x8(%ebp),%eax
    98e1:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    98e7:	85 c0                	test   %eax,%eax
    98e9:	74 0d                	je     98f8 <lodepng_assign_icc+0x63>
    98eb:	8b 45 08             	mov    0x8(%ebp),%eax
    98ee:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    98f4:	85 c0                	test   %eax,%eax
    98f6:	75 07                	jne    98ff <lodepng_assign_icc+0x6a>
    98f8:	b8 53 00 00 00       	mov    $0x53,%eax
    98fd:	eb 2d                	jmp    992c <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    98ff:	8b 55 14             	mov    0x14(%ebp),%edx
    9902:	8b 45 08             	mov    0x8(%ebp),%eax
    9905:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    990b:	83 ec 04             	sub    $0x4,%esp
    990e:	52                   	push   %edx
    990f:	ff 75 10             	pushl  0x10(%ebp)
    9912:	50                   	push   %eax
    9913:	e8 4b 9a ff ff       	call   3363 <lodepng_memcpy>
    9918:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    991b:	8b 45 08             	mov    0x8(%ebp),%eax
    991e:	8b 55 14             	mov    0x14(%ebp),%edx
    9921:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    9927:	b8 00 00 00 00       	mov    $0x0,%eax
}
    992c:	c9                   	leave  
    992d:	c3                   	ret    

0000992e <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    992e:	55                   	push   %ebp
    992f:	89 e5                	mov    %esp,%ebp
    9931:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    9934:	8b 45 08             	mov    0x8(%ebp),%eax
    9937:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    993d:	85 c0                	test   %eax,%eax
    993f:	74 0e                	je     994f <lodepng_set_icc+0x21>
    9941:	83 ec 0c             	sub    $0xc,%esp
    9944:	ff 75 08             	pushl  0x8(%ebp)
    9947:	e8 26 00 00 00       	call   9972 <lodepng_clear_icc>
    994c:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    994f:	8b 45 08             	mov    0x8(%ebp),%eax
    9952:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    9959:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    995c:	ff 75 14             	pushl  0x14(%ebp)
    995f:	ff 75 10             	pushl  0x10(%ebp)
    9962:	ff 75 0c             	pushl  0xc(%ebp)
    9965:	ff 75 08             	pushl  0x8(%ebp)
    9968:	e8 28 ff ff ff       	call   9895 <lodepng_assign_icc>
    996d:	83 c4 10             	add    $0x10,%esp
}
    9970:	c9                   	leave  
    9971:	c3                   	ret    

00009972 <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    9972:	55                   	push   %ebp
    9973:	89 e5                	mov    %esp,%ebp
    9975:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    9978:	8b 45 08             	mov    0x8(%ebp),%eax
    997b:	05 c0 00 00 00       	add    $0xc0,%eax
    9980:	83 ec 0c             	sub    $0xc,%esp
    9983:	50                   	push   %eax
    9984:	e8 90 9c ff ff       	call   3619 <string_cleanup>
    9989:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    998c:	8b 45 08             	mov    0x8(%ebp),%eax
    998f:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9995:	83 ec 0c             	sub    $0xc,%esp
    9998:	50                   	push   %eax
    9999:	e8 a8 99 ff ff       	call   3346 <lodepng_free>
    999e:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    99a1:	8b 45 08             	mov    0x8(%ebp),%eax
    99a4:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    99ab:	00 00 00 
  info->iccp_profile_size = 0;
    99ae:	8b 45 08             	mov    0x8(%ebp),%eax
    99b1:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    99b8:	00 00 00 
  info->iccp_defined = 0;
    99bb:	8b 45 08             	mov    0x8(%ebp),%eax
    99be:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    99c5:	00 00 00 
}
    99c8:	90                   	nop
    99c9:	c9                   	leave  
    99ca:	c3                   	ret    

000099cb <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    99cb:	55                   	push   %ebp
    99cc:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    99ce:	8b 45 08             	mov    0x8(%ebp),%eax
    99d1:	83 c0 0c             	add    $0xc,%eax
    99d4:	50                   	push   %eax
    99d5:	e8 5a f0 ff ff       	call   8a34 <lodepng_color_mode_init>
    99da:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    99dd:	8b 45 08             	mov    0x8(%ebp),%eax
    99e0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    99e7:	8b 45 08             	mov    0x8(%ebp),%eax
    99ea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    99f0:	8b 45 08             	mov    0x8(%ebp),%eax
    99f3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    99fa:	8b 45 08             	mov    0x8(%ebp),%eax
    99fd:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    9a04:	8b 45 08             	mov    0x8(%ebp),%eax
    9a07:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    9a0e:	8b 45 08             	mov    0x8(%ebp),%eax
    9a11:	8b 50 38             	mov    0x38(%eax),%edx
    9a14:	8b 45 08             	mov    0x8(%ebp),%eax
    9a17:	89 50 34             	mov    %edx,0x34(%eax)
    9a1a:	8b 45 08             	mov    0x8(%ebp),%eax
    9a1d:	8b 50 34             	mov    0x34(%eax),%edx
    9a20:	8b 45 08             	mov    0x8(%ebp),%eax
    9a23:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    9a26:	ff 75 08             	pushl  0x8(%ebp)
    9a29:	e8 2c f8 ff ff       	call   925a <LodePNGText_init>
    9a2e:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    9a31:	ff 75 08             	pushl  0x8(%ebp)
    9a34:	e8 a8 fa ff ff       	call   94e1 <LodePNGIText_init>
    9a39:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    9a3c:	8b 45 08             	mov    0x8(%ebp),%eax
    9a3f:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    9a46:	8b 45 08             	mov    0x8(%ebp),%eax
    9a49:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    9a50:	8b 45 08             	mov    0x8(%ebp),%eax
    9a53:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    9a5a:	00 00 00 
  info->chrm_defined = 0;
    9a5d:	8b 45 08             	mov    0x8(%ebp),%eax
    9a60:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    9a67:	00 00 00 
  info->srgb_defined = 0;
    9a6a:	8b 45 08             	mov    0x8(%ebp),%eax
    9a6d:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    9a74:	00 00 00 
  info->iccp_defined = 0;
    9a77:	8b 45 08             	mov    0x8(%ebp),%eax
    9a7a:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9a81:	00 00 00 
  info->iccp_name = NULL;
    9a84:	8b 45 08             	mov    0x8(%ebp),%eax
    9a87:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    9a8e:	00 00 00 
  info->iccp_profile = NULL;
    9a91:	8b 45 08             	mov    0x8(%ebp),%eax
    9a94:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9a9b:	00 00 00 

  LodePNGUnknownChunks_init(info);
    9a9e:	ff 75 08             	pushl  0x8(%ebp)
    9aa1:	e8 46 f6 ff ff       	call   90ec <LodePNGUnknownChunks_init>
    9aa6:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9aa9:	90                   	nop
    9aaa:	c9                   	leave  
    9aab:	c3                   	ret    

00009aac <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    9aac:	55                   	push   %ebp
    9aad:	89 e5                	mov    %esp,%ebp
    9aaf:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    9ab2:	8b 45 08             	mov    0x8(%ebp),%eax
    9ab5:	83 c0 0c             	add    $0xc,%eax
    9ab8:	83 ec 0c             	sub    $0xc,%esp
    9abb:	50                   	push   %eax
    9abc:	e8 66 f0 ff ff       	call   8b27 <lodepng_color_mode_cleanup>
    9ac1:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    9ac4:	83 ec 0c             	sub    $0xc,%esp
    9ac7:	ff 75 08             	pushl  0x8(%ebp)
    9aca:	e8 af f7 ff ff       	call   927e <LodePNGText_cleanup>
    9acf:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    9ad2:	83 ec 0c             	sub    $0xc,%esp
    9ad5:	ff 75 08             	pushl  0x8(%ebp)
    9ad8:	e8 3c fa ff ff       	call   9519 <LodePNGIText_cleanup>
    9add:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    9ae0:	83 ec 0c             	sub    $0xc,%esp
    9ae3:	ff 75 08             	pushl  0x8(%ebp)
    9ae6:	e8 87 fe ff ff       	call   9972 <lodepng_clear_icc>
    9aeb:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    9aee:	83 ec 0c             	sub    $0xc,%esp
    9af1:	ff 75 08             	pushl  0x8(%ebp)
    9af4:	e8 44 f6 ff ff       	call   913d <LodePNGUnknownChunks_cleanup>
    9af9:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9afc:	90                   	nop
    9afd:	c9                   	leave  
    9afe:	c3                   	ret    

00009aff <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9aff:	55                   	push   %ebp
    9b00:	89 e5                	mov    %esp,%ebp
    9b02:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    9b05:	83 ec 0c             	sub    $0xc,%esp
    9b08:	ff 75 08             	pushl  0x8(%ebp)
    9b0b:	e8 9c ff ff ff       	call   9aac <lodepng_info_cleanup>
    9b10:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    9b13:	83 ec 04             	sub    $0x4,%esp
    9b16:	68 e4 00 00 00       	push   $0xe4
    9b1b:	ff 75 0c             	pushl  0xc(%ebp)
    9b1e:	ff 75 08             	pushl  0x8(%ebp)
    9b21:	e8 3d 98 ff ff       	call   3363 <lodepng_memcpy>
    9b26:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    9b29:	8b 45 08             	mov    0x8(%ebp),%eax
    9b2c:	83 c0 0c             	add    $0xc,%eax
    9b2f:	83 ec 0c             	sub    $0xc,%esp
    9b32:	50                   	push   %eax
    9b33:	e8 fc ee ff ff       	call   8a34 <lodepng_color_mode_init>
    9b38:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    9b3b:	8b 45 0c             	mov    0xc(%ebp),%eax
    9b3e:	8d 50 0c             	lea    0xc(%eax),%edx
    9b41:	8b 45 08             	mov    0x8(%ebp),%eax
    9b44:	83 c0 0c             	add    $0xc,%eax
    9b47:	83 ec 08             	sub    $0x8,%esp
    9b4a:	52                   	push   %edx
    9b4b:	50                   	push   %eax
    9b4c:	e8 ed ef ff ff       	call   8b3e <lodepng_color_mode_copy>
    9b51:	83 c4 10             	add    $0x10,%esp
    9b54:	89 45 f4             	mov    %eax,-0xc(%ebp)
    9b57:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9b5b:	74 08                	je     9b65 <lodepng_info_copy+0x66>
    9b5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9b60:	e9 b7 00 00 00       	jmp    9c1c <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    9b65:	83 ec 08             	sub    $0x8,%esp
    9b68:	ff 75 0c             	pushl  0xc(%ebp)
    9b6b:	ff 75 08             	pushl  0x8(%ebp)
    9b6e:	e8 84 f7 ff ff       	call   92f7 <LodePNGText_copy>
    9b73:	83 c4 10             	add    $0x10,%esp
    9b76:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9b79:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9b7d:	74 08                	je     9b87 <lodepng_info_copy+0x88>
    9b7f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9b82:	e9 95 00 00 00       	jmp    9c1c <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    9b87:	83 ec 08             	sub    $0x8,%esp
    9b8a:	ff 75 0c             	pushl  0xc(%ebp)
    9b8d:	ff 75 08             	pushl  0x8(%ebp)
    9b90:	e8 55 fa ff ff       	call   95ea <LodePNGIText_copy>
    9b95:	83 c4 10             	add    $0x10,%esp
    9b98:	89 45 ec             	mov    %eax,-0x14(%ebp)
    9b9b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9b9f:	74 05                	je     9ba6 <lodepng_info_copy+0xa7>
    9ba1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9ba4:	eb 76                	jmp    9c1c <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    9ba6:	8b 45 0c             	mov    0xc(%ebp),%eax
    9ba9:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    9baf:	85 c0                	test   %eax,%eax
    9bb1:	74 37                	je     9bea <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    9bb3:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bb6:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    9bbc:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bbf:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    9bc5:	8b 45 0c             	mov    0xc(%ebp),%eax
    9bc8:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9bce:	51                   	push   %ecx
    9bcf:	52                   	push   %edx
    9bd0:	50                   	push   %eax
    9bd1:	ff 75 08             	pushl  0x8(%ebp)
    9bd4:	e8 bc fc ff ff       	call   9895 <lodepng_assign_icc>
    9bd9:	83 c4 10             	add    $0x10,%esp
    9bdc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    9bdf:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9be3:	74 05                	je     9bea <lodepng_info_copy+0xeb>
    9be5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9be8:	eb 32                	jmp    9c1c <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    9bea:	83 ec 0c             	sub    $0xc,%esp
    9bed:	ff 75 08             	pushl  0x8(%ebp)
    9bf0:	e8 f7 f4 ff ff       	call   90ec <LodePNGUnknownChunks_init>
    9bf5:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    9bf8:	83 ec 08             	sub    $0x8,%esp
    9bfb:	ff 75 0c             	pushl  0xc(%ebp)
    9bfe:	ff 75 08             	pushl  0x8(%ebp)
    9c01:	e8 6c f5 ff ff       	call   9172 <LodePNGUnknownChunks_copy>
    9c06:	83 c4 10             	add    $0x10,%esp
    9c09:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9c0c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    9c10:	74 05                	je     9c17 <lodepng_info_copy+0x118>
    9c12:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9c15:	eb 05                	jmp    9c1c <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    9c17:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9c1c:	c9                   	leave  
    9c1d:	c3                   	ret    

00009c1e <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    9c1e:	55                   	push   %ebp
    9c1f:	89 e5                	mov    %esp,%ebp
    9c21:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    9c24:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    9c28:	74 14                	je     9c3e <addColorBits+0x20>
    9c2a:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    9c2e:	75 07                	jne    9c37 <addColorBits+0x19>
    9c30:	b8 03 00 00 00       	mov    $0x3,%eax
    9c35:	eb 0c                	jmp    9c43 <addColorBits+0x25>
    9c37:	b8 01 00 00 00       	mov    $0x1,%eax
    9c3c:	eb 05                	jmp    9c43 <addColorBits+0x25>
    9c3e:	b8 07 00 00 00       	mov    $0x7,%eax
    9c43:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    9c46:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c49:	23 45 fc             	and    -0x4(%ebp),%eax
    9c4c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    9c4f:	8b 45 10             	mov    0x10(%ebp),%eax
    9c52:	ba 01 00 00 00       	mov    $0x1,%edx
    9c57:	89 c1                	mov    %eax,%ecx
    9c59:	d3 e2                	shl    %cl,%edx
    9c5b:	89 d0                	mov    %edx,%eax
    9c5d:	83 e8 01             	sub    $0x1,%eax
    9c60:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    9c63:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9c66:	2b 45 f8             	sub    -0x8(%ebp),%eax
    9c69:	0f af 45 10          	imul   0x10(%ebp),%eax
    9c6d:	89 c1                	mov    %eax,%ecx
    9c6f:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    9c72:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    9c76:	75 18                	jne    9c90 <addColorBits+0x72>
    9c78:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c7b:	0f af 45 10          	imul   0x10(%ebp),%eax
    9c7f:	c1 e8 03             	shr    $0x3,%eax
    9c82:	89 c2                	mov    %eax,%edx
    9c84:	8b 45 08             	mov    0x8(%ebp),%eax
    9c87:	01 d0                	add    %edx,%eax
    9c89:	8b 55 14             	mov    0x14(%ebp),%edx
    9c8c:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    9c8e:	eb 1e                	jmp    9cae <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    9c90:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c93:	0f af 45 10          	imul   0x10(%ebp),%eax
    9c97:	c1 e8 03             	shr    $0x3,%eax
    9c9a:	8b 55 08             	mov    0x8(%ebp),%edx
    9c9d:	01 c2                	add    %eax,%edx
    9c9f:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9ca2:	01 c8                	add    %ecx,%eax
    9ca4:	0f b6 08             	movzbl (%eax),%ecx
    9ca7:	8b 45 14             	mov    0x14(%ebp),%eax
    9caa:	09 c8                	or     %ecx,%eax
    9cac:	88 02                	mov    %al,(%edx)
}
    9cae:	90                   	nop
    9caf:	c9                   	leave  
    9cb0:	c3                   	ret    

00009cb1 <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    9cb1:	55                   	push   %ebp
    9cb2:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    9cb4:	8b 45 08             	mov    0x8(%ebp),%eax
    9cb7:	6a 40                	push   $0x40
    9cb9:	6a 00                	push   $0x0
    9cbb:	50                   	push   %eax
    9cbc:	e8 d5 96 ff ff       	call   3396 <lodepng_memset>
    9cc1:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    9cc4:	8b 45 08             	mov    0x8(%ebp),%eax
    9cc7:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    9cce:	90                   	nop
    9ccf:	c9                   	leave  
    9cd0:	c3                   	ret    

00009cd1 <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    9cd1:	55                   	push   %ebp
    9cd2:	89 e5                	mov    %esp,%ebp
    9cd4:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    9cd7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9cde:	eb 3b                	jmp    9d1b <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    9ce0:	8b 45 08             	mov    0x8(%ebp),%eax
    9ce3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9ce6:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9ce9:	85 c0                	test   %eax,%eax
    9ceb:	74 2a                	je     9d17 <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    9ced:	8b 45 08             	mov    0x8(%ebp),%eax
    9cf0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9cf3:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9cf6:	83 ec 0c             	sub    $0xc,%esp
    9cf9:	50                   	push   %eax
    9cfa:	e8 d2 ff ff ff       	call   9cd1 <color_tree_cleanup>
    9cff:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    9d02:	8b 45 08             	mov    0x8(%ebp),%eax
    9d05:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9d08:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9d0b:	83 ec 0c             	sub    $0xc,%esp
    9d0e:	50                   	push   %eax
    9d0f:	e8 32 96 ff ff       	call   3346 <lodepng_free>
    9d14:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    9d17:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9d1b:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    9d1f:	75 bf                	jne    9ce0 <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    9d21:	90                   	nop
    9d22:	c9                   	leave  
    9d23:	c3                   	ret    

00009d24 <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9d24:	55                   	push   %ebp
    9d25:	89 e5                	mov    %esp,%ebp
    9d27:	53                   	push   %ebx
    9d28:	83 ec 20             	sub    $0x20,%esp
    9d2b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9d2e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9d31:	8b 55 14             	mov    0x14(%ebp),%edx
    9d34:	8b 45 18             	mov    0x18(%ebp),%eax
    9d37:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9d3a:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9d3d:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9d40:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    9d43:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    9d4a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    9d51:	eb 76                	jmp    9dc9 <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9d53:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    9d57:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d5a:	89 c1                	mov    %eax,%ecx
    9d5c:	d3 fa                	sar    %cl,%edx
    9d5e:	89 d0                	mov    %edx,%eax
    9d60:	83 e0 01             	and    $0x1,%eax
    9d63:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9d66:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9d6a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d6d:	89 c1                	mov    %eax,%ecx
    9d6f:	d3 fa                	sar    %cl,%edx
    9d71:	89 d0                	mov    %edx,%eax
    9d73:	83 e0 01             	and    $0x1,%eax
    9d76:	01 d8                	add    %ebx,%eax
    9d78:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9d7b:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9d7f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d82:	89 c1                	mov    %eax,%ecx
    9d84:	d3 fa                	sar    %cl,%edx
    9d86:	89 d0                	mov    %edx,%eax
    9d88:	83 e0 01             	and    $0x1,%eax
    9d8b:	01 d8                	add    %ebx,%eax
    9d8d:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9d90:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9d94:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9d97:	89 c1                	mov    %eax,%ecx
    9d99:	d3 fa                	sar    %cl,%edx
    9d9b:	89 d0                	mov    %edx,%eax
    9d9d:	83 e0 01             	and    $0x1,%eax
    9da0:	01 d8                	add    %ebx,%eax
    9da2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    9da5:	8b 45 08             	mov    0x8(%ebp),%eax
    9da8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9dab:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9dae:	85 c0                	test   %eax,%eax
    9db0:	75 07                	jne    9db9 <color_tree_get+0x95>
    9db2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9db7:	eb 2a                	jmp    9de3 <color_tree_get+0xbf>
    else tree = tree->children[i];
    9db9:	8b 45 08             	mov    0x8(%ebp),%eax
    9dbc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9dbf:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9dc2:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    9dc5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    9dc9:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    9dcd:	7e 84                	jle    9d53 <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    9dcf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    9dd3:	74 08                	je     9ddd <color_tree_get+0xb9>
    9dd5:	8b 45 08             	mov    0x8(%ebp),%eax
    9dd8:	8b 40 40             	mov    0x40(%eax),%eax
    9ddb:	eb 05                	jmp    9de2 <color_tree_get+0xbe>
    9ddd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9de2:	90                   	nop
}
    9de3:	83 c4 20             	add    $0x20,%esp
    9de6:	5b                   	pop    %ebx
    9de7:	5d                   	pop    %ebp
    9de8:	c3                   	ret    

00009de9 <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9de9:	55                   	push   %ebp
    9dea:	89 e5                	mov    %esp,%ebp
    9dec:	53                   	push   %ebx
    9ded:	83 ec 10             	sub    $0x10,%esp
    9df0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9df3:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9df6:	8b 55 14             	mov    0x14(%ebp),%edx
    9df9:	8b 45 18             	mov    0x18(%ebp),%eax
    9dfc:	88 5d f8             	mov    %bl,-0x8(%ebp)
    9dff:	88 4d f4             	mov    %cl,-0xc(%ebp)
    9e02:	88 55 f0             	mov    %dl,-0x10(%ebp)
    9e05:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    9e08:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    9e0c:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    9e10:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    9e14:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    9e18:	53                   	push   %ebx
    9e19:	51                   	push   %ecx
    9e1a:	52                   	push   %edx
    9e1b:	50                   	push   %eax
    9e1c:	ff 75 08             	pushl  0x8(%ebp)
    9e1f:	e8 00 ff ff ff       	call   9d24 <color_tree_get>
    9e24:	83 c4 14             	add    $0x14,%esp
    9e27:	f7 d0                	not    %eax
    9e29:	c1 e8 1f             	shr    $0x1f,%eax
    9e2c:	0f b6 c0             	movzbl %al,%eax
}
    9e2f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9e32:	c9                   	leave  
    9e33:	c3                   	ret    

00009e34 <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    9e34:	55                   	push   %ebp
    9e35:	89 e5                	mov    %esp,%ebp
    9e37:	53                   	push   %ebx
    9e38:	83 ec 24             	sub    $0x24,%esp
    9e3b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9e3e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9e41:	8b 55 14             	mov    0x14(%ebp),%edx
    9e44:	8b 45 18             	mov    0x18(%ebp),%eax
    9e47:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    9e4a:	88 4d e0             	mov    %cl,-0x20(%ebp)
    9e4d:	88 55 dc             	mov    %dl,-0x24(%ebp)
    9e50:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9e53:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9e5a:	e9 b0 00 00 00       	jmp    9f0f <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9e5f:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9e63:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e66:	89 c1                	mov    %eax,%ecx
    9e68:	d3 fa                	sar    %cl,%edx
    9e6a:	89 d0                	mov    %edx,%eax
    9e6c:	83 e0 01             	and    $0x1,%eax
    9e6f:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e72:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9e76:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e79:	89 c1                	mov    %eax,%ecx
    9e7b:	d3 fa                	sar    %cl,%edx
    9e7d:	89 d0                	mov    %edx,%eax
    9e7f:	83 e0 01             	and    $0x1,%eax
    9e82:	01 d8                	add    %ebx,%eax
    9e84:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e87:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9e8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e8e:	89 c1                	mov    %eax,%ecx
    9e90:	d3 fa                	sar    %cl,%edx
    9e92:	89 d0                	mov    %edx,%eax
    9e94:	83 e0 01             	and    $0x1,%eax
    9e97:	01 d8                	add    %ebx,%eax
    9e99:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9e9c:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    9ea0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9ea3:	89 c1                	mov    %eax,%ecx
    9ea5:	d3 fa                	sar    %cl,%edx
    9ea7:	89 d0                	mov    %edx,%eax
    9ea9:	83 e0 01             	and    $0x1,%eax
    9eac:	01 d8                	add    %ebx,%eax
    9eae:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    9eb1:	8b 45 08             	mov    0x8(%ebp),%eax
    9eb4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9eb7:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9eba:	85 c0                	test   %eax,%eax
    9ebc:	75 41                	jne    9eff <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    9ebe:	83 ec 0c             	sub    $0xc,%esp
    9ec1:	6a 44                	push   $0x44
    9ec3:	e8 5d 94 ff ff       	call   3325 <lodepng_malloc>
    9ec8:	83 c4 10             	add    $0x10,%esp
    9ecb:	89 c1                	mov    %eax,%ecx
    9ecd:	8b 45 08             	mov    0x8(%ebp),%eax
    9ed0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ed3:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    9ed6:	8b 45 08             	mov    0x8(%ebp),%eax
    9ed9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9edc:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9edf:	85 c0                	test   %eax,%eax
    9ee1:	75 07                	jne    9eea <color_tree_add+0xb6>
    9ee3:	b8 53 00 00 00       	mov    $0x53,%eax
    9ee8:	eb 3d                	jmp    9f27 <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    9eea:	8b 45 08             	mov    0x8(%ebp),%eax
    9eed:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9ef0:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9ef3:	83 ec 0c             	sub    $0xc,%esp
    9ef6:	50                   	push   %eax
    9ef7:	e8 b5 fd ff ff       	call   9cb1 <color_tree_init>
    9efc:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    9eff:	8b 45 08             	mov    0x8(%ebp),%eax
    9f02:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9f05:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9f08:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9f0b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9f0f:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    9f13:	0f 8e 46 ff ff ff    	jle    9e5f <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    9f19:	8b 55 1c             	mov    0x1c(%ebp),%edx
    9f1c:	8b 45 08             	mov    0x8(%ebp),%eax
    9f1f:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    9f22:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9f27:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9f2a:	c9                   	leave  
    9f2b:	c3                   	ret    

00009f2c <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9f2c:	55                   	push   %ebp
    9f2d:	89 e5                	mov    %esp,%ebp
    9f2f:	53                   	push   %ebx
    9f30:	83 ec 20             	sub    $0x20,%esp
    9f33:	8b 5d 18             	mov    0x18(%ebp),%ebx
    9f36:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    9f39:	8b 55 20             	mov    0x20(%ebp),%edx
    9f3c:	8b 45 24             	mov    0x24(%ebp),%eax
    9f3f:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9f42:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9f45:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9f48:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    9f4b:	8b 45 10             	mov    0x10(%ebp),%eax
    9f4e:	8b 00                	mov    (%eax),%eax
    9f50:	85 c0                	test   %eax,%eax
    9f52:	0f 85 ad 00 00 00    	jne    a005 <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    9f58:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    9f5c:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    9f5f:	8b 45 10             	mov    0x10(%ebp),%eax
    9f62:	8b 40 04             	mov    0x4(%eax),%eax
    9f65:	83 f8 08             	cmp    $0x8,%eax
    9f68:	75 13                	jne    9f7d <rgba8ToPixel+0x51>
    9f6a:	8b 55 0c             	mov    0xc(%ebp),%edx
    9f6d:	8b 45 08             	mov    0x8(%ebp),%eax
    9f70:	01 c2                	add    %eax,%edx
    9f72:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    9f76:	88 02                	mov    %al,(%edx)
    9f78:	e9 b4 03 00 00       	jmp    a331 <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    9f7d:	8b 45 10             	mov    0x10(%ebp),%eax
    9f80:	8b 40 04             	mov    0x4(%eax),%eax
    9f83:	83 f8 10             	cmp    $0x10,%eax
    9f86:	75 2a                	jne    9fb2 <rgba8ToPixel+0x86>
    9f88:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f8b:	01 c0                	add    %eax,%eax
    9f8d:	89 c2                	mov    %eax,%edx
    9f8f:	8b 45 08             	mov    0x8(%ebp),%eax
    9f92:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    9f95:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f98:	01 c0                	add    %eax,%eax
    9f9a:	8d 50 01             	lea    0x1(%eax),%edx
    9f9d:	8b 45 08             	mov    0x8(%ebp),%eax
    9fa0:	01 d0                	add    %edx,%eax
    9fa2:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    9fa6:	88 10                	mov    %dl,(%eax)
    9fa8:	0f b6 00             	movzbl (%eax),%eax
    9fab:	88 01                	mov    %al,(%ecx)
    9fad:	e9 7f 03 00 00       	jmp    a331 <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    9fb2:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    9fb6:	8b 45 10             	mov    0x10(%ebp),%eax
    9fb9:	8b 40 04             	mov    0x4(%eax),%eax
    9fbc:	b9 08 00 00 00       	mov    $0x8,%ecx
    9fc1:	29 c1                	sub    %eax,%ecx
    9fc3:	89 c8                	mov    %ecx,%eax
    9fc5:	89 c1                	mov    %eax,%ecx
    9fc7:	d3 ea                	shr    %cl,%edx
    9fc9:	89 d0                	mov    %edx,%eax
    9fcb:	89 c2                	mov    %eax,%edx
    9fcd:	8b 45 10             	mov    0x10(%ebp),%eax
    9fd0:	8b 40 04             	mov    0x4(%eax),%eax
    9fd3:	bb 01 00 00 00       	mov    $0x1,%ebx
    9fd8:	89 c1                	mov    %eax,%ecx
    9fda:	d3 e3                	shl    %cl,%ebx
    9fdc:	89 d8                	mov    %ebx,%eax
    9fde:	83 e8 01             	sub    $0x1,%eax
    9fe1:	21 d0                	and    %edx,%eax
    9fe3:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    9fe6:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    9fea:	8b 45 10             	mov    0x10(%ebp),%eax
    9fed:	8b 40 04             	mov    0x4(%eax),%eax
    9ff0:	52                   	push   %edx
    9ff1:	50                   	push   %eax
    9ff2:	ff 75 0c             	pushl  0xc(%ebp)
    9ff5:	ff 75 08             	pushl  0x8(%ebp)
    9ff8:	e8 21 fc ff ff       	call   9c1e <addColorBits>
    9ffd:	83 c4 10             	add    $0x10,%esp
    a000:	e9 2c 03 00 00       	jmp    a331 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    a005:	8b 45 10             	mov    0x10(%ebp),%eax
    a008:	8b 00                	mov    (%eax),%eax
    a00a:	83 f8 02             	cmp    $0x2,%eax
    a00d:	0f 85 ee 00 00 00    	jne    a101 <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    a013:	8b 45 10             	mov    0x10(%ebp),%eax
    a016:	8b 40 04             	mov    0x4(%eax),%eax
    a019:	83 f8 08             	cmp    $0x8,%eax
    a01c:	75 49                	jne    a067 <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    a01e:	8b 55 0c             	mov    0xc(%ebp),%edx
    a021:	89 d0                	mov    %edx,%eax
    a023:	01 c0                	add    %eax,%eax
    a025:	01 d0                	add    %edx,%eax
    a027:	89 c2                	mov    %eax,%edx
    a029:	8b 45 08             	mov    0x8(%ebp),%eax
    a02c:	01 c2                	add    %eax,%edx
    a02e:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a032:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    a034:	8b 55 0c             	mov    0xc(%ebp),%edx
    a037:	89 d0                	mov    %edx,%eax
    a039:	01 c0                	add    %eax,%eax
    a03b:	01 d0                	add    %edx,%eax
    a03d:	8d 50 01             	lea    0x1(%eax),%edx
    a040:	8b 45 08             	mov    0x8(%ebp),%eax
    a043:	01 c2                	add    %eax,%edx
    a045:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a049:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    a04b:	8b 55 0c             	mov    0xc(%ebp),%edx
    a04e:	89 d0                	mov    %edx,%eax
    a050:	01 c0                	add    %eax,%eax
    a052:	01 d0                	add    %edx,%eax
    a054:	8d 50 02             	lea    0x2(%eax),%edx
    a057:	8b 45 08             	mov    0x8(%ebp),%eax
    a05a:	01 c2                	add    %eax,%edx
    a05c:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a060:	88 02                	mov    %al,(%edx)
    a062:	e9 ca 02 00 00       	jmp    a331 <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    a067:	8b 55 0c             	mov    0xc(%ebp),%edx
    a06a:	89 d0                	mov    %edx,%eax
    a06c:	01 c0                	add    %eax,%eax
    a06e:	01 d0                	add    %edx,%eax
    a070:	01 c0                	add    %eax,%eax
    a072:	89 c2                	mov    %eax,%edx
    a074:	8b 45 08             	mov    0x8(%ebp),%eax
    a077:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a07a:	8b 55 0c             	mov    0xc(%ebp),%edx
    a07d:	89 d0                	mov    %edx,%eax
    a07f:	01 c0                	add    %eax,%eax
    a081:	01 d0                	add    %edx,%eax
    a083:	01 c0                	add    %eax,%eax
    a085:	8d 50 01             	lea    0x1(%eax),%edx
    a088:	8b 45 08             	mov    0x8(%ebp),%eax
    a08b:	01 d0                	add    %edx,%eax
    a08d:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a091:	88 10                	mov    %dl,(%eax)
    a093:	0f b6 00             	movzbl (%eax),%eax
    a096:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    a098:	8b 55 0c             	mov    0xc(%ebp),%edx
    a09b:	89 d0                	mov    %edx,%eax
    a09d:	01 c0                	add    %eax,%eax
    a09f:	01 d0                	add    %edx,%eax
    a0a1:	01 c0                	add    %eax,%eax
    a0a3:	8d 50 02             	lea    0x2(%eax),%edx
    a0a6:	8b 45 08             	mov    0x8(%ebp),%eax
    a0a9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a0ac:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0af:	89 d0                	mov    %edx,%eax
    a0b1:	01 c0                	add    %eax,%eax
    a0b3:	01 d0                	add    %edx,%eax
    a0b5:	01 c0                	add    %eax,%eax
    a0b7:	8d 50 03             	lea    0x3(%eax),%edx
    a0ba:	8b 45 08             	mov    0x8(%ebp),%eax
    a0bd:	01 d0                	add    %edx,%eax
    a0bf:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a0c3:	88 10                	mov    %dl,(%eax)
    a0c5:	0f b6 00             	movzbl (%eax),%eax
    a0c8:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    a0ca:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0cd:	89 d0                	mov    %edx,%eax
    a0cf:	01 c0                	add    %eax,%eax
    a0d1:	01 d0                	add    %edx,%eax
    a0d3:	01 c0                	add    %eax,%eax
    a0d5:	8d 50 04             	lea    0x4(%eax),%edx
    a0d8:	8b 45 08             	mov    0x8(%ebp),%eax
    a0db:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a0de:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0e1:	89 d0                	mov    %edx,%eax
    a0e3:	01 c0                	add    %eax,%eax
    a0e5:	01 d0                	add    %edx,%eax
    a0e7:	01 c0                	add    %eax,%eax
    a0e9:	8d 50 05             	lea    0x5(%eax),%edx
    a0ec:	8b 45 08             	mov    0x8(%ebp),%eax
    a0ef:	01 d0                	add    %edx,%eax
    a0f1:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a0f5:	88 10                	mov    %dl,(%eax)
    a0f7:	0f b6 00             	movzbl (%eax),%eax
    a0fa:	88 01                	mov    %al,(%ecx)
    a0fc:	e9 30 02 00 00       	jmp    a331 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a101:	8b 45 10             	mov    0x10(%ebp),%eax
    a104:	8b 00                	mov    (%eax),%eax
    a106:	83 f8 03             	cmp    $0x3,%eax
    a109:	75 6d                	jne    a178 <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    a10b:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    a10f:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    a113:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a117:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a11b:	53                   	push   %ebx
    a11c:	51                   	push   %ecx
    a11d:	52                   	push   %edx
    a11e:	50                   	push   %eax
    a11f:	ff 75 14             	pushl  0x14(%ebp)
    a122:	e8 fd fb ff ff       	call   9d24 <color_tree_get>
    a127:	83 c4 14             	add    $0x14,%esp
    a12a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    a12d:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a131:	79 0a                	jns    a13d <rgba8ToPixel+0x211>
    a133:	b8 52 00 00 00       	mov    $0x52,%eax
    a138:	e9 f9 01 00 00       	jmp    a336 <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    a13d:	8b 45 10             	mov    0x10(%ebp),%eax
    a140:	8b 40 04             	mov    0x4(%eax),%eax
    a143:	83 f8 08             	cmp    $0x8,%eax
    a146:	75 12                	jne    a15a <rgba8ToPixel+0x22e>
    a148:	8b 55 0c             	mov    0xc(%ebp),%edx
    a14b:	8b 45 08             	mov    0x8(%ebp),%eax
    a14e:	01 d0                	add    %edx,%eax
    a150:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a153:	88 10                	mov    %dl,(%eax)
    a155:	e9 d7 01 00 00       	jmp    a331 <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    a15a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a15d:	8b 45 10             	mov    0x10(%ebp),%eax
    a160:	8b 40 04             	mov    0x4(%eax),%eax
    a163:	52                   	push   %edx
    a164:	50                   	push   %eax
    a165:	ff 75 0c             	pushl  0xc(%ebp)
    a168:	ff 75 08             	pushl  0x8(%ebp)
    a16b:	e8 ae fa ff ff       	call   9c1e <addColorBits>
    a170:	83 c4 10             	add    $0x10,%esp
    a173:	e9 b9 01 00 00       	jmp    a331 <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a178:	8b 45 10             	mov    0x10(%ebp),%eax
    a17b:	8b 00                	mov    (%eax),%eax
    a17d:	83 f8 04             	cmp    $0x4,%eax
    a180:	0f 85 9f 00 00 00    	jne    a225 <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a186:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a18a:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    a18d:	8b 45 10             	mov    0x10(%ebp),%eax
    a190:	8b 40 04             	mov    0x4(%eax),%eax
    a193:	83 f8 08             	cmp    $0x8,%eax
    a196:	75 2a                	jne    a1c2 <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    a198:	8b 45 0c             	mov    0xc(%ebp),%eax
    a19b:	01 c0                	add    %eax,%eax
    a19d:	89 c2                	mov    %eax,%edx
    a19f:	8b 45 08             	mov    0x8(%ebp),%eax
    a1a2:	01 c2                	add    %eax,%edx
    a1a4:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    a1a8:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    a1aa:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1ad:	01 c0                	add    %eax,%eax
    a1af:	8d 50 01             	lea    0x1(%eax),%edx
    a1b2:	8b 45 08             	mov    0x8(%ebp),%eax
    a1b5:	01 c2                	add    %eax,%edx
    a1b7:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a1bb:	88 02                	mov    %al,(%edx)
    a1bd:	e9 6f 01 00 00       	jmp    a331 <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    a1c2:	8b 45 10             	mov    0x10(%ebp),%eax
    a1c5:	8b 40 04             	mov    0x4(%eax),%eax
    a1c8:	83 f8 10             	cmp    $0x10,%eax
    a1cb:	0f 85 60 01 00 00    	jne    a331 <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    a1d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1d4:	c1 e0 02             	shl    $0x2,%eax
    a1d7:	89 c2                	mov    %eax,%edx
    a1d9:	8b 45 08             	mov    0x8(%ebp),%eax
    a1dc:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a1df:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1e2:	c1 e0 02             	shl    $0x2,%eax
    a1e5:	8d 50 01             	lea    0x1(%eax),%edx
    a1e8:	8b 45 08             	mov    0x8(%ebp),%eax
    a1eb:	01 d0                	add    %edx,%eax
    a1ed:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    a1f1:	88 10                	mov    %dl,(%eax)
    a1f3:	0f b6 00             	movzbl (%eax),%eax
    a1f6:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    a1f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a1fb:	c1 e0 02             	shl    $0x2,%eax
    a1fe:	8d 50 02             	lea    0x2(%eax),%edx
    a201:	8b 45 08             	mov    0x8(%ebp),%eax
    a204:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a207:	8b 45 0c             	mov    0xc(%ebp),%eax
    a20a:	c1 e0 02             	shl    $0x2,%eax
    a20d:	8d 50 03             	lea    0x3(%eax),%edx
    a210:	8b 45 08             	mov    0x8(%ebp),%eax
    a213:	01 d0                	add    %edx,%eax
    a215:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a219:	88 10                	mov    %dl,(%eax)
    a21b:	0f b6 00             	movzbl (%eax),%eax
    a21e:	88 01                	mov    %al,(%ecx)
    a220:	e9 0c 01 00 00       	jmp    a331 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    a225:	8b 45 10             	mov    0x10(%ebp),%eax
    a228:	8b 00                	mov    (%eax),%eax
    a22a:	83 f8 06             	cmp    $0x6,%eax
    a22d:	0f 85 fe 00 00 00    	jne    a331 <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    a233:	8b 45 10             	mov    0x10(%ebp),%eax
    a236:	8b 40 04             	mov    0x4(%eax),%eax
    a239:	83 f8 08             	cmp    $0x8,%eax
    a23c:	75 54                	jne    a292 <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    a23e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a241:	c1 e0 02             	shl    $0x2,%eax
    a244:	89 c2                	mov    %eax,%edx
    a246:	8b 45 08             	mov    0x8(%ebp),%eax
    a249:	01 c2                	add    %eax,%edx
    a24b:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a24f:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    a251:	8b 45 0c             	mov    0xc(%ebp),%eax
    a254:	c1 e0 02             	shl    $0x2,%eax
    a257:	8d 50 01             	lea    0x1(%eax),%edx
    a25a:	8b 45 08             	mov    0x8(%ebp),%eax
    a25d:	01 c2                	add    %eax,%edx
    a25f:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a263:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    a265:	8b 45 0c             	mov    0xc(%ebp),%eax
    a268:	c1 e0 02             	shl    $0x2,%eax
    a26b:	8d 50 02             	lea    0x2(%eax),%edx
    a26e:	8b 45 08             	mov    0x8(%ebp),%eax
    a271:	01 c2                	add    %eax,%edx
    a273:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a277:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    a279:	8b 45 0c             	mov    0xc(%ebp),%eax
    a27c:	c1 e0 02             	shl    $0x2,%eax
    a27f:	8d 50 03             	lea    0x3(%eax),%edx
    a282:	8b 45 08             	mov    0x8(%ebp),%eax
    a285:	01 c2                	add    %eax,%edx
    a287:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a28b:	88 02                	mov    %al,(%edx)
    a28d:	e9 9f 00 00 00       	jmp    a331 <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    a292:	8b 45 0c             	mov    0xc(%ebp),%eax
    a295:	c1 e0 03             	shl    $0x3,%eax
    a298:	89 c2                	mov    %eax,%edx
    a29a:	8b 45 08             	mov    0x8(%ebp),%eax
    a29d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a2a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2a3:	c1 e0 03             	shl    $0x3,%eax
    a2a6:	8d 50 01             	lea    0x1(%eax),%edx
    a2a9:	8b 45 08             	mov    0x8(%ebp),%eax
    a2ac:	01 d0                	add    %edx,%eax
    a2ae:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a2b2:	88 10                	mov    %dl,(%eax)
    a2b4:	0f b6 00             	movzbl (%eax),%eax
    a2b7:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    a2b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2bc:	c1 e0 03             	shl    $0x3,%eax
    a2bf:	8d 50 02             	lea    0x2(%eax),%edx
    a2c2:	8b 45 08             	mov    0x8(%ebp),%eax
    a2c5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a2c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2cb:	c1 e0 03             	shl    $0x3,%eax
    a2ce:	8d 50 03             	lea    0x3(%eax),%edx
    a2d1:	8b 45 08             	mov    0x8(%ebp),%eax
    a2d4:	01 d0                	add    %edx,%eax
    a2d6:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a2da:	88 10                	mov    %dl,(%eax)
    a2dc:	0f b6 00             	movzbl (%eax),%eax
    a2df:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    a2e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2e4:	c1 e0 03             	shl    $0x3,%eax
    a2e7:	8d 50 04             	lea    0x4(%eax),%edx
    a2ea:	8b 45 08             	mov    0x8(%ebp),%eax
    a2ed:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a2f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2f3:	c1 e0 03             	shl    $0x3,%eax
    a2f6:	8d 50 05             	lea    0x5(%eax),%edx
    a2f9:	8b 45 08             	mov    0x8(%ebp),%eax
    a2fc:	01 d0                	add    %edx,%eax
    a2fe:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a302:	88 10                	mov    %dl,(%eax)
    a304:	0f b6 00             	movzbl (%eax),%eax
    a307:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    a309:	8b 45 0c             	mov    0xc(%ebp),%eax
    a30c:	c1 e0 03             	shl    $0x3,%eax
    a30f:	8d 50 06             	lea    0x6(%eax),%edx
    a312:	8b 45 08             	mov    0x8(%ebp),%eax
    a315:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a318:	8b 45 0c             	mov    0xc(%ebp),%eax
    a31b:	c1 e0 03             	shl    $0x3,%eax
    a31e:	8d 50 07             	lea    0x7(%eax),%edx
    a321:	8b 45 08             	mov    0x8(%ebp),%eax
    a324:	01 d0                	add    %edx,%eax
    a326:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a32a:	88 10                	mov    %dl,(%eax)
    a32c:	0f b6 00             	movzbl (%eax),%eax
    a32f:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    a331:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a336:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a339:	c9                   	leave  
    a33a:	c3                   	ret    

0000a33b <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    a33b:	55                   	push   %ebp
    a33c:	89 e5                	mov    %esp,%ebp
    a33e:	53                   	push   %ebx
    a33f:	83 ec 20             	sub    $0x20,%esp
    a342:	8b 5d 14             	mov    0x14(%ebp),%ebx
    a345:	8b 4d 18             	mov    0x18(%ebp),%ecx
    a348:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a34b:	8b 45 20             	mov    0x20(%ebp),%eax
    a34e:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    a352:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    a356:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    a35a:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a35e:	8b 45 10             	mov    0x10(%ebp),%eax
    a361:	8b 00                	mov    (%eax),%eax
    a363:	85 c0                	test   %eax,%eax
    a365:	75 36                	jne    a39d <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a367:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a36b:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    a36f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a372:	01 c0                	add    %eax,%eax
    a374:	89 c2                	mov    %eax,%edx
    a376:	8b 45 08             	mov    0x8(%ebp),%eax
    a379:	01 d0                	add    %edx,%eax
    a37b:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a37f:	66 c1 ea 08          	shr    $0x8,%dx
    a383:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    a385:	8b 45 0c             	mov    0xc(%ebp),%eax
    a388:	01 c0                	add    %eax,%eax
    a38a:	8d 50 01             	lea    0x1(%eax),%edx
    a38d:	8b 45 08             	mov    0x8(%ebp),%eax
    a390:	01 d0                	add    %edx,%eax
    a392:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a396:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a398:	e9 df 01 00 00       	jmp    a57c <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    a39d:	8b 45 10             	mov    0x10(%ebp),%eax
    a3a0:	8b 00                	mov    (%eax),%eax
    a3a2:	83 f8 02             	cmp    $0x2,%eax
    a3a5:	0f 85 a6 00 00 00    	jne    a451 <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    a3ab:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3ae:	89 d0                	mov    %edx,%eax
    a3b0:	01 c0                	add    %eax,%eax
    a3b2:	01 d0                	add    %edx,%eax
    a3b4:	01 c0                	add    %eax,%eax
    a3b6:	89 c2                	mov    %eax,%edx
    a3b8:	8b 45 08             	mov    0x8(%ebp),%eax
    a3bb:	01 d0                	add    %edx,%eax
    a3bd:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a3c1:	66 c1 ea 08          	shr    $0x8,%dx
    a3c5:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    a3c7:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3ca:	89 d0                	mov    %edx,%eax
    a3cc:	01 c0                	add    %eax,%eax
    a3ce:	01 d0                	add    %edx,%eax
    a3d0:	01 c0                	add    %eax,%eax
    a3d2:	8d 50 01             	lea    0x1(%eax),%edx
    a3d5:	8b 45 08             	mov    0x8(%ebp),%eax
    a3d8:	01 d0                	add    %edx,%eax
    a3da:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a3de:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    a3e0:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3e3:	89 d0                	mov    %edx,%eax
    a3e5:	01 c0                	add    %eax,%eax
    a3e7:	01 d0                	add    %edx,%eax
    a3e9:	01 c0                	add    %eax,%eax
    a3eb:	8d 50 02             	lea    0x2(%eax),%edx
    a3ee:	8b 45 08             	mov    0x8(%ebp),%eax
    a3f1:	01 d0                	add    %edx,%eax
    a3f3:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a3f7:	66 c1 ea 08          	shr    $0x8,%dx
    a3fb:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    a3fd:	8b 55 0c             	mov    0xc(%ebp),%edx
    a400:	89 d0                	mov    %edx,%eax
    a402:	01 c0                	add    %eax,%eax
    a404:	01 d0                	add    %edx,%eax
    a406:	01 c0                	add    %eax,%eax
    a408:	8d 50 03             	lea    0x3(%eax),%edx
    a40b:	8b 45 08             	mov    0x8(%ebp),%eax
    a40e:	01 d0                	add    %edx,%eax
    a410:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a414:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    a416:	8b 55 0c             	mov    0xc(%ebp),%edx
    a419:	89 d0                	mov    %edx,%eax
    a41b:	01 c0                	add    %eax,%eax
    a41d:	01 d0                	add    %edx,%eax
    a41f:	01 c0                	add    %eax,%eax
    a421:	8d 50 04             	lea    0x4(%eax),%edx
    a424:	8b 45 08             	mov    0x8(%ebp),%eax
    a427:	01 d0                	add    %edx,%eax
    a429:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a42d:	66 c1 ea 08          	shr    $0x8,%dx
    a431:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    a433:	8b 55 0c             	mov    0xc(%ebp),%edx
    a436:	89 d0                	mov    %edx,%eax
    a438:	01 c0                	add    %eax,%eax
    a43a:	01 d0                	add    %edx,%eax
    a43c:	01 c0                	add    %eax,%eax
    a43e:	8d 50 05             	lea    0x5(%eax),%edx
    a441:	8b 45 08             	mov    0x8(%ebp),%eax
    a444:	01 d0                	add    %edx,%eax
    a446:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a44a:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a44c:	e9 2b 01 00 00       	jmp    a57c <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a451:	8b 45 10             	mov    0x10(%ebp),%eax
    a454:	8b 00                	mov    (%eax),%eax
    a456:	83 f8 04             	cmp    $0x4,%eax
    a459:	75 64                	jne    a4bf <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a45b:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a45f:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    a463:	8b 45 0c             	mov    0xc(%ebp),%eax
    a466:	c1 e0 02             	shl    $0x2,%eax
    a469:	89 c2                	mov    %eax,%edx
    a46b:	8b 45 08             	mov    0x8(%ebp),%eax
    a46e:	01 d0                	add    %edx,%eax
    a470:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a474:	66 c1 ea 08          	shr    $0x8,%dx
    a478:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    a47a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a47d:	c1 e0 02             	shl    $0x2,%eax
    a480:	8d 50 01             	lea    0x1(%eax),%edx
    a483:	8b 45 08             	mov    0x8(%ebp),%eax
    a486:	01 d0                	add    %edx,%eax
    a488:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a48c:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    a48e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a491:	c1 e0 02             	shl    $0x2,%eax
    a494:	8d 50 02             	lea    0x2(%eax),%edx
    a497:	8b 45 08             	mov    0x8(%ebp),%eax
    a49a:	01 d0                	add    %edx,%eax
    a49c:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a4a0:	66 c1 ea 08          	shr    $0x8,%dx
    a4a4:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    a4a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4a9:	c1 e0 02             	shl    $0x2,%eax
    a4ac:	8d 50 03             	lea    0x3(%eax),%edx
    a4af:	8b 45 08             	mov    0x8(%ebp),%eax
    a4b2:	01 d0                	add    %edx,%eax
    a4b4:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a4b8:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a4ba:	e9 bd 00 00 00       	jmp    a57c <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    a4bf:	8b 45 10             	mov    0x10(%ebp),%eax
    a4c2:	8b 00                	mov    (%eax),%eax
    a4c4:	83 f8 06             	cmp    $0x6,%eax
    a4c7:	0f 85 af 00 00 00    	jne    a57c <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    a4cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4d0:	c1 e0 03             	shl    $0x3,%eax
    a4d3:	89 c2                	mov    %eax,%edx
    a4d5:	8b 45 08             	mov    0x8(%ebp),%eax
    a4d8:	01 d0                	add    %edx,%eax
    a4da:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a4de:	66 c1 ea 08          	shr    $0x8,%dx
    a4e2:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    a4e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4e7:	c1 e0 03             	shl    $0x3,%eax
    a4ea:	8d 50 01             	lea    0x1(%eax),%edx
    a4ed:	8b 45 08             	mov    0x8(%ebp),%eax
    a4f0:	01 d0                	add    %edx,%eax
    a4f2:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a4f6:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    a4f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4fb:	c1 e0 03             	shl    $0x3,%eax
    a4fe:	8d 50 02             	lea    0x2(%eax),%edx
    a501:	8b 45 08             	mov    0x8(%ebp),%eax
    a504:	01 d0                	add    %edx,%eax
    a506:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a50a:	66 c1 ea 08          	shr    $0x8,%dx
    a50e:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    a510:	8b 45 0c             	mov    0xc(%ebp),%eax
    a513:	c1 e0 03             	shl    $0x3,%eax
    a516:	8d 50 03             	lea    0x3(%eax),%edx
    a519:	8b 45 08             	mov    0x8(%ebp),%eax
    a51c:	01 d0                	add    %edx,%eax
    a51e:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a522:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    a524:	8b 45 0c             	mov    0xc(%ebp),%eax
    a527:	c1 e0 03             	shl    $0x3,%eax
    a52a:	8d 50 04             	lea    0x4(%eax),%edx
    a52d:	8b 45 08             	mov    0x8(%ebp),%eax
    a530:	01 d0                	add    %edx,%eax
    a532:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a536:	66 c1 ea 08          	shr    $0x8,%dx
    a53a:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    a53c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a53f:	c1 e0 03             	shl    $0x3,%eax
    a542:	8d 50 05             	lea    0x5(%eax),%edx
    a545:	8b 45 08             	mov    0x8(%ebp),%eax
    a548:	01 d0                	add    %edx,%eax
    a54a:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a54e:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    a550:	8b 45 0c             	mov    0xc(%ebp),%eax
    a553:	c1 e0 03             	shl    $0x3,%eax
    a556:	8d 50 06             	lea    0x6(%eax),%edx
    a559:	8b 45 08             	mov    0x8(%ebp),%eax
    a55c:	01 d0                	add    %edx,%eax
    a55e:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a562:	66 c1 ea 08          	shr    $0x8,%dx
    a566:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    a568:	8b 45 0c             	mov    0xc(%ebp),%eax
    a56b:	c1 e0 03             	shl    $0x3,%eax
    a56e:	8d 50 07             	lea    0x7(%eax),%edx
    a571:	8b 45 08             	mov    0x8(%ebp),%eax
    a574:	01 d0                	add    %edx,%eax
    a576:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a57a:	88 10                	mov    %dl,(%eax)
  }
}
    a57c:	90                   	nop
    a57d:	83 c4 20             	add    $0x20,%esp
    a580:	5b                   	pop    %ebx
    a581:	5d                   	pop    %ebp
    a582:	c3                   	ret    

0000a583 <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    a583:	55                   	push   %ebp
    a584:	89 e5                	mov    %esp,%ebp
    a586:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    a589:	8b 45 20             	mov    0x20(%ebp),%eax
    a58c:	8b 00                	mov    (%eax),%eax
    a58e:	85 c0                	test   %eax,%eax
    a590:	0f 85 8c 01 00 00    	jne    a722 <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    a596:	8b 45 20             	mov    0x20(%ebp),%eax
    a599:	8b 40 04             	mov    0x4(%eax),%eax
    a59c:	83 f8 08             	cmp    $0x8,%eax
    a59f:	75 59                	jne    a5fa <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    a5a1:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a5a4:	8b 45 18             	mov    0x18(%ebp),%eax
    a5a7:	01 d0                	add    %edx,%eax
    a5a9:	0f b6 10             	movzbl (%eax),%edx
    a5ac:	8b 45 10             	mov    0x10(%ebp),%eax
    a5af:	88 10                	mov    %dl,(%eax)
    a5b1:	8b 45 10             	mov    0x10(%ebp),%eax
    a5b4:	0f b6 10             	movzbl (%eax),%edx
    a5b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5ba:	88 10                	mov    %dl,(%eax)
    a5bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5bf:	0f b6 10             	movzbl (%eax),%edx
    a5c2:	8b 45 08             	mov    0x8(%ebp),%eax
    a5c5:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    a5c7:	8b 45 20             	mov    0x20(%ebp),%eax
    a5ca:	8b 40 10             	mov    0x10(%eax),%eax
    a5cd:	85 c0                	test   %eax,%eax
    a5cf:	74 1e                	je     a5ef <getPixelColorRGBA8+0x6c>
    a5d1:	8b 45 08             	mov    0x8(%ebp),%eax
    a5d4:	0f b6 00             	movzbl (%eax),%eax
    a5d7:	0f b6 d0             	movzbl %al,%edx
    a5da:	8b 45 20             	mov    0x20(%ebp),%eax
    a5dd:	8b 40 14             	mov    0x14(%eax),%eax
    a5e0:	39 c2                	cmp    %eax,%edx
    a5e2:	75 0b                	jne    a5ef <getPixelColorRGBA8+0x6c>
    a5e4:	8b 45 14             	mov    0x14(%ebp),%eax
    a5e7:	c6 00 00             	movb   $0x0,(%eax)
    a5ea:	e9 5e 05 00 00       	jmp    ab4d <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a5ef:	8b 45 14             	mov    0x14(%ebp),%eax
    a5f2:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a5f5:	e9 53 05 00 00       	jmp    ab4d <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    a5fa:	8b 45 20             	mov    0x20(%ebp),%eax
    a5fd:	8b 40 04             	mov    0x4(%eax),%eax
    a600:	83 f8 10             	cmp    $0x10,%eax
    a603:	0f 85 80 00 00 00    	jne    a689 <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    a609:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a60c:	01 c0                	add    %eax,%eax
    a60e:	89 c2                	mov    %eax,%edx
    a610:	8b 45 18             	mov    0x18(%ebp),%eax
    a613:	01 d0                	add    %edx,%eax
    a615:	0f b6 10             	movzbl (%eax),%edx
    a618:	8b 45 10             	mov    0x10(%ebp),%eax
    a61b:	88 10                	mov    %dl,(%eax)
    a61d:	8b 45 10             	mov    0x10(%ebp),%eax
    a620:	0f b6 10             	movzbl (%eax),%edx
    a623:	8b 45 0c             	mov    0xc(%ebp),%eax
    a626:	88 10                	mov    %dl,(%eax)
    a628:	8b 45 0c             	mov    0xc(%ebp),%eax
    a62b:	0f b6 10             	movzbl (%eax),%edx
    a62e:	8b 45 08             	mov    0x8(%ebp),%eax
    a631:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    a633:	8b 45 20             	mov    0x20(%ebp),%eax
    a636:	8b 40 10             	mov    0x10(%eax),%eax
    a639:	85 c0                	test   %eax,%eax
    a63b:	74 41                	je     a67e <getPixelColorRGBA8+0xfb>
    a63d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a640:	01 c0                	add    %eax,%eax
    a642:	89 c2                	mov    %eax,%edx
    a644:	8b 45 18             	mov    0x18(%ebp),%eax
    a647:	01 d0                	add    %edx,%eax
    a649:	0f b6 00             	movzbl (%eax),%eax
    a64c:	0f b6 c0             	movzbl %al,%eax
    a64f:	c1 e0 08             	shl    $0x8,%eax
    a652:	89 c2                	mov    %eax,%edx
    a654:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a657:	01 c0                	add    %eax,%eax
    a659:	8d 48 01             	lea    0x1(%eax),%ecx
    a65c:	8b 45 18             	mov    0x18(%ebp),%eax
    a65f:	01 c8                	add    %ecx,%eax
    a661:	0f b6 00             	movzbl (%eax),%eax
    a664:	0f b6 c0             	movzbl %al,%eax
    a667:	01 c2                	add    %eax,%edx
    a669:	8b 45 20             	mov    0x20(%ebp),%eax
    a66c:	8b 40 14             	mov    0x14(%eax),%eax
    a66f:	39 c2                	cmp    %eax,%edx
    a671:	75 0b                	jne    a67e <getPixelColorRGBA8+0xfb>
    a673:	8b 45 14             	mov    0x14(%ebp),%eax
    a676:	c6 00 00             	movb   $0x0,(%eax)
    a679:	e9 cf 04 00 00       	jmp    ab4d <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a67e:	8b 45 14             	mov    0x14(%ebp),%eax
    a681:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a684:	e9 c4 04 00 00       	jmp    ab4d <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    a689:	8b 45 20             	mov    0x20(%ebp),%eax
    a68c:	8b 40 04             	mov    0x4(%eax),%eax
    a68f:	ba 01 00 00 00       	mov    $0x1,%edx
    a694:	89 c1                	mov    %eax,%ecx
    a696:	d3 e2                	shl    %cl,%edx
    a698:	89 d0                	mov    %edx,%eax
    a69a:	83 e8 01             	sub    $0x1,%eax
    a69d:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    a6a0:	8b 45 20             	mov    0x20(%ebp),%eax
    a6a3:	8b 50 04             	mov    0x4(%eax),%edx
    a6a6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a6a9:	0f af c2             	imul   %edx,%eax
    a6ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a6af:	8b 45 20             	mov    0x20(%ebp),%eax
    a6b2:	8b 40 04             	mov    0x4(%eax),%eax
    a6b5:	50                   	push   %eax
    a6b6:	ff 75 18             	pushl  0x18(%ebp)
    a6b9:	8d 45 f0             	lea    -0x10(%ebp),%eax
    a6bc:	50                   	push   %eax
    a6bd:	e8 06 db ff ff       	call   81c8 <readBitsFromReversedStream>
    a6c2:	83 c4 0c             	add    $0xc,%esp
    a6c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    a6c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a6cb:	89 d0                	mov    %edx,%eax
    a6cd:	c1 e0 08             	shl    $0x8,%eax
    a6d0:	29 d0                	sub    %edx,%eax
    a6d2:	ba 00 00 00 00       	mov    $0x0,%edx
    a6d7:	f7 75 f8             	divl   -0x8(%ebp)
    a6da:	89 c2                	mov    %eax,%edx
    a6dc:	8b 45 10             	mov    0x10(%ebp),%eax
    a6df:	88 10                	mov    %dl,(%eax)
    a6e1:	8b 45 10             	mov    0x10(%ebp),%eax
    a6e4:	0f b6 10             	movzbl (%eax),%edx
    a6e7:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6ea:	88 10                	mov    %dl,(%eax)
    a6ec:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6ef:	0f b6 10             	movzbl (%eax),%edx
    a6f2:	8b 45 08             	mov    0x8(%ebp),%eax
    a6f5:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    a6f7:	8b 45 20             	mov    0x20(%ebp),%eax
    a6fa:	8b 40 10             	mov    0x10(%eax),%eax
    a6fd:	85 c0                	test   %eax,%eax
    a6ff:	74 16                	je     a717 <getPixelColorRGBA8+0x194>
    a701:	8b 45 20             	mov    0x20(%ebp),%eax
    a704:	8b 40 14             	mov    0x14(%eax),%eax
    a707:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a70a:	75 0b                	jne    a717 <getPixelColorRGBA8+0x194>
    a70c:	8b 45 14             	mov    0x14(%ebp),%eax
    a70f:	c6 00 00             	movb   $0x0,(%eax)
    a712:	e9 36 04 00 00       	jmp    ab4d <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a717:	8b 45 14             	mov    0x14(%ebp),%eax
    a71a:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a71d:	e9 2b 04 00 00       	jmp    ab4d <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    a722:	8b 45 20             	mov    0x20(%ebp),%eax
    a725:	8b 00                	mov    (%eax),%eax
    a727:	83 f8 02             	cmp    $0x2,%eax
    a72a:	0f 85 f5 01 00 00    	jne    a925 <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    a730:	8b 45 20             	mov    0x20(%ebp),%eax
    a733:	8b 40 04             	mov    0x4(%eax),%eax
    a736:	83 f8 08             	cmp    $0x8,%eax
    a739:	0f 85 a3 00 00 00    	jne    a7e2 <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    a73f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a742:	89 d0                	mov    %edx,%eax
    a744:	01 c0                	add    %eax,%eax
    a746:	01 d0                	add    %edx,%eax
    a748:	89 c2                	mov    %eax,%edx
    a74a:	8b 45 18             	mov    0x18(%ebp),%eax
    a74d:	01 d0                	add    %edx,%eax
    a74f:	0f b6 10             	movzbl (%eax),%edx
    a752:	8b 45 08             	mov    0x8(%ebp),%eax
    a755:	88 10                	mov    %dl,(%eax)
    a757:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a75a:	89 d0                	mov    %edx,%eax
    a75c:	01 c0                	add    %eax,%eax
    a75e:	01 d0                	add    %edx,%eax
    a760:	8d 50 01             	lea    0x1(%eax),%edx
    a763:	8b 45 18             	mov    0x18(%ebp),%eax
    a766:	01 d0                	add    %edx,%eax
    a768:	0f b6 10             	movzbl (%eax),%edx
    a76b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a76e:	88 10                	mov    %dl,(%eax)
    a770:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a773:	89 d0                	mov    %edx,%eax
    a775:	01 c0                	add    %eax,%eax
    a777:	01 d0                	add    %edx,%eax
    a779:	8d 50 02             	lea    0x2(%eax),%edx
    a77c:	8b 45 18             	mov    0x18(%ebp),%eax
    a77f:	01 d0                	add    %edx,%eax
    a781:	0f b6 10             	movzbl (%eax),%edx
    a784:	8b 45 10             	mov    0x10(%ebp),%eax
    a787:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    a789:	8b 45 20             	mov    0x20(%ebp),%eax
    a78c:	8b 40 10             	mov    0x10(%eax),%eax
    a78f:	85 c0                	test   %eax,%eax
    a791:	74 44                	je     a7d7 <getPixelColorRGBA8+0x254>
    a793:	8b 45 08             	mov    0x8(%ebp),%eax
    a796:	0f b6 00             	movzbl (%eax),%eax
    a799:	0f b6 d0             	movzbl %al,%edx
    a79c:	8b 45 20             	mov    0x20(%ebp),%eax
    a79f:	8b 40 14             	mov    0x14(%eax),%eax
    a7a2:	39 c2                	cmp    %eax,%edx
    a7a4:	75 31                	jne    a7d7 <getPixelColorRGBA8+0x254>
    a7a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7a9:	0f b6 00             	movzbl (%eax),%eax
    a7ac:	0f b6 d0             	movzbl %al,%edx
    a7af:	8b 45 20             	mov    0x20(%ebp),%eax
    a7b2:	8b 40 18             	mov    0x18(%eax),%eax
    a7b5:	39 c2                	cmp    %eax,%edx
    a7b7:	75 1e                	jne    a7d7 <getPixelColorRGBA8+0x254>
    a7b9:	8b 45 10             	mov    0x10(%ebp),%eax
    a7bc:	0f b6 00             	movzbl (%eax),%eax
    a7bf:	0f b6 d0             	movzbl %al,%edx
    a7c2:	8b 45 20             	mov    0x20(%ebp),%eax
    a7c5:	8b 40 1c             	mov    0x1c(%eax),%eax
    a7c8:	39 c2                	cmp    %eax,%edx
    a7ca:	75 0b                	jne    a7d7 <getPixelColorRGBA8+0x254>
    a7cc:	8b 45 14             	mov    0x14(%ebp),%eax
    a7cf:	c6 00 00             	movb   $0x0,(%eax)
    a7d2:	e9 76 03 00 00       	jmp    ab4d <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a7d7:	8b 45 14             	mov    0x14(%ebp),%eax
    a7da:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a7dd:	e9 6b 03 00 00       	jmp    ab4d <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    a7e2:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a7e5:	89 d0                	mov    %edx,%eax
    a7e7:	01 c0                	add    %eax,%eax
    a7e9:	01 d0                	add    %edx,%eax
    a7eb:	01 c0                	add    %eax,%eax
    a7ed:	89 c2                	mov    %eax,%edx
    a7ef:	8b 45 18             	mov    0x18(%ebp),%eax
    a7f2:	01 d0                	add    %edx,%eax
    a7f4:	0f b6 10             	movzbl (%eax),%edx
    a7f7:	8b 45 08             	mov    0x8(%ebp),%eax
    a7fa:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    a7fc:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a7ff:	89 d0                	mov    %edx,%eax
    a801:	01 c0                	add    %eax,%eax
    a803:	01 d0                	add    %edx,%eax
    a805:	01 c0                	add    %eax,%eax
    a807:	8d 50 02             	lea    0x2(%eax),%edx
    a80a:	8b 45 18             	mov    0x18(%ebp),%eax
    a80d:	01 d0                	add    %edx,%eax
    a80f:	0f b6 10             	movzbl (%eax),%edx
    a812:	8b 45 0c             	mov    0xc(%ebp),%eax
    a815:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    a817:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a81a:	89 d0                	mov    %edx,%eax
    a81c:	01 c0                	add    %eax,%eax
    a81e:	01 d0                	add    %edx,%eax
    a820:	01 c0                	add    %eax,%eax
    a822:	8d 50 04             	lea    0x4(%eax),%edx
    a825:	8b 45 18             	mov    0x18(%ebp),%eax
    a828:	01 d0                	add    %edx,%eax
    a82a:	0f b6 10             	movzbl (%eax),%edx
    a82d:	8b 45 10             	mov    0x10(%ebp),%eax
    a830:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    a832:	8b 45 20             	mov    0x20(%ebp),%eax
    a835:	8b 40 10             	mov    0x10(%eax),%eax
    a838:	85 c0                	test   %eax,%eax
    a83a:	0f 84 da 00 00 00    	je     a91a <getPixelColorRGBA8+0x397>
    a840:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a843:	89 d0                	mov    %edx,%eax
    a845:	01 c0                	add    %eax,%eax
    a847:	01 d0                	add    %edx,%eax
    a849:	01 c0                	add    %eax,%eax
    a84b:	89 c2                	mov    %eax,%edx
    a84d:	8b 45 18             	mov    0x18(%ebp),%eax
    a850:	01 d0                	add    %edx,%eax
    a852:	0f b6 00             	movzbl (%eax),%eax
    a855:	0f b6 c0             	movzbl %al,%eax
    a858:	c1 e0 08             	shl    $0x8,%eax
    a85b:	89 c1                	mov    %eax,%ecx
    a85d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a860:	89 d0                	mov    %edx,%eax
    a862:	01 c0                	add    %eax,%eax
    a864:	01 d0                	add    %edx,%eax
    a866:	01 c0                	add    %eax,%eax
    a868:	8d 50 01             	lea    0x1(%eax),%edx
    a86b:	8b 45 18             	mov    0x18(%ebp),%eax
    a86e:	01 d0                	add    %edx,%eax
    a870:	0f b6 00             	movzbl (%eax),%eax
    a873:	0f b6 c0             	movzbl %al,%eax
    a876:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a879:	8b 45 20             	mov    0x20(%ebp),%eax
    a87c:	8b 40 14             	mov    0x14(%eax),%eax
    a87f:	39 c2                	cmp    %eax,%edx
    a881:	0f 85 93 00 00 00    	jne    a91a <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    a887:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a88a:	89 d0                	mov    %edx,%eax
    a88c:	01 c0                	add    %eax,%eax
    a88e:	01 d0                	add    %edx,%eax
    a890:	01 c0                	add    %eax,%eax
    a892:	8d 50 02             	lea    0x2(%eax),%edx
    a895:	8b 45 18             	mov    0x18(%ebp),%eax
    a898:	01 d0                	add    %edx,%eax
    a89a:	0f b6 00             	movzbl (%eax),%eax
    a89d:	0f b6 c0             	movzbl %al,%eax
    a8a0:	c1 e0 08             	shl    $0x8,%eax
    a8a3:	89 c1                	mov    %eax,%ecx
    a8a5:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8a8:	89 d0                	mov    %edx,%eax
    a8aa:	01 c0                	add    %eax,%eax
    a8ac:	01 d0                	add    %edx,%eax
    a8ae:	01 c0                	add    %eax,%eax
    a8b0:	8d 50 03             	lea    0x3(%eax),%edx
    a8b3:	8b 45 18             	mov    0x18(%ebp),%eax
    a8b6:	01 d0                	add    %edx,%eax
    a8b8:	0f b6 00             	movzbl (%eax),%eax
    a8bb:	0f b6 c0             	movzbl %al,%eax
    a8be:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a8c1:	8b 45 20             	mov    0x20(%ebp),%eax
    a8c4:	8b 40 18             	mov    0x18(%eax),%eax
    a8c7:	39 c2                	cmp    %eax,%edx
    a8c9:	75 4f                	jne    a91a <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    a8cb:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8ce:	89 d0                	mov    %edx,%eax
    a8d0:	01 c0                	add    %eax,%eax
    a8d2:	01 d0                	add    %edx,%eax
    a8d4:	01 c0                	add    %eax,%eax
    a8d6:	8d 50 04             	lea    0x4(%eax),%edx
    a8d9:	8b 45 18             	mov    0x18(%ebp),%eax
    a8dc:	01 d0                	add    %edx,%eax
    a8de:	0f b6 00             	movzbl (%eax),%eax
    a8e1:	0f b6 c0             	movzbl %al,%eax
    a8e4:	c1 e0 08             	shl    $0x8,%eax
    a8e7:	89 c1                	mov    %eax,%ecx
    a8e9:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8ec:	89 d0                	mov    %edx,%eax
    a8ee:	01 c0                	add    %eax,%eax
    a8f0:	01 d0                	add    %edx,%eax
    a8f2:	01 c0                	add    %eax,%eax
    a8f4:	8d 50 05             	lea    0x5(%eax),%edx
    a8f7:	8b 45 18             	mov    0x18(%ebp),%eax
    a8fa:	01 d0                	add    %edx,%eax
    a8fc:	0f b6 00             	movzbl (%eax),%eax
    a8ff:	0f b6 c0             	movzbl %al,%eax
    a902:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a905:	8b 45 20             	mov    0x20(%ebp),%eax
    a908:	8b 40 1c             	mov    0x1c(%eax),%eax
    a90b:	39 c2                	cmp    %eax,%edx
    a90d:	75 0b                	jne    a91a <getPixelColorRGBA8+0x397>
    a90f:	8b 45 14             	mov    0x14(%ebp),%eax
    a912:	c6 00 00             	movb   $0x0,(%eax)
    a915:	e9 33 02 00 00       	jmp    ab4d <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a91a:	8b 45 14             	mov    0x14(%ebp),%eax
    a91d:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a920:	e9 28 02 00 00       	jmp    ab4d <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a925:	8b 45 20             	mov    0x20(%ebp),%eax
    a928:	8b 00                	mov    (%eax),%eax
    a92a:	83 f8 03             	cmp    $0x3,%eax
    a92d:	0f 85 ac 00 00 00    	jne    a9df <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    a933:	8b 45 20             	mov    0x20(%ebp),%eax
    a936:	8b 40 04             	mov    0x4(%eax),%eax
    a939:	83 f8 08             	cmp    $0x8,%eax
    a93c:	75 13                	jne    a951 <getPixelColorRGBA8+0x3ce>
    a93e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a941:	8b 45 18             	mov    0x18(%ebp),%eax
    a944:	01 d0                	add    %edx,%eax
    a946:	0f b6 00             	movzbl (%eax),%eax
    a949:	0f b6 c0             	movzbl %al,%eax
    a94c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    a94f:	eb 28                	jmp    a979 <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    a951:	8b 45 20             	mov    0x20(%ebp),%eax
    a954:	8b 50 04             	mov    0x4(%eax),%edx
    a957:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a95a:	0f af c2             	imul   %edx,%eax
    a95d:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a960:	8b 45 20             	mov    0x20(%ebp),%eax
    a963:	8b 40 04             	mov    0x4(%eax),%eax
    a966:	50                   	push   %eax
    a967:	ff 75 18             	pushl  0x18(%ebp)
    a96a:	8d 45 ec             	lea    -0x14(%ebp),%eax
    a96d:	50                   	push   %eax
    a96e:	e8 55 d8 ff ff       	call   81c8 <readBitsFromReversedStream>
    a973:	83 c4 0c             	add    $0xc,%esp
    a976:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    a979:	8b 45 20             	mov    0x20(%ebp),%eax
    a97c:	8b 40 08             	mov    0x8(%eax),%eax
    a97f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a982:	c1 e2 02             	shl    $0x2,%edx
    a985:	01 d0                	add    %edx,%eax
    a987:	0f b6 10             	movzbl (%eax),%edx
    a98a:	8b 45 08             	mov    0x8(%ebp),%eax
    a98d:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    a98f:	8b 45 20             	mov    0x20(%ebp),%eax
    a992:	8b 40 08             	mov    0x8(%eax),%eax
    a995:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a998:	c1 e2 02             	shl    $0x2,%edx
    a99b:	83 c2 01             	add    $0x1,%edx
    a99e:	01 d0                	add    %edx,%eax
    a9a0:	0f b6 10             	movzbl (%eax),%edx
    a9a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9a6:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    a9a8:	8b 45 20             	mov    0x20(%ebp),%eax
    a9ab:	8b 40 08             	mov    0x8(%eax),%eax
    a9ae:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a9b1:	c1 e2 02             	shl    $0x2,%edx
    a9b4:	83 c2 02             	add    $0x2,%edx
    a9b7:	01 d0                	add    %edx,%eax
    a9b9:	0f b6 10             	movzbl (%eax),%edx
    a9bc:	8b 45 10             	mov    0x10(%ebp),%eax
    a9bf:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    a9c1:	8b 45 20             	mov    0x20(%ebp),%eax
    a9c4:	8b 40 08             	mov    0x8(%eax),%eax
    a9c7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    a9ca:	c1 e2 02             	shl    $0x2,%edx
    a9cd:	83 c2 03             	add    $0x3,%edx
    a9d0:	01 d0                	add    %edx,%eax
    a9d2:	0f b6 10             	movzbl (%eax),%edx
    a9d5:	8b 45 14             	mov    0x14(%ebp),%eax
    a9d8:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a9da:	e9 6e 01 00 00       	jmp    ab4d <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a9df:	8b 45 20             	mov    0x20(%ebp),%eax
    a9e2:	8b 00                	mov    (%eax),%eax
    a9e4:	83 f8 04             	cmp    $0x4,%eax
    a9e7:	0f 85 95 00 00 00    	jne    aa82 <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    a9ed:	8b 45 20             	mov    0x20(%ebp),%eax
    a9f0:	8b 40 04             	mov    0x4(%eax),%eax
    a9f3:	83 f8 08             	cmp    $0x8,%eax
    a9f6:	75 44                	jne    aa3c <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    a9f8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a9fb:	01 c0                	add    %eax,%eax
    a9fd:	89 c2                	mov    %eax,%edx
    a9ff:	8b 45 18             	mov    0x18(%ebp),%eax
    aa02:	01 d0                	add    %edx,%eax
    aa04:	0f b6 10             	movzbl (%eax),%edx
    aa07:	8b 45 10             	mov    0x10(%ebp),%eax
    aa0a:	88 10                	mov    %dl,(%eax)
    aa0c:	8b 45 10             	mov    0x10(%ebp),%eax
    aa0f:	0f b6 10             	movzbl (%eax),%edx
    aa12:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa15:	88 10                	mov    %dl,(%eax)
    aa17:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa1a:	0f b6 10             	movzbl (%eax),%edx
    aa1d:	8b 45 08             	mov    0x8(%ebp),%eax
    aa20:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    aa22:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa25:	01 c0                	add    %eax,%eax
    aa27:	8d 50 01             	lea    0x1(%eax),%edx
    aa2a:	8b 45 18             	mov    0x18(%ebp),%eax
    aa2d:	01 d0                	add    %edx,%eax
    aa2f:	0f b6 10             	movzbl (%eax),%edx
    aa32:	8b 45 14             	mov    0x14(%ebp),%eax
    aa35:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aa37:	e9 11 01 00 00       	jmp    ab4d <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    aa3c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa3f:	c1 e0 02             	shl    $0x2,%eax
    aa42:	89 c2                	mov    %eax,%edx
    aa44:	8b 45 18             	mov    0x18(%ebp),%eax
    aa47:	01 d0                	add    %edx,%eax
    aa49:	0f b6 10             	movzbl (%eax),%edx
    aa4c:	8b 45 10             	mov    0x10(%ebp),%eax
    aa4f:	88 10                	mov    %dl,(%eax)
    aa51:	8b 45 10             	mov    0x10(%ebp),%eax
    aa54:	0f b6 10             	movzbl (%eax),%edx
    aa57:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa5a:	88 10                	mov    %dl,(%eax)
    aa5c:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa5f:	0f b6 10             	movzbl (%eax),%edx
    aa62:	8b 45 08             	mov    0x8(%ebp),%eax
    aa65:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    aa67:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa6a:	c1 e0 02             	shl    $0x2,%eax
    aa6d:	8d 50 02             	lea    0x2(%eax),%edx
    aa70:	8b 45 18             	mov    0x18(%ebp),%eax
    aa73:	01 d0                	add    %edx,%eax
    aa75:	0f b6 10             	movzbl (%eax),%edx
    aa78:	8b 45 14             	mov    0x14(%ebp),%eax
    aa7b:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aa7d:	e9 cb 00 00 00       	jmp    ab4d <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    aa82:	8b 45 20             	mov    0x20(%ebp),%eax
    aa85:	8b 00                	mov    (%eax),%eax
    aa87:	83 f8 06             	cmp    $0x6,%eax
    aa8a:	0f 85 bd 00 00 00    	jne    ab4d <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    aa90:	8b 45 20             	mov    0x20(%ebp),%eax
    aa93:	8b 40 04             	mov    0x4(%eax),%eax
    aa96:	83 f8 08             	cmp    $0x8,%eax
    aa99:	75 59                	jne    aaf4 <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    aa9b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aa9e:	c1 e0 02             	shl    $0x2,%eax
    aaa1:	89 c2                	mov    %eax,%edx
    aaa3:	8b 45 18             	mov    0x18(%ebp),%eax
    aaa6:	01 d0                	add    %edx,%eax
    aaa8:	0f b6 10             	movzbl (%eax),%edx
    aaab:	8b 45 08             	mov    0x8(%ebp),%eax
    aaae:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    aab0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aab3:	c1 e0 02             	shl    $0x2,%eax
    aab6:	8d 50 01             	lea    0x1(%eax),%edx
    aab9:	8b 45 18             	mov    0x18(%ebp),%eax
    aabc:	01 d0                	add    %edx,%eax
    aabe:	0f b6 10             	movzbl (%eax),%edx
    aac1:	8b 45 0c             	mov    0xc(%ebp),%eax
    aac4:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    aac6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aac9:	c1 e0 02             	shl    $0x2,%eax
    aacc:	8d 50 02             	lea    0x2(%eax),%edx
    aacf:	8b 45 18             	mov    0x18(%ebp),%eax
    aad2:	01 d0                	add    %edx,%eax
    aad4:	0f b6 10             	movzbl (%eax),%edx
    aad7:	8b 45 10             	mov    0x10(%ebp),%eax
    aada:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    aadc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aadf:	c1 e0 02             	shl    $0x2,%eax
    aae2:	8d 50 03             	lea    0x3(%eax),%edx
    aae5:	8b 45 18             	mov    0x18(%ebp),%eax
    aae8:	01 d0                	add    %edx,%eax
    aaea:	0f b6 10             	movzbl (%eax),%edx
    aaed:	8b 45 14             	mov    0x14(%ebp),%eax
    aaf0:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aaf2:	eb 59                	jmp    ab4d <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    aaf4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aaf7:	c1 e0 03             	shl    $0x3,%eax
    aafa:	89 c2                	mov    %eax,%edx
    aafc:	8b 45 18             	mov    0x18(%ebp),%eax
    aaff:	01 d0                	add    %edx,%eax
    ab01:	0f b6 10             	movzbl (%eax),%edx
    ab04:	8b 45 08             	mov    0x8(%ebp),%eax
    ab07:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    ab09:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab0c:	c1 e0 03             	shl    $0x3,%eax
    ab0f:	8d 50 02             	lea    0x2(%eax),%edx
    ab12:	8b 45 18             	mov    0x18(%ebp),%eax
    ab15:	01 d0                	add    %edx,%eax
    ab17:	0f b6 10             	movzbl (%eax),%edx
    ab1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab1d:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    ab1f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab22:	c1 e0 03             	shl    $0x3,%eax
    ab25:	8d 50 04             	lea    0x4(%eax),%edx
    ab28:	8b 45 18             	mov    0x18(%ebp),%eax
    ab2b:	01 d0                	add    %edx,%eax
    ab2d:	0f b6 10             	movzbl (%eax),%edx
    ab30:	8b 45 10             	mov    0x10(%ebp),%eax
    ab33:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    ab35:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab38:	c1 e0 03             	shl    $0x3,%eax
    ab3b:	8d 50 06             	lea    0x6(%eax),%edx
    ab3e:	8b 45 18             	mov    0x18(%ebp),%eax
    ab41:	01 d0                	add    %edx,%eax
    ab43:	0f b6 10             	movzbl (%eax),%edx
    ab46:	8b 45 14             	mov    0x14(%ebp),%eax
    ab49:	88 10                	mov    %dl,(%eax)
    }
  }
}
    ab4b:	eb 00                	jmp    ab4d <getPixelColorRGBA8+0x5ca>
    ab4d:	90                   	nop
    ab4e:	c9                   	leave  
    ab4f:	c3                   	ret    

0000ab50 <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    ab50:	55                   	push   %ebp
    ab51:	89 e5                	mov    %esp,%ebp
    ab53:	53                   	push   %ebx
    ab54:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    ab57:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    ab5e:	8b 45 14             	mov    0x14(%ebp),%eax
    ab61:	8b 00                	mov    (%eax),%eax
    ab63:	85 c0                	test   %eax,%eax
    ab65:	0f 85 14 02 00 00    	jne    ad7f <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    ab6b:	8b 45 14             	mov    0x14(%ebp),%eax
    ab6e:	8b 40 04             	mov    0x4(%eax),%eax
    ab71:	83 f8 08             	cmp    $0x8,%eax
    ab74:	0f 85 a0 00 00 00    	jne    ac1a <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ab7a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ab81:	eb 39                	jmp    abbc <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    ab83:	8b 45 08             	mov    0x8(%ebp),%eax
    ab86:	83 c0 01             	add    $0x1,%eax
    ab89:	8b 55 08             	mov    0x8(%ebp),%edx
    ab8c:	83 c2 02             	add    $0x2,%edx
    ab8f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    ab92:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ab95:	01 d9                	add    %ebx,%ecx
    ab97:	0f b6 09             	movzbl (%ecx),%ecx
    ab9a:	88 0a                	mov    %cl,(%edx)
    ab9c:	0f b6 12             	movzbl (%edx),%edx
    ab9f:	88 10                	mov    %dl,(%eax)
    aba1:	0f b6 10             	movzbl (%eax),%edx
    aba4:	8b 45 08             	mov    0x8(%ebp),%eax
    aba7:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    aba9:	8b 45 08             	mov    0x8(%ebp),%eax
    abac:	83 c0 03             	add    $0x3,%eax
    abaf:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    abb2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    abb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    abb9:	01 45 08             	add    %eax,0x8(%ebp)
    abbc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    abbf:	3b 45 0c             	cmp    0xc(%ebp),%eax
    abc2:	75 bf                	jne    ab83 <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    abc4:	8b 45 14             	mov    0x14(%ebp),%eax
    abc7:	8b 40 10             	mov    0x10(%eax),%eax
    abca:	85 c0                	test   %eax,%eax
    abcc:	0f 84 48 06 00 00    	je     b21a <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    abd2:	8b 45 0c             	mov    0xc(%ebp),%eax
    abd5:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    abd9:	f7 d8                	neg    %eax
    abdb:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    abde:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    abe5:	eb 26                	jmp    ac0d <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    abe7:	8b 45 08             	mov    0x8(%ebp),%eax
    abea:	0f b6 00             	movzbl (%eax),%eax
    abed:	0f b6 d0             	movzbl %al,%edx
    abf0:	8b 45 14             	mov    0x14(%ebp),%eax
    abf3:	8b 40 14             	mov    0x14(%eax),%eax
    abf6:	39 c2                	cmp    %eax,%edx
    abf8:	75 09                	jne    ac03 <getPixelColorsRGBA8+0xb3>
    abfa:	8b 45 08             	mov    0x8(%ebp),%eax
    abfd:	83 c0 03             	add    $0x3,%eax
    ac00:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac03:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ac07:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ac0a:	01 45 08             	add    %eax,0x8(%ebp)
    ac0d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac10:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ac13:	75 d2                	jne    abe7 <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ac15:	e9 00 06 00 00       	jmp    b21a <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    ac1a:	8b 45 14             	mov    0x14(%ebp),%eax
    ac1d:	8b 40 04             	mov    0x4(%eax),%eax
    ac20:	83 f8 10             	cmp    $0x10,%eax
    ac23:	0f 85 a5 00 00 00    	jne    acce <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ac29:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ac30:	e9 88 00 00 00       	jmp    acbd <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    ac35:	8b 45 08             	mov    0x8(%ebp),%eax
    ac38:	83 c0 01             	add    $0x1,%eax
    ac3b:	8b 55 08             	mov    0x8(%ebp),%edx
    ac3e:	83 c2 02             	add    $0x2,%edx
    ac41:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    ac44:	01 c9                	add    %ecx,%ecx
    ac46:	89 cb                	mov    %ecx,%ebx
    ac48:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ac4b:	01 d9                	add    %ebx,%ecx
    ac4d:	0f b6 09             	movzbl (%ecx),%ecx
    ac50:	88 0a                	mov    %cl,(%edx)
    ac52:	0f b6 12             	movzbl (%edx),%edx
    ac55:	88 10                	mov    %dl,(%eax)
    ac57:	0f b6 10             	movzbl (%eax),%edx
    ac5a:	8b 45 08             	mov    0x8(%ebp),%eax
    ac5d:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    ac5f:	8b 45 08             	mov    0x8(%ebp),%eax
    ac62:	8d 50 03             	lea    0x3(%eax),%edx
    ac65:	8b 45 14             	mov    0x14(%ebp),%eax
    ac68:	8b 40 10             	mov    0x10(%eax),%eax
    ac6b:	85 c0                	test   %eax,%eax
    ac6d:	74 3d                	je     acac <getPixelColorsRGBA8+0x15c>
    ac6f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac72:	01 c0                	add    %eax,%eax
    ac74:	89 c1                	mov    %eax,%ecx
    ac76:	8b 45 10             	mov    0x10(%ebp),%eax
    ac79:	01 c8                	add    %ecx,%eax
    ac7b:	0f b6 00             	movzbl (%eax),%eax
    ac7e:	0f b6 c0             	movzbl %al,%eax
    ac81:	c1 e0 08             	shl    $0x8,%eax
    ac84:	89 c1                	mov    %eax,%ecx
    ac86:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ac89:	01 c0                	add    %eax,%eax
    ac8b:	8d 58 01             	lea    0x1(%eax),%ebx
    ac8e:	8b 45 10             	mov    0x10(%ebp),%eax
    ac91:	01 d8                	add    %ebx,%eax
    ac93:	0f b6 00             	movzbl (%eax),%eax
    ac96:	0f b6 c0             	movzbl %al,%eax
    ac99:	01 c1                	add    %eax,%ecx
    ac9b:	8b 45 14             	mov    0x14(%ebp),%eax
    ac9e:	8b 40 14             	mov    0x14(%eax),%eax
    aca1:	39 c1                	cmp    %eax,%ecx
    aca3:	75 07                	jne    acac <getPixelColorsRGBA8+0x15c>
    aca5:	b8 00 00 00 00       	mov    $0x0,%eax
    acaa:	eb 05                	jmp    acb1 <getPixelColorsRGBA8+0x161>
    acac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    acb1:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    acb3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    acb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    acba:	01 45 08             	add    %eax,0x8(%ebp)
    acbd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    acc0:	3b 45 0c             	cmp    0xc(%ebp),%eax
    acc3:	0f 85 6c ff ff ff    	jne    ac35 <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    acc9:	e9 4c 05 00 00       	jmp    b21a <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    acce:	8b 45 14             	mov    0x14(%ebp),%eax
    acd1:	8b 40 04             	mov    0x4(%eax),%eax
    acd4:	ba 01 00 00 00       	mov    $0x1,%edx
    acd9:	89 c1                	mov    %eax,%ecx
    acdb:	d3 e2                	shl    %cl,%edx
    acdd:	89 d0                	mov    %edx,%eax
    acdf:	83 e8 01             	sub    $0x1,%eax
    ace2:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    ace5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    acec:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    acf3:	eb 79                	jmp    ad6e <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    acf5:	8b 45 14             	mov    0x14(%ebp),%eax
    acf8:	8b 40 04             	mov    0x4(%eax),%eax
    acfb:	50                   	push   %eax
    acfc:	ff 75 10             	pushl  0x10(%ebp)
    acff:	8d 45 e0             	lea    -0x20(%ebp),%eax
    ad02:	50                   	push   %eax
    ad03:	e8 c0 d4 ff ff       	call   81c8 <readBitsFromReversedStream>
    ad08:	83 c4 0c             	add    $0xc,%esp
    ad0b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    ad0e:	8b 45 08             	mov    0x8(%ebp),%eax
    ad11:	8d 48 01             	lea    0x1(%eax),%ecx
    ad14:	8b 45 08             	mov    0x8(%ebp),%eax
    ad17:	8d 58 02             	lea    0x2(%eax),%ebx
    ad1a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ad1d:	89 d0                	mov    %edx,%eax
    ad1f:	c1 e0 08             	shl    $0x8,%eax
    ad22:	29 d0                	sub    %edx,%eax
    ad24:	ba 00 00 00 00       	mov    $0x0,%edx
    ad29:	f7 75 f0             	divl   -0x10(%ebp)
    ad2c:	88 03                	mov    %al,(%ebx)
    ad2e:	0f b6 03             	movzbl (%ebx),%eax
    ad31:	88 01                	mov    %al,(%ecx)
    ad33:	0f b6 11             	movzbl (%ecx),%edx
    ad36:	8b 45 08             	mov    0x8(%ebp),%eax
    ad39:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    ad3b:	8b 45 08             	mov    0x8(%ebp),%eax
    ad3e:	8d 50 03             	lea    0x3(%eax),%edx
    ad41:	8b 45 14             	mov    0x14(%ebp),%eax
    ad44:	8b 40 10             	mov    0x10(%eax),%eax
    ad47:	85 c0                	test   %eax,%eax
    ad49:	74 12                	je     ad5d <getPixelColorsRGBA8+0x20d>
    ad4b:	8b 45 14             	mov    0x14(%ebp),%eax
    ad4e:	8b 40 14             	mov    0x14(%eax),%eax
    ad51:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    ad54:	75 07                	jne    ad5d <getPixelColorsRGBA8+0x20d>
    ad56:	b8 00 00 00 00       	mov    $0x0,%eax
    ad5b:	eb 05                	jmp    ad62 <getPixelColorsRGBA8+0x212>
    ad5d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    ad62:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad64:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ad68:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ad6b:	01 45 08             	add    %eax,0x8(%ebp)
    ad6e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad71:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ad74:	0f 85 7b ff ff ff    	jne    acf5 <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ad7a:	e9 9b 04 00 00       	jmp    b21a <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    ad7f:	8b 45 14             	mov    0x14(%ebp),%eax
    ad82:	8b 00                	mov    (%eax),%eax
    ad84:	83 f8 02             	cmp    $0x2,%eax
    ad87:	0f 85 41 02 00 00    	jne    afce <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    ad8d:	8b 45 14             	mov    0x14(%ebp),%eax
    ad90:	8b 40 04             	mov    0x4(%eax),%eax
    ad93:	83 f8 08             	cmp    $0x8,%eax
    ad96:	0f 85 c4 00 00 00    	jne    ae60 <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad9c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ada3:	eb 31                	jmp    add6 <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    ada5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ada8:	89 d0                	mov    %edx,%eax
    adaa:	01 c0                	add    %eax,%eax
    adac:	01 d0                	add    %edx,%eax
    adae:	89 c2                	mov    %eax,%edx
    adb0:	8b 45 10             	mov    0x10(%ebp),%eax
    adb3:	01 d0                	add    %edx,%eax
    adb5:	6a 03                	push   $0x3
    adb7:	50                   	push   %eax
    adb8:	ff 75 08             	pushl  0x8(%ebp)
    adbb:	e8 a3 85 ff ff       	call   3363 <lodepng_memcpy>
    adc0:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    adc3:	8b 45 08             	mov    0x8(%ebp),%eax
    adc6:	83 c0 03             	add    $0x3,%eax
    adc9:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    adcc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    add0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    add3:	01 45 08             	add    %eax,0x8(%ebp)
    add6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    add9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    addc:	75 c7                	jne    ada5 <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    adde:	8b 45 14             	mov    0x14(%ebp),%eax
    ade1:	8b 40 10             	mov    0x10(%eax),%eax
    ade4:	85 c0                	test   %eax,%eax
    ade6:	0f 84 2e 04 00 00    	je     b21a <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    adec:	8b 45 0c             	mov    0xc(%ebp),%eax
    adef:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    adf3:	f7 d8                	neg    %eax
    adf5:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    adf8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    adff:	eb 52                	jmp    ae53 <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    ae01:	8b 45 08             	mov    0x8(%ebp),%eax
    ae04:	0f b6 00             	movzbl (%eax),%eax
    ae07:	0f b6 d0             	movzbl %al,%edx
    ae0a:	8b 45 14             	mov    0x14(%ebp),%eax
    ae0d:	8b 40 14             	mov    0x14(%eax),%eax
    ae10:	39 c2                	cmp    %eax,%edx
    ae12:	75 35                	jne    ae49 <getPixelColorsRGBA8+0x2f9>
    ae14:	8b 45 08             	mov    0x8(%ebp),%eax
    ae17:	83 c0 01             	add    $0x1,%eax
    ae1a:	0f b6 00             	movzbl (%eax),%eax
    ae1d:	0f b6 d0             	movzbl %al,%edx
    ae20:	8b 45 14             	mov    0x14(%ebp),%eax
    ae23:	8b 40 18             	mov    0x18(%eax),%eax
    ae26:	39 c2                	cmp    %eax,%edx
    ae28:	75 1f                	jne    ae49 <getPixelColorsRGBA8+0x2f9>
    ae2a:	8b 45 08             	mov    0x8(%ebp),%eax
    ae2d:	83 c0 02             	add    $0x2,%eax
    ae30:	0f b6 00             	movzbl (%eax),%eax
    ae33:	0f b6 d0             	movzbl %al,%edx
    ae36:	8b 45 14             	mov    0x14(%ebp),%eax
    ae39:	8b 40 1c             	mov    0x1c(%eax),%eax
    ae3c:	39 c2                	cmp    %eax,%edx
    ae3e:	75 09                	jne    ae49 <getPixelColorsRGBA8+0x2f9>
    ae40:	8b 45 08             	mov    0x8(%ebp),%eax
    ae43:	83 c0 03             	add    $0x3,%eax
    ae46:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae49:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ae4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ae50:	01 45 08             	add    %eax,0x8(%ebp)
    ae53:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae56:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ae59:	75 a6                	jne    ae01 <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ae5b:	e9 ba 03 00 00       	jmp    b21a <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae60:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae67:	e9 51 01 00 00       	jmp    afbd <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    ae6c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae6f:	89 d0                	mov    %edx,%eax
    ae71:	01 c0                	add    %eax,%eax
    ae73:	01 d0                	add    %edx,%eax
    ae75:	01 c0                	add    %eax,%eax
    ae77:	89 c2                	mov    %eax,%edx
    ae79:	8b 45 10             	mov    0x10(%ebp),%eax
    ae7c:	01 d0                	add    %edx,%eax
    ae7e:	0f b6 10             	movzbl (%eax),%edx
    ae81:	8b 45 08             	mov    0x8(%ebp),%eax
    ae84:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    ae86:	8b 45 08             	mov    0x8(%ebp),%eax
    ae89:	8d 48 01             	lea    0x1(%eax),%ecx
    ae8c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    ae8f:	89 d0                	mov    %edx,%eax
    ae91:	01 c0                	add    %eax,%eax
    ae93:	01 d0                	add    %edx,%eax
    ae95:	01 c0                	add    %eax,%eax
    ae97:	8d 50 02             	lea    0x2(%eax),%edx
    ae9a:	8b 45 10             	mov    0x10(%ebp),%eax
    ae9d:	01 d0                	add    %edx,%eax
    ae9f:	0f b6 00             	movzbl (%eax),%eax
    aea2:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    aea4:	8b 45 08             	mov    0x8(%ebp),%eax
    aea7:	8d 48 02             	lea    0x2(%eax),%ecx
    aeaa:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aead:	89 d0                	mov    %edx,%eax
    aeaf:	01 c0                	add    %eax,%eax
    aeb1:	01 d0                	add    %edx,%eax
    aeb3:	01 c0                	add    %eax,%eax
    aeb5:	8d 50 04             	lea    0x4(%eax),%edx
    aeb8:	8b 45 10             	mov    0x10(%ebp),%eax
    aebb:	01 d0                	add    %edx,%eax
    aebd:	0f b6 00             	movzbl (%eax),%eax
    aec0:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    aec2:	8b 45 08             	mov    0x8(%ebp),%eax
    aec5:	8d 48 03             	lea    0x3(%eax),%ecx
    aec8:	8b 45 14             	mov    0x14(%ebp),%eax
    aecb:	8b 40 10             	mov    0x10(%eax),%eax
    aece:	85 c0                	test   %eax,%eax
    aed0:	0f 84 d6 00 00 00    	je     afac <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    aed6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aed9:	89 d0                	mov    %edx,%eax
    aedb:	01 c0                	add    %eax,%eax
    aedd:	01 d0                	add    %edx,%eax
    aedf:	01 c0                	add    %eax,%eax
    aee1:	89 c2                	mov    %eax,%edx
    aee3:	8b 45 10             	mov    0x10(%ebp),%eax
    aee6:	01 d0                	add    %edx,%eax
    aee8:	0f b6 00             	movzbl (%eax),%eax
    aeeb:	0f b6 c0             	movzbl %al,%eax
    aeee:	c1 e0 08             	shl    $0x8,%eax
    aef1:	89 c3                	mov    %eax,%ebx
    aef3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aef6:	89 d0                	mov    %edx,%eax
    aef8:	01 c0                	add    %eax,%eax
    aefa:	01 d0                	add    %edx,%eax
    aefc:	01 c0                	add    %eax,%eax
    aefe:	8d 50 01             	lea    0x1(%eax),%edx
    af01:	8b 45 10             	mov    0x10(%ebp),%eax
    af04:	01 d0                	add    %edx,%eax
    af06:	0f b6 00             	movzbl (%eax),%eax
    af09:	0f b6 c0             	movzbl %al,%eax
    af0c:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    af0f:	8b 45 14             	mov    0x14(%ebp),%eax
    af12:	8b 40 14             	mov    0x14(%eax),%eax
    af15:	39 c2                	cmp    %eax,%edx
    af17:	0f 85 8f 00 00 00    	jne    afac <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    af1d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af20:	89 d0                	mov    %edx,%eax
    af22:	01 c0                	add    %eax,%eax
    af24:	01 d0                	add    %edx,%eax
    af26:	01 c0                	add    %eax,%eax
    af28:	8d 50 02             	lea    0x2(%eax),%edx
    af2b:	8b 45 10             	mov    0x10(%ebp),%eax
    af2e:	01 d0                	add    %edx,%eax
    af30:	0f b6 00             	movzbl (%eax),%eax
    af33:	0f b6 c0             	movzbl %al,%eax
    af36:	c1 e0 08             	shl    $0x8,%eax
    af39:	89 c3                	mov    %eax,%ebx
    af3b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af3e:	89 d0                	mov    %edx,%eax
    af40:	01 c0                	add    %eax,%eax
    af42:	01 d0                	add    %edx,%eax
    af44:	01 c0                	add    %eax,%eax
    af46:	8d 50 03             	lea    0x3(%eax),%edx
    af49:	8b 45 10             	mov    0x10(%ebp),%eax
    af4c:	01 d0                	add    %edx,%eax
    af4e:	0f b6 00             	movzbl (%eax),%eax
    af51:	0f b6 c0             	movzbl %al,%eax
    af54:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    af57:	8b 45 14             	mov    0x14(%ebp),%eax
    af5a:	8b 40 18             	mov    0x18(%eax),%eax
    af5d:	39 c2                	cmp    %eax,%edx
    af5f:	75 4b                	jne    afac <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    af61:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af64:	89 d0                	mov    %edx,%eax
    af66:	01 c0                	add    %eax,%eax
    af68:	01 d0                	add    %edx,%eax
    af6a:	01 c0                	add    %eax,%eax
    af6c:	8d 50 04             	lea    0x4(%eax),%edx
    af6f:	8b 45 10             	mov    0x10(%ebp),%eax
    af72:	01 d0                	add    %edx,%eax
    af74:	0f b6 00             	movzbl (%eax),%eax
    af77:	0f b6 c0             	movzbl %al,%eax
    af7a:	c1 e0 08             	shl    $0x8,%eax
    af7d:	89 c3                	mov    %eax,%ebx
    af7f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    af82:	89 d0                	mov    %edx,%eax
    af84:	01 c0                	add    %eax,%eax
    af86:	01 d0                	add    %edx,%eax
    af88:	01 c0                	add    %eax,%eax
    af8a:	8d 50 05             	lea    0x5(%eax),%edx
    af8d:	8b 45 10             	mov    0x10(%ebp),%eax
    af90:	01 d0                	add    %edx,%eax
    af92:	0f b6 00             	movzbl (%eax),%eax
    af95:	0f b6 c0             	movzbl %al,%eax
    af98:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    af9b:	8b 45 14             	mov    0x14(%ebp),%eax
    af9e:	8b 40 1c             	mov    0x1c(%eax),%eax
    afa1:	39 c2                	cmp    %eax,%edx
    afa3:	75 07                	jne    afac <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    afa5:	b8 00 00 00 00       	mov    $0x0,%eax
    afaa:	eb 05                	jmp    afb1 <getPixelColorsRGBA8+0x461>
    afac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    afb1:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    afb3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    afb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    afba:	01 45 08             	add    %eax,0x8(%ebp)
    afbd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    afc0:	3b 45 0c             	cmp    0xc(%ebp),%eax
    afc3:	0f 85 a3 fe ff ff    	jne    ae6c <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    afc9:	e9 4c 02 00 00       	jmp    b21a <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    afce:	8b 45 14             	mov    0x14(%ebp),%eax
    afd1:	8b 00                	mov    (%eax),%eax
    afd3:	83 f8 03             	cmp    $0x3,%eax
    afd6:	0f 85 b4 00 00 00    	jne    b090 <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    afdc:	8b 45 14             	mov    0x14(%ebp),%eax
    afdf:	8b 40 04             	mov    0x4(%eax),%eax
    afe2:	83 f8 08             	cmp    $0x8,%eax
    afe5:	75 4d                	jne    b034 <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    afe7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    afee:	eb 37                	jmp    b027 <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    aff0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aff3:	8b 45 10             	mov    0x10(%ebp),%eax
    aff6:	01 d0                	add    %edx,%eax
    aff8:	0f b6 00             	movzbl (%eax),%eax
    affb:	0f b6 c0             	movzbl %al,%eax
    affe:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b001:	8b 45 14             	mov    0x14(%ebp),%eax
    b004:	8b 40 08             	mov    0x8(%eax),%eax
    b007:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b00a:	c1 e2 02             	shl    $0x2,%edx
    b00d:	01 d0                	add    %edx,%eax
    b00f:	6a 04                	push   $0x4
    b011:	50                   	push   %eax
    b012:	ff 75 08             	pushl  0x8(%ebp)
    b015:	e8 49 83 ff ff       	call   3363 <lodepng_memcpy>
    b01a:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b01d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b021:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b024:	01 45 08             	add    %eax,0x8(%ebp)
    b027:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b02a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b02d:	75 c1                	jne    aff0 <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b02f:	e9 e6 01 00 00       	jmp    b21a <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    b034:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b03b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b042:	eb 3f                	jmp    b083 <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b044:	8b 45 14             	mov    0x14(%ebp),%eax
    b047:	8b 40 04             	mov    0x4(%eax),%eax
    b04a:	50                   	push   %eax
    b04b:	ff 75 10             	pushl  0x10(%ebp)
    b04e:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b051:	50                   	push   %eax
    b052:	e8 71 d1 ff ff       	call   81c8 <readBitsFromReversedStream>
    b057:	83 c4 0c             	add    $0xc,%esp
    b05a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b05d:	8b 45 14             	mov    0x14(%ebp),%eax
    b060:	8b 40 08             	mov    0x8(%eax),%eax
    b063:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b066:	c1 e2 02             	shl    $0x2,%edx
    b069:	01 d0                	add    %edx,%eax
    b06b:	6a 04                	push   $0x4
    b06d:	50                   	push   %eax
    b06e:	ff 75 08             	pushl  0x8(%ebp)
    b071:	e8 ed 82 ff ff       	call   3363 <lodepng_memcpy>
    b076:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b079:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b07d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b080:	01 45 08             	add    %eax,0x8(%ebp)
    b083:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b086:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b089:	75 b9                	jne    b044 <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b08b:	e9 8a 01 00 00       	jmp    b21a <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b090:	8b 45 14             	mov    0x14(%ebp),%eax
    b093:	8b 00                	mov    (%eax),%eax
    b095:	83 f8 04             	cmp    $0x4,%eax
    b098:	0f 85 d1 00 00 00    	jne    b16f <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    b09e:	8b 45 14             	mov    0x14(%ebp),%eax
    b0a1:	8b 40 04             	mov    0x4(%eax),%eax
    b0a4:	83 f8 08             	cmp    $0x8,%eax
    b0a7:	75 62                	jne    b10b <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0a9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b0b0:	eb 4c                	jmp    b0fe <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b0b2:	8b 45 08             	mov    0x8(%ebp),%eax
    b0b5:	83 c0 01             	add    $0x1,%eax
    b0b8:	8b 55 08             	mov    0x8(%ebp),%edx
    b0bb:	83 c2 02             	add    $0x2,%edx
    b0be:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b0c1:	01 c9                	add    %ecx,%ecx
    b0c3:	89 cb                	mov    %ecx,%ebx
    b0c5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b0c8:	01 d9                	add    %ebx,%ecx
    b0ca:	0f b6 09             	movzbl (%ecx),%ecx
    b0cd:	88 0a                	mov    %cl,(%edx)
    b0cf:	0f b6 12             	movzbl (%edx),%edx
    b0d2:	88 10                	mov    %dl,(%eax)
    b0d4:	0f b6 10             	movzbl (%eax),%edx
    b0d7:	8b 45 08             	mov    0x8(%ebp),%eax
    b0da:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    b0dc:	8b 45 08             	mov    0x8(%ebp),%eax
    b0df:	8d 50 03             	lea    0x3(%eax),%edx
    b0e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b0e5:	01 c0                	add    %eax,%eax
    b0e7:	8d 48 01             	lea    0x1(%eax),%ecx
    b0ea:	8b 45 10             	mov    0x10(%ebp),%eax
    b0ed:	01 c8                	add    %ecx,%eax
    b0ef:	0f b6 00             	movzbl (%eax),%eax
    b0f2:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0f4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b0f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b0fb:	01 45 08             	add    %eax,0x8(%ebp)
    b0fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b101:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b104:	75 ac                	jne    b0b2 <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b106:	e9 0f 01 00 00       	jmp    b21a <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b10b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b112:	eb 4e                	jmp    b162 <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b114:	8b 45 08             	mov    0x8(%ebp),%eax
    b117:	83 c0 01             	add    $0x1,%eax
    b11a:	8b 55 08             	mov    0x8(%ebp),%edx
    b11d:	83 c2 02             	add    $0x2,%edx
    b120:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b123:	c1 e1 02             	shl    $0x2,%ecx
    b126:	89 cb                	mov    %ecx,%ebx
    b128:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b12b:	01 d9                	add    %ebx,%ecx
    b12d:	0f b6 09             	movzbl (%ecx),%ecx
    b130:	88 0a                	mov    %cl,(%edx)
    b132:	0f b6 12             	movzbl (%edx),%edx
    b135:	88 10                	mov    %dl,(%eax)
    b137:	0f b6 10             	movzbl (%eax),%edx
    b13a:	8b 45 08             	mov    0x8(%ebp),%eax
    b13d:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    b13f:	8b 45 08             	mov    0x8(%ebp),%eax
    b142:	8d 50 03             	lea    0x3(%eax),%edx
    b145:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b148:	c1 e0 02             	shl    $0x2,%eax
    b14b:	8d 48 02             	lea    0x2(%eax),%ecx
    b14e:	8b 45 10             	mov    0x10(%ebp),%eax
    b151:	01 c8                	add    %ecx,%eax
    b153:	0f b6 00             	movzbl (%eax),%eax
    b156:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b158:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b15c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b15f:	01 45 08             	add    %eax,0x8(%ebp)
    b162:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b165:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b168:	75 aa                	jne    b114 <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b16a:	e9 ab 00 00 00       	jmp    b21a <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b16f:	8b 45 14             	mov    0x14(%ebp),%eax
    b172:	8b 00                	mov    (%eax),%eax
    b174:	83 f8 06             	cmp    $0x6,%eax
    b177:	0f 85 9d 00 00 00    	jne    b21a <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    b17d:	8b 45 14             	mov    0x14(%ebp),%eax
    b180:	8b 40 04             	mov    0x4(%eax),%eax
    b183:	83 f8 08             	cmp    $0x8,%eax
    b186:	75 17                	jne    b19f <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    b188:	8b 45 0c             	mov    0xc(%ebp),%eax
    b18b:	c1 e0 02             	shl    $0x2,%eax
    b18e:	50                   	push   %eax
    b18f:	ff 75 10             	pushl  0x10(%ebp)
    b192:	ff 75 08             	pushl  0x8(%ebp)
    b195:	e8 c9 81 ff ff       	call   3363 <lodepng_memcpy>
    b19a:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b19d:	eb 7b                	jmp    b21a <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b19f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b1a6:	eb 6a                	jmp    b212 <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    b1a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1ab:	c1 e0 03             	shl    $0x3,%eax
    b1ae:	89 c2                	mov    %eax,%edx
    b1b0:	8b 45 10             	mov    0x10(%ebp),%eax
    b1b3:	01 d0                	add    %edx,%eax
    b1b5:	0f b6 10             	movzbl (%eax),%edx
    b1b8:	8b 45 08             	mov    0x8(%ebp),%eax
    b1bb:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b1bd:	8b 45 08             	mov    0x8(%ebp),%eax
    b1c0:	8d 50 01             	lea    0x1(%eax),%edx
    b1c3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1c6:	c1 e0 03             	shl    $0x3,%eax
    b1c9:	8d 48 02             	lea    0x2(%eax),%ecx
    b1cc:	8b 45 10             	mov    0x10(%ebp),%eax
    b1cf:	01 c8                	add    %ecx,%eax
    b1d1:	0f b6 00             	movzbl (%eax),%eax
    b1d4:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b1d6:	8b 45 08             	mov    0x8(%ebp),%eax
    b1d9:	8d 50 02             	lea    0x2(%eax),%edx
    b1dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1df:	c1 e0 03             	shl    $0x3,%eax
    b1e2:	8d 48 04             	lea    0x4(%eax),%ecx
    b1e5:	8b 45 10             	mov    0x10(%ebp),%eax
    b1e8:	01 c8                	add    %ecx,%eax
    b1ea:	0f b6 00             	movzbl (%eax),%eax
    b1ed:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    b1ef:	8b 45 08             	mov    0x8(%ebp),%eax
    b1f2:	8d 50 03             	lea    0x3(%eax),%edx
    b1f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1f8:	c1 e0 03             	shl    $0x3,%eax
    b1fb:	8d 48 06             	lea    0x6(%eax),%ecx
    b1fe:	8b 45 10             	mov    0x10(%ebp),%eax
    b201:	01 c8                	add    %ecx,%eax
    b203:	0f b6 00             	movzbl (%eax),%eax
    b206:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b208:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b20c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b20f:	01 45 08             	add    %eax,0x8(%ebp)
    b212:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b215:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b218:	75 8e                	jne    b1a8 <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b21a:	90                   	nop
    b21b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b21e:	c9                   	leave  
    b21f:	c3                   	ret    

0000b220 <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    b220:	55                   	push   %ebp
    b221:	89 e5                	mov    %esp,%ebp
    b223:	53                   	push   %ebx
    b224:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    b227:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b22e:	8b 45 14             	mov    0x14(%ebp),%eax
    b231:	8b 00                	mov    (%eax),%eax
    b233:	85 c0                	test   %eax,%eax
    b235:	0f 85 2a 01 00 00    	jne    b365 <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    b23b:	8b 45 14             	mov    0x14(%ebp),%eax
    b23e:	8b 40 04             	mov    0x4(%eax),%eax
    b241:	83 f8 08             	cmp    $0x8,%eax
    b244:	75 46                	jne    b28c <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b246:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b24d:	eb 30                	jmp    b27f <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b24f:	8b 45 08             	mov    0x8(%ebp),%eax
    b252:	83 c0 01             	add    $0x1,%eax
    b255:	8b 55 08             	mov    0x8(%ebp),%edx
    b258:	83 c2 02             	add    $0x2,%edx
    b25b:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b25e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b261:	01 d9                	add    %ebx,%ecx
    b263:	0f b6 09             	movzbl (%ecx),%ecx
    b266:	88 0a                	mov    %cl,(%edx)
    b268:	0f b6 12             	movzbl (%edx),%edx
    b26b:	88 10                	mov    %dl,(%eax)
    b26d:	0f b6 10             	movzbl (%eax),%edx
    b270:	8b 45 08             	mov    0x8(%ebp),%eax
    b273:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b275:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b279:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b27c:	01 45 08             	add    %eax,0x8(%ebp)
    b27f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b282:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b285:	75 c8                	jne    b24f <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b287:	e9 a8 03 00 00       	jmp    b634 <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    b28c:	8b 45 14             	mov    0x14(%ebp),%eax
    b28f:	8b 40 04             	mov    0x4(%eax),%eax
    b292:	83 f8 10             	cmp    $0x10,%eax
    b295:	75 4a                	jne    b2e1 <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b297:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b29e:	eb 34                	jmp    b2d4 <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b2a0:	8b 45 08             	mov    0x8(%ebp),%eax
    b2a3:	83 c0 01             	add    $0x1,%eax
    b2a6:	8b 55 08             	mov    0x8(%ebp),%edx
    b2a9:	83 c2 02             	add    $0x2,%edx
    b2ac:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b2af:	01 c9                	add    %ecx,%ecx
    b2b1:	89 cb                	mov    %ecx,%ebx
    b2b3:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b2b6:	01 d9                	add    %ebx,%ecx
    b2b8:	0f b6 09             	movzbl (%ecx),%ecx
    b2bb:	88 0a                	mov    %cl,(%edx)
    b2bd:	0f b6 12             	movzbl (%edx),%edx
    b2c0:	88 10                	mov    %dl,(%eax)
    b2c2:	0f b6 10             	movzbl (%eax),%edx
    b2c5:	8b 45 08             	mov    0x8(%ebp),%eax
    b2c8:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2ca:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b2ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b2d1:	01 45 08             	add    %eax,0x8(%ebp)
    b2d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2d7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b2da:	75 c4                	jne    b2a0 <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b2dc:	e9 53 03 00 00       	jmp    b634 <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b2e1:	8b 45 14             	mov    0x14(%ebp),%eax
    b2e4:	8b 40 04             	mov    0x4(%eax),%eax
    b2e7:	ba 01 00 00 00       	mov    $0x1,%edx
    b2ec:	89 c1                	mov    %eax,%ecx
    b2ee:	d3 e2                	shl    %cl,%edx
    b2f0:	89 d0                	mov    %edx,%eax
    b2f2:	83 e8 01             	sub    $0x1,%eax
    b2f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b2f8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2ff:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b306:	eb 50                	jmp    b358 <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b308:	8b 45 14             	mov    0x14(%ebp),%eax
    b30b:	8b 40 04             	mov    0x4(%eax),%eax
    b30e:	50                   	push   %eax
    b30f:	ff 75 10             	pushl  0x10(%ebp)
    b312:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b315:	50                   	push   %eax
    b316:	e8 ad ce ff ff       	call   81c8 <readBitsFromReversedStream>
    b31b:	83 c4 0c             	add    $0xc,%esp
    b31e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b321:	8b 45 08             	mov    0x8(%ebp),%eax
    b324:	8d 48 01             	lea    0x1(%eax),%ecx
    b327:	8b 45 08             	mov    0x8(%ebp),%eax
    b32a:	8d 58 02             	lea    0x2(%eax),%ebx
    b32d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b330:	89 d0                	mov    %edx,%eax
    b332:	c1 e0 08             	shl    $0x8,%eax
    b335:	29 d0                	sub    %edx,%eax
    b337:	ba 00 00 00 00       	mov    $0x0,%edx
    b33c:	f7 75 f0             	divl   -0x10(%ebp)
    b33f:	88 03                	mov    %al,(%ebx)
    b341:	0f b6 03             	movzbl (%ebx),%eax
    b344:	88 01                	mov    %al,(%ecx)
    b346:	0f b6 11             	movzbl (%ecx),%edx
    b349:	8b 45 08             	mov    0x8(%ebp),%eax
    b34c:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b34e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b352:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b355:	01 45 08             	add    %eax,0x8(%ebp)
    b358:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b35b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b35e:	75 a8                	jne    b308 <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b360:	e9 cf 02 00 00       	jmp    b634 <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b365:	8b 45 14             	mov    0x14(%ebp),%eax
    b368:	8b 00                	mov    (%eax),%eax
    b36a:	83 f8 02             	cmp    $0x2,%eax
    b36d:	0f 85 9e 00 00 00    	jne    b411 <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    b373:	8b 45 14             	mov    0x14(%ebp),%eax
    b376:	8b 40 04             	mov    0x4(%eax),%eax
    b379:	83 f8 08             	cmp    $0x8,%eax
    b37c:	75 1d                	jne    b39b <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    b37e:	8b 55 0c             	mov    0xc(%ebp),%edx
    b381:	89 d0                	mov    %edx,%eax
    b383:	01 c0                	add    %eax,%eax
    b385:	01 d0                	add    %edx,%eax
    b387:	50                   	push   %eax
    b388:	ff 75 10             	pushl  0x10(%ebp)
    b38b:	ff 75 08             	pushl  0x8(%ebp)
    b38e:	e8 d0 7f ff ff       	call   3363 <lodepng_memcpy>
    b393:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b396:	e9 99 02 00 00       	jmp    b634 <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b39b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b3a2:	eb 60                	jmp    b404 <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    b3a4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3a7:	89 d0                	mov    %edx,%eax
    b3a9:	01 c0                	add    %eax,%eax
    b3ab:	01 d0                	add    %edx,%eax
    b3ad:	01 c0                	add    %eax,%eax
    b3af:	89 c2                	mov    %eax,%edx
    b3b1:	8b 45 10             	mov    0x10(%ebp),%eax
    b3b4:	01 d0                	add    %edx,%eax
    b3b6:	0f b6 10             	movzbl (%eax),%edx
    b3b9:	8b 45 08             	mov    0x8(%ebp),%eax
    b3bc:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b3be:	8b 45 08             	mov    0x8(%ebp),%eax
    b3c1:	8d 48 01             	lea    0x1(%eax),%ecx
    b3c4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3c7:	89 d0                	mov    %edx,%eax
    b3c9:	01 c0                	add    %eax,%eax
    b3cb:	01 d0                	add    %edx,%eax
    b3cd:	01 c0                	add    %eax,%eax
    b3cf:	8d 50 02             	lea    0x2(%eax),%edx
    b3d2:	8b 45 10             	mov    0x10(%ebp),%eax
    b3d5:	01 d0                	add    %edx,%eax
    b3d7:	0f b6 00             	movzbl (%eax),%eax
    b3da:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b3dc:	8b 45 08             	mov    0x8(%ebp),%eax
    b3df:	8d 48 02             	lea    0x2(%eax),%ecx
    b3e2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b3e5:	89 d0                	mov    %edx,%eax
    b3e7:	01 c0                	add    %eax,%eax
    b3e9:	01 d0                	add    %edx,%eax
    b3eb:	01 c0                	add    %eax,%eax
    b3ed:	8d 50 04             	lea    0x4(%eax),%edx
    b3f0:	8b 45 10             	mov    0x10(%ebp),%eax
    b3f3:	01 d0                	add    %edx,%eax
    b3f5:	0f b6 00             	movzbl (%eax),%eax
    b3f8:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3fa:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b3fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b401:	01 45 08             	add    %eax,0x8(%ebp)
    b404:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b407:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b40a:	75 98                	jne    b3a4 <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b40c:	e9 23 02 00 00       	jmp    b634 <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b411:	8b 45 14             	mov    0x14(%ebp),%eax
    b414:	8b 00                	mov    (%eax),%eax
    b416:	83 f8 03             	cmp    $0x3,%eax
    b419:	0f 85 b4 00 00 00    	jne    b4d3 <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    b41f:	8b 45 14             	mov    0x14(%ebp),%eax
    b422:	8b 40 04             	mov    0x4(%eax),%eax
    b425:	83 f8 08             	cmp    $0x8,%eax
    b428:	75 4d                	jne    b477 <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b42a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b431:	eb 37                	jmp    b46a <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    b433:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b436:	8b 45 10             	mov    0x10(%ebp),%eax
    b439:	01 d0                	add    %edx,%eax
    b43b:	0f b6 00             	movzbl (%eax),%eax
    b43e:	0f b6 c0             	movzbl %al,%eax
    b441:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b444:	8b 45 14             	mov    0x14(%ebp),%eax
    b447:	8b 40 08             	mov    0x8(%eax),%eax
    b44a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b44d:	c1 e2 02             	shl    $0x2,%edx
    b450:	01 d0                	add    %edx,%eax
    b452:	6a 03                	push   $0x3
    b454:	50                   	push   %eax
    b455:	ff 75 08             	pushl  0x8(%ebp)
    b458:	e8 06 7f ff ff       	call   3363 <lodepng_memcpy>
    b45d:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b460:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b464:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b467:	01 45 08             	add    %eax,0x8(%ebp)
    b46a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b46d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b470:	75 c1                	jne    b433 <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b472:	e9 bd 01 00 00       	jmp    b634 <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    b477:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b47e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b485:	eb 3f                	jmp    b4c6 <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b487:	8b 45 14             	mov    0x14(%ebp),%eax
    b48a:	8b 40 04             	mov    0x4(%eax),%eax
    b48d:	50                   	push   %eax
    b48e:	ff 75 10             	pushl  0x10(%ebp)
    b491:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b494:	50                   	push   %eax
    b495:	e8 2e cd ff ff       	call   81c8 <readBitsFromReversedStream>
    b49a:	83 c4 0c             	add    $0xc,%esp
    b49d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b4a0:	8b 45 14             	mov    0x14(%ebp),%eax
    b4a3:	8b 40 08             	mov    0x8(%eax),%eax
    b4a6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b4a9:	c1 e2 02             	shl    $0x2,%edx
    b4ac:	01 d0                	add    %edx,%eax
    b4ae:	6a 03                	push   $0x3
    b4b0:	50                   	push   %eax
    b4b1:	ff 75 08             	pushl  0x8(%ebp)
    b4b4:	e8 aa 7e ff ff       	call   3363 <lodepng_memcpy>
    b4b9:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4bc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b4c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b4c3:	01 45 08             	add    %eax,0x8(%ebp)
    b4c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4c9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b4cc:	75 b9                	jne    b487 <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b4ce:	e9 61 01 00 00       	jmp    b634 <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b4d3:	8b 45 14             	mov    0x14(%ebp),%eax
    b4d6:	8b 00                	mov    (%eax),%eax
    b4d8:	83 f8 04             	cmp    $0x4,%eax
    b4db:	0f 85 a0 00 00 00    	jne    b581 <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    b4e1:	8b 45 14             	mov    0x14(%ebp),%eax
    b4e4:	8b 40 04             	mov    0x4(%eax),%eax
    b4e7:	83 f8 08             	cmp    $0x8,%eax
    b4ea:	75 4a                	jne    b536 <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4ec:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b4f3:	eb 34                	jmp    b529 <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b4f5:	8b 45 08             	mov    0x8(%ebp),%eax
    b4f8:	83 c0 01             	add    $0x1,%eax
    b4fb:	8b 55 08             	mov    0x8(%ebp),%edx
    b4fe:	83 c2 02             	add    $0x2,%edx
    b501:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b504:	01 c9                	add    %ecx,%ecx
    b506:	89 cb                	mov    %ecx,%ebx
    b508:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b50b:	01 d9                	add    %ebx,%ecx
    b50d:	0f b6 09             	movzbl (%ecx),%ecx
    b510:	88 0a                	mov    %cl,(%edx)
    b512:	0f b6 12             	movzbl (%edx),%edx
    b515:	88 10                	mov    %dl,(%eax)
    b517:	0f b6 10             	movzbl (%eax),%edx
    b51a:	8b 45 08             	mov    0x8(%ebp),%eax
    b51d:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b51f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b523:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b526:	01 45 08             	add    %eax,0x8(%ebp)
    b529:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b52c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b52f:	75 c4                	jne    b4f5 <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b531:	e9 fe 00 00 00       	jmp    b634 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b536:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b53d:	eb 35                	jmp    b574 <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b53f:	8b 45 08             	mov    0x8(%ebp),%eax
    b542:	83 c0 01             	add    $0x1,%eax
    b545:	8b 55 08             	mov    0x8(%ebp),%edx
    b548:	83 c2 02             	add    $0x2,%edx
    b54b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b54e:	c1 e1 02             	shl    $0x2,%ecx
    b551:	89 cb                	mov    %ecx,%ebx
    b553:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b556:	01 d9                	add    %ebx,%ecx
    b558:	0f b6 09             	movzbl (%ecx),%ecx
    b55b:	88 0a                	mov    %cl,(%edx)
    b55d:	0f b6 12             	movzbl (%edx),%edx
    b560:	88 10                	mov    %dl,(%eax)
    b562:	0f b6 10             	movzbl (%eax),%edx
    b565:	8b 45 08             	mov    0x8(%ebp),%eax
    b568:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b56a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b56e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b571:	01 45 08             	add    %eax,0x8(%ebp)
    b574:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b577:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b57a:	75 c3                	jne    b53f <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b57c:	e9 b3 00 00 00       	jmp    b634 <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b581:	8b 45 14             	mov    0x14(%ebp),%eax
    b584:	8b 00                	mov    (%eax),%eax
    b586:	83 f8 06             	cmp    $0x6,%eax
    b589:	0f 85 a5 00 00 00    	jne    b634 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    b58f:	8b 45 14             	mov    0x14(%ebp),%eax
    b592:	8b 40 04             	mov    0x4(%eax),%eax
    b595:	83 f8 08             	cmp    $0x8,%eax
    b598:	75 38                	jne    b5d2 <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b59a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b5a1:	eb 25                	jmp    b5c8 <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    b5a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5a6:	c1 e0 02             	shl    $0x2,%eax
    b5a9:	89 c2                	mov    %eax,%edx
    b5ab:	8b 45 10             	mov    0x10(%ebp),%eax
    b5ae:	01 d0                	add    %edx,%eax
    b5b0:	6a 03                	push   $0x3
    b5b2:	50                   	push   %eax
    b5b3:	ff 75 08             	pushl  0x8(%ebp)
    b5b6:	e8 a8 7d ff ff       	call   3363 <lodepng_memcpy>
    b5bb:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5be:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b5c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b5c5:	01 45 08             	add    %eax,0x8(%ebp)
    b5c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5cb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b5ce:	75 d3                	jne    b5a3 <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b5d0:	eb 62                	jmp    b634 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5d2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b5d9:	eb 51                	jmp    b62c <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    b5db:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5de:	c1 e0 03             	shl    $0x3,%eax
    b5e1:	89 c2                	mov    %eax,%edx
    b5e3:	8b 45 10             	mov    0x10(%ebp),%eax
    b5e6:	01 d0                	add    %edx,%eax
    b5e8:	0f b6 10             	movzbl (%eax),%edx
    b5eb:	8b 45 08             	mov    0x8(%ebp),%eax
    b5ee:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b5f0:	8b 45 08             	mov    0x8(%ebp),%eax
    b5f3:	8d 50 01             	lea    0x1(%eax),%edx
    b5f6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5f9:	c1 e0 03             	shl    $0x3,%eax
    b5fc:	8d 48 02             	lea    0x2(%eax),%ecx
    b5ff:	8b 45 10             	mov    0x10(%ebp),%eax
    b602:	01 c8                	add    %ecx,%eax
    b604:	0f b6 00             	movzbl (%eax),%eax
    b607:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b609:	8b 45 08             	mov    0x8(%ebp),%eax
    b60c:	8d 50 02             	lea    0x2(%eax),%edx
    b60f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b612:	c1 e0 03             	shl    $0x3,%eax
    b615:	8d 48 04             	lea    0x4(%eax),%ecx
    b618:	8b 45 10             	mov    0x10(%ebp),%eax
    b61b:	01 c8                	add    %ecx,%eax
    b61d:	0f b6 00             	movzbl (%eax),%eax
    b620:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b622:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b626:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b629:	01 45 08             	add    %eax,0x8(%ebp)
    b62c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b62f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b632:	75 a7                	jne    b5db <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b634:	90                   	nop
    b635:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b638:	c9                   	leave  
    b639:	c3                   	ret    

0000b63a <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    b63a:	55                   	push   %ebp
    b63b:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    b63d:	8b 45 20             	mov    0x20(%ebp),%eax
    b640:	8b 00                	mov    (%eax),%eax
    b642:	85 c0                	test   %eax,%eax
    b644:	0f 85 a4 00 00 00    	jne    b6ee <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    b64a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b64d:	01 c0                	add    %eax,%eax
    b64f:	89 c2                	mov    %eax,%edx
    b651:	8b 45 18             	mov    0x18(%ebp),%eax
    b654:	01 d0                	add    %edx,%eax
    b656:	0f b6 00             	movzbl (%eax),%eax
    b659:	0f b6 c0             	movzbl %al,%eax
    b65c:	c1 e0 08             	shl    $0x8,%eax
    b65f:	89 c2                	mov    %eax,%edx
    b661:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b664:	01 c0                	add    %eax,%eax
    b666:	8d 48 01             	lea    0x1(%eax),%ecx
    b669:	8b 45 18             	mov    0x18(%ebp),%eax
    b66c:	01 c8                	add    %ecx,%eax
    b66e:	0f b6 00             	movzbl (%eax),%eax
    b671:	0f b6 c0             	movzbl %al,%eax
    b674:	01 c2                	add    %eax,%edx
    b676:	8b 45 10             	mov    0x10(%ebp),%eax
    b679:	66 89 10             	mov    %dx,(%eax)
    b67c:	8b 45 10             	mov    0x10(%ebp),%eax
    b67f:	0f b7 10             	movzwl (%eax),%edx
    b682:	8b 45 0c             	mov    0xc(%ebp),%eax
    b685:	66 89 10             	mov    %dx,(%eax)
    b688:	8b 45 0c             	mov    0xc(%ebp),%eax
    b68b:	0f b7 10             	movzwl (%eax),%edx
    b68e:	8b 45 08             	mov    0x8(%ebp),%eax
    b691:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    b694:	8b 45 20             	mov    0x20(%ebp),%eax
    b697:	8b 40 10             	mov    0x10(%eax),%eax
    b69a:	85 c0                	test   %eax,%eax
    b69c:	74 43                	je     b6e1 <getPixelColorRGBA16+0xa7>
    b69e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b6a1:	01 c0                	add    %eax,%eax
    b6a3:	89 c2                	mov    %eax,%edx
    b6a5:	8b 45 18             	mov    0x18(%ebp),%eax
    b6a8:	01 d0                	add    %edx,%eax
    b6aa:	0f b6 00             	movzbl (%eax),%eax
    b6ad:	0f b6 c0             	movzbl %al,%eax
    b6b0:	c1 e0 08             	shl    $0x8,%eax
    b6b3:	89 c2                	mov    %eax,%edx
    b6b5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b6b8:	01 c0                	add    %eax,%eax
    b6ba:	8d 48 01             	lea    0x1(%eax),%ecx
    b6bd:	8b 45 18             	mov    0x18(%ebp),%eax
    b6c0:	01 c8                	add    %ecx,%eax
    b6c2:	0f b6 00             	movzbl (%eax),%eax
    b6c5:	0f b6 c0             	movzbl %al,%eax
    b6c8:	01 c2                	add    %eax,%edx
    b6ca:	8b 45 20             	mov    0x20(%ebp),%eax
    b6cd:	8b 40 14             	mov    0x14(%eax),%eax
    b6d0:	39 c2                	cmp    %eax,%edx
    b6d2:	75 0d                	jne    b6e1 <getPixelColorRGBA16+0xa7>
    b6d4:	8b 45 14             	mov    0x14(%ebp),%eax
    b6d7:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b6dc:	e9 48 03 00 00       	jmp    ba29 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b6e1:	8b 45 14             	mov    0x14(%ebp),%eax
    b6e4:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b6e9:	e9 3b 03 00 00       	jmp    ba29 <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    b6ee:	8b 45 20             	mov    0x20(%ebp),%eax
    b6f1:	8b 00                	mov    (%eax),%eax
    b6f3:	83 f8 02             	cmp    $0x2,%eax
    b6f6:	0f 85 b6 01 00 00    	jne    b8b2 <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    b6fc:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b6ff:	89 d0                	mov    %edx,%eax
    b701:	01 c0                	add    %eax,%eax
    b703:	01 d0                	add    %edx,%eax
    b705:	01 c0                	add    %eax,%eax
    b707:	89 c2                	mov    %eax,%edx
    b709:	8b 45 18             	mov    0x18(%ebp),%eax
    b70c:	01 d0                	add    %edx,%eax
    b70e:	0f b6 00             	movzbl (%eax),%eax
    b711:	0f b6 c0             	movzbl %al,%eax
    b714:	c1 e0 08             	shl    $0x8,%eax
    b717:	89 c1                	mov    %eax,%ecx
    b719:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b71c:	89 d0                	mov    %edx,%eax
    b71e:	01 c0                	add    %eax,%eax
    b720:	01 d0                	add    %edx,%eax
    b722:	01 c0                	add    %eax,%eax
    b724:	8d 50 01             	lea    0x1(%eax),%edx
    b727:	8b 45 18             	mov    0x18(%ebp),%eax
    b72a:	01 d0                	add    %edx,%eax
    b72c:	0f b6 00             	movzbl (%eax),%eax
    b72f:	0f b6 c0             	movzbl %al,%eax
    b732:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b735:	8b 45 08             	mov    0x8(%ebp),%eax
    b738:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    b73b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b73e:	89 d0                	mov    %edx,%eax
    b740:	01 c0                	add    %eax,%eax
    b742:	01 d0                	add    %edx,%eax
    b744:	01 c0                	add    %eax,%eax
    b746:	8d 50 02             	lea    0x2(%eax),%edx
    b749:	8b 45 18             	mov    0x18(%ebp),%eax
    b74c:	01 d0                	add    %edx,%eax
    b74e:	0f b6 00             	movzbl (%eax),%eax
    b751:	0f b6 c0             	movzbl %al,%eax
    b754:	c1 e0 08             	shl    $0x8,%eax
    b757:	89 c1                	mov    %eax,%ecx
    b759:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b75c:	89 d0                	mov    %edx,%eax
    b75e:	01 c0                	add    %eax,%eax
    b760:	01 d0                	add    %edx,%eax
    b762:	01 c0                	add    %eax,%eax
    b764:	8d 50 03             	lea    0x3(%eax),%edx
    b767:	8b 45 18             	mov    0x18(%ebp),%eax
    b76a:	01 d0                	add    %edx,%eax
    b76c:	0f b6 00             	movzbl (%eax),%eax
    b76f:	0f b6 c0             	movzbl %al,%eax
    b772:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b775:	8b 45 0c             	mov    0xc(%ebp),%eax
    b778:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    b77b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b77e:	89 d0                	mov    %edx,%eax
    b780:	01 c0                	add    %eax,%eax
    b782:	01 d0                	add    %edx,%eax
    b784:	01 c0                	add    %eax,%eax
    b786:	8d 50 04             	lea    0x4(%eax),%edx
    b789:	8b 45 18             	mov    0x18(%ebp),%eax
    b78c:	01 d0                	add    %edx,%eax
    b78e:	0f b6 00             	movzbl (%eax),%eax
    b791:	0f b6 c0             	movzbl %al,%eax
    b794:	c1 e0 08             	shl    $0x8,%eax
    b797:	89 c1                	mov    %eax,%ecx
    b799:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b79c:	89 d0                	mov    %edx,%eax
    b79e:	01 c0                	add    %eax,%eax
    b7a0:	01 d0                	add    %edx,%eax
    b7a2:	01 c0                	add    %eax,%eax
    b7a4:	8d 50 05             	lea    0x5(%eax),%edx
    b7a7:	8b 45 18             	mov    0x18(%ebp),%eax
    b7aa:	01 d0                	add    %edx,%eax
    b7ac:	0f b6 00             	movzbl (%eax),%eax
    b7af:	0f b6 c0             	movzbl %al,%eax
    b7b2:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b7b5:	8b 45 10             	mov    0x10(%ebp),%eax
    b7b8:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    b7bb:	8b 45 20             	mov    0x20(%ebp),%eax
    b7be:	8b 40 10             	mov    0x10(%eax),%eax
    b7c1:	85 c0                	test   %eax,%eax
    b7c3:	0f 84 dc 00 00 00    	je     b8a5 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b7c9:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7cc:	89 d0                	mov    %edx,%eax
    b7ce:	01 c0                	add    %eax,%eax
    b7d0:	01 d0                	add    %edx,%eax
    b7d2:	01 c0                	add    %eax,%eax
    b7d4:	89 c2                	mov    %eax,%edx
    b7d6:	8b 45 18             	mov    0x18(%ebp),%eax
    b7d9:	01 d0                	add    %edx,%eax
    b7db:	0f b6 00             	movzbl (%eax),%eax
    b7de:	0f b6 c0             	movzbl %al,%eax
    b7e1:	c1 e0 08             	shl    $0x8,%eax
    b7e4:	89 c1                	mov    %eax,%ecx
    b7e6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b7e9:	89 d0                	mov    %edx,%eax
    b7eb:	01 c0                	add    %eax,%eax
    b7ed:	01 d0                	add    %edx,%eax
    b7ef:	01 c0                	add    %eax,%eax
    b7f1:	8d 50 01             	lea    0x1(%eax),%edx
    b7f4:	8b 45 18             	mov    0x18(%ebp),%eax
    b7f7:	01 d0                	add    %edx,%eax
    b7f9:	0f b6 00             	movzbl (%eax),%eax
    b7fc:	0f b6 c0             	movzbl %al,%eax
    b7ff:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b802:	8b 45 20             	mov    0x20(%ebp),%eax
    b805:	8b 40 14             	mov    0x14(%eax),%eax
    b808:	39 c2                	cmp    %eax,%edx
    b80a:	0f 85 95 00 00 00    	jne    b8a5 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b810:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b813:	89 d0                	mov    %edx,%eax
    b815:	01 c0                	add    %eax,%eax
    b817:	01 d0                	add    %edx,%eax
    b819:	01 c0                	add    %eax,%eax
    b81b:	8d 50 02             	lea    0x2(%eax),%edx
    b81e:	8b 45 18             	mov    0x18(%ebp),%eax
    b821:	01 d0                	add    %edx,%eax
    b823:	0f b6 00             	movzbl (%eax),%eax
    b826:	0f b6 c0             	movzbl %al,%eax
    b829:	c1 e0 08             	shl    $0x8,%eax
    b82c:	89 c1                	mov    %eax,%ecx
    b82e:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b831:	89 d0                	mov    %edx,%eax
    b833:	01 c0                	add    %eax,%eax
    b835:	01 d0                	add    %edx,%eax
    b837:	01 c0                	add    %eax,%eax
    b839:	8d 50 03             	lea    0x3(%eax),%edx
    b83c:	8b 45 18             	mov    0x18(%ebp),%eax
    b83f:	01 d0                	add    %edx,%eax
    b841:	0f b6 00             	movzbl (%eax),%eax
    b844:	0f b6 c0             	movzbl %al,%eax
    b847:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b84a:	8b 45 20             	mov    0x20(%ebp),%eax
    b84d:	8b 40 18             	mov    0x18(%eax),%eax
    b850:	39 c2                	cmp    %eax,%edx
    b852:	75 51                	jne    b8a5 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    b854:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b857:	89 d0                	mov    %edx,%eax
    b859:	01 c0                	add    %eax,%eax
    b85b:	01 d0                	add    %edx,%eax
    b85d:	01 c0                	add    %eax,%eax
    b85f:	8d 50 04             	lea    0x4(%eax),%edx
    b862:	8b 45 18             	mov    0x18(%ebp),%eax
    b865:	01 d0                	add    %edx,%eax
    b867:	0f b6 00             	movzbl (%eax),%eax
    b86a:	0f b6 c0             	movzbl %al,%eax
    b86d:	c1 e0 08             	shl    $0x8,%eax
    b870:	89 c1                	mov    %eax,%ecx
    b872:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b875:	89 d0                	mov    %edx,%eax
    b877:	01 c0                	add    %eax,%eax
    b879:	01 d0                	add    %edx,%eax
    b87b:	01 c0                	add    %eax,%eax
    b87d:	8d 50 05             	lea    0x5(%eax),%edx
    b880:	8b 45 18             	mov    0x18(%ebp),%eax
    b883:	01 d0                	add    %edx,%eax
    b885:	0f b6 00             	movzbl (%eax),%eax
    b888:	0f b6 c0             	movzbl %al,%eax
    b88b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b88e:	8b 45 20             	mov    0x20(%ebp),%eax
    b891:	8b 40 1c             	mov    0x1c(%eax),%eax
    b894:	39 c2                	cmp    %eax,%edx
    b896:	75 0d                	jne    b8a5 <getPixelColorRGBA16+0x26b>
    b898:	8b 45 14             	mov    0x14(%ebp),%eax
    b89b:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b8a0:	e9 84 01 00 00       	jmp    ba29 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b8a5:	8b 45 14             	mov    0x14(%ebp),%eax
    b8a8:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b8ad:	e9 77 01 00 00       	jmp    ba29 <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b8b2:	8b 45 20             	mov    0x20(%ebp),%eax
    b8b5:	8b 00                	mov    (%eax),%eax
    b8b7:	83 f8 04             	cmp    $0x4,%eax
    b8ba:	0f 85 86 00 00 00    	jne    b946 <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    b8c0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b8c3:	c1 e0 02             	shl    $0x2,%eax
    b8c6:	89 c2                	mov    %eax,%edx
    b8c8:	8b 45 18             	mov    0x18(%ebp),%eax
    b8cb:	01 d0                	add    %edx,%eax
    b8cd:	0f b6 00             	movzbl (%eax),%eax
    b8d0:	0f b6 c0             	movzbl %al,%eax
    b8d3:	c1 e0 08             	shl    $0x8,%eax
    b8d6:	89 c2                	mov    %eax,%edx
    b8d8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b8db:	c1 e0 02             	shl    $0x2,%eax
    b8de:	8d 48 01             	lea    0x1(%eax),%ecx
    b8e1:	8b 45 18             	mov    0x18(%ebp),%eax
    b8e4:	01 c8                	add    %ecx,%eax
    b8e6:	0f b6 00             	movzbl (%eax),%eax
    b8e9:	0f b6 c0             	movzbl %al,%eax
    b8ec:	01 c2                	add    %eax,%edx
    b8ee:	8b 45 10             	mov    0x10(%ebp),%eax
    b8f1:	66 89 10             	mov    %dx,(%eax)
    b8f4:	8b 45 10             	mov    0x10(%ebp),%eax
    b8f7:	0f b7 10             	movzwl (%eax),%edx
    b8fa:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8fd:	66 89 10             	mov    %dx,(%eax)
    b900:	8b 45 0c             	mov    0xc(%ebp),%eax
    b903:	0f b7 10             	movzwl (%eax),%edx
    b906:	8b 45 08             	mov    0x8(%ebp),%eax
    b909:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    b90c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b90f:	c1 e0 02             	shl    $0x2,%eax
    b912:	8d 50 02             	lea    0x2(%eax),%edx
    b915:	8b 45 18             	mov    0x18(%ebp),%eax
    b918:	01 d0                	add    %edx,%eax
    b91a:	0f b6 00             	movzbl (%eax),%eax
    b91d:	0f b6 c0             	movzbl %al,%eax
    b920:	c1 e0 08             	shl    $0x8,%eax
    b923:	89 c2                	mov    %eax,%edx
    b925:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b928:	c1 e0 02             	shl    $0x2,%eax
    b92b:	8d 48 03             	lea    0x3(%eax),%ecx
    b92e:	8b 45 18             	mov    0x18(%ebp),%eax
    b931:	01 c8                	add    %ecx,%eax
    b933:	0f b6 00             	movzbl (%eax),%eax
    b936:	0f b6 c0             	movzbl %al,%eax
    b939:	01 c2                	add    %eax,%edx
    b93b:	8b 45 14             	mov    0x14(%ebp),%eax
    b93e:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b941:	e9 e3 00 00 00       	jmp    ba29 <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    b946:	8b 45 20             	mov    0x20(%ebp),%eax
    b949:	8b 00                	mov    (%eax),%eax
    b94b:	83 f8 06             	cmp    $0x6,%eax
    b94e:	0f 85 d5 00 00 00    	jne    ba29 <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    b954:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b957:	c1 e0 03             	shl    $0x3,%eax
    b95a:	89 c2                	mov    %eax,%edx
    b95c:	8b 45 18             	mov    0x18(%ebp),%eax
    b95f:	01 d0                	add    %edx,%eax
    b961:	0f b6 00             	movzbl (%eax),%eax
    b964:	0f b6 c0             	movzbl %al,%eax
    b967:	c1 e0 08             	shl    $0x8,%eax
    b96a:	89 c2                	mov    %eax,%edx
    b96c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b96f:	c1 e0 03             	shl    $0x3,%eax
    b972:	8d 48 01             	lea    0x1(%eax),%ecx
    b975:	8b 45 18             	mov    0x18(%ebp),%eax
    b978:	01 c8                	add    %ecx,%eax
    b97a:	0f b6 00             	movzbl (%eax),%eax
    b97d:	0f b6 c0             	movzbl %al,%eax
    b980:	01 c2                	add    %eax,%edx
    b982:	8b 45 08             	mov    0x8(%ebp),%eax
    b985:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    b988:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b98b:	c1 e0 03             	shl    $0x3,%eax
    b98e:	8d 50 02             	lea    0x2(%eax),%edx
    b991:	8b 45 18             	mov    0x18(%ebp),%eax
    b994:	01 d0                	add    %edx,%eax
    b996:	0f b6 00             	movzbl (%eax),%eax
    b999:	0f b6 c0             	movzbl %al,%eax
    b99c:	c1 e0 08             	shl    $0x8,%eax
    b99f:	89 c2                	mov    %eax,%edx
    b9a1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9a4:	c1 e0 03             	shl    $0x3,%eax
    b9a7:	8d 48 03             	lea    0x3(%eax),%ecx
    b9aa:	8b 45 18             	mov    0x18(%ebp),%eax
    b9ad:	01 c8                	add    %ecx,%eax
    b9af:	0f b6 00             	movzbl (%eax),%eax
    b9b2:	0f b6 c0             	movzbl %al,%eax
    b9b5:	01 c2                	add    %eax,%edx
    b9b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    b9ba:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    b9bd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9c0:	c1 e0 03             	shl    $0x3,%eax
    b9c3:	8d 50 04             	lea    0x4(%eax),%edx
    b9c6:	8b 45 18             	mov    0x18(%ebp),%eax
    b9c9:	01 d0                	add    %edx,%eax
    b9cb:	0f b6 00             	movzbl (%eax),%eax
    b9ce:	0f b6 c0             	movzbl %al,%eax
    b9d1:	c1 e0 08             	shl    $0x8,%eax
    b9d4:	89 c2                	mov    %eax,%edx
    b9d6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9d9:	c1 e0 03             	shl    $0x3,%eax
    b9dc:	8d 48 05             	lea    0x5(%eax),%ecx
    b9df:	8b 45 18             	mov    0x18(%ebp),%eax
    b9e2:	01 c8                	add    %ecx,%eax
    b9e4:	0f b6 00             	movzbl (%eax),%eax
    b9e7:	0f b6 c0             	movzbl %al,%eax
    b9ea:	01 c2                	add    %eax,%edx
    b9ec:	8b 45 10             	mov    0x10(%ebp),%eax
    b9ef:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    b9f2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b9f5:	c1 e0 03             	shl    $0x3,%eax
    b9f8:	8d 50 06             	lea    0x6(%eax),%edx
    b9fb:	8b 45 18             	mov    0x18(%ebp),%eax
    b9fe:	01 d0                	add    %edx,%eax
    ba00:	0f b6 00             	movzbl (%eax),%eax
    ba03:	0f b6 c0             	movzbl %al,%eax
    ba06:	c1 e0 08             	shl    $0x8,%eax
    ba09:	89 c2                	mov    %eax,%edx
    ba0b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba0e:	c1 e0 03             	shl    $0x3,%eax
    ba11:	8d 48 07             	lea    0x7(%eax),%ecx
    ba14:	8b 45 18             	mov    0x18(%ebp),%eax
    ba17:	01 c8                	add    %ecx,%eax
    ba19:	0f b6 00             	movzbl (%eax),%eax
    ba1c:	0f b6 c0             	movzbl %al,%eax
    ba1f:	01 c2                	add    %eax,%edx
    ba21:	8b 45 14             	mov    0x14(%ebp),%eax
    ba24:	66 89 10             	mov    %dx,(%eax)
  }
}
    ba27:	eb 00                	jmp    ba29 <getPixelColorRGBA16+0x3ef>
    ba29:	90                   	nop
    ba2a:	5d                   	pop    %ebp
    ba2b:	c3                   	ret    

0000ba2c <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    ba2c:	55                   	push   %ebp
    ba2d:	89 e5                	mov    %esp,%ebp
    ba2f:	56                   	push   %esi
    ba30:	53                   	push   %ebx
    ba31:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    ba34:	8b 55 18             	mov    0x18(%ebp),%edx
    ba37:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba3a:	0f af c2             	imul   %edx,%eax
    ba3d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    ba40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    ba47:	8b 45 14             	mov    0x14(%ebp),%eax
    ba4a:	8b 00                	mov    (%eax),%eax
    ba4c:	83 f8 03             	cmp    $0x3,%eax
    ba4f:	75 14                	jne    ba65 <lodepng_convert+0x39>
    ba51:	8b 45 14             	mov    0x14(%ebp),%eax
    ba54:	8b 40 08             	mov    0x8(%eax),%eax
    ba57:	85 c0                	test   %eax,%eax
    ba59:	75 0a                	jne    ba65 <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    ba5b:	b8 6b 00 00 00       	mov    $0x6b,%eax
    ba60:	e9 19 03 00 00       	jmp    bd7e <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    ba65:	ff 75 14             	pushl  0x14(%ebp)
    ba68:	ff 75 10             	pushl  0x10(%ebp)
    ba6b:	e8 b7 d1 ff ff       	call   8c27 <lodepng_color_mode_equal>
    ba70:	83 c4 08             	add    $0x8,%esp
    ba73:	85 c0                	test   %eax,%eax
    ba75:	74 2f                	je     baa6 <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    ba77:	ff 75 14             	pushl  0x14(%ebp)
    ba7a:	ff 75 1c             	pushl  0x1c(%ebp)
    ba7d:	ff 75 18             	pushl  0x18(%ebp)
    ba80:	e8 fb d4 ff ff       	call   8f80 <lodepng_get_raw_size>
    ba85:	83 c4 0c             	add    $0xc,%esp
    ba88:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    ba8b:	ff 75 dc             	pushl  -0x24(%ebp)
    ba8e:	ff 75 0c             	pushl  0xc(%ebp)
    ba91:	ff 75 08             	pushl  0x8(%ebp)
    ba94:	e8 ca 78 ff ff       	call   3363 <lodepng_memcpy>
    ba99:	83 c4 0c             	add    $0xc,%esp
    return 0;
    ba9c:	b8 00 00 00 00       	mov    $0x0,%eax
    baa1:	e9 d8 02 00 00       	jmp    bd7e <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    baa6:	8b 45 10             	mov    0x10(%ebp),%eax
    baa9:	8b 00                	mov    (%eax),%eax
    baab:	83 f8 03             	cmp    $0x3,%eax
    baae:	0f 85 16 01 00 00    	jne    bbca <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    bab4:	8b 45 10             	mov    0x10(%ebp),%eax
    bab7:	8b 40 0c             	mov    0xc(%eax),%eax
    baba:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    babd:	8b 45 10             	mov    0x10(%ebp),%eax
    bac0:	8b 40 08             	mov    0x8(%eax),%eax
    bac3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    bac6:	8b 45 10             	mov    0x10(%ebp),%eax
    bac9:	8b 40 04             	mov    0x4(%eax),%eax
    bacc:	ba 01 00 00 00       	mov    $0x1,%edx
    bad1:	89 c1                	mov    %eax,%ecx
    bad3:	d3 e2                	shl    %cl,%edx
    bad5:	89 d0                	mov    %edx,%eax
    bad7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    bada:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    bade:	75 5b                	jne    bb3b <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    bae0:	8b 45 14             	mov    0x14(%ebp),%eax
    bae3:	8b 40 0c             	mov    0xc(%eax),%eax
    bae6:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    bae9:	8b 45 14             	mov    0x14(%ebp),%eax
    baec:	8b 40 08             	mov    0x8(%eax),%eax
    baef:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    baf2:	8b 45 14             	mov    0x14(%ebp),%eax
    baf5:	8b 00                	mov    (%eax),%eax
    baf7:	83 f8 03             	cmp    $0x3,%eax
    bafa:	75 3f                	jne    bb3b <lodepng_convert+0x10f>
    bafc:	8b 45 14             	mov    0x14(%ebp),%eax
    baff:	8b 50 04             	mov    0x4(%eax),%edx
    bb02:	8b 45 10             	mov    0x10(%ebp),%eax
    bb05:	8b 40 04             	mov    0x4(%eax),%eax
    bb08:	39 c2                	cmp    %eax,%edx
    bb0a:	75 2f                	jne    bb3b <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bb0c:	ff 75 14             	pushl  0x14(%ebp)
    bb0f:	ff 75 1c             	pushl  0x1c(%ebp)
    bb12:	ff 75 18             	pushl  0x18(%ebp)
    bb15:	e8 66 d4 ff ff       	call   8f80 <lodepng_get_raw_size>
    bb1a:	83 c4 0c             	add    $0xc,%esp
    bb1d:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    bb20:	ff 75 d8             	pushl  -0x28(%ebp)
    bb23:	ff 75 0c             	pushl  0xc(%ebp)
    bb26:	ff 75 08             	pushl  0x8(%ebp)
    bb29:	e8 35 78 ff ff       	call   3363 <lodepng_memcpy>
    bb2e:	83 c4 0c             	add    $0xc,%esp
        return 0;
    bb31:	b8 00 00 00 00       	mov    $0x0,%eax
    bb36:	e9 43 02 00 00       	jmp    bd7e <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    bb3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bb3e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bb41:	7d 06                	jge    bb49 <lodepng_convert+0x11d>
    bb43:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bb46:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    bb49:	8d 45 90             	lea    -0x70(%ebp),%eax
    bb4c:	50                   	push   %eax
    bb4d:	e8 5f e1 ff ff       	call   9cb1 <color_tree_init>
    bb52:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    bb55:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bb5c:	eb 61                	jmp    bbbf <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    bb5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bb61:	c1 e0 02             	shl    $0x2,%eax
    bb64:	89 c2                	mov    %eax,%edx
    bb66:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bb69:	01 d0                	add    %edx,%eax
    bb6b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    bb6e:	8b 75 f4             	mov    -0xc(%ebp),%esi
    bb71:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb74:	83 c0 03             	add    $0x3,%eax
    bb77:	0f b6 00             	movzbl (%eax),%eax
    bb7a:	0f b6 d8             	movzbl %al,%ebx
    bb7d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb80:	83 c0 02             	add    $0x2,%eax
    bb83:	0f b6 00             	movzbl (%eax),%eax
    bb86:	0f b6 c8             	movzbl %al,%ecx
    bb89:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb8c:	83 c0 01             	add    $0x1,%eax
    bb8f:	0f b6 00             	movzbl (%eax),%eax
    bb92:	0f b6 d0             	movzbl %al,%edx
    bb95:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bb98:	0f b6 00             	movzbl (%eax),%eax
    bb9b:	0f b6 c0             	movzbl %al,%eax
    bb9e:	83 ec 08             	sub    $0x8,%esp
    bba1:	56                   	push   %esi
    bba2:	53                   	push   %ebx
    bba3:	51                   	push   %ecx
    bba4:	52                   	push   %edx
    bba5:	50                   	push   %eax
    bba6:	8d 45 90             	lea    -0x70(%ebp),%eax
    bba9:	50                   	push   %eax
    bbaa:	e8 85 e2 ff ff       	call   9e34 <color_tree_add>
    bbaf:	83 c4 20             	add    $0x20,%esp
    bbb2:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    bbb5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bbb9:	75 0e                	jne    bbc9 <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    bbbb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bbbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bbc2:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bbc5:	75 97                	jne    bb5e <lodepng_convert+0x132>
    bbc7:	eb 01                	jmp    bbca <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    bbc9:	90                   	nop
    }
  }

  if(!error) {
    bbca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bbce:	0f 85 8e 01 00 00    	jne    bd62 <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bbd4:	8b 45 14             	mov    0x14(%ebp),%eax
    bbd7:	8b 40 04             	mov    0x4(%eax),%eax
    bbda:	83 f8 10             	cmp    $0x10,%eax
    bbdd:	0f 85 99 00 00 00    	jne    bc7c <lodepng_convert+0x250>
    bbe3:	8b 45 10             	mov    0x10(%ebp),%eax
    bbe6:	8b 40 04             	mov    0x4(%eax),%eax
    bbe9:	83 f8 10             	cmp    $0x10,%eax
    bbec:	0f 85 8a 00 00 00    	jne    bc7c <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    bbf2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bbf9:	eb 74                	jmp    bc6f <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    bbfb:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    bc01:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    bc07:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    bc0d:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    bc13:	83 ec 04             	sub    $0x4,%esp
    bc16:	ff 75 14             	pushl  0x14(%ebp)
    bc19:	ff 75 f4             	pushl  -0xc(%ebp)
    bc1c:	ff 75 0c             	pushl  0xc(%ebp)
    bc1f:	8d 45 88             	lea    -0x78(%ebp),%eax
    bc22:	50                   	push   %eax
    bc23:	8d 45 8a             	lea    -0x76(%ebp),%eax
    bc26:	50                   	push   %eax
    bc27:	8d 45 8c             	lea    -0x74(%ebp),%eax
    bc2a:	50                   	push   %eax
    bc2b:	8d 45 8e             	lea    -0x72(%ebp),%eax
    bc2e:	50                   	push   %eax
    bc2f:	e8 06 fa ff ff       	call   b63a <getPixelColorRGBA16>
    bc34:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    bc37:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    bc3b:	0f b7 d8             	movzwl %ax,%ebx
    bc3e:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    bc42:	0f b7 c8             	movzwl %ax,%ecx
    bc45:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    bc49:	0f b7 d0             	movzwl %ax,%edx
    bc4c:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    bc50:	0f b7 c0             	movzwl %ax,%eax
    bc53:	83 ec 04             	sub    $0x4,%esp
    bc56:	53                   	push   %ebx
    bc57:	51                   	push   %ecx
    bc58:	52                   	push   %edx
    bc59:	50                   	push   %eax
    bc5a:	ff 75 10             	pushl  0x10(%ebp)
    bc5d:	ff 75 f4             	pushl  -0xc(%ebp)
    bc60:	ff 75 08             	pushl  0x8(%ebp)
    bc63:	e8 d3 e6 ff ff       	call   a33b <rgba16ToPixel>
    bc68:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    bc6b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bc6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bc72:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bc75:	75 84                	jne    bbfb <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bc77:	e9 e6 00 00 00       	jmp    bd62 <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    bc7c:	8b 45 10             	mov    0x10(%ebp),%eax
    bc7f:	8b 40 04             	mov    0x4(%eax),%eax
    bc82:	83 f8 08             	cmp    $0x8,%eax
    bc85:	75 23                	jne    bcaa <lodepng_convert+0x27e>
    bc87:	8b 45 10             	mov    0x10(%ebp),%eax
    bc8a:	8b 00                	mov    (%eax),%eax
    bc8c:	83 f8 06             	cmp    $0x6,%eax
    bc8f:	75 19                	jne    bcaa <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    bc91:	ff 75 14             	pushl  0x14(%ebp)
    bc94:	ff 75 0c             	pushl  0xc(%ebp)
    bc97:	ff 75 e0             	pushl  -0x20(%ebp)
    bc9a:	ff 75 08             	pushl  0x8(%ebp)
    bc9d:	e8 ae ee ff ff       	call   ab50 <getPixelColorsRGBA8>
    bca2:	83 c4 10             	add    $0x10,%esp
    bca5:	e9 b8 00 00 00       	jmp    bd62 <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    bcaa:	8b 45 10             	mov    0x10(%ebp),%eax
    bcad:	8b 40 04             	mov    0x4(%eax),%eax
    bcb0:	83 f8 08             	cmp    $0x8,%eax
    bcb3:	75 23                	jne    bcd8 <lodepng_convert+0x2ac>
    bcb5:	8b 45 10             	mov    0x10(%ebp),%eax
    bcb8:	8b 00                	mov    (%eax),%eax
    bcba:	83 f8 02             	cmp    $0x2,%eax
    bcbd:	75 19                	jne    bcd8 <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    bcbf:	ff 75 14             	pushl  0x14(%ebp)
    bcc2:	ff 75 0c             	pushl  0xc(%ebp)
    bcc5:	ff 75 e0             	pushl  -0x20(%ebp)
    bcc8:	ff 75 08             	pushl  0x8(%ebp)
    bccb:	e8 50 f5 ff ff       	call   b220 <getPixelColorsRGB8>
    bcd0:	83 c4 10             	add    $0x10,%esp
    bcd3:	e9 8a 00 00 00       	jmp    bd62 <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    bcd8:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    bcdc:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    bce0:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    bce4:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    bce8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bcef:	eb 66                	jmp    bd57 <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    bcf1:	83 ec 04             	sub    $0x4,%esp
    bcf4:	ff 75 14             	pushl  0x14(%ebp)
    bcf7:	ff 75 f4             	pushl  -0xc(%ebp)
    bcfa:	ff 75 0c             	pushl  0xc(%ebp)
    bcfd:	8d 45 84             	lea    -0x7c(%ebp),%eax
    bd00:	50                   	push   %eax
    bd01:	8d 45 85             	lea    -0x7b(%ebp),%eax
    bd04:	50                   	push   %eax
    bd05:	8d 45 86             	lea    -0x7a(%ebp),%eax
    bd08:	50                   	push   %eax
    bd09:	8d 45 87             	lea    -0x79(%ebp),%eax
    bd0c:	50                   	push   %eax
    bd0d:	e8 71 e8 ff ff       	call   a583 <getPixelColorRGBA8>
    bd12:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    bd15:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    bd19:	0f b6 d8             	movzbl %al,%ebx
    bd1c:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    bd20:	0f b6 c8             	movzbl %al,%ecx
    bd23:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    bd27:	0f b6 d0             	movzbl %al,%edx
    bd2a:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    bd2e:	0f b6 c0             	movzbl %al,%eax
    bd31:	53                   	push   %ebx
    bd32:	51                   	push   %ecx
    bd33:	52                   	push   %edx
    bd34:	50                   	push   %eax
    bd35:	8d 45 90             	lea    -0x70(%ebp),%eax
    bd38:	50                   	push   %eax
    bd39:	ff 75 10             	pushl  0x10(%ebp)
    bd3c:	ff 75 f4             	pushl  -0xc(%ebp)
    bd3f:	ff 75 08             	pushl  0x8(%ebp)
    bd42:	e8 e5 e1 ff ff       	call   9f2c <rgba8ToPixel>
    bd47:	83 c4 20             	add    $0x20,%esp
    bd4a:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    bd4d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bd51:	75 0e                	jne    bd61 <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    bd53:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bd57:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bd5a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bd5d:	75 92                	jne    bcf1 <lodepng_convert+0x2c5>
    bd5f:	eb 01                	jmp    bd62 <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    bd61:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    bd62:	8b 45 10             	mov    0x10(%ebp),%eax
    bd65:	8b 00                	mov    (%eax),%eax
    bd67:	83 f8 03             	cmp    $0x3,%eax
    bd6a:	75 0f                	jne    bd7b <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    bd6c:	83 ec 0c             	sub    $0xc,%esp
    bd6f:	8d 45 90             	lea    -0x70(%ebp),%eax
    bd72:	50                   	push   %eax
    bd73:	e8 59 df ff ff       	call   9cd1 <color_tree_cleanup>
    bd78:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    bd7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    bd7e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    bd81:	5b                   	pop    %ebx
    bd82:	5e                   	pop    %esi
    bd83:	5d                   	pop    %ebp
    bd84:	c3                   	ret    

0000bd85 <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    bd85:	55                   	push   %ebp
    bd86:	89 e5                	mov    %esp,%ebp
    bd88:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    bd8b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    bd92:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bd99:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    bda0:	8b 45 24             	mov    0x24(%ebp),%eax
    bda3:	8b 40 04             	mov    0x4(%eax),%eax
    bda6:	ba 01 00 00 00       	mov    $0x1,%edx
    bdab:	89 c1                	mov    %eax,%ecx
    bdad:	d3 e2                	shl    %cl,%edx
    bdaf:	89 d0                	mov    %edx,%eax
    bdb1:	8d 48 ff             	lea    -0x1(%eax),%ecx
    bdb4:	b8 ff ff 00 00       	mov    $0xffff,%eax
    bdb9:	ba 00 00 00 00       	mov    $0x0,%edx
    bdbe:	f7 f1                	div    %ecx
    bdc0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    bdc3:	8b 45 20             	mov    0x20(%ebp),%eax
    bdc6:	8b 40 04             	mov    0x4(%eax),%eax
    bdc9:	ba 10 00 00 00       	mov    $0x10,%edx
    bdce:	29 c2                	sub    %eax,%edx
    bdd0:	89 d0                	mov    %edx,%eax
    bdd2:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    bdd5:	8b 45 24             	mov    0x24(%ebp),%eax
    bdd8:	8b 00                	mov    (%eax),%eax
    bdda:	85 c0                	test   %eax,%eax
    bddc:	74 0a                	je     bde8 <lodepng_convert_rgb+0x63>
    bdde:	8b 45 24             	mov    0x24(%ebp),%eax
    bde1:	8b 00                	mov    (%eax),%eax
    bde3:	83 f8 04             	cmp    $0x4,%eax
    bde6:	75 1b                	jne    be03 <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    bde8:	8b 45 14             	mov    0x14(%ebp),%eax
    bdeb:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bdef:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bdf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bdf5:	89 45 f8             	mov    %eax,-0x8(%ebp)
    bdf8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bdfb:	89 45 fc             	mov    %eax,-0x4(%ebp)
    bdfe:	e9 c2 00 00 00       	jmp    bec5 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    be03:	8b 45 24             	mov    0x24(%ebp),%eax
    be06:	8b 00                	mov    (%eax),%eax
    be08:	83 f8 02             	cmp    $0x2,%eax
    be0b:	74 0a                	je     be17 <lodepng_convert_rgb+0x92>
    be0d:	8b 45 24             	mov    0x24(%ebp),%eax
    be10:	8b 00                	mov    (%eax),%eax
    be12:	83 f8 06             	cmp    $0x6,%eax
    be15:	75 23                	jne    be3a <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    be17:	8b 45 14             	mov    0x14(%ebp),%eax
    be1a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be1e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    be21:	8b 45 18             	mov    0x18(%ebp),%eax
    be24:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be28:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    be2b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    be2e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    be32:	89 45 f4             	mov    %eax,-0xc(%ebp)
    be35:	e9 8b 00 00 00       	jmp    bec5 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    be3a:	8b 45 24             	mov    0x24(%ebp),%eax
    be3d:	8b 00                	mov    (%eax),%eax
    be3f:	83 f8 03             	cmp    $0x3,%eax
    be42:	75 77                	jne    bebb <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    be44:	8b 45 24             	mov    0x24(%ebp),%eax
    be47:	8b 40 0c             	mov    0xc(%eax),%eax
    be4a:	3b 45 14             	cmp    0x14(%ebp),%eax
    be4d:	77 0a                	ja     be59 <lodepng_convert_rgb+0xd4>
    be4f:	b8 52 00 00 00       	mov    $0x52,%eax
    be54:	e9 cb 01 00 00       	jmp    c024 <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    be59:	8b 45 24             	mov    0x24(%ebp),%eax
    be5c:	8b 40 08             	mov    0x8(%eax),%eax
    be5f:	8b 55 14             	mov    0x14(%ebp),%edx
    be62:	c1 e2 02             	shl    $0x2,%edx
    be65:	01 d0                	add    %edx,%eax
    be67:	0f b6 00             	movzbl (%eax),%eax
    be6a:	0f b6 d0             	movzbl %al,%edx
    be6d:	89 d0                	mov    %edx,%eax
    be6f:	c1 e0 08             	shl    $0x8,%eax
    be72:	01 d0                	add    %edx,%eax
    be74:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    be77:	8b 45 24             	mov    0x24(%ebp),%eax
    be7a:	8b 40 08             	mov    0x8(%eax),%eax
    be7d:	8b 55 14             	mov    0x14(%ebp),%edx
    be80:	c1 e2 02             	shl    $0x2,%edx
    be83:	83 c2 01             	add    $0x1,%edx
    be86:	01 d0                	add    %edx,%eax
    be88:	0f b6 00             	movzbl (%eax),%eax
    be8b:	0f b6 d0             	movzbl %al,%edx
    be8e:	89 d0                	mov    %edx,%eax
    be90:	c1 e0 08             	shl    $0x8,%eax
    be93:	01 d0                	add    %edx,%eax
    be95:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    be98:	8b 45 24             	mov    0x24(%ebp),%eax
    be9b:	8b 40 08             	mov    0x8(%eax),%eax
    be9e:	8b 55 14             	mov    0x14(%ebp),%edx
    bea1:	c1 e2 02             	shl    $0x2,%edx
    bea4:	83 c2 02             	add    $0x2,%edx
    bea7:	01 d0                	add    %edx,%eax
    bea9:	0f b6 00             	movzbl (%eax),%eax
    beac:	0f b6 d0             	movzbl %al,%edx
    beaf:	89 d0                	mov    %edx,%eax
    beb1:	c1 e0 08             	shl    $0x8,%eax
    beb4:	01 d0                	add    %edx,%eax
    beb6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    beb9:	eb 0a                	jmp    bec5 <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    bebb:	b8 1f 00 00 00       	mov    $0x1f,%eax
    bec0:	e9 5f 01 00 00       	jmp    c024 <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    bec5:	8b 45 20             	mov    0x20(%ebp),%eax
    bec8:	8b 00                	mov    (%eax),%eax
    beca:	85 c0                	test   %eax,%eax
    becc:	74 0a                	je     bed8 <lodepng_convert_rgb+0x153>
    bece:	8b 45 20             	mov    0x20(%ebp),%eax
    bed1:	8b 00                	mov    (%eax),%eax
    bed3:	83 f8 04             	cmp    $0x4,%eax
    bed6:	75 14                	jne    beec <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    bed8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bedb:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bede:	89 c1                	mov    %eax,%ecx
    bee0:	d3 ea                	shr    %cl,%edx
    bee2:	8b 45 08             	mov    0x8(%ebp),%eax
    bee5:	89 10                	mov    %edx,(%eax)
    bee7:	e9 33 01 00 00       	jmp    c01f <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    beec:	8b 45 20             	mov    0x20(%ebp),%eax
    beef:	8b 00                	mov    (%eax),%eax
    bef1:	83 f8 02             	cmp    $0x2,%eax
    bef4:	74 0a                	je     bf00 <lodepng_convert_rgb+0x17b>
    bef6:	8b 45 20             	mov    0x20(%ebp),%eax
    bef9:	8b 00                	mov    (%eax),%eax
    befb:	83 f8 06             	cmp    $0x6,%eax
    befe:	75 32                	jne    bf32 <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    bf00:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf03:	8b 55 fc             	mov    -0x4(%ebp),%edx
    bf06:	89 c1                	mov    %eax,%ecx
    bf08:	d3 ea                	shr    %cl,%edx
    bf0a:	8b 45 08             	mov    0x8(%ebp),%eax
    bf0d:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    bf0f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf12:	8b 55 f8             	mov    -0x8(%ebp),%edx
    bf15:	89 c1                	mov    %eax,%ecx
    bf17:	d3 ea                	shr    %cl,%edx
    bf19:	8b 45 0c             	mov    0xc(%ebp),%eax
    bf1c:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    bf1e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bf21:	8b 55 f4             	mov    -0xc(%ebp),%edx
    bf24:	89 c1                	mov    %eax,%ecx
    bf26:	d3 ea                	shr    %cl,%edx
    bf28:	8b 45 10             	mov    0x10(%ebp),%eax
    bf2b:	89 10                	mov    %edx,(%eax)
    bf2d:	e9 ed 00 00 00       	jmp    c01f <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    bf32:	8b 45 20             	mov    0x20(%ebp),%eax
    bf35:	8b 00                	mov    (%eax),%eax
    bf37:	83 f8 03             	cmp    $0x3,%eax
    bf3a:	0f 85 d8 00 00 00    	jne    c018 <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    bf40:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bf43:	c1 e8 08             	shr    $0x8,%eax
    bf46:	89 c2                	mov    %eax,%edx
    bf48:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bf4b:	0f b6 c0             	movzbl %al,%eax
    bf4e:	39 c2                	cmp    %eax,%edx
    bf50:	75 24                	jne    bf76 <lodepng_convert_rgb+0x1f1>
    bf52:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bf55:	c1 e8 08             	shr    $0x8,%eax
    bf58:	89 c2                	mov    %eax,%edx
    bf5a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bf5d:	0f b6 c0             	movzbl %al,%eax
    bf60:	39 c2                	cmp    %eax,%edx
    bf62:	75 12                	jne    bf76 <lodepng_convert_rgb+0x1f1>
    bf64:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf67:	c1 e8 08             	shr    $0x8,%eax
    bf6a:	89 c2                	mov    %eax,%edx
    bf6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf6f:	0f b6 c0             	movzbl %al,%eax
    bf72:	39 c2                	cmp    %eax,%edx
    bf74:	74 0a                	je     bf80 <lodepng_convert_rgb+0x1fb>
    bf76:	b8 52 00 00 00       	mov    $0x52,%eax
    bf7b:	e9 a4 00 00 00       	jmp    c024 <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    bf80:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    bf87:	eb 79                	jmp    c002 <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    bf89:	8b 45 f0             	mov    -0x10(%ebp),%eax
    bf8c:	c1 e0 02             	shl    $0x2,%eax
    bf8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    bf92:	8b 45 fc             	mov    -0x4(%ebp),%eax
    bf95:	c1 e8 08             	shr    $0x8,%eax
    bf98:	89 c1                	mov    %eax,%ecx
    bf9a:	8b 45 20             	mov    0x20(%ebp),%eax
    bf9d:	8b 50 08             	mov    0x8(%eax),%edx
    bfa0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    bfa3:	01 d0                	add    %edx,%eax
    bfa5:	0f b6 00             	movzbl (%eax),%eax
    bfa8:	0f b6 c0             	movzbl %al,%eax
    bfab:	39 c1                	cmp    %eax,%ecx
    bfad:	75 4f                	jne    bffe <lodepng_convert_rgb+0x279>
    bfaf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bfb2:	c1 e8 08             	shr    $0x8,%eax
    bfb5:	89 c1                	mov    %eax,%ecx
    bfb7:	8b 45 20             	mov    0x20(%ebp),%eax
    bfba:	8b 40 08             	mov    0x8(%eax),%eax
    bfbd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    bfc0:	83 c2 01             	add    $0x1,%edx
    bfc3:	01 d0                	add    %edx,%eax
    bfc5:	0f b6 00             	movzbl (%eax),%eax
    bfc8:	0f b6 c0             	movzbl %al,%eax
    bfcb:	39 c1                	cmp    %eax,%ecx
    bfcd:	75 2f                	jne    bffe <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    bfcf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bfd2:	c1 e8 08             	shr    $0x8,%eax
    bfd5:	89 c1                	mov    %eax,%ecx
    bfd7:	8b 45 20             	mov    0x20(%ebp),%eax
    bfda:	8b 40 08             	mov    0x8(%eax),%eax
    bfdd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    bfe0:	83 c2 02             	add    $0x2,%edx
    bfe3:	01 d0                	add    %edx,%eax
    bfe5:	0f b6 00             	movzbl (%eax),%eax
    bfe8:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    bfeb:	39 c1                	cmp    %eax,%ecx
    bfed:	75 0f                	jne    bffe <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    bfef:	8b 45 08             	mov    0x8(%ebp),%eax
    bff2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    bff5:	89 10                	mov    %edx,(%eax)
        return 0;
    bff7:	b8 00 00 00 00       	mov    $0x0,%eax
    bffc:	eb 26                	jmp    c024 <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    bffe:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c002:	8b 45 20             	mov    0x20(%ebp),%eax
    c005:	8b 40 0c             	mov    0xc(%eax),%eax
    c008:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    c00b:	0f 87 78 ff ff ff    	ja     bf89 <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    c011:	b8 52 00 00 00       	mov    $0x52,%eax
    c016:	eb 0c                	jmp    c024 <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    c018:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c01d:	eb 05                	jmp    c024 <lodepng_convert_rgb+0x29f>
  }

  return 0;
    c01f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c024:	c9                   	leave  
    c025:	c3                   	ret    

0000c026 <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    c026:	55                   	push   %ebp
    c027:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    c029:	8b 45 08             	mov    0x8(%ebp),%eax
    c02c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    c032:	8b 45 08             	mov    0x8(%ebp),%eax
    c035:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    c03c:	8b 45 08             	mov    0x8(%ebp),%eax
    c03f:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    c045:	8b 45 08             	mov    0x8(%ebp),%eax
    c048:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c04c:	8b 45 08             	mov    0x8(%ebp),%eax
    c04f:	66 89 50 0a          	mov    %dx,0xa(%eax)
    c053:	8b 45 08             	mov    0x8(%ebp),%eax
    c056:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c05a:	8b 45 08             	mov    0x8(%ebp),%eax
    c05d:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    c061:	8b 45 08             	mov    0x8(%ebp),%eax
    c064:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    c06b:	8b 45 08             	mov    0x8(%ebp),%eax
    c06e:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    c075:	8b 45 08             	mov    0x8(%ebp),%eax
    c078:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    c07f:	00 00 00 
  stats->numpixels = 0;
    c082:	8b 45 08             	mov    0x8(%ebp),%eax
    c085:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    c08c:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    c08f:	8b 45 08             	mov    0x8(%ebp),%eax
    c092:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    c099:	00 00 00 
  stats->allow_greyscale = 1;
    c09c:	8b 45 08             	mov    0x8(%ebp),%eax
    c09f:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    c0a6:	00 00 00 
}
    c0a9:	90                   	nop
    c0aa:	5d                   	pop    %ebp
    c0ab:	c3                   	ret    

0000c0ac <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    c0ac:	55                   	push   %ebp
    c0ad:	89 e5                	mov    %esp,%ebp
    c0af:	53                   	push   %ebx
    c0b0:	83 ec 04             	sub    $0x4,%esp
    c0b3:	8b 45 08             	mov    0x8(%ebp),%eax
    c0b6:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    c0b9:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    c0bd:	74 06                	je     c0c5 <getValueRequiredBits+0x19>
    c0bf:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    c0c3:	75 07                	jne    c0cc <getValueRequiredBits+0x20>
    c0c5:	b8 01 00 00 00       	mov    $0x1,%eax
    c0ca:	eb 6b                	jmp    c137 <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    c0cc:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c0d0:	0f b6 d9             	movzbl %cl,%ebx
    c0d3:	89 da                	mov    %ebx,%edx
    c0d5:	89 d0                	mov    %edx,%eax
    c0d7:	c1 e0 04             	shl    $0x4,%eax
    c0da:	89 c2                	mov    %eax,%edx
    c0dc:	89 d0                	mov    %edx,%eax
    c0de:	c1 e0 04             	shl    $0x4,%eax
    c0e1:	29 d0                	sub    %edx,%eax
    c0e3:	01 d8                	add    %ebx,%eax
    c0e5:	66 c1 e8 08          	shr    $0x8,%ax
    c0e9:	c0 e8 04             	shr    $0x4,%al
    c0ec:	89 c2                	mov    %eax,%edx
    c0ee:	c1 e2 04             	shl    $0x4,%edx
    c0f1:	01 c2                	add    %eax,%edx
    c0f3:	89 c8                	mov    %ecx,%eax
    c0f5:	29 d0                	sub    %edx,%eax
    c0f7:	84 c0                	test   %al,%al
    c0f9:	75 37                	jne    c132 <getValueRequiredBits+0x86>
    c0fb:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c0ff:	0f b6 d1             	movzbl %cl,%edx
    c102:	89 d0                	mov    %edx,%eax
    c104:	01 c0                	add    %eax,%eax
    c106:	01 d0                	add    %edx,%eax
    c108:	c1 e0 06             	shl    $0x6,%eax
    c10b:	01 d0                	add    %edx,%eax
    c10d:	66 c1 e8 08          	shr    $0x8,%ax
    c111:	c0 e8 06             	shr    $0x6,%al
    c114:	ba 55 00 00 00       	mov    $0x55,%edx
    c119:	0f af c2             	imul   %edx,%eax
    c11c:	29 c1                	sub    %eax,%ecx
    c11e:	89 c8                	mov    %ecx,%eax
    c120:	84 c0                	test   %al,%al
    c122:	75 07                	jne    c12b <getValueRequiredBits+0x7f>
    c124:	b8 02 00 00 00       	mov    $0x2,%eax
    c129:	eb 0c                	jmp    c137 <getValueRequiredBits+0x8b>
    c12b:	b8 04 00 00 00       	mov    $0x4,%eax
    c130:	eb 05                	jmp    c137 <getValueRequiredBits+0x8b>
  return 8;
    c132:	b8 08 00 00 00       	mov    $0x8,%eax
}
    c137:	83 c4 04             	add    $0x4,%esp
    c13a:	5b                   	pop    %ebx
    c13b:	5d                   	pop    %ebp
    c13c:	c3                   	ret    

0000c13d <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    c13d:	55                   	push   %ebp
    c13e:	89 e5                	mov    %esp,%ebp
    c140:	56                   	push   %esi
    c141:	53                   	push   %ebx
    c142:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c148:	8b 55 10             	mov    0x10(%ebp),%edx
    c14b:	8b 45 14             	mov    0x14(%ebp),%eax
    c14e:	0f af c2             	imul   %edx,%eax
    c151:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    c154:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    c15b:	ff 75 18             	pushl  0x18(%ebp)
    c15e:	e8 0b cd ff ff       	call   8e6e <lodepng_is_greyscale_type>
    c163:	83 c4 04             	add    $0x4,%esp
    c166:	85 c0                	test   %eax,%eax
    c168:	0f 95 c0             	setne  %al
    c16b:	0f b6 c0             	movzbl %al,%eax
    c16e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    c171:	ff 75 18             	pushl  0x18(%ebp)
    c174:	e8 85 cd ff ff       	call   8efe <lodepng_can_have_alpha>
    c179:	83 c4 04             	add    $0x4,%esp
    c17c:	85 c0                	test   %eax,%eax
    c17e:	0f 94 c0             	sete   %al
    c181:	0f b6 c0             	movzbl %al,%eax
    c184:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    c187:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    c18e:	ff 75 18             	pushl  0x18(%ebp)
    c191:	e8 ab cc ff ff       	call   8e41 <lodepng_get_bpp>
    c196:	83 c4 04             	add    $0x4,%esp
    c199:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    c19c:	8b 45 08             	mov    0x8(%ebp),%eax
    c19f:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c1a5:	83 f8 01             	cmp    $0x1,%eax
    c1a8:	75 0d                	jne    c1b7 <lodepng_compute_color_stats+0x7a>
    c1aa:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    c1ae:	75 07                	jne    c1b7 <lodepng_compute_color_stats+0x7a>
    c1b0:	b8 01 00 00 00       	mov    $0x1,%eax
    c1b5:	eb 05                	jmp    c1bc <lodepng_compute_color_stats+0x7f>
    c1b7:	b8 00 00 00 00       	mov    $0x0,%eax
    c1bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    c1bf:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    c1c6:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    c1cd:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    c1d1:	77 26                	ja     c1f9 <lodepng_compute_color_stats+0xbc>
    c1d3:	8b 45 08             	mov    0x8(%ebp),%eax
    c1d6:	8b 50 14             	mov    0x14(%eax),%edx
    c1d9:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c1dc:	bb 01 00 00 00       	mov    $0x1,%ebx
    c1e1:	89 c1                	mov    %eax,%ecx
    c1e3:	d3 e3                	shl    %cl,%ebx
    c1e5:	89 d8                	mov    %ebx,%eax
    c1e7:	01 d0                	add    %edx,%eax
    c1e9:	ba 01 01 00 00       	mov    $0x101,%edx
    c1ee:	3d 01 01 00 00       	cmp    $0x101,%eax
    c1f3:	0f 47 c2             	cmova  %edx,%eax
    c1f6:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    c1f9:	8b 45 08             	mov    0x8(%ebp),%eax
    c1fc:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    c202:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c205:	01 c2                	add    %eax,%edx
    c207:	8b 45 08             	mov    0x8(%ebp),%eax
    c20a:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    c210:	8b 45 08             	mov    0x8(%ebp),%eax
    c213:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    c219:	85 c0                	test   %eax,%eax
    c21b:	75 07                	jne    c224 <lodepng_compute_color_stats+0xe7>
    c21d:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    c224:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c22a:	50                   	push   %eax
    c22b:	e8 81 da ff ff       	call   9cb1 <color_tree_init>
    c230:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    c233:	8b 45 08             	mov    0x8(%ebp),%eax
    c236:	8b 40 10             	mov    0x10(%eax),%eax
    c239:	85 c0                	test   %eax,%eax
    c23b:	74 07                	je     c244 <lodepng_compute_color_stats+0x107>
    c23d:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    c244:	8b 45 08             	mov    0x8(%ebp),%eax
    c247:	8b 00                	mov    (%eax),%eax
    c249:	85 c0                	test   %eax,%eax
    c24b:	74 07                	je     c254 <lodepng_compute_color_stats+0x117>
    c24d:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    c254:	8b 45 08             	mov    0x8(%ebp),%eax
    c257:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c25d:	83 f8 10             	cmp    $0x10,%eax
    c260:	75 07                	jne    c269 <lodepng_compute_color_stats+0x12c>
    c262:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    c269:	8b 45 08             	mov    0x8(%ebp),%eax
    c26c:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c272:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c275:	72 07                	jb     c27e <lodepng_compute_color_stats+0x141>
    c277:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    c27e:	8b 45 08             	mov    0x8(%ebp),%eax
    c281:	8b 40 14             	mov    0x14(%eax),%eax
    c284:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c287:	72 07                	jb     c290 <lodepng_compute_color_stats+0x153>
    c289:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    c290:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c294:	0f 85 82 00 00 00    	jne    c31c <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    c29a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c2a1:	eb 6c                	jmp    c30f <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    c2a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c2a6:	c1 e0 02             	shl    $0x2,%eax
    c2a9:	8d 50 10             	lea    0x10(%eax),%edx
    c2ac:	8b 45 08             	mov    0x8(%ebp),%eax
    c2af:	01 d0                	add    %edx,%eax
    c2b1:	83 c0 08             	add    $0x8,%eax
    c2b4:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    c2b7:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c2ba:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2bd:	83 c0 03             	add    $0x3,%eax
    c2c0:	0f b6 00             	movzbl (%eax),%eax
    c2c3:	0f b6 d8             	movzbl %al,%ebx
    c2c6:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2c9:	83 c0 02             	add    $0x2,%eax
    c2cc:	0f b6 00             	movzbl (%eax),%eax
    c2cf:	0f b6 c8             	movzbl %al,%ecx
    c2d2:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2d5:	83 c0 01             	add    $0x1,%eax
    c2d8:	0f b6 00             	movzbl (%eax),%eax
    c2db:	0f b6 d0             	movzbl %al,%edx
    c2de:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c2e1:	0f b6 00             	movzbl (%eax),%eax
    c2e4:	0f b6 c0             	movzbl %al,%eax
    c2e7:	83 ec 08             	sub    $0x8,%esp
    c2ea:	56                   	push   %esi
    c2eb:	53                   	push   %ebx
    c2ec:	51                   	push   %ecx
    c2ed:	52                   	push   %edx
    c2ee:	50                   	push   %eax
    c2ef:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c2f5:	50                   	push   %eax
    c2f6:	e8 39 db ff ff       	call   9e34 <color_tree_add>
    c2fb:	83 c4 20             	add    $0x20,%esp
    c2fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    c301:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c305:	0f 85 22 09 00 00    	jne    cc2d <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    c30b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c30f:	8b 45 08             	mov    0x8(%ebp),%eax
    c312:	8b 50 14             	mov    0x14(%eax),%edx
    c315:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c318:	39 c2                	cmp    %eax,%edx
    c31a:	77 87                	ja     c2a3 <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    c31c:	8b 45 18             	mov    0x18(%ebp),%eax
    c31f:	8b 40 04             	mov    0x4(%eax),%eax
    c322:	83 f8 10             	cmp    $0x10,%eax
    c325:	0f 85 1e 01 00 00    	jne    c449 <lodepng_compute_color_stats+0x30c>
    c32b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c32f:	0f 85 14 01 00 00    	jne    c449 <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c335:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    c33c:	00 00 
    c33e:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    c345:	00 00 
    c347:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    c34e:	00 00 
    c350:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    c357:	00 00 
    for(i = 0; i != numpixels; ++i) {
    c359:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c360:	e9 d8 00 00 00       	jmp    c43d <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c365:	83 ec 04             	sub    $0x4,%esp
    c368:	ff 75 18             	pushl  0x18(%ebp)
    c36b:	ff 75 f4             	pushl  -0xc(%ebp)
    c36e:	ff 75 0c             	pushl  0xc(%ebp)
    c371:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    c377:	50                   	push   %eax
    c378:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    c37e:	50                   	push   %eax
    c37f:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    c385:	50                   	push   %eax
    c386:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    c38c:	50                   	push   %eax
    c38d:	e8 a8 f2 ff ff       	call   b63a <getPixelColorRGBA16>
    c392:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c395:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c39c:	66 c1 e8 08          	shr    $0x8,%ax
    c3a0:	89 c2                	mov    %eax,%edx
    c3a2:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c3a9:	31 d0                	xor    %edx,%eax
    c3ab:	0f b7 c0             	movzwl %ax,%eax
    c3ae:	0f b6 c0             	movzbl %al,%eax
    c3b1:	85 c0                	test   %eax,%eax
    c3b3:	75 60                	jne    c415 <lodepng_compute_color_stats+0x2d8>
    c3b5:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c3bc:	66 c1 e8 08          	shr    $0x8,%ax
    c3c0:	89 c2                	mov    %eax,%edx
    c3c2:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c3c9:	31 d0                	xor    %edx,%eax
    c3cb:	0f b7 c0             	movzwl %ax,%eax
    c3ce:	0f b6 c0             	movzbl %al,%eax
    c3d1:	85 c0                	test   %eax,%eax
    c3d3:	75 40                	jne    c415 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c3d5:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c3dc:	66 c1 e8 08          	shr    $0x8,%ax
    c3e0:	89 c2                	mov    %eax,%edx
    c3e2:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c3e9:	31 d0                	xor    %edx,%eax
    c3eb:	0f b7 c0             	movzwl %ax,%eax
    c3ee:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c3f1:	85 c0                	test   %eax,%eax
    c3f3:	75 20                	jne    c415 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c3f5:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c3fc:	66 c1 e8 08          	shr    $0x8,%ax
    c400:	89 c2                	mov    %eax,%edx
    c402:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c409:	31 d0                	xor    %edx,%eax
    c40b:	0f b7 c0             	movzwl %ax,%eax
    c40e:	0f b6 c0             	movzbl %al,%eax
    c411:	85 c0                	test   %eax,%eax
    c413:	74 24                	je     c439 <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    c415:	8b 45 08             	mov    0x8(%ebp),%eax
    c418:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    c41f:	00 00 00 
        sixteen = 1;
    c422:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    c429:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    c430:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    c437:	eb 10                	jmp    c449 <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    c439:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c43d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c440:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c443:	0f 85 1c ff ff ff    	jne    c365 <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    c449:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c44d:	0f 84 bd 02 00 00    	je     c710 <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c453:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    c45a:	00 00 
    c45c:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    c463:	00 00 
    c465:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    c46c:	00 00 
    c46e:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    c475:	00 00 

    for(i = 0; i != numpixels; ++i) {
    c477:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c47e:	e9 b1 01 00 00       	jmp    c634 <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c483:	83 ec 04             	sub    $0x4,%esp
    c486:	ff 75 18             	pushl  0x18(%ebp)
    c489:	ff 75 f4             	pushl  -0xc(%ebp)
    c48c:	ff 75 0c             	pushl  0xc(%ebp)
    c48f:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c495:	50                   	push   %eax
    c496:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c49c:	50                   	push   %eax
    c49d:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c4a3:	50                   	push   %eax
    c4a4:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c4aa:	50                   	push   %eax
    c4ab:	e8 8a f1 ff ff       	call   b63a <getPixelColorRGBA16>
    c4b0:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    c4b3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c4b7:	75 36                	jne    c4ef <lodepng_compute_color_stats+0x3b2>
    c4b9:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c4c0:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c4c7:	66 39 c2             	cmp    %ax,%dx
    c4ca:	75 13                	jne    c4df <lodepng_compute_color_stats+0x3a2>
    c4cc:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c4d3:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c4da:	66 39 c2             	cmp    %ax,%dx
    c4dd:	74 10                	je     c4ef <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    c4df:	8b 45 08             	mov    0x8(%ebp),%eax
    c4e2:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c4e8:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    c4ef:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c4f3:	0f 85 1f 01 00 00    	jne    c618 <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c4f9:	8b 45 08             	mov    0x8(%ebp),%eax
    c4fc:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c500:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c507:	66 39 c2             	cmp    %ax,%dx
    c50a:	75 2d                	jne    c539 <lodepng_compute_color_stats+0x3fc>
    c50c:	8b 45 08             	mov    0x8(%ebp),%eax
    c50f:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c513:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c51a:	66 39 c2             	cmp    %ax,%dx
    c51d:	75 1a                	jne    c539 <lodepng_compute_color_stats+0x3fc>
    c51f:	8b 45 08             	mov    0x8(%ebp),%eax
    c522:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c526:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c52d:	66 39 c2             	cmp    %ax,%dx
    c530:	75 07                	jne    c539 <lodepng_compute_color_stats+0x3fc>
    c532:	b8 01 00 00 00       	mov    $0x1,%eax
    c537:	eb 05                	jmp    c53e <lodepng_compute_color_stats+0x401>
    c539:	b8 00 00 00 00       	mov    $0x0,%eax
    c53e:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    c541:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c548:	66 83 f8 ff          	cmp    $0xffff,%ax
    c54c:	74 3c                	je     c58a <lodepng_compute_color_stats+0x44d>
    c54e:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c555:	66 85 c0             	test   %ax,%ax
    c558:	75 10                	jne    c56a <lodepng_compute_color_stats+0x42d>
    c55a:	8b 45 08             	mov    0x8(%ebp),%eax
    c55d:	8b 40 04             	mov    0x4(%eax),%eax
    c560:	85 c0                	test   %eax,%eax
    c562:	74 26                	je     c58a <lodepng_compute_color_stats+0x44d>
    c564:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c568:	75 20                	jne    c58a <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    c56a:	8b 45 08             	mov    0x8(%ebp),%eax
    c56d:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c574:	8b 45 08             	mov    0x8(%ebp),%eax
    c577:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c57e:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    c585:	e9 8e 00 00 00       	jmp    c618 <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c58a:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c591:	66 85 c0             	test   %ax,%ax
    c594:	75 4a                	jne    c5e0 <lodepng_compute_color_stats+0x4a3>
    c596:	8b 45 08             	mov    0x8(%ebp),%eax
    c599:	8b 40 10             	mov    0x10(%eax),%eax
    c59c:	85 c0                	test   %eax,%eax
    c59e:	75 40                	jne    c5e0 <lodepng_compute_color_stats+0x4a3>
    c5a0:	8b 45 08             	mov    0x8(%ebp),%eax
    c5a3:	8b 40 04             	mov    0x4(%eax),%eax
    c5a6:	85 c0                	test   %eax,%eax
    c5a8:	75 36                	jne    c5e0 <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    c5aa:	8b 45 08             	mov    0x8(%ebp),%eax
    c5ad:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c5b4:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c5bb:	8b 45 08             	mov    0x8(%ebp),%eax
    c5be:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c5c2:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    c5c9:	8b 45 08             	mov    0x8(%ebp),%eax
    c5cc:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c5d0:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    c5d7:	8b 45 08             	mov    0x8(%ebp),%eax
    c5da:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c5de:	eb 38                	jmp    c618 <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    c5e0:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c5e7:	66 83 f8 ff          	cmp    $0xffff,%ax
    c5eb:	75 2b                	jne    c618 <lodepng_compute_color_stats+0x4db>
    c5ed:	8b 45 08             	mov    0x8(%ebp),%eax
    c5f0:	8b 40 04             	mov    0x4(%eax),%eax
    c5f3:	85 c0                	test   %eax,%eax
    c5f5:	74 21                	je     c618 <lodepng_compute_color_stats+0x4db>
    c5f7:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c5fb:	74 1b                	je     c618 <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c5fd:	8b 45 08             	mov    0x8(%ebp),%eax
    c600:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c607:	8b 45 08             	mov    0x8(%ebp),%eax
    c60a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c611:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c618:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c61c:	74 12                	je     c630 <lodepng_compute_color_stats+0x4f3>
    c61e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c622:	74 0c                	je     c630 <lodepng_compute_color_stats+0x4f3>
    c624:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c628:	74 06                	je     c630 <lodepng_compute_color_stats+0x4f3>
    c62a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c62e:	75 12                	jne    c642 <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    c630:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c634:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c637:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c63a:	0f 85 43 fe ff ff    	jne    c483 <lodepng_compute_color_stats+0x346>
    c640:	eb 01                	jmp    c643 <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c642:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    c643:	8b 45 08             	mov    0x8(%ebp),%eax
    c646:	8b 40 04             	mov    0x4(%eax),%eax
    c649:	85 c0                	test   %eax,%eax
    c64b:	0f 84 e0 05 00 00    	je     cc31 <lodepng_compute_color_stats+0xaf4>
    c651:	8b 45 08             	mov    0x8(%ebp),%eax
    c654:	8b 40 10             	mov    0x10(%eax),%eax
    c657:	85 c0                	test   %eax,%eax
    c659:	0f 85 d2 05 00 00    	jne    cc31 <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    c65f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c666:	e9 94 00 00 00       	jmp    c6ff <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c66b:	83 ec 04             	sub    $0x4,%esp
    c66e:	ff 75 18             	pushl  0x18(%ebp)
    c671:	ff 75 f4             	pushl  -0xc(%ebp)
    c674:	ff 75 0c             	pushl  0xc(%ebp)
    c677:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c67d:	50                   	push   %eax
    c67e:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c684:	50                   	push   %eax
    c685:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c68b:	50                   	push   %eax
    c68c:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c692:	50                   	push   %eax
    c693:	e8 a2 ef ff ff       	call   b63a <getPixelColorRGBA16>
    c698:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    c69b:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c6a2:	66 85 c0             	test   %ax,%ax
    c6a5:	74 54                	je     c6fb <lodepng_compute_color_stats+0x5be>
    c6a7:	8b 45 08             	mov    0x8(%ebp),%eax
    c6aa:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c6ae:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c6b5:	66 39 c2             	cmp    %ax,%dx
    c6b8:	75 41                	jne    c6fb <lodepng_compute_color_stats+0x5be>
    c6ba:	8b 45 08             	mov    0x8(%ebp),%eax
    c6bd:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c6c1:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c6c8:	66 39 c2             	cmp    %ax,%dx
    c6cb:	75 2e                	jne    c6fb <lodepng_compute_color_stats+0x5be>
    c6cd:	8b 45 08             	mov    0x8(%ebp),%eax
    c6d0:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c6d4:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c6db:	66 39 c2             	cmp    %ax,%dx
    c6de:	75 1b                	jne    c6fb <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c6e0:	8b 45 08             	mov    0x8(%ebp),%eax
    c6e3:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c6ea:	8b 45 08             	mov    0x8(%ebp),%eax
    c6ed:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c6f4:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    c6fb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c6ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c702:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c705:	0f 85 60 ff ff ff    	jne    c66b <lodepng_compute_color_stats+0x52e>
    c70b:	e9 21 05 00 00       	jmp    cc31 <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    c710:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    c717:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    c71e:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    c725:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    c72c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c733:	e9 ab 03 00 00       	jmp    cae3 <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    c738:	83 ec 04             	sub    $0x4,%esp
    c73b:	ff 75 18             	pushl  0x18(%ebp)
    c73e:	ff 75 f4             	pushl  -0xc(%ebp)
    c741:	ff 75 0c             	pushl  0xc(%ebp)
    c744:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    c74a:	50                   	push   %eax
    c74b:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    c751:	50                   	push   %eax
    c752:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    c758:	50                   	push   %eax
    c759:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    c75f:	50                   	push   %eax
    c760:	e8 1e de ff ff       	call   a583 <getPixelColorRGBA8>
    c765:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    c768:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c76c:	75 41                	jne    c7af <lodepng_compute_color_stats+0x672>
    c76e:	8b 45 08             	mov    0x8(%ebp),%eax
    c771:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c777:	83 f8 07             	cmp    $0x7,%eax
    c77a:	77 33                	ja     c7af <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    c77c:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c783:	0f b6 c0             	movzbl %al,%eax
    c786:	83 ec 0c             	sub    $0xc,%esp
    c789:	50                   	push   %eax
    c78a:	e8 1d f9 ff ff       	call   c0ac <getValueRequiredBits>
    c78f:	83 c4 10             	add    $0x10,%esp
    c792:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    c795:	8b 45 08             	mov    0x8(%ebp),%eax
    c798:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c79e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    c7a1:	73 0c                	jae    c7af <lodepng_compute_color_stats+0x672>
    c7a3:	8b 45 08             	mov    0x8(%ebp),%eax
    c7a6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    c7a9:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    c7af:	8b 45 08             	mov    0x8(%ebp),%eax
    c7b2:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c7b8:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c7bb:	0f 93 c0             	setae  %al
    c7be:	0f b6 c0             	movzbl %al,%eax
    c7c1:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    c7c4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c7c8:	75 4f                	jne    c819 <lodepng_compute_color_stats+0x6dc>
    c7ca:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c7d1:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c7d8:	38 c2                	cmp    %al,%dl
    c7da:	75 12                	jne    c7ee <lodepng_compute_color_stats+0x6b1>
    c7dc:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c7e3:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c7ea:	38 c2                	cmp    %al,%dl
    c7ec:	74 2b                	je     c819 <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    c7ee:	8b 45 08             	mov    0x8(%ebp),%eax
    c7f1:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c7f7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    c7fe:	8b 45 08             	mov    0x8(%ebp),%eax
    c801:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c807:	83 f8 07             	cmp    $0x7,%eax
    c80a:	77 0d                	ja     c819 <lodepng_compute_color_stats+0x6dc>
    c80c:	8b 45 08             	mov    0x8(%ebp),%eax
    c80f:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c816:	00 00 00 
      }

      if(!alpha_done) {
    c819:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c81d:	0f 85 65 01 00 00    	jne    c988 <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c823:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c82a:	0f b6 d0             	movzbl %al,%edx
    c82d:	8b 45 08             	mov    0x8(%ebp),%eax
    c830:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c834:	66 39 c2             	cmp    %ax,%dx
    c837:	75 33                	jne    c86c <lodepng_compute_color_stats+0x72f>
    c839:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c840:	0f b6 d0             	movzbl %al,%edx
    c843:	8b 45 08             	mov    0x8(%ebp),%eax
    c846:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    c84a:	66 39 c2             	cmp    %ax,%dx
    c84d:	75 1d                	jne    c86c <lodepng_compute_color_stats+0x72f>
    c84f:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c856:	0f b6 d0             	movzbl %al,%edx
    c859:	8b 45 08             	mov    0x8(%ebp),%eax
    c85c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    c860:	66 39 c2             	cmp    %ax,%dx
    c863:	75 07                	jne    c86c <lodepng_compute_color_stats+0x72f>
    c865:	b8 01 00 00 00       	mov    $0x1,%eax
    c86a:	eb 05                	jmp    c871 <lodepng_compute_color_stats+0x734>
    c86c:	b8 00 00 00 00       	mov    $0x0,%eax
    c871:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    c874:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c87b:	3c ff                	cmp    $0xff,%al
    c87d:	74 5a                	je     c8d9 <lodepng_compute_color_stats+0x79c>
    c87f:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c886:	84 c0                	test   %al,%al
    c888:	75 10                	jne    c89a <lodepng_compute_color_stats+0x75d>
    c88a:	8b 45 08             	mov    0x8(%ebp),%eax
    c88d:	8b 40 04             	mov    0x4(%eax),%eax
    c890:	85 c0                	test   %eax,%eax
    c892:	74 45                	je     c8d9 <lodepng_compute_color_stats+0x79c>
    c894:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c898:	75 3f                	jne    c8d9 <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    c89a:	8b 45 08             	mov    0x8(%ebp),%eax
    c89d:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c8a4:	8b 45 08             	mov    0x8(%ebp),%eax
    c8a7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c8ae:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c8b5:	8b 45 08             	mov    0x8(%ebp),%eax
    c8b8:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c8be:	83 f8 07             	cmp    $0x7,%eax
    c8c1:	0f 87 c1 00 00 00    	ja     c988 <lodepng_compute_color_stats+0x84b>
    c8c7:	8b 45 08             	mov    0x8(%ebp),%eax
    c8ca:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c8d1:	00 00 00 
    c8d4:	e9 af 00 00 00       	jmp    c988 <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c8d9:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c8e0:	84 c0                	test   %al,%al
    c8e2:	75 53                	jne    c937 <lodepng_compute_color_stats+0x7fa>
    c8e4:	8b 45 08             	mov    0x8(%ebp),%eax
    c8e7:	8b 40 10             	mov    0x10(%eax),%eax
    c8ea:	85 c0                	test   %eax,%eax
    c8ec:	75 49                	jne    c937 <lodepng_compute_color_stats+0x7fa>
    c8ee:	8b 45 08             	mov    0x8(%ebp),%eax
    c8f1:	8b 40 04             	mov    0x4(%eax),%eax
    c8f4:	85 c0                	test   %eax,%eax
    c8f6:	75 3f                	jne    c937 <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    c8f8:	8b 45 08             	mov    0x8(%ebp),%eax
    c8fb:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c902:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c909:	0f b6 d0             	movzbl %al,%edx
    c90c:	8b 45 08             	mov    0x8(%ebp),%eax
    c90f:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c913:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c91a:	0f b6 d0             	movzbl %al,%edx
    c91d:	8b 45 08             	mov    0x8(%ebp),%eax
    c920:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c924:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c92b:	0f b6 d0             	movzbl %al,%edx
    c92e:	8b 45 08             	mov    0x8(%ebp),%eax
    c931:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c935:	eb 51                	jmp    c988 <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    c937:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c93e:	3c ff                	cmp    $0xff,%al
    c940:	75 46                	jne    c988 <lodepng_compute_color_stats+0x84b>
    c942:	8b 45 08             	mov    0x8(%ebp),%eax
    c945:	8b 40 04             	mov    0x4(%eax),%eax
    c948:	85 c0                	test   %eax,%eax
    c94a:	74 3c                	je     c988 <lodepng_compute_color_stats+0x84b>
    c94c:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c950:	74 36                	je     c988 <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c952:	8b 45 08             	mov    0x8(%ebp),%eax
    c955:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c95c:	8b 45 08             	mov    0x8(%ebp),%eax
    c95f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c966:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c96d:	8b 45 08             	mov    0x8(%ebp),%eax
    c970:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c976:	83 f8 07             	cmp    $0x7,%eax
    c979:	77 0d                	ja     c988 <lodepng_compute_color_stats+0x84b>
    c97b:	8b 45 08             	mov    0x8(%ebp),%eax
    c97e:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c985:	00 00 00 
        }
      }

      if(!numcolors_done) {
    c988:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c98c:	0f 85 35 01 00 00    	jne    cac7 <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    c992:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c999:	0f b6 d8             	movzbl %al,%ebx
    c99c:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c9a3:	0f b6 c8             	movzbl %al,%ecx
    c9a6:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c9ad:	0f b6 d0             	movzbl %al,%edx
    c9b0:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c9b7:	0f b6 c0             	movzbl %al,%eax
    c9ba:	83 ec 0c             	sub    $0xc,%esp
    c9bd:	53                   	push   %ebx
    c9be:	51                   	push   %ecx
    c9bf:	52                   	push   %edx
    c9c0:	50                   	push   %eax
    c9c1:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c9c7:	50                   	push   %eax
    c9c8:	e8 1c d4 ff ff       	call   9de9 <color_tree_has>
    c9cd:	83 c4 20             	add    $0x20,%esp
    c9d0:	85 c0                	test   %eax,%eax
    c9d2:	0f 85 ef 00 00 00    	jne    cac7 <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    c9d8:	8b 45 08             	mov    0x8(%ebp),%eax
    c9db:	8b 70 14             	mov    0x14(%eax),%esi
    c9de:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c9e5:	0f b6 d8             	movzbl %al,%ebx
    c9e8:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c9ef:	0f b6 c8             	movzbl %al,%ecx
    c9f2:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c9f9:	0f b6 d0             	movzbl %al,%edx
    c9fc:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca03:	0f b6 c0             	movzbl %al,%eax
    ca06:	83 ec 08             	sub    $0x8,%esp
    ca09:	56                   	push   %esi
    ca0a:	53                   	push   %ebx
    ca0b:	51                   	push   %ecx
    ca0c:	52                   	push   %edx
    ca0d:	50                   	push   %eax
    ca0e:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    ca14:	50                   	push   %eax
    ca15:	e8 1a d4 ff ff       	call   9e34 <color_tree_add>
    ca1a:	83 c4 20             	add    $0x20,%esp
    ca1d:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    ca20:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ca24:	0f 85 06 02 00 00    	jne    cc30 <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    ca2a:	8b 45 08             	mov    0x8(%ebp),%eax
    ca2d:	8b 40 14             	mov    0x14(%eax),%eax
    ca30:	3d ff 00 00 00       	cmp    $0xff,%eax
    ca35:	77 6f                	ja     caa6 <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    ca37:	8b 45 08             	mov    0x8(%ebp),%eax
    ca3a:	83 c0 18             	add    $0x18,%eax
    ca3d:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    ca40:	8b 45 08             	mov    0x8(%ebp),%eax
    ca43:	8b 40 14             	mov    0x14(%eax),%eax
    ca46:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    ca49:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca4c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ca53:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca56:	01 c2                	add    %eax,%edx
    ca58:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca5f:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    ca61:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca64:	c1 e0 02             	shl    $0x2,%eax
    ca67:	8d 50 01             	lea    0x1(%eax),%edx
    ca6a:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca6d:	01 c2                	add    %eax,%edx
    ca6f:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ca76:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    ca78:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca7b:	c1 e0 02             	shl    $0x2,%eax
    ca7e:	8d 50 02             	lea    0x2(%eax),%edx
    ca81:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca84:	01 c2                	add    %eax,%edx
    ca86:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ca8d:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    ca8f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ca92:	c1 e0 02             	shl    $0x2,%eax
    ca95:	8d 50 03             	lea    0x3(%eax),%edx
    ca98:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ca9b:	01 c2                	add    %eax,%edx
    ca9d:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    caa4:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    caa6:	8b 45 08             	mov    0x8(%ebp),%eax
    caa9:	8b 40 14             	mov    0x14(%eax),%eax
    caac:	8d 50 01             	lea    0x1(%eax),%edx
    caaf:	8b 45 08             	mov    0x8(%ebp),%eax
    cab2:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    cab5:	8b 45 08             	mov    0x8(%ebp),%eax
    cab8:	8b 40 14             	mov    0x14(%eax),%eax
    cabb:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cabe:	0f 93 c0             	setae  %al
    cac1:	0f b6 c0             	movzbl %al,%eax
    cac4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cac7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cacb:	74 12                	je     cadf <lodepng_compute_color_stats+0x9a2>
    cacd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cad1:	74 0c                	je     cadf <lodepng_compute_color_stats+0x9a2>
    cad3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cad7:	74 06                	je     cadf <lodepng_compute_color_stats+0x9a2>
    cad9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cadd:	75 12                	jne    caf1 <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    cadf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cae3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cae6:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cae9:	0f 85 49 fc ff ff    	jne    c738 <lodepng_compute_color_stats+0x5fb>
    caef:	eb 01                	jmp    caf2 <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    caf1:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    caf2:	8b 45 08             	mov    0x8(%ebp),%eax
    caf5:	8b 40 04             	mov    0x4(%eax),%eax
    caf8:	85 c0                	test   %eax,%eax
    cafa:	0f 84 dd 00 00 00    	je     cbdd <lodepng_compute_color_stats+0xaa0>
    cb00:	8b 45 08             	mov    0x8(%ebp),%eax
    cb03:	8b 40 10             	mov    0x10(%eax),%eax
    cb06:	85 c0                	test   %eax,%eax
    cb08:	0f 85 cf 00 00 00    	jne    cbdd <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    cb0e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cb15:	e9 b7 00 00 00       	jmp    cbd1 <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    cb1a:	83 ec 04             	sub    $0x4,%esp
    cb1d:	ff 75 18             	pushl  0x18(%ebp)
    cb20:	ff 75 f4             	pushl  -0xc(%ebp)
    cb23:	ff 75 0c             	pushl  0xc(%ebp)
    cb26:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    cb2c:	50                   	push   %eax
    cb2d:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    cb33:	50                   	push   %eax
    cb34:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    cb3a:	50                   	push   %eax
    cb3b:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    cb41:	50                   	push   %eax
    cb42:	e8 3c da ff ff       	call   a583 <getPixelColorRGBA8>
    cb47:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    cb4a:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cb51:	84 c0                	test   %al,%al
    cb53:	74 78                	je     cbcd <lodepng_compute_color_stats+0xa90>
    cb55:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cb5c:	0f b6 d0             	movzbl %al,%edx
    cb5f:	8b 45 08             	mov    0x8(%ebp),%eax
    cb62:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cb66:	66 39 c2             	cmp    %ax,%dx
    cb69:	75 62                	jne    cbcd <lodepng_compute_color_stats+0xa90>
    cb6b:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cb72:	0f b6 d0             	movzbl %al,%edx
    cb75:	8b 45 08             	mov    0x8(%ebp),%eax
    cb78:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cb7c:	66 39 c2             	cmp    %ax,%dx
    cb7f:	75 4c                	jne    cbcd <lodepng_compute_color_stats+0xa90>
    cb81:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cb88:	0f b6 d0             	movzbl %al,%edx
    cb8b:	8b 45 08             	mov    0x8(%ebp),%eax
    cb8e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cb92:	66 39 c2             	cmp    %ax,%dx
    cb95:	75 36                	jne    cbcd <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cb97:	8b 45 08             	mov    0x8(%ebp),%eax
    cb9a:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cba1:	8b 45 08             	mov    0x8(%ebp),%eax
    cba4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cbab:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cbb2:	8b 45 08             	mov    0x8(%ebp),%eax
    cbb5:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cbbb:	83 f8 07             	cmp    $0x7,%eax
    cbbe:	77 0d                	ja     cbcd <lodepng_compute_color_stats+0xa90>
    cbc0:	8b 45 08             	mov    0x8(%ebp),%eax
    cbc3:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cbca:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    cbcd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cbd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cbd4:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cbd7:	0f 85 3d ff ff ff    	jne    cb1a <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    cbdd:	8b 45 08             	mov    0x8(%ebp),%eax
    cbe0:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    cbe4:	8b 45 08             	mov    0x8(%ebp),%eax
    cbe7:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cbeb:	c1 e0 08             	shl    $0x8,%eax
    cbee:	01 c2                	add    %eax,%edx
    cbf0:	8b 45 08             	mov    0x8(%ebp),%eax
    cbf3:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    cbf7:	8b 45 08             	mov    0x8(%ebp),%eax
    cbfa:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    cbfe:	8b 45 08             	mov    0x8(%ebp),%eax
    cc01:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cc05:	c1 e0 08             	shl    $0x8,%eax
    cc08:	01 c2                	add    %eax,%edx
    cc0a:	8b 45 08             	mov    0x8(%ebp),%eax
    cc0d:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    cc11:	8b 45 08             	mov    0x8(%ebp),%eax
    cc14:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    cc18:	8b 45 08             	mov    0x8(%ebp),%eax
    cc1b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cc1f:	c1 e0 08             	shl    $0x8,%eax
    cc22:	01 c2                	add    %eax,%edx
    cc24:	8b 45 08             	mov    0x8(%ebp),%eax
    cc27:	66 89 50 0c          	mov    %dx,0xc(%eax)
    cc2b:	eb 04                	jmp    cc31 <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    cc2d:	90                   	nop
    cc2e:	eb 01                	jmp    cc31 <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    cc30:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    cc31:	83 ec 0c             	sub    $0xc,%esp
    cc34:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cc3a:	50                   	push   %eax
    cc3b:	e8 91 d0 ff ff       	call   9cd1 <color_tree_cleanup>
    cc40:	83 c4 10             	add    $0x10,%esp
  return error;
    cc43:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    cc46:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cc49:	5b                   	pop    %ebx
    cc4a:	5e                   	pop    %esi
    cc4b:	5d                   	pop    %ebp
    cc4c:	c3                   	ret    

0000cc4d <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    cc4d:	55                   	push   %ebp
    cc4e:	89 e5                	mov    %esp,%ebp
    cc50:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    cc53:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    cc5a:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cc5d:	50                   	push   %eax
    cc5e:	e8 d1 bd ff ff       	call   8a34 <lodepng_color_mode_init>
    cc63:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    cc66:	8b 45 0c             	mov    0xc(%ebp),%eax
    cc69:	c1 e8 08             	shr    $0x8,%eax
    cc6c:	88 45 ec             	mov    %al,-0x14(%ebp)
    cc6f:	8b 45 0c             	mov    0xc(%ebp),%eax
    cc72:	88 45 ed             	mov    %al,-0x13(%ebp)
    cc75:	8b 45 10             	mov    0x10(%ebp),%eax
    cc78:	c1 e8 08             	shr    $0x8,%eax
    cc7b:	88 45 ee             	mov    %al,-0x12(%ebp)
    cc7e:	8b 45 10             	mov    0x10(%ebp),%eax
    cc81:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    cc84:	8b 45 14             	mov    0x14(%ebp),%eax
    cc87:	c1 e8 08             	shr    $0x8,%eax
    cc8a:	88 45 f0             	mov    %al,-0x10(%ebp)
    cc8d:	8b 45 14             	mov    0x14(%ebp),%eax
    cc90:	88 45 f1             	mov    %al,-0xf(%ebp)
    cc93:	8b 45 18             	mov    0x18(%ebp),%eax
    cc96:	c1 e8 08             	shr    $0x8,%eax
    cc99:	88 45 f2             	mov    %al,-0xe(%ebp)
    cc9c:	8b 45 18             	mov    0x18(%ebp),%eax
    cc9f:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    cca2:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    cca9:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    ccb0:	83 ec 0c             	sub    $0xc,%esp
    ccb3:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ccb6:	50                   	push   %eax
    ccb7:	6a 01                	push   $0x1
    ccb9:	6a 01                	push   $0x1
    ccbb:	8d 45 ec             	lea    -0x14(%ebp),%eax
    ccbe:	50                   	push   %eax
    ccbf:	ff 75 08             	pushl  0x8(%ebp)
    ccc2:	e8 76 f4 ff ff       	call   c13d <lodepng_compute_color_stats>
    ccc7:	83 c4 20             	add    $0x20,%esp
    ccca:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    cccd:	83 ec 0c             	sub    $0xc,%esp
    ccd0:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ccd3:	50                   	push   %eax
    ccd4:	e8 4e be ff ff       	call   8b27 <lodepng_color_mode_cleanup>
    ccd9:	83 c4 10             	add    $0x10,%esp
  return error;
    ccdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ccdf:	c9                   	leave  
    cce0:	c3                   	ret    

0000cce1 <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    cce1:	55                   	push   %ebp
    cce2:	89 e5                	mov    %esp,%ebp
    cce4:	56                   	push   %esi
    cce5:	53                   	push   %ebx
    cce6:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    cce9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    ccf0:	8b 45 10             	mov    0x10(%ebp),%eax
    ccf3:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    ccf9:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    ccfc:	8b 45 10             	mov    0x10(%ebp),%eax
    ccff:	8b 40 10             	mov    0x10(%eax),%eax
    cd02:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    cd05:	8b 45 10             	mov    0x10(%ebp),%eax
    cd08:	8b 40 04             	mov    0x4(%eax),%eax
    cd0b:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    cd0e:	8b 45 10             	mov    0x10(%ebp),%eax
    cd11:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cd17:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    cd1a:	8b 45 08             	mov    0x8(%ebp),%eax
    cd1d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    cd24:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cd28:	74 21                	je     cd4b <auto_choose_color+0x6a>
    cd2a:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    cd2e:	7f 1b                	jg     cd4b <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    cd30:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    cd37:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cd3e:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    cd42:	77 07                	ja     cd4b <auto_choose_color+0x6a>
    cd44:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    cd4b:	8b 45 10             	mov    0x10(%ebp),%eax
    cd4e:	8b 00                	mov    (%eax),%eax
    cd50:	85 c0                	test   %eax,%eax
    cd52:	0f 94 c0             	sete   %al
    cd55:	0f b6 c0             	movzbl %al,%eax
    cd58:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    cd5b:	8b 45 10             	mov    0x10(%ebp),%eax
    cd5e:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    cd64:	85 c0                	test   %eax,%eax
    cd66:	75 07                	jne    cd6f <auto_choose_color+0x8e>
    cd68:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    cd6f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cd73:	75 0d                	jne    cd82 <auto_choose_color+0xa1>
    cd75:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    cd79:	77 07                	ja     cd82 <auto_choose_color+0xa1>
    cd7b:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    cd82:	8b 45 10             	mov    0x10(%ebp),%eax
    cd85:	8b 40 14             	mov    0x14(%eax),%eax
    cd88:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    cd8b:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    cd8f:	7e 21                	jle    cdb2 <auto_choose_color+0xd1>
    cd91:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    cd95:	7e 14                	jle    cdab <auto_choose_color+0xca>
    cd97:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    cd9b:	7f 07                	jg     cda4 <auto_choose_color+0xc3>
    cd9d:	b8 04 00 00 00       	mov    $0x4,%eax
    cda2:	eb 13                	jmp    cdb7 <auto_choose_color+0xd6>
    cda4:	b8 08 00 00 00       	mov    $0x8,%eax
    cda9:	eb 0c                	jmp    cdb7 <auto_choose_color+0xd6>
    cdab:	b8 02 00 00 00       	mov    $0x2,%eax
    cdb0:	eb 05                	jmp    cdb7 <auto_choose_color+0xd6>
    cdb2:	b8 01 00 00 00       	mov    $0x1,%eax
    cdb7:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    cdba:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    cdc1:	7f 13                	jg     cdd6 <auto_choose_color+0xf5>
    cdc3:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    cdc7:	77 0d                	ja     cdd6 <auto_choose_color+0xf5>
    cdc9:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    cdcd:	74 07                	je     cdd6 <auto_choose_color+0xf5>
    cdcf:	b8 01 00 00 00       	mov    $0x1,%eax
    cdd4:	eb 05                	jmp    cddb <auto_choose_color+0xfa>
    cdd6:	b8 00 00 00 00       	mov    $0x0,%eax
    cddb:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    cdde:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cde1:	01 c0                	add    %eax,%eax
    cde3:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cde6:	7e 07                	jle    cdef <auto_choose_color+0x10e>
    cde8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    cdef:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cdf3:	74 15                	je     ce0a <auto_choose_color+0x129>
    cdf5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cdf9:	75 0f                	jne    ce0a <auto_choose_color+0x129>
    cdfb:	8b 45 dc             	mov    -0x24(%ebp),%eax
    cdfe:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    ce01:	77 07                	ja     ce0a <auto_choose_color+0x129>
    ce03:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    ce0a:	8b 45 10             	mov    0x10(%ebp),%eax
    ce0d:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    ce13:	85 c0                	test   %eax,%eax
    ce15:	75 07                	jne    ce1e <auto_choose_color+0x13d>
    ce17:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    ce1e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ce22:	0f 84 0a 01 00 00    	je     cf32 <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    ce28:	8b 45 10             	mov    0x10(%ebp),%eax
    ce2b:	83 c0 18             	add    $0x18,%eax
    ce2e:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    ce31:	83 ec 0c             	sub    $0xc,%esp
    ce34:	ff 75 08             	pushl  0x8(%ebp)
    ce37:	e8 ef be ff ff       	call   8d2b <lodepng_palette_clear>
    ce3c:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    ce3f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ce46:	eb 6e                	jmp    ceb6 <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    ce48:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce4b:	c1 e0 02             	shl    $0x2,%eax
    ce4e:	8d 50 03             	lea    0x3(%eax),%edx
    ce51:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce54:	01 d0                	add    %edx,%eax
    ce56:	0f b6 00             	movzbl (%eax),%eax
    ce59:	0f b6 d8             	movzbl %al,%ebx
    ce5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce5f:	c1 e0 02             	shl    $0x2,%eax
    ce62:	8d 50 02             	lea    0x2(%eax),%edx
    ce65:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce68:	01 d0                	add    %edx,%eax
    ce6a:	0f b6 00             	movzbl (%eax),%eax
    ce6d:	0f b6 c8             	movzbl %al,%ecx
    ce70:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce73:	c1 e0 02             	shl    $0x2,%eax
    ce76:	8d 50 01             	lea    0x1(%eax),%edx
    ce79:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce7c:	01 d0                	add    %edx,%eax
    ce7e:	0f b6 00             	movzbl (%eax),%eax
    ce81:	0f b6 d0             	movzbl %al,%edx
    ce84:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ce87:	c1 e0 02             	shl    $0x2,%eax
    ce8a:	89 c6                	mov    %eax,%esi
    ce8c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ce8f:	01 f0                	add    %esi,%eax
    ce91:	0f b6 00             	movzbl (%eax),%eax
    ce94:	0f b6 c0             	movzbl %al,%eax
    ce97:	83 ec 0c             	sub    $0xc,%esp
    ce9a:	53                   	push   %ebx
    ce9b:	51                   	push   %ecx
    ce9c:	52                   	push   %edx
    ce9d:	50                   	push   %eax
    ce9e:	ff 75 08             	pushl  0x8(%ebp)
    cea1:	e8 be be ff ff       	call   8d64 <lodepng_palette_add>
    cea6:	83 c4 20             	add    $0x20,%esp
    cea9:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    ceac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ceb0:	75 13                	jne    cec5 <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    ceb2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ceb6:	8b 45 10             	mov    0x10(%ebp),%eax
    ceb9:	8b 50 14             	mov    0x14(%eax),%edx
    cebc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cebf:	39 c2                	cmp    %eax,%edx
    cec1:	75 85                	jne    ce48 <auto_choose_color+0x167>
    cec3:	eb 01                	jmp    cec6 <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    cec5:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    cec6:	8b 45 08             	mov    0x8(%ebp),%eax
    cec9:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    cecf:	8b 45 08             	mov    0x8(%ebp),%eax
    ced2:	8b 55 d0             	mov    -0x30(%ebp),%edx
    ced5:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    ced8:	8b 45 0c             	mov    0xc(%ebp),%eax
    cedb:	8b 00                	mov    (%eax),%eax
    cedd:	83 f8 03             	cmp    $0x3,%eax
    cee0:	0f 85 ec 00 00 00    	jne    cfd2 <auto_choose_color+0x2f1>
    cee6:	8b 45 0c             	mov    0xc(%ebp),%eax
    cee9:	8b 50 0c             	mov    0xc(%eax),%edx
    ceec:	8b 45 08             	mov    0x8(%ebp),%eax
    ceef:	8b 40 0c             	mov    0xc(%eax),%eax
    cef2:	39 c2                	cmp    %eax,%edx
    cef4:	0f 8c d8 00 00 00    	jl     cfd2 <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    cefa:	8b 45 0c             	mov    0xc(%ebp),%eax
    cefd:	8b 50 04             	mov    0x4(%eax),%edx
    cf00:	8b 45 08             	mov    0x8(%ebp),%eax
    cf03:	8b 40 04             	mov    0x4(%eax),%eax
    cf06:	39 c2                	cmp    %eax,%edx
    cf08:	0f 85 c4 00 00 00    	jne    cfd2 <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    cf0e:	83 ec 0c             	sub    $0xc,%esp
    cf11:	ff 75 08             	pushl  0x8(%ebp)
    cf14:	e8 0e bc ff ff       	call   8b27 <lodepng_color_mode_cleanup>
    cf19:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    cf1c:	83 ec 08             	sub    $0x8,%esp
    cf1f:	ff 75 0c             	pushl  0xc(%ebp)
    cf22:	ff 75 08             	pushl  0x8(%ebp)
    cf25:	e8 14 bc ff ff       	call   8b3e <lodepng_color_mode_copy>
    cf2a:	83 c4 10             	add    $0x10,%esp
    cf2d:	e9 a0 00 00 00       	jmp    cfd2 <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    cf32:	8b 45 08             	mov    0x8(%ebp),%eax
    cf35:	8b 55 dc             	mov    -0x24(%ebp),%edx
    cf38:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    cf3b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cf3f:	74 14                	je     cf55 <auto_choose_color+0x274>
    cf41:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cf45:	74 07                	je     cf4e <auto_choose_color+0x26d>
    cf47:	b8 04 00 00 00       	mov    $0x4,%eax
    cf4c:	eb 19                	jmp    cf67 <auto_choose_color+0x286>
    cf4e:	b8 06 00 00 00       	mov    $0x6,%eax
    cf53:	eb 12                	jmp    cf67 <auto_choose_color+0x286>
    cf55:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cf59:	74 07                	je     cf62 <auto_choose_color+0x281>
    cf5b:	b8 00 00 00 00       	mov    $0x0,%eax
    cf60:	eb 05                	jmp    cf67 <auto_choose_color+0x286>
    cf62:	b8 02 00 00 00       	mov    $0x2,%eax
    cf67:	8b 55 08             	mov    0x8(%ebp),%edx
    cf6a:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    cf6c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cf70:	74 60                	je     cfd2 <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    cf72:	8b 45 08             	mov    0x8(%ebp),%eax
    cf75:	8b 40 04             	mov    0x4(%eax),%eax
    cf78:	ba 01 00 00 00       	mov    $0x1,%edx
    cf7d:	89 c1                	mov    %eax,%ecx
    cf7f:	d3 e2                	shl    %cl,%edx
    cf81:	89 d0                	mov    %edx,%eax
    cf83:	83 e8 01             	sub    $0x1,%eax
    cf86:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    cf89:	8b 45 10             	mov    0x10(%ebp),%eax
    cf8c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cf90:	0f b7 c0             	movzwl %ax,%eax
    cf93:	23 45 c8             	and    -0x38(%ebp),%eax
    cf96:	89 c2                	mov    %eax,%edx
    cf98:	8b 45 08             	mov    0x8(%ebp),%eax
    cf9b:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    cf9e:	8b 45 10             	mov    0x10(%ebp),%eax
    cfa1:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cfa5:	0f b7 c0             	movzwl %ax,%eax
    cfa8:	23 45 c8             	and    -0x38(%ebp),%eax
    cfab:	89 c2                	mov    %eax,%edx
    cfad:	8b 45 08             	mov    0x8(%ebp),%eax
    cfb0:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    cfb3:	8b 45 10             	mov    0x10(%ebp),%eax
    cfb6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cfba:	0f b7 c0             	movzwl %ax,%eax
    cfbd:	23 45 c8             	and    -0x38(%ebp),%eax
    cfc0:	89 c2                	mov    %eax,%edx
    cfc2:	8b 45 08             	mov    0x8(%ebp),%eax
    cfc5:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    cfc8:	8b 45 08             	mov    0x8(%ebp),%eax
    cfcb:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    cfd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    cfd5:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cfd8:	5b                   	pop    %ebx
    cfd9:	5e                   	pop    %esi
    cfda:	5d                   	pop    %ebp
    cfdb:	c3                   	ret    

0000cfdc <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    cfdc:	55                   	push   %ebp
    cfdd:	89 e5                	mov    %esp,%ebp
    cfdf:	83 ec 1c             	sub    $0x1c,%esp
    cfe2:	8b 4d 08             	mov    0x8(%ebp),%ecx
    cfe5:	8b 55 0c             	mov    0xc(%ebp),%edx
    cfe8:	8b 45 10             	mov    0x10(%ebp),%eax
    cfeb:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    cfef:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    cff3:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    cff7:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    cffb:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    cfff:	29 c2                	sub    %eax,%edx
    d001:	89 d0                	mov    %edx,%eax
    d003:	99                   	cltd   
    d004:	31 d0                	xor    %edx,%eax
    d006:	29 d0                	sub    %edx,%eax
    d008:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    d00c:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d010:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d014:	29 c2                	sub    %eax,%edx
    d016:	89 d0                	mov    %edx,%eax
    d018:	99                   	cltd   
    d019:	31 d0                	xor    %edx,%eax
    d01b:	29 d0                	sub    %edx,%eax
    d01d:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    d021:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d025:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    d029:	01 c2                	add    %eax,%edx
    d02b:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d02f:	29 c2                	sub    %eax,%edx
    d031:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d035:	29 c2                	sub    %eax,%edx
    d037:	89 d0                	mov    %edx,%eax
    d039:	99                   	cltd   
    d03a:	31 d0                	xor    %edx,%eax
    d03c:	29 d0                	sub    %edx,%eax
    d03e:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    d042:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d046:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d04a:	7d 10                	jge    d05c <paethPredictor+0x80>
    d04c:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    d050:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    d054:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d058:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    d05c:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    d060:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d064:	7d 06                	jge    d06c <paethPredictor+0x90>
    d066:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    d06a:	eb 04                	jmp    d070 <paethPredictor+0x94>
    d06c:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    d070:	c9                   	leave  
    d071:	c3                   	ret    

0000d072 <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    d072:	55                   	push   %ebp
    d073:	89 e5                	mov    %esp,%ebp
    d075:	56                   	push   %esi
    d076:	53                   	push   %ebx
    d077:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d07a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d081:	e9 e2 00 00 00       	jmp    d168 <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    d086:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d089:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d090:	8b 45 08             	mov    0x8(%ebp),%eax
    d093:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d096:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d099:	8b 14 85 14 a0 01 00 	mov    0x1a014(,%eax,4),%edx
    d0a0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d0a3:	01 c2                	add    %eax,%edx
    d0a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0a8:	8b 04 85 dc 9f 01 00 	mov    0x19fdc(,%eax,4),%eax
    d0af:	29 c2                	sub    %eax,%edx
    d0b1:	89 d0                	mov    %edx,%eax
    d0b3:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d0b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0b9:	8b 34 85 14 a0 01 00 	mov    0x1a014(,%eax,4),%esi
    d0c0:	89 d8                	mov    %ebx,%eax
    d0c2:	ba 00 00 00 00       	mov    $0x0,%edx
    d0c7:	f7 f6                	div    %esi
    d0c9:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    d0cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0ce:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d0d5:	8b 45 0c             	mov    0xc(%ebp),%eax
    d0d8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d0db:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0de:	8b 14 85 30 a0 01 00 	mov    0x1a030(,%eax,4),%edx
    d0e5:	8b 45 20             	mov    0x20(%ebp),%eax
    d0e8:	01 c2                	add    %eax,%edx
    d0ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0ed:	8b 04 85 f8 9f 01 00 	mov    0x19ff8(,%eax,4),%eax
    d0f4:	29 c2                	sub    %eax,%edx
    d0f6:	89 d0                	mov    %edx,%eax
    d0f8:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d0fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d0fe:	8b 34 85 30 a0 01 00 	mov    0x1a030(,%eax,4),%esi
    d105:	89 d8                	mov    %ebx,%eax
    d107:	ba 00 00 00 00       	mov    $0x0,%edx
    d10c:	f7 f6                	div    %esi
    d10e:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    d110:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d113:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d11a:	8b 45 08             	mov    0x8(%ebp),%eax
    d11d:	01 d0                	add    %edx,%eax
    d11f:	8b 00                	mov    (%eax),%eax
    d121:	85 c0                	test   %eax,%eax
    d123:	75 15                	jne    d13a <Adam7_getpassvalues+0xc8>
    d125:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d128:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d12f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d132:	01 d0                	add    %edx,%eax
    d134:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    d13a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d13d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d144:	8b 45 0c             	mov    0xc(%ebp),%eax
    d147:	01 d0                	add    %edx,%eax
    d149:	8b 00                	mov    (%eax),%eax
    d14b:	85 c0                	test   %eax,%eax
    d14d:	75 15                	jne    d164 <Adam7_getpassvalues+0xf2>
    d14f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d152:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d159:	8b 45 08             	mov    0x8(%ebp),%eax
    d15c:	01 d0                	add    %edx,%eax
    d15e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d164:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d168:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d16c:	0f 85 14 ff ff ff    	jne    d086 <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    d172:	8b 45 18             	mov    0x18(%ebp),%eax
    d175:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d17b:	8b 45 18             	mov    0x18(%ebp),%eax
    d17e:	8b 10                	mov    (%eax),%edx
    d180:	8b 45 14             	mov    0x14(%ebp),%eax
    d183:	89 10                	mov    %edx,(%eax)
    d185:	8b 45 14             	mov    0x14(%ebp),%eax
    d188:	8b 10                	mov    (%eax),%edx
    d18a:	8b 45 10             	mov    0x10(%ebp),%eax
    d18d:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    d18f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d196:	e9 40 01 00 00       	jmp    d2db <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d19b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d19e:	83 c0 01             	add    $0x1,%eax
    d1a1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1a8:	8b 45 10             	mov    0x10(%ebp),%eax
    d1ab:	01 c2                	add    %eax,%edx
    d1ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1b0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1b7:	8b 45 10             	mov    0x10(%ebp),%eax
    d1ba:	01 c8                	add    %ecx,%eax
    d1bc:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    d1be:	89 c6                	mov    %eax,%esi
    d1c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1c3:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1ca:	8b 45 08             	mov    0x8(%ebp),%eax
    d1cd:	01 c8                	add    %ecx,%eax
    d1cf:	8b 00                	mov    (%eax),%eax
    d1d1:	85 c0                	test   %eax,%eax
    d1d3:	74 49                	je     d21e <Adam7_getpassvalues+0x1ac>
    d1d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1d8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1df:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1e2:	01 c8                	add    %ecx,%eax
    d1e4:	8b 00                	mov    (%eax),%eax
    d1e6:	85 c0                	test   %eax,%eax
    d1e8:	74 34                	je     d21e <Adam7_getpassvalues+0x1ac>
    d1ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1ed:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d1f4:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1f7:	01 c8                	add    %ecx,%eax
    d1f9:	8b 08                	mov    (%eax),%ecx
    d1fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1fe:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d205:	8b 45 08             	mov    0x8(%ebp),%eax
    d208:	01 d8                	add    %ebx,%eax
    d20a:	8b 00                	mov    (%eax),%eax
    d20c:	0f af 45 24          	imul   0x24(%ebp),%eax
    d210:	83 c0 07             	add    $0x7,%eax
    d213:	c1 e8 03             	shr    $0x3,%eax
    d216:	83 c0 01             	add    $0x1,%eax
    d219:	0f af c1             	imul   %ecx,%eax
    d21c:	eb 05                	jmp    d223 <Adam7_getpassvalues+0x1b1>
    d21e:	b8 00 00 00 00       	mov    $0x0,%eax
    d223:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d225:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    d227:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d22a:	83 c0 01             	add    $0x1,%eax
    d22d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d234:	8b 45 14             	mov    0x14(%ebp),%eax
    d237:	01 c2                	add    %eax,%edx
    d239:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d23c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d243:	8b 45 14             	mov    0x14(%ebp),%eax
    d246:	01 c8                	add    %ecx,%eax
    d248:	8b 00                	mov    (%eax),%eax
    d24a:	89 c6                	mov    %eax,%esi
    d24c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d24f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d256:	8b 45 0c             	mov    0xc(%ebp),%eax
    d259:	01 c8                	add    %ecx,%eax
    d25b:	8b 08                	mov    (%eax),%ecx
    d25d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d260:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d267:	8b 45 08             	mov    0x8(%ebp),%eax
    d26a:	01 d8                	add    %ebx,%eax
    d26c:	8b 00                	mov    (%eax),%eax
    d26e:	0f af 45 24          	imul   0x24(%ebp),%eax
    d272:	83 c0 07             	add    $0x7,%eax
    d275:	c1 e8 03             	shr    $0x3,%eax
    d278:	0f af c1             	imul   %ecx,%eax
    d27b:	01 f0                	add    %esi,%eax
    d27d:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    d27f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d282:	83 c0 01             	add    $0x1,%eax
    d285:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d28c:	8b 45 18             	mov    0x18(%ebp),%eax
    d28f:	01 c2                	add    %eax,%edx
    d291:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d294:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d29b:	8b 45 18             	mov    0x18(%ebp),%eax
    d29e:	01 c8                	add    %ecx,%eax
    d2a0:	8b 00                	mov    (%eax),%eax
    d2a2:	89 c6                	mov    %eax,%esi
    d2a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2a7:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d2ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    d2b1:	01 c8                	add    %ecx,%eax
    d2b3:	8b 08                	mov    (%eax),%ecx
    d2b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2b8:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d2bf:	8b 45 08             	mov    0x8(%ebp),%eax
    d2c2:	01 d8                	add    %ebx,%eax
    d2c4:	8b 00                	mov    (%eax),%eax
    d2c6:	0f af c1             	imul   %ecx,%eax
    d2c9:	0f af 45 24          	imul   0x24(%ebp),%eax
    d2cd:	83 c0 07             	add    $0x7,%eax
    d2d0:	c1 e8 03             	shr    $0x3,%eax
    d2d3:	01 f0                	add    %esi,%eax
    d2d5:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    d2d7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d2db:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d2df:	0f 85 b6 fe ff ff    	jne    d19b <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    d2e5:	90                   	nop
    d2e6:	83 c4 10             	add    $0x10,%esp
    d2e9:	5b                   	pop    %ebx
    d2ea:	5e                   	pop    %esi
    d2eb:	5d                   	pop    %ebp
    d2ec:	c3                   	ret    

0000d2ed <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    d2ed:	55                   	push   %ebp
    d2ee:	89 e5                	mov    %esp,%ebp
    d2f0:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    d2f3:	8b 45 10             	mov    0x10(%ebp),%eax
    d2f6:	05 98 00 00 00       	add    $0x98,%eax
    d2fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    d2fe:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    d302:	74 06                	je     d30a <lodepng_inspect+0x1d>
    d304:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d308:	75 17                	jne    d321 <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    d30a:	8b 45 10             	mov    0x10(%ebp),%eax
    d30d:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    d314:	00 00 00 
    d317:	b8 30 00 00 00       	mov    $0x30,%eax
    d31c:	e9 ce 02 00 00       	jmp    d5ef <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    d321:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    d325:	7f 17                	jg     d33e <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    d327:	8b 45 10             	mov    0x10(%ebp),%eax
    d32a:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    d331:	00 00 00 
    d334:	b8 1b 00 00 00       	mov    $0x1b,%eax
    d339:	e9 b1 02 00 00       	jmp    d5ef <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    d33e:	83 ec 0c             	sub    $0xc,%esp
    d341:	ff 75 f4             	pushl  -0xc(%ebp)
    d344:	e8 63 c7 ff ff       	call   9aac <lodepng_info_cleanup>
    d349:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    d34c:	83 ec 0c             	sub    $0xc,%esp
    d34f:	ff 75 f4             	pushl  -0xc(%ebp)
    d352:	e8 74 c6 ff ff       	call   99cb <lodepng_info_init>
    d357:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    d35a:	8b 45 14             	mov    0x14(%ebp),%eax
    d35d:	0f b6 00             	movzbl (%eax),%eax
    d360:	3c 89                	cmp    $0x89,%al
    d362:	75 5b                	jne    d3bf <lodepng_inspect+0xd2>
    d364:	8b 45 14             	mov    0x14(%ebp),%eax
    d367:	83 c0 01             	add    $0x1,%eax
    d36a:	0f b6 00             	movzbl (%eax),%eax
    d36d:	3c 50                	cmp    $0x50,%al
    d36f:	75 4e                	jne    d3bf <lodepng_inspect+0xd2>
    d371:	8b 45 14             	mov    0x14(%ebp),%eax
    d374:	83 c0 02             	add    $0x2,%eax
    d377:	0f b6 00             	movzbl (%eax),%eax
    d37a:	3c 4e                	cmp    $0x4e,%al
    d37c:	75 41                	jne    d3bf <lodepng_inspect+0xd2>
    d37e:	8b 45 14             	mov    0x14(%ebp),%eax
    d381:	83 c0 03             	add    $0x3,%eax
    d384:	0f b6 00             	movzbl (%eax),%eax
    d387:	3c 47                	cmp    $0x47,%al
    d389:	75 34                	jne    d3bf <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    d38b:	8b 45 14             	mov    0x14(%ebp),%eax
    d38e:	83 c0 04             	add    $0x4,%eax
    d391:	0f b6 00             	movzbl (%eax),%eax
    d394:	3c 0d                	cmp    $0xd,%al
    d396:	75 27                	jne    d3bf <lodepng_inspect+0xd2>
    d398:	8b 45 14             	mov    0x14(%ebp),%eax
    d39b:	83 c0 05             	add    $0x5,%eax
    d39e:	0f b6 00             	movzbl (%eax),%eax
    d3a1:	3c 0a                	cmp    $0xa,%al
    d3a3:	75 1a                	jne    d3bf <lodepng_inspect+0xd2>
    d3a5:	8b 45 14             	mov    0x14(%ebp),%eax
    d3a8:	83 c0 06             	add    $0x6,%eax
    d3ab:	0f b6 00             	movzbl (%eax),%eax
    d3ae:	3c 1a                	cmp    $0x1a,%al
    d3b0:	75 0d                	jne    d3bf <lodepng_inspect+0xd2>
    d3b2:	8b 45 14             	mov    0x14(%ebp),%eax
    d3b5:	83 c0 07             	add    $0x7,%eax
    d3b8:	0f b6 00             	movzbl (%eax),%eax
    d3bb:	3c 0a                	cmp    $0xa,%al
    d3bd:	74 17                	je     d3d6 <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    d3bf:	8b 45 10             	mov    0x10(%ebp),%eax
    d3c2:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    d3c9:	00 00 00 
    d3cc:	b8 1c 00 00 00       	mov    $0x1c,%eax
    d3d1:	e9 19 02 00 00       	jmp    d5ef <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    d3d6:	8b 45 14             	mov    0x14(%ebp),%eax
    d3d9:	83 c0 08             	add    $0x8,%eax
    d3dc:	83 ec 0c             	sub    $0xc,%esp
    d3df:	50                   	push   %eax
    d3e0:	e8 c2 ae ff ff       	call   82a7 <lodepng_chunk_length>
    d3e5:	83 c4 10             	add    $0x10,%esp
    d3e8:	83 f8 0d             	cmp    $0xd,%eax
    d3eb:	74 17                	je     d404 <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    d3ed:	8b 45 10             	mov    0x10(%ebp),%eax
    d3f0:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    d3f7:	00 00 00 
    d3fa:	b8 5e 00 00 00       	mov    $0x5e,%eax
    d3ff:	e9 eb 01 00 00       	jmp    d5ef <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    d404:	8b 45 14             	mov    0x14(%ebp),%eax
    d407:	83 c0 08             	add    $0x8,%eax
    d40a:	83 ec 08             	sub    $0x8,%esp
    d40d:	68 4c a0 01 00       	push   $0x1a04c
    d412:	50                   	push   %eax
    d413:	e8 dc ae ff ff       	call   82f4 <lodepng_chunk_type_equals>
    d418:	83 c4 10             	add    $0x10,%esp
    d41b:	84 c0                	test   %al,%al
    d41d:	75 17                	jne    d436 <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    d41f:	8b 45 10             	mov    0x10(%ebp),%eax
    d422:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    d429:	00 00 00 
    d42c:	b8 1d 00 00 00       	mov    $0x1d,%eax
    d431:	e9 b9 01 00 00       	jmp    d5ef <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    d436:	8b 45 14             	mov    0x14(%ebp),%eax
    d439:	83 c0 10             	add    $0x10,%eax
    d43c:	83 ec 0c             	sub    $0xc,%esp
    d43f:	50                   	push   %eax
    d440:	e8 5e 62 ff ff       	call   36a3 <lodepng_read32bitInt>
    d445:	83 c4 10             	add    $0x10,%esp
    d448:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    d44b:	8b 45 14             	mov    0x14(%ebp),%eax
    d44e:	83 c0 14             	add    $0x14,%eax
    d451:	83 ec 0c             	sub    $0xc,%esp
    d454:	50                   	push   %eax
    d455:	e8 49 62 ff ff       	call   36a3 <lodepng_read32bitInt>
    d45a:	83 c4 10             	add    $0x10,%esp
    d45d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    d460:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    d464:	74 08                	je     d46e <lodepng_inspect+0x181>
    d466:	8b 45 08             	mov    0x8(%ebp),%eax
    d469:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d46c:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    d46e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    d472:	74 08                	je     d47c <lodepng_inspect+0x18f>
    d474:	8b 45 0c             	mov    0xc(%ebp),%eax
    d477:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d47a:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    d47c:	8b 45 14             	mov    0x14(%ebp),%eax
    d47f:	83 c0 18             	add    $0x18,%eax
    d482:	0f b6 00             	movzbl (%eax),%eax
    d485:	0f b6 d0             	movzbl %al,%edx
    d488:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d48b:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    d48e:	8b 45 14             	mov    0x14(%ebp),%eax
    d491:	83 c0 19             	add    $0x19,%eax
    d494:	0f b6 00             	movzbl (%eax),%eax
    d497:	0f b6 d0             	movzbl %al,%edx
    d49a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d49d:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    d4a0:	8b 45 14             	mov    0x14(%ebp),%eax
    d4a3:	83 c0 1a             	add    $0x1a,%eax
    d4a6:	0f b6 00             	movzbl (%eax),%eax
    d4a9:	0f b6 d0             	movzbl %al,%edx
    d4ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4af:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    d4b1:	8b 45 14             	mov    0x14(%ebp),%eax
    d4b4:	83 c0 1b             	add    $0x1b,%eax
    d4b7:	0f b6 00             	movzbl (%eax),%eax
    d4ba:	0f b6 d0             	movzbl %al,%edx
    d4bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4c0:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    d4c3:	8b 45 14             	mov    0x14(%ebp),%eax
    d4c6:	83 c0 1c             	add    $0x1c,%eax
    d4c9:	0f b6 00             	movzbl (%eax),%eax
    d4cc:	0f b6 d0             	movzbl %al,%edx
    d4cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4d2:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    d4d5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d4d9:	74 06                	je     d4e1 <lodepng_inspect+0x1f4>
    d4db:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d4df:	75 17                	jne    d4f8 <lodepng_inspect+0x20b>
    d4e1:	8b 45 10             	mov    0x10(%ebp),%eax
    d4e4:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    d4eb:	00 00 00 
    d4ee:	b8 5d 00 00 00       	mov    $0x5d,%eax
    d4f3:	e9 f7 00 00 00       	jmp    d5ef <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    d4f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4fb:	8b 50 10             	mov    0x10(%eax),%edx
    d4fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d501:	8b 40 0c             	mov    0xc(%eax),%eax
    d504:	83 ec 08             	sub    $0x8,%esp
    d507:	52                   	push   %edx
    d508:	50                   	push   %eax
    d509:	e8 d4 b3 ff ff       	call   88e2 <checkColorValidity>
    d50e:	83 c4 10             	add    $0x10,%esp
    d511:	89 c2                	mov    %eax,%edx
    d513:	8b 45 10             	mov    0x10(%ebp),%eax
    d516:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    d51c:	8b 45 10             	mov    0x10(%ebp),%eax
    d51f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d525:	85 c0                	test   %eax,%eax
    d527:	74 0e                	je     d537 <lodepng_inspect+0x24a>
    d529:	8b 45 10             	mov    0x10(%ebp),%eax
    d52c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d532:	e9 b8 00 00 00       	jmp    d5ef <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    d537:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d53a:	8b 00                	mov    (%eax),%eax
    d53c:	85 c0                	test   %eax,%eax
    d53e:	74 17                	je     d557 <lodepng_inspect+0x26a>
    d540:	8b 45 10             	mov    0x10(%ebp),%eax
    d543:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    d54a:	00 00 00 
    d54d:	b8 20 00 00 00       	mov    $0x20,%eax
    d552:	e9 98 00 00 00       	jmp    d5ef <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    d557:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d55a:	8b 40 04             	mov    0x4(%eax),%eax
    d55d:	85 c0                	test   %eax,%eax
    d55f:	74 14                	je     d575 <lodepng_inspect+0x288>
    d561:	8b 45 10             	mov    0x10(%ebp),%eax
    d564:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    d56b:	00 00 00 
    d56e:	b8 21 00 00 00       	mov    $0x21,%eax
    d573:	eb 7a                	jmp    d5ef <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    d575:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d578:	8b 40 08             	mov    0x8(%eax),%eax
    d57b:	83 f8 01             	cmp    $0x1,%eax
    d57e:	76 14                	jbe    d594 <lodepng_inspect+0x2a7>
    d580:	8b 45 10             	mov    0x10(%ebp),%eax
    d583:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    d58a:	00 00 00 
    d58d:	b8 22 00 00 00       	mov    $0x22,%eax
    d592:	eb 5b                	jmp    d5ef <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    d594:	8b 45 10             	mov    0x10(%ebp),%eax
    d597:	8b 40 18             	mov    0x18(%eax),%eax
    d59a:	85 c0                	test   %eax,%eax
    d59c:	75 48                	jne    d5e6 <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    d59e:	8b 45 14             	mov    0x14(%ebp),%eax
    d5a1:	83 c0 1d             	add    $0x1d,%eax
    d5a4:	83 ec 0c             	sub    $0xc,%esp
    d5a7:	50                   	push   %eax
    d5a8:	e8 f6 60 ff ff       	call   36a3 <lodepng_read32bitInt>
    d5ad:	83 c4 10             	add    $0x10,%esp
    d5b0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    d5b3:	8b 45 14             	mov    0x14(%ebp),%eax
    d5b6:	83 c0 0c             	add    $0xc,%eax
    d5b9:	83 ec 08             	sub    $0x8,%esp
    d5bc:	6a 11                	push   $0x11
    d5be:	50                   	push   %eax
    d5bf:	e8 71 ab ff ff       	call   8135 <lodepng_crc32>
    d5c4:	83 c4 10             	add    $0x10,%esp
    d5c7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    d5ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d5cd:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    d5d0:	74 14                	je     d5e6 <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    d5d2:	8b 45 10             	mov    0x10(%ebp),%eax
    d5d5:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    d5dc:	00 00 00 
    d5df:	b8 39 00 00 00       	mov    $0x39,%eax
    d5e4:	eb 09                	jmp    d5ef <lodepng_inspect+0x302>
    }
  }

  return state->error;
    d5e6:	8b 45 10             	mov    0x10(%ebp),%eax
    d5e9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    d5ef:	c9                   	leave  
    d5f0:	c3                   	ret    

0000d5f1 <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    d5f1:	55                   	push   %ebp
    d5f2:	89 e5                	mov    %esp,%ebp
    d5f4:	56                   	push   %esi
    d5f5:	53                   	push   %ebx
    d5f6:	83 ec 44             	sub    $0x44,%esp
    d5f9:	8b 45 18             	mov    0x18(%ebp),%eax
    d5fc:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    d5ff:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    d603:	83 f8 04             	cmp    $0x4,%eax
    d606:	0f 87 81 07 00 00    	ja     dd8d <unfilterScanline+0x79c>
    d60c:	8b 04 85 54 a0 01 00 	mov    0x1a054(,%eax,4),%eax
    d613:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d615:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d61c:	eb 19                	jmp    d637 <unfilterScanline+0x46>
    d61e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d621:	8b 45 08             	mov    0x8(%ebp),%eax
    d624:	01 c2                	add    %eax,%edx
    d626:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d629:	8b 45 0c             	mov    0xc(%ebp),%eax
    d62c:	01 c8                	add    %ecx,%eax
    d62e:	0f b6 00             	movzbl (%eax),%eax
    d631:	88 02                	mov    %al,(%edx)
    d633:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d637:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d63a:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d63d:	75 df                	jne    d61e <unfilterScanline+0x2d>
      break;
    d63f:	e9 50 07 00 00       	jmp    dd94 <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d644:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d64b:	eb 19                	jmp    d666 <unfilterScanline+0x75>
    d64d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d650:	8b 45 08             	mov    0x8(%ebp),%eax
    d653:	01 c2                	add    %eax,%edx
    d655:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d658:	8b 45 0c             	mov    0xc(%ebp),%eax
    d65b:	01 c8                	add    %ecx,%eax
    d65d:	0f b6 00             	movzbl (%eax),%eax
    d660:	88 02                	mov    %al,(%edx)
    d662:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d666:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d669:	3b 45 14             	cmp    0x14(%ebp),%eax
    d66c:	75 df                	jne    d64d <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    d66e:	8b 45 14             	mov    0x14(%ebp),%eax
    d671:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d674:	eb 2b                	jmp    d6a1 <unfilterScanline+0xb0>
    d676:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d679:	8b 45 08             	mov    0x8(%ebp),%eax
    d67c:	01 c2                	add    %eax,%edx
    d67e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d681:	8b 45 0c             	mov    0xc(%ebp),%eax
    d684:	01 c8                	add    %ecx,%eax
    d686:	0f b6 08             	movzbl (%eax),%ecx
    d689:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d68c:	2b 45 14             	sub    0x14(%ebp),%eax
    d68f:	89 c3                	mov    %eax,%ebx
    d691:	8b 45 08             	mov    0x8(%ebp),%eax
    d694:	01 d8                	add    %ebx,%eax
    d696:	0f b6 00             	movzbl (%eax),%eax
    d699:	01 c8                	add    %ecx,%eax
    d69b:	88 02                	mov    %al,(%edx)
    d69d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d6a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6a4:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d6a7:	7c cd                	jl     d676 <unfilterScanline+0x85>
      break;
    d6a9:	e9 e6 06 00 00       	jmp    dd94 <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    d6ae:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d6b2:	74 3c                	je     d6f0 <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    d6b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d6bb:	eb 26                	jmp    d6e3 <unfilterScanline+0xf2>
    d6bd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d6c0:	8b 45 08             	mov    0x8(%ebp),%eax
    d6c3:	01 d0                	add    %edx,%eax
    d6c5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d6c8:	8b 55 0c             	mov    0xc(%ebp),%edx
    d6cb:	01 ca                	add    %ecx,%edx
    d6cd:	0f b6 0a             	movzbl (%edx),%ecx
    d6d0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d6d3:	8b 55 10             	mov    0x10(%ebp),%edx
    d6d6:	01 da                	add    %ebx,%edx
    d6d8:	0f b6 12             	movzbl (%edx),%edx
    d6db:	01 ca                	add    %ecx,%edx
    d6dd:	88 10                	mov    %dl,(%eax)
    d6df:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d6e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6e6:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d6e9:	75 d2                	jne    d6bd <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    d6eb:	e9 a4 06 00 00       	jmp    dd94 <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d6f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d6f7:	eb 19                	jmp    d712 <unfilterScanline+0x121>
    d6f9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d6fc:	8b 45 08             	mov    0x8(%ebp),%eax
    d6ff:	01 c2                	add    %eax,%edx
    d701:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d704:	8b 45 0c             	mov    0xc(%ebp),%eax
    d707:	01 c8                	add    %ecx,%eax
    d709:	0f b6 00             	movzbl (%eax),%eax
    d70c:	88 02                	mov    %al,(%edx)
    d70e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d712:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d715:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d718:	75 df                	jne    d6f9 <unfilterScanline+0x108>
      }
      break;
    d71a:	e9 75 06 00 00       	jmp    dd94 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    d71f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d723:	0f 84 8e 00 00 00    	je     d7b7 <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    d729:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d730:	eb 28                	jmp    d75a <unfilterScanline+0x169>
    d732:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d735:	8b 45 08             	mov    0x8(%ebp),%eax
    d738:	01 d0                	add    %edx,%eax
    d73a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d73d:	8b 55 0c             	mov    0xc(%ebp),%edx
    d740:	01 ca                	add    %ecx,%edx
    d742:	0f b6 12             	movzbl (%edx),%edx
    d745:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d748:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d74b:	01 d9                	add    %ebx,%ecx
    d74d:	0f b6 09             	movzbl (%ecx),%ecx
    d750:	d0 e9                	shr    %cl
    d752:	01 ca                	add    %ecx,%edx
    d754:	88 10                	mov    %dl,(%eax)
    d756:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d75a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d75d:	3b 45 14             	cmp    0x14(%ebp),%eax
    d760:	75 d0                	jne    d732 <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    d762:	8b 45 14             	mov    0x14(%ebp),%eax
    d765:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d768:	eb 40                	jmp    d7aa <unfilterScanline+0x1b9>
    d76a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d76d:	8b 45 08             	mov    0x8(%ebp),%eax
    d770:	01 c2                	add    %eax,%edx
    d772:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d775:	8b 45 0c             	mov    0xc(%ebp),%eax
    d778:	01 c8                	add    %ecx,%eax
    d77a:	0f b6 08             	movzbl (%eax),%ecx
    d77d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d780:	2b 45 14             	sub    0x14(%ebp),%eax
    d783:	89 c3                	mov    %eax,%ebx
    d785:	8b 45 08             	mov    0x8(%ebp),%eax
    d788:	01 d8                	add    %ebx,%eax
    d78a:	0f b6 00             	movzbl (%eax),%eax
    d78d:	0f b6 d8             	movzbl %al,%ebx
    d790:	8b 75 f4             	mov    -0xc(%ebp),%esi
    d793:	8b 45 10             	mov    0x10(%ebp),%eax
    d796:	01 f0                	add    %esi,%eax
    d798:	0f b6 00             	movzbl (%eax),%eax
    d79b:	0f b6 c0             	movzbl %al,%eax
    d79e:	01 d8                	add    %ebx,%eax
    d7a0:	d1 f8                	sar    %eax
    d7a2:	01 c8                	add    %ecx,%eax
    d7a4:	88 02                	mov    %al,(%edx)
    d7a6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7ad:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d7b0:	7c b8                	jl     d76a <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    d7b2:	e9 dd 05 00 00       	jmp    dd94 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d7b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d7be:	eb 19                	jmp    d7d9 <unfilterScanline+0x1e8>
    d7c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d7c3:	8b 45 08             	mov    0x8(%ebp),%eax
    d7c6:	01 c2                	add    %eax,%edx
    d7c8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7ce:	01 c8                	add    %ecx,%eax
    d7d0:	0f b6 00             	movzbl (%eax),%eax
    d7d3:	88 02                	mov    %al,(%edx)
    d7d5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7dc:	3b 45 14             	cmp    0x14(%ebp),%eax
    d7df:	75 df                	jne    d7c0 <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    d7e1:	8b 45 14             	mov    0x14(%ebp),%eax
    d7e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d7e7:	eb 2d                	jmp    d816 <unfilterScanline+0x225>
    d7e9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d7ec:	8b 45 08             	mov    0x8(%ebp),%eax
    d7ef:	01 c2                	add    %eax,%edx
    d7f1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7f4:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7f7:	01 c8                	add    %ecx,%eax
    d7f9:	0f b6 08             	movzbl (%eax),%ecx
    d7fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7ff:	2b 45 14             	sub    0x14(%ebp),%eax
    d802:	89 c3                	mov    %eax,%ebx
    d804:	8b 45 08             	mov    0x8(%ebp),%eax
    d807:	01 d8                	add    %ebx,%eax
    d809:	0f b6 00             	movzbl (%eax),%eax
    d80c:	d0 e8                	shr    %al
    d80e:	01 c8                	add    %ecx,%eax
    d810:	88 02                	mov    %al,(%edx)
    d812:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d816:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d819:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d81c:	7c cb                	jl     d7e9 <unfilterScanline+0x1f8>
      }
      break;
    d81e:	e9 71 05 00 00       	jmp    dd94 <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    d823:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d827:	0f 84 f9 04 00 00    	je     dd26 <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    d82d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d834:	eb 26                	jmp    d85c <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    d836:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d839:	8b 45 08             	mov    0x8(%ebp),%eax
    d83c:	01 d0                	add    %edx,%eax
    d83e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d841:	8b 55 0c             	mov    0xc(%ebp),%edx
    d844:	01 ca                	add    %ecx,%edx
    d846:	0f b6 0a             	movzbl (%edx),%ecx
    d849:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d84c:	8b 55 10             	mov    0x10(%ebp),%edx
    d84f:	01 da                	add    %ebx,%edx
    d851:	0f b6 12             	movzbl (%edx),%edx
    d854:	01 ca                	add    %ecx,%edx
    d856:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    d858:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d85c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d85f:	3b 45 14             	cmp    0x14(%ebp),%eax
    d862:	75 d2                	jne    d836 <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    d864:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    d868:	0f 8e db 01 00 00    	jle    da49 <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    d86e:	e9 c2 01 00 00       	jmp    da35 <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    d873:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d876:	2b 45 14             	sub    0x14(%ebp),%eax
    d879:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    d87c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d87f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d882:	01 d0                	add    %edx,%eax
    d884:	0f b6 00             	movzbl (%eax),%eax
    d887:	88 45 ef             	mov    %al,-0x11(%ebp)
    d88a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d88d:	8d 50 01             	lea    0x1(%eax),%edx
    d890:	8b 45 0c             	mov    0xc(%ebp),%eax
    d893:	01 d0                	add    %edx,%eax
    d895:	0f b6 00             	movzbl (%eax),%eax
    d898:	88 45 ee             	mov    %al,-0x12(%ebp)
    d89b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d89e:	8d 50 02             	lea    0x2(%eax),%edx
    d8a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    d8a4:	01 d0                	add    %edx,%eax
    d8a6:	0f b6 00             	movzbl (%eax),%eax
    d8a9:	88 45 ed             	mov    %al,-0x13(%ebp)
    d8ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8af:	8d 50 03             	lea    0x3(%eax),%edx
    d8b2:	8b 45 0c             	mov    0xc(%ebp),%eax
    d8b5:	01 d0                	add    %edx,%eax
    d8b7:	0f b6 00             	movzbl (%eax),%eax
    d8ba:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    d8bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d8c0:	8b 45 08             	mov    0x8(%ebp),%eax
    d8c3:	01 d0                	add    %edx,%eax
    d8c5:	0f b6 00             	movzbl (%eax),%eax
    d8c8:	88 45 eb             	mov    %al,-0x15(%ebp)
    d8cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d8ce:	8d 50 01             	lea    0x1(%eax),%edx
    d8d1:	8b 45 08             	mov    0x8(%ebp),%eax
    d8d4:	01 d0                	add    %edx,%eax
    d8d6:	0f b6 00             	movzbl (%eax),%eax
    d8d9:	88 45 ea             	mov    %al,-0x16(%ebp)
    d8dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d8df:	8d 50 02             	lea    0x2(%eax),%edx
    d8e2:	8b 45 08             	mov    0x8(%ebp),%eax
    d8e5:	01 d0                	add    %edx,%eax
    d8e7:	0f b6 00             	movzbl (%eax),%eax
    d8ea:	88 45 e9             	mov    %al,-0x17(%ebp)
    d8ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d8f0:	8d 50 03             	lea    0x3(%eax),%edx
    d8f3:	8b 45 08             	mov    0x8(%ebp),%eax
    d8f6:	01 d0                	add    %edx,%eax
    d8f8:	0f b6 00             	movzbl (%eax),%eax
    d8fb:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    d8fe:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d901:	8b 45 10             	mov    0x10(%ebp),%eax
    d904:	01 d0                	add    %edx,%eax
    d906:	0f b6 00             	movzbl (%eax),%eax
    d909:	88 45 e7             	mov    %al,-0x19(%ebp)
    d90c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d90f:	8d 50 01             	lea    0x1(%eax),%edx
    d912:	8b 45 10             	mov    0x10(%ebp),%eax
    d915:	01 d0                	add    %edx,%eax
    d917:	0f b6 00             	movzbl (%eax),%eax
    d91a:	88 45 e6             	mov    %al,-0x1a(%ebp)
    d91d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d920:	8d 50 02             	lea    0x2(%eax),%edx
    d923:	8b 45 10             	mov    0x10(%ebp),%eax
    d926:	01 d0                	add    %edx,%eax
    d928:	0f b6 00             	movzbl (%eax),%eax
    d92b:	88 45 e5             	mov    %al,-0x1b(%ebp)
    d92e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d931:	8d 50 03             	lea    0x3(%eax),%edx
    d934:	8b 45 10             	mov    0x10(%ebp),%eax
    d937:	01 d0                	add    %edx,%eax
    d939:	0f b6 00             	movzbl (%eax),%eax
    d93c:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    d93f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d942:	8b 45 10             	mov    0x10(%ebp),%eax
    d945:	01 d0                	add    %edx,%eax
    d947:	0f b6 00             	movzbl (%eax),%eax
    d94a:	88 45 e3             	mov    %al,-0x1d(%ebp)
    d94d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d950:	8d 50 01             	lea    0x1(%eax),%edx
    d953:	8b 45 10             	mov    0x10(%ebp),%eax
    d956:	01 d0                	add    %edx,%eax
    d958:	0f b6 00             	movzbl (%eax),%eax
    d95b:	88 45 e2             	mov    %al,-0x1e(%ebp)
    d95e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d961:	8d 50 02             	lea    0x2(%eax),%edx
    d964:	8b 45 10             	mov    0x10(%ebp),%eax
    d967:	01 d0                	add    %edx,%eax
    d969:	0f b6 00             	movzbl (%eax),%eax
    d96c:	88 45 e1             	mov    %al,-0x1f(%ebp)
    d96f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d972:	8d 50 03             	lea    0x3(%eax),%edx
    d975:	8b 45 10             	mov    0x10(%ebp),%eax
    d978:	01 d0                	add    %edx,%eax
    d97a:	0f b6 00             	movzbl (%eax),%eax
    d97d:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    d980:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d983:	8b 45 08             	mov    0x8(%ebp),%eax
    d986:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d989:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    d98d:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    d991:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    d995:	51                   	push   %ecx
    d996:	52                   	push   %edx
    d997:	50                   	push   %eax
    d998:	e8 3f f6 ff ff       	call   cfdc <paethPredictor>
    d99d:	83 c4 0c             	add    $0xc,%esp
    d9a0:	89 c2                	mov    %eax,%edx
    d9a2:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    d9a6:	01 d0                	add    %edx,%eax
    d9a8:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    d9aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9ad:	8d 50 01             	lea    0x1(%eax),%edx
    d9b0:	8b 45 08             	mov    0x8(%ebp),%eax
    d9b3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d9b6:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    d9ba:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    d9be:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    d9c2:	51                   	push   %ecx
    d9c3:	52                   	push   %edx
    d9c4:	50                   	push   %eax
    d9c5:	e8 12 f6 ff ff       	call   cfdc <paethPredictor>
    d9ca:	83 c4 0c             	add    $0xc,%esp
    d9cd:	89 c2                	mov    %eax,%edx
    d9cf:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    d9d3:	01 d0                	add    %edx,%eax
    d9d5:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    d9d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9da:	8d 50 02             	lea    0x2(%eax),%edx
    d9dd:	8b 45 08             	mov    0x8(%ebp),%eax
    d9e0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    d9e3:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    d9e7:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    d9eb:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    d9ef:	51                   	push   %ecx
    d9f0:	52                   	push   %edx
    d9f1:	50                   	push   %eax
    d9f2:	e8 e5 f5 ff ff       	call   cfdc <paethPredictor>
    d9f7:	83 c4 0c             	add    $0xc,%esp
    d9fa:	89 c2                	mov    %eax,%edx
    d9fc:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    da00:	01 d0                	add    %edx,%eax
    da02:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    da04:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da07:	8d 50 03             	lea    0x3(%eax),%edx
    da0a:	8b 45 08             	mov    0x8(%ebp),%eax
    da0d:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    da10:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    da14:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    da18:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    da1c:	51                   	push   %ecx
    da1d:	52                   	push   %edx
    da1e:	50                   	push   %eax
    da1f:	e8 b8 f5 ff ff       	call   cfdc <paethPredictor>
    da24:	83 c4 0c             	add    $0xc,%esp
    da27:	89 c2                	mov    %eax,%edx
    da29:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    da2d:	01 d0                	add    %edx,%eax
    da2f:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    da31:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    da35:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da38:	83 c0 03             	add    $0x3,%eax
    da3b:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    da3e:	0f 8c 2f fe ff ff    	jl     d873 <unfilterScanline+0x282>
    da44:	e9 d3 02 00 00       	jmp    dd1c <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    da49:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    da4d:	0f 8e 6a 01 00 00    	jle    dbbd <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    da53:	e9 51 01 00 00       	jmp    dba9 <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    da58:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da5b:	2b 45 14             	sub    0x14(%ebp),%eax
    da5e:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    da61:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da64:	8b 45 0c             	mov    0xc(%ebp),%eax
    da67:	01 d0                	add    %edx,%eax
    da69:	0f b6 00             	movzbl (%eax),%eax
    da6c:	88 45 db             	mov    %al,-0x25(%ebp)
    da6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da72:	8d 50 01             	lea    0x1(%eax),%edx
    da75:	8b 45 0c             	mov    0xc(%ebp),%eax
    da78:	01 d0                	add    %edx,%eax
    da7a:	0f b6 00             	movzbl (%eax),%eax
    da7d:	88 45 da             	mov    %al,-0x26(%ebp)
    da80:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da83:	8d 50 02             	lea    0x2(%eax),%edx
    da86:	8b 45 0c             	mov    0xc(%ebp),%eax
    da89:	01 d0                	add    %edx,%eax
    da8b:	0f b6 00             	movzbl (%eax),%eax
    da8e:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    da91:	8b 55 dc             	mov    -0x24(%ebp),%edx
    da94:	8b 45 08             	mov    0x8(%ebp),%eax
    da97:	01 d0                	add    %edx,%eax
    da99:	0f b6 00             	movzbl (%eax),%eax
    da9c:	88 45 d8             	mov    %al,-0x28(%ebp)
    da9f:	8b 45 dc             	mov    -0x24(%ebp),%eax
    daa2:	8d 50 01             	lea    0x1(%eax),%edx
    daa5:	8b 45 08             	mov    0x8(%ebp),%eax
    daa8:	01 d0                	add    %edx,%eax
    daaa:	0f b6 00             	movzbl (%eax),%eax
    daad:	88 45 d7             	mov    %al,-0x29(%ebp)
    dab0:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dab3:	8d 50 02             	lea    0x2(%eax),%edx
    dab6:	8b 45 08             	mov    0x8(%ebp),%eax
    dab9:	01 d0                	add    %edx,%eax
    dabb:	0f b6 00             	movzbl (%eax),%eax
    dabe:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    dac1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dac4:	8b 45 10             	mov    0x10(%ebp),%eax
    dac7:	01 d0                	add    %edx,%eax
    dac9:	0f b6 00             	movzbl (%eax),%eax
    dacc:	88 45 d5             	mov    %al,-0x2b(%ebp)
    dacf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dad2:	8d 50 01             	lea    0x1(%eax),%edx
    dad5:	8b 45 10             	mov    0x10(%ebp),%eax
    dad8:	01 d0                	add    %edx,%eax
    dada:	0f b6 00             	movzbl (%eax),%eax
    dadd:	88 45 d4             	mov    %al,-0x2c(%ebp)
    dae0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dae3:	8d 50 02             	lea    0x2(%eax),%edx
    dae6:	8b 45 10             	mov    0x10(%ebp),%eax
    dae9:	01 d0                	add    %edx,%eax
    daeb:	0f b6 00             	movzbl (%eax),%eax
    daee:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    daf1:	8b 55 dc             	mov    -0x24(%ebp),%edx
    daf4:	8b 45 10             	mov    0x10(%ebp),%eax
    daf7:	01 d0                	add    %edx,%eax
    daf9:	0f b6 00             	movzbl (%eax),%eax
    dafc:	88 45 d2             	mov    %al,-0x2e(%ebp)
    daff:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db02:	8d 50 01             	lea    0x1(%eax),%edx
    db05:	8b 45 10             	mov    0x10(%ebp),%eax
    db08:	01 d0                	add    %edx,%eax
    db0a:	0f b6 00             	movzbl (%eax),%eax
    db0d:	88 45 d1             	mov    %al,-0x2f(%ebp)
    db10:	8b 45 dc             	mov    -0x24(%ebp),%eax
    db13:	8d 50 02             	lea    0x2(%eax),%edx
    db16:	8b 45 10             	mov    0x10(%ebp),%eax
    db19:	01 d0                	add    %edx,%eax
    db1b:	0f b6 00             	movzbl (%eax),%eax
    db1e:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    db21:	8b 55 f4             	mov    -0xc(%ebp),%edx
    db24:	8b 45 08             	mov    0x8(%ebp),%eax
    db27:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db2a:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    db2e:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    db32:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    db36:	51                   	push   %ecx
    db37:	52                   	push   %edx
    db38:	50                   	push   %eax
    db39:	e8 9e f4 ff ff       	call   cfdc <paethPredictor>
    db3e:	83 c4 0c             	add    $0xc,%esp
    db41:	89 c2                	mov    %eax,%edx
    db43:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    db47:	01 d0                	add    %edx,%eax
    db49:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    db4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db4e:	8d 50 01             	lea    0x1(%eax),%edx
    db51:	8b 45 08             	mov    0x8(%ebp),%eax
    db54:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db57:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    db5b:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    db5f:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    db63:	51                   	push   %ecx
    db64:	52                   	push   %edx
    db65:	50                   	push   %eax
    db66:	e8 71 f4 ff ff       	call   cfdc <paethPredictor>
    db6b:	83 c4 0c             	add    $0xc,%esp
    db6e:	89 c2                	mov    %eax,%edx
    db70:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    db74:	01 d0                	add    %edx,%eax
    db76:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    db78:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db7b:	8d 50 02             	lea    0x2(%eax),%edx
    db7e:	8b 45 08             	mov    0x8(%ebp),%eax
    db81:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db84:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    db88:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    db8c:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    db90:	51                   	push   %ecx
    db91:	52                   	push   %edx
    db92:	50                   	push   %eax
    db93:	e8 44 f4 ff ff       	call   cfdc <paethPredictor>
    db98:	83 c4 0c             	add    $0xc,%esp
    db9b:	89 c2                	mov    %eax,%edx
    db9d:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    dba1:	01 d0                	add    %edx,%eax
    dba3:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    dba5:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    dba9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbac:	83 c0 02             	add    $0x2,%eax
    dbaf:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dbb2:	0f 8c a0 fe ff ff    	jl     da58 <unfilterScanline+0x467>
    dbb8:	e9 5f 01 00 00       	jmp    dd1c <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    dbbd:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    dbc1:	0f 8e 55 01 00 00    	jle    dd1c <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    dbc7:	e9 e0 00 00 00       	jmp    dcac <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    dbcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbcf:	2b 45 14             	sub    0x14(%ebp),%eax
    dbd2:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    dbd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dbd8:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbdb:	01 d0                	add    %edx,%eax
    dbdd:	0f b6 00             	movzbl (%eax),%eax
    dbe0:	88 45 cb             	mov    %al,-0x35(%ebp)
    dbe3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbe6:	8d 50 01             	lea    0x1(%eax),%edx
    dbe9:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbec:	01 d0                	add    %edx,%eax
    dbee:	0f b6 00             	movzbl (%eax),%eax
    dbf1:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    dbf4:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dbf7:	8b 45 08             	mov    0x8(%ebp),%eax
    dbfa:	01 d0                	add    %edx,%eax
    dbfc:	0f b6 00             	movzbl (%eax),%eax
    dbff:	88 45 c9             	mov    %al,-0x37(%ebp)
    dc02:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dc05:	8d 50 01             	lea    0x1(%eax),%edx
    dc08:	8b 45 08             	mov    0x8(%ebp),%eax
    dc0b:	01 d0                	add    %edx,%eax
    dc0d:	0f b6 00             	movzbl (%eax),%eax
    dc10:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    dc13:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc16:	8b 45 10             	mov    0x10(%ebp),%eax
    dc19:	01 d0                	add    %edx,%eax
    dc1b:	0f b6 00             	movzbl (%eax),%eax
    dc1e:	88 45 c7             	mov    %al,-0x39(%ebp)
    dc21:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc24:	8d 50 01             	lea    0x1(%eax),%edx
    dc27:	8b 45 10             	mov    0x10(%ebp),%eax
    dc2a:	01 d0                	add    %edx,%eax
    dc2c:	0f b6 00             	movzbl (%eax),%eax
    dc2f:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    dc32:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dc35:	8b 45 10             	mov    0x10(%ebp),%eax
    dc38:	01 d0                	add    %edx,%eax
    dc3a:	0f b6 00             	movzbl (%eax),%eax
    dc3d:	88 45 c5             	mov    %al,-0x3b(%ebp)
    dc40:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dc43:	8d 50 01             	lea    0x1(%eax),%edx
    dc46:	8b 45 10             	mov    0x10(%ebp),%eax
    dc49:	01 d0                	add    %edx,%eax
    dc4b:	0f b6 00             	movzbl (%eax),%eax
    dc4e:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dc51:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc54:	8b 45 08             	mov    0x8(%ebp),%eax
    dc57:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc5a:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    dc5e:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    dc62:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    dc66:	51                   	push   %ecx
    dc67:	52                   	push   %edx
    dc68:	50                   	push   %eax
    dc69:	e8 6e f3 ff ff       	call   cfdc <paethPredictor>
    dc6e:	83 c4 0c             	add    $0xc,%esp
    dc71:	89 c2                	mov    %eax,%edx
    dc73:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    dc77:	01 d0                	add    %edx,%eax
    dc79:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dc7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc7e:	8d 50 01             	lea    0x1(%eax),%edx
    dc81:	8b 45 08             	mov    0x8(%ebp),%eax
    dc84:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc87:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    dc8b:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    dc8f:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    dc93:	51                   	push   %ecx
    dc94:	52                   	push   %edx
    dc95:	50                   	push   %eax
    dc96:	e8 41 f3 ff ff       	call   cfdc <paethPredictor>
    dc9b:	83 c4 0c             	add    $0xc,%esp
    dc9e:	89 c2                	mov    %eax,%edx
    dca0:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    dca4:	01 d0                	add    %edx,%eax
    dca6:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    dca8:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    dcac:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcaf:	83 c0 01             	add    $0x1,%eax
    dcb2:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dcb5:	0f 8c 11 ff ff ff    	jl     dbcc <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dcbb:	eb 5f                	jmp    dd1c <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    dcbd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcc0:	8b 45 08             	mov    0x8(%ebp),%eax
    dcc3:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dcc6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcc9:	8b 45 0c             	mov    0xc(%ebp),%eax
    dccc:	01 d0                	add    %edx,%eax
    dcce:	0f b6 00             	movzbl (%eax),%eax
    dcd1:	88 45 b7             	mov    %al,-0x49(%ebp)
    dcd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcd7:	2b 45 14             	sub    0x14(%ebp),%eax
    dcda:	89 c2                	mov    %eax,%edx
    dcdc:	8b 45 10             	mov    0x10(%ebp),%eax
    dcdf:	01 d0                	add    %edx,%eax
    dce1:	0f b6 00             	movzbl (%eax),%eax
    dce4:	0f b6 c8             	movzbl %al,%ecx
    dce7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dcea:	8b 45 10             	mov    0x10(%ebp),%eax
    dced:	01 d0                	add    %edx,%eax
    dcef:	0f b6 00             	movzbl (%eax),%eax
    dcf2:	0f b6 d0             	movzbl %al,%edx
    dcf5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcf8:	2b 45 14             	sub    0x14(%ebp),%eax
    dcfb:	89 c6                	mov    %eax,%esi
    dcfd:	8b 45 08             	mov    0x8(%ebp),%eax
    dd00:	01 f0                	add    %esi,%eax
    dd02:	0f b6 00             	movzbl (%eax),%eax
    dd05:	0f b6 c0             	movzbl %al,%eax
    dd08:	51                   	push   %ecx
    dd09:	52                   	push   %edx
    dd0a:	50                   	push   %eax
    dd0b:	e8 cc f2 ff ff       	call   cfdc <paethPredictor>
    dd10:	83 c4 0c             	add    $0xc,%esp
    dd13:	02 45 b7             	add    -0x49(%ebp),%al
    dd16:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dd18:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd1f:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd22:	75 99                	jne    dcbd <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    dd24:	eb 6e                	jmp    dd94 <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    dd26:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dd2d:	eb 19                	jmp    dd48 <unfilterScanline+0x757>
          recon[i] = scanline[i];
    dd2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd32:	8b 45 08             	mov    0x8(%ebp),%eax
    dd35:	01 c2                	add    %eax,%edx
    dd37:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dd3a:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd3d:	01 c8                	add    %ecx,%eax
    dd3f:	0f b6 00             	movzbl (%eax),%eax
    dd42:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    dd44:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd48:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd4b:	3b 45 14             	cmp    0x14(%ebp),%eax
    dd4e:	75 df                	jne    dd2f <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    dd50:	8b 45 14             	mov    0x14(%ebp),%eax
    dd53:	89 45 f4             	mov    %eax,-0xc(%ebp)
    dd56:	eb 2b                	jmp    dd83 <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    dd58:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd5b:	8b 45 08             	mov    0x8(%ebp),%eax
    dd5e:	01 c2                	add    %eax,%edx
    dd60:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dd63:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd66:	01 c8                	add    %ecx,%eax
    dd68:	0f b6 08             	movzbl (%eax),%ecx
    dd6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd6e:	2b 45 14             	sub    0x14(%ebp),%eax
    dd71:	89 c3                	mov    %eax,%ebx
    dd73:	8b 45 08             	mov    0x8(%ebp),%eax
    dd76:	01 d8                	add    %ebx,%eax
    dd78:	0f b6 00             	movzbl (%eax),%eax
    dd7b:	01 c8                	add    %ecx,%eax
    dd7d:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    dd7f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dd83:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd86:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd89:	7c cd                	jl     dd58 <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    dd8b:	eb 07                	jmp    dd94 <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    dd8d:	b8 24 00 00 00       	mov    $0x24,%eax
    dd92:	eb 05                	jmp    dd99 <unfilterScanline+0x7a8>
  }
  return 0;
    dd94:	b8 00 00 00 00       	mov    $0x0,%eax
}
    dd99:	8d 65 f8             	lea    -0x8(%ebp),%esp
    dd9c:	5b                   	pop    %ebx
    dd9d:	5e                   	pop    %esi
    dd9e:	5d                   	pop    %ebp
    dd9f:	c3                   	ret    

0000dda0 <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    dda0:	55                   	push   %ebp
    dda1:	89 e5                	mov    %esp,%ebp
    dda3:	53                   	push   %ebx
    dda4:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    dda7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    ddae:	8b 45 18             	mov    0x18(%ebp),%eax
    ddb1:	83 c0 07             	add    $0x7,%eax
    ddb4:	c1 e8 03             	shr    $0x3,%eax
    ddb7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    ddba:	ff 75 18             	pushl  0x18(%ebp)
    ddbd:	6a 01                	push   $0x1
    ddbf:	ff 75 10             	pushl  0x10(%ebp)
    ddc2:	e8 d9 b1 ff ff       	call   8fa0 <lodepng_get_raw_size_idat>
    ddc7:	83 c4 0c             	add    $0xc,%esp
    ddca:	83 e8 01             	sub    $0x1,%eax
    ddcd:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    ddd0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ddd7:	eb 6d                	jmp    de46 <unfilter+0xa6>
    size_t outindex = linebytes * y;
    ddd9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dddc:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    dde0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    dde3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dde6:	83 c0 01             	add    $0x1,%eax
    dde9:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    dded:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    ddf0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ddf3:	8b 45 0c             	mov    0xc(%ebp),%eax
    ddf6:	01 d0                	add    %edx,%eax
    ddf8:	0f b6 00             	movzbl (%eax),%eax
    ddfb:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    ddfe:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    de02:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    de05:	8d 4a 01             	lea    0x1(%edx),%ecx
    de08:	8b 55 0c             	mov    0xc(%ebp),%edx
    de0b:	01 d1                	add    %edx,%ecx
    de0d:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    de10:	8b 55 08             	mov    0x8(%ebp),%edx
    de13:	01 da                	add    %ebx,%edx
    de15:	ff 75 ec             	pushl  -0x14(%ebp)
    de18:	50                   	push   %eax
    de19:	ff 75 f0             	pushl  -0x10(%ebp)
    de1c:	ff 75 f4             	pushl  -0xc(%ebp)
    de1f:	51                   	push   %ecx
    de20:	52                   	push   %edx
    de21:	e8 cb f7 ff ff       	call   d5f1 <unfilterScanline>
    de26:	83 c4 18             	add    $0x18,%esp
    de29:	89 45 dc             	mov    %eax,-0x24(%ebp)
    de2c:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    de30:	74 05                	je     de37 <unfilter+0x97>
    de32:	8b 45 dc             	mov    -0x24(%ebp),%eax
    de35:	eb 1c                	jmp    de53 <unfilter+0xb3>

    prevline = &out[outindex];
    de37:	8b 55 e8             	mov    -0x18(%ebp),%edx
    de3a:	8b 45 08             	mov    0x8(%ebp),%eax
    de3d:	01 d0                	add    %edx,%eax
    de3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    de42:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    de46:	8b 45 f8             	mov    -0x8(%ebp),%eax
    de49:	3b 45 14             	cmp    0x14(%ebp),%eax
    de4c:	72 8b                	jb     ddd9 <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    de4e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    de53:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    de56:	c9                   	leave  
    de57:	c3                   	ret    

0000de58 <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    de58:	55                   	push   %ebp
    de59:	89 e5                	mov    %esp,%ebp
    de5b:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    de61:	ff 75 18             	pushl  0x18(%ebp)
    de64:	ff 75 14             	pushl  0x14(%ebp)
    de67:	ff 75 10             	pushl  0x10(%ebp)
    de6a:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    de70:	50                   	push   %eax
    de71:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    de77:	50                   	push   %eax
    de78:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    de7e:	50                   	push   %eax
    de7f:	8d 45 94             	lea    -0x6c(%ebp),%eax
    de82:	50                   	push   %eax
    de83:	8d 45 b0             	lea    -0x50(%ebp),%eax
    de86:	50                   	push   %eax
    de87:	e8 e6 f1 ff ff       	call   d072 <Adam7_getpassvalues>
    de8c:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    de8f:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    de93:	0f 86 0a 01 00 00    	jbe    dfa3 <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    de99:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    dea0:	e9 ef 00 00 00       	jmp    df94 <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    dea5:	8b 45 18             	mov    0x18(%ebp),%eax
    dea8:	c1 e8 03             	shr    $0x3,%eax
    deab:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    deae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    deb5:	e9 c6 00 00 00       	jmp    df80 <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    deba:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    dec1:	e9 a6 00 00 00       	jmp    df6c <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    dec6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dec9:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    ded0:	89 c1                	mov    %eax,%ecx
    ded2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    ded5:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    ded9:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    dedd:	89 c2                	mov    %eax,%edx
    dedf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    dee2:	01 c2                	add    %eax,%edx
    dee4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    dee7:	0f af c2             	imul   %edx,%eax
    deea:	01 c8                	add    %ecx,%eax
    deec:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    deef:	8b 45 fc             	mov    -0x4(%ebp),%eax
    def2:	8b 14 85 f8 9f 01 00 	mov    0x19ff8(,%eax,4),%edx
    def9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    defc:	8b 04 85 30 a0 01 00 	mov    0x1a030(,%eax,4),%eax
    df03:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    df07:	01 d0                	add    %edx,%eax
    df09:	0f af 45 10          	imul   0x10(%ebp),%eax
    df0d:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    df0f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df12:	8b 04 85 14 a0 01 00 	mov    0x1a014(,%eax,4),%eax
    df19:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    df1d:	01 c2                	add    %eax,%edx
    df1f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df22:	8b 04 85 dc 9f 01 00 	mov    0x19fdc(,%eax,4),%eax
    df29:	01 c2                	add    %eax,%edx
    df2b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    df2e:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    df31:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    df34:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    df3b:	eb 23                	jmp    df60 <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    df3d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    df40:	8b 45 f0             	mov    -0x10(%ebp),%eax
    df43:	01 c2                	add    %eax,%edx
    df45:	8b 45 08             	mov    0x8(%ebp),%eax
    df48:	01 c2                	add    %eax,%edx
    df4a:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    df4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    df50:	01 c1                	add    %eax,%ecx
    df52:	8b 45 0c             	mov    0xc(%ebp),%eax
    df55:	01 c8                	add    %ecx,%eax
    df57:	0f b6 00             	movzbl (%eax),%eax
    df5a:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    df5c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    df60:	8b 45 e0             	mov    -0x20(%ebp),%eax
    df63:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    df66:	72 d5                	jb     df3d <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    df68:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    df6c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df6f:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    df73:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    df76:	0f 87 4a ff ff ff    	ja     dec6 <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    df7c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    df80:	8b 45 fc             	mov    -0x4(%ebp),%eax
    df83:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    df87:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    df8a:	0f 87 2a ff ff ff    	ja     deba <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    df90:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    df94:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    df98:	0f 85 07 ff ff ff    	jne    dea5 <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    df9e:	e9 22 01 00 00       	jmp    e0c5 <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    dfa3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    dfaa:	e9 0c 01 00 00       	jmp    e0bb <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    dfaf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfb2:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    dfb6:	0f af 45 18          	imul   0x18(%ebp),%eax
    dfba:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    dfbd:	8b 45 18             	mov    0x18(%ebp),%eax
    dfc0:	0f af 45 10          	imul   0x10(%ebp),%eax
    dfc4:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    dfc7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    dfce:	e9 d4 00 00 00       	jmp    e0a7 <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    dfd3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    dfda:	e9 b4 00 00 00       	jmp    e093 <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    dfdf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    dfe2:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    dfe9:	c1 e0 03             	shl    $0x3,%eax
    dfec:	89 c1                	mov    %eax,%ecx
    dfee:	8b 45 e8             	mov    -0x18(%ebp),%eax
    dff1:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    dff5:	89 c2                	mov    %eax,%edx
    dff7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    dffa:	0f af 45 18          	imul   0x18(%ebp),%eax
    dffe:	01 d0                	add    %edx,%eax
    e000:	01 c8                	add    %ecx,%eax
    e002:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    e008:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e00b:	8b 14 85 f8 9f 01 00 	mov    0x19ff8(,%eax,4),%edx
    e012:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e015:	8b 04 85 30 a0 01 00 	mov    0x1a030(,%eax,4),%eax
    e01c:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    e020:	01 d0                	add    %edx,%eax
    e022:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    e026:	89 c2                	mov    %eax,%edx
    e028:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e02b:	8b 0c 85 dc 9f 01 00 	mov    0x19fdc(,%eax,4),%ecx
    e032:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e035:	8b 04 85 14 a0 01 00 	mov    0x1a014(,%eax,4),%eax
    e03c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e040:	01 c8                	add    %ecx,%eax
    e042:	0f af 45 18          	imul   0x18(%ebp),%eax
    e046:	01 d0                	add    %edx,%eax
    e048:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    e04e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e055:	eb 30                	jmp    e087 <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    e057:	ff 75 0c             	pushl  0xc(%ebp)
    e05a:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    e060:	50                   	push   %eax
    e061:	e8 1e a1 ff ff       	call   8184 <readBitFromReversedStream>
    e066:	83 c4 08             	add    $0x8,%esp
    e069:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    e06c:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    e070:	50                   	push   %eax
    e071:	ff 75 08             	pushl  0x8(%ebp)
    e074:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    e07a:	50                   	push   %eax
    e07b:	e8 86 a1 ff ff       	call   8206 <setBitOfReversedStream>
    e080:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    e083:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    e087:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e08a:	3b 45 18             	cmp    0x18(%ebp),%eax
    e08d:	72 c8                	jb     e057 <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e08f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    e093:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e096:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e09a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e09d:	0f 87 3c ff ff ff    	ja     dfdf <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e0a3:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e0a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0aa:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e0ae:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e0b1:	0f 87 1c ff ff ff    	ja     dfd3 <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e0b7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e0bb:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e0bf:	0f 85 ea fe ff ff    	jne    dfaf <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e0c5:	90                   	nop
    e0c6:	c9                   	leave  
    e0c7:	c3                   	ret    

0000e0c8 <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    e0c8:	55                   	push   %ebp
    e0c9:	89 e5                	mov    %esp,%ebp
    e0cb:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    e0ce:	8b 45 14             	mov    0x14(%ebp),%eax
    e0d1:	2b 45 10             	sub    0x10(%ebp),%eax
    e0d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    e0d7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e0de:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    e0e5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e0ec:	eb 4a                	jmp    e138 <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e0ee:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e0f5:	eb 2a                	jmp    e121 <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    e0f7:	ff 75 0c             	pushl  0xc(%ebp)
    e0fa:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e0fd:	50                   	push   %eax
    e0fe:	e8 81 a0 ff ff       	call   8184 <readBitFromReversedStream>
    e103:	83 c4 08             	add    $0x8,%esp
    e106:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    e109:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e10d:	50                   	push   %eax
    e10e:	ff 75 08             	pushl  0x8(%ebp)
    e111:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e114:	50                   	push   %eax
    e115:	e8 ec a0 ff ff       	call   8206 <setBitOfReversedStream>
    e11a:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e11d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e121:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e124:	3b 45 10             	cmp    0x10(%ebp),%eax
    e127:	7c ce                	jl     e0f7 <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    e129:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e12c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e12f:	01 d0                	add    %edx,%eax
    e131:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    e134:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e138:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e13b:	3b 45 18             	cmp    0x18(%ebp),%eax
    e13e:	72 ae                	jb     e0ee <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    e140:	90                   	nop
    e141:	c9                   	leave  
    e142:	c3                   	ret    

0000e143 <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    e143:	55                   	push   %ebp
    e144:	89 e5                	mov    %esp,%ebp
    e146:	57                   	push   %edi
    e147:	56                   	push   %esi
    e148:	53                   	push   %ebx
    e149:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    e14f:	8b 45 18             	mov    0x18(%ebp),%eax
    e152:	83 c0 0c             	add    $0xc,%eax
    e155:	50                   	push   %eax
    e156:	e8 e6 ac ff ff       	call   8e41 <lodepng_get_bpp>
    e15b:	83 c4 04             	add    $0x4,%esp
    e15e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    e161:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e165:	75 0a                	jne    e171 <postProcessScanlines+0x2e>
    e167:	b8 1f 00 00 00       	mov    $0x1f,%eax
    e16c:	e9 c3 01 00 00       	jmp    e334 <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    e171:	8b 45 18             	mov    0x18(%ebp),%eax
    e174:	8b 40 08             	mov    0x8(%eax),%eax
    e177:	85 c0                	test   %eax,%eax
    e179:	0f 85 a8 00 00 00    	jne    e227 <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    e17f:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e183:	77 76                	ja     e1fb <postProcessScanlines+0xb8>
    e185:	8b 45 10             	mov    0x10(%ebp),%eax
    e188:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e18c:	89 c2                	mov    %eax,%edx
    e18e:	8b 45 10             	mov    0x10(%ebp),%eax
    e191:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e195:	83 c0 07             	add    $0x7,%eax
    e198:	c1 e8 03             	shr    $0x3,%eax
    e19b:	c1 e0 03             	shl    $0x3,%eax
    e19e:	39 c2                	cmp    %eax,%edx
    e1a0:	74 59                	je     e1fb <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    e1a2:	ff 75 ec             	pushl  -0x14(%ebp)
    e1a5:	ff 75 14             	pushl  0x14(%ebp)
    e1a8:	ff 75 10             	pushl  0x10(%ebp)
    e1ab:	ff 75 0c             	pushl  0xc(%ebp)
    e1ae:	ff 75 0c             	pushl  0xc(%ebp)
    e1b1:	e8 ea fb ff ff       	call   dda0 <unfilter>
    e1b6:	83 c4 14             	add    $0x14,%esp
    e1b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    e1bc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e1c0:	74 08                	je     e1ca <postProcessScanlines+0x87>
    e1c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e1c5:	e9 6a 01 00 00       	jmp    e334 <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    e1ca:	8b 45 10             	mov    0x10(%ebp),%eax
    e1cd:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e1d1:	83 c0 07             	add    $0x7,%eax
    e1d4:	c1 e8 03             	shr    $0x3,%eax
    e1d7:	c1 e0 03             	shl    $0x3,%eax
    e1da:	89 c2                	mov    %eax,%edx
    e1dc:	8b 45 10             	mov    0x10(%ebp),%eax
    e1df:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e1e3:	ff 75 14             	pushl  0x14(%ebp)
    e1e6:	52                   	push   %edx
    e1e7:	50                   	push   %eax
    e1e8:	ff 75 0c             	pushl  0xc(%ebp)
    e1eb:	ff 75 08             	pushl  0x8(%ebp)
    e1ee:	e8 d5 fe ff ff       	call   e0c8 <removePaddingBits>
    e1f3:	83 c4 14             	add    $0x14,%esp
    e1f6:	e9 34 01 00 00       	jmp    e32f <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    e1fb:	ff 75 ec             	pushl  -0x14(%ebp)
    e1fe:	ff 75 14             	pushl  0x14(%ebp)
    e201:	ff 75 10             	pushl  0x10(%ebp)
    e204:	ff 75 0c             	pushl  0xc(%ebp)
    e207:	ff 75 08             	pushl  0x8(%ebp)
    e20a:	e8 91 fb ff ff       	call   dda0 <unfilter>
    e20f:	83 c4 14             	add    $0x14,%esp
    e212:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e215:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e219:	0f 84 10 01 00 00    	je     e32f <postProcessScanlines+0x1ec>
    e21f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e222:	e9 0d 01 00 00       	jmp    e334 <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e227:	ff 75 ec             	pushl  -0x14(%ebp)
    e22a:	ff 75 14             	pushl  0x14(%ebp)
    e22d:	ff 75 10             	pushl  0x10(%ebp)
    e230:	8d 45 88             	lea    -0x78(%ebp),%eax
    e233:	50                   	push   %eax
    e234:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    e23a:	50                   	push   %eax
    e23b:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e241:	50                   	push   %eax
    e242:	8d 45 a8             	lea    -0x58(%ebp),%eax
    e245:	50                   	push   %eax
    e246:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e249:	50                   	push   %eax
    e24a:	e8 23 ee ff ff       	call   d072 <Adam7_getpassvalues>
    e24f:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    e252:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e259:	e9 b0 00 00 00       	jmp    e30e <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    e25e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e261:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    e265:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e268:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    e26c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e26f:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    e276:	89 cb                	mov    %ecx,%ebx
    e278:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e27b:	01 cb                	add    %ecx,%ebx
    e27d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e280:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    e287:	89 ce                	mov    %ecx,%esi
    e289:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e28c:	01 f1                	add    %esi,%ecx
    e28e:	ff 75 ec             	pushl  -0x14(%ebp)
    e291:	52                   	push   %edx
    e292:	50                   	push   %eax
    e293:	53                   	push   %ebx
    e294:	51                   	push   %ecx
    e295:	e8 06 fb ff ff       	call   dda0 <unfilter>
    e29a:	83 c4 14             	add    $0x14,%esp
    e29d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e2a0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e2a4:	74 08                	je     e2ae <postProcessScanlines+0x16b>
    e2a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e2a9:	e9 86 00 00 00       	jmp    e334 <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    e2ae:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e2b2:	77 56                	ja     e30a <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e2b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e2b7:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    e2bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2be:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e2c2:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e2c6:	83 c2 07             	add    $0x7,%edx
    e2c9:	c1 ea 03             	shr    $0x3,%edx
    e2cc:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e2cf:	89 d6                	mov    %edx,%esi
    e2d1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2d4:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e2d8:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e2dc:	89 d3                	mov    %edx,%ebx
    e2de:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2e1:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    e2e8:	89 d1                	mov    %edx,%ecx
    e2ea:	8b 55 0c             	mov    0xc(%ebp),%edx
    e2ed:	01 d1                	add    %edx,%ecx
    e2ef:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e2f2:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    e2f6:	89 d7                	mov    %edx,%edi
    e2f8:	8b 55 0c             	mov    0xc(%ebp),%edx
    e2fb:	01 fa                	add    %edi,%edx
    e2fd:	50                   	push   %eax
    e2fe:	56                   	push   %esi
    e2ff:	53                   	push   %ebx
    e300:	51                   	push   %ecx
    e301:	52                   	push   %edx
    e302:	e8 c1 fd ff ff       	call   e0c8 <removePaddingBits>
    e307:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    e30a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e30e:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    e312:	0f 85 46 ff ff ff    	jne    e25e <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    e318:	ff 75 ec             	pushl  -0x14(%ebp)
    e31b:	ff 75 14             	pushl  0x14(%ebp)
    e31e:	ff 75 10             	pushl  0x10(%ebp)
    e321:	ff 75 0c             	pushl  0xc(%ebp)
    e324:	ff 75 08             	pushl  0x8(%ebp)
    e327:	e8 2c fb ff ff       	call   de58 <Adam7_deinterlace>
    e32c:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    e32f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e334:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e337:	5b                   	pop    %ebx
    e338:	5e                   	pop    %esi
    e339:	5f                   	pop    %edi
    e33a:	5d                   	pop    %ebp
    e33b:	c3                   	ret    

0000e33c <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e33c:	55                   	push   %ebp
    e33d:	89 e5                	mov    %esp,%ebp
    e33f:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    e342:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    e349:	8b 45 10             	mov    0x10(%ebp),%eax
    e34c:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    e351:	f7 e2                	mul    %edx
    e353:	89 d0                	mov    %edx,%eax
    e355:	d1 e8                	shr    %eax
    e357:	89 c2                	mov    %eax,%edx
    e359:	8b 45 08             	mov    0x8(%ebp),%eax
    e35c:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    e35f:	8b 45 08             	mov    0x8(%ebp),%eax
    e362:	8b 40 0c             	mov    0xc(%eax),%eax
    e365:	85 c0                	test   %eax,%eax
    e367:	74 0d                	je     e376 <readChunk_PLTE+0x3a>
    e369:	8b 45 08             	mov    0x8(%ebp),%eax
    e36c:	8b 40 0c             	mov    0xc(%eax),%eax
    e36f:	3d 00 01 00 00       	cmp    $0x100,%eax
    e374:	7e 0a                	jle    e380 <readChunk_PLTE+0x44>
    e376:	b8 26 00 00 00       	mov    $0x26,%eax
    e37b:	e9 da 00 00 00       	jmp    e45a <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    e380:	83 ec 0c             	sub    $0xc,%esp
    e383:	ff 75 08             	pushl  0x8(%ebp)
    e386:	e8 02 a7 ff ff       	call   8a8d <lodepng_color_mode_alloc_palette>
    e38b:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    e38e:	8b 45 08             	mov    0x8(%ebp),%eax
    e391:	8b 40 08             	mov    0x8(%eax),%eax
    e394:	85 c0                	test   %eax,%eax
    e396:	75 1e                	jne    e3b6 <readChunk_PLTE+0x7a>
    e398:	8b 45 08             	mov    0x8(%ebp),%eax
    e39b:	8b 40 0c             	mov    0xc(%eax),%eax
    e39e:	85 c0                	test   %eax,%eax
    e3a0:	74 14                	je     e3b6 <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    e3a2:	8b 45 08             	mov    0x8(%ebp),%eax
    e3a5:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    e3ac:	b8 53 00 00 00       	mov    $0x53,%eax
    e3b1:	e9 a4 00 00 00       	jmp    e45a <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    e3b6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e3bd:	e9 84 00 00 00       	jmp    e446 <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    e3c2:	8b 45 08             	mov    0x8(%ebp),%eax
    e3c5:	8b 40 08             	mov    0x8(%eax),%eax
    e3c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e3cb:	c1 e2 02             	shl    $0x2,%edx
    e3ce:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e3d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3d4:	8d 50 01             	lea    0x1(%eax),%edx
    e3d7:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e3da:	8b 55 0c             	mov    0xc(%ebp),%edx
    e3dd:	01 d0                	add    %edx,%eax
    e3df:	0f b6 00             	movzbl (%eax),%eax
    e3e2:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    e3e4:	8b 45 08             	mov    0x8(%ebp),%eax
    e3e7:	8b 40 08             	mov    0x8(%eax),%eax
    e3ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e3ed:	c1 e2 02             	shl    $0x2,%edx
    e3f0:	83 c2 01             	add    $0x1,%edx
    e3f3:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e3f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3f9:	8d 50 01             	lea    0x1(%eax),%edx
    e3fc:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e3ff:	8b 55 0c             	mov    0xc(%ebp),%edx
    e402:	01 d0                	add    %edx,%eax
    e404:	0f b6 00             	movzbl (%eax),%eax
    e407:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    e409:	8b 45 08             	mov    0x8(%ebp),%eax
    e40c:	8b 40 08             	mov    0x8(%eax),%eax
    e40f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e412:	c1 e2 02             	shl    $0x2,%edx
    e415:	83 c2 02             	add    $0x2,%edx
    e418:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e41b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e41e:	8d 50 01             	lea    0x1(%eax),%edx
    e421:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e424:	8b 55 0c             	mov    0xc(%ebp),%edx
    e427:	01 d0                	add    %edx,%eax
    e429:	0f b6 00             	movzbl (%eax),%eax
    e42c:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    e42e:	8b 45 08             	mov    0x8(%ebp),%eax
    e431:	8b 40 08             	mov    0x8(%eax),%eax
    e434:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e437:	c1 e2 02             	shl    $0x2,%edx
    e43a:	83 c2 03             	add    $0x3,%edx
    e43d:	01 d0                	add    %edx,%eax
    e43f:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    e442:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e446:	8b 45 08             	mov    0x8(%ebp),%eax
    e449:	8b 40 0c             	mov    0xc(%eax),%eax
    e44c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e44f:	0f 85 6d ff ff ff    	jne    e3c2 <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    e455:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e45a:	c9                   	leave  
    e45b:	c3                   	ret    

0000e45c <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e45c:	55                   	push   %ebp
    e45d:	89 e5                	mov    %esp,%ebp
    e45f:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    e462:	8b 45 08             	mov    0x8(%ebp),%eax
    e465:	8b 00                	mov    (%eax),%eax
    e467:	83 f8 03             	cmp    $0x3,%eax
    e46a:	75 4d                	jne    e4b9 <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    e46c:	8b 45 08             	mov    0x8(%ebp),%eax
    e46f:	8b 40 0c             	mov    0xc(%eax),%eax
    e472:	3b 45 10             	cmp    0x10(%ebp),%eax
    e475:	7d 0a                	jge    e481 <readChunk_tRNS+0x25>
    e477:	b8 27 00 00 00       	mov    $0x27,%eax
    e47c:	e9 3c 01 00 00       	jmp    e5bd <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    e481:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e488:	eb 22                	jmp    e4ac <readChunk_tRNS+0x50>
    e48a:	8b 45 08             	mov    0x8(%ebp),%eax
    e48d:	8b 40 08             	mov    0x8(%eax),%eax
    e490:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e493:	c1 e2 02             	shl    $0x2,%edx
    e496:	83 c2 03             	add    $0x3,%edx
    e499:	01 c2                	add    %eax,%edx
    e49b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e49e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e4a1:	01 c8                	add    %ecx,%eax
    e4a3:	0f b6 00             	movzbl (%eax),%eax
    e4a6:	88 02                	mov    %al,(%edx)
    e4a8:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e4ac:	8b 45 10             	mov    0x10(%ebp),%eax
    e4af:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    e4b2:	75 d6                	jne    e48a <readChunk_tRNS+0x2e>
    e4b4:	e9 ff 00 00 00       	jmp    e5b8 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    e4b9:	8b 45 08             	mov    0x8(%ebp),%eax
    e4bc:	8b 00                	mov    (%eax),%eax
    e4be:	85 c0                	test   %eax,%eax
    e4c0:	75 59                	jne    e51b <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    e4c2:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e4c6:	74 0a                	je     e4d2 <readChunk_tRNS+0x76>
    e4c8:	b8 1e 00 00 00       	mov    $0x1e,%eax
    e4cd:	e9 eb 00 00 00       	jmp    e5bd <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e4d2:	8b 45 08             	mov    0x8(%ebp),%eax
    e4d5:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    e4dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    e4df:	0f b6 00             	movzbl (%eax),%eax
    e4e2:	0f b6 c0             	movzbl %al,%eax
    e4e5:	c1 e0 08             	shl    $0x8,%eax
    e4e8:	89 c2                	mov    %eax,%edx
    e4ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    e4ed:	83 c0 01             	add    $0x1,%eax
    e4f0:	0f b6 00             	movzbl (%eax),%eax
    e4f3:	0f b6 c0             	movzbl %al,%eax
    e4f6:	01 c2                	add    %eax,%edx
    e4f8:	8b 45 08             	mov    0x8(%ebp),%eax
    e4fb:	89 50 1c             	mov    %edx,0x1c(%eax)
    e4fe:	8b 45 08             	mov    0x8(%ebp),%eax
    e501:	8b 50 1c             	mov    0x1c(%eax),%edx
    e504:	8b 45 08             	mov    0x8(%ebp),%eax
    e507:	89 50 18             	mov    %edx,0x18(%eax)
    e50a:	8b 45 08             	mov    0x8(%ebp),%eax
    e50d:	8b 50 18             	mov    0x18(%eax),%edx
    e510:	8b 45 08             	mov    0x8(%ebp),%eax
    e513:	89 50 14             	mov    %edx,0x14(%eax)
    e516:	e9 9d 00 00 00       	jmp    e5b8 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    e51b:	8b 45 08             	mov    0x8(%ebp),%eax
    e51e:	8b 00                	mov    (%eax),%eax
    e520:	83 f8 02             	cmp    $0x2,%eax
    e523:	0f 85 88 00 00 00    	jne    e5b1 <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    e529:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e52d:	74 0a                	je     e539 <readChunk_tRNS+0xdd>
    e52f:	b8 29 00 00 00       	mov    $0x29,%eax
    e534:	e9 84 00 00 00       	jmp    e5bd <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e539:	8b 45 08             	mov    0x8(%ebp),%eax
    e53c:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    e543:	8b 45 0c             	mov    0xc(%ebp),%eax
    e546:	0f b6 00             	movzbl (%eax),%eax
    e549:	0f b6 c0             	movzbl %al,%eax
    e54c:	c1 e0 08             	shl    $0x8,%eax
    e54f:	89 c2                	mov    %eax,%edx
    e551:	8b 45 0c             	mov    0xc(%ebp),%eax
    e554:	83 c0 01             	add    $0x1,%eax
    e557:	0f b6 00             	movzbl (%eax),%eax
    e55a:	0f b6 c0             	movzbl %al,%eax
    e55d:	01 c2                	add    %eax,%edx
    e55f:	8b 45 08             	mov    0x8(%ebp),%eax
    e562:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    e565:	8b 45 0c             	mov    0xc(%ebp),%eax
    e568:	83 c0 02             	add    $0x2,%eax
    e56b:	0f b6 00             	movzbl (%eax),%eax
    e56e:	0f b6 c0             	movzbl %al,%eax
    e571:	c1 e0 08             	shl    $0x8,%eax
    e574:	89 c2                	mov    %eax,%edx
    e576:	8b 45 0c             	mov    0xc(%ebp),%eax
    e579:	83 c0 03             	add    $0x3,%eax
    e57c:	0f b6 00             	movzbl (%eax),%eax
    e57f:	0f b6 c0             	movzbl %al,%eax
    e582:	01 c2                	add    %eax,%edx
    e584:	8b 45 08             	mov    0x8(%ebp),%eax
    e587:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    e58a:	8b 45 0c             	mov    0xc(%ebp),%eax
    e58d:	83 c0 04             	add    $0x4,%eax
    e590:	0f b6 00             	movzbl (%eax),%eax
    e593:	0f b6 c0             	movzbl %al,%eax
    e596:	c1 e0 08             	shl    $0x8,%eax
    e599:	89 c2                	mov    %eax,%edx
    e59b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e59e:	83 c0 05             	add    $0x5,%eax
    e5a1:	0f b6 00             	movzbl (%eax),%eax
    e5a4:	0f b6 c0             	movzbl %al,%eax
    e5a7:	01 c2                	add    %eax,%edx
    e5a9:	8b 45 08             	mov    0x8(%ebp),%eax
    e5ac:	89 50 1c             	mov    %edx,0x1c(%eax)
    e5af:	eb 07                	jmp    e5b8 <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    e5b1:	b8 2a 00 00 00       	mov    $0x2a,%eax
    e5b6:	eb 05                	jmp    e5bd <readChunk_tRNS+0x161>

  return 0; /* OK */
    e5b8:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e5bd:	c9                   	leave  
    e5be:	c3                   	ret    

0000e5bf <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e5bf:	55                   	push   %ebp
    e5c0:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    e5c2:	8b 45 08             	mov    0x8(%ebp),%eax
    e5c5:	8b 40 0c             	mov    0xc(%eax),%eax
    e5c8:	83 f8 03             	cmp    $0x3,%eax
    e5cb:	75 63                	jne    e630 <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    e5cd:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    e5d1:	74 0a                	je     e5dd <readChunk_bKGD+0x1e>
    e5d3:	b8 2b 00 00 00       	mov    $0x2b,%eax
    e5d8:	e9 63 01 00 00       	jmp    e740 <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    e5dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    e5e0:	0f b6 00             	movzbl (%eax),%eax
    e5e3:	0f b6 d0             	movzbl %al,%edx
    e5e6:	8b 45 08             	mov    0x8(%ebp),%eax
    e5e9:	8b 40 18             	mov    0x18(%eax),%eax
    e5ec:	39 c2                	cmp    %eax,%edx
    e5ee:	7c 0a                	jl     e5fa <readChunk_bKGD+0x3b>
    e5f0:	b8 67 00 00 00       	mov    $0x67,%eax
    e5f5:	e9 46 01 00 00       	jmp    e740 <readChunk_bKGD+0x181>

    info->background_defined = 1;
    e5fa:	8b 45 08             	mov    0x8(%ebp),%eax
    e5fd:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    e604:	8b 45 0c             	mov    0xc(%ebp),%eax
    e607:	0f b6 00             	movzbl (%eax),%eax
    e60a:	0f b6 d0             	movzbl %al,%edx
    e60d:	8b 45 08             	mov    0x8(%ebp),%eax
    e610:	89 50 38             	mov    %edx,0x38(%eax)
    e613:	8b 45 08             	mov    0x8(%ebp),%eax
    e616:	8b 50 38             	mov    0x38(%eax),%edx
    e619:	8b 45 08             	mov    0x8(%ebp),%eax
    e61c:	89 50 34             	mov    %edx,0x34(%eax)
    e61f:	8b 45 08             	mov    0x8(%ebp),%eax
    e622:	8b 50 34             	mov    0x34(%eax),%edx
    e625:	8b 45 08             	mov    0x8(%ebp),%eax
    e628:	89 50 30             	mov    %edx,0x30(%eax)
    e62b:	e9 0b 01 00 00       	jmp    e73b <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    e630:	8b 45 08             	mov    0x8(%ebp),%eax
    e633:	8b 40 0c             	mov    0xc(%eax),%eax
    e636:	85 c0                	test   %eax,%eax
    e638:	74 0b                	je     e645 <readChunk_bKGD+0x86>
    e63a:	8b 45 08             	mov    0x8(%ebp),%eax
    e63d:	8b 40 0c             	mov    0xc(%eax),%eax
    e640:	83 f8 04             	cmp    $0x4,%eax
    e643:	75 59                	jne    e69e <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    e645:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e649:	74 0a                	je     e655 <readChunk_bKGD+0x96>
    e64b:	b8 2c 00 00 00       	mov    $0x2c,%eax
    e650:	e9 eb 00 00 00       	jmp    e740 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e655:	8b 45 08             	mov    0x8(%ebp),%eax
    e658:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    e65f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e662:	0f b6 00             	movzbl (%eax),%eax
    e665:	0f b6 c0             	movzbl %al,%eax
    e668:	c1 e0 08             	shl    $0x8,%eax
    e66b:	89 c2                	mov    %eax,%edx
    e66d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e670:	83 c0 01             	add    $0x1,%eax
    e673:	0f b6 00             	movzbl (%eax),%eax
    e676:	0f b6 c0             	movzbl %al,%eax
    e679:	01 c2                	add    %eax,%edx
    e67b:	8b 45 08             	mov    0x8(%ebp),%eax
    e67e:	89 50 38             	mov    %edx,0x38(%eax)
    e681:	8b 45 08             	mov    0x8(%ebp),%eax
    e684:	8b 50 38             	mov    0x38(%eax),%edx
    e687:	8b 45 08             	mov    0x8(%ebp),%eax
    e68a:	89 50 34             	mov    %edx,0x34(%eax)
    e68d:	8b 45 08             	mov    0x8(%ebp),%eax
    e690:	8b 50 34             	mov    0x34(%eax),%edx
    e693:	8b 45 08             	mov    0x8(%ebp),%eax
    e696:	89 50 30             	mov    %edx,0x30(%eax)
    e699:	e9 9d 00 00 00       	jmp    e73b <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    e69e:	8b 45 08             	mov    0x8(%ebp),%eax
    e6a1:	8b 40 0c             	mov    0xc(%eax),%eax
    e6a4:	83 f8 02             	cmp    $0x2,%eax
    e6a7:	74 0f                	je     e6b8 <readChunk_bKGD+0xf9>
    e6a9:	8b 45 08             	mov    0x8(%ebp),%eax
    e6ac:	8b 40 0c             	mov    0xc(%eax),%eax
    e6af:	83 f8 06             	cmp    $0x6,%eax
    e6b2:	0f 85 83 00 00 00    	jne    e73b <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    e6b8:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e6bc:	74 07                	je     e6c5 <readChunk_bKGD+0x106>
    e6be:	b8 2d 00 00 00       	mov    $0x2d,%eax
    e6c3:	eb 7b                	jmp    e740 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e6c5:	8b 45 08             	mov    0x8(%ebp),%eax
    e6c8:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    e6cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6d2:	0f b6 00             	movzbl (%eax),%eax
    e6d5:	0f b6 c0             	movzbl %al,%eax
    e6d8:	c1 e0 08             	shl    $0x8,%eax
    e6db:	89 c2                	mov    %eax,%edx
    e6dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6e0:	83 c0 01             	add    $0x1,%eax
    e6e3:	0f b6 00             	movzbl (%eax),%eax
    e6e6:	0f b6 c0             	movzbl %al,%eax
    e6e9:	01 c2                	add    %eax,%edx
    e6eb:	8b 45 08             	mov    0x8(%ebp),%eax
    e6ee:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    e6f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6f4:	83 c0 02             	add    $0x2,%eax
    e6f7:	0f b6 00             	movzbl (%eax),%eax
    e6fa:	0f b6 c0             	movzbl %al,%eax
    e6fd:	c1 e0 08             	shl    $0x8,%eax
    e700:	89 c2                	mov    %eax,%edx
    e702:	8b 45 0c             	mov    0xc(%ebp),%eax
    e705:	83 c0 03             	add    $0x3,%eax
    e708:	0f b6 00             	movzbl (%eax),%eax
    e70b:	0f b6 c0             	movzbl %al,%eax
    e70e:	01 c2                	add    %eax,%edx
    e710:	8b 45 08             	mov    0x8(%ebp),%eax
    e713:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    e716:	8b 45 0c             	mov    0xc(%ebp),%eax
    e719:	83 c0 04             	add    $0x4,%eax
    e71c:	0f b6 00             	movzbl (%eax),%eax
    e71f:	0f b6 c0             	movzbl %al,%eax
    e722:	c1 e0 08             	shl    $0x8,%eax
    e725:	89 c2                	mov    %eax,%edx
    e727:	8b 45 0c             	mov    0xc(%ebp),%eax
    e72a:	83 c0 05             	add    $0x5,%eax
    e72d:	0f b6 00             	movzbl (%eax),%eax
    e730:	0f b6 c0             	movzbl %al,%eax
    e733:	01 c2                	add    %eax,%edx
    e735:	8b 45 08             	mov    0x8(%ebp),%eax
    e738:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    e73b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e740:	5d                   	pop    %ebp
    e741:	c3                   	ret    

0000e742 <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e742:	55                   	push   %ebp
    e743:	89 e5                	mov    %esp,%ebp
    e745:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    e748:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    e74f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e756:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e75d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e761:	0f 85 06 01 00 00    	jne    e86d <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    e767:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    e76e:	eb 04                	jmp    e774 <readChunk_tEXt+0x32>
    e770:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e774:	8b 45 10             	mov    0x10(%ebp),%eax
    e777:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e77a:	73 0f                	jae    e78b <readChunk_tEXt+0x49>
    e77c:	8b 55 0c             	mov    0xc(%ebp),%edx
    e77f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e782:	01 d0                	add    %edx,%eax
    e784:	0f b6 00             	movzbl (%eax),%eax
    e787:	84 c0                	test   %al,%al
    e789:	75 e5                	jne    e770 <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e78b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e78f:	74 06                	je     e797 <readChunk_tEXt+0x55>
    e791:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    e795:	76 0c                	jbe    e7a3 <readChunk_tEXt+0x61>
    e797:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e79e:	e9 ca 00 00 00       	jmp    e86d <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    e7a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7a6:	83 c0 01             	add    $0x1,%eax
    e7a9:	83 ec 0c             	sub    $0xc,%esp
    e7ac:	50                   	push   %eax
    e7ad:	e8 73 4b ff ff       	call   3325 <lodepng_malloc>
    e7b2:	83 c4 10             	add    $0x10,%esp
    e7b5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e7b8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e7bc:	75 0c                	jne    e7ca <readChunk_tEXt+0x88>
    e7be:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e7c5:	e9 a3 00 00 00       	jmp    e86d <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    e7ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7cd:	83 ec 04             	sub    $0x4,%esp
    e7d0:	50                   	push   %eax
    e7d1:	ff 75 0c             	pushl  0xc(%ebp)
    e7d4:	ff 75 f0             	pushl  -0x10(%ebp)
    e7d7:	e8 87 4b ff ff       	call   3363 <lodepng_memcpy>
    e7dc:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e7df:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e7e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7e5:	01 d0                	add    %edx,%eax
    e7e7:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    e7ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e7ed:	83 c0 01             	add    $0x1,%eax
    e7f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    e7f3:	8b 45 10             	mov    0x10(%ebp),%eax
    e7f6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    e7f9:	72 08                	jb     e803 <readChunk_tEXt+0xc1>
    e7fb:	8b 45 10             	mov    0x10(%ebp),%eax
    e7fe:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    e801:	eb 05                	jmp    e808 <readChunk_tEXt+0xc6>
    e803:	b8 00 00 00 00       	mov    $0x0,%eax
    e808:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    e80b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e80e:	83 c0 01             	add    $0x1,%eax
    e811:	83 ec 0c             	sub    $0xc,%esp
    e814:	50                   	push   %eax
    e815:	e8 0b 4b ff ff       	call   3325 <lodepng_malloc>
    e81a:	83 c4 10             	add    $0x10,%esp
    e81d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    e820:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e824:	75 09                	jne    e82f <readChunk_tEXt+0xed>
    e826:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e82d:	eb 3e                	jmp    e86d <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    e82f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e832:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e835:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e838:	01 ca                	add    %ecx,%edx
    e83a:	83 ec 04             	sub    $0x4,%esp
    e83d:	50                   	push   %eax
    e83e:	52                   	push   %edx
    e83f:	ff 75 ec             	pushl  -0x14(%ebp)
    e842:	e8 1c 4b ff ff       	call   3363 <lodepng_memcpy>
    e847:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    e84a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e84d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e850:	01 d0                	add    %edx,%eax
    e852:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    e855:	83 ec 04             	sub    $0x4,%esp
    e858:	ff 75 ec             	pushl  -0x14(%ebp)
    e85b:	ff 75 f0             	pushl  -0x10(%ebp)
    e85e:	ff 75 08             	pushl  0x8(%ebp)
    e861:	e8 3f ac ff ff       	call   94a5 <lodepng_add_text>
    e866:	83 c4 10             	add    $0x10,%esp
    e869:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    e86c:	90                   	nop
  }

  lodepng_free(key);
    e86d:	83 ec 0c             	sub    $0xc,%esp
    e870:	ff 75 f0             	pushl  -0x10(%ebp)
    e873:	e8 ce 4a ff ff       	call   3346 <lodepng_free>
    e878:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    e87b:	83 ec 0c             	sub    $0xc,%esp
    e87e:	ff 75 ec             	pushl  -0x14(%ebp)
    e881:	e8 c0 4a ff ff       	call   3346 <lodepng_free>
    e886:	83 c4 10             	add    $0x10,%esp

  return error;
    e889:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e88c:	c9                   	leave  
    e88d:	c3                   	ret    

0000e88e <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    e88e:	55                   	push   %ebp
    e88f:	89 e5                	mov    %esp,%ebp
    e891:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    e894:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    e89b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e89e:	8b 10                	mov    (%eax),%edx
    e8a0:	89 55 d0             	mov    %edx,-0x30(%ebp)
    e8a3:	8b 50 04             	mov    0x4(%eax),%edx
    e8a6:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    e8a9:	8b 50 08             	mov    0x8(%eax),%edx
    e8ac:	89 55 d8             	mov    %edx,-0x28(%ebp)
    e8af:	8b 50 0c             	mov    0xc(%eax),%edx
    e8b2:	89 55 dc             	mov    %edx,-0x24(%ebp)
    e8b5:	8b 50 10             	mov    0x10(%eax),%edx
    e8b8:	89 55 e0             	mov    %edx,-0x20(%ebp)
    e8bb:	8b 40 14             	mov    0x14(%eax),%eax
    e8be:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    e8c1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    e8c8:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    e8cf:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e8d6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e8da:	0f 85 48 01 00 00    	jne    ea28 <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    e8e0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e8e7:	eb 04                	jmp    e8ed <readChunk_zTXt+0x5f>
    e8e9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e8ed:	8b 45 14             	mov    0x14(%ebp),%eax
    e8f0:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e8f3:	73 0f                	jae    e904 <readChunk_zTXt+0x76>
    e8f5:	8b 55 10             	mov    0x10(%ebp),%edx
    e8f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e8fb:	01 d0                	add    %edx,%eax
    e8fd:	0f b6 00             	movzbl (%eax),%eax
    e900:	84 c0                	test   %al,%al
    e902:	75 e5                	jne    e8e9 <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    e904:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e907:	8d 50 02             	lea    0x2(%eax),%edx
    e90a:	8b 45 14             	mov    0x14(%ebp),%eax
    e90d:	39 c2                	cmp    %eax,%edx
    e90f:	72 0c                	jb     e91d <readChunk_zTXt+0x8f>
    e911:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    e918:	e9 0b 01 00 00       	jmp    ea28 <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e91d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e921:	74 06                	je     e929 <readChunk_zTXt+0x9b>
    e923:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    e927:	76 0c                	jbe    e935 <readChunk_zTXt+0xa7>
    e929:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e930:	e9 f3 00 00 00       	jmp    ea28 <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    e935:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e938:	83 c0 01             	add    $0x1,%eax
    e93b:	83 ec 0c             	sub    $0xc,%esp
    e93e:	50                   	push   %eax
    e93f:	e8 e1 49 ff ff       	call   3325 <lodepng_malloc>
    e944:	83 c4 10             	add    $0x10,%esp
    e947:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e94a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e94e:	75 0c                	jne    e95c <readChunk_zTXt+0xce>
    e950:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e957:	e9 cc 00 00 00       	jmp    ea28 <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    e95c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e95f:	83 ec 04             	sub    $0x4,%esp
    e962:	50                   	push   %eax
    e963:	ff 75 10             	pushl  0x10(%ebp)
    e966:	ff 75 ec             	pushl  -0x14(%ebp)
    e969:	e8 f5 49 ff ff       	call   3363 <lodepng_memcpy>
    e96e:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e971:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e974:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e977:	01 d0                	add    %edx,%eax
    e979:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    e97c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e97f:	8d 50 01             	lea    0x1(%eax),%edx
    e982:	8b 45 10             	mov    0x10(%ebp),%eax
    e985:	01 d0                	add    %edx,%eax
    e987:	0f b6 00             	movzbl (%eax),%eax
    e98a:	84 c0                	test   %al,%al
    e98c:	74 0c                	je     e99a <readChunk_zTXt+0x10c>
    e98e:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    e995:	e9 8e 00 00 00       	jmp    ea28 <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    e99a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e99d:	83 c0 02             	add    $0x2,%eax
    e9a0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    e9a3:	8b 45 14             	mov    0x14(%ebp),%eax
    e9a6:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e9a9:	76 09                	jbe    e9b4 <readChunk_zTXt+0x126>
    e9ab:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    e9b2:	eb 74                	jmp    ea28 <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    e9b4:	8b 45 14             	mov    0x14(%ebp),%eax
    e9b7:	2b 45 e8             	sub    -0x18(%ebp),%eax
    e9ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    e9bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9c0:	8b 40 30             	mov    0x30(%eax),%eax
    e9c3:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    e9c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e9c9:	8b 4d 10             	mov    0x10(%ebp),%ecx
    e9cc:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e9cf:	01 d1                	add    %edx,%ecx
    e9d1:	83 ec 08             	sub    $0x8,%esp
    e9d4:	8d 55 d0             	lea    -0x30(%ebp),%edx
    e9d7:	52                   	push   %edx
    e9d8:	50                   	push   %eax
    e9d9:	51                   	push   %ecx
    e9da:	6a 00                	push   $0x0
    e9dc:	8d 45 c8             	lea    -0x38(%ebp),%eax
    e9df:	50                   	push   %eax
    e9e0:	8d 45 cc             	lea    -0x34(%ebp),%eax
    e9e3:	50                   	push   %eax
    e9e4:	e8 f7 93 ff ff       	call   7de0 <zlib_decompress>
    e9e9:	83 c4 20             	add    $0x20,%esp
    e9ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    e9ef:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e9f3:	74 11                	je     ea06 <readChunk_zTXt+0x178>
    e9f5:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e9f8:	8b 45 c8             	mov    -0x38(%ebp),%eax
    e9fb:	39 c2                	cmp    %eax,%edx
    e9fd:	7d 07                	jge    ea06 <readChunk_zTXt+0x178>
    e9ff:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    ea06:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ea0a:	75 1b                	jne    ea27 <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    ea0c:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ea0f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ea12:	52                   	push   %edx
    ea13:	50                   	push   %eax
    ea14:	ff 75 ec             	pushl  -0x14(%ebp)
    ea17:	ff 75 08             	pushl  0x8(%ebp)
    ea1a:	e8 60 a9 ff ff       	call   937f <lodepng_add_text_sized>
    ea1f:	83 c4 10             	add    $0x10,%esp
    ea22:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    ea25:	eb 01                	jmp    ea28 <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    ea27:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    ea28:	83 ec 0c             	sub    $0xc,%esp
    ea2b:	ff 75 ec             	pushl  -0x14(%ebp)
    ea2e:	e8 13 49 ff ff       	call   3346 <lodepng_free>
    ea33:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    ea36:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ea39:	83 ec 0c             	sub    $0xc,%esp
    ea3c:	50                   	push   %eax
    ea3d:	e8 04 49 ff ff       	call   3346 <lodepng_free>
    ea42:	83 c4 10             	add    $0x10,%esp

  return error;
    ea45:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ea48:	c9                   	leave  
    ea49:	c3                   	ret    

0000ea4a <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    ea4a:	55                   	push   %ebp
    ea4b:	89 e5                	mov    %esp,%ebp
    ea4d:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    ea50:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    ea57:	8b 45 0c             	mov    0xc(%ebp),%eax
    ea5a:	8b 10                	mov    (%eax),%edx
    ea5c:	89 55 c0             	mov    %edx,-0x40(%ebp)
    ea5f:	8b 50 04             	mov    0x4(%eax),%edx
    ea62:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    ea65:	8b 50 08             	mov    0x8(%eax),%edx
    ea68:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ea6b:	8b 50 0c             	mov    0xc(%eax),%edx
    ea6e:	89 55 cc             	mov    %edx,-0x34(%ebp)
    ea71:	8b 50 10             	mov    0x10(%eax),%edx
    ea74:	89 55 d0             	mov    %edx,-0x30(%ebp)
    ea77:	8b 40 14             	mov    0x14(%eax),%eax
    ea7a:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    ea7d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ea84:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    ea8b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ea92:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ea96:	0f 85 d5 02 00 00    	jne    ed71 <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    ea9c:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    eaa0:	7f 0c                	jg     eaae <readChunk_iTXt+0x64>
    eaa2:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    eaa9:	e9 c3 02 00 00       	jmp    ed71 <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    eaae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    eab5:	eb 04                	jmp    eabb <readChunk_iTXt+0x71>
    eab7:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    eabb:	8b 45 14             	mov    0x14(%ebp),%eax
    eabe:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    eac1:	73 0f                	jae    ead2 <readChunk_iTXt+0x88>
    eac3:	8b 55 10             	mov    0x10(%ebp),%edx
    eac6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eac9:	01 d0                	add    %edx,%eax
    eacb:	0f b6 00             	movzbl (%eax),%eax
    eace:	84 c0                	test   %al,%al
    ead0:	75 e5                	jne    eab7 <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    ead2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ead5:	8d 50 03             	lea    0x3(%eax),%edx
    ead8:	8b 45 14             	mov    0x14(%ebp),%eax
    eadb:	39 c2                	cmp    %eax,%edx
    eadd:	72 0c                	jb     eaeb <readChunk_iTXt+0xa1>
    eadf:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    eae6:	e9 86 02 00 00       	jmp    ed71 <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    eaeb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    eaef:	74 06                	je     eaf7 <readChunk_iTXt+0xad>
    eaf1:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    eaf5:	76 0c                	jbe    eb03 <readChunk_iTXt+0xb9>
    eaf7:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    eafe:	e9 6e 02 00 00       	jmp    ed71 <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    eb03:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb06:	83 c0 01             	add    $0x1,%eax
    eb09:	83 ec 0c             	sub    $0xc,%esp
    eb0c:	50                   	push   %eax
    eb0d:	e8 13 48 ff ff       	call   3325 <lodepng_malloc>
    eb12:	83 c4 10             	add    $0x10,%esp
    eb15:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    eb18:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    eb1c:	75 0c                	jne    eb2a <readChunk_iTXt+0xe0>
    eb1e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eb25:	e9 47 02 00 00       	jmp    ed71 <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    eb2a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb2d:	83 ec 04             	sub    $0x4,%esp
    eb30:	50                   	push   %eax
    eb31:	ff 75 10             	pushl  0x10(%ebp)
    eb34:	ff 75 e8             	pushl  -0x18(%ebp)
    eb37:	e8 27 48 ff ff       	call   3363 <lodepng_memcpy>
    eb3c:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    eb3f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    eb42:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb45:	01 d0                	add    %edx,%eax
    eb47:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    eb4a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb4d:	8d 50 01             	lea    0x1(%eax),%edx
    eb50:	8b 45 10             	mov    0x10(%ebp),%eax
    eb53:	01 d0                	add    %edx,%eax
    eb55:	0f b6 00             	movzbl (%eax),%eax
    eb58:	0f b6 c0             	movzbl %al,%eax
    eb5b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    eb5e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb61:	8d 50 02             	lea    0x2(%eax),%edx
    eb64:	8b 45 10             	mov    0x10(%ebp),%eax
    eb67:	01 d0                	add    %edx,%eax
    eb69:	0f b6 00             	movzbl (%eax),%eax
    eb6c:	84 c0                	test   %al,%al
    eb6e:	74 0c                	je     eb7c <readChunk_iTXt+0x132>
    eb70:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    eb77:	e9 f5 01 00 00       	jmp    ed71 <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    eb7c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eb7f:	83 c0 03             	add    $0x3,%eax
    eb82:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    eb85:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    eb8c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    eb8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    eb92:	eb 08                	jmp    eb9c <readChunk_iTXt+0x152>
    eb94:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    eb98:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    eb9c:	8b 45 14             	mov    0x14(%ebp),%eax
    eb9f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    eba2:	73 0f                	jae    ebb3 <readChunk_iTXt+0x169>
    eba4:	8b 55 10             	mov    0x10(%ebp),%edx
    eba7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ebaa:	01 d0                	add    %edx,%eax
    ebac:	0f b6 00             	movzbl (%eax),%eax
    ebaf:	84 c0                	test   %al,%al
    ebb1:	75 e1                	jne    eb94 <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    ebb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebb6:	83 c0 01             	add    $0x1,%eax
    ebb9:	83 ec 0c             	sub    $0xc,%esp
    ebbc:	50                   	push   %eax
    ebbd:	e8 63 47 ff ff       	call   3325 <lodepng_malloc>
    ebc2:	83 c4 10             	add    $0x10,%esp
    ebc5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    ebc8:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ebcc:	75 0c                	jne    ebda <readChunk_iTXt+0x190>
    ebce:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ebd5:	e9 97 01 00 00       	jmp    ed71 <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    ebda:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebdd:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ebe0:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ebe3:	01 ca                	add    %ecx,%edx
    ebe5:	83 ec 04             	sub    $0x4,%esp
    ebe8:	50                   	push   %eax
    ebe9:	52                   	push   %edx
    ebea:	ff 75 e4             	pushl  -0x1c(%ebp)
    ebed:	e8 71 47 ff ff       	call   3363 <lodepng_memcpy>
    ebf2:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    ebf5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ebf8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ebfb:	01 d0                	add    %edx,%eax
    ebfd:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    ec00:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ec03:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec06:	01 d0                	add    %edx,%eax
    ec08:	83 c0 01             	add    $0x1,%eax
    ec0b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ec0e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ec15:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec18:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ec1b:	eb 08                	jmp    ec25 <readChunk_iTXt+0x1db>
    ec1d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ec21:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ec25:	8b 45 14             	mov    0x14(%ebp),%eax
    ec28:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ec2b:	73 0f                	jae    ec3c <readChunk_iTXt+0x1f2>
    ec2d:	8b 55 10             	mov    0x10(%ebp),%edx
    ec30:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec33:	01 d0                	add    %edx,%eax
    ec35:	0f b6 00             	movzbl (%eax),%eax
    ec38:	84 c0                	test   %al,%al
    ec3a:	75 e1                	jne    ec1d <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    ec3c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec3f:	83 c0 01             	add    $0x1,%eax
    ec42:	83 ec 0c             	sub    $0xc,%esp
    ec45:	50                   	push   %eax
    ec46:	e8 da 46 ff ff       	call   3325 <lodepng_malloc>
    ec4b:	83 c4 10             	add    $0x10,%esp
    ec4e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    ec51:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ec55:	75 0c                	jne    ec63 <readChunk_iTXt+0x219>
    ec57:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ec5e:	e9 0e 01 00 00       	jmp    ed71 <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    ec63:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec66:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ec69:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ec6c:	01 ca                	add    %ecx,%edx
    ec6e:	83 ec 04             	sub    $0x4,%esp
    ec71:	50                   	push   %eax
    ec72:	52                   	push   %edx
    ec73:	ff 75 e0             	pushl  -0x20(%ebp)
    ec76:	e8 e8 46 ff ff       	call   3363 <lodepng_memcpy>
    ec7b:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    ec7e:	8b 55 e0             	mov    -0x20(%ebp),%edx
    ec81:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec84:	01 d0                	add    %edx,%eax
    ec86:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    ec89:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ec8c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ec8f:	01 d0                	add    %edx,%eax
    ec91:	83 c0 01             	add    $0x1,%eax
    ec94:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    ec97:	8b 45 14             	mov    0x14(%ebp),%eax
    ec9a:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ec9d:	72 08                	jb     eca7 <readChunk_iTXt+0x25d>
    ec9f:	8b 45 14             	mov    0x14(%ebp),%eax
    eca2:	2b 45 d8             	sub    -0x28(%ebp),%eax
    eca5:	eb 05                	jmp    ecac <readChunk_iTXt+0x262>
    eca7:	b8 00 00 00 00       	mov    $0x0,%eax
    ecac:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    ecaf:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    ecb3:	0f 84 90 00 00 00    	je     ed49 <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    ecb9:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    ecc0:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    ecc7:	8b 45 0c             	mov    0xc(%ebp),%eax
    ecca:	8b 40 30             	mov    0x30(%eax),%eax
    eccd:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    ecd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ecd3:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ecd6:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ecd9:	01 d1                	add    %edx,%ecx
    ecdb:	83 ec 08             	sub    $0x8,%esp
    ecde:	8d 55 c0             	lea    -0x40(%ebp),%edx
    ece1:	52                   	push   %edx
    ece2:	50                   	push   %eax
    ece3:	51                   	push   %ecx
    ece4:	6a 00                	push   $0x0
    ece6:	8d 45 b8             	lea    -0x48(%ebp),%eax
    ece9:	50                   	push   %eax
    ecea:	8d 45 bc             	lea    -0x44(%ebp),%eax
    eced:	50                   	push   %eax
    ecee:	e8 ed 90 ff ff       	call   7de0 <zlib_decompress>
    ecf3:	83 c4 20             	add    $0x20,%esp
    ecf6:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    ecf9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ecfd:	74 11                	je     ed10 <readChunk_iTXt+0x2c6>
    ecff:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ed02:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ed05:	39 c2                	cmp    %eax,%edx
    ed07:	7d 07                	jge    ed10 <readChunk_iTXt+0x2c6>
    ed09:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    ed10:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ed14:	75 22                	jne    ed38 <readChunk_iTXt+0x2ee>
    ed16:	8b 55 b8             	mov    -0x48(%ebp),%edx
    ed19:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ed1c:	83 ec 08             	sub    $0x8,%esp
    ed1f:	52                   	push   %edx
    ed20:	50                   	push   %eax
    ed21:	ff 75 e0             	pushl  -0x20(%ebp)
    ed24:	ff 75 e4             	pushl  -0x1c(%ebp)
    ed27:	ff 75 e8             	pushl  -0x18(%ebp)
    ed2a:	ff 75 08             	pushl  0x8(%ebp)
    ed2d:	e8 94 a9 ff ff       	call   96c6 <lodepng_add_itext_sized>
    ed32:	83 c4 20             	add    $0x20,%esp
    ed35:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    ed38:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ed3b:	83 ec 0c             	sub    $0xc,%esp
    ed3e:	50                   	push   %eax
    ed3f:	e8 02 46 ff ff       	call   3346 <lodepng_free>
    ed44:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    ed47:	eb 27                	jmp    ed70 <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    ed49:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed4c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ed4f:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ed52:	01 ca                	add    %ecx,%edx
    ed54:	83 ec 08             	sub    $0x8,%esp
    ed57:	50                   	push   %eax
    ed58:	52                   	push   %edx
    ed59:	ff 75 e0             	pushl  -0x20(%ebp)
    ed5c:	ff 75 e4             	pushl  -0x1c(%ebp)
    ed5f:	ff 75 e8             	pushl  -0x18(%ebp)
    ed62:	ff 75 08             	pushl  0x8(%ebp)
    ed65:	e8 5c a9 ff ff       	call   96c6 <lodepng_add_itext_sized>
    ed6a:	83 c4 20             	add    $0x20,%esp
    ed6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    ed70:	90                   	nop
  }

  lodepng_free(key);
    ed71:	83 ec 0c             	sub    $0xc,%esp
    ed74:	ff 75 e8             	pushl  -0x18(%ebp)
    ed77:	e8 ca 45 ff ff       	call   3346 <lodepng_free>
    ed7c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    ed7f:	83 ec 0c             	sub    $0xc,%esp
    ed82:	ff 75 e4             	pushl  -0x1c(%ebp)
    ed85:	e8 bc 45 ff ff       	call   3346 <lodepng_free>
    ed8a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    ed8d:	83 ec 0c             	sub    $0xc,%esp
    ed90:	ff 75 e0             	pushl  -0x20(%ebp)
    ed93:	e8 ae 45 ff ff       	call   3346 <lodepng_free>
    ed98:	83 c4 10             	add    $0x10,%esp

  return error;
    ed9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ed9e:	c9                   	leave  
    ed9f:	c3                   	ret    

0000eda0 <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    eda0:	55                   	push   %ebp
    eda1:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    eda3:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    eda7:	74 0a                	je     edb3 <readChunk_tIME+0x13>
    eda9:	b8 49 00 00 00       	mov    $0x49,%eax
    edae:	e9 8b 00 00 00       	jmp    ee3e <readChunk_tIME+0x9e>

  info->time_defined = 1;
    edb3:	8b 45 08             	mov    0x8(%ebp),%eax
    edb6:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    edbd:	8b 45 0c             	mov    0xc(%ebp),%eax
    edc0:	0f b6 00             	movzbl (%eax),%eax
    edc3:	0f b6 c0             	movzbl %al,%eax
    edc6:	c1 e0 08             	shl    $0x8,%eax
    edc9:	89 c2                	mov    %eax,%edx
    edcb:	8b 45 0c             	mov    0xc(%ebp),%eax
    edce:	83 c0 01             	add    $0x1,%eax
    edd1:	0f b6 00             	movzbl (%eax),%eax
    edd4:	0f b6 c0             	movzbl %al,%eax
    edd7:	01 c2                	add    %eax,%edx
    edd9:	8b 45 08             	mov    0x8(%ebp),%eax
    eddc:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    eddf:	8b 45 0c             	mov    0xc(%ebp),%eax
    ede2:	83 c0 02             	add    $0x2,%eax
    ede5:	0f b6 00             	movzbl (%eax),%eax
    ede8:	0f b6 d0             	movzbl %al,%edx
    edeb:	8b 45 08             	mov    0x8(%ebp),%eax
    edee:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    edf1:	8b 45 0c             	mov    0xc(%ebp),%eax
    edf4:	83 c0 03             	add    $0x3,%eax
    edf7:	0f b6 00             	movzbl (%eax),%eax
    edfa:	0f b6 d0             	movzbl %al,%edx
    edfd:	8b 45 08             	mov    0x8(%ebp),%eax
    ee00:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    ee03:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee06:	83 c0 04             	add    $0x4,%eax
    ee09:	0f b6 00             	movzbl (%eax),%eax
    ee0c:	0f b6 d0             	movzbl %al,%edx
    ee0f:	8b 45 08             	mov    0x8(%ebp),%eax
    ee12:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    ee15:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee18:	83 c0 05             	add    $0x5,%eax
    ee1b:	0f b6 00             	movzbl (%eax),%eax
    ee1e:	0f b6 d0             	movzbl %al,%edx
    ee21:	8b 45 08             	mov    0x8(%ebp),%eax
    ee24:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    ee27:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee2a:	83 c0 06             	add    $0x6,%eax
    ee2d:	0f b6 00             	movzbl (%eax),%eax
    ee30:	0f b6 d0             	movzbl %al,%edx
    ee33:	8b 45 08             	mov    0x8(%ebp),%eax
    ee36:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    ee39:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ee3e:	5d                   	pop    %ebp
    ee3f:	c3                   	ret    

0000ee40 <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ee40:	55                   	push   %ebp
    ee41:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    ee43:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    ee47:	74 0a                	je     ee53 <readChunk_pHYs+0x13>
    ee49:	b8 4a 00 00 00       	mov    $0x4a,%eax
    ee4e:	e9 ba 00 00 00       	jmp    ef0d <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    ee53:	8b 45 08             	mov    0x8(%ebp),%eax
    ee56:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    ee5d:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee60:	0f b6 00             	movzbl (%eax),%eax
    ee63:	0f b6 c0             	movzbl %al,%eax
    ee66:	c1 e0 08             	shl    $0x8,%eax
    ee69:	89 c2                	mov    %eax,%edx
    ee6b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee6e:	83 c0 01             	add    $0x1,%eax
    ee71:	0f b6 00             	movzbl (%eax),%eax
    ee74:	0f b6 c0             	movzbl %al,%eax
    ee77:	01 d0                	add    %edx,%eax
    ee79:	c1 e0 08             	shl    $0x8,%eax
    ee7c:	89 c2                	mov    %eax,%edx
    ee7e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee81:	83 c0 02             	add    $0x2,%eax
    ee84:	0f b6 00             	movzbl (%eax),%eax
    ee87:	0f b6 c0             	movzbl %al,%eax
    ee8a:	01 d0                	add    %edx,%eax
    ee8c:	c1 e0 08             	shl    $0x8,%eax
    ee8f:	89 c2                	mov    %eax,%edx
    ee91:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee94:	83 c0 03             	add    $0x3,%eax
    ee97:	0f b6 00             	movzbl (%eax),%eax
    ee9a:	0f b6 c0             	movzbl %al,%eax
    ee9d:	01 c2                	add    %eax,%edx
    ee9f:	8b 45 08             	mov    0x8(%ebp),%eax
    eea2:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    eea5:	8b 45 0c             	mov    0xc(%ebp),%eax
    eea8:	83 c0 04             	add    $0x4,%eax
    eeab:	0f b6 00             	movzbl (%eax),%eax
    eeae:	0f b6 c0             	movzbl %al,%eax
    eeb1:	c1 e0 08             	shl    $0x8,%eax
    eeb4:	89 c2                	mov    %eax,%edx
    eeb6:	8b 45 0c             	mov    0xc(%ebp),%eax
    eeb9:	83 c0 05             	add    $0x5,%eax
    eebc:	0f b6 00             	movzbl (%eax),%eax
    eebf:	0f b6 c0             	movzbl %al,%eax
    eec2:	01 d0                	add    %edx,%eax
    eec4:	c1 e0 08             	shl    $0x8,%eax
    eec7:	89 c2                	mov    %eax,%edx
    eec9:	8b 45 0c             	mov    0xc(%ebp),%eax
    eecc:	83 c0 06             	add    $0x6,%eax
    eecf:	0f b6 00             	movzbl (%eax),%eax
    eed2:	0f b6 c0             	movzbl %al,%eax
    eed5:	01 d0                	add    %edx,%eax
    eed7:	c1 e0 08             	shl    $0x8,%eax
    eeda:	89 c2                	mov    %eax,%edx
    eedc:	8b 45 0c             	mov    0xc(%ebp),%eax
    eedf:	83 c0 07             	add    $0x7,%eax
    eee2:	0f b6 00             	movzbl (%eax),%eax
    eee5:	0f b6 c0             	movzbl %al,%eax
    eee8:	01 c2                	add    %eax,%edx
    eeea:	8b 45 08             	mov    0x8(%ebp),%eax
    eeed:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    eef3:	8b 45 0c             	mov    0xc(%ebp),%eax
    eef6:	83 c0 08             	add    $0x8,%eax
    eef9:	0f b6 00             	movzbl (%eax),%eax
    eefc:	0f b6 d0             	movzbl %al,%edx
    eeff:	8b 45 08             	mov    0x8(%ebp),%eax
    ef02:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    ef08:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ef0d:	5d                   	pop    %ebp
    ef0e:	c3                   	ret    

0000ef0f <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ef0f:	55                   	push   %ebp
    ef10:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    ef12:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    ef16:	74 07                	je     ef1f <readChunk_gAMA+0x10>
    ef18:	b8 60 00 00 00       	mov    $0x60,%eax
    ef1d:	eb 5d                	jmp    ef7c <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    ef1f:	8b 45 08             	mov    0x8(%ebp),%eax
    ef22:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    ef29:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    ef2c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef2f:	0f b6 00             	movzbl (%eax),%eax
    ef32:	0f b6 c0             	movzbl %al,%eax
    ef35:	c1 e0 08             	shl    $0x8,%eax
    ef38:	89 c2                	mov    %eax,%edx
    ef3a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef3d:	83 c0 01             	add    $0x1,%eax
    ef40:	0f b6 00             	movzbl (%eax),%eax
    ef43:	0f b6 c0             	movzbl %al,%eax
    ef46:	01 d0                	add    %edx,%eax
    ef48:	c1 e0 08             	shl    $0x8,%eax
    ef4b:	89 c2                	mov    %eax,%edx
    ef4d:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef50:	83 c0 02             	add    $0x2,%eax
    ef53:	0f b6 00             	movzbl (%eax),%eax
    ef56:	0f b6 c0             	movzbl %al,%eax
    ef59:	01 d0                	add    %edx,%eax
    ef5b:	c1 e0 08             	shl    $0x8,%eax
    ef5e:	89 c2                	mov    %eax,%edx
    ef60:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef63:	83 c0 03             	add    $0x3,%eax
    ef66:	0f b6 00             	movzbl (%eax),%eax
    ef69:	0f b6 c0             	movzbl %al,%eax
    ef6c:	01 c2                	add    %eax,%edx
    ef6e:	8b 45 08             	mov    0x8(%ebp),%eax
    ef71:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    ef77:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ef7c:	5d                   	pop    %ebp
    ef7d:	c3                   	ret    

0000ef7e <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ef7e:	55                   	push   %ebp
    ef7f:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    ef81:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    ef85:	74 0a                	je     ef91 <readChunk_cHRM+0x13>
    ef87:	b8 61 00 00 00       	mov    $0x61,%eax
    ef8c:	e9 7f 02 00 00       	jmp    f210 <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    ef91:	8b 45 08             	mov    0x8(%ebp),%eax
    ef94:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    ef9b:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    ef9e:	8b 45 0c             	mov    0xc(%ebp),%eax
    efa1:	0f b6 00             	movzbl (%eax),%eax
    efa4:	0f b6 c0             	movzbl %al,%eax
    efa7:	c1 e0 08             	shl    $0x8,%eax
    efaa:	89 c2                	mov    %eax,%edx
    efac:	8b 45 0c             	mov    0xc(%ebp),%eax
    efaf:	83 c0 01             	add    $0x1,%eax
    efb2:	0f b6 00             	movzbl (%eax),%eax
    efb5:	0f b6 c0             	movzbl %al,%eax
    efb8:	01 d0                	add    %edx,%eax
    efba:	c1 e0 08             	shl    $0x8,%eax
    efbd:	89 c2                	mov    %eax,%edx
    efbf:	8b 45 0c             	mov    0xc(%ebp),%eax
    efc2:	83 c0 02             	add    $0x2,%eax
    efc5:	0f b6 00             	movzbl (%eax),%eax
    efc8:	0f b6 c0             	movzbl %al,%eax
    efcb:	01 d0                	add    %edx,%eax
    efcd:	c1 e0 08             	shl    $0x8,%eax
    efd0:	89 c2                	mov    %eax,%edx
    efd2:	8b 45 0c             	mov    0xc(%ebp),%eax
    efd5:	83 c0 03             	add    $0x3,%eax
    efd8:	0f b6 00             	movzbl (%eax),%eax
    efdb:	0f b6 c0             	movzbl %al,%eax
    efde:	01 c2                	add    %eax,%edx
    efe0:	8b 45 08             	mov    0x8(%ebp),%eax
    efe3:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    efe9:	8b 45 0c             	mov    0xc(%ebp),%eax
    efec:	83 c0 04             	add    $0x4,%eax
    efef:	0f b6 00             	movzbl (%eax),%eax
    eff2:	0f b6 c0             	movzbl %al,%eax
    eff5:	c1 e0 08             	shl    $0x8,%eax
    eff8:	89 c2                	mov    %eax,%edx
    effa:	8b 45 0c             	mov    0xc(%ebp),%eax
    effd:	83 c0 05             	add    $0x5,%eax
    f000:	0f b6 00             	movzbl (%eax),%eax
    f003:	0f b6 c0             	movzbl %al,%eax
    f006:	01 d0                	add    %edx,%eax
    f008:	c1 e0 08             	shl    $0x8,%eax
    f00b:	89 c2                	mov    %eax,%edx
    f00d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f010:	83 c0 06             	add    $0x6,%eax
    f013:	0f b6 00             	movzbl (%eax),%eax
    f016:	0f b6 c0             	movzbl %al,%eax
    f019:	01 d0                	add    %edx,%eax
    f01b:	c1 e0 08             	shl    $0x8,%eax
    f01e:	89 c2                	mov    %eax,%edx
    f020:	8b 45 0c             	mov    0xc(%ebp),%eax
    f023:	83 c0 07             	add    $0x7,%eax
    f026:	0f b6 00             	movzbl (%eax),%eax
    f029:	0f b6 c0             	movzbl %al,%eax
    f02c:	01 c2                	add    %eax,%edx
    f02e:	8b 45 08             	mov    0x8(%ebp),%eax
    f031:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    f037:	8b 45 0c             	mov    0xc(%ebp),%eax
    f03a:	83 c0 08             	add    $0x8,%eax
    f03d:	0f b6 00             	movzbl (%eax),%eax
    f040:	0f b6 c0             	movzbl %al,%eax
    f043:	c1 e0 08             	shl    $0x8,%eax
    f046:	89 c2                	mov    %eax,%edx
    f048:	8b 45 0c             	mov    0xc(%ebp),%eax
    f04b:	83 c0 09             	add    $0x9,%eax
    f04e:	0f b6 00             	movzbl (%eax),%eax
    f051:	0f b6 c0             	movzbl %al,%eax
    f054:	01 d0                	add    %edx,%eax
    f056:	c1 e0 08             	shl    $0x8,%eax
    f059:	89 c2                	mov    %eax,%edx
    f05b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f05e:	83 c0 0a             	add    $0xa,%eax
    f061:	0f b6 00             	movzbl (%eax),%eax
    f064:	0f b6 c0             	movzbl %al,%eax
    f067:	01 d0                	add    %edx,%eax
    f069:	c1 e0 08             	shl    $0x8,%eax
    f06c:	89 c2                	mov    %eax,%edx
    f06e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f071:	83 c0 0b             	add    $0xb,%eax
    f074:	0f b6 00             	movzbl (%eax),%eax
    f077:	0f b6 c0             	movzbl %al,%eax
    f07a:	01 c2                	add    %eax,%edx
    f07c:	8b 45 08             	mov    0x8(%ebp),%eax
    f07f:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    f085:	8b 45 0c             	mov    0xc(%ebp),%eax
    f088:	83 c0 0c             	add    $0xc,%eax
    f08b:	0f b6 00             	movzbl (%eax),%eax
    f08e:	0f b6 c0             	movzbl %al,%eax
    f091:	c1 e0 08             	shl    $0x8,%eax
    f094:	89 c2                	mov    %eax,%edx
    f096:	8b 45 0c             	mov    0xc(%ebp),%eax
    f099:	83 c0 0d             	add    $0xd,%eax
    f09c:	0f b6 00             	movzbl (%eax),%eax
    f09f:	0f b6 c0             	movzbl %al,%eax
    f0a2:	01 d0                	add    %edx,%eax
    f0a4:	c1 e0 08             	shl    $0x8,%eax
    f0a7:	89 c2                	mov    %eax,%edx
    f0a9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0ac:	83 c0 0e             	add    $0xe,%eax
    f0af:	0f b6 00             	movzbl (%eax),%eax
    f0b2:	0f b6 c0             	movzbl %al,%eax
    f0b5:	01 d0                	add    %edx,%eax
    f0b7:	c1 e0 08             	shl    $0x8,%eax
    f0ba:	89 c2                	mov    %eax,%edx
    f0bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0bf:	83 c0 0f             	add    $0xf,%eax
    f0c2:	0f b6 00             	movzbl (%eax),%eax
    f0c5:	0f b6 c0             	movzbl %al,%eax
    f0c8:	01 c2                	add    %eax,%edx
    f0ca:	8b 45 08             	mov    0x8(%ebp),%eax
    f0cd:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    f0d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0d6:	83 c0 10             	add    $0x10,%eax
    f0d9:	0f b6 00             	movzbl (%eax),%eax
    f0dc:	0f b6 c0             	movzbl %al,%eax
    f0df:	c1 e0 08             	shl    $0x8,%eax
    f0e2:	89 c2                	mov    %eax,%edx
    f0e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0e7:	83 c0 11             	add    $0x11,%eax
    f0ea:	0f b6 00             	movzbl (%eax),%eax
    f0ed:	0f b6 c0             	movzbl %al,%eax
    f0f0:	01 d0                	add    %edx,%eax
    f0f2:	c1 e0 08             	shl    $0x8,%eax
    f0f5:	89 c2                	mov    %eax,%edx
    f0f7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0fa:	83 c0 12             	add    $0x12,%eax
    f0fd:	0f b6 00             	movzbl (%eax),%eax
    f100:	0f b6 c0             	movzbl %al,%eax
    f103:	01 d0                	add    %edx,%eax
    f105:	c1 e0 08             	shl    $0x8,%eax
    f108:	89 c2                	mov    %eax,%edx
    f10a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f10d:	83 c0 13             	add    $0x13,%eax
    f110:	0f b6 00             	movzbl (%eax),%eax
    f113:	0f b6 c0             	movzbl %al,%eax
    f116:	01 c2                	add    %eax,%edx
    f118:	8b 45 08             	mov    0x8(%ebp),%eax
    f11b:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    f121:	8b 45 0c             	mov    0xc(%ebp),%eax
    f124:	83 c0 14             	add    $0x14,%eax
    f127:	0f b6 00             	movzbl (%eax),%eax
    f12a:	0f b6 c0             	movzbl %al,%eax
    f12d:	c1 e0 08             	shl    $0x8,%eax
    f130:	89 c2                	mov    %eax,%edx
    f132:	8b 45 0c             	mov    0xc(%ebp),%eax
    f135:	83 c0 15             	add    $0x15,%eax
    f138:	0f b6 00             	movzbl (%eax),%eax
    f13b:	0f b6 c0             	movzbl %al,%eax
    f13e:	01 d0                	add    %edx,%eax
    f140:	c1 e0 08             	shl    $0x8,%eax
    f143:	89 c2                	mov    %eax,%edx
    f145:	8b 45 0c             	mov    0xc(%ebp),%eax
    f148:	83 c0 16             	add    $0x16,%eax
    f14b:	0f b6 00             	movzbl (%eax),%eax
    f14e:	0f b6 c0             	movzbl %al,%eax
    f151:	01 d0                	add    %edx,%eax
    f153:	c1 e0 08             	shl    $0x8,%eax
    f156:	89 c2                	mov    %eax,%edx
    f158:	8b 45 0c             	mov    0xc(%ebp),%eax
    f15b:	83 c0 17             	add    $0x17,%eax
    f15e:	0f b6 00             	movzbl (%eax),%eax
    f161:	0f b6 c0             	movzbl %al,%eax
    f164:	01 c2                	add    %eax,%edx
    f166:	8b 45 08             	mov    0x8(%ebp),%eax
    f169:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    f16f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f172:	83 c0 18             	add    $0x18,%eax
    f175:	0f b6 00             	movzbl (%eax),%eax
    f178:	0f b6 c0             	movzbl %al,%eax
    f17b:	c1 e0 08             	shl    $0x8,%eax
    f17e:	89 c2                	mov    %eax,%edx
    f180:	8b 45 0c             	mov    0xc(%ebp),%eax
    f183:	83 c0 19             	add    $0x19,%eax
    f186:	0f b6 00             	movzbl (%eax),%eax
    f189:	0f b6 c0             	movzbl %al,%eax
    f18c:	01 d0                	add    %edx,%eax
    f18e:	c1 e0 08             	shl    $0x8,%eax
    f191:	89 c2                	mov    %eax,%edx
    f193:	8b 45 0c             	mov    0xc(%ebp),%eax
    f196:	83 c0 1a             	add    $0x1a,%eax
    f199:	0f b6 00             	movzbl (%eax),%eax
    f19c:	0f b6 c0             	movzbl %al,%eax
    f19f:	01 d0                	add    %edx,%eax
    f1a1:	c1 e0 08             	shl    $0x8,%eax
    f1a4:	89 c2                	mov    %eax,%edx
    f1a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1a9:	83 c0 1b             	add    $0x1b,%eax
    f1ac:	0f b6 00             	movzbl (%eax),%eax
    f1af:	0f b6 c0             	movzbl %al,%eax
    f1b2:	01 c2                	add    %eax,%edx
    f1b4:	8b 45 08             	mov    0x8(%ebp),%eax
    f1b7:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    f1bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1c0:	83 c0 1c             	add    $0x1c,%eax
    f1c3:	0f b6 00             	movzbl (%eax),%eax
    f1c6:	0f b6 c0             	movzbl %al,%eax
    f1c9:	c1 e0 08             	shl    $0x8,%eax
    f1cc:	89 c2                	mov    %eax,%edx
    f1ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1d1:	83 c0 1d             	add    $0x1d,%eax
    f1d4:	0f b6 00             	movzbl (%eax),%eax
    f1d7:	0f b6 c0             	movzbl %al,%eax
    f1da:	01 d0                	add    %edx,%eax
    f1dc:	c1 e0 08             	shl    $0x8,%eax
    f1df:	89 c2                	mov    %eax,%edx
    f1e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1e4:	83 c0 1e             	add    $0x1e,%eax
    f1e7:	0f b6 00             	movzbl (%eax),%eax
    f1ea:	0f b6 c0             	movzbl %al,%eax
    f1ed:	01 d0                	add    %edx,%eax
    f1ef:	c1 e0 08             	shl    $0x8,%eax
    f1f2:	89 c2                	mov    %eax,%edx
    f1f4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1f7:	83 c0 1f             	add    $0x1f,%eax
    f1fa:	0f b6 00             	movzbl (%eax),%eax
    f1fd:	0f b6 c0             	movzbl %al,%eax
    f200:	01 c2                	add    %eax,%edx
    f202:	8b 45 08             	mov    0x8(%ebp),%eax
    f205:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    f20b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f210:	5d                   	pop    %ebp
    f211:	c3                   	ret    

0000f212 <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f212:	55                   	push   %ebp
    f213:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    f215:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f219:	74 07                	je     f222 <readChunk_sRGB+0x10>
    f21b:	b8 62 00 00 00       	mov    $0x62,%eax
    f220:	eb 24                	jmp    f246 <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    f222:	8b 45 08             	mov    0x8(%ebp),%eax
    f225:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    f22c:	00 00 00 
  info->srgb_intent = data[0];
    f22f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f232:	0f b6 00             	movzbl (%eax),%eax
    f235:	0f b6 d0             	movzbl %al,%edx
    f238:	8b 45 08             	mov    0x8(%ebp),%eax
    f23b:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    f241:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f246:	5d                   	pop    %ebp
    f247:	c3                   	ret    

0000f248 <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f248:	55                   	push   %ebp
    f249:	89 e5                	mov    %esp,%ebp
    f24b:	53                   	push   %ebx
    f24c:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    f24f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    f256:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f25d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f260:	8b 10                	mov    (%eax),%edx
    f262:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f265:	8b 50 04             	mov    0x4(%eax),%edx
    f268:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f26b:	8b 50 08             	mov    0x8(%eax),%edx
    f26e:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f271:	8b 50 0c             	mov    0xc(%eax),%edx
    f274:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f277:	8b 50 10             	mov    0x10(%eax),%edx
    f27a:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f27d:	8b 40 14             	mov    0x14(%eax),%eax
    f280:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    f283:	8b 45 08             	mov    0x8(%ebp),%eax
    f286:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    f28d:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    f290:	8b 45 08             	mov    0x8(%ebp),%eax
    f293:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f299:	85 c0                	test   %eax,%eax
    f29b:	74 0e                	je     f2ab <readChunk_iCCP+0x63>
    f29d:	83 ec 0c             	sub    $0xc,%esp
    f2a0:	ff 75 08             	pushl  0x8(%ebp)
    f2a3:	e8 ca a6 ff ff       	call   9972 <lodepng_clear_icc>
    f2a8:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f2ab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f2b2:	eb 04                	jmp    f2b8 <readChunk_iCCP+0x70>
    f2b4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f2b8:	8b 45 14             	mov    0x14(%ebp),%eax
    f2bb:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f2be:	73 0f                	jae    f2cf <readChunk_iCCP+0x87>
    f2c0:	8b 55 10             	mov    0x10(%ebp),%edx
    f2c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2c6:	01 d0                	add    %edx,%eax
    f2c8:	0f b6 00             	movzbl (%eax),%eax
    f2cb:	84 c0                	test   %al,%al
    f2cd:	75 e5                	jne    f2b4 <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    f2cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2d2:	8d 50 02             	lea    0x2(%eax),%edx
    f2d5:	8b 45 14             	mov    0x14(%ebp),%eax
    f2d8:	39 c2                	cmp    %eax,%edx
    f2da:	72 0a                	jb     f2e6 <readChunk_iCCP+0x9e>
    f2dc:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f2e1:	e9 46 01 00 00       	jmp    f42c <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    f2e6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f2ea:	74 06                	je     f2f2 <readChunk_iCCP+0xaa>
    f2ec:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f2f0:	76 0a                	jbe    f2fc <readChunk_iCCP+0xb4>
    f2f2:	b8 59 00 00 00       	mov    $0x59,%eax
    f2f7:	e9 30 01 00 00       	jmp    f42c <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    f2fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f2ff:	83 c0 01             	add    $0x1,%eax
    f302:	83 ec 0c             	sub    $0xc,%esp
    f305:	50                   	push   %eax
    f306:	e8 1a 40 ff ff       	call   3325 <lodepng_malloc>
    f30b:	83 c4 10             	add    $0x10,%esp
    f30e:	89 c2                	mov    %eax,%edx
    f310:	8b 45 08             	mov    0x8(%ebp),%eax
    f313:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    f319:	8b 45 08             	mov    0x8(%ebp),%eax
    f31c:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f322:	85 c0                	test   %eax,%eax
    f324:	75 0a                	jne    f330 <readChunk_iCCP+0xe8>
    f326:	b8 53 00 00 00       	mov    $0x53,%eax
    f32b:	e9 fc 00 00 00       	jmp    f42c <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    f330:	8b 45 08             	mov    0x8(%ebp),%eax
    f333:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f339:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f33c:	01 d0                	add    %edx,%eax
    f33e:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    f341:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f348:	eb 1f                	jmp    f369 <readChunk_iCCP+0x121>
    f34a:	8b 45 08             	mov    0x8(%ebp),%eax
    f34d:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f353:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f356:	01 d0                	add    %edx,%eax
    f358:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f35b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f35e:	01 ca                	add    %ecx,%edx
    f360:	0f b6 12             	movzbl (%edx),%edx
    f363:	88 10                	mov    %dl,(%eax)
    f365:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f369:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f36c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f36f:	75 d9                	jne    f34a <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    f371:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f374:	8d 50 01             	lea    0x1(%eax),%edx
    f377:	8b 45 10             	mov    0x10(%ebp),%eax
    f37a:	01 d0                	add    %edx,%eax
    f37c:	0f b6 00             	movzbl (%eax),%eax
    f37f:	84 c0                	test   %al,%al
    f381:	74 0a                	je     f38d <readChunk_iCCP+0x145>
    f383:	b8 48 00 00 00       	mov    $0x48,%eax
    f388:	e9 9f 00 00 00       	jmp    f42c <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    f38d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f390:	83 c0 02             	add    $0x2,%eax
    f393:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    f396:	8b 45 14             	mov    0x14(%ebp),%eax
    f399:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f39c:	76 0a                	jbe    f3a8 <readChunk_iCCP+0x160>
    f39e:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f3a3:	e9 84 00 00 00       	jmp    f42c <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    f3a8:	8b 45 14             	mov    0x14(%ebp),%eax
    f3ab:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f3ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    f3b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3b4:	8b 40 34             	mov    0x34(%eax),%eax
    f3b7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    f3ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f3bd:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f3c0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f3c3:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    f3c6:	8b 55 08             	mov    0x8(%ebp),%edx
    f3c9:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    f3cf:	83 ec 08             	sub    $0x8,%esp
    f3d2:	8d 55 cc             	lea    -0x34(%ebp),%edx
    f3d5:	52                   	push   %edx
    f3d6:	50                   	push   %eax
    f3d7:	53                   	push   %ebx
    f3d8:	6a 00                	push   $0x0
    f3da:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    f3dd:	50                   	push   %eax
    f3de:	51                   	push   %ecx
    f3df:	e8 fc 89 ff ff       	call   7de0 <zlib_decompress>
    f3e4:	83 c4 20             	add    $0x20,%esp
    f3e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    f3ea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f3ee:	74 11                	je     f401 <readChunk_iCCP+0x1b9>
    f3f0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    f3f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f3f6:	39 c2                	cmp    %eax,%edx
    f3f8:	7d 07                	jge    f401 <readChunk_iCCP+0x1b9>
    f3fa:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    f401:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f404:	89 c2                	mov    %eax,%edx
    f406:	8b 45 08             	mov    0x8(%ebp),%eax
    f409:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    f40f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f413:	75 14                	jne    f429 <readChunk_iCCP+0x1e1>
    f415:	8b 45 08             	mov    0x8(%ebp),%eax
    f418:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    f41e:	85 c0                	test   %eax,%eax
    f420:	75 07                	jne    f429 <readChunk_iCCP+0x1e1>
    f422:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    f429:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f42c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f42f:	c9                   	leave  
    f430:	c3                   	ret    

0000f431 <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    f431:	55                   	push   %ebp
    f432:	89 e5                	mov    %esp,%ebp
    f434:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    f437:	8b 55 0c             	mov    0xc(%ebp),%edx
    f43a:	8b 45 10             	mov    0x10(%ebp),%eax
    f43d:	01 d0                	add    %edx,%eax
    f43f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    f442:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    f449:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    f450:	8b 45 0c             	mov    0xc(%ebp),%eax
    f453:	83 c0 04             	add    $0x4,%eax
    f456:	3b 45 14             	cmp    0x14(%ebp),%eax
    f459:	7e 0a                	jle    f465 <lodepng_inspect_chunk+0x34>
    f45b:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f460:	e9 43 03 00 00       	jmp    f7a8 <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    f465:	ff 75 ec             	pushl  -0x14(%ebp)
    f468:	e8 3a 8e ff ff       	call   82a7 <lodepng_chunk_length>
    f46d:	83 c4 04             	add    $0x4,%esp
    f470:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    f473:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f476:	85 c0                	test   %eax,%eax
    f478:	79 0a                	jns    f484 <lodepng_inspect_chunk+0x53>
    f47a:	b8 3f 00 00 00       	mov    $0x3f,%eax
    f47f:	e9 24 03 00 00       	jmp    f7a8 <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
    f484:	ff 75 ec             	pushl  -0x14(%ebp)
    f487:	e8 53 8f ff ff       	call   83df <lodepng_chunk_data_const>
    f48c:	83 c4 04             	add    $0x4,%esp
    f48f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
    f492:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f495:	8d 50 04             	lea    0x4(%eax),%edx
    f498:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f49b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    f49e:	8b 55 14             	mov    0x14(%ebp),%edx
    f4a1:	8b 45 10             	mov    0x10(%ebp),%eax
    f4a4:	01 d0                	add    %edx,%eax
    f4a6:	39 c1                	cmp    %eax,%ecx
    f4a8:	76 0a                	jbe    f4b4 <lodepng_inspect_chunk+0x83>
    f4aa:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f4af:	e9 f4 02 00 00       	jmp    f7a8 <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    f4b4:	68 68 a0 01 00       	push   $0x1a068
    f4b9:	ff 75 ec             	pushl  -0x14(%ebp)
    f4bc:	e8 33 8e ff ff       	call   82f4 <lodepng_chunk_type_equals>
    f4c1:	83 c4 08             	add    $0x8,%esp
    f4c4:	84 c0                	test   %al,%al
    f4c6:	74 24                	je     f4ec <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    f4c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f4cb:	8b 55 08             	mov    0x8(%ebp),%edx
    f4ce:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f4d4:	83 ec 04             	sub    $0x4,%esp
    f4d7:	50                   	push   %eax
    f4d8:	ff 75 e4             	pushl  -0x1c(%ebp)
    f4db:	52                   	push   %edx
    f4dc:	e8 5b ee ff ff       	call   e33c <readChunk_PLTE>
    f4e1:	83 c4 10             	add    $0x10,%esp
    f4e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f4e7:	e9 8a 02 00 00       	jmp    f776 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    f4ec:	83 ec 08             	sub    $0x8,%esp
    f4ef:	68 6d a0 01 00       	push   $0x1a06d
    f4f4:	ff 75 ec             	pushl  -0x14(%ebp)
    f4f7:	e8 f8 8d ff ff       	call   82f4 <lodepng_chunk_type_equals>
    f4fc:	83 c4 10             	add    $0x10,%esp
    f4ff:	84 c0                	test   %al,%al
    f501:	74 24                	je     f527 <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    f503:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f506:	8b 55 08             	mov    0x8(%ebp),%edx
    f509:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f50f:	83 ec 04             	sub    $0x4,%esp
    f512:	50                   	push   %eax
    f513:	ff 75 e4             	pushl  -0x1c(%ebp)
    f516:	52                   	push   %edx
    f517:	e8 40 ef ff ff       	call   e45c <readChunk_tRNS>
    f51c:	83 c4 10             	add    $0x10,%esp
    f51f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f522:	e9 4f 02 00 00       	jmp    f776 <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    f527:	83 ec 08             	sub    $0x8,%esp
    f52a:	68 72 a0 01 00       	push   $0x1a072
    f52f:	ff 75 ec             	pushl  -0x14(%ebp)
    f532:	e8 bd 8d ff ff       	call   82f4 <lodepng_chunk_type_equals>
    f537:	83 c4 10             	add    $0x10,%esp
    f53a:	84 c0                	test   %al,%al
    f53c:	74 24                	je     f562 <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
    f53e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f541:	8b 55 08             	mov    0x8(%ebp),%edx
    f544:	81 c2 98 00 00 00    	add    $0x98,%edx
    f54a:	83 ec 04             	sub    $0x4,%esp
    f54d:	50                   	push   %eax
    f54e:	ff 75 e4             	pushl  -0x1c(%ebp)
    f551:	52                   	push   %edx
    f552:	e8 68 f0 ff ff       	call   e5bf <readChunk_bKGD>
    f557:	83 c4 10             	add    $0x10,%esp
    f55a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f55d:	e9 14 02 00 00       	jmp    f776 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    f562:	83 ec 08             	sub    $0x8,%esp
    f565:	68 77 a0 01 00       	push   $0x1a077
    f56a:	ff 75 ec             	pushl  -0x14(%ebp)
    f56d:	e8 82 8d ff ff       	call   82f4 <lodepng_chunk_type_equals>
    f572:	83 c4 10             	add    $0x10,%esp
    f575:	84 c0                	test   %al,%al
    f577:	74 24                	je     f59d <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
    f579:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f57c:	8b 55 08             	mov    0x8(%ebp),%edx
    f57f:	81 c2 98 00 00 00    	add    $0x98,%edx
    f585:	83 ec 04             	sub    $0x4,%esp
    f588:	50                   	push   %eax
    f589:	ff 75 e4             	pushl  -0x1c(%ebp)
    f58c:	52                   	push   %edx
    f58d:	e8 b0 f1 ff ff       	call   e742 <readChunk_tEXt>
    f592:	83 c4 10             	add    $0x10,%esp
    f595:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f598:	e9 d9 01 00 00       	jmp    f776 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    f59d:	83 ec 08             	sub    $0x8,%esp
    f5a0:	68 7c a0 01 00       	push   $0x1a07c
    f5a5:	ff 75 ec             	pushl  -0x14(%ebp)
    f5a8:	e8 47 8d ff ff       	call   82f4 <lodepng_chunk_type_equals>
    f5ad:	83 c4 10             	add    $0x10,%esp
    f5b0:	84 c0                	test   %al,%al
    f5b2:	74 25                	je     f5d9 <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    f5b4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f5b7:	8b 45 08             	mov    0x8(%ebp),%eax
    f5ba:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f5bd:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f5c3:	52                   	push   %edx
    f5c4:	ff 75 e4             	pushl  -0x1c(%ebp)
    f5c7:	50                   	push   %eax
    f5c8:	51                   	push   %ecx
    f5c9:	e8 c0 f2 ff ff       	call   e88e <readChunk_zTXt>
    f5ce:	83 c4 10             	add    $0x10,%esp
    f5d1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f5d4:	e9 9d 01 00 00       	jmp    f776 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    f5d9:	83 ec 08             	sub    $0x8,%esp
    f5dc:	68 81 a0 01 00       	push   $0x1a081
    f5e1:	ff 75 ec             	pushl  -0x14(%ebp)
    f5e4:	e8 0b 8d ff ff       	call   82f4 <lodepng_chunk_type_equals>
    f5e9:	83 c4 10             	add    $0x10,%esp
    f5ec:	84 c0                	test   %al,%al
    f5ee:	74 25                	je     f615 <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    f5f0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f5f3:	8b 45 08             	mov    0x8(%ebp),%eax
    f5f6:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f5f9:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f5ff:	52                   	push   %edx
    f600:	ff 75 e4             	pushl  -0x1c(%ebp)
    f603:	50                   	push   %eax
    f604:	51                   	push   %ecx
    f605:	e8 40 f4 ff ff       	call   ea4a <readChunk_iTXt>
    f60a:	83 c4 10             	add    $0x10,%esp
    f60d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f610:	e9 61 01 00 00       	jmp    f776 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    f615:	83 ec 08             	sub    $0x8,%esp
    f618:	68 86 a0 01 00       	push   $0x1a086
    f61d:	ff 75 ec             	pushl  -0x14(%ebp)
    f620:	e8 cf 8c ff ff       	call   82f4 <lodepng_chunk_type_equals>
    f625:	83 c4 10             	add    $0x10,%esp
    f628:	84 c0                	test   %al,%al
    f62a:	74 24                	je     f650 <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
    f62c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f62f:	8b 55 08             	mov    0x8(%ebp),%edx
    f632:	81 c2 98 00 00 00    	add    $0x98,%edx
    f638:	83 ec 04             	sub    $0x4,%esp
    f63b:	50                   	push   %eax
    f63c:	ff 75 e4             	pushl  -0x1c(%ebp)
    f63f:	52                   	push   %edx
    f640:	e8 5b f7 ff ff       	call   eda0 <readChunk_tIME>
    f645:	83 c4 10             	add    $0x10,%esp
    f648:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f64b:	e9 26 01 00 00       	jmp    f776 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    f650:	83 ec 08             	sub    $0x8,%esp
    f653:	68 8b a0 01 00       	push   $0x1a08b
    f658:	ff 75 ec             	pushl  -0x14(%ebp)
    f65b:	e8 94 8c ff ff       	call   82f4 <lodepng_chunk_type_equals>
    f660:	83 c4 10             	add    $0x10,%esp
    f663:	84 c0                	test   %al,%al
    f665:	74 24                	je     f68b <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
    f667:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f66a:	8b 55 08             	mov    0x8(%ebp),%edx
    f66d:	81 c2 98 00 00 00    	add    $0x98,%edx
    f673:	83 ec 04             	sub    $0x4,%esp
    f676:	50                   	push   %eax
    f677:	ff 75 e4             	pushl  -0x1c(%ebp)
    f67a:	52                   	push   %edx
    f67b:	e8 c0 f7 ff ff       	call   ee40 <readChunk_pHYs>
    f680:	83 c4 10             	add    $0x10,%esp
    f683:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f686:	e9 eb 00 00 00       	jmp    f776 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    f68b:	83 ec 08             	sub    $0x8,%esp
    f68e:	68 90 a0 01 00       	push   $0x1a090
    f693:	ff 75 ec             	pushl  -0x14(%ebp)
    f696:	e8 59 8c ff ff       	call   82f4 <lodepng_chunk_type_equals>
    f69b:	83 c4 10             	add    $0x10,%esp
    f69e:	84 c0                	test   %al,%al
    f6a0:	74 24                	je     f6c6 <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
    f6a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f6a5:	8b 55 08             	mov    0x8(%ebp),%edx
    f6a8:	81 c2 98 00 00 00    	add    $0x98,%edx
    f6ae:	83 ec 04             	sub    $0x4,%esp
    f6b1:	50                   	push   %eax
    f6b2:	ff 75 e4             	pushl  -0x1c(%ebp)
    f6b5:	52                   	push   %edx
    f6b6:	e8 54 f8 ff ff       	call   ef0f <readChunk_gAMA>
    f6bb:	83 c4 10             	add    $0x10,%esp
    f6be:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6c1:	e9 b0 00 00 00       	jmp    f776 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    f6c6:	83 ec 08             	sub    $0x8,%esp
    f6c9:	68 95 a0 01 00       	push   $0x1a095
    f6ce:	ff 75 ec             	pushl  -0x14(%ebp)
    f6d1:	e8 1e 8c ff ff       	call   82f4 <lodepng_chunk_type_equals>
    f6d6:	83 c4 10             	add    $0x10,%esp
    f6d9:	84 c0                	test   %al,%al
    f6db:	74 21                	je     f6fe <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
    f6dd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f6e0:	8b 55 08             	mov    0x8(%ebp),%edx
    f6e3:	81 c2 98 00 00 00    	add    $0x98,%edx
    f6e9:	83 ec 04             	sub    $0x4,%esp
    f6ec:	50                   	push   %eax
    f6ed:	ff 75 e4             	pushl  -0x1c(%ebp)
    f6f0:	52                   	push   %edx
    f6f1:	e8 88 f8 ff ff       	call   ef7e <readChunk_cHRM>
    f6f6:	83 c4 10             	add    $0x10,%esp
    f6f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6fc:	eb 78                	jmp    f776 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    f6fe:	83 ec 08             	sub    $0x8,%esp
    f701:	68 9a a0 01 00       	push   $0x1a09a
    f706:	ff 75 ec             	pushl  -0x14(%ebp)
    f709:	e8 e6 8b ff ff       	call   82f4 <lodepng_chunk_type_equals>
    f70e:	83 c4 10             	add    $0x10,%esp
    f711:	84 c0                	test   %al,%al
    f713:	74 21                	je     f736 <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
    f715:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f718:	8b 55 08             	mov    0x8(%ebp),%edx
    f71b:	81 c2 98 00 00 00    	add    $0x98,%edx
    f721:	83 ec 04             	sub    $0x4,%esp
    f724:	50                   	push   %eax
    f725:	ff 75 e4             	pushl  -0x1c(%ebp)
    f728:	52                   	push   %edx
    f729:	e8 e4 fa ff ff       	call   f212 <readChunk_sRGB>
    f72e:	83 c4 10             	add    $0x10,%esp
    f731:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f734:	eb 40                	jmp    f776 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    f736:	83 ec 08             	sub    $0x8,%esp
    f739:	68 9f a0 01 00       	push   $0x1a09f
    f73e:	ff 75 ec             	pushl  -0x14(%ebp)
    f741:	e8 ae 8b ff ff       	call   82f4 <lodepng_chunk_type_equals>
    f746:	83 c4 10             	add    $0x10,%esp
    f749:	84 c0                	test   %al,%al
    f74b:	74 22                	je     f76f <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    f74d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f750:	8b 45 08             	mov    0x8(%ebp),%eax
    f753:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f756:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f75c:	52                   	push   %edx
    f75d:	ff 75 e4             	pushl  -0x1c(%ebp)
    f760:	50                   	push   %eax
    f761:	51                   	push   %ecx
    f762:	e8 e1 fa ff ff       	call   f248 <readChunk_iCCP>
    f767:	83 c4 10             	add    $0x10,%esp
    f76a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f76d:	eb 07                	jmp    f776 <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
    f76f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
    f776:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f77a:	75 29                	jne    f7a5 <lodepng_inspect_chunk+0x374>
    f77c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f780:	75 23                	jne    f7a5 <lodepng_inspect_chunk+0x374>
    f782:	8b 45 08             	mov    0x8(%ebp),%eax
    f785:	8b 40 18             	mov    0x18(%eax),%eax
    f788:	85 c0                	test   %eax,%eax
    f78a:	75 19                	jne    f7a5 <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
    f78c:	83 ec 0c             	sub    $0xc,%esp
    f78f:	ff 75 ec             	pushl  -0x14(%ebp)
    f792:	e8 53 8c ff ff       	call   83ea <lodepng_chunk_check_crc>
    f797:	83 c4 10             	add    $0x10,%esp
    f79a:	85 c0                	test   %eax,%eax
    f79c:	74 07                	je     f7a5 <lodepng_inspect_chunk+0x374>
    f79e:	b8 39 00 00 00       	mov    $0x39,%eax
    f7a3:	eb 03                	jmp    f7a8 <lodepng_inspect_chunk+0x377>
  }

  return error;
    f7a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    f7a8:	c9                   	leave  
    f7a9:	c3                   	ret    

0000f7aa <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
    f7aa:	55                   	push   %ebp
    f7ab:	89 e5                	mov    %esp,%ebp
    f7ad:	56                   	push   %esi
    f7ae:	53                   	push   %ebx
    f7af:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
    f7b2:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
    f7b6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
    f7bd:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
    f7c4:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    f7cb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
    f7d2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
    f7d9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
    f7e0:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
    f7e7:	8b 45 08             	mov    0x8(%ebp),%eax
    f7ea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
    f7f0:	8b 45 10             	mov    0x10(%ebp),%eax
    f7f3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    f7f9:	8b 45 10             	mov    0x10(%ebp),%eax
    f7fc:	8b 10                	mov    (%eax),%edx
    f7fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    f801:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
    f803:	83 ec 0c             	sub    $0xc,%esp
    f806:	ff 75 1c             	pushl  0x1c(%ebp)
    f809:	ff 75 18             	pushl  0x18(%ebp)
    f80c:	ff 75 14             	pushl  0x14(%ebp)
    f80f:	ff 75 10             	pushl  0x10(%ebp)
    f812:	ff 75 0c             	pushl  0xc(%ebp)
    f815:	e8 d3 da ff ff       	call   d2ed <lodepng_inspect>
    f81a:	83 c4 20             	add    $0x20,%esp
    f81d:	89 c2                	mov    %eax,%edx
    f81f:	8b 45 14             	mov    0x14(%ebp),%eax
    f822:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
    f828:	8b 45 14             	mov    0x14(%ebp),%eax
    f82b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    f831:	85 c0                	test   %eax,%eax
    f833:	0f 85 24 0a 00 00    	jne    1025d <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
    f839:	8b 45 14             	mov    0x14(%ebp),%eax
    f83c:	8d 58 78             	lea    0x78(%eax),%ebx
    f83f:	8b 45 14             	mov    0x14(%ebp),%eax
    f842:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
    f848:	8b 45 10             	mov    0x10(%ebp),%eax
    f84b:	8b 10                	mov    (%eax),%edx
    f84d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f850:	8b 00                	mov    (%eax),%eax
    f852:	53                   	push   %ebx
    f853:	51                   	push   %ecx
    f854:	52                   	push   %edx
    f855:	50                   	push   %eax
    f856:	e8 76 97 ff ff       	call   8fd1 <lodepng_pixel_overflow>
    f85b:	83 c4 10             	add    $0x10,%esp
    f85e:	85 c0                	test   %eax,%eax
    f860:	74 12                	je     f874 <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
    f862:	8b 45 14             	mov    0x14(%ebp),%eax
    f865:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
    f86c:	00 00 00 
    f86f:	e9 ea 09 00 00       	jmp    1025e <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
    f874:	83 ec 0c             	sub    $0xc,%esp
    f877:	ff 75 1c             	pushl  0x1c(%ebp)
    f87a:	e8 a6 3a ff ff       	call   3325 <lodepng_malloc>
    f87f:	83 c4 10             	add    $0x10,%esp
    f882:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
    f885:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    f889:	75 12                	jne    f89d <decodeGeneric+0xf3>
    f88b:	8b 45 14             	mov    0x14(%ebp),%eax
    f88e:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
    f895:	00 00 00 
    f898:	e9 c1 09 00 00       	jmp    1025e <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
    f89d:	8b 45 18             	mov    0x18(%ebp),%eax
    f8a0:	83 c0 21             	add    $0x21,%eax
    f8a3:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    f8a6:	e9 81 06 00 00       	jmp    ff2c <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
    f8ab:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f8ae:	8b 45 18             	mov    0x18(%ebp),%eax
    f8b1:	29 c2                	sub    %eax,%edx
    f8b3:	89 d0                	mov    %edx,%eax
    f8b5:	83 c0 0c             	add    $0xc,%eax
    f8b8:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f8bb:	7f 08                	jg     f8c5 <decodeGeneric+0x11b>
    f8bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f8c0:	3b 45 18             	cmp    0x18(%ebp),%eax
    f8c3:	73 20                	jae    f8e5 <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f8c5:	8b 45 14             	mov    0x14(%ebp),%eax
    f8c8:	8b 40 20             	mov    0x20(%eax),%eax
    f8cb:	85 c0                	test   %eax,%eax
    f8cd:	0f 85 72 06 00 00    	jne    ff45 <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
    f8d3:	8b 45 14             	mov    0x14(%ebp),%eax
    f8d6:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
    f8dd:	00 00 00 
    f8e0:	e9 6a 06 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    f8e5:	83 ec 0c             	sub    $0xc,%esp
    f8e8:	ff 75 f0             	pushl  -0x10(%ebp)
    f8eb:	e8 b7 89 ff ff       	call   82a7 <lodepng_chunk_length>
    f8f0:	83 c4 10             	add    $0x10,%esp
    f8f3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
    f8f6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f8f9:	85 c0                	test   %eax,%eax
    f8fb:	79 20                	jns    f91d <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    f8fd:	8b 45 14             	mov    0x14(%ebp),%eax
    f900:	8b 40 20             	mov    0x20(%eax),%eax
    f903:	85 c0                	test   %eax,%eax
    f905:	0f 85 3d 06 00 00    	jne    ff48 <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
    f90b:	8b 45 14             	mov    0x14(%ebp),%eax
    f90e:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
    f915:	00 00 00 
    f918:	e9 32 06 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
    f91d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f920:	8b 45 18             	mov    0x18(%ebp),%eax
    f923:	29 c2                	sub    %eax,%edx
    f925:	89 d0                	mov    %edx,%eax
    f927:	89 c2                	mov    %eax,%edx
    f929:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f92c:	01 d0                	add    %edx,%eax
    f92e:	83 c0 0c             	add    $0xc,%eax
    f931:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f934:	7f 10                	jg     f946 <decodeGeneric+0x19c>
    f936:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f939:	8d 50 0c             	lea    0xc(%eax),%edx
    f93c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f93f:	01 d0                	add    %edx,%eax
    f941:	3b 45 18             	cmp    0x18(%ebp),%eax
    f944:	73 12                	jae    f958 <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    f946:	8b 45 14             	mov    0x14(%ebp),%eax
    f949:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
    f950:	00 00 00 
    f953:	e9 f7 05 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
    f958:	83 ec 0c             	sub    $0xc,%esp
    f95b:	ff 75 f0             	pushl  -0x10(%ebp)
    f95e:	e8 7c 8a ff ff       	call   83df <lodepng_chunk_data_const>
    f963:	83 c4 10             	add    $0x10,%esp
    f966:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
    f969:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
    f970:	83 ec 08             	sub    $0x8,%esp
    f973:	68 a4 a0 01 00       	push   $0x1a0a4
    f978:	ff 75 f0             	pushl  -0x10(%ebp)
    f97b:	e8 74 89 ff ff       	call   82f4 <lodepng_chunk_type_equals>
    f980:	83 c4 10             	add    $0x10,%esp
    f983:	84 c0                	test   %al,%al
    f985:	74 79                	je     fa00 <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
    f987:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f98a:	83 ec 04             	sub    $0x4,%esp
    f98d:	8d 55 bc             	lea    -0x44(%ebp),%edx
    f990:	52                   	push   %edx
    f991:	50                   	push   %eax
    f992:	ff 75 ec             	pushl  -0x14(%ebp)
    f995:	e8 4f 3a ff ff       	call   33e9 <lodepng_addofl>
    f99a:	83 c4 10             	add    $0x10,%esp
    f99d:	85 c0                	test   %eax,%eax
    f99f:	74 12                	je     f9b3 <decodeGeneric+0x209>
    f9a1:	8b 45 14             	mov    0x14(%ebp),%eax
    f9a4:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    f9ab:	00 00 00 
    f9ae:	e9 9c 05 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
    f9b3:	8b 45 bc             	mov    -0x44(%ebp),%eax
    f9b6:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    f9b9:	7e 13                	jle    f9ce <decodeGeneric+0x224>
    f9bb:	8b 45 14             	mov    0x14(%ebp),%eax
    f9be:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    f9c5:	00 00 00 
    f9c8:	90                   	nop
    f9c9:	e9 81 05 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
    f9ce:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9d1:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    f9d4:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f9d7:	01 ca                	add    %ecx,%edx
    f9d9:	83 ec 04             	sub    $0x4,%esp
    f9dc:	50                   	push   %eax
    f9dd:	ff 75 d0             	pushl  -0x30(%ebp)
    f9e0:	52                   	push   %edx
    f9e1:	e8 7d 39 ff ff       	call   3363 <lodepng_memcpy>
    f9e6:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
    f9e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
    f9ec:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    f9ef:	01 d0                	add    %edx,%eax
    f9f1:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
    f9f4:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
    f9fb:	e9 db 04 00 00       	jmp    fedb <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
    fa00:	83 ec 08             	sub    $0x8,%esp
    fa03:	68 a9 a0 01 00       	push   $0x1a0a9
    fa08:	ff 75 f0             	pushl  -0x10(%ebp)
    fa0b:	e8 e4 88 ff ff       	call   82f4 <lodepng_chunk_type_equals>
    fa10:	83 c4 10             	add    $0x10,%esp
    fa13:	84 c0                	test   %al,%al
    fa15:	74 09                	je     fa20 <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
    fa17:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
    fa1b:	e9 bb 04 00 00       	jmp    fedb <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    fa20:	83 ec 08             	sub    $0x8,%esp
    fa23:	68 68 a0 01 00       	push   $0x1a068
    fa28:	ff 75 f0             	pushl  -0x10(%ebp)
    fa2b:	e8 c4 88 ff ff       	call   82f4 <lodepng_chunk_type_equals>
    fa30:	83 c4 10             	add    $0x10,%esp
    fa33:	84 c0                	test   %al,%al
    fa35:	74 44                	je     fa7b <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    fa37:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa3a:	8b 55 14             	mov    0x14(%ebp),%edx
    fa3d:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fa43:	83 ec 04             	sub    $0x4,%esp
    fa46:	50                   	push   %eax
    fa47:	ff 75 d0             	pushl  -0x30(%ebp)
    fa4a:	52                   	push   %edx
    fa4b:	e8 ec e8 ff ff       	call   e33c <readChunk_PLTE>
    fa50:	83 c4 10             	add    $0x10,%esp
    fa53:	89 c2                	mov    %eax,%edx
    fa55:	8b 45 14             	mov    0x14(%ebp),%eax
    fa58:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fa5e:	8b 45 14             	mov    0x14(%ebp),%eax
    fa61:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fa67:	85 c0                	test   %eax,%eax
    fa69:	0f 85 dc 04 00 00    	jne    ff4b <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
    fa6f:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
    fa76:	e9 60 04 00 00       	jmp    fedb <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fa7b:	83 ec 08             	sub    $0x8,%esp
    fa7e:	68 6d a0 01 00       	push   $0x1a06d
    fa83:	ff 75 f0             	pushl  -0x10(%ebp)
    fa86:	e8 69 88 ff ff       	call   82f4 <lodepng_chunk_type_equals>
    fa8b:	83 c4 10             	add    $0x10,%esp
    fa8e:	84 c0                	test   %al,%al
    fa90:	74 3d                	je     facf <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    fa92:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa95:	8b 55 14             	mov    0x14(%ebp),%edx
    fa98:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fa9e:	83 ec 04             	sub    $0x4,%esp
    faa1:	50                   	push   %eax
    faa2:	ff 75 d0             	pushl  -0x30(%ebp)
    faa5:	52                   	push   %edx
    faa6:	e8 b1 e9 ff ff       	call   e45c <readChunk_tRNS>
    faab:	83 c4 10             	add    $0x10,%esp
    faae:	89 c2                	mov    %eax,%edx
    fab0:	8b 45 14             	mov    0x14(%ebp),%eax
    fab3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fab9:	8b 45 14             	mov    0x14(%ebp),%eax
    fabc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fac2:	85 c0                	test   %eax,%eax
    fac4:	0f 84 11 04 00 00    	je     fedb <decodeGeneric+0x731>
    faca:	e9 80 04 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    facf:	83 ec 08             	sub    $0x8,%esp
    fad2:	68 72 a0 01 00       	push   $0x1a072
    fad7:	ff 75 f0             	pushl  -0x10(%ebp)
    fada:	e8 15 88 ff ff       	call   82f4 <lodepng_chunk_type_equals>
    fadf:	83 c4 10             	add    $0x10,%esp
    fae2:	84 c0                	test   %al,%al
    fae4:	74 3d                	je     fb23 <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
    fae6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fae9:	8b 55 14             	mov    0x14(%ebp),%edx
    faec:	81 c2 98 00 00 00    	add    $0x98,%edx
    faf2:	83 ec 04             	sub    $0x4,%esp
    faf5:	50                   	push   %eax
    faf6:	ff 75 d0             	pushl  -0x30(%ebp)
    faf9:	52                   	push   %edx
    fafa:	e8 c0 ea ff ff       	call   e5bf <readChunk_bKGD>
    faff:	83 c4 10             	add    $0x10,%esp
    fb02:	89 c2                	mov    %eax,%edx
    fb04:	8b 45 14             	mov    0x14(%ebp),%eax
    fb07:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fb0d:	8b 45 14             	mov    0x14(%ebp),%eax
    fb10:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb16:	85 c0                	test   %eax,%eax
    fb18:	0f 84 bd 03 00 00    	je     fedb <decodeGeneric+0x731>
    fb1e:	e9 2c 04 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    fb23:	83 ec 08             	sub    $0x8,%esp
    fb26:	68 77 a0 01 00       	push   $0x1a077
    fb2b:	ff 75 f0             	pushl  -0x10(%ebp)
    fb2e:	e8 c1 87 ff ff       	call   82f4 <lodepng_chunk_type_equals>
    fb33:	83 c4 10             	add    $0x10,%esp
    fb36:	84 c0                	test   %al,%al
    fb38:	74 4b                	je     fb85 <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
    fb3a:	8b 45 14             	mov    0x14(%ebp),%eax
    fb3d:	8b 40 28             	mov    0x28(%eax),%eax
    fb40:	85 c0                	test   %eax,%eax
    fb42:	0f 84 93 03 00 00    	je     fedb <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
    fb48:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb4b:	8b 55 14             	mov    0x14(%ebp),%edx
    fb4e:	81 c2 98 00 00 00    	add    $0x98,%edx
    fb54:	83 ec 04             	sub    $0x4,%esp
    fb57:	50                   	push   %eax
    fb58:	ff 75 d0             	pushl  -0x30(%ebp)
    fb5b:	52                   	push   %edx
    fb5c:	e8 e1 eb ff ff       	call   e742 <readChunk_tEXt>
    fb61:	83 c4 10             	add    $0x10,%esp
    fb64:	89 c2                	mov    %eax,%edx
    fb66:	8b 45 14             	mov    0x14(%ebp),%eax
    fb69:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fb6f:	8b 45 14             	mov    0x14(%ebp),%eax
    fb72:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fb78:	85 c0                	test   %eax,%eax
    fb7a:	0f 84 5b 03 00 00    	je     fedb <decodeGeneric+0x731>
    fb80:	e9 ca 03 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    fb85:	83 ec 08             	sub    $0x8,%esp
    fb88:	68 7c a0 01 00       	push   $0x1a07c
    fb8d:	ff 75 f0             	pushl  -0x10(%ebp)
    fb90:	e8 5f 87 ff ff       	call   82f4 <lodepng_chunk_type_equals>
    fb95:	83 c4 10             	add    $0x10,%esp
    fb98:	84 c0                	test   %al,%al
    fb9a:	74 4c                	je     fbe8 <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
    fb9c:	8b 45 14             	mov    0x14(%ebp),%eax
    fb9f:	8b 40 28             	mov    0x28(%eax),%eax
    fba2:	85 c0                	test   %eax,%eax
    fba4:	0f 84 31 03 00 00    	je     fedb <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    fbaa:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fbad:	8b 45 14             	mov    0x14(%ebp),%eax
    fbb0:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fbb3:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fbb9:	52                   	push   %edx
    fbba:	ff 75 d0             	pushl  -0x30(%ebp)
    fbbd:	50                   	push   %eax
    fbbe:	51                   	push   %ecx
    fbbf:	e8 ca ec ff ff       	call   e88e <readChunk_zTXt>
    fbc4:	83 c4 10             	add    $0x10,%esp
    fbc7:	89 c2                	mov    %eax,%edx
    fbc9:	8b 45 14             	mov    0x14(%ebp),%eax
    fbcc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fbd2:	8b 45 14             	mov    0x14(%ebp),%eax
    fbd5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fbdb:	85 c0                	test   %eax,%eax
    fbdd:	0f 84 f8 02 00 00    	je     fedb <decodeGeneric+0x731>
    fbe3:	e9 67 03 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    fbe8:	83 ec 08             	sub    $0x8,%esp
    fbeb:	68 81 a0 01 00       	push   $0x1a081
    fbf0:	ff 75 f0             	pushl  -0x10(%ebp)
    fbf3:	e8 fc 86 ff ff       	call   82f4 <lodepng_chunk_type_equals>
    fbf8:	83 c4 10             	add    $0x10,%esp
    fbfb:	84 c0                	test   %al,%al
    fbfd:	74 4c                	je     fc4b <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
    fbff:	8b 45 14             	mov    0x14(%ebp),%eax
    fc02:	8b 40 28             	mov    0x28(%eax),%eax
    fc05:	85 c0                	test   %eax,%eax
    fc07:	0f 84 ce 02 00 00    	je     fedb <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    fc0d:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fc10:	8b 45 14             	mov    0x14(%ebp),%eax
    fc13:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fc16:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fc1c:	52                   	push   %edx
    fc1d:	ff 75 d0             	pushl  -0x30(%ebp)
    fc20:	50                   	push   %eax
    fc21:	51                   	push   %ecx
    fc22:	e8 23 ee ff ff       	call   ea4a <readChunk_iTXt>
    fc27:	83 c4 10             	add    $0x10,%esp
    fc2a:	89 c2                	mov    %eax,%edx
    fc2c:	8b 45 14             	mov    0x14(%ebp),%eax
    fc2f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fc35:	8b 45 14             	mov    0x14(%ebp),%eax
    fc38:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc3e:	85 c0                	test   %eax,%eax
    fc40:	0f 84 95 02 00 00    	je     fedb <decodeGeneric+0x731>
    fc46:	e9 04 03 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    fc4b:	83 ec 08             	sub    $0x8,%esp
    fc4e:	68 86 a0 01 00       	push   $0x1a086
    fc53:	ff 75 f0             	pushl  -0x10(%ebp)
    fc56:	e8 99 86 ff ff       	call   82f4 <lodepng_chunk_type_equals>
    fc5b:	83 c4 10             	add    $0x10,%esp
    fc5e:	84 c0                	test   %al,%al
    fc60:	74 3d                	je     fc9f <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
    fc62:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fc65:	8b 55 14             	mov    0x14(%ebp),%edx
    fc68:	81 c2 98 00 00 00    	add    $0x98,%edx
    fc6e:	83 ec 04             	sub    $0x4,%esp
    fc71:	50                   	push   %eax
    fc72:	ff 75 d0             	pushl  -0x30(%ebp)
    fc75:	52                   	push   %edx
    fc76:	e8 25 f1 ff ff       	call   eda0 <readChunk_tIME>
    fc7b:	83 c4 10             	add    $0x10,%esp
    fc7e:	89 c2                	mov    %eax,%edx
    fc80:	8b 45 14             	mov    0x14(%ebp),%eax
    fc83:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fc89:	8b 45 14             	mov    0x14(%ebp),%eax
    fc8c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc92:	85 c0                	test   %eax,%eax
    fc94:	0f 84 41 02 00 00    	je     fedb <decodeGeneric+0x731>
    fc9a:	e9 b0 02 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    fc9f:	83 ec 08             	sub    $0x8,%esp
    fca2:	68 8b a0 01 00       	push   $0x1a08b
    fca7:	ff 75 f0             	pushl  -0x10(%ebp)
    fcaa:	e8 45 86 ff ff       	call   82f4 <lodepng_chunk_type_equals>
    fcaf:	83 c4 10             	add    $0x10,%esp
    fcb2:	84 c0                	test   %al,%al
    fcb4:	74 3d                	je     fcf3 <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
    fcb6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fcb9:	8b 55 14             	mov    0x14(%ebp),%edx
    fcbc:	81 c2 98 00 00 00    	add    $0x98,%edx
    fcc2:	83 ec 04             	sub    $0x4,%esp
    fcc5:	50                   	push   %eax
    fcc6:	ff 75 d0             	pushl  -0x30(%ebp)
    fcc9:	52                   	push   %edx
    fcca:	e8 71 f1 ff ff       	call   ee40 <readChunk_pHYs>
    fccf:	83 c4 10             	add    $0x10,%esp
    fcd2:	89 c2                	mov    %eax,%edx
    fcd4:	8b 45 14             	mov    0x14(%ebp),%eax
    fcd7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fcdd:	8b 45 14             	mov    0x14(%ebp),%eax
    fce0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fce6:	85 c0                	test   %eax,%eax
    fce8:	0f 84 ed 01 00 00    	je     fedb <decodeGeneric+0x731>
    fcee:	e9 5c 02 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    fcf3:	83 ec 08             	sub    $0x8,%esp
    fcf6:	68 90 a0 01 00       	push   $0x1a090
    fcfb:	ff 75 f0             	pushl  -0x10(%ebp)
    fcfe:	e8 f1 85 ff ff       	call   82f4 <lodepng_chunk_type_equals>
    fd03:	83 c4 10             	add    $0x10,%esp
    fd06:	84 c0                	test   %al,%al
    fd08:	74 3d                	je     fd47 <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
    fd0a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd0d:	8b 55 14             	mov    0x14(%ebp),%edx
    fd10:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd16:	83 ec 04             	sub    $0x4,%esp
    fd19:	50                   	push   %eax
    fd1a:	ff 75 d0             	pushl  -0x30(%ebp)
    fd1d:	52                   	push   %edx
    fd1e:	e8 ec f1 ff ff       	call   ef0f <readChunk_gAMA>
    fd23:	83 c4 10             	add    $0x10,%esp
    fd26:	89 c2                	mov    %eax,%edx
    fd28:	8b 45 14             	mov    0x14(%ebp),%eax
    fd2b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd31:	8b 45 14             	mov    0x14(%ebp),%eax
    fd34:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd3a:	85 c0                	test   %eax,%eax
    fd3c:	0f 84 99 01 00 00    	je     fedb <decodeGeneric+0x731>
    fd42:	e9 08 02 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    fd47:	83 ec 08             	sub    $0x8,%esp
    fd4a:	68 95 a0 01 00       	push   $0x1a095
    fd4f:	ff 75 f0             	pushl  -0x10(%ebp)
    fd52:	e8 9d 85 ff ff       	call   82f4 <lodepng_chunk_type_equals>
    fd57:	83 c4 10             	add    $0x10,%esp
    fd5a:	84 c0                	test   %al,%al
    fd5c:	74 3d                	je     fd9b <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
    fd5e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd61:	8b 55 14             	mov    0x14(%ebp),%edx
    fd64:	81 c2 98 00 00 00    	add    $0x98,%edx
    fd6a:	83 ec 04             	sub    $0x4,%esp
    fd6d:	50                   	push   %eax
    fd6e:	ff 75 d0             	pushl  -0x30(%ebp)
    fd71:	52                   	push   %edx
    fd72:	e8 07 f2 ff ff       	call   ef7e <readChunk_cHRM>
    fd77:	83 c4 10             	add    $0x10,%esp
    fd7a:	89 c2                	mov    %eax,%edx
    fd7c:	8b 45 14             	mov    0x14(%ebp),%eax
    fd7f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd85:	8b 45 14             	mov    0x14(%ebp),%eax
    fd88:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd8e:	85 c0                	test   %eax,%eax
    fd90:	0f 84 45 01 00 00    	je     fedb <decodeGeneric+0x731>
    fd96:	e9 b4 01 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    fd9b:	83 ec 08             	sub    $0x8,%esp
    fd9e:	68 9a a0 01 00       	push   $0x1a09a
    fda3:	ff 75 f0             	pushl  -0x10(%ebp)
    fda6:	e8 49 85 ff ff       	call   82f4 <lodepng_chunk_type_equals>
    fdab:	83 c4 10             	add    $0x10,%esp
    fdae:	84 c0                	test   %al,%al
    fdb0:	74 3d                	je     fdef <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
    fdb2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fdb5:	8b 55 14             	mov    0x14(%ebp),%edx
    fdb8:	81 c2 98 00 00 00    	add    $0x98,%edx
    fdbe:	83 ec 04             	sub    $0x4,%esp
    fdc1:	50                   	push   %eax
    fdc2:	ff 75 d0             	pushl  -0x30(%ebp)
    fdc5:	52                   	push   %edx
    fdc6:	e8 47 f4 ff ff       	call   f212 <readChunk_sRGB>
    fdcb:	83 c4 10             	add    $0x10,%esp
    fdce:	89 c2                	mov    %eax,%edx
    fdd0:	8b 45 14             	mov    0x14(%ebp),%eax
    fdd3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fdd9:	8b 45 14             	mov    0x14(%ebp),%eax
    fddc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fde2:	85 c0                	test   %eax,%eax
    fde4:	0f 84 f1 00 00 00    	je     fedb <decodeGeneric+0x731>
    fdea:	e9 60 01 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    fdef:	83 ec 08             	sub    $0x8,%esp
    fdf2:	68 9f a0 01 00       	push   $0x1a09f
    fdf7:	ff 75 f0             	pushl  -0x10(%ebp)
    fdfa:	e8 f5 84 ff ff       	call   82f4 <lodepng_chunk_type_equals>
    fdff:	83 c4 10             	add    $0x10,%esp
    fe02:	84 c0                	test   %al,%al
    fe04:	74 3e                	je     fe44 <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    fe06:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fe09:	8b 45 14             	mov    0x14(%ebp),%eax
    fe0c:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fe0f:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fe15:	52                   	push   %edx
    fe16:	ff 75 d0             	pushl  -0x30(%ebp)
    fe19:	50                   	push   %eax
    fe1a:	51                   	push   %ecx
    fe1b:	e8 28 f4 ff ff       	call   f248 <readChunk_iCCP>
    fe20:	83 c4 10             	add    $0x10,%esp
    fe23:	89 c2                	mov    %eax,%edx
    fe25:	8b 45 14             	mov    0x14(%ebp),%eax
    fe28:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fe2e:	8b 45 14             	mov    0x14(%ebp),%eax
    fe31:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe37:	85 c0                	test   %eax,%eax
    fe39:	0f 84 9c 00 00 00    	je     fedb <decodeGeneric+0x731>
    fe3f:	e9 0b 01 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
    fe44:	8b 45 14             	mov    0x14(%ebp),%eax
    fe47:	8b 40 1c             	mov    0x1c(%eax),%eax
    fe4a:	85 c0                	test   %eax,%eax
    fe4c:	75 24                	jne    fe72 <decodeGeneric+0x6c8>
    fe4e:	83 ec 0c             	sub    $0xc,%esp
    fe51:	ff 75 f0             	pushl  -0x10(%ebp)
    fe54:	e8 30 85 ff ff       	call   8389 <lodepng_chunk_ancillary>
    fe59:	83 c4 10             	add    $0x10,%esp
    fe5c:	84 c0                	test   %al,%al
    fe5e:	75 12                	jne    fe72 <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
    fe60:	8b 45 14             	mov    0x14(%ebp),%eax
    fe63:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
    fe6a:	00 00 00 
    fe6d:	e9 dd 00 00 00       	jmp    ff4f <decodeGeneric+0x7a5>
      }

      unknown = 1;
    fe72:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
    fe79:	8b 45 14             	mov    0x14(%ebp),%eax
    fe7c:	8b 40 2c             	mov    0x2c(%eax),%eax
    fe7f:	85 c0                	test   %eax,%eax
    fe81:	74 58                	je     fedb <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
    fe83:	8b 45 dc             	mov    -0x24(%ebp),%eax
    fe86:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
    fe89:	83 c0 58             	add    $0x58,%eax
    fe8c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    fe93:	8b 45 14             	mov    0x14(%ebp),%eax
    fe96:	01 d0                	add    %edx,%eax
    fe98:	8d 50 10             	lea    0x10(%eax),%edx
    fe9b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    fe9e:	83 e8 01             	sub    $0x1,%eax
    fea1:	83 c0 54             	add    $0x54,%eax
    fea4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    feab:	8b 45 14             	mov    0x14(%ebp),%eax
    feae:	01 c8                	add    %ecx,%eax
    feb0:	83 c0 14             	add    $0x14,%eax
    feb3:	83 ec 04             	sub    $0x4,%esp
    feb6:	ff 75 f0             	pushl  -0x10(%ebp)
    feb9:	52                   	push   %edx
    feba:	50                   	push   %eax
    febb:	e8 15 88 ff ff       	call   86d5 <lodepng_chunk_append>
    fec0:	83 c4 10             	add    $0x10,%esp
    fec3:	89 c2                	mov    %eax,%edx
    fec5:	8b 45 14             	mov    0x14(%ebp),%eax
    fec8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    fece:	8b 45 14             	mov    0x14(%ebp),%eax
    fed1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fed7:	85 c0                	test   %eax,%eax
    fed9:	75 73                	jne    ff4e <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
    fedb:	8b 45 14             	mov    0x14(%ebp),%eax
    fede:	8b 40 18             	mov    0x18(%eax),%eax
    fee1:	85 c0                	test   %eax,%eax
    fee3:	75 27                	jne    ff0c <decodeGeneric+0x762>
    fee5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    fee9:	75 21                	jne    ff0c <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
    feeb:	83 ec 0c             	sub    $0xc,%esp
    feee:	ff 75 f0             	pushl  -0x10(%ebp)
    fef1:	e8 f4 84 ff ff       	call   83ea <lodepng_chunk_check_crc>
    fef6:	83 c4 10             	add    $0x10,%esp
    fef9:	85 c0                	test   %eax,%eax
    fefb:	74 0f                	je     ff0c <decodeGeneric+0x762>
    fefd:	8b 45 14             	mov    0x14(%ebp),%eax
    ff00:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    ff07:	00 00 00 
    ff0a:	eb 43                	jmp    ff4f <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
    ff0c:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    ff10:	75 1a                	jne    ff2c <decodeGeneric+0x782>
    ff12:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ff15:	8b 45 18             	mov    0x18(%ebp),%eax
    ff18:	01 d0                	add    %edx,%eax
    ff1a:	83 ec 08             	sub    $0x8,%esp
    ff1d:	50                   	push   %eax
    ff1e:	ff 75 f0             	pushl  -0x10(%ebp)
    ff21:	e8 3f 86 ff ff       	call   8565 <lodepng_chunk_next_const>
    ff26:	83 c4 10             	add    $0x10,%esp
    ff29:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    ff2c:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    ff30:	75 1d                	jne    ff4f <decodeGeneric+0x7a5>
    ff32:	8b 45 14             	mov    0x14(%ebp),%eax
    ff35:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff3b:	85 c0                	test   %eax,%eax
    ff3d:	0f 84 68 f9 ff ff    	je     f8ab <decodeGeneric+0x101>
    ff43:	eb 0a                	jmp    ff4f <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    ff45:	90                   	nop
    ff46:	eb 07                	jmp    ff4f <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    ff48:	90                   	nop
    ff49:	eb 04                	jmp    ff4f <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
    ff4b:	90                   	nop
    ff4c:	eb 01                	jmp    ff4f <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
    ff4e:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
    ff4f:	8b 45 14             	mov    0x14(%ebp),%eax
    ff52:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff58:	85 c0                	test   %eax,%eax
    ff5a:	75 28                	jne    ff84 <decodeGeneric+0x7da>
    ff5c:	8b 45 14             	mov    0x14(%ebp),%eax
    ff5f:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
    ff65:	83 f8 03             	cmp    $0x3,%eax
    ff68:	75 1a                	jne    ff84 <decodeGeneric+0x7da>
    ff6a:	8b 45 14             	mov    0x14(%ebp),%eax
    ff6d:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
    ff73:	85 c0                	test   %eax,%eax
    ff75:	75 0d                	jne    ff84 <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
    ff77:	8b 45 14             	mov    0x14(%ebp),%eax
    ff7a:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
    ff81:	00 00 00 
  }

  if(!state->error) {
    ff84:	8b 45 14             	mov    0x14(%ebp),%eax
    ff87:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff8d:	85 c0                	test   %eax,%eax
    ff8f:	0f 85 d2 01 00 00    	jne    10167 <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
    ff95:	8b 45 14             	mov    0x14(%ebp),%eax
    ff98:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
    ff9e:	85 c0                	test   %eax,%eax
    ffa0:	75 3a                	jne    ffdc <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
    ffa2:	8b 45 14             	mov    0x14(%ebp),%eax
    ffa5:	05 a4 00 00 00       	add    $0xa4,%eax
    ffaa:	83 ec 0c             	sub    $0xc,%esp
    ffad:	50                   	push   %eax
    ffae:	e8 8e 8e ff ff       	call   8e41 <lodepng_get_bpp>
    ffb3:	83 c4 10             	add    $0x10,%esp
    ffb6:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
    ffb9:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    ffbc:	8b 45 10             	mov    0x10(%ebp),%eax
    ffbf:	8b 10                	mov    (%eax),%edx
    ffc1:	8b 45 0c             	mov    0xc(%ebp),%eax
    ffc4:	8b 00                	mov    (%eax),%eax
    ffc6:	83 ec 04             	sub    $0x4,%esp
    ffc9:	51                   	push   %ecx
    ffca:	52                   	push   %edx
    ffcb:	50                   	push   %eax
    ffcc:	e8 cf 8f ff ff       	call   8fa0 <lodepng_get_raw_size_idat>
    ffd1:	83 c4 10             	add    $0x10,%esp
    ffd4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    ffd7:	e9 60 01 00 00       	jmp    1013c <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
    ffdc:	8b 45 14             	mov    0x14(%ebp),%eax
    ffdf:	05 a4 00 00 00       	add    $0xa4,%eax
    ffe4:	83 ec 0c             	sub    $0xc,%esp
    ffe7:	50                   	push   %eax
    ffe8:	e8 54 8e ff ff       	call   8e41 <lodepng_get_bpp>
    ffed:	83 c4 10             	add    $0x10,%esp
    fff0:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
    fff3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
    fffa:	8b 45 c8             	mov    -0x38(%ebp),%eax
    fffd:	8b 55 10             	mov    0x10(%ebp),%edx
   10000:	8b 12                	mov    (%edx),%edx
   10002:	83 c2 07             	add    $0x7,%edx
   10005:	89 d1                	mov    %edx,%ecx
   10007:	c1 e9 03             	shr    $0x3,%ecx
   1000a:	8b 55 0c             	mov    0xc(%ebp),%edx
   1000d:	8b 12                	mov    (%edx),%edx
   1000f:	83 c2 07             	add    $0x7,%edx
   10012:	c1 ea 03             	shr    $0x3,%edx
   10015:	83 ec 04             	sub    $0x4,%esp
   10018:	50                   	push   %eax
   10019:	51                   	push   %ecx
   1001a:	52                   	push   %edx
   1001b:	e8 80 8f ff ff       	call   8fa0 <lodepng_get_raw_size_idat>
   10020:	83 c4 10             	add    $0x10,%esp
   10023:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   10026:	8b 45 0c             	mov    0xc(%ebp),%eax
   10029:	8b 00                	mov    (%eax),%eax
   1002b:	83 f8 04             	cmp    $0x4,%eax
   1002e:	76 2c                	jbe    1005c <decodeGeneric+0x8b2>
   10030:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10033:	8b 55 10             	mov    0x10(%ebp),%edx
   10036:	8b 12                	mov    (%edx),%edx
   10038:	83 c2 07             	add    $0x7,%edx
   1003b:	89 d1                	mov    %edx,%ecx
   1003d:	c1 e9 03             	shr    $0x3,%ecx
   10040:	8b 55 0c             	mov    0xc(%ebp),%edx
   10043:	8b 12                	mov    (%edx),%edx
   10045:	83 c2 03             	add    $0x3,%edx
   10048:	c1 ea 03             	shr    $0x3,%edx
   1004b:	83 ec 04             	sub    $0x4,%esp
   1004e:	50                   	push   %eax
   1004f:	51                   	push   %ecx
   10050:	52                   	push   %edx
   10051:	e8 4a 8f ff ff       	call   8fa0 <lodepng_get_raw_size_idat>
   10056:	83 c4 10             	add    $0x10,%esp
   10059:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   1005c:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1005f:	8b 55 10             	mov    0x10(%ebp),%edx
   10062:	8b 12                	mov    (%edx),%edx
   10064:	83 c2 03             	add    $0x3,%edx
   10067:	89 d1                	mov    %edx,%ecx
   10069:	c1 e9 03             	shr    $0x3,%ecx
   1006c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1006f:	8b 12                	mov    (%edx),%edx
   10071:	83 c2 03             	add    $0x3,%edx
   10074:	c1 ea 02             	shr    $0x2,%edx
   10077:	83 ec 04             	sub    $0x4,%esp
   1007a:	50                   	push   %eax
   1007b:	51                   	push   %ecx
   1007c:	52                   	push   %edx
   1007d:	e8 1e 8f ff ff       	call   8fa0 <lodepng_get_raw_size_idat>
   10082:	83 c4 10             	add    $0x10,%esp
   10085:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   10088:	8b 45 0c             	mov    0xc(%ebp),%eax
   1008b:	8b 00                	mov    (%eax),%eax
   1008d:	83 f8 02             	cmp    $0x2,%eax
   10090:	76 2c                	jbe    100be <decodeGeneric+0x914>
   10092:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10095:	8b 55 10             	mov    0x10(%ebp),%edx
   10098:	8b 12                	mov    (%edx),%edx
   1009a:	83 c2 03             	add    $0x3,%edx
   1009d:	89 d1                	mov    %edx,%ecx
   1009f:	c1 e9 02             	shr    $0x2,%ecx
   100a2:	8b 55 0c             	mov    0xc(%ebp),%edx
   100a5:	8b 12                	mov    (%edx),%edx
   100a7:	83 c2 01             	add    $0x1,%edx
   100aa:	c1 ea 02             	shr    $0x2,%edx
   100ad:	83 ec 04             	sub    $0x4,%esp
   100b0:	50                   	push   %eax
   100b1:	51                   	push   %ecx
   100b2:	52                   	push   %edx
   100b3:	e8 e8 8e ff ff       	call   8fa0 <lodepng_get_raw_size_idat>
   100b8:	83 c4 10             	add    $0x10,%esp
   100bb:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   100be:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100c1:	8b 55 10             	mov    0x10(%ebp),%edx
   100c4:	8b 12                	mov    (%edx),%edx
   100c6:	83 c2 01             	add    $0x1,%edx
   100c9:	89 d1                	mov    %edx,%ecx
   100cb:	c1 e9 02             	shr    $0x2,%ecx
   100ce:	8b 55 0c             	mov    0xc(%ebp),%edx
   100d1:	8b 12                	mov    (%edx),%edx
   100d3:	83 c2 01             	add    $0x1,%edx
   100d6:	d1 ea                	shr    %edx
   100d8:	83 ec 04             	sub    $0x4,%esp
   100db:	50                   	push   %eax
   100dc:	51                   	push   %ecx
   100dd:	52                   	push   %edx
   100de:	e8 bd 8e ff ff       	call   8fa0 <lodepng_get_raw_size_idat>
   100e3:	83 c4 10             	add    $0x10,%esp
   100e6:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   100e9:	8b 45 0c             	mov    0xc(%ebp),%eax
   100ec:	8b 00                	mov    (%eax),%eax
   100ee:	83 f8 01             	cmp    $0x1,%eax
   100f1:	76 27                	jbe    1011a <decodeGeneric+0x970>
   100f3:	8b 45 c8             	mov    -0x38(%ebp),%eax
   100f6:	8b 55 10             	mov    0x10(%ebp),%edx
   100f9:	8b 12                	mov    (%edx),%edx
   100fb:	83 c2 01             	add    $0x1,%edx
   100fe:	89 d1                	mov    %edx,%ecx
   10100:	d1 e9                	shr    %ecx
   10102:	8b 55 0c             	mov    0xc(%ebp),%edx
   10105:	8b 12                	mov    (%edx),%edx
   10107:	d1 ea                	shr    %edx
   10109:	83 ec 04             	sub    $0x4,%esp
   1010c:	50                   	push   %eax
   1010d:	51                   	push   %ecx
   1010e:	52                   	push   %edx
   1010f:	e8 8c 8e ff ff       	call   8fa0 <lodepng_get_raw_size_idat>
   10114:	83 c4 10             	add    $0x10,%esp
   10117:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   1011a:	8b 55 c8             	mov    -0x38(%ebp),%edx
   1011d:	8b 45 10             	mov    0x10(%ebp),%eax
   10120:	8b 00                	mov    (%eax),%eax
   10122:	d1 e8                	shr    %eax
   10124:	89 c1                	mov    %eax,%ecx
   10126:	8b 45 0c             	mov    0xc(%ebp),%eax
   10129:	8b 00                	mov    (%eax),%eax
   1012b:	83 ec 04             	sub    $0x4,%esp
   1012e:	52                   	push   %edx
   1012f:	51                   	push   %ecx
   10130:	50                   	push   %eax
   10131:	e8 6a 8e ff ff       	call   8fa0 <lodepng_get_raw_size_idat>
   10136:	83 c4 10             	add    $0x10,%esp
   10139:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   1013c:	8b 45 14             	mov    0x14(%ebp),%eax
   1013f:	83 ec 08             	sub    $0x8,%esp
   10142:	50                   	push   %eax
   10143:	ff 75 ec             	pushl  -0x14(%ebp)
   10146:	ff 75 d8             	pushl  -0x28(%ebp)
   10149:	ff 75 e8             	pushl  -0x18(%ebp)
   1014c:	8d 45 c0             	lea    -0x40(%ebp),%eax
   1014f:	50                   	push   %eax
   10150:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   10153:	50                   	push   %eax
   10154:	e8 87 7c ff ff       	call   7de0 <zlib_decompress>
   10159:	83 c4 20             	add    $0x20,%esp
   1015c:	89 c2                	mov    %eax,%edx
   1015e:	8b 45 14             	mov    0x14(%ebp),%eax
   10161:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   10167:	8b 45 14             	mov    0x14(%ebp),%eax
   1016a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10170:	85 c0                	test   %eax,%eax
   10172:	75 15                	jne    10189 <decodeGeneric+0x9df>
   10174:	8b 45 c0             	mov    -0x40(%ebp),%eax
   10177:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1017a:	74 0d                	je     10189 <decodeGeneric+0x9df>
   1017c:	8b 45 14             	mov    0x14(%ebp),%eax
   1017f:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   10186:	00 00 00 
  lodepng_free(idat);
   10189:	83 ec 0c             	sub    $0xc,%esp
   1018c:	ff 75 d8             	pushl  -0x28(%ebp)
   1018f:	e8 b2 31 ff ff       	call   3346 <lodepng_free>
   10194:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   10197:	8b 45 14             	mov    0x14(%ebp),%eax
   1019a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   101a0:	85 c0                	test   %eax,%eax
   101a2:	75 4f                	jne    101f3 <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   101a4:	8b 45 14             	mov    0x14(%ebp),%eax
   101a7:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   101ad:	8b 45 10             	mov    0x10(%ebp),%eax
   101b0:	8b 10                	mov    (%eax),%edx
   101b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   101b5:	8b 00                	mov    (%eax),%eax
   101b7:	83 ec 04             	sub    $0x4,%esp
   101ba:	51                   	push   %ecx
   101bb:	52                   	push   %edx
   101bc:	50                   	push   %eax
   101bd:	e8 be 8d ff ff       	call   8f80 <lodepng_get_raw_size>
   101c2:	83 c4 10             	add    $0x10,%esp
   101c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   101c8:	83 ec 0c             	sub    $0xc,%esp
   101cb:	ff 75 e4             	pushl  -0x1c(%ebp)
   101ce:	e8 52 31 ff ff       	call   3325 <lodepng_malloc>
   101d3:	83 c4 10             	add    $0x10,%esp
   101d6:	89 c2                	mov    %eax,%edx
   101d8:	8b 45 08             	mov    0x8(%ebp),%eax
   101db:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   101dd:	8b 45 08             	mov    0x8(%ebp),%eax
   101e0:	8b 00                	mov    (%eax),%eax
   101e2:	85 c0                	test   %eax,%eax
   101e4:	75 0d                	jne    101f3 <decodeGeneric+0xa49>
   101e6:	8b 45 14             	mov    0x14(%ebp),%eax
   101e9:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   101f0:	00 00 00 
  }
  if(!state->error) {
   101f3:	8b 45 14             	mov    0x14(%ebp),%eax
   101f6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   101fc:	85 c0                	test   %eax,%eax
   101fe:	75 4c                	jne    1024c <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   10200:	8b 45 08             	mov    0x8(%ebp),%eax
   10203:	8b 00                	mov    (%eax),%eax
   10205:	83 ec 04             	sub    $0x4,%esp
   10208:	ff 75 e4             	pushl  -0x1c(%ebp)
   1020b:	6a 00                	push   $0x0
   1020d:	50                   	push   %eax
   1020e:	e8 83 31 ff ff       	call   3396 <lodepng_memset>
   10213:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   10216:	8b 45 14             	mov    0x14(%ebp),%eax
   10219:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   1021f:	8b 45 10             	mov    0x10(%ebp),%eax
   10222:	8b 18                	mov    (%eax),%ebx
   10224:	8b 45 0c             	mov    0xc(%ebp),%eax
   10227:	8b 08                	mov    (%eax),%ecx
   10229:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   1022c:	8b 45 08             	mov    0x8(%ebp),%eax
   1022f:	8b 00                	mov    (%eax),%eax
   10231:	83 ec 0c             	sub    $0xc,%esp
   10234:	56                   	push   %esi
   10235:	53                   	push   %ebx
   10236:	51                   	push   %ecx
   10237:	52                   	push   %edx
   10238:	50                   	push   %eax
   10239:	e8 05 df ff ff       	call   e143 <postProcessScanlines>
   1023e:	83 c4 20             	add    $0x20,%esp
   10241:	89 c2                	mov    %eax,%edx
   10243:	8b 45 14             	mov    0x14(%ebp),%eax
   10246:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   1024c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1024f:	83 ec 0c             	sub    $0xc,%esp
   10252:	50                   	push   %eax
   10253:	e8 ee 30 ff ff       	call   3346 <lodepng_free>
   10258:	83 c4 10             	add    $0x10,%esp
   1025b:	eb 01                	jmp    1025e <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   1025d:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   1025e:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10261:	5b                   	pop    %ebx
   10262:	5e                   	pop    %esi
   10263:	5d                   	pop    %ebp
   10264:	c3                   	ret    

00010265 <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   10265:	55                   	push   %ebp
   10266:	89 e5                	mov    %esp,%ebp
   10268:	56                   	push   %esi
   10269:	53                   	push   %ebx
   1026a:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   1026d:	8b 45 08             	mov    0x8(%ebp),%eax
   10270:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   10276:	83 ec 08             	sub    $0x8,%esp
   10279:	ff 75 1c             	pushl  0x1c(%ebp)
   1027c:	ff 75 18             	pushl  0x18(%ebp)
   1027f:	ff 75 14             	pushl  0x14(%ebp)
   10282:	ff 75 10             	pushl  0x10(%ebp)
   10285:	ff 75 0c             	pushl  0xc(%ebp)
   10288:	ff 75 08             	pushl  0x8(%ebp)
   1028b:	e8 1a f5 ff ff       	call   f7aa <decodeGeneric>
   10290:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   10293:	8b 45 14             	mov    0x14(%ebp),%eax
   10296:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1029c:	85 c0                	test   %eax,%eax
   1029e:	74 0e                	je     102ae <lodepng_decode+0x49>
   102a0:	8b 45 14             	mov    0x14(%ebp),%eax
   102a3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   102a9:	e9 55 01 00 00       	jmp    10403 <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   102ae:	8b 45 14             	mov    0x14(%ebp),%eax
   102b1:	8b 40 24             	mov    0x24(%eax),%eax
   102b4:	85 c0                	test   %eax,%eax
   102b6:	74 20                	je     102d8 <lodepng_decode+0x73>
   102b8:	8b 45 14             	mov    0x14(%ebp),%eax
   102bb:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   102c1:	8b 45 14             	mov    0x14(%ebp),%eax
   102c4:	83 c0 78             	add    $0x78,%eax
   102c7:	83 ec 08             	sub    $0x8,%esp
   102ca:	52                   	push   %edx
   102cb:	50                   	push   %eax
   102cc:	e8 56 89 ff ff       	call   8c27 <lodepng_color_mode_equal>
   102d1:	83 c4 10             	add    $0x10,%esp
   102d4:	85 c0                	test   %eax,%eax
   102d6:	74 54                	je     1032c <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   102d8:	8b 45 14             	mov    0x14(%ebp),%eax
   102db:	8b 40 24             	mov    0x24(%eax),%eax
   102de:	85 c0                	test   %eax,%eax
   102e0:	0f 85 13 01 00 00    	jne    103f9 <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   102e6:	8b 45 14             	mov    0x14(%ebp),%eax
   102e9:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   102ef:	8b 45 14             	mov    0x14(%ebp),%eax
   102f2:	83 c0 78             	add    $0x78,%eax
   102f5:	83 ec 08             	sub    $0x8,%esp
   102f8:	52                   	push   %edx
   102f9:	50                   	push   %eax
   102fa:	e8 3f 88 ff ff       	call   8b3e <lodepng_color_mode_copy>
   102ff:	83 c4 10             	add    $0x10,%esp
   10302:	89 c2                	mov    %eax,%edx
   10304:	8b 45 14             	mov    0x14(%ebp),%eax
   10307:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   1030d:	8b 45 14             	mov    0x14(%ebp),%eax
   10310:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10316:	85 c0                	test   %eax,%eax
   10318:	0f 84 db 00 00 00    	je     103f9 <lodepng_decode+0x194>
   1031e:	8b 45 14             	mov    0x14(%ebp),%eax
   10321:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10327:	e9 d7 00 00 00       	jmp    10403 <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   1032c:	8b 45 08             	mov    0x8(%ebp),%eax
   1032f:	8b 00                	mov    (%eax),%eax
   10331:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   10334:	8b 45 14             	mov    0x14(%ebp),%eax
   10337:	8b 40 78             	mov    0x78(%eax),%eax
   1033a:	83 f8 02             	cmp    $0x2,%eax
   1033d:	74 20                	je     1035f <lodepng_decode+0xfa>
   1033f:	8b 45 14             	mov    0x14(%ebp),%eax
   10342:	8b 40 78             	mov    0x78(%eax),%eax
   10345:	83 f8 06             	cmp    $0x6,%eax
   10348:	74 15                	je     1035f <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   1034a:	8b 45 14             	mov    0x14(%ebp),%eax
   1034d:	8b 40 7c             	mov    0x7c(%eax),%eax
   10350:	83 f8 08             	cmp    $0x8,%eax
   10353:	74 0a                	je     1035f <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   10355:	b8 38 00 00 00       	mov    $0x38,%eax
   1035a:	e9 a4 00 00 00       	jmp    10403 <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   1035f:	8b 45 14             	mov    0x14(%ebp),%eax
   10362:	8d 48 78             	lea    0x78(%eax),%ecx
   10365:	8b 45 10             	mov    0x10(%ebp),%eax
   10368:	8b 10                	mov    (%eax),%edx
   1036a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1036d:	8b 00                	mov    (%eax),%eax
   1036f:	83 ec 04             	sub    $0x4,%esp
   10372:	51                   	push   %ecx
   10373:	52                   	push   %edx
   10374:	50                   	push   %eax
   10375:	e8 06 8c ff ff       	call   8f80 <lodepng_get_raw_size>
   1037a:	83 c4 10             	add    $0x10,%esp
   1037d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   10380:	83 ec 0c             	sub    $0xc,%esp
   10383:	ff 75 f0             	pushl  -0x10(%ebp)
   10386:	e8 9a 2f ff ff       	call   3325 <lodepng_malloc>
   1038b:	83 c4 10             	add    $0x10,%esp
   1038e:	89 c2                	mov    %eax,%edx
   10390:	8b 45 08             	mov    0x8(%ebp),%eax
   10393:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   10395:	8b 45 08             	mov    0x8(%ebp),%eax
   10398:	8b 00                	mov    (%eax),%eax
   1039a:	85 c0                	test   %eax,%eax
   1039c:	75 0f                	jne    103ad <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   1039e:	8b 45 14             	mov    0x14(%ebp),%eax
   103a1:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   103a8:	00 00 00 
   103ab:	eb 3c                	jmp    103e9 <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   103ad:	8b 45 10             	mov    0x10(%ebp),%eax
   103b0:	8b 08                	mov    (%eax),%ecx
   103b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   103b5:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   103b7:	8b 45 14             	mov    0x14(%ebp),%eax
   103ba:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   103c0:	8b 45 14             	mov    0x14(%ebp),%eax
   103c3:	8d 58 78             	lea    0x78(%eax),%ebx
   103c6:	8b 45 08             	mov    0x8(%ebp),%eax
   103c9:	8b 00                	mov    (%eax),%eax
   103cb:	83 ec 08             	sub    $0x8,%esp
   103ce:	51                   	push   %ecx
   103cf:	52                   	push   %edx
   103d0:	56                   	push   %esi
   103d1:	53                   	push   %ebx
   103d2:	ff 75 f4             	pushl  -0xc(%ebp)
   103d5:	50                   	push   %eax
   103d6:	e8 51 b6 ff ff       	call   ba2c <lodepng_convert>
   103db:	83 c4 20             	add    $0x20,%esp
   103de:	89 c2                	mov    %eax,%edx
   103e0:	8b 45 14             	mov    0x14(%ebp),%eax
   103e3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   103e9:	83 ec 0c             	sub    $0xc,%esp
   103ec:	ff 75 f4             	pushl  -0xc(%ebp)
   103ef:	e8 52 2f ff ff       	call   3346 <lodepng_free>
   103f4:	83 c4 10             	add    $0x10,%esp
   103f7:	eb 01                	jmp    103fa <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   103f9:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   103fa:	8b 45 14             	mov    0x14(%ebp),%eax
   103fd:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   10403:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10406:	5b                   	pop    %ebx
   10407:	5e                   	pop    %esi
   10408:	5d                   	pop    %ebp
   10409:	c3                   	ret    

0001040a <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   1040a:	55                   	push   %ebp
   1040b:	89 e5                	mov    %esp,%ebp
   1040d:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   10413:	83 ec 0c             	sub    $0xc,%esp
   10416:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1041c:	50                   	push   %eax
   1041d:	e8 d9 01 00 00       	call   105fb <lodepng_state_init>
   10422:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   10425:	8b 45 1c             	mov    0x1c(%ebp),%eax
   10428:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   1042e:	8b 45 20             	mov    0x20(%ebp),%eax
   10431:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   10437:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   1043e:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   10441:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   10448:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   1044b:	83 ec 08             	sub    $0x8,%esp
   1044e:	ff 75 18             	pushl  0x18(%ebp)
   10451:	ff 75 14             	pushl  0x14(%ebp)
   10454:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1045a:	50                   	push   %eax
   1045b:	ff 75 10             	pushl  0x10(%ebp)
   1045e:	ff 75 0c             	pushl  0xc(%ebp)
   10461:	ff 75 08             	pushl  0x8(%ebp)
   10464:	e8 fc fd ff ff       	call   10265 <lodepng_decode>
   10469:	83 c4 20             	add    $0x20,%esp
   1046c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   1046f:	83 ec 0c             	sub    $0xc,%esp
   10472:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10478:	50                   	push   %eax
   10479:	e8 d7 01 00 00       	call   10655 <lodepng_state_cleanup>
   1047e:	83 c4 10             	add    $0x10,%esp
  return error;
   10481:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10484:	c9                   	leave  
   10485:	c3                   	ret    

00010486 <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10486:	55                   	push   %ebp
   10487:	89 e5                	mov    %esp,%ebp
   10489:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   1048c:	83 ec 04             	sub    $0x4,%esp
   1048f:	6a 08                	push   $0x8
   10491:	6a 06                	push   $0x6
   10493:	ff 75 18             	pushl  0x18(%ebp)
   10496:	ff 75 14             	pushl  0x14(%ebp)
   10499:	ff 75 10             	pushl  0x10(%ebp)
   1049c:	ff 75 0c             	pushl  0xc(%ebp)
   1049f:	ff 75 08             	pushl  0x8(%ebp)
   104a2:	e8 63 ff ff ff       	call   1040a <lodepng_decode_memory>
   104a7:	83 c4 20             	add    $0x20,%esp
}
   104aa:	c9                   	leave  
   104ab:	c3                   	ret    

000104ac <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   104ac:	55                   	push   %ebp
   104ad:	89 e5                	mov    %esp,%ebp
   104af:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   104b2:	83 ec 04             	sub    $0x4,%esp
   104b5:	6a 08                	push   $0x8
   104b7:	6a 02                	push   $0x2
   104b9:	ff 75 18             	pushl  0x18(%ebp)
   104bc:	ff 75 14             	pushl  0x14(%ebp)
   104bf:	ff 75 10             	pushl  0x10(%ebp)
   104c2:	ff 75 0c             	pushl  0xc(%ebp)
   104c5:	ff 75 08             	pushl  0x8(%ebp)
   104c8:	e8 3d ff ff ff       	call   1040a <lodepng_decode_memory>
   104cd:	83 c4 20             	add    $0x20,%esp
}
   104d0:	c9                   	leave  
   104d1:	c3                   	ret    

000104d2 <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   104d2:	55                   	push   %ebp
   104d3:	89 e5                	mov    %esp,%ebp
   104d5:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   104d8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   104df:	8b 45 08             	mov    0x8(%ebp),%eax
   104e2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   104e8:	8b 45 10             	mov    0x10(%ebp),%eax
   104eb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   104f1:	8b 45 10             	mov    0x10(%ebp),%eax
   104f4:	8b 10                	mov    (%eax),%edx
   104f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   104f9:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   104fb:	83 ec 04             	sub    $0x4,%esp
   104fe:	ff 75 14             	pushl  0x14(%ebp)
   10501:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10504:	50                   	push   %eax
   10505:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10508:	50                   	push   %eax
   10509:	e8 70 32 ff ff       	call   377e <lodepng_load_file>
   1050e:	83 c4 10             	add    $0x10,%esp
   10511:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   10514:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10518:	75 25                	jne    1053f <lodepng_decode_file+0x6d>
   1051a:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1051d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10520:	83 ec 04             	sub    $0x4,%esp
   10523:	ff 75 1c             	pushl  0x1c(%ebp)
   10526:	ff 75 18             	pushl  0x18(%ebp)
   10529:	52                   	push   %edx
   1052a:	50                   	push   %eax
   1052b:	ff 75 10             	pushl  0x10(%ebp)
   1052e:	ff 75 0c             	pushl  0xc(%ebp)
   10531:	ff 75 08             	pushl  0x8(%ebp)
   10534:	e8 d1 fe ff ff       	call   1040a <lodepng_decode_memory>
   10539:	83 c4 20             	add    $0x20,%esp
   1053c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   1053f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10542:	83 ec 0c             	sub    $0xc,%esp
   10545:	50                   	push   %eax
   10546:	e8 fb 2d ff ff       	call   3346 <lodepng_free>
   1054b:	83 c4 10             	add    $0x10,%esp
  return error;
   1054e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10551:	c9                   	leave  
   10552:	c3                   	ret    

00010553 <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10553:	55                   	push   %ebp
   10554:	89 e5                	mov    %esp,%ebp
   10556:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   10559:	83 ec 08             	sub    $0x8,%esp
   1055c:	6a 08                	push   $0x8
   1055e:	6a 06                	push   $0x6
   10560:	ff 75 14             	pushl  0x14(%ebp)
   10563:	ff 75 10             	pushl  0x10(%ebp)
   10566:	ff 75 0c             	pushl  0xc(%ebp)
   10569:	ff 75 08             	pushl  0x8(%ebp)
   1056c:	e8 61 ff ff ff       	call   104d2 <lodepng_decode_file>
   10571:	83 c4 20             	add    $0x20,%esp
}
   10574:	c9                   	leave  
   10575:	c3                   	ret    

00010576 <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10576:	55                   	push   %ebp
   10577:	89 e5                	mov    %esp,%ebp
   10579:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   1057c:	83 ec 08             	sub    $0x8,%esp
   1057f:	6a 08                	push   $0x8
   10581:	6a 02                	push   $0x2
   10583:	ff 75 14             	pushl  0x14(%ebp)
   10586:	ff 75 10             	pushl  0x10(%ebp)
   10589:	ff 75 0c             	pushl  0xc(%ebp)
   1058c:	ff 75 08             	pushl  0x8(%ebp)
   1058f:	e8 3e ff ff ff       	call   104d2 <lodepng_decode_file>
   10594:	83 c4 20             	add    $0x20,%esp
}
   10597:	c9                   	leave  
   10598:	c3                   	ret    

00010599 <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   10599:	55                   	push   %ebp
   1059a:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   1059c:	8b 45 08             	mov    0x8(%ebp),%eax
   1059f:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   105a6:	8b 45 08             	mov    0x8(%ebp),%eax
   105a9:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   105b0:	8b 45 08             	mov    0x8(%ebp),%eax
   105b3:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   105ba:	8b 45 08             	mov    0x8(%ebp),%eax
   105bd:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   105c4:	8b 45 08             	mov    0x8(%ebp),%eax
   105c7:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   105ce:	8b 45 08             	mov    0x8(%ebp),%eax
   105d1:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   105d8:	8b 45 08             	mov    0x8(%ebp),%eax
   105db:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   105e2:	8b 45 08             	mov    0x8(%ebp),%eax
   105e5:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   105ec:	8b 45 08             	mov    0x8(%ebp),%eax
   105ef:	50                   	push   %eax
   105f0:	e8 ff 7a ff ff       	call   80f4 <lodepng_decompress_settings_init>
   105f5:	83 c4 04             	add    $0x4,%esp
}
   105f8:	90                   	nop
   105f9:	c9                   	leave  
   105fa:	c3                   	ret    

000105fb <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   105fb:	55                   	push   %ebp
   105fc:	89 e5                	mov    %esp,%ebp
   105fe:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   10601:	8b 45 08             	mov    0x8(%ebp),%eax
   10604:	50                   	push   %eax
   10605:	e8 8f ff ff ff       	call   10599 <lodepng_decoder_settings_init>
   1060a:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   1060d:	8b 45 08             	mov    0x8(%ebp),%eax
   10610:	83 c0 38             	add    $0x38,%eax
   10613:	83 ec 0c             	sub    $0xc,%esp
   10616:	50                   	push   %eax
   10617:	e8 fc 30 00 00       	call   13718 <lodepng_encoder_settings_init>
   1061c:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   1061f:	8b 45 08             	mov    0x8(%ebp),%eax
   10622:	83 c0 78             	add    $0x78,%eax
   10625:	83 ec 0c             	sub    $0xc,%esp
   10628:	50                   	push   %eax
   10629:	e8 06 84 ff ff       	call   8a34 <lodepng_color_mode_init>
   1062e:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   10631:	8b 45 08             	mov    0x8(%ebp),%eax
   10634:	05 98 00 00 00       	add    $0x98,%eax
   10639:	83 ec 0c             	sub    $0xc,%esp
   1063c:	50                   	push   %eax
   1063d:	e8 89 93 ff ff       	call   99cb <lodepng_info_init>
   10642:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   10645:	8b 45 08             	mov    0x8(%ebp),%eax
   10648:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   1064f:	00 00 00 
}
   10652:	90                   	nop
   10653:	c9                   	leave  
   10654:	c3                   	ret    

00010655 <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   10655:	55                   	push   %ebp
   10656:	89 e5                	mov    %esp,%ebp
   10658:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   1065b:	8b 45 08             	mov    0x8(%ebp),%eax
   1065e:	83 c0 78             	add    $0x78,%eax
   10661:	83 ec 0c             	sub    $0xc,%esp
   10664:	50                   	push   %eax
   10665:	e8 bd 84 ff ff       	call   8b27 <lodepng_color_mode_cleanup>
   1066a:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   1066d:	8b 45 08             	mov    0x8(%ebp),%eax
   10670:	05 98 00 00 00       	add    $0x98,%eax
   10675:	83 ec 0c             	sub    $0xc,%esp
   10678:	50                   	push   %eax
   10679:	e8 2e 94 ff ff       	call   9aac <lodepng_info_cleanup>
   1067e:	83 c4 10             	add    $0x10,%esp
}
   10681:	90                   	nop
   10682:	c9                   	leave  
   10683:	c3                   	ret    

00010684 <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   10684:	55                   	push   %ebp
   10685:	89 e5                	mov    %esp,%ebp
   10687:	57                   	push   %edi
   10688:	56                   	push   %esi
   10689:	53                   	push   %ebx
   1068a:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   1068d:	83 ec 0c             	sub    $0xc,%esp
   10690:	ff 75 08             	pushl  0x8(%ebp)
   10693:	e8 bd ff ff ff       	call   10655 <lodepng_state_cleanup>
   10698:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   1069b:	8b 55 08             	mov    0x8(%ebp),%edx
   1069e:	8b 45 0c             	mov    0xc(%ebp),%eax
   106a1:	89 c3                	mov    %eax,%ebx
   106a3:	b8 60 00 00 00       	mov    $0x60,%eax
   106a8:	89 d7                	mov    %edx,%edi
   106aa:	89 de                	mov    %ebx,%esi
   106ac:	89 c1                	mov    %eax,%ecx
   106ae:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   106b0:	8b 45 08             	mov    0x8(%ebp),%eax
   106b3:	83 c0 78             	add    $0x78,%eax
   106b6:	83 ec 0c             	sub    $0xc,%esp
   106b9:	50                   	push   %eax
   106ba:	e8 75 83 ff ff       	call   8a34 <lodepng_color_mode_init>
   106bf:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   106c2:	8b 45 08             	mov    0x8(%ebp),%eax
   106c5:	05 98 00 00 00       	add    $0x98,%eax
   106ca:	83 ec 0c             	sub    $0xc,%esp
   106cd:	50                   	push   %eax
   106ce:	e8 f8 92 ff ff       	call   99cb <lodepng_info_init>
   106d3:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   106d6:	8b 45 0c             	mov    0xc(%ebp),%eax
   106d9:	8d 50 78             	lea    0x78(%eax),%edx
   106dc:	8b 45 08             	mov    0x8(%ebp),%eax
   106df:	83 c0 78             	add    $0x78,%eax
   106e2:	83 ec 08             	sub    $0x8,%esp
   106e5:	52                   	push   %edx
   106e6:	50                   	push   %eax
   106e7:	e8 52 84 ff ff       	call   8b3e <lodepng_color_mode_copy>
   106ec:	83 c4 10             	add    $0x10,%esp
   106ef:	89 c2                	mov    %eax,%edx
   106f1:	8b 45 08             	mov    0x8(%ebp),%eax
   106f4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   106fa:	8b 45 08             	mov    0x8(%ebp),%eax
   106fd:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10703:	85 c0                	test   %eax,%eax
   10705:	75 36                	jne    1073d <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   10707:	8b 45 0c             	mov    0xc(%ebp),%eax
   1070a:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   10710:	8b 45 08             	mov    0x8(%ebp),%eax
   10713:	05 98 00 00 00       	add    $0x98,%eax
   10718:	83 ec 08             	sub    $0x8,%esp
   1071b:	52                   	push   %edx
   1071c:	50                   	push   %eax
   1071d:	e8 dd 93 ff ff       	call   9aff <lodepng_info_copy>
   10722:	83 c4 10             	add    $0x10,%esp
   10725:	89 c2                	mov    %eax,%edx
   10727:	8b 45 08             	mov    0x8(%ebp),%eax
   1072a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   10730:	8b 45 08             	mov    0x8(%ebp),%eax
   10733:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10739:	85 c0                	test   %eax,%eax
   1073b:	eb 01                	jmp    1073e <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   1073d:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   1073e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10741:	5b                   	pop    %ebx
   10742:	5e                   	pop    %esi
   10743:	5f                   	pop    %edi
   10744:	5d                   	pop    %ebp
   10745:	c3                   	ret    

00010746 <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   10746:	55                   	push   %ebp
   10747:	89 e5                	mov    %esp,%ebp
   10749:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   1074c:	8b 45 08             	mov    0x8(%ebp),%eax
   1074f:	8b 40 04             	mov    0x4(%eax),%eax
   10752:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   10755:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   10759:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   1075d:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   10761:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   10765:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   10769:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   1076d:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   10771:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   10775:	8b 45 08             	mov    0x8(%ebp),%eax
   10778:	8b 40 04             	mov    0x4(%eax),%eax
   1077b:	83 c0 08             	add    $0x8,%eax
   1077e:	50                   	push   %eax
   1077f:	ff 75 08             	pushl  0x8(%ebp)
   10782:	e8 f8 2d ff ff       	call   357f <ucvector_resize>
   10787:	83 c4 08             	add    $0x8,%esp
   1078a:	85 c0                	test   %eax,%eax
   1078c:	75 07                	jne    10795 <writeSignature+0x4f>
   1078e:	b8 53 00 00 00       	mov    $0x53,%eax
   10793:	eb 1e                	jmp    107b3 <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   10795:	8b 45 08             	mov    0x8(%ebp),%eax
   10798:	8b 10                	mov    (%eax),%edx
   1079a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1079d:	01 c2                	add    %eax,%edx
   1079f:	6a 08                	push   $0x8
   107a1:	8d 45 f4             	lea    -0xc(%ebp),%eax
   107a4:	50                   	push   %eax
   107a5:	52                   	push   %edx
   107a6:	e8 b8 2b ff ff       	call   3363 <lodepng_memcpy>
   107ab:	83 c4 0c             	add    $0xc,%esp
  return 0;
   107ae:	b8 00 00 00 00       	mov    $0x0,%eax
}
   107b3:	c9                   	leave  
   107b4:	c3                   	ret    

000107b5 <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   107b5:	55                   	push   %ebp
   107b6:	89 e5                	mov    %esp,%ebp
   107b8:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   107bb:	68 4c a0 01 00       	push   $0x1a04c
   107c0:	6a 0d                	push   $0xd
   107c2:	ff 75 08             	pushl  0x8(%ebp)
   107c5:	8d 45 f4             	lea    -0xc(%ebp),%eax
   107c8:	50                   	push   %eax
   107c9:	e8 cf 7f ff ff       	call   879d <lodepng_chunk_init>
   107ce:	83 c4 10             	add    $0x10,%esp
   107d1:	89 45 fc             	mov    %eax,-0x4(%ebp)
   107d4:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   107d8:	74 05                	je     107df <addChunk_IHDR+0x2a>
   107da:	8b 45 fc             	mov    -0x4(%ebp),%eax
   107dd:	eb 6d                	jmp    1084c <addChunk_IHDR+0x97>
  data = chunk + 8;
   107df:	8b 45 f4             	mov    -0xc(%ebp),%eax
   107e2:	83 c0 08             	add    $0x8,%eax
   107e5:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   107e8:	ff 75 0c             	pushl  0xc(%ebp)
   107eb:	ff 75 f8             	pushl  -0x8(%ebp)
   107ee:	e8 f3 2e ff ff       	call   36e6 <lodepng_set32bitInt>
   107f3:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   107f6:	8b 45 f8             	mov    -0x8(%ebp),%eax
   107f9:	83 c0 04             	add    $0x4,%eax
   107fc:	ff 75 10             	pushl  0x10(%ebp)
   107ff:	50                   	push   %eax
   10800:	e8 e1 2e ff ff       	call   36e6 <lodepng_set32bitInt>
   10805:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   10808:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1080b:	83 c0 08             	add    $0x8,%eax
   1080e:	8b 55 18             	mov    0x18(%ebp),%edx
   10811:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   10813:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10816:	83 c0 09             	add    $0x9,%eax
   10819:	8b 55 14             	mov    0x14(%ebp),%edx
   1081c:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   1081e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10821:	83 c0 0a             	add    $0xa,%eax
   10824:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   10827:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1082a:	83 c0 0b             	add    $0xb,%eax
   1082d:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   10830:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10833:	83 c0 0c             	add    $0xc,%eax
   10836:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10839:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   1083b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1083e:	50                   	push   %eax
   1083f:	e8 02 7c ff ff       	call   8446 <lodepng_chunk_generate_crc>
   10844:	83 c4 04             	add    $0x4,%esp
  return 0;
   10847:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1084c:	c9                   	leave  
   1084d:	c3                   	ret    

0001084e <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   1084e:	55                   	push   %ebp
   1084f:	89 e5                	mov    %esp,%ebp
   10851:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   10854:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   1085b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1085e:	8b 50 0c             	mov    0xc(%eax),%edx
   10861:	89 d0                	mov    %edx,%eax
   10863:	01 c0                	add    %eax,%eax
   10865:	01 d0                	add    %edx,%eax
   10867:	68 68 a0 01 00       	push   $0x1a068
   1086c:	50                   	push   %eax
   1086d:	ff 75 08             	pushl  0x8(%ebp)
   10870:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10873:	50                   	push   %eax
   10874:	e8 24 7f ff ff       	call   879d <lodepng_chunk_init>
   10879:	83 c4 10             	add    $0x10,%esp
   1087c:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1087f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10883:	74 08                	je     1088d <addChunk_PLTE+0x3f>
   10885:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10888:	e9 95 00 00 00       	jmp    10922 <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   1088d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10894:	eb 70                	jmp    10906 <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   10896:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10899:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1089c:	8d 50 01             	lea    0x1(%eax),%edx
   1089f:	89 55 f8             	mov    %edx,-0x8(%ebp)
   108a2:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   108a5:	8b 45 0c             	mov    0xc(%ebp),%eax
   108a8:	8b 40 08             	mov    0x8(%eax),%eax
   108ab:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   108ae:	c1 e1 02             	shl    $0x2,%ecx
   108b1:	01 c8                	add    %ecx,%eax
   108b3:	0f b6 00             	movzbl (%eax),%eax
   108b6:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   108b8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   108bb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108be:	8d 50 01             	lea    0x1(%eax),%edx
   108c1:	89 55 f8             	mov    %edx,-0x8(%ebp)
   108c4:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   108c7:	8b 45 0c             	mov    0xc(%ebp),%eax
   108ca:	8b 40 08             	mov    0x8(%eax),%eax
   108cd:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   108d0:	c1 e1 02             	shl    $0x2,%ecx
   108d3:	83 c1 01             	add    $0x1,%ecx
   108d6:	01 c8                	add    %ecx,%eax
   108d8:	0f b6 00             	movzbl (%eax),%eax
   108db:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   108dd:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   108e0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   108e3:	8d 50 01             	lea    0x1(%eax),%edx
   108e6:	89 55 f8             	mov    %edx,-0x8(%ebp)
   108e9:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   108ec:	8b 45 0c             	mov    0xc(%ebp),%eax
   108ef:	8b 40 08             	mov    0x8(%eax),%eax
   108f2:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   108f5:	c1 e1 02             	shl    $0x2,%ecx
   108f8:	83 c1 02             	add    $0x2,%ecx
   108fb:	01 c8                	add    %ecx,%eax
   108fd:	0f b6 00             	movzbl (%eax),%eax
   10900:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   10902:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10906:	8b 45 0c             	mov    0xc(%ebp),%eax
   10909:	8b 40 0c             	mov    0xc(%eax),%eax
   1090c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   1090f:	75 85                	jne    10896 <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   10911:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10914:	50                   	push   %eax
   10915:	e8 2c 7b ff ff       	call   8446 <lodepng_chunk_generate_crc>
   1091a:	83 c4 04             	add    $0x4,%esp
  return 0;
   1091d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10922:	c9                   	leave  
   10923:	c3                   	ret    

00010924 <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   10924:	55                   	push   %ebp
   10925:	89 e5                	mov    %esp,%ebp
   10927:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   1092a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   10931:	8b 45 0c             	mov    0xc(%ebp),%eax
   10934:	8b 00                	mov    (%eax),%eax
   10936:	83 f8 03             	cmp    $0x3,%eax
   10939:	0f 85 ae 00 00 00    	jne    109ed <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   1093f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10942:	8b 40 0c             	mov    0xc(%eax),%eax
   10945:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10948:	8b 45 0c             	mov    0xc(%ebp),%eax
   1094b:	8b 40 0c             	mov    0xc(%eax),%eax
   1094e:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10951:	eb 23                	jmp    10976 <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10953:	8b 45 0c             	mov    0xc(%ebp),%eax
   10956:	8b 40 08             	mov    0x8(%eax),%eax
   10959:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1095c:	83 ea 01             	sub    $0x1,%edx
   1095f:	c1 e2 02             	shl    $0x2,%edx
   10962:	83 c2 03             	add    $0x3,%edx
   10965:	01 d0                	add    %edx,%eax
   10967:	0f b6 00             	movzbl (%eax),%eax
   1096a:	3c ff                	cmp    $0xff,%al
   1096c:	75 10                	jne    1097e <addChunk_tRNS+0x5a>
      --amount;
   1096e:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10972:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   10976:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1097a:	75 d7                	jne    10953 <addChunk_tRNS+0x2f>
   1097c:	eb 01                	jmp    1097f <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   1097e:	90                   	nop
      --amount;
    }
    if(amount) {
   1097f:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   10983:	0f 84 63 01 00 00    	je     10aec <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   10989:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1098c:	68 6d a0 01 00       	push   $0x1a06d
   10991:	50                   	push   %eax
   10992:	ff 75 08             	pushl  0x8(%ebp)
   10995:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10998:	50                   	push   %eax
   10999:	e8 ff 7d ff ff       	call   879d <lodepng_chunk_init>
   1099e:	83 c4 10             	add    $0x10,%esp
   109a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
   109a4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   109a8:	74 08                	je     109b2 <addChunk_tRNS+0x8e>
   109aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   109ad:	e9 52 01 00 00       	jmp    10b04 <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   109b2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   109b9:	eb 25                	jmp    109e0 <addChunk_tRNS+0xbc>
   109bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   109be:	8b 55 fc             	mov    -0x4(%ebp),%edx
   109c1:	83 c2 08             	add    $0x8,%edx
   109c4:	01 c2                	add    %eax,%edx
   109c6:	8b 45 0c             	mov    0xc(%ebp),%eax
   109c9:	8b 40 08             	mov    0x8(%eax),%eax
   109cc:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   109cf:	c1 e1 02             	shl    $0x2,%ecx
   109d2:	83 c1 03             	add    $0x3,%ecx
   109d5:	01 c8                	add    %ecx,%eax
   109d7:	0f b6 00             	movzbl (%eax),%eax
   109da:	88 02                	mov    %al,(%edx)
   109dc:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   109e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   109e3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   109e6:	75 d3                	jne    109bb <addChunk_tRNS+0x97>
   109e8:	e9 ff 00 00 00       	jmp    10aec <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   109ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   109f0:	8b 00                	mov    (%eax),%eax
   109f2:	85 c0                	test   %eax,%eax
   109f4:	75 59                	jne    10a4f <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   109f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   109f9:	8b 40 10             	mov    0x10(%eax),%eax
   109fc:	85 c0                	test   %eax,%eax
   109fe:	0f 84 e8 00 00 00    	je     10aec <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   10a04:	68 6d a0 01 00       	push   $0x1a06d
   10a09:	6a 02                	push   $0x2
   10a0b:	ff 75 08             	pushl  0x8(%ebp)
   10a0e:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10a11:	50                   	push   %eax
   10a12:	e8 86 7d ff ff       	call   879d <lodepng_chunk_init>
   10a17:	83 c4 10             	add    $0x10,%esp
   10a1a:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10a1d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10a21:	74 08                	je     10a2b <addChunk_tRNS+0x107>
   10a23:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a26:	e9 d9 00 00 00       	jmp    10b04 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10a2b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a2e:	8d 50 08             	lea    0x8(%eax),%edx
   10a31:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a34:	8b 40 14             	mov    0x14(%eax),%eax
   10a37:	c1 e8 08             	shr    $0x8,%eax
   10a3a:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10a3c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a3f:	8d 50 09             	lea    0x9(%eax),%edx
   10a42:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a45:	8b 40 14             	mov    0x14(%eax),%eax
   10a48:	88 02                	mov    %al,(%edx)
   10a4a:	e9 9d 00 00 00       	jmp    10aec <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   10a4f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a52:	8b 00                	mov    (%eax),%eax
   10a54:	83 f8 02             	cmp    $0x2,%eax
   10a57:	0f 85 8f 00 00 00    	jne    10aec <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   10a5d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a60:	8b 40 10             	mov    0x10(%eax),%eax
   10a63:	85 c0                	test   %eax,%eax
   10a65:	0f 84 81 00 00 00    	je     10aec <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   10a6b:	68 6d a0 01 00       	push   $0x1a06d
   10a70:	6a 06                	push   $0x6
   10a72:	ff 75 08             	pushl  0x8(%ebp)
   10a75:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10a78:	50                   	push   %eax
   10a79:	e8 1f 7d ff ff       	call   879d <lodepng_chunk_init>
   10a7e:	83 c4 10             	add    $0x10,%esp
   10a81:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10a84:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10a88:	74 05                	je     10a8f <addChunk_tRNS+0x16b>
   10a8a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10a8d:	eb 75                	jmp    10b04 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10a8f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10a92:	8d 50 08             	lea    0x8(%eax),%edx
   10a95:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a98:	8b 40 14             	mov    0x14(%eax),%eax
   10a9b:	c1 e8 08             	shr    $0x8,%eax
   10a9e:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10aa0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10aa3:	8d 50 09             	lea    0x9(%eax),%edx
   10aa6:	8b 45 0c             	mov    0xc(%ebp),%eax
   10aa9:	8b 40 14             	mov    0x14(%eax),%eax
   10aac:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   10aae:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ab1:	8d 50 0a             	lea    0xa(%eax),%edx
   10ab4:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ab7:	8b 40 18             	mov    0x18(%eax),%eax
   10aba:	c1 e8 08             	shr    $0x8,%eax
   10abd:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   10abf:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ac2:	8d 50 0b             	lea    0xb(%eax),%edx
   10ac5:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ac8:	8b 40 18             	mov    0x18(%eax),%eax
   10acb:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   10acd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ad0:	8d 50 0c             	lea    0xc(%eax),%edx
   10ad3:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ad6:	8b 40 1c             	mov    0x1c(%eax),%eax
   10ad9:	c1 e8 08             	shr    $0x8,%eax
   10adc:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   10ade:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ae1:	8d 50 0d             	lea    0xd(%eax),%edx
   10ae4:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ae7:	8b 40 1c             	mov    0x1c(%eax),%eax
   10aea:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   10aec:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10aef:	85 c0                	test   %eax,%eax
   10af1:	74 0c                	je     10aff <addChunk_tRNS+0x1db>
   10af3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10af6:	50                   	push   %eax
   10af7:	e8 4a 79 ff ff       	call   8446 <lodepng_chunk_generate_crc>
   10afc:	83 c4 04             	add    $0x4,%esp
  return 0;
   10aff:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10b04:	c9                   	leave  
   10b05:	c3                   	ret    

00010b06 <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   10b06:	55                   	push   %ebp
   10b07:	89 e5                	mov    %esp,%ebp
   10b09:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   10b0c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   10b13:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   10b1a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   10b21:	83 ec 0c             	sub    $0xc,%esp
   10b24:	ff 75 14             	pushl  0x14(%ebp)
   10b27:	ff 75 10             	pushl  0x10(%ebp)
   10b2a:	ff 75 0c             	pushl  0xc(%ebp)
   10b2d:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10b30:	50                   	push   %eax
   10b31:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10b34:	50                   	push   %eax
   10b35:	e8 fb 74 ff ff       	call   8035 <zlib_compress>
   10b3a:	83 c4 20             	add    $0x20,%esp
   10b3d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   10b40:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10b44:	75 1b                	jne    10b61 <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   10b46:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b49:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10b4c:	50                   	push   %eax
   10b4d:	68 a4 a0 01 00       	push   $0x1a0a4
   10b52:	52                   	push   %edx
   10b53:	ff 75 08             	pushl  0x8(%ebp)
   10b56:	e8 ea 7c ff ff       	call   8845 <lodepng_chunk_createv>
   10b5b:	83 c4 10             	add    $0x10,%esp
   10b5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   10b61:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b64:	83 ec 0c             	sub    $0xc,%esp
   10b67:	50                   	push   %eax
   10b68:	e8 d9 27 ff ff       	call   3346 <lodepng_free>
   10b6d:	83 c4 10             	add    $0x10,%esp
  return error;
   10b70:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10b73:	c9                   	leave  
   10b74:	c3                   	ret    

00010b75 <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   10b75:	55                   	push   %ebp
   10b76:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   10b78:	6a 00                	push   $0x0
   10b7a:	68 a9 a0 01 00       	push   $0x1a0a9
   10b7f:	6a 00                	push   $0x0
   10b81:	ff 75 08             	pushl  0x8(%ebp)
   10b84:	e8 bc 7c ff ff       	call   8845 <lodepng_chunk_createv>
   10b89:	83 c4 10             	add    $0x10,%esp
}
   10b8c:	c9                   	leave  
   10b8d:	c3                   	ret    

00010b8e <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   10b8e:	55                   	push   %ebp
   10b8f:	89 e5                	mov    %esp,%ebp
   10b91:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10b94:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   10b9b:	ff 75 0c             	pushl  0xc(%ebp)
   10b9e:	e8 1e 28 ff ff       	call   33c1 <lodepng_strlen>
   10ba3:	83 c4 04             	add    $0x4,%esp
   10ba6:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10ba9:	ff 75 10             	pushl  0x10(%ebp)
   10bac:	e8 10 28 ff ff       	call   33c1 <lodepng_strlen>
   10bb1:	83 c4 04             	add    $0x4,%esp
   10bb4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   10bb7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10bba:	8d 50 01             	lea    0x1(%eax),%edx
   10bbd:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10bc0:	01 d0                	add    %edx,%eax
   10bc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10bc5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10bc9:	7e 06                	jle    10bd1 <addChunk_tEXt+0x43>
   10bcb:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   10bcf:	7e 07                	jle    10bd8 <addChunk_tEXt+0x4a>
   10bd1:	b8 59 00 00 00       	mov    $0x59,%eax
   10bd6:	eb 74                	jmp    10c4c <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   10bd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10bdb:	68 77 a0 01 00       	push   $0x1a077
   10be0:	50                   	push   %eax
   10be1:	ff 75 08             	pushl  0x8(%ebp)
   10be4:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10be7:	50                   	push   %eax
   10be8:	e8 b0 7b ff ff       	call   879d <lodepng_chunk_init>
   10bed:	83 c4 10             	add    $0x10,%esp
   10bf0:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10bf3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10bf7:	74 05                	je     10bfe <addChunk_tEXt+0x70>
   10bf9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10bfc:	eb 4e                	jmp    10c4c <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   10bfe:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c01:	83 c0 08             	add    $0x8,%eax
   10c04:	ff 75 fc             	pushl  -0x4(%ebp)
   10c07:	ff 75 0c             	pushl  0xc(%ebp)
   10c0a:	50                   	push   %eax
   10c0b:	e8 53 27 ff ff       	call   3363 <lodepng_memcpy>
   10c10:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   10c13:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c16:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10c19:	83 c2 08             	add    $0x8,%edx
   10c1c:	01 d0                	add    %edx,%eax
   10c1e:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   10c21:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c24:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10c27:	83 c2 09             	add    $0x9,%edx
   10c2a:	01 d0                	add    %edx,%eax
   10c2c:	ff 75 f8             	pushl  -0x8(%ebp)
   10c2f:	ff 75 10             	pushl  0x10(%ebp)
   10c32:	50                   	push   %eax
   10c33:	e8 2b 27 ff ff       	call   3363 <lodepng_memcpy>
   10c38:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   10c3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10c3e:	50                   	push   %eax
   10c3f:	e8 02 78 ff ff       	call   8446 <lodepng_chunk_generate_crc>
   10c44:	83 c4 04             	add    $0x4,%esp
  return 0;
   10c47:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10c4c:	c9                   	leave  
   10c4d:	c3                   	ret    

00010c4e <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   10c4e:	55                   	push   %ebp
   10c4f:	89 e5                	mov    %esp,%ebp
   10c51:	53                   	push   %ebx
   10c52:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   10c55:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10c5c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   10c63:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   10c6a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10c71:	ff 75 10             	pushl  0x10(%ebp)
   10c74:	e8 48 27 ff ff       	call   33c1 <lodepng_strlen>
   10c79:	83 c4 04             	add    $0x4,%esp
   10c7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   10c7f:	ff 75 0c             	pushl  0xc(%ebp)
   10c82:	e8 3a 27 ff ff       	call   33c1 <lodepng_strlen>
   10c87:	83 c4 04             	add    $0x4,%esp
   10c8a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10c8d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10c91:	7e 06                	jle    10c99 <addChunk_zTXt+0x4b>
   10c93:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10c97:	7e 0a                	jle    10ca3 <addChunk_zTXt+0x55>
   10c99:	b8 59 00 00 00       	mov    $0x59,%eax
   10c9e:	e9 c8 00 00 00       	jmp    10d6b <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   10ca3:	83 ec 0c             	sub    $0xc,%esp
   10ca6:	ff 75 14             	pushl  0x14(%ebp)
   10ca9:	ff 75 f0             	pushl  -0x10(%ebp)
   10cac:	ff 75 10             	pushl  0x10(%ebp)
   10caf:	8d 45 dc             	lea    -0x24(%ebp),%eax
   10cb2:	50                   	push   %eax
   10cb3:	8d 45 e0             	lea    -0x20(%ebp),%eax
   10cb6:	50                   	push   %eax
   10cb7:	e8 79 73 ff ff       	call   8035 <zlib_compress>
   10cbc:	83 c4 20             	add    $0x20,%esp
   10cbf:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   10cc2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10cc6:	75 29                	jne    10cf1 <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   10cc8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10ccb:	8d 50 02             	lea    0x2(%eax),%edx
   10cce:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10cd1:	01 d0                	add    %edx,%eax
   10cd3:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   10cd6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10cd9:	68 7c a0 01 00       	push   $0x1a07c
   10cde:	50                   	push   %eax
   10cdf:	ff 75 08             	pushl  0x8(%ebp)
   10ce2:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   10ce5:	50                   	push   %eax
   10ce6:	e8 b2 7a ff ff       	call   879d <lodepng_chunk_init>
   10ceb:	83 c4 10             	add    $0x10,%esp
   10cee:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10cf1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10cf5:	75 62                	jne    10d59 <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   10cf7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10cfa:	83 c0 08             	add    $0x8,%eax
   10cfd:	83 ec 04             	sub    $0x4,%esp
   10d00:	ff 75 ec             	pushl  -0x14(%ebp)
   10d03:	ff 75 0c             	pushl  0xc(%ebp)
   10d06:	50                   	push   %eax
   10d07:	e8 57 26 ff ff       	call   3363 <lodepng_memcpy>
   10d0c:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   10d0f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d12:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10d15:	83 c2 08             	add    $0x8,%edx
   10d18:	01 d0                	add    %edx,%eax
   10d1a:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   10d1d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d20:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10d23:	83 c2 09             	add    $0x9,%edx
   10d26:	01 d0                	add    %edx,%eax
   10d28:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   10d2b:	8b 55 dc             	mov    -0x24(%ebp),%edx
   10d2e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10d31:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   10d34:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   10d37:	83 c3 0a             	add    $0xa,%ebx
   10d3a:	01 d9                	add    %ebx,%ecx
   10d3c:	83 ec 04             	sub    $0x4,%esp
   10d3f:	52                   	push   %edx
   10d40:	50                   	push   %eax
   10d41:	51                   	push   %ecx
   10d42:	e8 1c 26 ff ff       	call   3363 <lodepng_memcpy>
   10d47:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   10d4a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10d4d:	83 ec 0c             	sub    $0xc,%esp
   10d50:	50                   	push   %eax
   10d51:	e8 f0 76 ff ff       	call   8446 <lodepng_chunk_generate_crc>
   10d56:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10d59:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10d5c:	83 ec 0c             	sub    $0xc,%esp
   10d5f:	50                   	push   %eax
   10d60:	e8 e1 25 ff ff       	call   3346 <lodepng_free>
   10d65:	83 c4 10             	add    $0x10,%esp
  return error;
   10d68:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10d6b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10d6e:	c9                   	leave  
   10d6f:	c3                   	ret    

00010d70 <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   10d70:	55                   	push   %ebp
   10d71:	89 e5                	mov    %esp,%ebp
   10d73:	53                   	push   %ebx
   10d74:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   10d77:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10d7e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   10d85:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   10d8c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10d93:	ff 75 1c             	pushl  0x1c(%ebp)
   10d96:	e8 26 26 ff ff       	call   33c1 <lodepng_strlen>
   10d9b:	83 c4 04             	add    $0x4,%esp
   10d9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   10da1:	ff 75 10             	pushl  0x10(%ebp)
   10da4:	e8 18 26 ff ff       	call   33c1 <lodepng_strlen>
   10da9:	83 c4 04             	add    $0x4,%esp
   10dac:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10daf:	ff 75 14             	pushl  0x14(%ebp)
   10db2:	e8 0a 26 ff ff       	call   33c1 <lodepng_strlen>
   10db7:	83 c4 04             	add    $0x4,%esp
   10dba:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10dbd:	ff 75 18             	pushl  0x18(%ebp)
   10dc0:	e8 fc 25 ff ff       	call   33c1 <lodepng_strlen>
   10dc5:	83 c4 04             	add    $0x4,%esp
   10dc8:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10dcb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10dcf:	7e 06                	jle    10dd7 <addChunk_iTXt+0x67>
   10dd1:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10dd5:	7e 0a                	jle    10de1 <addChunk_iTXt+0x71>
   10dd7:	b8 59 00 00 00       	mov    $0x59,%eax
   10ddc:	e9 9a 01 00 00       	jmp    10f7b <addChunk_iTXt+0x20b>

  if(compress) {
   10de1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10de5:	74 1f                	je     10e06 <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   10de7:	83 ec 0c             	sub    $0xc,%esp
   10dea:	ff 75 20             	pushl  0x20(%ebp)
   10ded:	ff 75 f0             	pushl  -0x10(%ebp)
   10df0:	ff 75 1c             	pushl  0x1c(%ebp)
   10df3:	8d 45 d0             	lea    -0x30(%ebp),%eax
   10df6:	50                   	push   %eax
   10df7:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   10dfa:	50                   	push   %eax
   10dfb:	e8 35 72 ff ff       	call   8035 <zlib_compress>
   10e00:	83 c4 20             	add    $0x20,%esp
   10e03:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   10e06:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e0a:	75 44                	jne    10e50 <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   10e0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e0f:	8d 50 03             	lea    0x3(%eax),%edx
   10e12:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e15:	01 d0                	add    %edx,%eax
   10e17:	8d 50 01             	lea    0x1(%eax),%edx
   10e1a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10e1d:	01 d0                	add    %edx,%eax
   10e1f:	8d 50 01             	lea    0x1(%eax),%edx
   10e22:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10e26:	74 05                	je     10e2d <addChunk_iTXt+0xbd>
   10e28:	8b 45 d0             	mov    -0x30(%ebp),%eax
   10e2b:	eb 03                	jmp    10e30 <addChunk_iTXt+0xc0>
   10e2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10e30:	01 d0                	add    %edx,%eax
   10e32:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   10e35:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10e38:	68 81 a0 01 00       	push   $0x1a081
   10e3d:	50                   	push   %eax
   10e3e:	ff 75 08             	pushl  0x8(%ebp)
   10e41:	8d 45 d8             	lea    -0x28(%ebp),%eax
   10e44:	50                   	push   %eax
   10e45:	e8 53 79 ff ff       	call   879d <lodepng_chunk_init>
   10e4a:	83 c4 10             	add    $0x10,%esp
   10e4d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10e50:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e54:	0f 85 0f 01 00 00    	jne    10f69 <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   10e5a:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   10e61:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10e64:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e67:	01 d0                	add    %edx,%eax
   10e69:	83 ec 04             	sub    $0x4,%esp
   10e6c:	ff 75 ec             	pushl  -0x14(%ebp)
   10e6f:	ff 75 10             	pushl  0x10(%ebp)
   10e72:	50                   	push   %eax
   10e73:	e8 eb 24 ff ff       	call   3363 <lodepng_memcpy>
   10e78:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   10e7b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e7e:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10e81:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10e84:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e87:	8d 50 01             	lea    0x1(%eax),%edx
   10e8a:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10e8d:	01 c8                	add    %ecx,%eax
   10e8f:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   10e92:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10e95:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e98:	8d 50 01             	lea    0x1(%eax),%edx
   10e9b:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10e9e:	01 c8                	add    %ecx,%eax
   10ea0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10ea4:	0f 95 c2             	setne  %dl
   10ea7:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   10ea9:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10eac:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10eaf:	8d 50 01             	lea    0x1(%eax),%edx
   10eb2:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10eb5:	01 c8                	add    %ecx,%eax
   10eb7:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   10eba:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10ebd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ec0:	01 d0                	add    %edx,%eax
   10ec2:	83 ec 04             	sub    $0x4,%esp
   10ec5:	ff 75 e8             	pushl  -0x18(%ebp)
   10ec8:	ff 75 14             	pushl  0x14(%ebp)
   10ecb:	50                   	push   %eax
   10ecc:	e8 92 24 ff ff       	call   3363 <lodepng_memcpy>
   10ed1:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   10ed4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10ed7:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10eda:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10edd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ee0:	8d 50 01             	lea    0x1(%eax),%edx
   10ee3:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10ee6:	01 c8                	add    %ecx,%eax
   10ee8:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   10eeb:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10eee:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ef1:	01 d0                	add    %edx,%eax
   10ef3:	83 ec 04             	sub    $0x4,%esp
   10ef6:	ff 75 e4             	pushl  -0x1c(%ebp)
   10ef9:	ff 75 18             	pushl  0x18(%ebp)
   10efc:	50                   	push   %eax
   10efd:	e8 61 24 ff ff       	call   3363 <lodepng_memcpy>
   10f02:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   10f05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10f08:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10f0b:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10f0e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f11:	8d 50 01             	lea    0x1(%eax),%edx
   10f14:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10f17:	01 c8                	add    %ecx,%eax
   10f19:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   10f1c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10f20:	74 1e                	je     10f40 <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   10f22:	8b 55 d0             	mov    -0x30(%ebp),%edx
   10f25:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10f28:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   10f2b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   10f2e:	01 d9                	add    %ebx,%ecx
   10f30:	83 ec 04             	sub    $0x4,%esp
   10f33:	52                   	push   %edx
   10f34:	50                   	push   %eax
   10f35:	51                   	push   %ecx
   10f36:	e8 28 24 ff ff       	call   3363 <lodepng_memcpy>
   10f3b:	83 c4 10             	add    $0x10,%esp
   10f3e:	eb 1a                	jmp    10f5a <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   10f40:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10f43:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f46:	01 d0                	add    %edx,%eax
   10f48:	83 ec 04             	sub    $0x4,%esp
   10f4b:	ff 75 f0             	pushl  -0x10(%ebp)
   10f4e:	ff 75 1c             	pushl  0x1c(%ebp)
   10f51:	50                   	push   %eax
   10f52:	e8 0c 24 ff ff       	call   3363 <lodepng_memcpy>
   10f57:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   10f5a:	8b 45 d8             	mov    -0x28(%ebp),%eax
   10f5d:	83 ec 0c             	sub    $0xc,%esp
   10f60:	50                   	push   %eax
   10f61:	e8 e0 74 ff ff       	call   8446 <lodepng_chunk_generate_crc>
   10f66:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10f69:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10f6c:	83 ec 0c             	sub    $0xc,%esp
   10f6f:	50                   	push   %eax
   10f70:	e8 d1 23 ff ff       	call   3346 <lodepng_free>
   10f75:	83 c4 10             	add    $0x10,%esp
  return error;
   10f78:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10f7b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10f7e:	c9                   	leave  
   10f7f:	c3                   	ret    

00010f80 <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   10f80:	55                   	push   %ebp
   10f81:	89 e5                	mov    %esp,%ebp
   10f83:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   10f86:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   10f8d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f90:	8b 40 0c             	mov    0xc(%eax),%eax
   10f93:	85 c0                	test   %eax,%eax
   10f95:	74 0b                	je     10fa2 <addChunk_bKGD+0x22>
   10f97:	8b 45 0c             	mov    0xc(%ebp),%eax
   10f9a:	8b 40 0c             	mov    0xc(%eax),%eax
   10f9d:	83 f8 04             	cmp    $0x4,%eax
   10fa0:	75 4b                	jne    10fed <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   10fa2:	68 72 a0 01 00       	push   $0x1a072
   10fa7:	6a 02                	push   $0x2
   10fa9:	ff 75 08             	pushl  0x8(%ebp)
   10fac:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10faf:	50                   	push   %eax
   10fb0:	e8 e8 77 ff ff       	call   879d <lodepng_chunk_init>
   10fb5:	83 c4 10             	add    $0x10,%esp
   10fb8:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10fbb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10fbf:	74 08                	je     10fc9 <addChunk_bKGD+0x49>
   10fc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10fc4:	e9 19 01 00 00       	jmp    110e2 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   10fc9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10fcc:	8d 50 08             	lea    0x8(%eax),%edx
   10fcf:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fd2:	8b 40 30             	mov    0x30(%eax),%eax
   10fd5:	c1 e8 08             	shr    $0x8,%eax
   10fd8:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   10fda:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10fdd:	8d 50 09             	lea    0x9(%eax),%edx
   10fe0:	8b 45 0c             	mov    0xc(%ebp),%eax
   10fe3:	8b 40 30             	mov    0x30(%eax),%eax
   10fe6:	88 02                	mov    %al,(%edx)
   10fe8:	e9 dd 00 00 00       	jmp    110ca <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   10fed:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ff0:	8b 40 0c             	mov    0xc(%eax),%eax
   10ff3:	83 f8 02             	cmp    $0x2,%eax
   10ff6:	74 0f                	je     11007 <addChunk_bKGD+0x87>
   10ff8:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ffb:	8b 40 0c             	mov    0xc(%eax),%eax
   10ffe:	83 f8 06             	cmp    $0x6,%eax
   11001:	0f 85 86 00 00 00    	jne    1108d <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   11007:	68 72 a0 01 00       	push   $0x1a072
   1100c:	6a 06                	push   $0x6
   1100e:	ff 75 08             	pushl  0x8(%ebp)
   11011:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11014:	50                   	push   %eax
   11015:	e8 83 77 ff ff       	call   879d <lodepng_chunk_init>
   1101a:	83 c4 10             	add    $0x10,%esp
   1101d:	89 45 f8             	mov    %eax,-0x8(%ebp)
   11020:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   11024:	74 08                	je     1102e <addChunk_bKGD+0xae>
   11026:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11029:	e9 b4 00 00 00       	jmp    110e2 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   1102e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11031:	8d 50 08             	lea    0x8(%eax),%edx
   11034:	8b 45 0c             	mov    0xc(%ebp),%eax
   11037:	8b 40 30             	mov    0x30(%eax),%eax
   1103a:	c1 e8 08             	shr    $0x8,%eax
   1103d:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   1103f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11042:	8d 50 09             	lea    0x9(%eax),%edx
   11045:	8b 45 0c             	mov    0xc(%ebp),%eax
   11048:	8b 40 30             	mov    0x30(%eax),%eax
   1104b:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   1104d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11050:	8d 50 0a             	lea    0xa(%eax),%edx
   11053:	8b 45 0c             	mov    0xc(%ebp),%eax
   11056:	8b 40 34             	mov    0x34(%eax),%eax
   11059:	c1 e8 08             	shr    $0x8,%eax
   1105c:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   1105e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11061:	8d 50 0b             	lea    0xb(%eax),%edx
   11064:	8b 45 0c             	mov    0xc(%ebp),%eax
   11067:	8b 40 34             	mov    0x34(%eax),%eax
   1106a:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   1106c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1106f:	8d 50 0c             	lea    0xc(%eax),%edx
   11072:	8b 45 0c             	mov    0xc(%ebp),%eax
   11075:	8b 40 38             	mov    0x38(%eax),%eax
   11078:	c1 e8 08             	shr    $0x8,%eax
   1107b:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   1107d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11080:	8d 50 0d             	lea    0xd(%eax),%edx
   11083:	8b 45 0c             	mov    0xc(%ebp),%eax
   11086:	8b 40 38             	mov    0x38(%eax),%eax
   11089:	88 02                	mov    %al,(%edx)
   1108b:	eb 3d                	jmp    110ca <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   1108d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11090:	8b 40 0c             	mov    0xc(%eax),%eax
   11093:	83 f8 03             	cmp    $0x3,%eax
   11096:	75 32                	jne    110ca <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   11098:	68 72 a0 01 00       	push   $0x1a072
   1109d:	6a 01                	push   $0x1
   1109f:	ff 75 08             	pushl  0x8(%ebp)
   110a2:	8d 45 f0             	lea    -0x10(%ebp),%eax
   110a5:	50                   	push   %eax
   110a6:	e8 f2 76 ff ff       	call   879d <lodepng_chunk_init>
   110ab:	83 c4 10             	add    $0x10,%esp
   110ae:	89 45 fc             	mov    %eax,-0x4(%ebp)
   110b1:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   110b5:	74 05                	je     110bc <addChunk_bKGD+0x13c>
   110b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   110ba:	eb 26                	jmp    110e2 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   110bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110bf:	8d 50 08             	lea    0x8(%eax),%edx
   110c2:	8b 45 0c             	mov    0xc(%ebp),%eax
   110c5:	8b 40 30             	mov    0x30(%eax),%eax
   110c8:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   110ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110cd:	85 c0                	test   %eax,%eax
   110cf:	74 0c                	je     110dd <addChunk_bKGD+0x15d>
   110d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110d4:	50                   	push   %eax
   110d5:	e8 6c 73 ff ff       	call   8446 <lodepng_chunk_generate_crc>
   110da:	83 c4 04             	add    $0x4,%esp
  return 0;
   110dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
   110e2:	c9                   	leave  
   110e3:	c3                   	ret    

000110e4 <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   110e4:	55                   	push   %ebp
   110e5:	89 e5                	mov    %esp,%ebp
   110e7:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   110ea:	68 86 a0 01 00       	push   $0x1a086
   110ef:	6a 07                	push   $0x7
   110f1:	ff 75 08             	pushl  0x8(%ebp)
   110f4:	8d 45 f8             	lea    -0x8(%ebp),%eax
   110f7:	50                   	push   %eax
   110f8:	e8 a0 76 ff ff       	call   879d <lodepng_chunk_init>
   110fd:	83 c4 10             	add    $0x10,%esp
   11100:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11103:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11107:	74 05                	je     1110e <addChunk_tIME+0x2a>
   11109:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1110c:	eb 74                	jmp    11182 <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   1110e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11111:	8d 50 08             	lea    0x8(%eax),%edx
   11114:	8b 45 0c             	mov    0xc(%ebp),%eax
   11117:	8b 00                	mov    (%eax),%eax
   11119:	c1 e8 08             	shr    $0x8,%eax
   1111c:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   1111e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11121:	8d 50 09             	lea    0x9(%eax),%edx
   11124:	8b 45 0c             	mov    0xc(%ebp),%eax
   11127:	8b 00                	mov    (%eax),%eax
   11129:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   1112b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1112e:	8d 50 0a             	lea    0xa(%eax),%edx
   11131:	8b 45 0c             	mov    0xc(%ebp),%eax
   11134:	8b 40 04             	mov    0x4(%eax),%eax
   11137:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   11139:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1113c:	8d 50 0b             	lea    0xb(%eax),%edx
   1113f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11142:	8b 40 08             	mov    0x8(%eax),%eax
   11145:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   11147:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1114a:	8d 50 0c             	lea    0xc(%eax),%edx
   1114d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11150:	8b 40 0c             	mov    0xc(%eax),%eax
   11153:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   11155:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11158:	8d 50 0d             	lea    0xd(%eax),%edx
   1115b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1115e:	8b 40 10             	mov    0x10(%eax),%eax
   11161:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   11163:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11166:	8d 50 0e             	lea    0xe(%eax),%edx
   11169:	8b 45 0c             	mov    0xc(%ebp),%eax
   1116c:	8b 40 14             	mov    0x14(%eax),%eax
   1116f:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   11171:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11174:	50                   	push   %eax
   11175:	e8 cc 72 ff ff       	call   8446 <lodepng_chunk_generate_crc>
   1117a:	83 c4 04             	add    $0x4,%esp
  return 0;
   1117d:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11182:	c9                   	leave  
   11183:	c3                   	ret    

00011184 <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   11184:	55                   	push   %ebp
   11185:	89 e5                	mov    %esp,%ebp
   11187:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   1118a:	68 8b a0 01 00       	push   $0x1a08b
   1118f:	6a 09                	push   $0x9
   11191:	ff 75 08             	pushl  0x8(%ebp)
   11194:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11197:	50                   	push   %eax
   11198:	e8 00 76 ff ff       	call   879d <lodepng_chunk_init>
   1119d:	83 c4 10             	add    $0x10,%esp
   111a0:	89 45 fc             	mov    %eax,-0x4(%ebp)
   111a3:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   111a7:	74 05                	je     111ae <addChunk_pHYs+0x2a>
   111a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   111ac:	eb 51                	jmp    111ff <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   111ae:	8b 45 0c             	mov    0xc(%ebp),%eax
   111b1:	8b 40 7c             	mov    0x7c(%eax),%eax
   111b4:	8b 55 f8             	mov    -0x8(%ebp),%edx
   111b7:	83 c2 08             	add    $0x8,%edx
   111ba:	50                   	push   %eax
   111bb:	52                   	push   %edx
   111bc:	e8 25 25 ff ff       	call   36e6 <lodepng_set32bitInt>
   111c1:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   111c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   111c7:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   111cd:	8b 55 f8             	mov    -0x8(%ebp),%edx
   111d0:	83 c2 0c             	add    $0xc,%edx
   111d3:	50                   	push   %eax
   111d4:	52                   	push   %edx
   111d5:	e8 0c 25 ff ff       	call   36e6 <lodepng_set32bitInt>
   111da:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   111dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111e0:	8d 50 10             	lea    0x10(%eax),%edx
   111e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   111e6:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   111ec:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   111ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
   111f1:	50                   	push   %eax
   111f2:	e8 4f 72 ff ff       	call   8446 <lodepng_chunk_generate_crc>
   111f7:	83 c4 04             	add    $0x4,%esp
  return 0;
   111fa:	b8 00 00 00 00       	mov    $0x0,%eax
}
   111ff:	c9                   	leave  
   11200:	c3                   	ret    

00011201 <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   11201:	55                   	push   %ebp
   11202:	89 e5                	mov    %esp,%ebp
   11204:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   11207:	68 90 a0 01 00       	push   $0x1a090
   1120c:	6a 04                	push   $0x4
   1120e:	ff 75 08             	pushl  0x8(%ebp)
   11211:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11214:	50                   	push   %eax
   11215:	e8 83 75 ff ff       	call   879d <lodepng_chunk_init>
   1121a:	83 c4 10             	add    $0x10,%esp
   1121d:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11220:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11224:	74 05                	je     1122b <addChunk_gAMA+0x2a>
   11226:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11229:	eb 2a                	jmp    11255 <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   1122b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1122e:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   11234:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11237:	83 c2 08             	add    $0x8,%edx
   1123a:	50                   	push   %eax
   1123b:	52                   	push   %edx
   1123c:	e8 a5 24 ff ff       	call   36e6 <lodepng_set32bitInt>
   11241:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   11244:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11247:	50                   	push   %eax
   11248:	e8 f9 71 ff ff       	call   8446 <lodepng_chunk_generate_crc>
   1124d:	83 c4 04             	add    $0x4,%esp
  return 0;
   11250:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11255:	c9                   	leave  
   11256:	c3                   	ret    

00011257 <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   11257:	55                   	push   %ebp
   11258:	89 e5                	mov    %esp,%ebp
   1125a:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   1125d:	68 95 a0 01 00       	push   $0x1a095
   11262:	6a 20                	push   $0x20
   11264:	ff 75 08             	pushl  0x8(%ebp)
   11267:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1126a:	50                   	push   %eax
   1126b:	e8 2d 75 ff ff       	call   879d <lodepng_chunk_init>
   11270:	83 c4 10             	add    $0x10,%esp
   11273:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11276:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1127a:	74 08                	je     11284 <addChunk_cHRM+0x2d>
   1127c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1127f:	e9 d9 00 00 00       	jmp    1135d <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   11284:	8b 45 0c             	mov    0xc(%ebp),%eax
   11287:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   1128d:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11290:	83 c2 08             	add    $0x8,%edx
   11293:	50                   	push   %eax
   11294:	52                   	push   %edx
   11295:	e8 4c 24 ff ff       	call   36e6 <lodepng_set32bitInt>
   1129a:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   1129d:	8b 45 0c             	mov    0xc(%ebp),%eax
   112a0:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   112a6:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112a9:	83 c2 0c             	add    $0xc,%edx
   112ac:	50                   	push   %eax
   112ad:	52                   	push   %edx
   112ae:	e8 33 24 ff ff       	call   36e6 <lodepng_set32bitInt>
   112b3:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   112b6:	8b 45 0c             	mov    0xc(%ebp),%eax
   112b9:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   112bf:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112c2:	83 c2 10             	add    $0x10,%edx
   112c5:	50                   	push   %eax
   112c6:	52                   	push   %edx
   112c7:	e8 1a 24 ff ff       	call   36e6 <lodepng_set32bitInt>
   112cc:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   112cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   112d2:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   112d8:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112db:	83 c2 14             	add    $0x14,%edx
   112de:	50                   	push   %eax
   112df:	52                   	push   %edx
   112e0:	e8 01 24 ff ff       	call   36e6 <lodepng_set32bitInt>
   112e5:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   112e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   112eb:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   112f1:	8b 55 f8             	mov    -0x8(%ebp),%edx
   112f4:	83 c2 18             	add    $0x18,%edx
   112f7:	50                   	push   %eax
   112f8:	52                   	push   %edx
   112f9:	e8 e8 23 ff ff       	call   36e6 <lodepng_set32bitInt>
   112fe:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   11301:	8b 45 0c             	mov    0xc(%ebp),%eax
   11304:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   1130a:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1130d:	83 c2 1c             	add    $0x1c,%edx
   11310:	50                   	push   %eax
   11311:	52                   	push   %edx
   11312:	e8 cf 23 ff ff       	call   36e6 <lodepng_set32bitInt>
   11317:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   1131a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1131d:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   11323:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11326:	83 c2 20             	add    $0x20,%edx
   11329:	50                   	push   %eax
   1132a:	52                   	push   %edx
   1132b:	e8 b6 23 ff ff       	call   36e6 <lodepng_set32bitInt>
   11330:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   11333:	8b 45 0c             	mov    0xc(%ebp),%eax
   11336:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   1133c:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1133f:	83 c2 24             	add    $0x24,%edx
   11342:	50                   	push   %eax
   11343:	52                   	push   %edx
   11344:	e8 9d 23 ff ff       	call   36e6 <lodepng_set32bitInt>
   11349:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   1134c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1134f:	50                   	push   %eax
   11350:	e8 f1 70 ff ff       	call   8446 <lodepng_chunk_generate_crc>
   11355:	83 c4 04             	add    $0x4,%esp
  return 0;
   11358:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1135d:	c9                   	leave  
   1135e:	c3                   	ret    

0001135f <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   1135f:	55                   	push   %ebp
   11360:	89 e5                	mov    %esp,%ebp
   11362:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   11365:	8b 45 0c             	mov    0xc(%ebp),%eax
   11368:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   1136e:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   11371:	8d 45 ff             	lea    -0x1(%ebp),%eax
   11374:	50                   	push   %eax
   11375:	68 9a a0 01 00       	push   $0x1a09a
   1137a:	6a 01                	push   $0x1
   1137c:	ff 75 08             	pushl  0x8(%ebp)
   1137f:	e8 c1 74 ff ff       	call   8845 <lodepng_chunk_createv>
   11384:	83 c4 10             	add    $0x10,%esp
}
   11387:	c9                   	leave  
   11388:	c3                   	ret    

00011389 <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   11389:	55                   	push   %ebp
   1138a:	89 e5                	mov    %esp,%ebp
   1138c:	53                   	push   %ebx
   1138d:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   11390:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11397:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   1139e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   113a5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   113ac:	8b 45 0c             	mov    0xc(%ebp),%eax
   113af:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   113b5:	50                   	push   %eax
   113b6:	e8 06 20 ff ff       	call   33c1 <lodepng_strlen>
   113bb:	83 c4 04             	add    $0x4,%esp
   113be:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   113c1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   113c5:	7e 06                	jle    113cd <addChunk_iCCP+0x44>
   113c7:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   113cb:	7e 0a                	jle    113d7 <addChunk_iCCP+0x4e>
   113cd:	b8 59 00 00 00       	mov    $0x59,%eax
   113d2:	e9 df 00 00 00       	jmp    114b6 <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   113d7:	8b 45 0c             	mov    0xc(%ebp),%eax
   113da:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   113e0:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   113e2:	8b 45 0c             	mov    0xc(%ebp),%eax
   113e5:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   113eb:	83 ec 0c             	sub    $0xc,%esp
   113ee:	ff 75 10             	pushl  0x10(%ebp)
   113f1:	52                   	push   %edx
   113f2:	50                   	push   %eax
   113f3:	8d 45 e0             	lea    -0x20(%ebp),%eax
   113f6:	50                   	push   %eax
   113f7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   113fa:	50                   	push   %eax
   113fb:	e8 35 6c ff ff       	call   8035 <zlib_compress>
   11400:	83 c4 20             	add    $0x20,%esp
   11403:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   11406:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1140a:	75 29                	jne    11435 <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   1140c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1140f:	8d 50 02             	lea    0x2(%eax),%edx
   11412:	8b 45 e0             	mov    -0x20(%ebp),%eax
   11415:	01 d0                	add    %edx,%eax
   11417:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   1141a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1141d:	68 9f a0 01 00       	push   $0x1a09f
   11422:	50                   	push   %eax
   11423:	ff 75 08             	pushl  0x8(%ebp)
   11426:	8d 45 e8             	lea    -0x18(%ebp),%eax
   11429:	50                   	push   %eax
   1142a:	e8 6e 73 ff ff       	call   879d <lodepng_chunk_init>
   1142f:	83 c4 10             	add    $0x10,%esp
   11432:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11435:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11439:	75 69                	jne    114a4 <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   1143b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1143e:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11444:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11447:	83 c2 08             	add    $0x8,%edx
   1144a:	83 ec 04             	sub    $0x4,%esp
   1144d:	ff 75 f0             	pushl  -0x10(%ebp)
   11450:	50                   	push   %eax
   11451:	52                   	push   %edx
   11452:	e8 0c 1f ff ff       	call   3363 <lodepng_memcpy>
   11457:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   1145a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1145d:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11460:	83 c2 08             	add    $0x8,%edx
   11463:	01 d0                	add    %edx,%eax
   11465:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   11468:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1146b:	8b 55 f0             	mov    -0x10(%ebp),%edx
   1146e:	83 c2 09             	add    $0x9,%edx
   11471:	01 d0                	add    %edx,%eax
   11473:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   11476:	8b 55 e0             	mov    -0x20(%ebp),%edx
   11479:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1147c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   1147f:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   11482:	83 c3 0a             	add    $0xa,%ebx
   11485:	01 d9                	add    %ebx,%ecx
   11487:	83 ec 04             	sub    $0x4,%esp
   1148a:	52                   	push   %edx
   1148b:	50                   	push   %eax
   1148c:	51                   	push   %ecx
   1148d:	e8 d1 1e ff ff       	call   3363 <lodepng_memcpy>
   11492:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   11495:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11498:	83 ec 0c             	sub    $0xc,%esp
   1149b:	50                   	push   %eax
   1149c:	e8 a5 6f ff ff       	call   8446 <lodepng_chunk_generate_crc>
   114a1:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   114a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   114a7:	83 ec 0c             	sub    $0xc,%esp
   114aa:	50                   	push   %eax
   114ab:	e8 96 1e ff ff       	call   3346 <lodepng_free>
   114b0:	83 c4 10             	add    $0x10,%esp
  return error;
   114b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   114b6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   114b9:	c9                   	leave  
   114ba:	c3                   	ret    

000114bb <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   114bb:	55                   	push   %ebp
   114bc:	89 e5                	mov    %esp,%ebp
   114be:	56                   	push   %esi
   114bf:	53                   	push   %ebx
   114c0:	83 ec 14             	sub    $0x14,%esp
   114c3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   114c6:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   114c9:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   114cd:	83 f8 04             	cmp    $0x4,%eax
   114d0:	0f 87 41 03 00 00    	ja     11817 <filterScanline+0x35c>
   114d6:	8b 04 85 b0 a0 01 00 	mov    0x1a0b0(,%eax,4),%eax
   114dd:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   114df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   114e6:	eb 19                	jmp    11501 <filterScanline+0x46>
   114e8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   114eb:	8b 45 08             	mov    0x8(%ebp),%eax
   114ee:	01 c2                	add    %eax,%edx
   114f0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   114f3:	8b 45 0c             	mov    0xc(%ebp),%eax
   114f6:	01 c8                	add    %ecx,%eax
   114f8:	0f b6 00             	movzbl (%eax),%eax
   114fb:	88 02                	mov    %al,(%edx)
   114fd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11501:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11504:	3b 45 14             	cmp    0x14(%ebp),%eax
   11507:	75 df                	jne    114e8 <filterScanline+0x2d>
      break;
   11509:	e9 0a 03 00 00       	jmp    11818 <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   1150e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11515:	eb 19                	jmp    11530 <filterScanline+0x75>
   11517:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1151a:	8b 45 08             	mov    0x8(%ebp),%eax
   1151d:	01 c2                	add    %eax,%edx
   1151f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11522:	8b 45 0c             	mov    0xc(%ebp),%eax
   11525:	01 c8                	add    %ecx,%eax
   11527:	0f b6 00             	movzbl (%eax),%eax
   1152a:	88 02                	mov    %al,(%edx)
   1152c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11530:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11533:	3b 45 18             	cmp    0x18(%ebp),%eax
   11536:	75 df                	jne    11517 <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   11538:	8b 45 18             	mov    0x18(%ebp),%eax
   1153b:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1153e:	eb 2d                	jmp    1156d <filterScanline+0xb2>
   11540:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11543:	8b 45 08             	mov    0x8(%ebp),%eax
   11546:	01 c2                	add    %eax,%edx
   11548:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1154b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1154e:	01 c8                	add    %ecx,%eax
   11550:	0f b6 08             	movzbl (%eax),%ecx
   11553:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11556:	2b 45 18             	sub    0x18(%ebp),%eax
   11559:	89 c3                	mov    %eax,%ebx
   1155b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1155e:	01 d8                	add    %ebx,%eax
   11560:	0f b6 00             	movzbl (%eax),%eax
   11563:	29 c1                	sub    %eax,%ecx
   11565:	89 c8                	mov    %ecx,%eax
   11567:	88 02                	mov    %al,(%edx)
   11569:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1156d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11570:	3b 45 14             	cmp    0x14(%ebp),%eax
   11573:	7c cb                	jl     11540 <filterScanline+0x85>
      break;
   11575:	e9 9e 02 00 00       	jmp    11818 <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   1157a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1157e:	74 3e                	je     115be <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   11580:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11587:	eb 28                	jmp    115b1 <filterScanline+0xf6>
   11589:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1158c:	8b 45 08             	mov    0x8(%ebp),%eax
   1158f:	01 d0                	add    %edx,%eax
   11591:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11594:	8b 55 0c             	mov    0xc(%ebp),%edx
   11597:	01 ca                	add    %ecx,%edx
   11599:	0f b6 0a             	movzbl (%edx),%ecx
   1159c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1159f:	8b 55 10             	mov    0x10(%ebp),%edx
   115a2:	01 da                	add    %ebx,%edx
   115a4:	0f b6 12             	movzbl (%edx),%edx
   115a7:	29 d1                	sub    %edx,%ecx
   115a9:	89 ca                	mov    %ecx,%edx
   115ab:	88 10                	mov    %dl,(%eax)
   115ad:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   115b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115b4:	3b 45 14             	cmp    0x14(%ebp),%eax
   115b7:	75 d0                	jne    11589 <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   115b9:	e9 5a 02 00 00       	jmp    11818 <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   115be:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   115c5:	eb 19                	jmp    115e0 <filterScanline+0x125>
   115c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
   115ca:	8b 45 08             	mov    0x8(%ebp),%eax
   115cd:	01 c2                	add    %eax,%edx
   115cf:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   115d2:	8b 45 0c             	mov    0xc(%ebp),%eax
   115d5:	01 c8                	add    %ecx,%eax
   115d7:	0f b6 00             	movzbl (%eax),%eax
   115da:	88 02                	mov    %al,(%edx)
   115dc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   115e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   115e3:	3b 45 14             	cmp    0x14(%ebp),%eax
   115e6:	75 df                	jne    115c7 <filterScanline+0x10c>
      }
      break;
   115e8:	e9 2b 02 00 00       	jmp    11818 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   115ed:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   115f1:	0f 84 90 00 00 00    	je     11687 <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   115f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   115fe:	eb 28                	jmp    11628 <filterScanline+0x16d>
   11600:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11603:	8b 45 08             	mov    0x8(%ebp),%eax
   11606:	01 d0                	add    %edx,%eax
   11608:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1160b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1160e:	01 ca                	add    %ecx,%edx
   11610:	0f b6 12             	movzbl (%edx),%edx
   11613:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11616:	8b 4d 10             	mov    0x10(%ebp),%ecx
   11619:	01 d9                	add    %ebx,%ecx
   1161b:	0f b6 09             	movzbl (%ecx),%ecx
   1161e:	d0 e9                	shr    %cl
   11620:	29 ca                	sub    %ecx,%edx
   11622:	88 10                	mov    %dl,(%eax)
   11624:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11628:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1162b:	3b 45 18             	cmp    0x18(%ebp),%eax
   1162e:	75 d0                	jne    11600 <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   11630:	8b 45 18             	mov    0x18(%ebp),%eax
   11633:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11636:	eb 42                	jmp    1167a <filterScanline+0x1bf>
   11638:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1163b:	8b 45 08             	mov    0x8(%ebp),%eax
   1163e:	01 c2                	add    %eax,%edx
   11640:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11643:	8b 45 0c             	mov    0xc(%ebp),%eax
   11646:	01 c8                	add    %ecx,%eax
   11648:	0f b6 08             	movzbl (%eax),%ecx
   1164b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1164e:	2b 45 18             	sub    0x18(%ebp),%eax
   11651:	89 c3                	mov    %eax,%ebx
   11653:	8b 45 0c             	mov    0xc(%ebp),%eax
   11656:	01 d8                	add    %ebx,%eax
   11658:	0f b6 00             	movzbl (%eax),%eax
   1165b:	0f b6 d8             	movzbl %al,%ebx
   1165e:	8b 75 f4             	mov    -0xc(%ebp),%esi
   11661:	8b 45 10             	mov    0x10(%ebp),%eax
   11664:	01 f0                	add    %esi,%eax
   11666:	0f b6 00             	movzbl (%eax),%eax
   11669:	0f b6 c0             	movzbl %al,%eax
   1166c:	01 d8                	add    %ebx,%eax
   1166e:	d1 f8                	sar    %eax
   11670:	29 c1                	sub    %eax,%ecx
   11672:	89 c8                	mov    %ecx,%eax
   11674:	88 02                	mov    %al,(%edx)
   11676:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1167a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1167d:	3b 45 14             	cmp    0x14(%ebp),%eax
   11680:	7c b6                	jl     11638 <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   11682:	e9 91 01 00 00       	jmp    11818 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11687:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1168e:	eb 19                	jmp    116a9 <filterScanline+0x1ee>
   11690:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11693:	8b 45 08             	mov    0x8(%ebp),%eax
   11696:	01 c2                	add    %eax,%edx
   11698:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1169b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1169e:	01 c8                	add    %ecx,%eax
   116a0:	0f b6 00             	movzbl (%eax),%eax
   116a3:	88 02                	mov    %al,(%edx)
   116a5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   116a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116ac:	3b 45 18             	cmp    0x18(%ebp),%eax
   116af:	75 df                	jne    11690 <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   116b1:	8b 45 18             	mov    0x18(%ebp),%eax
   116b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
   116b7:	eb 2f                	jmp    116e8 <filterScanline+0x22d>
   116b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116bc:	8b 45 08             	mov    0x8(%ebp),%eax
   116bf:	01 c2                	add    %eax,%edx
   116c1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   116c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   116c7:	01 c8                	add    %ecx,%eax
   116c9:	0f b6 08             	movzbl (%eax),%ecx
   116cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116cf:	2b 45 18             	sub    0x18(%ebp),%eax
   116d2:	89 c3                	mov    %eax,%ebx
   116d4:	8b 45 0c             	mov    0xc(%ebp),%eax
   116d7:	01 d8                	add    %ebx,%eax
   116d9:	0f b6 00             	movzbl (%eax),%eax
   116dc:	d0 e8                	shr    %al
   116de:	29 c1                	sub    %eax,%ecx
   116e0:	89 c8                	mov    %ecx,%eax
   116e2:	88 02                	mov    %al,(%edx)
   116e4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   116e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116eb:	3b 45 14             	cmp    0x14(%ebp),%eax
   116ee:	7c c9                	jl     116b9 <filterScanline+0x1fe>
      }
      break;
   116f0:	e9 23 01 00 00       	jmp    11818 <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   116f5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   116f9:	0f 84 af 00 00 00    	je     117ae <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   116ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11706:	eb 28                	jmp    11730 <filterScanline+0x275>
   11708:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1170b:	8b 45 08             	mov    0x8(%ebp),%eax
   1170e:	01 d0                	add    %edx,%eax
   11710:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11713:	8b 55 0c             	mov    0xc(%ebp),%edx
   11716:	01 ca                	add    %ecx,%edx
   11718:	0f b6 0a             	movzbl (%edx),%ecx
   1171b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1171e:	8b 55 10             	mov    0x10(%ebp),%edx
   11721:	01 da                	add    %ebx,%edx
   11723:	0f b6 12             	movzbl (%edx),%edx
   11726:	29 d1                	sub    %edx,%ecx
   11728:	89 ca                	mov    %ecx,%edx
   1172a:	88 10                	mov    %dl,(%eax)
   1172c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11730:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11733:	3b 45 18             	cmp    0x18(%ebp),%eax
   11736:	75 d0                	jne    11708 <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   11738:	8b 45 18             	mov    0x18(%ebp),%eax
   1173b:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1173e:	eb 64                	jmp    117a4 <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   11740:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11743:	8b 45 08             	mov    0x8(%ebp),%eax
   11746:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   11749:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1174c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1174f:	01 d0                	add    %edx,%eax
   11751:	0f b6 00             	movzbl (%eax),%eax
   11754:	88 45 e7             	mov    %al,-0x19(%ebp)
   11757:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1175a:	2b 45 18             	sub    0x18(%ebp),%eax
   1175d:	89 c2                	mov    %eax,%edx
   1175f:	8b 45 10             	mov    0x10(%ebp),%eax
   11762:	01 d0                	add    %edx,%eax
   11764:	0f b6 00             	movzbl (%eax),%eax
   11767:	0f b6 c8             	movzbl %al,%ecx
   1176a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1176d:	8b 45 10             	mov    0x10(%ebp),%eax
   11770:	01 d0                	add    %edx,%eax
   11772:	0f b6 00             	movzbl (%eax),%eax
   11775:	0f b6 d0             	movzbl %al,%edx
   11778:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1177b:	2b 45 18             	sub    0x18(%ebp),%eax
   1177e:	89 c6                	mov    %eax,%esi
   11780:	8b 45 0c             	mov    0xc(%ebp),%eax
   11783:	01 f0                	add    %esi,%eax
   11785:	0f b6 00             	movzbl (%eax),%eax
   11788:	0f b6 c0             	movzbl %al,%eax
   1178b:	51                   	push   %ecx
   1178c:	52                   	push   %edx
   1178d:	50                   	push   %eax
   1178e:	e8 49 b8 ff ff       	call   cfdc <paethPredictor>
   11793:	83 c4 0c             	add    $0xc,%esp
   11796:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   1179a:	29 c1                	sub    %eax,%ecx
   1179c:	89 c8                	mov    %ecx,%eax
   1179e:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   117a0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117a7:	3b 45 14             	cmp    0x14(%ebp),%eax
   117aa:	7c 94                	jl     11740 <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   117ac:	eb 6a                	jmp    11818 <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   117ae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   117b5:	eb 19                	jmp    117d0 <filterScanline+0x315>
   117b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117ba:	8b 45 08             	mov    0x8(%ebp),%eax
   117bd:	01 c2                	add    %eax,%edx
   117bf:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117c2:	8b 45 0c             	mov    0xc(%ebp),%eax
   117c5:	01 c8                	add    %ecx,%eax
   117c7:	0f b6 00             	movzbl (%eax),%eax
   117ca:	88 02                	mov    %al,(%edx)
   117cc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117d3:	3b 45 18             	cmp    0x18(%ebp),%eax
   117d6:	75 df                	jne    117b7 <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   117d8:	8b 45 18             	mov    0x18(%ebp),%eax
   117db:	89 45 f4             	mov    %eax,-0xc(%ebp)
   117de:	eb 2d                	jmp    1180d <filterScanline+0x352>
   117e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117e3:	8b 45 08             	mov    0x8(%ebp),%eax
   117e6:	01 c2                	add    %eax,%edx
   117e8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117eb:	8b 45 0c             	mov    0xc(%ebp),%eax
   117ee:	01 c8                	add    %ecx,%eax
   117f0:	0f b6 08             	movzbl (%eax),%ecx
   117f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117f6:	2b 45 18             	sub    0x18(%ebp),%eax
   117f9:	89 c3                	mov    %eax,%ebx
   117fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   117fe:	01 d8                	add    %ebx,%eax
   11800:	0f b6 00             	movzbl (%eax),%eax
   11803:	29 c1                	sub    %eax,%ecx
   11805:	89 c8                	mov    %ecx,%eax
   11807:	88 02                	mov    %al,(%edx)
   11809:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1180d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11810:	3b 45 14             	cmp    0x14(%ebp),%eax
   11813:	7c cb                	jl     117e0 <filterScanline+0x325>
      }
      break;
   11815:	eb 01                	jmp    11818 <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   11817:	90                   	nop
  }
}
   11818:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1181b:	5b                   	pop    %ebx
   1181c:	5e                   	pop    %esi
   1181d:	5d                   	pop    %ebp
   1181e:	c3                   	ret    

0001181f <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   1181f:	55                   	push   %ebp
   11820:	89 e5                	mov    %esp,%ebp
   11822:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   11825:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   1182c:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   11833:	7e 08                	jle    1183d <ilog2+0x1e>
   11835:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   11839:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   1183d:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   11844:	7e 08                	jle    1184e <ilog2+0x2f>
   11846:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   1184a:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   1184e:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   11852:	7e 08                	jle    1185c <ilog2+0x3d>
   11854:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   11858:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   1185c:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   11860:	7e 08                	jle    1186a <ilog2+0x4b>
   11862:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   11866:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   1186a:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   1186e:	7e 04                	jle    11874 <ilog2+0x55>
   11870:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   11874:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11877:	c9                   	leave  
   11878:	c3                   	ret    

00011879 <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   11879:	55                   	push   %ebp
   1187a:	89 e5                	mov    %esp,%ebp
   1187c:	56                   	push   %esi
   1187d:	53                   	push   %ebx
   1187e:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   11881:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11885:	75 07                	jne    1188e <ilog2i+0x15>
   11887:	b8 00 00 00 00       	mov    $0x0,%eax
   1188c:	eb 30                	jmp    118be <ilog2i+0x45>
  l = ilog2(i);
   1188e:	ff 75 08             	pushl  0x8(%ebp)
   11891:	e8 89 ff ff ff       	call   1181f <ilog2>
   11896:	83 c4 04             	add    $0x4,%esp
   11899:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   1189c:	8b 45 08             	mov    0x8(%ebp),%eax
   1189f:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   118a3:	89 c3                	mov    %eax,%ebx
   118a5:	8b 55 08             	mov    0x8(%ebp),%edx
   118a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118ab:	be 01 00 00 00       	mov    $0x1,%esi
   118b0:	89 c1                	mov    %eax,%ecx
   118b2:	d3 e6                	shl    %cl,%esi
   118b4:	89 f0                	mov    %esi,%eax
   118b6:	29 c2                	sub    %eax,%edx
   118b8:	89 d0                	mov    %edx,%eax
   118ba:	01 c0                	add    %eax,%eax
   118bc:	01 d8                	add    %ebx,%eax
}
   118be:	8d 65 f8             	lea    -0x8(%ebp),%esp
   118c1:	5b                   	pop    %ebx
   118c2:	5e                   	pop    %esi
   118c3:	5d                   	pop    %ebp
   118c4:	c3                   	ret    

000118c5 <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   118c5:	55                   	push   %ebp
   118c6:	89 e5                	mov    %esp,%ebp
   118c8:	53                   	push   %ebx
   118c9:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   118cf:	ff 75 18             	pushl  0x18(%ebp)
   118d2:	e8 6a 75 ff ff       	call   8e41 <lodepng_get_bpp>
   118d7:	83 c4 04             	add    $0x4,%esp
   118da:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   118dd:	ff 75 b8             	pushl  -0x48(%ebp)
   118e0:	6a 01                	push   $0x1
   118e2:	ff 75 10             	pushl  0x10(%ebp)
   118e5:	e8 b6 76 ff ff       	call   8fa0 <lodepng_get_raw_size_idat>
   118ea:	83 c4 0c             	add    $0xc,%esp
   118ed:	83 e8 01             	sub    $0x1,%eax
   118f0:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   118f3:	8b 45 b8             	mov    -0x48(%ebp),%eax
   118f6:	83 c0 07             	add    $0x7,%eax
   118f9:	c1 e8 03             	shr    $0x3,%eax
   118fc:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   118ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   11906:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   1190d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11910:	8b 40 2c             	mov    0x2c(%eax),%eax
   11913:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11916:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11919:	8b 40 28             	mov    0x28(%eax),%eax
   1191c:	85 c0                	test   %eax,%eax
   1191e:	74 1c                	je     1193c <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11920:	8b 45 18             	mov    0x18(%ebp),%eax
   11923:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11925:	83 f8 03             	cmp    $0x3,%eax
   11928:	74 0b                	je     11935 <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   1192a:	8b 45 18             	mov    0x18(%ebp),%eax
   1192d:	8b 40 04             	mov    0x4(%eax),%eax
   11930:	83 f8 07             	cmp    $0x7,%eax
   11933:	77 07                	ja     1193c <filter+0x77>
   11935:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   1193c:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   11940:	75 0a                	jne    1194c <filter+0x87>
   11942:	b8 1f 00 00 00       	mov    $0x1f,%eax
   11947:	e9 5b 07 00 00       	jmp    120a7 <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   1194c:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   11950:	77 7b                	ja     119cd <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   11952:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11955:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   11958:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1195f:	eb 5f                	jmp    119c0 <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11961:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11964:	83 c0 01             	add    $0x1,%eax
   11967:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1196b:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   1196e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11971:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11975:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   11978:	8b 55 9c             	mov    -0x64(%ebp),%edx
   1197b:	8b 45 08             	mov    0x8(%ebp),%eax
   1197e:	01 c2                	add    %eax,%edx
   11980:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11984:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11986:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   1198a:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   1198d:	8b 55 0c             	mov    0xc(%ebp),%edx
   11990:	01 d1                	add    %edx,%ecx
   11992:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11995:	8d 5a 01             	lea    0x1(%edx),%ebx
   11998:	8b 55 08             	mov    0x8(%ebp),%edx
   1199b:	01 da                	add    %ebx,%edx
   1199d:	50                   	push   %eax
   1199e:	ff 75 b0             	pushl  -0x50(%ebp)
   119a1:	ff 75 b4             	pushl  -0x4c(%ebp)
   119a4:	ff 75 f4             	pushl  -0xc(%ebp)
   119a7:	51                   	push   %ecx
   119a8:	52                   	push   %edx
   119a9:	e8 0d fb ff ff       	call   114bb <filterScanline>
   119ae:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   119b1:	8b 55 98             	mov    -0x68(%ebp),%edx
   119b4:	8b 45 0c             	mov    0xc(%ebp),%eax
   119b7:	01 d0                	add    %edx,%eax
   119b9:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   119bc:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   119c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   119c3:	3b 45 14             	cmp    0x14(%ebp),%eax
   119c6:	75 99                	jne    11961 <filter+0x9c>
   119c8:	e9 d7 06 00 00       	jmp    120a4 <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   119cd:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   119d1:	0f 85 e3 01 00 00    	jne    11bba <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   119d7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   119de:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   119e2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   119e6:	eb 2d                	jmp    11a15 <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   119e8:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   119ec:	83 ec 0c             	sub    $0xc,%esp
   119ef:	ff 75 b4             	pushl  -0x4c(%ebp)
   119f2:	e8 2e 19 ff ff       	call   3325 <lodepng_malloc>
   119f7:	83 c4 10             	add    $0x10,%esp
   119fa:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   119fe:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a02:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11a06:	85 c0                	test   %eax,%eax
   11a08:	75 07                	jne    11a11 <filter+0x14c>
   11a0a:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   11a11:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11a15:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11a19:	75 cd                	jne    119e8 <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11a1b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11a1f:	0f 85 6c 01 00 00    	jne    11b91 <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   11a25:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11a2c:	e9 54 01 00 00       	jmp    11b85 <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11a31:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11a35:	e9 d5 00 00 00       	jmp    11b0f <filter+0x24a>
          size_t sum = 0;
   11a3a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11a41:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   11a45:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11a48:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11a4c:	89 c1                	mov    %eax,%ecx
   11a4e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a51:	01 c1                	add    %eax,%ecx
   11a53:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a57:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11a5b:	83 ec 08             	sub    $0x8,%esp
   11a5e:	52                   	push   %edx
   11a5f:	ff 75 b0             	pushl  -0x50(%ebp)
   11a62:	ff 75 b4             	pushl  -0x4c(%ebp)
   11a65:	ff 75 f4             	pushl  -0xc(%ebp)
   11a68:	51                   	push   %ecx
   11a69:	50                   	push   %eax
   11a6a:	e8 4c fa ff ff       	call   114bb <filterScanline>
   11a6f:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   11a72:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11a76:	75 2d                	jne    11aa5 <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   11a78:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11a7f:	eb 1a                	jmp    11a9b <filter+0x1d6>
   11a81:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11a85:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11a89:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11a8c:	01 d0                	add    %edx,%eax
   11a8e:	0f b6 00             	movzbl (%eax),%eax
   11a91:	0f b6 c0             	movzbl %al,%eax
   11a94:	01 45 d8             	add    %eax,-0x28(%ebp)
   11a97:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11a9b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11a9e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11aa1:	75 de                	jne    11a81 <filter+0x1bc>
   11aa3:	eb 4b                	jmp    11af0 <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   11aa5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11aac:	eb 3a                	jmp    11ae8 <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   11aae:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11ab2:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11ab6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ab9:	01 d0                	add    %edx,%eax
   11abb:	0f b6 00             	movzbl (%eax),%eax
   11abe:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   11ac1:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11ac5:	84 c0                	test   %al,%al
   11ac7:	78 06                	js     11acf <filter+0x20a>
   11ac9:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11acd:	eb 0d                	jmp    11adc <filter+0x217>
   11acf:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11ad3:	ba ff 00 00 00       	mov    $0xff,%edx
   11ad8:	29 c2                	sub    %eax,%edx
   11ada:	89 d0                	mov    %edx,%eax
   11adc:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11adf:	01 d0                	add    %edx,%eax
   11ae1:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   11ae4:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11ae8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11aeb:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11aee:	75 be                	jne    11aae <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   11af0:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11af4:	74 08                	je     11afe <filter+0x239>
   11af6:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11af9:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   11afc:	7d 0d                	jge    11b0b <filter+0x246>
            bestType = type;
   11afe:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b02:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   11b05:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11b08:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11b0b:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11b0f:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11b13:	0f 85 21 ff ff ff    	jne    11a3a <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   11b19:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b1c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b20:	89 c2                	mov    %eax,%edx
   11b22:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b25:	01 d0                	add    %edx,%eax
   11b27:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11b2a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b2d:	83 c0 01             	add    $0x1,%eax
   11b30:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b34:	89 c2                	mov    %eax,%edx
   11b36:	8b 45 08             	mov    0x8(%ebp),%eax
   11b39:	01 c2                	add    %eax,%edx
   11b3b:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11b3f:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11b41:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11b48:	eb 2f                	jmp    11b79 <filter+0x2b4>
   11b4a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b4d:	83 c0 01             	add    $0x1,%eax
   11b50:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b54:	89 c2                	mov    %eax,%edx
   11b56:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b59:	01 d0                	add    %edx,%eax
   11b5b:	8d 50 01             	lea    0x1(%eax),%edx
   11b5e:	8b 45 08             	mov    0x8(%ebp),%eax
   11b61:	01 c2                	add    %eax,%edx
   11b63:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11b67:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   11b6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11b6e:	01 c8                	add    %ecx,%eax
   11b70:	0f b6 00             	movzbl (%eax),%eax
   11b73:	88 02                	mov    %al,(%edx)
   11b75:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11b79:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b7c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11b7f:	75 c9                	jne    11b4a <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11b81:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11b85:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b88:	3b 45 14             	cmp    0x14(%ebp),%eax
   11b8b:	0f 85 a0 fe ff ff    	jne    11a31 <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11b91:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11b95:	eb 18                	jmp    11baf <filter+0x2ea>
   11b97:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b9b:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11b9f:	83 ec 0c             	sub    $0xc,%esp
   11ba2:	50                   	push   %eax
   11ba3:	e8 9e 17 ff ff       	call   3346 <lodepng_free>
   11ba8:	83 c4 10             	add    $0x10,%esp
   11bab:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11baf:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11bb3:	75 e2                	jne    11b97 <filter+0x2d2>
   11bb5:	e9 ea 04 00 00       	jmp    120a4 <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   11bba:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   11bbe:	0f 85 17 02 00 00    	jne    11ddb <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   11bc4:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   11bcb:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11bd2:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11bd9:	eb 33                	jmp    11c0e <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11bdb:	83 ec 0c             	sub    $0xc,%esp
   11bde:	ff 75 b4             	pushl  -0x4c(%ebp)
   11be1:	e8 3f 17 ff ff       	call   3325 <lodepng_malloc>
   11be6:	83 c4 10             	add    $0x10,%esp
   11be9:	89 c2                	mov    %eax,%edx
   11beb:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11bee:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11bf5:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11bf8:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11bff:	85 c0                	test   %eax,%eax
   11c01:	75 07                	jne    11c0a <filter+0x345>
   11c03:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11c0a:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11c0e:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11c12:	75 c7                	jne    11bdb <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11c14:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11c18:	0f 85 8f 01 00 00    	jne    11dad <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   11c1e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11c25:	e9 77 01 00 00       	jmp    11da1 <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11c2a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11c31:	e9 f4 00 00 00       	jmp    11d2a <filter+0x465>
          size_t sum = 0;
   11c36:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11c3d:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c40:	0f b6 d0             	movzbl %al,%edx
   11c43:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c46:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c4a:	89 c1                	mov    %eax,%ecx
   11c4c:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c4f:	01 c1                	add    %eax,%ecx
   11c51:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c54:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11c5b:	83 ec 08             	sub    $0x8,%esp
   11c5e:	52                   	push   %edx
   11c5f:	ff 75 b0             	pushl  -0x50(%ebp)
   11c62:	ff 75 b4             	pushl  -0x4c(%ebp)
   11c65:	ff 75 f4             	pushl  -0xc(%ebp)
   11c68:	51                   	push   %ecx
   11c69:	50                   	push   %eax
   11c6a:	e8 4c f8 ff ff       	call   114bb <filterScanline>
   11c6f:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   11c72:	83 ec 04             	sub    $0x4,%esp
   11c75:	68 00 04 00 00       	push   $0x400
   11c7a:	6a 00                	push   $0x0
   11c7c:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11c82:	50                   	push   %eax
   11c83:	e8 0e 17 ff ff       	call   3396 <lodepng_memset>
   11c88:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   11c8b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11c92:	eb 2a                	jmp    11cbe <filter+0x3f9>
   11c94:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11c97:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   11c9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ca1:	01 d0                	add    %edx,%eax
   11ca3:	0f b6 00             	movzbl (%eax),%eax
   11ca6:	0f b6 c0             	movzbl %al,%eax
   11ca9:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   11cb0:	83 c2 01             	add    $0x1,%edx
   11cb3:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   11cba:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11cbe:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11cc1:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11cc4:	75 ce                	jne    11c94 <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   11cc6:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11cc9:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11cd0:	8d 50 01             	lea    0x1(%eax),%edx
   11cd3:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11cd6:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   11cdd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11ce4:	eb 1d                	jmp    11d03 <filter+0x43e>
            sum += ilog2i(count[x]);
   11ce6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ce9:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11cf0:	83 ec 0c             	sub    $0xc,%esp
   11cf3:	50                   	push   %eax
   11cf4:	e8 80 fb ff ff       	call   11879 <ilog2i>
   11cf9:	83 c4 10             	add    $0x10,%esp
   11cfc:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   11cff:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d03:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   11d0a:	75 da                	jne    11ce6 <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   11d0c:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   11d10:	74 08                	je     11d1a <filter+0x455>
   11d12:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11d15:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   11d18:	7e 0c                	jle    11d26 <filter+0x461>
            bestType = type;
   11d1a:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d1d:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   11d20:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11d23:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11d26:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11d2a:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11d2e:	0f 85 02 ff ff ff    	jne    11c36 <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   11d34:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d37:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d3b:	89 c2                	mov    %eax,%edx
   11d3d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d40:	01 d0                	add    %edx,%eax
   11d42:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11d45:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d48:	83 c0 01             	add    $0x1,%eax
   11d4b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d4f:	89 c2                	mov    %eax,%edx
   11d51:	8b 45 08             	mov    0x8(%ebp),%eax
   11d54:	01 d0                	add    %edx,%eax
   11d56:	8b 55 cc             	mov    -0x34(%ebp),%edx
   11d59:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11d5b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d62:	eb 31                	jmp    11d95 <filter+0x4d0>
   11d64:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d67:	83 c0 01             	add    $0x1,%eax
   11d6a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d6e:	89 c2                	mov    %eax,%edx
   11d70:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d73:	01 d0                	add    %edx,%eax
   11d75:	8d 50 01             	lea    0x1(%eax),%edx
   11d78:	8b 45 08             	mov    0x8(%ebp),%eax
   11d7b:	01 c2                	add    %eax,%edx
   11d7d:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11d80:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   11d87:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d8a:	01 c8                	add    %ecx,%eax
   11d8c:	0f b6 00             	movzbl (%eax),%eax
   11d8f:	88 02                	mov    %al,(%edx)
   11d91:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d95:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d98:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11d9b:	75 c7                	jne    11d64 <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11d9d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11da1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11da4:	3b 45 14             	cmp    0x14(%ebp),%eax
   11da7:	0f 85 7d fe ff ff    	jne    11c2a <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11dad:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11db4:	eb 1a                	jmp    11dd0 <filter+0x50b>
   11db6:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11db9:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11dc0:	83 ec 0c             	sub    $0xc,%esp
   11dc3:	50                   	push   %eax
   11dc4:	e8 7d 15 ff ff       	call   3346 <lodepng_free>
   11dc9:	83 c4 10             	add    $0x10,%esp
   11dcc:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11dd0:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11dd4:	75 e0                	jne    11db6 <filter+0x4f1>
   11dd6:	e9 c9 02 00 00       	jmp    120a4 <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   11ddb:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   11ddf:	0f 85 89 00 00 00    	jne    11e6e <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   11de5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11dec:	eb 73                	jmp    11e61 <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11dee:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11df1:	83 c0 01             	add    $0x1,%eax
   11df4:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11df8:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   11dfb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11dfe:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e02:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   11e05:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11e08:	8b 50 30             	mov    0x30(%eax),%edx
   11e0b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e0e:	01 d0                	add    %edx,%eax
   11e10:	0f b6 00             	movzbl (%eax),%eax
   11e13:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   11e16:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11e19:	8b 45 08             	mov    0x8(%ebp),%eax
   11e1c:	01 c2                	add    %eax,%edx
   11e1e:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11e22:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11e24:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11e28:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   11e2b:	8b 55 0c             	mov    0xc(%ebp),%edx
   11e2e:	01 d1                	add    %edx,%ecx
   11e30:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11e33:	8d 5a 01             	lea    0x1(%edx),%ebx
   11e36:	8b 55 08             	mov    0x8(%ebp),%edx
   11e39:	01 da                	add    %ebx,%edx
   11e3b:	83 ec 08             	sub    $0x8,%esp
   11e3e:	50                   	push   %eax
   11e3f:	ff 75 b0             	pushl  -0x50(%ebp)
   11e42:	ff 75 b4             	pushl  -0x4c(%ebp)
   11e45:	ff 75 f4             	pushl  -0xc(%ebp)
   11e48:	51                   	push   %ecx
   11e49:	52                   	push   %edx
   11e4a:	e8 6c f6 ff ff       	call   114bb <filterScanline>
   11e4f:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   11e52:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   11e55:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e58:	01 d0                	add    %edx,%eax
   11e5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   11e5d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11e61:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e64:	3b 45 14             	cmp    0x14(%ebp),%eax
   11e67:	75 85                	jne    11dee <filter+0x529>
   11e69:	e9 36 02 00 00       	jmp    120a4 <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   11e6e:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   11e72:	0f 85 25 02 00 00    	jne    1209d <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11e78:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   11e7f:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11e86:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   11e8d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11e90:	83 ec 04             	sub    $0x4,%esp
   11e93:	6a 24                	push   $0x24
   11e95:	50                   	push   %eax
   11e96:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11e9c:	50                   	push   %eax
   11e9d:	e8 c1 14 ff ff       	call   3363 <lodepng_memcpy>
   11ea2:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   11ea5:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   11eac:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   11eaf:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   11eb6:	00 00 00 
    zlibsettings.custom_deflate = 0;
   11eb9:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   11ec0:	00 00 00 
    for(type = 0; type != 5; ++type) {
   11ec3:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11eca:	eb 33                	jmp    11eff <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11ecc:	83 ec 0c             	sub    $0xc,%esp
   11ecf:	ff 75 b4             	pushl  -0x4c(%ebp)
   11ed2:	e8 4e 14 ff ff       	call   3325 <lodepng_malloc>
   11ed7:	83 c4 10             	add    $0x10,%esp
   11eda:	89 c2                	mov    %eax,%edx
   11edc:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11edf:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11ee6:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11ee9:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11ef0:	85 c0                	test   %eax,%eax
   11ef2:	75 07                	jne    11efb <filter+0x636>
   11ef4:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   11efb:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   11eff:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   11f03:	75 c7                	jne    11ecc <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   11f05:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11f09:	0f 85 63 01 00 00    	jne    12072 <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   11f0f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11f16:	e9 4b 01 00 00       	jmp    12066 <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   11f1b:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11f22:	e9 c8 00 00 00       	jmp    11fef <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   11f27:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f2a:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11f2d:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f30:	0f b6 d0             	movzbl %al,%edx
   11f33:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f36:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11f3a:	89 c1                	mov    %eax,%ecx
   11f3c:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f3f:	01 c1                	add    %eax,%ecx
   11f41:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f44:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11f4b:	83 ec 08             	sub    $0x8,%esp
   11f4e:	52                   	push   %edx
   11f4f:	ff 75 b0             	pushl  -0x50(%ebp)
   11f52:	ff 75 b4             	pushl  -0x4c(%ebp)
   11f55:	ff 75 f4             	pushl  -0xc(%ebp)
   11f58:	51                   	push   %ecx
   11f59:	50                   	push   %eax
   11f5a:	e8 5c f5 ff ff       	call   114bb <filterScanline>
   11f5f:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   11f62:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f65:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   11f6c:	00 00 00 00 
          dummy = 0;
   11f70:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   11f77:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   11f7a:	8b 55 ac             	mov    -0x54(%ebp),%edx
   11f7d:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11f80:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   11f87:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   11f8d:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   11f90:	c1 e3 02             	shl    $0x2,%ebx
   11f93:	01 cb                	add    %ecx,%ebx
   11f95:	83 ec 0c             	sub    $0xc,%esp
   11f98:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   11f9e:	51                   	push   %ecx
   11f9f:	52                   	push   %edx
   11fa0:	50                   	push   %eax
   11fa1:	53                   	push   %ebx
   11fa2:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   11fa8:	50                   	push   %eax
   11fa9:	e8 87 60 ff ff       	call   8035 <zlib_compress>
   11fae:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   11fb1:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   11fb7:	83 ec 0c             	sub    $0xc,%esp
   11fba:	50                   	push   %eax
   11fbb:	e8 86 13 ff ff       	call   3346 <lodepng_free>
   11fc0:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   11fc3:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   11fc7:	74 0f                	je     11fd8 <filter+0x713>
   11fc9:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fcc:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   11fd3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   11fd6:	7d 13                	jge    11feb <filter+0x726>
            bestType = type;
   11fd8:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fdb:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   11fde:	8b 45 c0             	mov    -0x40(%ebp),%eax
   11fe1:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   11fe8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   11feb:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   11fef:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   11ff3:	0f 85 2e ff ff ff    	jne    11f27 <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   11ff9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ffc:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12000:	89 c2                	mov    %eax,%edx
   12002:	8b 45 0c             	mov    0xc(%ebp),%eax
   12005:	01 d0                	add    %edx,%eax
   12007:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   1200a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1200d:	83 c0 01             	add    $0x1,%eax
   12010:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12014:	89 c2                	mov    %eax,%edx
   12016:	8b 45 08             	mov    0x8(%ebp),%eax
   12019:	01 d0                	add    %edx,%eax
   1201b:	8b 55 bc             	mov    -0x44(%ebp),%edx
   1201e:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   12020:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12027:	eb 31                	jmp    1205a <filter+0x795>
   12029:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1202c:	83 c0 01             	add    $0x1,%eax
   1202f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12033:	89 c2                	mov    %eax,%edx
   12035:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12038:	01 d0                	add    %edx,%eax
   1203a:	8d 50 01             	lea    0x1(%eax),%edx
   1203d:	8b 45 08             	mov    0x8(%ebp),%eax
   12040:	01 c2                	add    %eax,%edx
   12042:	8b 45 bc             	mov    -0x44(%ebp),%eax
   12045:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   1204c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1204f:	01 c8                	add    %ecx,%eax
   12051:	0f b6 00             	movzbl (%eax),%eax
   12054:	88 02                	mov    %al,(%edx)
   12056:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1205a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1205d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12060:	75 c7                	jne    12029 <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   12062:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12066:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12069:	3b 45 14             	cmp    0x14(%ebp),%eax
   1206c:	0f 85 a9 fe ff ff    	jne    11f1b <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   12072:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12079:	eb 1a                	jmp    12095 <filter+0x7d0>
   1207b:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1207e:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12085:	83 ec 0c             	sub    $0xc,%esp
   12088:	50                   	push   %eax
   12089:	e8 b8 12 ff ff       	call   3346 <lodepng_free>
   1208e:	83 c4 10             	add    $0x10,%esp
   12091:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12095:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   12099:	75 e0                	jne    1207b <filter+0x7b6>
   1209b:	eb 07                	jmp    120a4 <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   1209d:	b8 58 00 00 00       	mov    $0x58,%eax
   120a2:	eb 03                	jmp    120a7 <filter+0x7e2>

  return error;
   120a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   120a7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   120aa:	c9                   	leave  
   120ab:	c3                   	ret    

000120ac <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   120ac:	55                   	push   %ebp
   120ad:	89 e5                	mov    %esp,%ebp
   120af:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   120b2:	8b 45 10             	mov    0x10(%ebp),%eax
   120b5:	2b 45 14             	sub    0x14(%ebp),%eax
   120b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   120bb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   120c2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   120c9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   120d0:	eb 65                	jmp    12137 <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   120d2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   120d9:	eb 2a                	jmp    12105 <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   120db:	ff 75 0c             	pushl  0xc(%ebp)
   120de:	8d 45 e8             	lea    -0x18(%ebp),%eax
   120e1:	50                   	push   %eax
   120e2:	e8 9d 60 ff ff       	call   8184 <readBitFromReversedStream>
   120e7:	83 c4 08             	add    $0x8,%esp
   120ea:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   120ed:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   120f1:	50                   	push   %eax
   120f2:	ff 75 08             	pushl  0x8(%ebp)
   120f5:	8d 45 ec             	lea    -0x14(%ebp),%eax
   120f8:	50                   	push   %eax
   120f9:	e8 08 61 ff ff       	call   8206 <setBitOfReversedStream>
   120fe:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   12101:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12105:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12108:	3b 45 14             	cmp    0x14(%ebp),%eax
   1210b:	7c ce                	jl     120db <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   1210d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12114:	eb 15                	jmp    1212b <addPaddingBits+0x7f>
   12116:	6a 00                	push   $0x0
   12118:	ff 75 08             	pushl  0x8(%ebp)
   1211b:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1211e:	50                   	push   %eax
   1211f:	e8 e2 60 ff ff       	call   8206 <setBitOfReversedStream>
   12124:	83 c4 0c             	add    $0xc,%esp
   12127:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1212b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1212e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12131:	75 e3                	jne    12116 <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   12133:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12137:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1213a:	3b 45 18             	cmp    0x18(%ebp),%eax
   1213d:	75 93                	jne    120d2 <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   1213f:	90                   	nop
   12140:	c9                   	leave  
   12141:	c3                   	ret    

00012142 <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   12142:	55                   	push   %ebp
   12143:	89 e5                	mov    %esp,%ebp
   12145:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   1214b:	ff 75 18             	pushl  0x18(%ebp)
   1214e:	ff 75 14             	pushl  0x14(%ebp)
   12151:	ff 75 10             	pushl  0x10(%ebp)
   12154:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   1215a:	50                   	push   %eax
   1215b:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   12161:	50                   	push   %eax
   12162:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   12168:	50                   	push   %eax
   12169:	8d 45 94             	lea    -0x6c(%ebp),%eax
   1216c:	50                   	push   %eax
   1216d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12170:	50                   	push   %eax
   12171:	e8 fc ae ff ff       	call   d072 <Adam7_getpassvalues>
   12176:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   12179:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   1217d:	0f 86 0a 01 00 00    	jbe    1228d <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   12183:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1218a:	e9 ef 00 00 00       	jmp    1227e <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   1218f:	8b 45 18             	mov    0x18(%ebp),%eax
   12192:	c1 e8 03             	shr    $0x3,%eax
   12195:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   12198:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1219f:	e9 c6 00 00 00       	jmp    1226a <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   121a4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   121ab:	e9 a6 00 00 00       	jmp    12256 <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   121b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121b3:	8b 14 85 f8 9f 01 00 	mov    0x19ff8(,%eax,4),%edx
   121ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121bd:	8b 04 85 30 a0 01 00 	mov    0x1a030(,%eax,4),%eax
   121c4:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   121c8:	01 d0                	add    %edx,%eax
   121ca:	0f af 45 10          	imul   0x10(%ebp),%eax
   121ce:	89 c2                	mov    %eax,%edx
   121d0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121d3:	8b 04 85 14 a0 01 00 	mov    0x1a014(,%eax,4),%eax
   121da:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   121de:	01 c2                	add    %eax,%edx
   121e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121e3:	8b 04 85 dc 9f 01 00 	mov    0x19fdc(,%eax,4),%eax
   121ea:	01 c2                	add    %eax,%edx
   121ec:	8b 45 e0             	mov    -0x20(%ebp),%eax
   121ef:	0f af c2             	imul   %edx,%eax
   121f2:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   121f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   121f8:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   121ff:	89 c1                	mov    %eax,%ecx
   12201:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12204:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12208:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   1220c:	89 c2                	mov    %eax,%edx
   1220e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12211:	01 c2                	add    %eax,%edx
   12213:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12216:	0f af c2             	imul   %edx,%eax
   12219:	01 c8                	add    %ecx,%eax
   1221b:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   1221e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12225:	eb 23                	jmp    1224a <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   12227:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1222a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1222d:	01 c2                	add    %eax,%edx
   1222f:	8b 45 08             	mov    0x8(%ebp),%eax
   12232:	01 c2                	add    %eax,%edx
   12234:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   12237:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1223a:	01 c1                	add    %eax,%ecx
   1223c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1223f:	01 c8                	add    %ecx,%eax
   12241:	0f b6 00             	movzbl (%eax),%eax
   12244:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   12246:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1224a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1224d:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12250:	72 d5                	jb     12227 <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12252:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12256:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12259:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1225d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   12260:	0f 87 4a ff ff ff    	ja     121b0 <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   12266:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1226a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1226d:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12271:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12274:	0f 87 2a ff ff ff    	ja     121a4 <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   1227a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   1227e:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12282:	0f 85 07 ff ff ff    	jne    1218f <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12288:	e9 22 01 00 00       	jmp    123af <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   1228d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12294:	e9 0c 01 00 00       	jmp    123a5 <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   12299:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1229c:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   122a0:	0f af 45 18          	imul   0x18(%ebp),%eax
   122a4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   122a7:	8b 45 18             	mov    0x18(%ebp),%eax
   122aa:	0f af 45 10          	imul   0x10(%ebp),%eax
   122ae:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   122b1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   122b8:	e9 d4 00 00 00       	jmp    12391 <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   122bd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   122c4:	e9 b4 00 00 00       	jmp    1237d <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   122c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122cc:	8b 14 85 f8 9f 01 00 	mov    0x19ff8(,%eax,4),%edx
   122d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122d6:	8b 04 85 30 a0 01 00 	mov    0x1a030(,%eax,4),%eax
   122dd:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   122e1:	01 d0                	add    %edx,%eax
   122e3:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   122e7:	89 c2                	mov    %eax,%edx
   122e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122ec:	8b 0c 85 dc 9f 01 00 	mov    0x19fdc(,%eax,4),%ecx
   122f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122f6:	8b 04 85 14 a0 01 00 	mov    0x1a014(,%eax,4),%eax
   122fd:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12301:	01 c8                	add    %ecx,%eax
   12303:	0f af 45 18          	imul   0x18(%ebp),%eax
   12307:	01 d0                	add    %edx,%eax
   12309:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   1230f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12312:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   12319:	c1 e0 03             	shl    $0x3,%eax
   1231c:	89 c1                	mov    %eax,%ecx
   1231e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12321:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   12325:	89 c2                	mov    %eax,%edx
   12327:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1232a:	0f af 45 18          	imul   0x18(%ebp),%eax
   1232e:	01 d0                	add    %edx,%eax
   12330:	01 c8                	add    %ecx,%eax
   12332:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   12338:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1233f:	eb 30                	jmp    12371 <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   12341:	ff 75 0c             	pushl  0xc(%ebp)
   12344:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   1234a:	50                   	push   %eax
   1234b:	e8 34 5e ff ff       	call   8184 <readBitFromReversedStream>
   12350:	83 c4 08             	add    $0x8,%esp
   12353:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   12356:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   1235a:	50                   	push   %eax
   1235b:	ff 75 08             	pushl  0x8(%ebp)
   1235e:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   12364:	50                   	push   %eax
   12365:	e8 9c 5e ff ff       	call   8206 <setBitOfReversedStream>
   1236a:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   1236d:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   12371:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12374:	3b 45 18             	cmp    0x18(%ebp),%eax
   12377:	72 c8                	jb     12341 <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12379:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1237d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12380:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12384:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   12387:	0f 87 3c ff ff ff    	ja     122c9 <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   1238d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   12391:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12394:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12398:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1239b:	0f 87 1c ff ff ff    	ja     122bd <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   123a1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   123a5:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   123a9:	0f 85 ea fe ff ff    	jne    12299 <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   123af:	90                   	nop
   123b0:	c9                   	leave  
   123b1:	c3                   	ret    

000123b2 <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   123b2:	55                   	push   %ebp
   123b3:	89 e5                	mov    %esp,%ebp
   123b5:	57                   	push   %edi
   123b6:	56                   	push   %esi
   123b7:	53                   	push   %ebx
   123b8:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   123be:	8b 45 1c             	mov    0x1c(%ebp),%eax
   123c1:	83 c0 0c             	add    $0xc,%eax
   123c4:	50                   	push   %eax
   123c5:	e8 77 6a ff ff       	call   8e41 <lodepng_get_bpp>
   123ca:	83 c4 04             	add    $0x4,%esp
   123cd:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   123d0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   123d7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   123da:	8b 40 08             	mov    0x8(%eax),%eax
   123dd:	85 c0                	test   %eax,%eax
   123df:	0f 85 49 01 00 00    	jne    1252e <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   123e5:	8b 45 14             	mov    0x14(%ebp),%eax
   123e8:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   123ec:	83 c0 07             	add    $0x7,%eax
   123ef:	c1 e8 03             	shr    $0x3,%eax
   123f2:	83 c0 01             	add    $0x1,%eax
   123f5:	0f af 45 18          	imul   0x18(%ebp),%eax
   123f9:	89 c2                	mov    %eax,%edx
   123fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   123fe:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   12400:	8b 45 0c             	mov    0xc(%ebp),%eax
   12403:	8b 00                	mov    (%eax),%eax
   12405:	83 ec 0c             	sub    $0xc,%esp
   12408:	50                   	push   %eax
   12409:	e8 17 0f ff ff       	call   3325 <lodepng_malloc>
   1240e:	83 c4 10             	add    $0x10,%esp
   12411:	89 c2                	mov    %eax,%edx
   12413:	8b 45 08             	mov    0x8(%ebp),%eax
   12416:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   12418:	8b 45 08             	mov    0x8(%ebp),%eax
   1241b:	8b 00                	mov    (%eax),%eax
   1241d:	85 c0                	test   %eax,%eax
   1241f:	75 10                	jne    12431 <preProcessScanlines+0x7f>
   12421:	8b 45 0c             	mov    0xc(%ebp),%eax
   12424:	8b 00                	mov    (%eax),%eax
   12426:	85 c0                	test   %eax,%eax
   12428:	74 07                	je     12431 <preProcessScanlines+0x7f>
   1242a:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   12431:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12435:	0f 85 fb 02 00 00    	jne    12736 <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   1243b:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   1243f:	0f 87 bd 00 00 00    	ja     12502 <preProcessScanlines+0x150>
   12445:	8b 45 14             	mov    0x14(%ebp),%eax
   12448:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1244c:	89 c2                	mov    %eax,%edx
   1244e:	8b 45 14             	mov    0x14(%ebp),%eax
   12451:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12455:	83 c0 07             	add    $0x7,%eax
   12458:	c1 e8 03             	shr    $0x3,%eax
   1245b:	c1 e0 03             	shl    $0x3,%eax
   1245e:	39 c2                	cmp    %eax,%edx
   12460:	0f 84 9c 00 00 00    	je     12502 <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   12466:	8b 45 14             	mov    0x14(%ebp),%eax
   12469:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1246d:	83 c0 07             	add    $0x7,%eax
   12470:	c1 e8 03             	shr    $0x3,%eax
   12473:	0f af 45 18          	imul   0x18(%ebp),%eax
   12477:	83 ec 0c             	sub    $0xc,%esp
   1247a:	50                   	push   %eax
   1247b:	e8 a5 0e ff ff       	call   3325 <lodepng_malloc>
   12480:	83 c4 10             	add    $0x10,%esp
   12483:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   12486:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1248a:	75 07                	jne    12493 <preProcessScanlines+0xe1>
   1248c:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   12493:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12497:	75 56                	jne    124ef <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   12499:	8b 45 14             	mov    0x14(%ebp),%eax
   1249c:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   124a0:	89 c2                	mov    %eax,%edx
   124a2:	8b 45 14             	mov    0x14(%ebp),%eax
   124a5:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   124a9:	83 c0 07             	add    $0x7,%eax
   124ac:	c1 e8 03             	shr    $0x3,%eax
   124af:	c1 e0 03             	shl    $0x3,%eax
   124b2:	83 ec 0c             	sub    $0xc,%esp
   124b5:	ff 75 18             	pushl  0x18(%ebp)
   124b8:	52                   	push   %edx
   124b9:	50                   	push   %eax
   124ba:	ff 75 10             	pushl  0x10(%ebp)
   124bd:	ff 75 d8             	pushl  -0x28(%ebp)
   124c0:	e8 e7 fb ff ff       	call   120ac <addPaddingBits>
   124c5:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   124c8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   124cb:	8d 50 0c             	lea    0xc(%eax),%edx
   124ce:	8b 45 08             	mov    0x8(%ebp),%eax
   124d1:	8b 00                	mov    (%eax),%eax
   124d3:	83 ec 08             	sub    $0x8,%esp
   124d6:	ff 75 20             	pushl  0x20(%ebp)
   124d9:	52                   	push   %edx
   124da:	ff 75 18             	pushl  0x18(%ebp)
   124dd:	ff 75 14             	pushl  0x14(%ebp)
   124e0:	ff 75 d8             	pushl  -0x28(%ebp)
   124e3:	50                   	push   %eax
   124e4:	e8 dc f3 ff ff       	call   118c5 <filter>
   124e9:	83 c4 20             	add    $0x20,%esp
   124ec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   124ef:	83 ec 0c             	sub    $0xc,%esp
   124f2:	ff 75 d8             	pushl  -0x28(%ebp)
   124f5:	e8 4c 0e ff ff       	call   3346 <lodepng_free>
   124fa:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   124fd:	e9 34 02 00 00       	jmp    12736 <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   12502:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12505:	8d 50 0c             	lea    0xc(%eax),%edx
   12508:	8b 45 08             	mov    0x8(%ebp),%eax
   1250b:	8b 00                	mov    (%eax),%eax
   1250d:	83 ec 08             	sub    $0x8,%esp
   12510:	ff 75 20             	pushl  0x20(%ebp)
   12513:	52                   	push   %edx
   12514:	ff 75 18             	pushl  0x18(%ebp)
   12517:	ff 75 14             	pushl  0x14(%ebp)
   1251a:	ff 75 10             	pushl  0x10(%ebp)
   1251d:	50                   	push   %eax
   1251e:	e8 a2 f3 ff ff       	call   118c5 <filter>
   12523:	83 c4 20             	add    $0x20,%esp
   12526:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   12529:	e9 08 02 00 00       	jmp    12736 <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   1252e:	ff 75 dc             	pushl  -0x24(%ebp)
   12531:	ff 75 18             	pushl  0x18(%ebp)
   12534:	ff 75 14             	pushl  0x14(%ebp)
   12537:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   1253d:	50                   	push   %eax
   1253e:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   12544:	50                   	push   %eax
   12545:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   1254b:	50                   	push   %eax
   1254c:	8d 45 98             	lea    -0x68(%ebp),%eax
   1254f:	50                   	push   %eax
   12550:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   12553:	50                   	push   %eax
   12554:	e8 19 ab ff ff       	call   d072 <Adam7_getpassvalues>
   12559:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   1255c:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   12562:	8b 45 0c             	mov    0xc(%ebp),%eax
   12565:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   12567:	8b 45 0c             	mov    0xc(%ebp),%eax
   1256a:	8b 00                	mov    (%eax),%eax
   1256c:	83 ec 0c             	sub    $0xc,%esp
   1256f:	50                   	push   %eax
   12570:	e8 b0 0d ff ff       	call   3325 <lodepng_malloc>
   12575:	83 c4 10             	add    $0x10,%esp
   12578:	89 c2                	mov    %eax,%edx
   1257a:	8b 45 08             	mov    0x8(%ebp),%eax
   1257d:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   1257f:	8b 45 08             	mov    0x8(%ebp),%eax
   12582:	8b 00                	mov    (%eax),%eax
   12584:	85 c0                	test   %eax,%eax
   12586:	75 07                	jne    1258f <preProcessScanlines+0x1dd>
   12588:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   1258f:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12592:	83 ec 0c             	sub    $0xc,%esp
   12595:	50                   	push   %eax
   12596:	e8 8a 0d ff ff       	call   3325 <lodepng_malloc>
   1259b:	83 c4 10             	add    $0x10,%esp
   1259e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   125a1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   125a5:	75 0e                	jne    125b5 <preProcessScanlines+0x203>
   125a7:	8b 45 94             	mov    -0x6c(%ebp),%eax
   125aa:	85 c0                	test   %eax,%eax
   125ac:	74 07                	je     125b5 <preProcessScanlines+0x203>
   125ae:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   125b5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   125b9:	0f 85 69 01 00 00    	jne    12728 <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   125bf:	83 ec 0c             	sub    $0xc,%esp
   125c2:	ff 75 dc             	pushl  -0x24(%ebp)
   125c5:	ff 75 18             	pushl  0x18(%ebp)
   125c8:	ff 75 14             	pushl  0x14(%ebp)
   125cb:	ff 75 10             	pushl  0x10(%ebp)
   125ce:	ff 75 d4             	pushl  -0x2c(%ebp)
   125d1:	e8 6c fb ff ff       	call   12142 <Adam7_interlace>
   125d6:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   125d9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   125e0:	e9 36 01 00 00       	jmp    1271b <preProcessScanlines+0x369>
        if(bpp < 8) {
   125e5:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   125e9:	0f 87 d6 00 00 00    	ja     126c5 <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   125ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
   125f2:	83 c0 01             	add    $0x1,%eax
   125f5:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   125fc:	8b 45 e0             	mov    -0x20(%ebp),%eax
   125ff:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   12606:	29 c2                	sub    %eax,%edx
   12608:	89 d0                	mov    %edx,%eax
   1260a:	83 ec 0c             	sub    $0xc,%esp
   1260d:	50                   	push   %eax
   1260e:	e8 12 0d ff ff       	call   3325 <lodepng_malloc>
   12613:	83 c4 10             	add    $0x10,%esp
   12616:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   12619:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   1261d:	75 0c                	jne    1262b <preProcessScanlines+0x279>
   1261f:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   12626:	e9 fd 00 00 00       	jmp    12728 <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   1262b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1262e:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   12632:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12635:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12639:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   1263d:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   1263f:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12642:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12646:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   1264a:	83 c2 07             	add    $0x7,%edx
   1264d:	c1 ea 03             	shr    $0x3,%edx
   12650:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   12653:	89 d1                	mov    %edx,%ecx
   12655:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12658:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   1265f:	89 d6                	mov    %edx,%esi
   12661:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   12664:	01 f2                	add    %esi,%edx
   12666:	83 ec 0c             	sub    $0xc,%esp
   12669:	50                   	push   %eax
   1266a:	53                   	push   %ebx
   1266b:	51                   	push   %ecx
   1266c:	52                   	push   %edx
   1266d:	ff 75 d0             	pushl  -0x30(%ebp)
   12670:	e8 37 fa ff ff       	call   120ac <addPaddingBits>
   12675:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   12678:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1267b:	8d 58 0c             	lea    0xc(%eax),%ebx
   1267e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12681:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12685:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12688:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   1268c:	8b 4d 08             	mov    0x8(%ebp),%ecx
   1268f:	8b 31                	mov    (%ecx),%esi
   12691:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12694:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   1269b:	01 f1                	add    %esi,%ecx
   1269d:	83 ec 08             	sub    $0x8,%esp
   126a0:	ff 75 20             	pushl  0x20(%ebp)
   126a3:	53                   	push   %ebx
   126a4:	52                   	push   %edx
   126a5:	50                   	push   %eax
   126a6:	ff 75 d0             	pushl  -0x30(%ebp)
   126a9:	51                   	push   %ecx
   126aa:	e8 16 f2 ff ff       	call   118c5 <filter>
   126af:	83 c4 20             	add    $0x20,%esp
   126b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   126b5:	83 ec 0c             	sub    $0xc,%esp
   126b8:	ff 75 d0             	pushl  -0x30(%ebp)
   126bb:	e8 86 0c ff ff       	call   3346 <lodepng_free>
   126c0:	83 c4 10             	add    $0x10,%esp
   126c3:	eb 4c                	jmp    12711 <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   126c5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   126c8:	8d 70 0c             	lea    0xc(%eax),%esi
   126cb:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126ce:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   126d2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126d5:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   126d9:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   126dc:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   126e3:	89 cb                	mov    %ecx,%ebx
   126e5:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   126e8:	01 cb                	add    %ecx,%ebx
   126ea:	8b 4d 08             	mov    0x8(%ebp),%ecx
   126ed:	8b 39                	mov    (%ecx),%edi
   126ef:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   126f2:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   126f9:	01 f9                	add    %edi,%ecx
   126fb:	83 ec 08             	sub    $0x8,%esp
   126fe:	ff 75 20             	pushl  0x20(%ebp)
   12701:	56                   	push   %esi
   12702:	52                   	push   %edx
   12703:	50                   	push   %eax
   12704:	53                   	push   %ebx
   12705:	51                   	push   %ecx
   12706:	e8 ba f1 ff ff       	call   118c5 <filter>
   1270b:	83 c4 20             	add    $0x20,%esp
   1270e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   12711:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12715:	75 10                	jne    12727 <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   12717:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   1271b:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   1271f:	0f 85 c0 fe ff ff    	jne    125e5 <preProcessScanlines+0x233>
   12725:	eb 01                	jmp    12728 <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   12727:	90                   	nop
      }
    }

    lodepng_free(adam7);
   12728:	83 ec 0c             	sub    $0xc,%esp
   1272b:	ff 75 d4             	pushl  -0x2c(%ebp)
   1272e:	e8 13 0c ff ff       	call   3346 <lodepng_free>
   12733:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   12736:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   12739:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1273c:	5b                   	pop    %ebx
   1273d:	5e                   	pop    %esi
   1273e:	5f                   	pop    %edi
   1273f:	5d                   	pop    %ebp
   12740:	c3                   	ret    

00012741 <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   12741:	55                   	push   %ebp
   12742:	89 e5                	mov    %esp,%ebp
   12744:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   12747:	8b 45 0c             	mov    0xc(%ebp),%eax
   1274a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   1274d:	eb 47                	jmp    12796 <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   1274f:	8b 45 08             	mov    0x8(%ebp),%eax
   12752:	8d 50 04             	lea    0x4(%eax),%edx
   12755:	8b 45 08             	mov    0x8(%ebp),%eax
   12758:	ff 75 fc             	pushl  -0x4(%ebp)
   1275b:	52                   	push   %edx
   1275c:	50                   	push   %eax
   1275d:	e8 73 5f ff ff       	call   86d5 <lodepng_chunk_append>
   12762:	83 c4 0c             	add    $0xc,%esp
   12765:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12768:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   1276c:	74 05                	je     12773 <addUnknownChunks+0x32>
   1276e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12771:	eb 37                	jmp    127aa <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   12773:	8b 45 08             	mov    0x8(%ebp),%eax
   12776:	8b 50 04             	mov    0x4(%eax),%edx
   12779:	8b 45 08             	mov    0x8(%ebp),%eax
   1277c:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   1277f:	8b 55 10             	mov    0x10(%ebp),%edx
   12782:	8b 45 0c             	mov    0xc(%ebp),%eax
   12785:	01 d0                	add    %edx,%eax
   12787:	50                   	push   %eax
   12788:	ff 75 fc             	pushl  -0x4(%ebp)
   1278b:	e8 ff 5c ff ff       	call   848f <lodepng_chunk_next>
   12790:	83 c4 08             	add    $0x8,%esp
   12793:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   12796:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12799:	8b 45 0c             	mov    0xc(%ebp),%eax
   1279c:	29 c2                	sub    %eax,%edx
   1279e:	89 d0                	mov    %edx,%eax
   127a0:	3b 45 10             	cmp    0x10(%ebp),%eax
   127a3:	7c aa                	jl     1274f <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   127a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
   127aa:	c9                   	leave  
   127ab:	c3                   	ret    

000127ac <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   127ac:	55                   	push   %ebp
   127ad:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   127af:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   127b3:	77 07                	ja     127bc <isGrayICCProfile+0x10>
   127b5:	b8 00 00 00 00       	mov    $0x0,%eax
   127ba:	eb 40                	jmp    127fc <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   127bc:	8b 45 08             	mov    0x8(%ebp),%eax
   127bf:	83 c0 10             	add    $0x10,%eax
   127c2:	0f b6 00             	movzbl (%eax),%eax
   127c5:	3c 47                	cmp    $0x47,%al
   127c7:	75 2e                	jne    127f7 <isGrayICCProfile+0x4b>
   127c9:	8b 45 08             	mov    0x8(%ebp),%eax
   127cc:	83 c0 11             	add    $0x11,%eax
   127cf:	0f b6 00             	movzbl (%eax),%eax
   127d2:	3c 52                	cmp    $0x52,%al
   127d4:	75 21                	jne    127f7 <isGrayICCProfile+0x4b>
   127d6:	8b 45 08             	mov    0x8(%ebp),%eax
   127d9:	83 c0 12             	add    $0x12,%eax
   127dc:	0f b6 00             	movzbl (%eax),%eax
   127df:	3c 41                	cmp    $0x41,%al
   127e1:	75 14                	jne    127f7 <isGrayICCProfile+0x4b>
   127e3:	8b 45 08             	mov    0x8(%ebp),%eax
   127e6:	83 c0 13             	add    $0x13,%eax
   127e9:	0f b6 00             	movzbl (%eax),%eax
   127ec:	3c 59                	cmp    $0x59,%al
   127ee:	75 07                	jne    127f7 <isGrayICCProfile+0x4b>
   127f0:	b8 01 00 00 00       	mov    $0x1,%eax
   127f5:	eb 05                	jmp    127fc <isGrayICCProfile+0x50>
   127f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
   127fc:	5d                   	pop    %ebp
   127fd:	c3                   	ret    

000127fe <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   127fe:	55                   	push   %ebp
   127ff:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   12801:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12805:	77 07                	ja     1280e <isRGBICCProfile+0x10>
   12807:	b8 00 00 00 00       	mov    $0x0,%eax
   1280c:	eb 40                	jmp    1284e <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   1280e:	8b 45 08             	mov    0x8(%ebp),%eax
   12811:	83 c0 10             	add    $0x10,%eax
   12814:	0f b6 00             	movzbl (%eax),%eax
   12817:	3c 52                	cmp    $0x52,%al
   12819:	75 2e                	jne    12849 <isRGBICCProfile+0x4b>
   1281b:	8b 45 08             	mov    0x8(%ebp),%eax
   1281e:	83 c0 11             	add    $0x11,%eax
   12821:	0f b6 00             	movzbl (%eax),%eax
   12824:	3c 47                	cmp    $0x47,%al
   12826:	75 21                	jne    12849 <isRGBICCProfile+0x4b>
   12828:	8b 45 08             	mov    0x8(%ebp),%eax
   1282b:	83 c0 12             	add    $0x12,%eax
   1282e:	0f b6 00             	movzbl (%eax),%eax
   12831:	3c 42                	cmp    $0x42,%al
   12833:	75 14                	jne    12849 <isRGBICCProfile+0x4b>
   12835:	8b 45 08             	mov    0x8(%ebp),%eax
   12838:	83 c0 13             	add    $0x13,%eax
   1283b:	0f b6 00             	movzbl (%eax),%eax
   1283e:	3c 20                	cmp    $0x20,%al
   12840:	75 07                	jne    12849 <isRGBICCProfile+0x4b>
   12842:	b8 01 00 00 00       	mov    $0x1,%eax
   12847:	eb 05                	jmp    1284e <isRGBICCProfile+0x50>
   12849:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1284e:	5d                   	pop    %ebp
   1284f:	c3                   	ret    

00012850 <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   12850:	55                   	push   %ebp
   12851:	89 e5                	mov    %esp,%ebp
   12853:	57                   	push   %edi
   12854:	56                   	push   %esi
   12855:	53                   	push   %ebx
   12856:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   1285c:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   12863:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   1286a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1286d:	6a 00                	push   $0x0
   1286f:	6a 00                	push   $0x0
   12871:	50                   	push   %eax
   12872:	e8 6f 0d ff ff       	call   35e6 <ucvector_init>
   12877:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   1287a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1287d:	05 98 00 00 00       	add    $0x98,%eax
   12882:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   12885:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1288b:	50                   	push   %eax
   1288c:	e8 3a 71 ff ff       	call   99cb <lodepng_info_init>
   12891:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   12894:	8b 45 08             	mov    0x8(%ebp),%eax
   12897:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   1289d:	8b 45 0c             	mov    0xc(%ebp),%eax
   128a0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   128a6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128a9:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   128b0:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   128b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128b6:	8b 40 0c             	mov    0xc(%eax),%eax
   128b9:	83 f8 03             	cmp    $0x3,%eax
   128bc:	74 0a                	je     128c8 <lodepng_encode+0x78>
   128be:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128c1:	8b 40 6c             	mov    0x6c(%eax),%eax
   128c4:	85 c0                	test   %eax,%eax
   128c6:	74 29                	je     128f1 <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   128c8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128cb:	8b 40 18             	mov    0x18(%eax),%eax
   128ce:	85 c0                	test   %eax,%eax
   128d0:	74 0d                	je     128df <lodepng_encode+0x8f>
   128d2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   128d5:	8b 40 18             	mov    0x18(%eax),%eax
   128d8:	3d 00 01 00 00       	cmp    $0x100,%eax
   128dd:	7e 12                	jle    128f1 <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   128df:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128e2:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   128e9:	00 00 00 
    goto cleanup;
   128ec:	e9 78 0c 00 00       	jmp    13569 <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   128f1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128f4:	8b 40 38             	mov    0x38(%eax),%eax
   128f7:	83 f8 02             	cmp    $0x2,%eax
   128fa:	76 12                	jbe    1290e <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   128fc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   128ff:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   12906:	00 00 00 
    goto cleanup;
   12909:	e9 5b 0c 00 00       	jmp    13569 <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   1290e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12911:	8b 40 08             	mov    0x8(%eax),%eax
   12914:	83 f8 01             	cmp    $0x1,%eax
   12917:	76 12                	jbe    1292b <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   12919:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1291c:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   12923:	00 00 00 
    goto cleanup;
   12926:	e9 3e 0c 00 00       	jmp    13569 <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   1292b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1292e:	8b 50 10             	mov    0x10(%eax),%edx
   12931:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12934:	8b 40 0c             	mov    0xc(%eax),%eax
   12937:	52                   	push   %edx
   12938:	50                   	push   %eax
   12939:	e8 a4 5f ff ff       	call   88e2 <checkColorValidity>
   1293e:	83 c4 08             	add    $0x8,%esp
   12941:	89 c2                	mov    %eax,%edx
   12943:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12946:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   1294c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1294f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12955:	85 c0                	test   %eax,%eax
   12957:	0f 85 c6 0b 00 00    	jne    13523 <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   1295d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12960:	8b 50 7c             	mov    0x7c(%eax),%edx
   12963:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12966:	8b 40 78             	mov    0x78(%eax),%eax
   12969:	52                   	push   %edx
   1296a:	50                   	push   %eax
   1296b:	e8 72 5f ff ff       	call   88e2 <checkColorValidity>
   12970:	83 c4 08             	add    $0x8,%esp
   12973:	89 c2                	mov    %eax,%edx
   12975:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12978:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   1297e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12981:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12987:	85 c0                	test   %eax,%eax
   12989:	0f 85 97 0b 00 00    	jne    13526 <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   1298f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12992:	05 98 00 00 00       	add    $0x98,%eax
   12997:	83 ec 08             	sub    $0x8,%esp
   1299a:	50                   	push   %eax
   1299b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   129a1:	50                   	push   %eax
   129a2:	e8 58 71 ff ff       	call   9aff <lodepng_info_copy>
   129a7:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   129aa:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129ad:	8b 40 5c             	mov    0x5c(%eax),%eax
   129b0:	85 c0                	test   %eax,%eax
   129b2:	0f 84 3c 02 00 00    	je     12bf4 <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   129b8:	83 ec 0c             	sub    $0xc,%esp
   129bb:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   129c1:	50                   	push   %eax
   129c2:	e8 5f 96 ff ff       	call   c026 <lodepng_color_stats_init>
   129c7:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   129ca:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129cd:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   129d3:	85 c0                	test   %eax,%eax
   129d5:	74 2d                	je     12a04 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   129d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129da:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   129e0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129e3:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   129e9:	83 ec 08             	sub    $0x8,%esp
   129ec:	52                   	push   %edx
   129ed:	50                   	push   %eax
   129ee:	e8 b9 fd ff ff       	call   127ac <isGrayICCProfile>
   129f3:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   129f6:	85 c0                	test   %eax,%eax
   129f8:	74 0a                	je     12a04 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   129fa:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   12a01:	00 00 00 
    }
    if(info_png->iccp_defined &&
   12a04:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a07:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12a0d:	85 c0                	test   %eax,%eax
   12a0f:	74 2d                	je     12a3e <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12a11:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a14:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12a1a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a1d:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12a23:	83 ec 08             	sub    $0x8,%esp
   12a26:	52                   	push   %edx
   12a27:	50                   	push   %eax
   12a28:	e8 d1 fd ff ff       	call   127fe <isRGBICCProfile>
   12a2d:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   12a30:	85 c0                	test   %eax,%eax
   12a32:	74 0a                	je     12a3e <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   12a34:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   12a3b:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   12a3e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a41:	83 c0 78             	add    $0x78,%eax
   12a44:	83 ec 0c             	sub    $0xc,%esp
   12a47:	50                   	push   %eax
   12a48:	ff 75 18             	pushl  0x18(%ebp)
   12a4b:	ff 75 14             	pushl  0x14(%ebp)
   12a4e:	ff 75 10             	pushl  0x10(%ebp)
   12a51:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12a57:	50                   	push   %eax
   12a58:	e8 e0 96 ff ff       	call   c13d <lodepng_compute_color_stats>
   12a5d:	83 c4 20             	add    $0x20,%esp
   12a60:	89 c2                	mov    %eax,%edx
   12a62:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a65:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12a6b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a6e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12a74:	85 c0                	test   %eax,%eax
   12a76:	0f 85 ad 0a 00 00    	jne    13529 <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   12a7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a7f:	8b 40 2c             	mov    0x2c(%eax),%eax
   12a82:	85 c0                	test   %eax,%eax
   12a84:	0f 84 be 00 00 00    	je     12b48 <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   12a8a:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   12a91:	00 00 00 
   12a94:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   12a9b:	00 00 00 
   12a9e:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   12aa5:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   12aa8:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   12aae:	83 ec 04             	sub    $0x4,%esp
   12ab1:	6a 10                	push   $0x10
   12ab3:	6a 02                	push   $0x2
   12ab5:	50                   	push   %eax
   12ab6:	e8 15 61 ff ff       	call   8bd0 <lodepng_color_mode_make>
   12abb:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   12abe:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ac1:	8d 58 0c             	lea    0xc(%eax),%ebx
   12ac4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ac7:	8b 48 38             	mov    0x38(%eax),%ecx
   12aca:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12acd:	8b 50 34             	mov    0x34(%eax),%edx
   12ad0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ad3:	8b 40 30             	mov    0x30(%eax),%eax
   12ad6:	53                   	push   %ebx
   12ad7:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   12add:	53                   	push   %ebx
   12ade:	51                   	push   %ecx
   12adf:	52                   	push   %edx
   12ae0:	50                   	push   %eax
   12ae1:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   12ae7:	50                   	push   %eax
   12ae8:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   12aee:	50                   	push   %eax
   12aef:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   12af5:	50                   	push   %eax
   12af6:	e8 8a 92 ff ff       	call   bd85 <lodepng_convert_rgb>
   12afb:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   12afe:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   12b04:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   12b0a:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   12b10:	83 ec 0c             	sub    $0xc,%esp
   12b13:	68 ff ff 00 00       	push   $0xffff
   12b18:	51                   	push   %ecx
   12b19:	52                   	push   %edx
   12b1a:	50                   	push   %eax
   12b1b:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12b21:	50                   	push   %eax
   12b22:	e8 26 a1 ff ff       	call   cc4d <lodepng_color_stats_add>
   12b27:	83 c4 20             	add    $0x20,%esp
   12b2a:	89 c2                	mov    %eax,%edx
   12b2c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b2f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12b35:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b38:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12b3e:	85 c0                	test   %eax,%eax
   12b40:	74 06                	je     12b48 <lodepng_encode+0x2f8>
   12b42:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   12b43:	e9 e1 09 00 00       	jmp    13529 <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   12b48:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b4b:	8d 50 78             	lea    0x78(%eax),%edx
   12b4e:	83 ec 04             	sub    $0x4,%esp
   12b51:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12b57:	50                   	push   %eax
   12b58:	52                   	push   %edx
   12b59:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12b5f:	83 c0 0c             	add    $0xc,%eax
   12b62:	50                   	push   %eax
   12b63:	e8 79 a1 ff ff       	call   cce1 <auto_choose_color>
   12b68:	83 c4 10             	add    $0x10,%esp
   12b6b:	89 c2                	mov    %eax,%edx
   12b6d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b70:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12b76:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b79:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12b7f:	85 c0                	test   %eax,%eax
   12b81:	0f 85 a5 09 00 00    	jne    1352c <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   12b87:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b8a:	8b 40 2c             	mov    0x2c(%eax),%eax
   12b8d:	85 c0                	test   %eax,%eax
   12b8f:	74 63                	je     12bf4 <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   12b91:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b94:	8d 58 0c             	lea    0xc(%eax),%ebx
   12b97:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b9a:	8b 48 38             	mov    0x38(%eax),%ecx
   12b9d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ba0:	8b 50 34             	mov    0x34(%eax),%edx
   12ba3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ba6:	8b 40 30             	mov    0x30(%eax),%eax
   12ba9:	53                   	push   %ebx
   12baa:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   12bb0:	83 c3 0c             	add    $0xc,%ebx
   12bb3:	53                   	push   %ebx
   12bb4:	51                   	push   %ecx
   12bb5:	52                   	push   %edx
   12bb6:	50                   	push   %eax
   12bb7:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12bbd:	83 c0 38             	add    $0x38,%eax
   12bc0:	50                   	push   %eax
   12bc1:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12bc7:	83 c0 34             	add    $0x34,%eax
   12bca:	50                   	push   %eax
   12bcb:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12bd1:	83 c0 30             	add    $0x30,%eax
   12bd4:	50                   	push   %eax
   12bd5:	e8 ab 91 ff ff       	call   bd85 <lodepng_convert_rgb>
   12bda:	83 c4 20             	add    $0x20,%esp
   12bdd:	85 c0                	test   %eax,%eax
   12bdf:	74 13                	je     12bf4 <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   12be1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12be4:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   12beb:	00 00 00 
        goto cleanup;
   12bee:	90                   	nop
   12bef:	e9 75 09 00 00       	jmp    13569 <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   12bf4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bf7:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12bfd:	85 c0                	test   %eax,%eax
   12bff:	0f 84 b2 00 00 00    	je     12cb7 <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12c05:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c08:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12c0e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c11:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12c17:	83 ec 08             	sub    $0x8,%esp
   12c1a:	52                   	push   %edx
   12c1b:	50                   	push   %eax
   12c1c:	e8 8b fb ff ff       	call   127ac <isGrayICCProfile>
   12c21:	83 c4 10             	add    $0x10,%esp
   12c24:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12c27:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c2a:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12c30:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c33:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12c39:	83 ec 08             	sub    $0x8,%esp
   12c3c:	52                   	push   %edx
   12c3d:	50                   	push   %eax
   12c3e:	e8 bb fb ff ff       	call   127fe <isRGBICCProfile>
   12c43:	83 c4 10             	add    $0x10,%esp
   12c46:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   12c49:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12c4f:	85 c0                	test   %eax,%eax
   12c51:	74 0b                	je     12c5e <lodepng_encode+0x40e>
   12c53:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12c59:	83 f8 04             	cmp    $0x4,%eax
   12c5c:	75 07                	jne    12c65 <lodepng_encode+0x415>
   12c5e:	b8 01 00 00 00       	mov    $0x1,%eax
   12c63:	eb 05                	jmp    12c6a <lodepng_encode+0x41a>
   12c65:	b8 00 00 00 00       	mov    $0x0,%eax
   12c6a:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   12c6d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12c71:	75 18                	jne    12c8b <lodepng_encode+0x43b>
   12c73:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12c77:	75 12                	jne    12c8b <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   12c79:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c7c:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   12c83:	00 00 00 
      goto cleanup;
   12c86:	e9 de 08 00 00       	jmp    13569 <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   12c8b:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12c8e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   12c91:	74 24                	je     12cb7 <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   12c93:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c96:	8b 40 5c             	mov    0x5c(%eax),%eax
   12c99:	85 c0                	test   %eax,%eax
   12c9b:	74 07                	je     12ca4 <lodepng_encode+0x454>
   12c9d:	ba 66 00 00 00       	mov    $0x66,%edx
   12ca2:	eb 05                	jmp    12ca9 <lodepng_encode+0x459>
   12ca4:	ba 65 00 00 00       	mov    $0x65,%edx
   12ca9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cac:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   12cb2:	e9 b2 08 00 00       	jmp    13569 <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   12cb7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cba:	83 c0 78             	add    $0x78,%eax
   12cbd:	83 ec 08             	sub    $0x8,%esp
   12cc0:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   12cc6:	83 c2 0c             	add    $0xc,%edx
   12cc9:	52                   	push   %edx
   12cca:	50                   	push   %eax
   12ccb:	e8 57 5f ff ff       	call   8c27 <lodepng_color_mode_equal>
   12cd0:	83 c4 10             	add    $0x10,%esp
   12cd3:	85 c0                	test   %eax,%eax
   12cd5:	0f 85 f8 00 00 00    	jne    12dd3 <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   12cdb:	8b 55 14             	mov    0x14(%ebp),%edx
   12cde:	8b 45 18             	mov    0x18(%ebp),%eax
   12ce1:	89 d3                	mov    %edx,%ebx
   12ce3:	0f af d8             	imul   %eax,%ebx
   12ce6:	83 ec 0c             	sub    $0xc,%esp
   12ce9:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12cef:	83 c0 0c             	add    $0xc,%eax
   12cf2:	50                   	push   %eax
   12cf3:	e8 49 61 ff ff       	call   8e41 <lodepng_get_bpp>
   12cf8:	83 c4 10             	add    $0x10,%esp
   12cfb:	0f af c3             	imul   %ebx,%eax
   12cfe:	83 c0 07             	add    $0x7,%eax
   12d01:	c1 e8 03             	shr    $0x3,%eax
   12d04:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   12d07:	83 ec 0c             	sub    $0xc,%esp
   12d0a:	ff 75 cc             	pushl  -0x34(%ebp)
   12d0d:	e8 13 06 ff ff       	call   3325 <lodepng_malloc>
   12d12:	83 c4 10             	add    $0x10,%esp
   12d15:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   12d18:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   12d1c:	75 13                	jne    12d31 <lodepng_encode+0x4e1>
   12d1e:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   12d22:	74 0d                	je     12d31 <lodepng_encode+0x4e1>
   12d24:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d27:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   12d2e:	00 00 00 
    if(!state->error) {
   12d31:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d34:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12d3a:	85 c0                	test   %eax,%eax
   12d3c:	75 33                	jne    12d71 <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   12d3e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d41:	83 c0 78             	add    $0x78,%eax
   12d44:	83 ec 08             	sub    $0x8,%esp
   12d47:	ff 75 18             	pushl  0x18(%ebp)
   12d4a:	ff 75 14             	pushl  0x14(%ebp)
   12d4d:	50                   	push   %eax
   12d4e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d54:	83 c0 0c             	add    $0xc,%eax
   12d57:	50                   	push   %eax
   12d58:	ff 75 10             	pushl  0x10(%ebp)
   12d5b:	ff 75 c8             	pushl  -0x38(%ebp)
   12d5e:	e8 c9 8c ff ff       	call   ba2c <lodepng_convert>
   12d63:	83 c4 20             	add    $0x20,%esp
   12d66:	89 c2                	mov    %eax,%edx
   12d68:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d6b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   12d71:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d74:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12d7a:	85 c0                	test   %eax,%eax
   12d7c:	75 35                	jne    12db3 <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   12d7e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d81:	83 c0 38             	add    $0x38,%eax
   12d84:	83 ec 04             	sub    $0x4,%esp
   12d87:	50                   	push   %eax
   12d88:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d8e:	50                   	push   %eax
   12d8f:	ff 75 18             	pushl  0x18(%ebp)
   12d92:	ff 75 14             	pushl  0x14(%ebp)
   12d95:	ff 75 c8             	pushl  -0x38(%ebp)
   12d98:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12d9b:	50                   	push   %eax
   12d9c:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12d9f:	50                   	push   %eax
   12da0:	e8 0d f6 ff ff       	call   123b2 <preProcessScanlines>
   12da5:	83 c4 20             	add    $0x20,%esp
   12da8:	89 c2                	mov    %eax,%edx
   12daa:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dad:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   12db3:	83 ec 0c             	sub    $0xc,%esp
   12db6:	ff 75 c8             	pushl  -0x38(%ebp)
   12db9:	e8 88 05 ff ff       	call   3346 <lodepng_free>
   12dbe:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   12dc1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dc4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12dca:	85 c0                	test   %eax,%eax
   12dcc:	74 4b                	je     12e19 <lodepng_encode+0x5c9>
   12dce:	e9 96 07 00 00       	jmp    13569 <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   12dd3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dd6:	83 c0 38             	add    $0x38,%eax
   12dd9:	83 ec 04             	sub    $0x4,%esp
   12ddc:	50                   	push   %eax
   12ddd:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12de3:	50                   	push   %eax
   12de4:	ff 75 18             	pushl  0x18(%ebp)
   12de7:	ff 75 14             	pushl  0x14(%ebp)
   12dea:	ff 75 10             	pushl  0x10(%ebp)
   12ded:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12df0:	50                   	push   %eax
   12df1:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12df4:	50                   	push   %eax
   12df5:	e8 b8 f5 ff ff       	call   123b2 <preProcessScanlines>
   12dfa:	83 c4 20             	add    $0x20,%esp
   12dfd:	89 c2                	mov    %eax,%edx
   12dff:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e02:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e08:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e0b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e11:	85 c0                	test   %eax,%eax
   12e13:	0f 85 16 07 00 00    	jne    1352f <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   12e19:	83 ec 0c             	sub    $0xc,%esp
   12e1c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12e1f:	50                   	push   %eax
   12e20:	e8 21 d9 ff ff       	call   10746 <writeSignature>
   12e25:	83 c4 10             	add    $0x10,%esp
   12e28:	89 c2                	mov    %eax,%edx
   12e2a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e2d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e33:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e36:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e3c:	85 c0                	test   %eax,%eax
   12e3e:	0f 85 ee 06 00 00    	jne    13532 <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   12e44:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   12e4a:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   12e50:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12e56:	83 ec 08             	sub    $0x8,%esp
   12e59:	51                   	push   %ecx
   12e5a:	52                   	push   %edx
   12e5b:	50                   	push   %eax
   12e5c:	ff 75 18             	pushl  0x18(%ebp)
   12e5f:	ff 75 14             	pushl  0x14(%ebp)
   12e62:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12e65:	50                   	push   %eax
   12e66:	e8 4a d9 ff ff       	call   107b5 <addChunk_IHDR>
   12e6b:	83 c4 20             	add    $0x20,%esp
   12e6e:	89 c2                	mov    %eax,%edx
   12e70:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e73:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e79:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e7c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e82:	85 c0                	test   %eax,%eax
   12e84:	0f 85 ab 06 00 00    	jne    13535 <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   12e8a:	8b 45 98             	mov    -0x68(%ebp),%eax
   12e8d:	85 c0                	test   %eax,%eax
   12e8f:	74 33                	je     12ec4 <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   12e91:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   12e94:	8b 45 98             	mov    -0x68(%ebp),%eax
   12e97:	83 ec 04             	sub    $0x4,%esp
   12e9a:	52                   	push   %edx
   12e9b:	50                   	push   %eax
   12e9c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12e9f:	50                   	push   %eax
   12ea0:	e8 9c f8 ff ff       	call   12741 <addUnknownChunks>
   12ea5:	83 c4 10             	add    $0x10,%esp
   12ea8:	89 c2                	mov    %eax,%edx
   12eaa:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ead:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12eb3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12eb6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12ebc:	85 c0                	test   %eax,%eax
   12ebe:	0f 85 74 06 00 00    	jne    13538 <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   12ec4:	8b 45 88             	mov    -0x78(%ebp),%eax
   12ec7:	85 c0                	test   %eax,%eax
   12ec9:	74 39                	je     12f04 <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   12ecb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ece:	83 c0 38             	add    $0x38,%eax
   12ed1:	83 ec 04             	sub    $0x4,%esp
   12ed4:	50                   	push   %eax
   12ed5:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12edb:	50                   	push   %eax
   12edc:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12edf:	50                   	push   %eax
   12ee0:	e8 a4 e4 ff ff       	call   11389 <addChunk_iCCP>
   12ee5:	83 c4 10             	add    $0x10,%esp
   12ee8:	89 c2                	mov    %eax,%edx
   12eea:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12eed:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12ef3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ef6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12efc:	85 c0                	test   %eax,%eax
   12efe:	0f 85 37 06 00 00    	jne    1353b <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   12f04:	8b 45 80             	mov    -0x80(%ebp),%eax
   12f07:	85 c0                	test   %eax,%eax
   12f09:	74 32                	je     12f3d <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   12f0b:	83 ec 08             	sub    $0x8,%esp
   12f0e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f14:	50                   	push   %eax
   12f15:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f18:	50                   	push   %eax
   12f19:	e8 41 e4 ff ff       	call   1135f <addChunk_sRGB>
   12f1e:	83 c4 10             	add    $0x10,%esp
   12f21:	89 c2                	mov    %eax,%edx
   12f23:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f26:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f2c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f2f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f35:	85 c0                	test   %eax,%eax
   12f37:	0f 85 01 06 00 00    	jne    1353e <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   12f3d:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   12f43:	85 c0                	test   %eax,%eax
   12f45:	74 32                	je     12f79 <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   12f47:	83 ec 08             	sub    $0x8,%esp
   12f4a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f50:	50                   	push   %eax
   12f51:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f54:	50                   	push   %eax
   12f55:	e8 a7 e2 ff ff       	call   11201 <addChunk_gAMA>
   12f5a:	83 c4 10             	add    $0x10,%esp
   12f5d:	89 c2                	mov    %eax,%edx
   12f5f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f62:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12f68:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f6b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f71:	85 c0                	test   %eax,%eax
   12f73:	0f 85 c8 05 00 00    	jne    13541 <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   12f79:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   12f7f:	85 c0                	test   %eax,%eax
   12f81:	74 32                	je     12fb5 <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   12f83:	83 ec 08             	sub    $0x8,%esp
   12f86:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f8c:	50                   	push   %eax
   12f8d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f90:	50                   	push   %eax
   12f91:	e8 c1 e2 ff ff       	call   11257 <addChunk_cHRM>
   12f96:	83 c4 10             	add    $0x10,%esp
   12f99:	89 c2                	mov    %eax,%edx
   12f9b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f9e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12fa4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fa7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12fad:	85 c0                	test   %eax,%eax
   12faf:	0f 85 8f 05 00 00    	jne    13544 <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   12fb5:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12fbb:	83 f8 03             	cmp    $0x3,%eax
   12fbe:	75 35                	jne    12ff5 <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   12fc0:	83 ec 08             	sub    $0x8,%esp
   12fc3:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12fc9:	83 c0 0c             	add    $0xc,%eax
   12fcc:	50                   	push   %eax
   12fcd:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12fd0:	50                   	push   %eax
   12fd1:	e8 78 d8 ff ff       	call   1084e <addChunk_PLTE>
   12fd6:	83 c4 10             	add    $0x10,%esp
   12fd9:	89 c2                	mov    %eax,%edx
   12fdb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fde:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12fe4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fe7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12fed:	85 c0                	test   %eax,%eax
   12fef:	0f 85 52 05 00 00    	jne    13547 <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   12ff5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ff8:	8b 40 6c             	mov    0x6c(%eax),%eax
   12ffb:	85 c0                	test   %eax,%eax
   12ffd:	74 4b                	je     1304a <lodepng_encode+0x7fa>
   12fff:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13005:	83 f8 02             	cmp    $0x2,%eax
   13008:	74 0b                	je     13015 <lodepng_encode+0x7c5>
   1300a:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13010:	83 f8 06             	cmp    $0x6,%eax
   13013:	75 35                	jne    1304a <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   13015:	83 ec 08             	sub    $0x8,%esp
   13018:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1301e:	83 c0 0c             	add    $0xc,%eax
   13021:	50                   	push   %eax
   13022:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13025:	50                   	push   %eax
   13026:	e8 23 d8 ff ff       	call   1084e <addChunk_PLTE>
   1302b:	83 c4 10             	add    $0x10,%esp
   1302e:	89 c2                	mov    %eax,%edx
   13030:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13033:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13039:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1303c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13042:	85 c0                	test   %eax,%eax
   13044:	0f 85 00 05 00 00    	jne    1354a <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   1304a:	83 ec 08             	sub    $0x8,%esp
   1304d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13053:	83 c0 0c             	add    $0xc,%eax
   13056:	50                   	push   %eax
   13057:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1305a:	50                   	push   %eax
   1305b:	e8 c4 d8 ff ff       	call   10924 <addChunk_tRNS>
   13060:	83 c4 10             	add    $0x10,%esp
   13063:	89 c2                	mov    %eax,%edx
   13065:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13068:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1306e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13071:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13077:	85 c0                	test   %eax,%eax
   13079:	0f 85 ce 04 00 00    	jne    1354d <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   1307f:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   13085:	85 c0                	test   %eax,%eax
   13087:	74 32                	je     130bb <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   13089:	83 ec 08             	sub    $0x8,%esp
   1308c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13092:	50                   	push   %eax
   13093:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13096:	50                   	push   %eax
   13097:	e8 e4 de ff ff       	call   10f80 <addChunk_bKGD>
   1309c:	83 c4 10             	add    $0x10,%esp
   1309f:	89 c2                	mov    %eax,%edx
   130a1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130a4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   130aa:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130ad:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130b3:	85 c0                	test   %eax,%eax
   130b5:	0f 85 95 04 00 00    	jne    13550 <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   130bb:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   130c1:	85 c0                	test   %eax,%eax
   130c3:	74 32                	je     130f7 <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   130c5:	83 ec 08             	sub    $0x8,%esp
   130c8:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130ce:	50                   	push   %eax
   130cf:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130d2:	50                   	push   %eax
   130d3:	e8 ac e0 ff ff       	call   11184 <addChunk_pHYs>
   130d8:	83 c4 10             	add    $0x10,%esp
   130db:	89 c2                	mov    %eax,%edx
   130dd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130e0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   130e6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130e9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130ef:	85 c0                	test   %eax,%eax
   130f1:	0f 85 5c 04 00 00    	jne    13553 <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   130f7:	8b 45 9c             	mov    -0x64(%ebp),%eax
   130fa:	85 c0                	test   %eax,%eax
   130fc:	74 33                	je     13131 <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   130fe:	8b 55 a8             	mov    -0x58(%ebp),%edx
   13101:	8b 45 9c             	mov    -0x64(%ebp),%eax
   13104:	83 ec 04             	sub    $0x4,%esp
   13107:	52                   	push   %edx
   13108:	50                   	push   %eax
   13109:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1310c:	50                   	push   %eax
   1310d:	e8 2f f6 ff ff       	call   12741 <addUnknownChunks>
   13112:	83 c4 10             	add    $0x10,%esp
   13115:	89 c2                	mov    %eax,%edx
   13117:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1311a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13120:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13123:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13129:	85 c0                	test   %eax,%eax
   1312b:	0f 85 25 04 00 00    	jne    13556 <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   13131:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13134:	8d 48 38             	lea    0x38(%eax),%ecx
   13137:	8b 55 bc             	mov    -0x44(%ebp),%edx
   1313a:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1313d:	51                   	push   %ecx
   1313e:	52                   	push   %edx
   1313f:	50                   	push   %eax
   13140:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13143:	50                   	push   %eax
   13144:	e8 bd d9 ff ff       	call   10b06 <addChunk_IDAT>
   13149:	83 c4 10             	add    $0x10,%esp
   1314c:	89 c2                	mov    %eax,%edx
   1314e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13151:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13157:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1315a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13160:	85 c0                	test   %eax,%eax
   13162:	0f 85 f1 03 00 00    	jne    13559 <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   13168:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   1316e:	85 c0                	test   %eax,%eax
   13170:	74 35                	je     131a7 <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   13172:	83 ec 08             	sub    $0x8,%esp
   13175:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1317b:	83 c0 60             	add    $0x60,%eax
   1317e:	50                   	push   %eax
   1317f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13182:	50                   	push   %eax
   13183:	e8 5c df ff ff       	call   110e4 <addChunk_tIME>
   13188:	83 c4 10             	add    $0x10,%esp
   1318b:	89 c2                	mov    %eax,%edx
   1318d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13190:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13196:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13199:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1319f:	85 c0                	test   %eax,%eax
   131a1:	0f 85 b5 03 00 00    	jne    1355c <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   131a7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   131ae:	e9 12 01 00 00       	jmp    132c5 <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   131b3:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   131b9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   131bc:	c1 e2 02             	shl    $0x2,%edx
   131bf:	01 d0                	add    %edx,%eax
   131c1:	8b 00                	mov    (%eax),%eax
   131c3:	83 ec 0c             	sub    $0xc,%esp
   131c6:	50                   	push   %eax
   131c7:	e8 f5 01 ff ff       	call   33c1 <lodepng_strlen>
   131cc:	83 c4 10             	add    $0x10,%esp
   131cf:	83 f8 4f             	cmp    $0x4f,%eax
   131d2:	7e 12                	jle    131e6 <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   131d4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131d7:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   131de:	00 00 00 
        goto cleanup;
   131e1:	e9 83 03 00 00       	jmp    13569 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   131e6:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   131ec:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   131ef:	c1 e2 02             	shl    $0x2,%edx
   131f2:	01 d0                	add    %edx,%eax
   131f4:	8b 00                	mov    (%eax),%eax
   131f6:	83 ec 0c             	sub    $0xc,%esp
   131f9:	50                   	push   %eax
   131fa:	e8 c2 01 ff ff       	call   33c1 <lodepng_strlen>
   131ff:	83 c4 10             	add    $0x10,%esp
   13202:	85 c0                	test   %eax,%eax
   13204:	7f 12                	jg     13218 <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   13206:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13209:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   13210:	00 00 00 
        goto cleanup;
   13213:	e9 51 03 00 00       	jmp    13569 <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   13218:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1321b:	8b 40 74             	mov    0x74(%eax),%eax
   1321e:	85 c0                	test   %eax,%eax
   13220:	74 52                	je     13274 <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   13222:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13225:	8d 48 38             	lea    0x38(%eax),%ecx
   13228:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   1322e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13231:	c1 e2 02             	shl    $0x2,%edx
   13234:	01 d0                	add    %edx,%eax
   13236:	8b 10                	mov    (%eax),%edx
   13238:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1323e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   13241:	c1 e3 02             	shl    $0x2,%ebx
   13244:	01 d8                	add    %ebx,%eax
   13246:	8b 00                	mov    (%eax),%eax
   13248:	51                   	push   %ecx
   13249:	52                   	push   %edx
   1324a:	50                   	push   %eax
   1324b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1324e:	50                   	push   %eax
   1324f:	e8 fa d9 ff ff       	call   10c4e <addChunk_zTXt>
   13254:	83 c4 10             	add    $0x10,%esp
   13257:	89 c2                	mov    %eax,%edx
   13259:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1325c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13262:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13265:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1326b:	85 c0                	test   %eax,%eax
   1326d:	74 52                	je     132c1 <lodepng_encode+0xa71>
   1326f:	e9 f5 02 00 00       	jmp    13569 <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   13274:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   1327a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1327d:	c1 e2 02             	shl    $0x2,%edx
   13280:	01 d0                	add    %edx,%eax
   13282:	8b 10                	mov    (%eax),%edx
   13284:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1328a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   1328d:	c1 e1 02             	shl    $0x2,%ecx
   13290:	01 c8                	add    %ecx,%eax
   13292:	8b 00                	mov    (%eax),%eax
   13294:	83 ec 04             	sub    $0x4,%esp
   13297:	52                   	push   %edx
   13298:	50                   	push   %eax
   13299:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1329c:	50                   	push   %eax
   1329d:	e8 ec d8 ff ff       	call   10b8e <addChunk_tEXt>
   132a2:	83 c4 10             	add    $0x10,%esp
   132a5:	89 c2                	mov    %eax,%edx
   132a7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132aa:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   132b0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132b3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   132b9:	85 c0                	test   %eax,%eax
   132bb:	0f 85 9e 02 00 00    	jne    1355f <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   132c1:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   132c5:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   132cb:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   132ce:	0f 85 df fe ff ff    	jne    131b3 <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   132d4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132d7:	8b 40 70             	mov    0x70(%eax),%eax
   132da:	85 c0                	test   %eax,%eax
   132dc:	0f 84 e3 00 00 00    	je     133c5 <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   132e2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   132e9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   132f0:	e9 85 00 00 00       	jmp    1337a <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   132f5:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   132fb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   132fe:	c1 e2 02             	shl    $0x2,%edx
   13301:	01 d0                	add    %edx,%eax
   13303:	8b 00                	mov    (%eax),%eax
   13305:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13308:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1330b:	0f b6 00             	movzbl (%eax),%eax
   1330e:	3c 4c                	cmp    $0x4c,%al
   13310:	75 64                	jne    13376 <lodepng_encode+0xb26>
   13312:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13315:	83 c0 01             	add    $0x1,%eax
   13318:	0f b6 00             	movzbl (%eax),%eax
   1331b:	3c 6f                	cmp    $0x6f,%al
   1331d:	75 57                	jne    13376 <lodepng_encode+0xb26>
   1331f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13322:	83 c0 02             	add    $0x2,%eax
   13325:	0f b6 00             	movzbl (%eax),%eax
   13328:	3c 64                	cmp    $0x64,%al
   1332a:	75 4a                	jne    13376 <lodepng_encode+0xb26>
   1332c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1332f:	83 c0 03             	add    $0x3,%eax
   13332:	0f b6 00             	movzbl (%eax),%eax
   13335:	3c 65                	cmp    $0x65,%al
   13337:	75 3d                	jne    13376 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13339:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1333c:	83 c0 04             	add    $0x4,%eax
   1333f:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13342:	3c 50                	cmp    $0x50,%al
   13344:	75 30                	jne    13376 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13346:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13349:	83 c0 05             	add    $0x5,%eax
   1334c:	0f b6 00             	movzbl (%eax),%eax
   1334f:	3c 4e                	cmp    $0x4e,%al
   13351:	75 23                	jne    13376 <lodepng_encode+0xb26>
   13353:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13356:	83 c0 06             	add    $0x6,%eax
   13359:	0f b6 00             	movzbl (%eax),%eax
   1335c:	3c 47                	cmp    $0x47,%al
   1335e:	75 16                	jne    13376 <lodepng_encode+0xb26>
   13360:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13363:	83 c0 07             	add    $0x7,%eax
   13366:	0f b6 00             	movzbl (%eax),%eax
   13369:	84 c0                	test   %al,%al
   1336b:	75 09                	jne    13376 <lodepng_encode+0xb26>
          already_added_id_text = 1;
   1336d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   13374:	eb 13                	jmp    13389 <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   13376:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1337a:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   13380:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13383:	0f 85 6c ff ff ff    	jne    132f5 <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   13389:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1338d:	75 36                	jne    133c5 <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   1338f:	a1 00 e1 01 00       	mov    0x1e100,%eax
   13394:	83 ec 04             	sub    $0x4,%esp
   13397:	50                   	push   %eax
   13398:	68 c4 a0 01 00       	push   $0x1a0c4
   1339d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   133a0:	50                   	push   %eax
   133a1:	e8 e8 d7 ff ff       	call   10b8e <addChunk_tEXt>
   133a6:	83 c4 10             	add    $0x10,%esp
   133a9:	89 c2                	mov    %eax,%edx
   133ab:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133ae:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   133b4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133b7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   133bd:	85 c0                	test   %eax,%eax
   133bf:	0f 85 9d 01 00 00    	jne    13562 <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   133c5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   133cc:	e9 e6 00 00 00       	jmp    134b7 <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   133d1:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   133d7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   133da:	c1 e2 02             	shl    $0x2,%edx
   133dd:	01 d0                	add    %edx,%eax
   133df:	8b 00                	mov    (%eax),%eax
   133e1:	83 ec 0c             	sub    $0xc,%esp
   133e4:	50                   	push   %eax
   133e5:	e8 d7 ff fe ff       	call   33c1 <lodepng_strlen>
   133ea:	83 c4 10             	add    $0x10,%esp
   133ed:	83 f8 4f             	cmp    $0x4f,%eax
   133f0:	7e 12                	jle    13404 <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   133f2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133f5:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   133fc:	00 00 00 
        goto cleanup;
   133ff:	e9 65 01 00 00       	jmp    13569 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   13404:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   1340a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1340d:	c1 e2 02             	shl    $0x2,%edx
   13410:	01 d0                	add    %edx,%eax
   13412:	8b 00                	mov    (%eax),%eax
   13414:	83 ec 0c             	sub    $0xc,%esp
   13417:	50                   	push   %eax
   13418:	e8 a4 ff fe ff       	call   33c1 <lodepng_strlen>
   1341d:	83 c4 10             	add    $0x10,%esp
   13420:	85 c0                	test   %eax,%eax
   13422:	7f 12                	jg     13436 <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   13424:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13427:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   1342e:	00 00 00 
        goto cleanup;
   13431:	e9 33 01 00 00       	jmp    13569 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   13436:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13439:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1343c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   13442:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13445:	c1 e2 02             	shl    $0x2,%edx
   13448:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1344a:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1344c:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   13452:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13455:	c1 e2 02             	shl    $0x2,%edx
   13458:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1345a:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1345c:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   13462:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13465:	c1 e2 02             	shl    $0x2,%edx
   13468:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1346a:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1346c:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13472:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13475:	c1 e2 02             	shl    $0x2,%edx
   13478:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1347a:	8b 10                	mov    (%eax),%edx
   1347c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1347f:	8b 40 74             	mov    0x74(%eax),%eax
   13482:	83 ec 04             	sub    $0x4,%esp
   13485:	57                   	push   %edi
   13486:	56                   	push   %esi
   13487:	53                   	push   %ebx
   13488:	51                   	push   %ecx
   13489:	52                   	push   %edx
   1348a:	50                   	push   %eax
   1348b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1348e:	50                   	push   %eax
   1348f:	e8 dc d8 ff ff       	call   10d70 <addChunk_iTXt>
   13494:	83 c4 20             	add    $0x20,%esp
   13497:	89 c2                	mov    %eax,%edx
   13499:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1349c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   134a2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134a5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   134ab:	85 c0                	test   %eax,%eax
   134ad:	0f 85 b2 00 00 00    	jne    13565 <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   134b3:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   134b7:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   134bd:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   134c0:	0f 85 0b ff ff ff    	jne    133d1 <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   134c6:	8b 45 a0             	mov    -0x60(%ebp),%eax
   134c9:	85 c0                	test   %eax,%eax
   134cb:	74 2f                	je     134fc <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   134cd:	8b 55 ac             	mov    -0x54(%ebp),%edx
   134d0:	8b 45 a0             	mov    -0x60(%ebp),%eax
   134d3:	83 ec 04             	sub    $0x4,%esp
   134d6:	52                   	push   %edx
   134d7:	50                   	push   %eax
   134d8:	8d 45 b0             	lea    -0x50(%ebp),%eax
   134db:	50                   	push   %eax
   134dc:	e8 60 f2 ff ff       	call   12741 <addUnknownChunks>
   134e1:	83 c4 10             	add    $0x10,%esp
   134e4:	89 c2                	mov    %eax,%edx
   134e6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134e9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   134ef:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134f2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   134f8:	85 c0                	test   %eax,%eax
   134fa:	75 6c                	jne    13568 <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   134fc:	83 ec 0c             	sub    $0xc,%esp
   134ff:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13502:	50                   	push   %eax
   13503:	e8 6d d6 ff ff       	call   10b75 <addChunk_IEND>
   13508:	83 c4 10             	add    $0x10,%esp
   1350b:	89 c2                	mov    %eax,%edx
   1350d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13510:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13516:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13519:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1351f:	85 c0                	test   %eax,%eax
   13521:	eb 46                	jmp    13569 <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13523:	90                   	nop
   13524:	eb 43                	jmp    13569 <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   13526:	90                   	nop
   13527:	eb 40                	jmp    13569 <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   13529:	90                   	nop
   1352a:	eb 3d                	jmp    13569 <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   1352c:	90                   	nop
   1352d:	eb 3a                	jmp    13569 <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   1352f:	90                   	nop
   13530:	eb 37                	jmp    13569 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   13532:	90                   	nop
   13533:	eb 34                	jmp    13569 <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   13535:	90                   	nop
   13536:	eb 31                	jmp    13569 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   13538:	90                   	nop
   13539:	eb 2e                	jmp    13569 <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   1353b:	90                   	nop
   1353c:	eb 2b                	jmp    13569 <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   1353e:	90                   	nop
   1353f:	eb 28                	jmp    13569 <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   13541:	90                   	nop
   13542:	eb 25                	jmp    13569 <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   13544:	90                   	nop
   13545:	eb 22                	jmp    13569 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13547:	90                   	nop
   13548:	eb 1f                	jmp    13569 <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   1354a:	90                   	nop
   1354b:	eb 1c                	jmp    13569 <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   1354d:	90                   	nop
   1354e:	eb 19                	jmp    13569 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   13550:	90                   	nop
   13551:	eb 16                	jmp    13569 <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   13553:	90                   	nop
   13554:	eb 13                	jmp    13569 <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   13556:	90                   	nop
   13557:	eb 10                	jmp    13569 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   13559:	90                   	nop
   1355a:	eb 0d                	jmp    13569 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   1355c:	90                   	nop
   1355d:	eb 0a                	jmp    13569 <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   1355f:	90                   	nop
   13560:	eb 07                	jmp    13569 <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   13562:	90                   	nop
   13563:	eb 04                	jmp    13569 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13565:	90                   	nop
   13566:	eb 01                	jmp    13569 <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   13568:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   13569:	83 ec 0c             	sub    $0xc,%esp
   1356c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13572:	50                   	push   %eax
   13573:	e8 34 65 ff ff       	call   9aac <lodepng_info_cleanup>
   13578:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   1357b:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1357e:	83 ec 0c             	sub    $0xc,%esp
   13581:	50                   	push   %eax
   13582:	e8 bf fd fe ff       	call   3346 <lodepng_free>
   13587:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   1358a:	8b 55 b0             	mov    -0x50(%ebp),%edx
   1358d:	8b 45 08             	mov    0x8(%ebp),%eax
   13590:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   13592:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   13595:	8b 45 0c             	mov    0xc(%ebp),%eax
   13598:	89 10                	mov    %edx,(%eax)

  return state->error;
   1359a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1359d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   135a3:	8d 65 f4             	lea    -0xc(%ebp),%esp
   135a6:	5b                   	pop    %ebx
   135a7:	5e                   	pop    %esi
   135a8:	5f                   	pop    %edi
   135a9:	5d                   	pop    %ebp
   135aa:	c3                   	ret    

000135ab <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   135ab:	55                   	push   %ebp
   135ac:	89 e5                	mov    %esp,%ebp
   135ae:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   135b4:	83 ec 0c             	sub    $0xc,%esp
   135b7:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   135bd:	50                   	push   %eax
   135be:	e8 38 d0 ff ff       	call   105fb <lodepng_state_init>
   135c3:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   135c6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135c9:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   135cf:	8b 45 20             	mov    0x20(%ebp),%eax
   135d2:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   135d8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135db:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   135e1:	8b 45 20             	mov    0x20(%ebp),%eax
   135e4:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   135ea:	83 ec 08             	sub    $0x8,%esp
   135ed:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   135f3:	50                   	push   %eax
   135f4:	ff 75 18             	pushl  0x18(%ebp)
   135f7:	ff 75 14             	pushl  0x14(%ebp)
   135fa:	ff 75 10             	pushl  0x10(%ebp)
   135fd:	ff 75 0c             	pushl  0xc(%ebp)
   13600:	ff 75 08             	pushl  0x8(%ebp)
   13603:	e8 48 f2 ff ff       	call   12850 <lodepng_encode>
   13608:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   1360b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1360e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   13611:	83 ec 0c             	sub    $0xc,%esp
   13614:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1361a:	50                   	push   %eax
   1361b:	e8 35 d0 ff ff       	call   10655 <lodepng_state_cleanup>
   13620:	83 c4 10             	add    $0x10,%esp
  return error;
   13623:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13626:	c9                   	leave  
   13627:	c3                   	ret    

00013628 <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13628:	55                   	push   %ebp
   13629:	89 e5                	mov    %esp,%ebp
   1362b:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   1362e:	83 ec 04             	sub    $0x4,%esp
   13631:	6a 08                	push   $0x8
   13633:	6a 06                	push   $0x6
   13635:	ff 75 18             	pushl  0x18(%ebp)
   13638:	ff 75 14             	pushl  0x14(%ebp)
   1363b:	ff 75 10             	pushl  0x10(%ebp)
   1363e:	ff 75 0c             	pushl  0xc(%ebp)
   13641:	ff 75 08             	pushl  0x8(%ebp)
   13644:	e8 62 ff ff ff       	call   135ab <lodepng_encode_memory>
   13649:	83 c4 20             	add    $0x20,%esp
}
   1364c:	c9                   	leave  
   1364d:	c3                   	ret    

0001364e <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   1364e:	55                   	push   %ebp
   1364f:	89 e5                	mov    %esp,%ebp
   13651:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   13654:	83 ec 04             	sub    $0x4,%esp
   13657:	6a 08                	push   $0x8
   13659:	6a 02                	push   $0x2
   1365b:	ff 75 18             	pushl  0x18(%ebp)
   1365e:	ff 75 14             	pushl  0x14(%ebp)
   13661:	ff 75 10             	pushl  0x10(%ebp)
   13664:	ff 75 0c             	pushl  0xc(%ebp)
   13667:	ff 75 08             	pushl  0x8(%ebp)
   1366a:	e8 3c ff ff ff       	call   135ab <lodepng_encode_memory>
   1366f:	83 c4 20             	add    $0x20,%esp
}
   13672:	c9                   	leave  
   13673:	c3                   	ret    

00013674 <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   13674:	55                   	push   %ebp
   13675:	89 e5                	mov    %esp,%ebp
   13677:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   1367a:	83 ec 04             	sub    $0x4,%esp
   1367d:	ff 75 1c             	pushl  0x1c(%ebp)
   13680:	ff 75 18             	pushl  0x18(%ebp)
   13683:	ff 75 14             	pushl  0x14(%ebp)
   13686:	ff 75 10             	pushl  0x10(%ebp)
   13689:	ff 75 0c             	pushl  0xc(%ebp)
   1368c:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1368f:	50                   	push   %eax
   13690:	8d 45 f0             	lea    -0x10(%ebp),%eax
   13693:	50                   	push   %eax
   13694:	e8 12 ff ff ff       	call   135ab <lodepng_encode_memory>
   13699:	83 c4 20             	add    $0x20,%esp
   1369c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   1369f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   136a3:	75 19                	jne    136be <lodepng_encode_file+0x4a>
   136a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
   136a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   136ab:	83 ec 04             	sub    $0x4,%esp
   136ae:	ff 75 08             	pushl  0x8(%ebp)
   136b1:	52                   	push   %edx
   136b2:	50                   	push   %eax
   136b3:	e8 36 01 ff ff       	call   37ee <lodepng_save_file>
   136b8:	83 c4 10             	add    $0x10,%esp
   136bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   136be:	8b 45 f0             	mov    -0x10(%ebp),%eax
   136c1:	83 ec 0c             	sub    $0xc,%esp
   136c4:	50                   	push   %eax
   136c5:	e8 7c fc fe ff       	call   3346 <lodepng_free>
   136ca:	83 c4 10             	add    $0x10,%esp
  return error;
   136cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   136d0:	c9                   	leave  
   136d1:	c3                   	ret    

000136d2 <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   136d2:	55                   	push   %ebp
   136d3:	89 e5                	mov    %esp,%ebp
   136d5:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   136d8:	83 ec 08             	sub    $0x8,%esp
   136db:	6a 08                	push   $0x8
   136dd:	6a 06                	push   $0x6
   136df:	ff 75 14             	pushl  0x14(%ebp)
   136e2:	ff 75 10             	pushl  0x10(%ebp)
   136e5:	ff 75 0c             	pushl  0xc(%ebp)
   136e8:	ff 75 08             	pushl  0x8(%ebp)
   136eb:	e8 84 ff ff ff       	call   13674 <lodepng_encode_file>
   136f0:	83 c4 20             	add    $0x20,%esp
}
   136f3:	c9                   	leave  
   136f4:	c3                   	ret    

000136f5 <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   136f5:	55                   	push   %ebp
   136f6:	89 e5                	mov    %esp,%ebp
   136f8:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   136fb:	83 ec 08             	sub    $0x8,%esp
   136fe:	6a 08                	push   $0x8
   13700:	6a 02                	push   $0x2
   13702:	ff 75 14             	pushl  0x14(%ebp)
   13705:	ff 75 10             	pushl  0x10(%ebp)
   13708:	ff 75 0c             	pushl  0xc(%ebp)
   1370b:	ff 75 08             	pushl  0x8(%ebp)
   1370e:	e8 61 ff ff ff       	call   13674 <lodepng_encode_file>
   13713:	83 c4 20             	add    $0x20,%esp
}
   13716:	c9                   	leave  
   13717:	c3                   	ret    

00013718 <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   13718:	55                   	push   %ebp
   13719:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   1371b:	8b 45 08             	mov    0x8(%ebp),%eax
   1371e:	50                   	push   %eax
   1371f:	e8 71 49 ff ff       	call   8095 <lodepng_compress_settings_init>
   13724:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   13727:	8b 45 08             	mov    0x8(%ebp),%eax
   1372a:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   13731:	8b 45 08             	mov    0x8(%ebp),%eax
   13734:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   1373b:	8b 45 08             	mov    0x8(%ebp),%eax
   1373e:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   13745:	8b 45 08             	mov    0x8(%ebp),%eax
   13748:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   1374f:	8b 45 08             	mov    0x8(%ebp),%eax
   13752:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   13759:	8b 45 08             	mov    0x8(%ebp),%eax
   1375c:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   13763:	8b 45 08             	mov    0x8(%ebp),%eax
   13766:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   1376d:	90                   	nop
   1376e:	c9                   	leave  
   1376f:	c3                   	ret    

00013770 <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   13770:	55                   	push   %ebp
   13771:	89 e5                	mov    %esp,%ebp
  switch(code) {
   13773:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   13777:	0f 87 c1 03 00 00    	ja     13b3e <lodepng_error_text+0x3ce>
   1377d:	8b 45 08             	mov    0x8(%ebp),%eax
   13780:	c1 e0 02             	shl    $0x2,%eax
   13783:	05 00 b4 01 00       	add    $0x1b400,%eax
   13788:	8b 00                	mov    (%eax),%eax
   1378a:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   1378c:	b8 cc a0 01 00       	mov    $0x1a0cc,%eax
   13791:	e9 ad 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   13796:	b8 e9 a0 01 00       	mov    $0x1a0e9,%eax
   1379b:	e9 a3 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   137a0:	b8 fc a0 01 00       	mov    $0x1a0fc,%eax
   137a5:	e9 99 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   137aa:	b8 34 a1 01 00       	mov    $0x1a134,%eax
   137af:	e9 8f 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   137b4:	b8 6c a1 01 00       	mov    $0x1a16c,%eax
   137b9:	e9 85 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   137be:	b8 6c a1 01 00       	mov    $0x1a16c,%eax
   137c3:	e9 7b 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   137c8:	b8 6c a1 01 00       	mov    $0x1a16c,%eax
   137cd:	e9 71 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   137d2:	b8 9c a1 01 00       	mov    $0x1a19c,%eax
   137d7:	e9 67 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   137dc:	b8 d0 a1 01 00       	mov    $0x1a1d0,%eax
   137e1:	e9 5d 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   137e6:	b8 04 a2 01 00       	mov    $0x1a204,%eax
   137eb:	e9 53 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   137f0:	b8 d0 a1 01 00       	mov    $0x1a1d0,%eax
   137f5:	e9 49 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   137fa:	b8 2c a2 01 00       	mov    $0x1a22c,%eax
   137ff:	e9 3f 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   13804:	b8 64 a2 01 00       	mov    $0x1a264,%eax
   13809:	e9 35 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   1380e:	b8 d0 a1 01 00       	mov    $0x1a1d0,%eax
   13813:	e9 2b 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   13818:	b8 9c a2 01 00       	mov    $0x1a29c,%eax
   1381d:	e9 21 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   13822:	b8 cc a2 01 00       	mov    $0x1a2cc,%eax
   13827:	e9 17 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   1382c:	b8 ec a2 01 00       	mov    $0x1a2ec,%eax
   13831:	e9 0d 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   13836:	b8 18 a3 01 00       	mov    $0x1a318,%eax
   1383b:	e9 03 03 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   13840:	b8 58 a3 01 00       	mov    $0x1a358,%eax
   13845:	e9 f9 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   1384a:	b8 80 a3 01 00       	mov    $0x1a380,%eax
   1384f:	e9 ef 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   13854:	b8 b4 a3 01 00       	mov    $0x1a3b4,%eax
   13859:	e9 e5 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   1385e:	b8 d8 a3 01 00       	mov    $0x1a3d8,%eax
   13863:	e9 db 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   13868:	b8 10 a4 01 00       	mov    $0x1a410,%eax
   1386d:	e9 d1 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   13872:	b8 30 a4 01 00       	mov    $0x1a430,%eax
   13877:	e9 c7 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   1387c:	b8 4f a4 01 00       	mov    $0x1a44f,%eax
   13881:	e9 bd 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   13886:	b8 69 a4 01 00       	mov    $0x1a469,%eax
   1388b:	e9 b3 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   13890:	b8 88 a4 01 00       	mov    $0x1a488,%eax
   13895:	e9 a9 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   1389a:	b8 c4 a4 01 00       	mov    $0x1a4c4,%eax
   1389f:	e9 9f 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   138a4:	b8 e8 a4 01 00       	mov    $0x1a4e8,%eax
   138a9:	e9 95 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   138ae:	b8 14 a5 01 00       	mov    $0x1a514,%eax
   138b3:	e9 8b 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   138b8:	b8 38 a5 01 00       	mov    $0x1a538,%eax
   138bd:	e9 81 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   138c2:	b8 78 a5 01 00       	mov    $0x1a578,%eax
   138c7:	e9 77 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   138cc:	b8 a8 a5 01 00       	mov    $0x1a5a8,%eax
   138d1:	e9 6d 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   138d6:	b8 d0 a5 01 00       	mov    $0x1a5d0,%eax
   138db:	e9 63 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   138e0:	b8 14 a6 01 00       	mov    $0x1a614,%eax
   138e5:	e9 59 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   138ea:	b8 40 a6 01 00       	mov    $0x1a640,%eax
   138ef:	e9 4f 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   138f4:	b8 70 a6 01 00       	mov    $0x1a670,%eax
   138f9:	e9 45 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   138fe:	b8 98 a6 01 00       	mov    $0x1a698,%eax
   13903:	e9 3b 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   13908:	b8 e0 a6 01 00       	mov    $0x1a6e0,%eax
   1390d:	e9 31 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   13912:	b8 e0 a6 01 00       	mov    $0x1a6e0,%eax
   13917:	e9 27 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   1391c:	b8 1c a7 01 00       	mov    $0x1a71c,%eax
   13921:	e9 1d 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   13926:	b8 50 a7 01 00       	mov    $0x1a750,%eax
   1392b:	e9 13 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   13930:	b8 73 a7 01 00       	mov    $0x1a773,%eax
   13935:	e9 09 02 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   1393a:	b8 90 a7 01 00       	mov    $0x1a790,%eax
   1393f:	e9 ff 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   13944:	b8 cc a7 01 00       	mov    $0x1a7cc,%eax
   13949:	e9 f5 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   1394e:	b8 fc a7 01 00       	mov    $0x1a7fc,%eax
   13953:	e9 eb 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   13958:	b8 48 a8 01 00       	mov    $0x1a848,%eax
   1395d:	e9 e1 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   13962:	b8 80 a8 01 00       	mov    $0x1a880,%eax
   13967:	e9 d7 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   1396c:	b8 c0 a8 01 00       	mov    $0x1a8c0,%eax
   13971:	e9 cd 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   13976:	b8 ec a8 01 00       	mov    $0x1a8ec,%eax
   1397b:	e9 c3 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   13980:	b8 38 a9 01 00       	mov    $0x1a938,%eax
   13985:	e9 b9 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   1398a:	b8 8c a9 01 00       	mov    $0x1a98c,%eax
   1398f:	e9 af 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   13994:	b8 c0 a9 01 00       	mov    $0x1a9c0,%eax
   13999:	e9 a5 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   1399e:	b8 10 aa 01 00       	mov    $0x1aa10,%eax
   139a3:	e9 9b 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   139a8:	b8 4c aa 01 00       	mov    $0x1aa4c,%eax
   139ad:	e9 91 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   139b2:	b8 ac aa 01 00       	mov    $0x1aaac,%eax
   139b7:	e9 87 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   139bc:	b8 0c ab 01 00       	mov    $0x1ab0c,%eax
   139c1:	e9 7d 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   139c6:	b8 68 ab 01 00       	mov    $0x1ab68,%eax
   139cb:	e9 73 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   139d0:	b8 ac ab 01 00       	mov    $0x1abac,%eax
   139d5:	e9 69 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   139da:	b8 e8 ab 01 00       	mov    $0x1abe8,%eax
   139df:	e9 5f 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   139e4:	b8 45 ac 01 00       	mov    $0x1ac45,%eax
   139e9:	e9 55 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   139ee:	b8 5d ac 01 00       	mov    $0x1ac5d,%eax
   139f3:	e9 4b 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   139f8:	b8 78 ac 01 00       	mov    $0x1ac78,%eax
   139fd:	e9 41 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   13a02:	b8 b4 ac 01 00       	mov    $0x1acb4,%eax
   13a07:	e9 37 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   13a0c:	b8 e4 ac 01 00       	mov    $0x1ace4,%eax
   13a11:	e9 2d 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   13a16:	b8 04 ad 01 00       	mov    $0x1ad04,%eax
   13a1b:	e9 23 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   13a20:	b8 24 ad 01 00       	mov    $0x1ad24,%eax
   13a25:	e9 19 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   13a2a:	b8 44 ad 01 00       	mov    $0x1ad44,%eax
   13a2f:	e9 0f 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   13a34:	b8 68 ad 01 00       	mov    $0x1ad68,%eax
   13a39:	e9 05 01 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   13a3e:	b8 90 ad 01 00       	mov    $0x1ad90,%eax
   13a43:	e9 fb 00 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   13a48:	b8 ed ad 01 00       	mov    $0x1aded,%eax
   13a4d:	e9 f1 00 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   13a52:	b8 08 ae 01 00       	mov    $0x1ae08,%eax
   13a57:	e9 e7 00 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   13a5c:	b8 44 ae 01 00       	mov    $0x1ae44,%eax
   13a61:	e9 dd 00 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   13a66:	b8 78 ae 01 00       	mov    $0x1ae78,%eax
   13a6b:	e9 d3 00 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   13a70:	b8 cc ae 01 00       	mov    $0x1aecc,%eax
   13a75:	e9 c9 00 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   13a7a:	b8 18 af 01 00       	mov    $0x1af18,%eax
   13a7f:	e9 bf 00 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   13a84:	b8 54 af 01 00       	mov    $0x1af54,%eax
   13a89:	e9 b5 00 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   13a8e:	b8 78 af 01 00       	mov    $0x1af78,%eax
   13a93:	e9 ab 00 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   13a98:	b8 98 af 01 00       	mov    $0x1af98,%eax
   13a9d:	e9 a1 00 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   13aa2:	b8 c0 af 01 00       	mov    $0x1afc0,%eax
   13aa7:	e9 97 00 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   13aac:	b8 e0 af 01 00       	mov    $0x1afe0,%eax
   13ab1:	e9 8d 00 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   13ab6:	b8 0c b0 01 00       	mov    $0x1b00c,%eax
   13abb:	e9 83 00 00 00       	jmp    13b43 <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   13ac0:	b8 3b b0 01 00       	mov    $0x1b03b,%eax
   13ac5:	eb 7c                	jmp    13b43 <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   13ac7:	b8 53 b0 01 00       	mov    $0x1b053,%eax
   13acc:	eb 75                	jmp    13b43 <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   13ace:	b8 6b b0 01 00       	mov    $0x1b06b,%eax
   13ad3:	eb 6e                	jmp    13b43 <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   13ad5:	b8 83 b0 01 00       	mov    $0x1b083,%eax
   13ada:	eb 67                	jmp    13b43 <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   13adc:	b8 a4 b0 01 00       	mov    $0x1b0a4,%eax
   13ae1:	eb 60                	jmp    13b43 <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   13ae3:	b8 f4 b0 01 00       	mov    $0x1b0f4,%eax
   13ae8:	eb 59                	jmp    13b43 <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   13aea:	b8 48 b1 01 00       	mov    $0x1b148,%eax
   13aef:	eb 52                	jmp    13b43 <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   13af1:	b8 9c b1 01 00       	mov    $0x1b19c,%eax
   13af6:	eb 4b                	jmp    13b43 <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   13af8:	b8 e4 b1 01 00       	mov    $0x1b1e4,%eax
   13afd:	eb 44                	jmp    13b43 <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   13aff:	b8 28 b2 01 00       	mov    $0x1b228,%eax
   13b04:	eb 3d                	jmp    13b43 <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   13b06:	b8 44 b2 01 00       	mov    $0x1b244,%eax
   13b0b:	eb 36                	jmp    13b43 <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   13b0d:	b8 7c b2 01 00       	mov    $0x1b27c,%eax
   13b12:	eb 2f                	jmp    13b43 <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   13b14:	b8 d0 b2 01 00       	mov    $0x1b2d0,%eax
   13b19:	eb 28                	jmp    13b43 <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   13b1b:	b8 00 b3 01 00       	mov    $0x1b300,%eax
   13b20:	eb 21                	jmp    13b43 <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   13b22:	b8 50 b3 01 00       	mov    $0x1b350,%eax
   13b27:	eb 1a                	jmp    13b43 <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   13b29:	b8 7c b3 01 00       	mov    $0x1b37c,%eax
   13b2e:	eb 13                	jmp    13b43 <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   13b30:	b8 a8 b3 01 00       	mov    $0x1b3a8,%eax
   13b35:	eb 0c                	jmp    13b43 <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   13b37:	b8 cc b3 01 00       	mov    $0x1b3cc,%eax
   13b3c:	eb 05                	jmp    13b43 <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   13b3e:	b8 eb b3 01 00       	mov    $0x1b3eb,%eax
}
   13b43:	5d                   	pop    %ebp
   13b44:	c3                   	ret    

00013b45 <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   13b45:	55                   	push   %ebp
   13b46:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   13b48:	8b 45 08             	mov    0x8(%ebp),%eax
   13b4b:	8b 40 28             	mov    0x28(%eax),%eax
   13b4e:	83 f8 01             	cmp    $0x1,%eax
   13b51:	75 08                	jne    13b5b <GetImage+0x16>
   13b53:	8b 45 08             	mov    0x8(%ebp),%eax
   13b56:	8b 40 54             	mov    0x54(%eax),%eax
   13b59:	eb 09                	jmp    13b64 <GetImage+0x1f>
   13b5b:	8b 45 08             	mov    0x8(%ebp),%eax
   13b5e:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   13b64:	5d                   	pop    %ebp
   13b65:	c3                   	ret    

00013b66 <GetWidth>:

int GetWidth(Context* ctx){
   13b66:	55                   	push   %ebp
   13b67:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   13b69:	8b 45 08             	mov    0x8(%ebp),%eax
   13b6c:	8b 40 10             	mov    0x10(%eax),%eax
}
   13b6f:	5d                   	pop    %ebp
   13b70:	c3                   	ret    

00013b71 <GetHeight>:

int GetHeight(Context* ctx){
   13b71:	55                   	push   %ebp
   13b72:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   13b74:	8b 45 08             	mov    0x8(%ebp),%eax
   13b77:	8b 40 14             	mov    0x14(%eax),%eax
}
   13b7a:	5d                   	pop    %ebp
   13b7b:	c3                   	ret    

00013b7c <GetImageSize>:

uint GetImageSize(Context* ctx){
   13b7c:	55                   	push   %ebp
   13b7d:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   13b7f:	8b 45 08             	mov    0x8(%ebp),%eax
   13b82:	8b 50 10             	mov    0x10(%eax),%edx
   13b85:	8b 45 08             	mov    0x8(%ebp),%eax
   13b88:	8b 40 14             	mov    0x14(%eax),%eax
   13b8b:	0f af d0             	imul   %eax,%edx
   13b8e:	8b 45 08             	mov    0x8(%ebp),%eax
   13b91:	8b 40 28             	mov    0x28(%eax),%eax
   13b94:	0f af c2             	imul   %edx,%eax
}
   13b97:	5d                   	pop    %ebp
   13b98:	c3                   	ret    

00013b99 <_Clip>:

uchar _Clip(const int x){
   13b99:	55                   	push   %ebp
   13b9a:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   13b9c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13ba0:	78 15                	js     13bb7 <_Clip+0x1e>
   13ba2:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   13ba9:	7f 05                	jg     13bb0 <_Clip+0x17>
   13bab:	8b 45 08             	mov    0x8(%ebp),%eax
   13bae:	eb 0c                	jmp    13bbc <_Clip+0x23>
   13bb0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13bb5:	eb 05                	jmp    13bbc <_Clip+0x23>
   13bb7:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13bbc:	5d                   	pop    %ebp
   13bbd:	c3                   	ret    

00013bbe <_Skip>:

void _Skip(Context* ctx, int c){
   13bbe:	55                   	push   %ebp
   13bbf:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   13bc1:	8b 45 08             	mov    0x8(%ebp),%eax
   13bc4:	8b 50 04             	mov    0x4(%eax),%edx
   13bc7:	8b 45 0c             	mov    0xc(%ebp),%eax
   13bca:	01 c2                	add    %eax,%edx
   13bcc:	8b 45 08             	mov    0x8(%ebp),%eax
   13bcf:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   13bd2:	8b 45 08             	mov    0x8(%ebp),%eax
   13bd5:	8b 40 08             	mov    0x8(%eax),%eax
   13bd8:	2b 45 0c             	sub    0xc(%ebp),%eax
   13bdb:	89 c2                	mov    %eax,%edx
   13bdd:	8b 45 08             	mov    0x8(%ebp),%eax
   13be0:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   13be3:	8b 45 08             	mov    0x8(%ebp),%eax
   13be6:	8b 40 0c             	mov    0xc(%eax),%eax
   13be9:	2b 45 0c             	sub    0xc(%ebp),%eax
   13bec:	89 c2                	mov    %eax,%edx
   13bee:	8b 45 08             	mov    0x8(%ebp),%eax
   13bf1:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   13bf4:	8b 45 08             	mov    0x8(%ebp),%eax
   13bf7:	8b 40 08             	mov    0x8(%eax),%eax
   13bfa:	85 c0                	test   %eax,%eax
   13bfc:	79 09                	jns    13c07 <_Skip+0x49>
   13bfe:	8b 45 08             	mov    0x8(%ebp),%eax
   13c01:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   13c07:	90                   	nop
   13c08:	5d                   	pop    %ebp
   13c09:	c3                   	ret    

00013c0a <_DecodeLength>:

void _DecodeLength(Context* ctx){
   13c0a:	55                   	push   %ebp
   13c0b:	89 e5                	mov    %esp,%ebp
   13c0d:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   13c10:	8b 45 08             	mov    0x8(%ebp),%eax
   13c13:	8b 40 08             	mov    0x8(%eax),%eax
   13c16:	83 f8 01             	cmp    $0x1,%eax
   13c19:	7f 0b                	jg     13c26 <_DecodeLength+0x1c>
   13c1b:	8b 45 08             	mov    0x8(%ebp),%eax
   13c1e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13c24:	eb 45                	jmp    13c6b <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   13c26:	8b 45 08             	mov    0x8(%ebp),%eax
   13c29:	8b 40 04             	mov    0x4(%eax),%eax
   13c2c:	83 ec 0c             	sub    $0xc,%esp
   13c2f:	50                   	push   %eax
   13c30:	e8 38 00 00 00       	call   13c6d <_Decode2Bytes>
   13c35:	83 c4 10             	add    $0x10,%esp
   13c38:	89 c2                	mov    %eax,%edx
   13c3a:	8b 45 08             	mov    0x8(%ebp),%eax
   13c3d:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   13c40:	8b 45 08             	mov    0x8(%ebp),%eax
   13c43:	8b 50 0c             	mov    0xc(%eax),%edx
   13c46:	8b 45 08             	mov    0x8(%ebp),%eax
   13c49:	8b 40 08             	mov    0x8(%eax),%eax
   13c4c:	39 c2                	cmp    %eax,%edx
   13c4e:	7e 0b                	jle    13c5b <_DecodeLength+0x51>
   13c50:	8b 45 08             	mov    0x8(%ebp),%eax
   13c53:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13c59:	eb 10                	jmp    13c6b <_DecodeLength+0x61>
    _Skip(ctx, 2);
   13c5b:	83 ec 08             	sub    $0x8,%esp
   13c5e:	6a 02                	push   $0x2
   13c60:	ff 75 08             	pushl  0x8(%ebp)
   13c63:	e8 56 ff ff ff       	call   13bbe <_Skip>
   13c68:	83 c4 10             	add    $0x10,%esp
}
   13c6b:	c9                   	leave  
   13c6c:	c3                   	ret    

00013c6d <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   13c6d:	55                   	push   %ebp
   13c6e:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   13c70:	8b 45 08             	mov    0x8(%ebp),%eax
   13c73:	0f b6 00             	movzbl (%eax),%eax
   13c76:	0f b6 c0             	movzbl %al,%eax
   13c79:	c1 e0 08             	shl    $0x8,%eax
   13c7c:	89 c2                	mov    %eax,%edx
   13c7e:	8b 45 08             	mov    0x8(%ebp),%eax
   13c81:	83 c0 01             	add    $0x1,%eax
   13c84:	0f b6 00             	movzbl (%eax),%eax
   13c87:	0f b6 c0             	movzbl %al,%eax
   13c8a:	09 d0                	or     %edx,%eax
}
   13c8c:	5d                   	pop    %ebp
   13c8d:	c3                   	ret    

00013c8e <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   13c8e:	55                   	push   %ebp
   13c8f:	89 e5                	mov    %esp,%ebp
   13c91:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   13c94:	8b 45 08             	mov    0x8(%ebp),%eax
   13c97:	8b 55 10             	mov    0x10(%ebp),%edx
   13c9a:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   13c9d:	8b 45 14             	mov    0x14(%ebp),%eax
   13ca0:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   13ca5:	89 c2                	mov    %eax,%edx
   13ca7:	8b 45 08             	mov    0x8(%ebp),%eax
   13caa:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   13cad:	8b 45 08             	mov    0x8(%ebp),%eax
   13cb0:	8b 40 08             	mov    0x8(%eax),%eax
   13cb3:	83 f8 01             	cmp    $0x1,%eax
   13cb6:	7e 1d                	jle    13cd5 <_DecodeJPEG+0x47>
   13cb8:	8b 45 08             	mov    0x8(%ebp),%eax
   13cbb:	8b 40 04             	mov    0x4(%eax),%eax
   13cbe:	0f b6 00             	movzbl (%eax),%eax
   13cc1:	3c ff                	cmp    $0xff,%al
   13cc3:	75 10                	jne    13cd5 <_DecodeJPEG+0x47>
   13cc5:	8b 45 08             	mov    0x8(%ebp),%eax
   13cc8:	8b 40 04             	mov    0x4(%eax),%eax
   13ccb:	83 c0 01             	add    $0x1,%eax
   13cce:	0f b6 00             	movzbl (%eax),%eax
   13cd1:	3c d8                	cmp    $0xd8,%al
   13cd3:	74 0a                	je     13cdf <_DecodeJPEG+0x51>
   13cd5:	b8 01 00 00 00       	mov    $0x1,%eax
   13cda:	e9 56 01 00 00       	jmp    13e35 <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   13cdf:	6a 02                	push   $0x2
   13ce1:	ff 75 08             	pushl  0x8(%ebp)
   13ce4:	e8 d5 fe ff ff       	call   13bbe <_Skip>
   13ce9:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   13cec:	e9 0a 01 00 00       	jmp    13dfb <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   13cf1:	8b 45 08             	mov    0x8(%ebp),%eax
   13cf4:	8b 40 08             	mov    0x8(%eax),%eax
   13cf7:	85 c0                	test   %eax,%eax
   13cf9:	78 0d                	js     13d08 <_DecodeJPEG+0x7a>
   13cfb:	8b 45 08             	mov    0x8(%ebp),%eax
   13cfe:	8b 40 04             	mov    0x4(%eax),%eax
   13d01:	0f b6 00             	movzbl (%eax),%eax
   13d04:	3c ff                	cmp    $0xff,%al
   13d06:	74 0a                	je     13d12 <_DecodeJPEG+0x84>
   13d08:	b8 05 00 00 00       	mov    $0x5,%eax
   13d0d:	e9 23 01 00 00       	jmp    13e35 <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   13d12:	6a 02                	push   $0x2
   13d14:	ff 75 08             	pushl  0x8(%ebp)
   13d17:	e8 a2 fe ff ff       	call   13bbe <_Skip>
   13d1c:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   13d1f:	8b 45 08             	mov    0x8(%ebp),%eax
   13d22:	8b 40 04             	mov    0x4(%eax),%eax
   13d25:	83 e8 01             	sub    $0x1,%eax
   13d28:	0f b6 00             	movzbl (%eax),%eax
   13d2b:	0f b6 c0             	movzbl %al,%eax
   13d2e:	3d da 00 00 00       	cmp    $0xda,%eax
   13d33:	74 71                	je     13da6 <_DecodeJPEG+0x118>
   13d35:	3d da 00 00 00       	cmp    $0xda,%eax
   13d3a:	7f 10                	jg     13d4c <_DecodeJPEG+0xbe>
   13d3c:	3d c0 00 00 00       	cmp    $0xc0,%eax
   13d41:	74 20                	je     13d63 <_DecodeJPEG+0xd5>
   13d43:	3d c4 00 00 00       	cmp    $0xc4,%eax
   13d48:	74 2c                	je     13d76 <_DecodeJPEG+0xe8>
   13d4a:	eb 7d                	jmp    13dc9 <_DecodeJPEG+0x13b>
   13d4c:	3d dd 00 00 00       	cmp    $0xdd,%eax
   13d51:	74 43                	je     13d96 <_DecodeJPEG+0x108>
   13d53:	3d fe 00 00 00       	cmp    $0xfe,%eax
   13d58:	74 5f                	je     13db9 <_DecodeJPEG+0x12b>
   13d5a:	3d db 00 00 00       	cmp    $0xdb,%eax
   13d5f:	74 25                	je     13d86 <_DecodeJPEG+0xf8>
   13d61:	eb 66                	jmp    13dc9 <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   13d63:	83 ec 0c             	sub    $0xc,%esp
   13d66:	ff 75 08             	pushl  0x8(%ebp)
   13d69:	e8 c9 00 00 00       	call   13e37 <_DecodeSOF>
   13d6e:	83 c4 10             	add    $0x10,%esp
   13d71:	e9 85 00 00 00       	jmp    13dfb <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   13d76:	83 ec 0c             	sub    $0xc,%esp
   13d79:	ff 75 08             	pushl  0x8(%ebp)
   13d7c:	e8 28 05 00 00       	call   142a9 <_DecodeDHT>
   13d81:	83 c4 10             	add    $0x10,%esp
   13d84:	eb 75                	jmp    13dfb <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   13d86:	83 ec 0c             	sub    $0xc,%esp
   13d89:	ff 75 08             	pushl  0x8(%ebp)
   13d8c:	e8 05 07 00 00       	call   14496 <_DecodeDQT>
   13d91:	83 c4 10             	add    $0x10,%esp
   13d94:	eb 65                	jmp    13dfb <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   13d96:	83 ec 0c             	sub    $0xc,%esp
   13d99:	ff 75 08             	pushl  0x8(%ebp)
   13d9c:	e8 ff 07 00 00       	call   145a0 <_DecodeDRI>
   13da1:	83 c4 10             	add    $0x10,%esp
   13da4:	eb 55                	jmp    13dfb <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   13da6:	83 ec 08             	sub    $0x8,%esp
   13da9:	ff 75 0c             	pushl  0xc(%ebp)
   13dac:	ff 75 08             	pushl  0x8(%ebp)
   13daf:	e8 56 08 00 00       	call   1460a <_DecodeSOS>
   13db4:	83 c4 10             	add    $0x10,%esp
   13db7:	eb 42                	jmp    13dfb <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   13db9:	83 ec 0c             	sub    $0xc,%esp
   13dbc:	ff 75 08             	pushl  0x8(%ebp)
   13dbf:	e8 a8 15 00 00       	call   1536c <_SkipMarker>
   13dc4:	83 c4 10             	add    $0x10,%esp
   13dc7:	eb 32                	jmp    13dfb <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   13dc9:	8b 45 08             	mov    0x8(%ebp),%eax
   13dcc:	8b 40 04             	mov    0x4(%eax),%eax
   13dcf:	83 e8 01             	sub    $0x1,%eax
   13dd2:	0f b6 00             	movzbl (%eax),%eax
   13dd5:	0f b6 c0             	movzbl %al,%eax
   13dd8:	25 f0 00 00 00       	and    $0xf0,%eax
   13ddd:	3d e0 00 00 00       	cmp    $0xe0,%eax
   13de2:	75 10                	jne    13df4 <_DecodeJPEG+0x166>
   13de4:	83 ec 0c             	sub    $0xc,%esp
   13de7:	ff 75 08             	pushl  0x8(%ebp)
   13dea:	e8 7d 15 00 00       	call   1536c <_SkipMarker>
   13def:	83 c4 10             	add    $0x10,%esp
   13df2:	eb 07                	jmp    13dfb <_DecodeJPEG+0x16d>
                else return Unsupported;
   13df4:	b8 02 00 00 00       	mov    $0x2,%eax
   13df9:	eb 3a                	jmp    13e35 <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   13dfb:	8b 45 08             	mov    0x8(%ebp),%eax
   13dfe:	8b 00                	mov    (%eax),%eax
   13e00:	85 c0                	test   %eax,%eax
   13e02:	0f 84 e9 fe ff ff    	je     13cf1 <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   13e08:	8b 45 08             	mov    0x8(%ebp),%eax
   13e0b:	8b 00                	mov    (%eax),%eax
   13e0d:	83 f8 06             	cmp    $0x6,%eax
   13e10:	74 07                	je     13e19 <_DecodeJPEG+0x18b>
   13e12:	8b 45 08             	mov    0x8(%ebp),%eax
   13e15:	8b 00                	mov    (%eax),%eax
   13e17:	eb 1c                	jmp    13e35 <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   13e19:	8b 45 08             	mov    0x8(%ebp),%eax
   13e1c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   13e22:	83 ec 0c             	sub    $0xc,%esp
   13e25:	ff 75 08             	pushl  0x8(%ebp)
   13e28:	e8 6b 15 00 00       	call   15398 <_Convert>
   13e2d:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   13e30:	8b 45 08             	mov    0x8(%ebp),%eax
   13e33:	8b 00                	mov    (%eax),%eax
 }
   13e35:	c9                   	leave  
   13e36:	c3                   	ret    

00013e37 <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   13e37:	55                   	push   %ebp
   13e38:	89 e5                	mov    %esp,%ebp
   13e3a:	53                   	push   %ebx
   13e3b:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   13e3e:	83 ec 0c             	sub    $0xc,%esp
   13e41:	ff 75 08             	pushl  0x8(%ebp)
   13e44:	e8 c1 fd ff ff       	call   13c0a <_DecodeLength>
   13e49:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   13e4c:	8b 45 08             	mov    0x8(%ebp),%eax
   13e4f:	8b 00                	mov    (%eax),%eax
   13e51:	85 c0                	test   %eax,%eax
   13e53:	0f 85 4a 04 00 00    	jne    142a3 <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   13e59:	8b 45 08             	mov    0x8(%ebp),%eax
   13e5c:	8b 40 0c             	mov    0xc(%eax),%eax
   13e5f:	83 f8 08             	cmp    $0x8,%eax
   13e62:	7f 0e                	jg     13e72 <_DecodeSOF+0x3b>
   13e64:	8b 45 08             	mov    0x8(%ebp),%eax
   13e67:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13e6d:	e9 32 04 00 00       	jmp    142a4 <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   13e72:	8b 45 08             	mov    0x8(%ebp),%eax
   13e75:	8b 40 04             	mov    0x4(%eax),%eax
   13e78:	0f b6 00             	movzbl (%eax),%eax
   13e7b:	3c 08                	cmp    $0x8,%al
   13e7d:	74 0e                	je     13e8d <_DecodeSOF+0x56>
   13e7f:	8b 45 08             	mov    0x8(%ebp),%eax
   13e82:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13e88:	e9 17 04 00 00       	jmp    142a4 <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   13e8d:	8b 45 08             	mov    0x8(%ebp),%eax
   13e90:	8b 40 04             	mov    0x4(%eax),%eax
   13e93:	83 c0 01             	add    $0x1,%eax
   13e96:	83 ec 0c             	sub    $0xc,%esp
   13e99:	50                   	push   %eax
   13e9a:	e8 ce fd ff ff       	call   13c6d <_Decode2Bytes>
   13e9f:	83 c4 10             	add    $0x10,%esp
   13ea2:	89 c2                	mov    %eax,%edx
   13ea4:	8b 45 08             	mov    0x8(%ebp),%eax
   13ea7:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   13eaa:	8b 45 08             	mov    0x8(%ebp),%eax
   13ead:	8b 40 04             	mov    0x4(%eax),%eax
   13eb0:	83 c0 03             	add    $0x3,%eax
   13eb3:	83 ec 0c             	sub    $0xc,%esp
   13eb6:	50                   	push   %eax
   13eb7:	e8 b1 fd ff ff       	call   13c6d <_Decode2Bytes>
   13ebc:	83 c4 10             	add    $0x10,%esp
   13ebf:	89 c2                	mov    %eax,%edx
   13ec1:	8b 45 08             	mov    0x8(%ebp),%eax
   13ec4:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   13ec7:	8b 45 08             	mov    0x8(%ebp),%eax
   13eca:	8b 40 04             	mov    0x4(%eax),%eax
   13ecd:	83 c0 05             	add    $0x5,%eax
   13ed0:	0f b6 00             	movzbl (%eax),%eax
   13ed3:	0f b6 d0             	movzbl %al,%edx
   13ed6:	8b 45 08             	mov    0x8(%ebp),%eax
   13ed9:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   13edc:	83 ec 08             	sub    $0x8,%esp
   13edf:	6a 06                	push   $0x6
   13ee1:	ff 75 08             	pushl  0x8(%ebp)
   13ee4:	e8 d5 fc ff ff       	call   13bbe <_Skip>
   13ee9:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   13eec:	8b 45 08             	mov    0x8(%ebp),%eax
   13eef:	8b 40 28             	mov    0x28(%eax),%eax
   13ef2:	83 f8 01             	cmp    $0x1,%eax
   13ef5:	74 13                	je     13f0a <_DecodeSOF+0xd3>
   13ef7:	83 f8 03             	cmp    $0x3,%eax
   13efa:	74 0e                	je     13f0a <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   13efc:	8b 45 08             	mov    0x8(%ebp),%eax
   13eff:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13f05:	e9 9a 03 00 00       	jmp    142a4 <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   13f0a:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   13f0b:	8b 45 08             	mov    0x8(%ebp),%eax
   13f0e:	8b 48 0c             	mov    0xc(%eax),%ecx
   13f11:	8b 45 08             	mov    0x8(%ebp),%eax
   13f14:	8b 50 28             	mov    0x28(%eax),%edx
   13f17:	89 d0                	mov    %edx,%eax
   13f19:	01 c0                	add    %eax,%eax
   13f1b:	01 d0                	add    %edx,%eax
   13f1d:	39 c1                	cmp    %eax,%ecx
   13f1f:	7d 0e                	jge    13f2f <_DecodeSOF+0xf8>
   13f21:	8b 45 08             	mov    0x8(%ebp),%eax
   13f24:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13f2a:	e9 75 03 00 00       	jmp    142a4 <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   13f2f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   13f36:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   13f3d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   13f44:	8b 45 08             	mov    0x8(%ebp),%eax
   13f47:	83 c0 2c             	add    $0x2c,%eax
   13f4a:	89 45 e8             	mov    %eax,-0x18(%ebp)
   13f4d:	e9 50 01 00 00       	jmp    140a2 <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   13f52:	8b 45 08             	mov    0x8(%ebp),%eax
   13f55:	8b 40 04             	mov    0x4(%eax),%eax
   13f58:	0f b6 00             	movzbl (%eax),%eax
   13f5b:	0f b6 d0             	movzbl %al,%edx
   13f5e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f61:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   13f63:	8b 45 08             	mov    0x8(%ebp),%eax
   13f66:	8b 40 04             	mov    0x4(%eax),%eax
   13f69:	83 c0 01             	add    $0x1,%eax
   13f6c:	0f b6 00             	movzbl (%eax),%eax
   13f6f:	c0 e8 04             	shr    $0x4,%al
   13f72:	0f b6 d0             	movzbl %al,%edx
   13f75:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f78:	89 50 04             	mov    %edx,0x4(%eax)
   13f7b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13f7e:	8b 40 04             	mov    0x4(%eax),%eax
   13f81:	85 c0                	test   %eax,%eax
   13f83:	75 0e                	jne    13f93 <_DecodeSOF+0x15c>
   13f85:	8b 45 08             	mov    0x8(%ebp),%eax
   13f88:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13f8e:	e9 11 03 00 00       	jmp    142a4 <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   13f93:	8b 45 08             	mov    0x8(%ebp),%eax
   13f96:	8b 40 04             	mov    0x4(%eax),%eax
   13f99:	83 c0 01             	add    $0x1,%eax
   13f9c:	0f b6 00             	movzbl (%eax),%eax
   13f9f:	0f b6 c0             	movzbl %al,%eax
   13fa2:	83 e0 0f             	and    $0xf,%eax
   13fa5:	89 c2                	mov    %eax,%edx
   13fa7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13faa:	89 50 08             	mov    %edx,0x8(%eax)
   13fad:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fb0:	8b 40 08             	mov    0x8(%eax),%eax
   13fb3:	85 c0                	test   %eax,%eax
   13fb5:	75 0e                	jne    13fc5 <_DecodeSOF+0x18e>
   13fb7:	8b 45 08             	mov    0x8(%ebp),%eax
   13fba:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13fc0:	e9 df 02 00 00       	jmp    142a4 <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   13fc5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fc8:	8b 50 04             	mov    0x4(%eax),%edx
   13fcb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13fce:	8b 40 04             	mov    0x4(%eax),%eax
   13fd1:	83 e8 01             	sub    $0x1,%eax
   13fd4:	21 d0                	and    %edx,%eax
   13fd6:	85 c0                	test   %eax,%eax
   13fd8:	74 0e                	je     13fe8 <_DecodeSOF+0x1b1>
   13fda:	8b 45 08             	mov    0x8(%ebp),%eax
   13fdd:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13fe3:	e9 bc 02 00 00       	jmp    142a4 <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   13fe8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13feb:	8b 50 08             	mov    0x8(%eax),%edx
   13fee:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13ff1:	8b 40 08             	mov    0x8(%eax),%eax
   13ff4:	83 e8 01             	sub    $0x1,%eax
   13ff7:	21 d0                	and    %edx,%eax
   13ff9:	85 c0                	test   %eax,%eax
   13ffb:	74 0e                	je     1400b <_DecodeSOF+0x1d4>
   13ffd:	8b 45 08             	mov    0x8(%ebp),%eax
   14000:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14006:	e9 99 02 00 00       	jmp    142a4 <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   1400b:	8b 45 08             	mov    0x8(%ebp),%eax
   1400e:	8b 40 04             	mov    0x4(%eax),%eax
   14011:	83 c0 02             	add    $0x2,%eax
   14014:	0f b6 00             	movzbl (%eax),%eax
   14017:	0f b6 d0             	movzbl %al,%edx
   1401a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1401d:	89 50 18             	mov    %edx,0x18(%eax)
   14020:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14023:	8b 40 18             	mov    0x18(%eax),%eax
   14026:	25 fc 00 00 00       	and    $0xfc,%eax
   1402b:	85 c0                	test   %eax,%eax
   1402d:	74 0e                	je     1403d <_DecodeSOF+0x206>
   1402f:	8b 45 08             	mov    0x8(%ebp),%eax
   14032:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14038:	e9 67 02 00 00       	jmp    142a4 <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   1403d:	83 ec 08             	sub    $0x8,%esp
   14040:	6a 03                	push   $0x3
   14042:	ff 75 08             	pushl  0x8(%ebp)
   14045:	e8 74 fb ff ff       	call   13bbe <_Skip>
   1404a:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   1404d:	8b 45 08             	mov    0x8(%ebp),%eax
   14050:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   14056:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14059:	8b 40 18             	mov    0x18(%eax),%eax
   1405c:	bb 01 00 00 00       	mov    $0x1,%ebx
   14061:	89 c1                	mov    %eax,%ecx
   14063:	d3 e3                	shl    %cl,%ebx
   14065:	89 d8                	mov    %ebx,%eax
   14067:	09 c2                	or     %eax,%edx
   14069:	8b 45 08             	mov    0x8(%ebp),%eax
   1406c:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   14072:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14075:	8b 40 04             	mov    0x4(%eax),%eax
   14078:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1407b:	7e 09                	jle    14086 <_DecodeSOF+0x24f>
   1407d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14080:	8b 40 04             	mov    0x4(%eax),%eax
   14083:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   14086:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14089:	8b 40 08             	mov    0x8(%eax),%eax
   1408c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1408f:	7e 09                	jle    1409a <_DecodeSOF+0x263>
   14091:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14094:	8b 40 08             	mov    0x8(%eax),%eax
   14097:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1409a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1409e:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   140a2:	8b 45 08             	mov    0x8(%ebp),%eax
   140a5:	8b 40 28             	mov    0x28(%eax),%eax
   140a8:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   140ab:	0f 8f a1 fe ff ff    	jg     13f52 <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   140b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
   140b4:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   140bb:	8b 45 08             	mov    0x8(%ebp),%eax
   140be:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   140c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   140c4:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   140cb:	8b 45 08             	mov    0x8(%ebp),%eax
   140ce:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   140d1:	8b 45 08             	mov    0x8(%ebp),%eax
   140d4:	8b 50 10             	mov    0x10(%eax),%edx
   140d7:	8b 45 08             	mov    0x8(%ebp),%eax
   140da:	8b 40 20             	mov    0x20(%eax),%eax
   140dd:	01 d0                	add    %edx,%eax
   140df:	8d 48 ff             	lea    -0x1(%eax),%ecx
   140e2:	8b 45 08             	mov    0x8(%ebp),%eax
   140e5:	8b 58 20             	mov    0x20(%eax),%ebx
   140e8:	89 c8                	mov    %ecx,%eax
   140ea:	99                   	cltd   
   140eb:	f7 fb                	idiv   %ebx
   140ed:	89 c2                	mov    %eax,%edx
   140ef:	8b 45 08             	mov    0x8(%ebp),%eax
   140f2:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   140f5:	8b 45 08             	mov    0x8(%ebp),%eax
   140f8:	8b 50 14             	mov    0x14(%eax),%edx
   140fb:	8b 45 08             	mov    0x8(%ebp),%eax
   140fe:	8b 40 24             	mov    0x24(%eax),%eax
   14101:	01 d0                	add    %edx,%eax
   14103:	8d 48 ff             	lea    -0x1(%eax),%ecx
   14106:	8b 45 08             	mov    0x8(%ebp),%eax
   14109:	8b 58 24             	mov    0x24(%eax),%ebx
   1410c:	89 c8                	mov    %ecx,%eax
   1410e:	99                   	cltd   
   1410f:	f7 fb                	idiv   %ebx
   14111:	89 c2                	mov    %eax,%edx
   14113:	8b 45 08             	mov    0x8(%ebp),%eax
   14116:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   14119:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14120:	8b 45 08             	mov    0x8(%ebp),%eax
   14123:	83 c0 2c             	add    $0x2c,%eax
   14126:	89 45 e8             	mov    %eax,-0x18(%ebp)
   14129:	e9 fd 00 00 00       	jmp    1422b <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   1412e:	8b 45 08             	mov    0x8(%ebp),%eax
   14131:	8b 50 10             	mov    0x10(%eax),%edx
   14134:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14137:	8b 40 04             	mov    0x4(%eax),%eax
   1413a:	0f af d0             	imul   %eax,%edx
   1413d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14140:	01 d0                	add    %edx,%eax
   14142:	83 e8 01             	sub    $0x1,%eax
   14145:	99                   	cltd   
   14146:	f7 7d ec             	idivl  -0x14(%ebp)
   14149:	89 c2                	mov    %eax,%edx
   1414b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1414e:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   14151:	8b 45 08             	mov    0x8(%ebp),%eax
   14154:	8b 50 14             	mov    0x14(%eax),%edx
   14157:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1415a:	8b 40 08             	mov    0x8(%eax),%eax
   1415d:	0f af d0             	imul   %eax,%edx
   14160:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14163:	01 d0                	add    %edx,%eax
   14165:	83 e8 01             	sub    $0x1,%eax
   14168:	99                   	cltd   
   14169:	f7 7d f0             	idivl  -0x10(%ebp)
   1416c:	89 c2                	mov    %eax,%edx
   1416e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14171:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   14174:	8b 45 08             	mov    0x8(%ebp),%eax
   14177:	8b 50 18             	mov    0x18(%eax),%edx
   1417a:	8b 45 08             	mov    0x8(%ebp),%eax
   1417d:	8b 40 20             	mov    0x20(%eax),%eax
   14180:	0f af d0             	imul   %eax,%edx
   14183:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14186:	8b 40 04             	mov    0x4(%eax),%eax
   14189:	0f af c2             	imul   %edx,%eax
   1418c:	99                   	cltd   
   1418d:	f7 7d ec             	idivl  -0x14(%ebp)
   14190:	89 c2                	mov    %eax,%edx
   14192:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14195:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   14198:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1419b:	8b 40 0c             	mov    0xc(%eax),%eax
   1419e:	83 f8 02             	cmp    $0x2,%eax
   141a1:	7f 0b                	jg     141ae <_DecodeSOF+0x377>
   141a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141a6:	8b 40 04             	mov    0x4(%eax),%eax
   141a9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   141ac:	75 16                	jne    141c4 <_DecodeSOF+0x38d>
   141ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141b1:	8b 40 10             	mov    0x10(%eax),%eax
   141b4:	83 f8 02             	cmp    $0x2,%eax
   141b7:	7f 19                	jg     141d2 <_DecodeSOF+0x39b>
   141b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141bc:	8b 40 08             	mov    0x8(%eax),%eax
   141bf:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   141c2:	74 0e                	je     141d2 <_DecodeSOF+0x39b>
   141c4:	8b 45 08             	mov    0x8(%ebp),%eax
   141c7:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   141cd:	e9 d2 00 00 00       	jmp    142a4 <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   141d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141d5:	8b 48 14             	mov    0x14(%eax),%ecx
   141d8:	8b 45 08             	mov    0x8(%ebp),%eax
   141db:	8b 50 1c             	mov    0x1c(%eax),%edx
   141de:	8b 45 08             	mov    0x8(%ebp),%eax
   141e1:	8b 40 24             	mov    0x24(%eax),%eax
   141e4:	0f af d0             	imul   %eax,%edx
   141e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141ea:	8b 40 08             	mov    0x8(%eax),%eax
   141ed:	0f af c2             	imul   %edx,%eax
   141f0:	99                   	cltd   
   141f1:	f7 7d f0             	idivl  -0x10(%ebp)
   141f4:	0f af c1             	imul   %ecx,%eax
   141f7:	83 ec 0c             	sub    $0xc,%esp
   141fa:	50                   	push   %eax
   141fb:	e8 45 c5 fe ff       	call   745 <malloc>
   14200:	83 c4 10             	add    $0x10,%esp
   14203:	89 c2                	mov    %eax,%edx
   14205:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14208:	89 50 28             	mov    %edx,0x28(%eax)
   1420b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1420e:	8b 40 28             	mov    0x28(%eax),%eax
   14211:	85 c0                	test   %eax,%eax
   14213:	75 0e                	jne    14223 <_DecodeSOF+0x3ec>
   14215:	8b 45 08             	mov    0x8(%ebp),%eax
   14218:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1421e:	e9 81 00 00 00       	jmp    142a4 <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   14223:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14227:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   1422b:	8b 45 08             	mov    0x8(%ebp),%eax
   1422e:	8b 40 28             	mov    0x28(%eax),%eax
   14231:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14234:	0f 8f f4 fe ff ff    	jg     1412e <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   1423a:	8b 45 08             	mov    0x8(%ebp),%eax
   1423d:	8b 40 28             	mov    0x28(%eax),%eax
   14240:	83 f8 03             	cmp    $0x3,%eax
   14243:	75 47                	jne    1428c <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   14245:	8b 45 08             	mov    0x8(%ebp),%eax
   14248:	8b 50 10             	mov    0x10(%eax),%edx
   1424b:	8b 45 08             	mov    0x8(%ebp),%eax
   1424e:	8b 40 14             	mov    0x14(%eax),%eax
   14251:	0f af d0             	imul   %eax,%edx
   14254:	8b 45 08             	mov    0x8(%ebp),%eax
   14257:	8b 40 28             	mov    0x28(%eax),%eax
   1425a:	0f af c2             	imul   %edx,%eax
   1425d:	83 ec 0c             	sub    $0xc,%esp
   14260:	50                   	push   %eax
   14261:	e8 df c4 fe ff       	call   745 <malloc>
   14266:	83 c4 10             	add    $0x10,%esp
   14269:	89 c2                	mov    %eax,%edx
   1426b:	8b 45 08             	mov    0x8(%ebp),%eax
   1426e:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   14274:	8b 45 08             	mov    0x8(%ebp),%eax
   14277:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1427d:	85 c0                	test   %eax,%eax
   1427f:	75 0b                	jne    1428c <_DecodeSOF+0x455>
   14281:	8b 45 08             	mov    0x8(%ebp),%eax
   14284:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1428a:	eb 18                	jmp    142a4 <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   1428c:	8b 45 08             	mov    0x8(%ebp),%eax
   1428f:	8b 40 0c             	mov    0xc(%eax),%eax
   14292:	83 ec 08             	sub    $0x8,%esp
   14295:	50                   	push   %eax
   14296:	ff 75 08             	pushl  0x8(%ebp)
   14299:	e8 20 f9 ff ff       	call   13bbe <_Skip>
   1429e:	83 c4 10             	add    $0x10,%esp
   142a1:	eb 01                	jmp    142a4 <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   142a3:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   142a4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   142a7:	c9                   	leave  
   142a8:	c3                   	ret    

000142a9 <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   142a9:	55                   	push   %ebp
   142aa:	89 e5                	mov    %esp,%ebp
   142ac:	53                   	push   %ebx
   142ad:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   142b0:	83 ec 0c             	sub    $0xc,%esp
   142b3:	ff 75 08             	pushl  0x8(%ebp)
   142b6:	e8 4f f9 ff ff       	call   13c0a <_DecodeLength>
   142bb:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   142be:	8b 45 08             	mov    0x8(%ebp),%eax
   142c1:	8b 00                	mov    (%eax),%eax
   142c3:	85 c0                	test   %eax,%eax
   142c5:	0f 85 c5 01 00 00    	jne    14490 <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   142cb:	e9 9c 01 00 00       	jmp    1446c <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   142d0:	8b 45 08             	mov    0x8(%ebp),%eax
   142d3:	8b 40 04             	mov    0x4(%eax),%eax
   142d6:	0f b6 00             	movzbl (%eax),%eax
   142d9:	0f b6 c0             	movzbl %al,%eax
   142dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   142df:	8b 45 f4             	mov    -0xc(%ebp),%eax
   142e2:	25 ec 00 00 00       	and    $0xec,%eax
   142e7:	85 c0                	test   %eax,%eax
   142e9:	74 0e                	je     142f9 <_DecodeDHT+0x50>
   142eb:	8b 45 08             	mov    0x8(%ebp),%eax
   142ee:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   142f4:	e9 98 01 00 00       	jmp    14491 <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   142f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   142fc:	83 e0 02             	and    $0x2,%eax
   142ff:	85 c0                	test   %eax,%eax
   14301:	74 0e                	je     14311 <_DecodeDHT+0x68>
   14303:	8b 45 08             	mov    0x8(%ebp),%eax
   14306:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1430c:	e9 80 01 00 00       	jmp    14491 <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   14311:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14314:	c1 f8 03             	sar    $0x3,%eax
   14317:	0b 45 f4             	or     -0xc(%ebp),%eax
   1431a:	83 e0 03             	and    $0x3,%eax
   1431d:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   14320:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14327:	eb 1c                	jmp    14345 <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   14329:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1432c:	8d 50 ff             	lea    -0x1(%eax),%edx
   1432f:	8b 45 08             	mov    0x8(%ebp),%eax
   14332:	8b 48 04             	mov    0x4(%eax),%ecx
   14335:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14338:	01 c8                	add    %ecx,%eax
   1433a:	0f b6 00             	movzbl (%eax),%eax
   1433d:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   14341:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14345:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   14349:	7e de                	jle    14329 <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   1434b:	83 ec 08             	sub    $0x8,%esp
   1434e:	6a 11                	push   $0x11
   14350:	ff 75 08             	pushl  0x8(%ebp)
   14353:	e8 66 f8 ff ff       	call   13bbe <_Skip>
   14358:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   1435b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1435e:	c1 e0 11             	shl    $0x11,%eax
   14361:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14367:	8b 45 08             	mov    0x8(%ebp),%eax
   1436a:	01 d0                	add    %edx,%eax
   1436c:	83 c0 08             	add    $0x8,%eax
   1436f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   14372:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   14379:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1437c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   1437f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14386:	e9 be 00 00 00       	jmp    14449 <_DecodeDHT+0x1a0>
            spread >>= 1;
   1438b:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   1438e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14391:	83 e8 01             	sub    $0x1,%eax
   14394:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   14399:	0f b6 c0             	movzbl %al,%eax
   1439c:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   1439f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   143a3:	0f 84 9b 00 00 00    	je     14444 <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   143a9:	8b 45 08             	mov    0x8(%ebp),%eax
   143ac:	8b 40 0c             	mov    0xc(%eax),%eax
   143af:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   143b2:	7d 0e                	jge    143c2 <_DecodeDHT+0x119>
   143b4:	8b 45 08             	mov    0x8(%ebp),%eax
   143b7:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   143bd:	e9 cf 00 00 00       	jmp    14491 <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   143c2:	b8 10 00 00 00       	mov    $0x10,%eax
   143c7:	2b 45 f0             	sub    -0x10(%ebp),%eax
   143ca:	8b 55 e0             	mov    -0x20(%ebp),%edx
   143cd:	89 c1                	mov    %eax,%ecx
   143cf:	d3 e2                	shl    %cl,%edx
   143d1:	89 d0                	mov    %edx,%eax
   143d3:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   143d6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   143da:	79 0e                	jns    143ea <_DecodeDHT+0x141>
   143dc:	8b 45 08             	mov    0x8(%ebp),%eax
   143df:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   143e5:	e9 a7 00 00 00       	jmp    14491 <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   143ea:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   143f1:	eb 36                	jmp    14429 <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   143f3:	8b 45 08             	mov    0x8(%ebp),%eax
   143f6:	8b 50 04             	mov    0x4(%eax),%edx
   143f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   143fc:	01 d0                	add    %edx,%eax
   143fe:	0f b6 00             	movzbl (%eax),%eax
   14401:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   14403:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   14406:	eb 14                	jmp    1441c <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   14408:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1440b:	89 c2                	mov    %eax,%edx
   1440d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14410:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   14412:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14415:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   14418:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   1441c:	89 d8                	mov    %ebx,%eax
   1441e:	8d 58 ff             	lea    -0x1(%eax),%ebx
   14421:	85 c0                	test   %eax,%eax
   14423:	75 e3                	jne    14408 <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   14425:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14429:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1442c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   1442f:	7c c2                	jl     143f3 <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   14431:	83 ec 08             	sub    $0x8,%esp
   14434:	ff 75 e0             	pushl  -0x20(%ebp)
   14437:	ff 75 08             	pushl  0x8(%ebp)
   1443a:	e8 7f f7 ff ff       	call   13bbe <_Skip>
   1443f:	83 c4 10             	add    $0x10,%esp
   14442:	eb 01                	jmp    14445 <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   14444:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   14445:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14449:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   1444d:	0f 8e 38 ff ff ff    	jle    1438b <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14453:	eb 0a                	jmp    1445f <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   14455:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14458:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   1445b:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   1445f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14462:	8d 50 ff             	lea    -0x1(%eax),%edx
   14465:	89 55 ec             	mov    %edx,-0x14(%ebp)
   14468:	85 c0                	test   %eax,%eax
   1446a:	75 e9                	jne    14455 <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   1446c:	8b 45 08             	mov    0x8(%ebp),%eax
   1446f:	8b 40 0c             	mov    0xc(%eax),%eax
   14472:	83 f8 10             	cmp    $0x10,%eax
   14475:	0f 8f 55 fe ff ff    	jg     142d0 <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   1447b:	8b 45 08             	mov    0x8(%ebp),%eax
   1447e:	8b 40 0c             	mov    0xc(%eax),%eax
   14481:	85 c0                	test   %eax,%eax
   14483:	74 0c                	je     14491 <_DecodeDHT+0x1e8>
   14485:	8b 45 08             	mov    0x8(%ebp),%eax
   14488:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1448e:	eb 01                	jmp    14491 <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   14490:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14491:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14494:	c9                   	leave  
   14495:	c3                   	ret    

00014496 <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   14496:	55                   	push   %ebp
   14497:	89 e5                	mov    %esp,%ebp
   14499:	53                   	push   %ebx
   1449a:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   1449d:	83 ec 0c             	sub    $0xc,%esp
   144a0:	ff 75 08             	pushl  0x8(%ebp)
   144a3:	e8 62 f7 ff ff       	call   13c0a <_DecodeLength>
   144a8:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   144ab:	8b 45 08             	mov    0x8(%ebp),%eax
   144ae:	8b 00                	mov    (%eax),%eax
   144b0:	85 c0                	test   %eax,%eax
   144b2:	0f 85 e2 00 00 00    	jne    1459a <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   144b8:	e9 b8 00 00 00       	jmp    14575 <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   144bd:	8b 45 08             	mov    0x8(%ebp),%eax
   144c0:	8b 40 04             	mov    0x4(%eax),%eax
   144c3:	0f b6 00             	movzbl (%eax),%eax
   144c6:	0f b6 c0             	movzbl %al,%eax
   144c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   144cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144cf:	25 ec 00 00 00       	and    $0xec,%eax
   144d4:	85 c0                	test   %eax,%eax
   144d6:	74 0e                	je     144e6 <_DecodeDQT+0x50>
   144d8:	8b 45 08             	mov    0x8(%ebp),%eax
   144db:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   144e1:	e9 b5 00 00 00       	jmp    1459b <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   144e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144e9:	83 e0 10             	and    $0x10,%eax
   144ec:	85 c0                	test   %eax,%eax
   144ee:	74 0e                	je     144fe <_DecodeDQT+0x68>
   144f0:	8b 45 08             	mov    0x8(%ebp),%eax
   144f3:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   144f9:	e9 9d 00 00 00       	jmp    1459b <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   144fe:	8b 45 08             	mov    0x8(%ebp),%eax
   14501:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   14507:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1450a:	bb 01 00 00 00       	mov    $0x1,%ebx
   1450f:	89 c1                	mov    %eax,%ecx
   14511:	d3 e3                	shl    %cl,%ebx
   14513:	89 d8                	mov    %ebx,%eax
   14515:	09 c2                	or     %eax,%edx
   14517:	8b 45 08             	mov    0x8(%ebp),%eax
   1451a:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   14520:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14523:	c1 e0 06             	shl    $0x6,%eax
   14526:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   1452c:	8b 45 08             	mov    0x8(%ebp),%eax
   1452f:	01 d0                	add    %edx,%eax
   14531:	83 c0 08             	add    $0x8,%eax
   14534:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   14537:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1453e:	eb 1f                	jmp    1455f <_DecodeDQT+0xc9>
   14540:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14543:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14546:	01 c2                	add    %eax,%edx
   14548:	8b 45 08             	mov    0x8(%ebp),%eax
   1454b:	8b 40 04             	mov    0x4(%eax),%eax
   1454e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14551:	83 c1 01             	add    $0x1,%ecx
   14554:	01 c8                	add    %ecx,%eax
   14556:	0f b6 00             	movzbl (%eax),%eax
   14559:	88 02                	mov    %al,(%edx)
   1455b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1455f:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14563:	7e db                	jle    14540 <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   14565:	83 ec 08             	sub    $0x8,%esp
   14568:	6a 41                	push   $0x41
   1456a:	ff 75 08             	pushl  0x8(%ebp)
   1456d:	e8 4c f6 ff ff       	call   13bbe <_Skip>
   14572:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   14575:	8b 45 08             	mov    0x8(%ebp),%eax
   14578:	8b 40 0c             	mov    0xc(%eax),%eax
   1457b:	83 f8 40             	cmp    $0x40,%eax
   1457e:	0f 8f 39 ff ff ff    	jg     144bd <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14584:	8b 45 08             	mov    0x8(%ebp),%eax
   14587:	8b 40 0c             	mov    0xc(%eax),%eax
   1458a:	85 c0                	test   %eax,%eax
   1458c:	74 0d                	je     1459b <_DecodeDQT+0x105>
   1458e:	8b 45 08             	mov    0x8(%ebp),%eax
   14591:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14597:	90                   	nop
   14598:	eb 01                	jmp    1459b <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   1459a:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   1459b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1459e:	c9                   	leave  
   1459f:	c3                   	ret    

000145a0 <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   145a0:	55                   	push   %ebp
   145a1:	89 e5                	mov    %esp,%ebp
   145a3:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   145a6:	83 ec 0c             	sub    $0xc,%esp
   145a9:	ff 75 08             	pushl  0x8(%ebp)
   145ac:	e8 59 f6 ff ff       	call   13c0a <_DecodeLength>
   145b1:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   145b4:	8b 45 08             	mov    0x8(%ebp),%eax
   145b7:	8b 00                	mov    (%eax),%eax
   145b9:	85 c0                	test   %eax,%eax
   145bb:	75 4a                	jne    14607 <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   145bd:	8b 45 08             	mov    0x8(%ebp),%eax
   145c0:	8b 40 0c             	mov    0xc(%eax),%eax
   145c3:	83 f8 01             	cmp    $0x1,%eax
   145c6:	7f 0b                	jg     145d3 <_DecodeDRI+0x33>
   145c8:	8b 45 08             	mov    0x8(%ebp),%eax
   145cb:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   145d1:	eb 35                	jmp    14608 <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   145d3:	8b 45 08             	mov    0x8(%ebp),%eax
   145d6:	8b 40 04             	mov    0x4(%eax),%eax
   145d9:	83 ec 0c             	sub    $0xc,%esp
   145dc:	50                   	push   %eax
   145dd:	e8 8b f6 ff ff       	call   13c6d <_Decode2Bytes>
   145e2:	83 c4 10             	add    $0x10,%esp
   145e5:	89 c2                	mov    %eax,%edx
   145e7:	8b 45 08             	mov    0x8(%ebp),%eax
   145ea:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   145f0:	8b 45 08             	mov    0x8(%ebp),%eax
   145f3:	8b 40 0c             	mov    0xc(%eax),%eax
   145f6:	83 ec 08             	sub    $0x8,%esp
   145f9:	50                   	push   %eax
   145fa:	ff 75 08             	pushl  0x8(%ebp)
   145fd:	e8 bc f5 ff ff       	call   13bbe <_Skip>
   14602:	83 c4 10             	add    $0x10,%esp
   14605:	eb 01                	jmp    14608 <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   14607:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   14608:	c9                   	leave  
   14609:	c3                   	ret    

0001460a <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   1460a:	55                   	push   %ebp
   1460b:	89 e5                	mov    %esp,%ebp
   1460d:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   14610:	8b 45 08             	mov    0x8(%ebp),%eax
   14613:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14619:	89 45 e0             	mov    %eax,-0x20(%ebp)
   1461c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   14623:	83 ec 0c             	sub    $0xc,%esp
   14626:	ff 75 08             	pushl  0x8(%ebp)
   14629:	e8 dc f5 ff ff       	call   13c0a <_DecodeLength>
   1462e:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14631:	8b 45 08             	mov    0x8(%ebp),%eax
   14634:	8b 00                	mov    (%eax),%eax
   14636:	85 c0                	test   %eax,%eax
   14638:	0f 85 c2 02 00 00    	jne    14900 <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   1463e:	8b 45 08             	mov    0x8(%ebp),%eax
   14641:	8b 50 0c             	mov    0xc(%eax),%edx
   14644:	8b 45 08             	mov    0x8(%ebp),%eax
   14647:	8b 40 28             	mov    0x28(%eax),%eax
   1464a:	83 c0 02             	add    $0x2,%eax
   1464d:	01 c0                	add    %eax,%eax
   1464f:	39 c2                	cmp    %eax,%edx
   14651:	7c 16                	jl     14669 <_DecodeSOS+0x5f>
   14653:	8b 45 08             	mov    0x8(%ebp),%eax
   14656:	8b 40 04             	mov    0x4(%eax),%eax
   14659:	0f b6 00             	movzbl (%eax),%eax
   1465c:	0f b6 d0             	movzbl %al,%edx
   1465f:	8b 45 08             	mov    0x8(%ebp),%eax
   14662:	8b 40 28             	mov    0x28(%eax),%eax
   14665:	39 c2                	cmp    %eax,%edx
   14667:	74 0e                	je     14677 <_DecodeSOS+0x6d>
   14669:	8b 45 08             	mov    0x8(%ebp),%eax
   1466c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14672:	e9 8d 02 00 00       	jmp    14904 <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   14677:	83 ec 08             	sub    $0x8,%esp
   1467a:	6a 01                	push   $0x1
   1467c:	ff 75 08             	pushl  0x8(%ebp)
   1467f:	e8 3a f5 ff ff       	call   13bbe <_Skip>
   14684:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14687:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1468e:	8b 45 08             	mov    0x8(%ebp),%eax
   14691:	83 c0 2c             	add    $0x2c,%eax
   14694:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14697:	e9 ba 00 00 00       	jmp    14756 <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   1469c:	8b 45 08             	mov    0x8(%ebp),%eax
   1469f:	8b 40 04             	mov    0x4(%eax),%eax
   146a2:	0f b6 00             	movzbl (%eax),%eax
   146a5:	0f b6 d0             	movzbl %al,%edx
   146a8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   146ab:	8b 00                	mov    (%eax),%eax
   146ad:	39 c2                	cmp    %eax,%edx
   146af:	74 0e                	je     146bf <_DecodeSOS+0xb5>
   146b1:	8b 45 08             	mov    0x8(%ebp),%eax
   146b4:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146ba:	e9 45 02 00 00       	jmp    14904 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   146bf:	8b 45 08             	mov    0x8(%ebp),%eax
   146c2:	8b 40 04             	mov    0x4(%eax),%eax
   146c5:	83 c0 01             	add    $0x1,%eax
   146c8:	0f b6 00             	movzbl (%eax),%eax
   146cb:	0f b6 c0             	movzbl %al,%eax
   146ce:	25 ec 00 00 00       	and    $0xec,%eax
   146d3:	85 c0                	test   %eax,%eax
   146d5:	74 0e                	je     146e5 <_DecodeSOS+0xdb>
   146d7:	8b 45 08             	mov    0x8(%ebp),%eax
   146da:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146e0:	e9 1f 02 00 00       	jmp    14904 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   146e5:	8b 45 08             	mov    0x8(%ebp),%eax
   146e8:	8b 40 04             	mov    0x4(%eax),%eax
   146eb:	83 c0 01             	add    $0x1,%eax
   146ee:	0f b6 00             	movzbl (%eax),%eax
   146f1:	0f b6 c0             	movzbl %al,%eax
   146f4:	83 e0 02             	and    $0x2,%eax
   146f7:	85 c0                	test   %eax,%eax
   146f9:	74 0e                	je     14709 <_DecodeSOS+0xff>
   146fb:	8b 45 08             	mov    0x8(%ebp),%eax
   146fe:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14704:	e9 fb 01 00 00       	jmp    14904 <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   14709:	8b 45 08             	mov    0x8(%ebp),%eax
   1470c:	8b 40 04             	mov    0x4(%eax),%eax
   1470f:	83 c0 01             	add    $0x1,%eax
   14712:	0f b6 00             	movzbl (%eax),%eax
   14715:	c0 e8 04             	shr    $0x4,%al
   14718:	0f b6 d0             	movzbl %al,%edx
   1471b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1471e:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   14721:	8b 45 08             	mov    0x8(%ebp),%eax
   14724:	8b 40 04             	mov    0x4(%eax),%eax
   14727:	83 c0 01             	add    $0x1,%eax
   1472a:	0f b6 00             	movzbl (%eax),%eax
   1472d:	0f b6 c0             	movzbl %al,%eax
   14730:	83 e0 01             	and    $0x1,%eax
   14733:	83 c8 02             	or     $0x2,%eax
   14736:	89 c2                	mov    %eax,%edx
   14738:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1473b:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   1473e:	83 ec 08             	sub    $0x8,%esp
   14741:	6a 02                	push   $0x2
   14743:	ff 75 08             	pushl  0x8(%ebp)
   14746:	e8 73 f4 ff ff       	call   13bbe <_Skip>
   1474b:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1474e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14752:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14756:	8b 45 08             	mov    0x8(%ebp),%eax
   14759:	8b 40 28             	mov    0x28(%eax),%eax
   1475c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1475f:	0f 8f 37 ff ff ff    	jg     1469c <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   14765:	8b 45 08             	mov    0x8(%ebp),%eax
   14768:	8b 40 04             	mov    0x4(%eax),%eax
   1476b:	0f b6 00             	movzbl (%eax),%eax
   1476e:	84 c0                	test   %al,%al
   14770:	75 10                	jne    14782 <_DecodeSOS+0x178>
   14772:	8b 45 08             	mov    0x8(%ebp),%eax
   14775:	8b 40 04             	mov    0x4(%eax),%eax
   14778:	83 c0 01             	add    $0x1,%eax
   1477b:	0f b6 00             	movzbl (%eax),%eax
   1477e:	3c 3f                	cmp    $0x3f,%al
   14780:	74 0e                	je     14790 <_DecodeSOS+0x186>
   14782:	8b 45 08             	mov    0x8(%ebp),%eax
   14785:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1478b:	e9 74 01 00 00       	jmp    14904 <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   14790:	8b 45 08             	mov    0x8(%ebp),%eax
   14793:	8b 40 04             	mov    0x4(%eax),%eax
   14796:	83 c0 02             	add    $0x2,%eax
   14799:	0f b6 00             	movzbl (%eax),%eax
   1479c:	84 c0                	test   %al,%al
   1479e:	74 0e                	je     147ae <_DecodeSOS+0x1a4>
   147a0:	8b 45 08             	mov    0x8(%ebp),%eax
   147a3:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   147a9:	e9 56 01 00 00       	jmp    14904 <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   147ae:	8b 45 08             	mov    0x8(%ebp),%eax
   147b1:	8b 40 0c             	mov    0xc(%eax),%eax
   147b4:	83 ec 08             	sub    $0x8,%esp
   147b7:	50                   	push   %eax
   147b8:	ff 75 08             	pushl  0x8(%ebp)
   147bb:	e8 fe f3 ff ff       	call   13bbe <_Skip>
   147c0:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   147c3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   147ca:	e9 17 01 00 00       	jmp    148e6 <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   147cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   147d6:	e9 f8 00 00 00       	jmp    148d3 <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   147db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   147e2:	8b 45 08             	mov    0x8(%ebp),%eax
   147e5:	83 c0 2c             	add    $0x2c,%eax
   147e8:	89 45 dc             	mov    %eax,-0x24(%ebp)
   147eb:	e9 8d 00 00 00       	jmp    1487d <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   147f0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   147f7:	eb 71                	jmp    1486a <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   147f9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   14800:	eb 59                	jmp    1485b <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   14802:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14805:	8b 50 28             	mov    0x28(%eax),%edx
   14808:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1480b:	8b 40 08             	mov    0x8(%eax),%eax
   1480e:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   14812:	89 c1                	mov    %eax,%ecx
   14814:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14817:	01 c1                	add    %eax,%ecx
   14819:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1481c:	8b 40 14             	mov    0x14(%eax),%eax
   1481f:	0f af c8             	imul   %eax,%ecx
   14822:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14825:	8b 40 04             	mov    0x4(%eax),%eax
   14828:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   1482c:	01 c1                	add    %eax,%ecx
   1482e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14831:	01 c8                	add    %ecx,%eax
   14833:	c1 e0 03             	shl    $0x3,%eax
   14836:	01 d0                	add    %edx,%eax
   14838:	50                   	push   %eax
   14839:	ff 75 dc             	pushl  -0x24(%ebp)
   1483c:	ff 75 0c             	pushl  0xc(%ebp)
   1483f:	ff 75 08             	pushl  0x8(%ebp)
   14842:	e8 bf 00 00 00       	call   14906 <_DecodeBlock>
   14847:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   1484a:	8b 45 08             	mov    0x8(%ebp),%eax
   1484d:	8b 00                	mov    (%eax),%eax
   1484f:	85 c0                	test   %eax,%eax
   14851:	0f 85 ac 00 00 00    	jne    14903 <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14857:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   1485b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1485e:	8b 40 04             	mov    0x4(%eax),%eax
   14861:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   14864:	7f 9c                	jg     14802 <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   14866:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1486a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1486d:	8b 40 08             	mov    0x8(%eax),%eax
   14870:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   14873:	7f 84                	jg     147f9 <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14875:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14879:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   1487d:	8b 45 08             	mov    0x8(%ebp),%eax
   14880:	8b 40 28             	mov    0x28(%eax),%eax
   14883:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14886:	0f 8f 64 ff ff ff    	jg     147f0 <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   1488c:	8b 45 08             	mov    0x8(%ebp),%eax
   1488f:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14895:	85 c0                	test   %eax,%eax
   14897:	74 36                	je     148cf <_DecodeSOS+0x2c5>
   14899:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   1489d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   148a1:	75 2c                	jne    148cf <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   148a3:	83 ec 0c             	sub    $0xc,%esp
   148a6:	ff 75 08             	pushl  0x8(%ebp)
   148a9:	e8 9f 0a 00 00       	call   1534d <_ByteAlign>
   148ae:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   148b1:	83 ec 08             	sub    $0x8,%esp
   148b4:	6a 10                	push   $0x10
   148b6:	ff 75 08             	pushl  0x8(%ebp)
   148b9:	e8 ce 04 00 00       	call   14d8c <_GetBits>
   148be:	83 c4 10             	add    $0x10,%esp
   148c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   148c4:	8b 45 08             	mov    0x8(%ebp),%eax
   148c7:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   148cd:	eb 35                	jmp    14904 <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   148cf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   148d3:	8b 45 08             	mov    0x8(%ebp),%eax
   148d6:	8b 40 18             	mov    0x18(%eax),%eax
   148d9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   148dc:	0f 8f f9 fe ff ff    	jg     147db <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   148e2:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   148e6:	8b 45 08             	mov    0x8(%ebp),%eax
   148e9:	8b 40 1c             	mov    0x1c(%eax),%eax
   148ec:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   148ef:	0f 8f da fe ff ff    	jg     147cf <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   148f5:	8b 45 08             	mov    0x8(%ebp),%eax
   148f8:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   148fe:	eb 04                	jmp    14904 <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   14900:	90                   	nop
   14901:	eb 01                	jmp    14904 <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   14903:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   14904:	c9                   	leave  
   14905:	c3                   	ret    

00014906 <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   14906:	55                   	push   %ebp
   14907:	89 e5                	mov    %esp,%ebp
   14909:	53                   	push   %ebx
   1490a:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   1490d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   14914:	8b 45 08             	mov    0x8(%ebp),%eax
   14917:	05 c0 01 08 00       	add    $0x801c0,%eax
   1491c:	83 ec 04             	sub    $0x4,%esp
   1491f:	68 00 01 00 00       	push   $0x100
   14924:	6a 00                	push   $0x0
   14926:	50                   	push   %eax
   14927:	e8 04 b8 fe ff       	call   130 <memset>
   1492c:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   1492f:	8b 45 10             	mov    0x10(%ebp),%eax
   14932:	8b 40 20             	mov    0x20(%eax),%eax
   14935:	c1 e0 11             	shl    $0x11,%eax
   14938:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   1493e:	8b 45 08             	mov    0x8(%ebp),%eax
   14941:	01 d0                	add    %edx,%eax
   14943:	83 c0 08             	add    $0x8,%eax
   14946:	83 ec 04             	sub    $0x4,%esp
   14949:	6a 00                	push   $0x0
   1494b:	50                   	push   %eax
   1494c:	ff 75 08             	pushl  0x8(%ebp)
   1494f:	e8 86 01 00 00       	call   14ada <_GetVLC>
   14954:	83 c4 10             	add    $0x10,%esp
   14957:	89 c2                	mov    %eax,%edx
   14959:	8b 45 10             	mov    0x10(%ebp),%eax
   1495c:	8b 40 24             	mov    0x24(%eax),%eax
   1495f:	01 c2                	add    %eax,%edx
   14961:	8b 45 10             	mov    0x10(%ebp),%eax
   14964:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   14967:	8b 45 10             	mov    0x10(%ebp),%eax
   1496a:	8b 50 24             	mov    0x24(%eax),%edx
   1496d:	8b 45 10             	mov    0x10(%ebp),%eax
   14970:	8b 48 18             	mov    0x18(%eax),%ecx
   14973:	8b 45 08             	mov    0x8(%ebp),%eax
   14976:	c1 e1 06             	shl    $0x6,%ecx
   14979:	01 c8                	add    %ecx,%eax
   1497b:	05 b8 00 00 00       	add    $0xb8,%eax
   14980:	0f b6 00             	movzbl (%eax),%eax
   14983:	0f b6 c0             	movzbl %al,%eax
   14986:	0f af d0             	imul   %eax,%edx
   14989:	8b 45 08             	mov    0x8(%ebp),%eax
   1498c:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   14992:	8b 45 10             	mov    0x10(%ebp),%eax
   14995:	8b 40 1c             	mov    0x1c(%eax),%eax
   14998:	c1 e0 11             	shl    $0x11,%eax
   1499b:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   149a1:	8b 45 08             	mov    0x8(%ebp),%eax
   149a4:	01 d0                	add    %edx,%eax
   149a6:	8d 50 08             	lea    0x8(%eax),%edx
   149a9:	83 ec 04             	sub    $0x4,%esp
   149ac:	8d 45 ef             	lea    -0x11(%ebp),%eax
   149af:	50                   	push   %eax
   149b0:	52                   	push   %edx
   149b1:	ff 75 08             	pushl  0x8(%ebp)
   149b4:	e8 21 01 00 00       	call   14ada <_GetVLC>
   149b9:	83 c4 10             	add    $0x10,%esp
   149bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   149bf:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149c3:	84 c0                	test   %al,%al
   149c5:	0f 84 92 00 00 00    	je     14a5d <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   149cb:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149cf:	0f b6 c0             	movzbl %al,%eax
   149d2:	83 e0 0f             	and    $0xf,%eax
   149d5:	85 c0                	test   %eax,%eax
   149d7:	75 16                	jne    149ef <_DecodeBlock+0xe9>
   149d9:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149dd:	3c f0                	cmp    $0xf0,%al
   149df:	74 0e                	je     149ef <_DecodeBlock+0xe9>
   149e1:	8b 45 08             	mov    0x8(%ebp),%eax
   149e4:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   149ea:	e9 e6 00 00 00       	jmp    14ad5 <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   149ef:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   149f3:	c0 e8 04             	shr    $0x4,%al
   149f6:	0f b6 c0             	movzbl %al,%eax
   149f9:	83 c0 01             	add    $0x1,%eax
   149fc:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   149ff:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14a03:	7e 0e                	jle    14a13 <_DecodeBlock+0x10d>
   14a05:	8b 45 08             	mov    0x8(%ebp),%eax
   14a08:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a0e:	e9 c2 00 00 00       	jmp    14ad5 <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   14a13:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14a16:	8b 45 0c             	mov    0xc(%ebp),%eax
   14a19:	01 d0                	add    %edx,%eax
   14a1b:	0f b6 00             	movzbl (%eax),%eax
   14a1e:	0f be c8             	movsbl %al,%ecx
   14a21:	8b 45 10             	mov    0x10(%ebp),%eax
   14a24:	8b 50 18             	mov    0x18(%eax),%edx
   14a27:	8b 45 08             	mov    0x8(%ebp),%eax
   14a2a:	c1 e2 06             	shl    $0x6,%edx
   14a2d:	01 c2                	add    %eax,%edx
   14a2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a32:	01 d0                	add    %edx,%eax
   14a34:	05 b8 00 00 00       	add    $0xb8,%eax
   14a39:	0f b6 00             	movzbl (%eax),%eax
   14a3c:	0f b6 c0             	movzbl %al,%eax
   14a3f:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14a43:	89 c2                	mov    %eax,%edx
   14a45:	8b 45 08             	mov    0x8(%ebp),%eax
   14a48:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   14a4e:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   14a51:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   14a55:	0f 8e 37 ff ff ff    	jle    14992 <_DecodeBlock+0x8c>
   14a5b:	eb 01                	jmp    14a5e <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   14a5d:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   14a5e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14a65:	eb 24                	jmp    14a8b <_DecodeBlock+0x185>
   14a67:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14a6a:	05 70 00 02 00       	add    $0x20070,%eax
   14a6f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14a76:	8b 45 08             	mov    0x8(%ebp),%eax
   14a79:	01 d0                	add    %edx,%eax
   14a7b:	83 ec 0c             	sub    $0xc,%esp
   14a7e:	50                   	push   %eax
   14a7f:	e8 32 03 00 00       	call   14db6 <_RowIDCT>
   14a84:	83 c4 10             	add    $0x10,%esp
   14a87:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   14a8b:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14a8f:	7e d6                	jle    14a67 <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   14a91:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14a98:	eb 35                	jmp    14acf <_DecodeBlock+0x1c9>
   14a9a:	8b 45 10             	mov    0x10(%ebp),%eax
   14a9d:	8b 40 14             	mov    0x14(%eax),%eax
   14aa0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14aa3:	8b 55 14             	mov    0x14(%ebp),%edx
   14aa6:	01 d1                	add    %edx,%ecx
   14aa8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14aab:	81 c2 70 00 02 00    	add    $0x20070,%edx
   14ab1:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   14ab8:	8b 55 08             	mov    0x8(%ebp),%edx
   14abb:	01 da                	add    %ebx,%edx
   14abd:	83 ec 04             	sub    $0x4,%esp
   14ac0:	50                   	push   %eax
   14ac1:	51                   	push   %ecx
   14ac2:	52                   	push   %edx
   14ac3:	e8 7b 05 00 00       	call   15043 <_ColIDCT>
   14ac8:	83 c4 10             	add    $0x10,%esp
   14acb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14acf:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14ad3:	7e c5                	jle    14a9a <_DecodeBlock+0x194>
}
   14ad5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14ad8:	c9                   	leave  
   14ad9:	c3                   	ret    

00014ada <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   14ada:	55                   	push   %ebp
   14adb:	89 e5                	mov    %esp,%ebp
   14add:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   14ae0:	83 ec 08             	sub    $0x8,%esp
   14ae3:	6a 10                	push   $0x10
   14ae5:	ff 75 08             	pushl  0x8(%ebp)
   14ae8:	e8 c2 00 00 00       	call   14baf <_ShowBits>
   14aed:	83 c4 10             	add    $0x10,%esp
   14af0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   14af3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14af6:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14af9:	8b 45 0c             	mov    0xc(%ebp),%eax
   14afc:	01 d0                	add    %edx,%eax
   14afe:	0f b6 00             	movzbl (%eax),%eax
   14b01:	0f b6 c0             	movzbl %al,%eax
   14b04:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   14b07:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14b0b:	75 13                	jne    14b20 <_GetVLC+0x46>
   14b0d:	8b 45 08             	mov    0x8(%ebp),%eax
   14b10:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14b16:	b8 00 00 00 00       	mov    $0x0,%eax
   14b1b:	e9 8d 00 00 00       	jmp    14bad <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   14b20:	83 ec 08             	sub    $0x8,%esp
   14b23:	ff 75 f0             	pushl  -0x10(%ebp)
   14b26:	ff 75 08             	pushl  0x8(%ebp)
   14b29:	e8 25 02 00 00       	call   14d53 <_SkipBits>
   14b2e:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   14b31:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b34:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14b37:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b3a:	01 d0                	add    %edx,%eax
   14b3c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   14b40:	0f b6 c0             	movzbl %al,%eax
   14b43:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   14b46:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14b4a:	74 0a                	je     14b56 <_GetVLC+0x7c>
   14b4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b4f:	89 c2                	mov    %eax,%edx
   14b51:	8b 45 10             	mov    0x10(%ebp),%eax
   14b54:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   14b56:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b59:	83 e0 0f             	and    $0xf,%eax
   14b5c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   14b5f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14b63:	75 07                	jne    14b6c <_GetVLC+0x92>
   14b65:	b8 00 00 00 00       	mov    $0x0,%eax
   14b6a:	eb 41                	jmp    14bad <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   14b6c:	83 ec 08             	sub    $0x8,%esp
   14b6f:	ff 75 f0             	pushl  -0x10(%ebp)
   14b72:	ff 75 08             	pushl  0x8(%ebp)
   14b75:	e8 12 02 00 00       	call   14d8c <_GetBits>
   14b7a:	83 c4 10             	add    $0x10,%esp
   14b7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   14b80:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14b83:	83 e8 01             	sub    $0x1,%eax
   14b86:	ba 01 00 00 00       	mov    $0x1,%edx
   14b8b:	89 c1                	mov    %eax,%ecx
   14b8d:	d3 e2                	shl    %cl,%edx
   14b8f:	89 d0                	mov    %edx,%eax
   14b91:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14b94:	7e 14                	jle    14baa <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   14b96:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14b99:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   14b9e:	89 c1                	mov    %eax,%ecx
   14ba0:	d3 e2                	shl    %cl,%edx
   14ba2:	89 d0                	mov    %edx,%eax
   14ba4:	83 c0 01             	add    $0x1,%eax
   14ba7:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   14baa:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14bad:	c9                   	leave  
   14bae:	c3                   	ret    

00014baf <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   14baf:	55                   	push   %ebp
   14bb0:	89 e5                	mov    %esp,%ebp
   14bb2:	53                   	push   %ebx
   14bb3:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   14bb6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14bba:	0f 85 4f 01 00 00    	jne    14d0f <_ShowBits+0x160>
   14bc0:	b8 00 00 00 00       	mov    $0x0,%eax
   14bc5:	e9 83 01 00 00       	jmp    14d4d <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   14bca:	8b 45 08             	mov    0x8(%ebp),%eax
   14bcd:	8b 40 08             	mov    0x8(%eax),%eax
   14bd0:	85 c0                	test   %eax,%eax
   14bd2:	7f 33                	jg     14c07 <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   14bd4:	8b 45 08             	mov    0x8(%ebp),%eax
   14bd7:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14bdd:	c1 e0 08             	shl    $0x8,%eax
   14be0:	0c ff                	or     $0xff,%al
   14be2:	89 c2                	mov    %eax,%edx
   14be4:	8b 45 08             	mov    0x8(%ebp),%eax
   14be7:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   14bed:	8b 45 08             	mov    0x8(%ebp),%eax
   14bf0:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14bf6:	8d 50 08             	lea    0x8(%eax),%edx
   14bf9:	8b 45 08             	mov    0x8(%ebp),%eax
   14bfc:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   14c02:	e9 08 01 00 00       	jmp    14d0f <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   14c07:	8b 45 08             	mov    0x8(%ebp),%eax
   14c0a:	8b 40 04             	mov    0x4(%eax),%eax
   14c0d:	8d 48 01             	lea    0x1(%eax),%ecx
   14c10:	8b 55 08             	mov    0x8(%ebp),%edx
   14c13:	89 4a 04             	mov    %ecx,0x4(%edx)
   14c16:	0f b6 00             	movzbl (%eax),%eax
   14c19:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   14c1c:	8b 45 08             	mov    0x8(%ebp),%eax
   14c1f:	8b 40 08             	mov    0x8(%eax),%eax
   14c22:	8d 50 ff             	lea    -0x1(%eax),%edx
   14c25:	8b 45 08             	mov    0x8(%ebp),%eax
   14c28:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   14c2b:	8b 45 08             	mov    0x8(%ebp),%eax
   14c2e:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14c34:	8d 50 08             	lea    0x8(%eax),%edx
   14c37:	8b 45 08             	mov    0x8(%ebp),%eax
   14c3a:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   14c40:	8b 45 08             	mov    0x8(%ebp),%eax
   14c43:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14c49:	c1 e0 08             	shl    $0x8,%eax
   14c4c:	89 c2                	mov    %eax,%edx
   14c4e:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   14c52:	09 c2                	or     %eax,%edx
   14c54:	8b 45 08             	mov    0x8(%ebp),%eax
   14c57:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   14c5d:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   14c61:	0f 85 a8 00 00 00    	jne    14d0f <_ShowBits+0x160>
            if(ctx->size){
   14c67:	8b 45 08             	mov    0x8(%ebp),%eax
   14c6a:	8b 40 08             	mov    0x8(%eax),%eax
   14c6d:	85 c0                	test   %eax,%eax
   14c6f:	0f 84 91 00 00 00    	je     14d06 <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   14c75:	8b 45 08             	mov    0x8(%ebp),%eax
   14c78:	8b 40 04             	mov    0x4(%eax),%eax
   14c7b:	8d 48 01             	lea    0x1(%eax),%ecx
   14c7e:	8b 55 08             	mov    0x8(%ebp),%edx
   14c81:	89 4a 04             	mov    %ecx,0x4(%edx)
   14c84:	0f b6 00             	movzbl (%eax),%eax
   14c87:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   14c8a:	8b 45 08             	mov    0x8(%ebp),%eax
   14c8d:	8b 40 08             	mov    0x8(%eax),%eax
   14c90:	8d 50 ff             	lea    -0x1(%eax),%edx
   14c93:	8b 45 08             	mov    0x8(%ebp),%eax
   14c96:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   14c99:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14c9d:	85 c0                	test   %eax,%eax
   14c9f:	74 62                	je     14d03 <_ShowBits+0x154>
   14ca1:	3d d9 00 00 00       	cmp    $0xd9,%eax
   14ca6:	75 0c                	jne    14cb4 <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   14ca8:	8b 45 08             	mov    0x8(%ebp),%eax
   14cab:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   14cb2:	eb 5b                	jmp    14d0f <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   14cb4:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14cb8:	25 f8 00 00 00       	and    $0xf8,%eax
   14cbd:	3d d0 00 00 00       	cmp    $0xd0,%eax
   14cc2:	74 0b                	je     14ccf <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   14cc4:	8b 45 08             	mov    0x8(%ebp),%eax
   14cc7:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14ccd:	eb 40                	jmp    14d0f <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   14ccf:	8b 45 08             	mov    0x8(%ebp),%eax
   14cd2:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14cd8:	c1 e0 08             	shl    $0x8,%eax
   14cdb:	89 c2                	mov    %eax,%edx
   14cdd:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14ce1:	09 c2                	or     %eax,%edx
   14ce3:	8b 45 08             	mov    0x8(%ebp),%eax
   14ce6:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   14cec:	8b 45 08             	mov    0x8(%ebp),%eax
   14cef:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14cf5:	8d 50 08             	lea    0x8(%eax),%edx
   14cf8:	8b 45 08             	mov    0x8(%ebp),%eax
   14cfb:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   14d01:	eb 0c                	jmp    14d0f <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   14d03:	90                   	nop
   14d04:	eb 09                	jmp    14d0f <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   14d06:	8b 45 08             	mov    0x8(%ebp),%eax
   14d09:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   14d0f:	8b 45 08             	mov    0x8(%ebp),%eax
   14d12:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d18:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14d1b:	0f 8c a9 fe ff ff    	jl     14bca <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   14d21:	8b 45 08             	mov    0x8(%ebp),%eax
   14d24:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   14d2a:	8b 45 08             	mov    0x8(%ebp),%eax
   14d2d:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d33:	2b 45 0c             	sub    0xc(%ebp),%eax
   14d36:	89 c1                	mov    %eax,%ecx
   14d38:	d3 fa                	sar    %cl,%edx
   14d3a:	8b 45 0c             	mov    0xc(%ebp),%eax
   14d3d:	bb 01 00 00 00       	mov    $0x1,%ebx
   14d42:	89 c1                	mov    %eax,%ecx
   14d44:	d3 e3                	shl    %cl,%ebx
   14d46:	89 d8                	mov    %ebx,%eax
   14d48:	83 e8 01             	sub    $0x1,%eax
   14d4b:	21 d0                	and    %edx,%eax
}
   14d4d:	83 c4 10             	add    $0x10,%esp
   14d50:	5b                   	pop    %ebx
   14d51:	5d                   	pop    %ebp
   14d52:	c3                   	ret    

00014d53 <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   14d53:	55                   	push   %ebp
   14d54:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   14d56:	8b 45 08             	mov    0x8(%ebp),%eax
   14d59:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d5f:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14d62:	7d 0e                	jge    14d72 <_SkipBits+0x1f>
   14d64:	ff 75 0c             	pushl  0xc(%ebp)
   14d67:	ff 75 08             	pushl  0x8(%ebp)
   14d6a:	e8 40 fe ff ff       	call   14baf <_ShowBits>
   14d6f:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   14d72:	8b 45 08             	mov    0x8(%ebp),%eax
   14d75:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d7b:	2b 45 0c             	sub    0xc(%ebp),%eax
   14d7e:	89 c2                	mov    %eax,%edx
   14d80:	8b 45 08             	mov    0x8(%ebp),%eax
   14d83:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   14d89:	90                   	nop
   14d8a:	c9                   	leave  
   14d8b:	c3                   	ret    

00014d8c <_GetBits>:

int _GetBits(Context* ctx, int bits){
   14d8c:	55                   	push   %ebp
   14d8d:	89 e5                	mov    %esp,%ebp
   14d8f:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   14d92:	ff 75 0c             	pushl  0xc(%ebp)
   14d95:	ff 75 08             	pushl  0x8(%ebp)
   14d98:	e8 12 fe ff ff       	call   14baf <_ShowBits>
   14d9d:	83 c4 08             	add    $0x8,%esp
   14da0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   14da3:	ff 75 0c             	pushl  0xc(%ebp)
   14da6:	ff 75 08             	pushl  0x8(%ebp)
   14da9:	e8 a5 ff ff ff       	call   14d53 <_SkipBits>
   14dae:	83 c4 08             	add    $0x8,%esp
    return res;
   14db1:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   14db4:	c9                   	leave  
   14db5:	c3                   	ret    

00014db6 <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   14db6:	55                   	push   %ebp
   14db7:	89 e5                	mov    %esp,%ebp
   14db9:	57                   	push   %edi
   14dba:	56                   	push   %esi
   14dbb:	53                   	push   %ebx
   14dbc:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14dbf:	8b 45 08             	mov    0x8(%ebp),%eax
   14dc2:	83 c0 10             	add    $0x10,%eax
   14dc5:	8b 00                	mov    (%eax),%eax
   14dc7:	c1 e0 0b             	shl    $0xb,%eax
   14dca:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   14dcd:	8b 45 08             	mov    0x8(%ebp),%eax
   14dd0:	8b 40 18             	mov    0x18(%eax),%eax
   14dd3:	89 45 ec             	mov    %eax,-0x14(%ebp)
   14dd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14dd9:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   14ddc:	8b 55 08             	mov    0x8(%ebp),%edx
   14ddf:	8b 52 08             	mov    0x8(%edx),%edx
   14de2:	89 55 e8             	mov    %edx,-0x18(%ebp)
   14de5:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   14de8:	8b 55 08             	mov    0x8(%ebp),%edx
   14deb:	8b 52 04             	mov    0x4(%edx),%edx
   14dee:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   14df1:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   14df4:	8b 55 08             	mov    0x8(%ebp),%edx
   14df7:	8b 52 1c             	mov    0x1c(%edx),%edx
   14dfa:	89 55 e0             	mov    %edx,-0x20(%ebp)
   14dfd:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   14e00:	8b 55 08             	mov    0x8(%ebp),%edx
   14e03:	8b 52 14             	mov    0x14(%edx),%edx
   14e06:	89 55 dc             	mov    %edx,-0x24(%ebp)
   14e09:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   14e0c:	8b 55 08             	mov    0x8(%ebp),%edx
   14e0f:	8b 52 0c             	mov    0xc(%edx),%edx
   14e12:	89 55 d8             	mov    %edx,-0x28(%ebp)
   14e15:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14e18:	85 c0                	test   %eax,%eax
   14e1a:	75 68                	jne    14e84 <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   14e1c:	8b 45 08             	mov    0x8(%ebp),%eax
   14e1f:	8d 48 04             	lea    0x4(%eax),%ecx
   14e22:	8b 45 08             	mov    0x8(%ebp),%eax
   14e25:	8d 58 08             	lea    0x8(%eax),%ebx
   14e28:	8b 45 08             	mov    0x8(%ebp),%eax
   14e2b:	8d 70 0c             	lea    0xc(%eax),%esi
   14e2e:	8b 45 08             	mov    0x8(%ebp),%eax
   14e31:	8d 78 10             	lea    0x10(%eax),%edi
   14e34:	8b 45 08             	mov    0x8(%ebp),%eax
   14e37:	83 c0 14             	add    $0x14,%eax
   14e3a:	89 45 c0             	mov    %eax,-0x40(%ebp)
   14e3d:	8b 45 08             	mov    0x8(%ebp),%eax
   14e40:	83 c0 18             	add    $0x18,%eax
   14e43:	89 45 bc             	mov    %eax,-0x44(%ebp)
   14e46:	8b 45 08             	mov    0x8(%ebp),%eax
   14e49:	8d 50 1c             	lea    0x1c(%eax),%edx
   14e4c:	8b 45 08             	mov    0x8(%ebp),%eax
   14e4f:	8b 00                	mov    (%eax),%eax
   14e51:	c1 e0 03             	shl    $0x3,%eax
   14e54:	89 02                	mov    %eax,(%edx)
   14e56:	8b 02                	mov    (%edx),%eax
   14e58:	8b 55 bc             	mov    -0x44(%ebp),%edx
   14e5b:	89 02                	mov    %eax,(%edx)
   14e5d:	89 d0                	mov    %edx,%eax
   14e5f:	8b 00                	mov    (%eax),%eax
   14e61:	8b 55 c0             	mov    -0x40(%ebp),%edx
   14e64:	89 02                	mov    %eax,(%edx)
   14e66:	89 d0                	mov    %edx,%eax
   14e68:	8b 00                	mov    (%eax),%eax
   14e6a:	89 07                	mov    %eax,(%edi)
   14e6c:	8b 07                	mov    (%edi),%eax
   14e6e:	89 06                	mov    %eax,(%esi)
   14e70:	8b 06                	mov    (%esi),%eax
   14e72:	89 03                	mov    %eax,(%ebx)
   14e74:	8b 03                	mov    (%ebx),%eax
   14e76:	89 01                	mov    %eax,(%ecx)
   14e78:	8b 11                	mov    (%ecx),%edx
   14e7a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e7d:	89 10                	mov    %edx,(%eax)
        return;
   14e7f:	e9 b7 01 00 00       	jmp    1503b <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   14e84:	8b 45 08             	mov    0x8(%ebp),%eax
   14e87:	8b 00                	mov    (%eax),%eax
   14e89:	c1 e0 0b             	shl    $0xb,%eax
   14e8c:	83 e8 80             	sub    $0xffffff80,%eax
   14e8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   14e92:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14e95:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14e98:	01 d0                	add    %edx,%eax
   14e9a:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   14ea0:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   14ea3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14ea6:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   14eac:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14eaf:	01 d0                	add    %edx,%eax
   14eb1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   14eb4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14eb7:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   14ebd:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14ec0:	01 d0                	add    %edx,%eax
   14ec2:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   14ec5:	8b 55 dc             	mov    -0x24(%ebp),%edx
   14ec8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14ecb:	01 d0                	add    %edx,%eax
   14ecd:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   14ed3:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   14ed6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14ed9:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   14edf:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14ee2:	01 d0                	add    %edx,%eax
   14ee4:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   14ee7:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14eea:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   14ef0:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14ef3:	01 d0                	add    %edx,%eax
   14ef5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   14ef8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   14efb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14efe:	01 d0                	add    %edx,%eax
   14f00:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   14f03:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f06:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   14f09:	8b 55 e8             	mov    -0x18(%ebp),%edx
   14f0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f0f:	01 d0                	add    %edx,%eax
   14f11:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   14f17:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   14f1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f1d:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   14f23:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f26:	01 d0                	add    %edx,%eax
   14f28:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   14f2b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f2e:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   14f34:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f37:	01 d0                	add    %edx,%eax
   14f39:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   14f3c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14f3f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f42:	01 d0                	add    %edx,%eax
   14f44:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   14f47:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14f4a:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   14f4d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   14f50:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f53:	01 d0                	add    %edx,%eax
   14f55:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   14f58:	8b 45 d8             	mov    -0x28(%ebp),%eax
   14f5b:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   14f5e:	8b 55 d0             	mov    -0x30(%ebp),%edx
   14f61:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f64:	01 d0                	add    %edx,%eax
   14f66:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   14f69:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14f6c:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   14f6f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   14f72:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f75:	01 d0                	add    %edx,%eax
   14f77:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   14f7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14f7d:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   14f80:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14f83:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14f86:	01 d0                	add    %edx,%eax
   14f88:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   14f8e:	83 e8 80             	sub    $0xffffff80,%eax
   14f91:	c1 f8 08             	sar    $0x8,%eax
   14f94:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   14f97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14f9a:	2b 45 e0             	sub    -0x20(%ebp),%eax
   14f9d:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   14fa3:	83 e8 80             	sub    $0xffffff80,%eax
   14fa6:	c1 f8 08             	sar    $0x8,%eax
   14fa9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   14fac:	8b 55 d8             	mov    -0x28(%ebp),%edx
   14faf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14fb2:	01 d0                	add    %edx,%eax
   14fb4:	c1 f8 08             	sar    $0x8,%eax
   14fb7:	89 c2                	mov    %eax,%edx
   14fb9:	8b 45 08             	mov    0x8(%ebp),%eax
   14fbc:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   14fbe:	8b 45 08             	mov    0x8(%ebp),%eax
   14fc1:	83 c0 04             	add    $0x4,%eax
   14fc4:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   14fc7:	8b 55 ec             	mov    -0x14(%ebp),%edx
   14fca:	01 ca                	add    %ecx,%edx
   14fcc:	c1 fa 08             	sar    $0x8,%edx
   14fcf:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   14fd1:	8b 45 08             	mov    0x8(%ebp),%eax
   14fd4:	83 c0 08             	add    $0x8,%eax
   14fd7:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   14fda:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14fdd:	01 ca                	add    %ecx,%edx
   14fdf:	c1 fa 08             	sar    $0x8,%edx
   14fe2:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   14fe4:	8b 45 08             	mov    0x8(%ebp),%eax
   14fe7:	83 c0 0c             	add    $0xc,%eax
   14fea:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   14fed:	8b 55 dc             	mov    -0x24(%ebp),%edx
   14ff0:	01 ca                	add    %ecx,%edx
   14ff2:	c1 fa 08             	sar    $0x8,%edx
   14ff5:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   14ff7:	8b 45 08             	mov    0x8(%ebp),%eax
   14ffa:	8d 50 10             	lea    0x10(%eax),%edx
   14ffd:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15000:	2b 45 dc             	sub    -0x24(%ebp),%eax
   15003:	c1 f8 08             	sar    $0x8,%eax
   15006:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   15008:	8b 45 08             	mov    0x8(%ebp),%eax
   1500b:	8d 50 14             	lea    0x14(%eax),%edx
   1500e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   15011:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   15014:	c1 f8 08             	sar    $0x8,%eax
   15017:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   15019:	8b 45 08             	mov    0x8(%ebp),%eax
   1501c:	8d 50 18             	lea    0x18(%eax),%edx
   1501f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15022:	2b 45 ec             	sub    -0x14(%ebp),%eax
   15025:	c1 f8 08             	sar    $0x8,%eax
   15028:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   1502a:	8b 45 08             	mov    0x8(%ebp),%eax
   1502d:	8d 50 1c             	lea    0x1c(%eax),%edx
   15030:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15033:	2b 45 f0             	sub    -0x10(%ebp),%eax
   15036:	c1 f8 08             	sar    $0x8,%eax
   15039:	89 02                	mov    %eax,(%edx)
}
   1503b:	83 c4 38             	add    $0x38,%esp
   1503e:	5b                   	pop    %ebx
   1503f:	5e                   	pop    %esi
   15040:	5f                   	pop    %edi
   15041:	5d                   	pop    %ebp
   15042:	c3                   	ret    

00015043 <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   15043:	55                   	push   %ebp
   15044:	89 e5                	mov    %esp,%ebp
   15046:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   15049:	8b 45 08             	mov    0x8(%ebp),%eax
   1504c:	83 e8 80             	sub    $0xffffff80,%eax
   1504f:	8b 00                	mov    (%eax),%eax
   15051:	c1 e0 08             	shl    $0x8,%eax
   15054:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   15057:	8b 45 08             	mov    0x8(%ebp),%eax
   1505a:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   15060:	89 45 f4             	mov    %eax,-0xc(%ebp)
   15063:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15066:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   15069:	8b 55 08             	mov    0x8(%ebp),%edx
   1506c:	8b 52 40             	mov    0x40(%edx),%edx
   1506f:	89 55 f0             	mov    %edx,-0x10(%ebp)
   15072:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   15075:	8b 55 08             	mov    0x8(%ebp),%edx
   15078:	8b 52 20             	mov    0x20(%edx),%edx
   1507b:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1507e:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   15081:	8b 55 08             	mov    0x8(%ebp),%edx
   15084:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   1508a:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1508d:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   15090:	8b 55 08             	mov    0x8(%ebp),%edx
   15093:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   15099:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   1509c:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   1509f:	8b 55 08             	mov    0x8(%ebp),%edx
   150a2:	8b 52 60             	mov    0x60(%edx),%edx
   150a5:	89 55 e0             	mov    %edx,-0x20(%ebp)
   150a8:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   150ab:	85 c0                	test   %eax,%eax
   150ad:	75 45                	jne    150f4 <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   150af:	8b 45 08             	mov    0x8(%ebp),%eax
   150b2:	8b 00                	mov    (%eax),%eax
   150b4:	83 c0 20             	add    $0x20,%eax
   150b7:	c1 f8 06             	sar    $0x6,%eax
   150ba:	83 e8 80             	sub    $0xffffff80,%eax
   150bd:	50                   	push   %eax
   150be:	e8 d6 ea ff ff       	call   13b99 <_Clip>
   150c3:	83 c4 04             	add    $0x4,%esp
   150c6:	0f b6 c0             	movzbl %al,%eax
   150c9:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   150cc:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   150d3:	eb 14                	jmp    150e9 <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   150d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
   150d8:	89 c2                	mov    %eax,%edx
   150da:	8b 45 0c             	mov    0xc(%ebp),%eax
   150dd:	88 10                	mov    %dl,(%eax)
            out += stride;
   150df:	8b 45 10             	mov    0x10(%ebp),%eax
   150e2:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   150e5:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   150e9:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   150ed:	75 e6                	jne    150d5 <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   150ef:	e9 57 02 00 00       	jmp    1534b <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   150f4:	8b 45 08             	mov    0x8(%ebp),%eax
   150f7:	8b 00                	mov    (%eax),%eax
   150f9:	c1 e0 08             	shl    $0x8,%eax
   150fc:	05 00 20 00 00       	add    $0x2000,%eax
   15101:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   15104:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15107:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1510a:	01 d0                	add    %edx,%eax
   1510c:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   15112:	83 c0 04             	add    $0x4,%eax
   15115:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   15118:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1511b:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   15121:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15124:	01 d0                	add    %edx,%eax
   15126:	c1 f8 03             	sar    $0x3,%eax
   15129:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   1512c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1512f:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   15135:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15138:	01 d0                	add    %edx,%eax
   1513a:	c1 f8 03             	sar    $0x3,%eax
   1513d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   15140:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15143:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15146:	01 d0                	add    %edx,%eax
   15148:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   1514e:	83 c0 04             	add    $0x4,%eax
   15151:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   15154:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15157:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   1515d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15160:	01 d0                	add    %edx,%eax
   15162:	c1 f8 03             	sar    $0x3,%eax
   15165:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   15168:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1516b:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   15171:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15174:	01 d0                	add    %edx,%eax
   15176:	c1 f8 03             	sar    $0x3,%eax
   15179:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   1517c:	8b 55 fc             	mov    -0x4(%ebp),%edx
   1517f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15182:	01 d0                	add    %edx,%eax
   15184:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   15187:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1518a:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   1518d:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15190:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15193:	01 d0                	add    %edx,%eax
   15195:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   1519b:	83 c0 04             	add    $0x4,%eax
   1519e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   151a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   151a4:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   151aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
   151ad:	01 d0                	add    %edx,%eax
   151af:	c1 f8 03             	sar    $0x3,%eax
   151b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   151b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151b8:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   151be:	8b 45 f8             	mov    -0x8(%ebp),%eax
   151c1:	01 d0                	add    %edx,%eax
   151c3:	c1 f8 03             	sar    $0x3,%eax
   151c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   151c9:	8b 55 ec             	mov    -0x14(%ebp),%edx
   151cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   151cf:	01 d0                	add    %edx,%eax
   151d1:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   151d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   151d7:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   151da:	8b 55 e8             	mov    -0x18(%ebp),%edx
   151dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   151e0:	01 d0                	add    %edx,%eax
   151e2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   151e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   151e8:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   151eb:	8b 55 dc             	mov    -0x24(%ebp),%edx
   151ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151f1:	01 d0                	add    %edx,%eax
   151f3:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   151f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151f9:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   151fc:	8b 55 fc             	mov    -0x4(%ebp),%edx
   151ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15202:	01 d0                	add    %edx,%eax
   15204:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   15207:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1520a:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   1520d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15210:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15213:	01 d0                	add    %edx,%eax
   15215:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   1521b:	83 e8 80             	sub    $0xffffff80,%eax
   1521e:	c1 f8 08             	sar    $0x8,%eax
   15221:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   15224:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15227:	2b 45 e8             	sub    -0x18(%ebp),%eax
   1522a:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15230:	83 e8 80             	sub    $0xffffff80,%eax
   15233:	c1 f8 08             	sar    $0x8,%eax
   15236:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   15239:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1523c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1523f:	01 d0                	add    %edx,%eax
   15241:	c1 f8 0e             	sar    $0xe,%eax
   15244:	83 e8 80             	sub    $0xffffff80,%eax
   15247:	50                   	push   %eax
   15248:	e8 4c e9 ff ff       	call   13b99 <_Clip>
   1524d:	83 c4 04             	add    $0x4,%esp
   15250:	89 c2                	mov    %eax,%edx
   15252:	8b 45 0c             	mov    0xc(%ebp),%eax
   15255:	88 10                	mov    %dl,(%eax)
   15257:	8b 45 10             	mov    0x10(%ebp),%eax
   1525a:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   1525d:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15260:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15263:	01 d0                	add    %edx,%eax
   15265:	c1 f8 0e             	sar    $0xe,%eax
   15268:	83 e8 80             	sub    $0xffffff80,%eax
   1526b:	50                   	push   %eax
   1526c:	e8 28 e9 ff ff       	call   13b99 <_Clip>
   15271:	83 c4 04             	add    $0x4,%esp
   15274:	89 c2                	mov    %eax,%edx
   15276:	8b 45 0c             	mov    0xc(%ebp),%eax
   15279:	88 10                	mov    %dl,(%eax)
   1527b:	8b 45 10             	mov    0x10(%ebp),%eax
   1527e:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   15281:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15284:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15287:	01 d0                	add    %edx,%eax
   15289:	c1 f8 0e             	sar    $0xe,%eax
   1528c:	83 e8 80             	sub    $0xffffff80,%eax
   1528f:	50                   	push   %eax
   15290:	e8 04 e9 ff ff       	call   13b99 <_Clip>
   15295:	83 c4 04             	add    $0x4,%esp
   15298:	89 c2                	mov    %eax,%edx
   1529a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1529d:	88 10                	mov    %dl,(%eax)
   1529f:	8b 45 10             	mov    0x10(%ebp),%eax
   152a2:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   152a5:	8b 55 dc             	mov    -0x24(%ebp),%edx
   152a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   152ab:	01 d0                	add    %edx,%eax
   152ad:	c1 f8 0e             	sar    $0xe,%eax
   152b0:	83 e8 80             	sub    $0xffffff80,%eax
   152b3:	50                   	push   %eax
   152b4:	e8 e0 e8 ff ff       	call   13b99 <_Clip>
   152b9:	83 c4 04             	add    $0x4,%esp
   152bc:	89 c2                	mov    %eax,%edx
   152be:	8b 45 0c             	mov    0xc(%ebp),%eax
   152c1:	88 10                	mov    %dl,(%eax)
   152c3:	8b 45 10             	mov    0x10(%ebp),%eax
   152c6:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   152c9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   152cc:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   152cf:	c1 f8 0e             	sar    $0xe,%eax
   152d2:	83 e8 80             	sub    $0xffffff80,%eax
   152d5:	50                   	push   %eax
   152d6:	e8 be e8 ff ff       	call   13b99 <_Clip>
   152db:	83 c4 04             	add    $0x4,%esp
   152de:	89 c2                	mov    %eax,%edx
   152e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   152e3:	88 10                	mov    %dl,(%eax)
   152e5:	8b 45 10             	mov    0x10(%ebp),%eax
   152e8:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   152eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   152ee:	2b 45 ec             	sub    -0x14(%ebp),%eax
   152f1:	c1 f8 0e             	sar    $0xe,%eax
   152f4:	83 e8 80             	sub    $0xffffff80,%eax
   152f7:	50                   	push   %eax
   152f8:	e8 9c e8 ff ff       	call   13b99 <_Clip>
   152fd:	83 c4 04             	add    $0x4,%esp
   15300:	89 c2                	mov    %eax,%edx
   15302:	8b 45 0c             	mov    0xc(%ebp),%eax
   15305:	88 10                	mov    %dl,(%eax)
   15307:	8b 45 10             	mov    0x10(%ebp),%eax
   1530a:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   1530d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15310:	2b 45 f4             	sub    -0xc(%ebp),%eax
   15313:	c1 f8 0e             	sar    $0xe,%eax
   15316:	83 e8 80             	sub    $0xffffff80,%eax
   15319:	50                   	push   %eax
   1531a:	e8 7a e8 ff ff       	call   13b99 <_Clip>
   1531f:	83 c4 04             	add    $0x4,%esp
   15322:	89 c2                	mov    %eax,%edx
   15324:	8b 45 0c             	mov    0xc(%ebp),%eax
   15327:	88 10                	mov    %dl,(%eax)
   15329:	8b 45 10             	mov    0x10(%ebp),%eax
   1532c:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   1532f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15332:	2b 45 f8             	sub    -0x8(%ebp),%eax
   15335:	c1 f8 0e             	sar    $0xe,%eax
   15338:	83 e8 80             	sub    $0xffffff80,%eax
   1533b:	50                   	push   %eax
   1533c:	e8 58 e8 ff ff       	call   13b99 <_Clip>
   15341:	83 c4 04             	add    $0x4,%esp
   15344:	89 c2                	mov    %eax,%edx
   15346:	8b 45 0c             	mov    0xc(%ebp),%eax
   15349:	88 10                	mov    %dl,(%eax)
}
   1534b:	c9                   	leave  
   1534c:	c3                   	ret    

0001534d <_ByteAlign>:

void _ByteAlign(Context* ctx){
   1534d:	55                   	push   %ebp
   1534e:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   15350:	8b 45 08             	mov    0x8(%ebp),%eax
   15353:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15359:	25 f8 00 00 00       	and    $0xf8,%eax
   1535e:	89 c2                	mov    %eax,%edx
   15360:	8b 45 08             	mov    0x8(%ebp),%eax
   15363:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   15369:	90                   	nop
   1536a:	5d                   	pop    %ebp
   1536b:	c3                   	ret    

0001536c <_SkipMarker>:

void _SkipMarker(Context* ctx){
   1536c:	55                   	push   %ebp
   1536d:	89 e5                	mov    %esp,%ebp
   1536f:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   15372:	83 ec 0c             	sub    $0xc,%esp
   15375:	ff 75 08             	pushl  0x8(%ebp)
   15378:	e8 8d e8 ff ff       	call   13c0a <_DecodeLength>
   1537d:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   15380:	8b 45 08             	mov    0x8(%ebp),%eax
   15383:	8b 40 0c             	mov    0xc(%eax),%eax
   15386:	83 ec 08             	sub    $0x8,%esp
   15389:	50                   	push   %eax
   1538a:	ff 75 08             	pushl  0x8(%ebp)
   1538d:	e8 2c e8 ff ff       	call   13bbe <_Skip>
   15392:	83 c4 10             	add    $0x10,%esp
}
   15395:	90                   	nop
   15396:	c9                   	leave  
   15397:	c3                   	ret    

00015398 <_Convert>:

void _Convert(Context* ctx){
   15398:	55                   	push   %ebp
   15399:	89 e5                	mov    %esp,%ebp
   1539b:	57                   	push   %edi
   1539c:	56                   	push   %esi
   1539d:	53                   	push   %ebx
   1539e:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   153a1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   153a8:	8b 45 08             	mov    0x8(%ebp),%eax
   153ab:	83 c0 2c             	add    $0x2c,%eax
   153ae:	89 45 e0             	mov    %eax,-0x20(%ebp)
   153b1:	e9 b2 00 00 00       	jmp    15468 <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   153b6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   153b9:	8b 50 0c             	mov    0xc(%eax),%edx
   153bc:	8b 45 08             	mov    0x8(%ebp),%eax
   153bf:	8b 40 10             	mov    0x10(%eax),%eax
   153c2:	39 c2                	cmp    %eax,%edx
   153c4:	7d 11                	jge    153d7 <_Convert+0x3f>
   153c6:	83 ec 08             	sub    $0x8,%esp
   153c9:	ff 75 e0             	pushl  -0x20(%ebp)
   153cc:	ff 75 08             	pushl  0x8(%ebp)
   153cf:	e8 79 02 00 00       	call   1564d <_UpsampleH>
   153d4:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   153d7:	8b 45 08             	mov    0x8(%ebp),%eax
   153da:	8b 00                	mov    (%eax),%eax
   153dc:	85 c0                	test   %eax,%eax
   153de:	0f 85 5d 02 00 00    	jne    15641 <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   153e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   153e7:	8b 50 10             	mov    0x10(%eax),%edx
   153ea:	8b 45 08             	mov    0x8(%ebp),%eax
   153ed:	8b 40 14             	mov    0x14(%eax),%eax
   153f0:	39 c2                	cmp    %eax,%edx
   153f2:	7d 11                	jge    15405 <_Convert+0x6d>
   153f4:	83 ec 08             	sub    $0x8,%esp
   153f7:	ff 75 e0             	pushl  -0x20(%ebp)
   153fa:	ff 75 08             	pushl  0x8(%ebp)
   153fd:	e8 db 05 00 00       	call   159dd <_UpsampleV>
   15402:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   15405:	8b 45 08             	mov    0x8(%ebp),%eax
   15408:	8b 00                	mov    (%eax),%eax
   1540a:	85 c0                	test   %eax,%eax
   1540c:	0f 85 32 02 00 00    	jne    15644 <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   15412:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15415:	8b 50 0c             	mov    0xc(%eax),%edx
   15418:	8b 45 08             	mov    0x8(%ebp),%eax
   1541b:	8b 40 10             	mov    0x10(%eax),%eax
   1541e:	39 c2                	cmp    %eax,%edx
   15420:	7c 94                	jl     153b6 <_Convert+0x1e>
   15422:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15425:	8b 50 10             	mov    0x10(%eax),%edx
   15428:	8b 45 08             	mov    0x8(%ebp),%eax
   1542b:	8b 40 14             	mov    0x14(%eax),%eax
   1542e:	39 c2                	cmp    %eax,%edx
   15430:	7c 84                	jl     153b6 <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   15432:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15435:	8b 50 0c             	mov    0xc(%eax),%edx
   15438:	8b 45 08             	mov    0x8(%ebp),%eax
   1543b:	8b 40 10             	mov    0x10(%eax),%eax
   1543e:	39 c2                	cmp    %eax,%edx
   15440:	7c 10                	jl     15452 <_Convert+0xba>
   15442:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15445:	8b 50 10             	mov    0x10(%eax),%edx
   15448:	8b 45 08             	mov    0x8(%ebp),%eax
   1544b:	8b 40 14             	mov    0x14(%eax),%eax
   1544e:	39 c2                	cmp    %eax,%edx
   15450:	7d 0e                	jge    15460 <_Convert+0xc8>
   15452:	8b 45 08             	mov    0x8(%ebp),%eax
   15455:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   1545b:	e9 e5 01 00 00       	jmp    15645 <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15460:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   15464:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   15468:	8b 45 08             	mov    0x8(%ebp),%eax
   1546b:	8b 40 28             	mov    0x28(%eax),%eax
   1546e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15471:	7f 9f                	jg     15412 <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   15473:	8b 45 08             	mov    0x8(%ebp),%eax
   15476:	8b 40 28             	mov    0x28(%eax),%eax
   15479:	83 f8 03             	cmp    $0x3,%eax
   1547c:	0f 85 3d 01 00 00    	jne    155bf <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   15482:	8b 45 08             	mov    0x8(%ebp),%eax
   15485:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1548b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   1548e:	8b 45 08             	mov    0x8(%ebp),%eax
   15491:	8b 40 54             	mov    0x54(%eax),%eax
   15494:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   15497:	8b 45 08             	mov    0x8(%ebp),%eax
   1549a:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   154a0:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   154a3:	8b 45 08             	mov    0x8(%ebp),%eax
   154a6:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   154ac:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   154af:	8b 45 08             	mov    0x8(%ebp),%eax
   154b2:	8b 40 14             	mov    0x14(%eax),%eax
   154b5:	89 45 d8             	mov    %eax,-0x28(%ebp)
   154b8:	e9 f3 00 00 00       	jmp    155b0 <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   154bd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   154c4:	e9 b6 00 00 00       	jmp    1557f <_Convert+0x1e7>
                register int y = py[x] << 8;
   154c9:	8b 55 dc             	mov    -0x24(%ebp),%edx
   154cc:	8b 45 d0             	mov    -0x30(%ebp),%eax
   154cf:	01 d0                	add    %edx,%eax
   154d1:	0f b6 00             	movzbl (%eax),%eax
   154d4:	0f b6 c0             	movzbl %al,%eax
   154d7:	c1 e0 08             	shl    $0x8,%eax
   154da:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   154dc:	8b 55 dc             	mov    -0x24(%ebp),%edx
   154df:	8b 45 cc             	mov    -0x34(%ebp),%eax
   154e2:	01 d0                	add    %edx,%eax
   154e4:	0f b6 00             	movzbl (%eax),%eax
   154e7:	0f b6 c0             	movzbl %al,%eax
   154ea:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   154ed:	8b 55 dc             	mov    -0x24(%ebp),%edx
   154f0:	8b 45 c8             	mov    -0x38(%ebp),%eax
   154f3:	01 d0                	add    %edx,%eax
   154f5:	0f b6 00             	movzbl (%eax),%eax
   154f8:	0f b6 c0             	movzbl %al,%eax
   154fb:	83 c0 80             	add    $0xffffff80,%eax
   154fe:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   15500:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15503:	8d 46 01             	lea    0x1(%esi),%eax
   15506:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15509:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   1550c:	89 c8                	mov    %ecx,%eax
   1550e:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   15514:	01 d8                	add    %ebx,%eax
   15516:	83 e8 80             	sub    $0xffffff80,%eax
   15519:	c1 f8 08             	sar    $0x8,%eax
   1551c:	83 ec 0c             	sub    $0xc,%esp
   1551f:	50                   	push   %eax
   15520:	e8 74 e6 ff ff       	call   13b99 <_Clip>
   15525:	83 c4 10             	add    $0x10,%esp
   15528:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   1552a:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1552d:	8d 46 01             	lea    0x1(%esi),%eax
   15530:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15533:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   15536:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   15539:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   15540:	01 d0                	add    %edx,%eax
   15542:	83 e8 80             	sub    $0xffffff80,%eax
   15545:	c1 f8 08             	sar    $0x8,%eax
   15548:	83 ec 0c             	sub    $0xc,%esp
   1554b:	50                   	push   %eax
   1554c:	e8 48 e6 ff ff       	call   13b99 <_Clip>
   15551:	83 c4 10             	add    $0x10,%esp
   15554:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   15556:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15559:	8d 46 01             	lea    0x1(%esi),%eax
   1555c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1555f:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   15565:	01 d8                	add    %ebx,%eax
   15567:	83 e8 80             	sub    $0xffffff80,%eax
   1556a:	c1 f8 08             	sar    $0x8,%eax
   1556d:	83 ec 0c             	sub    $0xc,%esp
   15570:	50                   	push   %eax
   15571:	e8 23 e6 ff ff       	call   13b99 <_Clip>
   15576:	83 c4 10             	add    $0x10,%esp
   15579:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   1557b:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   1557f:	8b 45 08             	mov    0x8(%ebp),%eax
   15582:	8b 40 10             	mov    0x10(%eax),%eax
   15585:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   15588:	0f 8f 3b ff ff ff    	jg     154c9 <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   1558e:	8b 45 08             	mov    0x8(%ebp),%eax
   15591:	8b 40 40             	mov    0x40(%eax),%eax
   15594:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   15597:	8b 45 08             	mov    0x8(%ebp),%eax
   1559a:	8b 40 6c             	mov    0x6c(%eax),%eax
   1559d:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   155a0:	8b 45 08             	mov    0x8(%ebp),%eax
   155a3:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   155a9:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   155ac:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   155b0:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   155b4:	0f 85 03 ff ff ff    	jne    154bd <_Convert+0x125>
   155ba:	e9 86 00 00 00       	jmp    15645 <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   155bf:	8b 45 08             	mov    0x8(%ebp),%eax
   155c2:	8b 50 38             	mov    0x38(%eax),%edx
   155c5:	8b 45 08             	mov    0x8(%ebp),%eax
   155c8:	8b 40 40             	mov    0x40(%eax),%eax
   155cb:	39 c2                	cmp    %eax,%edx
   155cd:	74 76                	je     15645 <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   155cf:	8b 45 08             	mov    0x8(%ebp),%eax
   155d2:	8b 50 54             	mov    0x54(%eax),%edx
   155d5:	8b 45 08             	mov    0x8(%ebp),%eax
   155d8:	8b 40 40             	mov    0x40(%eax),%eax
   155db:	01 d0                	add    %edx,%eax
   155dd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   155e0:	8b 45 08             	mov    0x8(%ebp),%eax
   155e3:	8b 50 54             	mov    0x54(%eax),%edx
   155e6:	8b 45 08             	mov    0x8(%ebp),%eax
   155e9:	8b 40 38             	mov    0x38(%eax),%eax
   155ec:	01 d0                	add    %edx,%eax
   155ee:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   155f1:	8b 45 08             	mov    0x8(%ebp),%eax
   155f4:	8b 40 3c             	mov    0x3c(%eax),%eax
   155f7:	83 e8 01             	sub    $0x1,%eax
   155fa:	89 45 bc             	mov    %eax,-0x44(%ebp)
   155fd:	eb 2e                	jmp    1562d <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   155ff:	8b 45 08             	mov    0x8(%ebp),%eax
   15602:	8b 40 38             	mov    0x38(%eax),%eax
   15605:	83 ec 04             	sub    $0x4,%esp
   15608:	50                   	push   %eax
   15609:	ff 75 c4             	pushl  -0x3c(%ebp)
   1560c:	ff 75 c0             	pushl  -0x40(%ebp)
   1560f:	e8 72 ac fe ff       	call   286 <memmove>
   15614:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   15617:	8b 45 08             	mov    0x8(%ebp),%eax
   1561a:	8b 40 40             	mov    0x40(%eax),%eax
   1561d:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   15620:	8b 45 08             	mov    0x8(%ebp),%eax
   15623:	8b 40 38             	mov    0x38(%eax),%eax
   15626:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   15629:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   1562d:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   15631:	75 cc                	jne    155ff <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   15633:	8b 45 08             	mov    0x8(%ebp),%eax
   15636:	8b 50 38             	mov    0x38(%eax),%edx
   15639:	8b 45 08             	mov    0x8(%ebp),%eax
   1563c:	89 50 40             	mov    %edx,0x40(%eax)
   1563f:	eb 04                	jmp    15645 <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   15641:	90                   	nop
   15642:	eb 01                	jmp    15645 <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   15644:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   15645:	8d 65 f4             	lea    -0xc(%ebp),%esp
   15648:	5b                   	pop    %ebx
   15649:	5e                   	pop    %esi
   1564a:	5f                   	pop    %edi
   1564b:	5d                   	pop    %ebp
   1564c:	c3                   	ret    

0001564d <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   1564d:	55                   	push   %ebp
   1564e:	89 e5                	mov    %esp,%ebp
   15650:	53                   	push   %ebx
   15651:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   15654:	8b 45 0c             	mov    0xc(%ebp),%eax
   15657:	8b 40 0c             	mov    0xc(%eax),%eax
   1565a:	83 e8 03             	sub    $0x3,%eax
   1565d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15660:	8b 45 0c             	mov    0xc(%ebp),%eax
   15663:	8b 50 0c             	mov    0xc(%eax),%edx
   15666:	8b 45 0c             	mov    0xc(%ebp),%eax
   15669:	8b 40 10             	mov    0x10(%eax),%eax
   1566c:	0f af c2             	imul   %edx,%eax
   1566f:	01 c0                	add    %eax,%eax
   15671:	83 ec 0c             	sub    $0xc,%esp
   15674:	50                   	push   %eax
   15675:	e8 cb b0 fe ff       	call   745 <malloc>
   1567a:	83 c4 10             	add    $0x10,%esp
   1567d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15680:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   15684:	75 0e                	jne    15694 <_UpsampleH+0x47>
   15686:	8b 45 08             	mov    0x8(%ebp),%eax
   15689:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1568f:	e9 44 03 00 00       	jmp    159d8 <_UpsampleH+0x38b>
    lin = c->pixels;
   15694:	8b 45 0c             	mov    0xc(%ebp),%eax
   15697:	8b 40 28             	mov    0x28(%eax),%eax
   1569a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   1569d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   156a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   156a3:	8b 45 0c             	mov    0xc(%ebp),%eax
   156a6:	8b 40 10             	mov    0x10(%eax),%eax
   156a9:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   156ac:	e9 e0 02 00 00       	jmp    15991 <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   156b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156b4:	0f b6 00             	movzbl (%eax),%eax
   156b7:	0f b6 c0             	movzbl %al,%eax
   156ba:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   156c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156c3:	83 c0 01             	add    $0x1,%eax
   156c6:	0f b6 00             	movzbl (%eax),%eax
   156c9:	0f b6 c0             	movzbl %al,%eax
   156cc:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   156cf:	01 d0                	add    %edx,%eax
   156d1:	83 ec 0c             	sub    $0xc,%esp
   156d4:	50                   	push   %eax
   156d5:	e8 c4 06 00 00       	call   15d9e <CF>
   156da:	83 c4 10             	add    $0x10,%esp
   156dd:	89 c2                	mov    %eax,%edx
   156df:	8b 45 f0             	mov    -0x10(%ebp),%eax
   156e2:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   156e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   156e7:	8d 58 01             	lea    0x1(%eax),%ebx
   156ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156ed:	0f b6 00             	movzbl (%eax),%eax
   156f0:	0f b6 c0             	movzbl %al,%eax
   156f3:	6b c8 68             	imul   $0x68,%eax,%ecx
   156f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   156f9:	83 c0 01             	add    $0x1,%eax
   156fc:	0f b6 00             	movzbl (%eax),%eax
   156ff:	0f b6 d0             	movzbl %al,%edx
   15702:	89 d0                	mov    %edx,%eax
   15704:	01 c0                	add    %eax,%eax
   15706:	01 d0                	add    %edx,%eax
   15708:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1570f:	01 d0                	add    %edx,%eax
   15711:	01 c1                	add    %eax,%ecx
   15713:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15716:	83 c0 02             	add    $0x2,%eax
   15719:	0f b6 00             	movzbl (%eax),%eax
   1571c:	0f b6 d0             	movzbl %al,%edx
   1571f:	89 d0                	mov    %edx,%eax
   15721:	01 c0                	add    %eax,%eax
   15723:	01 d0                	add    %edx,%eax
   15725:	f7 d8                	neg    %eax
   15727:	01 c8                	add    %ecx,%eax
   15729:	83 ec 0c             	sub    $0xc,%esp
   1572c:	50                   	push   %eax
   1572d:	e8 6c 06 00 00       	call   15d9e <CF>
   15732:	83 c4 10             	add    $0x10,%esp
   15735:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   15737:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1573a:	8d 58 02             	lea    0x2(%eax),%ebx
   1573d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15740:	0f b6 00             	movzbl (%eax),%eax
   15743:	0f b6 c0             	movzbl %al,%eax
   15746:	c1 e0 02             	shl    $0x2,%eax
   15749:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15750:	29 c2                	sub    %eax,%edx
   15752:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15755:	83 c0 01             	add    $0x1,%eax
   15758:	0f b6 00             	movzbl (%eax),%eax
   1575b:	0f b6 c0             	movzbl %al,%eax
   1575e:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15761:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15764:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15767:	83 c0 02             	add    $0x2,%eax
   1576a:	0f b6 00             	movzbl (%eax),%eax
   1576d:	0f b6 d0             	movzbl %al,%edx
   15770:	89 d0                	mov    %edx,%eax
   15772:	c1 e0 03             	shl    $0x3,%eax
   15775:	01 d0                	add    %edx,%eax
   15777:	f7 d8                	neg    %eax
   15779:	01 c8                	add    %ecx,%eax
   1577b:	83 ec 0c             	sub    $0xc,%esp
   1577e:	50                   	push   %eax
   1577f:	e8 1a 06 00 00       	call   15d9e <CF>
   15784:	83 c4 10             	add    $0x10,%esp
   15787:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   15789:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15790:	e9 fa 00 00 00       	jmp    1588f <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   15795:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15798:	01 c0                	add    %eax,%eax
   1579a:	8d 50 03             	lea    0x3(%eax),%edx
   1579d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   157a0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   157a3:	8b 55 ec             	mov    -0x14(%ebp),%edx
   157a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157a9:	01 d0                	add    %edx,%eax
   157ab:	0f b6 00             	movzbl (%eax),%eax
   157ae:	0f b6 d0             	movzbl %al,%edx
   157b1:	89 d0                	mov    %edx,%eax
   157b3:	c1 e0 03             	shl    $0x3,%eax
   157b6:	01 d0                	add    %edx,%eax
   157b8:	f7 d8                	neg    %eax
   157ba:	8b 55 ec             	mov    -0x14(%ebp),%edx
   157bd:	8d 4a 01             	lea    0x1(%edx),%ecx
   157c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
   157c3:	01 ca                	add    %ecx,%edx
   157c5:	0f b6 12             	movzbl (%edx),%edx
   157c8:	0f b6 d2             	movzbl %dl,%edx
   157cb:	6b d2 6f             	imul   $0x6f,%edx,%edx
   157ce:	01 c2                	add    %eax,%edx
   157d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   157d3:	8d 48 02             	lea    0x2(%eax),%ecx
   157d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157d9:	01 c8                	add    %ecx,%eax
   157db:	0f b6 00             	movzbl (%eax),%eax
   157de:	0f b6 c0             	movzbl %al,%eax
   157e1:	6b c0 1d             	imul   $0x1d,%eax,%eax
   157e4:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   157e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   157ea:	8d 50 03             	lea    0x3(%eax),%edx
   157ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157f0:	01 d0                	add    %edx,%eax
   157f2:	0f b6 00             	movzbl (%eax),%eax
   157f5:	0f b6 d0             	movzbl %al,%edx
   157f8:	89 d0                	mov    %edx,%eax
   157fa:	01 c0                	add    %eax,%eax
   157fc:	01 d0                	add    %edx,%eax
   157fe:	f7 d8                	neg    %eax
   15800:	01 c8                	add    %ecx,%eax
   15802:	83 ec 0c             	sub    $0xc,%esp
   15805:	50                   	push   %eax
   15806:	e8 93 05 00 00       	call   15d9e <CF>
   1580b:	83 c4 10             	add    $0x10,%esp
   1580e:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   15810:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15813:	01 c0                	add    %eax,%eax
   15815:	8d 50 04             	lea    0x4(%eax),%edx
   15818:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1581b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   1581e:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15821:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15824:	01 d0                	add    %edx,%eax
   15826:	0f b6 00             	movzbl (%eax),%eax
   15829:	0f b6 d0             	movzbl %al,%edx
   1582c:	89 d0                	mov    %edx,%eax
   1582e:	01 c0                	add    %eax,%eax
   15830:	01 d0                	add    %edx,%eax
   15832:	f7 d8                	neg    %eax
   15834:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15837:	8d 4a 01             	lea    0x1(%edx),%ecx
   1583a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1583d:	01 ca                	add    %ecx,%edx
   1583f:	0f b6 12             	movzbl (%edx),%edx
   15842:	0f b6 d2             	movzbl %dl,%edx
   15845:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15848:	01 c2                	add    %eax,%edx
   1584a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1584d:	8d 48 02             	lea    0x2(%eax),%ecx
   15850:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15853:	01 c8                	add    %ecx,%eax
   15855:	0f b6 00             	movzbl (%eax),%eax
   15858:	0f b6 c0             	movzbl %al,%eax
   1585b:	6b c0 6f             	imul   $0x6f,%eax,%eax
   1585e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15861:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15864:	8d 50 03             	lea    0x3(%eax),%edx
   15867:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1586a:	01 d0                	add    %edx,%eax
   1586c:	0f b6 00             	movzbl (%eax),%eax
   1586f:	0f b6 d0             	movzbl %al,%edx
   15872:	89 d0                	mov    %edx,%eax
   15874:	c1 e0 03             	shl    $0x3,%eax
   15877:	01 d0                	add    %edx,%eax
   15879:	f7 d8                	neg    %eax
   1587b:	01 c8                	add    %ecx,%eax
   1587d:	83 ec 0c             	sub    $0xc,%esp
   15880:	50                   	push   %eax
   15881:	e8 18 05 00 00       	call   15d9e <CF>
   15886:	83 c4 10             	add    $0x10,%esp
   15889:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   1588b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1588f:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15892:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15895:	0f 8c fa fe ff ff    	jl     15795 <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   1589b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1589e:	8b 40 14             	mov    0x14(%eax),%eax
   158a1:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   158a4:	8b 45 0c             	mov    0xc(%ebp),%eax
   158a7:	8b 40 0c             	mov    0xc(%eax),%eax
   158aa:	01 c0                	add    %eax,%eax
   158ac:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   158af:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158b2:	8d 58 fd             	lea    -0x3(%eax),%ebx
   158b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158b8:	83 e8 01             	sub    $0x1,%eax
   158bb:	0f b6 00             	movzbl (%eax),%eax
   158be:	0f b6 c0             	movzbl %al,%eax
   158c1:	c1 e0 02             	shl    $0x2,%eax
   158c4:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   158cb:	29 c2                	sub    %eax,%edx
   158cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158d0:	83 e8 02             	sub    $0x2,%eax
   158d3:	0f b6 00             	movzbl (%eax),%eax
   158d6:	0f b6 c0             	movzbl %al,%eax
   158d9:	6b c0 6d             	imul   $0x6d,%eax,%eax
   158dc:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   158df:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158e2:	83 e8 03             	sub    $0x3,%eax
   158e5:	0f b6 00             	movzbl (%eax),%eax
   158e8:	0f b6 d0             	movzbl %al,%edx
   158eb:	89 d0                	mov    %edx,%eax
   158ed:	c1 e0 03             	shl    $0x3,%eax
   158f0:	01 d0                	add    %edx,%eax
   158f2:	f7 d8                	neg    %eax
   158f4:	01 c8                	add    %ecx,%eax
   158f6:	83 ec 0c             	sub    $0xc,%esp
   158f9:	50                   	push   %eax
   158fa:	e8 9f 04 00 00       	call   15d9e <CF>
   158ff:	83 c4 10             	add    $0x10,%esp
   15902:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   15904:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15907:	8d 58 fe             	lea    -0x2(%eax),%ebx
   1590a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1590d:	83 e8 01             	sub    $0x1,%eax
   15910:	0f b6 00             	movzbl (%eax),%eax
   15913:	0f b6 c0             	movzbl %al,%eax
   15916:	6b c8 68             	imul   $0x68,%eax,%ecx
   15919:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1591c:	83 e8 02             	sub    $0x2,%eax
   1591f:	0f b6 00             	movzbl (%eax),%eax
   15922:	0f b6 d0             	movzbl %al,%edx
   15925:	89 d0                	mov    %edx,%eax
   15927:	01 c0                	add    %eax,%eax
   15929:	01 d0                	add    %edx,%eax
   1592b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15932:	01 d0                	add    %edx,%eax
   15934:	01 c1                	add    %eax,%ecx
   15936:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15939:	83 e8 03             	sub    $0x3,%eax
   1593c:	0f b6 00             	movzbl (%eax),%eax
   1593f:	0f b6 d0             	movzbl %al,%edx
   15942:	89 d0                	mov    %edx,%eax
   15944:	01 c0                	add    %eax,%eax
   15946:	01 d0                	add    %edx,%eax
   15948:	f7 d8                	neg    %eax
   1594a:	01 c8                	add    %ecx,%eax
   1594c:	83 ec 0c             	sub    $0xc,%esp
   1594f:	50                   	push   %eax
   15950:	e8 49 04 00 00       	call   15d9e <CF>
   15955:	83 c4 10             	add    $0x10,%esp
   15958:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   1595a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1595d:	8d 58 ff             	lea    -0x1(%eax),%ebx
   15960:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15963:	83 e8 01             	sub    $0x1,%eax
   15966:	0f b6 00             	movzbl (%eax),%eax
   15969:	0f b6 c0             	movzbl %al,%eax
   1596c:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15972:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15975:	83 e8 02             	sub    $0x2,%eax
   15978:	0f b6 00             	movzbl (%eax),%eax
   1597b:	0f b6 c0             	movzbl %al,%eax
   1597e:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15981:	01 d0                	add    %edx,%eax
   15983:	83 ec 0c             	sub    $0xc,%esp
   15986:	50                   	push   %eax
   15987:	e8 12 04 00 00       	call   15d9e <CF>
   1598c:	83 c4 10             	add    $0x10,%esp
   1598f:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   15991:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15994:	8d 50 ff             	lea    -0x1(%eax),%edx
   15997:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1599a:	85 c0                	test   %eax,%eax
   1599c:	0f 85 0f fd ff ff    	jne    156b1 <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   159a2:	8b 45 0c             	mov    0xc(%ebp),%eax
   159a5:	8b 40 0c             	mov    0xc(%eax),%eax
   159a8:	8d 14 00             	lea    (%eax,%eax,1),%edx
   159ab:	8b 45 0c             	mov    0xc(%ebp),%eax
   159ae:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   159b1:	8b 45 0c             	mov    0xc(%ebp),%eax
   159b4:	8b 50 0c             	mov    0xc(%eax),%edx
   159b7:	8b 45 0c             	mov    0xc(%ebp),%eax
   159ba:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   159bd:	8b 45 0c             	mov    0xc(%ebp),%eax
   159c0:	8b 40 28             	mov    0x28(%eax),%eax
   159c3:	83 ec 0c             	sub    $0xc,%esp
   159c6:	50                   	push   %eax
   159c7:	e8 37 ac fe ff       	call   603 <free>
   159cc:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   159cf:	8b 45 0c             	mov    0xc(%ebp),%eax
   159d2:	8b 55 e0             	mov    -0x20(%ebp),%edx
   159d5:	89 50 28             	mov    %edx,0x28(%eax)
}
   159d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   159db:	c9                   	leave  
   159dc:	c3                   	ret    

000159dd <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   159dd:	55                   	push   %ebp
   159de:	89 e5                	mov    %esp,%ebp
   159e0:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   159e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   159e6:	8b 40 0c             	mov    0xc(%eax),%eax
   159e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   159ec:	8b 45 0c             	mov    0xc(%ebp),%eax
   159ef:	8b 40 14             	mov    0x14(%eax),%eax
   159f2:	89 45 e0             	mov    %eax,-0x20(%ebp)
   159f5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   159f8:	01 c0                	add    %eax,%eax
   159fa:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   159fd:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a00:	8b 50 0c             	mov    0xc(%eax),%edx
   15a03:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a06:	8b 40 10             	mov    0x10(%eax),%eax
   15a09:	0f af c2             	imul   %edx,%eax
   15a0c:	01 c0                	add    %eax,%eax
   15a0e:	83 ec 0c             	sub    $0xc,%esp
   15a11:	50                   	push   %eax
   15a12:	e8 2e ad fe ff       	call   745 <malloc>
   15a17:	83 c4 10             	add    $0x10,%esp
   15a1a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15a1d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15a21:	75 0e                	jne    15a31 <_UpsampleV+0x54>
   15a23:	8b 45 08             	mov    0x8(%ebp),%eax
   15a26:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15a2c:	e9 6b 03 00 00       	jmp    15d9c <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   15a31:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15a38:	e9 1d 03 00 00       	jmp    15d5a <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   15a3d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15a40:	8b 50 28             	mov    0x28(%eax),%edx
   15a43:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15a46:	01 d0                	add    %edx,%eax
   15a48:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   15a4b:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15a4e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15a51:	01 d0                	add    %edx,%eax
   15a53:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   15a56:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a59:	0f b6 00             	movzbl (%eax),%eax
   15a5c:	0f b6 c0             	movzbl %al,%eax
   15a5f:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15a65:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   15a68:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a6b:	01 c8                	add    %ecx,%eax
   15a6d:	0f b6 00             	movzbl (%eax),%eax
   15a70:	0f b6 c0             	movzbl %al,%eax
   15a73:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15a76:	01 d0                	add    %edx,%eax
   15a78:	83 ec 0c             	sub    $0xc,%esp
   15a7b:	50                   	push   %eax
   15a7c:	e8 1d 03 00 00       	call   15d9e <CF>
   15a81:	83 c4 10             	add    $0x10,%esp
   15a84:	89 c2                	mov    %eax,%edx
   15a86:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a89:	88 10                	mov    %dl,(%eax)
   15a8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15a8e:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   15a91:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a94:	0f b6 00             	movzbl (%eax),%eax
   15a97:	0f b6 c0             	movzbl %al,%eax
   15a9a:	6b c8 68             	imul   $0x68,%eax,%ecx
   15a9d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15aa0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15aa3:	01 d0                	add    %edx,%eax
   15aa5:	0f b6 00             	movzbl (%eax),%eax
   15aa8:	0f b6 d0             	movzbl %al,%edx
   15aab:	89 d0                	mov    %edx,%eax
   15aad:	01 c0                	add    %eax,%eax
   15aaf:	01 d0                	add    %edx,%eax
   15ab1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15ab8:	01 d0                	add    %edx,%eax
   15aba:	01 c1                	add    %eax,%ecx
   15abc:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15abf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ac2:	01 d0                	add    %edx,%eax
   15ac4:	0f b6 00             	movzbl (%eax),%eax
   15ac7:	0f b6 d0             	movzbl %al,%edx
   15aca:	89 d0                	mov    %edx,%eax
   15acc:	01 c0                	add    %eax,%eax
   15ace:	01 d0                	add    %edx,%eax
   15ad0:	f7 d8                	neg    %eax
   15ad2:	01 c8                	add    %ecx,%eax
   15ad4:	83 ec 0c             	sub    $0xc,%esp
   15ad7:	50                   	push   %eax
   15ad8:	e8 c1 02 00 00       	call   15d9e <CF>
   15add:	83 c4 10             	add    $0x10,%esp
   15ae0:	89 c2                	mov    %eax,%edx
   15ae2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15ae5:	88 10                	mov    %dl,(%eax)
   15ae7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15aea:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   15aed:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15af0:	0f b6 00             	movzbl (%eax),%eax
   15af3:	0f b6 c0             	movzbl %al,%eax
   15af6:	c1 e0 02             	shl    $0x2,%eax
   15af9:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15b00:	89 d1                	mov    %edx,%ecx
   15b02:	29 c1                	sub    %eax,%ecx
   15b04:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15b07:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b0a:	01 d0                	add    %edx,%eax
   15b0c:	0f b6 00             	movzbl (%eax),%eax
   15b0f:	0f b6 c0             	movzbl %al,%eax
   15b12:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15b15:	01 c1                	add    %eax,%ecx
   15b17:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15b1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b1d:	01 d0                	add    %edx,%eax
   15b1f:	0f b6 00             	movzbl (%eax),%eax
   15b22:	0f b6 d0             	movzbl %al,%edx
   15b25:	89 d0                	mov    %edx,%eax
   15b27:	c1 e0 03             	shl    $0x3,%eax
   15b2a:	01 d0                	add    %edx,%eax
   15b2c:	f7 d8                	neg    %eax
   15b2e:	01 c8                	add    %ecx,%eax
   15b30:	83 ec 0c             	sub    $0xc,%esp
   15b33:	50                   	push   %eax
   15b34:	e8 65 02 00 00       	call   15d9e <CF>
   15b39:	83 c4 10             	add    $0x10,%esp
   15b3c:	89 c2                	mov    %eax,%edx
   15b3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b41:	88 10                	mov    %dl,(%eax)
   15b43:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15b46:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   15b49:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b4c:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   15b4f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b52:	8b 40 10             	mov    0x10(%eax),%eax
   15b55:	83 e8 03             	sub    $0x3,%eax
   15b58:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15b5b:	e9 e6 00 00 00       	jmp    15c46 <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   15b60:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b63:	f7 d8                	neg    %eax
   15b65:	89 c2                	mov    %eax,%edx
   15b67:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b6a:	01 d0                	add    %edx,%eax
   15b6c:	0f b6 00             	movzbl (%eax),%eax
   15b6f:	0f b6 d0             	movzbl %al,%edx
   15b72:	89 d0                	mov    %edx,%eax
   15b74:	c1 e0 03             	shl    $0x3,%eax
   15b77:	01 d0                	add    %edx,%eax
   15b79:	f7 d8                	neg    %eax
   15b7b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15b7e:	0f b6 12             	movzbl (%edx),%edx
   15b81:	0f b6 d2             	movzbl %dl,%edx
   15b84:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15b87:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15b8a:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15b8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b90:	01 d0                	add    %edx,%eax
   15b92:	0f b6 00             	movzbl (%eax),%eax
   15b95:	0f b6 c0             	movzbl %al,%eax
   15b98:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15b9b:	01 c1                	add    %eax,%ecx
   15b9d:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15ba0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ba3:	01 d0                	add    %edx,%eax
   15ba5:	0f b6 00             	movzbl (%eax),%eax
   15ba8:	0f b6 d0             	movzbl %al,%edx
   15bab:	89 d0                	mov    %edx,%eax
   15bad:	01 c0                	add    %eax,%eax
   15baf:	01 d0                	add    %edx,%eax
   15bb1:	f7 d8                	neg    %eax
   15bb3:	01 c8                	add    %ecx,%eax
   15bb5:	83 ec 0c             	sub    $0xc,%esp
   15bb8:	50                   	push   %eax
   15bb9:	e8 e0 01 00 00       	call   15d9e <CF>
   15bbe:	83 c4 10             	add    $0x10,%esp
   15bc1:	89 c2                	mov    %eax,%edx
   15bc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15bc6:	88 10                	mov    %dl,(%eax)
   15bc8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15bcb:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   15bce:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15bd1:	f7 d8                	neg    %eax
   15bd3:	89 c2                	mov    %eax,%edx
   15bd5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bd8:	01 d0                	add    %edx,%eax
   15bda:	0f b6 00             	movzbl (%eax),%eax
   15bdd:	0f b6 d0             	movzbl %al,%edx
   15be0:	89 d0                	mov    %edx,%eax
   15be2:	01 c0                	add    %eax,%eax
   15be4:	01 d0                	add    %edx,%eax
   15be6:	f7 d8                	neg    %eax
   15be8:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15beb:	0f b6 12             	movzbl (%edx),%edx
   15bee:	0f b6 d2             	movzbl %dl,%edx
   15bf1:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15bf4:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15bf7:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15bfa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bfd:	01 d0                	add    %edx,%eax
   15bff:	0f b6 00             	movzbl (%eax),%eax
   15c02:	0f b6 c0             	movzbl %al,%eax
   15c05:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15c08:	01 c1                	add    %eax,%ecx
   15c0a:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15c0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c10:	01 d0                	add    %edx,%eax
   15c12:	0f b6 00             	movzbl (%eax),%eax
   15c15:	0f b6 d0             	movzbl %al,%edx
   15c18:	89 d0                	mov    %edx,%eax
   15c1a:	c1 e0 03             	shl    $0x3,%eax
   15c1d:	01 d0                	add    %edx,%eax
   15c1f:	f7 d8                	neg    %eax
   15c21:	01 c8                	add    %ecx,%eax
   15c23:	83 ec 0c             	sub    $0xc,%esp
   15c26:	50                   	push   %eax
   15c27:	e8 72 01 00 00       	call   15d9e <CF>
   15c2c:	83 c4 10             	add    $0x10,%esp
   15c2f:	89 c2                	mov    %eax,%edx
   15c31:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c34:	88 10                	mov    %dl,(%eax)
   15c36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15c39:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   15c3c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c3f:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   15c42:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   15c46:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15c4a:	0f 85 10 ff ff ff    	jne    15b60 <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   15c50:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c53:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   15c56:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c59:	0f b6 00             	movzbl (%eax),%eax
   15c5c:	0f b6 c0             	movzbl %al,%eax
   15c5f:	c1 e0 02             	shl    $0x2,%eax
   15c62:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15c69:	29 c2                	sub    %eax,%edx
   15c6b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c6e:	f7 d8                	neg    %eax
   15c70:	89 c1                	mov    %eax,%ecx
   15c72:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c75:	01 c8                	add    %ecx,%eax
   15c77:	0f b6 00             	movzbl (%eax),%eax
   15c7a:	0f b6 c0             	movzbl %al,%eax
   15c7d:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15c80:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15c83:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15c86:	f7 d8                	neg    %eax
   15c88:	89 c2                	mov    %eax,%edx
   15c8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c8d:	01 d0                	add    %edx,%eax
   15c8f:	0f b6 00             	movzbl (%eax),%eax
   15c92:	0f b6 d0             	movzbl %al,%edx
   15c95:	89 d0                	mov    %edx,%eax
   15c97:	c1 e0 03             	shl    $0x3,%eax
   15c9a:	01 d0                	add    %edx,%eax
   15c9c:	f7 d8                	neg    %eax
   15c9e:	01 c8                	add    %ecx,%eax
   15ca0:	83 ec 0c             	sub    $0xc,%esp
   15ca3:	50                   	push   %eax
   15ca4:	e8 f5 00 00 00       	call   15d9e <CF>
   15ca9:	83 c4 10             	add    $0x10,%esp
   15cac:	89 c2                	mov    %eax,%edx
   15cae:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15cb1:	88 10                	mov    %dl,(%eax)
   15cb3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15cb6:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   15cb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cbc:	0f b6 00             	movzbl (%eax),%eax
   15cbf:	0f b6 c0             	movzbl %al,%eax
   15cc2:	6b c8 68             	imul   $0x68,%eax,%ecx
   15cc5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15cc8:	f7 d8                	neg    %eax
   15cca:	89 c2                	mov    %eax,%edx
   15ccc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ccf:	01 d0                	add    %edx,%eax
   15cd1:	0f b6 00             	movzbl (%eax),%eax
   15cd4:	0f b6 d0             	movzbl %al,%edx
   15cd7:	89 d0                	mov    %edx,%eax
   15cd9:	01 c0                	add    %eax,%eax
   15cdb:	01 d0                	add    %edx,%eax
   15cdd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15ce4:	01 d0                	add    %edx,%eax
   15ce6:	01 c1                	add    %eax,%ecx
   15ce8:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15ceb:	f7 d8                	neg    %eax
   15ced:	89 c2                	mov    %eax,%edx
   15cef:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cf2:	01 d0                	add    %edx,%eax
   15cf4:	0f b6 00             	movzbl (%eax),%eax
   15cf7:	0f b6 d0             	movzbl %al,%edx
   15cfa:	89 d0                	mov    %edx,%eax
   15cfc:	01 c0                	add    %eax,%eax
   15cfe:	01 d0                	add    %edx,%eax
   15d00:	f7 d8                	neg    %eax
   15d02:	01 c8                	add    %ecx,%eax
   15d04:	83 ec 0c             	sub    $0xc,%esp
   15d07:	50                   	push   %eax
   15d08:	e8 91 00 00 00       	call   15d9e <CF>
   15d0d:	83 c4 10             	add    $0x10,%esp
   15d10:	89 c2                	mov    %eax,%edx
   15d12:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d15:	88 10                	mov    %dl,(%eax)
   15d17:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d1a:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   15d1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d20:	0f b6 00             	movzbl (%eax),%eax
   15d23:	0f b6 c0             	movzbl %al,%eax
   15d26:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15d2c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d2f:	f7 d8                	neg    %eax
   15d31:	89 c1                	mov    %eax,%ecx
   15d33:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d36:	01 c8                	add    %ecx,%eax
   15d38:	0f b6 00             	movzbl (%eax),%eax
   15d3b:	0f b6 c0             	movzbl %al,%eax
   15d3e:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15d41:	01 d0                	add    %edx,%eax
   15d43:	83 ec 0c             	sub    $0xc,%esp
   15d46:	50                   	push   %eax
   15d47:	e8 52 00 00 00       	call   15d9e <CF>
   15d4c:	83 c4 10             	add    $0x10,%esp
   15d4f:	89 c2                	mov    %eax,%edx
   15d51:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d54:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   15d56:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15d5a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15d5d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15d60:	0f 8c d7 fc ff ff    	jl     15a3d <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   15d66:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d69:	8b 40 10             	mov    0x10(%eax),%eax
   15d6c:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15d6f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d72:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   15d75:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d78:	8b 50 0c             	mov    0xc(%eax),%edx
   15d7b:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d7e:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15d81:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d84:	8b 40 28             	mov    0x28(%eax),%eax
   15d87:	83 ec 0c             	sub    $0xc,%esp
   15d8a:	50                   	push   %eax
   15d8b:	e8 73 a8 fe ff       	call   603 <free>
   15d90:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15d93:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d96:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15d99:	89 50 28             	mov    %edx,0x28(%eax)
}
   15d9c:	c9                   	leave  
   15d9d:	c3                   	ret    

00015d9e <CF>:

uchar CF(const int x){
   15d9e:	55                   	push   %ebp
   15d9f:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   15da1:	8b 45 08             	mov    0x8(%ebp),%eax
   15da4:	83 c0 40             	add    $0x40,%eax
   15da7:	c1 f8 07             	sar    $0x7,%eax
   15daa:	50                   	push   %eax
   15dab:	e8 e9 dd ff ff       	call   13b99 <_Clip>
   15db0:	83 c4 04             	add    $0x4,%esp
}
   15db3:	c9                   	leave  
   15db4:	c3                   	ret    
