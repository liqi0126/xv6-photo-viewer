
_wc：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <wc>:

char buf[512];

void
wc(int fd, char *name)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	83 ec 28             	sub    $0x28,%esp
  int i, n;
  int l, w, c, inword;

  l = w = c = 0;
       6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
       d:	8b 45 e8             	mov    -0x18(%ebp),%eax
      10:	89 45 ec             	mov    %eax,-0x14(%ebp)
      13:	8b 45 ec             	mov    -0x14(%ebp),%eax
      16:	89 45 f0             	mov    %eax,-0x10(%ebp)
  inword = 0;
      19:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  while((n = read(fd, buf, sizeof(buf))) > 0){
      20:	eb 69                	jmp    8b <wc+0x8b>
    for(i=0; i<n; i++){
      22:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      29:	eb 58                	jmp    83 <wc+0x83>
      c++;
      2b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
      if(buf[i] == '\n')
      2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
      32:	05 a0 e6 01 00       	add    $0x1e6a0,%eax
      37:	0f b6 00             	movzbl (%eax),%eax
      3a:	3c 0a                	cmp    $0xa,%al
      3c:	75 04                	jne    42 <wc+0x42>
        l++;
      3e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
      if(strchr(" \r\t\n\v", buf[i]))
      42:	8b 45 f4             	mov    -0xc(%ebp),%eax
      45:	05 a0 e6 01 00       	add    $0x1e6a0,%eax
      4a:	0f b6 00             	movzbl (%eax),%eax
      4d:	0f be c0             	movsbl %al,%eax
      50:	83 ec 08             	sub    $0x8,%esp
      53:	50                   	push   %eax
      54:	68 00 5f 01 00       	push   $0x15f00
      59:	e8 35 02 00 00       	call   293 <strchr>
      5e:	83 c4 10             	add    $0x10,%esp
      61:	85 c0                	test   %eax,%eax
      63:	74 09                	je     6e <wc+0x6e>
        inword = 0;
      65:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
      6c:	eb 11                	jmp    7f <wc+0x7f>
      else if(!inword){
      6e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
      72:	75 0b                	jne    7f <wc+0x7f>
        w++;
      74:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        inword = 1;
      78:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  int l, w, c, inword;

  l = w = c = 0;
  inword = 0;
  while((n = read(fd, buf, sizeof(buf))) > 0){
    for(i=0; i<n; i++){
      7f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      83:	8b 45 f4             	mov    -0xc(%ebp),%eax
      86:	3b 45 e0             	cmp    -0x20(%ebp),%eax
      89:	7c a0                	jl     2b <wc+0x2b>
  int i, n;
  int l, w, c, inword;

  l = w = c = 0;
  inword = 0;
  while((n = read(fd, buf, sizeof(buf))) > 0){
      8b:	83 ec 04             	sub    $0x4,%esp
      8e:	68 00 02 00 00       	push   $0x200
      93:	68 a0 e6 01 00       	push   $0x1e6a0
      98:	ff 75 08             	pushl  0x8(%ebp)
      9b:	e8 8c 03 00 00       	call   42c <read>
      a0:	83 c4 10             	add    $0x10,%esp
      a3:	89 45 e0             	mov    %eax,-0x20(%ebp)
      a6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
      aa:	0f 8f 72 ff ff ff    	jg     22 <wc+0x22>
        w++;
        inword = 1;
      }
    }
  }
  if(n < 0){
      b0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
      b4:	79 17                	jns    cd <wc+0xcd>
    printf(1, "wc: read error\n");
      b6:	83 ec 08             	sub    $0x8,%esp
      b9:	68 06 5f 01 00       	push   $0x15f06
      be:	6a 01                	push   $0x1
      c0:	e8 f6 04 00 00       	call   5bb <printf>
      c5:	83 c4 10             	add    $0x10,%esp
    exit();
      c8:	e8 47 03 00 00       	call   414 <exit>
  }
  printf(1, "%d %d %d %s\n", l, w, c, name);
      cd:	83 ec 08             	sub    $0x8,%esp
      d0:	ff 75 0c             	pushl  0xc(%ebp)
      d3:	ff 75 e8             	pushl  -0x18(%ebp)
      d6:	ff 75 ec             	pushl  -0x14(%ebp)
      d9:	ff 75 f0             	pushl  -0x10(%ebp)
      dc:	68 16 5f 01 00       	push   $0x15f16
      e1:	6a 01                	push   $0x1
      e3:	e8 d3 04 00 00       	call   5bb <printf>
      e8:	83 c4 20             	add    $0x20,%esp
}
      eb:	90                   	nop
      ec:	c9                   	leave  
      ed:	c3                   	ret    

000000ee <main>:

int
main(int argc, char *argv[])
{
      ee:	8d 4c 24 04          	lea    0x4(%esp),%ecx
      f2:	83 e4 f0             	and    $0xfffffff0,%esp
      f5:	ff 71 fc             	pushl  -0x4(%ecx)
      f8:	55                   	push   %ebp
      f9:	89 e5                	mov    %esp,%ebp
      fb:	53                   	push   %ebx
      fc:	51                   	push   %ecx
      fd:	83 ec 10             	sub    $0x10,%esp
     100:	89 cb                	mov    %ecx,%ebx
  int fd, i;

  if(argc <= 1){
     102:	83 3b 01             	cmpl   $0x1,(%ebx)
     105:	7f 17                	jg     11e <main+0x30>
    wc(0, "");
     107:	83 ec 08             	sub    $0x8,%esp
     10a:	68 23 5f 01 00       	push   $0x15f23
     10f:	6a 00                	push   $0x0
     111:	e8 ea fe ff ff       	call   0 <wc>
     116:	83 c4 10             	add    $0x10,%esp
    exit();
     119:	e8 f6 02 00 00       	call   414 <exit>
  }

  for(i = 1; i < argc; i++){
     11e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
     125:	e9 83 00 00 00       	jmp    1ad <main+0xbf>
    if((fd = open(argv[i], 0)) < 0){
     12a:	8b 45 f4             	mov    -0xc(%ebp),%eax
     12d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
     134:	8b 43 04             	mov    0x4(%ebx),%eax
     137:	01 d0                	add    %edx,%eax
     139:	8b 00                	mov    (%eax),%eax
     13b:	83 ec 08             	sub    $0x8,%esp
     13e:	6a 00                	push   $0x0
     140:	50                   	push   %eax
     141:	e8 0e 03 00 00       	call   454 <open>
     146:	83 c4 10             	add    $0x10,%esp
     149:	89 45 f0             	mov    %eax,-0x10(%ebp)
     14c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     150:	79 29                	jns    17b <main+0x8d>
      printf(1, "wc: cannot open %s\n", argv[i]);
     152:	8b 45 f4             	mov    -0xc(%ebp),%eax
     155:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
     15c:	8b 43 04             	mov    0x4(%ebx),%eax
     15f:	01 d0                	add    %edx,%eax
     161:	8b 00                	mov    (%eax),%eax
     163:	83 ec 04             	sub    $0x4,%esp
     166:	50                   	push   %eax
     167:	68 24 5f 01 00       	push   $0x15f24
     16c:	6a 01                	push   $0x1
     16e:	e8 48 04 00 00       	call   5bb <printf>
     173:	83 c4 10             	add    $0x10,%esp
      exit();
     176:	e8 99 02 00 00       	call   414 <exit>
    }
    wc(fd, argv[i]);
     17b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     17e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
     185:	8b 43 04             	mov    0x4(%ebx),%eax
     188:	01 d0                	add    %edx,%eax
     18a:	8b 00                	mov    (%eax),%eax
     18c:	83 ec 08             	sub    $0x8,%esp
     18f:	50                   	push   %eax
     190:	ff 75 f0             	pushl  -0x10(%ebp)
     193:	e8 68 fe ff ff       	call   0 <wc>
     198:	83 c4 10             	add    $0x10,%esp
    close(fd);
     19b:	83 ec 0c             	sub    $0xc,%esp
     19e:	ff 75 f0             	pushl  -0x10(%ebp)
     1a1:	e8 96 02 00 00       	call   43c <close>
     1a6:	83 c4 10             	add    $0x10,%esp
  if(argc <= 1){
    wc(0, "");
    exit();
  }

  for(i = 1; i < argc; i++){
     1a9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     1ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
     1b0:	3b 03                	cmp    (%ebx),%eax
     1b2:	0f 8c 72 ff ff ff    	jl     12a <main+0x3c>
      exit();
    }
    wc(fd, argv[i]);
    close(fd);
  }
  exit();
     1b8:	e8 57 02 00 00       	call   414 <exit>

000001bd <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
     1bd:	55                   	push   %ebp
     1be:	89 e5                	mov    %esp,%ebp
     1c0:	57                   	push   %edi
     1c1:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
     1c2:	8b 4d 08             	mov    0x8(%ebp),%ecx
     1c5:	8b 55 10             	mov    0x10(%ebp),%edx
     1c8:	8b 45 0c             	mov    0xc(%ebp),%eax
     1cb:	89 cb                	mov    %ecx,%ebx
     1cd:	89 df                	mov    %ebx,%edi
     1cf:	89 d1                	mov    %edx,%ecx
     1d1:	fc                   	cld    
     1d2:	f3 aa                	rep stos %al,%es:(%edi)
     1d4:	89 ca                	mov    %ecx,%edx
     1d6:	89 fb                	mov    %edi,%ebx
     1d8:	89 5d 08             	mov    %ebx,0x8(%ebp)
     1db:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
     1de:	90                   	nop
     1df:	5b                   	pop    %ebx
     1e0:	5f                   	pop    %edi
     1e1:	5d                   	pop    %ebp
     1e2:	c3                   	ret    

000001e3 <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
     1e3:	55                   	push   %ebp
     1e4:	89 e5                	mov    %esp,%ebp
     1e6:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
     1e9:	8b 45 08             	mov    0x8(%ebp),%eax
     1ec:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
     1ef:	90                   	nop
     1f0:	8b 45 08             	mov    0x8(%ebp),%eax
     1f3:	8d 50 01             	lea    0x1(%eax),%edx
     1f6:	89 55 08             	mov    %edx,0x8(%ebp)
     1f9:	8b 55 0c             	mov    0xc(%ebp),%edx
     1fc:	8d 4a 01             	lea    0x1(%edx),%ecx
     1ff:	89 4d 0c             	mov    %ecx,0xc(%ebp)
     202:	0f b6 12             	movzbl (%edx),%edx
     205:	88 10                	mov    %dl,(%eax)
     207:	0f b6 00             	movzbl (%eax),%eax
     20a:	84 c0                	test   %al,%al
     20c:	75 e2                	jne    1f0 <strcpy+0xd>
    ;
  return os;
     20e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     211:	c9                   	leave  
     212:	c3                   	ret    

00000213 <strcmp>:

int
strcmp(const char *p, const char *q)
{
     213:	55                   	push   %ebp
     214:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
     216:	eb 08                	jmp    220 <strcmp+0xd>
    p++, q++;
     218:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     21c:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
     220:	8b 45 08             	mov    0x8(%ebp),%eax
     223:	0f b6 00             	movzbl (%eax),%eax
     226:	84 c0                	test   %al,%al
     228:	74 10                	je     23a <strcmp+0x27>
     22a:	8b 45 08             	mov    0x8(%ebp),%eax
     22d:	0f b6 10             	movzbl (%eax),%edx
     230:	8b 45 0c             	mov    0xc(%ebp),%eax
     233:	0f b6 00             	movzbl (%eax),%eax
     236:	38 c2                	cmp    %al,%dl
     238:	74 de                	je     218 <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
     23a:	8b 45 08             	mov    0x8(%ebp),%eax
     23d:	0f b6 00             	movzbl (%eax),%eax
     240:	0f b6 d0             	movzbl %al,%edx
     243:	8b 45 0c             	mov    0xc(%ebp),%eax
     246:	0f b6 00             	movzbl (%eax),%eax
     249:	0f b6 c0             	movzbl %al,%eax
     24c:	29 c2                	sub    %eax,%edx
     24e:	89 d0                	mov    %edx,%eax
}
     250:	5d                   	pop    %ebp
     251:	c3                   	ret    

00000252 <strlen>:

uint
strlen(char *s)
{
     252:	55                   	push   %ebp
     253:	89 e5                	mov    %esp,%ebp
     255:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
     258:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     25f:	eb 04                	jmp    265 <strlen+0x13>
     261:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
     265:	8b 55 fc             	mov    -0x4(%ebp),%edx
     268:	8b 45 08             	mov    0x8(%ebp),%eax
     26b:	01 d0                	add    %edx,%eax
     26d:	0f b6 00             	movzbl (%eax),%eax
     270:	84 c0                	test   %al,%al
     272:	75 ed                	jne    261 <strlen+0xf>
    ;
  return n;
     274:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     277:	c9                   	leave  
     278:	c3                   	ret    

00000279 <memset>:

void*
memset(void *dst, int c, uint n)
{
     279:	55                   	push   %ebp
     27a:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
     27c:	8b 45 10             	mov    0x10(%ebp),%eax
     27f:	50                   	push   %eax
     280:	ff 75 0c             	pushl  0xc(%ebp)
     283:	ff 75 08             	pushl  0x8(%ebp)
     286:	e8 32 ff ff ff       	call   1bd <stosb>
     28b:	83 c4 0c             	add    $0xc,%esp
  return dst;
     28e:	8b 45 08             	mov    0x8(%ebp),%eax
}
     291:	c9                   	leave  
     292:	c3                   	ret    

00000293 <strchr>:

char*
strchr(const char *s, char c)
{
     293:	55                   	push   %ebp
     294:	89 e5                	mov    %esp,%ebp
     296:	83 ec 04             	sub    $0x4,%esp
     299:	8b 45 0c             	mov    0xc(%ebp),%eax
     29c:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     29f:	eb 14                	jmp    2b5 <strchr+0x22>
    if(*s == c)
     2a1:	8b 45 08             	mov    0x8(%ebp),%eax
     2a4:	0f b6 00             	movzbl (%eax),%eax
     2a7:	3a 45 fc             	cmp    -0x4(%ebp),%al
     2aa:	75 05                	jne    2b1 <strchr+0x1e>
      return (char*)s;
     2ac:	8b 45 08             	mov    0x8(%ebp),%eax
     2af:	eb 13                	jmp    2c4 <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     2b1:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     2b5:	8b 45 08             	mov    0x8(%ebp),%eax
     2b8:	0f b6 00             	movzbl (%eax),%eax
     2bb:	84 c0                	test   %al,%al
     2bd:	75 e2                	jne    2a1 <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     2bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
     2c4:	c9                   	leave  
     2c5:	c3                   	ret    

000002c6 <gets>:

char*
gets(char *buf, int max)
{
     2c6:	55                   	push   %ebp
     2c7:	89 e5                	mov    %esp,%ebp
     2c9:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     2cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     2d3:	eb 42                	jmp    317 <gets+0x51>
    cc = read(0, &c, 1);
     2d5:	83 ec 04             	sub    $0x4,%esp
     2d8:	6a 01                	push   $0x1
     2da:	8d 45 ef             	lea    -0x11(%ebp),%eax
     2dd:	50                   	push   %eax
     2de:	6a 00                	push   $0x0
     2e0:	e8 47 01 00 00       	call   42c <read>
     2e5:	83 c4 10             	add    $0x10,%esp
     2e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     2eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     2ef:	7e 33                	jle    324 <gets+0x5e>
      break;
    buf[i++] = c;
     2f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
     2f4:	8d 50 01             	lea    0x1(%eax),%edx
     2f7:	89 55 f4             	mov    %edx,-0xc(%ebp)
     2fa:	89 c2                	mov    %eax,%edx
     2fc:	8b 45 08             	mov    0x8(%ebp),%eax
     2ff:	01 c2                	add    %eax,%edx
     301:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     305:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     307:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     30b:	3c 0a                	cmp    $0xa,%al
     30d:	74 16                	je     325 <gets+0x5f>
     30f:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     313:	3c 0d                	cmp    $0xd,%al
     315:	74 0e                	je     325 <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     317:	8b 45 f4             	mov    -0xc(%ebp),%eax
     31a:	83 c0 01             	add    $0x1,%eax
     31d:	3b 45 0c             	cmp    0xc(%ebp),%eax
     320:	7c b3                	jl     2d5 <gets+0xf>
     322:	eb 01                	jmp    325 <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     324:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     325:	8b 55 f4             	mov    -0xc(%ebp),%edx
     328:	8b 45 08             	mov    0x8(%ebp),%eax
     32b:	01 d0                	add    %edx,%eax
     32d:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     330:	8b 45 08             	mov    0x8(%ebp),%eax
}
     333:	c9                   	leave  
     334:	c3                   	ret    

00000335 <stat>:

int
stat(char *n, struct stat *st)
{
     335:	55                   	push   %ebp
     336:	89 e5                	mov    %esp,%ebp
     338:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     33b:	83 ec 08             	sub    $0x8,%esp
     33e:	6a 00                	push   $0x0
     340:	ff 75 08             	pushl  0x8(%ebp)
     343:	e8 0c 01 00 00       	call   454 <open>
     348:	83 c4 10             	add    $0x10,%esp
     34b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     34e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     352:	79 07                	jns    35b <stat+0x26>
    return -1;
     354:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     359:	eb 25                	jmp    380 <stat+0x4b>
  r = fstat(fd, st);
     35b:	83 ec 08             	sub    $0x8,%esp
     35e:	ff 75 0c             	pushl  0xc(%ebp)
     361:	ff 75 f4             	pushl  -0xc(%ebp)
     364:	e8 03 01 00 00       	call   46c <fstat>
     369:	83 c4 10             	add    $0x10,%esp
     36c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     36f:	83 ec 0c             	sub    $0xc,%esp
     372:	ff 75 f4             	pushl  -0xc(%ebp)
     375:	e8 c2 00 00 00       	call   43c <close>
     37a:	83 c4 10             	add    $0x10,%esp
  return r;
     37d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     380:	c9                   	leave  
     381:	c3                   	ret    

00000382 <atoi>:

int
atoi(const char *s)
{
     382:	55                   	push   %ebp
     383:	89 e5                	mov    %esp,%ebp
     385:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     388:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     38f:	eb 25                	jmp    3b6 <atoi+0x34>
    n = n*10 + *s++ - '0';
     391:	8b 55 fc             	mov    -0x4(%ebp),%edx
     394:	89 d0                	mov    %edx,%eax
     396:	c1 e0 02             	shl    $0x2,%eax
     399:	01 d0                	add    %edx,%eax
     39b:	01 c0                	add    %eax,%eax
     39d:	89 c1                	mov    %eax,%ecx
     39f:	8b 45 08             	mov    0x8(%ebp),%eax
     3a2:	8d 50 01             	lea    0x1(%eax),%edx
     3a5:	89 55 08             	mov    %edx,0x8(%ebp)
     3a8:	0f b6 00             	movzbl (%eax),%eax
     3ab:	0f be c0             	movsbl %al,%eax
     3ae:	01 c8                	add    %ecx,%eax
     3b0:	83 e8 30             	sub    $0x30,%eax
     3b3:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     3b6:	8b 45 08             	mov    0x8(%ebp),%eax
     3b9:	0f b6 00             	movzbl (%eax),%eax
     3bc:	3c 2f                	cmp    $0x2f,%al
     3be:	7e 0a                	jle    3ca <atoi+0x48>
     3c0:	8b 45 08             	mov    0x8(%ebp),%eax
     3c3:	0f b6 00             	movzbl (%eax),%eax
     3c6:	3c 39                	cmp    $0x39,%al
     3c8:	7e c7                	jle    391 <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     3ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     3cd:	c9                   	leave  
     3ce:	c3                   	ret    

000003cf <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     3cf:	55                   	push   %ebp
     3d0:	89 e5                	mov    %esp,%ebp
     3d2:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     3d5:	8b 45 08             	mov    0x8(%ebp),%eax
     3d8:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     3db:	8b 45 0c             	mov    0xc(%ebp),%eax
     3de:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     3e1:	eb 17                	jmp    3fa <memmove+0x2b>
    *dst++ = *src++;
     3e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
     3e6:	8d 50 01             	lea    0x1(%eax),%edx
     3e9:	89 55 fc             	mov    %edx,-0x4(%ebp)
     3ec:	8b 55 f8             	mov    -0x8(%ebp),%edx
     3ef:	8d 4a 01             	lea    0x1(%edx),%ecx
     3f2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     3f5:	0f b6 12             	movzbl (%edx),%edx
     3f8:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     3fa:	8b 45 10             	mov    0x10(%ebp),%eax
     3fd:	8d 50 ff             	lea    -0x1(%eax),%edx
     400:	89 55 10             	mov    %edx,0x10(%ebp)
     403:	85 c0                	test   %eax,%eax
     405:	7f dc                	jg     3e3 <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     407:	8b 45 08             	mov    0x8(%ebp),%eax
}
     40a:	c9                   	leave  
     40b:	c3                   	ret    

0000040c <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     40c:	b8 01 00 00 00       	mov    $0x1,%eax
     411:	cd 40                	int    $0x40
     413:	c3                   	ret    

00000414 <exit>:
SYSCALL(exit)
     414:	b8 02 00 00 00       	mov    $0x2,%eax
     419:	cd 40                	int    $0x40
     41b:	c3                   	ret    

0000041c <wait>:
SYSCALL(wait)
     41c:	b8 03 00 00 00       	mov    $0x3,%eax
     421:	cd 40                	int    $0x40
     423:	c3                   	ret    

00000424 <pipe>:
SYSCALL(pipe)
     424:	b8 04 00 00 00       	mov    $0x4,%eax
     429:	cd 40                	int    $0x40
     42b:	c3                   	ret    

0000042c <read>:
SYSCALL(read)
     42c:	b8 05 00 00 00       	mov    $0x5,%eax
     431:	cd 40                	int    $0x40
     433:	c3                   	ret    

00000434 <write>:
SYSCALL(write)
     434:	b8 10 00 00 00       	mov    $0x10,%eax
     439:	cd 40                	int    $0x40
     43b:	c3                   	ret    

0000043c <close>:
SYSCALL(close)
     43c:	b8 15 00 00 00       	mov    $0x15,%eax
     441:	cd 40                	int    $0x40
     443:	c3                   	ret    

00000444 <kill>:
SYSCALL(kill)
     444:	b8 06 00 00 00       	mov    $0x6,%eax
     449:	cd 40                	int    $0x40
     44b:	c3                   	ret    

0000044c <exec>:
SYSCALL(exec)
     44c:	b8 07 00 00 00       	mov    $0x7,%eax
     451:	cd 40                	int    $0x40
     453:	c3                   	ret    

00000454 <open>:
SYSCALL(open)
     454:	b8 0f 00 00 00       	mov    $0xf,%eax
     459:	cd 40                	int    $0x40
     45b:	c3                   	ret    

0000045c <mknod>:
SYSCALL(mknod)
     45c:	b8 11 00 00 00       	mov    $0x11,%eax
     461:	cd 40                	int    $0x40
     463:	c3                   	ret    

00000464 <unlink>:
SYSCALL(unlink)
     464:	b8 12 00 00 00       	mov    $0x12,%eax
     469:	cd 40                	int    $0x40
     46b:	c3                   	ret    

0000046c <fstat>:
SYSCALL(fstat)
     46c:	b8 08 00 00 00       	mov    $0x8,%eax
     471:	cd 40                	int    $0x40
     473:	c3                   	ret    

00000474 <link>:
SYSCALL(link)
     474:	b8 13 00 00 00       	mov    $0x13,%eax
     479:	cd 40                	int    $0x40
     47b:	c3                   	ret    

0000047c <mkdir>:
SYSCALL(mkdir)
     47c:	b8 14 00 00 00       	mov    $0x14,%eax
     481:	cd 40                	int    $0x40
     483:	c3                   	ret    

00000484 <chdir>:
SYSCALL(chdir)
     484:	b8 09 00 00 00       	mov    $0x9,%eax
     489:	cd 40                	int    $0x40
     48b:	c3                   	ret    

0000048c <dup>:
SYSCALL(dup)
     48c:	b8 0a 00 00 00       	mov    $0xa,%eax
     491:	cd 40                	int    $0x40
     493:	c3                   	ret    

00000494 <getpid>:
SYSCALL(getpid)
     494:	b8 0b 00 00 00       	mov    $0xb,%eax
     499:	cd 40                	int    $0x40
     49b:	c3                   	ret    

0000049c <sbrk>:
SYSCALL(sbrk)
     49c:	b8 0c 00 00 00       	mov    $0xc,%eax
     4a1:	cd 40                	int    $0x40
     4a3:	c3                   	ret    

000004a4 <sleep>:
SYSCALL(sleep)
     4a4:	b8 0d 00 00 00       	mov    $0xd,%eax
     4a9:	cd 40                	int    $0x40
     4ab:	c3                   	ret    

000004ac <uptime>:
SYSCALL(uptime)
     4ac:	b8 0e 00 00 00       	mov    $0xe,%eax
     4b1:	cd 40                	int    $0x40
     4b3:	c3                   	ret    

000004b4 <createwindow>:
SYSCALL(createwindow)
     4b4:	b8 16 00 00 00       	mov    $0x16,%eax
     4b9:	cd 40                	int    $0x40
     4bb:	c3                   	ret    

000004bc <repaintwindow>:
SYSCALL(repaintwindow)
     4bc:	b8 17 00 00 00       	mov    $0x17,%eax
     4c1:	cd 40                	int    $0x40
     4c3:	c3                   	ret    

000004c4 <getmessage>:
SYSCALL(getmessage)
     4c4:	b8 18 00 00 00       	mov    $0x18,%eax
     4c9:	cd 40                	int    $0x40
     4cb:	c3                   	ret    

000004cc <settimer>:
SYSCALL(settimer)
     4cc:	b8 19 00 00 00       	mov    $0x19,%eax
     4d1:	cd 40                	int    $0x40
     4d3:	c3                   	ret    

000004d4 <updatewindow>:
SYSCALL(updatewindow)
     4d4:	b8 1a 00 00 00       	mov    $0x1a,%eax
     4d9:	cd 40                	int    $0x40
     4db:	c3                   	ret    

000004dc <destroywindow>:
SYSCALL(destroywindow)
     4dc:	b8 1b 00 00 00       	mov    $0x1b,%eax
     4e1:	cd 40                	int    $0x40
     4e3:	c3                   	ret    

000004e4 <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     4e4:	55                   	push   %ebp
     4e5:	89 e5                	mov    %esp,%ebp
     4e7:	83 ec 18             	sub    $0x18,%esp
     4ea:	8b 45 0c             	mov    0xc(%ebp),%eax
     4ed:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     4f0:	83 ec 04             	sub    $0x4,%esp
     4f3:	6a 01                	push   $0x1
     4f5:	8d 45 f4             	lea    -0xc(%ebp),%eax
     4f8:	50                   	push   %eax
     4f9:	ff 75 08             	pushl  0x8(%ebp)
     4fc:	e8 33 ff ff ff       	call   434 <write>
     501:	83 c4 10             	add    $0x10,%esp
}
     504:	90                   	nop
     505:	c9                   	leave  
     506:	c3                   	ret    

00000507 <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     507:	55                   	push   %ebp
     508:	89 e5                	mov    %esp,%ebp
     50a:	53                   	push   %ebx
     50b:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     50e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     515:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     519:	74 17                	je     532 <printint+0x2b>
     51b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     51f:	79 11                	jns    532 <printint+0x2b>
    neg = 1;
     521:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     528:	8b 45 0c             	mov    0xc(%ebp),%eax
     52b:	f7 d8                	neg    %eax
     52d:	89 45 ec             	mov    %eax,-0x14(%ebp)
     530:	eb 06                	jmp    538 <printint+0x31>
  } else {
    x = xx;
     532:	8b 45 0c             	mov    0xc(%ebp),%eax
     535:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     538:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     53f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     542:	8d 41 01             	lea    0x1(%ecx),%eax
     545:	89 45 f4             	mov    %eax,-0xc(%ebp)
     548:	8b 5d 10             	mov    0x10(%ebp),%ebx
     54b:	8b 45 ec             	mov    -0x14(%ebp),%eax
     54e:	ba 00 00 00 00       	mov    $0x0,%edx
     553:	f7 f3                	div    %ebx
     555:	89 d0                	mov    %edx,%eax
     557:	0f b6 80 40 e2 01 00 	movzbl 0x1e240(%eax),%eax
     55e:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     562:	8b 5d 10             	mov    0x10(%ebp),%ebx
     565:	8b 45 ec             	mov    -0x14(%ebp),%eax
     568:	ba 00 00 00 00       	mov    $0x0,%edx
     56d:	f7 f3                	div    %ebx
     56f:	89 45 ec             	mov    %eax,-0x14(%ebp)
     572:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     576:	75 c7                	jne    53f <printint+0x38>
  if(neg)
     578:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     57c:	74 2d                	je     5ab <printint+0xa4>
    buf[i++] = '-';
     57e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     581:	8d 50 01             	lea    0x1(%eax),%edx
     584:	89 55 f4             	mov    %edx,-0xc(%ebp)
     587:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     58c:	eb 1d                	jmp    5ab <printint+0xa4>
    putc(fd, buf[i]);
     58e:	8d 55 dc             	lea    -0x24(%ebp),%edx
     591:	8b 45 f4             	mov    -0xc(%ebp),%eax
     594:	01 d0                	add    %edx,%eax
     596:	0f b6 00             	movzbl (%eax),%eax
     599:	0f be c0             	movsbl %al,%eax
     59c:	83 ec 08             	sub    $0x8,%esp
     59f:	50                   	push   %eax
     5a0:	ff 75 08             	pushl  0x8(%ebp)
     5a3:	e8 3c ff ff ff       	call   4e4 <putc>
     5a8:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     5ab:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     5af:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     5b3:	79 d9                	jns    58e <printint+0x87>
    putc(fd, buf[i]);
}
     5b5:	90                   	nop
     5b6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     5b9:	c9                   	leave  
     5ba:	c3                   	ret    

000005bb <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     5bb:	55                   	push   %ebp
     5bc:	89 e5                	mov    %esp,%ebp
     5be:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     5c1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
     5c8:	8d 45 0c             	lea    0xc(%ebp),%eax
     5cb:	83 c0 04             	add    $0x4,%eax
     5ce:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
     5d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     5d8:	e9 59 01 00 00       	jmp    736 <printf+0x17b>
    c = fmt[i] & 0xff;
     5dd:	8b 55 0c             	mov    0xc(%ebp),%edx
     5e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
     5e3:	01 d0                	add    %edx,%eax
     5e5:	0f b6 00             	movzbl (%eax),%eax
     5e8:	0f be c0             	movsbl %al,%eax
     5eb:	25 ff 00 00 00       	and    $0xff,%eax
     5f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
     5f3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     5f7:	75 2c                	jne    625 <printf+0x6a>
      if(c == '%'){
     5f9:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     5fd:	75 0c                	jne    60b <printf+0x50>
        state = '%';
     5ff:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
     606:	e9 27 01 00 00       	jmp    732 <printf+0x177>
      } else {
        putc(fd, c);
     60b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     60e:	0f be c0             	movsbl %al,%eax
     611:	83 ec 08             	sub    $0x8,%esp
     614:	50                   	push   %eax
     615:	ff 75 08             	pushl  0x8(%ebp)
     618:	e8 c7 fe ff ff       	call   4e4 <putc>
     61d:	83 c4 10             	add    $0x10,%esp
     620:	e9 0d 01 00 00       	jmp    732 <printf+0x177>
      }
    } else if(state == '%'){
     625:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
     629:	0f 85 03 01 00 00    	jne    732 <printf+0x177>
      if(c == 'd'){
     62f:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
     633:	75 1e                	jne    653 <printf+0x98>
        printint(fd, *ap, 10, 1);
     635:	8b 45 e8             	mov    -0x18(%ebp),%eax
     638:	8b 00                	mov    (%eax),%eax
     63a:	6a 01                	push   $0x1
     63c:	6a 0a                	push   $0xa
     63e:	50                   	push   %eax
     63f:	ff 75 08             	pushl  0x8(%ebp)
     642:	e8 c0 fe ff ff       	call   507 <printint>
     647:	83 c4 10             	add    $0x10,%esp
        ap++;
     64a:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     64e:	e9 d8 00 00 00       	jmp    72b <printf+0x170>
      } else if(c == 'x' || c == 'p'){
     653:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
     657:	74 06                	je     65f <printf+0xa4>
     659:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
     65d:	75 1e                	jne    67d <printf+0xc2>
        printint(fd, *ap, 16, 0);
     65f:	8b 45 e8             	mov    -0x18(%ebp),%eax
     662:	8b 00                	mov    (%eax),%eax
     664:	6a 00                	push   $0x0
     666:	6a 10                	push   $0x10
     668:	50                   	push   %eax
     669:	ff 75 08             	pushl  0x8(%ebp)
     66c:	e8 96 fe ff ff       	call   507 <printint>
     671:	83 c4 10             	add    $0x10,%esp
        ap++;
     674:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     678:	e9 ae 00 00 00       	jmp    72b <printf+0x170>
      } else if(c == 's'){
     67d:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
     681:	75 43                	jne    6c6 <printf+0x10b>
        s = (char*)*ap;
     683:	8b 45 e8             	mov    -0x18(%ebp),%eax
     686:	8b 00                	mov    (%eax),%eax
     688:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
     68b:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
     68f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     693:	75 25                	jne    6ba <printf+0xff>
          s = "(null)";
     695:	c7 45 f4 38 5f 01 00 	movl   $0x15f38,-0xc(%ebp)
        while(*s != 0){
     69c:	eb 1c                	jmp    6ba <printf+0xff>
          putc(fd, *s);
     69e:	8b 45 f4             	mov    -0xc(%ebp),%eax
     6a1:	0f b6 00             	movzbl (%eax),%eax
     6a4:	0f be c0             	movsbl %al,%eax
     6a7:	83 ec 08             	sub    $0x8,%esp
     6aa:	50                   	push   %eax
     6ab:	ff 75 08             	pushl  0x8(%ebp)
     6ae:	e8 31 fe ff ff       	call   4e4 <putc>
     6b3:	83 c4 10             	add    $0x10,%esp
          s++;
     6b6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
     6ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
     6bd:	0f b6 00             	movzbl (%eax),%eax
     6c0:	84 c0                	test   %al,%al
     6c2:	75 da                	jne    69e <printf+0xe3>
     6c4:	eb 65                	jmp    72b <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
     6c6:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
     6ca:	75 1d                	jne    6e9 <printf+0x12e>
        putc(fd, *ap);
     6cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
     6cf:	8b 00                	mov    (%eax),%eax
     6d1:	0f be c0             	movsbl %al,%eax
     6d4:	83 ec 08             	sub    $0x8,%esp
     6d7:	50                   	push   %eax
     6d8:	ff 75 08             	pushl  0x8(%ebp)
     6db:	e8 04 fe ff ff       	call   4e4 <putc>
     6e0:	83 c4 10             	add    $0x10,%esp
        ap++;
     6e3:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     6e7:	eb 42                	jmp    72b <printf+0x170>
      } else if(c == '%'){
     6e9:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     6ed:	75 17                	jne    706 <printf+0x14b>
        putc(fd, c);
     6ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     6f2:	0f be c0             	movsbl %al,%eax
     6f5:	83 ec 08             	sub    $0x8,%esp
     6f8:	50                   	push   %eax
     6f9:	ff 75 08             	pushl  0x8(%ebp)
     6fc:	e8 e3 fd ff ff       	call   4e4 <putc>
     701:	83 c4 10             	add    $0x10,%esp
     704:	eb 25                	jmp    72b <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
     706:	83 ec 08             	sub    $0x8,%esp
     709:	6a 25                	push   $0x25
     70b:	ff 75 08             	pushl  0x8(%ebp)
     70e:	e8 d1 fd ff ff       	call   4e4 <putc>
     713:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
     716:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     719:	0f be c0             	movsbl %al,%eax
     71c:	83 ec 08             	sub    $0x8,%esp
     71f:	50                   	push   %eax
     720:	ff 75 08             	pushl  0x8(%ebp)
     723:	e8 bc fd ff ff       	call   4e4 <putc>
     728:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
     72b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
     732:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     736:	8b 55 0c             	mov    0xc(%ebp),%edx
     739:	8b 45 f0             	mov    -0x10(%ebp),%eax
     73c:	01 d0                	add    %edx,%eax
     73e:	0f b6 00             	movzbl (%eax),%eax
     741:	84 c0                	test   %al,%al
     743:	0f 85 94 fe ff ff    	jne    5dd <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
     749:	90                   	nop
     74a:	c9                   	leave  
     74b:	c3                   	ret    

0000074c <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
     74c:	55                   	push   %ebp
     74d:	89 e5                	mov    %esp,%ebp
     74f:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
     752:	8b 45 08             	mov    0x8(%ebp),%eax
     755:	83 e8 08             	sub    $0x8,%eax
     758:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     75b:	a1 88 e6 01 00       	mov    0x1e688,%eax
     760:	89 45 fc             	mov    %eax,-0x4(%ebp)
     763:	eb 24                	jmp    789 <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
     765:	8b 45 fc             	mov    -0x4(%ebp),%eax
     768:	8b 00                	mov    (%eax),%eax
     76a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     76d:	77 12                	ja     781 <free+0x35>
     76f:	8b 45 f8             	mov    -0x8(%ebp),%eax
     772:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     775:	77 24                	ja     79b <free+0x4f>
     777:	8b 45 fc             	mov    -0x4(%ebp),%eax
     77a:	8b 00                	mov    (%eax),%eax
     77c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     77f:	77 1a                	ja     79b <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     781:	8b 45 fc             	mov    -0x4(%ebp),%eax
     784:	8b 00                	mov    (%eax),%eax
     786:	89 45 fc             	mov    %eax,-0x4(%ebp)
     789:	8b 45 f8             	mov    -0x8(%ebp),%eax
     78c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     78f:	76 d4                	jbe    765 <free+0x19>
     791:	8b 45 fc             	mov    -0x4(%ebp),%eax
     794:	8b 00                	mov    (%eax),%eax
     796:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     799:	76 ca                	jbe    765 <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
     79b:	8b 45 f8             	mov    -0x8(%ebp),%eax
     79e:	8b 40 04             	mov    0x4(%eax),%eax
     7a1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     7a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
     7ab:	01 c2                	add    %eax,%edx
     7ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
     7b0:	8b 00                	mov    (%eax),%eax
     7b2:	39 c2                	cmp    %eax,%edx
     7b4:	75 24                	jne    7da <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
     7b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
     7b9:	8b 50 04             	mov    0x4(%eax),%edx
     7bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
     7bf:	8b 00                	mov    (%eax),%eax
     7c1:	8b 40 04             	mov    0x4(%eax),%eax
     7c4:	01 c2                	add    %eax,%edx
     7c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
     7c9:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
     7cc:	8b 45 fc             	mov    -0x4(%ebp),%eax
     7cf:	8b 00                	mov    (%eax),%eax
     7d1:	8b 10                	mov    (%eax),%edx
     7d3:	8b 45 f8             	mov    -0x8(%ebp),%eax
     7d6:	89 10                	mov    %edx,(%eax)
     7d8:	eb 0a                	jmp    7e4 <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
     7da:	8b 45 fc             	mov    -0x4(%ebp),%eax
     7dd:	8b 10                	mov    (%eax),%edx
     7df:	8b 45 f8             	mov    -0x8(%ebp),%eax
     7e2:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
     7e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
     7e7:	8b 40 04             	mov    0x4(%eax),%eax
     7ea:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     7f1:	8b 45 fc             	mov    -0x4(%ebp),%eax
     7f4:	01 d0                	add    %edx,%eax
     7f6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     7f9:	75 20                	jne    81b <free+0xcf>
    p->s.size += bp->s.size;
     7fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
     7fe:	8b 50 04             	mov    0x4(%eax),%edx
     801:	8b 45 f8             	mov    -0x8(%ebp),%eax
     804:	8b 40 04             	mov    0x4(%eax),%eax
     807:	01 c2                	add    %eax,%edx
     809:	8b 45 fc             	mov    -0x4(%ebp),%eax
     80c:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
     80f:	8b 45 f8             	mov    -0x8(%ebp),%eax
     812:	8b 10                	mov    (%eax),%edx
     814:	8b 45 fc             	mov    -0x4(%ebp),%eax
     817:	89 10                	mov    %edx,(%eax)
     819:	eb 08                	jmp    823 <free+0xd7>
  } else
    p->s.ptr = bp;
     81b:	8b 45 fc             	mov    -0x4(%ebp),%eax
     81e:	8b 55 f8             	mov    -0x8(%ebp),%edx
     821:	89 10                	mov    %edx,(%eax)
  freep = p;
     823:	8b 45 fc             	mov    -0x4(%ebp),%eax
     826:	a3 88 e6 01 00       	mov    %eax,0x1e688
}
     82b:	90                   	nop
     82c:	c9                   	leave  
     82d:	c3                   	ret    

0000082e <morecore>:

static Header*
morecore(uint nu)
{
     82e:	55                   	push   %ebp
     82f:	89 e5                	mov    %esp,%ebp
     831:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
     834:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
     83b:	77 07                	ja     844 <morecore+0x16>
    nu = 4096;
     83d:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
     844:	8b 45 08             	mov    0x8(%ebp),%eax
     847:	c1 e0 03             	shl    $0x3,%eax
     84a:	83 ec 0c             	sub    $0xc,%esp
     84d:	50                   	push   %eax
     84e:	e8 49 fc ff ff       	call   49c <sbrk>
     853:	83 c4 10             	add    $0x10,%esp
     856:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
     859:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     85d:	75 07                	jne    866 <morecore+0x38>
    return 0;
     85f:	b8 00 00 00 00       	mov    $0x0,%eax
     864:	eb 26                	jmp    88c <morecore+0x5e>
  hp = (Header*)p;
     866:	8b 45 f4             	mov    -0xc(%ebp),%eax
     869:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
     86c:	8b 45 f0             	mov    -0x10(%ebp),%eax
     86f:	8b 55 08             	mov    0x8(%ebp),%edx
     872:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
     875:	8b 45 f0             	mov    -0x10(%ebp),%eax
     878:	83 c0 08             	add    $0x8,%eax
     87b:	83 ec 0c             	sub    $0xc,%esp
     87e:	50                   	push   %eax
     87f:	e8 c8 fe ff ff       	call   74c <free>
     884:	83 c4 10             	add    $0x10,%esp
  return freep;
     887:	a1 88 e6 01 00       	mov    0x1e688,%eax
}
     88c:	c9                   	leave  
     88d:	c3                   	ret    

0000088e <malloc>:

void*
malloc(uint nbytes)
{
     88e:	55                   	push   %ebp
     88f:	89 e5                	mov    %esp,%ebp
     891:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
     894:	8b 45 08             	mov    0x8(%ebp),%eax
     897:	83 c0 07             	add    $0x7,%eax
     89a:	c1 e8 03             	shr    $0x3,%eax
     89d:	83 c0 01             	add    $0x1,%eax
     8a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
     8a3:	a1 88 e6 01 00       	mov    0x1e688,%eax
     8a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
     8ab:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     8af:	75 23                	jne    8d4 <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
     8b1:	c7 45 f0 80 e6 01 00 	movl   $0x1e680,-0x10(%ebp)
     8b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
     8bb:	a3 88 e6 01 00       	mov    %eax,0x1e688
     8c0:	a1 88 e6 01 00       	mov    0x1e688,%eax
     8c5:	a3 80 e6 01 00       	mov    %eax,0x1e680
    base.s.size = 0;
     8ca:	c7 05 84 e6 01 00 00 	movl   $0x0,0x1e684
     8d1:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     8d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
     8d7:	8b 00                	mov    (%eax),%eax
     8d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
     8dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8df:	8b 40 04             	mov    0x4(%eax),%eax
     8e2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     8e5:	72 4d                	jb     934 <malloc+0xa6>
      if(p->s.size == nunits)
     8e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8ea:	8b 40 04             	mov    0x4(%eax),%eax
     8ed:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     8f0:	75 0c                	jne    8fe <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
     8f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
     8f5:	8b 10                	mov    (%eax),%edx
     8f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
     8fa:	89 10                	mov    %edx,(%eax)
     8fc:	eb 26                	jmp    924 <malloc+0x96>
      else {
        p->s.size -= nunits;
     8fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
     901:	8b 40 04             	mov    0x4(%eax),%eax
     904:	2b 45 ec             	sub    -0x14(%ebp),%eax
     907:	89 c2                	mov    %eax,%edx
     909:	8b 45 f4             	mov    -0xc(%ebp),%eax
     90c:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
     90f:	8b 45 f4             	mov    -0xc(%ebp),%eax
     912:	8b 40 04             	mov    0x4(%eax),%eax
     915:	c1 e0 03             	shl    $0x3,%eax
     918:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
     91b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     91e:	8b 55 ec             	mov    -0x14(%ebp),%edx
     921:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
     924:	8b 45 f0             	mov    -0x10(%ebp),%eax
     927:	a3 88 e6 01 00       	mov    %eax,0x1e688
      return (void*)(p + 1);
     92c:	8b 45 f4             	mov    -0xc(%ebp),%eax
     92f:	83 c0 08             	add    $0x8,%eax
     932:	eb 3b                	jmp    96f <malloc+0xe1>
    }
    if(p == freep)
     934:	a1 88 e6 01 00       	mov    0x1e688,%eax
     939:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     93c:	75 1e                	jne    95c <malloc+0xce>
      if((p = morecore(nunits)) == 0)
     93e:	83 ec 0c             	sub    $0xc,%esp
     941:	ff 75 ec             	pushl  -0x14(%ebp)
     944:	e8 e5 fe ff ff       	call   82e <morecore>
     949:	83 c4 10             	add    $0x10,%esp
     94c:	89 45 f4             	mov    %eax,-0xc(%ebp)
     94f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     953:	75 07                	jne    95c <malloc+0xce>
        return 0;
     955:	b8 00 00 00 00       	mov    $0x0,%eax
     95a:	eb 13                	jmp    96f <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     95c:	8b 45 f4             	mov    -0xc(%ebp),%eax
     95f:	89 45 f0             	mov    %eax,-0x10(%ebp)
     962:	8b 45 f4             	mov    -0xc(%ebp),%eax
     965:	8b 00                	mov    (%eax),%eax
     967:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
     96a:	e9 6d ff ff ff       	jmp    8dc <malloc+0x4e>
}
     96f:	c9                   	leave  
     970:	c3                   	ret    

00000971 <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
     971:	55                   	push   %ebp
     972:	89 e5                	mov    %esp,%ebp
    ++g_seed;
     974:	a1 8c e6 01 00       	mov    0x1e68c,%eax
     979:	83 c0 01             	add    $0x1,%eax
     97c:	a3 8c e6 01 00       	mov    %eax,0x1e68c
    g_seed = (214013*g_seed+2531011);
     981:	a1 8c e6 01 00       	mov    0x1e68c,%eax
     986:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
     98c:	05 c3 9e 26 00       	add    $0x269ec3,%eax
     991:	a3 8c e6 01 00       	mov    %eax,0x1e68c
    return (g_seed>>16)&0x7FFF;
     996:	a1 8c e6 01 00       	mov    0x1e68c,%eax
     99b:	c1 e8 10             	shr    $0x10,%eax
     99e:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
     9a3:	5d                   	pop    %ebp
     9a4:	c3                   	ret    

000009a5 <abs>:

#define PI 3.1415926536

float abs(float x) 
{
     9a5:	55                   	push   %ebp
     9a6:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
     9a8:	d9 45 08             	flds   0x8(%ebp)
     9ab:	d9 ee                	fldz   
     9ad:	d9 c9                	fxch   %st(1)
     9af:	df e9                	fucomip %st(1),%st
     9b1:	dd d8                	fstp   %st(0)
     9b3:	76 05                	jbe    9ba <abs+0x15>
     9b5:	d9 45 08             	flds   0x8(%ebp)
     9b8:	eb 05                	jmp    9bf <abs+0x1a>
	return -x;
     9ba:	d9 45 08             	flds   0x8(%ebp)
     9bd:	d9 e0                	fchs   
}
     9bf:	5d                   	pop    %ebp
     9c0:	c3                   	ret    

000009c1 <pow>:

float pow(float a, int b)
{
     9c1:	55                   	push   %ebp
     9c2:	89 e5                	mov    %esp,%ebp
     9c4:	83 ec 10             	sub    $0x10,%esp
	float r = a;
     9c7:	d9 45 08             	flds   0x8(%ebp)
     9ca:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
     9cd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     9d1:	7e 17                	jle    9ea <pow+0x29>
		while (--b)
     9d3:	eb 09                	jmp    9de <pow+0x1d>
			r *= a;
     9d5:	d9 45 fc             	flds   -0x4(%ebp)
     9d8:	d8 4d 08             	fmuls  0x8(%ebp)
     9db:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
     9de:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
     9e2:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     9e6:	75 ed                	jne    9d5 <pow+0x14>
     9e8:	eb 2a                	jmp    a14 <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
     9ea:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     9ee:	79 1f                	jns    a0f <pow+0x4e>
		while (++b)
     9f0:	eb 09                	jmp    9fb <pow+0x3a>
			r *= a;
     9f2:	d9 45 fc             	flds   -0x4(%ebp)
     9f5:	d8 4d 08             	fmuls  0x8(%ebp)
     9f8:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
     9fb:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
     9ff:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     a03:	75 ed                	jne    9f2 <pow+0x31>
			r *= a;
		r = 1.0 / r;
     a05:	d9 e8                	fld1   
     a07:	d8 75 fc             	fdivs  -0x4(%ebp)
     a0a:	d9 5d fc             	fstps  -0x4(%ebp)
     a0d:	eb 05                	jmp    a14 <pow+0x53>
	}
	else r = 0;
     a0f:	d9 ee                	fldz   
     a11:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
     a14:	d9 45 fc             	flds   -0x4(%ebp)
}
     a17:	c9                   	leave  
     a18:	c3                   	ret    

00000a19 <sqrt>:

float sqrt(float number) {
     a19:	55                   	push   %ebp
     a1a:	89 e5                	mov    %esp,%ebp
     a1c:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
     a1f:	d9 ee                	fldz   
     a21:	d9 45 08             	flds   0x8(%ebp)
     a24:	d9 c9                	fxch   %st(1)
     a26:	df e9                	fucomip %st(1),%st
     a28:	dd d8                	fstp   %st(0)
     a2a:	76 06                	jbe    a32 <sqrt+0x19>
		return -1;
     a2c:	d9 e8                	fld1   
     a2e:	d9 e0                	fchs   
     a30:	eb 3a                	jmp    a6c <sqrt+0x53>
	}

	new_guess = 1;
     a32:	d9 e8                	fld1   
     a34:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
     a37:	d9 45 fc             	flds   -0x4(%ebp)
     a3a:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
     a3d:	d9 45 08             	flds   0x8(%ebp)
     a40:	d8 75 f8             	fdivs  -0x8(%ebp)
     a43:	d8 45 f8             	fadds  -0x8(%ebp)
     a46:	d9 05 40 5f 01 00    	flds   0x15f40
     a4c:	de f9                	fdivrp %st,%st(1)
     a4e:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
     a51:	d9 45 fc             	flds   -0x4(%ebp)
     a54:	d9 45 f8             	flds   -0x8(%ebp)
     a57:	df e9                	fucomip %st(1),%st
     a59:	dd d8                	fstp   %st(0)
     a5b:	7a da                	jp     a37 <sqrt+0x1e>
     a5d:	d9 45 fc             	flds   -0x4(%ebp)
     a60:	d9 45 f8             	flds   -0x8(%ebp)
     a63:	df e9                	fucomip %st(1),%st
     a65:	dd d8                	fstp   %st(0)
     a67:	75 ce                	jne    a37 <sqrt+0x1e>

	return new_guess;
     a69:	d9 45 fc             	flds   -0x4(%ebp)
}
     a6c:	c9                   	leave  
     a6d:	c3                   	ret    

00000a6e <cos>:

float cos(float x)
{
     a6e:	55                   	push   %ebp
     a6f:	89 e5                	mov    %esp,%ebp
     a71:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     a74:	d9 e8                	fld1   
     a76:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     a79:	d9 45 08             	flds   0x8(%ebp)
     a7c:	dd 05 48 5f 01 00    	fldl   0x15f48
     a82:	d9 c9                	fxch   %st(1)
     a84:	df e9                	fucomip %st(1),%st
     a86:	dd d8                	fstp   %st(0)
     a88:	77 0f                	ja     a99 <cos+0x2b>
     a8a:	d9 45 08             	flds   0x8(%ebp)
     a8d:	dd 05 50 5f 01 00    	fldl   0x15f50
     a93:	df e9                	fucomip %st(1),%st
     a95:	dd d8                	fstp   %st(0)
     a97:	76 3c                	jbe    ad5 <cos+0x67>
     a99:	d9 45 08             	flds   0x8(%ebp)
     a9c:	d9 45 08             	flds   0x8(%ebp)
     a9f:	dd 05 48 5f 01 00    	fldl   0x15f48
     aa5:	de f9                	fdivrp %st,%st(1)
     aa7:	d9 7d e2             	fnstcw -0x1e(%ebp)
     aaa:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     aae:	b4 0c                	mov    $0xc,%ah
     ab0:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     ab4:	d9 6d e0             	fldcw  -0x20(%ebp)
     ab7:	db 5d dc             	fistpl -0x24(%ebp)
     aba:	d9 6d e2             	fldcw  -0x1e(%ebp)
     abd:	8b 45 dc             	mov    -0x24(%ebp),%eax
     ac0:	01 c0                	add    %eax,%eax
     ac2:	89 45 d8             	mov    %eax,-0x28(%ebp)
     ac5:	db 45 d8             	fildl  -0x28(%ebp)
     ac8:	dd 05 58 5f 01 00    	fldl   0x15f58
     ace:	de c9                	fmulp  %st,%st(1)
     ad0:	de e9                	fsubrp %st,%st(1)
     ad2:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     ad5:	d9 45 08             	flds   0x8(%ebp)
     ad8:	dd 05 58 5f 01 00    	fldl   0x15f58
     ade:	d9 c9                	fxch   %st(1)
     ae0:	df e9                	fucomip %st(1),%st
     ae2:	dd d8                	fstp   %st(0)
     ae4:	76 0e                	jbe    af4 <cos+0x86>
     ae6:	d9 45 08             	flds   0x8(%ebp)
     ae9:	dd 05 48 5f 01 00    	fldl   0x15f48
     aef:	de e9                	fsubrp %st,%st(1)
     af1:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     af4:	d9 45 08             	flds   0x8(%ebp)
     af7:	dd 05 60 5f 01 00    	fldl   0x15f60
     afd:	df e9                	fucomip %st(1),%st
     aff:	dd d8                	fstp   %st(0)
     b01:	76 0e                	jbe    b11 <cos+0xa3>
     b03:	d9 45 08             	flds   0x8(%ebp)
     b06:	dd 05 48 5f 01 00    	fldl   0x15f48
     b0c:	de c1                	faddp  %st,%st(1)
     b0e:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     b11:	d9 45 08             	flds   0x8(%ebp)
     b14:	dd 05 68 5f 01 00    	fldl   0x15f68
     b1a:	d9 c9                	fxch   %st(1)
     b1c:	df e9                	fucomip %st(1),%st
     b1e:	dd d8                	fstp   %st(0)
     b20:	76 16                	jbe    b38 <cos+0xca>
    {
        x -= PI;
     b22:	d9 45 08             	flds   0x8(%ebp)
     b25:	dd 05 58 5f 01 00    	fldl   0x15f58
     b2b:	de e9                	fsubrp %st,%st(1)
     b2d:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     b30:	d9 45 f4             	flds   -0xc(%ebp)
     b33:	d9 e0                	fchs   
     b35:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     b38:	d9 45 08             	flds   0x8(%ebp)
     b3b:	dd 05 70 5f 01 00    	fldl   0x15f70
     b41:	df e9                	fucomip %st(1),%st
     b43:	dd d8                	fstp   %st(0)
     b45:	76 16                	jbe    b5d <cos+0xef>
    {
        x += PI;
     b47:	d9 45 08             	flds   0x8(%ebp)
     b4a:	dd 05 58 5f 01 00    	fldl   0x15f58
     b50:	de c1                	faddp  %st,%st(1)
     b52:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     b55:	d9 45 f4             	flds   -0xc(%ebp)
     b58:	d9 e0                	fchs   
     b5a:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
     b5d:	d9 45 08             	flds   0x8(%ebp)
     b60:	dd 05 78 5f 01 00    	fldl   0x15f78
     b66:	d9 c9                	fxch   %st(1)
     b68:	df e9                	fucomip %st(1),%st
     b6a:	dd d8                	fstp   %st(0)
     b6c:	76 28                	jbe    b96 <cos+0x128>
     b6e:	d9 45 08             	flds   0x8(%ebp)
     b71:	dd 05 68 5f 01 00    	fldl   0x15f68
     b77:	de e1                	fsubp  %st,%st(1)
     b79:	d9 5d e4             	fstps  -0x1c(%ebp)
     b7c:	d9 45 e4             	flds   -0x1c(%ebp)
     b7f:	83 ec 0c             	sub    $0xc,%esp
     b82:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     b86:	d9 1c 24             	fstps  (%esp)
     b89:	e8 83 00 00 00       	call   c11 <sin>
     b8e:	83 c4 10             	add    $0x10,%esp
     b91:	d8 4d f4             	fmuls  -0xc(%ebp)
     b94:	eb 79                	jmp    c0f <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
     b96:	83 ec 08             	sub    $0x8,%esp
     b99:	6a 02                	push   $0x2
     b9b:	ff 75 08             	pushl  0x8(%ebp)
     b9e:	e8 1e fe ff ff       	call   9c1 <pow>
     ba3:	83 c4 10             	add    $0x10,%esp
     ba6:	d9 05 40 5f 01 00    	flds   0x15f40
     bac:	de f9                	fdivrp %st,%st(1)
     bae:	d9 e8                	fld1   
     bb0:	de e1                	fsubp  %st,%st(1)
     bb2:	d9 5d d8             	fstps  -0x28(%ebp)
     bb5:	83 ec 08             	sub    $0x8,%esp
     bb8:	6a 04                	push   $0x4
     bba:	ff 75 08             	pushl  0x8(%ebp)
     bbd:	e8 ff fd ff ff       	call   9c1 <pow>
     bc2:	83 c4 10             	add    $0x10,%esp
     bc5:	d9 05 80 5f 01 00    	flds   0x15f80
     bcb:	de f9                	fdivrp %st,%st(1)
     bcd:	d8 45 d8             	fadds  -0x28(%ebp)
     bd0:	d9 5d d8             	fstps  -0x28(%ebp)
     bd3:	83 ec 08             	sub    $0x8,%esp
     bd6:	6a 06                	push   $0x6
     bd8:	ff 75 08             	pushl  0x8(%ebp)
     bdb:	e8 e1 fd ff ff       	call   9c1 <pow>
     be0:	83 c4 10             	add    $0x10,%esp
     be3:	d9 05 84 5f 01 00    	flds   0x15f84
     be9:	de f9                	fdivrp %st,%st(1)
     beb:	d8 6d d8             	fsubrs -0x28(%ebp)
     bee:	d9 5d d8             	fstps  -0x28(%ebp)
     bf1:	83 ec 08             	sub    $0x8,%esp
     bf4:	6a 08                	push   $0x8
     bf6:	ff 75 08             	pushl  0x8(%ebp)
     bf9:	e8 c3 fd ff ff       	call   9c1 <pow>
     bfe:	83 c4 10             	add    $0x10,%esp
     c01:	d9 05 88 5f 01 00    	flds   0x15f88
     c07:	de f9                	fdivrp %st,%st(1)
     c09:	d8 45 d8             	fadds  -0x28(%ebp)
     c0c:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     c0f:	c9                   	leave  
     c10:	c3                   	ret    

00000c11 <sin>:

float sin(float x)
{
     c11:	55                   	push   %ebp
     c12:	89 e5                	mov    %esp,%ebp
     c14:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     c17:	d9 e8                	fld1   
     c19:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     c1c:	d9 45 08             	flds   0x8(%ebp)
     c1f:	dd 05 48 5f 01 00    	fldl   0x15f48
     c25:	d9 c9                	fxch   %st(1)
     c27:	df e9                	fucomip %st(1),%st
     c29:	dd d8                	fstp   %st(0)
     c2b:	77 0f                	ja     c3c <sin+0x2b>
     c2d:	d9 45 08             	flds   0x8(%ebp)
     c30:	dd 05 50 5f 01 00    	fldl   0x15f50
     c36:	df e9                	fucomip %st(1),%st
     c38:	dd d8                	fstp   %st(0)
     c3a:	76 3c                	jbe    c78 <sin+0x67>
     c3c:	d9 45 08             	flds   0x8(%ebp)
     c3f:	d9 45 08             	flds   0x8(%ebp)
     c42:	dd 05 48 5f 01 00    	fldl   0x15f48
     c48:	de f9                	fdivrp %st,%st(1)
     c4a:	d9 7d e2             	fnstcw -0x1e(%ebp)
     c4d:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     c51:	b4 0c                	mov    $0xc,%ah
     c53:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     c57:	d9 6d e0             	fldcw  -0x20(%ebp)
     c5a:	db 5d dc             	fistpl -0x24(%ebp)
     c5d:	d9 6d e2             	fldcw  -0x1e(%ebp)
     c60:	8b 45 dc             	mov    -0x24(%ebp),%eax
     c63:	01 c0                	add    %eax,%eax
     c65:	89 45 d8             	mov    %eax,-0x28(%ebp)
     c68:	db 45 d8             	fildl  -0x28(%ebp)
     c6b:	dd 05 58 5f 01 00    	fldl   0x15f58
     c71:	de c9                	fmulp  %st,%st(1)
     c73:	de e9                	fsubrp %st,%st(1)
     c75:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     c78:	d9 45 08             	flds   0x8(%ebp)
     c7b:	dd 05 58 5f 01 00    	fldl   0x15f58
     c81:	d9 c9                	fxch   %st(1)
     c83:	df e9                	fucomip %st(1),%st
     c85:	dd d8                	fstp   %st(0)
     c87:	76 0e                	jbe    c97 <sin+0x86>
     c89:	d9 45 08             	flds   0x8(%ebp)
     c8c:	dd 05 48 5f 01 00    	fldl   0x15f48
     c92:	de e9                	fsubrp %st,%st(1)
     c94:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     c97:	d9 45 08             	flds   0x8(%ebp)
     c9a:	dd 05 60 5f 01 00    	fldl   0x15f60
     ca0:	df e9                	fucomip %st(1),%st
     ca2:	dd d8                	fstp   %st(0)
     ca4:	76 0e                	jbe    cb4 <sin+0xa3>
     ca6:	d9 45 08             	flds   0x8(%ebp)
     ca9:	dd 05 48 5f 01 00    	fldl   0x15f48
     caf:	de c1                	faddp  %st,%st(1)
     cb1:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     cb4:	d9 45 08             	flds   0x8(%ebp)
     cb7:	dd 05 68 5f 01 00    	fldl   0x15f68
     cbd:	d9 c9                	fxch   %st(1)
     cbf:	df e9                	fucomip %st(1),%st
     cc1:	dd d8                	fstp   %st(0)
     cc3:	76 16                	jbe    cdb <sin+0xca>
    {
        x -= PI;
     cc5:	d9 45 08             	flds   0x8(%ebp)
     cc8:	dd 05 58 5f 01 00    	fldl   0x15f58
     cce:	de e9                	fsubrp %st,%st(1)
     cd0:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     cd3:	d9 45 f4             	flds   -0xc(%ebp)
     cd6:	d9 e0                	fchs   
     cd8:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     cdb:	d9 45 08             	flds   0x8(%ebp)
     cde:	dd 05 70 5f 01 00    	fldl   0x15f70
     ce4:	df e9                	fucomip %st(1),%st
     ce6:	dd d8                	fstp   %st(0)
     ce8:	76 16                	jbe    d00 <sin+0xef>
    {
        x += PI;
     cea:	d9 45 08             	flds   0x8(%ebp)
     ced:	dd 05 58 5f 01 00    	fldl   0x15f58
     cf3:	de c1                	faddp  %st,%st(1)
     cf5:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     cf8:	d9 45 f4             	flds   -0xc(%ebp)
     cfb:	d9 e0                	fchs   
     cfd:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
     d00:	d9 ee                	fldz   
     d02:	d9 45 08             	flds   0x8(%ebp)
     d05:	d9 c9                	fxch   %st(1)
     d07:	df e9                	fucomip %st(1),%st
     d09:	dd d8                	fstp   %st(0)
     d0b:	76 10                	jbe    d1d <sin+0x10c>
    {
        x *= -1;
     d0d:	d9 45 08             	flds   0x8(%ebp)
     d10:	d9 e0                	fchs   
     d12:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     d15:	d9 45 f4             	flds   -0xc(%ebp)
     d18:	d9 e0                	fchs   
     d1a:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
     d1d:	d9 45 08             	flds   0x8(%ebp)
     d20:	dd 05 78 5f 01 00    	fldl   0x15f78
     d26:	d9 c9                	fxch   %st(1)
     d28:	df e9                	fucomip %st(1),%st
     d2a:	dd d8                	fstp   %st(0)
     d2c:	76 28                	jbe    d56 <sin+0x145>
     d2e:	d9 45 08             	flds   0x8(%ebp)
     d31:	dd 05 68 5f 01 00    	fldl   0x15f68
     d37:	de e1                	fsubp  %st,%st(1)
     d39:	d9 5d e4             	fstps  -0x1c(%ebp)
     d3c:	d9 45 e4             	flds   -0x1c(%ebp)
     d3f:	83 ec 0c             	sub    $0xc,%esp
     d42:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     d46:	d9 1c 24             	fstps  (%esp)
     d49:	e8 20 fd ff ff       	call   a6e <cos>
     d4e:	83 c4 10             	add    $0x10,%esp
     d51:	d8 4d f4             	fmuls  -0xc(%ebp)
     d54:	eb 7a                	jmp    dd0 <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
     d56:	83 ec 08             	sub    $0x8,%esp
     d59:	6a 03                	push   $0x3
     d5b:	ff 75 08             	pushl  0x8(%ebp)
     d5e:	e8 5e fc ff ff       	call   9c1 <pow>
     d63:	83 c4 10             	add    $0x10,%esp
     d66:	d9 05 8c 5f 01 00    	flds   0x15f8c
     d6c:	de f9                	fdivrp %st,%st(1)
     d6e:	d9 45 08             	flds   0x8(%ebp)
     d71:	de e1                	fsubp  %st,%st(1)
     d73:	d9 5d d8             	fstps  -0x28(%ebp)
     d76:	83 ec 08             	sub    $0x8,%esp
     d79:	6a 05                	push   $0x5
     d7b:	ff 75 08             	pushl  0x8(%ebp)
     d7e:	e8 3e fc ff ff       	call   9c1 <pow>
     d83:	83 c4 10             	add    $0x10,%esp
     d86:	d9 05 90 5f 01 00    	flds   0x15f90
     d8c:	de f9                	fdivrp %st,%st(1)
     d8e:	d8 45 d8             	fadds  -0x28(%ebp)
     d91:	d9 5d d8             	fstps  -0x28(%ebp)
     d94:	83 ec 08             	sub    $0x8,%esp
     d97:	6a 07                	push   $0x7
     d99:	ff 75 08             	pushl  0x8(%ebp)
     d9c:	e8 20 fc ff ff       	call   9c1 <pow>
     da1:	83 c4 10             	add    $0x10,%esp
     da4:	d9 05 94 5f 01 00    	flds   0x15f94
     daa:	de f9                	fdivrp %st,%st(1)
     dac:	d8 6d d8             	fsubrs -0x28(%ebp)
     daf:	d9 5d d8             	fstps  -0x28(%ebp)
     db2:	83 ec 08             	sub    $0x8,%esp
     db5:	6a 09                	push   $0x9
     db7:	ff 75 08             	pushl  0x8(%ebp)
     dba:	e8 02 fc ff ff       	call   9c1 <pow>
     dbf:	83 c4 10             	add    $0x10,%esp
     dc2:	d9 05 98 5f 01 00    	flds   0x15f98
     dc8:	de f9                	fdivrp %st,%st(1)
     dca:	d8 45 d8             	fadds  -0x28(%ebp)
     dcd:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     dd0:	c9                   	leave  
     dd1:	c3                   	ret    

00000dd2 <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
     dd2:	55                   	push   %ebp
     dd3:	89 e5                	mov    %esp,%ebp
     dd5:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
     dd8:	83 ec 04             	sub    $0x4,%esp
     ddb:	6a 0e                	push   $0xe
     ddd:	ff 75 0c             	pushl  0xc(%ebp)
     de0:	ff 75 08             	pushl  0x8(%ebp)
     de3:	e8 44 f6 ff ff       	call   42c <read>
     de8:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
     deb:	83 ec 04             	sub    $0x4,%esp
     dee:	6a 28                	push   $0x28
     df0:	ff 75 10             	pushl  0x10(%ebp)
     df3:	ff 75 08             	pushl  0x8(%ebp)
     df6:	e8 31 f6 ff ff       	call   42c <read>
     dfb:	83 c4 10             	add    $0x10,%esp
}
     dfe:	90                   	nop
     dff:	c9                   	leave  
     e00:	c3                   	ret    

00000e01 <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
     e01:	55                   	push   %ebp
     e02:	89 e5                	mov    %esp,%ebp
     e04:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     e0a:	83 ec 08             	sub    $0x8,%esp
     e0d:	6a 00                	push   $0x0
     e0f:	ff 75 08             	pushl  0x8(%ebp)
     e12:	e8 3d f6 ff ff       	call   454 <open>
     e17:	83 c4 10             	add    $0x10,%esp
     e1a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     e1d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     e21:	79 0a                	jns    e2d <readBitmapFile+0x2c>
        return -1;
     e23:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     e28:	e9 6e 01 00 00       	jmp    f9b <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     e2d:	83 ec 04             	sub    $0x4,%esp
     e30:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     e33:	50                   	push   %eax
     e34:	8d 45 ca             	lea    -0x36(%ebp),%eax
     e37:	50                   	push   %eax
     e38:	ff 75 ec             	pushl  -0x14(%ebp)
     e3b:	e8 92 ff ff ff       	call   dd2 <readBitmapHeader>
     e40:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     e43:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     e46:	83 e8 36             	sub    $0x36,%eax
     e49:	83 ec 04             	sub    $0x4,%esp
     e4c:	50                   	push   %eax
     e4d:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     e53:	50                   	push   %eax
     e54:	ff 75 ec             	pushl  -0x14(%ebp)
     e57:	e8 d0 f5 ff ff       	call   42c <read>
     e5c:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     e5f:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     e62:	8b 45 14             	mov    0x14(%ebp),%eax
     e65:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     e67:	8b 55 aa             	mov    -0x56(%ebp),%edx
     e6a:	8b 45 10             	mov    0x10(%ebp),%eax
     e6d:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     e6f:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     e72:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     e75:	8b 45 aa             	mov    -0x56(%ebp),%eax
     e78:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     e7b:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     e7f:	0f b7 c0             	movzwl %ax,%eax
     e82:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
     e85:	8b 45 e8             	mov    -0x18(%ebp),%eax
     e88:	0f af 45 e0          	imul   -0x20(%ebp),%eax
     e8c:	8d 50 07             	lea    0x7(%eax),%edx
     e8f:	85 c0                	test   %eax,%eax
     e91:	0f 48 c2             	cmovs  %edx,%eax
     e94:	c1 f8 03             	sar    $0x3,%eax
     e97:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
     e9a:	8b 45 0c             	mov    0xc(%ebp),%eax
     e9d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
     ea0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     ea3:	83 e8 01             	sub    $0x1,%eax
     ea6:	89 45 f4             	mov    %eax,-0xc(%ebp)
     ea9:	e9 d0 00 00 00       	jmp    f7e <readBitmapFile+0x17d>
        if (bits == 32) {
     eae:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
     eb2:	75 22                	jne    ed6 <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
     eb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
     eb7:	0f af 45 dc          	imul   -0x24(%ebp),%eax
     ebb:	89 c2                	mov    %eax,%edx
     ebd:	8b 45 d8             	mov    -0x28(%ebp),%eax
     ec0:	01 d0                	add    %edx,%eax
     ec2:	83 ec 04             	sub    $0x4,%esp
     ec5:	ff 75 dc             	pushl  -0x24(%ebp)
     ec8:	50                   	push   %eax
     ec9:	ff 75 ec             	pushl  -0x14(%ebp)
     ecc:	e8 5b f5 ff ff       	call   42c <read>
     ed1:	83 c4 10             	add    $0x10,%esp
     ed4:	eb 65                	jmp    f3b <readBitmapFile+0x13a>
        } else {
            int j = 0;
     ed6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
     edd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     ee4:	eb 4d                	jmp    f33 <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
     ee6:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ee9:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     eed:	c1 e0 02             	shl    $0x2,%eax
     ef0:	89 c2                	mov    %eax,%edx
     ef2:	8b 45 f0             	mov    -0x10(%ebp),%eax
     ef5:	c1 e0 02             	shl    $0x2,%eax
     ef8:	01 c2                	add    %eax,%edx
     efa:	8b 45 d8             	mov    -0x28(%ebp),%eax
     efd:	01 d0                	add    %edx,%eax
     eff:	83 ec 04             	sub    $0x4,%esp
     f02:	6a 03                	push   $0x3
     f04:	50                   	push   %eax
     f05:	ff 75 ec             	pushl  -0x14(%ebp)
     f08:	e8 1f f5 ff ff       	call   42c <read>
     f0d:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
     f10:	8b 45 f4             	mov    -0xc(%ebp),%eax
     f13:	0f af 45 e8          	imul   -0x18(%ebp),%eax
     f17:	c1 e0 02             	shl    $0x2,%eax
     f1a:	89 c2                	mov    %eax,%edx
     f1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
     f1f:	c1 e0 02             	shl    $0x2,%eax
     f22:	01 d0                	add    %edx,%eax
     f24:	8d 50 03             	lea    0x3(%eax),%edx
     f27:	8b 45 d8             	mov    -0x28(%ebp),%eax
     f2a:	01 d0                	add    %edx,%eax
     f2c:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
     f2f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     f33:	8b 45 f0             	mov    -0x10(%ebp),%eax
     f36:	3b 45 e8             	cmp    -0x18(%ebp),%eax
     f39:	7c ab                	jl     ee6 <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
     f3b:	8b 45 dc             	mov    -0x24(%ebp),%eax
     f3e:	99                   	cltd   
     f3f:	c1 ea 1e             	shr    $0x1e,%edx
     f42:	01 d0                	add    %edx,%eax
     f44:	83 e0 03             	and    $0x3,%eax
     f47:	29 d0                	sub    %edx,%eax
     f49:	85 c0                	test   %eax,%eax
     f4b:	7e 2d                	jle    f7a <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
     f4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
     f50:	99                   	cltd   
     f51:	c1 ea 1e             	shr    $0x1e,%edx
     f54:	01 d0                	add    %edx,%eax
     f56:	83 e0 03             	and    $0x3,%eax
     f59:	29 d0                	sub    %edx,%eax
     f5b:	ba 04 00 00 00       	mov    $0x4,%edx
     f60:	29 c2                	sub    %eax,%edx
     f62:	89 d0                	mov    %edx,%eax
     f64:	83 ec 04             	sub    $0x4,%esp
     f67:	50                   	push   %eax
     f68:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
     f6e:	50                   	push   %eax
     f6f:	ff 75 ec             	pushl  -0x14(%ebp)
     f72:	e8 b5 f4 ff ff       	call   42c <read>
     f77:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
     f7a:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     f7e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     f82:	0f 89 26 ff ff ff    	jns    eae <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
     f88:	83 ec 0c             	sub    $0xc,%esp
     f8b:	ff 75 ec             	pushl  -0x14(%ebp)
     f8e:	e8 a9 f4 ff ff       	call   43c <close>
     f93:	83 c4 10             	add    $0x10,%esp
    return 0;
     f96:	b8 00 00 00 00       	mov    $0x0,%eax
}
     f9b:	c9                   	leave  
     f9c:	c3                   	ret    

00000f9d <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
     f9d:	55                   	push   %ebp
     f9e:	89 e5                	mov    %esp,%ebp
     fa0:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     fa6:	83 ec 08             	sub    $0x8,%esp
     fa9:	6a 00                	push   $0x0
     fab:	ff 75 08             	pushl  0x8(%ebp)
     fae:	e8 a1 f4 ff ff       	call   454 <open>
     fb3:	83 c4 10             	add    $0x10,%esp
     fb6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     fb9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     fbd:	79 0a                	jns    fc9 <read24BitmapFile+0x2c>
        return -1;
     fbf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     fc4:	e9 66 01 00 00       	jmp    112f <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     fc9:	83 ec 04             	sub    $0x4,%esp
     fcc:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     fcf:	50                   	push   %eax
     fd0:	8d 45 ca             	lea    -0x36(%ebp),%eax
     fd3:	50                   	push   %eax
     fd4:	ff 75 ec             	pushl  -0x14(%ebp)
     fd7:	e8 f6 fd ff ff       	call   dd2 <readBitmapHeader>
     fdc:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     fdf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     fe2:	83 e8 36             	sub    $0x36,%eax
     fe5:	83 ec 04             	sub    $0x4,%esp
     fe8:	50                   	push   %eax
     fe9:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     fef:	50                   	push   %eax
     ff0:	ff 75 ec             	pushl  -0x14(%ebp)
     ff3:	e8 34 f4 ff ff       	call   42c <read>
     ff8:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     ffb:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     ffe:	8b 45 14             	mov    0x14(%ebp),%eax
    1001:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    1003:	8b 55 aa             	mov    -0x56(%ebp),%edx
    1006:	8b 45 10             	mov    0x10(%ebp),%eax
    1009:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    100b:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    100e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    1011:	8b 45 aa             	mov    -0x56(%ebp),%eax
    1014:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    1017:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    101b:	0f b7 c0             	movzwl %ax,%eax
    101e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
    1021:	8b 55 e8             	mov    -0x18(%ebp),%edx
    1024:	89 d0                	mov    %edx,%eax
    1026:	01 c0                	add    %eax,%eax
    1028:	01 d0                	add    %edx,%eax
    102a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    102d:	8b 45 0c             	mov    0xc(%ebp),%eax
    1030:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    1033:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1036:	83 e8 01             	sub    $0x1,%eax
    1039:	89 45 f4             	mov    %eax,-0xc(%ebp)
    103c:	e9 d1 00 00 00       	jmp    1112 <read24BitmapFile+0x175>
        if (bits == 24) {
    1041:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
    1045:	75 22                	jne    1069 <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    1047:	8b 45 f4             	mov    -0xc(%ebp),%eax
    104a:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    104e:	89 c2                	mov    %eax,%edx
    1050:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1053:	01 d0                	add    %edx,%eax
    1055:	83 ec 04             	sub    $0x4,%esp
    1058:	ff 75 dc             	pushl  -0x24(%ebp)
    105b:	50                   	push   %eax
    105c:	ff 75 ec             	pushl  -0x14(%ebp)
    105f:	e8 c8 f3 ff ff       	call   42c <read>
    1064:	83 c4 10             	add    $0x10,%esp
    1067:	eb 66                	jmp    10cf <read24BitmapFile+0x132>
        } else {
            int j = 0;
    1069:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    1070:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1077:	eb 4e                	jmp    10c7 <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
    1079:	8b 45 f4             	mov    -0xc(%ebp),%eax
    107c:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    1080:	89 c2                	mov    %eax,%edx
    1082:	89 d0                	mov    %edx,%eax
    1084:	01 c0                	add    %eax,%eax
    1086:	01 d0                	add    %edx,%eax
    1088:	89 c1                	mov    %eax,%ecx
    108a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    108d:	89 d0                	mov    %edx,%eax
    108f:	01 c0                	add    %eax,%eax
    1091:	01 d0                	add    %edx,%eax
    1093:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    1096:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1099:	01 d0                	add    %edx,%eax
    109b:	83 ec 04             	sub    $0x4,%esp
    109e:	6a 03                	push   $0x3
    10a0:	50                   	push   %eax
    10a1:	ff 75 ec             	pushl  -0x14(%ebp)
    10a4:	e8 83 f3 ff ff       	call   42c <read>
    10a9:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
    10ac:	83 ec 04             	sub    $0x4,%esp
    10af:	6a 01                	push   $0x1
    10b1:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    10b7:	50                   	push   %eax
    10b8:	ff 75 ec             	pushl  -0x14(%ebp)
    10bb:	e8 6c f3 ff ff       	call   42c <read>
    10c0:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    10c3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    10c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    10ca:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    10cd:	7c aa                	jl     1079 <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
    10cf:	8b 45 dc             	mov    -0x24(%ebp),%eax
    10d2:	99                   	cltd   
    10d3:	c1 ea 1e             	shr    $0x1e,%edx
    10d6:	01 d0                	add    %edx,%eax
    10d8:	83 e0 03             	and    $0x3,%eax
    10db:	29 d0                	sub    %edx,%eax
    10dd:	85 c0                	test   %eax,%eax
    10df:	7e 2d                	jle    110e <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    10e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    10e4:	99                   	cltd   
    10e5:	c1 ea 1e             	shr    $0x1e,%edx
    10e8:	01 d0                	add    %edx,%eax
    10ea:	83 e0 03             	and    $0x3,%eax
    10ed:	29 d0                	sub    %edx,%eax
    10ef:	ba 04 00 00 00       	mov    $0x4,%edx
    10f4:	29 c2                	sub    %eax,%edx
    10f6:	89 d0                	mov    %edx,%eax
    10f8:	83 ec 04             	sub    $0x4,%esp
    10fb:	50                   	push   %eax
    10fc:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    1102:	50                   	push   %eax
    1103:	ff 75 ec             	pushl  -0x14(%ebp)
    1106:	e8 21 f3 ff ff       	call   42c <read>
    110b:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    110e:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1112:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1116:	0f 89 25 ff ff ff    	jns    1041 <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    111c:	83 ec 0c             	sub    $0xc,%esp
    111f:	ff 75 ec             	pushl  -0x14(%ebp)
    1122:	e8 15 f3 ff ff       	call   43c <close>
    1127:	83 c4 10             	add    $0x10,%esp
    return 0;
    112a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    112f:	c9                   	leave  
    1130:	c3                   	ret    

00001131 <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    1131:	55                   	push   %ebp
    1132:	89 e5                	mov    %esp,%ebp
    1134:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    1137:	8b 55 10             	mov    0x10(%ebp),%edx
    113a:	89 d0                	mov    %edx,%eax
    113c:	01 c0                	add    %eax,%eax
    113e:	01 d0                	add    %edx,%eax
    1140:	c1 e0 03             	shl    $0x3,%eax
    1143:	83 c0 1f             	add    $0x1f,%eax
    1146:	8d 50 1f             	lea    0x1f(%eax),%edx
    1149:	85 c0                	test   %eax,%eax
    114b:	0f 48 c2             	cmovs  %edx,%eax
    114e:	c1 f8 05             	sar    $0x5,%eax
    1151:	c1 e0 02             	shl    $0x2,%eax
    1154:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    1157:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    115d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1160:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1164:	83 c0 36             	add    $0x36,%eax
    1167:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    116a:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    1170:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    1176:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    117d:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    1184:	8b 45 10             	mov    0x10(%ebp),%eax
    1187:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    118a:	8b 45 0c             	mov    0xc(%ebp),%eax
    118d:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    1190:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    1196:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    119c:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    11a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    11a6:	0f af 45 0c          	imul   0xc(%ebp),%eax
    11aa:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    11ad:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    11b4:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    11bb:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    11c2:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    11c9:	83 ec 04             	sub    $0x4,%esp
    11cc:	6a 0e                	push   $0xe
    11ce:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    11d1:	50                   	push   %eax
    11d2:	ff 75 08             	pushl  0x8(%ebp)
    11d5:	e8 5a f2 ff ff       	call   434 <write>
    11da:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    11dd:	83 ec 04             	sub    $0x4,%esp
    11e0:	6a 28                	push   $0x28
    11e2:	8d 45 be             	lea    -0x42(%ebp),%eax
    11e5:	50                   	push   %eax
    11e6:	ff 75 08             	pushl  0x8(%ebp)
    11e9:	e8 46 f2 ff ff       	call   434 <write>
    11ee:	83 c4 10             	add    $0x10,%esp
}
    11f1:	90                   	nop
    11f2:	c9                   	leave  
    11f3:	c3                   	ret    

000011f4 <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    11f4:	55                   	push   %ebp
    11f5:	89 e5                	mov    %esp,%ebp
    11f7:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    11fa:	83 ec 08             	sub    $0x8,%esp
    11fd:	68 02 02 00 00       	push   $0x202
    1202:	ff 75 08             	pushl  0x8(%ebp)
    1205:	e8 4a f2 ff ff       	call   454 <open>
    120a:	83 c4 10             	add    $0x10,%esp
    120d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    1210:	8b 55 14             	mov    0x14(%ebp),%edx
    1213:	89 d0                	mov    %edx,%eax
    1215:	01 c0                	add    %eax,%eax
    1217:	01 d0                	add    %edx,%eax
    1219:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    121c:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    1220:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    1224:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    1228:	83 ec 04             	sub    $0x4,%esp
    122b:	ff 75 14             	pushl  0x14(%ebp)
    122e:	ff 75 10             	pushl  0x10(%ebp)
    1231:	ff 75 f0             	pushl  -0x10(%ebp)
    1234:	e8 f8 fe ff ff       	call   1131 <write24BitmapFileHeader>
    1239:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    123c:	8b 45 10             	mov    0x10(%ebp),%eax
    123f:	83 e8 01             	sub    $0x1,%eax
    1242:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1245:	eb 66                	jmp    12ad <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    1247:	8b 45 f4             	mov    -0xc(%ebp),%eax
    124a:	0f af 45 14          	imul   0x14(%ebp),%eax
    124e:	89 c2                	mov    %eax,%edx
    1250:	89 d0                	mov    %edx,%eax
    1252:	01 c0                	add    %eax,%eax
    1254:	01 c2                	add    %eax,%edx
    1256:	8b 45 0c             	mov    0xc(%ebp),%eax
    1259:	01 d0                	add    %edx,%eax
    125b:	83 ec 04             	sub    $0x4,%esp
    125e:	ff 75 ec             	pushl  -0x14(%ebp)
    1261:	50                   	push   %eax
    1262:	ff 75 f0             	pushl  -0x10(%ebp)
    1265:	e8 ca f1 ff ff       	call   434 <write>
    126a:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    126d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1270:	99                   	cltd   
    1271:	c1 ea 1e             	shr    $0x1e,%edx
    1274:	01 d0                	add    %edx,%eax
    1276:	83 e0 03             	and    $0x3,%eax
    1279:	29 d0                	sub    %edx,%eax
    127b:	85 c0                	test   %eax,%eax
    127d:	7e 2a                	jle    12a9 <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    127f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1282:	99                   	cltd   
    1283:	c1 ea 1e             	shr    $0x1e,%edx
    1286:	01 d0                	add    %edx,%eax
    1288:	83 e0 03             	and    $0x3,%eax
    128b:	29 d0                	sub    %edx,%eax
    128d:	ba 04 00 00 00       	mov    $0x4,%edx
    1292:	29 c2                	sub    %eax,%edx
    1294:	89 d0                	mov    %edx,%eax
    1296:	83 ec 04             	sub    $0x4,%esp
    1299:	50                   	push   %eax
    129a:	8d 45 e9             	lea    -0x17(%ebp),%eax
    129d:	50                   	push   %eax
    129e:	ff 75 f0             	pushl  -0x10(%ebp)
    12a1:	e8 8e f1 ff ff       	call   434 <write>
    12a6:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    12a9:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    12ad:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    12b1:	79 94                	jns    1247 <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    12b3:	83 ec 0c             	sub    $0xc,%esp
    12b6:	ff 75 f0             	pushl  -0x10(%ebp)
    12b9:	e8 7e f1 ff ff       	call   43c <close>
    12be:	83 c4 10             	add    $0x10,%esp
    return 0;
    12c1:	b8 00 00 00 00       	mov    $0x0,%eax
    12c6:	c9                   	leave  
    12c7:	c3                   	ret    

000012c8 <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    12c8:	55                   	push   %ebp
    12c9:	89 e5                	mov    %esp,%ebp
    12cb:	57                   	push   %edi
    12cc:	56                   	push   %esi
    12cd:	53                   	push   %ebx
    12ce:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    12d1:	8b 45 08             	mov    0x8(%ebp),%eax
    12d4:	8b 50 10             	mov    0x10(%eax),%edx
    12d7:	8b 40 0c             	mov    0xc(%eax),%eax
    12da:	89 45 e0             	mov    %eax,-0x20(%ebp)
    12dd:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    12e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    12e3:	8b 55 e0             	mov    -0x20(%ebp),%edx
    12e6:	83 c2 1e             	add    $0x1e,%edx
    12e9:	0f af d0             	imul   %eax,%edx
    12ec:	89 d0                	mov    %edx,%eax
    12ee:	01 c0                	add    %eax,%eax
    12f0:	01 d0                	add    %edx,%eax
    12f2:	83 ec 0c             	sub    $0xc,%esp
    12f5:	50                   	push   %eax
    12f6:	e8 93 f5 ff ff       	call   88e <malloc>
    12fb:	83 c4 10             	add    $0x10,%esp
    12fe:	89 c2                	mov    %eax,%edx
    1300:	8b 45 08             	mov    0x8(%ebp),%eax
    1303:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    1306:	8b 45 08             	mov    0x8(%ebp),%eax
    1309:	8b 40 1c             	mov    0x1c(%eax),%eax
    130c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    130f:	6b d2 5a             	imul   $0x5a,%edx,%edx
    1312:	01 c2                	add    %eax,%edx
    1314:	8b 45 08             	mov    0x8(%ebp),%eax
    1317:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    131a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    131d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    1320:	0f af d0             	imul   %eax,%edx
    1323:	89 d0                	mov    %edx,%eax
    1325:	01 c0                	add    %eax,%eax
    1327:	01 d0                	add    %edx,%eax
    1329:	89 c2                	mov    %eax,%edx
    132b:	8b 45 08             	mov    0x8(%ebp),%eax
    132e:	8b 40 18             	mov    0x18(%eax),%eax
    1331:	83 ec 04             	sub    $0x4,%esp
    1334:	52                   	push   %edx
    1335:	68 ff 00 00 00       	push   $0xff
    133a:	50                   	push   %eax
    133b:	e8 39 ef ff ff       	call   279 <memset>
    1340:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    1343:	8b 45 08             	mov    0x8(%ebp),%eax
    1346:	8b 78 1c             	mov    0x1c(%eax),%edi
    1349:	8b 45 08             	mov    0x8(%ebp),%eax
    134c:	8b 70 14             	mov    0x14(%eax),%esi
    134f:	8b 45 08             	mov    0x8(%ebp),%eax
    1352:	8b 58 0c             	mov    0xc(%eax),%ebx
    1355:	8b 45 08             	mov    0x8(%ebp),%eax
    1358:	8b 48 10             	mov    0x10(%eax),%ecx
    135b:	8b 45 08             	mov    0x8(%ebp),%eax
    135e:	8b 50 08             	mov    0x8(%eax),%edx
    1361:	8b 45 08             	mov    0x8(%ebp),%eax
    1364:	8b 40 04             	mov    0x4(%eax),%eax
    1367:	83 ec 08             	sub    $0x8,%esp
    136a:	57                   	push   %edi
    136b:	56                   	push   %esi
    136c:	53                   	push   %ebx
    136d:	51                   	push   %ecx
    136e:	52                   	push   %edx
    136f:	50                   	push   %eax
    1370:	e8 3f f1 ff ff       	call   4b4 <createwindow>
    1375:	83 c4 20             	add    $0x20,%esp
    1378:	89 c2                	mov    %eax,%edx
    137a:	8b 45 08             	mov    0x8(%ebp),%eax
    137d:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    137f:	8b 45 08             	mov    0x8(%ebp),%eax
    1382:	8b 00                	mov    (%eax),%eax
}
    1384:	8d 65 f4             	lea    -0xc(%ebp),%esp
    1387:	5b                   	pop    %ebx
    1388:	5e                   	pop    %esi
    1389:	5f                   	pop    %edi
    138a:	5d                   	pop    %ebp
    138b:	c3                   	ret    

0000138c <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    138c:	55                   	push   %ebp
    138d:	89 e5                	mov    %esp,%ebp
    138f:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    1392:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1399:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    13a0:	8b 45 08             	mov    0x8(%ebp),%eax
    13a3:	8b 40 18             	mov    0x18(%eax),%eax
    13a6:	ff 75 1c             	pushl  0x1c(%ebp)
    13a9:	ff 75 18             	pushl  0x18(%ebp)
    13ac:	ff 75 1c             	pushl  0x1c(%ebp)
    13af:	ff 75 18             	pushl  0x18(%ebp)
    13b2:	8b 55 08             	mov    0x8(%ebp),%edx
    13b5:	ff 72 10             	pushl  0x10(%edx)
    13b8:	ff 72 0c             	pushl  0xc(%edx)
    13bb:	ff 75 f4             	pushl  -0xc(%ebp)
    13be:	ff 75 f0             	pushl  -0x10(%ebp)
    13c1:	ff 75 14             	pushl  0x14(%ebp)
    13c4:	ff 75 10             	pushl  0x10(%ebp)
    13c7:	ff 75 0c             	pushl  0xc(%ebp)
    13ca:	50                   	push   %eax
    13cb:	e8 d5 07 00 00       	call   1ba5 <drawBitmap>
    13d0:	83 c4 30             	add    $0x30,%esp
    return 0;
    13d3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    13d8:	c9                   	leave  
    13d9:	c3                   	ret    

000013da <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    13da:	55                   	push   %ebp
    13db:	89 e5                	mov    %esp,%ebp
    13dd:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    13e0:	8b 45 08             	mov    0x8(%ebp),%eax
    13e3:	8b 40 18             	mov    0x18(%eax),%eax
    13e6:	ff 75 2c             	pushl  0x2c(%ebp)
    13e9:	ff 75 28             	pushl  0x28(%ebp)
    13ec:	ff 75 24             	pushl  0x24(%ebp)
    13ef:	ff 75 20             	pushl  0x20(%ebp)
    13f2:	8b 55 08             	mov    0x8(%ebp),%edx
    13f5:	ff 72 10             	pushl  0x10(%edx)
    13f8:	ff 72 0c             	pushl  0xc(%edx)
    13fb:	ff 75 1c             	pushl  0x1c(%ebp)
    13fe:	ff 75 18             	pushl  0x18(%ebp)
    1401:	ff 75 14             	pushl  0x14(%ebp)
    1404:	ff 75 10             	pushl  0x10(%ebp)
    1407:	ff 75 0c             	pushl  0xc(%ebp)
    140a:	50                   	push   %eax
    140b:	e8 95 07 00 00       	call   1ba5 <drawBitmap>
    1410:	83 c4 30             	add    $0x30,%esp
    return 0;
    1413:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1418:	c9                   	leave  
    1419:	c3                   	ret    

0000141a <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    141a:	55                   	push   %ebp
    141b:	89 e5                	mov    %esp,%ebp
    141d:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1420:	8b 45 08             	mov    0x8(%ebp),%eax
    1423:	8b 40 18             	mov    0x18(%eax),%eax
    1426:	ff 75 2c             	pushl  0x2c(%ebp)
    1429:	ff 75 28             	pushl  0x28(%ebp)
    142c:	ff 75 24             	pushl  0x24(%ebp)
    142f:	ff 75 20             	pushl  0x20(%ebp)
    1432:	8b 55 08             	mov    0x8(%ebp),%edx
    1435:	ff 72 10             	pushl  0x10(%edx)
    1438:	ff 72 0c             	pushl  0xc(%edx)
    143b:	ff 75 1c             	pushl  0x1c(%ebp)
    143e:	ff 75 18             	pushl  0x18(%ebp)
    1441:	ff 75 14             	pushl  0x14(%ebp)
    1444:	ff 75 10             	pushl  0x10(%ebp)
    1447:	ff 75 0c             	pushl  0xc(%ebp)
    144a:	50                   	push   %eax
    144b:	e8 75 08 00 00       	call   1cc5 <drawTransparentBitmap>
    1450:	83 c4 30             	add    $0x30,%esp
    return 0;
    1453:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1458:	c9                   	leave  
    1459:	c3                   	ret    

0000145a <api_repaint>:

int api_repaint(Window* wnd)
{
    145a:	55                   	push   %ebp
    145b:	89 e5                	mov    %esp,%ebp
    145d:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    1460:	8b 45 08             	mov    0x8(%ebp),%eax
    1463:	8b 00                	mov    (%eax),%eax
    1465:	83 ec 0c             	sub    $0xc,%esp
    1468:	50                   	push   %eax
    1469:	e8 4e f0 ff ff       	call   4bc <repaintwindow>
    146e:	83 c4 10             	add    $0x10,%esp
    return 0;
    1471:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1476:	c9                   	leave  
    1477:	c3                   	ret    

00001478 <api_update>:

int api_update(Window* wnd, Rect rect)
{
    1478:	55                   	push   %ebp
    1479:	89 e5                	mov    %esp,%ebp
    147b:	56                   	push   %esi
    147c:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    147d:	8b 75 18             	mov    0x18(%ebp),%esi
    1480:	8b 5d 14             	mov    0x14(%ebp),%ebx
    1483:	8b 4d 10             	mov    0x10(%ebp),%ecx
    1486:	8b 55 0c             	mov    0xc(%ebp),%edx
    1489:	8b 45 08             	mov    0x8(%ebp),%eax
    148c:	8b 00                	mov    (%eax),%eax
    148e:	83 ec 0c             	sub    $0xc,%esp
    1491:	56                   	push   %esi
    1492:	53                   	push   %ebx
    1493:	51                   	push   %ecx
    1494:	52                   	push   %edx
    1495:	50                   	push   %eax
    1496:	e8 39 f0 ff ff       	call   4d4 <updatewindow>
    149b:	83 c4 20             	add    $0x20,%esp
    return 0;
    149e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    14a3:	8d 65 f8             	lea    -0x8(%ebp),%esp
    14a6:	5b                   	pop    %ebx
    14a7:	5e                   	pop    %esi
    14a8:	5d                   	pop    %ebp
    14a9:	c3                   	ret    

000014aa <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    14aa:	55                   	push   %ebp
    14ab:	89 e5                	mov    %esp,%ebp
    14ad:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    14b0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    14b7:	8b 45 08             	mov    0x8(%ebp),%eax
    14ba:	8b 00                	mov    (%eax),%eax
    14bc:	83 ec 08             	sub    $0x8,%esp
    14bf:	8d 55 c8             	lea    -0x38(%ebp),%edx
    14c2:	52                   	push   %edx
    14c3:	50                   	push   %eax
    14c4:	e8 fb ef ff ff       	call   4c4 <getmessage>
    14c9:	83 c4 10             	add    $0x10,%esp
    14cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    14cf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    14d3:	74 e2                	je     14b7 <api_exec+0xd>
        {
            pf(&msg);
    14d5:	83 ec 0c             	sub    $0xc,%esp
    14d8:	8d 45 c8             	lea    -0x38(%ebp),%eax
    14db:	50                   	push   %eax
    14dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    14df:	ff d0                	call   *%eax
    14e1:	83 c4 10             	add    $0x10,%esp
        }
    }
    14e4:	eb d1                	jmp    14b7 <api_exec+0xd>

000014e6 <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    14e6:	55                   	push   %ebp
    14e7:	89 e5                	mov    %esp,%ebp
    14e9:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    14ec:	8b 45 08             	mov    0x8(%ebp),%eax
    14ef:	8b 00                	mov    (%eax),%eax
    14f1:	83 ec 08             	sub    $0x8,%esp
    14f4:	ff 75 0c             	pushl  0xc(%ebp)
    14f7:	50                   	push   %eax
    14f8:	e8 cf ef ff ff       	call   4cc <settimer>
    14fd:	83 c4 10             	add    $0x10,%esp
    return 0;
    1500:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1505:	c9                   	leave  
    1506:	c3                   	ret    

00001507 <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    1507:	55                   	push   %ebp
    1508:	89 e5                	mov    %esp,%ebp
    150a:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    150d:	8b 45 08             	mov    0x8(%ebp),%eax
    1510:	8b 50 18             	mov    0x18(%eax),%edx
    1513:	ff 75 18             	pushl  0x18(%ebp)
    1516:	ff 75 14             	pushl  0x14(%ebp)
    1519:	83 ec 04             	sub    $0x4,%esp
    151c:	89 e0                	mov    %esp,%eax
    151e:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    1522:	66 89 08             	mov    %cx,(%eax)
    1525:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    1529:	88 48 02             	mov    %cl,0x2(%eax)
    152c:	8b 45 08             	mov    0x8(%ebp),%eax
    152f:	ff 70 10             	pushl  0x10(%eax)
    1532:	ff 70 0c             	pushl  0xc(%eax)
    1535:	ff 75 10             	pushl  0x10(%ebp)
    1538:	ff 75 0c             	pushl  0xc(%ebp)
    153b:	52                   	push   %edx
    153c:	e8 6f 04 00 00       	call   19b0 <drawRect>
    1541:	83 c4 20             	add    $0x20,%esp
    return 0;
    1544:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1549:	c9                   	leave  
    154a:	c3                   	ret    

0000154b <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    154b:	55                   	push   %ebp
    154c:	89 e5                	mov    %esp,%ebp
    154e:	83 ec 28             	sub    $0x28,%esp
    1551:	8b 45 14             	mov    0x14(%ebp),%eax
    1554:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    1557:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    155b:	8b 45 0c             	mov    0xc(%ebp),%eax
    155e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1561:	8b 45 10             	mov    0x10(%ebp),%eax
    1564:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1567:	8b 45 08             	mov    0x8(%ebp),%eax
    156a:	8b 40 18             	mov    0x18(%eax),%eax
    156d:	83 ec 04             	sub    $0x4,%esp
    1570:	ff 75 18             	pushl  0x18(%ebp)
    1573:	52                   	push   %edx
    1574:	8b 55 08             	mov    0x8(%ebp),%edx
    1577:	ff 72 10             	pushl  0x10(%edx)
    157a:	ff 72 0c             	pushl  0xc(%edx)
    157d:	ff 75 f4             	pushl  -0xc(%ebp)
    1580:	ff 75 f0             	pushl  -0x10(%ebp)
    1583:	50                   	push   %eax
    1584:	e8 d4 02 00 00       	call   185d <drawCharacter>
    1589:	83 c4 20             	add    $0x20,%esp
    return 0;
    158c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1591:	c9                   	leave  
    1592:	c3                   	ret    

00001593 <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    1593:	55                   	push   %ebp
    1594:	89 e5                	mov    %esp,%ebp
    1596:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    1599:	8b 45 0c             	mov    0xc(%ebp),%eax
    159c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    159f:	8b 45 10             	mov    0x10(%ebp),%eax
    15a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    15a5:	8b 45 08             	mov    0x8(%ebp),%eax
    15a8:	8b 40 18             	mov    0x18(%eax),%eax
    15ab:	83 ec 04             	sub    $0x4,%esp
    15ae:	ff 75 18             	pushl  0x18(%ebp)
    15b1:	ff 75 14             	pushl  0x14(%ebp)
    15b4:	8b 55 08             	mov    0x8(%ebp),%edx
    15b7:	ff 72 10             	pushl  0x10(%edx)
    15ba:	ff 72 0c             	pushl  0xc(%edx)
    15bd:	ff 75 f4             	pushl  -0xc(%ebp)
    15c0:	ff 75 f0             	pushl  -0x10(%ebp)
    15c3:	50                   	push   %eax
    15c4:	e8 8e 03 00 00       	call   1957 <drawString>
    15c9:	83 c4 20             	add    $0x20,%esp
    return 0;
    15cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
    15d1:	c9                   	leave  
    15d2:	c3                   	ret    

000015d3 <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    15d3:	55                   	push   %ebp
    15d4:	89 e5                	mov    %esp,%ebp
    15d6:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    15d9:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    15dd:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    15e1:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    15e5:	83 ec 08             	sub    $0x8,%esp
    15e8:	83 ec 04             	sub    $0x4,%esp
    15eb:	89 e0                	mov    %esp,%eax
    15ed:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    15f1:	66 89 10             	mov    %dx,(%eax)
    15f4:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    15f8:	88 50 02             	mov    %dl,0x2(%eax)
    15fb:	ff 75 18             	pushl  0x18(%ebp)
    15fe:	ff 75 14             	pushl  0x14(%ebp)
    1601:	ff 75 10             	pushl  0x10(%ebp)
    1604:	ff 75 0c             	pushl  0xc(%ebp)
    1607:	ff 75 08             	pushl  0x8(%ebp)
    160a:	e8 f8 fe ff ff       	call   1507 <api_drawRect>
    160f:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    1612:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    1616:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    161a:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    161e:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    1622:	8b 45 10             	mov    0x10(%ebp),%eax
    1625:	8d 50 0a             	lea    0xa(%eax),%edx
    1628:	8b 45 0c             	mov    0xc(%ebp),%eax
    162b:	83 c0 0a             	add    $0xa,%eax
    162e:	83 ec 0c             	sub    $0xc,%esp
    1631:	ff 75 f4             	pushl  -0xc(%ebp)
    1634:	ff 75 1c             	pushl  0x1c(%ebp)
    1637:	52                   	push   %edx
    1638:	50                   	push   %eax
    1639:	ff 75 08             	pushl  0x8(%ebp)
    163c:	e8 52 ff ff ff       	call   1593 <api_drawString>
    1641:	83 c4 20             	add    $0x20,%esp
    return 0;
    1644:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1649:	c9                   	leave  
    164a:	c3                   	ret    

0000164b <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    164b:	55                   	push   %ebp
    164c:	89 e5                	mov    %esp,%ebp
    164e:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    1651:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1658:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    165f:	8b 45 08             	mov    0x8(%ebp),%eax
    1662:	8b 40 18             	mov    0x18(%eax),%eax
    1665:	ff 75 1c             	pushl  0x1c(%ebp)
    1668:	ff 75 18             	pushl  0x18(%ebp)
    166b:	ff 75 1c             	pushl  0x1c(%ebp)
    166e:	ff 75 18             	pushl  0x18(%ebp)
    1671:	8b 55 08             	mov    0x8(%ebp),%edx
    1674:	ff 72 10             	pushl  0x10(%edx)
    1677:	ff 72 0c             	pushl  0xc(%edx)
    167a:	ff 75 f4             	pushl  -0xc(%ebp)
    167d:	ff 75 f0             	pushl  -0x10(%ebp)
    1680:	ff 75 14             	pushl  0x14(%ebp)
    1683:	ff 75 10             	pushl  0x10(%ebp)
    1686:	ff 75 0c             	pushl  0xc(%ebp)
    1689:	50                   	push   %eax
    168a:	e8 16 05 00 00       	call   1ba5 <drawBitmap>
    168f:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    1692:	8b 45 08             	mov    0x8(%ebp),%eax
    1695:	8b 40 18             	mov    0x18(%eax),%eax
    1698:	ff 75 28             	pushl  0x28(%ebp)
    169b:	ff 75 1c             	pushl  0x1c(%ebp)
    169e:	ff 75 18             	pushl  0x18(%ebp)
    16a1:	8b 55 08             	mov    0x8(%ebp),%edx
    16a4:	ff 72 10             	pushl  0x10(%edx)
    16a7:	ff 72 0c             	pushl  0xc(%edx)
    16aa:	ff 75 14             	pushl  0x14(%ebp)
    16ad:	ff 75 10             	pushl  0x10(%ebp)
    16b0:	50                   	push   %eax
    16b1:	e8 99 07 00 00       	call   1e4f <colorShift>
    16b6:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    16b9:	8b 45 08             	mov    0x8(%ebp),%eax
    16bc:	8b 50 18             	mov    0x18(%eax),%edx
    16bf:	83 ec 0c             	sub    $0xc,%esp
    16c2:	ff 75 20             	pushl  0x20(%ebp)
    16c5:	ff 75 1c             	pushl  0x1c(%ebp)
    16c8:	ff 75 18             	pushl  0x18(%ebp)
    16cb:	83 ec 04             	sub    $0x4,%esp
    16ce:	89 e0                	mov    %esp,%eax
    16d0:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    16d4:	66 89 08             	mov    %cx,(%eax)
    16d7:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    16db:	88 48 02             	mov    %cl,0x2(%eax)
    16de:	8b 45 08             	mov    0x8(%ebp),%eax
    16e1:	ff 70 10             	pushl  0x10(%eax)
    16e4:	ff 70 0c             	pushl  0xc(%eax)
    16e7:	ff 75 14             	pushl  0x14(%ebp)
    16ea:	ff 75 10             	pushl  0x10(%ebp)
    16ed:	52                   	push   %edx
    16ee:	e8 6d 03 00 00       	call   1a60 <drawBorder>
    16f3:	83 c4 30             	add    $0x30,%esp
    return 0;
    16f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    16fb:	c9                   	leave  
    16fc:	c3                   	ret    

000016fd <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    16fd:	55                   	push   %ebp
    16fe:	89 e5                	mov    %esp,%ebp
    1700:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    1703:	8b 45 08             	mov    0x8(%ebp),%eax
    1706:	8b 00                	mov    (%eax),%eax
    1708:	83 ec 0c             	sub    $0xc,%esp
    170b:	50                   	push   %eax
    170c:	e8 cb ed ff ff       	call   4dc <destroywindow>
    1711:	83 c4 10             	add    $0x10,%esp
    return 0;
    1714:	b8 00 00 00 00       	mov    $0x0,%eax
    1719:	c9                   	leave  
    171a:	c3                   	ret    

0000171b <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    171b:	55                   	push   %ebp
    171c:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    171e:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    1722:	8b 45 08             	mov    0x8(%ebp),%eax
    1725:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    1728:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    172c:	8b 45 08             	mov    0x8(%ebp),%eax
    172f:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    1732:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    1736:	8b 45 08             	mov    0x8(%ebp),%eax
    1739:	88 10                	mov    %dl,(%eax)
}
    173b:	90                   	nop
    173c:	5d                   	pop    %ebp
    173d:	c3                   	ret    

0000173e <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    173e:	55                   	push   %ebp
    173f:	89 e5                	mov    %esp,%ebp
    1741:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    1744:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1748:	3c ff                	cmp    $0xff,%al
    174a:	75 22                	jne    176e <drawPointAlpha+0x30>
        color->R = origin.R;
    174c:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    1750:	8b 45 08             	mov    0x8(%ebp),%eax
    1753:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    1756:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    175a:	8b 45 08             	mov    0x8(%ebp),%eax
    175d:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    1760:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    1764:	8b 45 08             	mov    0x8(%ebp),%eax
    1767:	88 10                	mov    %dl,(%eax)
        return;
    1769:	e9 ed 00 00 00       	jmp    185b <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    176e:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    1772:	84 c0                	test   %al,%al
    1774:	0f 84 e0 00 00 00    	je     185a <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    177a:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    177e:	0f b6 c0             	movzbl %al,%eax
    1781:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    1785:	df 45 e4             	fild   -0x1c(%ebp)
    1788:	d9 05 e0 9d 01 00    	flds   0x19de0
    178e:	de f9                	fdivrp %st,%st(1)
    1790:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    1793:	8b 45 08             	mov    0x8(%ebp),%eax
    1796:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    179a:	0f b6 c0             	movzbl %al,%eax
    179d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    17a0:	db 45 e4             	fildl  -0x1c(%ebp)
    17a3:	d9 e8                	fld1   
    17a5:	d8 65 fc             	fsubs  -0x4(%ebp)
    17a8:	de c9                	fmulp  %st,%st(1)
    17aa:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    17ae:	0f b6 c0             	movzbl %al,%eax
    17b1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    17b4:	db 45 e4             	fildl  -0x1c(%ebp)
    17b7:	d8 4d fc             	fmuls  -0x4(%ebp)
    17ba:	de c1                	faddp  %st,%st(1)
    17bc:	d9 7d ee             	fnstcw -0x12(%ebp)
    17bf:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    17c3:	b4 0c                	mov    $0xc,%ah
    17c5:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    17c9:	d9 6d ec             	fldcw  -0x14(%ebp)
    17cc:	df 5d ea             	fistp  -0x16(%ebp)
    17cf:	d9 6d ee             	fldcw  -0x12(%ebp)
    17d2:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    17d6:	89 c2                	mov    %eax,%edx
    17d8:	8b 45 08             	mov    0x8(%ebp),%eax
    17db:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    17de:	8b 45 08             	mov    0x8(%ebp),%eax
    17e1:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    17e5:	0f b6 c0             	movzbl %al,%eax
    17e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    17eb:	db 45 e4             	fildl  -0x1c(%ebp)
    17ee:	d9 e8                	fld1   
    17f0:	d8 65 fc             	fsubs  -0x4(%ebp)
    17f3:	de c9                	fmulp  %st,%st(1)
    17f5:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    17f9:	0f b6 c0             	movzbl %al,%eax
    17fc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    17ff:	db 45 e4             	fildl  -0x1c(%ebp)
    1802:	d8 4d fc             	fmuls  -0x4(%ebp)
    1805:	de c1                	faddp  %st,%st(1)
    1807:	d9 6d ec             	fldcw  -0x14(%ebp)
    180a:	df 5d ea             	fistp  -0x16(%ebp)
    180d:	d9 6d ee             	fldcw  -0x12(%ebp)
    1810:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1814:	89 c2                	mov    %eax,%edx
    1816:	8b 45 08             	mov    0x8(%ebp),%eax
    1819:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    181c:	8b 45 08             	mov    0x8(%ebp),%eax
    181f:	0f b6 00             	movzbl (%eax),%eax
    1822:	0f b6 c0             	movzbl %al,%eax
    1825:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1828:	db 45 e4             	fildl  -0x1c(%ebp)
    182b:	d9 e8                	fld1   
    182d:	d8 65 fc             	fsubs  -0x4(%ebp)
    1830:	de c9                	fmulp  %st,%st(1)
    1832:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    1836:	0f b6 c0             	movzbl %al,%eax
    1839:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    183c:	db 45 e4             	fildl  -0x1c(%ebp)
    183f:	d8 4d fc             	fmuls  -0x4(%ebp)
    1842:	de c1                	faddp  %st,%st(1)
    1844:	d9 6d ec             	fldcw  -0x14(%ebp)
    1847:	df 5d ea             	fistp  -0x16(%ebp)
    184a:	d9 6d ee             	fldcw  -0x12(%ebp)
    184d:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    1851:	89 c2                	mov    %eax,%edx
    1853:	8b 45 08             	mov    0x8(%ebp),%eax
    1856:	88 10                	mov    %dl,(%eax)
    1858:	eb 01                	jmp    185b <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    185a:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    185b:	c9                   	leave  
    185c:	c3                   	ret    

0000185d <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    185d:	55                   	push   %ebp
    185e:	89 e5                	mov    %esp,%ebp
    1860:	83 ec 14             	sub    $0x14,%esp
    1863:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1866:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    1869:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    186d:	83 e8 20             	sub    $0x20,%eax
    1870:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    1873:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    1877:	0f 88 d7 00 00 00    	js     1954 <drawCharacter+0xf7>
    187d:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    1881:	0f 8f cd 00 00 00    	jg     1954 <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1887:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    188e:	e9 b5 00 00 00       	jmp    1948 <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    1893:	8b 55 10             	mov    0x10(%ebp),%edx
    1896:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1899:	01 c2                	add    %eax,%edx
    189b:	8b 45 14             	mov    0x14(%ebp),%eax
    189e:	39 c2                	cmp    %eax,%edx
    18a0:	0f 8f af 00 00 00    	jg     1955 <drawCharacter+0xf8>
    18a6:	8b 55 10             	mov    0x10(%ebp),%edx
    18a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    18ac:	01 d0                	add    %edx,%eax
    18ae:	85 c0                	test   %eax,%eax
    18b0:	0f 88 9f 00 00 00    	js     1955 <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    18b6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    18bd:	eb 7b                	jmp    193a <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    18bf:	8b 55 fc             	mov    -0x4(%ebp),%edx
    18c2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    18c5:	89 d0                	mov    %edx,%eax
    18c7:	c1 e0 03             	shl    $0x3,%eax
    18ca:	01 d0                	add    %edx,%eax
    18cc:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    18d2:	01 c2                	add    %eax,%edx
    18d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    18d7:	01 d0                	add    %edx,%eax
    18d9:	05 c0 61 01 00       	add    $0x161c0,%eax
    18de:	0f b6 00             	movzbl (%eax),%eax
    18e1:	3c 01                	cmp    $0x1,%al
    18e3:	75 51                	jne    1936 <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    18e5:	8b 55 0c             	mov    0xc(%ebp),%edx
    18e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    18eb:	01 c2                	add    %eax,%edx
    18ed:	8b 45 18             	mov    0x18(%ebp),%eax
    18f0:	39 c2                	cmp    %eax,%edx
    18f2:	7f 50                	jg     1944 <drawCharacter+0xe7>
    18f4:	8b 55 0c             	mov    0xc(%ebp),%edx
    18f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    18fa:	01 d0                	add    %edx,%eax
    18fc:	85 c0                	test   %eax,%eax
    18fe:	78 44                	js     1944 <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    1900:	8b 55 10             	mov    0x10(%ebp),%edx
    1903:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1906:	01 c2                	add    %eax,%edx
    1908:	8b 45 18             	mov    0x18(%ebp),%eax
    190b:	0f af c2             	imul   %edx,%eax
    190e:	89 c2                	mov    %eax,%edx
    1910:	8b 45 0c             	mov    0xc(%ebp),%eax
    1913:	01 c2                	add    %eax,%edx
    1915:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1918:	01 c2                	add    %eax,%edx
    191a:	89 d0                	mov    %edx,%eax
    191c:	01 c0                	add    %eax,%eax
    191e:	01 c2                	add    %eax,%edx
    1920:	8b 45 08             	mov    0x8(%ebp),%eax
    1923:	01 d0                	add    %edx,%eax
    1925:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    1928:	ff 75 20             	pushl  0x20(%ebp)
    192b:	ff 75 f0             	pushl  -0x10(%ebp)
    192e:	e8 0b fe ff ff       	call   173e <drawPointAlpha>
    1933:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1936:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    193a:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    193e:	0f 8e 7b ff ff ff    	jle    18bf <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1944:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    1948:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    194c:	0f 8e 41 ff ff ff    	jle    1893 <drawCharacter+0x36>
    1952:	eb 01                	jmp    1955 <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    1954:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    1955:	c9                   	leave  
    1956:	c3                   	ret    

00001957 <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    1957:	55                   	push   %ebp
    1958:	89 e5                	mov    %esp,%ebp
    195a:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    195d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    1964:	eb 3d                	jmp    19a3 <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    1966:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1969:	0f b6 00             	movzbl (%eax),%eax
    196c:	0f be c0             	movsbl %al,%eax
    196f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1972:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1975:	01 ca                	add    %ecx,%edx
    1977:	89 55 f4             	mov    %edx,-0xc(%ebp)
    197a:	8b 55 10             	mov    0x10(%ebp),%edx
    197d:	89 55 f8             	mov    %edx,-0x8(%ebp)
    1980:	ff 75 20             	pushl  0x20(%ebp)
    1983:	50                   	push   %eax
    1984:	ff 75 18             	pushl  0x18(%ebp)
    1987:	ff 75 14             	pushl  0x14(%ebp)
    198a:	ff 75 f8             	pushl  -0x8(%ebp)
    198d:	ff 75 f4             	pushl  -0xc(%ebp)
    1990:	ff 75 08             	pushl  0x8(%ebp)
    1993:	e8 c5 fe ff ff       	call   185d <drawCharacter>
    1998:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    199b:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    199f:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    19a3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    19a6:	0f b6 00             	movzbl (%eax),%eax
    19a9:	84 c0                	test   %al,%al
    19ab:	75 b9                	jne    1966 <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    19ad:	90                   	nop
    19ae:	c9                   	leave  
    19af:	c3                   	ret    

000019b0 <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    19b0:	55                   	push   %ebp
    19b1:	89 e5                	mov    %esp,%ebp
    19b3:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    19b6:	8b 45 20             	mov    0x20(%ebp),%eax
    19b9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    19bc:	8b 45 24             	mov    0x24(%ebp),%eax
    19bf:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    19c2:	8b 55 14             	mov    0x14(%ebp),%edx
    19c5:	8b 45 10             	mov    0x10(%ebp),%eax
    19c8:	29 c2                	sub    %eax,%edx
    19ca:	89 d0                	mov    %edx,%eax
    19cc:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    19cf:	7d 0d                	jge    19de <drawRect+0x2e>
        draw_h = s.h - p.y;
    19d1:	8b 55 14             	mov    0x14(%ebp),%edx
    19d4:	8b 45 10             	mov    0x10(%ebp),%eax
    19d7:	29 c2                	sub    %eax,%edx
    19d9:	89 d0                	mov    %edx,%eax
    19db:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    19de:	8b 55 18             	mov    0x18(%ebp),%edx
    19e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    19e4:	29 c2                	sub    %eax,%edx
    19e6:	89 d0                	mov    %edx,%eax
    19e8:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    19eb:	7d 0d                	jge    19fa <drawRect+0x4a>
        draw_w = s.w - p.x;
    19ed:	8b 55 18             	mov    0x18(%ebp),%edx
    19f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    19f3:	29 c2                	sub    %eax,%edx
    19f5:	89 d0                	mov    %edx,%eax
    19f7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    19fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1a01:	eb 52                	jmp    1a55 <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    1a03:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1a0a:	eb 3d                	jmp    1a49 <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    1a0c:	8b 55 10             	mov    0x10(%ebp),%edx
    1a0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1a12:	01 c2                	add    %eax,%edx
    1a14:	8b 45 18             	mov    0x18(%ebp),%eax
    1a17:	0f af c2             	imul   %edx,%eax
    1a1a:	89 c2                	mov    %eax,%edx
    1a1c:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a1f:	01 c2                	add    %eax,%edx
    1a21:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1a24:	01 c2                	add    %eax,%edx
    1a26:	89 d0                	mov    %edx,%eax
    1a28:	01 c0                	add    %eax,%eax
    1a2a:	01 c2                	add    %eax,%edx
    1a2c:	8b 45 08             	mov    0x8(%ebp),%eax
    1a2f:	01 d0                	add    %edx,%eax
    1a31:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    1a34:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1a37:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1a3b:	66 89 10             	mov    %dx,(%eax)
    1a3e:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1a42:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1a45:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1a49:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1a4c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1a4f:	7c bb                	jl     1a0c <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1a51:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1a55:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1a58:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1a5b:	7c a6                	jl     1a03 <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    1a5d:	90                   	nop
    1a5e:	c9                   	leave  
    1a5f:	c3                   	ret    

00001a60 <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    1a60:	55                   	push   %ebp
    1a61:	89 e5                	mov    %esp,%ebp
    1a63:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    1a66:	8b 45 28             	mov    0x28(%ebp),%eax
    1a69:	89 45 c8             	mov    %eax,-0x38(%ebp)
    1a6c:	8b 45 24             	mov    0x24(%ebp),%eax
    1a6f:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1a72:	ff 75 cc             	pushl  -0x34(%ebp)
    1a75:	ff 75 c8             	pushl  -0x38(%ebp)
    1a78:	83 ec 04             	sub    $0x4,%esp
    1a7b:	89 e0                	mov    %esp,%eax
    1a7d:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1a81:	66 89 10             	mov    %dx,(%eax)
    1a84:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1a88:	88 50 02             	mov    %dl,0x2(%eax)
    1a8b:	ff 75 18             	pushl  0x18(%ebp)
    1a8e:	ff 75 14             	pushl  0x14(%ebp)
    1a91:	ff 75 10             	pushl  0x10(%ebp)
    1a94:	ff 75 0c             	pushl  0xc(%ebp)
    1a97:	ff 75 08             	pushl  0x8(%ebp)
    1a9a:	e8 11 ff ff ff       	call   19b0 <drawRect>
    1a9f:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    1aa2:	8b 45 28             	mov    0x28(%ebp),%eax
    1aa5:	89 45 d0             	mov    %eax,-0x30(%ebp)
    1aa8:	8b 45 24             	mov    0x24(%ebp),%eax
    1aab:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1aae:	8b 45 0c             	mov    0xc(%ebp),%eax
    1ab1:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1ab4:	8b 55 10             	mov    0x10(%ebp),%edx
    1ab7:	8b 45 20             	mov    0x20(%ebp),%eax
    1aba:	01 d0                	add    %edx,%eax
    1abc:	2b 45 28             	sub    0x28(%ebp),%eax
    1abf:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1ac2:	ff 75 d4             	pushl  -0x2c(%ebp)
    1ac5:	ff 75 d0             	pushl  -0x30(%ebp)
    1ac8:	83 ec 04             	sub    $0x4,%esp
    1acb:	89 e0                	mov    %esp,%eax
    1acd:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1ad1:	66 89 10             	mov    %dx,(%eax)
    1ad4:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1ad8:	88 50 02             	mov    %dl,0x2(%eax)
    1adb:	ff 75 18             	pushl  0x18(%ebp)
    1ade:	ff 75 14             	pushl  0x14(%ebp)
    1ae1:	ff 75 dc             	pushl  -0x24(%ebp)
    1ae4:	ff 75 d8             	pushl  -0x28(%ebp)
    1ae7:	ff 75 08             	pushl  0x8(%ebp)
    1aea:	e8 c1 fe ff ff       	call   19b0 <drawRect>
    1aef:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1af2:	8b 45 20             	mov    0x20(%ebp),%eax
    1af5:	8b 55 28             	mov    0x28(%ebp),%edx
    1af8:	01 d2                	add    %edx,%edx
    1afa:	29 d0                	sub    %edx,%eax
    1afc:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1aff:	8b 45 28             	mov    0x28(%ebp),%eax
    1b02:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1b05:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b08:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1b0b:	8b 55 10             	mov    0x10(%ebp),%edx
    1b0e:	8b 45 28             	mov    0x28(%ebp),%eax
    1b11:	01 d0                	add    %edx,%eax
    1b13:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1b16:	ff 75 e4             	pushl  -0x1c(%ebp)
    1b19:	ff 75 e0             	pushl  -0x20(%ebp)
    1b1c:	83 ec 04             	sub    $0x4,%esp
    1b1f:	89 e0                	mov    %esp,%eax
    1b21:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1b25:	66 89 10             	mov    %dx,(%eax)
    1b28:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1b2c:	88 50 02             	mov    %dl,0x2(%eax)
    1b2f:	ff 75 18             	pushl  0x18(%ebp)
    1b32:	ff 75 14             	pushl  0x14(%ebp)
    1b35:	ff 75 ec             	pushl  -0x14(%ebp)
    1b38:	ff 75 e8             	pushl  -0x18(%ebp)
    1b3b:	ff 75 08             	pushl  0x8(%ebp)
    1b3e:	e8 6d fe ff ff       	call   19b0 <drawRect>
    1b43:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1b46:	8b 45 20             	mov    0x20(%ebp),%eax
    1b49:	8b 55 28             	mov    0x28(%ebp),%edx
    1b4c:	01 d2                	add    %edx,%edx
    1b4e:	29 d0                	sub    %edx,%eax
    1b50:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1b53:	8b 45 28             	mov    0x28(%ebp),%eax
    1b56:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1b59:	8b 55 0c             	mov    0xc(%ebp),%edx
    1b5c:	8b 45 24             	mov    0x24(%ebp),%eax
    1b5f:	01 d0                	add    %edx,%eax
    1b61:	2b 45 28             	sub    0x28(%ebp),%eax
    1b64:	89 45 f8             	mov    %eax,-0x8(%ebp)
    1b67:	8b 55 10             	mov    0x10(%ebp),%edx
    1b6a:	8b 45 28             	mov    0x28(%ebp),%eax
    1b6d:	01 d0                	add    %edx,%eax
    1b6f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1b72:	ff 75 f4             	pushl  -0xc(%ebp)
    1b75:	ff 75 f0             	pushl  -0x10(%ebp)
    1b78:	83 ec 04             	sub    $0x4,%esp
    1b7b:	89 e0                	mov    %esp,%eax
    1b7d:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1b81:	66 89 10             	mov    %dx,(%eax)
    1b84:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1b88:	88 50 02             	mov    %dl,0x2(%eax)
    1b8b:	ff 75 18             	pushl  0x18(%ebp)
    1b8e:	ff 75 14             	pushl  0x14(%ebp)
    1b91:	ff 75 fc             	pushl  -0x4(%ebp)
    1b94:	ff 75 f8             	pushl  -0x8(%ebp)
    1b97:	ff 75 08             	pushl  0x8(%ebp)
    1b9a:	e8 11 fe ff ff       	call   19b0 <drawRect>
    1b9f:	83 c4 20             	add    $0x20,%esp
}
    1ba2:	90                   	nop
    1ba3:	c9                   	leave  
    1ba4:	c3                   	ret    

00001ba5 <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1ba5:	55                   	push   %ebp
    1ba6:	89 e5                	mov    %esp,%ebp
    1ba8:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1bab:	8b 45 30             	mov    0x30(%ebp),%eax
    1bae:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    1bb1:	8b 45 34             	mov    0x34(%ebp),%eax
    1bb4:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    1bb7:	8b 55 20             	mov    0x20(%ebp),%edx
    1bba:	8b 45 14             	mov    0x14(%ebp),%eax
    1bbd:	29 c2                	sub    %eax,%edx
    1bbf:	89 d0                	mov    %edx,%eax
    1bc1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1bc4:	7d 0d                	jge    1bd3 <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    1bc6:	8b 55 20             	mov    0x20(%ebp),%edx
    1bc9:	8b 45 14             	mov    0x14(%ebp),%eax
    1bcc:	29 c2                	sub    %eax,%edx
    1bce:	89 d0                	mov    %edx,%eax
    1bd0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1bd3:	8b 55 28             	mov    0x28(%ebp),%edx
    1bd6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1bd9:	29 c2                	sub    %eax,%edx
    1bdb:	89 d0                	mov    %edx,%eax
    1bdd:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1be0:	7d 0d                	jge    1bef <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1be2:	8b 55 28             	mov    0x28(%ebp),%edx
    1be5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1be8:	29 c2                	sub    %eax,%edx
    1bea:	89 d0                	mov    %edx,%eax
    1bec:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1bef:	8b 55 24             	mov    0x24(%ebp),%edx
    1bf2:	8b 45 10             	mov    0x10(%ebp),%eax
    1bf5:	29 c2                	sub    %eax,%edx
    1bf7:	89 d0                	mov    %edx,%eax
    1bf9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1bfc:	7d 0d                	jge    1c0b <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    1bfe:	8b 55 24             	mov    0x24(%ebp),%edx
    1c01:	8b 45 10             	mov    0x10(%ebp),%eax
    1c04:	29 c2                	sub    %eax,%edx
    1c06:	89 d0                	mov    %edx,%eax
    1c08:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1c0b:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1c0e:	8b 45 18             	mov    0x18(%ebp),%eax
    1c11:	29 c2                	sub    %eax,%edx
    1c13:	89 d0                	mov    %edx,%eax
    1c15:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1c18:	7d 0d                	jge    1c27 <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    1c1a:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1c1d:	8b 45 18             	mov    0x18(%ebp),%eax
    1c20:	29 c2                	sub    %eax,%edx
    1c22:	89 d0                	mov    %edx,%eax
    1c24:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1c27:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    1c2e:	e9 83 00 00 00       	jmp    1cb6 <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    1c33:	8b 55 14             	mov    0x14(%ebp),%edx
    1c36:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c39:	01 d0                	add    %edx,%eax
    1c3b:	85 c0                	test   %eax,%eax
    1c3d:	78 72                	js     1cb1 <drawBitmap+0x10c>
    1c3f:	8b 55 14             	mov    0x14(%ebp),%edx
    1c42:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c45:	01 c2                	add    %eax,%edx
    1c47:	8b 45 20             	mov    0x20(%ebp),%eax
    1c4a:	39 c2                	cmp    %eax,%edx
    1c4c:	7d 63                	jge    1cb1 <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    1c4e:	8b 55 14             	mov    0x14(%ebp),%edx
    1c51:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c54:	01 c2                	add    %eax,%edx
    1c56:	8b 45 24             	mov    0x24(%ebp),%eax
    1c59:	0f af c2             	imul   %edx,%eax
    1c5c:	89 c2                	mov    %eax,%edx
    1c5e:	8b 45 10             	mov    0x10(%ebp),%eax
    1c61:	01 c2                	add    %eax,%edx
    1c63:	89 d0                	mov    %edx,%eax
    1c65:	01 c0                	add    %eax,%eax
    1c67:	01 c2                	add    %eax,%edx
    1c69:	8b 45 08             	mov    0x8(%ebp),%eax
    1c6c:	01 d0                	add    %edx,%eax
    1c6e:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    1c71:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1c74:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1c77:	01 c2                	add    %eax,%edx
    1c79:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1c7c:	0f af c2             	imul   %edx,%eax
    1c7f:	89 c2                	mov    %eax,%edx
    1c81:	8b 45 18             	mov    0x18(%ebp),%eax
    1c84:	01 c2                	add    %eax,%edx
    1c86:	89 d0                	mov    %edx,%eax
    1c88:	01 c0                	add    %eax,%eax
    1c8a:	01 c2                	add    %eax,%edx
    1c8c:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c8f:	01 d0                	add    %edx,%eax
    1c91:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    1c94:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1c97:	89 d0                	mov    %edx,%eax
    1c99:	01 c0                	add    %eax,%eax
    1c9b:	01 d0                	add    %edx,%eax
    1c9d:	83 ec 04             	sub    $0x4,%esp
    1ca0:	50                   	push   %eax
    1ca1:	ff 75 e4             	pushl  -0x1c(%ebp)
    1ca4:	ff 75 e8             	pushl  -0x18(%ebp)
    1ca7:	e8 23 e7 ff ff       	call   3cf <memmove>
    1cac:	83 c4 10             	add    $0x10,%esp
    1caf:	eb 01                	jmp    1cb2 <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    1cb1:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1cb2:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    1cb6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1cb9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1cbc:	0f 8c 71 ff ff ff    	jl     1c33 <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    1cc2:	90                   	nop
    1cc3:	c9                   	leave  
    1cc4:	c3                   	ret    

00001cc5 <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1cc5:	55                   	push   %ebp
    1cc6:	89 e5                	mov    %esp,%ebp
    1cc8:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1ccb:	8b 45 30             	mov    0x30(%ebp),%eax
    1cce:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    1cd1:	8b 45 34             	mov    0x34(%ebp),%eax
    1cd4:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    1cd7:	8b 55 20             	mov    0x20(%ebp),%edx
    1cda:	8b 45 14             	mov    0x14(%ebp),%eax
    1cdd:	29 c2                	sub    %eax,%edx
    1cdf:	89 d0                	mov    %edx,%eax
    1ce1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1ce4:	7d 0d                	jge    1cf3 <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    1ce6:	8b 55 20             	mov    0x20(%ebp),%edx
    1ce9:	8b 45 14             	mov    0x14(%ebp),%eax
    1cec:	29 c2                	sub    %eax,%edx
    1cee:	89 d0                	mov    %edx,%eax
    1cf0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1cf3:	8b 55 28             	mov    0x28(%ebp),%edx
    1cf6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1cf9:	29 c2                	sub    %eax,%edx
    1cfb:	89 d0                	mov    %edx,%eax
    1cfd:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1d00:	7d 0d                	jge    1d0f <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1d02:	8b 55 28             	mov    0x28(%ebp),%edx
    1d05:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1d08:	29 c2                	sub    %eax,%edx
    1d0a:	89 d0                	mov    %edx,%eax
    1d0c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1d0f:	8b 55 24             	mov    0x24(%ebp),%edx
    1d12:	8b 45 10             	mov    0x10(%ebp),%eax
    1d15:	29 c2                	sub    %eax,%edx
    1d17:	89 d0                	mov    %edx,%eax
    1d19:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1d1c:	7d 0d                	jge    1d2b <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    1d1e:	8b 55 24             	mov    0x24(%ebp),%edx
    1d21:	8b 45 10             	mov    0x10(%ebp),%eax
    1d24:	29 c2                	sub    %eax,%edx
    1d26:	89 d0                	mov    %edx,%eax
    1d28:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1d2b:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1d2e:	8b 45 18             	mov    0x18(%ebp),%eax
    1d31:	29 c2                	sub    %eax,%edx
    1d33:	89 d0                	mov    %edx,%eax
    1d35:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1d38:	7d 0d                	jge    1d47 <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    1d3a:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1d3d:	8b 45 18             	mov    0x18(%ebp),%eax
    1d40:	29 c2                	sub    %eax,%edx
    1d42:	89 d0                	mov    %edx,%eax
    1d44:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    1d47:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1d4e:	e9 b8 00 00 00       	jmp    1e0b <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    1d53:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1d5a:	e9 9c 00 00 00       	jmp    1dfb <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    1d5f:	8b 55 14             	mov    0x14(%ebp),%edx
    1d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1d65:	01 c2                	add    %eax,%edx
    1d67:	8b 45 24             	mov    0x24(%ebp),%eax
    1d6a:	0f af c2             	imul   %edx,%eax
    1d6d:	89 c2                	mov    %eax,%edx
    1d6f:	8b 45 10             	mov    0x10(%ebp),%eax
    1d72:	01 c2                	add    %eax,%edx
    1d74:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1d77:	01 c2                	add    %eax,%edx
    1d79:	89 d0                	mov    %edx,%eax
    1d7b:	01 c0                	add    %eax,%eax
    1d7d:	01 c2                	add    %eax,%edx
    1d7f:	8b 45 08             	mov    0x8(%ebp),%eax
    1d82:	01 d0                	add    %edx,%eax
    1d84:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    1d87:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1d8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1d8d:	01 c2                	add    %eax,%edx
    1d8f:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1d92:	0f af c2             	imul   %edx,%eax
    1d95:	89 c2                	mov    %eax,%edx
    1d97:	8b 45 18             	mov    0x18(%ebp),%eax
    1d9a:	01 c2                	add    %eax,%edx
    1d9c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1d9f:	01 c2                	add    %eax,%edx
    1da1:	89 d0                	mov    %edx,%eax
    1da3:	01 c0                	add    %eax,%eax
    1da5:	01 c2                	add    %eax,%edx
    1da7:	8b 45 0c             	mov    0xc(%ebp),%eax
    1daa:	01 d0                	add    %edx,%eax
    1dac:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    1daf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1db2:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1db6:	3c ff                	cmp    $0xff,%al
    1db8:	75 15                	jne    1dcf <drawTransparentBitmap+0x10a>
    1dba:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1dbd:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1dc1:	3c ff                	cmp    $0xff,%al
    1dc3:	75 0a                	jne    1dcf <drawTransparentBitmap+0x10a>
    1dc5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1dc8:	0f b6 00             	movzbl (%eax),%eax
    1dcb:	3c ff                	cmp    $0xff,%al
    1dcd:	74 27                	je     1df6 <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    1dcf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1dd2:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    1dd6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1dd9:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    1ddc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1ddf:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    1de3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1de6:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    1de9:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1dec:	0f b6 10             	movzbl (%eax),%edx
    1def:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1df2:	88 10                	mov    %dl,(%eax)
    1df4:	eb 01                	jmp    1df7 <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    1df6:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    1df7:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1dfb:	8b 45 34             	mov    0x34(%ebp),%eax
    1dfe:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1e01:	0f 8f 58 ff ff ff    	jg     1d5f <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    1e07:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1e0b:	8b 45 30             	mov    0x30(%ebp),%eax
    1e0e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1e11:	0f 8f 3c ff ff ff    	jg     1d53 <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    1e17:	90                   	nop
    1e18:	c9                   	leave  
    1e19:	c3                   	ret    

00001e1a <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    1e1a:	55                   	push   %ebp
    1e1b:	89 e5                	mov    %esp,%ebp
    1e1d:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    1e20:	ff 75 24             	pushl  0x24(%ebp)
    1e23:	ff 75 20             	pushl  0x20(%ebp)
    1e26:	ff 75 1c             	pushl  0x1c(%ebp)
    1e29:	ff 75 18             	pushl  0x18(%ebp)
    1e2c:	ff 75 1c             	pushl  0x1c(%ebp)
    1e2f:	ff 75 18             	pushl  0x18(%ebp)
    1e32:	ff 75 14             	pushl  0x14(%ebp)
    1e35:	ff 75 10             	pushl  0x10(%ebp)
    1e38:	ff 75 14             	pushl  0x14(%ebp)
    1e3b:	ff 75 10             	pushl  0x10(%ebp)
    1e3e:	ff 75 0c             	pushl  0xc(%ebp)
    1e41:	ff 75 08             	pushl  0x8(%ebp)
    1e44:	e8 5c fd ff ff       	call   1ba5 <drawBitmap>
    1e49:	83 c4 30             	add    $0x30,%esp
}
    1e4c:	90                   	nop
    1e4d:	c9                   	leave  
    1e4e:	c3                   	ret    

00001e4f <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    1e4f:	55                   	push   %ebp
    1e50:	89 e5                	mov    %esp,%ebp
    1e52:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1e55:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1e58:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1e5b:	8b 45 20             	mov    0x20(%ebp),%eax
    1e5e:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1e61:	8b 55 14             	mov    0x14(%ebp),%edx
    1e64:	8b 45 10             	mov    0x10(%ebp),%eax
    1e67:	29 c2                	sub    %eax,%edx
    1e69:	89 d0                	mov    %edx,%eax
    1e6b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1e6e:	7d 0d                	jge    1e7d <colorShift+0x2e>
        draw_h = s.h - p.y;
    1e70:	8b 55 14             	mov    0x14(%ebp),%edx
    1e73:	8b 45 10             	mov    0x10(%ebp),%eax
    1e76:	29 c2                	sub    %eax,%edx
    1e78:	89 d0                	mov    %edx,%eax
    1e7a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1e7d:	8b 55 18             	mov    0x18(%ebp),%edx
    1e80:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e83:	29 c2                	sub    %eax,%edx
    1e85:	89 d0                	mov    %edx,%eax
    1e87:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1e8a:	7d 0d                	jge    1e99 <colorShift+0x4a>
        draw_w = s.w - p.x;
    1e8c:	8b 55 18             	mov    0x18(%ebp),%edx
    1e8f:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e92:	29 c2                	sub    %eax,%edx
    1e94:	89 d0                	mov    %edx,%eax
    1e96:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1e99:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1ea0:	e9 fc 00 00 00       	jmp    1fa1 <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    1ea5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1eac:	e9 e0 00 00 00       	jmp    1f91 <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    1eb1:	8b 55 10             	mov    0x10(%ebp),%edx
    1eb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1eb7:	01 c2                	add    %eax,%edx
    1eb9:	8b 45 18             	mov    0x18(%ebp),%eax
    1ebc:	0f af c2             	imul   %edx,%eax
    1ebf:	89 c2                	mov    %eax,%edx
    1ec1:	8b 45 0c             	mov    0xc(%ebp),%eax
    1ec4:	01 c2                	add    %eax,%edx
    1ec6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1ec9:	01 c2                	add    %eax,%edx
    1ecb:	89 d0                	mov    %edx,%eax
    1ecd:	01 c0                	add    %eax,%eax
    1ecf:	01 c2                	add    %eax,%edx
    1ed1:	8b 45 08             	mov    0x8(%ebp),%eax
    1ed4:	01 d0                	add    %edx,%eax
    1ed6:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    1ed9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1edc:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1ee0:	3c c8                	cmp    $0xc8,%al
    1ee2:	0f 86 a5 00 00 00    	jbe    1f8d <colorShift+0x13e>
    1ee8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1eeb:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1eef:	3c c8                	cmp    $0xc8,%al
    1ef1:	0f 86 96 00 00 00    	jbe    1f8d <colorShift+0x13e>
    1ef7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1efa:	0f b6 00             	movzbl (%eax),%eax
    1efd:	3c c8                	cmp    $0xc8,%al
    1eff:	0f 86 88 00 00 00    	jbe    1f8d <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    1f05:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f08:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1f0c:	0f b6 d0             	movzbl %al,%edx
    1f0f:	8b 45 24             	mov    0x24(%ebp),%eax
    1f12:	01 d0                	add    %edx,%eax
    1f14:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1f1a:	89 d0                	mov    %edx,%eax
    1f1c:	c1 f8 1f             	sar    $0x1f,%eax
    1f1f:	c1 e8 18             	shr    $0x18,%eax
    1f22:	01 c2                	add    %eax,%edx
    1f24:	0f b6 d2             	movzbl %dl,%edx
    1f27:	29 c2                	sub    %eax,%edx
    1f29:	89 d0                	mov    %edx,%eax
    1f2b:	89 c2                	mov    %eax,%edx
    1f2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f30:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    1f33:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f36:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1f3a:	0f b6 d0             	movzbl %al,%edx
    1f3d:	8b 45 24             	mov    0x24(%ebp),%eax
    1f40:	01 d0                	add    %edx,%eax
    1f42:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1f48:	89 d0                	mov    %edx,%eax
    1f4a:	c1 f8 1f             	sar    $0x1f,%eax
    1f4d:	c1 e8 18             	shr    $0x18,%eax
    1f50:	01 c2                	add    %eax,%edx
    1f52:	0f b6 d2             	movzbl %dl,%edx
    1f55:	29 c2                	sub    %eax,%edx
    1f57:	89 d0                	mov    %edx,%eax
    1f59:	89 c2                	mov    %eax,%edx
    1f5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f5e:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    1f61:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f64:	0f b6 00             	movzbl (%eax),%eax
    1f67:	0f b6 d0             	movzbl %al,%edx
    1f6a:	8b 45 24             	mov    0x24(%ebp),%eax
    1f6d:	01 d0                	add    %edx,%eax
    1f6f:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    1f75:	89 d0                	mov    %edx,%eax
    1f77:	c1 f8 1f             	sar    $0x1f,%eax
    1f7a:	c1 e8 18             	shr    $0x18,%eax
    1f7d:	01 c2                	add    %eax,%edx
    1f7f:	0f b6 d2             	movzbl %dl,%edx
    1f82:	29 c2                	sub    %eax,%edx
    1f84:	89 d0                	mov    %edx,%eax
    1f86:	89 c2                	mov    %eax,%edx
    1f88:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f8b:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1f8d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1f91:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1f94:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1f97:	0f 8c 14 ff ff ff    	jl     1eb1 <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1f9d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1fa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1fa4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1fa7:	0f 8c f8 fe ff ff    	jl     1ea5 <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    1fad:	90                   	nop
    1fae:	c9                   	leave  
    1faf:	c3                   	ret    

00001fb0 <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    1fb0:	55                   	push   %ebp
    1fb1:	89 e5                	mov    %esp,%ebp
    1fb3:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    1fb6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1fbd:	e9 fb 00 00 00       	jmp    20bd <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    1fc2:	8b 55 14             	mov    0x14(%ebp),%edx
    1fc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1fc8:	01 c2                	add    %eax,%edx
    1fca:	0f b7 05 a2 e8 01 00 	movzwl 0x1e8a2,%eax
    1fd1:	0f b7 c0             	movzwl %ax,%eax
    1fd4:	39 c2                	cmp    %eax,%edx
    1fd6:	0f 8f eb 00 00 00    	jg     20c7 <drawMouse+0x117>
    1fdc:	8b 55 14             	mov    0x14(%ebp),%edx
    1fdf:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1fe2:	01 d0                	add    %edx,%eax
    1fe4:	85 c0                	test   %eax,%eax
    1fe6:	0f 88 db 00 00 00    	js     20c7 <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    1fec:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1ff3:	e9 b7 00 00 00       	jmp    20af <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    1ff8:	8b 55 10             	mov    0x10(%ebp),%edx
    1ffb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1ffe:	01 c2                	add    %eax,%edx
    2000:	0f b7 05 a0 e8 01 00 	movzwl 0x1e8a0,%eax
    2007:	0f b7 c0             	movzwl %ax,%eax
    200a:	39 c2                	cmp    %eax,%edx
    200c:	0f 8f a7 00 00 00    	jg     20b9 <drawMouse+0x109>
    2012:	8b 55 10             	mov    0x10(%ebp),%edx
    2015:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2018:	01 d0                	add    %edx,%eax
    201a:	85 c0                	test   %eax,%eax
    201c:	0f 88 97 00 00 00    	js     20b9 <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    2022:	8b 55 fc             	mov    -0x4(%ebp),%edx
    2025:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    2028:	89 d0                	mov    %edx,%eax
    202a:	c1 e0 04             	shl    $0x4,%eax
    202d:	29 d0                	sub    %edx,%eax
    202f:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    2035:	01 c2                	add    %eax,%edx
    2037:	8b 45 f8             	mov    -0x8(%ebp),%eax
    203a:	01 d0                	add    %edx,%eax
    203c:	05 a0 5f 01 00       	add    $0x15fa0,%eax
    2041:	0f b6 00             	movzbl (%eax),%eax
    2044:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    2047:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    204b:	74 5e                	je     20ab <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    204d:	8b 55 14             	mov    0x14(%ebp),%edx
    2050:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2053:	01 c2                	add    %eax,%edx
    2055:	0f b7 05 a0 e8 01 00 	movzwl 0x1e8a0,%eax
    205c:	0f b7 c0             	movzwl %ax,%eax
    205f:	0f af c2             	imul   %edx,%eax
    2062:	89 c2                	mov    %eax,%edx
    2064:	8b 45 10             	mov    0x10(%ebp),%eax
    2067:	01 c2                	add    %eax,%edx
    2069:	8b 45 f8             	mov    -0x8(%ebp),%eax
    206c:	01 c2                	add    %eax,%edx
    206e:	89 d0                	mov    %edx,%eax
    2070:	01 c0                	add    %eax,%eax
    2072:	01 c2                	add    %eax,%edx
    2074:	8b 45 08             	mov    0x8(%ebp),%eax
    2077:	01 d0                	add    %edx,%eax
    2079:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    207c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    2080:	8d 50 ff             	lea    -0x1(%eax),%edx
    2083:	89 d0                	mov    %edx,%eax
    2085:	01 c0                	add    %eax,%eax
    2087:	01 d0                	add    %edx,%eax
    2089:	05 a8 e8 01 00       	add    $0x1e8a8,%eax
    208e:	83 ec 04             	sub    $0x4,%esp
    2091:	89 e2                	mov    %esp,%edx
    2093:	0f b7 08             	movzwl (%eax),%ecx
    2096:	66 89 0a             	mov    %cx,(%edx)
    2099:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    209d:	88 42 02             	mov    %al,0x2(%edx)
    20a0:	ff 75 f0             	pushl  -0x10(%ebp)
    20a3:	e8 73 f6 ff ff       	call   171b <drawPoint>
    20a8:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    20ab:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    20af:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    20b3:	0f 8e 3f ff ff ff    	jle    1ff8 <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    20b9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    20bd:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    20c1:	0f 8e fb fe ff ff    	jle    1fc2 <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    20c7:	90                   	nop
    20c8:	c9                   	leave  
    20c9:	c3                   	ret    

000020ca <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    20ca:	55                   	push   %ebp
    20cb:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    20cd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    20d1:	78 1b                	js     20ee <getColor+0x24>
    20d3:	8b 45 08             	mov    0x8(%ebp),%eax
    20d6:	8b 40 04             	mov    0x4(%eax),%eax
    20d9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    20dc:	7c 10                	jl     20ee <getColor+0x24>
    20de:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    20e2:	78 0a                	js     20ee <getColor+0x24>
    20e4:	8b 45 08             	mov    0x8(%ebp),%eax
    20e7:	8b 00                	mov    (%eax),%eax
    20e9:	3b 45 10             	cmp    0x10(%ebp),%eax
    20ec:	7d 10                	jge    20fe <getColor+0x34>
    {
        *isInPic = 1;
    20ee:	8b 45 14             	mov    0x14(%ebp),%eax
    20f1:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    20f7:	b8 51 e2 01 00       	mov    $0x1e251,%eax
    20fc:	eb 44                	jmp    2142 <getColor+0x78>
    }

    if (y == pic->height)
    20fe:	8b 45 08             	mov    0x8(%ebp),%eax
    2101:	8b 40 04             	mov    0x4(%eax),%eax
    2104:	3b 45 0c             	cmp    0xc(%ebp),%eax
    2107:	75 04                	jne    210d <getColor+0x43>
        y--;
    2109:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    210d:	8b 45 08             	mov    0x8(%ebp),%eax
    2110:	8b 00                	mov    (%eax),%eax
    2112:	3b 45 10             	cmp    0x10(%ebp),%eax
    2115:	75 04                	jne    211b <getColor+0x51>
        x--;
    2117:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    211b:	8b 45 14             	mov    0x14(%ebp),%eax
    211e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    2124:	8b 45 08             	mov    0x8(%ebp),%eax
    2127:	8b 48 08             	mov    0x8(%eax),%ecx
    212a:	8b 45 08             	mov    0x8(%ebp),%eax
    212d:	8b 00                	mov    (%eax),%eax
    212f:	0f af 45 0c          	imul   0xc(%ebp),%eax
    2133:	89 c2                	mov    %eax,%edx
    2135:	8b 45 10             	mov    0x10(%ebp),%eax
    2138:	01 c2                	add    %eax,%edx
    213a:	89 d0                	mov    %edx,%eax
    213c:	01 c0                	add    %eax,%eax
    213e:	01 d0                	add    %edx,%eax
    2140:	01 c8                	add    %ecx,%eax
}
    2142:	5d                   	pop    %ebp
    2143:	c3                   	ret    

00002144 <setColor>:

int setColor(RGB *src, RGB *dst)
{
    2144:	55                   	push   %ebp
    2145:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    2147:	8b 45 08             	mov    0x8(%ebp),%eax
    214a:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    214e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2151:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    2154:	8b 45 08             	mov    0x8(%ebp),%eax
    2157:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    215b:	8b 45 0c             	mov    0xc(%ebp),%eax
    215e:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    2161:	8b 45 08             	mov    0x8(%ebp),%eax
    2164:	0f b6 10             	movzbl (%eax),%edx
    2167:	8b 45 0c             	mov    0xc(%ebp),%eax
    216a:	88 10                	mov    %dl,(%eax)

    return 1;
    216c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2171:	5d                   	pop    %ebp
    2172:	c3                   	ret    

00002173 <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    2173:	55                   	push   %ebp
    2174:	89 e5                	mov    %esp,%ebp
    2176:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    2179:	d9 45 10             	flds   0x10(%ebp)
    217c:	d9 7d be             	fnstcw -0x42(%ebp)
    217f:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    2183:	b4 0c                	mov    $0xc,%ah
    2185:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    2189:	d9 6d bc             	fldcw  -0x44(%ebp)
    218c:	db 5d fc             	fistpl -0x4(%ebp)
    218f:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    2192:	d9 45 0c             	flds   0xc(%ebp)
    2195:	d9 6d bc             	fldcw  -0x44(%ebp)
    2198:	db 5d f8             	fistpl -0x8(%ebp)
    219b:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    219e:	db 45 fc             	fildl  -0x4(%ebp)
    21a1:	d9 45 10             	flds   0x10(%ebp)
    21a4:	d9 c9                	fxch   %st(1)
    21a6:	df e9                	fucomip %st(1),%st
    21a8:	dd d8                	fstp   %st(0)
    21aa:	76 04                	jbe    21b0 <mixColor+0x3d>
        x--;
    21ac:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    21b0:	db 45 f8             	fildl  -0x8(%ebp)
    21b3:	d9 45 0c             	flds   0xc(%ebp)
    21b6:	d9 c9                	fxch   %st(1)
    21b8:	df e9                	fucomip %st(1),%st
    21ba:	dd d8                	fstp   %st(0)
    21bc:	76 04                	jbe    21c2 <mixColor+0x4f>
        y--;
    21be:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    21c2:	8d 45 c0             	lea    -0x40(%ebp),%eax
    21c5:	50                   	push   %eax
    21c6:	ff 75 fc             	pushl  -0x4(%ebp)
    21c9:	ff 75 f8             	pushl  -0x8(%ebp)
    21cc:	ff 75 08             	pushl  0x8(%ebp)
    21cf:	e8 f6 fe ff ff       	call   20ca <getColor>
    21d4:	83 c4 10             	add    $0x10,%esp
    21d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    21da:	8b 45 f8             	mov    -0x8(%ebp),%eax
    21dd:	83 c0 01             	add    $0x1,%eax
    21e0:	8d 55 c0             	lea    -0x40(%ebp),%edx
    21e3:	83 c2 04             	add    $0x4,%edx
    21e6:	52                   	push   %edx
    21e7:	ff 75 fc             	pushl  -0x4(%ebp)
    21ea:	50                   	push   %eax
    21eb:	ff 75 08             	pushl  0x8(%ebp)
    21ee:	e8 d7 fe ff ff       	call   20ca <getColor>
    21f3:	83 c4 10             	add    $0x10,%esp
    21f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    21f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    21fc:	83 c0 01             	add    $0x1,%eax
    21ff:	8d 55 c0             	lea    -0x40(%ebp),%edx
    2202:	83 c2 08             	add    $0x8,%edx
    2205:	52                   	push   %edx
    2206:	50                   	push   %eax
    2207:	ff 75 f8             	pushl  -0x8(%ebp)
    220a:	ff 75 08             	pushl  0x8(%ebp)
    220d:	e8 b8 fe ff ff       	call   20ca <getColor>
    2212:	83 c4 10             	add    $0x10,%esp
    2215:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    2218:	8b 45 fc             	mov    -0x4(%ebp),%eax
    221b:	8d 50 01             	lea    0x1(%eax),%edx
    221e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2221:	83 c0 01             	add    $0x1,%eax
    2224:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    2227:	83 c1 0c             	add    $0xc,%ecx
    222a:	51                   	push   %ecx
    222b:	52                   	push   %edx
    222c:	50                   	push   %eax
    222d:	ff 75 08             	pushl  0x8(%ebp)
    2230:	e8 95 fe ff ff       	call   20ca <getColor>
    2235:	83 c4 10             	add    $0x10,%esp
    2238:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    223b:	db 45 fc             	fildl  -0x4(%ebp)
    223e:	d9 45 10             	flds   0x10(%ebp)
    2241:	de e1                	fsubp  %st,%st(1)
    2243:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    2246:	db 45 f8             	fildl  -0x8(%ebp)
    2249:	d9 45 0c             	flds   0xc(%ebp)
    224c:	de e1                	fsubp  %st,%st(1)
    224e:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    2251:	d9 45 e4             	flds   -0x1c(%ebp)
    2254:	d8 4d e0             	fmuls  -0x20(%ebp)
    2257:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    225a:	d9 e8                	fld1   
    225c:	d8 65 e0             	fsubs  -0x20(%ebp)
    225f:	d8 4d e4             	fmuls  -0x1c(%ebp)
    2262:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    2265:	d9 e8                	fld1   
    2267:	d8 65 e4             	fsubs  -0x1c(%ebp)
    226a:	d8 4d e0             	fmuls  -0x20(%ebp)
    226d:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    2270:	d9 e8                	fld1   
    2272:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2275:	d9 e8                	fld1   
    2277:	d8 65 e0             	fsubs  -0x20(%ebp)
    227a:	de c9                	fmulp  %st,%st(1)
    227c:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    227f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2282:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2286:	0f b6 c0             	movzbl %al,%eax
    2289:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    228c:	db 45 b4             	fildl  -0x4c(%ebp)
    228f:	d8 4d d0             	fmuls  -0x30(%ebp)
    2292:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2295:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2298:	db 45 b4             	fildl  -0x4c(%ebp)
    229b:	de c9                	fmulp  %st,%st(1)
    229d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    22a0:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    22a4:	0f b6 c0             	movzbl %al,%eax
    22a7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22aa:	db 45 b4             	fildl  -0x4c(%ebp)
    22ad:	d8 4d d4             	fmuls  -0x2c(%ebp)
    22b0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    22b3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22b6:	db 45 b4             	fildl  -0x4c(%ebp)
    22b9:	de c9                	fmulp  %st,%st(1)
    22bb:	de c1                	faddp  %st,%st(1)
    22bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    22c0:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    22c4:	0f b6 c0             	movzbl %al,%eax
    22c7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22ca:	db 45 b4             	fildl  -0x4c(%ebp)
    22cd:	d8 4d d8             	fmuls  -0x28(%ebp)
    22d0:	8b 45 c8             	mov    -0x38(%ebp),%eax
    22d3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22d6:	db 45 b4             	fildl  -0x4c(%ebp)
    22d9:	de c9                	fmulp  %st,%st(1)
    22db:	de c1                	faddp  %st,%st(1)
    22dd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    22e0:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    22e4:	0f b6 c0             	movzbl %al,%eax
    22e7:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22ea:	db 45 b4             	fildl  -0x4c(%ebp)
    22ed:	d8 4d dc             	fmuls  -0x24(%ebp)
    22f0:	8b 45 cc             	mov    -0x34(%ebp),%eax
    22f3:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    22f6:	db 45 b4             	fildl  -0x4c(%ebp)
    22f9:	de c9                	fmulp  %st,%st(1)
    22fb:	de c1                	faddp  %st,%st(1)
    22fd:	d9 7d be             	fnstcw -0x42(%ebp)
    2300:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    2304:	b4 0c                	mov    $0xc,%ah
    2306:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    230a:	d9 6d bc             	fldcw  -0x44(%ebp)
    230d:	db 5d b8             	fistpl -0x48(%ebp)
    2310:	d9 6d be             	fldcw  -0x42(%ebp)
    2313:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2316:	89 c2                	mov    %eax,%edx
    2318:	8b 45 14             	mov    0x14(%ebp),%eax
    231b:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    231e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2321:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2325:	0f b6 c0             	movzbl %al,%eax
    2328:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    232b:	db 45 b4             	fildl  -0x4c(%ebp)
    232e:	d8 4d d0             	fmuls  -0x30(%ebp)
    2331:	8b 45 c0             	mov    -0x40(%ebp),%eax
    2334:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2337:	db 45 b4             	fildl  -0x4c(%ebp)
    233a:	de c9                	fmulp  %st,%st(1)
    233c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    233f:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2343:	0f b6 c0             	movzbl %al,%eax
    2346:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2349:	db 45 b4             	fildl  -0x4c(%ebp)
    234c:	d8 4d d4             	fmuls  -0x2c(%ebp)
    234f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2352:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2355:	db 45 b4             	fildl  -0x4c(%ebp)
    2358:	de c9                	fmulp  %st,%st(1)
    235a:	de c1                	faddp  %st,%st(1)
    235c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    235f:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2363:	0f b6 c0             	movzbl %al,%eax
    2366:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2369:	db 45 b4             	fildl  -0x4c(%ebp)
    236c:	d8 4d d8             	fmuls  -0x28(%ebp)
    236f:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2372:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2375:	db 45 b4             	fildl  -0x4c(%ebp)
    2378:	de c9                	fmulp  %st,%st(1)
    237a:	de c1                	faddp  %st,%st(1)
    237c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    237f:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2383:	0f b6 c0             	movzbl %al,%eax
    2386:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2389:	db 45 b4             	fildl  -0x4c(%ebp)
    238c:	d8 4d dc             	fmuls  -0x24(%ebp)
    238f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2392:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2395:	db 45 b4             	fildl  -0x4c(%ebp)
    2398:	de c9                	fmulp  %st,%st(1)
    239a:	de c1                	faddp  %st,%st(1)
    239c:	d9 6d bc             	fldcw  -0x44(%ebp)
    239f:	db 5d b8             	fistpl -0x48(%ebp)
    23a2:	d9 6d be             	fldcw  -0x42(%ebp)
    23a5:	8b 45 b8             	mov    -0x48(%ebp),%eax
    23a8:	89 c2                	mov    %eax,%edx
    23aa:	8b 45 14             	mov    0x14(%ebp),%eax
    23ad:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    23b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    23b3:	0f b6 00             	movzbl (%eax),%eax
    23b6:	0f b6 c0             	movzbl %al,%eax
    23b9:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    23bc:	db 45 b4             	fildl  -0x4c(%ebp)
    23bf:	d8 4d d0             	fmuls  -0x30(%ebp)
    23c2:	8b 45 c0             	mov    -0x40(%ebp),%eax
    23c5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    23c8:	db 45 b4             	fildl  -0x4c(%ebp)
    23cb:	de c9                	fmulp  %st,%st(1)
    23cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    23d0:	0f b6 00             	movzbl (%eax),%eax
    23d3:	0f b6 c0             	movzbl %al,%eax
    23d6:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    23d9:	db 45 b4             	fildl  -0x4c(%ebp)
    23dc:	d8 4d d4             	fmuls  -0x2c(%ebp)
    23df:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    23e2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    23e5:	db 45 b4             	fildl  -0x4c(%ebp)
    23e8:	de c9                	fmulp  %st,%st(1)
    23ea:	de c1                	faddp  %st,%st(1)
    23ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
    23ef:	0f b6 00             	movzbl (%eax),%eax
    23f2:	0f b6 c0             	movzbl %al,%eax
    23f5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    23f8:	db 45 b4             	fildl  -0x4c(%ebp)
    23fb:	d8 4d d8             	fmuls  -0x28(%ebp)
    23fe:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2401:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2404:	db 45 b4             	fildl  -0x4c(%ebp)
    2407:	de c9                	fmulp  %st,%st(1)
    2409:	de c1                	faddp  %st,%st(1)
    240b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    240e:	0f b6 00             	movzbl (%eax),%eax
    2411:	0f b6 c0             	movzbl %al,%eax
    2414:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2417:	db 45 b4             	fildl  -0x4c(%ebp)
    241a:	d8 4d dc             	fmuls  -0x24(%ebp)
    241d:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2420:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2423:	db 45 b4             	fildl  -0x4c(%ebp)
    2426:	de c9                	fmulp  %st,%st(1)
    2428:	de c1                	faddp  %st,%st(1)
    242a:	d9 6d bc             	fldcw  -0x44(%ebp)
    242d:	db 5d b8             	fistpl -0x48(%ebp)
    2430:	d9 6d be             	fldcw  -0x42(%ebp)
    2433:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2436:	89 c2                	mov    %eax,%edx
    2438:	8b 45 14             	mov    0x14(%ebp),%eax
    243b:	88 10                	mov    %dl,(%eax)

    return 1;
    243d:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2442:	c9                   	leave  
    2443:	c3                   	ret    

00002444 <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    2444:	55                   	push   %ebp
    2445:	89 e5                	mov    %esp,%ebp
    2447:	53                   	push   %ebx
    2448:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    244b:	8b 45 10             	mov    0x10(%ebp),%eax
    244e:	c1 f8 10             	sar    $0x10,%eax
    2451:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    2454:	8b 45 0c             	mov    0xc(%ebp),%eax
    2457:	c1 f8 10             	sar    $0x10,%eax
    245a:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    245d:	8d 45 bc             	lea    -0x44(%ebp),%eax
    2460:	50                   	push   %eax
    2461:	ff 75 f8             	pushl  -0x8(%ebp)
    2464:	ff 75 f4             	pushl  -0xc(%ebp)
    2467:	ff 75 08             	pushl  0x8(%ebp)
    246a:	e8 5b fc ff ff       	call   20ca <getColor>
    246f:	83 c4 10             	add    $0x10,%esp
    2472:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    2475:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2478:	83 c0 01             	add    $0x1,%eax
    247b:	8d 55 bc             	lea    -0x44(%ebp),%edx
    247e:	83 c2 04             	add    $0x4,%edx
    2481:	52                   	push   %edx
    2482:	ff 75 f8             	pushl  -0x8(%ebp)
    2485:	50                   	push   %eax
    2486:	ff 75 08             	pushl  0x8(%ebp)
    2489:	e8 3c fc ff ff       	call   20ca <getColor>
    248e:	83 c4 10             	add    $0x10,%esp
    2491:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    2494:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2497:	83 c0 01             	add    $0x1,%eax
    249a:	8d 55 bc             	lea    -0x44(%ebp),%edx
    249d:	83 c2 08             	add    $0x8,%edx
    24a0:	52                   	push   %edx
    24a1:	50                   	push   %eax
    24a2:	ff 75 f4             	pushl  -0xc(%ebp)
    24a5:	ff 75 08             	pushl  0x8(%ebp)
    24a8:	e8 1d fc ff ff       	call   20ca <getColor>
    24ad:	83 c4 10             	add    $0x10,%esp
    24b0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    24b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    24b6:	8d 50 01             	lea    0x1(%eax),%edx
    24b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    24bc:	83 c0 01             	add    $0x1,%eax
    24bf:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    24c2:	83 c1 0c             	add    $0xc,%ecx
    24c5:	51                   	push   %ecx
    24c6:	52                   	push   %edx
    24c7:	50                   	push   %eax
    24c8:	ff 75 08             	pushl  0x8(%ebp)
    24cb:	e8 fa fb ff ff       	call   20ca <getColor>
    24d0:	83 c4 10             	add    $0x10,%esp
    24d3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    24d6:	8b 45 10             	mov    0x10(%ebp),%eax
    24d9:	0f b7 c0             	movzwl %ax,%eax
    24dc:	c1 f8 08             	sar    $0x8,%eax
    24df:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    24e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    24e5:	0f b7 c0             	movzwl %ax,%eax
    24e8:	c1 f8 08             	sar    $0x8,%eax
    24eb:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    24ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
    24f1:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    24f5:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    24f8:	b8 ff 00 00 00       	mov    $0xff,%eax
    24fd:	2b 45 dc             	sub    -0x24(%ebp),%eax
    2500:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    2504:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    2507:	b8 ff 00 00 00       	mov    $0xff,%eax
    250c:	2b 45 e0             	sub    -0x20(%ebp),%eax
    250f:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    2513:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    2516:	b8 ff 00 00 00       	mov    $0xff,%eax
    251b:	2b 45 e0             	sub    -0x20(%ebp),%eax
    251e:	89 c2                	mov    %eax,%edx
    2520:	b8 ff 00 00 00       	mov    $0xff,%eax
    2525:	2b 45 dc             	sub    -0x24(%ebp),%eax
    2528:	0f af c2             	imul   %edx,%eax
    252b:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    252e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2531:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2535:	0f b6 c0             	movzbl %al,%eax
    2538:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    253c:	8b 55 bc             	mov    -0x44(%ebp),%edx
    253f:	0f af d0             	imul   %eax,%edx
    2542:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2545:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2549:	0f b6 c0             	movzbl %al,%eax
    254c:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2550:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2553:	0f af c1             	imul   %ecx,%eax
    2556:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2559:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    255c:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2560:	0f b6 c0             	movzbl %al,%eax
    2563:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2567:	8b 55 c8             	mov    -0x38(%ebp),%edx
    256a:	0f af d0             	imul   %eax,%edx
    256d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2570:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2574:	0f b6 c0             	movzbl %al,%eax
    2577:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    257b:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    257e:	0f af c1             	imul   %ecx,%eax
    2581:	01 d0                	add    %edx,%eax
    2583:	01 d8                	add    %ebx,%eax
    2585:	c1 e8 10             	shr    $0x10,%eax
    2588:	89 c2                	mov    %eax,%edx
    258a:	8b 45 14             	mov    0x14(%ebp),%eax
    258d:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    2590:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2593:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2597:	0f b6 c0             	movzbl %al,%eax
    259a:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    259e:	8b 55 bc             	mov    -0x44(%ebp),%edx
    25a1:	0f af d0             	imul   %eax,%edx
    25a4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    25a7:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    25ab:	0f b6 c0             	movzbl %al,%eax
    25ae:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    25b2:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    25b5:	0f af c1             	imul   %ecx,%eax
    25b8:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    25bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    25be:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    25c2:	0f b6 c0             	movzbl %al,%eax
    25c5:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    25c9:	8b 55 c8             	mov    -0x38(%ebp),%edx
    25cc:	0f af d0             	imul   %eax,%edx
    25cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    25d2:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    25d6:	0f b6 c0             	movzbl %al,%eax
    25d9:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    25dd:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    25e0:	0f af c1             	imul   %ecx,%eax
    25e3:	01 d0                	add    %edx,%eax
    25e5:	01 d8                	add    %ebx,%eax
    25e7:	c1 e8 10             	shr    $0x10,%eax
    25ea:	89 c2                	mov    %eax,%edx
    25ec:	8b 45 14             	mov    0x14(%ebp),%eax
    25ef:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    25f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    25f5:	0f b6 00             	movzbl (%eax),%eax
    25f8:	0f b6 c0             	movzbl %al,%eax
    25fb:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    25ff:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2602:	0f af d0             	imul   %eax,%edx
    2605:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2608:	0f b6 00             	movzbl (%eax),%eax
    260b:	0f b6 c0             	movzbl %al,%eax
    260e:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2612:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    2615:	0f af c1             	imul   %ecx,%eax
    2618:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    261b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    261e:	0f b6 00             	movzbl (%eax),%eax
    2621:	0f b6 c0             	movzbl %al,%eax
    2624:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2628:	8b 55 c8             	mov    -0x38(%ebp),%edx
    262b:	0f af d0             	imul   %eax,%edx
    262e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2631:	0f b6 00             	movzbl (%eax),%eax
    2634:	0f b6 c0             	movzbl %al,%eax
    2637:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    263b:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    263e:	0f af c1             	imul   %ecx,%eax
    2641:	01 d0                	add    %edx,%eax
    2643:	01 d8                	add    %ebx,%eax
    2645:	c1 e8 10             	shr    $0x10,%eax
    2648:	89 c2                	mov    %eax,%edx
    264a:	8b 45 14             	mov    0x14(%ebp),%eax
    264d:	88 10                	mov    %dl,(%eax)
}
    264f:	90                   	nop
    2650:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2653:	c9                   	leave  
    2654:	c3                   	ret    

00002655 <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    2655:	55                   	push   %ebp
    2656:	89 e5                	mov    %esp,%ebp
    2658:	53                   	push   %ebx
    2659:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    265c:	8b 45 08             	mov    0x8(%ebp),%eax
    265f:	8b 00                	mov    (%eax),%eax
    2661:	c1 e0 10             	shl    $0x10,%eax
    2664:	89 c1                	mov    %eax,%ecx
    2666:	8b 45 0c             	mov    0xc(%ebp),%eax
    2669:	8b 18                	mov    (%eax),%ebx
    266b:	89 c8                	mov    %ecx,%eax
    266d:	99                   	cltd   
    266e:	f7 fb                	idiv   %ebx
    2670:	83 c0 01             	add    $0x1,%eax
    2673:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    2676:	8b 45 08             	mov    0x8(%ebp),%eax
    2679:	8b 40 04             	mov    0x4(%eax),%eax
    267c:	c1 e0 10             	shl    $0x10,%eax
    267f:	89 c1                	mov    %eax,%ecx
    2681:	8b 45 0c             	mov    0xc(%ebp),%eax
    2684:	8b 58 04             	mov    0x4(%eax),%ebx
    2687:	89 c8                	mov    %ecx,%eax
    2689:	99                   	cltd   
    268a:	f7 fb                	idiv   %ebx
    268c:	83 c0 01             	add    $0x1,%eax
    268f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    2692:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2695:	d1 f8                	sar    %eax
    2697:	2d 00 80 00 00       	sub    $0x8000,%eax
    269c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    269f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    26a2:	d1 f8                	sar    %eax
    26a4:	2d 00 80 00 00       	sub    $0x8000,%eax
    26a9:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    26ac:	8b 45 dc             	mov    -0x24(%ebp),%eax
    26af:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    26b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    26b9:	eb 5d                	jmp    2718 <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    26bb:	8b 45 e0             	mov    -0x20(%ebp),%eax
    26be:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    26c1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    26c8:	eb 3a                	jmp    2704 <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    26ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    26cd:	8b 48 08             	mov    0x8(%eax),%ecx
    26d0:	8b 45 0c             	mov    0xc(%ebp),%eax
    26d3:	8b 00                	mov    (%eax),%eax
    26d5:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    26d9:	89 c2                	mov    %eax,%edx
    26db:	8b 45 ec             	mov    -0x14(%ebp),%eax
    26de:	01 c2                	add    %eax,%edx
    26e0:	89 d0                	mov    %edx,%eax
    26e2:	01 c0                	add    %eax,%eax
    26e4:	01 d0                	add    %edx,%eax
    26e6:	01 c8                	add    %ecx,%eax
    26e8:	50                   	push   %eax
    26e9:	ff 75 f0             	pushl  -0x10(%ebp)
    26ec:	ff 75 f8             	pushl  -0x8(%ebp)
    26ef:	ff 75 08             	pushl  0x8(%ebp)
    26f2:	e8 4d fd ff ff       	call   2444 <mixColorInt>
    26f7:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    26fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
    26fd:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    2700:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    2704:	8b 45 0c             	mov    0xc(%ebp),%eax
    2707:	8b 00                	mov    (%eax),%eax
    2709:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    270c:	7f bc                	jg     26ca <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    270e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2711:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    2714:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2718:	8b 45 0c             	mov    0xc(%ebp),%eax
    271b:	8b 40 04             	mov    0x4(%eax),%eax
    271e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2721:	7f 98                	jg     26bb <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    2723:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2728:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    272b:	c9                   	leave  
    272c:	c3                   	ret    

0000272d <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    272d:	55                   	push   %ebp
    272e:	89 e5                	mov    %esp,%ebp
    2730:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    2733:	8b 45 08             	mov    0x8(%ebp),%eax
    2736:	8b 00                	mov    (%eax),%eax
    2738:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    273b:	db 45 e4             	fildl  -0x1c(%ebp)
    273e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2741:	8b 00                	mov    (%eax),%eax
    2743:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2746:	db 45 e4             	fildl  -0x1c(%ebp)
    2749:	de f9                	fdivrp %st,%st(1)
    274b:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    274e:	8b 45 08             	mov    0x8(%ebp),%eax
    2751:	8b 40 04             	mov    0x4(%eax),%eax
    2754:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2757:	db 45 e4             	fildl  -0x1c(%ebp)
    275a:	8b 45 0c             	mov    0xc(%ebp),%eax
    275d:	8b 40 04             	mov    0x4(%eax),%eax
    2760:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    2763:	db 45 e4             	fildl  -0x1c(%ebp)
    2766:	de f9                	fdivrp %st,%st(1)
    2768:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    276b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    2772:	eb 5e                	jmp    27d2 <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    2774:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    277b:	eb 47                	jmp    27c4 <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    277d:	db 45 f8             	fildl  -0x8(%ebp)
    2780:	d8 4d f4             	fmuls  -0xc(%ebp)
    2783:	d9 7d ee             	fnstcw -0x12(%ebp)
    2786:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    278a:	b4 0c                	mov    $0xc,%ah
    278c:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    2790:	d9 6d ec             	fldcw  -0x14(%ebp)
    2793:	db 5d e8             	fistpl -0x18(%ebp)
    2796:	d9 6d ee             	fldcw  -0x12(%ebp)
    2799:	8b 55 e8             	mov    -0x18(%ebp),%edx
    279c:	db 45 fc             	fildl  -0x4(%ebp)
    279f:	d8 4d f0             	fmuls  -0x10(%ebp)
    27a2:	d9 6d ec             	fldcw  -0x14(%ebp)
    27a5:	db 5d e8             	fistpl -0x18(%ebp)
    27a8:	d9 6d ee             	fldcw  -0x12(%ebp)
    27ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
    27ae:	6a 00                	push   $0x0
    27b0:	52                   	push   %edx
    27b1:	50                   	push   %eax
    27b2:	ff 75 08             	pushl  0x8(%ebp)
    27b5:	e8 10 f9 ff ff       	call   20ca <getColor>
    27ba:	83 c4 10             	add    $0x10,%esp
    27bd:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    27c0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    27c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    27c7:	8b 00                	mov    (%eax),%eax
    27c9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    27cc:	7f af                	jg     277d <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    27ce:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    27d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    27d5:	8b 40 04             	mov    0x4(%eax),%eax
    27d8:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    27db:	7f 97                	jg     2774 <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    27dd:	b8 01 00 00 00       	mov    $0x1,%eax
}
    27e2:	c9                   	leave  
    27e3:	c3                   	ret    

000027e4 <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    27e4:	55                   	push   %ebp
    27e5:	89 e5                	mov    %esp,%ebp
    27e7:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    27ea:	8b 45 08             	mov    0x8(%ebp),%eax
    27ed:	8b 00                	mov    (%eax),%eax
    27ef:	89 45 e0             	mov    %eax,-0x20(%ebp)
    27f2:	db 45 e0             	fildl  -0x20(%ebp)
    27f5:	d9 5d e0             	fstps  -0x20(%ebp)
    27f8:	83 ec 0c             	sub    $0xc,%esp
    27fb:	ff 75 10             	pushl  0x10(%ebp)
    27fe:	e8 6b e2 ff ff       	call   a6e <cos>
    2803:	83 c4 10             	add    $0x10,%esp
    2806:	d9 5d dc             	fstps  -0x24(%ebp)
    2809:	8b 45 dc             	mov    -0x24(%ebp),%eax
    280c:	83 ec 0c             	sub    $0xc,%esp
    280f:	50                   	push   %eax
    2810:	e8 90 e1 ff ff       	call   9a5 <abs>
    2815:	83 c4 10             	add    $0x10,%esp
    2818:	d8 4d e0             	fmuls  -0x20(%ebp)
    281b:	d9 5d e0             	fstps  -0x20(%ebp)
    281e:	8b 45 0c             	mov    0xc(%ebp),%eax
    2821:	8b 00                	mov    (%eax),%eax
    2823:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2826:	db 45 dc             	fildl  -0x24(%ebp)
    2829:	d9 5d dc             	fstps  -0x24(%ebp)
    282c:	83 ec 0c             	sub    $0xc,%esp
    282f:	ff 75 10             	pushl  0x10(%ebp)
    2832:	e8 da e3 ff ff       	call   c11 <sin>
    2837:	83 c4 10             	add    $0x10,%esp
    283a:	d9 5d d8             	fstps  -0x28(%ebp)
    283d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2840:	83 ec 0c             	sub    $0xc,%esp
    2843:	50                   	push   %eax
    2844:	e8 5c e1 ff ff       	call   9a5 <abs>
    2849:	83 c4 10             	add    $0x10,%esp
    284c:	d8 4d dc             	fmuls  -0x24(%ebp)
    284f:	d8 45 e0             	fadds  -0x20(%ebp)
    2852:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2855:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    2859:	b4 0c                	mov    $0xc,%ah
    285b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    285f:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2862:	db 5d f4             	fistpl -0xc(%ebp)
    2865:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    2868:	8b 45 08             	mov    0x8(%ebp),%eax
    286b:	8b 00                	mov    (%eax),%eax
    286d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    2870:	db 45 e0             	fildl  -0x20(%ebp)
    2873:	d9 5d e0             	fstps  -0x20(%ebp)
    2876:	83 ec 0c             	sub    $0xc,%esp
    2879:	ff 75 10             	pushl  0x10(%ebp)
    287c:	e8 90 e3 ff ff       	call   c11 <sin>
    2881:	83 c4 10             	add    $0x10,%esp
    2884:	d9 5d dc             	fstps  -0x24(%ebp)
    2887:	8b 45 dc             	mov    -0x24(%ebp),%eax
    288a:	83 ec 0c             	sub    $0xc,%esp
    288d:	50                   	push   %eax
    288e:	e8 12 e1 ff ff       	call   9a5 <abs>
    2893:	83 c4 10             	add    $0x10,%esp
    2896:	d8 4d e0             	fmuls  -0x20(%ebp)
    2899:	d9 5d e0             	fstps  -0x20(%ebp)
    289c:	8b 45 0c             	mov    0xc(%ebp),%eax
    289f:	8b 00                	mov    (%eax),%eax
    28a1:	89 45 dc             	mov    %eax,-0x24(%ebp)
    28a4:	db 45 dc             	fildl  -0x24(%ebp)
    28a7:	d9 5d dc             	fstps  -0x24(%ebp)
    28aa:	83 ec 0c             	sub    $0xc,%esp
    28ad:	ff 75 10             	pushl  0x10(%ebp)
    28b0:	e8 b9 e1 ff ff       	call   a6e <cos>
    28b5:	83 c4 10             	add    $0x10,%esp
    28b8:	d9 5d d8             	fstps  -0x28(%ebp)
    28bb:	8b 45 d8             	mov    -0x28(%ebp),%eax
    28be:	83 ec 0c             	sub    $0xc,%esp
    28c1:	50                   	push   %eax
    28c2:	e8 de e0 ff ff       	call   9a5 <abs>
    28c7:	83 c4 10             	add    $0x10,%esp
    28ca:	d8 4d dc             	fmuls  -0x24(%ebp)
    28cd:	d8 45 e0             	fadds  -0x20(%ebp)
    28d0:	d9 7d e6             	fnstcw -0x1a(%ebp)
    28d3:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    28d7:	b4 0c                	mov    $0xc,%ah
    28d9:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    28dd:	d9 6d e4             	fldcw  -0x1c(%ebp)
    28e0:	db 5d f0             	fistpl -0x10(%ebp)
    28e3:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    28e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    28e9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    28ec:	89 10                	mov    %edx,(%eax)
    *width = w;
    28ee:	8b 45 08             	mov    0x8(%ebp),%eax
    28f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    28f4:	89 10                	mov    %edx,(%eax)
    return 1;
    28f6:	b8 01 00 00 00       	mov    $0x1,%eax
}
    28fb:	c9                   	leave  
    28fc:	c3                   	ret    

000028fd <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    28fd:	55                   	push   %ebp
    28fe:	89 e5                	mov    %esp,%ebp
    2900:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    2903:	8b 45 08             	mov    0x8(%ebp),%eax
    2906:	8b 40 04             	mov    0x4(%eax),%eax
    2909:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    290c:	db 45 c4             	fildl  -0x3c(%ebp)
    290f:	d9 05 e4 9d 01 00    	flds   0x19de4
    2915:	de f9                	fdivrp %st,%st(1)
    2917:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    291a:	8b 45 08             	mov    0x8(%ebp),%eax
    291d:	8b 00                	mov    (%eax),%eax
    291f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2922:	db 45 c4             	fildl  -0x3c(%ebp)
    2925:	d9 05 e4 9d 01 00    	flds   0x19de4
    292b:	de f9                	fdivrp %st,%st(1)
    292d:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    2930:	8b 45 0c             	mov    0xc(%ebp),%eax
    2933:	8b 50 04             	mov    0x4(%eax),%edx
    2936:	8b 45 08             	mov    0x8(%ebp),%eax
    2939:	8b 40 04             	mov    0x4(%eax),%eax
    293c:	29 c2                	sub    %eax,%edx
    293e:	89 d0                	mov    %edx,%eax
    2940:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2943:	db 45 c4             	fildl  -0x3c(%ebp)
    2946:	d9 05 e4 9d 01 00    	flds   0x19de4
    294c:	de f9                	fdivrp %st,%st(1)
    294e:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    2951:	8b 45 0c             	mov    0xc(%ebp),%eax
    2954:	8b 10                	mov    (%eax),%edx
    2956:	8b 45 08             	mov    0x8(%ebp),%eax
    2959:	8b 00                	mov    (%eax),%eax
    295b:	29 c2                	sub    %eax,%edx
    295d:	89 d0                	mov    %edx,%eax
    295f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2962:	db 45 c4             	fildl  -0x3c(%ebp)
    2965:	d9 05 e4 9d 01 00    	flds   0x19de4
    296b:	de f9                	fdivrp %st,%st(1)
    296d:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    2970:	d9 45 10             	flds   0x10(%ebp)
    2973:	d9 e0                	fchs   
    2975:	83 ec 0c             	sub    $0xc,%esp
    2978:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    297c:	d9 1c 24             	fstps  (%esp)
    297f:	e8 ea e0 ff ff       	call   a6e <cos>
    2984:	83 c4 10             	add    $0x10,%esp
    2987:	d9 5d c4             	fstps  -0x3c(%ebp)
    298a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    298d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    2990:	d9 45 10             	flds   0x10(%ebp)
    2993:	d9 e0                	fchs   
    2995:	83 ec 0c             	sub    $0xc,%esp
    2998:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    299c:	d9 1c 24             	fstps  (%esp)
    299f:	e8 6d e2 ff ff       	call   c11 <sin>
    29a4:	83 c4 10             	add    $0x10,%esp
    29a7:	d9 5d c4             	fstps  -0x3c(%ebp)
    29aa:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    29ad:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    29b0:	d9 ee                	fldz   
    29b2:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    29b5:	d9 ee                	fldz   
    29b7:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    29ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    29c1:	e9 28 01 00 00       	jmp    2aee <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    29c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    29cd:	e9 0a 01 00 00       	jmp    2adc <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    29d2:	db 45 f4             	fildl  -0xc(%ebp)
    29d5:	d8 65 e4             	fsubs  -0x1c(%ebp)
    29d8:	d8 65 ec             	fsubs  -0x14(%ebp)
    29db:	d8 4d dc             	fmuls  -0x24(%ebp)
    29de:	db 45 f0             	fildl  -0x10(%ebp)
    29e1:	d8 65 e0             	fsubs  -0x20(%ebp)
    29e4:	d8 65 e8             	fsubs  -0x18(%ebp)
    29e7:	d8 4d d8             	fmuls  -0x28(%ebp)
    29ea:	de c1                	faddp  %st,%st(1)
    29ec:	d8 45 ec             	fadds  -0x14(%ebp)
    29ef:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    29f2:	db 45 f0             	fildl  -0x10(%ebp)
    29f5:	d8 65 e0             	fsubs  -0x20(%ebp)
    29f8:	d8 65 e8             	fsubs  -0x18(%ebp)
    29fb:	d8 4d dc             	fmuls  -0x24(%ebp)
    29fe:	db 45 f4             	fildl  -0xc(%ebp)
    2a01:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2a04:	d8 65 ec             	fsubs  -0x14(%ebp)
    2a07:	d8 4d d8             	fmuls  -0x28(%ebp)
    2a0a:	de e9                	fsubrp %st,%st(1)
    2a0c:	d8 45 e8             	fadds  -0x18(%ebp)
    2a0f:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    2a12:	d9 45 d4             	flds   -0x2c(%ebp)
    2a15:	d9 ee                	fldz   
    2a17:	d9 c9                	fxch   %st(1)
    2a19:	df e9                	fucomip %st(1),%st
    2a1b:	dd d8                	fstp   %st(0)
    2a1d:	0f 93 c0             	setae  %al
    2a20:	83 f0 01             	xor    $0x1,%eax
    2a23:	84 c0                	test   %al,%al
    2a25:	75 52                	jne    2a79 <picTurn+0x17c>
    2a27:	8b 45 08             	mov    0x8(%ebp),%eax
    2a2a:	8b 40 04             	mov    0x4(%eax),%eax
    2a2d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2a30:	db 45 c4             	fildl  -0x3c(%ebp)
    2a33:	d9 45 d4             	flds   -0x2c(%ebp)
    2a36:	d9 c9                	fxch   %st(1)
    2a38:	df e9                	fucomip %st(1),%st
    2a3a:	dd d8                	fstp   %st(0)
    2a3c:	0f 97 c0             	seta   %al
    2a3f:	83 f0 01             	xor    $0x1,%eax
    2a42:	84 c0                	test   %al,%al
    2a44:	75 33                	jne    2a79 <picTurn+0x17c>
    2a46:	d9 45 d0             	flds   -0x30(%ebp)
    2a49:	d9 ee                	fldz   
    2a4b:	d9 c9                	fxch   %st(1)
    2a4d:	df e9                	fucomip %st(1),%st
    2a4f:	dd d8                	fstp   %st(0)
    2a51:	0f 93 c0             	setae  %al
    2a54:	83 f0 01             	xor    $0x1,%eax
    2a57:	84 c0                	test   %al,%al
    2a59:	75 1e                	jne    2a79 <picTurn+0x17c>
    2a5b:	8b 45 08             	mov    0x8(%ebp),%eax
    2a5e:	8b 00                	mov    (%eax),%eax
    2a60:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2a63:	db 45 c4             	fildl  -0x3c(%ebp)
    2a66:	d9 45 d0             	flds   -0x30(%ebp)
    2a69:	d9 c9                	fxch   %st(1)
    2a6b:	df e9                	fucomip %st(1),%st
    2a6d:	dd d8                	fstp   %st(0)
    2a6f:	0f 97 c0             	seta   %al
    2a72:	83 f0 01             	xor    $0x1,%eax
    2a75:	84 c0                	test   %al,%al
    2a77:	74 2f                	je     2aa8 <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    2a79:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a7c:	8b 48 08             	mov    0x8(%eax),%ecx
    2a7f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a82:	8b 00                	mov    (%eax),%eax
    2a84:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2a88:	89 c2                	mov    %eax,%edx
    2a8a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2a8d:	01 c2                	add    %eax,%edx
    2a8f:	89 d0                	mov    %edx,%eax
    2a91:	01 c0                	add    %eax,%eax
    2a93:	01 d0                	add    %edx,%eax
    2a95:	01 c8                	add    %ecx,%eax
    2a97:	83 ec 08             	sub    $0x8,%esp
    2a9a:	50                   	push   %eax
    2a9b:	68 51 e2 01 00       	push   $0x1e251
    2aa0:	e8 9f f6 ff ff       	call   2144 <setColor>
    2aa5:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    2aa8:	8b 45 0c             	mov    0xc(%ebp),%eax
    2aab:	8b 48 08             	mov    0x8(%eax),%ecx
    2aae:	8b 45 0c             	mov    0xc(%ebp),%eax
    2ab1:	8b 00                	mov    (%eax),%eax
    2ab3:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2ab7:	89 c2                	mov    %eax,%edx
    2ab9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2abc:	01 c2                	add    %eax,%edx
    2abe:	89 d0                	mov    %edx,%eax
    2ac0:	01 c0                	add    %eax,%eax
    2ac2:	01 d0                	add    %edx,%eax
    2ac4:	01 c8                	add    %ecx,%eax
    2ac6:	50                   	push   %eax
    2ac7:	ff 75 d0             	pushl  -0x30(%ebp)
    2aca:	ff 75 d4             	pushl  -0x2c(%ebp)
    2acd:	ff 75 08             	pushl  0x8(%ebp)
    2ad0:	e8 9e f6 ff ff       	call   2173 <mixColor>
    2ad5:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    2ad8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2adc:	8b 45 0c             	mov    0xc(%ebp),%eax
    2adf:	8b 00                	mov    (%eax),%eax
    2ae1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2ae4:	0f 8f e8 fe ff ff    	jg     29d2 <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    2aea:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2aee:	8b 45 0c             	mov    0xc(%ebp),%eax
    2af1:	8b 40 04             	mov    0x4(%eax),%eax
    2af4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2af7:	0f 8f c9 fe ff ff    	jg     29c6 <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    2afd:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2b02:	c9                   	leave  
    2b03:	c3                   	ret    

00002b04 <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    2b04:	55                   	push   %ebp
    2b05:	89 e5                	mov    %esp,%ebp
    2b07:	53                   	push   %ebx
    2b08:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2b0b:	8b 45 08             	mov    0x8(%ebp),%eax
    2b0e:	8b 10                	mov    (%eax),%edx
    2b10:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b13:	8b 00                	mov    (%eax),%eax
    2b15:	39 c2                	cmp    %eax,%edx
    2b17:	75 10                	jne    2b29 <picRollingOver+0x25>
    2b19:	8b 45 08             	mov    0x8(%ebp),%eax
    2b1c:	8b 50 04             	mov    0x4(%eax),%edx
    2b1f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b22:	8b 40 04             	mov    0x4(%eax),%eax
    2b25:	39 c2                	cmp    %eax,%edx
    2b27:	74 0a                	je     2b33 <picRollingOver+0x2f>
        return 0;
    2b29:	b8 00 00 00 00       	mov    $0x0,%eax
    2b2e:	e9 88 00 00 00       	jmp    2bbb <picRollingOver+0xb7>

    int h = src->height;
    2b33:	8b 45 08             	mov    0x8(%ebp),%eax
    2b36:	8b 40 04             	mov    0x4(%eax),%eax
    2b39:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2b3c:	8b 45 08             	mov    0x8(%ebp),%eax
    2b3f:	8b 00                	mov    (%eax),%eax
    2b41:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2b44:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2b4b:	eb 61                	jmp    2bae <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    2b4d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2b54:	eb 4c                	jmp    2ba2 <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    2b56:	8b 45 0c             	mov    0xc(%ebp),%eax
    2b59:	8b 48 08             	mov    0x8(%eax),%ecx
    2b5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2b5f:	2b 45 f8             	sub    -0x8(%ebp),%eax
    2b62:	83 e8 01             	sub    $0x1,%eax
    2b65:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2b69:	89 c2                	mov    %eax,%edx
    2b6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b6e:	01 c2                	add    %eax,%edx
    2b70:	89 d0                	mov    %edx,%eax
    2b72:	01 c0                	add    %eax,%eax
    2b74:	01 d0                	add    %edx,%eax
    2b76:	01 c1                	add    %eax,%ecx
    2b78:	8b 45 08             	mov    0x8(%ebp),%eax
    2b7b:	8b 58 08             	mov    0x8(%eax),%ebx
    2b7e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2b81:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2b85:	89 c2                	mov    %eax,%edx
    2b87:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2b8a:	01 c2                	add    %eax,%edx
    2b8c:	89 d0                	mov    %edx,%eax
    2b8e:	01 c0                	add    %eax,%eax
    2b90:	01 d0                	add    %edx,%eax
    2b92:	01 d8                	add    %ebx,%eax
    2b94:	51                   	push   %ecx
    2b95:	50                   	push   %eax
    2b96:	e8 a9 f5 ff ff       	call   2144 <setColor>
    2b9b:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2b9e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2ba2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ba5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2ba8:	7c ac                	jl     2b56 <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2baa:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2bae:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2bb1:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2bb4:	7c 97                	jl     2b4d <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    2bb6:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2bbb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2bbe:	c9                   	leave  
    2bbf:	c3                   	ret    

00002bc0 <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    2bc0:	55                   	push   %ebp
    2bc1:	89 e5                	mov    %esp,%ebp
    2bc3:	53                   	push   %ebx
    2bc4:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2bc7:	8b 45 08             	mov    0x8(%ebp),%eax
    2bca:	8b 10                	mov    (%eax),%edx
    2bcc:	8b 45 0c             	mov    0xc(%ebp),%eax
    2bcf:	8b 00                	mov    (%eax),%eax
    2bd1:	39 c2                	cmp    %eax,%edx
    2bd3:	75 10                	jne    2be5 <picTurnAround+0x25>
    2bd5:	8b 45 08             	mov    0x8(%ebp),%eax
    2bd8:	8b 50 04             	mov    0x4(%eax),%edx
    2bdb:	8b 45 0c             	mov    0xc(%ebp),%eax
    2bde:	8b 40 04             	mov    0x4(%eax),%eax
    2be1:	39 c2                	cmp    %eax,%edx
    2be3:	74 0a                	je     2bef <picTurnAround+0x2f>
        return 0;
    2be5:	b8 00 00 00 00       	mov    $0x0,%eax
    2bea:	e9 88 00 00 00       	jmp    2c77 <picTurnAround+0xb7>

    int h = src->height;
    2bef:	8b 45 08             	mov    0x8(%ebp),%eax
    2bf2:	8b 40 04             	mov    0x4(%eax),%eax
    2bf5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2bf8:	8b 45 08             	mov    0x8(%ebp),%eax
    2bfb:	8b 00                	mov    (%eax),%eax
    2bfd:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2c00:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2c07:	eb 61                	jmp    2c6a <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    2c09:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2c10:	eb 4c                	jmp    2c5e <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    2c12:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c15:	8b 48 08             	mov    0x8(%eax),%ecx
    2c18:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2c1b:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2c1f:	89 c2                	mov    %eax,%edx
    2c21:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2c24:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2c27:	01 c2                	add    %eax,%edx
    2c29:	89 d0                	mov    %edx,%eax
    2c2b:	01 c0                	add    %eax,%eax
    2c2d:	01 d0                	add    %edx,%eax
    2c2f:	83 e8 03             	sub    $0x3,%eax
    2c32:	01 c1                	add    %eax,%ecx
    2c34:	8b 45 08             	mov    0x8(%ebp),%eax
    2c37:	8b 58 08             	mov    0x8(%eax),%ebx
    2c3a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2c3d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2c41:	89 c2                	mov    %eax,%edx
    2c43:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c46:	01 c2                	add    %eax,%edx
    2c48:	89 d0                	mov    %edx,%eax
    2c4a:	01 c0                	add    %eax,%eax
    2c4c:	01 d0                	add    %edx,%eax
    2c4e:	01 d8                	add    %ebx,%eax
    2c50:	51                   	push   %ecx
    2c51:	50                   	push   %eax
    2c52:	e8 ed f4 ff ff       	call   2144 <setColor>
    2c57:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2c5a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2c5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c61:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2c64:	7c ac                	jl     2c12 <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2c66:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2c6a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2c6d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2c70:	7c 97                	jl     2c09 <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    2c72:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2c77:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2c7a:	c9                   	leave  
    2c7b:	c3                   	ret    

00002c7c <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    2c7c:	55                   	push   %ebp
    2c7d:	89 e5                	mov    %esp,%ebp
    2c7f:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    2c82:	83 ec 0c             	sub    $0xc,%esp
    2c85:	ff 75 08             	pushl  0x8(%ebp)
    2c88:	e8 c5 d5 ff ff       	call   252 <strlen>
    2c8d:	83 c4 10             	add    $0x10,%esp
    2c90:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    2c93:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2c96:	8d 50 ff             	lea    -0x1(%eax),%edx
    2c99:	8b 45 08             	mov    0x8(%ebp),%eax
    2c9c:	01 d0                	add    %edx,%eax
    2c9e:	0f b6 00             	movzbl (%eax),%eax
    2ca1:	3c 67                	cmp    $0x67,%al
    2ca3:	75 2b                	jne    2cd0 <type+0x54>
    2ca5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ca8:	8d 50 fe             	lea    -0x2(%eax),%edx
    2cab:	8b 45 08             	mov    0x8(%ebp),%eax
    2cae:	01 d0                	add    %edx,%eax
    2cb0:	0f b6 00             	movzbl (%eax),%eax
    2cb3:	3c 70                	cmp    $0x70,%al
    2cb5:	75 19                	jne    2cd0 <type+0x54>
    2cb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2cba:	8d 50 fd             	lea    -0x3(%eax),%edx
    2cbd:	8b 45 08             	mov    0x8(%ebp),%eax
    2cc0:	01 d0                	add    %edx,%eax
    2cc2:	0f b6 00             	movzbl (%eax),%eax
    2cc5:	3c 6a                	cmp    $0x6a,%al
    2cc7:	75 07                	jne    2cd0 <type+0x54>
    2cc9:	b8 00 00 00 00       	mov    $0x0,%eax
    2cce:	eb 7f                	jmp    2d4f <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    2cd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2cd3:	8d 50 ff             	lea    -0x1(%eax),%edx
    2cd6:	8b 45 08             	mov    0x8(%ebp),%eax
    2cd9:	01 d0                	add    %edx,%eax
    2cdb:	0f b6 00             	movzbl (%eax),%eax
    2cde:	3c 70                	cmp    $0x70,%al
    2ce0:	75 2b                	jne    2d0d <type+0x91>
    2ce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ce5:	8d 50 fe             	lea    -0x2(%eax),%edx
    2ce8:	8b 45 08             	mov    0x8(%ebp),%eax
    2ceb:	01 d0                	add    %edx,%eax
    2ced:	0f b6 00             	movzbl (%eax),%eax
    2cf0:	3c 6d                	cmp    $0x6d,%al
    2cf2:	75 19                	jne    2d0d <type+0x91>
    2cf4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2cf7:	8d 50 fd             	lea    -0x3(%eax),%edx
    2cfa:	8b 45 08             	mov    0x8(%ebp),%eax
    2cfd:	01 d0                	add    %edx,%eax
    2cff:	0f b6 00             	movzbl (%eax),%eax
    2d02:	3c 62                	cmp    $0x62,%al
    2d04:	75 07                	jne    2d0d <type+0x91>
    2d06:	b8 01 00 00 00       	mov    $0x1,%eax
    2d0b:	eb 42                	jmp    2d4f <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    2d0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2d10:	8d 50 ff             	lea    -0x1(%eax),%edx
    2d13:	8b 45 08             	mov    0x8(%ebp),%eax
    2d16:	01 d0                	add    %edx,%eax
    2d18:	0f b6 00             	movzbl (%eax),%eax
    2d1b:	3c 67                	cmp    $0x67,%al
    2d1d:	75 2b                	jne    2d4a <type+0xce>
    2d1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2d22:	8d 50 fe             	lea    -0x2(%eax),%edx
    2d25:	8b 45 08             	mov    0x8(%ebp),%eax
    2d28:	01 d0                	add    %edx,%eax
    2d2a:	0f b6 00             	movzbl (%eax),%eax
    2d2d:	3c 6e                	cmp    $0x6e,%al
    2d2f:	75 19                	jne    2d4a <type+0xce>
    2d31:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2d34:	8d 50 fd             	lea    -0x3(%eax),%edx
    2d37:	8b 45 08             	mov    0x8(%ebp),%eax
    2d3a:	01 d0                	add    %edx,%eax
    2d3c:	0f b6 00             	movzbl (%eax),%eax
    2d3f:	3c 70                	cmp    $0x70,%al
    2d41:	75 07                	jne    2d4a <type+0xce>
    2d43:	b8 02 00 00 00       	mov    $0x2,%eax
    2d48:	eb 05                	jmp    2d4f <type+0xd3>
    else return NONE;
    2d4a:	b8 03 00 00 00       	mov    $0x3,%eax
}
    2d4f:	c9                   	leave  
    2d50:	c3                   	ret    

00002d51 <LoadBmp>:

PBitmap LoadBmp(char* filename){
    2d51:	55                   	push   %ebp
    2d52:	89 e5                	mov    %esp,%ebp
    2d54:	56                   	push   %esi
    2d55:	53                   	push   %ebx
    2d56:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    2d59:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    2d60:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    2d67:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    2d6e:	83 ec 08             	sub    $0x8,%esp
    2d71:	6a 00                	push   $0x0
    2d73:	ff 75 0c             	pushl  0xc(%ebp)
    2d76:	e8 d9 d6 ff ff       	call   454 <open>
    2d7b:	83 c4 10             	add    $0x10,%esp
    2d7e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2d81:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2d85:	79 2c                	jns    2db3 <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    2d87:	83 ec 08             	sub    $0x8,%esp
    2d8a:	ff 75 0c             	pushl  0xc(%ebp)
    2d8d:	68 e8 9d 01 00       	push   $0x19de8
    2d92:	e8 24 d8 ff ff       	call   5bb <printf>
    2d97:	83 c4 10             	add    $0x10,%esp
        return bmp;
    2d9a:	8b 45 08             	mov    0x8(%ebp),%eax
    2d9d:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2da0:	89 10                	mov    %edx,(%eax)
    2da2:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2da5:	89 50 04             	mov    %edx,0x4(%eax)
    2da8:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2dab:	89 50 08             	mov    %edx,0x8(%eax)
    2dae:	e9 2d 02 00 00       	jmp    2fe0 <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    2db3:	83 ec 04             	sub    $0x4,%esp
    2db6:	6a 0e                	push   $0xe
    2db8:	8d 45 aa             	lea    -0x56(%ebp),%eax
    2dbb:	50                   	push   %eax
    2dbc:	ff 75 ec             	pushl  -0x14(%ebp)
    2dbf:	e8 68 d6 ff ff       	call   42c <read>
    2dc4:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    2dc7:	83 ec 04             	sub    $0x4,%esp
    2dca:	6a 28                	push   $0x28
    2dcc:	8d 45 82             	lea    -0x7e(%ebp),%eax
    2dcf:	50                   	push   %eax
    2dd0:	ff 75 ec             	pushl  -0x14(%ebp)
    2dd3:	e8 54 d6 ff ff       	call   42c <read>
    2dd8:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2ddb:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2ddf:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2de2:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2de6:	0f b7 d8             	movzwl %ax,%ebx
    2de9:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    2dec:	8b 55 ac             	mov    -0x54(%ebp),%edx
    2def:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    2df3:	0f b7 c0             	movzwl %ax,%eax
    2df6:	83 ec 04             	sub    $0x4,%esp
    2df9:	6a 36                	push   $0x36
    2dfb:	56                   	push   %esi
    2dfc:	53                   	push   %ebx
    2dfd:	51                   	push   %ecx
    2dfe:	52                   	push   %edx
    2dff:	50                   	push   %eax
    2e00:	68 f8 9d 01 00       	push   $0x19df8
    2e05:	e8 b1 d7 ff ff       	call   5bb <printf>
    2e0a:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    2e0d:	8b 45 86             	mov    -0x7a(%ebp),%eax
    2e10:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    2e13:	8b 45 8a             	mov    -0x76(%ebp),%eax
    2e16:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    2e19:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2e1c:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2e1f:	0f af c2             	imul   %edx,%eax
    2e22:	89 c2                	mov    %eax,%edx
    2e24:	89 d0                	mov    %edx,%eax
    2e26:	01 c0                	add    %eax,%eax
    2e28:	01 d0                	add    %edx,%eax
    2e2a:	83 ec 0c             	sub    $0xc,%esp
    2e2d:	50                   	push   %eax
    2e2e:	e8 5b da ff ff       	call   88e <malloc>
    2e33:	83 c4 10             	add    $0x10,%esp
    2e36:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    2e39:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2e3d:	0f b7 c0             	movzwl %ax,%eax
    2e40:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    2e43:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2e46:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    2e4a:	83 c0 1f             	add    $0x1f,%eax
    2e4d:	c1 f8 05             	sar    $0x5,%eax
    2e50:	c1 e0 02             	shl    $0x2,%eax
    2e53:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    2e56:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2e59:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2e5d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    2e60:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2e63:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2e66:	83 ec 08             	sub    $0x8,%esp
    2e69:	52                   	push   %edx
    2e6a:	50                   	push   %eax
    2e6b:	ff 75 e8             	pushl  -0x18(%ebp)
    2e6e:	ff 75 e0             	pushl  -0x20(%ebp)
    2e71:	ff 75 e4             	pushl  -0x1c(%ebp)
    2e74:	68 20 9e 01 00       	push   $0x19e20
    2e79:	e8 3d d7 ff ff       	call   5bb <printf>
    2e7e:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    2e81:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    2e84:	83 e8 36             	sub    $0x36,%eax
    2e87:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    2e8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2e8d:	83 ec 0c             	sub    $0xc,%esp
    2e90:	50                   	push   %eax
    2e91:	e8 f8 d9 ff ff       	call   88e <malloc>
    2e96:	83 c4 10             	add    $0x10,%esp
    2e99:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    2e9c:	83 ec 04             	sub    $0x4,%esp
    2e9f:	ff 75 dc             	pushl  -0x24(%ebp)
    2ea2:	ff 75 d8             	pushl  -0x28(%ebp)
    2ea5:	ff 75 ec             	pushl  -0x14(%ebp)
    2ea8:	e8 7f d5 ff ff       	call   42c <read>
    2ead:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    2eb0:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2eb3:	83 ec 0c             	sub    $0xc,%esp
    2eb6:	50                   	push   %eax
    2eb7:	e8 d2 d9 ff ff       	call   88e <malloc>
    2ebc:	83 c4 10             	add    $0x10,%esp
    2ebf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    2ec2:	8b 45 ac             	mov    -0x54(%ebp),%eax
    2ec5:	83 ec 04             	sub    $0x4,%esp
    2ec8:	50                   	push   %eax
    2ec9:	ff 75 d4             	pushl  -0x2c(%ebp)
    2ecc:	ff 75 ec             	pushl  -0x14(%ebp)
    2ecf:	e8 58 d5 ff ff       	call   42c <read>
    2ed4:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    2ed7:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2edb:	66 c1 e8 03          	shr    $0x3,%ax
    2edf:	0f b7 c0             	movzwl %ax,%eax
    2ee2:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    2ee5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2eec:	e9 c1 00 00 00       	jmp    2fb2 <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    2ef1:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2ef4:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2ef7:	8d 50 ff             	lea    -0x1(%eax),%edx
    2efa:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2efd:	0f af c2             	imul   %edx,%eax
    2f00:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    2f03:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2f06:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2f0a:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    2f0d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2f14:	e9 89 00 00 00       	jmp    2fa2 <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    2f19:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2f1c:	83 c0 01             	add    $0x1,%eax
    2f1f:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    2f23:	89 c2                	mov    %eax,%edx
    2f25:	8b 45 c8             	mov    -0x38(%ebp),%eax
    2f28:	01 d0                	add    %edx,%eax
    2f2a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    2f2d:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2f30:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2f33:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2f36:	01 c8                	add    %ecx,%eax
    2f38:	89 c1                	mov    %eax,%ecx
    2f3a:	89 c8                	mov    %ecx,%eax
    2f3c:	01 c0                	add    %eax,%eax
    2f3e:	01 c8                	add    %ecx,%eax
    2f40:	01 c2                	add    %eax,%edx
    2f42:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2f45:	8d 48 ff             	lea    -0x1(%eax),%ecx
    2f48:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2f4b:	01 c8                	add    %ecx,%eax
    2f4d:	0f b6 00             	movzbl (%eax),%eax
    2f50:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    2f53:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2f56:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2f59:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2f5c:	01 c8                	add    %ecx,%eax
    2f5e:	89 c1                	mov    %eax,%ecx
    2f60:	89 c8                	mov    %ecx,%eax
    2f62:	01 c0                	add    %eax,%eax
    2f64:	01 c8                	add    %ecx,%eax
    2f66:	01 c2                	add    %eax,%edx
    2f68:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2f6b:	8d 48 fe             	lea    -0x2(%eax),%ecx
    2f6e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2f71:	01 c8                	add    %ecx,%eax
    2f73:	0f b6 00             	movzbl (%eax),%eax
    2f76:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    2f79:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2f7c:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    2f7f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2f82:	01 c8                	add    %ecx,%eax
    2f84:	89 c1                	mov    %eax,%ecx
    2f86:	89 c8                	mov    %ecx,%eax
    2f88:	01 c0                	add    %eax,%eax
    2f8a:	01 c8                	add    %ecx,%eax
    2f8c:	01 c2                	add    %eax,%edx
    2f8e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2f91:	8d 48 fd             	lea    -0x3(%eax),%ecx
    2f94:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    2f97:	01 c8                	add    %ecx,%eax
    2f99:	0f b6 00             	movzbl (%eax),%eax
    2f9c:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    2f9e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2fa2:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2fa5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2fa8:	0f 8f 6b ff ff ff    	jg     2f19 <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    2fae:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2fb2:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2fb5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2fb8:	0f 8f 33 ff ff ff    	jg     2ef1 <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    2fbe:	83 ec 0c             	sub    $0xc,%esp
    2fc1:	ff 75 ec             	pushl  -0x14(%ebp)
    2fc4:	e8 73 d4 ff ff       	call   43c <close>
    2fc9:	83 c4 10             	add    $0x10,%esp
    return bmp;
    2fcc:	8b 45 08             	mov    0x8(%ebp),%eax
    2fcf:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2fd2:	89 10                	mov    %edx,(%eax)
    2fd4:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2fd7:	89 50 04             	mov    %edx,0x4(%eax)
    2fda:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2fdd:	89 50 08             	mov    %edx,0x8(%eax)
}
    2fe0:	8b 45 08             	mov    0x8(%ebp),%eax
    2fe3:	8d 65 f8             	lea    -0x8(%ebp),%esp
    2fe6:	5b                   	pop    %ebx
    2fe7:	5e                   	pop    %esi
    2fe8:	5d                   	pop    %ebp
    2fe9:	c2 04 00             	ret    $0x4

00002fec <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    2fec:	55                   	push   %ebp
    2fed:	89 e5                	mov    %esp,%ebp
    2fef:	53                   	push   %ebx
    2ff0:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    2ff3:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    2ff7:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    2ffb:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    2fff:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    3003:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    3007:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    300b:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    300f:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    3013:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    3017:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    301b:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    301f:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    3023:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    3027:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    302b:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    302f:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    3033:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    3037:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    303b:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    303f:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    3043:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    3047:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    304b:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    304f:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    3053:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    3057:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    305b:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    305f:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    3063:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    3067:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    306b:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    306f:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    3073:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    3077:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    307b:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    307f:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    3083:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    3087:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    308b:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    308f:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    3093:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    3097:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    309b:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    309f:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    30a3:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    30a7:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    30ab:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    30af:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    30b3:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    30b7:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    30bb:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    30bf:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    30c3:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    30c7:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    30cb:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    30cf:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    30d3:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    30d7:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    30db:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    30df:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    30e3:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    30e7:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    30eb:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    30ef:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    30f3:	83 ec 0c             	sub    $0xc,%esp
    30f6:	68 c8 02 08 00       	push   $0x802c8
    30fb:	e8 8e d7 ff ff       	call   88e <malloc>
    3100:	83 c4 10             	add    $0x10,%esp
    3103:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    3106:	83 ec 04             	sub    $0x4,%esp
    3109:	68 c8 02 08 00       	push   $0x802c8
    310e:	6a 00                	push   $0x0
    3110:	ff 75 f0             	pushl  -0x10(%ebp)
    3113:	e8 61 d1 ff ff       	call   279 <memset>
    3118:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    311b:	83 ec 08             	sub    $0x8,%esp
    311e:	6a 00                	push   $0x0
    3120:	ff 75 0c             	pushl  0xc(%ebp)
    3123:	e8 2c d3 ff ff       	call   454 <open>
    3128:	83 c4 10             	add    $0x10,%esp
    312b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    312e:	83 ec 0c             	sub    $0xc,%esp
    3131:	68 40 42 0f 00       	push   $0xf4240
    3136:	e8 53 d7 ff ff       	call   88e <malloc>
    313b:	83 c4 10             	add    $0x10,%esp
    313e:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    3141:	83 ec 04             	sub    $0x4,%esp
    3144:	68 40 42 0f 00       	push   $0xf4240
    3149:	ff 75 e8             	pushl  -0x18(%ebp)
    314c:	ff 75 ec             	pushl  -0x14(%ebp)
    314f:	e8 d8 d2 ff ff       	call   42c <read>
    3154:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    3157:	83 ec 0c             	sub    $0xc,%esp
    315a:	ff 75 ec             	pushl  -0x14(%ebp)
    315d:	e8 da d2 ff ff       	call   43c <close>
    3162:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    3165:	68 40 42 0f 00       	push   $0xf4240
    316a:	ff 75 e8             	pushl  -0x18(%ebp)
    316d:	8d 45 9c             	lea    -0x64(%ebp),%eax
    3170:	50                   	push   %eax
    3171:	ff 75 f0             	pushl  -0x10(%ebp)
    3174:	e8 5e 0c 01 00       	call   13dd7 <_DecodeJPEG>
    3179:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    317c:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    3183:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    318a:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    3191:	83 ec 0c             	sub    $0xc,%esp
    3194:	ff 75 f0             	pushl  -0x10(%ebp)
    3197:	e8 29 0b 01 00       	call   13cc5 <GetImageSize>
    319c:	83 c4 10             	add    $0x10,%esp
    319f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    31a2:	83 ec 0c             	sub    $0xc,%esp
    31a5:	ff 75 f0             	pushl  -0x10(%ebp)
    31a8:	e8 e1 0a 01 00       	call   13c8e <GetImage>
    31ad:	83 c4 10             	add    $0x10,%esp
    31b0:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    31b3:	83 ec 0c             	sub    $0xc,%esp
    31b6:	ff 75 f0             	pushl  -0x10(%ebp)
    31b9:	e8 f1 0a 01 00       	call   13caf <GetWidth>
    31be:	83 c4 10             	add    $0x10,%esp
    31c1:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    31c4:	83 ec 0c             	sub    $0xc,%esp
    31c7:	ff 75 f0             	pushl  -0x10(%ebp)
    31ca:	e8 eb 0a 01 00       	call   13cba <GetHeight>
    31cf:	83 c4 10             	add    $0x10,%esp
    31d2:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    31d5:	8b 55 90             	mov    -0x70(%ebp),%edx
    31d8:	8b 45 94             	mov    -0x6c(%ebp),%eax
    31db:	0f af c2             	imul   %edx,%eax
    31de:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    31e1:	8b 55 dc             	mov    -0x24(%ebp),%edx
    31e4:	89 d0                	mov    %edx,%eax
    31e6:	01 c0                	add    %eax,%eax
    31e8:	01 d0                	add    %edx,%eax
    31ea:	83 ec 0c             	sub    $0xc,%esp
    31ed:	50                   	push   %eax
    31ee:	e8 9b d6 ff ff       	call   88e <malloc>
    31f3:	83 c4 10             	add    $0x10,%esp
    31f6:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    31f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3200:	e9 9c 00 00 00       	jmp    32a1 <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    3205:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3208:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    320b:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3210:	89 c8                	mov    %ecx,%eax
    3212:	f7 ea                	imul   %edx
    3214:	89 c8                	mov    %ecx,%eax
    3216:	c1 f8 1f             	sar    $0x1f,%eax
    3219:	29 c2                	sub    %eax,%edx
    321b:	89 d0                	mov    %edx,%eax
    321d:	89 c2                	mov    %eax,%edx
    321f:	89 d0                	mov    %edx,%eax
    3221:	01 c0                	add    %eax,%eax
    3223:	01 d0                	add    %edx,%eax
    3225:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3228:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    322b:	8b 45 e0             	mov    -0x20(%ebp),%eax
    322e:	01 c8                	add    %ecx,%eax
    3230:	0f b6 00             	movzbl (%eax),%eax
    3233:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    3236:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3239:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    323c:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3241:	89 c8                	mov    %ecx,%eax
    3243:	f7 ea                	imul   %edx
    3245:	89 c8                	mov    %ecx,%eax
    3247:	c1 f8 1f             	sar    $0x1f,%eax
    324a:	29 c2                	sub    %eax,%edx
    324c:	89 d0                	mov    %edx,%eax
    324e:	89 c2                	mov    %eax,%edx
    3250:	89 d0                	mov    %edx,%eax
    3252:	01 c0                	add    %eax,%eax
    3254:	01 d0                	add    %edx,%eax
    3256:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3259:	8b 45 f4             	mov    -0xc(%ebp),%eax
    325c:	8d 48 01             	lea    0x1(%eax),%ecx
    325f:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3262:	01 c8                	add    %ecx,%eax
    3264:	0f b6 00             	movzbl (%eax),%eax
    3267:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    326a:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    326d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3270:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3275:	89 c8                	mov    %ecx,%eax
    3277:	f7 ea                	imul   %edx
    3279:	89 c8                	mov    %ecx,%eax
    327b:	c1 f8 1f             	sar    $0x1f,%eax
    327e:	29 c2                	sub    %eax,%edx
    3280:	89 d0                	mov    %edx,%eax
    3282:	89 c2                	mov    %eax,%edx
    3284:	89 d0                	mov    %edx,%eax
    3286:	01 c0                	add    %eax,%eax
    3288:	01 d0                	add    %edx,%eax
    328a:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    328d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3290:	8d 48 02             	lea    0x2(%eax),%ecx
    3293:	8b 45 e0             	mov    -0x20(%ebp),%eax
    3296:	01 c8                	add    %ecx,%eax
    3298:	0f b6 00             	movzbl (%eax),%eax
    329b:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    329d:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    32a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    32a4:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    32a7:	0f 8c 58 ff ff ff    	jl     3205 <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    32ad:	8b 45 08             	mov    0x8(%ebp),%eax
    32b0:	8b 55 90             	mov    -0x70(%ebp),%edx
    32b3:	89 10                	mov    %edx,(%eax)
    32b5:	8b 55 94             	mov    -0x6c(%ebp),%edx
    32b8:	89 50 04             	mov    %edx,0x4(%eax)
    32bb:	8b 55 98             	mov    -0x68(%ebp),%edx
    32be:	89 50 08             	mov    %edx,0x8(%eax)
}
    32c1:	8b 45 08             	mov    0x8(%ebp),%eax
    32c4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    32c7:	c9                   	leave  
    32c8:	c2 04 00             	ret    $0x4

000032cb <LoadPng>:

PBitmap LoadPng(char* filename){
    32cb:	55                   	push   %ebp
    32cc:	89 e5                	mov    %esp,%ebp
    32ce:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    32d1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    32d8:	ff 75 0c             	pushl  0xc(%ebp)
    32db:	8d 45 e0             	lea    -0x20(%ebp),%eax
    32de:	50                   	push   %eax
    32df:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    32e2:	50                   	push   %eax
    32e3:	8d 45 e8             	lea    -0x18(%ebp),%eax
    32e6:	50                   	push   %eax
    32e7:	e8 d3 d3 00 00       	call   106bf <lodepng_decode24_file>
    32ec:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    32ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
    32f2:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    32f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    32f8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    32fb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    3302:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    3305:	8b 45 d8             	mov    -0x28(%ebp),%eax
    3308:	0f af c2             	imul   %edx,%eax
    330b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    330e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3311:	89 d0                	mov    %edx,%eax
    3313:	01 c0                	add    %eax,%eax
    3315:	01 d0                	add    %edx,%eax
    3317:	83 ec 0c             	sub    $0xc,%esp
    331a:	50                   	push   %eax
    331b:	e8 6e d5 ff ff       	call   88e <malloc>
    3320:	83 c4 10             	add    $0x10,%esp
    3323:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    3326:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    332d:	e9 87 00 00 00       	jmp    33b9 <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    3332:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3335:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3338:	89 d0                	mov    %edx,%eax
    333a:	01 c0                	add    %eax,%eax
    333c:	01 d0                	add    %edx,%eax
    333e:	01 c8                	add    %ecx,%eax
    3340:	0f b6 00             	movzbl (%eax),%eax
    3343:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    3346:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3349:	8b 55 f4             	mov    -0xc(%ebp),%edx
    334c:	89 d0                	mov    %edx,%eax
    334e:	01 c0                	add    %eax,%eax
    3350:	01 d0                	add    %edx,%eax
    3352:	83 c0 01             	add    $0x1,%eax
    3355:	01 c8                	add    %ecx,%eax
    3357:	0f b6 00             	movzbl (%eax),%eax
    335a:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    335d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    3360:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3363:	89 d0                	mov    %edx,%eax
    3365:	01 c0                	add    %eax,%eax
    3367:	01 d0                	add    %edx,%eax
    3369:	83 c0 02             	add    $0x2,%eax
    336c:	01 c8                	add    %ecx,%eax
    336e:	0f b6 00             	movzbl (%eax),%eax
    3371:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    3374:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3377:	8b 55 f4             	mov    -0xc(%ebp),%edx
    337a:	89 d0                	mov    %edx,%eax
    337c:	01 c0                	add    %eax,%eax
    337e:	01 d0                	add    %edx,%eax
    3380:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3383:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    3387:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    338a:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    338d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3390:	89 d0                	mov    %edx,%eax
    3392:	01 c0                	add    %eax,%eax
    3394:	01 d0                	add    %edx,%eax
    3396:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3399:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    339d:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    33a0:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    33a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    33a6:	89 d0                	mov    %edx,%eax
    33a8:	01 c0                	add    %eax,%eax
    33aa:	01 d0                	add    %edx,%eax
    33ac:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    33af:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    33b3:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    33b5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    33b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    33bc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    33bf:	0f 8c 6d ff ff ff    	jl     3332 <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    33c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    33c8:	83 ec 0c             	sub    $0xc,%esp
    33cb:	50                   	push   %eax
    33cc:	e8 7b d3 ff ff       	call   74c <free>
    33d1:	83 c4 10             	add    $0x10,%esp
    return bmp;
    33d4:	8b 45 08             	mov    0x8(%ebp),%eax
    33d7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    33da:	89 10                	mov    %edx,(%eax)
    33dc:	8b 55 d8             	mov    -0x28(%ebp),%edx
    33df:	89 50 04             	mov    %edx,0x4(%eax)
    33e2:	8b 55 dc             	mov    -0x24(%ebp),%edx
    33e5:	89 50 08             	mov    %edx,0x8(%eax)

}
    33e8:	8b 45 08             	mov    0x8(%ebp),%eax
    33eb:	c9                   	leave  
    33ec:	c2 04 00             	ret    $0x4

000033ef <LoadImg>:

PBitmap LoadImg(char* filename){
    33ef:	55                   	push   %ebp
    33f0:	89 e5                	mov    %esp,%ebp
    33f2:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    33f5:	83 ec 0c             	sub    $0xc,%esp
    33f8:	ff 75 0c             	pushl  0xc(%ebp)
    33fb:	e8 7c f8 ff ff       	call   2c7c <type>
    3400:	83 c4 10             	add    $0x10,%esp
    3403:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    3406:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3409:	83 f8 01             	cmp    $0x1,%eax
    340c:	74 1d                	je     342b <LoadImg+0x3c>
    340e:	83 f8 02             	cmp    $0x2,%eax
    3411:	74 2c                	je     343f <LoadImg+0x50>
    3413:	85 c0                	test   %eax,%eax
    3415:	75 3c                	jne    3453 <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    3417:	8b 45 08             	mov    0x8(%ebp),%eax
    341a:	83 ec 08             	sub    $0x8,%esp
    341d:	ff 75 0c             	pushl  0xc(%ebp)
    3420:	50                   	push   %eax
    3421:	e8 c6 fb ff ff       	call   2fec <LoadJpeg>
    3426:	83 c4 0c             	add    $0xc,%esp
    3429:	eb 3c                	jmp    3467 <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    342b:	8b 45 08             	mov    0x8(%ebp),%eax
    342e:	83 ec 08             	sub    $0x8,%esp
    3431:	ff 75 0c             	pushl  0xc(%ebp)
    3434:	50                   	push   %eax
    3435:	e8 17 f9 ff ff       	call   2d51 <LoadBmp>
    343a:	83 c4 0c             	add    $0xc,%esp
    343d:	eb 28                	jmp    3467 <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    343f:	8b 45 08             	mov    0x8(%ebp),%eax
    3442:	83 ec 08             	sub    $0x8,%esp
    3445:	ff 75 0c             	pushl  0xc(%ebp)
    3448:	50                   	push   %eax
    3449:	e8 7d fe ff ff       	call   32cb <LoadPng>
    344e:	83 c4 0c             	add    $0xc,%esp
    3451:	eb 14                	jmp    3467 <LoadImg+0x78>

        default: return bmp;
    3453:	8b 45 08             	mov    0x8(%ebp),%eax
    3456:	8b 55 e8             	mov    -0x18(%ebp),%edx
    3459:	89 10                	mov    %edx,(%eax)
    345b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    345e:	89 50 04             	mov    %edx,0x4(%eax)
    3461:	8b 55 f0             	mov    -0x10(%ebp),%edx
    3464:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    3467:	8b 45 08             	mov    0x8(%ebp),%eax
    346a:	c9                   	leave  
    346b:	c2 04 00             	ret    $0x4

0000346e <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    346e:	55                   	push   %ebp
    346f:	89 e5                	mov    %esp,%ebp
    3471:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    3474:	8b 45 08             	mov    0x8(%ebp),%eax
    3477:	83 ec 0c             	sub    $0xc,%esp
    347a:	50                   	push   %eax
    347b:	e8 0e d4 ff ff       	call   88e <malloc>
    3480:	83 c4 10             	add    $0x10,%esp
}
    3483:	c9                   	leave  
    3484:	c3                   	ret    

00003485 <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    3485:	55                   	push   %ebp
    3486:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    3488:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    348d:	5d                   	pop    %ebp
    348e:	c3                   	ret    

0000348f <lodepng_free>:

static void lodepng_free(void* ptr) {
    348f:	55                   	push   %ebp
    3490:	89 e5                	mov    %esp,%ebp
    3492:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    3495:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    3499:	74 0e                	je     34a9 <lodepng_free+0x1a>
    free(ptr);
    349b:	83 ec 0c             	sub    $0xc,%esp
    349e:	ff 75 08             	pushl  0x8(%ebp)
    34a1:	e8 a6 d2 ff ff       	call   74c <free>
    34a6:	83 c4 10             	add    $0x10,%esp
}
    34a9:	90                   	nop
    34aa:	c9                   	leave  
    34ab:	c3                   	ret    

000034ac <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    34ac:	55                   	push   %ebp
    34ad:	89 e5                	mov    %esp,%ebp
    34af:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    34b2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    34b9:	eb 19                	jmp    34d4 <lodepng_memcpy+0x28>
    34bb:	8b 55 fc             	mov    -0x4(%ebp),%edx
    34be:	8b 45 08             	mov    0x8(%ebp),%eax
    34c1:	01 c2                	add    %eax,%edx
    34c3:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    34c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    34c9:	01 c8                	add    %ecx,%eax
    34cb:	0f b6 00             	movzbl (%eax),%eax
    34ce:	88 02                	mov    %al,(%edx)
    34d0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    34d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    34d7:	3b 45 10             	cmp    0x10(%ebp),%eax
    34da:	7c df                	jl     34bb <lodepng_memcpy+0xf>
}
    34dc:	90                   	nop
    34dd:	c9                   	leave  
    34de:	c3                   	ret    

000034df <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    34df:	55                   	push   %ebp
    34e0:	89 e5                	mov    %esp,%ebp
    34e2:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    34e5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    34ec:	eb 11                	jmp    34ff <lodepng_memset+0x20>
    34ee:	8b 55 fc             	mov    -0x4(%ebp),%edx
    34f1:	8b 45 08             	mov    0x8(%ebp),%eax
    34f4:	01 d0                	add    %edx,%eax
    34f6:	8b 55 0c             	mov    0xc(%ebp),%edx
    34f9:	88 10                	mov    %dl,(%eax)
    34fb:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    34ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3502:	3b 45 10             	cmp    0x10(%ebp),%eax
    3505:	7c e7                	jl     34ee <lodepng_memset+0xf>
}
    3507:	90                   	nop
    3508:	c9                   	leave  
    3509:	c3                   	ret    

0000350a <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    350a:	55                   	push   %ebp
    350b:	89 e5                	mov    %esp,%ebp
    350d:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    3510:	8b 45 08             	mov    0x8(%ebp),%eax
    3513:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    3516:	eb 04                	jmp    351c <lodepng_strlen+0x12>
    3518:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    351c:	8b 45 08             	mov    0x8(%ebp),%eax
    351f:	0f b6 00             	movzbl (%eax),%eax
    3522:	84 c0                	test   %al,%al
    3524:	75 f2                	jne    3518 <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    3526:	8b 55 08             	mov    0x8(%ebp),%edx
    3529:	8b 45 fc             	mov    -0x4(%ebp),%eax
    352c:	29 c2                	sub    %eax,%edx
    352e:	89 d0                	mov    %edx,%eax
}
    3530:	c9                   	leave  
    3531:	c3                   	ret    

00003532 <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    3532:	55                   	push   %ebp
    3533:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    3535:	8b 55 08             	mov    0x8(%ebp),%edx
    3538:	8b 45 0c             	mov    0xc(%ebp),%eax
    353b:	01 c2                	add    %eax,%edx
    353d:	8b 45 10             	mov    0x10(%ebp),%eax
    3540:	89 10                	mov    %edx,(%eax)
  return *result < a;
    3542:	8b 45 10             	mov    0x10(%ebp),%eax
    3545:	8b 00                	mov    (%eax),%eax
    3547:	3b 45 08             	cmp    0x8(%ebp),%eax
    354a:	0f 9c c0             	setl   %al
    354d:	0f b6 c0             	movzbl %al,%eax
}
    3550:	5d                   	pop    %ebp
    3551:	c3                   	ret    

00003552 <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    3552:	55                   	push   %ebp
    3553:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    3555:	8b 45 08             	mov    0x8(%ebp),%eax
    3558:	0f af 45 0c          	imul   0xc(%ebp),%eax
    355c:	89 c2                	mov    %eax,%edx
    355e:	8b 45 10             	mov    0x10(%ebp),%eax
    3561:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    3563:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    3567:	74 15                	je     357e <lodepng_mulofl+0x2c>
    3569:	8b 45 10             	mov    0x10(%ebp),%eax
    356c:	8b 00                	mov    (%eax),%eax
    356e:	99                   	cltd   
    356f:	f7 7d 08             	idivl  0x8(%ebp)
    3572:	3b 45 0c             	cmp    0xc(%ebp),%eax
    3575:	74 07                	je     357e <lodepng_mulofl+0x2c>
    3577:	b8 01 00 00 00       	mov    $0x1,%eax
    357c:	eb 05                	jmp    3583 <lodepng_mulofl+0x31>
    357e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3583:	5d                   	pop    %ebp
    3584:	c3                   	ret    

00003585 <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    3585:	55                   	push   %ebp
    3586:	89 e5                	mov    %esp,%ebp
    3588:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    358b:	8d 45 fc             	lea    -0x4(%ebp),%eax
    358e:	50                   	push   %eax
    358f:	ff 75 0c             	pushl  0xc(%ebp)
    3592:	ff 75 08             	pushl  0x8(%ebp)
    3595:	e8 98 ff ff ff       	call   3532 <lodepng_addofl>
    359a:	83 c4 0c             	add    $0xc,%esp
    359d:	85 c0                	test   %eax,%eax
    359f:	74 07                	je     35a8 <lodepng_gtofl+0x23>
    35a1:	b8 01 00 00 00       	mov    $0x1,%eax
    35a6:	eb 0c                	jmp    35b4 <lodepng_gtofl+0x2f>
  return d > c;
    35a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    35ab:	3b 45 10             	cmp    0x10(%ebp),%eax
    35ae:	0f 9f c0             	setg   %al
    35b1:	0f b6 c0             	movzbl %al,%eax
}
    35b4:	c9                   	leave  
    35b5:	c3                   	ret    

000035b6 <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    35b6:	55                   	push   %ebp
    35b7:	89 e5                	mov    %esp,%ebp
    35b9:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    35bc:	8b 45 08             	mov    0x8(%ebp),%eax
    35bf:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    35c6:	8b 45 08             	mov    0x8(%ebp),%eax
    35c9:	8b 50 08             	mov    0x8(%eax),%edx
    35cc:	8b 45 08             	mov    0x8(%ebp),%eax
    35cf:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    35d2:	8b 45 08             	mov    0x8(%ebp),%eax
    35d5:	8b 00                	mov    (%eax),%eax
    35d7:	83 ec 0c             	sub    $0xc,%esp
    35da:	50                   	push   %eax
    35db:	e8 af fe ff ff       	call   348f <lodepng_free>
    35e0:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    35e3:	8b 45 08             	mov    0x8(%ebp),%eax
    35e6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    35ec:	90                   	nop
    35ed:	c9                   	leave  
    35ee:	c3                   	ret    

000035ef <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    35ef:	55                   	push   %ebp
    35f0:	89 e5                	mov    %esp,%ebp
    35f2:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    35f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    35f8:	c1 e0 02             	shl    $0x2,%eax
    35fb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    35fe:	8b 45 08             	mov    0x8(%ebp),%eax
    3601:	8b 40 08             	mov    0x8(%eax),%eax
    3604:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    3607:	7d 46                	jge    364f <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    3609:	8b 45 08             	mov    0x8(%ebp),%eax
    360c:	8b 40 08             	mov    0x8(%eax),%eax
    360f:	d1 f8                	sar    %eax
    3611:	89 c2                	mov    %eax,%edx
    3613:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3616:	01 d0                	add    %edx,%eax
    3618:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    361b:	8b 45 08             	mov    0x8(%ebp),%eax
    361e:	8b 00                	mov    (%eax),%eax
    3620:	ff 75 f8             	pushl  -0x8(%ebp)
    3623:	50                   	push   %eax
    3624:	e8 5c fe ff ff       	call   3485 <lodepng_realloc>
    3629:	83 c4 08             	add    $0x8,%esp
    362c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    362f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3633:	74 13                	je     3648 <uivector_resize+0x59>
      p->allocsize = newsize;
    3635:	8b 45 08             	mov    0x8(%ebp),%eax
    3638:	8b 55 f8             	mov    -0x8(%ebp),%edx
    363b:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    363e:	8b 45 08             	mov    0x8(%ebp),%eax
    3641:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3644:	89 10                	mov    %edx,(%eax)
    3646:	eb 07                	jmp    364f <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    3648:	b8 00 00 00 00       	mov    $0x0,%eax
    364d:	eb 0e                	jmp    365d <uivector_resize+0x6e>
  }
  p->size = size;
    364f:	8b 45 08             	mov    0x8(%ebp),%eax
    3652:	8b 55 0c             	mov    0xc(%ebp),%edx
    3655:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    3658:	b8 01 00 00 00       	mov    $0x1,%eax
}
    365d:	c9                   	leave  
    365e:	c3                   	ret    

0000365f <uivector_init>:

static void uivector_init(uivector* p) {
    365f:	55                   	push   %ebp
    3660:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    3662:	8b 45 08             	mov    0x8(%ebp),%eax
    3665:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    366b:	8b 45 08             	mov    0x8(%ebp),%eax
    366e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    3675:	8b 45 08             	mov    0x8(%ebp),%eax
    3678:	8b 50 08             	mov    0x8(%eax),%edx
    367b:	8b 45 08             	mov    0x8(%ebp),%eax
    367e:	89 50 04             	mov    %edx,0x4(%eax)
}
    3681:	90                   	nop
    3682:	5d                   	pop    %ebp
    3683:	c3                   	ret    

00003684 <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    3684:	55                   	push   %ebp
    3685:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    3687:	8b 45 08             	mov    0x8(%ebp),%eax
    368a:	8b 40 04             	mov    0x4(%eax),%eax
    368d:	83 c0 01             	add    $0x1,%eax
    3690:	50                   	push   %eax
    3691:	ff 75 08             	pushl  0x8(%ebp)
    3694:	e8 56 ff ff ff       	call   35ef <uivector_resize>
    3699:	83 c4 08             	add    $0x8,%esp
    369c:	85 c0                	test   %eax,%eax
    369e:	75 07                	jne    36a7 <uivector_push_back+0x23>
    36a0:	b8 00 00 00 00       	mov    $0x0,%eax
    36a5:	eb 1f                	jmp    36c6 <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    36a7:	8b 45 08             	mov    0x8(%ebp),%eax
    36aa:	8b 10                	mov    (%eax),%edx
    36ac:	8b 45 08             	mov    0x8(%ebp),%eax
    36af:	8b 40 04             	mov    0x4(%eax),%eax
    36b2:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    36b7:	c1 e0 02             	shl    $0x2,%eax
    36ba:	01 c2                	add    %eax,%edx
    36bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    36bf:	89 02                	mov    %eax,(%edx)
  return 1;
    36c1:	b8 01 00 00 00       	mov    $0x1,%eax
}
    36c6:	c9                   	leave  
    36c7:	c3                   	ret    

000036c8 <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    36c8:	55                   	push   %ebp
    36c9:	89 e5                	mov    %esp,%ebp
    36cb:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    36ce:	8b 45 08             	mov    0x8(%ebp),%eax
    36d1:	8b 40 08             	mov    0x8(%eax),%eax
    36d4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    36d7:	7d 46                	jge    371f <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    36d9:	8b 45 08             	mov    0x8(%ebp),%eax
    36dc:	8b 40 08             	mov    0x8(%eax),%eax
    36df:	d1 f8                	sar    %eax
    36e1:	89 c2                	mov    %eax,%edx
    36e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    36e6:	01 d0                	add    %edx,%eax
    36e8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    36eb:	8b 45 08             	mov    0x8(%ebp),%eax
    36ee:	8b 00                	mov    (%eax),%eax
    36f0:	ff 75 fc             	pushl  -0x4(%ebp)
    36f3:	50                   	push   %eax
    36f4:	e8 8c fd ff ff       	call   3485 <lodepng_realloc>
    36f9:	83 c4 08             	add    $0x8,%esp
    36fc:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    36ff:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    3703:	74 13                	je     3718 <ucvector_resize+0x50>
      p->allocsize = newsize;
    3705:	8b 45 08             	mov    0x8(%ebp),%eax
    3708:	8b 55 fc             	mov    -0x4(%ebp),%edx
    370b:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    370e:	8b 45 08             	mov    0x8(%ebp),%eax
    3711:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3714:	89 10                	mov    %edx,(%eax)
    3716:	eb 07                	jmp    371f <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    3718:	b8 00 00 00 00       	mov    $0x0,%eax
    371d:	eb 0e                	jmp    372d <ucvector_resize+0x65>
  }
  p->size = size;
    371f:	8b 45 08             	mov    0x8(%ebp),%eax
    3722:	8b 55 0c             	mov    0xc(%ebp),%edx
    3725:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    3728:	b8 01 00 00 00       	mov    $0x1,%eax
}
    372d:	c9                   	leave  
    372e:	c3                   	ret    

0000372f <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    372f:	55                   	push   %ebp
    3730:	89 e5                	mov    %esp,%ebp
    3732:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    3735:	8b 45 0c             	mov    0xc(%ebp),%eax
    3738:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    373b:	8b 45 10             	mov    0x10(%ebp),%eax
    373e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    3741:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3744:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    3747:	8b 45 08             	mov    0x8(%ebp),%eax
    374a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    374d:	89 10                	mov    %edx,(%eax)
    374f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    3752:	89 50 04             	mov    %edx,0x4(%eax)
    3755:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3758:	89 50 08             	mov    %edx,0x8(%eax)
}
    375b:	8b 45 08             	mov    0x8(%ebp),%eax
    375e:	c9                   	leave  
    375f:	c2 04 00             	ret    $0x4

00003762 <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    3762:	55                   	push   %ebp
    3763:	89 e5                	mov    %esp,%ebp
    3765:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    3768:	8b 45 08             	mov    0x8(%ebp),%eax
    376b:	8b 00                	mov    (%eax),%eax
    376d:	83 ec 0c             	sub    $0xc,%esp
    3770:	50                   	push   %eax
    3771:	e8 19 fd ff ff       	call   348f <lodepng_free>
    3776:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    3779:	8b 45 08             	mov    0x8(%ebp),%eax
    377c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3782:	90                   	nop
    3783:	c9                   	leave  
    3784:	c3                   	ret    

00003785 <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    3785:	55                   	push   %ebp
    3786:	89 e5                	mov    %esp,%ebp
    3788:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    378b:	8b 45 0c             	mov    0xc(%ebp),%eax
    378e:	83 c0 01             	add    $0x1,%eax
    3791:	83 ec 0c             	sub    $0xc,%esp
    3794:	50                   	push   %eax
    3795:	e8 d4 fc ff ff       	call   346e <lodepng_malloc>
    379a:	83 c4 10             	add    $0x10,%esp
    379d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    37a0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    37a4:	74 1f                	je     37c5 <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    37a6:	83 ec 04             	sub    $0x4,%esp
    37a9:	ff 75 0c             	pushl  0xc(%ebp)
    37ac:	ff 75 08             	pushl  0x8(%ebp)
    37af:	ff 75 f4             	pushl  -0xc(%ebp)
    37b2:	e8 f5 fc ff ff       	call   34ac <lodepng_memcpy>
    37b7:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    37ba:	8b 55 0c             	mov    0xc(%ebp),%edx
    37bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    37c0:	01 d0                	add    %edx,%eax
    37c2:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    37c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    37c8:	c9                   	leave  
    37c9:	c3                   	ret    

000037ca <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    37ca:	55                   	push   %ebp
    37cb:	89 e5                	mov    %esp,%ebp
    37cd:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    37d0:	ff 75 08             	pushl  0x8(%ebp)
    37d3:	e8 32 fd ff ff       	call   350a <lodepng_strlen>
    37d8:	83 c4 04             	add    $0x4,%esp
    37db:	83 ec 08             	sub    $0x8,%esp
    37de:	50                   	push   %eax
    37df:	ff 75 08             	pushl  0x8(%ebp)
    37e2:	e8 9e ff ff ff       	call   3785 <alloc_string_sized>
    37e7:	83 c4 10             	add    $0x10,%esp
}
    37ea:	c9                   	leave  
    37eb:	c3                   	ret    

000037ec <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    37ec:	55                   	push   %ebp
    37ed:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    37ef:	8b 45 08             	mov    0x8(%ebp),%eax
    37f2:	0f b6 00             	movzbl (%eax),%eax
    37f5:	0f b6 c0             	movzbl %al,%eax
    37f8:	c1 e0 18             	shl    $0x18,%eax
    37fb:	89 c2                	mov    %eax,%edx
    37fd:	8b 45 08             	mov    0x8(%ebp),%eax
    3800:	83 c0 01             	add    $0x1,%eax
    3803:	0f b6 00             	movzbl (%eax),%eax
    3806:	0f b6 c0             	movzbl %al,%eax
    3809:	c1 e0 10             	shl    $0x10,%eax
    380c:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    380e:	8b 45 08             	mov    0x8(%ebp),%eax
    3811:	83 c0 02             	add    $0x2,%eax
    3814:	0f b6 00             	movzbl (%eax),%eax
    3817:	0f b6 c0             	movzbl %al,%eax
    381a:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    381d:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    381f:	8b 45 08             	mov    0x8(%ebp),%eax
    3822:	83 c0 03             	add    $0x3,%eax
    3825:	0f b6 00             	movzbl (%eax),%eax
    3828:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    382b:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    382d:	5d                   	pop    %ebp
    382e:	c3                   	ret    

0000382f <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    382f:	55                   	push   %ebp
    3830:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    3832:	8b 45 0c             	mov    0xc(%ebp),%eax
    3835:	c1 e8 18             	shr    $0x18,%eax
    3838:	89 c2                	mov    %eax,%edx
    383a:	8b 45 08             	mov    0x8(%ebp),%eax
    383d:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    383f:	8b 45 08             	mov    0x8(%ebp),%eax
    3842:	83 c0 01             	add    $0x1,%eax
    3845:	8b 55 0c             	mov    0xc(%ebp),%edx
    3848:	c1 ea 10             	shr    $0x10,%edx
    384b:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    384d:	8b 45 08             	mov    0x8(%ebp),%eax
    3850:	83 c0 02             	add    $0x2,%eax
    3853:	8b 55 0c             	mov    0xc(%ebp),%edx
    3856:	c1 ea 08             	shr    $0x8,%edx
    3859:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    385b:	8b 45 08             	mov    0x8(%ebp),%eax
    385e:	83 c0 03             	add    $0x3,%eax
    3861:	8b 55 0c             	mov    0xc(%ebp),%edx
    3864:	88 10                	mov    %dl,(%eax)
}
    3866:	90                   	nop
    3867:	5d                   	pop    %ebp
    3868:	c3                   	ret    

00003869 <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    3869:	55                   	push   %ebp
    386a:	89 e5                	mov    %esp,%ebp
    386c:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    386f:	83 ec 08             	sub    $0x8,%esp
    3872:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    3875:	50                   	push   %eax
    3876:	ff 75 08             	pushl  0x8(%ebp)
    3879:	e8 b7 ca ff ff       	call   335 <stat>
    387e:	83 c4 10             	add    $0x10,%esp
  return s.size;
    3881:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3884:	c9                   	leave  
    3885:	c3                   	ret    

00003886 <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    3886:	55                   	push   %ebp
    3887:	89 e5                	mov    %esp,%ebp
    3889:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    388c:	83 ec 08             	sub    $0x8,%esp
    388f:	6a 00                	push   $0x0
    3891:	ff 75 10             	pushl  0x10(%ebp)
    3894:	e8 bb cb ff ff       	call   454 <open>
    3899:	83 c4 10             	add    $0x10,%esp
    389c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    389f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    38a3:	79 07                	jns    38ac <lodepng_buffer_file+0x26>
  {
      return -1;
    38a5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    38aa:	eb 19                	jmp    38c5 <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    38ac:	83 ec 04             	sub    $0x4,%esp
    38af:	ff 75 0c             	pushl  0xc(%ebp)
    38b2:	ff 75 08             	pushl  0x8(%ebp)
    38b5:	ff 75 f4             	pushl  -0xc(%ebp)
    38b8:	e8 6f cb ff ff       	call   42c <read>
    38bd:	83 c4 10             	add    $0x10,%esp
  return 0;
    38c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    38c5:	c9                   	leave  
    38c6:	c3                   	ret    

000038c7 <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    38c7:	55                   	push   %ebp
    38c8:	89 e5                	mov    %esp,%ebp
    38ca:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    38cd:	83 ec 0c             	sub    $0xc,%esp
    38d0:	ff 75 10             	pushl  0x10(%ebp)
    38d3:	e8 91 ff ff ff       	call   3869 <lodepng_filesize>
    38d8:	83 c4 10             	add    $0x10,%esp
    38db:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    38de:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    38e2:	79 07                	jns    38eb <lodepng_load_file+0x24>
    38e4:	b8 4e 00 00 00       	mov    $0x4e,%eax
    38e9:	eb 4a                	jmp    3935 <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    38eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    38ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
    38f1:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    38f3:	83 ec 0c             	sub    $0xc,%esp
    38f6:	ff 75 f4             	pushl  -0xc(%ebp)
    38f9:	e8 70 fb ff ff       	call   346e <lodepng_malloc>
    38fe:	83 c4 10             	add    $0x10,%esp
    3901:	89 c2                	mov    %eax,%edx
    3903:	8b 45 08             	mov    0x8(%ebp),%eax
    3906:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    3908:	8b 45 08             	mov    0x8(%ebp),%eax
    390b:	8b 00                	mov    (%eax),%eax
    390d:	85 c0                	test   %eax,%eax
    390f:	75 0d                	jne    391e <lodepng_load_file+0x57>
    3911:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3915:	7e 07                	jle    391e <lodepng_load_file+0x57>
    3917:	b8 53 00 00 00       	mov    $0x53,%eax
    391c:	eb 17                	jmp    3935 <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    391e:	8b 45 08             	mov    0x8(%ebp),%eax
    3921:	8b 00                	mov    (%eax),%eax
    3923:	83 ec 04             	sub    $0x4,%esp
    3926:	ff 75 10             	pushl  0x10(%ebp)
    3929:	ff 75 f4             	pushl  -0xc(%ebp)
    392c:	50                   	push   %eax
    392d:	e8 54 ff ff ff       	call   3886 <lodepng_buffer_file>
    3932:	83 c4 10             	add    $0x10,%esp
}
    3935:	c9                   	leave  
    3936:	c3                   	ret    

00003937 <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    3937:	55                   	push   %ebp
    3938:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    393a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    393f:	5d                   	pop    %ebp
    3940:	c3                   	ret    

00003941 <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    3941:	55                   	push   %ebp
    3942:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    3944:	8b 45 08             	mov    0x8(%ebp),%eax
    3947:	8b 55 0c             	mov    0xc(%ebp),%edx
    394a:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    394c:	8b 45 08             	mov    0x8(%ebp),%eax
    394f:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    3953:	90                   	nop
    3954:	5d                   	pop    %ebp
    3955:	c3                   	ret    

00003956 <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3956:	55                   	push   %ebp
    3957:	89 e5                	mov    %esp,%ebp
    3959:	56                   	push   %esi
    395a:	53                   	push   %ebx
    395b:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    395e:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    3962:	0f 85 aa 00 00 00    	jne    3a12 <writeBits+0xbc>
    WRITEBIT(writer, value);
    3968:	8b 45 08             	mov    0x8(%ebp),%eax
    396b:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    396f:	0f b6 c0             	movzbl %al,%eax
    3972:	83 e0 07             	and    $0x7,%eax
    3975:	85 c0                	test   %eax,%eax
    3977:	75 39                	jne    39b2 <writeBits+0x5c>
    3979:	8b 45 08             	mov    0x8(%ebp),%eax
    397c:	8b 00                	mov    (%eax),%eax
    397e:	8b 40 04             	mov    0x4(%eax),%eax
    3981:	8d 50 01             	lea    0x1(%eax),%edx
    3984:	8b 45 08             	mov    0x8(%ebp),%eax
    3987:	8b 00                	mov    (%eax),%eax
    3989:	52                   	push   %edx
    398a:	50                   	push   %eax
    398b:	e8 38 fd ff ff       	call   36c8 <ucvector_resize>
    3990:	83 c4 08             	add    $0x8,%esp
    3993:	85 c0                	test   %eax,%eax
    3995:	0f 84 44 01 00 00    	je     3adf <writeBits+0x189>
    399b:	8b 45 08             	mov    0x8(%ebp),%eax
    399e:	8b 00                	mov    (%eax),%eax
    39a0:	8b 10                	mov    (%eax),%edx
    39a2:	8b 45 08             	mov    0x8(%ebp),%eax
    39a5:	8b 00                	mov    (%eax),%eax
    39a7:	8b 40 04             	mov    0x4(%eax),%eax
    39aa:	83 e8 01             	sub    $0x1,%eax
    39ad:	01 d0                	add    %edx,%eax
    39af:	c6 00 00             	movb   $0x0,(%eax)
    39b2:	8b 45 08             	mov    0x8(%ebp),%eax
    39b5:	8b 00                	mov    (%eax),%eax
    39b7:	8b 10                	mov    (%eax),%edx
    39b9:	8b 45 08             	mov    0x8(%ebp),%eax
    39bc:	8b 00                	mov    (%eax),%eax
    39be:	8b 40 04             	mov    0x4(%eax),%eax
    39c1:	83 e8 01             	sub    $0x1,%eax
    39c4:	01 c2                	add    %eax,%edx
    39c6:	8b 45 08             	mov    0x8(%ebp),%eax
    39c9:	8b 00                	mov    (%eax),%eax
    39cb:	8b 08                	mov    (%eax),%ecx
    39cd:	8b 45 08             	mov    0x8(%ebp),%eax
    39d0:	8b 00                	mov    (%eax),%eax
    39d2:	8b 40 04             	mov    0x4(%eax),%eax
    39d5:	83 e8 01             	sub    $0x1,%eax
    39d8:	01 c8                	add    %ecx,%eax
    39da:	0f b6 00             	movzbl (%eax),%eax
    39dd:	88 45 e7             	mov    %al,-0x19(%ebp)
    39e0:	8b 45 08             	mov    0x8(%ebp),%eax
    39e3:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    39e7:	0f b6 c0             	movzbl %al,%eax
    39ea:	83 e0 07             	and    $0x7,%eax
    39ed:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    39f0:	89 de                	mov    %ebx,%esi
    39f2:	89 c1                	mov    %eax,%ecx
    39f4:	d3 e6                	shl    %cl,%esi
    39f6:	89 f0                	mov    %esi,%eax
    39f8:	0a 45 e7             	or     -0x19(%ebp),%al
    39fb:	88 02                	mov    %al,(%edx)
    39fd:	8b 45 08             	mov    0x8(%ebp),%eax
    3a00:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a04:	8d 50 01             	lea    0x1(%eax),%edx
    3a07:	8b 45 08             	mov    0x8(%ebp),%eax
    3a0a:	88 50 04             	mov    %dl,0x4(%eax)
    3a0d:	e9 d1 00 00 00       	jmp    3ae3 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3a12:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3a19:	e9 b3 00 00 00       	jmp    3ad1 <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3a1e:	8b 45 08             	mov    0x8(%ebp),%eax
    3a21:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3a25:	0f b6 c0             	movzbl %al,%eax
    3a28:	83 e0 07             	and    $0x7,%eax
    3a2b:	85 c0                	test   %eax,%eax
    3a2d:	75 39                	jne    3a68 <writeBits+0x112>
    3a2f:	8b 45 08             	mov    0x8(%ebp),%eax
    3a32:	8b 00                	mov    (%eax),%eax
    3a34:	8b 40 04             	mov    0x4(%eax),%eax
    3a37:	8d 50 01             	lea    0x1(%eax),%edx
    3a3a:	8b 45 08             	mov    0x8(%ebp),%eax
    3a3d:	8b 00                	mov    (%eax),%eax
    3a3f:	52                   	push   %edx
    3a40:	50                   	push   %eax
    3a41:	e8 82 fc ff ff       	call   36c8 <ucvector_resize>
    3a46:	83 c4 08             	add    $0x8,%esp
    3a49:	85 c0                	test   %eax,%eax
    3a4b:	0f 84 91 00 00 00    	je     3ae2 <writeBits+0x18c>
    3a51:	8b 45 08             	mov    0x8(%ebp),%eax
    3a54:	8b 00                	mov    (%eax),%eax
    3a56:	8b 10                	mov    (%eax),%edx
    3a58:	8b 45 08             	mov    0x8(%ebp),%eax
    3a5b:	8b 00                	mov    (%eax),%eax
    3a5d:	8b 40 04             	mov    0x4(%eax),%eax
    3a60:	83 e8 01             	sub    $0x1,%eax
    3a63:	01 d0                	add    %edx,%eax
    3a65:	c6 00 00             	movb   $0x0,(%eax)
    3a68:	8b 45 08             	mov    0x8(%ebp),%eax
    3a6b:	8b 00                	mov    (%eax),%eax
    3a6d:	8b 10                	mov    (%eax),%edx
    3a6f:	8b 45 08             	mov    0x8(%ebp),%eax
    3a72:	8b 00                	mov    (%eax),%eax
    3a74:	8b 40 04             	mov    0x4(%eax),%eax
    3a77:	83 e8 01             	sub    $0x1,%eax
    3a7a:	01 c2                	add    %eax,%edx
    3a7c:	8b 45 08             	mov    0x8(%ebp),%eax
    3a7f:	8b 00                	mov    (%eax),%eax
    3a81:	8b 08                	mov    (%eax),%ecx
    3a83:	8b 45 08             	mov    0x8(%ebp),%eax
    3a86:	8b 00                	mov    (%eax),%eax
    3a88:	8b 40 04             	mov    0x4(%eax),%eax
    3a8b:	83 e8 01             	sub    $0x1,%eax
    3a8e:	01 c8                	add    %ecx,%eax
    3a90:	0f b6 00             	movzbl (%eax),%eax
    3a93:	89 c6                	mov    %eax,%esi
    3a95:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3a98:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3a9b:	89 c1                	mov    %eax,%ecx
    3a9d:	d3 eb                	shr    %cl,%ebx
    3a9f:	89 d8                	mov    %ebx,%eax
    3aa1:	83 e0 01             	and    $0x1,%eax
    3aa4:	89 c3                	mov    %eax,%ebx
    3aa6:	8b 45 08             	mov    0x8(%ebp),%eax
    3aa9:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3aad:	0f b6 c0             	movzbl %al,%eax
    3ab0:	83 e0 07             	and    $0x7,%eax
    3ab3:	89 c1                	mov    %eax,%ecx
    3ab5:	d3 e3                	shl    %cl,%ebx
    3ab7:	89 d8                	mov    %ebx,%eax
    3ab9:	09 f0                	or     %esi,%eax
    3abb:	88 02                	mov    %al,(%edx)
    3abd:	8b 45 08             	mov    0x8(%ebp),%eax
    3ac0:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3ac4:	8d 50 01             	lea    0x1(%eax),%edx
    3ac7:	8b 45 08             	mov    0x8(%ebp),%eax
    3aca:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3acd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3ad1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3ad4:	3b 45 10             	cmp    0x10(%ebp),%eax
    3ad7:	0f 85 41 ff ff ff    	jne    3a1e <writeBits+0xc8>
    3add:	eb 04                	jmp    3ae3 <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    3adf:	90                   	nop
    3ae0:	eb 01                	jmp    3ae3 <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3ae2:	90                   	nop
    }
  }
}
    3ae3:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3ae6:	5b                   	pop    %ebx
    3ae7:	5e                   	pop    %esi
    3ae8:	5d                   	pop    %ebp
    3ae9:	c3                   	ret    

00003aea <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3aea:	55                   	push   %ebp
    3aeb:	89 e5                	mov    %esp,%ebp
    3aed:	56                   	push   %esi
    3aee:	53                   	push   %ebx
    3aef:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3af2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3af9:	e9 bd 00 00 00       	jmp    3bbb <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3afe:	8b 45 08             	mov    0x8(%ebp),%eax
    3b01:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3b05:	0f b6 c0             	movzbl %al,%eax
    3b08:	83 e0 07             	and    $0x7,%eax
    3b0b:	85 c0                	test   %eax,%eax
    3b0d:	75 39                	jne    3b48 <writeBitsReversed+0x5e>
    3b0f:	8b 45 08             	mov    0x8(%ebp),%eax
    3b12:	8b 00                	mov    (%eax),%eax
    3b14:	8b 40 04             	mov    0x4(%eax),%eax
    3b17:	8d 50 01             	lea    0x1(%eax),%edx
    3b1a:	8b 45 08             	mov    0x8(%ebp),%eax
    3b1d:	8b 00                	mov    (%eax),%eax
    3b1f:	52                   	push   %edx
    3b20:	50                   	push   %eax
    3b21:	e8 a2 fb ff ff       	call   36c8 <ucvector_resize>
    3b26:	83 c4 08             	add    $0x8,%esp
    3b29:	85 c0                	test   %eax,%eax
    3b2b:	0f 84 98 00 00 00    	je     3bc9 <writeBitsReversed+0xdf>
    3b31:	8b 45 08             	mov    0x8(%ebp),%eax
    3b34:	8b 00                	mov    (%eax),%eax
    3b36:	8b 10                	mov    (%eax),%edx
    3b38:	8b 45 08             	mov    0x8(%ebp),%eax
    3b3b:	8b 00                	mov    (%eax),%eax
    3b3d:	8b 40 04             	mov    0x4(%eax),%eax
    3b40:	83 e8 01             	sub    $0x1,%eax
    3b43:	01 d0                	add    %edx,%eax
    3b45:	c6 00 00             	movb   $0x0,(%eax)
    3b48:	8b 45 08             	mov    0x8(%ebp),%eax
    3b4b:	8b 00                	mov    (%eax),%eax
    3b4d:	8b 10                	mov    (%eax),%edx
    3b4f:	8b 45 08             	mov    0x8(%ebp),%eax
    3b52:	8b 00                	mov    (%eax),%eax
    3b54:	8b 40 04             	mov    0x4(%eax),%eax
    3b57:	83 e8 01             	sub    $0x1,%eax
    3b5a:	01 c2                	add    %eax,%edx
    3b5c:	8b 45 08             	mov    0x8(%ebp),%eax
    3b5f:	8b 00                	mov    (%eax),%eax
    3b61:	8b 08                	mov    (%eax),%ecx
    3b63:	8b 45 08             	mov    0x8(%ebp),%eax
    3b66:	8b 00                	mov    (%eax),%eax
    3b68:	8b 40 04             	mov    0x4(%eax),%eax
    3b6b:	83 e8 01             	sub    $0x1,%eax
    3b6e:	01 c8                	add    %ecx,%eax
    3b70:	0f b6 00             	movzbl (%eax),%eax
    3b73:	89 c6                	mov    %eax,%esi
    3b75:	8b 4d 10             	mov    0x10(%ebp),%ecx
    3b78:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3b7b:	29 c1                	sub    %eax,%ecx
    3b7d:	89 c8                	mov    %ecx,%eax
    3b7f:	83 e8 01             	sub    $0x1,%eax
    3b82:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3b85:	89 c1                	mov    %eax,%ecx
    3b87:	d3 eb                	shr    %cl,%ebx
    3b89:	89 d8                	mov    %ebx,%eax
    3b8b:	83 e0 01             	and    $0x1,%eax
    3b8e:	89 c3                	mov    %eax,%ebx
    3b90:	8b 45 08             	mov    0x8(%ebp),%eax
    3b93:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3b97:	0f b6 c0             	movzbl %al,%eax
    3b9a:	83 e0 07             	and    $0x7,%eax
    3b9d:	89 c1                	mov    %eax,%ecx
    3b9f:	d3 e3                	shl    %cl,%ebx
    3ba1:	89 d8                	mov    %ebx,%eax
    3ba3:	09 f0                	or     %esi,%eax
    3ba5:	88 02                	mov    %al,(%edx)
    3ba7:	8b 45 08             	mov    0x8(%ebp),%eax
    3baa:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3bae:	8d 50 01             	lea    0x1(%eax),%edx
    3bb1:	8b 45 08             	mov    0x8(%ebp),%eax
    3bb4:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3bb7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3bbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3bbe:	3b 45 10             	cmp    0x10(%ebp),%eax
    3bc1:	0f 85 37 ff ff ff    	jne    3afe <writeBitsReversed+0x14>
    3bc7:	eb 01                	jmp    3bca <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3bc9:	90                   	nop
  }
}
    3bca:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3bcd:	5b                   	pop    %ebx
    3bce:	5e                   	pop    %esi
    3bcf:	5d                   	pop    %ebp
    3bd0:	c3                   	ret    

00003bd1 <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    3bd1:	55                   	push   %ebp
    3bd2:	89 e5                	mov    %esp,%ebp
    3bd4:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    3bd7:	8b 45 08             	mov    0x8(%ebp),%eax
    3bda:	8b 55 0c             	mov    0xc(%ebp),%edx
    3bdd:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    3bdf:	8b 45 08             	mov    0x8(%ebp),%eax
    3be2:	8b 55 10             	mov    0x10(%ebp),%edx
    3be5:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    3be8:	8b 45 08             	mov    0x8(%ebp),%eax
    3beb:	83 c0 08             	add    $0x8,%eax
    3bee:	50                   	push   %eax
    3bef:	6a 08                	push   $0x8
    3bf1:	ff 75 10             	pushl  0x10(%ebp)
    3bf4:	e8 59 f9 ff ff       	call   3552 <lodepng_mulofl>
    3bf9:	83 c4 0c             	add    $0xc,%esp
    3bfc:	85 c0                	test   %eax,%eax
    3bfe:	74 07                	je     3c07 <LodePNGBitReader_init+0x36>
    3c00:	b8 69 00 00 00       	mov    $0x69,%eax
    3c05:	eb 39                	jmp    3c40 <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    3c07:	8b 45 08             	mov    0x8(%ebp),%eax
    3c0a:	8b 40 08             	mov    0x8(%eax),%eax
    3c0d:	8d 55 fc             	lea    -0x4(%ebp),%edx
    3c10:	52                   	push   %edx
    3c11:	6a 40                	push   $0x40
    3c13:	50                   	push   %eax
    3c14:	e8 19 f9 ff ff       	call   3532 <lodepng_addofl>
    3c19:	83 c4 0c             	add    $0xc,%esp
    3c1c:	85 c0                	test   %eax,%eax
    3c1e:	74 07                	je     3c27 <LodePNGBitReader_init+0x56>
    3c20:	b8 69 00 00 00       	mov    $0x69,%eax
    3c25:	eb 19                	jmp    3c40 <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    3c27:	8b 45 08             	mov    0x8(%ebp),%eax
    3c2a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    3c31:	8b 45 08             	mov    0x8(%ebp),%eax
    3c34:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    3c3b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3c40:	c9                   	leave  
    3c41:	c3                   	ret    

00003c42 <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    3c42:	55                   	push   %ebp
    3c43:	89 e5                	mov    %esp,%ebp
    3c45:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3c48:	8b 45 08             	mov    0x8(%ebp),%eax
    3c4b:	8b 40 0c             	mov    0xc(%eax),%eax
    3c4e:	c1 f8 03             	sar    $0x3,%eax
    3c51:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3c54:	8b 45 08             	mov    0x8(%ebp),%eax
    3c57:	8b 40 04             	mov    0x4(%eax),%eax
    3c5a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    3c5d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c60:	8d 50 01             	lea    0x1(%eax),%edx
    3c63:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3c66:	39 c2                	cmp    %eax,%edx
    3c68:	73 4e                	jae    3cb8 <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    3c6a:	8b 45 08             	mov    0x8(%ebp),%eax
    3c6d:	8b 10                	mov    (%eax),%edx
    3c6f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3c72:	01 d0                	add    %edx,%eax
    3c74:	0f b6 00             	movzbl (%eax),%eax
    3c77:	0f b6 d0             	movzbl %al,%edx
    3c7a:	8b 45 08             	mov    0x8(%ebp),%eax
    3c7d:	8b 00                	mov    (%eax),%eax
    3c7f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3c82:	83 c1 01             	add    $0x1,%ecx
    3c85:	01 c8                	add    %ecx,%eax
    3c87:	0f b6 00             	movzbl (%eax),%eax
    3c8a:	0f b6 c0             	movzbl %al,%eax
    3c8d:	c1 e0 08             	shl    $0x8,%eax
    3c90:	09 c2                	or     %eax,%edx
    3c92:	8b 45 08             	mov    0x8(%ebp),%eax
    3c95:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3c98:	8b 45 08             	mov    0x8(%ebp),%eax
    3c9b:	8b 50 10             	mov    0x10(%eax),%edx
    3c9e:	8b 45 08             	mov    0x8(%ebp),%eax
    3ca1:	8b 40 0c             	mov    0xc(%eax),%eax
    3ca4:	83 e0 07             	and    $0x7,%eax
    3ca7:	89 c1                	mov    %eax,%ecx
    3ca9:	d3 ea                	shr    %cl,%edx
    3cab:	8b 45 08             	mov    0x8(%ebp),%eax
    3cae:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3cb1:	b8 01 00 00 00       	mov    $0x1,%eax
    3cb6:	eb 64                	jmp    3d1c <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    3cb8:	8b 45 08             	mov    0x8(%ebp),%eax
    3cbb:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3cc2:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3cc5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3cc8:	39 c2                	cmp    %eax,%edx
    3cca:	73 1e                	jae    3cea <ensureBits9+0xa8>
    3ccc:	8b 45 08             	mov    0x8(%ebp),%eax
    3ccf:	8b 50 10             	mov    0x10(%eax),%edx
    3cd2:	8b 45 08             	mov    0x8(%ebp),%eax
    3cd5:	8b 08                	mov    (%eax),%ecx
    3cd7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3cda:	01 c8                	add    %ecx,%eax
    3cdc:	0f b6 00             	movzbl (%eax),%eax
    3cdf:	0f b6 c0             	movzbl %al,%eax
    3ce2:	09 c2                	or     %eax,%edx
    3ce4:	8b 45 08             	mov    0x8(%ebp),%eax
    3ce7:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3cea:	8b 45 08             	mov    0x8(%ebp),%eax
    3ced:	8b 50 10             	mov    0x10(%eax),%edx
    3cf0:	8b 45 08             	mov    0x8(%ebp),%eax
    3cf3:	8b 40 0c             	mov    0xc(%eax),%eax
    3cf6:	83 e0 07             	and    $0x7,%eax
    3cf9:	89 c1                	mov    %eax,%ecx
    3cfb:	d3 ea                	shr    %cl,%edx
    3cfd:	8b 45 08             	mov    0x8(%ebp),%eax
    3d00:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3d03:	8b 45 08             	mov    0x8(%ebp),%eax
    3d06:	8b 50 0c             	mov    0xc(%eax),%edx
    3d09:	8b 45 0c             	mov    0xc(%ebp),%eax
    3d0c:	01 c2                	add    %eax,%edx
    3d0e:	8b 45 08             	mov    0x8(%ebp),%eax
    3d11:	8b 40 08             	mov    0x8(%eax),%eax
    3d14:	39 c2                	cmp    %eax,%edx
    3d16:	0f 9e c0             	setle  %al
    3d19:	0f b6 c0             	movzbl %al,%eax
  }
}
    3d1c:	c9                   	leave  
    3d1d:	c3                   	ret    

00003d1e <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    3d1e:	55                   	push   %ebp
    3d1f:	89 e5                	mov    %esp,%ebp
    3d21:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3d24:	8b 45 08             	mov    0x8(%ebp),%eax
    3d27:	8b 40 0c             	mov    0xc(%eax),%eax
    3d2a:	c1 f8 03             	sar    $0x3,%eax
    3d2d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3d30:	8b 45 08             	mov    0x8(%ebp),%eax
    3d33:	8b 40 04             	mov    0x4(%eax),%eax
    3d36:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    3d39:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d3c:	8d 50 02             	lea    0x2(%eax),%edx
    3d3f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3d42:	39 c2                	cmp    %eax,%edx
    3d44:	73 6d                	jae    3db3 <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d46:	8b 45 08             	mov    0x8(%ebp),%eax
    3d49:	8b 10                	mov    (%eax),%edx
    3d4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3d4e:	01 d0                	add    %edx,%eax
    3d50:	0f b6 00             	movzbl (%eax),%eax
    3d53:	0f b6 d0             	movzbl %al,%edx
    3d56:	8b 45 08             	mov    0x8(%ebp),%eax
    3d59:	8b 00                	mov    (%eax),%eax
    3d5b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3d5e:	83 c1 01             	add    $0x1,%ecx
    3d61:	01 c8                	add    %ecx,%eax
    3d63:	0f b6 00             	movzbl (%eax),%eax
    3d66:	0f b6 c0             	movzbl %al,%eax
    3d69:	c1 e0 08             	shl    $0x8,%eax
    3d6c:	89 d1                	mov    %edx,%ecx
    3d6e:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    3d70:	8b 45 08             	mov    0x8(%ebp),%eax
    3d73:	8b 00                	mov    (%eax),%eax
    3d75:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3d78:	83 c2 02             	add    $0x2,%edx
    3d7b:	01 d0                	add    %edx,%eax
    3d7d:	0f b6 00             	movzbl (%eax),%eax
    3d80:	0f b6 c0             	movzbl %al,%eax
    3d83:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3d86:	09 c1                	or     %eax,%ecx
    3d88:	89 ca                	mov    %ecx,%edx
    3d8a:	8b 45 08             	mov    0x8(%ebp),%eax
    3d8d:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    3d90:	8b 45 08             	mov    0x8(%ebp),%eax
    3d93:	8b 50 10             	mov    0x10(%eax),%edx
    3d96:	8b 45 08             	mov    0x8(%ebp),%eax
    3d99:	8b 40 0c             	mov    0xc(%eax),%eax
    3d9c:	83 e0 07             	and    $0x7,%eax
    3d9f:	89 c1                	mov    %eax,%ecx
    3da1:	d3 ea                	shr    %cl,%edx
    3da3:	8b 45 08             	mov    0x8(%ebp),%eax
    3da6:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3da9:	b8 01 00 00 00       	mov    $0x1,%eax
    3dae:	e9 95 00 00 00       	jmp    3e48 <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    3db3:	8b 45 08             	mov    0x8(%ebp),%eax
    3db6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3dbd:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3dc0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3dc3:	39 c2                	cmp    %eax,%edx
    3dc5:	73 1e                	jae    3de5 <ensureBits17+0xc7>
    3dc7:	8b 45 08             	mov    0x8(%ebp),%eax
    3dca:	8b 50 10             	mov    0x10(%eax),%edx
    3dcd:	8b 45 08             	mov    0x8(%ebp),%eax
    3dd0:	8b 08                	mov    (%eax),%ecx
    3dd2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3dd5:	01 c8                	add    %ecx,%eax
    3dd7:	0f b6 00             	movzbl (%eax),%eax
    3dda:	0f b6 c0             	movzbl %al,%eax
    3ddd:	09 c2                	or     %eax,%edx
    3ddf:	8b 45 08             	mov    0x8(%ebp),%eax
    3de2:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3de5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3de8:	8d 50 01             	lea    0x1(%eax),%edx
    3deb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3dee:	39 c2                	cmp    %eax,%edx
    3df0:	73 24                	jae    3e16 <ensureBits17+0xf8>
    3df2:	8b 45 08             	mov    0x8(%ebp),%eax
    3df5:	8b 50 10             	mov    0x10(%eax),%edx
    3df8:	8b 45 08             	mov    0x8(%ebp),%eax
    3dfb:	8b 00                	mov    (%eax),%eax
    3dfd:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3e00:	83 c1 01             	add    $0x1,%ecx
    3e03:	01 c8                	add    %ecx,%eax
    3e05:	0f b6 00             	movzbl (%eax),%eax
    3e08:	0f b6 c0             	movzbl %al,%eax
    3e0b:	c1 e0 08             	shl    $0x8,%eax
    3e0e:	09 c2                	or     %eax,%edx
    3e10:	8b 45 08             	mov    0x8(%ebp),%eax
    3e13:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3e16:	8b 45 08             	mov    0x8(%ebp),%eax
    3e19:	8b 50 10             	mov    0x10(%eax),%edx
    3e1c:	8b 45 08             	mov    0x8(%ebp),%eax
    3e1f:	8b 40 0c             	mov    0xc(%eax),%eax
    3e22:	83 e0 07             	and    $0x7,%eax
    3e25:	89 c1                	mov    %eax,%ecx
    3e27:	d3 ea                	shr    %cl,%edx
    3e29:	8b 45 08             	mov    0x8(%ebp),%eax
    3e2c:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3e2f:	8b 45 08             	mov    0x8(%ebp),%eax
    3e32:	8b 50 0c             	mov    0xc(%eax),%edx
    3e35:	8b 45 0c             	mov    0xc(%ebp),%eax
    3e38:	01 c2                	add    %eax,%edx
    3e3a:	8b 45 08             	mov    0x8(%ebp),%eax
    3e3d:	8b 40 08             	mov    0x8(%eax),%eax
    3e40:	39 c2                	cmp    %eax,%edx
    3e42:	0f 9e c0             	setle  %al
    3e45:	0f b6 c0             	movzbl %al,%eax
  }
}
    3e48:	c9                   	leave  
    3e49:	c3                   	ret    

00003e4a <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    3e4a:	55                   	push   %ebp
    3e4b:	89 e5                	mov    %esp,%ebp
    3e4d:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3e50:	8b 45 08             	mov    0x8(%ebp),%eax
    3e53:	8b 40 0c             	mov    0xc(%eax),%eax
    3e56:	c1 f8 03             	sar    $0x3,%eax
    3e59:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3e5c:	8b 45 08             	mov    0x8(%ebp),%eax
    3e5f:	8b 40 04             	mov    0x4(%eax),%eax
    3e62:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    3e65:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3e68:	8d 50 03             	lea    0x3(%eax),%edx
    3e6b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e6e:	39 c2                	cmp    %eax,%edx
    3e70:	0f 83 85 00 00 00    	jae    3efb <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3e76:	8b 45 08             	mov    0x8(%ebp),%eax
    3e79:	8b 10                	mov    (%eax),%edx
    3e7b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3e7e:	01 d0                	add    %edx,%eax
    3e80:	0f b6 00             	movzbl (%eax),%eax
    3e83:	0f b6 d0             	movzbl %al,%edx
    3e86:	8b 45 08             	mov    0x8(%ebp),%eax
    3e89:	8b 00                	mov    (%eax),%eax
    3e8b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3e8e:	83 c1 01             	add    $0x1,%ecx
    3e91:	01 c8                	add    %ecx,%eax
    3e93:	0f b6 00             	movzbl (%eax),%eax
    3e96:	0f b6 c0             	movzbl %al,%eax
    3e99:	c1 e0 08             	shl    $0x8,%eax
    3e9c:	89 d1                	mov    %edx,%ecx
    3e9e:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3ea0:	8b 45 08             	mov    0x8(%ebp),%eax
    3ea3:	8b 00                	mov    (%eax),%eax
    3ea5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3ea8:	83 c2 02             	add    $0x2,%edx
    3eab:	01 d0                	add    %edx,%eax
    3ead:	0f b6 00             	movzbl (%eax),%eax
    3eb0:	0f b6 c0             	movzbl %al,%eax
    3eb3:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3eb6:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    3eb8:	8b 45 08             	mov    0x8(%ebp),%eax
    3ebb:	8b 00                	mov    (%eax),%eax
    3ebd:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3ec0:	83 c2 03             	add    $0x3,%edx
    3ec3:	01 d0                	add    %edx,%eax
    3ec5:	0f b6 00             	movzbl (%eax),%eax
    3ec8:	0f b6 c0             	movzbl %al,%eax
    3ecb:	c1 e0 18             	shl    $0x18,%eax
    3ece:	09 c1                	or     %eax,%ecx
    3ed0:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3ed2:	8b 45 08             	mov    0x8(%ebp),%eax
    3ed5:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    3ed8:	8b 45 08             	mov    0x8(%ebp),%eax
    3edb:	8b 50 10             	mov    0x10(%eax),%edx
    3ede:	8b 45 08             	mov    0x8(%ebp),%eax
    3ee1:	8b 40 0c             	mov    0xc(%eax),%eax
    3ee4:	83 e0 07             	and    $0x7,%eax
    3ee7:	89 c1                	mov    %eax,%ecx
    3ee9:	d3 ea                	shr    %cl,%edx
    3eeb:	8b 45 08             	mov    0x8(%ebp),%eax
    3eee:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3ef1:	b8 01 00 00 00       	mov    $0x1,%eax
    3ef6:	e9 c6 00 00 00       	jmp    3fc1 <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    3efb:	8b 45 08             	mov    0x8(%ebp),%eax
    3efe:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3f05:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3f08:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f0b:	39 c2                	cmp    %eax,%edx
    3f0d:	73 1e                	jae    3f2d <ensureBits25+0xe3>
    3f0f:	8b 45 08             	mov    0x8(%ebp),%eax
    3f12:	8b 50 10             	mov    0x10(%eax),%edx
    3f15:	8b 45 08             	mov    0x8(%ebp),%eax
    3f18:	8b 08                	mov    (%eax),%ecx
    3f1a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3f1d:	01 c8                	add    %ecx,%eax
    3f1f:	0f b6 00             	movzbl (%eax),%eax
    3f22:	0f b6 c0             	movzbl %al,%eax
    3f25:	09 c2                	or     %eax,%edx
    3f27:	8b 45 08             	mov    0x8(%ebp),%eax
    3f2a:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3f2d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3f30:	8d 50 01             	lea    0x1(%eax),%edx
    3f33:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f36:	39 c2                	cmp    %eax,%edx
    3f38:	73 24                	jae    3f5e <ensureBits25+0x114>
    3f3a:	8b 45 08             	mov    0x8(%ebp),%eax
    3f3d:	8b 50 10             	mov    0x10(%eax),%edx
    3f40:	8b 45 08             	mov    0x8(%ebp),%eax
    3f43:	8b 00                	mov    (%eax),%eax
    3f45:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3f48:	83 c1 01             	add    $0x1,%ecx
    3f4b:	01 c8                	add    %ecx,%eax
    3f4d:	0f b6 00             	movzbl (%eax),%eax
    3f50:	0f b6 c0             	movzbl %al,%eax
    3f53:	c1 e0 08             	shl    $0x8,%eax
    3f56:	09 c2                	or     %eax,%edx
    3f58:	8b 45 08             	mov    0x8(%ebp),%eax
    3f5b:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    3f5e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3f61:	8d 50 02             	lea    0x2(%eax),%edx
    3f64:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f67:	39 c2                	cmp    %eax,%edx
    3f69:	73 24                	jae    3f8f <ensureBits25+0x145>
    3f6b:	8b 45 08             	mov    0x8(%ebp),%eax
    3f6e:	8b 50 10             	mov    0x10(%eax),%edx
    3f71:	8b 45 08             	mov    0x8(%ebp),%eax
    3f74:	8b 00                	mov    (%eax),%eax
    3f76:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3f79:	83 c1 02             	add    $0x2,%ecx
    3f7c:	01 c8                	add    %ecx,%eax
    3f7e:	0f b6 00             	movzbl (%eax),%eax
    3f81:	0f b6 c0             	movzbl %al,%eax
    3f84:	c1 e0 10             	shl    $0x10,%eax
    3f87:	09 c2                	or     %eax,%edx
    3f89:	8b 45 08             	mov    0x8(%ebp),%eax
    3f8c:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3f8f:	8b 45 08             	mov    0x8(%ebp),%eax
    3f92:	8b 50 10             	mov    0x10(%eax),%edx
    3f95:	8b 45 08             	mov    0x8(%ebp),%eax
    3f98:	8b 40 0c             	mov    0xc(%eax),%eax
    3f9b:	83 e0 07             	and    $0x7,%eax
    3f9e:	89 c1                	mov    %eax,%ecx
    3fa0:	d3 ea                	shr    %cl,%edx
    3fa2:	8b 45 08             	mov    0x8(%ebp),%eax
    3fa5:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3fa8:	8b 45 08             	mov    0x8(%ebp),%eax
    3fab:	8b 50 0c             	mov    0xc(%eax),%edx
    3fae:	8b 45 0c             	mov    0xc(%ebp),%eax
    3fb1:	01 c2                	add    %eax,%edx
    3fb3:	8b 45 08             	mov    0x8(%ebp),%eax
    3fb6:	8b 40 08             	mov    0x8(%eax),%eax
    3fb9:	39 c2                	cmp    %eax,%edx
    3fbb:	0f 9e c0             	setle  %al
    3fbe:	0f b6 c0             	movzbl %al,%eax
  }
}
    3fc1:	c9                   	leave  
    3fc2:	c3                   	ret    

00003fc3 <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    3fc3:	55                   	push   %ebp
    3fc4:	89 e5                	mov    %esp,%ebp
    3fc6:	53                   	push   %ebx
    3fc7:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3fca:	8b 45 08             	mov    0x8(%ebp),%eax
    3fcd:	8b 40 0c             	mov    0xc(%eax),%eax
    3fd0:	c1 f8 03             	sar    $0x3,%eax
    3fd3:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    3fd6:	8b 45 08             	mov    0x8(%ebp),%eax
    3fd9:	8b 40 04             	mov    0x4(%eax),%eax
    3fdc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    3fdf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3fe2:	8d 50 04             	lea    0x4(%eax),%edx
    3fe5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3fe8:	39 c2                	cmp    %eax,%edx
    3fea:	0f 83 c3 00 00 00    	jae    40b3 <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3ff0:	8b 45 08             	mov    0x8(%ebp),%eax
    3ff3:	8b 10                	mov    (%eax),%edx
    3ff5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ff8:	01 d0                	add    %edx,%eax
    3ffa:	0f b6 00             	movzbl (%eax),%eax
    3ffd:	0f b6 d0             	movzbl %al,%edx
    4000:	8b 45 08             	mov    0x8(%ebp),%eax
    4003:	8b 00                	mov    (%eax),%eax
    4005:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4008:	83 c1 01             	add    $0x1,%ecx
    400b:	01 c8                	add    %ecx,%eax
    400d:	0f b6 00             	movzbl (%eax),%eax
    4010:	0f b6 c0             	movzbl %al,%eax
    4013:	c1 e0 08             	shl    $0x8,%eax
    4016:	89 d1                	mov    %edx,%ecx
    4018:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    401a:	8b 45 08             	mov    0x8(%ebp),%eax
    401d:	8b 00                	mov    (%eax),%eax
    401f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4022:	83 c2 02             	add    $0x2,%edx
    4025:	01 d0                	add    %edx,%eax
    4027:	0f b6 00             	movzbl (%eax),%eax
    402a:	0f b6 c0             	movzbl %al,%eax
    402d:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4030:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4032:	8b 45 08             	mov    0x8(%ebp),%eax
    4035:	8b 00                	mov    (%eax),%eax
    4037:	8b 55 f8             	mov    -0x8(%ebp),%edx
    403a:	83 c2 03             	add    $0x3,%edx
    403d:	01 d0                	add    %edx,%eax
    403f:	0f b6 00             	movzbl (%eax),%eax
    4042:	0f b6 c0             	movzbl %al,%eax
    4045:	c1 e0 18             	shl    $0x18,%eax
    4048:	09 c1                	or     %eax,%ecx
    404a:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    404c:	8b 45 08             	mov    0x8(%ebp),%eax
    404f:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    4052:	8b 45 08             	mov    0x8(%ebp),%eax
    4055:	8b 50 10             	mov    0x10(%eax),%edx
    4058:	8b 45 08             	mov    0x8(%ebp),%eax
    405b:	8b 40 0c             	mov    0xc(%eax),%eax
    405e:	83 e0 07             	and    $0x7,%eax
    4061:	89 c1                	mov    %eax,%ecx
    4063:	d3 ea                	shr    %cl,%edx
    4065:	8b 45 08             	mov    0x8(%ebp),%eax
    4068:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    406b:	8b 45 08             	mov    0x8(%ebp),%eax
    406e:	8b 50 10             	mov    0x10(%eax),%edx
    4071:	8b 45 08             	mov    0x8(%ebp),%eax
    4074:	8b 00                	mov    (%eax),%eax
    4076:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4079:	83 c1 04             	add    $0x4,%ecx
    407c:	01 c8                	add    %ecx,%eax
    407e:	0f b6 00             	movzbl (%eax),%eax
    4081:	0f b6 c0             	movzbl %al,%eax
    4084:	c1 e0 18             	shl    $0x18,%eax
    4087:	89 c3                	mov    %eax,%ebx
    4089:	8b 45 08             	mov    0x8(%ebp),%eax
    408c:	8b 40 0c             	mov    0xc(%eax),%eax
    408f:	83 e0 07             	and    $0x7,%eax
    4092:	b9 08 00 00 00       	mov    $0x8,%ecx
    4097:	29 c1                	sub    %eax,%ecx
    4099:	89 c8                	mov    %ecx,%eax
    409b:	89 c1                	mov    %eax,%ecx
    409d:	d3 e3                	shl    %cl,%ebx
    409f:	89 d8                	mov    %ebx,%eax
    40a1:	09 c2                	or     %eax,%edx
    40a3:	8b 45 08             	mov    0x8(%ebp),%eax
    40a6:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    40a9:	b8 01 00 00 00       	mov    $0x1,%eax
    40ae:	e9 f7 00 00 00       	jmp    41aa <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    40b3:	8b 45 08             	mov    0x8(%ebp),%eax
    40b6:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    40bd:	8b 55 f8             	mov    -0x8(%ebp),%edx
    40c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    40c3:	39 c2                	cmp    %eax,%edx
    40c5:	73 1e                	jae    40e5 <ensureBits32+0x122>
    40c7:	8b 45 08             	mov    0x8(%ebp),%eax
    40ca:	8b 50 10             	mov    0x10(%eax),%edx
    40cd:	8b 45 08             	mov    0x8(%ebp),%eax
    40d0:	8b 08                	mov    (%eax),%ecx
    40d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    40d5:	01 c8                	add    %ecx,%eax
    40d7:	0f b6 00             	movzbl (%eax),%eax
    40da:	0f b6 c0             	movzbl %al,%eax
    40dd:	09 c2                	or     %eax,%edx
    40df:	8b 45 08             	mov    0x8(%ebp),%eax
    40e2:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    40e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    40e8:	8d 50 01             	lea    0x1(%eax),%edx
    40eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    40ee:	39 c2                	cmp    %eax,%edx
    40f0:	73 24                	jae    4116 <ensureBits32+0x153>
    40f2:	8b 45 08             	mov    0x8(%ebp),%eax
    40f5:	8b 50 10             	mov    0x10(%eax),%edx
    40f8:	8b 45 08             	mov    0x8(%ebp),%eax
    40fb:	8b 00                	mov    (%eax),%eax
    40fd:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4100:	83 c1 01             	add    $0x1,%ecx
    4103:	01 c8                	add    %ecx,%eax
    4105:	0f b6 00             	movzbl (%eax),%eax
    4108:	0f b6 c0             	movzbl %al,%eax
    410b:	c1 e0 08             	shl    $0x8,%eax
    410e:	09 c2                	or     %eax,%edx
    4110:	8b 45 08             	mov    0x8(%ebp),%eax
    4113:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    4116:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4119:	8d 50 02             	lea    0x2(%eax),%edx
    411c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    411f:	39 c2                	cmp    %eax,%edx
    4121:	73 24                	jae    4147 <ensureBits32+0x184>
    4123:	8b 45 08             	mov    0x8(%ebp),%eax
    4126:	8b 50 10             	mov    0x10(%eax),%edx
    4129:	8b 45 08             	mov    0x8(%ebp),%eax
    412c:	8b 00                	mov    (%eax),%eax
    412e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4131:	83 c1 02             	add    $0x2,%ecx
    4134:	01 c8                	add    %ecx,%eax
    4136:	0f b6 00             	movzbl (%eax),%eax
    4139:	0f b6 c0             	movzbl %al,%eax
    413c:	c1 e0 10             	shl    $0x10,%eax
    413f:	09 c2                	or     %eax,%edx
    4141:	8b 45 08             	mov    0x8(%ebp),%eax
    4144:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    4147:	8b 45 f8             	mov    -0x8(%ebp),%eax
    414a:	8d 50 03             	lea    0x3(%eax),%edx
    414d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4150:	39 c2                	cmp    %eax,%edx
    4152:	73 24                	jae    4178 <ensureBits32+0x1b5>
    4154:	8b 45 08             	mov    0x8(%ebp),%eax
    4157:	8b 50 10             	mov    0x10(%eax),%edx
    415a:	8b 45 08             	mov    0x8(%ebp),%eax
    415d:	8b 00                	mov    (%eax),%eax
    415f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4162:	83 c1 03             	add    $0x3,%ecx
    4165:	01 c8                	add    %ecx,%eax
    4167:	0f b6 00             	movzbl (%eax),%eax
    416a:	0f b6 c0             	movzbl %al,%eax
    416d:	c1 e0 18             	shl    $0x18,%eax
    4170:	09 c2                	or     %eax,%edx
    4172:	8b 45 08             	mov    0x8(%ebp),%eax
    4175:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4178:	8b 45 08             	mov    0x8(%ebp),%eax
    417b:	8b 50 10             	mov    0x10(%eax),%edx
    417e:	8b 45 08             	mov    0x8(%ebp),%eax
    4181:	8b 40 0c             	mov    0xc(%eax),%eax
    4184:	83 e0 07             	and    $0x7,%eax
    4187:	89 c1                	mov    %eax,%ecx
    4189:	d3 ea                	shr    %cl,%edx
    418b:	8b 45 08             	mov    0x8(%ebp),%eax
    418e:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4191:	8b 45 08             	mov    0x8(%ebp),%eax
    4194:	8b 50 0c             	mov    0xc(%eax),%edx
    4197:	8b 45 0c             	mov    0xc(%ebp),%eax
    419a:	01 c2                	add    %eax,%edx
    419c:	8b 45 08             	mov    0x8(%ebp),%eax
    419f:	8b 40 08             	mov    0x8(%eax),%eax
    41a2:	39 c2                	cmp    %eax,%edx
    41a4:	0f 9e c0             	setle  %al
    41a7:	0f b6 c0             	movzbl %al,%eax
  }
}
    41aa:	83 c4 10             	add    $0x10,%esp
    41ad:	5b                   	pop    %ebx
    41ae:	5d                   	pop    %ebp
    41af:	c3                   	ret    

000041b0 <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    41b0:	55                   	push   %ebp
    41b1:	89 e5                	mov    %esp,%ebp
    41b3:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    41b4:	8b 45 08             	mov    0x8(%ebp),%eax
    41b7:	8b 50 10             	mov    0x10(%eax),%edx
    41ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    41bd:	bb 01 00 00 00       	mov    $0x1,%ebx
    41c2:	89 c1                	mov    %eax,%ecx
    41c4:	d3 e3                	shl    %cl,%ebx
    41c6:	89 d8                	mov    %ebx,%eax
    41c8:	83 e8 01             	sub    $0x1,%eax
    41cb:	21 d0                	and    %edx,%eax
}
    41cd:	5b                   	pop    %ebx
    41ce:	5d                   	pop    %ebp
    41cf:	c3                   	ret    

000041d0 <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    41d0:	55                   	push   %ebp
    41d1:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    41d3:	8b 45 08             	mov    0x8(%ebp),%eax
    41d6:	8b 50 10             	mov    0x10(%eax),%edx
    41d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    41dc:	89 c1                	mov    %eax,%ecx
    41de:	d3 ea                	shr    %cl,%edx
    41e0:	8b 45 08             	mov    0x8(%ebp),%eax
    41e3:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    41e6:	8b 45 08             	mov    0x8(%ebp),%eax
    41e9:	8b 50 0c             	mov    0xc(%eax),%edx
    41ec:	8b 45 0c             	mov    0xc(%ebp),%eax
    41ef:	01 c2                	add    %eax,%edx
    41f1:	8b 45 08             	mov    0x8(%ebp),%eax
    41f4:	89 50 0c             	mov    %edx,0xc(%eax)
}
    41f7:	90                   	nop
    41f8:	5d                   	pop    %ebp
    41f9:	c3                   	ret    

000041fa <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    41fa:	55                   	push   %ebp
    41fb:	89 e5                	mov    %esp,%ebp
    41fd:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    4200:	ff 75 0c             	pushl  0xc(%ebp)
    4203:	ff 75 08             	pushl  0x8(%ebp)
    4206:	e8 a5 ff ff ff       	call   41b0 <peekBits>
    420b:	83 c4 08             	add    $0x8,%esp
    420e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    4211:	ff 75 0c             	pushl  0xc(%ebp)
    4214:	ff 75 08             	pushl  0x8(%ebp)
    4217:	e8 b4 ff ff ff       	call   41d0 <advanceBits>
    421c:	83 c4 08             	add    $0x8,%esp
  return result;
    421f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    4222:	c9                   	leave  
    4223:	c3                   	ret    

00004224 <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    4224:	55                   	push   %ebp
    4225:	89 e5                	mov    %esp,%ebp
    4227:	53                   	push   %ebx
    4228:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    422b:	ff 75 0c             	pushl  0xc(%ebp)
    422e:	ff 75 08             	pushl  0x8(%ebp)
    4231:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4234:	50                   	push   %eax
    4235:	e8 97 f9 ff ff       	call   3bd1 <LodePNGBitReader_init>
    423a:	83 c4 0c             	add    $0xc,%esp
    423d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    4240:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    4244:	74 0a                	je     4250 <lode_png_test_bitreader+0x2c>
    4246:	b8 00 00 00 00       	mov    $0x0,%eax
    424b:	e9 c3 00 00 00       	jmp    4313 <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    4250:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4257:	e9 a6 00 00 00       	jmp    4302 <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    425c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    425f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4266:	8b 45 14             	mov    0x14(%ebp),%eax
    4269:	01 d0                	add    %edx,%eax
    426b:	8b 00                	mov    (%eax),%eax
    426d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    4270:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    4274:	7e 14                	jle    428a <lode_png_test_bitreader+0x66>
    4276:	ff 75 ec             	pushl  -0x14(%ebp)
    4279:	8d 45 d8             	lea    -0x28(%ebp),%eax
    427c:	50                   	push   %eax
    427d:	e8 41 fd ff ff       	call   3fc3 <ensureBits32>
    4282:	83 c4 08             	add    $0x8,%esp
    4285:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4288:	eb 46                	jmp    42d0 <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    428a:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    428e:	7e 14                	jle    42a4 <lode_png_test_bitreader+0x80>
    4290:	ff 75 ec             	pushl  -0x14(%ebp)
    4293:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4296:	50                   	push   %eax
    4297:	e8 ae fb ff ff       	call   3e4a <ensureBits25>
    429c:	83 c4 08             	add    $0x8,%esp
    429f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    42a2:	eb 2c                	jmp    42d0 <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    42a4:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    42a8:	7e 14                	jle    42be <lode_png_test_bitreader+0x9a>
    42aa:	ff 75 ec             	pushl  -0x14(%ebp)
    42ad:	8d 45 d8             	lea    -0x28(%ebp),%eax
    42b0:	50                   	push   %eax
    42b1:	e8 68 fa ff ff       	call   3d1e <ensureBits17>
    42b6:	83 c4 08             	add    $0x8,%esp
    42b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    42bc:	eb 12                	jmp    42d0 <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    42be:	ff 75 ec             	pushl  -0x14(%ebp)
    42c1:	8d 45 d8             	lea    -0x28(%ebp),%eax
    42c4:	50                   	push   %eax
    42c5:	e8 78 f9 ff ff       	call   3c42 <ensureBits9>
    42ca:	83 c4 08             	add    $0x8,%esp
    42cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    42d0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    42d4:	75 07                	jne    42dd <lode_png_test_bitreader+0xb9>
    42d6:	b8 00 00 00 00       	mov    $0x0,%eax
    42db:	eb 36                	jmp    4313 <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    42dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    42e0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    42e7:	8b 45 18             	mov    0x18(%ebp),%eax
    42ea:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    42ed:	ff 75 ec             	pushl  -0x14(%ebp)
    42f0:	8d 45 d8             	lea    -0x28(%ebp),%eax
    42f3:	50                   	push   %eax
    42f4:	e8 01 ff ff ff       	call   41fa <readBits>
    42f9:	83 c4 08             	add    $0x8,%esp
    42fc:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    42fe:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4302:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4305:	3b 45 10             	cmp    0x10(%ebp),%eax
    4308:	0f 8c 4e ff ff ff    	jl     425c <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    430e:	b8 01 00 00 00       	mov    $0x1,%eax
}
    4313:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    4316:	c9                   	leave  
    4317:	c3                   	ret    

00004318 <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    4318:	55                   	push   %ebp
    4319:	89 e5                	mov    %esp,%ebp
    431b:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    431e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    4325:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    432c:	eb 27                	jmp    4355 <reverseBits+0x3d>
    432e:	8b 45 0c             	mov    0xc(%ebp),%eax
    4331:	2b 45 fc             	sub    -0x4(%ebp),%eax
    4334:	83 e8 01             	sub    $0x1,%eax
    4337:	8b 55 08             	mov    0x8(%ebp),%edx
    433a:	89 c1                	mov    %eax,%ecx
    433c:	d3 ea                	shr    %cl,%edx
    433e:	89 d0                	mov    %edx,%eax
    4340:	83 e0 01             	and    $0x1,%eax
    4343:	89 c2                	mov    %eax,%edx
    4345:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4348:	89 c1                	mov    %eax,%ecx
    434a:	d3 e2                	shl    %cl,%edx
    434c:	89 d0                	mov    %edx,%eax
    434e:	09 45 f8             	or     %eax,-0x8(%ebp)
    4351:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    4355:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4358:	3b 45 0c             	cmp    0xc(%ebp),%eax
    435b:	72 d1                	jb     432e <reverseBits+0x16>
  return result;
    435d:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    4360:	c9                   	leave  
    4361:	c3                   	ret    

00004362 <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    4362:	55                   	push   %ebp
    4363:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    4365:	8b 45 08             	mov    0x8(%ebp),%eax
    4368:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    436e:	8b 45 08             	mov    0x8(%ebp),%eax
    4371:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    4378:	8b 45 08             	mov    0x8(%ebp),%eax
    437b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    4382:	8b 45 08             	mov    0x8(%ebp),%eax
    4385:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    438c:	90                   	nop
    438d:	5d                   	pop    %ebp
    438e:	c3                   	ret    

0000438f <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    438f:	55                   	push   %ebp
    4390:	89 e5                	mov    %esp,%ebp
    4392:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    4395:	8b 45 08             	mov    0x8(%ebp),%eax
    4398:	8b 00                	mov    (%eax),%eax
    439a:	83 ec 0c             	sub    $0xc,%esp
    439d:	50                   	push   %eax
    439e:	e8 ec f0 ff ff       	call   348f <lodepng_free>
    43a3:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    43a6:	8b 45 08             	mov    0x8(%ebp),%eax
    43a9:	8b 40 04             	mov    0x4(%eax),%eax
    43ac:	83 ec 0c             	sub    $0xc,%esp
    43af:	50                   	push   %eax
    43b0:	e8 da f0 ff ff       	call   348f <lodepng_free>
    43b5:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    43b8:	8b 45 08             	mov    0x8(%ebp),%eax
    43bb:	8b 40 10             	mov    0x10(%eax),%eax
    43be:	83 ec 0c             	sub    $0xc,%esp
    43c1:	50                   	push   %eax
    43c2:	e8 c8 f0 ff ff       	call   348f <lodepng_free>
    43c7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    43ca:	8b 45 08             	mov    0x8(%ebp),%eax
    43cd:	8b 40 14             	mov    0x14(%eax),%eax
    43d0:	83 ec 0c             	sub    $0xc,%esp
    43d3:	50                   	push   %eax
    43d4:	e8 b6 f0 ff ff       	call   348f <lodepng_free>
    43d9:	83 c4 10             	add    $0x10,%esp
}
    43dc:	90                   	nop
    43dd:	c9                   	leave  
    43de:	c3                   	ret    

000043df <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    43df:	55                   	push   %ebp
    43e0:	89 e5                	mov    %esp,%ebp
    43e2:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    43e5:	a1 08 b7 01 00       	mov    0x1b708,%eax
    43ea:	c1 e0 02             	shl    $0x2,%eax
    43ed:	83 ec 0c             	sub    $0xc,%esp
    43f0:	50                   	push   %eax
    43f1:	e8 78 f0 ff ff       	call   346e <lodepng_malloc>
    43f6:	83 c4 10             	add    $0x10,%esp
    43f9:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    43fc:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    4400:	75 0a                	jne    440c <HuffmanTree_makeTable+0x2d>
    4402:	b8 53 00 00 00       	mov    $0x53,%eax
    4407:	e9 61 04 00 00       	jmp    486d <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    440c:	a1 08 b7 01 00       	mov    0x1b708,%eax
    4411:	c1 e0 02             	shl    $0x2,%eax
    4414:	83 ec 04             	sub    $0x4,%esp
    4417:	50                   	push   %eax
    4418:	6a 00                	push   $0x0
    441a:	ff 75 dc             	pushl  -0x24(%ebp)
    441d:	e8 bd f0 ff ff       	call   34df <lodepng_memset>
    4422:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    4425:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    442c:	eb 7d                	jmp    44ab <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    442e:	8b 45 08             	mov    0x8(%ebp),%eax
    4431:	8b 00                	mov    (%eax),%eax
    4433:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4436:	c1 e2 02             	shl    $0x2,%edx
    4439:	01 d0                	add    %edx,%eax
    443b:	8b 00                	mov    (%eax),%eax
    443d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    4440:	8b 45 08             	mov    0x8(%ebp),%eax
    4443:	8b 40 04             	mov    0x4(%eax),%eax
    4446:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4449:	c1 e2 02             	shl    $0x2,%edx
    444c:	01 d0                	add    %edx,%eax
    444e:	8b 00                	mov    (%eax),%eax
    4450:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    4453:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    4457:	76 4d                	jbe    44a6 <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    4459:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    445c:	83 e8 09             	sub    $0x9,%eax
    445f:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4462:	89 c1                	mov    %eax,%ecx
    4464:	d3 ea                	shr    %cl,%edx
    4466:	89 d0                	mov    %edx,%eax
    4468:	83 ec 08             	sub    $0x8,%esp
    446b:	6a 09                	push   $0x9
    446d:	50                   	push   %eax
    446e:	e8 a5 fe ff ff       	call   4318 <reverseBits>
    4473:	83 c4 10             	add    $0x10,%esp
    4476:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    4479:	8b 45 d0             	mov    -0x30(%ebp),%eax
    447c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4483:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4486:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    4489:	8b 45 d0             	mov    -0x30(%ebp),%eax
    448c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4493:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4496:	01 d0                	add    %edx,%eax
    4498:	8b 10                	mov    (%eax),%edx
    449a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    449d:	39 c2                	cmp    %eax,%edx
    449f:	0f 43 c2             	cmovae %edx,%eax
    44a2:	89 01                	mov    %eax,(%ecx)
    44a4:	eb 01                	jmp    44a7 <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    44a6:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    44a7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    44ab:	8b 45 08             	mov    0x8(%ebp),%eax
    44ae:	8b 50 0c             	mov    0xc(%eax),%edx
    44b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    44b4:	39 c2                	cmp    %eax,%edx
    44b6:	0f 87 72 ff ff ff    	ja     442e <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    44bc:	a1 08 b7 01 00       	mov    0x1b708,%eax
    44c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    44c4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    44cb:	eb 35                	jmp    4502 <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    44cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    44d0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    44d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    44da:	01 d0                	add    %edx,%eax
    44dc:	8b 00                	mov    (%eax),%eax
    44de:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    44e1:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    44e5:	76 17                	jbe    44fe <HuffmanTree_makeTable+0x11f>
    44e7:	8b 45 cc             	mov    -0x34(%ebp),%eax
    44ea:	83 e8 09             	sub    $0x9,%eax
    44ed:	ba 01 00 00 00       	mov    $0x1,%edx
    44f2:	89 c1                	mov    %eax,%ecx
    44f4:	d3 e2                	shl    %cl,%edx
    44f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    44f9:	01 d0                	add    %edx,%eax
    44fb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    44fe:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4502:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4505:	a1 08 b7 01 00       	mov    0x1b708,%eax
    450a:	39 c2                	cmp    %eax,%edx
    450c:	72 bf                	jb     44cd <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    450e:	83 ec 0c             	sub    $0xc,%esp
    4511:	ff 75 e8             	pushl  -0x18(%ebp)
    4514:	e8 55 ef ff ff       	call   346e <lodepng_malloc>
    4519:	83 c4 10             	add    $0x10,%esp
    451c:	89 c2                	mov    %eax,%edx
    451e:	8b 45 08             	mov    0x8(%ebp),%eax
    4521:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    4524:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4527:	01 c0                	add    %eax,%eax
    4529:	83 ec 0c             	sub    $0xc,%esp
    452c:	50                   	push   %eax
    452d:	e8 3c ef ff ff       	call   346e <lodepng_malloc>
    4532:	83 c4 10             	add    $0x10,%esp
    4535:	89 c2                	mov    %eax,%edx
    4537:	8b 45 08             	mov    0x8(%ebp),%eax
    453a:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    453d:	8b 45 08             	mov    0x8(%ebp),%eax
    4540:	8b 40 10             	mov    0x10(%eax),%eax
    4543:	85 c0                	test   %eax,%eax
    4545:	74 0a                	je     4551 <HuffmanTree_makeTable+0x172>
    4547:	8b 45 08             	mov    0x8(%ebp),%eax
    454a:	8b 40 14             	mov    0x14(%eax),%eax
    454d:	85 c0                	test   %eax,%eax
    454f:	75 18                	jne    4569 <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    4551:	83 ec 0c             	sub    $0xc,%esp
    4554:	ff 75 dc             	pushl  -0x24(%ebp)
    4557:	e8 33 ef ff ff       	call   348f <lodepng_free>
    455c:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    455f:	b8 53 00 00 00       	mov    $0x53,%eax
    4564:	e9 04 03 00 00       	jmp    486d <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    4569:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4570:	eb 12                	jmp    4584 <HuffmanTree_makeTable+0x1a5>
    4572:	8b 45 08             	mov    0x8(%ebp),%eax
    4575:	8b 50 10             	mov    0x10(%eax),%edx
    4578:	8b 45 f4             	mov    -0xc(%ebp),%eax
    457b:	01 d0                	add    %edx,%eax
    457d:	c6 00 10             	movb   $0x10,(%eax)
    4580:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4584:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4587:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    458a:	7c e6                	jl     4572 <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    458c:	a1 08 b7 01 00       	mov    0x1b708,%eax
    4591:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    4594:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    459b:	eb 5b                	jmp    45f8 <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    459d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    45a0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    45a7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    45aa:	01 d0                	add    %edx,%eax
    45ac:	8b 00                	mov    (%eax),%eax
    45ae:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    45b1:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    45b5:	76 3c                	jbe    45f3 <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    45b7:	8b 45 08             	mov    0x8(%ebp),%eax
    45ba:	8b 50 10             	mov    0x10(%eax),%edx
    45bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    45c0:	01 d0                	add    %edx,%eax
    45c2:	8b 55 c8             	mov    -0x38(%ebp),%edx
    45c5:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    45c7:	8b 45 08             	mov    0x8(%ebp),%eax
    45ca:	8b 40 14             	mov    0x14(%eax),%eax
    45cd:	8b 55 f4             	mov    -0xc(%ebp),%edx
    45d0:	01 d2                	add    %edx,%edx
    45d2:	01 d0                	add    %edx,%eax
    45d4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    45d7:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    45da:	8b 45 c8             	mov    -0x38(%ebp),%eax
    45dd:	83 e8 09             	sub    $0x9,%eax
    45e0:	ba 01 00 00 00       	mov    $0x1,%edx
    45e5:	89 c1                	mov    %eax,%ecx
    45e7:	d3 e2                	shl    %cl,%edx
    45e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    45ec:	01 d0                	add    %edx,%eax
    45ee:	89 45 ec             	mov    %eax,-0x14(%ebp)
    45f1:	eb 01                	jmp    45f4 <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    45f3:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    45f4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    45f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    45fb:	a1 08 b7 01 00       	mov    0x1b708,%eax
    4600:	39 c2                	cmp    %eax,%edx
    4602:	72 99                	jb     459d <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    4604:	83 ec 0c             	sub    $0xc,%esp
    4607:	ff 75 dc             	pushl  -0x24(%ebp)
    460a:	e8 80 ee ff ff       	call   348f <lodepng_free>
    460f:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    4612:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    4619:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4620:	e9 9d 01 00 00       	jmp    47c2 <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    4625:	8b 45 08             	mov    0x8(%ebp),%eax
    4628:	8b 40 04             	mov    0x4(%eax),%eax
    462b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    462e:	c1 e2 02             	shl    $0x2,%edx
    4631:	01 d0                	add    %edx,%eax
    4633:	8b 00                	mov    (%eax),%eax
    4635:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    4638:	8b 45 08             	mov    0x8(%ebp),%eax
    463b:	8b 00                	mov    (%eax),%eax
    463d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4640:	c1 e2 02             	shl    $0x2,%edx
    4643:	01 d0                	add    %edx,%eax
    4645:	8b 00                	mov    (%eax),%eax
    4647:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    464a:	83 ec 08             	sub    $0x8,%esp
    464d:	ff 75 c4             	pushl  -0x3c(%ebp)
    4650:	ff 75 c0             	pushl  -0x40(%ebp)
    4653:	e8 c0 fc ff ff       	call   4318 <reverseBits>
    4658:	83 c4 10             	add    $0x10,%esp
    465b:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    465e:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    4662:	0f 84 55 01 00 00    	je     47bd <HuffmanTree_makeTable+0x3de>
    numpresent++;
    4668:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    466c:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    4670:	0f 87 81 00 00 00    	ja     46f7 <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    4676:	b8 09 00 00 00       	mov    $0x9,%eax
    467b:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    467e:	ba 01 00 00 00       	mov    $0x1,%edx
    4683:	89 c1                	mov    %eax,%ecx
    4685:	d3 e2                	shl    %cl,%edx
    4687:	89 d0                	mov    %edx,%eax
    4689:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    468c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    4693:	eb 55                	jmp    46ea <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    4695:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4698:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    469b:	89 c1                	mov    %eax,%ecx
    469d:	d3 e2                	shl    %cl,%edx
    469f:	89 d0                	mov    %edx,%eax
    46a1:	0b 45 bc             	or     -0x44(%ebp),%eax
    46a4:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    46a7:	8b 45 08             	mov    0x8(%ebp),%eax
    46aa:	8b 50 10             	mov    0x10(%eax),%edx
    46ad:	8b 45 98             	mov    -0x68(%ebp),%eax
    46b0:	01 d0                	add    %edx,%eax
    46b2:	0f b6 00             	movzbl (%eax),%eax
    46b5:	3c 10                	cmp    $0x10,%al
    46b7:	74 0a                	je     46c3 <HuffmanTree_makeTable+0x2e4>
    46b9:	b8 37 00 00 00       	mov    $0x37,%eax
    46be:	e9 aa 01 00 00       	jmp    486d <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    46c3:	8b 45 08             	mov    0x8(%ebp),%eax
    46c6:	8b 50 10             	mov    0x10(%eax),%edx
    46c9:	8b 45 98             	mov    -0x68(%ebp),%eax
    46cc:	01 d0                	add    %edx,%eax
    46ce:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    46d1:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    46d3:	8b 45 08             	mov    0x8(%ebp),%eax
    46d6:	8b 40 14             	mov    0x14(%eax),%eax
    46d9:	8b 55 98             	mov    -0x68(%ebp),%edx
    46dc:	01 d2                	add    %edx,%edx
    46de:	01 d0                	add    %edx,%eax
    46e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    46e3:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    46e6:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    46ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    46ed:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    46f0:	72 a3                	jb     4695 <HuffmanTree_makeTable+0x2b6>
    46f2:	e9 c7 00 00 00       	jmp    47be <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    46f7:	a1 0c b7 01 00       	mov    0x1b70c,%eax
    46fc:	23 45 bc             	and    -0x44(%ebp),%eax
    46ff:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    4702:	8b 45 08             	mov    0x8(%ebp),%eax
    4705:	8b 50 10             	mov    0x10(%eax),%edx
    4708:	8b 45 b8             	mov    -0x48(%ebp),%eax
    470b:	01 d0                	add    %edx,%eax
    470d:	0f b6 00             	movzbl (%eax),%eax
    4710:	0f b6 c0             	movzbl %al,%eax
    4713:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    4716:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    4719:	83 e8 09             	sub    $0x9,%eax
    471c:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    471f:	8b 45 08             	mov    0x8(%ebp),%eax
    4722:	8b 40 14             	mov    0x14(%eax),%eax
    4725:	8b 55 b8             	mov    -0x48(%ebp),%edx
    4728:	01 d2                	add    %edx,%edx
    472a:	01 d0                	add    %edx,%eax
    472c:	0f b7 00             	movzwl (%eax),%eax
    472f:	0f b7 c0             	movzwl %ax,%eax
    4732:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    4735:	8b 45 b0             	mov    -0x50(%ebp),%eax
    4738:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    473b:	83 c0 09             	add    $0x9,%eax
    473e:	ba 01 00 00 00       	mov    $0x1,%edx
    4743:	89 c1                	mov    %eax,%ecx
    4745:	d3 e2                	shl    %cl,%edx
    4747:	89 d0                	mov    %edx,%eax
    4749:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    474c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    474f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    4752:	73 0a                	jae    475e <HuffmanTree_makeTable+0x37f>
    4754:	b8 37 00 00 00       	mov    $0x37,%eax
    4759:	e9 0f 01 00 00       	jmp    486d <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    475e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    4765:	eb 4c                	jmp    47b3 <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    4767:	8b 45 bc             	mov    -0x44(%ebp),%eax
    476a:	c1 e8 09             	shr    $0x9,%eax
    476d:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    4770:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4773:	83 e8 09             	sub    $0x9,%eax
    4776:	8b 55 e0             	mov    -0x20(%ebp),%edx
    4779:	89 c1                	mov    %eax,%ecx
    477b:	d3 e2                	shl    %cl,%edx
    477d:	89 d0                	mov    %edx,%eax
    477f:	0b 45 a4             	or     -0x5c(%ebp),%eax
    4782:	89 c2                	mov    %eax,%edx
    4784:	8b 45 ac             	mov    -0x54(%ebp),%eax
    4787:	01 d0                	add    %edx,%eax
    4789:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    478c:	8b 45 08             	mov    0x8(%ebp),%eax
    478f:	8b 50 10             	mov    0x10(%eax),%edx
    4792:	8b 45 a0             	mov    -0x60(%ebp),%eax
    4795:	01 d0                	add    %edx,%eax
    4797:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    479a:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    479c:	8b 45 08             	mov    0x8(%ebp),%eax
    479f:	8b 40 14             	mov    0x14(%eax),%eax
    47a2:	8b 55 a0             	mov    -0x60(%ebp),%edx
    47a5:	01 d2                	add    %edx,%edx
    47a7:	01 d0                	add    %edx,%eax
    47a9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    47ac:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    47af:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    47b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    47b6:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    47b9:	72 ac                	jb     4767 <HuffmanTree_makeTable+0x388>
    47bb:	eb 01                	jmp    47be <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    47bd:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    47be:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    47c2:	8b 45 08             	mov    0x8(%ebp),%eax
    47c5:	8b 50 0c             	mov    0xc(%eax),%edx
    47c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    47cb:	39 c2                	cmp    %eax,%edx
    47cd:	0f 87 52 fe ff ff    	ja     4625 <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    47d3:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    47d7:	7f 61                	jg     483a <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    47d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    47e0:	eb 4e                	jmp    4830 <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    47e2:	8b 45 08             	mov    0x8(%ebp),%eax
    47e5:	8b 50 10             	mov    0x10(%eax),%edx
    47e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    47eb:	01 d0                	add    %edx,%eax
    47ed:	0f b6 00             	movzbl (%eax),%eax
    47f0:	3c 10                	cmp    $0x10,%al
    47f2:	75 38                	jne    482c <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    47f4:	8b 45 08             	mov    0x8(%ebp),%eax
    47f7:	8b 50 10             	mov    0x10(%eax),%edx
    47fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    47fd:	01 d0                	add    %edx,%eax
    47ff:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    4802:	8b 15 08 b7 01 00    	mov    0x1b708,%edx
    4808:	39 d1                	cmp    %edx,%ecx
    480a:	73 07                	jae    4813 <HuffmanTree_makeTable+0x434>
    480c:	ba 01 00 00 00       	mov    $0x1,%edx
    4811:	eb 05                	jmp    4818 <HuffmanTree_makeTable+0x439>
    4813:	ba 0a 00 00 00       	mov    $0xa,%edx
    4818:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    481a:	8b 45 08             	mov    0x8(%ebp),%eax
    481d:	8b 40 14             	mov    0x14(%eax),%eax
    4820:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4823:	01 d2                	add    %edx,%edx
    4825:	01 d0                	add    %edx,%eax
    4827:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    482c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4830:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4833:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4836:	7c aa                	jl     47e2 <HuffmanTree_makeTable+0x403>
    4838:	eb 2e                	jmp    4868 <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    483a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4841:	eb 1d                	jmp    4860 <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    4843:	8b 45 08             	mov    0x8(%ebp),%eax
    4846:	8b 50 10             	mov    0x10(%eax),%edx
    4849:	8b 45 f4             	mov    -0xc(%ebp),%eax
    484c:	01 d0                	add    %edx,%eax
    484e:	0f b6 00             	movzbl (%eax),%eax
    4851:	3c 10                	cmp    $0x10,%al
    4853:	75 07                	jne    485c <HuffmanTree_makeTable+0x47d>
    4855:	b8 37 00 00 00       	mov    $0x37,%eax
    485a:	eb 11                	jmp    486d <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    485c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4860:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4863:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4866:	7c db                	jl     4843 <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    4868:	b8 00 00 00 00       	mov    $0x0,%eax
}
    486d:	c9                   	leave  
    486e:	c3                   	ret    

0000486f <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    486f:	55                   	push   %ebp
    4870:	89 e5                	mov    %esp,%ebp
    4872:	56                   	push   %esi
    4873:	53                   	push   %ebx
    4874:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    4877:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    487e:	8b 45 08             	mov    0x8(%ebp),%eax
    4881:	8b 40 0c             	mov    0xc(%eax),%eax
    4884:	c1 e0 02             	shl    $0x2,%eax
    4887:	83 ec 0c             	sub    $0xc,%esp
    488a:	50                   	push   %eax
    488b:	e8 de eb ff ff       	call   346e <lodepng_malloc>
    4890:	83 c4 10             	add    $0x10,%esp
    4893:	89 c2                	mov    %eax,%edx
    4895:	8b 45 08             	mov    0x8(%ebp),%eax
    4898:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    489a:	8b 45 08             	mov    0x8(%ebp),%eax
    489d:	8b 40 08             	mov    0x8(%eax),%eax
    48a0:	83 c0 01             	add    $0x1,%eax
    48a3:	c1 e0 02             	shl    $0x2,%eax
    48a6:	83 ec 0c             	sub    $0xc,%esp
    48a9:	50                   	push   %eax
    48aa:	e8 bf eb ff ff       	call   346e <lodepng_malloc>
    48af:	83 c4 10             	add    $0x10,%esp
    48b2:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    48b5:	8b 45 08             	mov    0x8(%ebp),%eax
    48b8:	8b 40 08             	mov    0x8(%eax),%eax
    48bb:	83 c0 01             	add    $0x1,%eax
    48be:	c1 e0 02             	shl    $0x2,%eax
    48c1:	83 ec 0c             	sub    $0xc,%esp
    48c4:	50                   	push   %eax
    48c5:	e8 a4 eb ff ff       	call   346e <lodepng_malloc>
    48ca:	83 c4 10             	add    $0x10,%esp
    48cd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    48d0:	8b 45 08             	mov    0x8(%ebp),%eax
    48d3:	8b 00                	mov    (%eax),%eax
    48d5:	85 c0                	test   %eax,%eax
    48d7:	74 0c                	je     48e5 <HuffmanTree_makeFromLengths2+0x76>
    48d9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    48dd:	74 06                	je     48e5 <HuffmanTree_makeFromLengths2+0x76>
    48df:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    48e3:	75 07                	jne    48ec <HuffmanTree_makeFromLengths2+0x7d>
    48e5:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    48ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    48f0:	0f 85 7d 01 00 00    	jne    4a73 <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    48f6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    48fd:	eb 2c                	jmp    492b <HuffmanTree_makeFromLengths2+0xbc>
    48ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4902:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4909:	8b 45 e8             	mov    -0x18(%ebp),%eax
    490c:	01 c2                	add    %eax,%edx
    490e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4911:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4918:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    491b:	01 c8                	add    %ecx,%eax
    491d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    4923:	8b 00                	mov    (%eax),%eax
    4925:	89 02                	mov    %eax,(%edx)
    4927:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    492b:	8b 45 08             	mov    0x8(%ebp),%eax
    492e:	8b 40 08             	mov    0x8(%eax),%eax
    4931:	83 c0 01             	add    $0x1,%eax
    4934:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4937:	75 c6                	jne    48ff <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    4939:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4940:	eb 27                	jmp    4969 <HuffmanTree_makeFromLengths2+0xfa>
    4942:	8b 45 08             	mov    0x8(%ebp),%eax
    4945:	8b 40 04             	mov    0x4(%eax),%eax
    4948:	8b 55 f0             	mov    -0x10(%ebp),%edx
    494b:	c1 e2 02             	shl    $0x2,%edx
    494e:	01 d0                	add    %edx,%eax
    4950:	8b 00                	mov    (%eax),%eax
    4952:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4959:	8b 45 e8             	mov    -0x18(%ebp),%eax
    495c:	01 d0                	add    %edx,%eax
    495e:	8b 10                	mov    (%eax),%edx
    4960:	83 c2 01             	add    $0x1,%edx
    4963:	89 10                	mov    %edx,(%eax)
    4965:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4969:	8b 45 08             	mov    0x8(%ebp),%eax
    496c:	8b 40 0c             	mov    0xc(%eax),%eax
    496f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4972:	75 ce                	jne    4942 <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4974:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    497b:	eb 47                	jmp    49c4 <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    497d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4980:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4987:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    498a:	01 d0                	add    %edx,%eax
    498c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    498f:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4995:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    499c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    499f:	01 ca                	add    %ecx,%edx
    49a1:	8b 0a                	mov    (%edx),%ecx
    49a3:	8b 55 f0             	mov    -0x10(%ebp),%edx
    49a6:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    49ac:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    49b3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    49b6:	01 da                	add    %ebx,%edx
    49b8:	8b 12                	mov    (%edx),%edx
    49ba:	01 ca                	add    %ecx,%edx
    49bc:	01 d2                	add    %edx,%edx
    49be:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    49c0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    49c4:	8b 45 08             	mov    0x8(%ebp),%eax
    49c7:	8b 40 08             	mov    0x8(%eax),%eax
    49ca:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    49cd:	73 ae                	jae    497d <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    49cf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    49d6:	e9 89 00 00 00       	jmp    4a64 <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    49db:	8b 45 08             	mov    0x8(%ebp),%eax
    49de:	8b 40 04             	mov    0x4(%eax),%eax
    49e1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    49e4:	c1 e2 02             	shl    $0x2,%edx
    49e7:	01 d0                	add    %edx,%eax
    49e9:	8b 00                	mov    (%eax),%eax
    49eb:	85 c0                	test   %eax,%eax
    49ed:	74 71                	je     4a60 <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    49ef:	8b 45 08             	mov    0x8(%ebp),%eax
    49f2:	8b 00                	mov    (%eax),%eax
    49f4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    49f7:	c1 e2 02             	shl    $0x2,%edx
    49fa:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    49fd:	8b 45 08             	mov    0x8(%ebp),%eax
    4a00:	8b 40 04             	mov    0x4(%eax),%eax
    4a03:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4a06:	c1 e2 02             	shl    $0x2,%edx
    4a09:	01 d0                	add    %edx,%eax
    4a0b:	8b 00                	mov    (%eax),%eax
    4a0d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4a14:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4a17:	01 c2                	add    %eax,%edx
    4a19:	8b 02                	mov    (%edx),%eax
    4a1b:	8d 48 01             	lea    0x1(%eax),%ecx
    4a1e:	89 0a                	mov    %ecx,(%edx)
    4a20:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    4a22:	8b 45 08             	mov    0x8(%ebp),%eax
    4a25:	8b 00                	mov    (%eax),%eax
    4a27:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4a2a:	c1 e2 02             	shl    $0x2,%edx
    4a2d:	01 c2                	add    %eax,%edx
    4a2f:	8b 45 08             	mov    0x8(%ebp),%eax
    4a32:	8b 00                	mov    (%eax),%eax
    4a34:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    4a37:	c1 e1 02             	shl    $0x2,%ecx
    4a3a:	01 c8                	add    %ecx,%eax
    4a3c:	8b 18                	mov    (%eax),%ebx
    4a3e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a41:	8b 40 04             	mov    0x4(%eax),%eax
    4a44:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    4a47:	c1 e1 02             	shl    $0x2,%ecx
    4a4a:	01 c8                	add    %ecx,%eax
    4a4c:	8b 00                	mov    (%eax),%eax
    4a4e:	be 01 00 00 00       	mov    $0x1,%esi
    4a53:	89 c1                	mov    %eax,%ecx
    4a55:	d3 e6                	shl    %cl,%esi
    4a57:	89 f0                	mov    %esi,%eax
    4a59:	83 e8 01             	sub    $0x1,%eax
    4a5c:	21 d8                	and    %ebx,%eax
    4a5e:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4a60:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    4a64:	8b 45 08             	mov    0x8(%ebp),%eax
    4a67:	8b 40 0c             	mov    0xc(%eax),%eax
    4a6a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4a6d:	0f 85 68 ff ff ff    	jne    49db <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    4a73:	83 ec 0c             	sub    $0xc,%esp
    4a76:	ff 75 e8             	pushl  -0x18(%ebp)
    4a79:	e8 11 ea ff ff       	call   348f <lodepng_free>
    4a7e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    4a81:	83 ec 0c             	sub    $0xc,%esp
    4a84:	ff 75 e4             	pushl  -0x1c(%ebp)
    4a87:	e8 03 ea ff ff       	call   348f <lodepng_free>
    4a8c:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    4a8f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4a93:	75 11                	jne    4aa6 <HuffmanTree_makeFromLengths2+0x237>
    4a95:	83 ec 0c             	sub    $0xc,%esp
    4a98:	ff 75 08             	pushl  0x8(%ebp)
    4a9b:	e8 3f f9 ff ff       	call   43df <HuffmanTree_makeTable>
    4aa0:	83 c4 10             	add    $0x10,%esp
    4aa3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    4aa6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    4aa9:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4aac:	5b                   	pop    %ebx
    4aad:	5e                   	pop    %esi
    4aae:	5d                   	pop    %ebp
    4aaf:	c3                   	ret    

00004ab0 <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    4ab0:	55                   	push   %ebp
    4ab1:	89 e5                	mov    %esp,%ebp
    4ab3:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    4ab6:	8b 45 10             	mov    0x10(%ebp),%eax
    4ab9:	c1 e0 02             	shl    $0x2,%eax
    4abc:	83 ec 0c             	sub    $0xc,%esp
    4abf:	50                   	push   %eax
    4ac0:	e8 a9 e9 ff ff       	call   346e <lodepng_malloc>
    4ac5:	83 c4 10             	add    $0x10,%esp
    4ac8:	89 c2                	mov    %eax,%edx
    4aca:	8b 45 08             	mov    0x8(%ebp),%eax
    4acd:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    4ad0:	8b 45 08             	mov    0x8(%ebp),%eax
    4ad3:	8b 40 04             	mov    0x4(%eax),%eax
    4ad6:	85 c0                	test   %eax,%eax
    4ad8:	75 07                	jne    4ae1 <HuffmanTree_makeFromLengths+0x31>
    4ada:	b8 53 00 00 00       	mov    $0x53,%eax
    4adf:	eb 56                	jmp    4b37 <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    4ae1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4ae8:	eb 25                	jmp    4b0f <HuffmanTree_makeFromLengths+0x5f>
    4aea:	8b 45 08             	mov    0x8(%ebp),%eax
    4aed:	8b 40 04             	mov    0x4(%eax),%eax
    4af0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4af3:	c1 e2 02             	shl    $0x2,%edx
    4af6:	01 c2                	add    %eax,%edx
    4af8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4afb:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4b02:	8b 45 0c             	mov    0xc(%ebp),%eax
    4b05:	01 c8                	add    %ecx,%eax
    4b07:	8b 00                	mov    (%eax),%eax
    4b09:	89 02                	mov    %eax,(%edx)
    4b0b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4b0f:	8b 45 10             	mov    0x10(%ebp),%eax
    4b12:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4b15:	75 d3                	jne    4aea <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    4b17:	8b 55 10             	mov    0x10(%ebp),%edx
    4b1a:	8b 45 08             	mov    0x8(%ebp),%eax
    4b1d:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    4b20:	8b 45 08             	mov    0x8(%ebp),%eax
    4b23:	8b 55 14             	mov    0x14(%ebp),%edx
    4b26:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    4b29:	83 ec 0c             	sub    $0xc,%esp
    4b2c:	ff 75 08             	pushl  0x8(%ebp)
    4b2f:	e8 3b fd ff ff       	call   486f <HuffmanTree_makeFromLengths2>
    4b34:	83 c4 10             	add    $0x10,%esp
}
    4b37:	c9                   	leave  
    4b38:	c3                   	ret    

00004b39 <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    4b39:	55                   	push   %ebp
    4b3a:	89 e5                	mov    %esp,%ebp
    4b3c:	53                   	push   %ebx
    4b3d:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    4b40:	8b 45 08             	mov    0x8(%ebp),%eax
    4b43:	8b 50 0c             	mov    0xc(%eax),%edx
    4b46:	8b 45 08             	mov    0x8(%ebp),%eax
    4b49:	8b 40 08             	mov    0x8(%eax),%eax
    4b4c:	39 c2                	cmp    %eax,%edx
    4b4e:	0f 82 0b 01 00 00    	jb     4c5f <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    4b54:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4b5b:	eb 19                	jmp    4b76 <bpmnode_create+0x3d>
    4b5d:	8b 45 08             	mov    0x8(%ebp),%eax
    4b60:	8b 40 04             	mov    0x4(%eax),%eax
    4b63:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4b66:	c1 e2 04             	shl    $0x4,%edx
    4b69:	01 d0                	add    %edx,%eax
    4b6b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    4b72:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4b76:	8b 45 08             	mov    0x8(%ebp),%eax
    4b79:	8b 00                	mov    (%eax),%eax
    4b7b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4b7e:	75 dd                	jne    4b5d <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    4b80:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4b87:	eb 60                	jmp    4be9 <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    4b89:	8b 45 08             	mov    0x8(%ebp),%eax
    4b8c:	8b 40 18             	mov    0x18(%eax),%eax
    4b8f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4b92:	c1 e2 02             	shl    $0x2,%edx
    4b95:	01 d0                	add    %edx,%eax
    4b97:	8b 00                	mov    (%eax),%eax
    4b99:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4b9c:	eb 13                	jmp    4bb1 <bpmnode_create+0x78>
    4b9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4ba1:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4ba8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4bab:	8b 40 08             	mov    0x8(%eax),%eax
    4bae:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4bb1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4bb5:	75 e7                	jne    4b9e <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    4bb7:	8b 45 08             	mov    0x8(%ebp),%eax
    4bba:	8b 40 1c             	mov    0x1c(%eax),%eax
    4bbd:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4bc0:	c1 e2 02             	shl    $0x2,%edx
    4bc3:	01 d0                	add    %edx,%eax
    4bc5:	8b 00                	mov    (%eax),%eax
    4bc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4bca:	eb 13                	jmp    4bdf <bpmnode_create+0xa6>
    4bcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4bcf:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4bd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4bd9:	8b 40 08             	mov    0x8(%eax),%eax
    4bdc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4bdf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4be3:	75 e7                	jne    4bcc <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    4be5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4be9:	8b 45 08             	mov    0x8(%ebp),%eax
    4bec:	8b 40 14             	mov    0x14(%eax),%eax
    4bef:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4bf2:	75 95                	jne    4b89 <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    4bf4:	8b 45 08             	mov    0x8(%ebp),%eax
    4bf7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    4bfe:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4c05:	eb 44                	jmp    4c4b <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    4c07:	8b 45 08             	mov    0x8(%ebp),%eax
    4c0a:	8b 40 04             	mov    0x4(%eax),%eax
    4c0d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4c10:	c1 e2 04             	shl    $0x4,%edx
    4c13:	01 d0                	add    %edx,%eax
    4c15:	8b 40 0c             	mov    0xc(%eax),%eax
    4c18:	85 c0                	test   %eax,%eax
    4c1a:	75 2b                	jne    4c47 <bpmnode_create+0x10e>
    4c1c:	8b 45 08             	mov    0x8(%ebp),%eax
    4c1f:	8b 58 10             	mov    0x10(%eax),%ebx
    4c22:	8b 45 08             	mov    0x8(%ebp),%eax
    4c25:	8b 40 08             	mov    0x8(%eax),%eax
    4c28:	8d 48 01             	lea    0x1(%eax),%ecx
    4c2b:	8b 55 08             	mov    0x8(%ebp),%edx
    4c2e:	89 4a 08             	mov    %ecx,0x8(%edx)
    4c31:	c1 e0 02             	shl    $0x2,%eax
    4c34:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    4c37:	8b 45 08             	mov    0x8(%ebp),%eax
    4c3a:	8b 40 04             	mov    0x4(%eax),%eax
    4c3d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4c40:	c1 e1 04             	shl    $0x4,%ecx
    4c43:	01 c8                	add    %ecx,%eax
    4c45:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    4c47:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4c4b:	8b 45 08             	mov    0x8(%ebp),%eax
    4c4e:	8b 00                	mov    (%eax),%eax
    4c50:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4c53:	75 b2                	jne    4c07 <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    4c55:	8b 45 08             	mov    0x8(%ebp),%eax
    4c58:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    4c5f:	8b 45 08             	mov    0x8(%ebp),%eax
    4c62:	8b 58 10             	mov    0x10(%eax),%ebx
    4c65:	8b 45 08             	mov    0x8(%ebp),%eax
    4c68:	8b 40 0c             	mov    0xc(%eax),%eax
    4c6b:	8d 48 01             	lea    0x1(%eax),%ecx
    4c6e:	8b 55 08             	mov    0x8(%ebp),%edx
    4c71:	89 4a 0c             	mov    %ecx,0xc(%edx)
    4c74:	c1 e0 02             	shl    $0x2,%eax
    4c77:	01 d8                	add    %ebx,%eax
    4c79:	8b 00                	mov    (%eax),%eax
    4c7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    4c7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c81:	8b 55 0c             	mov    0xc(%ebp),%edx
    4c84:	89 10                	mov    %edx,(%eax)
  result->index = index;
    4c86:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c89:	8b 55 10             	mov    0x10(%ebp),%edx
    4c8c:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    4c8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4c92:	8b 55 14             	mov    0x14(%ebp),%edx
    4c95:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    4c98:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    4c9b:	83 c4 10             	add    $0x10,%esp
    4c9e:	5b                   	pop    %ebx
    4c9f:	5d                   	pop    %ebp
    4ca0:	c3                   	ret    

00004ca1 <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    4ca1:	55                   	push   %ebp
    4ca2:	89 e5                	mov    %esp,%ebp
    4ca4:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    4ca7:	8b 45 0c             	mov    0xc(%ebp),%eax
    4caa:	c1 e0 04             	shl    $0x4,%eax
    4cad:	83 ec 0c             	sub    $0xc,%esp
    4cb0:	50                   	push   %eax
    4cb1:	e8 b8 e7 ff ff       	call   346e <lodepng_malloc>
    4cb6:	83 c4 10             	add    $0x10,%esp
    4cb9:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    4cbc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    4cc3:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    4cca:	e9 41 01 00 00       	jmp    4e10 <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    4ccf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4cd2:	83 e0 01             	and    $0x1,%eax
    4cd5:	85 c0                	test   %eax,%eax
    4cd7:	74 05                	je     4cde <bpmnode_sort+0x3d>
    4cd9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4cdc:	eb 03                	jmp    4ce1 <bpmnode_sort+0x40>
    4cde:	8b 45 08             	mov    0x8(%ebp),%eax
    4ce1:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    4ce4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4ce7:	83 e0 01             	and    $0x1,%eax
    4cea:	85 c0                	test   %eax,%eax
    4cec:	74 05                	je     4cf3 <bpmnode_sort+0x52>
    4cee:	8b 45 08             	mov    0x8(%ebp),%eax
    4cf1:	eb 03                	jmp    4cf6 <bpmnode_sort+0x55>
    4cf3:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4cf6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4cf9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4d00:	e9 f8 00 00 00       	jmp    4dfd <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    4d05:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4d08:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d0b:	01 c2                	add    %eax,%edx
    4d0d:	8b 45 0c             	mov    0xc(%ebp),%eax
    4d10:	39 c2                	cmp    %eax,%edx
    4d12:	0f 4e c2             	cmovle %edx,%eax
    4d15:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    4d18:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d1b:	8d 14 00             	lea    (%eax,%eax,1),%edx
    4d1e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4d21:	01 c2                	add    %eax,%edx
    4d23:	8b 45 0c             	mov    0xc(%ebp),%eax
    4d26:	39 c2                	cmp    %eax,%edx
    4d28:	0f 4e c2             	cmovle %edx,%eax
    4d2b:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    4d2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4d31:	89 45 e8             	mov    %eax,-0x18(%ebp)
    4d34:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4d37:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    4d3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4d3d:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4d40:	e9 a4 00 00 00       	jmp    4de9 <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    4d45:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4d48:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    4d4b:	7d 62                	jge    4daf <bpmnode_sort+0x10e>
    4d4d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4d50:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4d53:	7d 22                	jge    4d77 <bpmnode_sort+0xd6>
    4d55:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4d58:	c1 e0 04             	shl    $0x4,%eax
    4d5b:	89 c2                	mov    %eax,%edx
    4d5d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4d60:	01 d0                	add    %edx,%eax
    4d62:	8b 10                	mov    (%eax),%edx
    4d64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4d67:	c1 e0 04             	shl    $0x4,%eax
    4d6a:	89 c1                	mov    %eax,%ecx
    4d6c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4d6f:	01 c8                	add    %ecx,%eax
    4d71:	8b 00                	mov    (%eax),%eax
    4d73:	39 c2                	cmp    %eax,%edx
    4d75:	7f 38                	jg     4daf <bpmnode_sort+0x10e>
    4d77:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4d7a:	c1 e0 04             	shl    $0x4,%eax
    4d7d:	89 c2                	mov    %eax,%edx
    4d7f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4d82:	01 d0                	add    %edx,%eax
    4d84:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4d87:	8d 4a 01             	lea    0x1(%edx),%ecx
    4d8a:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    4d8d:	89 d1                	mov    %edx,%ecx
    4d8f:	c1 e1 04             	shl    $0x4,%ecx
    4d92:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4d95:	01 ca                	add    %ecx,%edx
    4d97:	8b 0a                	mov    (%edx),%ecx
    4d99:	89 08                	mov    %ecx,(%eax)
    4d9b:	8b 4a 04             	mov    0x4(%edx),%ecx
    4d9e:	89 48 04             	mov    %ecx,0x4(%eax)
    4da1:	8b 4a 08             	mov    0x8(%edx),%ecx
    4da4:	89 48 08             	mov    %ecx,0x8(%eax)
    4da7:	8b 52 0c             	mov    0xc(%edx),%edx
    4daa:	89 50 0c             	mov    %edx,0xc(%eax)
    4dad:	eb 36                	jmp    4de5 <bpmnode_sort+0x144>
        else b[k] = a[j++];
    4daf:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4db2:	c1 e0 04             	shl    $0x4,%eax
    4db5:	89 c2                	mov    %eax,%edx
    4db7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4dba:	01 d0                	add    %edx,%eax
    4dbc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4dbf:	8d 4a 01             	lea    0x1(%edx),%ecx
    4dc2:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    4dc5:	89 d1                	mov    %edx,%ecx
    4dc7:	c1 e1 04             	shl    $0x4,%ecx
    4dca:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4dcd:	01 ca                	add    %ecx,%edx
    4dcf:	8b 0a                	mov    (%edx),%ecx
    4dd1:	89 08                	mov    %ecx,(%eax)
    4dd3:	8b 4a 04             	mov    0x4(%edx),%ecx
    4dd6:	89 48 04             	mov    %ecx,0x4(%eax)
    4dd9:	8b 4a 08             	mov    0x8(%edx),%ecx
    4ddc:	89 48 08             	mov    %ecx,0x8(%eax)
    4ddf:	8b 52 0c             	mov    0xc(%edx),%edx
    4de2:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    4de5:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4de9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4dec:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4def:	0f 8c 50 ff ff ff    	jl     4d45 <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4df5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4df8:	01 c0                	add    %eax,%eax
    4dfa:	01 45 ec             	add    %eax,-0x14(%ebp)
    4dfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4e00:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4e03:	0f 8c fc fe ff ff    	jl     4d05 <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    4e09:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    4e0d:	d1 65 f4             	shll   -0xc(%ebp)
    4e10:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e13:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4e16:	0f 8c b3 fe ff ff    	jl     4ccf <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    4e1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4e1f:	83 e0 01             	and    $0x1,%eax
    4e22:	85 c0                	test   %eax,%eax
    4e24:	74 18                	je     4e3e <bpmnode_sort+0x19d>
    4e26:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e29:	c1 e0 04             	shl    $0x4,%eax
    4e2c:	83 ec 04             	sub    $0x4,%esp
    4e2f:	50                   	push   %eax
    4e30:	ff 75 dc             	pushl  -0x24(%ebp)
    4e33:	ff 75 08             	pushl  0x8(%ebp)
    4e36:	e8 71 e6 ff ff       	call   34ac <lodepng_memcpy>
    4e3b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    4e3e:	83 ec 0c             	sub    $0xc,%esp
    4e41:	ff 75 dc             	pushl  -0x24(%ebp)
    4e44:	e8 46 e6 ff ff       	call   348f <lodepng_free>
    4e49:	83 c4 10             	add    $0x10,%esp
}
    4e4c:	90                   	nop
    4e4d:	c9                   	leave  
    4e4e:	c3                   	ret    

00004e4f <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    4e4f:	55                   	push   %ebp
    4e50:	89 e5                	mov    %esp,%ebp
    4e52:	56                   	push   %esi
    4e53:	53                   	push   %ebx
    4e54:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    4e57:	8b 45 08             	mov    0x8(%ebp),%eax
    4e5a:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e5d:	8b 55 14             	mov    0x14(%ebp),%edx
    4e60:	c1 e2 02             	shl    $0x2,%edx
    4e63:	01 d0                	add    %edx,%eax
    4e65:	8b 00                	mov    (%eax),%eax
    4e67:	8b 40 04             	mov    0x4(%eax),%eax
    4e6a:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    4e6d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    4e71:	75 66                	jne    4ed9 <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    4e73:	8b 45 10             	mov    0x10(%ebp),%eax
    4e76:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4e79:	0f 83 a0 01 00 00    	jae    501f <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    4e7f:	8b 45 08             	mov    0x8(%ebp),%eax
    4e82:	8b 40 18             	mov    0x18(%eax),%eax
    4e85:	8b 55 14             	mov    0x14(%ebp),%edx
    4e88:	c1 e2 02             	shl    $0x2,%edx
    4e8b:	01 c2                	add    %eax,%edx
    4e8d:	8b 45 08             	mov    0x8(%ebp),%eax
    4e90:	8b 40 1c             	mov    0x1c(%eax),%eax
    4e93:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4e96:	c1 e1 02             	shl    $0x2,%ecx
    4e99:	01 c8                	add    %ecx,%eax
    4e9b:	8b 00                	mov    (%eax),%eax
    4e9d:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    4e9f:	8b 45 08             	mov    0x8(%ebp),%eax
    4ea2:	8b 40 1c             	mov    0x1c(%eax),%eax
    4ea5:	8b 55 14             	mov    0x14(%ebp),%edx
    4ea8:	c1 e2 02             	shl    $0x2,%edx
    4eab:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4eae:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4eb1:	8d 50 01             	lea    0x1(%eax),%edx
    4eb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4eb7:	c1 e0 04             	shl    $0x4,%eax
    4eba:	89 c1                	mov    %eax,%ecx
    4ebc:	8b 45 0c             	mov    0xc(%ebp),%eax
    4ebf:	01 c8                	add    %ecx,%eax
    4ec1:	8b 00                	mov    (%eax),%eax
    4ec3:	6a 00                	push   $0x0
    4ec5:	52                   	push   %edx
    4ec6:	50                   	push   %eax
    4ec7:	ff 75 08             	pushl  0x8(%ebp)
    4eca:	e8 6a fc ff ff       	call   4b39 <bpmnode_create>
    4ecf:	83 c4 10             	add    $0x10,%esp
    4ed2:	89 03                	mov    %eax,(%ebx)
    4ed4:	e9 47 01 00 00       	jmp    5020 <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    4ed9:	8b 45 08             	mov    0x8(%ebp),%eax
    4edc:	8b 40 18             	mov    0x18(%eax),%eax
    4edf:	8b 55 14             	mov    0x14(%ebp),%edx
    4ee2:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4ee8:	c1 e2 02             	shl    $0x2,%edx
    4eeb:	01 d0                	add    %edx,%eax
    4eed:	8b 00                	mov    (%eax),%eax
    4eef:	8b 10                	mov    (%eax),%edx
    4ef1:	8b 45 08             	mov    0x8(%ebp),%eax
    4ef4:	8b 40 1c             	mov    0x1c(%eax),%eax
    4ef7:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4efa:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    4f00:	c1 e1 02             	shl    $0x2,%ecx
    4f03:	01 c8                	add    %ecx,%eax
    4f05:	8b 00                	mov    (%eax),%eax
    4f07:	8b 00                	mov    (%eax),%eax
    4f09:	01 d0                	add    %edx,%eax
    4f0b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    4f0e:	8b 45 08             	mov    0x8(%ebp),%eax
    4f11:	8b 40 18             	mov    0x18(%eax),%eax
    4f14:	8b 55 14             	mov    0x14(%ebp),%edx
    4f17:	c1 e2 02             	shl    $0x2,%edx
    4f1a:	01 c2                	add    %eax,%edx
    4f1c:	8b 45 08             	mov    0x8(%ebp),%eax
    4f1f:	8b 40 1c             	mov    0x1c(%eax),%eax
    4f22:	8b 4d 14             	mov    0x14(%ebp),%ecx
    4f25:	c1 e1 02             	shl    $0x2,%ecx
    4f28:	01 c8                	add    %ecx,%eax
    4f2a:	8b 00                	mov    (%eax),%eax
    4f2c:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    4f2e:	8b 45 10             	mov    0x10(%ebp),%eax
    4f31:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4f34:	73 60                	jae    4f96 <boundaryPM+0x147>
    4f36:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4f39:	c1 e0 04             	shl    $0x4,%eax
    4f3c:	89 c2                	mov    %eax,%edx
    4f3e:	8b 45 0c             	mov    0xc(%ebp),%eax
    4f41:	01 d0                	add    %edx,%eax
    4f43:	8b 00                	mov    (%eax),%eax
    4f45:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4f48:	7d 4c                	jge    4f96 <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    4f4a:	8b 45 08             	mov    0x8(%ebp),%eax
    4f4d:	8b 40 1c             	mov    0x1c(%eax),%eax
    4f50:	8b 55 14             	mov    0x14(%ebp),%edx
    4f53:	c1 e2 02             	shl    $0x2,%edx
    4f56:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4f59:	8b 45 08             	mov    0x8(%ebp),%eax
    4f5c:	8b 40 1c             	mov    0x1c(%eax),%eax
    4f5f:	8b 55 14             	mov    0x14(%ebp),%edx
    4f62:	c1 e2 02             	shl    $0x2,%edx
    4f65:	01 d0                	add    %edx,%eax
    4f67:	8b 00                	mov    (%eax),%eax
    4f69:	8b 50 08             	mov    0x8(%eax),%edx
    4f6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4f6f:	8d 48 01             	lea    0x1(%eax),%ecx
    4f72:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4f75:	c1 e0 04             	shl    $0x4,%eax
    4f78:	89 c6                	mov    %eax,%esi
    4f7a:	8b 45 0c             	mov    0xc(%ebp),%eax
    4f7d:	01 f0                	add    %esi,%eax
    4f7f:	8b 00                	mov    (%eax),%eax
    4f81:	52                   	push   %edx
    4f82:	51                   	push   %ecx
    4f83:	50                   	push   %eax
    4f84:	ff 75 08             	pushl  0x8(%ebp)
    4f87:	e8 ad fb ff ff       	call   4b39 <bpmnode_create>
    4f8c:	83 c4 10             	add    $0x10,%esp
    4f8f:	89 03                	mov    %eax,(%ebx)
      return;
    4f91:	e9 8a 00 00 00       	jmp    5020 <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    4f96:	8b 45 08             	mov    0x8(%ebp),%eax
    4f99:	8b 40 1c             	mov    0x1c(%eax),%eax
    4f9c:	8b 55 14             	mov    0x14(%ebp),%edx
    4f9f:	c1 e2 02             	shl    $0x2,%edx
    4fa2:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4fa5:	8b 45 08             	mov    0x8(%ebp),%eax
    4fa8:	8b 40 1c             	mov    0x1c(%eax),%eax
    4fab:	8b 55 14             	mov    0x14(%ebp),%edx
    4fae:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4fb4:	c1 e2 02             	shl    $0x2,%edx
    4fb7:	01 d0                	add    %edx,%eax
    4fb9:	8b 00                	mov    (%eax),%eax
    4fbb:	50                   	push   %eax
    4fbc:	ff 75 f4             	pushl  -0xc(%ebp)
    4fbf:	ff 75 f0             	pushl  -0x10(%ebp)
    4fc2:	ff 75 08             	pushl  0x8(%ebp)
    4fc5:	e8 6f fb ff ff       	call   4b39 <bpmnode_create>
    4fca:	83 c4 10             	add    $0x10,%esp
    4fcd:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    4fcf:	8b 45 18             	mov    0x18(%ebp),%eax
    4fd2:	8d 50 01             	lea    0x1(%eax),%edx
    4fd5:	8b 45 10             	mov    0x10(%ebp),%eax
    4fd8:	83 e8 01             	sub    $0x1,%eax
    4fdb:	01 c0                	add    %eax,%eax
    4fdd:	39 c2                	cmp    %eax,%edx
    4fdf:	7d 3f                	jge    5020 <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4fe1:	8b 45 14             	mov    0x14(%ebp),%eax
    4fe4:	83 e8 01             	sub    $0x1,%eax
    4fe7:	83 ec 0c             	sub    $0xc,%esp
    4fea:	ff 75 18             	pushl  0x18(%ebp)
    4fed:	50                   	push   %eax
    4fee:	ff 75 10             	pushl  0x10(%ebp)
    4ff1:	ff 75 0c             	pushl  0xc(%ebp)
    4ff4:	ff 75 08             	pushl  0x8(%ebp)
    4ff7:	e8 53 fe ff ff       	call   4e4f <boundaryPM>
    4ffc:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    4fff:	8b 45 14             	mov    0x14(%ebp),%eax
    5002:	83 e8 01             	sub    $0x1,%eax
    5005:	83 ec 0c             	sub    $0xc,%esp
    5008:	ff 75 18             	pushl  0x18(%ebp)
    500b:	50                   	push   %eax
    500c:	ff 75 10             	pushl  0x10(%ebp)
    500f:	ff 75 0c             	pushl  0xc(%ebp)
    5012:	ff 75 08             	pushl  0x8(%ebp)
    5015:	e8 35 fe ff ff       	call   4e4f <boundaryPM>
    501a:	83 c4 20             	add    $0x20,%esp
    501d:	eb 01                	jmp    5020 <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    501f:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    5020:	8d 65 f8             	lea    -0x8(%ebp),%esp
    5023:	5b                   	pop    %ebx
    5024:	5e                   	pop    %esi
    5025:	5d                   	pop    %ebp
    5026:	c3                   	ret    

00005027 <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    5027:	55                   	push   %ebp
    5028:	89 e5                	mov    %esp,%ebp
    502a:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    502d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    5034:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    503b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    503f:	75 0a                	jne    504b <lodepng_huffman_code_lengths+0x24>
    5041:	b8 50 00 00 00       	mov    $0x50,%eax
    5046:	e9 4d 03 00 00       	jmp    5398 <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    504b:	8b 45 14             	mov    0x14(%ebp),%eax
    504e:	ba 01 00 00 00       	mov    $0x1,%edx
    5053:	89 c1                	mov    %eax,%ecx
    5055:	d3 e2                	shl    %cl,%edx
    5057:	8b 45 10             	mov    0x10(%ebp),%eax
    505a:	39 c2                	cmp    %eax,%edx
    505c:	73 0a                	jae    5068 <lodepng_huffman_code_lengths+0x41>
    505e:	b8 50 00 00 00       	mov    $0x50,%eax
    5063:	e9 30 03 00 00       	jmp    5398 <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    5068:	8b 45 10             	mov    0x10(%ebp),%eax
    506b:	c1 e0 04             	shl    $0x4,%eax
    506e:	83 ec 0c             	sub    $0xc,%esp
    5071:	50                   	push   %eax
    5072:	e8 f7 e3 ff ff       	call   346e <lodepng_malloc>
    5077:	83 c4 10             	add    $0x10,%esp
    507a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    507d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    5081:	75 0a                	jne    508d <lodepng_huffman_code_lengths+0x66>
    5083:	b8 53 00 00 00       	mov    $0x53,%eax
    5088:	e9 0b 03 00 00       	jmp    5398 <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    508d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5094:	eb 50                	jmp    50e6 <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    5096:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5099:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    50a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    50a3:	01 d0                	add    %edx,%eax
    50a5:	8b 00                	mov    (%eax),%eax
    50a7:	85 c0                	test   %eax,%eax
    50a9:	74 37                	je     50e2 <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    50ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
    50ae:	c1 e0 04             	shl    $0x4,%eax
    50b1:	89 c2                	mov    %eax,%edx
    50b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    50b6:	01 d0                	add    %edx,%eax
    50b8:	8b 55 f0             	mov    -0x10(%ebp),%edx
    50bb:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    50c2:	8b 55 0c             	mov    0xc(%ebp),%edx
    50c5:	01 ca                	add    %ecx,%edx
    50c7:	8b 12                	mov    (%edx),%edx
    50c9:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    50cb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    50ce:	c1 e0 04             	shl    $0x4,%eax
    50d1:	89 c2                	mov    %eax,%edx
    50d3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    50d6:	01 c2                	add    %eax,%edx
    50d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    50db:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    50de:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    50e2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    50e6:	8b 45 10             	mov    0x10(%ebp),%eax
    50e9:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    50ec:	75 a8                	jne    5096 <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    50ee:	8b 45 10             	mov    0x10(%ebp),%eax
    50f1:	c1 e0 02             	shl    $0x2,%eax
    50f4:	83 ec 04             	sub    $0x4,%esp
    50f7:	50                   	push   %eax
    50f8:	6a 00                	push   $0x0
    50fa:	ff 75 08             	pushl  0x8(%ebp)
    50fd:	e8 dd e3 ff ff       	call   34df <lodepng_memset>
    5102:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    5105:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5109:	75 18                	jne    5123 <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    510b:	8b 45 08             	mov    0x8(%ebp),%eax
    510e:	83 c0 04             	add    $0x4,%eax
    5111:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    5117:	8b 10                	mov    (%eax),%edx
    5119:	8b 45 08             	mov    0x8(%ebp),%eax
    511c:	89 10                	mov    %edx,(%eax)
    511e:	e9 64 02 00 00       	jmp    5387 <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    5123:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    5127:	75 3e                	jne    5167 <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    5129:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    512c:	8b 40 04             	mov    0x4(%eax),%eax
    512f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5136:	8b 45 08             	mov    0x8(%ebp),%eax
    5139:	01 d0                	add    %edx,%eax
    513b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    5141:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5144:	8b 40 04             	mov    0x4(%eax),%eax
    5147:	85 c0                	test   %eax,%eax
    5149:	75 07                	jne    5152 <lodepng_huffman_code_lengths+0x12b>
    514b:	ba 04 00 00 00       	mov    $0x4,%edx
    5150:	eb 05                	jmp    5157 <lodepng_huffman_code_lengths+0x130>
    5152:	ba 00 00 00 00       	mov    $0x0,%edx
    5157:	8b 45 08             	mov    0x8(%ebp),%eax
    515a:	01 d0                	add    %edx,%eax
    515c:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    5162:	e9 20 02 00 00       	jmp    5387 <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    5167:	83 ec 08             	sub    $0x8,%esp
    516a:	ff 75 ec             	pushl  -0x14(%ebp)
    516d:	ff 75 e4             	pushl  -0x1c(%ebp)
    5170:	e8 2c fb ff ff       	call   4ca1 <bpmnode_sort>
    5175:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    5178:	8b 45 14             	mov    0x14(%ebp),%eax
    517b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    517e:	8b 45 14             	mov    0x14(%ebp),%eax
    5181:	83 c0 01             	add    $0x1,%eax
    5184:	0f af 45 14          	imul   0x14(%ebp),%eax
    5188:	01 c0                	add    %eax,%eax
    518a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    518d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    5194:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5197:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    519a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    519d:	c1 e0 04             	shl    $0x4,%eax
    51a0:	83 ec 0c             	sub    $0xc,%esp
    51a3:	50                   	push   %eax
    51a4:	e8 c5 e2 ff ff       	call   346e <lodepng_malloc>
    51a9:	83 c4 10             	add    $0x10,%esp
    51ac:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    51af:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    51b2:	c1 e0 02             	shl    $0x2,%eax
    51b5:	83 ec 0c             	sub    $0xc,%esp
    51b8:	50                   	push   %eax
    51b9:	e8 b0 e2 ff ff       	call   346e <lodepng_malloc>
    51be:	83 c4 10             	add    $0x10,%esp
    51c1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    51c4:	8b 45 d8             	mov    -0x28(%ebp),%eax
    51c7:	c1 e0 02             	shl    $0x2,%eax
    51ca:	83 ec 0c             	sub    $0xc,%esp
    51cd:	50                   	push   %eax
    51ce:	e8 9b e2 ff ff       	call   346e <lodepng_malloc>
    51d3:	83 c4 10             	add    $0x10,%esp
    51d6:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    51d9:	8b 45 d8             	mov    -0x28(%ebp),%eax
    51dc:	c1 e0 02             	shl    $0x2,%eax
    51df:	83 ec 0c             	sub    $0xc,%esp
    51e2:	50                   	push   %eax
    51e3:	e8 86 e2 ff ff       	call   346e <lodepng_malloc>
    51e8:	83 c4 10             	add    $0x10,%esp
    51eb:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    51ee:	8b 45 c8             	mov    -0x38(%ebp),%eax
    51f1:	85 c0                	test   %eax,%eax
    51f3:	74 15                	je     520a <lodepng_huffman_code_lengths+0x1e3>
    51f5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    51f8:	85 c0                	test   %eax,%eax
    51fa:	74 0e                	je     520a <lodepng_huffman_code_lengths+0x1e3>
    51fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
    51ff:	85 c0                	test   %eax,%eax
    5201:	74 07                	je     520a <lodepng_huffman_code_lengths+0x1e3>
    5203:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5206:	85 c0                	test   %eax,%eax
    5208:	75 07                	jne    5211 <lodepng_huffman_code_lengths+0x1ea>
    520a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    5211:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5215:	0f 85 30 01 00 00    	jne    534b <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    521b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5222:	eb 1c                	jmp    5240 <lodepng_huffman_code_lengths+0x219>
    5224:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5227:	8b 55 f0             	mov    -0x10(%ebp),%edx
    522a:	c1 e2 02             	shl    $0x2,%edx
    522d:	01 d0                	add    %edx,%eax
    522f:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5232:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5235:	c1 e1 04             	shl    $0x4,%ecx
    5238:	01 ca                	add    %ecx,%edx
    523a:	89 10                	mov    %edx,(%eax)
    523c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5240:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5243:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5246:	75 dc                	jne    5224 <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    5248:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    524b:	8b 00                	mov    (%eax),%eax
    524d:	6a 00                	push   $0x0
    524f:	6a 01                	push   $0x1
    5251:	50                   	push   %eax
    5252:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5255:	50                   	push   %eax
    5256:	e8 de f8 ff ff       	call   4b39 <bpmnode_create>
    525b:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    525e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5261:	83 c0 10             	add    $0x10,%eax
    5264:	8b 00                	mov    (%eax),%eax
    5266:	6a 00                	push   $0x0
    5268:	6a 02                	push   $0x2
    526a:	50                   	push   %eax
    526b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    526e:	50                   	push   %eax
    526f:	e8 c5 f8 ff ff       	call   4b39 <bpmnode_create>
    5274:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    5277:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    527e:	eb 27                	jmp    52a7 <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    5280:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5283:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5286:	c1 e2 02             	shl    $0x2,%edx
    5289:	01 c2                	add    %eax,%edx
    528b:	8b 45 c8             	mov    -0x38(%ebp),%eax
    528e:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    5290:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5293:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5296:	c1 e2 02             	shl    $0x2,%edx
    5299:	01 d0                	add    %edx,%eax
    529b:	8b 55 c8             	mov    -0x38(%ebp),%edx
    529e:	83 c2 10             	add    $0x10,%edx
    52a1:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    52a3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    52a7:	8b 45 d8             	mov    -0x28(%ebp),%eax
    52aa:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    52ad:	75 d1                	jne    5280 <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    52af:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    52b6:	eb 24                	jmp    52dc <lodepng_huffman_code_lengths+0x2b5>
    52b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    52bb:	8b 55 14             	mov    0x14(%ebp),%edx
    52be:	83 ea 01             	sub    $0x1,%edx
    52c1:	83 ec 0c             	sub    $0xc,%esp
    52c4:	50                   	push   %eax
    52c5:	52                   	push   %edx
    52c6:	ff 75 ec             	pushl  -0x14(%ebp)
    52c9:	ff 75 e4             	pushl  -0x1c(%ebp)
    52cc:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    52cf:	50                   	push   %eax
    52d0:	e8 7a fb ff ff       	call   4e4f <boundaryPM>
    52d5:	83 c4 20             	add    $0x20,%esp
    52d8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    52dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    52df:	83 e8 01             	sub    $0x1,%eax
    52e2:	01 c0                	add    %eax,%eax
    52e4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    52e7:	75 cf                	jne    52b8 <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    52e9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    52ec:	8b 55 14             	mov    0x14(%ebp),%edx
    52ef:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    52f5:	c1 e2 02             	shl    $0x2,%edx
    52f8:	01 d0                	add    %edx,%eax
    52fa:	8b 00                	mov    (%eax),%eax
    52fc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    52ff:	eb 44                	jmp    5345 <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    5301:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5308:	eb 27                	jmp    5331 <lodepng_huffman_code_lengths+0x30a>
    530a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    530d:	c1 e0 04             	shl    $0x4,%eax
    5310:	89 c2                	mov    %eax,%edx
    5312:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5315:	01 d0                	add    %edx,%eax
    5317:	8b 40 04             	mov    0x4(%eax),%eax
    531a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5321:	8b 45 08             	mov    0x8(%ebp),%eax
    5324:	01 d0                	add    %edx,%eax
    5326:	8b 10                	mov    (%eax),%edx
    5328:	83 c2 01             	add    $0x1,%edx
    532b:	89 10                	mov    %edx,(%eax)
    532d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5331:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5334:	8b 40 04             	mov    0x4(%eax),%eax
    5337:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    533a:	75 ce                	jne    530a <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    533c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    533f:	8b 40 08             	mov    0x8(%eax),%eax
    5342:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5345:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    5349:	75 b6                	jne    5301 <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    534b:	8b 45 c8             	mov    -0x38(%ebp),%eax
    534e:	83 ec 0c             	sub    $0xc,%esp
    5351:	50                   	push   %eax
    5352:	e8 38 e1 ff ff       	call   348f <lodepng_free>
    5357:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    535a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    535d:	83 ec 0c             	sub    $0xc,%esp
    5360:	50                   	push   %eax
    5361:	e8 29 e1 ff ff       	call   348f <lodepng_free>
    5366:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    5369:	8b 45 dc             	mov    -0x24(%ebp),%eax
    536c:	83 ec 0c             	sub    $0xc,%esp
    536f:	50                   	push   %eax
    5370:	e8 1a e1 ff ff       	call   348f <lodepng_free>
    5375:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    5378:	8b 45 e0             	mov    -0x20(%ebp),%eax
    537b:	83 ec 0c             	sub    $0xc,%esp
    537e:	50                   	push   %eax
    537f:	e8 0b e1 ff ff       	call   348f <lodepng_free>
    5384:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    5387:	83 ec 0c             	sub    $0xc,%esp
    538a:	ff 75 e4             	pushl  -0x1c(%ebp)
    538d:	e8 fd e0 ff ff       	call   348f <lodepng_free>
    5392:	83 c4 10             	add    $0x10,%esp
  return error;
    5395:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5398:	c9                   	leave  
    5399:	c3                   	ret    

0000539a <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    539a:	55                   	push   %ebp
    539b:	89 e5                	mov    %esp,%ebp
    539d:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    53a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    53a7:	eb 04                	jmp    53ad <HuffmanTree_makeFromFrequencies+0x13>
    53a9:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    53ad:	8b 45 14             	mov    0x14(%ebp),%eax
    53b0:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    53b5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    53bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    53bf:	01 d0                	add    %edx,%eax
    53c1:	8b 00                	mov    (%eax),%eax
    53c3:	85 c0                	test   %eax,%eax
    53c5:	75 08                	jne    53cf <HuffmanTree_makeFromFrequencies+0x35>
    53c7:	8b 45 14             	mov    0x14(%ebp),%eax
    53ca:	3b 45 10             	cmp    0x10(%ebp),%eax
    53cd:	7f da                	jg     53a9 <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    53cf:	8b 45 14             	mov    0x14(%ebp),%eax
    53d2:	c1 e0 02             	shl    $0x2,%eax
    53d5:	83 ec 0c             	sub    $0xc,%esp
    53d8:	50                   	push   %eax
    53d9:	e8 90 e0 ff ff       	call   346e <lodepng_malloc>
    53de:	83 c4 10             	add    $0x10,%esp
    53e1:	89 c2                	mov    %eax,%edx
    53e3:	8b 45 08             	mov    0x8(%ebp),%eax
    53e6:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    53e9:	8b 45 08             	mov    0x8(%ebp),%eax
    53ec:	8b 40 04             	mov    0x4(%eax),%eax
    53ef:	85 c0                	test   %eax,%eax
    53f1:	75 07                	jne    53fa <HuffmanTree_makeFromFrequencies+0x60>
    53f3:	b8 53 00 00 00       	mov    $0x53,%eax
    53f8:	eb 47                	jmp    5441 <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    53fa:	8b 45 08             	mov    0x8(%ebp),%eax
    53fd:	8b 55 18             	mov    0x18(%ebp),%edx
    5400:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    5403:	8b 55 14             	mov    0x14(%ebp),%edx
    5406:	8b 45 08             	mov    0x8(%ebp),%eax
    5409:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    540c:	8b 45 08             	mov    0x8(%ebp),%eax
    540f:	8b 40 04             	mov    0x4(%eax),%eax
    5412:	ff 75 18             	pushl  0x18(%ebp)
    5415:	ff 75 14             	pushl  0x14(%ebp)
    5418:	ff 75 0c             	pushl  0xc(%ebp)
    541b:	50                   	push   %eax
    541c:	e8 06 fc ff ff       	call   5027 <lodepng_huffman_code_lengths>
    5421:	83 c4 10             	add    $0x10,%esp
    5424:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    5427:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    542b:	75 11                	jne    543e <HuffmanTree_makeFromFrequencies+0xa4>
    542d:	83 ec 0c             	sub    $0xc,%esp
    5430:	ff 75 08             	pushl  0x8(%ebp)
    5433:	e8 37 f4 ff ff       	call   486f <HuffmanTree_makeFromLengths2>
    5438:	83 c4 10             	add    $0x10,%esp
    543b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    543e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5441:	c9                   	leave  
    5442:	c3                   	ret    

00005443 <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    5443:	55                   	push   %ebp
    5444:	89 e5                	mov    %esp,%ebp
    5446:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    5449:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    5450:	83 ec 0c             	sub    $0xc,%esp
    5453:	68 80 04 00 00       	push   $0x480
    5458:	e8 11 e0 ff ff       	call   346e <lodepng_malloc>
    545d:	83 c4 10             	add    $0x10,%esp
    5460:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    5463:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5467:	75 0a                	jne    5473 <generateFixedLitLenTree+0x30>
    5469:	b8 53 00 00 00       	mov    $0x53,%eax
    546e:	e9 d5 00 00 00       	jmp    5548 <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    5473:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    547a:	eb 19                	jmp    5495 <generateFixedLitLenTree+0x52>
    547c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    547f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5486:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5489:	01 d0                	add    %edx,%eax
    548b:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5491:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5495:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    549c:	76 de                	jbe    547c <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    549e:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    54a5:	eb 19                	jmp    54c0 <generateFixedLitLenTree+0x7d>
    54a7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    54aa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    54b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    54b4:	01 d0                	add    %edx,%eax
    54b6:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    54bc:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    54c0:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    54c7:	76 de                	jbe    54a7 <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    54c9:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    54d0:	eb 19                	jmp    54eb <generateFixedLitLenTree+0xa8>
    54d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    54d5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    54dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    54df:	01 d0                	add    %edx,%eax
    54e1:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    54e7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    54eb:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    54f2:	76 de                	jbe    54d2 <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    54f4:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    54fb:	eb 19                	jmp    5516 <generateFixedLitLenTree+0xd3>
    54fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5500:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5507:	8b 45 ec             	mov    -0x14(%ebp),%eax
    550a:	01 d0                	add    %edx,%eax
    550c:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    5512:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5516:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    551d:	76 de                	jbe    54fd <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    551f:	6a 0f                	push   $0xf
    5521:	68 20 01 00 00       	push   $0x120
    5526:	ff 75 ec             	pushl  -0x14(%ebp)
    5529:	ff 75 08             	pushl  0x8(%ebp)
    552c:	e8 7f f5 ff ff       	call   4ab0 <HuffmanTree_makeFromLengths>
    5531:	83 c4 10             	add    $0x10,%esp
    5534:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    5537:	83 ec 0c             	sub    $0xc,%esp
    553a:	ff 75 ec             	pushl  -0x14(%ebp)
    553d:	e8 4d df ff ff       	call   348f <lodepng_free>
    5542:	83 c4 10             	add    $0x10,%esp
  return error;
    5545:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    5548:	c9                   	leave  
    5549:	c3                   	ret    

0000554a <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    554a:	55                   	push   %ebp
    554b:	89 e5                	mov    %esp,%ebp
    554d:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    5550:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    5557:	83 ec 0c             	sub    $0xc,%esp
    555a:	68 80 00 00 00       	push   $0x80
    555f:	e8 0a df ff ff       	call   346e <lodepng_malloc>
    5564:	83 c4 10             	add    $0x10,%esp
    5567:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    556a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    556e:	75 07                	jne    5577 <generateFixedDistanceTree+0x2d>
    5570:	b8 53 00 00 00       	mov    $0x53,%eax
    5575:	eb 4e                	jmp    55c5 <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    5577:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    557e:	eb 19                	jmp    5599 <generateFixedDistanceTree+0x4f>
    5580:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5583:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    558a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    558d:	01 d0                	add    %edx,%eax
    558f:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    5595:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5599:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    559d:	75 e1                	jne    5580 <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    559f:	6a 0f                	push   $0xf
    55a1:	6a 20                	push   $0x20
    55a3:	ff 75 ec             	pushl  -0x14(%ebp)
    55a6:	ff 75 08             	pushl  0x8(%ebp)
    55a9:	e8 02 f5 ff ff       	call   4ab0 <HuffmanTree_makeFromLengths>
    55ae:	83 c4 10             	add    $0x10,%esp
    55b1:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    55b4:	83 ec 0c             	sub    $0xc,%esp
    55b7:	ff 75 ec             	pushl  -0x14(%ebp)
    55ba:	e8 d0 de ff ff       	call   348f <lodepng_free>
    55bf:	83 c4 10             	add    $0x10,%esp
  return error;
    55c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    55c5:	c9                   	leave  
    55c6:	c3                   	ret    

000055c7 <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    55c7:	55                   	push   %ebp
    55c8:	89 e5                	mov    %esp,%ebp
    55ca:	53                   	push   %ebx
    55cb:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    55ce:	6a 09                	push   $0x9
    55d0:	ff 75 08             	pushl  0x8(%ebp)
    55d3:	e8 d8 eb ff ff       	call   41b0 <peekBits>
    55d8:	83 c4 08             	add    $0x8,%esp
    55db:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    55df:	8b 45 0c             	mov    0xc(%ebp),%eax
    55e2:	8b 50 10             	mov    0x10(%eax),%edx
    55e5:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    55e9:	01 d0                	add    %edx,%eax
    55eb:	0f b6 00             	movzbl (%eax),%eax
    55ee:	0f b6 c0             	movzbl %al,%eax
    55f1:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    55f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    55f8:	8b 40 14             	mov    0x14(%eax),%eax
    55fb:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    55ff:	01 d2                	add    %edx,%edx
    5601:	01 d0                	add    %edx,%eax
    5603:	0f b7 00             	movzwl (%eax),%eax
    5606:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    560a:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    560f:	77 16                	ja     5627 <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    5611:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    5615:	50                   	push   %eax
    5616:	ff 75 08             	pushl  0x8(%ebp)
    5619:	e8 b2 eb ff ff       	call   41d0 <advanceBits>
    561e:	83 c4 08             	add    $0x8,%esp
    return value;
    5621:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    5625:	eb 5c                	jmp    5683 <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    5627:	6a 09                	push   $0x9
    5629:	ff 75 08             	pushl  0x8(%ebp)
    562c:	e8 9f eb ff ff       	call   41d0 <advanceBits>
    5631:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    5634:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    5638:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    563c:	83 e8 09             	sub    $0x9,%eax
    563f:	50                   	push   %eax
    5640:	ff 75 08             	pushl  0x8(%ebp)
    5643:	e8 68 eb ff ff       	call   41b0 <peekBits>
    5648:	83 c4 08             	add    $0x8,%esp
    564b:	01 d8                	add    %ebx,%eax
    564d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    5650:	8b 45 0c             	mov    0xc(%ebp),%eax
    5653:	8b 50 10             	mov    0x10(%eax),%edx
    5656:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5659:	01 d0                	add    %edx,%eax
    565b:	0f b6 00             	movzbl (%eax),%eax
    565e:	0f b6 c0             	movzbl %al,%eax
    5661:	83 e8 09             	sub    $0x9,%eax
    5664:	50                   	push   %eax
    5665:	ff 75 08             	pushl  0x8(%ebp)
    5668:	e8 63 eb ff ff       	call   41d0 <advanceBits>
    566d:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    5670:	8b 45 0c             	mov    0xc(%ebp),%eax
    5673:	8b 40 14             	mov    0x14(%eax),%eax
    5676:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5679:	01 d2                	add    %edx,%edx
    567b:	01 d0                	add    %edx,%eax
    567d:	0f b7 00             	movzwl (%eax),%eax
    5680:	0f b7 c0             	movzwl %ax,%eax
  }
}
    5683:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5686:	c9                   	leave  
    5687:	c3                   	ret    

00005688 <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    5688:	55                   	push   %ebp
    5689:	89 e5                	mov    %esp,%ebp
    568b:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    568e:	83 ec 0c             	sub    $0xc,%esp
    5691:	ff 75 08             	pushl  0x8(%ebp)
    5694:	e8 aa fd ff ff       	call   5443 <generateFixedLitLenTree>
    5699:	83 c4 10             	add    $0x10,%esp
    569c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    569f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    56a3:	74 05                	je     56aa <getTreeInflateFixed+0x22>
    56a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    56a8:	eb 0e                	jmp    56b8 <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    56aa:	83 ec 0c             	sub    $0xc,%esp
    56ad:	ff 75 0c             	pushl  0xc(%ebp)
    56b0:	e8 95 fe ff ff       	call   554a <generateFixedDistanceTree>
    56b5:	83 c4 10             	add    $0x10,%esp
}
    56b8:	c9                   	leave  
    56b9:	c3                   	ret    

000056ba <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    56ba:	55                   	push   %ebp
    56bb:	89 e5                	mov    %esp,%ebp
    56bd:	53                   	push   %ebx
    56be:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    56c1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    56c8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    56cf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    56d6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    56dd:	6a 0e                	push   $0xe
    56df:	ff 75 10             	pushl  0x10(%ebp)
    56e2:	e8 37 e6 ff ff       	call   3d1e <ensureBits17>
    56e7:	83 c4 08             	add    $0x8,%esp
    56ea:	85 c0                	test   %eax,%eax
    56ec:	75 0a                	jne    56f8 <getTreeInflateDynamic+0x3e>
    56ee:	b8 31 00 00 00       	mov    $0x31,%eax
    56f3:	e9 ec 04 00 00       	jmp    5be4 <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    56f8:	6a 05                	push   $0x5
    56fa:	ff 75 10             	pushl  0x10(%ebp)
    56fd:	e8 f8 ea ff ff       	call   41fa <readBits>
    5702:	83 c4 08             	add    $0x8,%esp
    5705:	05 01 01 00 00       	add    $0x101,%eax
    570a:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    570d:	6a 05                	push   $0x5
    570f:	ff 75 10             	pushl  0x10(%ebp)
    5712:	e8 e3 ea ff ff       	call   41fa <readBits>
    5717:	83 c4 08             	add    $0x8,%esp
    571a:	83 c0 01             	add    $0x1,%eax
    571d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    5720:	6a 04                	push   $0x4
    5722:	ff 75 10             	pushl  0x10(%ebp)
    5725:	e8 d0 ea ff ff       	call   41fa <readBits>
    572a:	83 c4 08             	add    $0x8,%esp
    572d:	83 c0 04             	add    $0x4,%eax
    5730:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    5733:	83 ec 0c             	sub    $0xc,%esp
    5736:	6a 4c                	push   $0x4c
    5738:	e8 31 dd ff ff       	call   346e <lodepng_malloc>
    573d:	83 c4 10             	add    $0x10,%esp
    5740:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    5743:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    5747:	75 0a                	jne    5753 <getTreeInflateDynamic+0x99>
    5749:	b8 53 00 00 00       	mov    $0x53,%eax
    574e:	e9 91 04 00 00       	jmp    5be4 <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    5753:	83 ec 0c             	sub    $0xc,%esp
    5756:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5759:	50                   	push   %eax
    575a:	e8 03 ec ff ff       	call   4362 <HuffmanTree_init>
    575f:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    5762:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5766:	0f 85 3c 04 00 00    	jne    5ba8 <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    576c:	8b 45 10             	mov    0x10(%ebp),%eax
    576f:	8b 48 08             	mov    0x8(%eax),%ecx
    5772:	8b 55 d0             	mov    -0x30(%ebp),%edx
    5775:	89 d0                	mov    %edx,%eax
    5777:	01 c0                	add    %eax,%eax
    5779:	01 d0                	add    %edx,%eax
    577b:	89 c2                	mov    %eax,%edx
    577d:	8b 45 10             	mov    0x10(%ebp),%eax
    5780:	8b 40 0c             	mov    0xc(%eax),%eax
    5783:	83 ec 04             	sub    $0x4,%esp
    5786:	51                   	push   %ecx
    5787:	52                   	push   %edx
    5788:	50                   	push   %eax
    5789:	e8 f7 dd ff ff       	call   3585 <lodepng_gtofl>
    578e:	83 c4 10             	add    $0x10,%esp
    5791:	85 c0                	test   %eax,%eax
    5793:	74 0c                	je     57a1 <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    5795:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    579c:	e9 07 04 00 00       	jmp    5ba8 <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    57a1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    57a8:	eb 3d                	jmp    57e7 <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    57aa:	83 ec 08             	sub    $0x8,%esp
    57ad:	6a 03                	push   $0x3
    57af:	ff 75 10             	pushl  0x10(%ebp)
    57b2:	e8 8b e4 ff ff       	call   3c42 <ensureBits9>
    57b7:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    57ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    57bd:	8b 04 85 80 a0 01 00 	mov    0x1a080(,%eax,4),%eax
    57c4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    57cb:	8b 45 dc             	mov    -0x24(%ebp),%eax
    57ce:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    57d1:	83 ec 08             	sub    $0x8,%esp
    57d4:	6a 03                	push   $0x3
    57d6:	ff 75 10             	pushl  0x10(%ebp)
    57d9:	e8 1c ea ff ff       	call   41fa <readBits>
    57de:	83 c4 10             	add    $0x10,%esp
    57e1:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    57e3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    57e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    57ea:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    57ed:	75 bb                	jne    57aa <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    57ef:	8b 45 d0             	mov    -0x30(%ebp),%eax
    57f2:	89 45 ec             	mov    %eax,-0x14(%ebp)
    57f5:	eb 20                	jmp    5817 <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    57f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    57fa:	8b 04 85 80 a0 01 00 	mov    0x1a080(,%eax,4),%eax
    5801:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5808:	8b 45 dc             	mov    -0x24(%ebp),%eax
    580b:	01 d0                	add    %edx,%eax
    580d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5813:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5817:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    581b:	75 da                	jne    57f7 <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    581d:	6a 07                	push   $0x7
    581f:	6a 13                	push   $0x13
    5821:	ff 75 dc             	pushl  -0x24(%ebp)
    5824:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5827:	50                   	push   %eax
    5828:	e8 83 f2 ff ff       	call   4ab0 <HuffmanTree_makeFromLengths>
    582d:	83 c4 10             	add    $0x10,%esp
    5830:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5833:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5837:	0f 85 64 03 00 00    	jne    5ba1 <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    583d:	83 ec 0c             	sub    $0xc,%esp
    5840:	68 80 04 00 00       	push   $0x480
    5845:	e8 24 dc ff ff       	call   346e <lodepng_malloc>
    584a:	83 c4 10             	add    $0x10,%esp
    584d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    5850:	83 ec 0c             	sub    $0xc,%esp
    5853:	68 80 00 00 00       	push   $0x80
    5858:	e8 11 dc ff ff       	call   346e <lodepng_malloc>
    585d:	83 c4 10             	add    $0x10,%esp
    5860:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    5863:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    5867:	74 06                	je     586f <getTreeInflateDynamic+0x1b5>
    5869:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    586d:	75 0c                	jne    587b <getTreeInflateDynamic+0x1c1>
    586f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5876:	e9 2d 03 00 00       	jmp    5ba8 <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    587b:	83 ec 04             	sub    $0x4,%esp
    587e:	68 80 04 00 00       	push   $0x480
    5883:	6a 00                	push   $0x0
    5885:	ff 75 e8             	pushl  -0x18(%ebp)
    5888:	e8 52 dc ff ff       	call   34df <lodepng_memset>
    588d:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    5890:	83 ec 04             	sub    $0x4,%esp
    5893:	68 80 00 00 00       	push   $0x80
    5898:	6a 00                	push   $0x0
    589a:	ff 75 e4             	pushl  -0x1c(%ebp)
    589d:	e8 3d dc ff ff       	call   34df <lodepng_memset>
    58a2:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    58a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    58ac:	e9 8d 02 00 00       	jmp    5b3e <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    58b1:	83 ec 08             	sub    $0x8,%esp
    58b4:	6a 16                	push   $0x16
    58b6:	ff 75 10             	pushl  0x10(%ebp)
    58b9:	e8 8c e5 ff ff       	call   3e4a <ensureBits25>
    58be:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    58c1:	83 ec 08             	sub    $0x8,%esp
    58c4:	8d 45 a8             	lea    -0x58(%ebp),%eax
    58c7:	50                   	push   %eax
    58c8:	ff 75 10             	pushl  0x10(%ebp)
    58cb:	e8 f7 fc ff ff       	call   55c7 <huffmanDecodeSymbol>
    58d0:	83 c4 10             	add    $0x10,%esp
    58d3:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    58d6:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    58da:	77 3e                	ja     591a <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    58dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58df:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    58e2:	73 16                	jae    58fa <getTreeInflateDynamic+0x240>
    58e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    58ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
    58f1:	01 c2                	add    %eax,%edx
    58f3:	8b 45 cc             	mov    -0x34(%ebp),%eax
    58f6:	89 02                	mov    %eax,(%edx)
    58f8:	eb 17                	jmp    5911 <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    58fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    58fd:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5900:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5907:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    590a:	01 c2                	add    %eax,%edx
    590c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    590f:	89 02                	mov    %eax,(%edx)
        ++i;
    5911:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5915:	e9 0b 02 00 00       	jmp    5b25 <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    591a:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    591e:	0f 85 da 00 00 00    	jne    59fe <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    5924:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    592b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    592f:	75 0c                	jne    593d <getTreeInflateDynamic+0x283>
    5931:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    5938:	e9 12 02 00 00       	jmp    5b4f <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    593d:	83 ec 08             	sub    $0x8,%esp
    5940:	6a 02                	push   $0x2
    5942:	ff 75 10             	pushl  0x10(%ebp)
    5945:	e8 b0 e8 ff ff       	call   41fa <readBits>
    594a:	83 c4 10             	add    $0x10,%esp
    594d:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    5950:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5953:	83 c0 01             	add    $0x1,%eax
    5956:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5959:	76 1b                	jbe    5976 <getTreeInflateDynamic+0x2bc>
    595b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    595e:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5963:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    596a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    596d:	01 d0                	add    %edx,%eax
    596f:	8b 00                	mov    (%eax),%eax
    5971:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5974:	eb 1c                	jmp    5992 <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    5976:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5979:	2b 45 d8             	sub    -0x28(%ebp),%eax
    597c:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5981:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5988:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    598b:	01 d0                	add    %edx,%eax
    598d:	8b 00                	mov    (%eax),%eax
    598f:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5992:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5999:	eb 56                	jmp    59f1 <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    599b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    599e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    59a1:	01 d0                	add    %edx,%eax
    59a3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    59a6:	77 0c                	ja     59b4 <getTreeInflateDynamic+0x2fa>
    59a8:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    59af:	e9 71 01 00 00       	jmp    5b25 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    59b4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59b7:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    59ba:	73 16                	jae    59d2 <getTreeInflateDynamic+0x318>
    59bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59bf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    59c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    59c9:	01 c2                	add    %eax,%edx
    59cb:	8b 45 e0             	mov    -0x20(%ebp),%eax
    59ce:	89 02                	mov    %eax,(%edx)
    59d0:	eb 17                	jmp    59e9 <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    59d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    59d5:	2b 45 d8             	sub    -0x28(%ebp),%eax
    59d8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    59df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    59e2:	01 c2                	add    %eax,%edx
    59e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    59e7:	89 02                	mov    %eax,(%edx)
          ++i;
    59e9:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    59ed:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    59f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    59f4:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    59f7:	72 a2                	jb     599b <getTreeInflateDynamic+0x2e1>
    59f9:	e9 27 01 00 00       	jmp    5b25 <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    59fe:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    5a02:	0f 85 88 00 00 00    	jne    5a90 <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    5a08:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    5a0f:	83 ec 08             	sub    $0x8,%esp
    5a12:	6a 03                	push   $0x3
    5a14:	ff 75 10             	pushl  0x10(%ebp)
    5a17:	e8 de e7 ff ff       	call   41fa <readBits>
    5a1c:	83 c4 10             	add    $0x10,%esp
    5a1f:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5a22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5a29:	eb 58                	jmp    5a83 <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    5a2b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5a2e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5a31:	01 d0                	add    %edx,%eax
    5a33:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5a36:	77 0c                	ja     5a44 <getTreeInflateDynamic+0x38a>
    5a38:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    5a3f:	e9 e1 00 00 00       	jmp    5b25 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5a44:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a47:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5a4a:	73 17                	jae    5a63 <getTreeInflateDynamic+0x3a9>
    5a4c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a4f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a56:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5a59:	01 d0                	add    %edx,%eax
    5a5b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5a61:	eb 18                	jmp    5a7b <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    5a63:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a66:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5a69:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a70:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5a73:	01 d0                	add    %edx,%eax
    5a75:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5a7b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5a7f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5a83:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5a86:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    5a89:	72 a0                	jb     5a2b <getTreeInflateDynamic+0x371>
    5a8b:	e9 95 00 00 00       	jmp    5b25 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    5a90:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    5a94:	0f 85 82 00 00 00    	jne    5b1c <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    5a9a:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    5aa1:	83 ec 08             	sub    $0x8,%esp
    5aa4:	6a 07                	push   $0x7
    5aa6:	ff 75 10             	pushl  0x10(%ebp)
    5aa9:	e8 4c e7 ff ff       	call   41fa <readBits>
    5aae:	83 c4 10             	add    $0x10,%esp
    5ab1:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5ab4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5abb:	eb 55                	jmp    5b12 <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    5abd:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5ac0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5ac3:	01 d0                	add    %edx,%eax
    5ac5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5ac8:	77 09                	ja     5ad3 <getTreeInflateDynamic+0x419>
    5aca:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    5ad1:	eb 52                	jmp    5b25 <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5ad3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ad6:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5ad9:	73 17                	jae    5af2 <getTreeInflateDynamic+0x438>
    5adb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ade:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5ae5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5ae8:	01 d0                	add    %edx,%eax
    5aea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5af0:	eb 18                	jmp    5b0a <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    5af2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5af5:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5af8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5aff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5b02:	01 d0                	add    %edx,%eax
    5b04:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5b0a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5b0e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5b12:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5b15:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    5b18:	72 a3                	jb     5abd <getTreeInflateDynamic+0x403>
    5b1a:	eb 09                	jmp    5b25 <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5b1c:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5b23:	eb 2a                	jmp    5b4f <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    5b25:	8b 45 10             	mov    0x10(%ebp),%eax
    5b28:	8b 50 0c             	mov    0xc(%eax),%edx
    5b2b:	8b 45 10             	mov    0x10(%ebp),%eax
    5b2e:	8b 40 08             	mov    0x8(%eax),%eax
    5b31:	39 c2                	cmp    %eax,%edx
    5b33:	7e 09                	jle    5b3e <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    5b35:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5b3c:	eb 11                	jmp    5b4f <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    5b3e:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5b41:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5b44:	01 d0                	add    %edx,%eax
    5b46:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5b49:	0f 87 62 fd ff ff    	ja     58b1 <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5b4f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5b53:	75 4f                	jne    5ba4 <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    5b55:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5b58:	05 00 04 00 00       	add    $0x400,%eax
    5b5d:	8b 00                	mov    (%eax),%eax
    5b5f:	85 c0                	test   %eax,%eax
    5b61:	75 09                	jne    5b6c <getTreeInflateDynamic+0x4b2>
    5b63:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    5b6a:	eb 3c                	jmp    5ba8 <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5b6c:	6a 0f                	push   $0xf
    5b6e:	68 20 01 00 00       	push   $0x120
    5b73:	ff 75 e8             	pushl  -0x18(%ebp)
    5b76:	ff 75 08             	pushl  0x8(%ebp)
    5b79:	e8 32 ef ff ff       	call   4ab0 <HuffmanTree_makeFromLengths>
    5b7e:	83 c4 10             	add    $0x10,%esp
    5b81:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5b84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5b88:	75 1d                	jne    5ba7 <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    5b8a:	6a 0f                	push   $0xf
    5b8c:	6a 20                	push   $0x20
    5b8e:	ff 75 e4             	pushl  -0x1c(%ebp)
    5b91:	ff 75 0c             	pushl  0xc(%ebp)
    5b94:	e8 17 ef ff ff       	call   4ab0 <HuffmanTree_makeFromLengths>
    5b99:	83 c4 10             	add    $0x10,%esp
    5b9c:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    5b9f:	eb 07                	jmp    5ba8 <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    5ba1:	90                   	nop
    5ba2:	eb 04                	jmp    5ba8 <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5ba4:	90                   	nop
    5ba5:	eb 01                	jmp    5ba8 <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    5ba7:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    5ba8:	83 ec 0c             	sub    $0xc,%esp
    5bab:	ff 75 dc             	pushl  -0x24(%ebp)
    5bae:	e8 dc d8 ff ff       	call   348f <lodepng_free>
    5bb3:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    5bb6:	83 ec 0c             	sub    $0xc,%esp
    5bb9:	ff 75 e8             	pushl  -0x18(%ebp)
    5bbc:	e8 ce d8 ff ff       	call   348f <lodepng_free>
    5bc1:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    5bc4:	83 ec 0c             	sub    $0xc,%esp
    5bc7:	ff 75 e4             	pushl  -0x1c(%ebp)
    5bca:	e8 c0 d8 ff ff       	call   348f <lodepng_free>
    5bcf:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    5bd2:	83 ec 0c             	sub    $0xc,%esp
    5bd5:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5bd8:	50                   	push   %eax
    5bd9:	e8 b1 e7 ff ff       	call   438f <HuffmanTree_cleanup>
    5bde:	83 c4 10             	add    $0x10,%esp

  return error;
    5be1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5be4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5be7:	c9                   	leave  
    5be8:	c3                   	ret    

00005be9 <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    5be9:	55                   	push   %ebp
    5bea:	89 e5                	mov    %esp,%ebp
    5bec:	53                   	push   %ebx
    5bed:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    5bf0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    5bf7:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5bfa:	50                   	push   %eax
    5bfb:	e8 62 e7 ff ff       	call   4362 <HuffmanTree_init>
    5c00:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    5c03:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5c06:	50                   	push   %eax
    5c07:	e8 56 e7 ff ff       	call   4362 <HuffmanTree_init>
    5c0c:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    5c0f:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    5c13:	75 1b                	jne    5c30 <inflateHuffmanBlock+0x47>
    5c15:	83 ec 08             	sub    $0x8,%esp
    5c18:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5c1b:	50                   	push   %eax
    5c1c:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5c1f:	50                   	push   %eax
    5c20:	e8 63 fa ff ff       	call   5688 <getTreeInflateFixed>
    5c25:	83 c4 10             	add    $0x10,%esp
    5c28:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5c2b:	e9 9a 02 00 00       	jmp    5eca <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    5c30:	83 ec 04             	sub    $0x4,%esp
    5c33:	ff 75 0c             	pushl  0xc(%ebp)
    5c36:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5c39:	50                   	push   %eax
    5c3a:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5c3d:	50                   	push   %eax
    5c3e:	e8 77 fa ff ff       	call   56ba <getTreeInflateDynamic>
    5c43:	83 c4 10             	add    $0x10,%esp
    5c46:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5c49:	e9 7c 02 00 00       	jmp    5eca <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    5c4e:	83 ec 08             	sub    $0x8,%esp
    5c51:	6a 14                	push   $0x14
    5c53:	ff 75 0c             	pushl  0xc(%ebp)
    5c56:	e8 ef e1 ff ff       	call   3e4a <ensureBits25>
    5c5b:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    5c5e:	83 ec 08             	sub    $0x8,%esp
    5c61:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5c64:	50                   	push   %eax
    5c65:	ff 75 0c             	pushl  0xc(%ebp)
    5c68:	e8 5a f9 ff ff       	call   55c7 <huffmanDecodeSymbol>
    5c6d:	83 c4 10             	add    $0x10,%esp
    5c70:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    5c73:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    5c7a:	77 42                	ja     5cbe <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    5c7c:	8b 45 08             	mov    0x8(%ebp),%eax
    5c7f:	8b 40 04             	mov    0x4(%eax),%eax
    5c82:	83 c0 01             	add    $0x1,%eax
    5c85:	83 ec 08             	sub    $0x8,%esp
    5c88:	50                   	push   %eax
    5c89:	ff 75 08             	pushl  0x8(%ebp)
    5c8c:	e8 37 da ff ff       	call   36c8 <ucvector_resize>
    5c91:	83 c4 10             	add    $0x10,%esp
    5c94:	85 c0                	test   %eax,%eax
    5c96:	75 0c                	jne    5ca4 <inflateHuffmanBlock+0xbb>
    5c98:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5c9f:	e9 33 02 00 00       	jmp    5ed7 <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    5ca4:	8b 45 08             	mov    0x8(%ebp),%eax
    5ca7:	8b 10                	mov    (%eax),%edx
    5ca9:	8b 45 08             	mov    0x8(%ebp),%eax
    5cac:	8b 40 04             	mov    0x4(%eax),%eax
    5caf:	83 e8 01             	sub    $0x1,%eax
    5cb2:	01 d0                	add    %edx,%eax
    5cb4:	8b 55 dc             	mov    -0x24(%ebp),%edx
    5cb7:	88 10                	mov    %dl,(%eax)
    5cb9:	e9 d9 01 00 00       	jmp    5e97 <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5cbe:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5cc5:	0f 86 ba 01 00 00    	jbe    5e85 <inflateHuffmanBlock+0x29c>
    5ccb:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    5cd2:	0f 87 ad 01 00 00    	ja     5e85 <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    5cd8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5cdb:	2d 01 01 00 00       	sub    $0x101,%eax
    5ce0:	8b 04 85 80 9e 01 00 	mov    0x19e80(,%eax,4),%eax
    5ce7:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    5cea:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5ced:	2d 01 01 00 00       	sub    $0x101,%eax
    5cf2:	8b 04 85 00 9f 01 00 	mov    0x19f00(,%eax,4),%eax
    5cf9:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    5cfc:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    5d00:	74 1c                	je     5d1e <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    5d02:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5d05:	83 ec 08             	sub    $0x8,%esp
    5d08:	50                   	push   %eax
    5d09:	ff 75 0c             	pushl  0xc(%ebp)
    5d0c:	e8 e9 e4 ff ff       	call   41fa <readBits>
    5d11:	83 c4 10             	add    $0x10,%esp
    5d14:	89 c2                	mov    %eax,%edx
    5d16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5d19:	01 d0                	add    %edx,%eax
    5d1b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    5d1e:	83 ec 08             	sub    $0x8,%esp
    5d21:	6a 1c                	push   $0x1c
    5d23:	ff 75 0c             	pushl  0xc(%ebp)
    5d26:	e8 98 e2 ff ff       	call   3fc3 <ensureBits32>
    5d2b:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    5d2e:	83 ec 08             	sub    $0x8,%esp
    5d31:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5d34:	50                   	push   %eax
    5d35:	ff 75 0c             	pushl  0xc(%ebp)
    5d38:	e8 8a f8 ff ff       	call   55c7 <huffmanDecodeSymbol>
    5d3d:	83 c4 10             	add    $0x10,%esp
    5d40:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    5d43:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    5d47:	76 1e                	jbe    5d67 <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    5d49:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    5d4d:	77 0c                	ja     5d5b <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    5d4f:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    5d56:	e9 7c 01 00 00       	jmp    5ed7 <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5d5b:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5d62:	e9 70 01 00 00       	jmp    5ed7 <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    5d67:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5d6a:	8b 04 85 80 9f 01 00 	mov    0x19f80(,%eax,4),%eax
    5d71:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    5d74:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5d77:	8b 04 85 00 a0 01 00 	mov    0x1a000(,%eax,4),%eax
    5d7e:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    5d81:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    5d85:	74 15                	je     5d9c <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    5d87:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5d8a:	83 ec 08             	sub    $0x8,%esp
    5d8d:	50                   	push   %eax
    5d8e:	ff 75 0c             	pushl  0xc(%ebp)
    5d91:	e8 64 e4 ff ff       	call   41fa <readBits>
    5d96:	83 c4 10             	add    $0x10,%esp
    5d99:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    5d9c:	8b 45 08             	mov    0x8(%ebp),%eax
    5d9f:	8b 40 04             	mov    0x4(%eax),%eax
    5da2:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    5da5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5da8:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5dab:	76 0c                	jbe    5db9 <inflateHuffmanBlock+0x1d0>
    5dad:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    5db4:	e9 1e 01 00 00       	jmp    5ed7 <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    5db9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5dbc:	2b 45 f0             	sub    -0x10(%ebp),%eax
    5dbf:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    5dc2:	8b 45 08             	mov    0x8(%ebp),%eax
    5dc5:	8b 50 04             	mov    0x4(%eax),%edx
    5dc8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5dcb:	01 d0                	add    %edx,%eax
    5dcd:	83 ec 08             	sub    $0x8,%esp
    5dd0:	50                   	push   %eax
    5dd1:	ff 75 08             	pushl  0x8(%ebp)
    5dd4:	e8 ef d8 ff ff       	call   36c8 <ucvector_resize>
    5dd9:	83 c4 10             	add    $0x10,%esp
    5ddc:	85 c0                	test   %eax,%eax
    5dde:	75 0c                	jne    5dec <inflateHuffmanBlock+0x203>
    5de0:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5de7:	e9 eb 00 00 00       	jmp    5ed7 <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    5dec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5def:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5df2:	73 6b                	jae    5e5f <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    5df4:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5df7:	8b 55 08             	mov    0x8(%ebp),%edx
    5dfa:	8b 0a                	mov    (%edx),%ecx
    5dfc:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5dff:	01 d1                	add    %edx,%ecx
    5e01:	8b 55 08             	mov    0x8(%ebp),%edx
    5e04:	8b 1a                	mov    (%edx),%ebx
    5e06:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5e09:	01 da                	add    %ebx,%edx
    5e0b:	83 ec 04             	sub    $0x4,%esp
    5e0e:	50                   	push   %eax
    5e0f:	51                   	push   %ecx
    5e10:	52                   	push   %edx
    5e11:	e8 96 d6 ff ff       	call   34ac <lodepng_memcpy>
    5e16:	83 c4 10             	add    $0x10,%esp
        start += distance;
    5e19:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5e1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5e1f:	01 d0                	add    %edx,%eax
    5e21:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    5e24:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5e27:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5e2a:	eb 29                	jmp    5e55 <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    5e2c:	8b 45 08             	mov    0x8(%ebp),%eax
    5e2f:	8b 08                	mov    (%eax),%ecx
    5e31:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e34:	8d 50 01             	lea    0x1(%eax),%edx
    5e37:	89 55 ec             	mov    %edx,-0x14(%ebp)
    5e3a:	01 c1                	add    %eax,%ecx
    5e3c:	8b 45 08             	mov    0x8(%ebp),%eax
    5e3f:	8b 18                	mov    (%eax),%ebx
    5e41:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5e44:	8d 50 01             	lea    0x1(%eax),%edx
    5e47:	89 55 e8             	mov    %edx,-0x18(%ebp)
    5e4a:	01 d8                	add    %ebx,%eax
    5e4c:	0f b6 00             	movzbl (%eax),%eax
    5e4f:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    5e51:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5e55:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5e58:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    5e5b:	7c cf                	jl     5e2c <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5e5d:	eb 38                	jmp    5e97 <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    5e5f:	8b 45 08             	mov    0x8(%ebp),%eax
    5e62:	8b 10                	mov    (%eax),%edx
    5e64:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5e67:	01 c2                	add    %eax,%edx
    5e69:	8b 45 08             	mov    0x8(%ebp),%eax
    5e6c:	8b 08                	mov    (%eax),%ecx
    5e6e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5e71:	01 c8                	add    %ecx,%eax
    5e73:	83 ec 04             	sub    $0x4,%esp
    5e76:	ff 75 e4             	pushl  -0x1c(%ebp)
    5e79:	52                   	push   %edx
    5e7a:	50                   	push   %eax
    5e7b:	e8 2c d6 ff ff       	call   34ac <lodepng_memcpy>
    5e80:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5e83:	eb 12                	jmp    5e97 <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    5e85:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5e8c:	74 48                	je     5ed6 <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5e8e:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5e95:	eb 40                	jmp    5ed7 <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    5e97:	8b 45 0c             	mov    0xc(%ebp),%eax
    5e9a:	8b 50 0c             	mov    0xc(%eax),%edx
    5e9d:	8b 45 0c             	mov    0xc(%ebp),%eax
    5ea0:	8b 40 08             	mov    0x8(%eax),%eax
    5ea3:	39 c2                	cmp    %eax,%edx
    5ea5:	7e 09                	jle    5eb0 <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    5ea7:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    5eae:	eb 27                	jmp    5ed7 <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    5eb0:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    5eb4:	74 14                	je     5eca <inflateHuffmanBlock+0x2e1>
    5eb6:	8b 45 08             	mov    0x8(%ebp),%eax
    5eb9:	8b 40 04             	mov    0x4(%eax),%eax
    5ebc:	3b 45 14             	cmp    0x14(%ebp),%eax
    5ebf:	7e 09                	jle    5eca <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    5ec1:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    5ec8:	eb 0d                	jmp    5ed7 <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5eca:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5ece:	0f 84 7a fd ff ff    	je     5c4e <inflateHuffmanBlock+0x65>
    5ed4:	eb 01                	jmp    5ed7 <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    5ed6:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    5ed7:	83 ec 0c             	sub    $0xc,%esp
    5eda:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5edd:	50                   	push   %eax
    5ede:	e8 ac e4 ff ff       	call   438f <HuffmanTree_cleanup>
    5ee3:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    5ee6:	83 ec 0c             	sub    $0xc,%esp
    5ee9:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5eec:	50                   	push   %eax
    5eed:	e8 9d e4 ff ff       	call   438f <HuffmanTree_cleanup>
    5ef2:	83 c4 10             	add    $0x10,%esp

  return error;
    5ef5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5ef8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5efb:	c9                   	leave  
    5efc:	c3                   	ret    

00005efd <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    5efd:	55                   	push   %ebp
    5efe:	89 e5                	mov    %esp,%ebp
    5f00:	53                   	push   %ebx
    5f01:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    5f04:	8b 45 0c             	mov    0xc(%ebp),%eax
    5f07:	8b 40 04             	mov    0x4(%eax),%eax
    5f0a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    5f0d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    5f14:	8b 45 0c             	mov    0xc(%ebp),%eax
    5f17:	8b 40 0c             	mov    0xc(%eax),%eax
    5f1a:	83 c0 07             	add    $0x7,%eax
    5f1d:	c1 e8 03             	shr    $0x3,%eax
    5f20:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    5f23:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f26:	83 c0 04             	add    $0x4,%eax
    5f29:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    5f2c:	7c 0a                	jl     5f38 <inflateNoCompression+0x3b>
    5f2e:	b8 34 00 00 00       	mov    $0x34,%eax
    5f33:	e9 01 01 00 00       	jmp    6039 <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5f38:	8b 45 0c             	mov    0xc(%ebp),%eax
    5f3b:	8b 10                	mov    (%eax),%edx
    5f3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f40:	01 d0                	add    %edx,%eax
    5f42:	0f b6 00             	movzbl (%eax),%eax
    5f45:	0f b6 d0             	movzbl %al,%edx
    5f48:	8b 45 0c             	mov    0xc(%ebp),%eax
    5f4b:	8b 00                	mov    (%eax),%eax
    5f4d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5f50:	83 c1 01             	add    $0x1,%ecx
    5f53:	01 c8                	add    %ecx,%eax
    5f55:	0f b6 00             	movzbl (%eax),%eax
    5f58:	0f b6 c0             	movzbl %al,%eax
    5f5b:	c1 e0 08             	shl    $0x8,%eax
    5f5e:	01 d0                	add    %edx,%eax
    5f60:	89 45 ec             	mov    %eax,-0x14(%ebp)
    5f63:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    5f67:	8b 45 0c             	mov    0xc(%ebp),%eax
    5f6a:	8b 10                	mov    (%eax),%edx
    5f6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f6f:	01 d0                	add    %edx,%eax
    5f71:	0f b6 00             	movzbl (%eax),%eax
    5f74:	0f b6 d0             	movzbl %al,%edx
    5f77:	8b 45 0c             	mov    0xc(%ebp),%eax
    5f7a:	8b 00                	mov    (%eax),%eax
    5f7c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    5f7f:	83 c1 01             	add    $0x1,%ecx
    5f82:	01 c8                	add    %ecx,%eax
    5f84:	0f b6 00             	movzbl (%eax),%eax
    5f87:	0f b6 c0             	movzbl %al,%eax
    5f8a:	c1 e0 08             	shl    $0x8,%eax
    5f8d:	01 d0                	add    %edx,%eax
    5f8f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5f92:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    5f96:	8b 45 10             	mov    0x10(%ebp),%eax
    5f99:	8b 40 04             	mov    0x4(%eax),%eax
    5f9c:	85 c0                	test   %eax,%eax
    5f9e:	75 19                	jne    5fb9 <inflateNoCompression+0xbc>
    5fa0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5fa3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5fa6:	01 d0                	add    %edx,%eax
    5fa8:	3d ff ff 00 00       	cmp    $0xffff,%eax
    5fad:	74 0a                	je     5fb9 <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    5faf:	b8 15 00 00 00       	mov    $0x15,%eax
    5fb4:	e9 80 00 00 00       	jmp    6039 <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    5fb9:	8b 45 08             	mov    0x8(%ebp),%eax
    5fbc:	8b 40 04             	mov    0x4(%eax),%eax
    5fbf:	89 c2                	mov    %eax,%edx
    5fc1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5fc4:	01 d0                	add    %edx,%eax
    5fc6:	50                   	push   %eax
    5fc7:	ff 75 08             	pushl  0x8(%ebp)
    5fca:	e8 f9 d6 ff ff       	call   36c8 <ucvector_resize>
    5fcf:	83 c4 08             	add    $0x8,%esp
    5fd2:	85 c0                	test   %eax,%eax
    5fd4:	75 07                	jne    5fdd <inflateNoCompression+0xe0>
    5fd6:	b8 53 00 00 00       	mov    $0x53,%eax
    5fdb:	eb 5c                	jmp    6039 <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    5fdd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5fe0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5fe3:	01 c2                	add    %eax,%edx
    5fe5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    5fe8:	39 c2                	cmp    %eax,%edx
    5fea:	76 07                	jbe    5ff3 <inflateNoCompression+0xf6>
    5fec:	b8 17 00 00 00       	mov    $0x17,%eax
    5ff1:	eb 46                	jmp    6039 <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    5ff3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ff6:	8b 55 0c             	mov    0xc(%ebp),%edx
    5ff9:	8b 0a                	mov    (%edx),%ecx
    5ffb:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5ffe:	01 d1                	add    %edx,%ecx
    6000:	8b 55 08             	mov    0x8(%ebp),%edx
    6003:	8b 1a                	mov    (%edx),%ebx
    6005:	8b 55 08             	mov    0x8(%ebp),%edx
    6008:	8b 52 04             	mov    0x4(%edx),%edx
    600b:	2b 55 ec             	sub    -0x14(%ebp),%edx
    600e:	01 da                	add    %ebx,%edx
    6010:	50                   	push   %eax
    6011:	51                   	push   %ecx
    6012:	52                   	push   %edx
    6013:	e8 94 d4 ff ff       	call   34ac <lodepng_memcpy>
    6018:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    601b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    601e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6021:	01 d0                	add    %edx,%eax
    6023:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    6026:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6029:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    6030:	8b 45 0c             	mov    0xc(%ebp),%eax
    6033:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    6036:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6039:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    603c:	c9                   	leave  
    603d:	c3                   	ret    

0000603e <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    603e:	55                   	push   %ebp
    603f:	89 e5                	mov    %esp,%ebp
    6041:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    6044:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    604b:	ff 75 10             	pushl  0x10(%ebp)
    604e:	ff 75 0c             	pushl  0xc(%ebp)
    6051:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6054:	50                   	push   %eax
    6055:	e8 77 db ff ff       	call   3bd1 <LodePNGBitReader_init>
    605a:	83 c4 0c             	add    $0xc,%esp
    605d:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    6060:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6064:	0f 84 b9 00 00 00    	je     6123 <lodepng_inflatev+0xe5>
    606a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    606d:	e9 c1 00 00 00       	jmp    6133 <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    6072:	6a 03                	push   $0x3
    6074:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6077:	50                   	push   %eax
    6078:	e8 c5 db ff ff       	call   3c42 <ensureBits9>
    607d:	83 c4 08             	add    $0x8,%esp
    6080:	85 c0                	test   %eax,%eax
    6082:	75 0a                	jne    608e <lodepng_inflatev+0x50>
    6084:	b8 34 00 00 00       	mov    $0x34,%eax
    6089:	e9 a5 00 00 00       	jmp    6133 <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    608e:	6a 01                	push   $0x1
    6090:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6093:	50                   	push   %eax
    6094:	e8 61 e1 ff ff       	call   41fa <readBits>
    6099:	83 c4 08             	add    $0x8,%esp
    609c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    609f:	6a 02                	push   $0x2
    60a1:	8d 45 d8             	lea    -0x28(%ebp),%eax
    60a4:	50                   	push   %eax
    60a5:	e8 50 e1 ff ff       	call   41fa <readBits>
    60aa:	83 c4 08             	add    $0x8,%esp
    60ad:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    60b0:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    60b4:	75 07                	jne    60bd <lodepng_inflatev+0x7f>
    60b6:	b8 14 00 00 00       	mov    $0x14,%eax
    60bb:	eb 76                	jmp    6133 <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    60bd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    60c1:	75 17                	jne    60da <lodepng_inflatev+0x9c>
    60c3:	ff 75 14             	pushl  0x14(%ebp)
    60c6:	8d 45 d8             	lea    -0x28(%ebp),%eax
    60c9:	50                   	push   %eax
    60ca:	ff 75 08             	pushl  0x8(%ebp)
    60cd:	e8 2b fe ff ff       	call   5efd <inflateNoCompression>
    60d2:	83 c4 0c             	add    $0xc,%esp
    60d5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    60d8:	eb 1c                	jmp    60f6 <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    60da:	8b 45 14             	mov    0x14(%ebp),%eax
    60dd:	8b 40 08             	mov    0x8(%eax),%eax
    60e0:	50                   	push   %eax
    60e1:	ff 75 ec             	pushl  -0x14(%ebp)
    60e4:	8d 45 d8             	lea    -0x28(%ebp),%eax
    60e7:	50                   	push   %eax
    60e8:	ff 75 08             	pushl  0x8(%ebp)
    60eb:	e8 f9 fa ff ff       	call   5be9 <inflateHuffmanBlock>
    60f0:	83 c4 10             	add    $0x10,%esp
    60f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    60f6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    60fa:	75 21                	jne    611d <lodepng_inflatev+0xdf>
    60fc:	8b 45 14             	mov    0x14(%ebp),%eax
    60ff:	8b 40 08             	mov    0x8(%eax),%eax
    6102:	85 c0                	test   %eax,%eax
    6104:	74 17                	je     611d <lodepng_inflatev+0xdf>
    6106:	8b 45 08             	mov    0x8(%ebp),%eax
    6109:	8b 50 04             	mov    0x4(%eax),%edx
    610c:	8b 45 14             	mov    0x14(%ebp),%eax
    610f:	8b 40 08             	mov    0x8(%eax),%eax
    6112:	39 c2                	cmp    %eax,%edx
    6114:	7e 07                	jle    611d <lodepng_inflatev+0xdf>
    6116:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    611d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6121:	75 0c                	jne    612f <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    6123:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6127:	0f 84 45 ff ff ff    	je     6072 <lodepng_inflatev+0x34>
    612d:	eb 01                	jmp    6130 <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    612f:	90                   	nop
  }

  return error;
    6130:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    6133:	c9                   	leave  
    6134:	c3                   	ret    

00006135 <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    6135:	55                   	push   %ebp
    6136:	89 e5                	mov    %esp,%ebp
    6138:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    613b:	8b 45 0c             	mov    0xc(%ebp),%eax
    613e:	8b 08                	mov    (%eax),%ecx
    6140:	8b 45 08             	mov    0x8(%ebp),%eax
    6143:	8b 10                	mov    (%eax),%edx
    6145:	8d 45 e8             	lea    -0x18(%ebp),%eax
    6148:	51                   	push   %ecx
    6149:	52                   	push   %edx
    614a:	50                   	push   %eax
    614b:	e8 df d5 ff ff       	call   372f <ucvector_init>
    6150:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    6153:	ff 75 18             	pushl  0x18(%ebp)
    6156:	ff 75 14             	pushl  0x14(%ebp)
    6159:	ff 75 10             	pushl  0x10(%ebp)
    615c:	8d 45 e8             	lea    -0x18(%ebp),%eax
    615f:	50                   	push   %eax
    6160:	e8 d9 fe ff ff       	call   603e <lodepng_inflatev>
    6165:	83 c4 10             	add    $0x10,%esp
    6168:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    616b:	8b 55 e8             	mov    -0x18(%ebp),%edx
    616e:	8b 45 08             	mov    0x8(%ebp),%eax
    6171:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    6173:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6176:	8b 45 0c             	mov    0xc(%ebp),%eax
    6179:	89 10                	mov    %edx,(%eax)
  return error;
    617b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    617e:	c9                   	leave  
    617f:	c3                   	ret    

00006180 <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    6180:	55                   	push   %ebp
    6181:	89 e5                	mov    %esp,%ebp
    6183:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    6186:	8b 45 14             	mov    0x14(%ebp),%eax
    6189:	8b 40 10             	mov    0x10(%eax),%eax
    618c:	85 c0                	test   %eax,%eax
    618e:	74 64                	je     61f4 <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    6190:	8b 45 14             	mov    0x14(%ebp),%eax
    6193:	8b 40 10             	mov    0x10(%eax),%eax
    6196:	8b 55 08             	mov    0x8(%ebp),%edx
    6199:	8d 4a 04             	lea    0x4(%edx),%ecx
    619c:	8b 55 08             	mov    0x8(%ebp),%edx
    619f:	83 ec 0c             	sub    $0xc,%esp
    61a2:	ff 75 14             	pushl  0x14(%ebp)
    61a5:	ff 75 10             	pushl  0x10(%ebp)
    61a8:	ff 75 0c             	pushl  0xc(%ebp)
    61ab:	51                   	push   %ecx
    61ac:	52                   	push   %edx
    61ad:	ff d0                	call   *%eax
    61af:	83 c4 20             	add    $0x20,%esp
    61b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    61b5:	8b 45 08             	mov    0x8(%ebp),%eax
    61b8:	8b 50 04             	mov    0x4(%eax),%edx
    61bb:	8b 45 08             	mov    0x8(%ebp),%eax
    61be:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    61c1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    61c5:	74 28                	je     61ef <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    61c7:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    61ce:	8b 45 14             	mov    0x14(%ebp),%eax
    61d1:	8b 40 08             	mov    0x8(%eax),%eax
    61d4:	85 c0                	test   %eax,%eax
    61d6:	74 17                	je     61ef <inflatev+0x6f>
    61d8:	8b 45 08             	mov    0x8(%ebp),%eax
    61db:	8b 50 04             	mov    0x4(%eax),%edx
    61de:	8b 45 14             	mov    0x14(%ebp),%eax
    61e1:	8b 40 08             	mov    0x8(%eax),%eax
    61e4:	39 c2                	cmp    %eax,%edx
    61e6:	7e 07                	jle    61ef <inflatev+0x6f>
    61e8:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    61ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
    61f2:	eb 14                	jmp    6208 <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    61f4:	ff 75 14             	pushl  0x14(%ebp)
    61f7:	ff 75 10             	pushl  0x10(%ebp)
    61fa:	ff 75 0c             	pushl  0xc(%ebp)
    61fd:	ff 75 08             	pushl  0x8(%ebp)
    6200:	e8 39 fe ff ff       	call   603e <lodepng_inflatev>
    6205:	83 c4 10             	add    $0x10,%esp
  }
}
    6208:	c9                   	leave  
    6209:	c3                   	ret    

0000620a <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    620a:	55                   	push   %ebp
    620b:	89 e5                	mov    %esp,%ebp
    620d:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    6210:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    6217:	8b 45 0c             	mov    0xc(%ebp),%eax
    621a:	83 e8 01             	sub    $0x1,%eax
    621d:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    6220:	eb 39                	jmp    625b <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    6222:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6225:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6228:	01 d0                	add    %edx,%eax
    622a:	d1 f8                	sar    %eax
    622c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    622f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6232:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6239:	8b 45 08             	mov    0x8(%ebp),%eax
    623c:	01 d0                	add    %edx,%eax
    623e:	8b 10                	mov    (%eax),%edx
    6240:	8b 45 10             	mov    0x10(%ebp),%eax
    6243:	39 c2                	cmp    %eax,%edx
    6245:	72 0b                	jb     6252 <searchCodeIndex+0x48>
    6247:	8b 45 f4             	mov    -0xc(%ebp),%eax
    624a:	83 e8 01             	sub    $0x1,%eax
    624d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    6250:	eb 09                	jmp    625b <searchCodeIndex+0x51>
    else left = mid + 1;
    6252:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6255:	83 c0 01             	add    $0x1,%eax
    6258:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    625b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    625e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6261:	7e bf                	jle    6222 <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    6263:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6266:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6269:	7d 18                	jge    6283 <searchCodeIndex+0x79>
    626b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    626e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    6275:	8b 45 08             	mov    0x8(%ebp),%eax
    6278:	01 d0                	add    %edx,%eax
    627a:	8b 10                	mov    (%eax),%edx
    627c:	8b 45 10             	mov    0x10(%ebp),%eax
    627f:	39 c2                	cmp    %eax,%edx
    6281:	76 04                	jbe    6287 <searchCodeIndex+0x7d>
    6283:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    6287:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    628a:	c9                   	leave  
    628b:	c3                   	ret    

0000628c <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    628c:	55                   	push   %ebp
    628d:	89 e5                	mov    %esp,%ebp
    628f:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    6292:	ff 75 0c             	pushl  0xc(%ebp)
    6295:	6a 1d                	push   $0x1d
    6297:	68 80 9e 01 00       	push   $0x19e80
    629c:	e8 69 ff ff ff       	call   620a <searchCodeIndex>
    62a1:	83 c4 0c             	add    $0xc,%esp
    62a4:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    62a7:	8b 55 0c             	mov    0xc(%ebp),%edx
    62aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
    62ad:	8b 04 85 80 9e 01 00 	mov    0x19e80(,%eax,4),%eax
    62b4:	29 c2                	sub    %eax,%edx
    62b6:	89 d0                	mov    %edx,%eax
    62b8:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    62bb:	ff 75 10             	pushl  0x10(%ebp)
    62be:	6a 1e                	push   $0x1e
    62c0:	68 80 9f 01 00       	push   $0x19f80
    62c5:	e8 40 ff ff ff       	call   620a <searchCodeIndex>
    62ca:	83 c4 0c             	add    $0xc,%esp
    62cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    62d0:	8b 55 10             	mov    0x10(%ebp),%edx
    62d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    62d6:	8b 04 85 80 9f 01 00 	mov    0x19f80(,%eax,4),%eax
    62dd:	29 c2                	sub    %eax,%edx
    62df:	89 d0                	mov    %edx,%eax
    62e1:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    62e4:	8b 45 08             	mov    0x8(%ebp),%eax
    62e7:	8b 40 04             	mov    0x4(%eax),%eax
    62ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    62ed:	8b 45 08             	mov    0x8(%ebp),%eax
    62f0:	8b 40 04             	mov    0x4(%eax),%eax
    62f3:	83 c0 04             	add    $0x4,%eax
    62f6:	50                   	push   %eax
    62f7:	ff 75 08             	pushl  0x8(%ebp)
    62fa:	e8 f0 d2 ff ff       	call   35ef <uivector_resize>
    62ff:	83 c4 08             	add    $0x8,%esp
    6302:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    6305:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    6309:	74 57                	je     6362 <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    630b:	8b 45 08             	mov    0x8(%ebp),%eax
    630e:	8b 00                	mov    (%eax),%eax
    6310:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6313:	c1 e2 02             	shl    $0x2,%edx
    6316:	01 d0                	add    %edx,%eax
    6318:	8b 55 fc             	mov    -0x4(%ebp),%edx
    631b:	81 c2 01 01 00 00    	add    $0x101,%edx
    6321:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    6323:	8b 45 08             	mov    0x8(%ebp),%eax
    6326:	8b 00                	mov    (%eax),%eax
    6328:	8b 55 ec             	mov    -0x14(%ebp),%edx
    632b:	83 c2 01             	add    $0x1,%edx
    632e:	c1 e2 02             	shl    $0x2,%edx
    6331:	01 c2                	add    %eax,%edx
    6333:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6336:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    6338:	8b 45 08             	mov    0x8(%ebp),%eax
    633b:	8b 00                	mov    (%eax),%eax
    633d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6340:	83 c2 02             	add    $0x2,%edx
    6343:	c1 e2 02             	shl    $0x2,%edx
    6346:	01 c2                	add    %eax,%edx
    6348:	8b 45 f4             	mov    -0xc(%ebp),%eax
    634b:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    634d:	8b 45 08             	mov    0x8(%ebp),%eax
    6350:	8b 00                	mov    (%eax),%eax
    6352:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6355:	83 c2 03             	add    $0x3,%edx
    6358:	c1 e2 02             	shl    $0x2,%edx
    635b:	01 c2                	add    %eax,%edx
    635d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6360:	89 02                	mov    %eax,(%edx)
  }
}
    6362:	90                   	nop
    6363:	c9                   	leave  
    6364:	c3                   	ret    

00006365 <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    6365:	55                   	push   %ebp
    6366:	89 e5                	mov    %esp,%ebp
    6368:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    636b:	b8 00 00 01 00       	mov    $0x10000,%eax
    6370:	c1 e0 02             	shl    $0x2,%eax
    6373:	83 ec 0c             	sub    $0xc,%esp
    6376:	50                   	push   %eax
    6377:	e8 f2 d0 ff ff       	call   346e <lodepng_malloc>
    637c:	83 c4 10             	add    $0x10,%esp
    637f:	89 c2                	mov    %eax,%edx
    6381:	8b 45 08             	mov    0x8(%ebp),%eax
    6384:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    6386:	8b 45 0c             	mov    0xc(%ebp),%eax
    6389:	c1 e0 02             	shl    $0x2,%eax
    638c:	83 ec 0c             	sub    $0xc,%esp
    638f:	50                   	push   %eax
    6390:	e8 d9 d0 ff ff       	call   346e <lodepng_malloc>
    6395:	83 c4 10             	add    $0x10,%esp
    6398:	89 c2                	mov    %eax,%edx
    639a:	8b 45 08             	mov    0x8(%ebp),%eax
    639d:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    63a0:	8b 45 0c             	mov    0xc(%ebp),%eax
    63a3:	01 c0                	add    %eax,%eax
    63a5:	83 ec 0c             	sub    $0xc,%esp
    63a8:	50                   	push   %eax
    63a9:	e8 c0 d0 ff ff       	call   346e <lodepng_malloc>
    63ae:	83 c4 10             	add    $0x10,%esp
    63b1:	89 c2                	mov    %eax,%edx
    63b3:	8b 45 08             	mov    0x8(%ebp),%eax
    63b6:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    63b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    63bc:	01 c0                	add    %eax,%eax
    63be:	83 ec 0c             	sub    $0xc,%esp
    63c1:	50                   	push   %eax
    63c2:	e8 a7 d0 ff ff       	call   346e <lodepng_malloc>
    63c7:	83 c4 10             	add    $0x10,%esp
    63ca:	89 c2                	mov    %eax,%edx
    63cc:	8b 45 08             	mov    0x8(%ebp),%eax
    63cf:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    63d2:	b8 02 01 00 00       	mov    $0x102,%eax
    63d7:	83 c0 01             	add    $0x1,%eax
    63da:	c1 e0 02             	shl    $0x2,%eax
    63dd:	83 ec 0c             	sub    $0xc,%esp
    63e0:	50                   	push   %eax
    63e1:	e8 88 d0 ff ff       	call   346e <lodepng_malloc>
    63e6:	83 c4 10             	add    $0x10,%esp
    63e9:	89 c2                	mov    %eax,%edx
    63eb:	8b 45 08             	mov    0x8(%ebp),%eax
    63ee:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    63f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    63f4:	01 c0                	add    %eax,%eax
    63f6:	83 ec 0c             	sub    $0xc,%esp
    63f9:	50                   	push   %eax
    63fa:	e8 6f d0 ff ff       	call   346e <lodepng_malloc>
    63ff:	83 c4 10             	add    $0x10,%esp
    6402:	89 c2                	mov    %eax,%edx
    6404:	8b 45 08             	mov    0x8(%ebp),%eax
    6407:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    640a:	8b 45 08             	mov    0x8(%ebp),%eax
    640d:	8b 00                	mov    (%eax),%eax
    640f:	85 c0                	test   %eax,%eax
    6411:	74 32                	je     6445 <hash_init+0xe0>
    6413:	8b 45 08             	mov    0x8(%ebp),%eax
    6416:	8b 40 04             	mov    0x4(%eax),%eax
    6419:	85 c0                	test   %eax,%eax
    641b:	74 28                	je     6445 <hash_init+0xe0>
    641d:	8b 45 08             	mov    0x8(%ebp),%eax
    6420:	8b 40 08             	mov    0x8(%eax),%eax
    6423:	85 c0                	test   %eax,%eax
    6425:	74 1e                	je     6445 <hash_init+0xe0>
    6427:	8b 45 08             	mov    0x8(%ebp),%eax
    642a:	8b 40 0c             	mov    0xc(%eax),%eax
    642d:	85 c0                	test   %eax,%eax
    642f:	74 14                	je     6445 <hash_init+0xe0>
    6431:	8b 45 08             	mov    0x8(%ebp),%eax
    6434:	8b 40 10             	mov    0x10(%eax),%eax
    6437:	85 c0                	test   %eax,%eax
    6439:	74 0a                	je     6445 <hash_init+0xe0>
    643b:	8b 45 08             	mov    0x8(%ebp),%eax
    643e:	8b 40 14             	mov    0x14(%eax),%eax
    6441:	85 c0                	test   %eax,%eax
    6443:	75 0a                	jne    644f <hash_init+0xea>
    return 83; /*alloc fail*/
    6445:	b8 53 00 00 00       	mov    $0x53,%eax
    644a:	e9 d3 00 00 00       	jmp    6522 <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    644f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6456:	eb 17                	jmp    646f <hash_init+0x10a>
    6458:	8b 45 08             	mov    0x8(%ebp),%eax
    645b:	8b 00                	mov    (%eax),%eax
    645d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6460:	c1 e2 02             	shl    $0x2,%edx
    6463:	01 d0                	add    %edx,%eax
    6465:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    646b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    646f:	b8 00 00 01 00       	mov    $0x10000,%eax
    6474:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    6477:	75 df                	jne    6458 <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    6479:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6480:	eb 18                	jmp    649a <hash_init+0x135>
    6482:	8b 45 08             	mov    0x8(%ebp),%eax
    6485:	8b 40 08             	mov    0x8(%eax),%eax
    6488:	8b 55 f4             	mov    -0xc(%ebp),%edx
    648b:	c1 e2 02             	shl    $0x2,%edx
    648e:	01 d0                	add    %edx,%eax
    6490:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6496:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    649a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    649d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    64a0:	75 e0                	jne    6482 <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    64a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    64a9:	eb 17                	jmp    64c2 <hash_init+0x15d>
    64ab:	8b 45 08             	mov    0x8(%ebp),%eax
    64ae:	8b 40 04             	mov    0x4(%eax),%eax
    64b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    64b4:	01 d2                	add    %edx,%edx
    64b6:	01 d0                	add    %edx,%eax
    64b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    64bb:	66 89 10             	mov    %dx,(%eax)
    64be:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    64c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    64c5:	3b 45 0c             	cmp    0xc(%ebp),%eax
    64c8:	75 e1                	jne    64ab <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    64ca:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    64d1:	eb 18                	jmp    64eb <hash_init+0x186>
    64d3:	8b 45 08             	mov    0x8(%ebp),%eax
    64d6:	8b 40 0c             	mov    0xc(%eax),%eax
    64d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    64dc:	c1 e2 02             	shl    $0x2,%edx
    64df:	01 d0                	add    %edx,%eax
    64e1:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    64e7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    64eb:	b8 02 01 00 00       	mov    $0x102,%eax
    64f0:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    64f3:	76 de                	jbe    64d3 <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    64f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    64fc:	eb 17                	jmp    6515 <hash_init+0x1b0>
    64fe:	8b 45 08             	mov    0x8(%ebp),%eax
    6501:	8b 40 10             	mov    0x10(%eax),%eax
    6504:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6507:	01 d2                	add    %edx,%edx
    6509:	01 d0                	add    %edx,%eax
    650b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    650e:	66 89 10             	mov    %dx,(%eax)
    6511:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6515:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6518:	3b 45 0c             	cmp    0xc(%ebp),%eax
    651b:	75 e1                	jne    64fe <hash_init+0x199>

  return 0;
    651d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6522:	c9                   	leave  
    6523:	c3                   	ret    

00006524 <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    6524:	55                   	push   %ebp
    6525:	89 e5                	mov    %esp,%ebp
    6527:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    652a:	8b 45 08             	mov    0x8(%ebp),%eax
    652d:	8b 00                	mov    (%eax),%eax
    652f:	83 ec 0c             	sub    $0xc,%esp
    6532:	50                   	push   %eax
    6533:	e8 57 cf ff ff       	call   348f <lodepng_free>
    6538:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    653b:	8b 45 08             	mov    0x8(%ebp),%eax
    653e:	8b 40 08             	mov    0x8(%eax),%eax
    6541:	83 ec 0c             	sub    $0xc,%esp
    6544:	50                   	push   %eax
    6545:	e8 45 cf ff ff       	call   348f <lodepng_free>
    654a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    654d:	8b 45 08             	mov    0x8(%ebp),%eax
    6550:	8b 40 04             	mov    0x4(%eax),%eax
    6553:	83 ec 0c             	sub    $0xc,%esp
    6556:	50                   	push   %eax
    6557:	e8 33 cf ff ff       	call   348f <lodepng_free>
    655c:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    655f:	8b 45 08             	mov    0x8(%ebp),%eax
    6562:	8b 40 14             	mov    0x14(%eax),%eax
    6565:	83 ec 0c             	sub    $0xc,%esp
    6568:	50                   	push   %eax
    6569:	e8 21 cf ff ff       	call   348f <lodepng_free>
    656e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    6571:	8b 45 08             	mov    0x8(%ebp),%eax
    6574:	8b 40 0c             	mov    0xc(%eax),%eax
    6577:	83 ec 0c             	sub    $0xc,%esp
    657a:	50                   	push   %eax
    657b:	e8 0f cf ff ff       	call   348f <lodepng_free>
    6580:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    6583:	8b 45 08             	mov    0x8(%ebp),%eax
    6586:	8b 40 10             	mov    0x10(%eax),%eax
    6589:	83 ec 0c             	sub    $0xc,%esp
    658c:	50                   	push   %eax
    658d:	e8 fd ce ff ff       	call   348f <lodepng_free>
    6592:	83 c4 10             	add    $0x10,%esp
}
    6595:	90                   	nop
    6596:	c9                   	leave  
    6597:	c3                   	ret    

00006598 <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    6598:	55                   	push   %ebp
    6599:	89 e5                	mov    %esp,%ebp
    659b:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    659e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    65a5:	8b 45 10             	mov    0x10(%ebp),%eax
    65a8:	83 c0 02             	add    $0x2,%eax
    65ab:	3b 45 0c             	cmp    0xc(%ebp),%eax
    65ae:	7d 41                	jge    65f1 <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    65b0:	8b 55 10             	mov    0x10(%ebp),%edx
    65b3:	8b 45 08             	mov    0x8(%ebp),%eax
    65b6:	01 d0                	add    %edx,%eax
    65b8:	0f b6 00             	movzbl (%eax),%eax
    65bb:	0f b6 c0             	movzbl %al,%eax
    65be:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    65c1:	8b 45 10             	mov    0x10(%ebp),%eax
    65c4:	8d 50 01             	lea    0x1(%eax),%edx
    65c7:	8b 45 08             	mov    0x8(%ebp),%eax
    65ca:	01 d0                	add    %edx,%eax
    65cc:	0f b6 00             	movzbl (%eax),%eax
    65cf:	0f b6 c0             	movzbl %al,%eax
    65d2:	c1 e0 04             	shl    $0x4,%eax
    65d5:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    65d8:	8b 45 10             	mov    0x10(%ebp),%eax
    65db:	8d 50 02             	lea    0x2(%eax),%edx
    65de:	8b 45 08             	mov    0x8(%ebp),%eax
    65e1:	01 d0                	add    %edx,%eax
    65e3:	0f b6 00             	movzbl (%eax),%eax
    65e6:	0f b6 c0             	movzbl %al,%eax
    65e9:	c1 e0 08             	shl    $0x8,%eax
    65ec:	31 45 fc             	xor    %eax,-0x4(%ebp)
    65ef:	eb 51                	jmp    6642 <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    65f1:	8b 45 10             	mov    0x10(%ebp),%eax
    65f4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    65f7:	7c 07                	jl     6600 <getHash+0x68>
    65f9:	b8 00 00 00 00       	mov    $0x0,%eax
    65fe:	eb 4a                	jmp    664a <getHash+0xb2>
    amount = size - pos;
    6600:	8b 45 0c             	mov    0xc(%ebp),%eax
    6603:	2b 45 10             	sub    0x10(%ebp),%eax
    6606:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    6609:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6610:	eb 28                	jmp    663a <getHash+0xa2>
    6612:	8b 55 10             	mov    0x10(%ebp),%edx
    6615:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6618:	01 d0                	add    %edx,%eax
    661a:	89 c2                	mov    %eax,%edx
    661c:	8b 45 08             	mov    0x8(%ebp),%eax
    661f:	01 d0                	add    %edx,%eax
    6621:	0f b6 00             	movzbl (%eax),%eax
    6624:	0f b6 d0             	movzbl %al,%edx
    6627:	8b 45 f8             	mov    -0x8(%ebp),%eax
    662a:	c1 e0 03             	shl    $0x3,%eax
    662d:	89 c1                	mov    %eax,%ecx
    662f:	d3 e2                	shl    %cl,%edx
    6631:	89 d0                	mov    %edx,%eax
    6633:	31 45 fc             	xor    %eax,-0x4(%ebp)
    6636:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    663a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    663d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    6640:	75 d0                	jne    6612 <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    6642:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6647:	23 45 fc             	and    -0x4(%ebp),%eax
}
    664a:	c9                   	leave  
    664b:	c3                   	ret    

0000664c <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    664c:	55                   	push   %ebp
    664d:	89 e5                	mov    %esp,%ebp
    664f:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    6652:	8b 55 10             	mov    0x10(%ebp),%edx
    6655:	8b 45 08             	mov    0x8(%ebp),%eax
    6658:	01 d0                	add    %edx,%eax
    665a:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    665d:	b8 02 01 00 00       	mov    $0x102,%eax
    6662:	89 c2                	mov    %eax,%edx
    6664:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6667:	01 d0                	add    %edx,%eax
    6669:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    666c:	8b 55 0c             	mov    0xc(%ebp),%edx
    666f:	8b 45 08             	mov    0x8(%ebp),%eax
    6672:	01 d0                	add    %edx,%eax
    6674:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6677:	73 0b                	jae    6684 <countZeros+0x38>
    6679:	8b 55 0c             	mov    0xc(%ebp),%edx
    667c:	8b 45 08             	mov    0x8(%ebp),%eax
    667f:	01 d0                	add    %edx,%eax
    6681:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    6684:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6687:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    668a:	eb 04                	jmp    6690 <countZeros+0x44>
    668c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    6690:	8b 45 08             	mov    0x8(%ebp),%eax
    6693:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6696:	74 0a                	je     66a2 <countZeros+0x56>
    6698:	8b 45 08             	mov    0x8(%ebp),%eax
    669b:	0f b6 00             	movzbl (%eax),%eax
    669e:	84 c0                	test   %al,%al
    66a0:	74 ea                	je     668c <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    66a2:	8b 55 08             	mov    0x8(%ebp),%edx
    66a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    66a8:	29 c2                	sub    %eax,%edx
    66aa:	89 d0                	mov    %edx,%eax
}
    66ac:	c9                   	leave  
    66ad:	c3                   	ret    

000066ae <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    66ae:	55                   	push   %ebp
    66af:	89 e5                	mov    %esp,%ebp
    66b1:	83 ec 04             	sub    $0x4,%esp
    66b4:	8b 45 14             	mov    0x14(%ebp),%eax
    66b7:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    66bb:	8b 45 08             	mov    0x8(%ebp),%eax
    66be:	8b 40 08             	mov    0x8(%eax),%eax
    66c1:	8b 55 0c             	mov    0xc(%ebp),%edx
    66c4:	c1 e2 02             	shl    $0x2,%edx
    66c7:	01 c2                	add    %eax,%edx
    66c9:	8b 45 10             	mov    0x10(%ebp),%eax
    66cc:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    66ce:	8b 45 08             	mov    0x8(%ebp),%eax
    66d1:	8b 00                	mov    (%eax),%eax
    66d3:	8b 55 10             	mov    0x10(%ebp),%edx
    66d6:	c1 e2 02             	shl    $0x2,%edx
    66d9:	01 d0                	add    %edx,%eax
    66db:	8b 00                	mov    (%eax),%eax
    66dd:	83 f8 ff             	cmp    $0xffffffff,%eax
    66e0:	74 1f                	je     6701 <updateHashChain+0x53>
    66e2:	8b 45 08             	mov    0x8(%ebp),%eax
    66e5:	8b 40 04             	mov    0x4(%eax),%eax
    66e8:	8b 55 0c             	mov    0xc(%ebp),%edx
    66eb:	01 d2                	add    %edx,%edx
    66ed:	01 c2                	add    %eax,%edx
    66ef:	8b 45 08             	mov    0x8(%ebp),%eax
    66f2:	8b 00                	mov    (%eax),%eax
    66f4:	8b 4d 10             	mov    0x10(%ebp),%ecx
    66f7:	c1 e1 02             	shl    $0x2,%ecx
    66fa:	01 c8                	add    %ecx,%eax
    66fc:	8b 00                	mov    (%eax),%eax
    66fe:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    6701:	8b 45 08             	mov    0x8(%ebp),%eax
    6704:	8b 00                	mov    (%eax),%eax
    6706:	8b 55 10             	mov    0x10(%ebp),%edx
    6709:	c1 e2 02             	shl    $0x2,%edx
    670c:	01 c2                	add    %eax,%edx
    670e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6711:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    6713:	8b 45 08             	mov    0x8(%ebp),%eax
    6716:	8b 40 14             	mov    0x14(%eax),%eax
    6719:	8b 55 0c             	mov    0xc(%ebp),%edx
    671c:	01 d2                	add    %edx,%edx
    671e:	01 c2                	add    %eax,%edx
    6720:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    6724:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    6727:	8b 45 08             	mov    0x8(%ebp),%eax
    672a:	8b 40 0c             	mov    0xc(%eax),%eax
    672d:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    6731:	c1 e2 02             	shl    $0x2,%edx
    6734:	01 d0                	add    %edx,%eax
    6736:	8b 00                	mov    (%eax),%eax
    6738:	83 f8 ff             	cmp    $0xffffffff,%eax
    673b:	74 21                	je     675e <updateHashChain+0xb0>
    673d:	8b 45 08             	mov    0x8(%ebp),%eax
    6740:	8b 40 10             	mov    0x10(%eax),%eax
    6743:	8b 55 0c             	mov    0xc(%ebp),%edx
    6746:	01 d2                	add    %edx,%edx
    6748:	01 c2                	add    %eax,%edx
    674a:	8b 45 08             	mov    0x8(%ebp),%eax
    674d:	8b 40 0c             	mov    0xc(%eax),%eax
    6750:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    6754:	c1 e1 02             	shl    $0x2,%ecx
    6757:	01 c8                	add    %ecx,%eax
    6759:	8b 00                	mov    (%eax),%eax
    675b:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    675e:	8b 45 08             	mov    0x8(%ebp),%eax
    6761:	8b 40 0c             	mov    0xc(%eax),%eax
    6764:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    6768:	c1 e2 02             	shl    $0x2,%edx
    676b:	01 c2                	add    %eax,%edx
    676d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6770:	89 02                	mov    %eax,(%edx)
}
    6772:	90                   	nop
    6773:	c9                   	leave  
    6774:	c3                   	ret    

00006775 <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    6775:	55                   	push   %ebp
    6776:	89 e5                	mov    %esp,%ebp
    6778:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    677b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    6782:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6789:	77 08                	ja     6793 <encodeLZ77+0x1e>
    678b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    678e:	c1 e8 03             	shr    $0x3,%eax
    6791:	eb 03                	jmp    6796 <encodeLZ77+0x21>
    6793:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6796:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    6799:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    67a0:	76 07                	jbe    67a9 <encodeLZ77+0x34>
    67a2:	b8 02 01 00 00       	mov    $0x102,%eax
    67a7:	eb 05                	jmp    67ae <encodeLZ77+0x39>
    67a9:	b8 40 00 00 00       	mov    $0x40,%eax
    67ae:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    67b1:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    67b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    67bf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    67c6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    67cd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    67d4:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    67d8:	74 09                	je     67e3 <encodeLZ77+0x6e>
    67da:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    67e1:	76 0a                	jbe    67ed <encodeLZ77+0x78>
    67e3:	b8 3c 00 00 00       	mov    $0x3c,%eax
    67e8:	e9 e3 04 00 00       	jmp    6cd0 <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    67ed:	8b 45 1c             	mov    0x1c(%ebp),%eax
    67f0:	83 e8 01             	sub    $0x1,%eax
    67f3:	23 45 1c             	and    0x1c(%ebp),%eax
    67f6:	85 c0                	test   %eax,%eax
    67f8:	74 0a                	je     6804 <encodeLZ77+0x8f>
    67fa:	b8 5a 00 00 00       	mov    $0x5a,%eax
    67ff:	e9 cc 04 00 00       	jmp    6cd0 <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    6804:	b8 02 01 00 00       	mov    $0x102,%eax
    6809:	39 45 24             	cmp    %eax,0x24(%ebp)
    680c:	76 08                	jbe    6816 <encodeLZ77+0xa1>
    680e:	b8 02 01 00 00       	mov    $0x102,%eax
    6813:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    6816:	8b 45 14             	mov    0x14(%ebp),%eax
    6819:	89 45 fc             	mov    %eax,-0x4(%ebp)
    681c:	e9 a0 04 00 00       	jmp    6cc1 <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    6821:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6824:	8d 50 ff             	lea    -0x1(%eax),%edx
    6827:	8b 45 fc             	mov    -0x4(%ebp),%eax
    682a:	21 d0                	and    %edx,%eax
    682c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    682f:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    6836:	ff 75 fc             	pushl  -0x4(%ebp)
    6839:	ff 75 18             	pushl  0x18(%ebp)
    683c:	ff 75 10             	pushl  0x10(%ebp)
    683f:	e8 54 fd ff ff       	call   6598 <getHash>
    6844:	83 c4 0c             	add    $0xc,%esp
    6847:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    684a:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    684e:	74 4e                	je     689e <encodeLZ77+0x129>
    6850:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6854:	75 48                	jne    689e <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6856:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    685a:	75 16                	jne    6872 <encodeLZ77+0xfd>
    685c:	ff 75 fc             	pushl  -0x4(%ebp)
    685f:	ff 75 18             	pushl  0x18(%ebp)
    6862:	ff 75 10             	pushl  0x10(%ebp)
    6865:	e8 e2 fd ff ff       	call   664c <countZeros>
    686a:	83 c4 0c             	add    $0xc,%esp
    686d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6870:	eb 35                	jmp    68a7 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6872:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6875:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6878:	01 c2                	add    %eax,%edx
    687a:	8b 45 18             	mov    0x18(%ebp),%eax
    687d:	39 c2                	cmp    %eax,%edx
    687f:	77 17                	ja     6898 <encodeLZ77+0x123>
    6881:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6884:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6887:	01 d0                	add    %edx,%eax
    6889:	8d 50 ff             	lea    -0x1(%eax),%edx
    688c:	8b 45 10             	mov    0x10(%ebp),%eax
    688f:	01 d0                	add    %edx,%eax
    6891:	0f b6 00             	movzbl (%eax),%eax
    6894:	84 c0                	test   %al,%al
    6896:	74 0f                	je     68a7 <encodeLZ77+0x132>
    6898:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    689c:	eb 09                	jmp    68a7 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    689e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    68a5:	eb 01                	jmp    68a8 <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    68a7:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    68a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    68ab:	0f b7 c0             	movzwl %ax,%eax
    68ae:	50                   	push   %eax
    68af:	ff 75 b0             	pushl  -0x50(%ebp)
    68b2:	ff 75 b4             	pushl  -0x4c(%ebp)
    68b5:	ff 75 0c             	pushl  0xc(%ebp)
    68b8:	e8 f1 fd ff ff       	call   66ae <updateHashChain>
    68bd:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    68c0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    68c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    68ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    68d1:	8b 40 04             	mov    0x4(%eax),%eax
    68d4:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    68d7:	01 d2                	add    %edx,%edx
    68d9:	01 d0                	add    %edx,%eax
    68db:	0f b7 00             	movzwl (%eax),%eax
    68de:	0f b7 c0             	movzwl %ax,%eax
    68e1:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    68e4:	ba 02 01 00 00       	mov    $0x102,%edx
    68e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    68ec:	01 c2                	add    %eax,%edx
    68ee:	8b 45 18             	mov    0x18(%ebp),%eax
    68f1:	39 c2                	cmp    %eax,%edx
    68f3:	0f 4e c2             	cmovle %edx,%eax
    68f6:	89 c2                	mov    %eax,%edx
    68f8:	8b 45 10             	mov    0x10(%ebp),%eax
    68fb:	01 d0                	add    %edx,%eax
    68fd:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    6900:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6907:	8b 45 c8             	mov    -0x38(%ebp),%eax
    690a:	8d 50 01             	lea    0x1(%eax),%edx
    690d:	89 55 c8             	mov    %edx,-0x38(%ebp)
    6910:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    6913:	0f 83 67 01 00 00    	jae    6a80 <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    6919:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    691c:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    691f:	77 08                	ja     6929 <encodeLZ77+0x1b4>
    6921:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6924:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6927:	eb 0d                	jmp    6936 <encodeLZ77+0x1c1>
    6929:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    692c:	2b 45 cc             	sub    -0x34(%ebp),%eax
    692f:	89 c2                	mov    %eax,%edx
    6931:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6934:	01 d0                	add    %edx,%eax
    6936:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    6939:	8b 45 a8             	mov    -0x58(%ebp),%eax
    693c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    693f:	0f 82 3e 01 00 00    	jb     6a83 <encodeLZ77+0x30e>
      prev_offset = current_offset;
    6945:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6948:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    694b:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    694f:	0f 84 a3 00 00 00    	je     69f8 <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    6955:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6958:	8b 45 10             	mov    0x10(%ebp),%eax
    695b:	01 d0                	add    %edx,%eax
    695d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    6960:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6963:	2b 45 a8             	sub    -0x58(%ebp),%eax
    6966:	89 c2                	mov    %eax,%edx
    6968:	8b 45 10             	mov    0x10(%ebp),%eax
    696b:	01 d0                	add    %edx,%eax
    696d:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    6970:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6974:	76 3a                	jbe    69b0 <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    6976:	8b 45 0c             	mov    0xc(%ebp),%eax
    6979:	8b 40 14             	mov    0x14(%eax),%eax
    697c:	8b 55 cc             	mov    -0x34(%ebp),%edx
    697f:	01 d2                	add    %edx,%edx
    6981:	01 d0                	add    %edx,%eax
    6983:	0f b7 00             	movzwl (%eax),%eax
    6986:	0f b7 c0             	movzwl %ax,%eax
    6989:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    698c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    698f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6992:	76 06                	jbe    699a <encodeLZ77+0x225>
    6994:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6997:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    699a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    699d:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    69a0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    69a3:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    69a6:	eb 08                	jmp    69b0 <encodeLZ77+0x23b>
          ++backptr;
    69a8:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    69ac:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    69b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    69b3:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    69b6:	74 10                	je     69c8 <encodeLZ77+0x253>
    69b8:	8b 45 d0             	mov    -0x30(%ebp),%eax
    69bb:	0f b6 10             	movzbl (%eax),%edx
    69be:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    69c1:	0f b6 00             	movzbl (%eax),%eax
    69c4:	38 c2                	cmp    %al,%dl
    69c6:	74 e0                	je     69a8 <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    69c8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    69cb:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    69ce:	8b 55 10             	mov    0x10(%ebp),%edx
    69d1:	01 ca                	add    %ecx,%edx
    69d3:	29 d0                	sub    %edx,%eax
    69d5:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    69d8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    69db:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    69de:	76 18                	jbe    69f8 <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    69e0:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    69e3:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    69e6:	8b 45 a8             	mov    -0x58(%ebp),%eax
    69e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    69ec:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    69ef:	3b 45 24             	cmp    0x24(%ebp),%eax
    69f2:	0f 83 8e 00 00 00    	jae    6a86 <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    69f8:	8b 45 0c             	mov    0xc(%ebp),%eax
    69fb:	8b 40 04             	mov    0x4(%eax),%eax
    69fe:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6a01:	01 d2                	add    %edx,%edx
    6a03:	01 d0                	add    %edx,%eax
    6a05:	0f b7 00             	movzwl (%eax),%eax
    6a08:	0f b7 c0             	movzwl %ax,%eax
    6a0b:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    6a0e:	74 79                	je     6a89 <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    6a10:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6a14:	76 38                	jbe    6a4e <encodeLZ77+0x2d9>
    6a16:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6a19:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6a1c:	76 30                	jbe    6a4e <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    6a1e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a21:	8b 40 10             	mov    0x10(%eax),%eax
    6a24:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6a27:	01 d2                	add    %edx,%edx
    6a29:	01 d0                	add    %edx,%eax
    6a2b:	0f b7 00             	movzwl (%eax),%eax
    6a2e:	0f b7 c0             	movzwl %ax,%eax
    6a31:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    6a34:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a37:	8b 40 14             	mov    0x14(%eax),%eax
    6a3a:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6a3d:	01 d2                	add    %edx,%edx
    6a3f:	01 d0                	add    %edx,%eax
    6a41:	0f b7 00             	movzwl (%eax),%eax
    6a44:	0f b7 c0             	movzwl %ax,%eax
    6a47:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6a4a:	74 2f                	je     6a7b <encodeLZ77+0x306>
    6a4c:	eb 3f                	jmp    6a8d <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    6a4e:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a51:	8b 40 04             	mov    0x4(%eax),%eax
    6a54:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6a57:	01 d2                	add    %edx,%edx
    6a59:	01 d0                	add    %edx,%eax
    6a5b:	0f b7 00             	movzwl (%eax),%eax
    6a5e:	0f b7 c0             	movzwl %ax,%eax
    6a61:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6a64:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a67:	8b 40 08             	mov    0x8(%eax),%eax
    6a6a:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6a6d:	c1 e2 02             	shl    $0x2,%edx
    6a70:	01 d0                	add    %edx,%eax
    6a72:	8b 10                	mov    (%eax),%edx
    6a74:	8b 45 b0             	mov    -0x50(%ebp),%eax
    6a77:	39 c2                	cmp    %eax,%edx
    6a79:	75 11                	jne    6a8c <encodeLZ77+0x317>
      }
    }
    6a7b:	e9 87 fe ff ff       	jmp    6907 <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6a80:	90                   	nop
    6a81:	eb 0a                	jmp    6a8d <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    6a83:	90                   	nop
    6a84:	eb 07                	jmp    6a8d <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6a86:	90                   	nop
    6a87:	eb 04                	jmp    6a8d <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    6a89:	90                   	nop
    6a8a:	eb 01                	jmp    6a8d <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6a8c:	90                   	nop
      }
    }

    if(lazymatching) {
    6a8d:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    6a91:	0f 84 c8 00 00 00    	je     6b5f <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    6a97:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6a9b:	75 30                	jne    6acd <encodeLZ77+0x358>
    6a9d:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6aa1:	76 2a                	jbe    6acd <encodeLZ77+0x358>
    6aa3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6aa6:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    6aa9:	77 22                	ja     6acd <encodeLZ77+0x358>
    6aab:	b8 02 01 00 00       	mov    $0x102,%eax
    6ab0:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6ab3:	73 18                	jae    6acd <encodeLZ77+0x358>
        lazy = 1;
    6ab5:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    6abc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6abf:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    6ac2:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6ac5:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    6ac8:	e9 f0 01 00 00       	jmp    6cbd <encodeLZ77+0x548>
      }
      if(lazy) {
    6acd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6ad1:	0f 84 88 00 00 00    	je     6b5f <encodeLZ77+0x3ea>
        lazy = 0;
    6ad7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    6ade:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    6ae2:	75 0c                	jne    6af0 <encodeLZ77+0x37b>
    6ae4:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    6aeb:	e9 dd 01 00 00       	jmp    6ccd <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    6af0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6af3:	83 c0 01             	add    $0x1,%eax
    6af6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6af9:	73 2d                	jae    6b28 <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    6afb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6afe:	8d 50 ff             	lea    -0x1(%eax),%edx
    6b01:	8b 45 10             	mov    0x10(%ebp),%eax
    6b04:	01 d0                	add    %edx,%eax
    6b06:	0f b6 00             	movzbl (%eax),%eax
    6b09:	0f b6 c0             	movzbl %al,%eax
    6b0c:	50                   	push   %eax
    6b0d:	ff 75 08             	pushl  0x8(%ebp)
    6b10:	e8 6f cb ff ff       	call   3684 <uivector_push_back>
    6b15:	83 c4 08             	add    $0x8,%esp
    6b18:	85 c0                	test   %eax,%eax
    6b1a:	75 43                	jne    6b5f <encodeLZ77+0x3ea>
    6b1c:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6b23:	e9 a5 01 00 00       	jmp    6ccd <encodeLZ77+0x558>
        } else {
          length = lazylength;
    6b28:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6b2b:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    6b2e:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6b31:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    6b34:	8b 45 0c             	mov    0xc(%ebp),%eax
    6b37:	8b 00                	mov    (%eax),%eax
    6b39:	8b 55 b0             	mov    -0x50(%ebp),%edx
    6b3c:	c1 e2 02             	shl    $0x2,%edx
    6b3f:	01 d0                	add    %edx,%eax
    6b41:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    6b47:	8b 45 0c             	mov    0xc(%ebp),%eax
    6b4a:	8b 40 0c             	mov    0xc(%eax),%eax
    6b4d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6b50:	c1 e2 02             	shl    $0x2,%edx
    6b53:	01 d0                	add    %edx,%eax
    6b55:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    6b5b:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    6b5f:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6b63:	76 14                	jbe    6b79 <encodeLZ77+0x404>
    6b65:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6b68:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    6b6b:	76 0c                	jbe    6b79 <encodeLZ77+0x404>
    6b6d:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    6b74:	e9 54 01 00 00       	jmp    6ccd <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    6b79:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6b7d:	77 2e                	ja     6bad <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6b7f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6b82:	8b 45 10             	mov    0x10(%ebp),%eax
    6b85:	01 d0                	add    %edx,%eax
    6b87:	0f b6 00             	movzbl (%eax),%eax
    6b8a:	0f b6 c0             	movzbl %al,%eax
    6b8d:	50                   	push   %eax
    6b8e:	ff 75 08             	pushl  0x8(%ebp)
    6b91:	e8 ee ca ff ff       	call   3684 <uivector_push_back>
    6b96:	83 c4 08             	add    $0x8,%esp
    6b99:	85 c0                	test   %eax,%eax
    6b9b:	0f 85 1c 01 00 00    	jne    6cbd <encodeLZ77+0x548>
    6ba1:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6ba8:	e9 20 01 00 00       	jmp    6ccd <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    6bad:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6bb0:	3b 45 20             	cmp    0x20(%ebp),%eax
    6bb3:	72 0f                	jb     6bc4 <encodeLZ77+0x44f>
    6bb5:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    6bb9:	75 37                	jne    6bf2 <encodeLZ77+0x47d>
    6bbb:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    6bc2:	76 2e                	jbe    6bf2 <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6bc4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6bc7:	8b 45 10             	mov    0x10(%ebp),%eax
    6bca:	01 d0                	add    %edx,%eax
    6bcc:	0f b6 00             	movzbl (%eax),%eax
    6bcf:	0f b6 c0             	movzbl %al,%eax
    6bd2:	50                   	push   %eax
    6bd3:	ff 75 08             	pushl  0x8(%ebp)
    6bd6:	e8 a9 ca ff ff       	call   3684 <uivector_push_back>
    6bdb:	83 c4 08             	add    $0x8,%esp
    6bde:	85 c0                	test   %eax,%eax
    6be0:	0f 85 d7 00 00 00    	jne    6cbd <encodeLZ77+0x548>
    6be6:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6bed:	e9 db 00 00 00       	jmp    6ccd <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    6bf2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6bf5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6bf8:	52                   	push   %edx
    6bf9:	50                   	push   %eax
    6bfa:	ff 75 08             	pushl  0x8(%ebp)
    6bfd:	e8 8a f6 ff ff       	call   628c <addLengthDistance>
    6c02:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    6c05:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    6c0c:	e9 a0 00 00 00       	jmp    6cb1 <encodeLZ77+0x53c>
        ++pos;
    6c11:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    6c15:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6c18:	8d 50 ff             	lea    -0x1(%eax),%edx
    6c1b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6c1e:	21 d0                	and    %edx,%eax
    6c20:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    6c23:	ff 75 fc             	pushl  -0x4(%ebp)
    6c26:	ff 75 18             	pushl  0x18(%ebp)
    6c29:	ff 75 10             	pushl  0x10(%ebp)
    6c2c:	e8 67 f9 ff ff       	call   6598 <getHash>
    6c31:	83 c4 0c             	add    $0xc,%esp
    6c34:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    6c37:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6c3b:	74 4e                	je     6c8b <encodeLZ77+0x516>
    6c3d:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6c41:	75 48                	jne    6c8b <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6c43:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6c47:	75 16                	jne    6c5f <encodeLZ77+0x4ea>
    6c49:	ff 75 fc             	pushl  -0x4(%ebp)
    6c4c:	ff 75 18             	pushl  0x18(%ebp)
    6c4f:	ff 75 10             	pushl  0x10(%ebp)
    6c52:	e8 f5 f9 ff ff       	call   664c <countZeros>
    6c57:	83 c4 0c             	add    $0xc,%esp
    6c5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6c5d:	eb 35                	jmp    6c94 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6c5f:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6c62:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c65:	01 c2                	add    %eax,%edx
    6c67:	8b 45 18             	mov    0x18(%ebp),%eax
    6c6a:	39 c2                	cmp    %eax,%edx
    6c6c:	77 17                	ja     6c85 <encodeLZ77+0x510>
    6c6e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6c71:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c74:	01 d0                	add    %edx,%eax
    6c76:	8d 50 ff             	lea    -0x1(%eax),%edx
    6c79:	8b 45 10             	mov    0x10(%ebp),%eax
    6c7c:	01 d0                	add    %edx,%eax
    6c7e:	0f b6 00             	movzbl (%eax),%eax
    6c81:	84 c0                	test   %al,%al
    6c83:	74 0f                	je     6c94 <encodeLZ77+0x51f>
    6c85:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6c89:	eb 09                	jmp    6c94 <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    6c8b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6c92:	eb 01                	jmp    6c95 <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6c94:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    6c95:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6c98:	0f b7 c0             	movzwl %ax,%eax
    6c9b:	50                   	push   %eax
    6c9c:	ff 75 b0             	pushl  -0x50(%ebp)
    6c9f:	ff 75 b4             	pushl  -0x4c(%ebp)
    6ca2:	ff 75 0c             	pushl  0xc(%ebp)
    6ca5:	e8 04 fa ff ff       	call   66ae <updateHashChain>
    6caa:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    6cad:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6cb1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6cb4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6cb7:	0f 82 54 ff ff ff    	jb     6c11 <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    6cbd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6cc1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6cc4:	3b 45 18             	cmp    0x18(%ebp),%eax
    6cc7:	0f 8c 54 fb ff ff    	jl     6821 <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    6ccd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6cd0:	c9                   	leave  
    6cd1:	c3                   	ret    

00006cd2 <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    6cd2:	55                   	push   %ebp
    6cd3:	89 e5                	mov    %esp,%ebp
    6cd5:	53                   	push   %ebx
    6cd6:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    6cd9:	8b 45 10             	mov    0x10(%ebp),%eax
    6cdc:	05 fe ff 00 00       	add    $0xfffe,%eax
    6ce1:	ba 01 80 00 80       	mov    $0x80008001,%edx
    6ce6:	f7 e2                	mul    %edx
    6ce8:	89 d0                	mov    %edx,%eax
    6cea:	c1 e8 0f             	shr    $0xf,%eax
    6ced:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    6cf0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    6cf7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6cfe:	e9 1b 01 00 00       	jmp    6e1e <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    6d03:	8b 45 08             	mov    0x8(%ebp),%eax
    6d06:	8b 40 04             	mov    0x4(%eax),%eax
    6d09:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    6d0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6d0f:	83 e8 01             	sub    $0x1,%eax
    6d12:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6d15:	0f 94 c0             	sete   %al
    6d18:	0f b6 c0             	movzbl %al,%eax
    6d1b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    6d1e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    6d25:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    6d2c:	8b 45 10             	mov    0x10(%ebp),%eax
    6d2f:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6d32:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    6d37:	77 09                	ja     6d42 <deflateNoCompression+0x70>
    6d39:	8b 45 10             	mov    0x10(%ebp),%eax
    6d3c:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6d3f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    6d42:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6d47:	2b 45 f0             	sub    -0x10(%ebp),%eax
    6d4a:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    6d4d:	8b 45 08             	mov    0x8(%ebp),%eax
    6d50:	8b 40 04             	mov    0x4(%eax),%eax
    6d53:	89 c2                	mov    %eax,%edx
    6d55:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6d58:	01 d0                	add    %edx,%eax
    6d5a:	83 c0 05             	add    $0x5,%eax
    6d5d:	50                   	push   %eax
    6d5e:	ff 75 08             	pushl  0x8(%ebp)
    6d61:	e8 62 c9 ff ff       	call   36c8 <ucvector_resize>
    6d66:	83 c4 08             	add    $0x8,%esp
    6d69:	85 c0                	test   %eax,%eax
    6d6b:	75 0a                	jne    6d77 <deflateNoCompression+0xa5>
    6d6d:	b8 53 00 00 00       	mov    $0x53,%eax
    6d72:	e9 b8 00 00 00       	jmp    6e2f <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    6d77:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6d7a:	89 c2                	mov    %eax,%edx
    6d7c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6d7f:	83 e0 01             	and    $0x1,%eax
    6d82:	01 c0                	add    %eax,%eax
    6d84:	01 c2                	add    %eax,%edx
    6d86:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6d89:	83 e0 02             	and    $0x2,%eax
    6d8c:	01 c0                	add    %eax,%eax
    6d8e:	01 d0                	add    %edx,%eax
    6d90:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    6d93:	8b 45 08             	mov    0x8(%ebp),%eax
    6d96:	8b 10                	mov    (%eax),%edx
    6d98:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6d9b:	01 c2                	add    %eax,%edx
    6d9d:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    6da1:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    6da3:	8b 45 08             	mov    0x8(%ebp),%eax
    6da6:	8b 00                	mov    (%eax),%eax
    6da8:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6dab:	83 c2 01             	add    $0x1,%edx
    6dae:	01 d0                	add    %edx,%eax
    6db0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6db3:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    6db5:	8b 45 08             	mov    0x8(%ebp),%eax
    6db8:	8b 00                	mov    (%eax),%eax
    6dba:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6dbd:	83 c2 02             	add    $0x2,%edx
    6dc0:	01 d0                	add    %edx,%eax
    6dc2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6dc5:	c1 ea 08             	shr    $0x8,%edx
    6dc8:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    6dca:	8b 45 08             	mov    0x8(%ebp),%eax
    6dcd:	8b 00                	mov    (%eax),%eax
    6dcf:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6dd2:	83 c2 03             	add    $0x3,%edx
    6dd5:	01 d0                	add    %edx,%eax
    6dd7:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6dda:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    6ddc:	8b 45 08             	mov    0x8(%ebp),%eax
    6ddf:	8b 00                	mov    (%eax),%eax
    6de1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6de4:	83 c2 04             	add    $0x4,%edx
    6de7:	01 d0                	add    %edx,%eax
    6de9:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6dec:	c1 ea 08             	shr    $0x8,%edx
    6def:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    6df1:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6df4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    6df7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6dfa:	01 d1                	add    %edx,%ecx
    6dfc:	8b 55 08             	mov    0x8(%ebp),%edx
    6dff:	8b 12                	mov    (%edx),%edx
    6e01:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6e04:	83 c3 05             	add    $0x5,%ebx
    6e07:	01 da                	add    %ebx,%edx
    6e09:	50                   	push   %eax
    6e0a:	51                   	push   %ecx
    6e0b:	52                   	push   %edx
    6e0c:	e8 9b c6 ff ff       	call   34ac <lodepng_memcpy>
    6e11:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    6e14:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6e17:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    6e1a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6e1e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6e21:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6e24:	0f 85 d9 fe ff ff    	jne    6d03 <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    6e2a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6e2f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6e32:	c9                   	leave  
    6e33:	c3                   	ret    

00006e34 <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    6e34:	55                   	push   %ebp
    6e35:	89 e5                	mov    %esp,%ebp
    6e37:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    6e3a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    6e41:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    6e48:	e9 10 01 00 00       	jmp    6f5d <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    6e4d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6e50:	8b 00                	mov    (%eax),%eax
    6e52:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6e55:	c1 e2 02             	shl    $0x2,%edx
    6e58:	01 d0                	add    %edx,%eax
    6e5a:	8b 00                	mov    (%eax),%eax
    6e5c:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    6e5f:	8b 45 10             	mov    0x10(%ebp),%eax
    6e62:	8b 40 04             	mov    0x4(%eax),%eax
    6e65:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6e68:	c1 e2 02             	shl    $0x2,%edx
    6e6b:	01 d0                	add    %edx,%eax
    6e6d:	8b 00                	mov    (%eax),%eax
    6e6f:	89 c1                	mov    %eax,%ecx
    6e71:	8b 45 10             	mov    0x10(%ebp),%eax
    6e74:	8b 00                	mov    (%eax),%eax
    6e76:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6e79:	c1 e2 02             	shl    $0x2,%edx
    6e7c:	01 d0                	add    %edx,%eax
    6e7e:	8b 00                	mov    (%eax),%eax
    6e80:	51                   	push   %ecx
    6e81:	50                   	push   %eax
    6e82:	ff 75 08             	pushl  0x8(%ebp)
    6e85:	e8 60 cc ff ff       	call   3aea <writeBitsReversed>
    6e8a:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    6e8d:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    6e94:	0f 86 bf 00 00 00    	jbe    6f59 <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    6e9a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6e9d:	2d 01 01 00 00       	sub    $0x101,%eax
    6ea2:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    6ea5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6ea8:	8b 04 85 00 9f 01 00 	mov    0x19f00(,%eax,4),%eax
    6eaf:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    6eb2:	8b 45 0c             	mov    0xc(%ebp),%eax
    6eb5:	8b 00                	mov    (%eax),%eax
    6eb7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6ebb:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6ebe:	c1 e2 02             	shl    $0x2,%edx
    6ec1:	01 d0                	add    %edx,%eax
    6ec3:	8b 00                	mov    (%eax),%eax
    6ec5:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    6ec8:	8b 45 0c             	mov    0xc(%ebp),%eax
    6ecb:	8b 00                	mov    (%eax),%eax
    6ecd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6ed1:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6ed4:	c1 e2 02             	shl    $0x2,%edx
    6ed7:	01 d0                	add    %edx,%eax
    6ed9:	8b 00                	mov    (%eax),%eax
    6edb:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    6ede:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6ee1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    6ee4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6ee7:	8b 04 85 00 a0 01 00 	mov    0x1a000(,%eax,4),%eax
    6eee:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    6ef1:	8b 45 0c             	mov    0xc(%ebp),%eax
    6ef4:	8b 00                	mov    (%eax),%eax
    6ef6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6efa:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6efd:	c1 e2 02             	shl    $0x2,%edx
    6f00:	01 d0                	add    %edx,%eax
    6f02:	8b 00                	mov    (%eax),%eax
    6f04:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    6f07:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6f0a:	50                   	push   %eax
    6f0b:	ff 75 ec             	pushl  -0x14(%ebp)
    6f0e:	ff 75 08             	pushl  0x8(%ebp)
    6f11:	e8 40 ca ff ff       	call   3956 <writeBits>
    6f16:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    6f19:	8b 45 14             	mov    0x14(%ebp),%eax
    6f1c:	8b 40 04             	mov    0x4(%eax),%eax
    6f1f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6f22:	c1 e2 02             	shl    $0x2,%edx
    6f25:	01 d0                	add    %edx,%eax
    6f27:	8b 00                	mov    (%eax),%eax
    6f29:	89 c1                	mov    %eax,%ecx
    6f2b:	8b 45 14             	mov    0x14(%ebp),%eax
    6f2e:	8b 00                	mov    (%eax),%eax
    6f30:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6f33:	c1 e2 02             	shl    $0x2,%edx
    6f36:	01 d0                	add    %edx,%eax
    6f38:	8b 00                	mov    (%eax),%eax
    6f3a:	51                   	push   %ecx
    6f3b:	50                   	push   %eax
    6f3c:	ff 75 08             	pushl  0x8(%ebp)
    6f3f:	e8 a6 cb ff ff       	call   3aea <writeBitsReversed>
    6f44:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    6f47:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6f4a:	50                   	push   %eax
    6f4b:	ff 75 dc             	pushl  -0x24(%ebp)
    6f4e:	ff 75 08             	pushl  0x8(%ebp)
    6f51:	e8 00 ca ff ff       	call   3956 <writeBits>
    6f56:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    6f59:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6f5d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6f60:	8b 40 04             	mov    0x4(%eax),%eax
    6f63:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    6f66:	0f 85 e1 fe ff ff    	jne    6e4d <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    6f6c:	90                   	nop
    6f6d:	c9                   	leave  
    6f6e:	c3                   	ret    

00006f6f <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    6f6f:	55                   	push   %ebp
    6f70:	89 e5                	mov    %esp,%ebp
    6f72:	53                   	push   %ebx
    6f73:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    6f79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    6f80:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    6f87:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    6f8e:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    6f95:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    6f9c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    6fa3:	8b 45 18             	mov    0x18(%ebp),%eax
    6fa6:	2b 45 14             	sub    0x14(%ebp),%eax
    6fa9:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    6fac:	8b 45 20             	mov    0x20(%ebp),%eax
    6faf:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    6fb2:	8d 45 90             	lea    -0x70(%ebp),%eax
    6fb5:	50                   	push   %eax
    6fb6:	e8 a4 c6 ff ff       	call   365f <uivector_init>
    6fbb:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    6fbe:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    6fc4:	50                   	push   %eax
    6fc5:	e8 98 d3 ff ff       	call   4362 <HuffmanTree_init>
    6fca:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    6fcd:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    6fd3:	50                   	push   %eax
    6fd4:	e8 89 d3 ff ff       	call   4362 <HuffmanTree_init>
    6fd9:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    6fdc:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    6fe2:	50                   	push   %eax
    6fe3:	e8 7a d3 ff ff       	call   4362 <HuffmanTree_init>
    6fe8:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    6feb:	83 ec 0c             	sub    $0xc,%esp
    6fee:	68 78 04 00 00       	push   $0x478
    6ff3:	e8 76 c4 ff ff       	call   346e <lodepng_malloc>
    6ff8:	83 c4 10             	add    $0x10,%esp
    6ffb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    6ffe:	83 ec 0c             	sub    $0xc,%esp
    7001:	6a 78                	push   $0x78
    7003:	e8 66 c4 ff ff       	call   346e <lodepng_malloc>
    7008:	83 c4 10             	add    $0x10,%esp
    700b:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    700e:	83 ec 0c             	sub    $0xc,%esp
    7011:	6a 4c                	push   $0x4c
    7013:	e8 56 c4 ff ff       	call   346e <lodepng_malloc>
    7018:	83 c4 10             	add    $0x10,%esp
    701b:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    701e:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    7022:	74 0c                	je     7030 <deflateDynamic+0xc1>
    7024:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    7028:	74 06                	je     7030 <deflateDynamic+0xc1>
    702a:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    702e:	75 07                	jne    7037 <deflateDynamic+0xc8>
    7030:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    7037:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    703b:	0f 85 f6 07 00 00    	jne    7837 <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    7041:	83 ec 04             	sub    $0x4,%esp
    7044:	68 78 04 00 00       	push   $0x478
    7049:	6a 00                	push   $0x0
    704b:	ff 75 d4             	pushl  -0x2c(%ebp)
    704e:	e8 8c c4 ff ff       	call   34df <lodepng_memset>
    7053:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    7056:	83 ec 04             	sub    $0x4,%esp
    7059:	6a 78                	push   $0x78
    705b:	6a 00                	push   $0x0
    705d:	ff 75 d0             	pushl  -0x30(%ebp)
    7060:	e8 7a c4 ff ff       	call   34df <lodepng_memset>
    7065:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    7068:	83 ec 04             	sub    $0x4,%esp
    706b:	6a 4c                	push   $0x4c
    706d:	6a 00                	push   $0x0
    706f:	ff 75 cc             	pushl  -0x34(%ebp)
    7072:	e8 68 c4 ff ff       	call   34df <lodepng_memset>
    7077:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    707a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    707d:	8b 40 04             	mov    0x4(%eax),%eax
    7080:	85 c0                	test   %eax,%eax
    7082:	74 45                	je     70c9 <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    7084:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7087:	8b 58 14             	mov    0x14(%eax),%ebx
    708a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    708d:	8b 48 10             	mov    0x10(%eax),%ecx
    7090:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7093:	8b 50 0c             	mov    0xc(%eax),%edx
    7096:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7099:	8b 40 08             	mov    0x8(%eax),%eax
    709c:	83 ec 0c             	sub    $0xc,%esp
    709f:	53                   	push   %ebx
    70a0:	51                   	push   %ecx
    70a1:	52                   	push   %edx
    70a2:	50                   	push   %eax
    70a3:	ff 75 18             	pushl  0x18(%ebp)
    70a6:	ff 75 14             	pushl  0x14(%ebp)
    70a9:	ff 75 10             	pushl  0x10(%ebp)
    70ac:	ff 75 0c             	pushl  0xc(%ebp)
    70af:	8d 45 90             	lea    -0x70(%ebp),%eax
    70b2:	50                   	push   %eax
    70b3:	e8 bd f6 ff ff       	call   6775 <encodeLZ77>
    70b8:	83 c4 30             	add    $0x30,%esp
    70bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    70be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    70c2:	74 59                	je     711d <deflateDynamic+0x1ae>
    70c4:	e9 6e 07 00 00       	jmp    7837 <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    70c9:	83 ec 08             	sub    $0x8,%esp
    70cc:	ff 75 c8             	pushl  -0x38(%ebp)
    70cf:	8d 45 90             	lea    -0x70(%ebp),%eax
    70d2:	50                   	push   %eax
    70d3:	e8 17 c5 ff ff       	call   35ef <uivector_resize>
    70d8:	83 c4 10             	add    $0x10,%esp
    70db:	85 c0                	test   %eax,%eax
    70dd:	75 0c                	jne    70eb <deflateDynamic+0x17c>
    70df:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    70e6:	e9 4c 07 00 00       	jmp    7837 <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    70eb:	8b 45 14             	mov    0x14(%ebp),%eax
    70ee:	89 45 e8             	mov    %eax,-0x18(%ebp)
    70f1:	eb 22                	jmp    7115 <deflateDynamic+0x1a6>
    70f3:	8b 55 90             	mov    -0x70(%ebp),%edx
    70f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    70f9:	2b 45 14             	sub    0x14(%ebp),%eax
    70fc:	c1 e0 02             	shl    $0x2,%eax
    70ff:	01 c2                	add    %eax,%edx
    7101:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7104:	8b 45 10             	mov    0x10(%ebp),%eax
    7107:	01 c8                	add    %ecx,%eax
    7109:	0f b6 00             	movzbl (%eax),%eax
    710c:	0f b6 c0             	movzbl %al,%eax
    710f:	89 02                	mov    %eax,(%edx)
    7111:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7115:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7118:	3b 45 18             	cmp    0x18(%ebp),%eax
    711b:	7c d6                	jl     70f3 <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    711d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7124:	eb 60                	jmp    7186 <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    7126:	8b 45 90             	mov    -0x70(%ebp),%eax
    7129:	8b 55 e8             	mov    -0x18(%ebp),%edx
    712c:	c1 e2 02             	shl    $0x2,%edx
    712f:	01 d0                	add    %edx,%eax
    7131:	8b 00                	mov    (%eax),%eax
    7133:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    7136:	8b 45 c0             	mov    -0x40(%ebp),%eax
    7139:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7140:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7143:	01 d0                	add    %edx,%eax
    7145:	8b 10                	mov    (%eax),%edx
    7147:	83 c2 01             	add    $0x1,%edx
    714a:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    714c:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    7153:	76 2d                	jbe    7182 <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    7155:	8b 45 90             	mov    -0x70(%ebp),%eax
    7158:	8b 55 e8             	mov    -0x18(%ebp),%edx
    715b:	83 c2 02             	add    $0x2,%edx
    715e:	c1 e2 02             	shl    $0x2,%edx
    7161:	01 d0                	add    %edx,%eax
    7163:	8b 00                	mov    (%eax),%eax
    7165:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    7168:	8b 45 bc             	mov    -0x44(%ebp),%eax
    716b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7172:	8b 45 d0             	mov    -0x30(%ebp),%eax
    7175:	01 d0                	add    %edx,%eax
    7177:	8b 10                	mov    (%eax),%edx
    7179:	83 c2 01             	add    $0x1,%edx
    717c:	89 10                	mov    %edx,(%eax)
        i += 3;
    717e:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    7182:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7186:	8b 45 94             	mov    -0x6c(%ebp),%eax
    7189:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    718c:	75 98                	jne    7126 <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    718e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7191:	05 00 04 00 00       	add    $0x400,%eax
    7196:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    719c:	83 ec 0c             	sub    $0xc,%esp
    719f:	6a 0f                	push   $0xf
    71a1:	68 1e 01 00 00       	push   $0x11e
    71a6:	68 01 01 00 00       	push   $0x101
    71ab:	ff 75 d4             	pushl  -0x2c(%ebp)
    71ae:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    71b4:	50                   	push   %eax
    71b5:	e8 e0 e1 ff ff       	call   539a <HuffmanTree_makeFromFrequencies>
    71ba:	83 c4 20             	add    $0x20,%esp
    71bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    71c0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    71c4:	0f 85 66 06 00 00    	jne    7830 <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    71ca:	83 ec 0c             	sub    $0xc,%esp
    71cd:	6a 0f                	push   $0xf
    71cf:	6a 1e                	push   $0x1e
    71d1:	6a 02                	push   $0x2
    71d3:	ff 75 d0             	pushl  -0x30(%ebp)
    71d6:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    71dc:	50                   	push   %eax
    71dd:	e8 b8 e1 ff ff       	call   539a <HuffmanTree_makeFromFrequencies>
    71e2:	83 c4 20             	add    $0x20,%esp
    71e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    71e8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    71ec:	0f 85 41 06 00 00    	jne    7833 <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    71f2:	8b 45 84             	mov    -0x7c(%ebp),%eax
    71f5:	ba 1e 01 00 00       	mov    $0x11e,%edx
    71fa:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    71ff:	0f 47 c2             	cmova  %edx,%eax
    7202:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    7205:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    720b:	ba 1e 00 00 00       	mov    $0x1e,%edx
    7210:	83 f8 1e             	cmp    $0x1e,%eax
    7213:	0f 47 c2             	cmova  %edx,%eax
    7216:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    7219:	8b 55 b8             	mov    -0x48(%ebp),%edx
    721c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    721f:	01 d0                	add    %edx,%eax
    7221:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    7224:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7227:	c1 e0 02             	shl    $0x2,%eax
    722a:	83 ec 0c             	sub    $0xc,%esp
    722d:	50                   	push   %eax
    722e:	e8 3b c2 ff ff       	call   346e <lodepng_malloc>
    7233:	83 c4 10             	add    $0x10,%esp
    7236:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    7239:	8b 45 b0             	mov    -0x50(%ebp),%eax
    723c:	c1 e0 02             	shl    $0x2,%eax
    723f:	83 ec 0c             	sub    $0xc,%esp
    7242:	50                   	push   %eax
    7243:	e8 26 c2 ff ff       	call   346e <lodepng_malloc>
    7248:	83 c4 10             	add    $0x10,%esp
    724b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    724e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    7252:	74 06                	je     725a <deflateDynamic+0x2eb>
    7254:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    7258:	75 0c                	jne    7266 <deflateDynamic+0x2f7>
    725a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    7261:	e9 d1 05 00 00       	jmp    7837 <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    7266:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    726d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7274:	eb 25                	jmp    729b <deflateDynamic+0x32c>
    7276:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7279:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7280:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7283:	01 c2                	add    %eax,%edx
    7285:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    728b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    728e:	c1 e1 02             	shl    $0x2,%ecx
    7291:	01 c8                	add    %ecx,%eax
    7293:	8b 00                	mov    (%eax),%eax
    7295:	89 02                	mov    %eax,(%edx)
    7297:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    729b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    729e:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    72a1:	75 d3                	jne    7276 <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    72a3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    72aa:	eb 2a                	jmp    72d6 <deflateDynamic+0x367>
    72ac:	8b 55 b8             	mov    -0x48(%ebp),%edx
    72af:	8b 45 e8             	mov    -0x18(%ebp),%eax
    72b2:	01 d0                	add    %edx,%eax
    72b4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    72be:	01 c2                	add    %eax,%edx
    72c0:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    72c6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    72c9:	c1 e1 02             	shl    $0x2,%ecx
    72cc:	01 c8                	add    %ecx,%eax
    72ce:	8b 00                	mov    (%eax),%eax
    72d0:	89 02                	mov    %eax,(%edx)
    72d2:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    72d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    72d9:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    72dc:	75 ce                	jne    72ac <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    72de:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    72e5:	e9 3b 02 00 00       	jmp    7525 <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    72ea:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    72f1:	eb 04                	jmp    72f7 <deflateDynamic+0x388>
    72f3:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    72f7:	8b 55 e8             	mov    -0x18(%ebp),%edx
    72fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
    72fd:	01 d0                	add    %edx,%eax
    72ff:	8d 50 01             	lea    0x1(%eax),%edx
    7302:	8b 45 b0             	mov    -0x50(%ebp),%eax
    7305:	39 c2                	cmp    %eax,%edx
    7307:	73 2e                	jae    7337 <deflateDynamic+0x3c8>
    7309:	8b 55 e8             	mov    -0x18(%ebp),%edx
    730c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    730f:	01 d0                	add    %edx,%eax
    7311:	83 c0 01             	add    $0x1,%eax
    7314:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    731b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    731e:	01 d0                	add    %edx,%eax
    7320:	8b 10                	mov    (%eax),%edx
    7322:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7325:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    732c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    732f:	01 c8                	add    %ecx,%eax
    7331:	8b 00                	mov    (%eax),%eax
    7333:	39 c2                	cmp    %eax,%edx
    7335:	74 bc                	je     72f3 <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    7337:	8b 45 e8             	mov    -0x18(%ebp),%eax
    733a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7341:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7344:	01 d0                	add    %edx,%eax
    7346:	8b 00                	mov    (%eax),%eax
    7348:	85 c0                	test   %eax,%eax
    734a:	0f 85 a9 00 00 00    	jne    73f9 <deflateDynamic+0x48a>
    7350:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    7354:	0f 86 9f 00 00 00    	jbe    73f9 <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    735a:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    735e:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    7362:	77 3a                	ja     739e <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    7364:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7367:	8d 50 01             	lea    0x1(%eax),%edx
    736a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    736d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7374:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7377:	01 d0                	add    %edx,%eax
    7379:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    737f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7382:	8d 50 01             	lea    0x1(%eax),%edx
    7385:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7388:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    738f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7392:	01 d0                	add    %edx,%eax
    7394:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7397:	83 ea 03             	sub    $0x3,%edx
    739a:	89 10                	mov    %edx,(%eax)
    739c:	eb 48                	jmp    73e6 <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    739e:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    73a5:	76 07                	jbe    73ae <deflateDynamic+0x43f>
    73a7:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    73ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73b1:	8d 50 01             	lea    0x1(%eax),%edx
    73b4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    73b7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73be:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73c1:	01 d0                	add    %edx,%eax
    73c3:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    73c9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    73cc:	8d 50 01             	lea    0x1(%eax),%edx
    73cf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    73d2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    73dc:	01 d0                	add    %edx,%eax
    73de:	8b 55 dc             	mov    -0x24(%ebp),%edx
    73e1:	83 ea 0b             	sub    $0xb,%edx
    73e4:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    73e6:	8b 55 e8             	mov    -0x18(%ebp),%edx
    73e9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    73ec:	01 d0                	add    %edx,%eax
    73ee:	83 e8 01             	sub    $0x1,%eax
    73f1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    73f4:	e9 28 01 00 00       	jmp    7521 <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    73f9:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    73fd:	0f 86 f6 00 00 00    	jbe    74f9 <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    7403:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7406:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    740b:	f7 e2                	mul    %edx
    740d:	89 d0                	mov    %edx,%eax
    740f:	c1 e8 02             	shr    $0x2,%eax
    7412:	89 45 ac             	mov    %eax,-0x54(%ebp)
    7415:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7418:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    741d:	89 c8                	mov    %ecx,%eax
    741f:	f7 e2                	mul    %edx
    7421:	c1 ea 02             	shr    $0x2,%edx
    7424:	89 d0                	mov    %edx,%eax
    7426:	01 c0                	add    %eax,%eax
    7428:	01 d0                	add    %edx,%eax
    742a:	01 c0                	add    %eax,%eax
    742c:	29 c1                	sub    %eax,%ecx
    742e:	89 c8                	mov    %ecx,%eax
    7430:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    7433:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7436:	8d 50 01             	lea    0x1(%eax),%edx
    7439:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    743c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7443:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7446:	01 c2                	add    %eax,%edx
    7448:	8b 45 e8             	mov    -0x18(%ebp),%eax
    744b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7452:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7455:	01 c8                	add    %ecx,%eax
    7457:	8b 00                	mov    (%eax),%eax
    7459:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    745b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    7462:	eb 3a                	jmp    749e <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    7464:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7467:	8d 50 01             	lea    0x1(%eax),%edx
    746a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    746d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7474:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7477:	01 d0                	add    %edx,%eax
    7479:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    747f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7482:	8d 50 01             	lea    0x1(%eax),%edx
    7485:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7488:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    748f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7492:	01 d0                	add    %edx,%eax
    7494:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    749a:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    749e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    74a1:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    74a4:	72 be                	jb     7464 <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    74a6:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    74aa:	76 3a                	jbe    74e6 <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    74ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    74af:	8d 50 01             	lea    0x1(%eax),%edx
    74b2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    74b5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    74bf:	01 d0                	add    %edx,%eax
    74c1:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    74c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    74ca:	8d 50 01             	lea    0x1(%eax),%edx
    74cd:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    74d0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    74da:	01 d0                	add    %edx,%eax
    74dc:	8b 55 a8             	mov    -0x58(%ebp),%edx
    74df:	83 ea 03             	sub    $0x3,%edx
    74e2:	89 10                	mov    %edx,(%eax)
    74e4:	eb 06                	jmp    74ec <deflateDynamic+0x57d>
        }
        else j -= rest;
    74e6:	8b 45 a8             	mov    -0x58(%ebp),%eax
    74e9:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    74ec:	8b 55 e8             	mov    -0x18(%ebp),%edx
    74ef:	8b 45 dc             	mov    -0x24(%ebp),%eax
    74f2:	01 d0                	add    %edx,%eax
    74f4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    74f7:	eb 28                	jmp    7521 <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    74f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    74fc:	8d 50 01             	lea    0x1(%eax),%edx
    74ff:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7502:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7509:	8b 45 ec             	mov    -0x14(%ebp),%eax
    750c:	01 c2                	add    %eax,%edx
    750e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7511:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7518:	8b 45 f0             	mov    -0x10(%ebp),%eax
    751b:	01 c8                	add    %ecx,%eax
    751d:	8b 00                	mov    (%eax),%eax
    751f:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7521:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7525:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7528:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    752b:	0f 85 b9 fd ff ff    	jne    72ea <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7531:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7538:	eb 42                	jmp    757c <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    753a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    753d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7544:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7547:	01 d0                	add    %edx,%eax
    7549:	8b 00                	mov    (%eax),%eax
    754b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7552:	8b 45 cc             	mov    -0x34(%ebp),%eax
    7555:	01 d0                	add    %edx,%eax
    7557:	8b 10                	mov    (%eax),%edx
    7559:	83 c2 01             	add    $0x1,%edx
    755c:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    755e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7561:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7568:	8b 45 ec             	mov    -0x14(%ebp),%eax
    756b:	01 d0                	add    %edx,%eax
    756d:	8b 00                	mov    (%eax),%eax
    756f:	83 f8 0f             	cmp    $0xf,%eax
    7572:	76 04                	jbe    7578 <deflateDynamic+0x609>
    7574:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7578:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    757c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    757f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7582:	75 b6                	jne    753a <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    7584:	83 ec 0c             	sub    $0xc,%esp
    7587:	6a 07                	push   $0x7
    7589:	6a 13                	push   $0x13
    758b:	6a 13                	push   $0x13
    758d:	ff 75 cc             	pushl  -0x34(%ebp)
    7590:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7596:	50                   	push   %eax
    7597:	e8 fe dd ff ff       	call   539a <HuffmanTree_makeFromFrequencies>
    759c:	83 c4 20             	add    $0x20,%esp
    759f:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    75a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    75a6:	0f 85 8a 02 00 00    	jne    7836 <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    75ac:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    75b3:	eb 04                	jmp    75b9 <deflateDynamic+0x64a>
      numcodes_cl--;
    75b5:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    75b9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    75bc:	83 f8 04             	cmp    $0x4,%eax
    75bf:	76 1e                	jbe    75df <deflateDynamic+0x670>
    75c1:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    75c7:	8b 55 e0             	mov    -0x20(%ebp),%edx
    75ca:	83 ea 01             	sub    $0x1,%edx
    75cd:	8b 14 95 80 a0 01 00 	mov    0x1a080(,%edx,4),%edx
    75d4:	c1 e2 02             	shl    $0x2,%edx
    75d7:	01 d0                	add    %edx,%eax
    75d9:	8b 00                	mov    (%eax),%eax
    75db:	85 c0                	test   %eax,%eax
    75dd:	74 d6                	je     75b5 <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    75df:	83 ec 04             	sub    $0x4,%esp
    75e2:	6a 01                	push   $0x1
    75e4:	ff 75 c4             	pushl  -0x3c(%ebp)
    75e7:	ff 75 08             	pushl  0x8(%ebp)
    75ea:	e8 67 c3 ff ff       	call   3956 <writeBits>
    75ef:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    75f2:	83 ec 04             	sub    $0x4,%esp
    75f5:	6a 01                	push   $0x1
    75f7:	6a 00                	push   $0x0
    75f9:	ff 75 08             	pushl  0x8(%ebp)
    75fc:	e8 55 c3 ff ff       	call   3956 <writeBits>
    7601:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    7604:	83 ec 04             	sub    $0x4,%esp
    7607:	6a 01                	push   $0x1
    7609:	6a 01                	push   $0x1
    760b:	ff 75 08             	pushl  0x8(%ebp)
    760e:	e8 43 c3 ff ff       	call   3956 <writeBits>
    7613:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    7616:	8b 45 b8             	mov    -0x48(%ebp),%eax
    7619:	2d 01 01 00 00       	sub    $0x101,%eax
    761e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    7621:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7624:	83 e8 01             	sub    $0x1,%eax
    7627:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    762a:	8b 45 e0             	mov    -0x20(%ebp),%eax
    762d:	83 e8 04             	sub    $0x4,%eax
    7630:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    7633:	83 ec 04             	sub    $0x4,%esp
    7636:	6a 05                	push   $0x5
    7638:	ff 75 a4             	pushl  -0x5c(%ebp)
    763b:	ff 75 08             	pushl  0x8(%ebp)
    763e:	e8 13 c3 ff ff       	call   3956 <writeBits>
    7643:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    7646:	83 ec 04             	sub    $0x4,%esp
    7649:	6a 05                	push   $0x5
    764b:	ff 75 a0             	pushl  -0x60(%ebp)
    764e:	ff 75 08             	pushl  0x8(%ebp)
    7651:	e8 00 c3 ff ff       	call   3956 <writeBits>
    7656:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    7659:	83 ec 04             	sub    $0x4,%esp
    765c:	6a 04                	push   $0x4
    765e:	ff 75 9c             	pushl  -0x64(%ebp)
    7661:	ff 75 08             	pushl  0x8(%ebp)
    7664:	e8 ed c2 ff ff       	call   3956 <writeBits>
    7669:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    766c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7673:	eb 2c                	jmp    76a1 <deflateDynamic+0x732>
    7675:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    767b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    767e:	8b 04 85 80 a0 01 00 	mov    0x1a080(,%eax,4),%eax
    7685:	c1 e0 02             	shl    $0x2,%eax
    7688:	01 d0                	add    %edx,%eax
    768a:	8b 00                	mov    (%eax),%eax
    768c:	83 ec 04             	sub    $0x4,%esp
    768f:	6a 03                	push   $0x3
    7691:	50                   	push   %eax
    7692:	ff 75 08             	pushl  0x8(%ebp)
    7695:	e8 bc c2 ff ff       	call   3956 <writeBits>
    769a:	83 c4 10             	add    $0x10,%esp
    769d:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    76a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76a4:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    76a7:	75 cc                	jne    7675 <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    76a9:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    76b0:	e9 0a 01 00 00       	jmp    77bf <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    76b5:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    76bb:	8b 55 e8             	mov    -0x18(%ebp),%edx
    76be:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    76c5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    76c8:	01 ca                	add    %ecx,%edx
    76ca:	8b 12                	mov    (%edx),%edx
    76cc:	c1 e2 02             	shl    $0x2,%edx
    76cf:	01 d0                	add    %edx,%eax
    76d1:	8b 00                	mov    (%eax),%eax
    76d3:	89 c3                	mov    %eax,%ebx
    76d5:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    76db:	8b 55 e8             	mov    -0x18(%ebp),%edx
    76de:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    76e5:	8b 55 ec             	mov    -0x14(%ebp),%edx
    76e8:	01 ca                	add    %ecx,%edx
    76ea:	8b 12                	mov    (%edx),%edx
    76ec:	c1 e2 02             	shl    $0x2,%edx
    76ef:	01 d0                	add    %edx,%eax
    76f1:	8b 00                	mov    (%eax),%eax
    76f3:	83 ec 04             	sub    $0x4,%esp
    76f6:	53                   	push   %ebx
    76f7:	50                   	push   %eax
    76f8:	ff 75 08             	pushl  0x8(%ebp)
    76fb:	e8 ea c3 ff ff       	call   3aea <writeBitsReversed>
    7700:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    7703:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7706:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    770d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7710:	01 d0                	add    %edx,%eax
    7712:	8b 00                	mov    (%eax),%eax
    7714:	83 f8 10             	cmp    $0x10,%eax
    7717:	75 28                	jne    7741 <deflateDynamic+0x7d2>
    7719:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    771d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7720:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7727:	8b 45 ec             	mov    -0x14(%ebp),%eax
    772a:	01 d0                	add    %edx,%eax
    772c:	8b 00                	mov    (%eax),%eax
    772e:	83 ec 04             	sub    $0x4,%esp
    7731:	6a 02                	push   $0x2
    7733:	50                   	push   %eax
    7734:	ff 75 08             	pushl  0x8(%ebp)
    7737:	e8 1a c2 ff ff       	call   3956 <writeBits>
    773c:	83 c4 10             	add    $0x10,%esp
    773f:	eb 7a                	jmp    77bb <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    7741:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7744:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    774b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    774e:	01 d0                	add    %edx,%eax
    7750:	8b 00                	mov    (%eax),%eax
    7752:	83 f8 11             	cmp    $0x11,%eax
    7755:	75 28                	jne    777f <deflateDynamic+0x810>
    7757:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    775b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    775e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7765:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7768:	01 d0                	add    %edx,%eax
    776a:	8b 00                	mov    (%eax),%eax
    776c:	83 ec 04             	sub    $0x4,%esp
    776f:	6a 03                	push   $0x3
    7771:	50                   	push   %eax
    7772:	ff 75 08             	pushl  0x8(%ebp)
    7775:	e8 dc c1 ff ff       	call   3956 <writeBits>
    777a:	83 c4 10             	add    $0x10,%esp
    777d:	eb 3c                	jmp    77bb <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    777f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7782:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7789:	8b 45 ec             	mov    -0x14(%ebp),%eax
    778c:	01 d0                	add    %edx,%eax
    778e:	8b 00                	mov    (%eax),%eax
    7790:	83 f8 12             	cmp    $0x12,%eax
    7793:	75 26                	jne    77bb <deflateDynamic+0x84c>
    7795:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7799:	8b 45 e8             	mov    -0x18(%ebp),%eax
    779c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    77a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    77a6:	01 d0                	add    %edx,%eax
    77a8:	8b 00                	mov    (%eax),%eax
    77aa:	83 ec 04             	sub    $0x4,%esp
    77ad:	6a 07                	push   $0x7
    77af:	50                   	push   %eax
    77b0:	ff 75 08             	pushl  0x8(%ebp)
    77b3:	e8 9e c1 ff ff       	call   3956 <writeBits>
    77b8:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    77bb:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    77bf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    77c2:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    77c5:	0f 85 ea fe ff ff    	jne    76b5 <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    77cb:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    77d1:	50                   	push   %eax
    77d2:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    77d8:	50                   	push   %eax
    77d9:	8d 45 90             	lea    -0x70(%ebp),%eax
    77dc:	50                   	push   %eax
    77dd:	ff 75 08             	pushl  0x8(%ebp)
    77e0:	e8 4f f6 ff ff       	call   6e34 <writeLZ77data>
    77e5:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    77e8:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    77ee:	05 00 04 00 00       	add    $0x400,%eax
    77f3:	8b 00                	mov    (%eax),%eax
    77f5:	85 c0                	test   %eax,%eax
    77f7:	75 09                	jne    7802 <deflateDynamic+0x893>
    77f9:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    7800:	eb 35                	jmp    7837 <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    7802:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7808:	05 00 04 00 00       	add    $0x400,%eax
    780d:	8b 00                	mov    (%eax),%eax
    780f:	89 c2                	mov    %eax,%edx
    7811:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    7817:	05 00 04 00 00       	add    $0x400,%eax
    781c:	8b 00                	mov    (%eax),%eax
    781e:	83 ec 04             	sub    $0x4,%esp
    7821:	52                   	push   %edx
    7822:	50                   	push   %eax
    7823:	ff 75 08             	pushl  0x8(%ebp)
    7826:	e8 bf c2 ff ff       	call   3aea <writeBitsReversed>
    782b:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    782e:	eb 07                	jmp    7837 <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    7830:	90                   	nop
    7831:	eb 04                	jmp    7837 <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    7833:	90                   	nop
    7834:	eb 01                	jmp    7837 <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    7836:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    7837:	83 ec 0c             	sub    $0xc,%esp
    783a:	8d 45 90             	lea    -0x70(%ebp),%eax
    783d:	50                   	push   %eax
    783e:	e8 73 bd ff ff       	call   35b6 <uivector_cleanup>
    7843:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    7846:	83 ec 0c             	sub    $0xc,%esp
    7849:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    784f:	50                   	push   %eax
    7850:	e8 3a cb ff ff       	call   438f <HuffmanTree_cleanup>
    7855:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    7858:	83 ec 0c             	sub    $0xc,%esp
    785b:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7861:	50                   	push   %eax
    7862:	e8 28 cb ff ff       	call   438f <HuffmanTree_cleanup>
    7867:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    786a:	83 ec 0c             	sub    $0xc,%esp
    786d:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    7873:	50                   	push   %eax
    7874:	e8 16 cb ff ff       	call   438f <HuffmanTree_cleanup>
    7879:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    787c:	83 ec 0c             	sub    $0xc,%esp
    787f:	ff 75 d4             	pushl  -0x2c(%ebp)
    7882:	e8 08 bc ff ff       	call   348f <lodepng_free>
    7887:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    788a:	83 ec 0c             	sub    $0xc,%esp
    788d:	ff 75 d0             	pushl  -0x30(%ebp)
    7890:	e8 fa bb ff ff       	call   348f <lodepng_free>
    7895:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    7898:	83 ec 0c             	sub    $0xc,%esp
    789b:	ff 75 cc             	pushl  -0x34(%ebp)
    789e:	e8 ec bb ff ff       	call   348f <lodepng_free>
    78a3:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    78a6:	83 ec 0c             	sub    $0xc,%esp
    78a9:	ff 75 f0             	pushl  -0x10(%ebp)
    78ac:	e8 de bb ff ff       	call   348f <lodepng_free>
    78b1:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    78b4:	83 ec 0c             	sub    $0xc,%esp
    78b7:	ff 75 ec             	pushl  -0x14(%ebp)
    78ba:	e8 d0 bb ff ff       	call   348f <lodepng_free>
    78bf:	83 c4 10             	add    $0x10,%esp

  return error;
    78c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    78c5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    78c8:	c9                   	leave  
    78c9:	c3                   	ret    

000078ca <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    78ca:	55                   	push   %ebp
    78cb:	89 e5                	mov    %esp,%ebp
    78cd:	53                   	push   %ebx
    78ce:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    78d1:	8b 45 20             	mov    0x20(%ebp),%eax
    78d4:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    78d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    78de:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    78e1:	50                   	push   %eax
    78e2:	e8 7b ca ff ff       	call   4362 <HuffmanTree_init>
    78e7:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    78ea:	8d 45 bc             	lea    -0x44(%ebp),%eax
    78ed:	50                   	push   %eax
    78ee:	e8 6f ca ff ff       	call   4362 <HuffmanTree_init>
    78f3:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    78f6:	83 ec 0c             	sub    $0xc,%esp
    78f9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    78fc:	50                   	push   %eax
    78fd:	e8 41 db ff ff       	call   5443 <generateFixedLitLenTree>
    7902:	83 c4 10             	add    $0x10,%esp
    7905:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    7908:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    790c:	75 12                	jne    7920 <deflateFixed+0x56>
    790e:	83 ec 0c             	sub    $0xc,%esp
    7911:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7914:	50                   	push   %eax
    7915:	e8 30 dc ff ff       	call   554a <generateFixedDistanceTree>
    791a:	83 c4 10             	add    $0x10,%esp
    791d:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7920:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7924:	0f 85 3a 01 00 00    	jne    7a64 <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    792a:	83 ec 04             	sub    $0x4,%esp
    792d:	6a 01                	push   $0x1
    792f:	ff 75 ec             	pushl  -0x14(%ebp)
    7932:	ff 75 08             	pushl  0x8(%ebp)
    7935:	e8 1c c0 ff ff       	call   3956 <writeBits>
    793a:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    793d:	83 ec 04             	sub    $0x4,%esp
    7940:	6a 01                	push   $0x1
    7942:	6a 01                	push   $0x1
    7944:	ff 75 08             	pushl  0x8(%ebp)
    7947:	e8 0a c0 ff ff       	call   3956 <writeBits>
    794c:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    794f:	83 ec 04             	sub    $0x4,%esp
    7952:	6a 01                	push   $0x1
    7954:	6a 00                	push   $0x0
    7956:	ff 75 08             	pushl  0x8(%ebp)
    7959:	e8 f8 bf ff ff       	call   3956 <writeBits>
    795e:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    7961:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7964:	8b 40 04             	mov    0x4(%eax),%eax
    7967:	85 c0                	test   %eax,%eax
    7969:	74 77                	je     79e2 <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    796b:	83 ec 0c             	sub    $0xc,%esp
    796e:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7971:	50                   	push   %eax
    7972:	e8 e8 bc ff ff       	call   365f <uivector_init>
    7977:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    797a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    797d:	8b 58 14             	mov    0x14(%eax),%ebx
    7980:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7983:	8b 48 10             	mov    0x10(%eax),%ecx
    7986:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7989:	8b 50 0c             	mov    0xc(%eax),%edx
    798c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    798f:	8b 40 08             	mov    0x8(%eax),%eax
    7992:	83 ec 0c             	sub    $0xc,%esp
    7995:	53                   	push   %ebx
    7996:	51                   	push   %ecx
    7997:	52                   	push   %edx
    7998:	50                   	push   %eax
    7999:	ff 75 18             	pushl  0x18(%ebp)
    799c:	ff 75 14             	pushl  0x14(%ebp)
    799f:	ff 75 10             	pushl  0x10(%ebp)
    79a2:	ff 75 0c             	pushl  0xc(%ebp)
    79a5:	8d 45 b0             	lea    -0x50(%ebp),%eax
    79a8:	50                   	push   %eax
    79a9:	e8 c7 ed ff ff       	call   6775 <encodeLZ77>
    79ae:	83 c4 30             	add    $0x30,%esp
    79b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    79b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    79b8:	75 17                	jne    79d1 <deflateFixed+0x107>
    79ba:	8d 45 bc             	lea    -0x44(%ebp),%eax
    79bd:	50                   	push   %eax
    79be:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    79c1:	50                   	push   %eax
    79c2:	8d 45 b0             	lea    -0x50(%ebp),%eax
    79c5:	50                   	push   %eax
    79c6:	ff 75 08             	pushl  0x8(%ebp)
    79c9:	e8 66 f4 ff ff       	call   6e34 <writeLZ77data>
    79ce:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    79d1:	83 ec 0c             	sub    $0xc,%esp
    79d4:	8d 45 b0             	lea    -0x50(%ebp),%eax
    79d7:	50                   	push   %eax
    79d8:	e8 d9 bb ff ff       	call   35b6 <uivector_cleanup>
    79dd:	83 c4 10             	add    $0x10,%esp
    79e0:	eb 56                	jmp    7a38 <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    79e2:	8b 45 14             	mov    0x14(%ebp),%eax
    79e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    79e8:	eb 46                	jmp    7a30 <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    79ea:	8b 45 d8             	mov    -0x28(%ebp),%eax
    79ed:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    79f0:	8b 55 10             	mov    0x10(%ebp),%edx
    79f3:	01 ca                	add    %ecx,%edx
    79f5:	0f b6 12             	movzbl (%edx),%edx
    79f8:	0f b6 d2             	movzbl %dl,%edx
    79fb:	c1 e2 02             	shl    $0x2,%edx
    79fe:	01 d0                	add    %edx,%eax
    7a00:	8b 00                	mov    (%eax),%eax
    7a02:	89 c3                	mov    %eax,%ebx
    7a04:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7a07:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7a0a:	8b 55 10             	mov    0x10(%ebp),%edx
    7a0d:	01 ca                	add    %ecx,%edx
    7a0f:	0f b6 12             	movzbl (%edx),%edx
    7a12:	0f b6 d2             	movzbl %dl,%edx
    7a15:	c1 e2 02             	shl    $0x2,%edx
    7a18:	01 d0                	add    %edx,%eax
    7a1a:	8b 00                	mov    (%eax),%eax
    7a1c:	83 ec 04             	sub    $0x4,%esp
    7a1f:	53                   	push   %ebx
    7a20:	50                   	push   %eax
    7a21:	ff 75 08             	pushl  0x8(%ebp)
    7a24:	e8 c1 c0 ff ff       	call   3aea <writeBitsReversed>
    7a29:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7a2c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7a30:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7a33:	3b 45 18             	cmp    0x18(%ebp),%eax
    7a36:	7c b2                	jl     79ea <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    7a38:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7a3c:	75 26                	jne    7a64 <deflateFixed+0x19a>
    7a3e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7a41:	05 00 04 00 00       	add    $0x400,%eax
    7a46:	8b 00                	mov    (%eax),%eax
    7a48:	89 c2                	mov    %eax,%edx
    7a4a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7a4d:	05 00 04 00 00       	add    $0x400,%eax
    7a52:	8b 00                	mov    (%eax),%eax
    7a54:	83 ec 04             	sub    $0x4,%esp
    7a57:	52                   	push   %edx
    7a58:	50                   	push   %eax
    7a59:	ff 75 08             	pushl  0x8(%ebp)
    7a5c:	e8 89 c0 ff ff       	call   3aea <writeBitsReversed>
    7a61:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    7a64:	83 ec 0c             	sub    $0xc,%esp
    7a67:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7a6a:	50                   	push   %eax
    7a6b:	e8 1f c9 ff ff       	call   438f <HuffmanTree_cleanup>
    7a70:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    7a73:	83 ec 0c             	sub    $0xc,%esp
    7a76:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a79:	50                   	push   %eax
    7a7a:	e8 10 c9 ff ff       	call   438f <HuffmanTree_cleanup>
    7a7f:	83 c4 10             	add    $0x10,%esp

  return error;
    7a82:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7a85:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7a88:	c9                   	leave  
    7a89:	c3                   	ret    

00007a8a <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    7a8a:	55                   	push   %ebp
    7a8b:	89 e5                	mov    %esp,%ebp
    7a8d:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    7a90:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    7a97:	ff 75 08             	pushl  0x8(%ebp)
    7a9a:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a9d:	50                   	push   %eax
    7a9e:	e8 9e be ff ff       	call   3941 <LodePNGBitWriter_init>
    7aa3:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    7aa6:	8b 45 14             	mov    0x14(%ebp),%eax
    7aa9:	8b 00                	mov    (%eax),%eax
    7aab:	83 f8 02             	cmp    $0x2,%eax
    7aae:	76 0a                	jbe    7aba <lodepng_deflatev+0x30>
    7ab0:	b8 3d 00 00 00       	mov    $0x3d,%eax
    7ab5:	e9 68 01 00 00       	jmp    7c22 <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    7aba:	8b 45 14             	mov    0x14(%ebp),%eax
    7abd:	8b 00                	mov    (%eax),%eax
    7abf:	85 c0                	test   %eax,%eax
    7ac1:	75 16                	jne    7ad9 <lodepng_deflatev+0x4f>
    7ac3:	ff 75 10             	pushl  0x10(%ebp)
    7ac6:	ff 75 0c             	pushl  0xc(%ebp)
    7ac9:	ff 75 08             	pushl  0x8(%ebp)
    7acc:	e8 01 f2 ff ff       	call   6cd2 <deflateNoCompression>
    7ad1:	83 c4 0c             	add    $0xc,%esp
    7ad4:	e9 49 01 00 00       	jmp    7c22 <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    7ad9:	8b 45 14             	mov    0x14(%ebp),%eax
    7adc:	8b 00                	mov    (%eax),%eax
    7ade:	83 f8 01             	cmp    $0x1,%eax
    7ae1:	75 08                	jne    7aeb <lodepng_deflatev+0x61>
    7ae3:	8b 45 10             	mov    0x10(%ebp),%eax
    7ae6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    7ae9:	eb 2c                	jmp    7b17 <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    7aeb:	8b 45 10             	mov    0x10(%ebp),%eax
    7aee:	c1 e8 03             	shr    $0x3,%eax
    7af1:	83 c0 08             	add    $0x8,%eax
    7af4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    7af7:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    7afe:	7f 07                	jg     7b07 <lodepng_deflatev+0x7d>
    7b00:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    7b07:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    7b0e:	7e 07                	jle    7b17 <lodepng_deflatev+0x8d>
    7b10:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    7b17:	8b 55 10             	mov    0x10(%ebp),%edx
    7b1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7b1d:	01 d0                	add    %edx,%eax
    7b1f:	83 e8 01             	sub    $0x1,%eax
    7b22:	99                   	cltd   
    7b23:	f7 7d ec             	idivl  -0x14(%ebp)
    7b26:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    7b29:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7b2d:	75 07                	jne    7b36 <lodepng_deflatev+0xac>
    7b2f:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    7b36:	8b 45 14             	mov    0x14(%ebp),%eax
    7b39:	8b 40 08             	mov    0x8(%eax),%eax
    7b3c:	83 ec 08             	sub    $0x8,%esp
    7b3f:	50                   	push   %eax
    7b40:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7b43:	50                   	push   %eax
    7b44:	e8 1c e8 ff ff       	call   6365 <hash_init>
    7b49:	83 c4 10             	add    $0x10,%esp
    7b4c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7b4f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7b53:	0f 85 b7 00 00 00    	jne    7c10 <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7b59:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7b60:	e9 99 00 00 00       	jmp    7bfe <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    7b65:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7b68:	83 e8 01             	sub    $0x1,%eax
    7b6b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7b6e:	0f 94 c0             	sete   %al
    7b71:	0f b6 c0             	movzbl %al,%eax
    7b74:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    7b77:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7b7a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    7b7e:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    7b81:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7b84:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7b87:	01 d0                	add    %edx,%eax
    7b89:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    7b8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7b8f:	3b 45 10             	cmp    0x10(%ebp),%eax
    7b92:	7e 06                	jle    7b9a <lodepng_deflatev+0x110>
    7b94:	8b 45 10             	mov    0x10(%ebp),%eax
    7b97:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    7b9a:	8b 45 14             	mov    0x14(%ebp),%eax
    7b9d:	8b 00                	mov    (%eax),%eax
    7b9f:	83 f8 01             	cmp    $0x1,%eax
    7ba2:	75 27                	jne    7bcb <lodepng_deflatev+0x141>
    7ba4:	83 ec 04             	sub    $0x4,%esp
    7ba7:	ff 75 e0             	pushl  -0x20(%ebp)
    7baa:	ff 75 14             	pushl  0x14(%ebp)
    7bad:	ff 75 e4             	pushl  -0x1c(%ebp)
    7bb0:	ff 75 dc             	pushl  -0x24(%ebp)
    7bb3:	ff 75 0c             	pushl  0xc(%ebp)
    7bb6:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7bb9:	50                   	push   %eax
    7bba:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7bbd:	50                   	push   %eax
    7bbe:	e8 07 fd ff ff       	call   78ca <deflateFixed>
    7bc3:	83 c4 20             	add    $0x20,%esp
    7bc6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7bc9:	eb 2f                	jmp    7bfa <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    7bcb:	8b 45 14             	mov    0x14(%ebp),%eax
    7bce:	8b 00                	mov    (%eax),%eax
    7bd0:	83 f8 02             	cmp    $0x2,%eax
    7bd3:	75 25                	jne    7bfa <lodepng_deflatev+0x170>
    7bd5:	83 ec 04             	sub    $0x4,%esp
    7bd8:	ff 75 e0             	pushl  -0x20(%ebp)
    7bdb:	ff 75 14             	pushl  0x14(%ebp)
    7bde:	ff 75 e4             	pushl  -0x1c(%ebp)
    7be1:	ff 75 dc             	pushl  -0x24(%ebp)
    7be4:	ff 75 0c             	pushl  0xc(%ebp)
    7be7:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7bea:	50                   	push   %eax
    7beb:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7bee:	50                   	push   %eax
    7bef:	e8 7b f3 ff ff       	call   6f6f <deflateDynamic>
    7bf4:	83 c4 20             	add    $0x20,%esp
    7bf7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7bfa:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7bfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7c01:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7c04:	74 0a                	je     7c10 <lodepng_deflatev+0x186>
    7c06:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7c0a:	0f 84 55 ff ff ff    	je     7b65 <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    7c10:	83 ec 0c             	sub    $0xc,%esp
    7c13:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7c16:	50                   	push   %eax
    7c17:	e8 08 e9 ff ff       	call   6524 <hash_cleanup>
    7c1c:	83 c4 10             	add    $0x10,%esp

  return error;
    7c1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7c22:	c9                   	leave  
    7c23:	c3                   	ret    

00007c24 <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    7c24:	55                   	push   %ebp
    7c25:	89 e5                	mov    %esp,%ebp
    7c27:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7c2a:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c2d:	8b 08                	mov    (%eax),%ecx
    7c2f:	8b 45 08             	mov    0x8(%ebp),%eax
    7c32:	8b 10                	mov    (%eax),%edx
    7c34:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7c37:	51                   	push   %ecx
    7c38:	52                   	push   %edx
    7c39:	50                   	push   %eax
    7c3a:	e8 f0 ba ff ff       	call   372f <ucvector_init>
    7c3f:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    7c42:	ff 75 18             	pushl  0x18(%ebp)
    7c45:	ff 75 14             	pushl  0x14(%ebp)
    7c48:	ff 75 10             	pushl  0x10(%ebp)
    7c4b:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7c4e:	50                   	push   %eax
    7c4f:	e8 36 fe ff ff       	call   7a8a <lodepng_deflatev>
    7c54:	83 c4 10             	add    $0x10,%esp
    7c57:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7c5a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7c5d:	8b 45 08             	mov    0x8(%ebp),%eax
    7c60:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7c62:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7c65:	8b 45 0c             	mov    0xc(%ebp),%eax
    7c68:	89 10                	mov    %edx,(%eax)
  return error;
    7c6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7c6d:	c9                   	leave  
    7c6e:	c3                   	ret    

00007c6f <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    7c6f:	55                   	push   %ebp
    7c70:	89 e5                	mov    %esp,%ebp
    7c72:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    7c75:	8b 45 18             	mov    0x18(%ebp),%eax
    7c78:	8b 40 1c             	mov    0x1c(%eax),%eax
    7c7b:	85 c0                	test   %eax,%eax
    7c7d:	74 34                	je     7cb3 <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    7c7f:	8b 45 18             	mov    0x18(%ebp),%eax
    7c82:	8b 40 1c             	mov    0x1c(%eax),%eax
    7c85:	83 ec 0c             	sub    $0xc,%esp
    7c88:	ff 75 18             	pushl  0x18(%ebp)
    7c8b:	ff 75 14             	pushl  0x14(%ebp)
    7c8e:	ff 75 10             	pushl  0x10(%ebp)
    7c91:	ff 75 0c             	pushl  0xc(%ebp)
    7c94:	ff 75 08             	pushl  0x8(%ebp)
    7c97:	ff d0                	call   *%eax
    7c99:	83 c4 20             	add    $0x20,%esp
    7c9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    7c9f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7ca3:	74 07                	je     7cac <deflate+0x3d>
    7ca5:	b8 6f 00 00 00       	mov    $0x6f,%eax
    7caa:	eb 21                	jmp    7ccd <deflate+0x5e>
    7cac:	b8 00 00 00 00       	mov    $0x0,%eax
    7cb1:	eb 1a                	jmp    7ccd <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    7cb3:	83 ec 0c             	sub    $0xc,%esp
    7cb6:	ff 75 18             	pushl  0x18(%ebp)
    7cb9:	ff 75 14             	pushl  0x14(%ebp)
    7cbc:	ff 75 10             	pushl  0x10(%ebp)
    7cbf:	ff 75 0c             	pushl  0xc(%ebp)
    7cc2:	ff 75 08             	pushl  0x8(%ebp)
    7cc5:	e8 5a ff ff ff       	call   7c24 <lodepng_deflate>
    7cca:	83 c4 20             	add    $0x20,%esp
  }
}
    7ccd:	c9                   	leave  
    7cce:	c3                   	ret    

00007ccf <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    7ccf:	55                   	push   %ebp
    7cd0:	89 e5                	mov    %esp,%ebp
    7cd2:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    7cd5:	8b 45 08             	mov    0x8(%ebp),%eax
    7cd8:	0f b7 c0             	movzwl %ax,%eax
    7cdb:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    7cde:	8b 45 08             	mov    0x8(%ebp),%eax
    7ce1:	c1 e8 10             	shr    $0x10,%eax
    7ce4:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    7ce7:	e9 82 00 00 00       	jmp    7d6e <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    7cec:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    7cf1:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    7cf8:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    7cfc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    7cff:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7d02:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    7d05:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7d0c:	eb 1c                	jmp    7d2a <update_adler32+0x5b>
      s1 += (*data++);
    7d0e:	8b 45 0c             	mov    0xc(%ebp),%eax
    7d11:	8d 50 01             	lea    0x1(%eax),%edx
    7d14:	89 55 0c             	mov    %edx,0xc(%ebp)
    7d17:	0f b6 00             	movzbl (%eax),%eax
    7d1a:	0f b6 c0             	movzbl %al,%eax
    7d1d:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    7d20:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7d23:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    7d26:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7d2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7d2d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7d30:	75 dc                	jne    7d0e <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    7d32:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7d35:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7d3a:	89 c8                	mov    %ecx,%eax
    7d3c:	f7 e2                	mul    %edx
    7d3e:	89 d0                	mov    %edx,%eax
    7d40:	c1 e8 0f             	shr    $0xf,%eax
    7d43:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7d49:	29 c1                	sub    %eax,%ecx
    7d4b:	89 c8                	mov    %ecx,%eax
    7d4d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    7d50:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7d53:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7d58:	89 c8                	mov    %ecx,%eax
    7d5a:	f7 e2                	mul    %edx
    7d5c:	89 d0                	mov    %edx,%eax
    7d5e:	c1 e8 0f             	shr    $0xf,%eax
    7d61:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7d67:	29 c1                	sub    %eax,%ecx
    7d69:	89 c8                	mov    %ecx,%eax
    7d6b:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    7d6e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7d72:	0f 85 74 ff ff ff    	jne    7cec <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    7d78:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7d7b:	c1 e0 10             	shl    $0x10,%eax
    7d7e:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    7d81:	c9                   	leave  
    7d82:	c3                   	ret    

00007d83 <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    7d83:	55                   	push   %ebp
    7d84:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    7d86:	ff 75 0c             	pushl  0xc(%ebp)
    7d89:	ff 75 08             	pushl  0x8(%ebp)
    7d8c:	6a 01                	push   $0x1
    7d8e:	e8 3c ff ff ff       	call   7ccf <update_adler32>
    7d93:	83 c4 0c             	add    $0xc,%esp
}
    7d96:	c9                   	leave  
    7d97:	c3                   	ret    

00007d98 <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    7d98:	55                   	push   %ebp
    7d99:	89 e5                	mov    %esp,%ebp
    7d9b:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    7d9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    7da5:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    7da9:	7f 0a                	jg     7db5 <lodepng_zlib_decompressv+0x1d>
    7dab:	b8 35 00 00 00       	mov    $0x35,%eax
    7db0:	e9 27 01 00 00       	jmp    7edc <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    7db5:	8b 45 0c             	mov    0xc(%ebp),%eax
    7db8:	0f b6 00             	movzbl (%eax),%eax
    7dbb:	0f b6 c0             	movzbl %al,%eax
    7dbe:	c1 e0 08             	shl    $0x8,%eax
    7dc1:	89 c2                	mov    %eax,%edx
    7dc3:	8b 45 0c             	mov    0xc(%ebp),%eax
    7dc6:	83 c0 01             	add    $0x1,%eax
    7dc9:	0f b6 00             	movzbl (%eax),%eax
    7dcc:	0f b6 c0             	movzbl %al,%eax
    7dcf:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    7dd2:	ba 43 08 21 84       	mov    $0x84210843,%edx
    7dd7:	89 c8                	mov    %ecx,%eax
    7dd9:	f7 ea                	imul   %edx
    7ddb:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    7dde:	c1 f8 04             	sar    $0x4,%eax
    7de1:	89 c2                	mov    %eax,%edx
    7de3:	89 c8                	mov    %ecx,%eax
    7de5:	c1 f8 1f             	sar    $0x1f,%eax
    7de8:	29 c2                	sub    %eax,%edx
    7dea:	89 d0                	mov    %edx,%eax
    7dec:	89 c2                	mov    %eax,%edx
    7dee:	c1 e2 05             	shl    $0x5,%edx
    7df1:	29 c2                	sub    %eax,%edx
    7df3:	89 c8                	mov    %ecx,%eax
    7df5:	29 d0                	sub    %edx,%eax
    7df7:	85 c0                	test   %eax,%eax
    7df9:	74 0a                	je     7e05 <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    7dfb:	b8 18 00 00 00       	mov    $0x18,%eax
    7e00:	e9 d7 00 00 00       	jmp    7edc <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    7e05:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e08:	0f b6 00             	movzbl (%eax),%eax
    7e0b:	0f b6 c0             	movzbl %al,%eax
    7e0e:	83 e0 0f             	and    $0xf,%eax
    7e11:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    7e14:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e17:	0f b6 00             	movzbl (%eax),%eax
    7e1a:	c0 e8 04             	shr    $0x4,%al
    7e1d:	0f b6 c0             	movzbl %al,%eax
    7e20:	83 e0 0f             	and    $0xf,%eax
    7e23:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    7e26:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e29:	83 c0 01             	add    $0x1,%eax
    7e2c:	0f b6 00             	movzbl (%eax),%eax
    7e2f:	c0 e8 05             	shr    $0x5,%al
    7e32:	0f b6 c0             	movzbl %al,%eax
    7e35:	83 e0 01             	and    $0x1,%eax
    7e38:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    7e3b:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    7e3f:	75 06                	jne    7e47 <lodepng_zlib_decompressv+0xaf>
    7e41:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    7e45:	76 0a                	jbe    7e51 <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    7e47:	b8 19 00 00 00       	mov    $0x19,%eax
    7e4c:	e9 8b 00 00 00       	jmp    7edc <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    7e51:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7e55:	74 07                	je     7e5e <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    7e57:	b8 1a 00 00 00       	mov    $0x1a,%eax
    7e5c:	eb 7e                	jmp    7edc <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    7e5e:	8b 45 10             	mov    0x10(%ebp),%eax
    7e61:	8d 50 fe             	lea    -0x2(%eax),%edx
    7e64:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e67:	83 c0 02             	add    $0x2,%eax
    7e6a:	ff 75 14             	pushl  0x14(%ebp)
    7e6d:	52                   	push   %edx
    7e6e:	50                   	push   %eax
    7e6f:	ff 75 08             	pushl  0x8(%ebp)
    7e72:	e8 09 e3 ff ff       	call   6180 <inflatev>
    7e77:	83 c4 10             	add    $0x10,%esp
    7e7a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    7e7d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7e81:	74 05                	je     7e88 <lodepng_zlib_decompressv+0xf0>
    7e83:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7e86:	eb 54                	jmp    7edc <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    7e88:	8b 45 14             	mov    0x14(%ebp),%eax
    7e8b:	8b 00                	mov    (%eax),%eax
    7e8d:	85 c0                	test   %eax,%eax
    7e8f:	75 46                	jne    7ed7 <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    7e91:	8b 45 10             	mov    0x10(%ebp),%eax
    7e94:	8d 50 fc             	lea    -0x4(%eax),%edx
    7e97:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e9a:	01 d0                	add    %edx,%eax
    7e9c:	83 ec 0c             	sub    $0xc,%esp
    7e9f:	50                   	push   %eax
    7ea0:	e8 47 b9 ff ff       	call   37ec <lodepng_read32bitInt>
    7ea5:	83 c4 10             	add    $0x10,%esp
    7ea8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    7eab:	8b 45 08             	mov    0x8(%ebp),%eax
    7eae:	8b 40 04             	mov    0x4(%eax),%eax
    7eb1:	89 c2                	mov    %eax,%edx
    7eb3:	8b 45 08             	mov    0x8(%ebp),%eax
    7eb6:	8b 00                	mov    (%eax),%eax
    7eb8:	83 ec 08             	sub    $0x8,%esp
    7ebb:	52                   	push   %edx
    7ebc:	50                   	push   %eax
    7ebd:	e8 c1 fe ff ff       	call   7d83 <adler32>
    7ec2:	83 c4 10             	add    $0x10,%esp
    7ec5:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    7ec8:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7ecb:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    7ece:	74 07                	je     7ed7 <lodepng_zlib_decompressv+0x13f>
    7ed0:	b8 3a 00 00 00       	mov    $0x3a,%eax
    7ed5:	eb 05                	jmp    7edc <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    7ed7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    7edc:	c9                   	leave  
    7edd:	c3                   	ret    

00007ede <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    7ede:	55                   	push   %ebp
    7edf:	89 e5                	mov    %esp,%ebp
    7ee1:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7ee4:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ee7:	8b 08                	mov    (%eax),%ecx
    7ee9:	8b 45 08             	mov    0x8(%ebp),%eax
    7eec:	8b 10                	mov    (%eax),%edx
    7eee:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7ef1:	51                   	push   %ecx
    7ef2:	52                   	push   %edx
    7ef3:	50                   	push   %eax
    7ef4:	e8 36 b8 ff ff       	call   372f <ucvector_init>
    7ef9:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7efc:	ff 75 18             	pushl  0x18(%ebp)
    7eff:	ff 75 14             	pushl  0x14(%ebp)
    7f02:	ff 75 10             	pushl  0x10(%ebp)
    7f05:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7f08:	50                   	push   %eax
    7f09:	e8 8a fe ff ff       	call   7d98 <lodepng_zlib_decompressv>
    7f0e:	83 c4 10             	add    $0x10,%esp
    7f11:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7f14:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7f17:	8b 45 08             	mov    0x8(%ebp),%eax
    7f1a:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7f1c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7f1f:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f22:	89 10                	mov    %edx,(%eax)
  return error;
    7f24:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7f27:	c9                   	leave  
    7f28:	c3                   	ret    

00007f29 <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    7f29:	55                   	push   %ebp
    7f2a:	89 e5                	mov    %esp,%ebp
    7f2c:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    7f2f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7f32:	8b 40 0c             	mov    0xc(%eax),%eax
    7f35:	85 c0                	test   %eax,%eax
    7f37:	74 57                	je     7f90 <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    7f39:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7f3c:	8b 40 0c             	mov    0xc(%eax),%eax
    7f3f:	83 ec 0c             	sub    $0xc,%esp
    7f42:	ff 75 1c             	pushl  0x1c(%ebp)
    7f45:	ff 75 18             	pushl  0x18(%ebp)
    7f48:	ff 75 14             	pushl  0x14(%ebp)
    7f4b:	ff 75 0c             	pushl  0xc(%ebp)
    7f4e:	ff 75 08             	pushl  0x8(%ebp)
    7f51:	ff d0                	call   *%eax
    7f53:	83 c4 20             	add    $0x20,%esp
    7f56:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    7f59:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7f5d:	0f 84 98 00 00 00    	je     7ffb <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    7f63:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    7f6a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7f6d:	8b 40 08             	mov    0x8(%eax),%eax
    7f70:	85 c0                	test   %eax,%eax
    7f72:	0f 84 83 00 00 00    	je     7ffb <zlib_decompress+0xd2>
    7f78:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f7b:	8b 10                	mov    (%eax),%edx
    7f7d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7f80:	8b 40 08             	mov    0x8(%eax),%eax
    7f83:	39 c2                	cmp    %eax,%edx
    7f85:	7e 74                	jle    7ffb <zlib_decompress+0xd2>
    7f87:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    7f8e:	eb 6b                	jmp    7ffb <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    7f90:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f93:	8b 08                	mov    (%eax),%ecx
    7f95:	8b 45 08             	mov    0x8(%ebp),%eax
    7f98:	8b 10                	mov    (%eax),%edx
    7f9a:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7f9d:	83 ec 04             	sub    $0x4,%esp
    7fa0:	51                   	push   %ecx
    7fa1:	52                   	push   %edx
    7fa2:	50                   	push   %eax
    7fa3:	e8 87 b7 ff ff       	call   372f <ucvector_init>
    7fa8:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    7fab:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7faf:	74 22                	je     7fd3 <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    7fb1:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fb4:	8b 10                	mov    (%eax),%edx
    7fb6:	8b 45 10             	mov    0x10(%ebp),%eax
    7fb9:	01 d0                	add    %edx,%eax
    7fbb:	83 ec 08             	sub    $0x8,%esp
    7fbe:	50                   	push   %eax
    7fbf:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7fc2:	50                   	push   %eax
    7fc3:	e8 00 b7 ff ff       	call   36c8 <ucvector_resize>
    7fc8:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    7fcb:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fce:	8b 00                	mov    (%eax),%eax
    7fd0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    7fd3:	ff 75 1c             	pushl  0x1c(%ebp)
    7fd6:	ff 75 18             	pushl  0x18(%ebp)
    7fd9:	ff 75 14             	pushl  0x14(%ebp)
    7fdc:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7fdf:	50                   	push   %eax
    7fe0:	e8 b3 fd ff ff       	call   7d98 <lodepng_zlib_decompressv>
    7fe5:	83 c4 10             	add    $0x10,%esp
    7fe8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    7feb:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7fee:	8b 45 08             	mov    0x8(%ebp),%eax
    7ff1:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    7ff3:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7ff6:	8b 45 0c             	mov    0xc(%ebp),%eax
    7ff9:	89 10                	mov    %edx,(%eax)
  }
  return error;
    7ffb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7ffe:	c9                   	leave  
    7fff:	c3                   	ret    

00008000 <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    8000:	55                   	push   %ebp
    8001:	89 e5                	mov    %esp,%ebp
    8003:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    8006:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    800d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    8014:	83 ec 0c             	sub    $0xc,%esp
    8017:	ff 75 18             	pushl  0x18(%ebp)
    801a:	ff 75 14             	pushl  0x14(%ebp)
    801d:	ff 75 10             	pushl  0x10(%ebp)
    8020:	8d 45 d0             	lea    -0x30(%ebp),%eax
    8023:	50                   	push   %eax
    8024:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    8027:	50                   	push   %eax
    8028:	e8 42 fc ff ff       	call   7c6f <deflate>
    802d:	83 c4 20             	add    $0x20,%esp
    8030:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    8033:	8b 45 08             	mov    0x8(%ebp),%eax
    8036:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    803c:	8b 45 0c             	mov    0xc(%ebp),%eax
    803f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    8045:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    8049:	75 33                	jne    807e <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    804b:	8b 45 d0             	mov    -0x30(%ebp),%eax
    804e:	8d 50 06             	lea    0x6(%eax),%edx
    8051:	8b 45 0c             	mov    0xc(%ebp),%eax
    8054:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    8056:	8b 45 0c             	mov    0xc(%ebp),%eax
    8059:	8b 00                	mov    (%eax),%eax
    805b:	83 ec 0c             	sub    $0xc,%esp
    805e:	50                   	push   %eax
    805f:	e8 0a b4 ff ff       	call   346e <lodepng_malloc>
    8064:	83 c4 10             	add    $0x10,%esp
    8067:	89 c2                	mov    %eax,%edx
    8069:	8b 45 08             	mov    0x8(%ebp),%eax
    806c:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    806e:	8b 45 08             	mov    0x8(%ebp),%eax
    8071:	8b 00                	mov    (%eax),%eax
    8073:	85 c0                	test   %eax,%eax
    8075:	75 07                	jne    807e <lodepng_zlib_compress+0x7e>
    8077:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    807e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    8082:	0f 85 e2 00 00 00    	jne    816a <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    8088:	8b 45 14             	mov    0x14(%ebp),%eax
    808b:	83 ec 08             	sub    $0x8,%esp
    808e:	50                   	push   %eax
    808f:	ff 75 10             	pushl  0x10(%ebp)
    8092:	e8 ec fc ff ff       	call   7d83 <adler32>
    8097:	83 c4 10             	add    $0x10,%esp
    809a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    809d:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    80a4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    80ab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    80b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    80b5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    80bc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    80bf:	01 d0                	add    %edx,%eax
    80c1:	8d 14 00             	lea    (%eax,%eax,1),%edx
    80c4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    80c7:	01 d0                	add    %edx,%eax
    80c9:	c1 e0 05             	shl    $0x5,%eax
    80cc:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    80cf:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    80d2:	ba 85 10 42 08       	mov    $0x8421085,%edx
    80d7:	89 c8                	mov    %ecx,%eax
    80d9:	f7 e2                	mul    %edx
    80db:	89 c8                	mov    %ecx,%eax
    80dd:	29 d0                	sub    %edx,%eax
    80df:	d1 e8                	shr    %eax
    80e1:	01 d0                	add    %edx,%eax
    80e3:	c1 e8 04             	shr    $0x4,%eax
    80e6:	89 c2                	mov    %eax,%edx
    80e8:	c1 e2 05             	shl    $0x5,%edx
    80eb:	29 c2                	sub    %eax,%edx
    80ed:	89 c8                	mov    %ecx,%eax
    80ef:	29 d0                	sub    %edx,%eax
    80f1:	ba 1f 00 00 00       	mov    $0x1f,%edx
    80f6:	29 c2                	sub    %eax,%edx
    80f8:	89 d0                	mov    %edx,%eax
    80fa:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    80fd:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8100:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    8103:	8b 45 08             	mov    0x8(%ebp),%eax
    8106:	8b 00                	mov    (%eax),%eax
    8108:	8b 55 dc             	mov    -0x24(%ebp),%edx
    810b:	c1 ea 08             	shr    $0x8,%edx
    810e:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    8110:	8b 45 08             	mov    0x8(%ebp),%eax
    8113:	8b 00                	mov    (%eax),%eax
    8115:	83 c0 01             	add    $0x1,%eax
    8118:	8b 55 dc             	mov    -0x24(%ebp),%edx
    811b:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    811d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8124:	eb 1e                	jmp    8144 <lodepng_zlib_compress+0x144>
    8126:	8b 45 08             	mov    0x8(%ebp),%eax
    8129:	8b 00                	mov    (%eax),%eax
    812b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    812e:	83 c2 02             	add    $0x2,%edx
    8131:	01 c2                	add    %eax,%edx
    8133:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    8136:	8b 45 f4             	mov    -0xc(%ebp),%eax
    8139:	01 c8                	add    %ecx,%eax
    813b:	0f b6 00             	movzbl (%eax),%eax
    813e:	88 02                	mov    %al,(%edx)
    8140:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8144:	8b 45 d0             	mov    -0x30(%ebp),%eax
    8147:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    814a:	75 da                	jne    8126 <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    814c:	8b 45 08             	mov    0x8(%ebp),%eax
    814f:	8b 10                	mov    (%eax),%edx
    8151:	8b 45 0c             	mov    0xc(%ebp),%eax
    8154:	8b 00                	mov    (%eax),%eax
    8156:	83 e8 04             	sub    $0x4,%eax
    8159:	01 d0                	add    %edx,%eax
    815b:	83 ec 08             	sub    $0x8,%esp
    815e:	ff 75 ec             	pushl  -0x14(%ebp)
    8161:	50                   	push   %eax
    8162:	e8 c8 b6 ff ff       	call   382f <lodepng_set32bitInt>
    8167:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    816a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    816d:	83 ec 0c             	sub    $0xc,%esp
    8170:	50                   	push   %eax
    8171:	e8 19 b3 ff ff       	call   348f <lodepng_free>
    8176:	83 c4 10             	add    $0x10,%esp
  return error;
    8179:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    817c:	c9                   	leave  
    817d:	c3                   	ret    

0000817e <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    817e:	55                   	push   %ebp
    817f:	89 e5                	mov    %esp,%ebp
    8181:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    8184:	8b 45 18             	mov    0x18(%ebp),%eax
    8187:	8b 40 18             	mov    0x18(%eax),%eax
    818a:	85 c0                	test   %eax,%eax
    818c:	74 34                	je     81c2 <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    818e:	8b 45 18             	mov    0x18(%ebp),%eax
    8191:	8b 40 18             	mov    0x18(%eax),%eax
    8194:	83 ec 0c             	sub    $0xc,%esp
    8197:	ff 75 18             	pushl  0x18(%ebp)
    819a:	ff 75 14             	pushl  0x14(%ebp)
    819d:	ff 75 10             	pushl  0x10(%ebp)
    81a0:	ff 75 0c             	pushl  0xc(%ebp)
    81a3:	ff 75 08             	pushl  0x8(%ebp)
    81a6:	ff d0                	call   *%eax
    81a8:	83 c4 20             	add    $0x20,%esp
    81ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    81ae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    81b2:	74 07                	je     81bb <zlib_compress+0x3d>
    81b4:	b8 6f 00 00 00       	mov    $0x6f,%eax
    81b9:	eb 21                	jmp    81dc <zlib_compress+0x5e>
    81bb:	b8 00 00 00 00       	mov    $0x0,%eax
    81c0:	eb 1a                	jmp    81dc <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    81c2:	83 ec 0c             	sub    $0xc,%esp
    81c5:	ff 75 18             	pushl  0x18(%ebp)
    81c8:	ff 75 14             	pushl  0x14(%ebp)
    81cb:	ff 75 10             	pushl  0x10(%ebp)
    81ce:	ff 75 0c             	pushl  0xc(%ebp)
    81d1:	ff 75 08             	pushl  0x8(%ebp)
    81d4:	e8 27 fe ff ff       	call   8000 <lodepng_zlib_compress>
    81d9:	83 c4 20             	add    $0x20,%esp
  }
}
    81dc:	c9                   	leave  
    81dd:	c3                   	ret    

000081de <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    81de:	55                   	push   %ebp
    81df:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    81e1:	8b 45 08             	mov    0x8(%ebp),%eax
    81e4:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    81ea:	8b 45 08             	mov    0x8(%ebp),%eax
    81ed:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    81f4:	8b 45 08             	mov    0x8(%ebp),%eax
    81f7:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    81fe:	8b 45 08             	mov    0x8(%ebp),%eax
    8201:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    8208:	8b 45 08             	mov    0x8(%ebp),%eax
    820b:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    8212:	8b 45 08             	mov    0x8(%ebp),%eax
    8215:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    821c:	8b 45 08             	mov    0x8(%ebp),%eax
    821f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    8226:	8b 45 08             	mov    0x8(%ebp),%eax
    8229:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    8230:	8b 45 08             	mov    0x8(%ebp),%eax
    8233:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    823a:	90                   	nop
    823b:	5d                   	pop    %ebp
    823c:	c3                   	ret    

0000823d <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    823d:	55                   	push   %ebp
    823e:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    8240:	8b 45 08             	mov    0x8(%ebp),%eax
    8243:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    8249:	8b 45 08             	mov    0x8(%ebp),%eax
    824c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    8253:	8b 45 08             	mov    0x8(%ebp),%eax
    8256:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    825d:	8b 45 08             	mov    0x8(%ebp),%eax
    8260:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    8267:	8b 45 08             	mov    0x8(%ebp),%eax
    826a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    8271:	8b 45 08             	mov    0x8(%ebp),%eax
    8274:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    827b:	90                   	nop
    827c:	5d                   	pop    %ebp
    827d:	c3                   	ret    

0000827e <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    827e:	55                   	push   %ebp
    827f:	89 e5                	mov    %esp,%ebp
    8281:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    8284:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    828b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8292:	eb 2a                	jmp    82be <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    8294:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8297:	8b 45 08             	mov    0x8(%ebp),%eax
    829a:	01 d0                	add    %edx,%eax
    829c:	0f b6 00             	movzbl (%eax),%eax
    829f:	0f b6 c0             	movzbl %al,%eax
    82a2:	33 45 fc             	xor    -0x4(%ebp),%eax
    82a5:	0f b6 c0             	movzbl %al,%eax
    82a8:	8b 04 85 80 e2 01 00 	mov    0x1e280(,%eax,4),%eax
    82af:	8b 55 fc             	mov    -0x4(%ebp),%edx
    82b2:	c1 ea 08             	shr    $0x8,%edx
    82b5:	31 d0                	xor    %edx,%eax
    82b7:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    82ba:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    82be:	8b 45 f8             	mov    -0x8(%ebp),%eax
    82c1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    82c4:	7c ce                	jl     8294 <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    82c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    82c9:	f7 d0                	not    %eax
}
    82cb:	c9                   	leave  
    82cc:	c3                   	ret    

000082cd <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    82cd:	55                   	push   %ebp
    82ce:	89 e5                	mov    %esp,%ebp
    82d0:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    82d3:	8b 45 08             	mov    0x8(%ebp),%eax
    82d6:	8b 00                	mov    (%eax),%eax
    82d8:	c1 f8 03             	sar    $0x3,%eax
    82db:	89 c2                	mov    %eax,%edx
    82dd:	8b 45 0c             	mov    0xc(%ebp),%eax
    82e0:	01 d0                	add    %edx,%eax
    82e2:	0f b6 00             	movzbl (%eax),%eax
    82e5:	0f b6 d0             	movzbl %al,%edx
    82e8:	8b 45 08             	mov    0x8(%ebp),%eax
    82eb:	8b 00                	mov    (%eax),%eax
    82ed:	f7 d0                	not    %eax
    82ef:	83 e0 07             	and    $0x7,%eax
    82f2:	89 c1                	mov    %eax,%ecx
    82f4:	d3 fa                	sar    %cl,%edx
    82f6:	89 d0                	mov    %edx,%eax
    82f8:	83 e0 01             	and    $0x1,%eax
    82fb:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    82fe:	8b 45 08             	mov    0x8(%ebp),%eax
    8301:	8b 00                	mov    (%eax),%eax
    8303:	8d 50 01             	lea    0x1(%eax),%edx
    8306:	8b 45 08             	mov    0x8(%ebp),%eax
    8309:	89 10                	mov    %edx,(%eax)
  return result;
    830b:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    830f:	c9                   	leave  
    8310:	c3                   	ret    

00008311 <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    8311:	55                   	push   %ebp
    8312:	89 e5                	mov    %esp,%ebp
    8314:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    8317:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    831e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    8325:	eb 1b                	jmp    8342 <readBitsFromReversedStream+0x31>
    result <<= 1u;
    8327:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    832a:	ff 75 0c             	pushl  0xc(%ebp)
    832d:	ff 75 08             	pushl  0x8(%ebp)
    8330:	e8 98 ff ff ff       	call   82cd <readBitFromReversedStream>
    8335:	83 c4 08             	add    $0x8,%esp
    8338:	0f b6 c0             	movzbl %al,%eax
    833b:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    833e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8342:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8345:	3b 45 10             	cmp    0x10(%ebp),%eax
    8348:	7c dd                	jl     8327 <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    834a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    834d:	c9                   	leave  
    834e:	c3                   	ret    

0000834f <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    834f:	55                   	push   %ebp
    8350:	89 e5                	mov    %esp,%ebp
    8352:	56                   	push   %esi
    8353:	53                   	push   %ebx
    8354:	83 ec 04             	sub    $0x4,%esp
    8357:	8b 45 10             	mov    0x10(%ebp),%eax
    835a:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    835d:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    8361:	75 3e                	jne    83a1 <setBitOfReversedStream+0x52>
    8363:	8b 45 08             	mov    0x8(%ebp),%eax
    8366:	8b 00                	mov    (%eax),%eax
    8368:	c1 f8 03             	sar    $0x3,%eax
    836b:	89 c2                	mov    %eax,%edx
    836d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8370:	01 c2                	add    %eax,%edx
    8372:	8b 45 08             	mov    0x8(%ebp),%eax
    8375:	8b 00                	mov    (%eax),%eax
    8377:	c1 f8 03             	sar    $0x3,%eax
    837a:	89 c1                	mov    %eax,%ecx
    837c:	8b 45 0c             	mov    0xc(%ebp),%eax
    837f:	01 c8                	add    %ecx,%eax
    8381:	0f b6 18             	movzbl (%eax),%ebx
    8384:	8b 45 08             	mov    0x8(%ebp),%eax
    8387:	8b 00                	mov    (%eax),%eax
    8389:	f7 d0                	not    %eax
    838b:	83 e0 07             	and    $0x7,%eax
    838e:	be 01 00 00 00       	mov    $0x1,%esi
    8393:	89 c1                	mov    %eax,%ecx
    8395:	d3 e6                	shl    %cl,%esi
    8397:	89 f0                	mov    %esi,%eax
    8399:	f7 d0                	not    %eax
    839b:	21 d8                	and    %ebx,%eax
    839d:	88 02                	mov    %al,(%edx)
    839f:	eb 3a                	jmp    83db <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    83a1:	8b 45 08             	mov    0x8(%ebp),%eax
    83a4:	8b 00                	mov    (%eax),%eax
    83a6:	c1 f8 03             	sar    $0x3,%eax
    83a9:	89 c2                	mov    %eax,%edx
    83ab:	8b 45 0c             	mov    0xc(%ebp),%eax
    83ae:	01 c2                	add    %eax,%edx
    83b0:	8b 45 08             	mov    0x8(%ebp),%eax
    83b3:	8b 00                	mov    (%eax),%eax
    83b5:	c1 f8 03             	sar    $0x3,%eax
    83b8:	89 c1                	mov    %eax,%ecx
    83ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    83bd:	01 c8                	add    %ecx,%eax
    83bf:	0f b6 18             	movzbl (%eax),%ebx
    83c2:	8b 45 08             	mov    0x8(%ebp),%eax
    83c5:	8b 00                	mov    (%eax),%eax
    83c7:	f7 d0                	not    %eax
    83c9:	83 e0 07             	and    $0x7,%eax
    83cc:	be 01 00 00 00       	mov    $0x1,%esi
    83d1:	89 c1                	mov    %eax,%ecx
    83d3:	d3 e6                	shl    %cl,%esi
    83d5:	89 f0                	mov    %esi,%eax
    83d7:	09 d8                	or     %ebx,%eax
    83d9:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    83db:	8b 45 08             	mov    0x8(%ebp),%eax
    83de:	8b 00                	mov    (%eax),%eax
    83e0:	8d 50 01             	lea    0x1(%eax),%edx
    83e3:	8b 45 08             	mov    0x8(%ebp),%eax
    83e6:	89 10                	mov    %edx,(%eax)
}
    83e8:	90                   	nop
    83e9:	83 c4 04             	add    $0x4,%esp
    83ec:	5b                   	pop    %ebx
    83ed:	5e                   	pop    %esi
    83ee:	5d                   	pop    %ebp
    83ef:	c3                   	ret    

000083f0 <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    83f0:	55                   	push   %ebp
    83f1:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    83f3:	ff 75 08             	pushl  0x8(%ebp)
    83f6:	e8 f1 b3 ff ff       	call   37ec <lodepng_read32bitInt>
    83fb:	83 c4 04             	add    $0x4,%esp
}
    83fe:	c9                   	leave  
    83ff:	c3                   	ret    

00008400 <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    8400:	55                   	push   %ebp
    8401:	89 e5                	mov    %esp,%ebp
    8403:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    8406:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    840d:	eb 1c                	jmp    842b <lodepng_chunk_type+0x2b>
    840f:	8b 55 08             	mov    0x8(%ebp),%edx
    8412:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8415:	01 d0                	add    %edx,%eax
    8417:	8b 55 fc             	mov    -0x4(%ebp),%edx
    841a:	8d 4a 04             	lea    0x4(%edx),%ecx
    841d:	8b 55 0c             	mov    0xc(%ebp),%edx
    8420:	01 ca                	add    %ecx,%edx
    8422:	0f b6 12             	movzbl (%edx),%edx
    8425:	88 10                	mov    %dl,(%eax)
    8427:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    842b:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    842f:	75 de                	jne    840f <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    8431:	8b 45 08             	mov    0x8(%ebp),%eax
    8434:	83 c0 04             	add    $0x4,%eax
    8437:	c6 00 00             	movb   $0x0,(%eax)
}
    843a:	90                   	nop
    843b:	c9                   	leave  
    843c:	c3                   	ret    

0000843d <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    843d:	55                   	push   %ebp
    843e:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    8440:	ff 75 0c             	pushl  0xc(%ebp)
    8443:	e8 c2 b0 ff ff       	call   350a <lodepng_strlen>
    8448:	83 c4 04             	add    $0x4,%esp
    844b:	83 f8 04             	cmp    $0x4,%eax
    844e:	74 07                	je     8457 <lodepng_chunk_type_equals+0x1a>
    8450:	b8 00 00 00 00       	mov    $0x0,%eax
    8455:	eb 79                	jmp    84d0 <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    8457:	8b 45 08             	mov    0x8(%ebp),%eax
    845a:	83 c0 04             	add    $0x4,%eax
    845d:	0f b6 00             	movzbl (%eax),%eax
    8460:	0f b6 d0             	movzbl %al,%edx
    8463:	8b 45 0c             	mov    0xc(%ebp),%eax
    8466:	0f b6 00             	movzbl (%eax),%eax
    8469:	0f be c0             	movsbl %al,%eax
    846c:	39 c2                	cmp    %eax,%edx
    846e:	75 5b                	jne    84cb <lodepng_chunk_type_equals+0x8e>
    8470:	8b 45 08             	mov    0x8(%ebp),%eax
    8473:	83 c0 05             	add    $0x5,%eax
    8476:	0f b6 00             	movzbl (%eax),%eax
    8479:	0f b6 d0             	movzbl %al,%edx
    847c:	8b 45 0c             	mov    0xc(%ebp),%eax
    847f:	83 c0 01             	add    $0x1,%eax
    8482:	0f b6 00             	movzbl (%eax),%eax
    8485:	0f be c0             	movsbl %al,%eax
    8488:	39 c2                	cmp    %eax,%edx
    848a:	75 3f                	jne    84cb <lodepng_chunk_type_equals+0x8e>
    848c:	8b 45 08             	mov    0x8(%ebp),%eax
    848f:	83 c0 06             	add    $0x6,%eax
    8492:	0f b6 00             	movzbl (%eax),%eax
    8495:	0f b6 d0             	movzbl %al,%edx
    8498:	8b 45 0c             	mov    0xc(%ebp),%eax
    849b:	83 c0 02             	add    $0x2,%eax
    849e:	0f b6 00             	movzbl (%eax),%eax
    84a1:	0f be c0             	movsbl %al,%eax
    84a4:	39 c2                	cmp    %eax,%edx
    84a6:	75 23                	jne    84cb <lodepng_chunk_type_equals+0x8e>
    84a8:	8b 45 08             	mov    0x8(%ebp),%eax
    84ab:	83 c0 07             	add    $0x7,%eax
    84ae:	0f b6 00             	movzbl (%eax),%eax
    84b1:	0f b6 d0             	movzbl %al,%edx
    84b4:	8b 45 0c             	mov    0xc(%ebp),%eax
    84b7:	83 c0 03             	add    $0x3,%eax
    84ba:	0f b6 00             	movzbl (%eax),%eax
    84bd:	0f be c0             	movsbl %al,%eax
    84c0:	39 c2                	cmp    %eax,%edx
    84c2:	75 07                	jne    84cb <lodepng_chunk_type_equals+0x8e>
    84c4:	b8 01 00 00 00       	mov    $0x1,%eax
    84c9:	eb 05                	jmp    84d0 <lodepng_chunk_type_equals+0x93>
    84cb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    84d0:	c9                   	leave  
    84d1:	c3                   	ret    

000084d2 <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    84d2:	55                   	push   %ebp
    84d3:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    84d5:	8b 45 08             	mov    0x8(%ebp),%eax
    84d8:	83 c0 04             	add    $0x4,%eax
    84db:	0f b6 00             	movzbl (%eax),%eax
    84de:	0f b6 c0             	movzbl %al,%eax
    84e1:	83 e0 20             	and    $0x20,%eax
    84e4:	85 c0                	test   %eax,%eax
    84e6:	0f 95 c0             	setne  %al
}
    84e9:	5d                   	pop    %ebp
    84ea:	c3                   	ret    

000084eb <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    84eb:	55                   	push   %ebp
    84ec:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    84ee:	8b 45 08             	mov    0x8(%ebp),%eax
    84f1:	83 c0 06             	add    $0x6,%eax
    84f4:	0f b6 00             	movzbl (%eax),%eax
    84f7:	0f b6 c0             	movzbl %al,%eax
    84fa:	83 e0 20             	and    $0x20,%eax
    84fd:	85 c0                	test   %eax,%eax
    84ff:	0f 95 c0             	setne  %al
}
    8502:	5d                   	pop    %ebp
    8503:	c3                   	ret    

00008504 <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    8504:	55                   	push   %ebp
    8505:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    8507:	8b 45 08             	mov    0x8(%ebp),%eax
    850a:	83 c0 07             	add    $0x7,%eax
    850d:	0f b6 00             	movzbl (%eax),%eax
    8510:	0f b6 c0             	movzbl %al,%eax
    8513:	83 e0 20             	and    $0x20,%eax
    8516:	85 c0                	test   %eax,%eax
    8518:	0f 95 c0             	setne  %al
}
    851b:	5d                   	pop    %ebp
    851c:	c3                   	ret    

0000851d <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    851d:	55                   	push   %ebp
    851e:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    8520:	8b 45 08             	mov    0x8(%ebp),%eax
    8523:	83 c0 08             	add    $0x8,%eax
}
    8526:	5d                   	pop    %ebp
    8527:	c3                   	ret    

00008528 <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    8528:	55                   	push   %ebp
    8529:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    852b:	8b 45 08             	mov    0x8(%ebp),%eax
    852e:	83 c0 08             	add    $0x8,%eax
}
    8531:	5d                   	pop    %ebp
    8532:	c3                   	ret    

00008533 <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    8533:	55                   	push   %ebp
    8534:	89 e5                	mov    %esp,%ebp
    8536:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    8539:	ff 75 08             	pushl  0x8(%ebp)
    853c:	e8 af fe ff ff       	call   83f0 <lodepng_chunk_length>
    8541:	83 c4 04             	add    $0x4,%esp
    8544:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    8547:	8b 45 fc             	mov    -0x4(%ebp),%eax
    854a:	8d 50 08             	lea    0x8(%eax),%edx
    854d:	8b 45 08             	mov    0x8(%ebp),%eax
    8550:	01 d0                	add    %edx,%eax
    8552:	50                   	push   %eax
    8553:	e8 94 b2 ff ff       	call   37ec <lodepng_read32bitInt>
    8558:	83 c4 04             	add    $0x4,%esp
    855b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    855e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8561:	83 c0 04             	add    $0x4,%eax
    8564:	89 c2                	mov    %eax,%edx
    8566:	8b 45 08             	mov    0x8(%ebp),%eax
    8569:	83 c0 04             	add    $0x4,%eax
    856c:	52                   	push   %edx
    856d:	50                   	push   %eax
    856e:	e8 0b fd ff ff       	call   827e <lodepng_crc32>
    8573:	83 c4 08             	add    $0x8,%esp
    8576:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    8579:	8b 45 f8             	mov    -0x8(%ebp),%eax
    857c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    857f:	74 07                	je     8588 <lodepng_chunk_check_crc+0x55>
    8581:	b8 01 00 00 00       	mov    $0x1,%eax
    8586:	eb 05                	jmp    858d <lodepng_chunk_check_crc+0x5a>
  else return 0;
    8588:	b8 00 00 00 00       	mov    $0x0,%eax
}
    858d:	c9                   	leave  
    858e:	c3                   	ret    

0000858f <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    858f:	55                   	push   %ebp
    8590:	89 e5                	mov    %esp,%ebp
    8592:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    8595:	ff 75 08             	pushl  0x8(%ebp)
    8598:	e8 53 fe ff ff       	call   83f0 <lodepng_chunk_length>
    859d:	83 c4 04             	add    $0x4,%esp
    85a0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    85a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    85a6:	83 c0 04             	add    $0x4,%eax
    85a9:	89 c2                	mov    %eax,%edx
    85ab:	8b 45 08             	mov    0x8(%ebp),%eax
    85ae:	83 c0 04             	add    $0x4,%eax
    85b1:	52                   	push   %edx
    85b2:	50                   	push   %eax
    85b3:	e8 c6 fc ff ff       	call   827e <lodepng_crc32>
    85b8:	83 c4 08             	add    $0x8,%esp
    85bb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    85be:	8b 45 fc             	mov    -0x4(%ebp),%eax
    85c1:	8d 50 08             	lea    0x8(%eax),%edx
    85c4:	8b 45 08             	mov    0x8(%ebp),%eax
    85c7:	01 d0                	add    %edx,%eax
    85c9:	ff 75 f8             	pushl  -0x8(%ebp)
    85cc:	50                   	push   %eax
    85cd:	e8 5d b2 ff ff       	call   382f <lodepng_set32bitInt>
    85d2:	83 c4 08             	add    $0x8,%esp
}
    85d5:	90                   	nop
    85d6:	c9                   	leave  
    85d7:	c3                   	ret    

000085d8 <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    85d8:	55                   	push   %ebp
    85d9:	89 e5                	mov    %esp,%ebp
    85db:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    85de:	8b 45 08             	mov    0x8(%ebp),%eax
    85e1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    85e4:	73 0f                	jae    85f5 <lodepng_chunk_next+0x1d>
    85e6:	8b 55 0c             	mov    0xc(%ebp),%edx
    85e9:	8b 45 08             	mov    0x8(%ebp),%eax
    85ec:	29 c2                	sub    %eax,%edx
    85ee:	89 d0                	mov    %edx,%eax
    85f0:	83 f8 0b             	cmp    $0xb,%eax
    85f3:	7f 08                	jg     85fd <lodepng_chunk_next+0x25>
    85f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    85f8:	e9 af 00 00 00       	jmp    86ac <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    85fd:	8b 45 08             	mov    0x8(%ebp),%eax
    8600:	0f b6 00             	movzbl (%eax),%eax
    8603:	3c 89                	cmp    $0x89,%al
    8605:	75 63                	jne    866a <lodepng_chunk_next+0x92>
    8607:	8b 45 08             	mov    0x8(%ebp),%eax
    860a:	83 c0 01             	add    $0x1,%eax
    860d:	0f b6 00             	movzbl (%eax),%eax
    8610:	3c 50                	cmp    $0x50,%al
    8612:	75 56                	jne    866a <lodepng_chunk_next+0x92>
    8614:	8b 45 08             	mov    0x8(%ebp),%eax
    8617:	83 c0 02             	add    $0x2,%eax
    861a:	0f b6 00             	movzbl (%eax),%eax
    861d:	3c 4e                	cmp    $0x4e,%al
    861f:	75 49                	jne    866a <lodepng_chunk_next+0x92>
    8621:	8b 45 08             	mov    0x8(%ebp),%eax
    8624:	83 c0 03             	add    $0x3,%eax
    8627:	0f b6 00             	movzbl (%eax),%eax
    862a:	3c 47                	cmp    $0x47,%al
    862c:	75 3c                	jne    866a <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    862e:	8b 45 08             	mov    0x8(%ebp),%eax
    8631:	83 c0 04             	add    $0x4,%eax
    8634:	0f b6 00             	movzbl (%eax),%eax
    8637:	3c 0d                	cmp    $0xd,%al
    8639:	75 2f                	jne    866a <lodepng_chunk_next+0x92>
    863b:	8b 45 08             	mov    0x8(%ebp),%eax
    863e:	83 c0 05             	add    $0x5,%eax
    8641:	0f b6 00             	movzbl (%eax),%eax
    8644:	3c 0a                	cmp    $0xa,%al
    8646:	75 22                	jne    866a <lodepng_chunk_next+0x92>
    8648:	8b 45 08             	mov    0x8(%ebp),%eax
    864b:	83 c0 06             	add    $0x6,%eax
    864e:	0f b6 00             	movzbl (%eax),%eax
    8651:	3c 1a                	cmp    $0x1a,%al
    8653:	75 15                	jne    866a <lodepng_chunk_next+0x92>
    8655:	8b 45 08             	mov    0x8(%ebp),%eax
    8658:	83 c0 07             	add    $0x7,%eax
    865b:	0f b6 00             	movzbl (%eax),%eax
    865e:	3c 0a                	cmp    $0xa,%al
    8660:	75 08                	jne    866a <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    8662:	8b 45 08             	mov    0x8(%ebp),%eax
    8665:	83 c0 08             	add    $0x8,%eax
    8668:	eb 42                	jmp    86ac <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    866a:	ff 75 08             	pushl  0x8(%ebp)
    866d:	e8 7e fd ff ff       	call   83f0 <lodepng_chunk_length>
    8672:	83 c4 04             	add    $0x4,%esp
    8675:	89 c2                	mov    %eax,%edx
    8677:	8d 45 f8             	lea    -0x8(%ebp),%eax
    867a:	50                   	push   %eax
    867b:	6a 0c                	push   $0xc
    867d:	52                   	push   %edx
    867e:	e8 af ae ff ff       	call   3532 <lodepng_addofl>
    8683:	83 c4 0c             	add    $0xc,%esp
    8686:	85 c0                	test   %eax,%eax
    8688:	74 05                	je     868f <lodepng_chunk_next+0xb7>
    868a:	8b 45 0c             	mov    0xc(%ebp),%eax
    868d:	eb 1d                	jmp    86ac <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    868f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8692:	89 c2                	mov    %eax,%edx
    8694:	8b 45 08             	mov    0x8(%ebp),%eax
    8697:	01 d0                	add    %edx,%eax
    8699:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    869c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    869f:	3b 45 08             	cmp    0x8(%ebp),%eax
    86a2:	73 05                	jae    86a9 <lodepng_chunk_next+0xd1>
    86a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    86a7:	eb 03                	jmp    86ac <lodepng_chunk_next+0xd4>
    return result;
    86a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    86ac:	c9                   	leave  
    86ad:	c3                   	ret    

000086ae <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    86ae:	55                   	push   %ebp
    86af:	89 e5                	mov    %esp,%ebp
    86b1:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    86b4:	8b 45 08             	mov    0x8(%ebp),%eax
    86b7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    86ba:	73 0f                	jae    86cb <lodepng_chunk_next_const+0x1d>
    86bc:	8b 55 0c             	mov    0xc(%ebp),%edx
    86bf:	8b 45 08             	mov    0x8(%ebp),%eax
    86c2:	29 c2                	sub    %eax,%edx
    86c4:	89 d0                	mov    %edx,%eax
    86c6:	83 f8 0b             	cmp    $0xb,%eax
    86c9:	7f 08                	jg     86d3 <lodepng_chunk_next_const+0x25>
    86cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    86ce:	e9 af 00 00 00       	jmp    8782 <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    86d3:	8b 45 08             	mov    0x8(%ebp),%eax
    86d6:	0f b6 00             	movzbl (%eax),%eax
    86d9:	3c 89                	cmp    $0x89,%al
    86db:	75 63                	jne    8740 <lodepng_chunk_next_const+0x92>
    86dd:	8b 45 08             	mov    0x8(%ebp),%eax
    86e0:	83 c0 01             	add    $0x1,%eax
    86e3:	0f b6 00             	movzbl (%eax),%eax
    86e6:	3c 50                	cmp    $0x50,%al
    86e8:	75 56                	jne    8740 <lodepng_chunk_next_const+0x92>
    86ea:	8b 45 08             	mov    0x8(%ebp),%eax
    86ed:	83 c0 02             	add    $0x2,%eax
    86f0:	0f b6 00             	movzbl (%eax),%eax
    86f3:	3c 4e                	cmp    $0x4e,%al
    86f5:	75 49                	jne    8740 <lodepng_chunk_next_const+0x92>
    86f7:	8b 45 08             	mov    0x8(%ebp),%eax
    86fa:	83 c0 03             	add    $0x3,%eax
    86fd:	0f b6 00             	movzbl (%eax),%eax
    8700:	3c 47                	cmp    $0x47,%al
    8702:	75 3c                	jne    8740 <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    8704:	8b 45 08             	mov    0x8(%ebp),%eax
    8707:	83 c0 04             	add    $0x4,%eax
    870a:	0f b6 00             	movzbl (%eax),%eax
    870d:	3c 0d                	cmp    $0xd,%al
    870f:	75 2f                	jne    8740 <lodepng_chunk_next_const+0x92>
    8711:	8b 45 08             	mov    0x8(%ebp),%eax
    8714:	83 c0 05             	add    $0x5,%eax
    8717:	0f b6 00             	movzbl (%eax),%eax
    871a:	3c 0a                	cmp    $0xa,%al
    871c:	75 22                	jne    8740 <lodepng_chunk_next_const+0x92>
    871e:	8b 45 08             	mov    0x8(%ebp),%eax
    8721:	83 c0 06             	add    $0x6,%eax
    8724:	0f b6 00             	movzbl (%eax),%eax
    8727:	3c 1a                	cmp    $0x1a,%al
    8729:	75 15                	jne    8740 <lodepng_chunk_next_const+0x92>
    872b:	8b 45 08             	mov    0x8(%ebp),%eax
    872e:	83 c0 07             	add    $0x7,%eax
    8731:	0f b6 00             	movzbl (%eax),%eax
    8734:	3c 0a                	cmp    $0xa,%al
    8736:	75 08                	jne    8740 <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    8738:	8b 45 08             	mov    0x8(%ebp),%eax
    873b:	83 c0 08             	add    $0x8,%eax
    873e:	eb 42                	jmp    8782 <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    8740:	ff 75 08             	pushl  0x8(%ebp)
    8743:	e8 a8 fc ff ff       	call   83f0 <lodepng_chunk_length>
    8748:	83 c4 04             	add    $0x4,%esp
    874b:	89 c2                	mov    %eax,%edx
    874d:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8750:	50                   	push   %eax
    8751:	6a 0c                	push   $0xc
    8753:	52                   	push   %edx
    8754:	e8 d9 ad ff ff       	call   3532 <lodepng_addofl>
    8759:	83 c4 0c             	add    $0xc,%esp
    875c:	85 c0                	test   %eax,%eax
    875e:	74 05                	je     8765 <lodepng_chunk_next_const+0xb7>
    8760:	8b 45 0c             	mov    0xc(%ebp),%eax
    8763:	eb 1d                	jmp    8782 <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    8765:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8768:	89 c2                	mov    %eax,%edx
    876a:	8b 45 08             	mov    0x8(%ebp),%eax
    876d:	01 d0                	add    %edx,%eax
    876f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8772:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8775:	3b 45 08             	cmp    0x8(%ebp),%eax
    8778:	73 05                	jae    877f <lodepng_chunk_next_const+0xd1>
    877a:	8b 45 0c             	mov    0xc(%ebp),%eax
    877d:	eb 03                	jmp    8782 <lodepng_chunk_next_const+0xd4>
    return result;
    877f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8782:	c9                   	leave  
    8783:	c3                   	ret    

00008784 <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    8784:	55                   	push   %ebp
    8785:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    8787:	8b 45 08             	mov    0x8(%ebp),%eax
    878a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    878d:	73 0f                	jae    879e <lodepng_chunk_find+0x1a>
    878f:	8b 55 0c             	mov    0xc(%ebp),%edx
    8792:	8b 45 08             	mov    0x8(%ebp),%eax
    8795:	29 c2                	sub    %eax,%edx
    8797:	89 d0                	mov    %edx,%eax
    8799:	83 f8 0b             	cmp    $0xb,%eax
    879c:	7f 07                	jg     87a5 <lodepng_chunk_find+0x21>
    879e:	b8 00 00 00 00       	mov    $0x0,%eax
    87a3:	eb 2a                	jmp    87cf <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    87a5:	ff 75 10             	pushl  0x10(%ebp)
    87a8:	ff 75 08             	pushl  0x8(%ebp)
    87ab:	e8 8d fc ff ff       	call   843d <lodepng_chunk_type_equals>
    87b0:	83 c4 08             	add    $0x8,%esp
    87b3:	84 c0                	test   %al,%al
    87b5:	74 05                	je     87bc <lodepng_chunk_find+0x38>
    87b7:	8b 45 08             	mov    0x8(%ebp),%eax
    87ba:	eb 13                	jmp    87cf <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    87bc:	ff 75 0c             	pushl  0xc(%ebp)
    87bf:	ff 75 08             	pushl  0x8(%ebp)
    87c2:	e8 11 fe ff ff       	call   85d8 <lodepng_chunk_next>
    87c7:	83 c4 08             	add    $0x8,%esp
    87ca:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    87cd:	eb b8                	jmp    8787 <lodepng_chunk_find+0x3>
}
    87cf:	c9                   	leave  
    87d0:	c3                   	ret    

000087d1 <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    87d1:	55                   	push   %ebp
    87d2:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    87d4:	8b 45 08             	mov    0x8(%ebp),%eax
    87d7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    87da:	73 0f                	jae    87eb <lodepng_chunk_find_const+0x1a>
    87dc:	8b 55 0c             	mov    0xc(%ebp),%edx
    87df:	8b 45 08             	mov    0x8(%ebp),%eax
    87e2:	29 c2                	sub    %eax,%edx
    87e4:	89 d0                	mov    %edx,%eax
    87e6:	83 f8 0b             	cmp    $0xb,%eax
    87e9:	7f 07                	jg     87f2 <lodepng_chunk_find_const+0x21>
    87eb:	b8 00 00 00 00       	mov    $0x0,%eax
    87f0:	eb 2a                	jmp    881c <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    87f2:	ff 75 10             	pushl  0x10(%ebp)
    87f5:	ff 75 08             	pushl  0x8(%ebp)
    87f8:	e8 40 fc ff ff       	call   843d <lodepng_chunk_type_equals>
    87fd:	83 c4 08             	add    $0x8,%esp
    8800:	84 c0                	test   %al,%al
    8802:	74 05                	je     8809 <lodepng_chunk_find_const+0x38>
    8804:	8b 45 08             	mov    0x8(%ebp),%eax
    8807:	eb 13                	jmp    881c <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    8809:	ff 75 0c             	pushl  0xc(%ebp)
    880c:	ff 75 08             	pushl  0x8(%ebp)
    880f:	e8 9a fe ff ff       	call   86ae <lodepng_chunk_next_const>
    8814:	83 c4 08             	add    $0x8,%esp
    8817:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    881a:	eb b8                	jmp    87d4 <lodepng_chunk_find_const+0x3>
}
    881c:	c9                   	leave  
    881d:	c3                   	ret    

0000881e <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    881e:	55                   	push   %ebp
    881f:	89 e5                	mov    %esp,%ebp
    8821:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    8824:	ff 75 10             	pushl  0x10(%ebp)
    8827:	e8 c4 fb ff ff       	call   83f0 <lodepng_chunk_length>
    882c:	83 c4 04             	add    $0x4,%esp
    882f:	89 c2                	mov    %eax,%edx
    8831:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8834:	50                   	push   %eax
    8835:	6a 0c                	push   $0xc
    8837:	52                   	push   %edx
    8838:	e8 f5 ac ff ff       	call   3532 <lodepng_addofl>
    883d:	83 c4 0c             	add    $0xc,%esp
    8840:	85 c0                	test   %eax,%eax
    8842:	74 0a                	je     884e <lodepng_chunk_append+0x30>
    8844:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8849:	e9 96 00 00 00       	jmp    88e4 <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    884e:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8851:	8b 45 0c             	mov    0xc(%ebp),%eax
    8854:	8b 00                	mov    (%eax),%eax
    8856:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    8859:	51                   	push   %ecx
    885a:	52                   	push   %edx
    885b:	50                   	push   %eax
    885c:	e8 d1 ac ff ff       	call   3532 <lodepng_addofl>
    8861:	83 c4 0c             	add    $0xc,%esp
    8864:	85 c0                	test   %eax,%eax
    8866:	74 07                	je     886f <lodepng_chunk_append+0x51>
    8868:	b8 4d 00 00 00       	mov    $0x4d,%eax
    886d:	eb 75                	jmp    88e4 <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    886f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8872:	8b 45 08             	mov    0x8(%ebp),%eax
    8875:	8b 00                	mov    (%eax),%eax
    8877:	52                   	push   %edx
    8878:	50                   	push   %eax
    8879:	e8 07 ac ff ff       	call   3485 <lodepng_realloc>
    887e:	83 c4 08             	add    $0x8,%esp
    8881:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    8884:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    8888:	75 07                	jne    8891 <lodepng_chunk_append+0x73>
    888a:	b8 53 00 00 00       	mov    $0x53,%eax
    888f:	eb 53                	jmp    88e4 <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    8891:	8b 45 08             	mov    0x8(%ebp),%eax
    8894:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8897:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    8899:	8b 55 ec             	mov    -0x14(%ebp),%edx
    889c:	8b 45 0c             	mov    0xc(%ebp),%eax
    889f:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    88a1:	8b 45 08             	mov    0x8(%ebp),%eax
    88a4:	8b 00                	mov    (%eax),%eax
    88a6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    88a9:	8b 55 f0             	mov    -0x10(%ebp),%edx
    88ac:	29 d1                	sub    %edx,%ecx
    88ae:	89 ca                	mov    %ecx,%edx
    88b0:	01 d0                	add    %edx,%eax
    88b2:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    88b5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    88bc:	eb 19                	jmp    88d7 <lodepng_chunk_append+0xb9>
    88be:	8b 55 f4             	mov    -0xc(%ebp),%edx
    88c1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    88c4:	01 c2                	add    %eax,%edx
    88c6:	8b 4d 10             	mov    0x10(%ebp),%ecx
    88c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    88cc:	01 c8                	add    %ecx,%eax
    88ce:	0f b6 00             	movzbl (%eax),%eax
    88d1:	88 02                	mov    %al,(%edx)
    88d3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    88d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    88da:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    88dd:	75 df                	jne    88be <lodepng_chunk_append+0xa0>

  return 0;
    88df:	b8 00 00 00 00       	mov    $0x0,%eax
}
    88e4:	c9                   	leave  
    88e5:	c3                   	ret    

000088e6 <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    88e6:	55                   	push   %ebp
    88e7:	89 e5                	mov    %esp,%ebp
    88e9:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    88ec:	8b 45 0c             	mov    0xc(%ebp),%eax
    88ef:	8b 40 04             	mov    0x4(%eax),%eax
    88f2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    88f5:	8b 55 10             	mov    0x10(%ebp),%edx
    88f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    88fb:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    88fe:	51                   	push   %ecx
    88ff:	52                   	push   %edx
    8900:	50                   	push   %eax
    8901:	e8 2c ac ff ff       	call   3532 <lodepng_addofl>
    8906:	83 c4 0c             	add    $0xc,%esp
    8909:	85 c0                	test   %eax,%eax
    890b:	74 07                	je     8914 <lodepng_chunk_init+0x2e>
    890d:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8912:	eb 78                	jmp    898c <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    8914:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8917:	8d 55 fc             	lea    -0x4(%ebp),%edx
    891a:	52                   	push   %edx
    891b:	6a 0c                	push   $0xc
    891d:	50                   	push   %eax
    891e:	e8 0f ac ff ff       	call   3532 <lodepng_addofl>
    8923:	83 c4 0c             	add    $0xc,%esp
    8926:	85 c0                	test   %eax,%eax
    8928:	74 07                	je     8931 <lodepng_chunk_init+0x4b>
    892a:	b8 4d 00 00 00       	mov    $0x4d,%eax
    892f:	eb 5b                	jmp    898c <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    8931:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8934:	50                   	push   %eax
    8935:	ff 75 0c             	pushl  0xc(%ebp)
    8938:	e8 8b ad ff ff       	call   36c8 <ucvector_resize>
    893d:	83 c4 08             	add    $0x8,%esp
    8940:	85 c0                	test   %eax,%eax
    8942:	75 07                	jne    894b <lodepng_chunk_init+0x65>
    8944:	b8 53 00 00 00       	mov    $0x53,%eax
    8949:	eb 41                	jmp    898c <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    894b:	8b 45 0c             	mov    0xc(%ebp),%eax
    894e:	8b 00                	mov    (%eax),%eax
    8950:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8953:	2b 55 10             	sub    0x10(%ebp),%edx
    8956:	83 ea 0c             	sub    $0xc,%edx
    8959:	01 c2                	add    %eax,%edx
    895b:	8b 45 08             	mov    0x8(%ebp),%eax
    895e:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    8960:	8b 45 08             	mov    0x8(%ebp),%eax
    8963:	8b 00                	mov    (%eax),%eax
    8965:	ff 75 10             	pushl  0x10(%ebp)
    8968:	50                   	push   %eax
    8969:	e8 c1 ae ff ff       	call   382f <lodepng_set32bitInt>
    896e:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    8971:	8b 45 08             	mov    0x8(%ebp),%eax
    8974:	8b 00                	mov    (%eax),%eax
    8976:	83 c0 04             	add    $0x4,%eax
    8979:	6a 04                	push   $0x4
    897b:	ff 75 14             	pushl  0x14(%ebp)
    897e:	50                   	push   %eax
    897f:	e8 28 ab ff ff       	call   34ac <lodepng_memcpy>
    8984:	83 c4 0c             	add    $0xc,%esp

  return 0;
    8987:	b8 00 00 00 00       	mov    $0x0,%eax
}
    898c:	c9                   	leave  
    898d:	c3                   	ret    

0000898e <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    898e:	55                   	push   %ebp
    898f:	89 e5                	mov    %esp,%ebp
    8991:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    8994:	ff 75 10             	pushl  0x10(%ebp)
    8997:	ff 75 0c             	pushl  0xc(%ebp)
    899a:	ff 75 08             	pushl  0x8(%ebp)
    899d:	8d 45 f8             	lea    -0x8(%ebp),%eax
    89a0:	50                   	push   %eax
    89a1:	e8 40 ff ff ff       	call   88e6 <lodepng_chunk_init>
    89a6:	83 c4 10             	add    $0x10,%esp
    89a9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    89ac:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    89b0:	74 05                	je     89b7 <lodepng_chunk_createv+0x29>
    89b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    89b5:	eb 27                	jmp    89de <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    89b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    89ba:	8b 55 f8             	mov    -0x8(%ebp),%edx
    89bd:	83 c2 08             	add    $0x8,%edx
    89c0:	50                   	push   %eax
    89c1:	ff 75 14             	pushl  0x14(%ebp)
    89c4:	52                   	push   %edx
    89c5:	e8 e2 aa ff ff       	call   34ac <lodepng_memcpy>
    89ca:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    89cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    89d0:	50                   	push   %eax
    89d1:	e8 b9 fb ff ff       	call   858f <lodepng_chunk_generate_crc>
    89d6:	83 c4 04             	add    $0x4,%esp

  return 0;
    89d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    89de:	c9                   	leave  
    89df:	c3                   	ret    

000089e0 <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    89e0:	55                   	push   %ebp
    89e1:	89 e5                	mov    %esp,%ebp
    89e3:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    89e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    89e9:	8b 08                	mov    (%eax),%ecx
    89eb:	8b 45 08             	mov    0x8(%ebp),%eax
    89ee:	8b 10                	mov    (%eax),%edx
    89f0:	8d 45 f0             	lea    -0x10(%ebp),%eax
    89f3:	51                   	push   %ecx
    89f4:	52                   	push   %edx
    89f5:	50                   	push   %eax
    89f6:	e8 34 ad ff ff       	call   372f <ucvector_init>
    89fb:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    89fe:	ff 75 18             	pushl  0x18(%ebp)
    8a01:	ff 75 14             	pushl  0x14(%ebp)
    8a04:	ff 75 10             	pushl  0x10(%ebp)
    8a07:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8a0a:	50                   	push   %eax
    8a0b:	e8 7e ff ff ff       	call   898e <lodepng_chunk_createv>
    8a10:	83 c4 10             	add    $0x10,%esp
    8a13:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    8a16:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8a19:	8b 45 08             	mov    0x8(%ebp),%eax
    8a1c:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8a1e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8a21:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a24:	89 10                	mov    %edx,(%eax)
  return error;
    8a26:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    8a29:	c9                   	leave  
    8a2a:	c3                   	ret    

00008a2b <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    8a2b:	55                   	push   %ebp
    8a2c:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8a2e:	8b 45 08             	mov    0x8(%ebp),%eax
    8a31:	83 f8 03             	cmp    $0x3,%eax
    8a34:	74 6d                	je     8aa3 <checkColorValidity+0x78>
    8a36:	83 f8 03             	cmp    $0x3,%eax
    8a39:	77 0e                	ja     8a49 <checkColorValidity+0x1e>
    8a3b:	85 c0                	test   %eax,%eax
    8a3d:	74 28                	je     8a67 <checkColorValidity+0x3c>
    8a3f:	83 f8 02             	cmp    $0x2,%eax
    8a42:	74 4c                	je     8a90 <checkColorValidity+0x65>
    8a44:	e9 a6 00 00 00       	jmp    8aef <checkColorValidity+0xc4>
    8a49:	83 f8 06             	cmp    $0x6,%eax
    8a4c:	0f 84 83 00 00 00    	je     8ad5 <checkColorValidity+0xaa>
    8a52:	3d ff 00 00 00       	cmp    $0xff,%eax
    8a57:	0f 84 8b 00 00 00    	je     8ae8 <checkColorValidity+0xbd>
    8a5d:	83 f8 04             	cmp    $0x4,%eax
    8a60:	74 60                	je     8ac2 <checkColorValidity+0x97>
    8a62:	e9 88 00 00 00       	jmp    8aef <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    8a67:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8a6b:	0f 84 85 00 00 00    	je     8af6 <checkColorValidity+0xcb>
    8a71:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8a75:	74 7f                	je     8af6 <checkColorValidity+0xcb>
    8a77:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8a7b:	74 79                	je     8af6 <checkColorValidity+0xcb>
    8a7d:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8a81:	74 73                	je     8af6 <checkColorValidity+0xcb>
    8a83:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8a87:	74 6d                	je     8af6 <checkColorValidity+0xcb>
    8a89:	b8 25 00 00 00       	mov    $0x25,%eax
    8a8e:	eb 78                	jmp    8b08 <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8a90:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8a94:	74 63                	je     8af9 <checkColorValidity+0xce>
    8a96:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8a9a:	74 5d                	je     8af9 <checkColorValidity+0xce>
    8a9c:	b8 25 00 00 00       	mov    $0x25,%eax
    8aa1:	eb 65                	jmp    8b08 <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8aa3:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8aa7:	74 53                	je     8afc <checkColorValidity+0xd1>
    8aa9:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8aad:	74 4d                	je     8afc <checkColorValidity+0xd1>
    8aaf:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8ab3:	74 47                	je     8afc <checkColorValidity+0xd1>
    8ab5:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8ab9:	74 41                	je     8afc <checkColorValidity+0xd1>
    8abb:	b8 25 00 00 00       	mov    $0x25,%eax
    8ac0:	eb 46                	jmp    8b08 <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8ac2:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8ac6:	74 37                	je     8aff <checkColorValidity+0xd4>
    8ac8:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8acc:	74 31                	je     8aff <checkColorValidity+0xd4>
    8ace:	b8 25 00 00 00       	mov    $0x25,%eax
    8ad3:	eb 33                	jmp    8b08 <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8ad5:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8ad9:	74 27                	je     8b02 <checkColorValidity+0xd7>
    8adb:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8adf:	74 21                	je     8b02 <checkColorValidity+0xd7>
    8ae1:	b8 25 00 00 00       	mov    $0x25,%eax
    8ae6:	eb 20                	jmp    8b08 <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    8ae8:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8aed:	eb 19                	jmp    8b08 <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    8aef:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8af4:	eb 12                	jmp    8b08 <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    8af6:	90                   	nop
    8af7:	eb 0a                	jmp    8b03 <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8af9:	90                   	nop
    8afa:	eb 07                	jmp    8b03 <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8afc:	90                   	nop
    8afd:	eb 04                	jmp    8b03 <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8aff:	90                   	nop
    8b00:	eb 01                	jmp    8b03 <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8b02:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    8b03:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8b08:	5d                   	pop    %ebp
    8b09:	c3                   	ret    

00008b0a <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    8b0a:	55                   	push   %ebp
    8b0b:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8b0d:	8b 45 08             	mov    0x8(%ebp),%eax
    8b10:	83 f8 03             	cmp    $0x3,%eax
    8b13:	74 31                	je     8b46 <getNumColorChannels+0x3c>
    8b15:	83 f8 03             	cmp    $0x3,%eax
    8b18:	77 0b                	ja     8b25 <getNumColorChannels+0x1b>
    8b1a:	85 c0                	test   %eax,%eax
    8b1c:	74 1a                	je     8b38 <getNumColorChannels+0x2e>
    8b1e:	83 f8 02             	cmp    $0x2,%eax
    8b21:	74 1c                	je     8b3f <getNumColorChannels+0x35>
    8b23:	eb 3d                	jmp    8b62 <getNumColorChannels+0x58>
    8b25:	83 f8 06             	cmp    $0x6,%eax
    8b28:	74 2a                	je     8b54 <getNumColorChannels+0x4a>
    8b2a:	3d ff 00 00 00       	cmp    $0xff,%eax
    8b2f:	74 2a                	je     8b5b <getNumColorChannels+0x51>
    8b31:	83 f8 04             	cmp    $0x4,%eax
    8b34:	74 17                	je     8b4d <getNumColorChannels+0x43>
    8b36:	eb 2a                	jmp    8b62 <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    8b38:	b8 01 00 00 00       	mov    $0x1,%eax
    8b3d:	eb 28                	jmp    8b67 <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    8b3f:	b8 03 00 00 00       	mov    $0x3,%eax
    8b44:	eb 21                	jmp    8b67 <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    8b46:	b8 01 00 00 00       	mov    $0x1,%eax
    8b4b:	eb 1a                	jmp    8b67 <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    8b4d:	b8 02 00 00 00       	mov    $0x2,%eax
    8b52:	eb 13                	jmp    8b67 <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    8b54:	b8 04 00 00 00       	mov    $0x4,%eax
    8b59:	eb 0c                	jmp    8b67 <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    8b5b:	b8 00 00 00 00       	mov    $0x0,%eax
    8b60:	eb 05                	jmp    8b67 <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    8b62:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    8b67:	5d                   	pop    %ebp
    8b68:	c3                   	ret    

00008b69 <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    8b69:	55                   	push   %ebp
    8b6a:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    8b6c:	ff 75 08             	pushl  0x8(%ebp)
    8b6f:	e8 96 ff ff ff       	call   8b0a <getNumColorChannels>
    8b74:	83 c4 04             	add    $0x4,%esp
    8b77:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    8b7b:	c9                   	leave  
    8b7c:	c3                   	ret    

00008b7d <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    8b7d:	55                   	push   %ebp
    8b7e:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    8b80:	8b 45 08             	mov    0x8(%ebp),%eax
    8b83:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    8b8a:	8b 45 08             	mov    0x8(%ebp),%eax
    8b8d:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    8b94:	8b 45 08             	mov    0x8(%ebp),%eax
    8b97:	8b 50 1c             	mov    0x1c(%eax),%edx
    8b9a:	8b 45 08             	mov    0x8(%ebp),%eax
    8b9d:	89 50 18             	mov    %edx,0x18(%eax)
    8ba0:	8b 45 08             	mov    0x8(%ebp),%eax
    8ba3:	8b 50 18             	mov    0x18(%eax),%edx
    8ba6:	8b 45 08             	mov    0x8(%ebp),%eax
    8ba9:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    8bac:	8b 45 08             	mov    0x8(%ebp),%eax
    8baf:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    8bb5:	8b 45 08             	mov    0x8(%ebp),%eax
    8bb8:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    8bbf:	8b 45 08             	mov    0x8(%ebp),%eax
    8bc2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8bc9:	8b 45 08             	mov    0x8(%ebp),%eax
    8bcc:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8bd3:	90                   	nop
    8bd4:	5d                   	pop    %ebp
    8bd5:	c3                   	ret    

00008bd6 <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    8bd6:	55                   	push   %ebp
    8bd7:	89 e5                	mov    %esp,%ebp
    8bd9:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    8bdc:	8b 45 08             	mov    0x8(%ebp),%eax
    8bdf:	8b 40 08             	mov    0x8(%eax),%eax
    8be2:	85 c0                	test   %eax,%eax
    8be4:	75 18                	jne    8bfe <lodepng_color_mode_alloc_palette+0x28>
    8be6:	83 ec 0c             	sub    $0xc,%esp
    8be9:	68 00 04 00 00       	push   $0x400
    8bee:	e8 7b a8 ff ff       	call   346e <lodepng_malloc>
    8bf3:	83 c4 10             	add    $0x10,%esp
    8bf6:	89 c2                	mov    %eax,%edx
    8bf8:	8b 45 08             	mov    0x8(%ebp),%eax
    8bfb:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    8bfe:	8b 45 08             	mov    0x8(%ebp),%eax
    8c01:	8b 40 08             	mov    0x8(%eax),%eax
    8c04:	85 c0                	test   %eax,%eax
    8c06:	74 65                	je     8c6d <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    8c08:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8c0f:	eb 51                	jmp    8c62 <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    8c11:	8b 45 08             	mov    0x8(%ebp),%eax
    8c14:	8b 40 08             	mov    0x8(%eax),%eax
    8c17:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8c1a:	c1 e2 02             	shl    $0x2,%edx
    8c1d:	01 d0                	add    %edx,%eax
    8c1f:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    8c22:	8b 45 08             	mov    0x8(%ebp),%eax
    8c25:	8b 40 08             	mov    0x8(%eax),%eax
    8c28:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8c2b:	c1 e2 02             	shl    $0x2,%edx
    8c2e:	83 c2 01             	add    $0x1,%edx
    8c31:	01 d0                	add    %edx,%eax
    8c33:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    8c36:	8b 45 08             	mov    0x8(%ebp),%eax
    8c39:	8b 40 08             	mov    0x8(%eax),%eax
    8c3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8c3f:	c1 e2 02             	shl    $0x2,%edx
    8c42:	83 c2 02             	add    $0x2,%edx
    8c45:	01 d0                	add    %edx,%eax
    8c47:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    8c4a:	8b 45 08             	mov    0x8(%ebp),%eax
    8c4d:	8b 40 08             	mov    0x8(%eax),%eax
    8c50:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8c53:	c1 e2 02             	shl    $0x2,%edx
    8c56:	83 c2 03             	add    $0x3,%edx
    8c59:	01 d0                	add    %edx,%eax
    8c5b:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    8c5e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8c62:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    8c69:	75 a6                	jne    8c11 <lodepng_color_mode_alloc_palette+0x3b>
    8c6b:	eb 01                	jmp    8c6e <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    8c6d:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    8c6e:	c9                   	leave  
    8c6f:	c3                   	ret    

00008c70 <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    8c70:	55                   	push   %ebp
    8c71:	89 e5                	mov    %esp,%ebp
    8c73:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    8c76:	83 ec 0c             	sub    $0xc,%esp
    8c79:	ff 75 08             	pushl  0x8(%ebp)
    8c7c:	e8 f3 01 00 00       	call   8e74 <lodepng_palette_clear>
    8c81:	83 c4 10             	add    $0x10,%esp
}
    8c84:	90                   	nop
    8c85:	c9                   	leave  
    8c86:	c3                   	ret    

00008c87 <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    8c87:	55                   	push   %ebp
    8c88:	89 e5                	mov    %esp,%ebp
    8c8a:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    8c8d:	83 ec 0c             	sub    $0xc,%esp
    8c90:	ff 75 08             	pushl  0x8(%ebp)
    8c93:	e8 d8 ff ff ff       	call   8c70 <lodepng_color_mode_cleanup>
    8c98:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    8c9b:	83 ec 04             	sub    $0x4,%esp
    8c9e:	6a 20                	push   $0x20
    8ca0:	ff 75 0c             	pushl  0xc(%ebp)
    8ca3:	ff 75 08             	pushl  0x8(%ebp)
    8ca6:	e8 01 a8 ff ff       	call   34ac <lodepng_memcpy>
    8cab:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    8cae:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cb1:	8b 40 08             	mov    0x8(%eax),%eax
    8cb4:	85 c0                	test   %eax,%eax
    8cb6:	74 5a                	je     8d12 <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    8cb8:	83 ec 0c             	sub    $0xc,%esp
    8cbb:	68 00 04 00 00       	push   $0x400
    8cc0:	e8 a9 a7 ff ff       	call   346e <lodepng_malloc>
    8cc5:	83 c4 10             	add    $0x10,%esp
    8cc8:	89 c2                	mov    %eax,%edx
    8cca:	8b 45 08             	mov    0x8(%ebp),%eax
    8ccd:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    8cd0:	8b 45 08             	mov    0x8(%ebp),%eax
    8cd3:	8b 40 08             	mov    0x8(%eax),%eax
    8cd6:	85 c0                	test   %eax,%eax
    8cd8:	75 11                	jne    8ceb <lodepng_color_mode_copy+0x64>
    8cda:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cdd:	8b 40 0c             	mov    0xc(%eax),%eax
    8ce0:	85 c0                	test   %eax,%eax
    8ce2:	74 07                	je     8ceb <lodepng_color_mode_copy+0x64>
    8ce4:	b8 53 00 00 00       	mov    $0x53,%eax
    8ce9:	eb 2c                	jmp    8d17 <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    8ceb:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cee:	8b 40 0c             	mov    0xc(%eax),%eax
    8cf1:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    8cf8:	8b 45 0c             	mov    0xc(%ebp),%eax
    8cfb:	8b 50 08             	mov    0x8(%eax),%edx
    8cfe:	8b 45 08             	mov    0x8(%ebp),%eax
    8d01:	8b 40 08             	mov    0x8(%eax),%eax
    8d04:	83 ec 04             	sub    $0x4,%esp
    8d07:	51                   	push   %ecx
    8d08:	52                   	push   %edx
    8d09:	50                   	push   %eax
    8d0a:	e8 9d a7 ff ff       	call   34ac <lodepng_memcpy>
    8d0f:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    8d12:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8d17:	c9                   	leave  
    8d18:	c3                   	ret    

00008d19 <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    8d19:	55                   	push   %ebp
    8d1a:	89 e5                	mov    %esp,%ebp
    8d1c:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    8d1f:	8d 45 e0             	lea    -0x20(%ebp),%eax
    8d22:	50                   	push   %eax
    8d23:	e8 55 fe ff ff       	call   8b7d <lodepng_color_mode_init>
    8d28:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    8d2b:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d2e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    8d31:	8b 45 10             	mov    0x10(%ebp),%eax
    8d34:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    8d37:	8b 45 08             	mov    0x8(%ebp),%eax
    8d3a:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8d3d:	89 10                	mov    %edx,(%eax)
    8d3f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8d42:	89 50 04             	mov    %edx,0x4(%eax)
    8d45:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8d48:	89 50 08             	mov    %edx,0x8(%eax)
    8d4b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8d4e:	89 50 0c             	mov    %edx,0xc(%eax)
    8d51:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8d54:	89 50 10             	mov    %edx,0x10(%eax)
    8d57:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8d5a:	89 50 14             	mov    %edx,0x14(%eax)
    8d5d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8d60:	89 50 18             	mov    %edx,0x18(%eax)
    8d63:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8d66:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    8d69:	8b 45 08             	mov    0x8(%ebp),%eax
    8d6c:	c9                   	leave  
    8d6d:	c2 04 00             	ret    $0x4

00008d70 <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    8d70:	55                   	push   %ebp
    8d71:	89 e5                	mov    %esp,%ebp
    8d73:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    8d76:	8b 45 08             	mov    0x8(%ebp),%eax
    8d79:	8b 10                	mov    (%eax),%edx
    8d7b:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d7e:	8b 00                	mov    (%eax),%eax
    8d80:	39 c2                	cmp    %eax,%edx
    8d82:	74 0a                	je     8d8e <lodepng_color_mode_equal+0x1e>
    8d84:	b8 00 00 00 00       	mov    $0x0,%eax
    8d89:	e9 e4 00 00 00       	jmp    8e72 <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    8d8e:	8b 45 08             	mov    0x8(%ebp),%eax
    8d91:	8b 50 04             	mov    0x4(%eax),%edx
    8d94:	8b 45 0c             	mov    0xc(%ebp),%eax
    8d97:	8b 40 04             	mov    0x4(%eax),%eax
    8d9a:	39 c2                	cmp    %eax,%edx
    8d9c:	74 0a                	je     8da8 <lodepng_color_mode_equal+0x38>
    8d9e:	b8 00 00 00 00       	mov    $0x0,%eax
    8da3:	e9 ca 00 00 00       	jmp    8e72 <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    8da8:	8b 45 08             	mov    0x8(%ebp),%eax
    8dab:	8b 50 10             	mov    0x10(%eax),%edx
    8dae:	8b 45 0c             	mov    0xc(%ebp),%eax
    8db1:	8b 40 10             	mov    0x10(%eax),%eax
    8db4:	39 c2                	cmp    %eax,%edx
    8db6:	74 0a                	je     8dc2 <lodepng_color_mode_equal+0x52>
    8db8:	b8 00 00 00 00       	mov    $0x0,%eax
    8dbd:	e9 b0 00 00 00       	jmp    8e72 <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    8dc2:	8b 45 08             	mov    0x8(%ebp),%eax
    8dc5:	8b 40 10             	mov    0x10(%eax),%eax
    8dc8:	85 c0                	test   %eax,%eax
    8dca:	74 48                	je     8e14 <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    8dcc:	8b 45 08             	mov    0x8(%ebp),%eax
    8dcf:	8b 50 14             	mov    0x14(%eax),%edx
    8dd2:	8b 45 0c             	mov    0xc(%ebp),%eax
    8dd5:	8b 40 14             	mov    0x14(%eax),%eax
    8dd8:	39 c2                	cmp    %eax,%edx
    8dda:	74 0a                	je     8de6 <lodepng_color_mode_equal+0x76>
    8ddc:	b8 00 00 00 00       	mov    $0x0,%eax
    8de1:	e9 8c 00 00 00       	jmp    8e72 <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    8de6:	8b 45 08             	mov    0x8(%ebp),%eax
    8de9:	8b 50 18             	mov    0x18(%eax),%edx
    8dec:	8b 45 0c             	mov    0xc(%ebp),%eax
    8def:	8b 40 18             	mov    0x18(%eax),%eax
    8df2:	39 c2                	cmp    %eax,%edx
    8df4:	74 07                	je     8dfd <lodepng_color_mode_equal+0x8d>
    8df6:	b8 00 00 00 00       	mov    $0x0,%eax
    8dfb:	eb 75                	jmp    8e72 <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    8dfd:	8b 45 08             	mov    0x8(%ebp),%eax
    8e00:	8b 50 1c             	mov    0x1c(%eax),%edx
    8e03:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e06:	8b 40 1c             	mov    0x1c(%eax),%eax
    8e09:	39 c2                	cmp    %eax,%edx
    8e0b:	74 07                	je     8e14 <lodepng_color_mode_equal+0xa4>
    8e0d:	b8 00 00 00 00       	mov    $0x0,%eax
    8e12:	eb 5e                	jmp    8e72 <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    8e14:	8b 45 08             	mov    0x8(%ebp),%eax
    8e17:	8b 50 0c             	mov    0xc(%eax),%edx
    8e1a:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e1d:	8b 40 0c             	mov    0xc(%eax),%eax
    8e20:	39 c2                	cmp    %eax,%edx
    8e22:	74 07                	je     8e2b <lodepng_color_mode_equal+0xbb>
    8e24:	b8 00 00 00 00       	mov    $0x0,%eax
    8e29:	eb 47                	jmp    8e72 <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    8e2b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8e32:	eb 2b                	jmp    8e5f <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    8e34:	8b 45 08             	mov    0x8(%ebp),%eax
    8e37:	8b 50 08             	mov    0x8(%eax),%edx
    8e3a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8e3d:	01 d0                	add    %edx,%eax
    8e3f:	0f b6 10             	movzbl (%eax),%edx
    8e42:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e45:	8b 48 08             	mov    0x8(%eax),%ecx
    8e48:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8e4b:	01 c8                	add    %ecx,%eax
    8e4d:	0f b6 00             	movzbl (%eax),%eax
    8e50:	38 c2                	cmp    %al,%dl
    8e52:	74 07                	je     8e5b <lodepng_color_mode_equal+0xeb>
    8e54:	b8 00 00 00 00       	mov    $0x0,%eax
    8e59:	eb 17                	jmp    8e72 <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    8e5b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8e5f:	8b 45 08             	mov    0x8(%ebp),%eax
    8e62:	8b 40 0c             	mov    0xc(%eax),%eax
    8e65:	c1 e0 02             	shl    $0x2,%eax
    8e68:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8e6b:	75 c7                	jne    8e34 <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    8e6d:	b8 01 00 00 00       	mov    $0x1,%eax
}
    8e72:	c9                   	leave  
    8e73:	c3                   	ret    

00008e74 <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    8e74:	55                   	push   %ebp
    8e75:	89 e5                	mov    %esp,%ebp
    8e77:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    8e7a:	8b 45 08             	mov    0x8(%ebp),%eax
    8e7d:	8b 40 08             	mov    0x8(%eax),%eax
    8e80:	85 c0                	test   %eax,%eax
    8e82:	74 12                	je     8e96 <lodepng_palette_clear+0x22>
    8e84:	8b 45 08             	mov    0x8(%ebp),%eax
    8e87:	8b 40 08             	mov    0x8(%eax),%eax
    8e8a:	83 ec 0c             	sub    $0xc,%esp
    8e8d:	50                   	push   %eax
    8e8e:	e8 fc a5 ff ff       	call   348f <lodepng_free>
    8e93:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    8e96:	8b 45 08             	mov    0x8(%ebp),%eax
    8e99:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8ea0:	8b 45 08             	mov    0x8(%ebp),%eax
    8ea3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8eaa:	90                   	nop
    8eab:	c9                   	leave  
    8eac:	c3                   	ret    

00008ead <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    8ead:	55                   	push   %ebp
    8eae:	89 e5                	mov    %esp,%ebp
    8eb0:	53                   	push   %ebx
    8eb1:	83 ec 14             	sub    $0x14,%esp
    8eb4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    8eb7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8eba:	8b 55 14             	mov    0x14(%ebp),%edx
    8ebd:	8b 45 18             	mov    0x18(%ebp),%eax
    8ec0:	88 5d f4             	mov    %bl,-0xc(%ebp)
    8ec3:	88 4d f0             	mov    %cl,-0x10(%ebp)
    8ec6:	88 55 ec             	mov    %dl,-0x14(%ebp)
    8ec9:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    8ecc:	8b 45 08             	mov    0x8(%ebp),%eax
    8ecf:	8b 40 08             	mov    0x8(%eax),%eax
    8ed2:	85 c0                	test   %eax,%eax
    8ed4:	75 22                	jne    8ef8 <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    8ed6:	83 ec 0c             	sub    $0xc,%esp
    8ed9:	ff 75 08             	pushl  0x8(%ebp)
    8edc:	e8 f5 fc ff ff       	call   8bd6 <lodepng_color_mode_alloc_palette>
    8ee1:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    8ee4:	8b 45 08             	mov    0x8(%ebp),%eax
    8ee7:	8b 40 08             	mov    0x8(%eax),%eax
    8eea:	85 c0                	test   %eax,%eax
    8eec:	75 0a                	jne    8ef8 <lodepng_palette_add+0x4b>
    8eee:	b8 53 00 00 00       	mov    $0x53,%eax
    8ef3:	e9 8d 00 00 00       	jmp    8f85 <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    8ef8:	8b 45 08             	mov    0x8(%ebp),%eax
    8efb:	8b 40 0c             	mov    0xc(%eax),%eax
    8efe:	3d ff 00 00 00       	cmp    $0xff,%eax
    8f03:	7e 07                	jle    8f0c <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    8f05:	b8 6c 00 00 00       	mov    $0x6c,%eax
    8f0a:	eb 79                	jmp    8f85 <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    8f0c:	8b 45 08             	mov    0x8(%ebp),%eax
    8f0f:	8b 50 08             	mov    0x8(%eax),%edx
    8f12:	8b 45 08             	mov    0x8(%ebp),%eax
    8f15:	8b 40 0c             	mov    0xc(%eax),%eax
    8f18:	c1 e0 02             	shl    $0x2,%eax
    8f1b:	01 c2                	add    %eax,%edx
    8f1d:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    8f21:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    8f23:	8b 45 08             	mov    0x8(%ebp),%eax
    8f26:	8b 50 08             	mov    0x8(%eax),%edx
    8f29:	8b 45 08             	mov    0x8(%ebp),%eax
    8f2c:	8b 40 0c             	mov    0xc(%eax),%eax
    8f2f:	c1 e0 02             	shl    $0x2,%eax
    8f32:	83 c0 01             	add    $0x1,%eax
    8f35:	01 c2                	add    %eax,%edx
    8f37:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    8f3b:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    8f3d:	8b 45 08             	mov    0x8(%ebp),%eax
    8f40:	8b 50 08             	mov    0x8(%eax),%edx
    8f43:	8b 45 08             	mov    0x8(%ebp),%eax
    8f46:	8b 40 0c             	mov    0xc(%eax),%eax
    8f49:	c1 e0 02             	shl    $0x2,%eax
    8f4c:	83 c0 02             	add    $0x2,%eax
    8f4f:	01 c2                	add    %eax,%edx
    8f51:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    8f55:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    8f57:	8b 45 08             	mov    0x8(%ebp),%eax
    8f5a:	8b 50 08             	mov    0x8(%eax),%edx
    8f5d:	8b 45 08             	mov    0x8(%ebp),%eax
    8f60:	8b 40 0c             	mov    0xc(%eax),%eax
    8f63:	c1 e0 02             	shl    $0x2,%eax
    8f66:	83 c0 03             	add    $0x3,%eax
    8f69:	01 c2                	add    %eax,%edx
    8f6b:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    8f6f:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    8f71:	8b 45 08             	mov    0x8(%ebp),%eax
    8f74:	8b 40 0c             	mov    0xc(%eax),%eax
    8f77:	8d 50 01             	lea    0x1(%eax),%edx
    8f7a:	8b 45 08             	mov    0x8(%ebp),%eax
    8f7d:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    8f80:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8f85:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    8f88:	c9                   	leave  
    8f89:	c3                   	ret    

00008f8a <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    8f8a:	55                   	push   %ebp
    8f8b:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    8f8d:	8b 45 08             	mov    0x8(%ebp),%eax
    8f90:	8b 50 04             	mov    0x4(%eax),%edx
    8f93:	8b 45 08             	mov    0x8(%ebp),%eax
    8f96:	8b 00                	mov    (%eax),%eax
    8f98:	52                   	push   %edx
    8f99:	50                   	push   %eax
    8f9a:	e8 ca fb ff ff       	call   8b69 <lodepng_get_bpp_lct>
    8f9f:	83 c4 08             	add    $0x8,%esp
}
    8fa2:	c9                   	leave  
    8fa3:	c3                   	ret    

00008fa4 <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    8fa4:	55                   	push   %ebp
    8fa5:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    8fa7:	8b 45 08             	mov    0x8(%ebp),%eax
    8faa:	8b 00                	mov    (%eax),%eax
    8fac:	50                   	push   %eax
    8fad:	e8 58 fb ff ff       	call   8b0a <getNumColorChannels>
    8fb2:	83 c4 04             	add    $0x4,%esp
}
    8fb5:	c9                   	leave  
    8fb6:	c3                   	ret    

00008fb7 <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    8fb7:	55                   	push   %ebp
    8fb8:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    8fba:	8b 45 08             	mov    0x8(%ebp),%eax
    8fbd:	8b 00                	mov    (%eax),%eax
    8fbf:	85 c0                	test   %eax,%eax
    8fc1:	74 0a                	je     8fcd <lodepng_is_greyscale_type+0x16>
    8fc3:	8b 45 08             	mov    0x8(%ebp),%eax
    8fc6:	8b 00                	mov    (%eax),%eax
    8fc8:	83 f8 04             	cmp    $0x4,%eax
    8fcb:	75 07                	jne    8fd4 <lodepng_is_greyscale_type+0x1d>
    8fcd:	b8 01 00 00 00       	mov    $0x1,%eax
    8fd2:	eb 05                	jmp    8fd9 <lodepng_is_greyscale_type+0x22>
    8fd4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8fd9:	5d                   	pop    %ebp
    8fda:	c3                   	ret    

00008fdb <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    8fdb:	55                   	push   %ebp
    8fdc:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    8fde:	8b 45 08             	mov    0x8(%ebp),%eax
    8fe1:	8b 00                	mov    (%eax),%eax
    8fe3:	83 e0 04             	and    $0x4,%eax
    8fe6:	85 c0                	test   %eax,%eax
    8fe8:	0f 95 c0             	setne  %al
    8feb:	0f b6 c0             	movzbl %al,%eax
}
    8fee:	5d                   	pop    %ebp
    8fef:	c3                   	ret    

00008ff0 <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    8ff0:	55                   	push   %ebp
    8ff1:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    8ff3:	8b 45 08             	mov    0x8(%ebp),%eax
    8ff6:	8b 00                	mov    (%eax),%eax
    8ff8:	83 f8 03             	cmp    $0x3,%eax
    8ffb:	0f 94 c0             	sete   %al
    8ffe:	0f b6 c0             	movzbl %al,%eax
}
    9001:	5d                   	pop    %ebp
    9002:	c3                   	ret    

00009003 <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    9003:	55                   	push   %ebp
    9004:	89 e5                	mov    %esp,%ebp
    9006:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    9009:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9010:	eb 23                	jmp    9035 <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    9012:	8b 45 08             	mov    0x8(%ebp),%eax
    9015:	8b 40 08             	mov    0x8(%eax),%eax
    9018:	8b 55 fc             	mov    -0x4(%ebp),%edx
    901b:	c1 e2 02             	shl    $0x2,%edx
    901e:	83 c2 03             	add    $0x3,%edx
    9021:	01 d0                	add    %edx,%eax
    9023:	0f b6 00             	movzbl (%eax),%eax
    9026:	3c ff                	cmp    $0xff,%al
    9028:	74 07                	je     9031 <lodepng_has_palette_alpha+0x2e>
    902a:	b8 01 00 00 00       	mov    $0x1,%eax
    902f:	eb 14                	jmp    9045 <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    9031:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9035:	8b 45 08             	mov    0x8(%ebp),%eax
    9038:	8b 40 0c             	mov    0xc(%eax),%eax
    903b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    903e:	75 d2                	jne    9012 <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    9040:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9045:	c9                   	leave  
    9046:	c3                   	ret    

00009047 <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    9047:	55                   	push   %ebp
    9048:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    904a:	8b 45 08             	mov    0x8(%ebp),%eax
    904d:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    9050:	85 c0                	test   %eax,%eax
    9052:	75 1e                	jne    9072 <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    9054:	ff 75 08             	pushl  0x8(%ebp)
    9057:	e8 7f ff ff ff       	call   8fdb <lodepng_is_alpha_type>
    905c:	83 c4 04             	add    $0x4,%esp
    905f:	85 c0                	test   %eax,%eax
    9061:	75 0f                	jne    9072 <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    9063:	ff 75 08             	pushl  0x8(%ebp)
    9066:	e8 98 ff ff ff       	call   9003 <lodepng_has_palette_alpha>
    906b:	83 c4 04             	add    $0x4,%esp
    906e:	85 c0                	test   %eax,%eax
    9070:	74 07                	je     9079 <lodepng_can_have_alpha+0x32>
    9072:	b8 01 00 00 00       	mov    $0x1,%eax
    9077:	eb 05                	jmp    907e <lodepng_can_have_alpha+0x37>
    9079:	b8 00 00 00 00       	mov    $0x0,%eax
}
    907e:	c9                   	leave  
    907f:	c3                   	ret    

00009080 <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    9080:	55                   	push   %ebp
    9081:	89 e5                	mov    %esp,%ebp
    9083:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    9086:	ff 75 14             	pushl  0x14(%ebp)
    9089:	ff 75 10             	pushl  0x10(%ebp)
    908c:	e8 d8 fa ff ff       	call   8b69 <lodepng_get_bpp_lct>
    9091:	83 c4 08             	add    $0x8,%esp
    9094:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    9097:	8b 55 08             	mov    0x8(%ebp),%edx
    909a:	8b 45 0c             	mov    0xc(%ebp),%eax
    909d:	0f af c2             	imul   %edx,%eax
    90a0:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    90a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    90a6:	c1 e8 03             	shr    $0x3,%eax
    90a9:	89 c2                	mov    %eax,%edx
    90ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
    90ae:	0f af c2             	imul   %edx,%eax
    90b1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    90b4:	89 d1                	mov    %edx,%ecx
    90b6:	83 e1 07             	and    $0x7,%ecx
    90b9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    90bc:	0f af d1             	imul   %ecx,%edx
    90bf:	83 c2 07             	add    $0x7,%edx
    90c2:	c1 ea 03             	shr    $0x3,%edx
    90c5:	01 d0                	add    %edx,%eax
}
    90c7:	c9                   	leave  
    90c8:	c3                   	ret    

000090c9 <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    90c9:	55                   	push   %ebp
    90ca:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    90cc:	8b 45 10             	mov    0x10(%ebp),%eax
    90cf:	8b 50 04             	mov    0x4(%eax),%edx
    90d2:	8b 45 10             	mov    0x10(%ebp),%eax
    90d5:	8b 00                	mov    (%eax),%eax
    90d7:	52                   	push   %edx
    90d8:	50                   	push   %eax
    90d9:	ff 75 0c             	pushl  0xc(%ebp)
    90dc:	ff 75 08             	pushl  0x8(%ebp)
    90df:	e8 9c ff ff ff       	call   9080 <lodepng_get_raw_size_lct>
    90e4:	83 c4 10             	add    $0x10,%esp
}
    90e7:	c9                   	leave  
    90e8:	c3                   	ret    

000090e9 <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    90e9:	55                   	push   %ebp
    90ea:	89 e5                	mov    %esp,%ebp
    90ec:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    90ef:	8b 45 08             	mov    0x8(%ebp),%eax
    90f2:	c1 e8 03             	shr    $0x3,%eax
    90f5:	0f af 45 10          	imul   0x10(%ebp),%eax
    90f9:	8b 55 08             	mov    0x8(%ebp),%edx
    90fc:	83 e2 07             	and    $0x7,%edx
    90ff:	0f af 55 10          	imul   0x10(%ebp),%edx
    9103:	83 c2 07             	add    $0x7,%edx
    9106:	c1 ea 03             	shr    $0x3,%edx
    9109:	01 d0                	add    %edx,%eax
    910b:	83 c0 01             	add    $0x1,%eax
    910e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    9111:	8b 45 0c             	mov    0xc(%ebp),%eax
    9114:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    9118:	c9                   	leave  
    9119:	c3                   	ret    

0000911a <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    911a:	55                   	push   %ebp
    911b:	89 e5                	mov    %esp,%ebp
    911d:	53                   	push   %ebx
    911e:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    9121:	ff 75 10             	pushl  0x10(%ebp)
    9124:	e8 61 fe ff ff       	call   8f8a <lodepng_get_bpp>
    9129:	83 c4 04             	add    $0x4,%esp
    912c:	89 c3                	mov    %eax,%ebx
    912e:	ff 75 14             	pushl  0x14(%ebp)
    9131:	e8 54 fe ff ff       	call   8f8a <lodepng_get_bpp>
    9136:	83 c4 04             	add    $0x4,%esp
    9139:	39 c3                	cmp    %eax,%ebx
    913b:	76 0d                	jbe    914a <lodepng_pixel_overflow+0x30>
    913d:	ff 75 10             	pushl  0x10(%ebp)
    9140:	e8 45 fe ff ff       	call   8f8a <lodepng_get_bpp>
    9145:	83 c4 04             	add    $0x4,%esp
    9148:	eb 0b                	jmp    9155 <lodepng_pixel_overflow+0x3b>
    914a:	ff 75 14             	pushl  0x14(%ebp)
    914d:	e8 38 fe ff ff       	call   8f8a <lodepng_get_bpp>
    9152:	83 c4 04             	add    $0x4,%esp
    9155:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    9158:	8b 55 0c             	mov    0xc(%ebp),%edx
    915b:	8b 45 08             	mov    0x8(%ebp),%eax
    915e:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    9161:	51                   	push   %ecx
    9162:	52                   	push   %edx
    9163:	50                   	push   %eax
    9164:	e8 e9 a3 ff ff       	call   3552 <lodepng_mulofl>
    9169:	83 c4 0c             	add    $0xc,%esp
    916c:	85 c0                	test   %eax,%eax
    916e:	74 0a                	je     917a <lodepng_pixel_overflow+0x60>
    9170:	b8 01 00 00 00       	mov    $0x1,%eax
    9175:	e9 b6 00 00 00       	jmp    9230 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    917a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    917d:	8d 55 f0             	lea    -0x10(%ebp),%edx
    9180:	52                   	push   %edx
    9181:	6a 08                	push   $0x8
    9183:	50                   	push   %eax
    9184:	e8 c9 a3 ff ff       	call   3552 <lodepng_mulofl>
    9189:	83 c4 0c             	add    $0xc,%esp
    918c:	85 c0                	test   %eax,%eax
    918e:	74 0a                	je     919a <lodepng_pixel_overflow+0x80>
    9190:	b8 01 00 00 00       	mov    $0x1,%eax
    9195:	e9 96 00 00 00       	jmp    9230 <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    919a:	8b 45 08             	mov    0x8(%ebp),%eax
    919d:	c1 e8 03             	shr    $0x3,%eax
    91a0:	89 c2                	mov    %eax,%edx
    91a2:	8d 45 ec             	lea    -0x14(%ebp),%eax
    91a5:	50                   	push   %eax
    91a6:	ff 75 f8             	pushl  -0x8(%ebp)
    91a9:	52                   	push   %edx
    91aa:	e8 a3 a3 ff ff       	call   3552 <lodepng_mulofl>
    91af:	83 c4 0c             	add    $0xc,%esp
    91b2:	85 c0                	test   %eax,%eax
    91b4:	74 07                	je     91bd <lodepng_pixel_overflow+0xa3>
    91b6:	b8 01 00 00 00       	mov    $0x1,%eax
    91bb:	eb 73                	jmp    9230 <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    91bd:	8b 45 08             	mov    0x8(%ebp),%eax
    91c0:	83 e0 07             	and    $0x7,%eax
    91c3:	89 c2                	mov    %eax,%edx
    91c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    91c8:	0f af c2             	imul   %edx,%eax
    91cb:	83 c0 07             	add    $0x7,%eax
    91ce:	c1 e8 03             	shr    $0x3,%eax
    91d1:	89 c1                	mov    %eax,%ecx
    91d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    91d6:	8d 55 ec             	lea    -0x14(%ebp),%edx
    91d9:	52                   	push   %edx
    91da:	51                   	push   %ecx
    91db:	50                   	push   %eax
    91dc:	e8 51 a3 ff ff       	call   3532 <lodepng_addofl>
    91e1:	83 c4 0c             	add    $0xc,%esp
    91e4:	85 c0                	test   %eax,%eax
    91e6:	74 07                	je     91ef <lodepng_pixel_overflow+0xd5>
    91e8:	b8 01 00 00 00       	mov    $0x1,%eax
    91ed:	eb 41                	jmp    9230 <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    91ef:	8b 45 ec             	mov    -0x14(%ebp),%eax
    91f2:	8d 55 ec             	lea    -0x14(%ebp),%edx
    91f5:	52                   	push   %edx
    91f6:	6a 05                	push   $0x5
    91f8:	50                   	push   %eax
    91f9:	e8 34 a3 ff ff       	call   3532 <lodepng_addofl>
    91fe:	83 c4 0c             	add    $0xc,%esp
    9201:	85 c0                	test   %eax,%eax
    9203:	74 07                	je     920c <lodepng_pixel_overflow+0xf2>
    9205:	b8 01 00 00 00       	mov    $0x1,%eax
    920a:	eb 24                	jmp    9230 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    920c:	8b 55 0c             	mov    0xc(%ebp),%edx
    920f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9212:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    9215:	51                   	push   %ecx
    9216:	52                   	push   %edx
    9217:	50                   	push   %eax
    9218:	e8 35 a3 ff ff       	call   3552 <lodepng_mulofl>
    921d:	83 c4 0c             	add    $0xc,%esp
    9220:	85 c0                	test   %eax,%eax
    9222:	74 07                	je     922b <lodepng_pixel_overflow+0x111>
    9224:	b8 01 00 00 00       	mov    $0x1,%eax
    9229:	eb 05                	jmp    9230 <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    922b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9230:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9233:	c9                   	leave  
    9234:	c3                   	ret    

00009235 <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    9235:	55                   	push   %ebp
    9236:	89 e5                	mov    %esp,%ebp
    9238:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    923b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9242:	eb 15                	jmp    9259 <LodePNGUnknownChunks_init+0x24>
    9244:	8b 45 08             	mov    0x8(%ebp),%eax
    9247:	8b 55 fc             	mov    -0x4(%ebp),%edx
    924a:	83 c2 30             	add    $0x30,%edx
    924d:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    9254:	00 
    9255:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    9259:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    925d:	75 e5                	jne    9244 <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    925f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9266:	eb 15                	jmp    927d <LodePNGUnknownChunks_init+0x48>
    9268:	8b 45 08             	mov    0x8(%ebp),%eax
    926b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    926e:	83 c2 34             	add    $0x34,%edx
    9271:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    9278:	00 
    9279:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    927d:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    9281:	75 e5                	jne    9268 <LodePNGUnknownChunks_init+0x33>
}
    9283:	90                   	nop
    9284:	c9                   	leave  
    9285:	c3                   	ret    

00009286 <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    9286:	55                   	push   %ebp
    9287:	89 e5                	mov    %esp,%ebp
    9289:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    928c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9293:	eb 1d                	jmp    92b2 <LodePNGUnknownChunks_cleanup+0x2c>
    9295:	8b 45 08             	mov    0x8(%ebp),%eax
    9298:	8b 55 f4             	mov    -0xc(%ebp),%edx
    929b:	83 c2 30             	add    $0x30,%edx
    929e:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    92a2:	83 ec 0c             	sub    $0xc,%esp
    92a5:	50                   	push   %eax
    92a6:	e8 e4 a1 ff ff       	call   348f <lodepng_free>
    92ab:	83 c4 10             	add    $0x10,%esp
    92ae:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    92b2:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    92b6:	75 dd                	jne    9295 <LodePNGUnknownChunks_cleanup+0xf>
}
    92b8:	90                   	nop
    92b9:	c9                   	leave  
    92ba:	c3                   	ret    

000092bb <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    92bb:	55                   	push   %ebp
    92bc:	89 e5                	mov    %esp,%ebp
    92be:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    92c1:	83 ec 0c             	sub    $0xc,%esp
    92c4:	ff 75 08             	pushl  0x8(%ebp)
    92c7:	e8 ba ff ff ff       	call   9286 <LodePNGUnknownChunks_cleanup>
    92cc:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    92cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    92d6:	e9 b7 00 00 00       	jmp    9392 <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    92db:	8b 45 0c             	mov    0xc(%ebp),%eax
    92de:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92e1:	83 c2 34             	add    $0x34,%edx
    92e4:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    92e8:	8b 45 08             	mov    0x8(%ebp),%eax
    92eb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    92ee:	83 c1 34             	add    $0x34,%ecx
    92f1:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    92f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    92f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    92fb:	83 c2 34             	add    $0x34,%edx
    92fe:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9302:	83 ec 0c             	sub    $0xc,%esp
    9305:	50                   	push   %eax
    9306:	e8 63 a1 ff ff       	call   346e <lodepng_malloc>
    930b:	83 c4 10             	add    $0x10,%esp
    930e:	89 c1                	mov    %eax,%ecx
    9310:	8b 45 08             	mov    0x8(%ebp),%eax
    9313:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9316:	83 c2 30             	add    $0x30,%edx
    9319:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    931d:	8b 45 08             	mov    0x8(%ebp),%eax
    9320:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9323:	83 c2 30             	add    $0x30,%edx
    9326:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    932a:	85 c0                	test   %eax,%eax
    932c:	75 18                	jne    9346 <LodePNGUnknownChunks_copy+0x8b>
    932e:	8b 45 08             	mov    0x8(%ebp),%eax
    9331:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9334:	83 c2 34             	add    $0x34,%edx
    9337:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    933b:	85 c0                	test   %eax,%eax
    933d:	74 07                	je     9346 <LodePNGUnknownChunks_copy+0x8b>
    933f:	b8 53 00 00 00       	mov    $0x53,%eax
    9344:	eb 5b                	jmp    93a1 <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    9346:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    934d:	eb 2d                	jmp    937c <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    934f:	8b 45 08             	mov    0x8(%ebp),%eax
    9352:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9355:	83 c2 30             	add    $0x30,%edx
    9358:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    935c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    935f:	01 c2                	add    %eax,%edx
    9361:	8b 45 0c             	mov    0xc(%ebp),%eax
    9364:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9367:	83 c1 30             	add    $0x30,%ecx
    936a:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    936e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9371:	01 c8                	add    %ecx,%eax
    9373:	0f b6 00             	movzbl (%eax),%eax
    9376:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    9378:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    937c:	8b 45 0c             	mov    0xc(%ebp),%eax
    937f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9382:	83 c2 34             	add    $0x34,%edx
    9385:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9389:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    938c:	7f c1                	jg     934f <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    938e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9392:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    9396:	0f 85 3f ff ff ff    	jne    92db <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    939c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    93a1:	c9                   	leave  
    93a2:	c3                   	ret    

000093a3 <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    93a3:	55                   	push   %ebp
    93a4:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    93a6:	8b 45 08             	mov    0x8(%ebp),%eax
    93a9:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    93b0:	8b 45 08             	mov    0x8(%ebp),%eax
    93b3:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    93ba:	8b 45 08             	mov    0x8(%ebp),%eax
    93bd:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    93c4:	90                   	nop
    93c5:	5d                   	pop    %ebp
    93c6:	c3                   	ret    

000093c7 <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    93c7:	55                   	push   %ebp
    93c8:	89 e5                	mov    %esp,%ebp
    93ca:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    93cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    93d4:	eb 38                	jmp    940e <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    93d6:	8b 45 08             	mov    0x8(%ebp),%eax
    93d9:	8b 40 40             	mov    0x40(%eax),%eax
    93dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    93df:	c1 e2 02             	shl    $0x2,%edx
    93e2:	01 d0                	add    %edx,%eax
    93e4:	83 ec 0c             	sub    $0xc,%esp
    93e7:	50                   	push   %eax
    93e8:	e8 75 a3 ff ff       	call   3762 <string_cleanup>
    93ed:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    93f0:	8b 45 08             	mov    0x8(%ebp),%eax
    93f3:	8b 40 44             	mov    0x44(%eax),%eax
    93f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    93f9:	c1 e2 02             	shl    $0x2,%edx
    93fc:	01 d0                	add    %edx,%eax
    93fe:	83 ec 0c             	sub    $0xc,%esp
    9401:	50                   	push   %eax
    9402:	e8 5b a3 ff ff       	call   3762 <string_cleanup>
    9407:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    940a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    940e:	8b 45 08             	mov    0x8(%ebp),%eax
    9411:	8b 40 3c             	mov    0x3c(%eax),%eax
    9414:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9417:	75 bd                	jne    93d6 <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    9419:	8b 45 08             	mov    0x8(%ebp),%eax
    941c:	8b 40 40             	mov    0x40(%eax),%eax
    941f:	83 ec 0c             	sub    $0xc,%esp
    9422:	50                   	push   %eax
    9423:	e8 67 a0 ff ff       	call   348f <lodepng_free>
    9428:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    942b:	8b 45 08             	mov    0x8(%ebp),%eax
    942e:	8b 40 44             	mov    0x44(%eax),%eax
    9431:	83 ec 0c             	sub    $0xc,%esp
    9434:	50                   	push   %eax
    9435:	e8 55 a0 ff ff       	call   348f <lodepng_free>
    943a:	83 c4 10             	add    $0x10,%esp
}
    943d:	90                   	nop
    943e:	c9                   	leave  
    943f:	c3                   	ret    

00009440 <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9440:	55                   	push   %ebp
    9441:	89 e5                	mov    %esp,%ebp
    9443:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    9446:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    944d:	8b 45 08             	mov    0x8(%ebp),%eax
    9450:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    9457:	8b 45 08             	mov    0x8(%ebp),%eax
    945a:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    9461:	8b 45 08             	mov    0x8(%ebp),%eax
    9464:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    946b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9472:	eb 42                	jmp    94b6 <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    9474:	8b 45 0c             	mov    0xc(%ebp),%eax
    9477:	8b 40 44             	mov    0x44(%eax),%eax
    947a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    947d:	c1 e2 02             	shl    $0x2,%edx
    9480:	01 d0                	add    %edx,%eax
    9482:	8b 10                	mov    (%eax),%edx
    9484:	8b 45 0c             	mov    0xc(%ebp),%eax
    9487:	8b 40 40             	mov    0x40(%eax),%eax
    948a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    948d:	c1 e1 02             	shl    $0x2,%ecx
    9490:	01 c8                	add    %ecx,%eax
    9492:	8b 00                	mov    (%eax),%eax
    9494:	83 ec 04             	sub    $0x4,%esp
    9497:	52                   	push   %edx
    9498:	50                   	push   %eax
    9499:	ff 75 08             	pushl  0x8(%ebp)
    949c:	e8 4d 01 00 00       	call   95ee <lodepng_add_text>
    94a1:	83 c4 10             	add    $0x10,%esp
    94a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    94a7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    94ab:	74 05                	je     94b2 <LodePNGText_copy+0x72>
    94ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
    94b0:	eb 14                	jmp    94c6 <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    94b2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    94b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    94b9:	8b 40 3c             	mov    0x3c(%eax),%eax
    94bc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    94bf:	75 b3                	jne    9474 <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    94c1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    94c6:	c9                   	leave  
    94c7:	c3                   	ret    

000094c8 <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    94c8:	55                   	push   %ebp
    94c9:	89 e5                	mov    %esp,%ebp
    94cb:	53                   	push   %ebx
    94cc:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    94cf:	8b 45 08             	mov    0x8(%ebp),%eax
    94d2:	8b 40 3c             	mov    0x3c(%eax),%eax
    94d5:	83 c0 01             	add    $0x1,%eax
    94d8:	c1 e0 02             	shl    $0x2,%eax
    94db:	89 c2                	mov    %eax,%edx
    94dd:	8b 45 08             	mov    0x8(%ebp),%eax
    94e0:	8b 40 40             	mov    0x40(%eax),%eax
    94e3:	52                   	push   %edx
    94e4:	50                   	push   %eax
    94e5:	e8 9b 9f ff ff       	call   3485 <lodepng_realloc>
    94ea:	83 c4 08             	add    $0x8,%esp
    94ed:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    94f0:	8b 45 08             	mov    0x8(%ebp),%eax
    94f3:	8b 40 3c             	mov    0x3c(%eax),%eax
    94f6:	83 c0 01             	add    $0x1,%eax
    94f9:	c1 e0 02             	shl    $0x2,%eax
    94fc:	89 c2                	mov    %eax,%edx
    94fe:	8b 45 08             	mov    0x8(%ebp),%eax
    9501:	8b 40 44             	mov    0x44(%eax),%eax
    9504:	52                   	push   %edx
    9505:	50                   	push   %eax
    9506:	e8 7a 9f ff ff       	call   3485 <lodepng_realloc>
    950b:	83 c4 08             	add    $0x8,%esp
    950e:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    9511:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9515:	74 09                	je     9520 <lodepng_add_text_sized+0x58>
    9517:	8b 45 08             	mov    0x8(%ebp),%eax
    951a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    951d:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    9520:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9524:	74 09                	je     952f <lodepng_add_text_sized+0x67>
    9526:	8b 45 08             	mov    0x8(%ebp),%eax
    9529:	8b 55 f0             	mov    -0x10(%ebp),%edx
    952c:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    952f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9533:	74 06                	je     953b <lodepng_add_text_sized+0x73>
    9535:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9539:	75 0a                	jne    9545 <lodepng_add_text_sized+0x7d>
    953b:	b8 53 00 00 00       	mov    $0x53,%eax
    9540:	e9 a4 00 00 00       	jmp    95e9 <lodepng_add_text_sized+0x121>

  ++info->text_num;
    9545:	8b 45 08             	mov    0x8(%ebp),%eax
    9548:	8b 40 3c             	mov    0x3c(%eax),%eax
    954b:	8d 50 01             	lea    0x1(%eax),%edx
    954e:	8b 45 08             	mov    0x8(%ebp),%eax
    9551:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    9554:	8b 45 08             	mov    0x8(%ebp),%eax
    9557:	8b 50 40             	mov    0x40(%eax),%edx
    955a:	8b 45 08             	mov    0x8(%ebp),%eax
    955d:	8b 40 3c             	mov    0x3c(%eax),%eax
    9560:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9565:	c1 e0 02             	shl    $0x2,%eax
    9568:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    956b:	83 ec 0c             	sub    $0xc,%esp
    956e:	ff 75 0c             	pushl  0xc(%ebp)
    9571:	e8 54 a2 ff ff       	call   37ca <alloc_string>
    9576:	83 c4 10             	add    $0x10,%esp
    9579:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    957b:	8b 45 08             	mov    0x8(%ebp),%eax
    957e:	8b 50 44             	mov    0x44(%eax),%edx
    9581:	8b 45 08             	mov    0x8(%ebp),%eax
    9584:	8b 40 3c             	mov    0x3c(%eax),%eax
    9587:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    958c:	c1 e0 02             	shl    $0x2,%eax
    958f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9592:	83 ec 08             	sub    $0x8,%esp
    9595:	ff 75 14             	pushl  0x14(%ebp)
    9598:	ff 75 10             	pushl  0x10(%ebp)
    959b:	e8 e5 a1 ff ff       	call   3785 <alloc_string_sized>
    95a0:	83 c4 10             	add    $0x10,%esp
    95a3:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    95a5:	8b 45 08             	mov    0x8(%ebp),%eax
    95a8:	8b 50 40             	mov    0x40(%eax),%edx
    95ab:	8b 45 08             	mov    0x8(%ebp),%eax
    95ae:	8b 40 3c             	mov    0x3c(%eax),%eax
    95b1:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    95b6:	c1 e0 02             	shl    $0x2,%eax
    95b9:	01 d0                	add    %edx,%eax
    95bb:	8b 00                	mov    (%eax),%eax
    95bd:	85 c0                	test   %eax,%eax
    95bf:	74 1c                	je     95dd <lodepng_add_text_sized+0x115>
    95c1:	8b 45 08             	mov    0x8(%ebp),%eax
    95c4:	8b 50 44             	mov    0x44(%eax),%edx
    95c7:	8b 45 08             	mov    0x8(%ebp),%eax
    95ca:	8b 40 3c             	mov    0x3c(%eax),%eax
    95cd:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    95d2:	c1 e0 02             	shl    $0x2,%eax
    95d5:	01 d0                	add    %edx,%eax
    95d7:	8b 00                	mov    (%eax),%eax
    95d9:	85 c0                	test   %eax,%eax
    95db:	75 07                	jne    95e4 <lodepng_add_text_sized+0x11c>
    95dd:	b8 53 00 00 00       	mov    $0x53,%eax
    95e2:	eb 05                	jmp    95e9 <lodepng_add_text_sized+0x121>

  return 0;
    95e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    95e9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    95ec:	c9                   	leave  
    95ed:	c3                   	ret    

000095ee <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    95ee:	55                   	push   %ebp
    95ef:	89 e5                	mov    %esp,%ebp
    95f1:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    95f4:	ff 75 10             	pushl  0x10(%ebp)
    95f7:	e8 0e 9f ff ff       	call   350a <lodepng_strlen>
    95fc:	83 c4 04             	add    $0x4,%esp
    95ff:	50                   	push   %eax
    9600:	ff 75 10             	pushl  0x10(%ebp)
    9603:	ff 75 0c             	pushl  0xc(%ebp)
    9606:	ff 75 08             	pushl  0x8(%ebp)
    9609:	e8 ba fe ff ff       	call   94c8 <lodepng_add_text_sized>
    960e:	83 c4 10             	add    $0x10,%esp
}
    9611:	c9                   	leave  
    9612:	c3                   	ret    

00009613 <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    9613:	55                   	push   %ebp
    9614:	89 e5                	mov    %esp,%ebp
    9616:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    9619:	83 ec 0c             	sub    $0xc,%esp
    961c:	ff 75 08             	pushl  0x8(%ebp)
    961f:	e8 a3 fd ff ff       	call   93c7 <LodePNGText_cleanup>
    9624:	83 c4 10             	add    $0x10,%esp
}
    9627:	90                   	nop
    9628:	c9                   	leave  
    9629:	c3                   	ret    

0000962a <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    962a:	55                   	push   %ebp
    962b:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    962d:	8b 45 08             	mov    0x8(%ebp),%eax
    9630:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    9637:	8b 45 08             	mov    0x8(%ebp),%eax
    963a:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    9641:	8b 45 08             	mov    0x8(%ebp),%eax
    9644:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    964b:	8b 45 08             	mov    0x8(%ebp),%eax
    964e:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    9655:	8b 45 08             	mov    0x8(%ebp),%eax
    9658:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    965f:	90                   	nop
    9660:	5d                   	pop    %ebp
    9661:	c3                   	ret    

00009662 <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    9662:	55                   	push   %ebp
    9663:	89 e5                	mov    %esp,%ebp
    9665:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    9668:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    966f:	eb 6c                	jmp    96dd <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    9671:	8b 45 08             	mov    0x8(%ebp),%eax
    9674:	8b 40 4c             	mov    0x4c(%eax),%eax
    9677:	8b 55 f4             	mov    -0xc(%ebp),%edx
    967a:	c1 e2 02             	shl    $0x2,%edx
    967d:	01 d0                	add    %edx,%eax
    967f:	83 ec 0c             	sub    $0xc,%esp
    9682:	50                   	push   %eax
    9683:	e8 da a0 ff ff       	call   3762 <string_cleanup>
    9688:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    968b:	8b 45 08             	mov    0x8(%ebp),%eax
    968e:	8b 40 50             	mov    0x50(%eax),%eax
    9691:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9694:	c1 e2 02             	shl    $0x2,%edx
    9697:	01 d0                	add    %edx,%eax
    9699:	83 ec 0c             	sub    $0xc,%esp
    969c:	50                   	push   %eax
    969d:	e8 c0 a0 ff ff       	call   3762 <string_cleanup>
    96a2:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    96a5:	8b 45 08             	mov    0x8(%ebp),%eax
    96a8:	8b 40 54             	mov    0x54(%eax),%eax
    96ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
    96ae:	c1 e2 02             	shl    $0x2,%edx
    96b1:	01 d0                	add    %edx,%eax
    96b3:	83 ec 0c             	sub    $0xc,%esp
    96b6:	50                   	push   %eax
    96b7:	e8 a6 a0 ff ff       	call   3762 <string_cleanup>
    96bc:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    96bf:	8b 45 08             	mov    0x8(%ebp),%eax
    96c2:	8b 40 58             	mov    0x58(%eax),%eax
    96c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    96c8:	c1 e2 02             	shl    $0x2,%edx
    96cb:	01 d0                	add    %edx,%eax
    96cd:	83 ec 0c             	sub    $0xc,%esp
    96d0:	50                   	push   %eax
    96d1:	e8 8c a0 ff ff       	call   3762 <string_cleanup>
    96d6:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    96d9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    96dd:	8b 45 08             	mov    0x8(%ebp),%eax
    96e0:	8b 40 48             	mov    0x48(%eax),%eax
    96e3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    96e6:	75 89                	jne    9671 <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    96e8:	8b 45 08             	mov    0x8(%ebp),%eax
    96eb:	8b 40 4c             	mov    0x4c(%eax),%eax
    96ee:	83 ec 0c             	sub    $0xc,%esp
    96f1:	50                   	push   %eax
    96f2:	e8 98 9d ff ff       	call   348f <lodepng_free>
    96f7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    96fa:	8b 45 08             	mov    0x8(%ebp),%eax
    96fd:	8b 40 50             	mov    0x50(%eax),%eax
    9700:	83 ec 0c             	sub    $0xc,%esp
    9703:	50                   	push   %eax
    9704:	e8 86 9d ff ff       	call   348f <lodepng_free>
    9709:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    970c:	8b 45 08             	mov    0x8(%ebp),%eax
    970f:	8b 40 54             	mov    0x54(%eax),%eax
    9712:	83 ec 0c             	sub    $0xc,%esp
    9715:	50                   	push   %eax
    9716:	e8 74 9d ff ff       	call   348f <lodepng_free>
    971b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    971e:	8b 45 08             	mov    0x8(%ebp),%eax
    9721:	8b 40 58             	mov    0x58(%eax),%eax
    9724:	83 ec 0c             	sub    $0xc,%esp
    9727:	50                   	push   %eax
    9728:	e8 62 9d ff ff       	call   348f <lodepng_free>
    972d:	83 c4 10             	add    $0x10,%esp
}
    9730:	90                   	nop
    9731:	c9                   	leave  
    9732:	c3                   	ret    

00009733 <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9733:	55                   	push   %ebp
    9734:	89 e5                	mov    %esp,%ebp
    9736:	56                   	push   %esi
    9737:	53                   	push   %ebx
    9738:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    973b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    9742:	8b 45 08             	mov    0x8(%ebp),%eax
    9745:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    974c:	8b 45 08             	mov    0x8(%ebp),%eax
    974f:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    9756:	8b 45 08             	mov    0x8(%ebp),%eax
    9759:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    9760:	8b 45 08             	mov    0x8(%ebp),%eax
    9763:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    976a:	8b 45 08             	mov    0x8(%ebp),%eax
    976d:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    9774:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    977b:	eb 64                	jmp    97e1 <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    977d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9780:	8b 40 58             	mov    0x58(%eax),%eax
    9783:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9786:	c1 e2 02             	shl    $0x2,%edx
    9789:	01 d0                	add    %edx,%eax
    978b:	8b 18                	mov    (%eax),%ebx
    978d:	8b 45 0c             	mov    0xc(%ebp),%eax
    9790:	8b 40 54             	mov    0x54(%eax),%eax
    9793:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9796:	c1 e2 02             	shl    $0x2,%edx
    9799:	01 d0                	add    %edx,%eax
    979b:	8b 08                	mov    (%eax),%ecx
    979d:	8b 45 0c             	mov    0xc(%ebp),%eax
    97a0:	8b 40 50             	mov    0x50(%eax),%eax
    97a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    97a6:	c1 e2 02             	shl    $0x2,%edx
    97a9:	01 d0                	add    %edx,%eax
    97ab:	8b 10                	mov    (%eax),%edx
    97ad:	8b 45 0c             	mov    0xc(%ebp),%eax
    97b0:	8b 40 4c             	mov    0x4c(%eax),%eax
    97b3:	8b 75 f4             	mov    -0xc(%ebp),%esi
    97b6:	c1 e6 02             	shl    $0x2,%esi
    97b9:	01 f0                	add    %esi,%eax
    97bb:	8b 00                	mov    (%eax),%eax
    97bd:	83 ec 0c             	sub    $0xc,%esp
    97c0:	53                   	push   %ebx
    97c1:	51                   	push   %ecx
    97c2:	52                   	push   %edx
    97c3:	50                   	push   %eax
    97c4:	ff 75 08             	pushl  0x8(%ebp)
    97c7:	e8 e4 01 00 00       	call   99b0 <lodepng_add_itext>
    97cc:	83 c4 20             	add    $0x20,%esp
    97cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    97d2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    97d6:	74 05                	je     97dd <LodePNGIText_copy+0xaa>
    97d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    97db:	eb 14                	jmp    97f1 <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    97dd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    97e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    97e4:	8b 40 48             	mov    0x48(%eax),%eax
    97e7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    97ea:	75 91                	jne    977d <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    97ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
    97f1:	8d 65 f8             	lea    -0x8(%ebp),%esp
    97f4:	5b                   	pop    %ebx
    97f5:	5e                   	pop    %esi
    97f6:	5d                   	pop    %ebp
    97f7:	c3                   	ret    

000097f8 <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    97f8:	55                   	push   %ebp
    97f9:	89 e5                	mov    %esp,%ebp
    97fb:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    97fe:	83 ec 0c             	sub    $0xc,%esp
    9801:	ff 75 08             	pushl  0x8(%ebp)
    9804:	e8 59 fe ff ff       	call   9662 <LodePNGIText_cleanup>
    9809:	83 c4 10             	add    $0x10,%esp
}
    980c:	90                   	nop
    980d:	c9                   	leave  
    980e:	c3                   	ret    

0000980f <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    980f:	55                   	push   %ebp
    9810:	89 e5                	mov    %esp,%ebp
    9812:	53                   	push   %ebx
    9813:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    9816:	8b 45 08             	mov    0x8(%ebp),%eax
    9819:	8b 40 48             	mov    0x48(%eax),%eax
    981c:	83 c0 01             	add    $0x1,%eax
    981f:	c1 e0 02             	shl    $0x2,%eax
    9822:	89 c2                	mov    %eax,%edx
    9824:	8b 45 08             	mov    0x8(%ebp),%eax
    9827:	8b 40 4c             	mov    0x4c(%eax),%eax
    982a:	52                   	push   %edx
    982b:	50                   	push   %eax
    982c:	e8 54 9c ff ff       	call   3485 <lodepng_realloc>
    9831:	83 c4 08             	add    $0x8,%esp
    9834:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    9837:	8b 45 08             	mov    0x8(%ebp),%eax
    983a:	8b 40 48             	mov    0x48(%eax),%eax
    983d:	83 c0 01             	add    $0x1,%eax
    9840:	c1 e0 02             	shl    $0x2,%eax
    9843:	89 c2                	mov    %eax,%edx
    9845:	8b 45 08             	mov    0x8(%ebp),%eax
    9848:	8b 40 50             	mov    0x50(%eax),%eax
    984b:	52                   	push   %edx
    984c:	50                   	push   %eax
    984d:	e8 33 9c ff ff       	call   3485 <lodepng_realloc>
    9852:	83 c4 08             	add    $0x8,%esp
    9855:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    9858:	8b 45 08             	mov    0x8(%ebp),%eax
    985b:	8b 40 48             	mov    0x48(%eax),%eax
    985e:	83 c0 01             	add    $0x1,%eax
    9861:	c1 e0 02             	shl    $0x2,%eax
    9864:	89 c2                	mov    %eax,%edx
    9866:	8b 45 08             	mov    0x8(%ebp),%eax
    9869:	8b 40 54             	mov    0x54(%eax),%eax
    986c:	52                   	push   %edx
    986d:	50                   	push   %eax
    986e:	e8 12 9c ff ff       	call   3485 <lodepng_realloc>
    9873:	83 c4 08             	add    $0x8,%esp
    9876:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    9879:	8b 45 08             	mov    0x8(%ebp),%eax
    987c:	8b 40 48             	mov    0x48(%eax),%eax
    987f:	83 c0 01             	add    $0x1,%eax
    9882:	c1 e0 02             	shl    $0x2,%eax
    9885:	89 c2                	mov    %eax,%edx
    9887:	8b 45 08             	mov    0x8(%ebp),%eax
    988a:	8b 40 58             	mov    0x58(%eax),%eax
    988d:	52                   	push   %edx
    988e:	50                   	push   %eax
    988f:	e8 f1 9b ff ff       	call   3485 <lodepng_realloc>
    9894:	83 c4 08             	add    $0x8,%esp
    9897:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    989a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    989e:	74 09                	je     98a9 <lodepng_add_itext_sized+0x9a>
    98a0:	8b 45 08             	mov    0x8(%ebp),%eax
    98a3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    98a6:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    98a9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    98ad:	74 09                	je     98b8 <lodepng_add_itext_sized+0xa9>
    98af:	8b 45 08             	mov    0x8(%ebp),%eax
    98b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    98b5:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    98b8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    98bc:	74 09                	je     98c7 <lodepng_add_itext_sized+0xb8>
    98be:	8b 45 08             	mov    0x8(%ebp),%eax
    98c1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    98c4:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    98c7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    98cb:	74 09                	je     98d6 <lodepng_add_itext_sized+0xc7>
    98cd:	8b 45 08             	mov    0x8(%ebp),%eax
    98d0:	8b 55 e8             	mov    -0x18(%ebp),%edx
    98d3:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    98d6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    98da:	74 12                	je     98ee <lodepng_add_itext_sized+0xdf>
    98dc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    98e0:	74 0c                	je     98ee <lodepng_add_itext_sized+0xdf>
    98e2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    98e6:	74 06                	je     98ee <lodepng_add_itext_sized+0xdf>
    98e8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    98ec:	75 0a                	jne    98f8 <lodepng_add_itext_sized+0xe9>
    98ee:	b8 53 00 00 00       	mov    $0x53,%eax
    98f3:	e9 b3 00 00 00       	jmp    99ab <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    98f8:	8b 45 08             	mov    0x8(%ebp),%eax
    98fb:	8b 40 48             	mov    0x48(%eax),%eax
    98fe:	8d 50 01             	lea    0x1(%eax),%edx
    9901:	8b 45 08             	mov    0x8(%ebp),%eax
    9904:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    9907:	8b 45 08             	mov    0x8(%ebp),%eax
    990a:	8b 50 4c             	mov    0x4c(%eax),%edx
    990d:	8b 45 08             	mov    0x8(%ebp),%eax
    9910:	8b 40 48             	mov    0x48(%eax),%eax
    9913:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9918:	c1 e0 02             	shl    $0x2,%eax
    991b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    991e:	83 ec 0c             	sub    $0xc,%esp
    9921:	ff 75 0c             	pushl  0xc(%ebp)
    9924:	e8 a1 9e ff ff       	call   37ca <alloc_string>
    9929:	83 c4 10             	add    $0x10,%esp
    992c:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    992e:	8b 45 08             	mov    0x8(%ebp),%eax
    9931:	8b 50 50             	mov    0x50(%eax),%edx
    9934:	8b 45 08             	mov    0x8(%ebp),%eax
    9937:	8b 40 48             	mov    0x48(%eax),%eax
    993a:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    993f:	c1 e0 02             	shl    $0x2,%eax
    9942:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9945:	83 ec 0c             	sub    $0xc,%esp
    9948:	ff 75 10             	pushl  0x10(%ebp)
    994b:	e8 7a 9e ff ff       	call   37ca <alloc_string>
    9950:	83 c4 10             	add    $0x10,%esp
    9953:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    9955:	8b 45 08             	mov    0x8(%ebp),%eax
    9958:	8b 50 54             	mov    0x54(%eax),%edx
    995b:	8b 45 08             	mov    0x8(%ebp),%eax
    995e:	8b 40 48             	mov    0x48(%eax),%eax
    9961:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9966:	c1 e0 02             	shl    $0x2,%eax
    9969:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    996c:	83 ec 0c             	sub    $0xc,%esp
    996f:	ff 75 14             	pushl  0x14(%ebp)
    9972:	e8 53 9e ff ff       	call   37ca <alloc_string>
    9977:	83 c4 10             	add    $0x10,%esp
    997a:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    997c:	8b 45 08             	mov    0x8(%ebp),%eax
    997f:	8b 50 58             	mov    0x58(%eax),%edx
    9982:	8b 45 08             	mov    0x8(%ebp),%eax
    9985:	8b 40 48             	mov    0x48(%eax),%eax
    9988:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    998d:	c1 e0 02             	shl    $0x2,%eax
    9990:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9993:	83 ec 08             	sub    $0x8,%esp
    9996:	ff 75 1c             	pushl  0x1c(%ebp)
    9999:	ff 75 18             	pushl  0x18(%ebp)
    999c:	e8 e4 9d ff ff       	call   3785 <alloc_string_sized>
    99a1:	83 c4 10             	add    $0x10,%esp
    99a4:	89 03                	mov    %eax,(%ebx)

  return 0;
    99a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
    99ab:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    99ae:	c9                   	leave  
    99af:	c3                   	ret    

000099b0 <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    99b0:	55                   	push   %ebp
    99b1:	89 e5                	mov    %esp,%ebp
    99b3:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    99b6:	ff 75 18             	pushl  0x18(%ebp)
    99b9:	e8 4c 9b ff ff       	call   350a <lodepng_strlen>
    99be:	83 c4 04             	add    $0x4,%esp
    99c1:	83 ec 08             	sub    $0x8,%esp
    99c4:	50                   	push   %eax
    99c5:	ff 75 18             	pushl  0x18(%ebp)
    99c8:	ff 75 14             	pushl  0x14(%ebp)
    99cb:	ff 75 10             	pushl  0x10(%ebp)
    99ce:	ff 75 0c             	pushl  0xc(%ebp)
    99d1:	ff 75 08             	pushl  0x8(%ebp)
    99d4:	e8 36 fe ff ff       	call   980f <lodepng_add_itext_sized>
    99d9:	83 c4 20             	add    $0x20,%esp
}
    99dc:	c9                   	leave  
    99dd:	c3                   	ret    

000099de <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    99de:	55                   	push   %ebp
    99df:	89 e5                	mov    %esp,%ebp
    99e1:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    99e4:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    99e8:	75 0a                	jne    99f4 <lodepng_assign_icc+0x16>
    99ea:	b8 64 00 00 00       	mov    $0x64,%eax
    99ef:	e9 81 00 00 00       	jmp    9a75 <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    99f4:	83 ec 0c             	sub    $0xc,%esp
    99f7:	ff 75 0c             	pushl  0xc(%ebp)
    99fa:	e8 cb 9d ff ff       	call   37ca <alloc_string>
    99ff:	83 c4 10             	add    $0x10,%esp
    9a02:	89 c2                	mov    %eax,%edx
    9a04:	8b 45 08             	mov    0x8(%ebp),%eax
    9a07:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    9a0d:	8b 45 14             	mov    0x14(%ebp),%eax
    9a10:	83 ec 0c             	sub    $0xc,%esp
    9a13:	50                   	push   %eax
    9a14:	e8 55 9a ff ff       	call   346e <lodepng_malloc>
    9a19:	83 c4 10             	add    $0x10,%esp
    9a1c:	89 c2                	mov    %eax,%edx
    9a1e:	8b 45 08             	mov    0x8(%ebp),%eax
    9a21:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    9a27:	8b 45 08             	mov    0x8(%ebp),%eax
    9a2a:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9a30:	85 c0                	test   %eax,%eax
    9a32:	74 0d                	je     9a41 <lodepng_assign_icc+0x63>
    9a34:	8b 45 08             	mov    0x8(%ebp),%eax
    9a37:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9a3d:	85 c0                	test   %eax,%eax
    9a3f:	75 07                	jne    9a48 <lodepng_assign_icc+0x6a>
    9a41:	b8 53 00 00 00       	mov    $0x53,%eax
    9a46:	eb 2d                	jmp    9a75 <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    9a48:	8b 55 14             	mov    0x14(%ebp),%edx
    9a4b:	8b 45 08             	mov    0x8(%ebp),%eax
    9a4e:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9a54:	83 ec 04             	sub    $0x4,%esp
    9a57:	52                   	push   %edx
    9a58:	ff 75 10             	pushl  0x10(%ebp)
    9a5b:	50                   	push   %eax
    9a5c:	e8 4b 9a ff ff       	call   34ac <lodepng_memcpy>
    9a61:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    9a64:	8b 45 08             	mov    0x8(%ebp),%eax
    9a67:	8b 55 14             	mov    0x14(%ebp),%edx
    9a6a:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    9a70:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9a75:	c9                   	leave  
    9a76:	c3                   	ret    

00009a77 <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9a77:	55                   	push   %ebp
    9a78:	89 e5                	mov    %esp,%ebp
    9a7a:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    9a7d:	8b 45 08             	mov    0x8(%ebp),%eax
    9a80:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9a86:	85 c0                	test   %eax,%eax
    9a88:	74 0e                	je     9a98 <lodepng_set_icc+0x21>
    9a8a:	83 ec 0c             	sub    $0xc,%esp
    9a8d:	ff 75 08             	pushl  0x8(%ebp)
    9a90:	e8 26 00 00 00       	call   9abb <lodepng_clear_icc>
    9a95:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    9a98:	8b 45 08             	mov    0x8(%ebp),%eax
    9a9b:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    9aa2:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    9aa5:	ff 75 14             	pushl  0x14(%ebp)
    9aa8:	ff 75 10             	pushl  0x10(%ebp)
    9aab:	ff 75 0c             	pushl  0xc(%ebp)
    9aae:	ff 75 08             	pushl  0x8(%ebp)
    9ab1:	e8 28 ff ff ff       	call   99de <lodepng_assign_icc>
    9ab6:	83 c4 10             	add    $0x10,%esp
}
    9ab9:	c9                   	leave  
    9aba:	c3                   	ret    

00009abb <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    9abb:	55                   	push   %ebp
    9abc:	89 e5                	mov    %esp,%ebp
    9abe:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    9ac1:	8b 45 08             	mov    0x8(%ebp),%eax
    9ac4:	05 c0 00 00 00       	add    $0xc0,%eax
    9ac9:	83 ec 0c             	sub    $0xc,%esp
    9acc:	50                   	push   %eax
    9acd:	e8 90 9c ff ff       	call   3762 <string_cleanup>
    9ad2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    9ad5:	8b 45 08             	mov    0x8(%ebp),%eax
    9ad8:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9ade:	83 ec 0c             	sub    $0xc,%esp
    9ae1:	50                   	push   %eax
    9ae2:	e8 a8 99 ff ff       	call   348f <lodepng_free>
    9ae7:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    9aea:	8b 45 08             	mov    0x8(%ebp),%eax
    9aed:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9af4:	00 00 00 
  info->iccp_profile_size = 0;
    9af7:	8b 45 08             	mov    0x8(%ebp),%eax
    9afa:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    9b01:	00 00 00 
  info->iccp_defined = 0;
    9b04:	8b 45 08             	mov    0x8(%ebp),%eax
    9b07:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9b0e:	00 00 00 
}
    9b11:	90                   	nop
    9b12:	c9                   	leave  
    9b13:	c3                   	ret    

00009b14 <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    9b14:	55                   	push   %ebp
    9b15:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    9b17:	8b 45 08             	mov    0x8(%ebp),%eax
    9b1a:	83 c0 0c             	add    $0xc,%eax
    9b1d:	50                   	push   %eax
    9b1e:	e8 5a f0 ff ff       	call   8b7d <lodepng_color_mode_init>
    9b23:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    9b26:	8b 45 08             	mov    0x8(%ebp),%eax
    9b29:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    9b30:	8b 45 08             	mov    0x8(%ebp),%eax
    9b33:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    9b39:	8b 45 08             	mov    0x8(%ebp),%eax
    9b3c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    9b43:	8b 45 08             	mov    0x8(%ebp),%eax
    9b46:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    9b4d:	8b 45 08             	mov    0x8(%ebp),%eax
    9b50:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    9b57:	8b 45 08             	mov    0x8(%ebp),%eax
    9b5a:	8b 50 38             	mov    0x38(%eax),%edx
    9b5d:	8b 45 08             	mov    0x8(%ebp),%eax
    9b60:	89 50 34             	mov    %edx,0x34(%eax)
    9b63:	8b 45 08             	mov    0x8(%ebp),%eax
    9b66:	8b 50 34             	mov    0x34(%eax),%edx
    9b69:	8b 45 08             	mov    0x8(%ebp),%eax
    9b6c:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    9b6f:	ff 75 08             	pushl  0x8(%ebp)
    9b72:	e8 2c f8 ff ff       	call   93a3 <LodePNGText_init>
    9b77:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    9b7a:	ff 75 08             	pushl  0x8(%ebp)
    9b7d:	e8 a8 fa ff ff       	call   962a <LodePNGIText_init>
    9b82:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    9b85:	8b 45 08             	mov    0x8(%ebp),%eax
    9b88:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    9b8f:	8b 45 08             	mov    0x8(%ebp),%eax
    9b92:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    9b99:	8b 45 08             	mov    0x8(%ebp),%eax
    9b9c:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    9ba3:	00 00 00 
  info->chrm_defined = 0;
    9ba6:	8b 45 08             	mov    0x8(%ebp),%eax
    9ba9:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    9bb0:	00 00 00 
  info->srgb_defined = 0;
    9bb3:	8b 45 08             	mov    0x8(%ebp),%eax
    9bb6:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    9bbd:	00 00 00 
  info->iccp_defined = 0;
    9bc0:	8b 45 08             	mov    0x8(%ebp),%eax
    9bc3:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9bca:	00 00 00 
  info->iccp_name = NULL;
    9bcd:	8b 45 08             	mov    0x8(%ebp),%eax
    9bd0:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    9bd7:	00 00 00 
  info->iccp_profile = NULL;
    9bda:	8b 45 08             	mov    0x8(%ebp),%eax
    9bdd:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9be4:	00 00 00 

  LodePNGUnknownChunks_init(info);
    9be7:	ff 75 08             	pushl  0x8(%ebp)
    9bea:	e8 46 f6 ff ff       	call   9235 <LodePNGUnknownChunks_init>
    9bef:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9bf2:	90                   	nop
    9bf3:	c9                   	leave  
    9bf4:	c3                   	ret    

00009bf5 <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    9bf5:	55                   	push   %ebp
    9bf6:	89 e5                	mov    %esp,%ebp
    9bf8:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    9bfb:	8b 45 08             	mov    0x8(%ebp),%eax
    9bfe:	83 c0 0c             	add    $0xc,%eax
    9c01:	83 ec 0c             	sub    $0xc,%esp
    9c04:	50                   	push   %eax
    9c05:	e8 66 f0 ff ff       	call   8c70 <lodepng_color_mode_cleanup>
    9c0a:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    9c0d:	83 ec 0c             	sub    $0xc,%esp
    9c10:	ff 75 08             	pushl  0x8(%ebp)
    9c13:	e8 af f7 ff ff       	call   93c7 <LodePNGText_cleanup>
    9c18:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    9c1b:	83 ec 0c             	sub    $0xc,%esp
    9c1e:	ff 75 08             	pushl  0x8(%ebp)
    9c21:	e8 3c fa ff ff       	call   9662 <LodePNGIText_cleanup>
    9c26:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    9c29:	83 ec 0c             	sub    $0xc,%esp
    9c2c:	ff 75 08             	pushl  0x8(%ebp)
    9c2f:	e8 87 fe ff ff       	call   9abb <lodepng_clear_icc>
    9c34:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    9c37:	83 ec 0c             	sub    $0xc,%esp
    9c3a:	ff 75 08             	pushl  0x8(%ebp)
    9c3d:	e8 44 f6 ff ff       	call   9286 <LodePNGUnknownChunks_cleanup>
    9c42:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9c45:	90                   	nop
    9c46:	c9                   	leave  
    9c47:	c3                   	ret    

00009c48 <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9c48:	55                   	push   %ebp
    9c49:	89 e5                	mov    %esp,%ebp
    9c4b:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    9c4e:	83 ec 0c             	sub    $0xc,%esp
    9c51:	ff 75 08             	pushl  0x8(%ebp)
    9c54:	e8 9c ff ff ff       	call   9bf5 <lodepng_info_cleanup>
    9c59:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    9c5c:	83 ec 04             	sub    $0x4,%esp
    9c5f:	68 e4 00 00 00       	push   $0xe4
    9c64:	ff 75 0c             	pushl  0xc(%ebp)
    9c67:	ff 75 08             	pushl  0x8(%ebp)
    9c6a:	e8 3d 98 ff ff       	call   34ac <lodepng_memcpy>
    9c6f:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    9c72:	8b 45 08             	mov    0x8(%ebp),%eax
    9c75:	83 c0 0c             	add    $0xc,%eax
    9c78:	83 ec 0c             	sub    $0xc,%esp
    9c7b:	50                   	push   %eax
    9c7c:	e8 fc ee ff ff       	call   8b7d <lodepng_color_mode_init>
    9c81:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    9c84:	8b 45 0c             	mov    0xc(%ebp),%eax
    9c87:	8d 50 0c             	lea    0xc(%eax),%edx
    9c8a:	8b 45 08             	mov    0x8(%ebp),%eax
    9c8d:	83 c0 0c             	add    $0xc,%eax
    9c90:	83 ec 08             	sub    $0x8,%esp
    9c93:	52                   	push   %edx
    9c94:	50                   	push   %eax
    9c95:	e8 ed ef ff ff       	call   8c87 <lodepng_color_mode_copy>
    9c9a:	83 c4 10             	add    $0x10,%esp
    9c9d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    9ca0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9ca4:	74 08                	je     9cae <lodepng_info_copy+0x66>
    9ca6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9ca9:	e9 b7 00 00 00       	jmp    9d65 <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    9cae:	83 ec 08             	sub    $0x8,%esp
    9cb1:	ff 75 0c             	pushl  0xc(%ebp)
    9cb4:	ff 75 08             	pushl  0x8(%ebp)
    9cb7:	e8 84 f7 ff ff       	call   9440 <LodePNGText_copy>
    9cbc:	83 c4 10             	add    $0x10,%esp
    9cbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9cc2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9cc6:	74 08                	je     9cd0 <lodepng_info_copy+0x88>
    9cc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9ccb:	e9 95 00 00 00       	jmp    9d65 <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    9cd0:	83 ec 08             	sub    $0x8,%esp
    9cd3:	ff 75 0c             	pushl  0xc(%ebp)
    9cd6:	ff 75 08             	pushl  0x8(%ebp)
    9cd9:	e8 55 fa ff ff       	call   9733 <LodePNGIText_copy>
    9cde:	83 c4 10             	add    $0x10,%esp
    9ce1:	89 45 ec             	mov    %eax,-0x14(%ebp)
    9ce4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9ce8:	74 05                	je     9cef <lodepng_info_copy+0xa7>
    9cea:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9ced:	eb 76                	jmp    9d65 <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    9cef:	8b 45 0c             	mov    0xc(%ebp),%eax
    9cf2:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    9cf8:	85 c0                	test   %eax,%eax
    9cfa:	74 37                	je     9d33 <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    9cfc:	8b 45 0c             	mov    0xc(%ebp),%eax
    9cff:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    9d05:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d08:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    9d0e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d11:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9d17:	51                   	push   %ecx
    9d18:	52                   	push   %edx
    9d19:	50                   	push   %eax
    9d1a:	ff 75 08             	pushl  0x8(%ebp)
    9d1d:	e8 bc fc ff ff       	call   99de <lodepng_assign_icc>
    9d22:	83 c4 10             	add    $0x10,%esp
    9d25:	89 45 e8             	mov    %eax,-0x18(%ebp)
    9d28:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9d2c:	74 05                	je     9d33 <lodepng_info_copy+0xeb>
    9d2e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9d31:	eb 32                	jmp    9d65 <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    9d33:	83 ec 0c             	sub    $0xc,%esp
    9d36:	ff 75 08             	pushl  0x8(%ebp)
    9d39:	e8 f7 f4 ff ff       	call   9235 <LodePNGUnknownChunks_init>
    9d3e:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    9d41:	83 ec 08             	sub    $0x8,%esp
    9d44:	ff 75 0c             	pushl  0xc(%ebp)
    9d47:	ff 75 08             	pushl  0x8(%ebp)
    9d4a:	e8 6c f5 ff ff       	call   92bb <LodePNGUnknownChunks_copy>
    9d4f:	83 c4 10             	add    $0x10,%esp
    9d52:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9d55:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    9d59:	74 05                	je     9d60 <lodepng_info_copy+0x118>
    9d5b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9d5e:	eb 05                	jmp    9d65 <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    9d60:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9d65:	c9                   	leave  
    9d66:	c3                   	ret    

00009d67 <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    9d67:	55                   	push   %ebp
    9d68:	89 e5                	mov    %esp,%ebp
    9d6a:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    9d6d:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    9d71:	74 14                	je     9d87 <addColorBits+0x20>
    9d73:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    9d77:	75 07                	jne    9d80 <addColorBits+0x19>
    9d79:	b8 03 00 00 00       	mov    $0x3,%eax
    9d7e:	eb 0c                	jmp    9d8c <addColorBits+0x25>
    9d80:	b8 01 00 00 00       	mov    $0x1,%eax
    9d85:	eb 05                	jmp    9d8c <addColorBits+0x25>
    9d87:	b8 07 00 00 00       	mov    $0x7,%eax
    9d8c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    9d8f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9d92:	23 45 fc             	and    -0x4(%ebp),%eax
    9d95:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    9d98:	8b 45 10             	mov    0x10(%ebp),%eax
    9d9b:	ba 01 00 00 00       	mov    $0x1,%edx
    9da0:	89 c1                	mov    %eax,%ecx
    9da2:	d3 e2                	shl    %cl,%edx
    9da4:	89 d0                	mov    %edx,%eax
    9da6:	83 e8 01             	sub    $0x1,%eax
    9da9:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    9dac:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9daf:	2b 45 f8             	sub    -0x8(%ebp),%eax
    9db2:	0f af 45 10          	imul   0x10(%ebp),%eax
    9db6:	89 c1                	mov    %eax,%ecx
    9db8:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    9dbb:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    9dbf:	75 18                	jne    9dd9 <addColorBits+0x72>
    9dc1:	8b 45 0c             	mov    0xc(%ebp),%eax
    9dc4:	0f af 45 10          	imul   0x10(%ebp),%eax
    9dc8:	c1 e8 03             	shr    $0x3,%eax
    9dcb:	89 c2                	mov    %eax,%edx
    9dcd:	8b 45 08             	mov    0x8(%ebp),%eax
    9dd0:	01 d0                	add    %edx,%eax
    9dd2:	8b 55 14             	mov    0x14(%ebp),%edx
    9dd5:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    9dd7:	eb 1e                	jmp    9df7 <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    9dd9:	8b 45 0c             	mov    0xc(%ebp),%eax
    9ddc:	0f af 45 10          	imul   0x10(%ebp),%eax
    9de0:	c1 e8 03             	shr    $0x3,%eax
    9de3:	8b 55 08             	mov    0x8(%ebp),%edx
    9de6:	01 c2                	add    %eax,%edx
    9de8:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9deb:	01 c8                	add    %ecx,%eax
    9ded:	0f b6 08             	movzbl (%eax),%ecx
    9df0:	8b 45 14             	mov    0x14(%ebp),%eax
    9df3:	09 c8                	or     %ecx,%eax
    9df5:	88 02                	mov    %al,(%edx)
}
    9df7:	90                   	nop
    9df8:	c9                   	leave  
    9df9:	c3                   	ret    

00009dfa <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    9dfa:	55                   	push   %ebp
    9dfb:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    9dfd:	8b 45 08             	mov    0x8(%ebp),%eax
    9e00:	6a 40                	push   $0x40
    9e02:	6a 00                	push   $0x0
    9e04:	50                   	push   %eax
    9e05:	e8 d5 96 ff ff       	call   34df <lodepng_memset>
    9e0a:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    9e0d:	8b 45 08             	mov    0x8(%ebp),%eax
    9e10:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    9e17:	90                   	nop
    9e18:	c9                   	leave  
    9e19:	c3                   	ret    

00009e1a <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    9e1a:	55                   	push   %ebp
    9e1b:	89 e5                	mov    %esp,%ebp
    9e1d:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    9e20:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9e27:	eb 3b                	jmp    9e64 <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    9e29:	8b 45 08             	mov    0x8(%ebp),%eax
    9e2c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9e2f:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9e32:	85 c0                	test   %eax,%eax
    9e34:	74 2a                	je     9e60 <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    9e36:	8b 45 08             	mov    0x8(%ebp),%eax
    9e39:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9e3c:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9e3f:	83 ec 0c             	sub    $0xc,%esp
    9e42:	50                   	push   %eax
    9e43:	e8 d2 ff ff ff       	call   9e1a <color_tree_cleanup>
    9e48:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    9e4b:	8b 45 08             	mov    0x8(%ebp),%eax
    9e4e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9e51:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9e54:	83 ec 0c             	sub    $0xc,%esp
    9e57:	50                   	push   %eax
    9e58:	e8 32 96 ff ff       	call   348f <lodepng_free>
    9e5d:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    9e60:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9e64:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    9e68:	75 bf                	jne    9e29 <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    9e6a:	90                   	nop
    9e6b:	c9                   	leave  
    9e6c:	c3                   	ret    

00009e6d <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9e6d:	55                   	push   %ebp
    9e6e:	89 e5                	mov    %esp,%ebp
    9e70:	53                   	push   %ebx
    9e71:	83 ec 20             	sub    $0x20,%esp
    9e74:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9e77:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9e7a:	8b 55 14             	mov    0x14(%ebp),%edx
    9e7d:	8b 45 18             	mov    0x18(%ebp),%eax
    9e80:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9e83:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9e86:	88 55 e0             	mov    %dl,-0x20(%ebp)
    9e89:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    9e8c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    9e93:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    9e9a:	eb 76                	jmp    9f12 <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9e9c:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    9ea0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9ea3:	89 c1                	mov    %eax,%ecx
    9ea5:	d3 fa                	sar    %cl,%edx
    9ea7:	89 d0                	mov    %edx,%eax
    9ea9:	83 e0 01             	and    $0x1,%eax
    9eac:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9eaf:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9eb3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9eb6:	89 c1                	mov    %eax,%ecx
    9eb8:	d3 fa                	sar    %cl,%edx
    9eba:	89 d0                	mov    %edx,%eax
    9ebc:	83 e0 01             	and    $0x1,%eax
    9ebf:	01 d8                	add    %ebx,%eax
    9ec1:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9ec4:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9ec8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9ecb:	89 c1                	mov    %eax,%ecx
    9ecd:	d3 fa                	sar    %cl,%edx
    9ecf:	89 d0                	mov    %edx,%eax
    9ed1:	83 e0 01             	and    $0x1,%eax
    9ed4:	01 d8                	add    %ebx,%eax
    9ed6:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9ed9:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9edd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9ee0:	89 c1                	mov    %eax,%ecx
    9ee2:	d3 fa                	sar    %cl,%edx
    9ee4:	89 d0                	mov    %edx,%eax
    9ee6:	83 e0 01             	and    $0x1,%eax
    9ee9:	01 d8                	add    %ebx,%eax
    9eeb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    9eee:	8b 45 08             	mov    0x8(%ebp),%eax
    9ef1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9ef4:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9ef7:	85 c0                	test   %eax,%eax
    9ef9:	75 07                	jne    9f02 <color_tree_get+0x95>
    9efb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9f00:	eb 2a                	jmp    9f2c <color_tree_get+0xbf>
    else tree = tree->children[i];
    9f02:	8b 45 08             	mov    0x8(%ebp),%eax
    9f05:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9f08:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9f0b:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    9f0e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    9f12:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    9f16:	7e 84                	jle    9e9c <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    9f18:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    9f1c:	74 08                	je     9f26 <color_tree_get+0xb9>
    9f1e:	8b 45 08             	mov    0x8(%ebp),%eax
    9f21:	8b 40 40             	mov    0x40(%eax),%eax
    9f24:	eb 05                	jmp    9f2b <color_tree_get+0xbe>
    9f26:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    9f2b:	90                   	nop
}
    9f2c:	83 c4 20             	add    $0x20,%esp
    9f2f:	5b                   	pop    %ebx
    9f30:	5d                   	pop    %ebp
    9f31:	c3                   	ret    

00009f32 <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9f32:	55                   	push   %ebp
    9f33:	89 e5                	mov    %esp,%ebp
    9f35:	53                   	push   %ebx
    9f36:	83 ec 10             	sub    $0x10,%esp
    9f39:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9f3c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9f3f:	8b 55 14             	mov    0x14(%ebp),%edx
    9f42:	8b 45 18             	mov    0x18(%ebp),%eax
    9f45:	88 5d f8             	mov    %bl,-0x8(%ebp)
    9f48:	88 4d f4             	mov    %cl,-0xc(%ebp)
    9f4b:	88 55 f0             	mov    %dl,-0x10(%ebp)
    9f4e:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    9f51:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    9f55:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    9f59:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    9f5d:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    9f61:	53                   	push   %ebx
    9f62:	51                   	push   %ecx
    9f63:	52                   	push   %edx
    9f64:	50                   	push   %eax
    9f65:	ff 75 08             	pushl  0x8(%ebp)
    9f68:	e8 00 ff ff ff       	call   9e6d <color_tree_get>
    9f6d:	83 c4 14             	add    $0x14,%esp
    9f70:	f7 d0                	not    %eax
    9f72:	c1 e8 1f             	shr    $0x1f,%eax
    9f75:	0f b6 c0             	movzbl %al,%eax
}
    9f78:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9f7b:	c9                   	leave  
    9f7c:	c3                   	ret    

00009f7d <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    9f7d:	55                   	push   %ebp
    9f7e:	89 e5                	mov    %esp,%ebp
    9f80:	53                   	push   %ebx
    9f81:	83 ec 24             	sub    $0x24,%esp
    9f84:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9f87:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9f8a:	8b 55 14             	mov    0x14(%ebp),%edx
    9f8d:	8b 45 18             	mov    0x18(%ebp),%eax
    9f90:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    9f93:	88 4d e0             	mov    %cl,-0x20(%ebp)
    9f96:	88 55 dc             	mov    %dl,-0x24(%ebp)
    9f99:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    9f9c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9fa3:	e9 b0 00 00 00       	jmp    a058 <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    9fa8:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    9fac:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9faf:	89 c1                	mov    %eax,%ecx
    9fb1:	d3 fa                	sar    %cl,%edx
    9fb3:	89 d0                	mov    %edx,%eax
    9fb5:	83 e0 01             	and    $0x1,%eax
    9fb8:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9fbb:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    9fbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9fc2:	89 c1                	mov    %eax,%ecx
    9fc4:	d3 fa                	sar    %cl,%edx
    9fc6:	89 d0                	mov    %edx,%eax
    9fc8:	83 e0 01             	and    $0x1,%eax
    9fcb:	01 d8                	add    %ebx,%eax
    9fcd:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9fd0:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    9fd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9fd7:	89 c1                	mov    %eax,%ecx
    9fd9:	d3 fa                	sar    %cl,%edx
    9fdb:	89 d0                	mov    %edx,%eax
    9fdd:	83 e0 01             	and    $0x1,%eax
    9fe0:	01 d8                	add    %ebx,%eax
    9fe2:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    9fe5:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    9fe9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9fec:	89 c1                	mov    %eax,%ecx
    9fee:	d3 fa                	sar    %cl,%edx
    9ff0:	89 d0                	mov    %edx,%eax
    9ff2:	83 e0 01             	and    $0x1,%eax
    9ff5:	01 d8                	add    %ebx,%eax
    9ff7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    9ffa:	8b 45 08             	mov    0x8(%ebp),%eax
    9ffd:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a000:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a003:	85 c0                	test   %eax,%eax
    a005:	75 41                	jne    a048 <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    a007:	83 ec 0c             	sub    $0xc,%esp
    a00a:	6a 44                	push   $0x44
    a00c:	e8 5d 94 ff ff       	call   346e <lodepng_malloc>
    a011:	83 c4 10             	add    $0x10,%esp
    a014:	89 c1                	mov    %eax,%ecx
    a016:	8b 45 08             	mov    0x8(%ebp),%eax
    a019:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a01c:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    a01f:	8b 45 08             	mov    0x8(%ebp),%eax
    a022:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a025:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a028:	85 c0                	test   %eax,%eax
    a02a:	75 07                	jne    a033 <color_tree_add+0xb6>
    a02c:	b8 53 00 00 00       	mov    $0x53,%eax
    a031:	eb 3d                	jmp    a070 <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    a033:	8b 45 08             	mov    0x8(%ebp),%eax
    a036:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a039:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a03c:	83 ec 0c             	sub    $0xc,%esp
    a03f:	50                   	push   %eax
    a040:	e8 b5 fd ff ff       	call   9dfa <color_tree_init>
    a045:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    a048:	8b 45 08             	mov    0x8(%ebp),%eax
    a04b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a04e:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a051:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    a054:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a058:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    a05c:	0f 8e 46 ff ff ff    	jle    9fa8 <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    a062:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a065:	8b 45 08             	mov    0x8(%ebp),%eax
    a068:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    a06b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a070:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a073:	c9                   	leave  
    a074:	c3                   	ret    

0000a075 <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a075:	55                   	push   %ebp
    a076:	89 e5                	mov    %esp,%ebp
    a078:	53                   	push   %ebx
    a079:	83 ec 20             	sub    $0x20,%esp
    a07c:	8b 5d 18             	mov    0x18(%ebp),%ebx
    a07f:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    a082:	8b 55 20             	mov    0x20(%ebp),%edx
    a085:	8b 45 24             	mov    0x24(%ebp),%eax
    a088:	88 5d e8             	mov    %bl,-0x18(%ebp)
    a08b:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    a08e:	88 55 e0             	mov    %dl,-0x20(%ebp)
    a091:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a094:	8b 45 10             	mov    0x10(%ebp),%eax
    a097:	8b 00                	mov    (%eax),%eax
    a099:	85 c0                	test   %eax,%eax
    a09b:	0f 85 ad 00 00 00    	jne    a14e <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a0a1:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a0a5:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    a0a8:	8b 45 10             	mov    0x10(%ebp),%eax
    a0ab:	8b 40 04             	mov    0x4(%eax),%eax
    a0ae:	83 f8 08             	cmp    $0x8,%eax
    a0b1:	75 13                	jne    a0c6 <rgba8ToPixel+0x51>
    a0b3:	8b 55 0c             	mov    0xc(%ebp),%edx
    a0b6:	8b 45 08             	mov    0x8(%ebp),%eax
    a0b9:	01 c2                	add    %eax,%edx
    a0bb:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    a0bf:	88 02                	mov    %al,(%edx)
    a0c1:	e9 b4 03 00 00       	jmp    a47a <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    a0c6:	8b 45 10             	mov    0x10(%ebp),%eax
    a0c9:	8b 40 04             	mov    0x4(%eax),%eax
    a0cc:	83 f8 10             	cmp    $0x10,%eax
    a0cf:	75 2a                	jne    a0fb <rgba8ToPixel+0x86>
    a0d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a0d4:	01 c0                	add    %eax,%eax
    a0d6:	89 c2                	mov    %eax,%edx
    a0d8:	8b 45 08             	mov    0x8(%ebp),%eax
    a0db:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a0de:	8b 45 0c             	mov    0xc(%ebp),%eax
    a0e1:	01 c0                	add    %eax,%eax
    a0e3:	8d 50 01             	lea    0x1(%eax),%edx
    a0e6:	8b 45 08             	mov    0x8(%ebp),%eax
    a0e9:	01 d0                	add    %edx,%eax
    a0eb:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a0ef:	88 10                	mov    %dl,(%eax)
    a0f1:	0f b6 00             	movzbl (%eax),%eax
    a0f4:	88 01                	mov    %al,(%ecx)
    a0f6:	e9 7f 03 00 00       	jmp    a47a <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    a0fb:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a0ff:	8b 45 10             	mov    0x10(%ebp),%eax
    a102:	8b 40 04             	mov    0x4(%eax),%eax
    a105:	b9 08 00 00 00       	mov    $0x8,%ecx
    a10a:	29 c1                	sub    %eax,%ecx
    a10c:	89 c8                	mov    %ecx,%eax
    a10e:	89 c1                	mov    %eax,%ecx
    a110:	d3 ea                	shr    %cl,%edx
    a112:	89 d0                	mov    %edx,%eax
    a114:	89 c2                	mov    %eax,%edx
    a116:	8b 45 10             	mov    0x10(%ebp),%eax
    a119:	8b 40 04             	mov    0x4(%eax),%eax
    a11c:	bb 01 00 00 00       	mov    $0x1,%ebx
    a121:	89 c1                	mov    %eax,%ecx
    a123:	d3 e3                	shl    %cl,%ebx
    a125:	89 d8                	mov    %ebx,%eax
    a127:	83 e8 01             	sub    $0x1,%eax
    a12a:	21 d0                	and    %edx,%eax
    a12c:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    a12f:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a133:	8b 45 10             	mov    0x10(%ebp),%eax
    a136:	8b 40 04             	mov    0x4(%eax),%eax
    a139:	52                   	push   %edx
    a13a:	50                   	push   %eax
    a13b:	ff 75 0c             	pushl  0xc(%ebp)
    a13e:	ff 75 08             	pushl  0x8(%ebp)
    a141:	e8 21 fc ff ff       	call   9d67 <addColorBits>
    a146:	83 c4 10             	add    $0x10,%esp
    a149:	e9 2c 03 00 00       	jmp    a47a <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    a14e:	8b 45 10             	mov    0x10(%ebp),%eax
    a151:	8b 00                	mov    (%eax),%eax
    a153:	83 f8 02             	cmp    $0x2,%eax
    a156:	0f 85 ee 00 00 00    	jne    a24a <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    a15c:	8b 45 10             	mov    0x10(%ebp),%eax
    a15f:	8b 40 04             	mov    0x4(%eax),%eax
    a162:	83 f8 08             	cmp    $0x8,%eax
    a165:	75 49                	jne    a1b0 <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    a167:	8b 55 0c             	mov    0xc(%ebp),%edx
    a16a:	89 d0                	mov    %edx,%eax
    a16c:	01 c0                	add    %eax,%eax
    a16e:	01 d0                	add    %edx,%eax
    a170:	89 c2                	mov    %eax,%edx
    a172:	8b 45 08             	mov    0x8(%ebp),%eax
    a175:	01 c2                	add    %eax,%edx
    a177:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a17b:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    a17d:	8b 55 0c             	mov    0xc(%ebp),%edx
    a180:	89 d0                	mov    %edx,%eax
    a182:	01 c0                	add    %eax,%eax
    a184:	01 d0                	add    %edx,%eax
    a186:	8d 50 01             	lea    0x1(%eax),%edx
    a189:	8b 45 08             	mov    0x8(%ebp),%eax
    a18c:	01 c2                	add    %eax,%edx
    a18e:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a192:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    a194:	8b 55 0c             	mov    0xc(%ebp),%edx
    a197:	89 d0                	mov    %edx,%eax
    a199:	01 c0                	add    %eax,%eax
    a19b:	01 d0                	add    %edx,%eax
    a19d:	8d 50 02             	lea    0x2(%eax),%edx
    a1a0:	8b 45 08             	mov    0x8(%ebp),%eax
    a1a3:	01 c2                	add    %eax,%edx
    a1a5:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a1a9:	88 02                	mov    %al,(%edx)
    a1ab:	e9 ca 02 00 00       	jmp    a47a <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    a1b0:	8b 55 0c             	mov    0xc(%ebp),%edx
    a1b3:	89 d0                	mov    %edx,%eax
    a1b5:	01 c0                	add    %eax,%eax
    a1b7:	01 d0                	add    %edx,%eax
    a1b9:	01 c0                	add    %eax,%eax
    a1bb:	89 c2                	mov    %eax,%edx
    a1bd:	8b 45 08             	mov    0x8(%ebp),%eax
    a1c0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a1c3:	8b 55 0c             	mov    0xc(%ebp),%edx
    a1c6:	89 d0                	mov    %edx,%eax
    a1c8:	01 c0                	add    %eax,%eax
    a1ca:	01 d0                	add    %edx,%eax
    a1cc:	01 c0                	add    %eax,%eax
    a1ce:	8d 50 01             	lea    0x1(%eax),%edx
    a1d1:	8b 45 08             	mov    0x8(%ebp),%eax
    a1d4:	01 d0                	add    %edx,%eax
    a1d6:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a1da:	88 10                	mov    %dl,(%eax)
    a1dc:	0f b6 00             	movzbl (%eax),%eax
    a1df:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    a1e1:	8b 55 0c             	mov    0xc(%ebp),%edx
    a1e4:	89 d0                	mov    %edx,%eax
    a1e6:	01 c0                	add    %eax,%eax
    a1e8:	01 d0                	add    %edx,%eax
    a1ea:	01 c0                	add    %eax,%eax
    a1ec:	8d 50 02             	lea    0x2(%eax),%edx
    a1ef:	8b 45 08             	mov    0x8(%ebp),%eax
    a1f2:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a1f5:	8b 55 0c             	mov    0xc(%ebp),%edx
    a1f8:	89 d0                	mov    %edx,%eax
    a1fa:	01 c0                	add    %eax,%eax
    a1fc:	01 d0                	add    %edx,%eax
    a1fe:	01 c0                	add    %eax,%eax
    a200:	8d 50 03             	lea    0x3(%eax),%edx
    a203:	8b 45 08             	mov    0x8(%ebp),%eax
    a206:	01 d0                	add    %edx,%eax
    a208:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a20c:	88 10                	mov    %dl,(%eax)
    a20e:	0f b6 00             	movzbl (%eax),%eax
    a211:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    a213:	8b 55 0c             	mov    0xc(%ebp),%edx
    a216:	89 d0                	mov    %edx,%eax
    a218:	01 c0                	add    %eax,%eax
    a21a:	01 d0                	add    %edx,%eax
    a21c:	01 c0                	add    %eax,%eax
    a21e:	8d 50 04             	lea    0x4(%eax),%edx
    a221:	8b 45 08             	mov    0x8(%ebp),%eax
    a224:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a227:	8b 55 0c             	mov    0xc(%ebp),%edx
    a22a:	89 d0                	mov    %edx,%eax
    a22c:	01 c0                	add    %eax,%eax
    a22e:	01 d0                	add    %edx,%eax
    a230:	01 c0                	add    %eax,%eax
    a232:	8d 50 05             	lea    0x5(%eax),%edx
    a235:	8b 45 08             	mov    0x8(%ebp),%eax
    a238:	01 d0                	add    %edx,%eax
    a23a:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a23e:	88 10                	mov    %dl,(%eax)
    a240:	0f b6 00             	movzbl (%eax),%eax
    a243:	88 01                	mov    %al,(%ecx)
    a245:	e9 30 02 00 00       	jmp    a47a <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a24a:	8b 45 10             	mov    0x10(%ebp),%eax
    a24d:	8b 00                	mov    (%eax),%eax
    a24f:	83 f8 03             	cmp    $0x3,%eax
    a252:	75 6d                	jne    a2c1 <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    a254:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    a258:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    a25c:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a260:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a264:	53                   	push   %ebx
    a265:	51                   	push   %ecx
    a266:	52                   	push   %edx
    a267:	50                   	push   %eax
    a268:	ff 75 14             	pushl  0x14(%ebp)
    a26b:	e8 fd fb ff ff       	call   9e6d <color_tree_get>
    a270:	83 c4 14             	add    $0x14,%esp
    a273:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    a276:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a27a:	79 0a                	jns    a286 <rgba8ToPixel+0x211>
    a27c:	b8 52 00 00 00       	mov    $0x52,%eax
    a281:	e9 f9 01 00 00       	jmp    a47f <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    a286:	8b 45 10             	mov    0x10(%ebp),%eax
    a289:	8b 40 04             	mov    0x4(%eax),%eax
    a28c:	83 f8 08             	cmp    $0x8,%eax
    a28f:	75 12                	jne    a2a3 <rgba8ToPixel+0x22e>
    a291:	8b 55 0c             	mov    0xc(%ebp),%edx
    a294:	8b 45 08             	mov    0x8(%ebp),%eax
    a297:	01 d0                	add    %edx,%eax
    a299:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a29c:	88 10                	mov    %dl,(%eax)
    a29e:	e9 d7 01 00 00       	jmp    a47a <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    a2a3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a2a6:	8b 45 10             	mov    0x10(%ebp),%eax
    a2a9:	8b 40 04             	mov    0x4(%eax),%eax
    a2ac:	52                   	push   %edx
    a2ad:	50                   	push   %eax
    a2ae:	ff 75 0c             	pushl  0xc(%ebp)
    a2b1:	ff 75 08             	pushl  0x8(%ebp)
    a2b4:	e8 ae fa ff ff       	call   9d67 <addColorBits>
    a2b9:	83 c4 10             	add    $0x10,%esp
    a2bc:	e9 b9 01 00 00       	jmp    a47a <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a2c1:	8b 45 10             	mov    0x10(%ebp),%eax
    a2c4:	8b 00                	mov    (%eax),%eax
    a2c6:	83 f8 04             	cmp    $0x4,%eax
    a2c9:	0f 85 9f 00 00 00    	jne    a36e <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a2cf:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a2d3:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    a2d6:	8b 45 10             	mov    0x10(%ebp),%eax
    a2d9:	8b 40 04             	mov    0x4(%eax),%eax
    a2dc:	83 f8 08             	cmp    $0x8,%eax
    a2df:	75 2a                	jne    a30b <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    a2e1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2e4:	01 c0                	add    %eax,%eax
    a2e6:	89 c2                	mov    %eax,%edx
    a2e8:	8b 45 08             	mov    0x8(%ebp),%eax
    a2eb:	01 c2                	add    %eax,%edx
    a2ed:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    a2f1:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    a2f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a2f6:	01 c0                	add    %eax,%eax
    a2f8:	8d 50 01             	lea    0x1(%eax),%edx
    a2fb:	8b 45 08             	mov    0x8(%ebp),%eax
    a2fe:	01 c2                	add    %eax,%edx
    a300:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a304:	88 02                	mov    %al,(%edx)
    a306:	e9 6f 01 00 00       	jmp    a47a <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    a30b:	8b 45 10             	mov    0x10(%ebp),%eax
    a30e:	8b 40 04             	mov    0x4(%eax),%eax
    a311:	83 f8 10             	cmp    $0x10,%eax
    a314:	0f 85 60 01 00 00    	jne    a47a <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    a31a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a31d:	c1 e0 02             	shl    $0x2,%eax
    a320:	89 c2                	mov    %eax,%edx
    a322:	8b 45 08             	mov    0x8(%ebp),%eax
    a325:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a328:	8b 45 0c             	mov    0xc(%ebp),%eax
    a32b:	c1 e0 02             	shl    $0x2,%eax
    a32e:	8d 50 01             	lea    0x1(%eax),%edx
    a331:	8b 45 08             	mov    0x8(%ebp),%eax
    a334:	01 d0                	add    %edx,%eax
    a336:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    a33a:	88 10                	mov    %dl,(%eax)
    a33c:	0f b6 00             	movzbl (%eax),%eax
    a33f:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    a341:	8b 45 0c             	mov    0xc(%ebp),%eax
    a344:	c1 e0 02             	shl    $0x2,%eax
    a347:	8d 50 02             	lea    0x2(%eax),%edx
    a34a:	8b 45 08             	mov    0x8(%ebp),%eax
    a34d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a350:	8b 45 0c             	mov    0xc(%ebp),%eax
    a353:	c1 e0 02             	shl    $0x2,%eax
    a356:	8d 50 03             	lea    0x3(%eax),%edx
    a359:	8b 45 08             	mov    0x8(%ebp),%eax
    a35c:	01 d0                	add    %edx,%eax
    a35e:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a362:	88 10                	mov    %dl,(%eax)
    a364:	0f b6 00             	movzbl (%eax),%eax
    a367:	88 01                	mov    %al,(%ecx)
    a369:	e9 0c 01 00 00       	jmp    a47a <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    a36e:	8b 45 10             	mov    0x10(%ebp),%eax
    a371:	8b 00                	mov    (%eax),%eax
    a373:	83 f8 06             	cmp    $0x6,%eax
    a376:	0f 85 fe 00 00 00    	jne    a47a <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    a37c:	8b 45 10             	mov    0x10(%ebp),%eax
    a37f:	8b 40 04             	mov    0x4(%eax),%eax
    a382:	83 f8 08             	cmp    $0x8,%eax
    a385:	75 54                	jne    a3db <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    a387:	8b 45 0c             	mov    0xc(%ebp),%eax
    a38a:	c1 e0 02             	shl    $0x2,%eax
    a38d:	89 c2                	mov    %eax,%edx
    a38f:	8b 45 08             	mov    0x8(%ebp),%eax
    a392:	01 c2                	add    %eax,%edx
    a394:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a398:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    a39a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a39d:	c1 e0 02             	shl    $0x2,%eax
    a3a0:	8d 50 01             	lea    0x1(%eax),%edx
    a3a3:	8b 45 08             	mov    0x8(%ebp),%eax
    a3a6:	01 c2                	add    %eax,%edx
    a3a8:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a3ac:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    a3ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3b1:	c1 e0 02             	shl    $0x2,%eax
    a3b4:	8d 50 02             	lea    0x2(%eax),%edx
    a3b7:	8b 45 08             	mov    0x8(%ebp),%eax
    a3ba:	01 c2                	add    %eax,%edx
    a3bc:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a3c0:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    a3c2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3c5:	c1 e0 02             	shl    $0x2,%eax
    a3c8:	8d 50 03             	lea    0x3(%eax),%edx
    a3cb:	8b 45 08             	mov    0x8(%ebp),%eax
    a3ce:	01 c2                	add    %eax,%edx
    a3d0:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a3d4:	88 02                	mov    %al,(%edx)
    a3d6:	e9 9f 00 00 00       	jmp    a47a <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    a3db:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3de:	c1 e0 03             	shl    $0x3,%eax
    a3e1:	89 c2                	mov    %eax,%edx
    a3e3:	8b 45 08             	mov    0x8(%ebp),%eax
    a3e6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a3e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a3ec:	c1 e0 03             	shl    $0x3,%eax
    a3ef:	8d 50 01             	lea    0x1(%eax),%edx
    a3f2:	8b 45 08             	mov    0x8(%ebp),%eax
    a3f5:	01 d0                	add    %edx,%eax
    a3f7:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a3fb:	88 10                	mov    %dl,(%eax)
    a3fd:	0f b6 00             	movzbl (%eax),%eax
    a400:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    a402:	8b 45 0c             	mov    0xc(%ebp),%eax
    a405:	c1 e0 03             	shl    $0x3,%eax
    a408:	8d 50 02             	lea    0x2(%eax),%edx
    a40b:	8b 45 08             	mov    0x8(%ebp),%eax
    a40e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a411:	8b 45 0c             	mov    0xc(%ebp),%eax
    a414:	c1 e0 03             	shl    $0x3,%eax
    a417:	8d 50 03             	lea    0x3(%eax),%edx
    a41a:	8b 45 08             	mov    0x8(%ebp),%eax
    a41d:	01 d0                	add    %edx,%eax
    a41f:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a423:	88 10                	mov    %dl,(%eax)
    a425:	0f b6 00             	movzbl (%eax),%eax
    a428:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    a42a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a42d:	c1 e0 03             	shl    $0x3,%eax
    a430:	8d 50 04             	lea    0x4(%eax),%edx
    a433:	8b 45 08             	mov    0x8(%ebp),%eax
    a436:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a439:	8b 45 0c             	mov    0xc(%ebp),%eax
    a43c:	c1 e0 03             	shl    $0x3,%eax
    a43f:	8d 50 05             	lea    0x5(%eax),%edx
    a442:	8b 45 08             	mov    0x8(%ebp),%eax
    a445:	01 d0                	add    %edx,%eax
    a447:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a44b:	88 10                	mov    %dl,(%eax)
    a44d:	0f b6 00             	movzbl (%eax),%eax
    a450:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    a452:	8b 45 0c             	mov    0xc(%ebp),%eax
    a455:	c1 e0 03             	shl    $0x3,%eax
    a458:	8d 50 06             	lea    0x6(%eax),%edx
    a45b:	8b 45 08             	mov    0x8(%ebp),%eax
    a45e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a461:	8b 45 0c             	mov    0xc(%ebp),%eax
    a464:	c1 e0 03             	shl    $0x3,%eax
    a467:	8d 50 07             	lea    0x7(%eax),%edx
    a46a:	8b 45 08             	mov    0x8(%ebp),%eax
    a46d:	01 d0                	add    %edx,%eax
    a46f:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a473:	88 10                	mov    %dl,(%eax)
    a475:	0f b6 00             	movzbl (%eax),%eax
    a478:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    a47a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a47f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a482:	c9                   	leave  
    a483:	c3                   	ret    

0000a484 <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    a484:	55                   	push   %ebp
    a485:	89 e5                	mov    %esp,%ebp
    a487:	53                   	push   %ebx
    a488:	83 ec 20             	sub    $0x20,%esp
    a48b:	8b 5d 14             	mov    0x14(%ebp),%ebx
    a48e:	8b 4d 18             	mov    0x18(%ebp),%ecx
    a491:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a494:	8b 45 20             	mov    0x20(%ebp),%eax
    a497:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    a49b:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    a49f:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    a4a3:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a4a7:	8b 45 10             	mov    0x10(%ebp),%eax
    a4aa:	8b 00                	mov    (%eax),%eax
    a4ac:	85 c0                	test   %eax,%eax
    a4ae:	75 36                	jne    a4e6 <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a4b0:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a4b4:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    a4b8:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4bb:	01 c0                	add    %eax,%eax
    a4bd:	89 c2                	mov    %eax,%edx
    a4bf:	8b 45 08             	mov    0x8(%ebp),%eax
    a4c2:	01 d0                	add    %edx,%eax
    a4c4:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a4c8:	66 c1 ea 08          	shr    $0x8,%dx
    a4cc:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    a4ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4d1:	01 c0                	add    %eax,%eax
    a4d3:	8d 50 01             	lea    0x1(%eax),%edx
    a4d6:	8b 45 08             	mov    0x8(%ebp),%eax
    a4d9:	01 d0                	add    %edx,%eax
    a4db:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a4df:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a4e1:	e9 df 01 00 00       	jmp    a6c5 <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    a4e6:	8b 45 10             	mov    0x10(%ebp),%eax
    a4e9:	8b 00                	mov    (%eax),%eax
    a4eb:	83 f8 02             	cmp    $0x2,%eax
    a4ee:	0f 85 a6 00 00 00    	jne    a59a <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    a4f4:	8b 55 0c             	mov    0xc(%ebp),%edx
    a4f7:	89 d0                	mov    %edx,%eax
    a4f9:	01 c0                	add    %eax,%eax
    a4fb:	01 d0                	add    %edx,%eax
    a4fd:	01 c0                	add    %eax,%eax
    a4ff:	89 c2                	mov    %eax,%edx
    a501:	8b 45 08             	mov    0x8(%ebp),%eax
    a504:	01 d0                	add    %edx,%eax
    a506:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a50a:	66 c1 ea 08          	shr    $0x8,%dx
    a50e:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    a510:	8b 55 0c             	mov    0xc(%ebp),%edx
    a513:	89 d0                	mov    %edx,%eax
    a515:	01 c0                	add    %eax,%eax
    a517:	01 d0                	add    %edx,%eax
    a519:	01 c0                	add    %eax,%eax
    a51b:	8d 50 01             	lea    0x1(%eax),%edx
    a51e:	8b 45 08             	mov    0x8(%ebp),%eax
    a521:	01 d0                	add    %edx,%eax
    a523:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a527:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    a529:	8b 55 0c             	mov    0xc(%ebp),%edx
    a52c:	89 d0                	mov    %edx,%eax
    a52e:	01 c0                	add    %eax,%eax
    a530:	01 d0                	add    %edx,%eax
    a532:	01 c0                	add    %eax,%eax
    a534:	8d 50 02             	lea    0x2(%eax),%edx
    a537:	8b 45 08             	mov    0x8(%ebp),%eax
    a53a:	01 d0                	add    %edx,%eax
    a53c:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a540:	66 c1 ea 08          	shr    $0x8,%dx
    a544:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    a546:	8b 55 0c             	mov    0xc(%ebp),%edx
    a549:	89 d0                	mov    %edx,%eax
    a54b:	01 c0                	add    %eax,%eax
    a54d:	01 d0                	add    %edx,%eax
    a54f:	01 c0                	add    %eax,%eax
    a551:	8d 50 03             	lea    0x3(%eax),%edx
    a554:	8b 45 08             	mov    0x8(%ebp),%eax
    a557:	01 d0                	add    %edx,%eax
    a559:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a55d:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    a55f:	8b 55 0c             	mov    0xc(%ebp),%edx
    a562:	89 d0                	mov    %edx,%eax
    a564:	01 c0                	add    %eax,%eax
    a566:	01 d0                	add    %edx,%eax
    a568:	01 c0                	add    %eax,%eax
    a56a:	8d 50 04             	lea    0x4(%eax),%edx
    a56d:	8b 45 08             	mov    0x8(%ebp),%eax
    a570:	01 d0                	add    %edx,%eax
    a572:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a576:	66 c1 ea 08          	shr    $0x8,%dx
    a57a:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    a57c:	8b 55 0c             	mov    0xc(%ebp),%edx
    a57f:	89 d0                	mov    %edx,%eax
    a581:	01 c0                	add    %eax,%eax
    a583:	01 d0                	add    %edx,%eax
    a585:	01 c0                	add    %eax,%eax
    a587:	8d 50 05             	lea    0x5(%eax),%edx
    a58a:	8b 45 08             	mov    0x8(%ebp),%eax
    a58d:	01 d0                	add    %edx,%eax
    a58f:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a593:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a595:	e9 2b 01 00 00       	jmp    a6c5 <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a59a:	8b 45 10             	mov    0x10(%ebp),%eax
    a59d:	8b 00                	mov    (%eax),%eax
    a59f:	83 f8 04             	cmp    $0x4,%eax
    a5a2:	75 64                	jne    a608 <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a5a4:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a5a8:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    a5ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5af:	c1 e0 02             	shl    $0x2,%eax
    a5b2:	89 c2                	mov    %eax,%edx
    a5b4:	8b 45 08             	mov    0x8(%ebp),%eax
    a5b7:	01 d0                	add    %edx,%eax
    a5b9:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a5bd:	66 c1 ea 08          	shr    $0x8,%dx
    a5c1:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    a5c3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5c6:	c1 e0 02             	shl    $0x2,%eax
    a5c9:	8d 50 01             	lea    0x1(%eax),%edx
    a5cc:	8b 45 08             	mov    0x8(%ebp),%eax
    a5cf:	01 d0                	add    %edx,%eax
    a5d1:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a5d5:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    a5d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5da:	c1 e0 02             	shl    $0x2,%eax
    a5dd:	8d 50 02             	lea    0x2(%eax),%edx
    a5e0:	8b 45 08             	mov    0x8(%ebp),%eax
    a5e3:	01 d0                	add    %edx,%eax
    a5e5:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a5e9:	66 c1 ea 08          	shr    $0x8,%dx
    a5ed:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    a5ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5f2:	c1 e0 02             	shl    $0x2,%eax
    a5f5:	8d 50 03             	lea    0x3(%eax),%edx
    a5f8:	8b 45 08             	mov    0x8(%ebp),%eax
    a5fb:	01 d0                	add    %edx,%eax
    a5fd:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a601:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a603:	e9 bd 00 00 00       	jmp    a6c5 <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    a608:	8b 45 10             	mov    0x10(%ebp),%eax
    a60b:	8b 00                	mov    (%eax),%eax
    a60d:	83 f8 06             	cmp    $0x6,%eax
    a610:	0f 85 af 00 00 00    	jne    a6c5 <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    a616:	8b 45 0c             	mov    0xc(%ebp),%eax
    a619:	c1 e0 03             	shl    $0x3,%eax
    a61c:	89 c2                	mov    %eax,%edx
    a61e:	8b 45 08             	mov    0x8(%ebp),%eax
    a621:	01 d0                	add    %edx,%eax
    a623:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a627:	66 c1 ea 08          	shr    $0x8,%dx
    a62b:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    a62d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a630:	c1 e0 03             	shl    $0x3,%eax
    a633:	8d 50 01             	lea    0x1(%eax),%edx
    a636:	8b 45 08             	mov    0x8(%ebp),%eax
    a639:	01 d0                	add    %edx,%eax
    a63b:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a63f:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    a641:	8b 45 0c             	mov    0xc(%ebp),%eax
    a644:	c1 e0 03             	shl    $0x3,%eax
    a647:	8d 50 02             	lea    0x2(%eax),%edx
    a64a:	8b 45 08             	mov    0x8(%ebp),%eax
    a64d:	01 d0                	add    %edx,%eax
    a64f:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a653:	66 c1 ea 08          	shr    $0x8,%dx
    a657:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    a659:	8b 45 0c             	mov    0xc(%ebp),%eax
    a65c:	c1 e0 03             	shl    $0x3,%eax
    a65f:	8d 50 03             	lea    0x3(%eax),%edx
    a662:	8b 45 08             	mov    0x8(%ebp),%eax
    a665:	01 d0                	add    %edx,%eax
    a667:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a66b:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    a66d:	8b 45 0c             	mov    0xc(%ebp),%eax
    a670:	c1 e0 03             	shl    $0x3,%eax
    a673:	8d 50 04             	lea    0x4(%eax),%edx
    a676:	8b 45 08             	mov    0x8(%ebp),%eax
    a679:	01 d0                	add    %edx,%eax
    a67b:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a67f:	66 c1 ea 08          	shr    $0x8,%dx
    a683:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    a685:	8b 45 0c             	mov    0xc(%ebp),%eax
    a688:	c1 e0 03             	shl    $0x3,%eax
    a68b:	8d 50 05             	lea    0x5(%eax),%edx
    a68e:	8b 45 08             	mov    0x8(%ebp),%eax
    a691:	01 d0                	add    %edx,%eax
    a693:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a697:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    a699:	8b 45 0c             	mov    0xc(%ebp),%eax
    a69c:	c1 e0 03             	shl    $0x3,%eax
    a69f:	8d 50 06             	lea    0x6(%eax),%edx
    a6a2:	8b 45 08             	mov    0x8(%ebp),%eax
    a6a5:	01 d0                	add    %edx,%eax
    a6a7:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a6ab:	66 c1 ea 08          	shr    $0x8,%dx
    a6af:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    a6b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a6b4:	c1 e0 03             	shl    $0x3,%eax
    a6b7:	8d 50 07             	lea    0x7(%eax),%edx
    a6ba:	8b 45 08             	mov    0x8(%ebp),%eax
    a6bd:	01 d0                	add    %edx,%eax
    a6bf:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a6c3:	88 10                	mov    %dl,(%eax)
  }
}
    a6c5:	90                   	nop
    a6c6:	83 c4 20             	add    $0x20,%esp
    a6c9:	5b                   	pop    %ebx
    a6ca:	5d                   	pop    %ebp
    a6cb:	c3                   	ret    

0000a6cc <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    a6cc:	55                   	push   %ebp
    a6cd:	89 e5                	mov    %esp,%ebp
    a6cf:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    a6d2:	8b 45 20             	mov    0x20(%ebp),%eax
    a6d5:	8b 00                	mov    (%eax),%eax
    a6d7:	85 c0                	test   %eax,%eax
    a6d9:	0f 85 8c 01 00 00    	jne    a86b <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    a6df:	8b 45 20             	mov    0x20(%ebp),%eax
    a6e2:	8b 40 04             	mov    0x4(%eax),%eax
    a6e5:	83 f8 08             	cmp    $0x8,%eax
    a6e8:	75 59                	jne    a743 <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    a6ea:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a6ed:	8b 45 18             	mov    0x18(%ebp),%eax
    a6f0:	01 d0                	add    %edx,%eax
    a6f2:	0f b6 10             	movzbl (%eax),%edx
    a6f5:	8b 45 10             	mov    0x10(%ebp),%eax
    a6f8:	88 10                	mov    %dl,(%eax)
    a6fa:	8b 45 10             	mov    0x10(%ebp),%eax
    a6fd:	0f b6 10             	movzbl (%eax),%edx
    a700:	8b 45 0c             	mov    0xc(%ebp),%eax
    a703:	88 10                	mov    %dl,(%eax)
    a705:	8b 45 0c             	mov    0xc(%ebp),%eax
    a708:	0f b6 10             	movzbl (%eax),%edx
    a70b:	8b 45 08             	mov    0x8(%ebp),%eax
    a70e:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    a710:	8b 45 20             	mov    0x20(%ebp),%eax
    a713:	8b 40 10             	mov    0x10(%eax),%eax
    a716:	85 c0                	test   %eax,%eax
    a718:	74 1e                	je     a738 <getPixelColorRGBA8+0x6c>
    a71a:	8b 45 08             	mov    0x8(%ebp),%eax
    a71d:	0f b6 00             	movzbl (%eax),%eax
    a720:	0f b6 d0             	movzbl %al,%edx
    a723:	8b 45 20             	mov    0x20(%ebp),%eax
    a726:	8b 40 14             	mov    0x14(%eax),%eax
    a729:	39 c2                	cmp    %eax,%edx
    a72b:	75 0b                	jne    a738 <getPixelColorRGBA8+0x6c>
    a72d:	8b 45 14             	mov    0x14(%ebp),%eax
    a730:	c6 00 00             	movb   $0x0,(%eax)
    a733:	e9 5e 05 00 00       	jmp    ac96 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a738:	8b 45 14             	mov    0x14(%ebp),%eax
    a73b:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a73e:	e9 53 05 00 00       	jmp    ac96 <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    a743:	8b 45 20             	mov    0x20(%ebp),%eax
    a746:	8b 40 04             	mov    0x4(%eax),%eax
    a749:	83 f8 10             	cmp    $0x10,%eax
    a74c:	0f 85 80 00 00 00    	jne    a7d2 <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    a752:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a755:	01 c0                	add    %eax,%eax
    a757:	89 c2                	mov    %eax,%edx
    a759:	8b 45 18             	mov    0x18(%ebp),%eax
    a75c:	01 d0                	add    %edx,%eax
    a75e:	0f b6 10             	movzbl (%eax),%edx
    a761:	8b 45 10             	mov    0x10(%ebp),%eax
    a764:	88 10                	mov    %dl,(%eax)
    a766:	8b 45 10             	mov    0x10(%ebp),%eax
    a769:	0f b6 10             	movzbl (%eax),%edx
    a76c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a76f:	88 10                	mov    %dl,(%eax)
    a771:	8b 45 0c             	mov    0xc(%ebp),%eax
    a774:	0f b6 10             	movzbl (%eax),%edx
    a777:	8b 45 08             	mov    0x8(%ebp),%eax
    a77a:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    a77c:	8b 45 20             	mov    0x20(%ebp),%eax
    a77f:	8b 40 10             	mov    0x10(%eax),%eax
    a782:	85 c0                	test   %eax,%eax
    a784:	74 41                	je     a7c7 <getPixelColorRGBA8+0xfb>
    a786:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a789:	01 c0                	add    %eax,%eax
    a78b:	89 c2                	mov    %eax,%edx
    a78d:	8b 45 18             	mov    0x18(%ebp),%eax
    a790:	01 d0                	add    %edx,%eax
    a792:	0f b6 00             	movzbl (%eax),%eax
    a795:	0f b6 c0             	movzbl %al,%eax
    a798:	c1 e0 08             	shl    $0x8,%eax
    a79b:	89 c2                	mov    %eax,%edx
    a79d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a7a0:	01 c0                	add    %eax,%eax
    a7a2:	8d 48 01             	lea    0x1(%eax),%ecx
    a7a5:	8b 45 18             	mov    0x18(%ebp),%eax
    a7a8:	01 c8                	add    %ecx,%eax
    a7aa:	0f b6 00             	movzbl (%eax),%eax
    a7ad:	0f b6 c0             	movzbl %al,%eax
    a7b0:	01 c2                	add    %eax,%edx
    a7b2:	8b 45 20             	mov    0x20(%ebp),%eax
    a7b5:	8b 40 14             	mov    0x14(%eax),%eax
    a7b8:	39 c2                	cmp    %eax,%edx
    a7ba:	75 0b                	jne    a7c7 <getPixelColorRGBA8+0xfb>
    a7bc:	8b 45 14             	mov    0x14(%ebp),%eax
    a7bf:	c6 00 00             	movb   $0x0,(%eax)
    a7c2:	e9 cf 04 00 00       	jmp    ac96 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a7c7:	8b 45 14             	mov    0x14(%ebp),%eax
    a7ca:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a7cd:	e9 c4 04 00 00       	jmp    ac96 <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    a7d2:	8b 45 20             	mov    0x20(%ebp),%eax
    a7d5:	8b 40 04             	mov    0x4(%eax),%eax
    a7d8:	ba 01 00 00 00       	mov    $0x1,%edx
    a7dd:	89 c1                	mov    %eax,%ecx
    a7df:	d3 e2                	shl    %cl,%edx
    a7e1:	89 d0                	mov    %edx,%eax
    a7e3:	83 e8 01             	sub    $0x1,%eax
    a7e6:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    a7e9:	8b 45 20             	mov    0x20(%ebp),%eax
    a7ec:	8b 50 04             	mov    0x4(%eax),%edx
    a7ef:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a7f2:	0f af c2             	imul   %edx,%eax
    a7f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a7f8:	8b 45 20             	mov    0x20(%ebp),%eax
    a7fb:	8b 40 04             	mov    0x4(%eax),%eax
    a7fe:	50                   	push   %eax
    a7ff:	ff 75 18             	pushl  0x18(%ebp)
    a802:	8d 45 f0             	lea    -0x10(%ebp),%eax
    a805:	50                   	push   %eax
    a806:	e8 06 db ff ff       	call   8311 <readBitsFromReversedStream>
    a80b:	83 c4 0c             	add    $0xc,%esp
    a80e:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    a811:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a814:	89 d0                	mov    %edx,%eax
    a816:	c1 e0 08             	shl    $0x8,%eax
    a819:	29 d0                	sub    %edx,%eax
    a81b:	ba 00 00 00 00       	mov    $0x0,%edx
    a820:	f7 75 f8             	divl   -0x8(%ebp)
    a823:	89 c2                	mov    %eax,%edx
    a825:	8b 45 10             	mov    0x10(%ebp),%eax
    a828:	88 10                	mov    %dl,(%eax)
    a82a:	8b 45 10             	mov    0x10(%ebp),%eax
    a82d:	0f b6 10             	movzbl (%eax),%edx
    a830:	8b 45 0c             	mov    0xc(%ebp),%eax
    a833:	88 10                	mov    %dl,(%eax)
    a835:	8b 45 0c             	mov    0xc(%ebp),%eax
    a838:	0f b6 10             	movzbl (%eax),%edx
    a83b:	8b 45 08             	mov    0x8(%ebp),%eax
    a83e:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    a840:	8b 45 20             	mov    0x20(%ebp),%eax
    a843:	8b 40 10             	mov    0x10(%eax),%eax
    a846:	85 c0                	test   %eax,%eax
    a848:	74 16                	je     a860 <getPixelColorRGBA8+0x194>
    a84a:	8b 45 20             	mov    0x20(%ebp),%eax
    a84d:	8b 40 14             	mov    0x14(%eax),%eax
    a850:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a853:	75 0b                	jne    a860 <getPixelColorRGBA8+0x194>
    a855:	8b 45 14             	mov    0x14(%ebp),%eax
    a858:	c6 00 00             	movb   $0x0,(%eax)
    a85b:	e9 36 04 00 00       	jmp    ac96 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a860:	8b 45 14             	mov    0x14(%ebp),%eax
    a863:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a866:	e9 2b 04 00 00       	jmp    ac96 <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    a86b:	8b 45 20             	mov    0x20(%ebp),%eax
    a86e:	8b 00                	mov    (%eax),%eax
    a870:	83 f8 02             	cmp    $0x2,%eax
    a873:	0f 85 f5 01 00 00    	jne    aa6e <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    a879:	8b 45 20             	mov    0x20(%ebp),%eax
    a87c:	8b 40 04             	mov    0x4(%eax),%eax
    a87f:	83 f8 08             	cmp    $0x8,%eax
    a882:	0f 85 a3 00 00 00    	jne    a92b <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    a888:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a88b:	89 d0                	mov    %edx,%eax
    a88d:	01 c0                	add    %eax,%eax
    a88f:	01 d0                	add    %edx,%eax
    a891:	89 c2                	mov    %eax,%edx
    a893:	8b 45 18             	mov    0x18(%ebp),%eax
    a896:	01 d0                	add    %edx,%eax
    a898:	0f b6 10             	movzbl (%eax),%edx
    a89b:	8b 45 08             	mov    0x8(%ebp),%eax
    a89e:	88 10                	mov    %dl,(%eax)
    a8a0:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8a3:	89 d0                	mov    %edx,%eax
    a8a5:	01 c0                	add    %eax,%eax
    a8a7:	01 d0                	add    %edx,%eax
    a8a9:	8d 50 01             	lea    0x1(%eax),%edx
    a8ac:	8b 45 18             	mov    0x18(%ebp),%eax
    a8af:	01 d0                	add    %edx,%eax
    a8b1:	0f b6 10             	movzbl (%eax),%edx
    a8b4:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8b7:	88 10                	mov    %dl,(%eax)
    a8b9:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a8bc:	89 d0                	mov    %edx,%eax
    a8be:	01 c0                	add    %eax,%eax
    a8c0:	01 d0                	add    %edx,%eax
    a8c2:	8d 50 02             	lea    0x2(%eax),%edx
    a8c5:	8b 45 18             	mov    0x18(%ebp),%eax
    a8c8:	01 d0                	add    %edx,%eax
    a8ca:	0f b6 10             	movzbl (%eax),%edx
    a8cd:	8b 45 10             	mov    0x10(%ebp),%eax
    a8d0:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    a8d2:	8b 45 20             	mov    0x20(%ebp),%eax
    a8d5:	8b 40 10             	mov    0x10(%eax),%eax
    a8d8:	85 c0                	test   %eax,%eax
    a8da:	74 44                	je     a920 <getPixelColorRGBA8+0x254>
    a8dc:	8b 45 08             	mov    0x8(%ebp),%eax
    a8df:	0f b6 00             	movzbl (%eax),%eax
    a8e2:	0f b6 d0             	movzbl %al,%edx
    a8e5:	8b 45 20             	mov    0x20(%ebp),%eax
    a8e8:	8b 40 14             	mov    0x14(%eax),%eax
    a8eb:	39 c2                	cmp    %eax,%edx
    a8ed:	75 31                	jne    a920 <getPixelColorRGBA8+0x254>
    a8ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8f2:	0f b6 00             	movzbl (%eax),%eax
    a8f5:	0f b6 d0             	movzbl %al,%edx
    a8f8:	8b 45 20             	mov    0x20(%ebp),%eax
    a8fb:	8b 40 18             	mov    0x18(%eax),%eax
    a8fe:	39 c2                	cmp    %eax,%edx
    a900:	75 1e                	jne    a920 <getPixelColorRGBA8+0x254>
    a902:	8b 45 10             	mov    0x10(%ebp),%eax
    a905:	0f b6 00             	movzbl (%eax),%eax
    a908:	0f b6 d0             	movzbl %al,%edx
    a90b:	8b 45 20             	mov    0x20(%ebp),%eax
    a90e:	8b 40 1c             	mov    0x1c(%eax),%eax
    a911:	39 c2                	cmp    %eax,%edx
    a913:	75 0b                	jne    a920 <getPixelColorRGBA8+0x254>
    a915:	8b 45 14             	mov    0x14(%ebp),%eax
    a918:	c6 00 00             	movb   $0x0,(%eax)
    a91b:	e9 76 03 00 00       	jmp    ac96 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a920:	8b 45 14             	mov    0x14(%ebp),%eax
    a923:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a926:	e9 6b 03 00 00       	jmp    ac96 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    a92b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a92e:	89 d0                	mov    %edx,%eax
    a930:	01 c0                	add    %eax,%eax
    a932:	01 d0                	add    %edx,%eax
    a934:	01 c0                	add    %eax,%eax
    a936:	89 c2                	mov    %eax,%edx
    a938:	8b 45 18             	mov    0x18(%ebp),%eax
    a93b:	01 d0                	add    %edx,%eax
    a93d:	0f b6 10             	movzbl (%eax),%edx
    a940:	8b 45 08             	mov    0x8(%ebp),%eax
    a943:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    a945:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a948:	89 d0                	mov    %edx,%eax
    a94a:	01 c0                	add    %eax,%eax
    a94c:	01 d0                	add    %edx,%eax
    a94e:	01 c0                	add    %eax,%eax
    a950:	8d 50 02             	lea    0x2(%eax),%edx
    a953:	8b 45 18             	mov    0x18(%ebp),%eax
    a956:	01 d0                	add    %edx,%eax
    a958:	0f b6 10             	movzbl (%eax),%edx
    a95b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a95e:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    a960:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a963:	89 d0                	mov    %edx,%eax
    a965:	01 c0                	add    %eax,%eax
    a967:	01 d0                	add    %edx,%eax
    a969:	01 c0                	add    %eax,%eax
    a96b:	8d 50 04             	lea    0x4(%eax),%edx
    a96e:	8b 45 18             	mov    0x18(%ebp),%eax
    a971:	01 d0                	add    %edx,%eax
    a973:	0f b6 10             	movzbl (%eax),%edx
    a976:	8b 45 10             	mov    0x10(%ebp),%eax
    a979:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    a97b:	8b 45 20             	mov    0x20(%ebp),%eax
    a97e:	8b 40 10             	mov    0x10(%eax),%eax
    a981:	85 c0                	test   %eax,%eax
    a983:	0f 84 da 00 00 00    	je     aa63 <getPixelColorRGBA8+0x397>
    a989:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a98c:	89 d0                	mov    %edx,%eax
    a98e:	01 c0                	add    %eax,%eax
    a990:	01 d0                	add    %edx,%eax
    a992:	01 c0                	add    %eax,%eax
    a994:	89 c2                	mov    %eax,%edx
    a996:	8b 45 18             	mov    0x18(%ebp),%eax
    a999:	01 d0                	add    %edx,%eax
    a99b:	0f b6 00             	movzbl (%eax),%eax
    a99e:	0f b6 c0             	movzbl %al,%eax
    a9a1:	c1 e0 08             	shl    $0x8,%eax
    a9a4:	89 c1                	mov    %eax,%ecx
    a9a6:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a9a9:	89 d0                	mov    %edx,%eax
    a9ab:	01 c0                	add    %eax,%eax
    a9ad:	01 d0                	add    %edx,%eax
    a9af:	01 c0                	add    %eax,%eax
    a9b1:	8d 50 01             	lea    0x1(%eax),%edx
    a9b4:	8b 45 18             	mov    0x18(%ebp),%eax
    a9b7:	01 d0                	add    %edx,%eax
    a9b9:	0f b6 00             	movzbl (%eax),%eax
    a9bc:	0f b6 c0             	movzbl %al,%eax
    a9bf:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    a9c2:	8b 45 20             	mov    0x20(%ebp),%eax
    a9c5:	8b 40 14             	mov    0x14(%eax),%eax
    a9c8:	39 c2                	cmp    %eax,%edx
    a9ca:	0f 85 93 00 00 00    	jne    aa63 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    a9d0:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a9d3:	89 d0                	mov    %edx,%eax
    a9d5:	01 c0                	add    %eax,%eax
    a9d7:	01 d0                	add    %edx,%eax
    a9d9:	01 c0                	add    %eax,%eax
    a9db:	8d 50 02             	lea    0x2(%eax),%edx
    a9de:	8b 45 18             	mov    0x18(%ebp),%eax
    a9e1:	01 d0                	add    %edx,%eax
    a9e3:	0f b6 00             	movzbl (%eax),%eax
    a9e6:	0f b6 c0             	movzbl %al,%eax
    a9e9:	c1 e0 08             	shl    $0x8,%eax
    a9ec:	89 c1                	mov    %eax,%ecx
    a9ee:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a9f1:	89 d0                	mov    %edx,%eax
    a9f3:	01 c0                	add    %eax,%eax
    a9f5:	01 d0                	add    %edx,%eax
    a9f7:	01 c0                	add    %eax,%eax
    a9f9:	8d 50 03             	lea    0x3(%eax),%edx
    a9fc:	8b 45 18             	mov    0x18(%ebp),%eax
    a9ff:	01 d0                	add    %edx,%eax
    aa01:	0f b6 00             	movzbl (%eax),%eax
    aa04:	0f b6 c0             	movzbl %al,%eax
    aa07:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    aa0a:	8b 45 20             	mov    0x20(%ebp),%eax
    aa0d:	8b 40 18             	mov    0x18(%eax),%eax
    aa10:	39 c2                	cmp    %eax,%edx
    aa12:	75 4f                	jne    aa63 <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    aa14:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aa17:	89 d0                	mov    %edx,%eax
    aa19:	01 c0                	add    %eax,%eax
    aa1b:	01 d0                	add    %edx,%eax
    aa1d:	01 c0                	add    %eax,%eax
    aa1f:	8d 50 04             	lea    0x4(%eax),%edx
    aa22:	8b 45 18             	mov    0x18(%ebp),%eax
    aa25:	01 d0                	add    %edx,%eax
    aa27:	0f b6 00             	movzbl (%eax),%eax
    aa2a:	0f b6 c0             	movzbl %al,%eax
    aa2d:	c1 e0 08             	shl    $0x8,%eax
    aa30:	89 c1                	mov    %eax,%ecx
    aa32:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aa35:	89 d0                	mov    %edx,%eax
    aa37:	01 c0                	add    %eax,%eax
    aa39:	01 d0                	add    %edx,%eax
    aa3b:	01 c0                	add    %eax,%eax
    aa3d:	8d 50 05             	lea    0x5(%eax),%edx
    aa40:	8b 45 18             	mov    0x18(%ebp),%eax
    aa43:	01 d0                	add    %edx,%eax
    aa45:	0f b6 00             	movzbl (%eax),%eax
    aa48:	0f b6 c0             	movzbl %al,%eax
    aa4b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    aa4e:	8b 45 20             	mov    0x20(%ebp),%eax
    aa51:	8b 40 1c             	mov    0x1c(%eax),%eax
    aa54:	39 c2                	cmp    %eax,%edx
    aa56:	75 0b                	jne    aa63 <getPixelColorRGBA8+0x397>
    aa58:	8b 45 14             	mov    0x14(%ebp),%eax
    aa5b:	c6 00 00             	movb   $0x0,(%eax)
    aa5e:	e9 33 02 00 00       	jmp    ac96 <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    aa63:	8b 45 14             	mov    0x14(%ebp),%eax
    aa66:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aa69:	e9 28 02 00 00       	jmp    ac96 <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    aa6e:	8b 45 20             	mov    0x20(%ebp),%eax
    aa71:	8b 00                	mov    (%eax),%eax
    aa73:	83 f8 03             	cmp    $0x3,%eax
    aa76:	0f 85 ac 00 00 00    	jne    ab28 <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    aa7c:	8b 45 20             	mov    0x20(%ebp),%eax
    aa7f:	8b 40 04             	mov    0x4(%eax),%eax
    aa82:	83 f8 08             	cmp    $0x8,%eax
    aa85:	75 13                	jne    aa9a <getPixelColorRGBA8+0x3ce>
    aa87:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aa8a:	8b 45 18             	mov    0x18(%ebp),%eax
    aa8d:	01 d0                	add    %edx,%eax
    aa8f:	0f b6 00             	movzbl (%eax),%eax
    aa92:	0f b6 c0             	movzbl %al,%eax
    aa95:	89 45 fc             	mov    %eax,-0x4(%ebp)
    aa98:	eb 28                	jmp    aac2 <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    aa9a:	8b 45 20             	mov    0x20(%ebp),%eax
    aa9d:	8b 50 04             	mov    0x4(%eax),%edx
    aaa0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    aaa3:	0f af c2             	imul   %edx,%eax
    aaa6:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    aaa9:	8b 45 20             	mov    0x20(%ebp),%eax
    aaac:	8b 40 04             	mov    0x4(%eax),%eax
    aaaf:	50                   	push   %eax
    aab0:	ff 75 18             	pushl  0x18(%ebp)
    aab3:	8d 45 ec             	lea    -0x14(%ebp),%eax
    aab6:	50                   	push   %eax
    aab7:	e8 55 d8 ff ff       	call   8311 <readBitsFromReversedStream>
    aabc:	83 c4 0c             	add    $0xc,%esp
    aabf:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    aac2:	8b 45 20             	mov    0x20(%ebp),%eax
    aac5:	8b 40 08             	mov    0x8(%eax),%eax
    aac8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aacb:	c1 e2 02             	shl    $0x2,%edx
    aace:	01 d0                	add    %edx,%eax
    aad0:	0f b6 10             	movzbl (%eax),%edx
    aad3:	8b 45 08             	mov    0x8(%ebp),%eax
    aad6:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    aad8:	8b 45 20             	mov    0x20(%ebp),%eax
    aadb:	8b 40 08             	mov    0x8(%eax),%eax
    aade:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aae1:	c1 e2 02             	shl    $0x2,%edx
    aae4:	83 c2 01             	add    $0x1,%edx
    aae7:	01 d0                	add    %edx,%eax
    aae9:	0f b6 10             	movzbl (%eax),%edx
    aaec:	8b 45 0c             	mov    0xc(%ebp),%eax
    aaef:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    aaf1:	8b 45 20             	mov    0x20(%ebp),%eax
    aaf4:	8b 40 08             	mov    0x8(%eax),%eax
    aaf7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    aafa:	c1 e2 02             	shl    $0x2,%edx
    aafd:	83 c2 02             	add    $0x2,%edx
    ab00:	01 d0                	add    %edx,%eax
    ab02:	0f b6 10             	movzbl (%eax),%edx
    ab05:	8b 45 10             	mov    0x10(%ebp),%eax
    ab08:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    ab0a:	8b 45 20             	mov    0x20(%ebp),%eax
    ab0d:	8b 40 08             	mov    0x8(%eax),%eax
    ab10:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ab13:	c1 e2 02             	shl    $0x2,%edx
    ab16:	83 c2 03             	add    $0x3,%edx
    ab19:	01 d0                	add    %edx,%eax
    ab1b:	0f b6 10             	movzbl (%eax),%edx
    ab1e:	8b 45 14             	mov    0x14(%ebp),%eax
    ab21:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ab23:	e9 6e 01 00 00       	jmp    ac96 <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    ab28:	8b 45 20             	mov    0x20(%ebp),%eax
    ab2b:	8b 00                	mov    (%eax),%eax
    ab2d:	83 f8 04             	cmp    $0x4,%eax
    ab30:	0f 85 95 00 00 00    	jne    abcb <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    ab36:	8b 45 20             	mov    0x20(%ebp),%eax
    ab39:	8b 40 04             	mov    0x4(%eax),%eax
    ab3c:	83 f8 08             	cmp    $0x8,%eax
    ab3f:	75 44                	jne    ab85 <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    ab41:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab44:	01 c0                	add    %eax,%eax
    ab46:	89 c2                	mov    %eax,%edx
    ab48:	8b 45 18             	mov    0x18(%ebp),%eax
    ab4b:	01 d0                	add    %edx,%eax
    ab4d:	0f b6 10             	movzbl (%eax),%edx
    ab50:	8b 45 10             	mov    0x10(%ebp),%eax
    ab53:	88 10                	mov    %dl,(%eax)
    ab55:	8b 45 10             	mov    0x10(%ebp),%eax
    ab58:	0f b6 10             	movzbl (%eax),%edx
    ab5b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab5e:	88 10                	mov    %dl,(%eax)
    ab60:	8b 45 0c             	mov    0xc(%ebp),%eax
    ab63:	0f b6 10             	movzbl (%eax),%edx
    ab66:	8b 45 08             	mov    0x8(%ebp),%eax
    ab69:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    ab6b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab6e:	01 c0                	add    %eax,%eax
    ab70:	8d 50 01             	lea    0x1(%eax),%edx
    ab73:	8b 45 18             	mov    0x18(%ebp),%eax
    ab76:	01 d0                	add    %edx,%eax
    ab78:	0f b6 10             	movzbl (%eax),%edx
    ab7b:	8b 45 14             	mov    0x14(%ebp),%eax
    ab7e:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ab80:	e9 11 01 00 00       	jmp    ac96 <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    ab85:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ab88:	c1 e0 02             	shl    $0x2,%eax
    ab8b:	89 c2                	mov    %eax,%edx
    ab8d:	8b 45 18             	mov    0x18(%ebp),%eax
    ab90:	01 d0                	add    %edx,%eax
    ab92:	0f b6 10             	movzbl (%eax),%edx
    ab95:	8b 45 10             	mov    0x10(%ebp),%eax
    ab98:	88 10                	mov    %dl,(%eax)
    ab9a:	8b 45 10             	mov    0x10(%ebp),%eax
    ab9d:	0f b6 10             	movzbl (%eax),%edx
    aba0:	8b 45 0c             	mov    0xc(%ebp),%eax
    aba3:	88 10                	mov    %dl,(%eax)
    aba5:	8b 45 0c             	mov    0xc(%ebp),%eax
    aba8:	0f b6 10             	movzbl (%eax),%edx
    abab:	8b 45 08             	mov    0x8(%ebp),%eax
    abae:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    abb0:	8b 45 1c             	mov    0x1c(%ebp),%eax
    abb3:	c1 e0 02             	shl    $0x2,%eax
    abb6:	8d 50 02             	lea    0x2(%eax),%edx
    abb9:	8b 45 18             	mov    0x18(%ebp),%eax
    abbc:	01 d0                	add    %edx,%eax
    abbe:	0f b6 10             	movzbl (%eax),%edx
    abc1:	8b 45 14             	mov    0x14(%ebp),%eax
    abc4:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    abc6:	e9 cb 00 00 00       	jmp    ac96 <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    abcb:	8b 45 20             	mov    0x20(%ebp),%eax
    abce:	8b 00                	mov    (%eax),%eax
    abd0:	83 f8 06             	cmp    $0x6,%eax
    abd3:	0f 85 bd 00 00 00    	jne    ac96 <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    abd9:	8b 45 20             	mov    0x20(%ebp),%eax
    abdc:	8b 40 04             	mov    0x4(%eax),%eax
    abdf:	83 f8 08             	cmp    $0x8,%eax
    abe2:	75 59                	jne    ac3d <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    abe4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    abe7:	c1 e0 02             	shl    $0x2,%eax
    abea:	89 c2                	mov    %eax,%edx
    abec:	8b 45 18             	mov    0x18(%ebp),%eax
    abef:	01 d0                	add    %edx,%eax
    abf1:	0f b6 10             	movzbl (%eax),%edx
    abf4:	8b 45 08             	mov    0x8(%ebp),%eax
    abf7:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    abf9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    abfc:	c1 e0 02             	shl    $0x2,%eax
    abff:	8d 50 01             	lea    0x1(%eax),%edx
    ac02:	8b 45 18             	mov    0x18(%ebp),%eax
    ac05:	01 d0                	add    %edx,%eax
    ac07:	0f b6 10             	movzbl (%eax),%edx
    ac0a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac0d:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    ac0f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ac12:	c1 e0 02             	shl    $0x2,%eax
    ac15:	8d 50 02             	lea    0x2(%eax),%edx
    ac18:	8b 45 18             	mov    0x18(%ebp),%eax
    ac1b:	01 d0                	add    %edx,%eax
    ac1d:	0f b6 10             	movzbl (%eax),%edx
    ac20:	8b 45 10             	mov    0x10(%ebp),%eax
    ac23:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    ac25:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ac28:	c1 e0 02             	shl    $0x2,%eax
    ac2b:	8d 50 03             	lea    0x3(%eax),%edx
    ac2e:	8b 45 18             	mov    0x18(%ebp),%eax
    ac31:	01 d0                	add    %edx,%eax
    ac33:	0f b6 10             	movzbl (%eax),%edx
    ac36:	8b 45 14             	mov    0x14(%ebp),%eax
    ac39:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ac3b:	eb 59                	jmp    ac96 <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    ac3d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ac40:	c1 e0 03             	shl    $0x3,%eax
    ac43:	89 c2                	mov    %eax,%edx
    ac45:	8b 45 18             	mov    0x18(%ebp),%eax
    ac48:	01 d0                	add    %edx,%eax
    ac4a:	0f b6 10             	movzbl (%eax),%edx
    ac4d:	8b 45 08             	mov    0x8(%ebp),%eax
    ac50:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    ac52:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ac55:	c1 e0 03             	shl    $0x3,%eax
    ac58:	8d 50 02             	lea    0x2(%eax),%edx
    ac5b:	8b 45 18             	mov    0x18(%ebp),%eax
    ac5e:	01 d0                	add    %edx,%eax
    ac60:	0f b6 10             	movzbl (%eax),%edx
    ac63:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac66:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    ac68:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ac6b:	c1 e0 03             	shl    $0x3,%eax
    ac6e:	8d 50 04             	lea    0x4(%eax),%edx
    ac71:	8b 45 18             	mov    0x18(%ebp),%eax
    ac74:	01 d0                	add    %edx,%eax
    ac76:	0f b6 10             	movzbl (%eax),%edx
    ac79:	8b 45 10             	mov    0x10(%ebp),%eax
    ac7c:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    ac7e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ac81:	c1 e0 03             	shl    $0x3,%eax
    ac84:	8d 50 06             	lea    0x6(%eax),%edx
    ac87:	8b 45 18             	mov    0x18(%ebp),%eax
    ac8a:	01 d0                	add    %edx,%eax
    ac8c:	0f b6 10             	movzbl (%eax),%edx
    ac8f:	8b 45 14             	mov    0x14(%ebp),%eax
    ac92:	88 10                	mov    %dl,(%eax)
    }
  }
}
    ac94:	eb 00                	jmp    ac96 <getPixelColorRGBA8+0x5ca>
    ac96:	90                   	nop
    ac97:	c9                   	leave  
    ac98:	c3                   	ret    

0000ac99 <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    ac99:	55                   	push   %ebp
    ac9a:	89 e5                	mov    %esp,%ebp
    ac9c:	53                   	push   %ebx
    ac9d:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    aca0:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    aca7:	8b 45 14             	mov    0x14(%ebp),%eax
    acaa:	8b 00                	mov    (%eax),%eax
    acac:	85 c0                	test   %eax,%eax
    acae:	0f 85 14 02 00 00    	jne    aec8 <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    acb4:	8b 45 14             	mov    0x14(%ebp),%eax
    acb7:	8b 40 04             	mov    0x4(%eax),%eax
    acba:	83 f8 08             	cmp    $0x8,%eax
    acbd:	0f 85 a0 00 00 00    	jne    ad63 <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    acc3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    acca:	eb 39                	jmp    ad05 <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    accc:	8b 45 08             	mov    0x8(%ebp),%eax
    accf:	83 c0 01             	add    $0x1,%eax
    acd2:	8b 55 08             	mov    0x8(%ebp),%edx
    acd5:	83 c2 02             	add    $0x2,%edx
    acd8:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    acdb:	8b 4d 10             	mov    0x10(%ebp),%ecx
    acde:	01 d9                	add    %ebx,%ecx
    ace0:	0f b6 09             	movzbl (%ecx),%ecx
    ace3:	88 0a                	mov    %cl,(%edx)
    ace5:	0f b6 12             	movzbl (%edx),%edx
    ace8:	88 10                	mov    %dl,(%eax)
    acea:	0f b6 10             	movzbl (%eax),%edx
    aced:	8b 45 08             	mov    0x8(%ebp),%eax
    acf0:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    acf2:	8b 45 08             	mov    0x8(%ebp),%eax
    acf5:	83 c0 03             	add    $0x3,%eax
    acf8:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    acfb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    acff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ad02:	01 45 08             	add    %eax,0x8(%ebp)
    ad05:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad08:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ad0b:	75 bf                	jne    accc <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    ad0d:	8b 45 14             	mov    0x14(%ebp),%eax
    ad10:	8b 40 10             	mov    0x10(%eax),%eax
    ad13:	85 c0                	test   %eax,%eax
    ad15:	0f 84 48 06 00 00    	je     b363 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    ad1b:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad1e:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    ad22:	f7 d8                	neg    %eax
    ad24:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad27:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ad2e:	eb 26                	jmp    ad56 <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    ad30:	8b 45 08             	mov    0x8(%ebp),%eax
    ad33:	0f b6 00             	movzbl (%eax),%eax
    ad36:	0f b6 d0             	movzbl %al,%edx
    ad39:	8b 45 14             	mov    0x14(%ebp),%eax
    ad3c:	8b 40 14             	mov    0x14(%eax),%eax
    ad3f:	39 c2                	cmp    %eax,%edx
    ad41:	75 09                	jne    ad4c <getPixelColorsRGBA8+0xb3>
    ad43:	8b 45 08             	mov    0x8(%ebp),%eax
    ad46:	83 c0 03             	add    $0x3,%eax
    ad49:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad4c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ad50:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ad53:	01 45 08             	add    %eax,0x8(%ebp)
    ad56:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ad59:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ad5c:	75 d2                	jne    ad30 <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ad5e:	e9 00 06 00 00       	jmp    b363 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    ad63:	8b 45 14             	mov    0x14(%ebp),%eax
    ad66:	8b 40 04             	mov    0x4(%eax),%eax
    ad69:	83 f8 10             	cmp    $0x10,%eax
    ad6c:	0f 85 a5 00 00 00    	jne    ae17 <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ad72:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ad79:	e9 88 00 00 00       	jmp    ae06 <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    ad7e:	8b 45 08             	mov    0x8(%ebp),%eax
    ad81:	83 c0 01             	add    $0x1,%eax
    ad84:	8b 55 08             	mov    0x8(%ebp),%edx
    ad87:	83 c2 02             	add    $0x2,%edx
    ad8a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    ad8d:	01 c9                	add    %ecx,%ecx
    ad8f:	89 cb                	mov    %ecx,%ebx
    ad91:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ad94:	01 d9                	add    %ebx,%ecx
    ad96:	0f b6 09             	movzbl (%ecx),%ecx
    ad99:	88 0a                	mov    %cl,(%edx)
    ad9b:	0f b6 12             	movzbl (%edx),%edx
    ad9e:	88 10                	mov    %dl,(%eax)
    ada0:	0f b6 10             	movzbl (%eax),%edx
    ada3:	8b 45 08             	mov    0x8(%ebp),%eax
    ada6:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    ada8:	8b 45 08             	mov    0x8(%ebp),%eax
    adab:	8d 50 03             	lea    0x3(%eax),%edx
    adae:	8b 45 14             	mov    0x14(%ebp),%eax
    adb1:	8b 40 10             	mov    0x10(%eax),%eax
    adb4:	85 c0                	test   %eax,%eax
    adb6:	74 3d                	je     adf5 <getPixelColorsRGBA8+0x15c>
    adb8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    adbb:	01 c0                	add    %eax,%eax
    adbd:	89 c1                	mov    %eax,%ecx
    adbf:	8b 45 10             	mov    0x10(%ebp),%eax
    adc2:	01 c8                	add    %ecx,%eax
    adc4:	0f b6 00             	movzbl (%eax),%eax
    adc7:	0f b6 c0             	movzbl %al,%eax
    adca:	c1 e0 08             	shl    $0x8,%eax
    adcd:	89 c1                	mov    %eax,%ecx
    adcf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    add2:	01 c0                	add    %eax,%eax
    add4:	8d 58 01             	lea    0x1(%eax),%ebx
    add7:	8b 45 10             	mov    0x10(%ebp),%eax
    adda:	01 d8                	add    %ebx,%eax
    addc:	0f b6 00             	movzbl (%eax),%eax
    addf:	0f b6 c0             	movzbl %al,%eax
    ade2:	01 c1                	add    %eax,%ecx
    ade4:	8b 45 14             	mov    0x14(%ebp),%eax
    ade7:	8b 40 14             	mov    0x14(%eax),%eax
    adea:	39 c1                	cmp    %eax,%ecx
    adec:	75 07                	jne    adf5 <getPixelColorsRGBA8+0x15c>
    adee:	b8 00 00 00 00       	mov    $0x0,%eax
    adf3:	eb 05                	jmp    adfa <getPixelColorsRGBA8+0x161>
    adf5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    adfa:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    adfc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ae00:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ae03:	01 45 08             	add    %eax,0x8(%ebp)
    ae06:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae09:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ae0c:	0f 85 6c ff ff ff    	jne    ad7e <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    ae12:	e9 4c 05 00 00       	jmp    b363 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    ae17:	8b 45 14             	mov    0x14(%ebp),%eax
    ae1a:	8b 40 04             	mov    0x4(%eax),%eax
    ae1d:	ba 01 00 00 00       	mov    $0x1,%edx
    ae22:	89 c1                	mov    %eax,%ecx
    ae24:	d3 e2                	shl    %cl,%edx
    ae26:	89 d0                	mov    %edx,%eax
    ae28:	83 e8 01             	sub    $0x1,%eax
    ae2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    ae2e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae35:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae3c:	eb 79                	jmp    aeb7 <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    ae3e:	8b 45 14             	mov    0x14(%ebp),%eax
    ae41:	8b 40 04             	mov    0x4(%eax),%eax
    ae44:	50                   	push   %eax
    ae45:	ff 75 10             	pushl  0x10(%ebp)
    ae48:	8d 45 e0             	lea    -0x20(%ebp),%eax
    ae4b:	50                   	push   %eax
    ae4c:	e8 c0 d4 ff ff       	call   8311 <readBitsFromReversedStream>
    ae51:	83 c4 0c             	add    $0xc,%esp
    ae54:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    ae57:	8b 45 08             	mov    0x8(%ebp),%eax
    ae5a:	8d 48 01             	lea    0x1(%eax),%ecx
    ae5d:	8b 45 08             	mov    0x8(%ebp),%eax
    ae60:	8d 58 02             	lea    0x2(%eax),%ebx
    ae63:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ae66:	89 d0                	mov    %edx,%eax
    ae68:	c1 e0 08             	shl    $0x8,%eax
    ae6b:	29 d0                	sub    %edx,%eax
    ae6d:	ba 00 00 00 00       	mov    $0x0,%edx
    ae72:	f7 75 f0             	divl   -0x10(%ebp)
    ae75:	88 03                	mov    %al,(%ebx)
    ae77:	0f b6 03             	movzbl (%ebx),%eax
    ae7a:	88 01                	mov    %al,(%ecx)
    ae7c:	0f b6 11             	movzbl (%ecx),%edx
    ae7f:	8b 45 08             	mov    0x8(%ebp),%eax
    ae82:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    ae84:	8b 45 08             	mov    0x8(%ebp),%eax
    ae87:	8d 50 03             	lea    0x3(%eax),%edx
    ae8a:	8b 45 14             	mov    0x14(%ebp),%eax
    ae8d:	8b 40 10             	mov    0x10(%eax),%eax
    ae90:	85 c0                	test   %eax,%eax
    ae92:	74 12                	je     aea6 <getPixelColorsRGBA8+0x20d>
    ae94:	8b 45 14             	mov    0x14(%ebp),%eax
    ae97:	8b 40 14             	mov    0x14(%eax),%eax
    ae9a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    ae9d:	75 07                	jne    aea6 <getPixelColorsRGBA8+0x20d>
    ae9f:	b8 00 00 00 00       	mov    $0x0,%eax
    aea4:	eb 05                	jmp    aeab <getPixelColorsRGBA8+0x212>
    aea6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    aeab:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aead:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    aeb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    aeb4:	01 45 08             	add    %eax,0x8(%ebp)
    aeb7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    aeba:	3b 45 0c             	cmp    0xc(%ebp),%eax
    aebd:	0f 85 7b ff ff ff    	jne    ae3e <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    aec3:	e9 9b 04 00 00       	jmp    b363 <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    aec8:	8b 45 14             	mov    0x14(%ebp),%eax
    aecb:	8b 00                	mov    (%eax),%eax
    aecd:	83 f8 02             	cmp    $0x2,%eax
    aed0:	0f 85 41 02 00 00    	jne    b117 <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    aed6:	8b 45 14             	mov    0x14(%ebp),%eax
    aed9:	8b 40 04             	mov    0x4(%eax),%eax
    aedc:	83 f8 08             	cmp    $0x8,%eax
    aedf:	0f 85 c4 00 00 00    	jne    afa9 <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aee5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    aeec:	eb 31                	jmp    af1f <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    aeee:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aef1:	89 d0                	mov    %edx,%eax
    aef3:	01 c0                	add    %eax,%eax
    aef5:	01 d0                	add    %edx,%eax
    aef7:	89 c2                	mov    %eax,%edx
    aef9:	8b 45 10             	mov    0x10(%ebp),%eax
    aefc:	01 d0                	add    %edx,%eax
    aefe:	6a 03                	push   $0x3
    af00:	50                   	push   %eax
    af01:	ff 75 08             	pushl  0x8(%ebp)
    af04:	e8 a3 85 ff ff       	call   34ac <lodepng_memcpy>
    af09:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    af0c:	8b 45 08             	mov    0x8(%ebp),%eax
    af0f:	83 c0 03             	add    $0x3,%eax
    af12:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    af15:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    af19:	8b 45 f4             	mov    -0xc(%ebp),%eax
    af1c:	01 45 08             	add    %eax,0x8(%ebp)
    af1f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    af22:	3b 45 0c             	cmp    0xc(%ebp),%eax
    af25:	75 c7                	jne    aeee <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    af27:	8b 45 14             	mov    0x14(%ebp),%eax
    af2a:	8b 40 10             	mov    0x10(%eax),%eax
    af2d:	85 c0                	test   %eax,%eax
    af2f:	0f 84 2e 04 00 00    	je     b363 <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    af35:	8b 45 0c             	mov    0xc(%ebp),%eax
    af38:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    af3c:	f7 d8                	neg    %eax
    af3e:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    af41:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    af48:	eb 52                	jmp    af9c <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    af4a:	8b 45 08             	mov    0x8(%ebp),%eax
    af4d:	0f b6 00             	movzbl (%eax),%eax
    af50:	0f b6 d0             	movzbl %al,%edx
    af53:	8b 45 14             	mov    0x14(%ebp),%eax
    af56:	8b 40 14             	mov    0x14(%eax),%eax
    af59:	39 c2                	cmp    %eax,%edx
    af5b:	75 35                	jne    af92 <getPixelColorsRGBA8+0x2f9>
    af5d:	8b 45 08             	mov    0x8(%ebp),%eax
    af60:	83 c0 01             	add    $0x1,%eax
    af63:	0f b6 00             	movzbl (%eax),%eax
    af66:	0f b6 d0             	movzbl %al,%edx
    af69:	8b 45 14             	mov    0x14(%ebp),%eax
    af6c:	8b 40 18             	mov    0x18(%eax),%eax
    af6f:	39 c2                	cmp    %eax,%edx
    af71:	75 1f                	jne    af92 <getPixelColorsRGBA8+0x2f9>
    af73:	8b 45 08             	mov    0x8(%ebp),%eax
    af76:	83 c0 02             	add    $0x2,%eax
    af79:	0f b6 00             	movzbl (%eax),%eax
    af7c:	0f b6 d0             	movzbl %al,%edx
    af7f:	8b 45 14             	mov    0x14(%ebp),%eax
    af82:	8b 40 1c             	mov    0x1c(%eax),%eax
    af85:	39 c2                	cmp    %eax,%edx
    af87:	75 09                	jne    af92 <getPixelColorsRGBA8+0x2f9>
    af89:	8b 45 08             	mov    0x8(%ebp),%eax
    af8c:	83 c0 03             	add    $0x3,%eax
    af8f:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    af92:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    af96:	8b 45 f4             	mov    -0xc(%ebp),%eax
    af99:	01 45 08             	add    %eax,0x8(%ebp)
    af9c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    af9f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    afa2:	75 a6                	jne    af4a <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    afa4:	e9 ba 03 00 00       	jmp    b363 <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    afa9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    afb0:	e9 51 01 00 00       	jmp    b106 <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    afb5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    afb8:	89 d0                	mov    %edx,%eax
    afba:	01 c0                	add    %eax,%eax
    afbc:	01 d0                	add    %edx,%eax
    afbe:	01 c0                	add    %eax,%eax
    afc0:	89 c2                	mov    %eax,%edx
    afc2:	8b 45 10             	mov    0x10(%ebp),%eax
    afc5:	01 d0                	add    %edx,%eax
    afc7:	0f b6 10             	movzbl (%eax),%edx
    afca:	8b 45 08             	mov    0x8(%ebp),%eax
    afcd:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    afcf:	8b 45 08             	mov    0x8(%ebp),%eax
    afd2:	8d 48 01             	lea    0x1(%eax),%ecx
    afd5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    afd8:	89 d0                	mov    %edx,%eax
    afda:	01 c0                	add    %eax,%eax
    afdc:	01 d0                	add    %edx,%eax
    afde:	01 c0                	add    %eax,%eax
    afe0:	8d 50 02             	lea    0x2(%eax),%edx
    afe3:	8b 45 10             	mov    0x10(%ebp),%eax
    afe6:	01 d0                	add    %edx,%eax
    afe8:	0f b6 00             	movzbl (%eax),%eax
    afeb:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    afed:	8b 45 08             	mov    0x8(%ebp),%eax
    aff0:	8d 48 02             	lea    0x2(%eax),%ecx
    aff3:	8b 55 f8             	mov    -0x8(%ebp),%edx
    aff6:	89 d0                	mov    %edx,%eax
    aff8:	01 c0                	add    %eax,%eax
    affa:	01 d0                	add    %edx,%eax
    affc:	01 c0                	add    %eax,%eax
    affe:	8d 50 04             	lea    0x4(%eax),%edx
    b001:	8b 45 10             	mov    0x10(%ebp),%eax
    b004:	01 d0                	add    %edx,%eax
    b006:	0f b6 00             	movzbl (%eax),%eax
    b009:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    b00b:	8b 45 08             	mov    0x8(%ebp),%eax
    b00e:	8d 48 03             	lea    0x3(%eax),%ecx
    b011:	8b 45 14             	mov    0x14(%ebp),%eax
    b014:	8b 40 10             	mov    0x10(%eax),%eax
    b017:	85 c0                	test   %eax,%eax
    b019:	0f 84 d6 00 00 00    	je     b0f5 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b01f:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b022:	89 d0                	mov    %edx,%eax
    b024:	01 c0                	add    %eax,%eax
    b026:	01 d0                	add    %edx,%eax
    b028:	01 c0                	add    %eax,%eax
    b02a:	89 c2                	mov    %eax,%edx
    b02c:	8b 45 10             	mov    0x10(%ebp),%eax
    b02f:	01 d0                	add    %edx,%eax
    b031:	0f b6 00             	movzbl (%eax),%eax
    b034:	0f b6 c0             	movzbl %al,%eax
    b037:	c1 e0 08             	shl    $0x8,%eax
    b03a:	89 c3                	mov    %eax,%ebx
    b03c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b03f:	89 d0                	mov    %edx,%eax
    b041:	01 c0                	add    %eax,%eax
    b043:	01 d0                	add    %edx,%eax
    b045:	01 c0                	add    %eax,%eax
    b047:	8d 50 01             	lea    0x1(%eax),%edx
    b04a:	8b 45 10             	mov    0x10(%ebp),%eax
    b04d:	01 d0                	add    %edx,%eax
    b04f:	0f b6 00             	movzbl (%eax),%eax
    b052:	0f b6 c0             	movzbl %al,%eax
    b055:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b058:	8b 45 14             	mov    0x14(%ebp),%eax
    b05b:	8b 40 14             	mov    0x14(%eax),%eax
    b05e:	39 c2                	cmp    %eax,%edx
    b060:	0f 85 8f 00 00 00    	jne    b0f5 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b066:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b069:	89 d0                	mov    %edx,%eax
    b06b:	01 c0                	add    %eax,%eax
    b06d:	01 d0                	add    %edx,%eax
    b06f:	01 c0                	add    %eax,%eax
    b071:	8d 50 02             	lea    0x2(%eax),%edx
    b074:	8b 45 10             	mov    0x10(%ebp),%eax
    b077:	01 d0                	add    %edx,%eax
    b079:	0f b6 00             	movzbl (%eax),%eax
    b07c:	0f b6 c0             	movzbl %al,%eax
    b07f:	c1 e0 08             	shl    $0x8,%eax
    b082:	89 c3                	mov    %eax,%ebx
    b084:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b087:	89 d0                	mov    %edx,%eax
    b089:	01 c0                	add    %eax,%eax
    b08b:	01 d0                	add    %edx,%eax
    b08d:	01 c0                	add    %eax,%eax
    b08f:	8d 50 03             	lea    0x3(%eax),%edx
    b092:	8b 45 10             	mov    0x10(%ebp),%eax
    b095:	01 d0                	add    %edx,%eax
    b097:	0f b6 00             	movzbl (%eax),%eax
    b09a:	0f b6 c0             	movzbl %al,%eax
    b09d:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b0a0:	8b 45 14             	mov    0x14(%ebp),%eax
    b0a3:	8b 40 18             	mov    0x18(%eax),%eax
    b0a6:	39 c2                	cmp    %eax,%edx
    b0a8:	75 4b                	jne    b0f5 <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    b0aa:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b0ad:	89 d0                	mov    %edx,%eax
    b0af:	01 c0                	add    %eax,%eax
    b0b1:	01 d0                	add    %edx,%eax
    b0b3:	01 c0                	add    %eax,%eax
    b0b5:	8d 50 04             	lea    0x4(%eax),%edx
    b0b8:	8b 45 10             	mov    0x10(%ebp),%eax
    b0bb:	01 d0                	add    %edx,%eax
    b0bd:	0f b6 00             	movzbl (%eax),%eax
    b0c0:	0f b6 c0             	movzbl %al,%eax
    b0c3:	c1 e0 08             	shl    $0x8,%eax
    b0c6:	89 c3                	mov    %eax,%ebx
    b0c8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b0cb:	89 d0                	mov    %edx,%eax
    b0cd:	01 c0                	add    %eax,%eax
    b0cf:	01 d0                	add    %edx,%eax
    b0d1:	01 c0                	add    %eax,%eax
    b0d3:	8d 50 05             	lea    0x5(%eax),%edx
    b0d6:	8b 45 10             	mov    0x10(%ebp),%eax
    b0d9:	01 d0                	add    %edx,%eax
    b0db:	0f b6 00             	movzbl (%eax),%eax
    b0de:	0f b6 c0             	movzbl %al,%eax
    b0e1:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b0e4:	8b 45 14             	mov    0x14(%ebp),%eax
    b0e7:	8b 40 1c             	mov    0x1c(%eax),%eax
    b0ea:	39 c2                	cmp    %eax,%edx
    b0ec:	75 07                	jne    b0f5 <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    b0ee:	b8 00 00 00 00       	mov    $0x0,%eax
    b0f3:	eb 05                	jmp    b0fa <getPixelColorsRGBA8+0x461>
    b0f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b0fa:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0fc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b100:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b103:	01 45 08             	add    %eax,0x8(%ebp)
    b106:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b109:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b10c:	0f 85 a3 fe ff ff    	jne    afb5 <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b112:	e9 4c 02 00 00       	jmp    b363 <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b117:	8b 45 14             	mov    0x14(%ebp),%eax
    b11a:	8b 00                	mov    (%eax),%eax
    b11c:	83 f8 03             	cmp    $0x3,%eax
    b11f:	0f 85 b4 00 00 00    	jne    b1d9 <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    b125:	8b 45 14             	mov    0x14(%ebp),%eax
    b128:	8b 40 04             	mov    0x4(%eax),%eax
    b12b:	83 f8 08             	cmp    $0x8,%eax
    b12e:	75 4d                	jne    b17d <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b130:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b137:	eb 37                	jmp    b170 <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    b139:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b13c:	8b 45 10             	mov    0x10(%ebp),%eax
    b13f:	01 d0                	add    %edx,%eax
    b141:	0f b6 00             	movzbl (%eax),%eax
    b144:	0f b6 c0             	movzbl %al,%eax
    b147:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b14a:	8b 45 14             	mov    0x14(%ebp),%eax
    b14d:	8b 40 08             	mov    0x8(%eax),%eax
    b150:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b153:	c1 e2 02             	shl    $0x2,%edx
    b156:	01 d0                	add    %edx,%eax
    b158:	6a 04                	push   $0x4
    b15a:	50                   	push   %eax
    b15b:	ff 75 08             	pushl  0x8(%ebp)
    b15e:	e8 49 83 ff ff       	call   34ac <lodepng_memcpy>
    b163:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b166:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b16a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b16d:	01 45 08             	add    %eax,0x8(%ebp)
    b170:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b173:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b176:	75 c1                	jne    b139 <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b178:	e9 e6 01 00 00       	jmp    b363 <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    b17d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b184:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b18b:	eb 3f                	jmp    b1cc <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b18d:	8b 45 14             	mov    0x14(%ebp),%eax
    b190:	8b 40 04             	mov    0x4(%eax),%eax
    b193:	50                   	push   %eax
    b194:	ff 75 10             	pushl  0x10(%ebp)
    b197:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b19a:	50                   	push   %eax
    b19b:	e8 71 d1 ff ff       	call   8311 <readBitsFromReversedStream>
    b1a0:	83 c4 0c             	add    $0xc,%esp
    b1a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b1a6:	8b 45 14             	mov    0x14(%ebp),%eax
    b1a9:	8b 40 08             	mov    0x8(%eax),%eax
    b1ac:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b1af:	c1 e2 02             	shl    $0x2,%edx
    b1b2:	01 d0                	add    %edx,%eax
    b1b4:	6a 04                	push   $0x4
    b1b6:	50                   	push   %eax
    b1b7:	ff 75 08             	pushl  0x8(%ebp)
    b1ba:	e8 ed 82 ff ff       	call   34ac <lodepng_memcpy>
    b1bf:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b1c2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b1c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b1c9:	01 45 08             	add    %eax,0x8(%ebp)
    b1cc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b1cf:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b1d2:	75 b9                	jne    b18d <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b1d4:	e9 8a 01 00 00       	jmp    b363 <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b1d9:	8b 45 14             	mov    0x14(%ebp),%eax
    b1dc:	8b 00                	mov    (%eax),%eax
    b1de:	83 f8 04             	cmp    $0x4,%eax
    b1e1:	0f 85 d1 00 00 00    	jne    b2b8 <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    b1e7:	8b 45 14             	mov    0x14(%ebp),%eax
    b1ea:	8b 40 04             	mov    0x4(%eax),%eax
    b1ed:	83 f8 08             	cmp    $0x8,%eax
    b1f0:	75 62                	jne    b254 <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b1f2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b1f9:	eb 4c                	jmp    b247 <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b1fb:	8b 45 08             	mov    0x8(%ebp),%eax
    b1fe:	83 c0 01             	add    $0x1,%eax
    b201:	8b 55 08             	mov    0x8(%ebp),%edx
    b204:	83 c2 02             	add    $0x2,%edx
    b207:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b20a:	01 c9                	add    %ecx,%ecx
    b20c:	89 cb                	mov    %ecx,%ebx
    b20e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b211:	01 d9                	add    %ebx,%ecx
    b213:	0f b6 09             	movzbl (%ecx),%ecx
    b216:	88 0a                	mov    %cl,(%edx)
    b218:	0f b6 12             	movzbl (%edx),%edx
    b21b:	88 10                	mov    %dl,(%eax)
    b21d:	0f b6 10             	movzbl (%eax),%edx
    b220:	8b 45 08             	mov    0x8(%ebp),%eax
    b223:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    b225:	8b 45 08             	mov    0x8(%ebp),%eax
    b228:	8d 50 03             	lea    0x3(%eax),%edx
    b22b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b22e:	01 c0                	add    %eax,%eax
    b230:	8d 48 01             	lea    0x1(%eax),%ecx
    b233:	8b 45 10             	mov    0x10(%ebp),%eax
    b236:	01 c8                	add    %ecx,%eax
    b238:	0f b6 00             	movzbl (%eax),%eax
    b23b:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b23d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b241:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b244:	01 45 08             	add    %eax,0x8(%ebp)
    b247:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b24a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b24d:	75 ac                	jne    b1fb <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b24f:	e9 0f 01 00 00       	jmp    b363 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b254:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b25b:	eb 4e                	jmp    b2ab <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b25d:	8b 45 08             	mov    0x8(%ebp),%eax
    b260:	83 c0 01             	add    $0x1,%eax
    b263:	8b 55 08             	mov    0x8(%ebp),%edx
    b266:	83 c2 02             	add    $0x2,%edx
    b269:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b26c:	c1 e1 02             	shl    $0x2,%ecx
    b26f:	89 cb                	mov    %ecx,%ebx
    b271:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b274:	01 d9                	add    %ebx,%ecx
    b276:	0f b6 09             	movzbl (%ecx),%ecx
    b279:	88 0a                	mov    %cl,(%edx)
    b27b:	0f b6 12             	movzbl (%edx),%edx
    b27e:	88 10                	mov    %dl,(%eax)
    b280:	0f b6 10             	movzbl (%eax),%edx
    b283:	8b 45 08             	mov    0x8(%ebp),%eax
    b286:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    b288:	8b 45 08             	mov    0x8(%ebp),%eax
    b28b:	8d 50 03             	lea    0x3(%eax),%edx
    b28e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b291:	c1 e0 02             	shl    $0x2,%eax
    b294:	8d 48 02             	lea    0x2(%eax),%ecx
    b297:	8b 45 10             	mov    0x10(%ebp),%eax
    b29a:	01 c8                	add    %ecx,%eax
    b29c:	0f b6 00             	movzbl (%eax),%eax
    b29f:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2a1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b2a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b2a8:	01 45 08             	add    %eax,0x8(%ebp)
    b2ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2ae:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b2b1:	75 aa                	jne    b25d <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b2b3:	e9 ab 00 00 00       	jmp    b363 <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b2b8:	8b 45 14             	mov    0x14(%ebp),%eax
    b2bb:	8b 00                	mov    (%eax),%eax
    b2bd:	83 f8 06             	cmp    $0x6,%eax
    b2c0:	0f 85 9d 00 00 00    	jne    b363 <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    b2c6:	8b 45 14             	mov    0x14(%ebp),%eax
    b2c9:	8b 40 04             	mov    0x4(%eax),%eax
    b2cc:	83 f8 08             	cmp    $0x8,%eax
    b2cf:	75 17                	jne    b2e8 <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    b2d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    b2d4:	c1 e0 02             	shl    $0x2,%eax
    b2d7:	50                   	push   %eax
    b2d8:	ff 75 10             	pushl  0x10(%ebp)
    b2db:	ff 75 08             	pushl  0x8(%ebp)
    b2de:	e8 c9 81 ff ff       	call   34ac <lodepng_memcpy>
    b2e3:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b2e6:	eb 7b                	jmp    b363 <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2e8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b2ef:	eb 6a                	jmp    b35b <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    b2f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2f4:	c1 e0 03             	shl    $0x3,%eax
    b2f7:	89 c2                	mov    %eax,%edx
    b2f9:	8b 45 10             	mov    0x10(%ebp),%eax
    b2fc:	01 d0                	add    %edx,%eax
    b2fe:	0f b6 10             	movzbl (%eax),%edx
    b301:	8b 45 08             	mov    0x8(%ebp),%eax
    b304:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b306:	8b 45 08             	mov    0x8(%ebp),%eax
    b309:	8d 50 01             	lea    0x1(%eax),%edx
    b30c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b30f:	c1 e0 03             	shl    $0x3,%eax
    b312:	8d 48 02             	lea    0x2(%eax),%ecx
    b315:	8b 45 10             	mov    0x10(%ebp),%eax
    b318:	01 c8                	add    %ecx,%eax
    b31a:	0f b6 00             	movzbl (%eax),%eax
    b31d:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b31f:	8b 45 08             	mov    0x8(%ebp),%eax
    b322:	8d 50 02             	lea    0x2(%eax),%edx
    b325:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b328:	c1 e0 03             	shl    $0x3,%eax
    b32b:	8d 48 04             	lea    0x4(%eax),%ecx
    b32e:	8b 45 10             	mov    0x10(%ebp),%eax
    b331:	01 c8                	add    %ecx,%eax
    b333:	0f b6 00             	movzbl (%eax),%eax
    b336:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    b338:	8b 45 08             	mov    0x8(%ebp),%eax
    b33b:	8d 50 03             	lea    0x3(%eax),%edx
    b33e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b341:	c1 e0 03             	shl    $0x3,%eax
    b344:	8d 48 06             	lea    0x6(%eax),%ecx
    b347:	8b 45 10             	mov    0x10(%ebp),%eax
    b34a:	01 c8                	add    %ecx,%eax
    b34c:	0f b6 00             	movzbl (%eax),%eax
    b34f:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b351:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b355:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b358:	01 45 08             	add    %eax,0x8(%ebp)
    b35b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b35e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b361:	75 8e                	jne    b2f1 <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b363:	90                   	nop
    b364:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b367:	c9                   	leave  
    b368:	c3                   	ret    

0000b369 <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    b369:	55                   	push   %ebp
    b36a:	89 e5                	mov    %esp,%ebp
    b36c:	53                   	push   %ebx
    b36d:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    b370:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b377:	8b 45 14             	mov    0x14(%ebp),%eax
    b37a:	8b 00                	mov    (%eax),%eax
    b37c:	85 c0                	test   %eax,%eax
    b37e:	0f 85 2a 01 00 00    	jne    b4ae <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    b384:	8b 45 14             	mov    0x14(%ebp),%eax
    b387:	8b 40 04             	mov    0x4(%eax),%eax
    b38a:	83 f8 08             	cmp    $0x8,%eax
    b38d:	75 46                	jne    b3d5 <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b38f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b396:	eb 30                	jmp    b3c8 <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b398:	8b 45 08             	mov    0x8(%ebp),%eax
    b39b:	83 c0 01             	add    $0x1,%eax
    b39e:	8b 55 08             	mov    0x8(%ebp),%edx
    b3a1:	83 c2 02             	add    $0x2,%edx
    b3a4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b3a7:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b3aa:	01 d9                	add    %ebx,%ecx
    b3ac:	0f b6 09             	movzbl (%ecx),%ecx
    b3af:	88 0a                	mov    %cl,(%edx)
    b3b1:	0f b6 12             	movzbl (%edx),%edx
    b3b4:	88 10                	mov    %dl,(%eax)
    b3b6:	0f b6 10             	movzbl (%eax),%edx
    b3b9:	8b 45 08             	mov    0x8(%ebp),%eax
    b3bc:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3be:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b3c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3c5:	01 45 08             	add    %eax,0x8(%ebp)
    b3c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b3cb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b3ce:	75 c8                	jne    b398 <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b3d0:	e9 a8 03 00 00       	jmp    b77d <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    b3d5:	8b 45 14             	mov    0x14(%ebp),%eax
    b3d8:	8b 40 04             	mov    0x4(%eax),%eax
    b3db:	83 f8 10             	cmp    $0x10,%eax
    b3de:	75 4a                	jne    b42a <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3e0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b3e7:	eb 34                	jmp    b41d <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b3e9:	8b 45 08             	mov    0x8(%ebp),%eax
    b3ec:	83 c0 01             	add    $0x1,%eax
    b3ef:	8b 55 08             	mov    0x8(%ebp),%edx
    b3f2:	83 c2 02             	add    $0x2,%edx
    b3f5:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b3f8:	01 c9                	add    %ecx,%ecx
    b3fa:	89 cb                	mov    %ecx,%ebx
    b3fc:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b3ff:	01 d9                	add    %ebx,%ecx
    b401:	0f b6 09             	movzbl (%ecx),%ecx
    b404:	88 0a                	mov    %cl,(%edx)
    b406:	0f b6 12             	movzbl (%edx),%edx
    b409:	88 10                	mov    %dl,(%eax)
    b40b:	0f b6 10             	movzbl (%eax),%edx
    b40e:	8b 45 08             	mov    0x8(%ebp),%eax
    b411:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b413:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b417:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b41a:	01 45 08             	add    %eax,0x8(%ebp)
    b41d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b420:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b423:	75 c4                	jne    b3e9 <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b425:	e9 53 03 00 00       	jmp    b77d <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b42a:	8b 45 14             	mov    0x14(%ebp),%eax
    b42d:	8b 40 04             	mov    0x4(%eax),%eax
    b430:	ba 01 00 00 00       	mov    $0x1,%edx
    b435:	89 c1                	mov    %eax,%ecx
    b437:	d3 e2                	shl    %cl,%edx
    b439:	89 d0                	mov    %edx,%eax
    b43b:	83 e8 01             	sub    $0x1,%eax
    b43e:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b441:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b448:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b44f:	eb 50                	jmp    b4a1 <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b451:	8b 45 14             	mov    0x14(%ebp),%eax
    b454:	8b 40 04             	mov    0x4(%eax),%eax
    b457:	50                   	push   %eax
    b458:	ff 75 10             	pushl  0x10(%ebp)
    b45b:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b45e:	50                   	push   %eax
    b45f:	e8 ad ce ff ff       	call   8311 <readBitsFromReversedStream>
    b464:	83 c4 0c             	add    $0xc,%esp
    b467:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b46a:	8b 45 08             	mov    0x8(%ebp),%eax
    b46d:	8d 48 01             	lea    0x1(%eax),%ecx
    b470:	8b 45 08             	mov    0x8(%ebp),%eax
    b473:	8d 58 02             	lea    0x2(%eax),%ebx
    b476:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b479:	89 d0                	mov    %edx,%eax
    b47b:	c1 e0 08             	shl    $0x8,%eax
    b47e:	29 d0                	sub    %edx,%eax
    b480:	ba 00 00 00 00       	mov    $0x0,%edx
    b485:	f7 75 f0             	divl   -0x10(%ebp)
    b488:	88 03                	mov    %al,(%ebx)
    b48a:	0f b6 03             	movzbl (%ebx),%eax
    b48d:	88 01                	mov    %al,(%ecx)
    b48f:	0f b6 11             	movzbl (%ecx),%edx
    b492:	8b 45 08             	mov    0x8(%ebp),%eax
    b495:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b497:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b49b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b49e:	01 45 08             	add    %eax,0x8(%ebp)
    b4a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4a4:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b4a7:	75 a8                	jne    b451 <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b4a9:	e9 cf 02 00 00       	jmp    b77d <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b4ae:	8b 45 14             	mov    0x14(%ebp),%eax
    b4b1:	8b 00                	mov    (%eax),%eax
    b4b3:	83 f8 02             	cmp    $0x2,%eax
    b4b6:	0f 85 9e 00 00 00    	jne    b55a <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    b4bc:	8b 45 14             	mov    0x14(%ebp),%eax
    b4bf:	8b 40 04             	mov    0x4(%eax),%eax
    b4c2:	83 f8 08             	cmp    $0x8,%eax
    b4c5:	75 1d                	jne    b4e4 <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    b4c7:	8b 55 0c             	mov    0xc(%ebp),%edx
    b4ca:	89 d0                	mov    %edx,%eax
    b4cc:	01 c0                	add    %eax,%eax
    b4ce:	01 d0                	add    %edx,%eax
    b4d0:	50                   	push   %eax
    b4d1:	ff 75 10             	pushl  0x10(%ebp)
    b4d4:	ff 75 08             	pushl  0x8(%ebp)
    b4d7:	e8 d0 7f ff ff       	call   34ac <lodepng_memcpy>
    b4dc:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b4df:	e9 99 02 00 00       	jmp    b77d <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4e4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b4eb:	eb 60                	jmp    b54d <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    b4ed:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b4f0:	89 d0                	mov    %edx,%eax
    b4f2:	01 c0                	add    %eax,%eax
    b4f4:	01 d0                	add    %edx,%eax
    b4f6:	01 c0                	add    %eax,%eax
    b4f8:	89 c2                	mov    %eax,%edx
    b4fa:	8b 45 10             	mov    0x10(%ebp),%eax
    b4fd:	01 d0                	add    %edx,%eax
    b4ff:	0f b6 10             	movzbl (%eax),%edx
    b502:	8b 45 08             	mov    0x8(%ebp),%eax
    b505:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b507:	8b 45 08             	mov    0x8(%ebp),%eax
    b50a:	8d 48 01             	lea    0x1(%eax),%ecx
    b50d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b510:	89 d0                	mov    %edx,%eax
    b512:	01 c0                	add    %eax,%eax
    b514:	01 d0                	add    %edx,%eax
    b516:	01 c0                	add    %eax,%eax
    b518:	8d 50 02             	lea    0x2(%eax),%edx
    b51b:	8b 45 10             	mov    0x10(%ebp),%eax
    b51e:	01 d0                	add    %edx,%eax
    b520:	0f b6 00             	movzbl (%eax),%eax
    b523:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b525:	8b 45 08             	mov    0x8(%ebp),%eax
    b528:	8d 48 02             	lea    0x2(%eax),%ecx
    b52b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b52e:	89 d0                	mov    %edx,%eax
    b530:	01 c0                	add    %eax,%eax
    b532:	01 d0                	add    %edx,%eax
    b534:	01 c0                	add    %eax,%eax
    b536:	8d 50 04             	lea    0x4(%eax),%edx
    b539:	8b 45 10             	mov    0x10(%ebp),%eax
    b53c:	01 d0                	add    %edx,%eax
    b53e:	0f b6 00             	movzbl (%eax),%eax
    b541:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b543:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b547:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b54a:	01 45 08             	add    %eax,0x8(%ebp)
    b54d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b550:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b553:	75 98                	jne    b4ed <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b555:	e9 23 02 00 00       	jmp    b77d <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b55a:	8b 45 14             	mov    0x14(%ebp),%eax
    b55d:	8b 00                	mov    (%eax),%eax
    b55f:	83 f8 03             	cmp    $0x3,%eax
    b562:	0f 85 b4 00 00 00    	jne    b61c <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    b568:	8b 45 14             	mov    0x14(%ebp),%eax
    b56b:	8b 40 04             	mov    0x4(%eax),%eax
    b56e:	83 f8 08             	cmp    $0x8,%eax
    b571:	75 4d                	jne    b5c0 <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b573:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b57a:	eb 37                	jmp    b5b3 <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    b57c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b57f:	8b 45 10             	mov    0x10(%ebp),%eax
    b582:	01 d0                	add    %edx,%eax
    b584:	0f b6 00             	movzbl (%eax),%eax
    b587:	0f b6 c0             	movzbl %al,%eax
    b58a:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b58d:	8b 45 14             	mov    0x14(%ebp),%eax
    b590:	8b 40 08             	mov    0x8(%eax),%eax
    b593:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b596:	c1 e2 02             	shl    $0x2,%edx
    b599:	01 d0                	add    %edx,%eax
    b59b:	6a 03                	push   $0x3
    b59d:	50                   	push   %eax
    b59e:	ff 75 08             	pushl  0x8(%ebp)
    b5a1:	e8 06 7f ff ff       	call   34ac <lodepng_memcpy>
    b5a6:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5a9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b5ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b5b0:	01 45 08             	add    %eax,0x8(%ebp)
    b5b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b5b6:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b5b9:	75 c1                	jne    b57c <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b5bb:	e9 bd 01 00 00       	jmp    b77d <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    b5c0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5c7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b5ce:	eb 3f                	jmp    b60f <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b5d0:	8b 45 14             	mov    0x14(%ebp),%eax
    b5d3:	8b 40 04             	mov    0x4(%eax),%eax
    b5d6:	50                   	push   %eax
    b5d7:	ff 75 10             	pushl  0x10(%ebp)
    b5da:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b5dd:	50                   	push   %eax
    b5de:	e8 2e cd ff ff       	call   8311 <readBitsFromReversedStream>
    b5e3:	83 c4 0c             	add    $0xc,%esp
    b5e6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b5e9:	8b 45 14             	mov    0x14(%ebp),%eax
    b5ec:	8b 40 08             	mov    0x8(%eax),%eax
    b5ef:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b5f2:	c1 e2 02             	shl    $0x2,%edx
    b5f5:	01 d0                	add    %edx,%eax
    b5f7:	6a 03                	push   $0x3
    b5f9:	50                   	push   %eax
    b5fa:	ff 75 08             	pushl  0x8(%ebp)
    b5fd:	e8 aa 7e ff ff       	call   34ac <lodepng_memcpy>
    b602:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b605:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b609:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b60c:	01 45 08             	add    %eax,0x8(%ebp)
    b60f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b612:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b615:	75 b9                	jne    b5d0 <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b617:	e9 61 01 00 00       	jmp    b77d <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b61c:	8b 45 14             	mov    0x14(%ebp),%eax
    b61f:	8b 00                	mov    (%eax),%eax
    b621:	83 f8 04             	cmp    $0x4,%eax
    b624:	0f 85 a0 00 00 00    	jne    b6ca <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    b62a:	8b 45 14             	mov    0x14(%ebp),%eax
    b62d:	8b 40 04             	mov    0x4(%eax),%eax
    b630:	83 f8 08             	cmp    $0x8,%eax
    b633:	75 4a                	jne    b67f <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b635:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b63c:	eb 34                	jmp    b672 <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b63e:	8b 45 08             	mov    0x8(%ebp),%eax
    b641:	83 c0 01             	add    $0x1,%eax
    b644:	8b 55 08             	mov    0x8(%ebp),%edx
    b647:	83 c2 02             	add    $0x2,%edx
    b64a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b64d:	01 c9                	add    %ecx,%ecx
    b64f:	89 cb                	mov    %ecx,%ebx
    b651:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b654:	01 d9                	add    %ebx,%ecx
    b656:	0f b6 09             	movzbl (%ecx),%ecx
    b659:	88 0a                	mov    %cl,(%edx)
    b65b:	0f b6 12             	movzbl (%edx),%edx
    b65e:	88 10                	mov    %dl,(%eax)
    b660:	0f b6 10             	movzbl (%eax),%edx
    b663:	8b 45 08             	mov    0x8(%ebp),%eax
    b666:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b668:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b66c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b66f:	01 45 08             	add    %eax,0x8(%ebp)
    b672:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b675:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b678:	75 c4                	jne    b63e <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b67a:	e9 fe 00 00 00       	jmp    b77d <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b67f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b686:	eb 35                	jmp    b6bd <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b688:	8b 45 08             	mov    0x8(%ebp),%eax
    b68b:	83 c0 01             	add    $0x1,%eax
    b68e:	8b 55 08             	mov    0x8(%ebp),%edx
    b691:	83 c2 02             	add    $0x2,%edx
    b694:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b697:	c1 e1 02             	shl    $0x2,%ecx
    b69a:	89 cb                	mov    %ecx,%ebx
    b69c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b69f:	01 d9                	add    %ebx,%ecx
    b6a1:	0f b6 09             	movzbl (%ecx),%ecx
    b6a4:	88 0a                	mov    %cl,(%edx)
    b6a6:	0f b6 12             	movzbl (%edx),%edx
    b6a9:	88 10                	mov    %dl,(%eax)
    b6ab:	0f b6 10             	movzbl (%eax),%edx
    b6ae:	8b 45 08             	mov    0x8(%ebp),%eax
    b6b1:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b6b3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b6b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b6ba:	01 45 08             	add    %eax,0x8(%ebp)
    b6bd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b6c0:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b6c3:	75 c3                	jne    b688 <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b6c5:	e9 b3 00 00 00       	jmp    b77d <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b6ca:	8b 45 14             	mov    0x14(%ebp),%eax
    b6cd:	8b 00                	mov    (%eax),%eax
    b6cf:	83 f8 06             	cmp    $0x6,%eax
    b6d2:	0f 85 a5 00 00 00    	jne    b77d <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    b6d8:	8b 45 14             	mov    0x14(%ebp),%eax
    b6db:	8b 40 04             	mov    0x4(%eax),%eax
    b6de:	83 f8 08             	cmp    $0x8,%eax
    b6e1:	75 38                	jne    b71b <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b6e3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b6ea:	eb 25                	jmp    b711 <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    b6ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b6ef:	c1 e0 02             	shl    $0x2,%eax
    b6f2:	89 c2                	mov    %eax,%edx
    b6f4:	8b 45 10             	mov    0x10(%ebp),%eax
    b6f7:	01 d0                	add    %edx,%eax
    b6f9:	6a 03                	push   $0x3
    b6fb:	50                   	push   %eax
    b6fc:	ff 75 08             	pushl  0x8(%ebp)
    b6ff:	e8 a8 7d ff ff       	call   34ac <lodepng_memcpy>
    b704:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b707:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b70b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b70e:	01 45 08             	add    %eax,0x8(%ebp)
    b711:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b714:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b717:	75 d3                	jne    b6ec <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b719:	eb 62                	jmp    b77d <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b71b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b722:	eb 51                	jmp    b775 <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    b724:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b727:	c1 e0 03             	shl    $0x3,%eax
    b72a:	89 c2                	mov    %eax,%edx
    b72c:	8b 45 10             	mov    0x10(%ebp),%eax
    b72f:	01 d0                	add    %edx,%eax
    b731:	0f b6 10             	movzbl (%eax),%edx
    b734:	8b 45 08             	mov    0x8(%ebp),%eax
    b737:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b739:	8b 45 08             	mov    0x8(%ebp),%eax
    b73c:	8d 50 01             	lea    0x1(%eax),%edx
    b73f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b742:	c1 e0 03             	shl    $0x3,%eax
    b745:	8d 48 02             	lea    0x2(%eax),%ecx
    b748:	8b 45 10             	mov    0x10(%ebp),%eax
    b74b:	01 c8                	add    %ecx,%eax
    b74d:	0f b6 00             	movzbl (%eax),%eax
    b750:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b752:	8b 45 08             	mov    0x8(%ebp),%eax
    b755:	8d 50 02             	lea    0x2(%eax),%edx
    b758:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b75b:	c1 e0 03             	shl    $0x3,%eax
    b75e:	8d 48 04             	lea    0x4(%eax),%ecx
    b761:	8b 45 10             	mov    0x10(%ebp),%eax
    b764:	01 c8                	add    %ecx,%eax
    b766:	0f b6 00             	movzbl (%eax),%eax
    b769:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b76b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b76f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b772:	01 45 08             	add    %eax,0x8(%ebp)
    b775:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b778:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b77b:	75 a7                	jne    b724 <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b77d:	90                   	nop
    b77e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b781:	c9                   	leave  
    b782:	c3                   	ret    

0000b783 <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    b783:	55                   	push   %ebp
    b784:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    b786:	8b 45 20             	mov    0x20(%ebp),%eax
    b789:	8b 00                	mov    (%eax),%eax
    b78b:	85 c0                	test   %eax,%eax
    b78d:	0f 85 a4 00 00 00    	jne    b837 <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    b793:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b796:	01 c0                	add    %eax,%eax
    b798:	89 c2                	mov    %eax,%edx
    b79a:	8b 45 18             	mov    0x18(%ebp),%eax
    b79d:	01 d0                	add    %edx,%eax
    b79f:	0f b6 00             	movzbl (%eax),%eax
    b7a2:	0f b6 c0             	movzbl %al,%eax
    b7a5:	c1 e0 08             	shl    $0x8,%eax
    b7a8:	89 c2                	mov    %eax,%edx
    b7aa:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b7ad:	01 c0                	add    %eax,%eax
    b7af:	8d 48 01             	lea    0x1(%eax),%ecx
    b7b2:	8b 45 18             	mov    0x18(%ebp),%eax
    b7b5:	01 c8                	add    %ecx,%eax
    b7b7:	0f b6 00             	movzbl (%eax),%eax
    b7ba:	0f b6 c0             	movzbl %al,%eax
    b7bd:	01 c2                	add    %eax,%edx
    b7bf:	8b 45 10             	mov    0x10(%ebp),%eax
    b7c2:	66 89 10             	mov    %dx,(%eax)
    b7c5:	8b 45 10             	mov    0x10(%ebp),%eax
    b7c8:	0f b7 10             	movzwl (%eax),%edx
    b7cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    b7ce:	66 89 10             	mov    %dx,(%eax)
    b7d1:	8b 45 0c             	mov    0xc(%ebp),%eax
    b7d4:	0f b7 10             	movzwl (%eax),%edx
    b7d7:	8b 45 08             	mov    0x8(%ebp),%eax
    b7da:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    b7dd:	8b 45 20             	mov    0x20(%ebp),%eax
    b7e0:	8b 40 10             	mov    0x10(%eax),%eax
    b7e3:	85 c0                	test   %eax,%eax
    b7e5:	74 43                	je     b82a <getPixelColorRGBA16+0xa7>
    b7e7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b7ea:	01 c0                	add    %eax,%eax
    b7ec:	89 c2                	mov    %eax,%edx
    b7ee:	8b 45 18             	mov    0x18(%ebp),%eax
    b7f1:	01 d0                	add    %edx,%eax
    b7f3:	0f b6 00             	movzbl (%eax),%eax
    b7f6:	0f b6 c0             	movzbl %al,%eax
    b7f9:	c1 e0 08             	shl    $0x8,%eax
    b7fc:	89 c2                	mov    %eax,%edx
    b7fe:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b801:	01 c0                	add    %eax,%eax
    b803:	8d 48 01             	lea    0x1(%eax),%ecx
    b806:	8b 45 18             	mov    0x18(%ebp),%eax
    b809:	01 c8                	add    %ecx,%eax
    b80b:	0f b6 00             	movzbl (%eax),%eax
    b80e:	0f b6 c0             	movzbl %al,%eax
    b811:	01 c2                	add    %eax,%edx
    b813:	8b 45 20             	mov    0x20(%ebp),%eax
    b816:	8b 40 14             	mov    0x14(%eax),%eax
    b819:	39 c2                	cmp    %eax,%edx
    b81b:	75 0d                	jne    b82a <getPixelColorRGBA16+0xa7>
    b81d:	8b 45 14             	mov    0x14(%ebp),%eax
    b820:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b825:	e9 48 03 00 00       	jmp    bb72 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b82a:	8b 45 14             	mov    0x14(%ebp),%eax
    b82d:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b832:	e9 3b 03 00 00       	jmp    bb72 <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    b837:	8b 45 20             	mov    0x20(%ebp),%eax
    b83a:	8b 00                	mov    (%eax),%eax
    b83c:	83 f8 02             	cmp    $0x2,%eax
    b83f:	0f 85 b6 01 00 00    	jne    b9fb <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    b845:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b848:	89 d0                	mov    %edx,%eax
    b84a:	01 c0                	add    %eax,%eax
    b84c:	01 d0                	add    %edx,%eax
    b84e:	01 c0                	add    %eax,%eax
    b850:	89 c2                	mov    %eax,%edx
    b852:	8b 45 18             	mov    0x18(%ebp),%eax
    b855:	01 d0                	add    %edx,%eax
    b857:	0f b6 00             	movzbl (%eax),%eax
    b85a:	0f b6 c0             	movzbl %al,%eax
    b85d:	c1 e0 08             	shl    $0x8,%eax
    b860:	89 c1                	mov    %eax,%ecx
    b862:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b865:	89 d0                	mov    %edx,%eax
    b867:	01 c0                	add    %eax,%eax
    b869:	01 d0                	add    %edx,%eax
    b86b:	01 c0                	add    %eax,%eax
    b86d:	8d 50 01             	lea    0x1(%eax),%edx
    b870:	8b 45 18             	mov    0x18(%ebp),%eax
    b873:	01 d0                	add    %edx,%eax
    b875:	0f b6 00             	movzbl (%eax),%eax
    b878:	0f b6 c0             	movzbl %al,%eax
    b87b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b87e:	8b 45 08             	mov    0x8(%ebp),%eax
    b881:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    b884:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b887:	89 d0                	mov    %edx,%eax
    b889:	01 c0                	add    %eax,%eax
    b88b:	01 d0                	add    %edx,%eax
    b88d:	01 c0                	add    %eax,%eax
    b88f:	8d 50 02             	lea    0x2(%eax),%edx
    b892:	8b 45 18             	mov    0x18(%ebp),%eax
    b895:	01 d0                	add    %edx,%eax
    b897:	0f b6 00             	movzbl (%eax),%eax
    b89a:	0f b6 c0             	movzbl %al,%eax
    b89d:	c1 e0 08             	shl    $0x8,%eax
    b8a0:	89 c1                	mov    %eax,%ecx
    b8a2:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b8a5:	89 d0                	mov    %edx,%eax
    b8a7:	01 c0                	add    %eax,%eax
    b8a9:	01 d0                	add    %edx,%eax
    b8ab:	01 c0                	add    %eax,%eax
    b8ad:	8d 50 03             	lea    0x3(%eax),%edx
    b8b0:	8b 45 18             	mov    0x18(%ebp),%eax
    b8b3:	01 d0                	add    %edx,%eax
    b8b5:	0f b6 00             	movzbl (%eax),%eax
    b8b8:	0f b6 c0             	movzbl %al,%eax
    b8bb:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b8be:	8b 45 0c             	mov    0xc(%ebp),%eax
    b8c1:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    b8c4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b8c7:	89 d0                	mov    %edx,%eax
    b8c9:	01 c0                	add    %eax,%eax
    b8cb:	01 d0                	add    %edx,%eax
    b8cd:	01 c0                	add    %eax,%eax
    b8cf:	8d 50 04             	lea    0x4(%eax),%edx
    b8d2:	8b 45 18             	mov    0x18(%ebp),%eax
    b8d5:	01 d0                	add    %edx,%eax
    b8d7:	0f b6 00             	movzbl (%eax),%eax
    b8da:	0f b6 c0             	movzbl %al,%eax
    b8dd:	c1 e0 08             	shl    $0x8,%eax
    b8e0:	89 c1                	mov    %eax,%ecx
    b8e2:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b8e5:	89 d0                	mov    %edx,%eax
    b8e7:	01 c0                	add    %eax,%eax
    b8e9:	01 d0                	add    %edx,%eax
    b8eb:	01 c0                	add    %eax,%eax
    b8ed:	8d 50 05             	lea    0x5(%eax),%edx
    b8f0:	8b 45 18             	mov    0x18(%ebp),%eax
    b8f3:	01 d0                	add    %edx,%eax
    b8f5:	0f b6 00             	movzbl (%eax),%eax
    b8f8:	0f b6 c0             	movzbl %al,%eax
    b8fb:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b8fe:	8b 45 10             	mov    0x10(%ebp),%eax
    b901:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    b904:	8b 45 20             	mov    0x20(%ebp),%eax
    b907:	8b 40 10             	mov    0x10(%eax),%eax
    b90a:	85 c0                	test   %eax,%eax
    b90c:	0f 84 dc 00 00 00    	je     b9ee <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b912:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b915:	89 d0                	mov    %edx,%eax
    b917:	01 c0                	add    %eax,%eax
    b919:	01 d0                	add    %edx,%eax
    b91b:	01 c0                	add    %eax,%eax
    b91d:	89 c2                	mov    %eax,%edx
    b91f:	8b 45 18             	mov    0x18(%ebp),%eax
    b922:	01 d0                	add    %edx,%eax
    b924:	0f b6 00             	movzbl (%eax),%eax
    b927:	0f b6 c0             	movzbl %al,%eax
    b92a:	c1 e0 08             	shl    $0x8,%eax
    b92d:	89 c1                	mov    %eax,%ecx
    b92f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b932:	89 d0                	mov    %edx,%eax
    b934:	01 c0                	add    %eax,%eax
    b936:	01 d0                	add    %edx,%eax
    b938:	01 c0                	add    %eax,%eax
    b93a:	8d 50 01             	lea    0x1(%eax),%edx
    b93d:	8b 45 18             	mov    0x18(%ebp),%eax
    b940:	01 d0                	add    %edx,%eax
    b942:	0f b6 00             	movzbl (%eax),%eax
    b945:	0f b6 c0             	movzbl %al,%eax
    b948:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b94b:	8b 45 20             	mov    0x20(%ebp),%eax
    b94e:	8b 40 14             	mov    0x14(%eax),%eax
    b951:	39 c2                	cmp    %eax,%edx
    b953:	0f 85 95 00 00 00    	jne    b9ee <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b959:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b95c:	89 d0                	mov    %edx,%eax
    b95e:	01 c0                	add    %eax,%eax
    b960:	01 d0                	add    %edx,%eax
    b962:	01 c0                	add    %eax,%eax
    b964:	8d 50 02             	lea    0x2(%eax),%edx
    b967:	8b 45 18             	mov    0x18(%ebp),%eax
    b96a:	01 d0                	add    %edx,%eax
    b96c:	0f b6 00             	movzbl (%eax),%eax
    b96f:	0f b6 c0             	movzbl %al,%eax
    b972:	c1 e0 08             	shl    $0x8,%eax
    b975:	89 c1                	mov    %eax,%ecx
    b977:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b97a:	89 d0                	mov    %edx,%eax
    b97c:	01 c0                	add    %eax,%eax
    b97e:	01 d0                	add    %edx,%eax
    b980:	01 c0                	add    %eax,%eax
    b982:	8d 50 03             	lea    0x3(%eax),%edx
    b985:	8b 45 18             	mov    0x18(%ebp),%eax
    b988:	01 d0                	add    %edx,%eax
    b98a:	0f b6 00             	movzbl (%eax),%eax
    b98d:	0f b6 c0             	movzbl %al,%eax
    b990:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b993:	8b 45 20             	mov    0x20(%ebp),%eax
    b996:	8b 40 18             	mov    0x18(%eax),%eax
    b999:	39 c2                	cmp    %eax,%edx
    b99b:	75 51                	jne    b9ee <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    b99d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b9a0:	89 d0                	mov    %edx,%eax
    b9a2:	01 c0                	add    %eax,%eax
    b9a4:	01 d0                	add    %edx,%eax
    b9a6:	01 c0                	add    %eax,%eax
    b9a8:	8d 50 04             	lea    0x4(%eax),%edx
    b9ab:	8b 45 18             	mov    0x18(%ebp),%eax
    b9ae:	01 d0                	add    %edx,%eax
    b9b0:	0f b6 00             	movzbl (%eax),%eax
    b9b3:	0f b6 c0             	movzbl %al,%eax
    b9b6:	c1 e0 08             	shl    $0x8,%eax
    b9b9:	89 c1                	mov    %eax,%ecx
    b9bb:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b9be:	89 d0                	mov    %edx,%eax
    b9c0:	01 c0                	add    %eax,%eax
    b9c2:	01 d0                	add    %edx,%eax
    b9c4:	01 c0                	add    %eax,%eax
    b9c6:	8d 50 05             	lea    0x5(%eax),%edx
    b9c9:	8b 45 18             	mov    0x18(%ebp),%eax
    b9cc:	01 d0                	add    %edx,%eax
    b9ce:	0f b6 00             	movzbl (%eax),%eax
    b9d1:	0f b6 c0             	movzbl %al,%eax
    b9d4:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b9d7:	8b 45 20             	mov    0x20(%ebp),%eax
    b9da:	8b 40 1c             	mov    0x1c(%eax),%eax
    b9dd:	39 c2                	cmp    %eax,%edx
    b9df:	75 0d                	jne    b9ee <getPixelColorRGBA16+0x26b>
    b9e1:	8b 45 14             	mov    0x14(%ebp),%eax
    b9e4:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b9e9:	e9 84 01 00 00       	jmp    bb72 <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b9ee:	8b 45 14             	mov    0x14(%ebp),%eax
    b9f1:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b9f6:	e9 77 01 00 00       	jmp    bb72 <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b9fb:	8b 45 20             	mov    0x20(%ebp),%eax
    b9fe:	8b 00                	mov    (%eax),%eax
    ba00:	83 f8 04             	cmp    $0x4,%eax
    ba03:	0f 85 86 00 00 00    	jne    ba8f <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    ba09:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba0c:	c1 e0 02             	shl    $0x2,%eax
    ba0f:	89 c2                	mov    %eax,%edx
    ba11:	8b 45 18             	mov    0x18(%ebp),%eax
    ba14:	01 d0                	add    %edx,%eax
    ba16:	0f b6 00             	movzbl (%eax),%eax
    ba19:	0f b6 c0             	movzbl %al,%eax
    ba1c:	c1 e0 08             	shl    $0x8,%eax
    ba1f:	89 c2                	mov    %eax,%edx
    ba21:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba24:	c1 e0 02             	shl    $0x2,%eax
    ba27:	8d 48 01             	lea    0x1(%eax),%ecx
    ba2a:	8b 45 18             	mov    0x18(%ebp),%eax
    ba2d:	01 c8                	add    %ecx,%eax
    ba2f:	0f b6 00             	movzbl (%eax),%eax
    ba32:	0f b6 c0             	movzbl %al,%eax
    ba35:	01 c2                	add    %eax,%edx
    ba37:	8b 45 10             	mov    0x10(%ebp),%eax
    ba3a:	66 89 10             	mov    %dx,(%eax)
    ba3d:	8b 45 10             	mov    0x10(%ebp),%eax
    ba40:	0f b7 10             	movzwl (%eax),%edx
    ba43:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba46:	66 89 10             	mov    %dx,(%eax)
    ba49:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba4c:	0f b7 10             	movzwl (%eax),%edx
    ba4f:	8b 45 08             	mov    0x8(%ebp),%eax
    ba52:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    ba55:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba58:	c1 e0 02             	shl    $0x2,%eax
    ba5b:	8d 50 02             	lea    0x2(%eax),%edx
    ba5e:	8b 45 18             	mov    0x18(%ebp),%eax
    ba61:	01 d0                	add    %edx,%eax
    ba63:	0f b6 00             	movzbl (%eax),%eax
    ba66:	0f b6 c0             	movzbl %al,%eax
    ba69:	c1 e0 08             	shl    $0x8,%eax
    ba6c:	89 c2                	mov    %eax,%edx
    ba6e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ba71:	c1 e0 02             	shl    $0x2,%eax
    ba74:	8d 48 03             	lea    0x3(%eax),%ecx
    ba77:	8b 45 18             	mov    0x18(%ebp),%eax
    ba7a:	01 c8                	add    %ecx,%eax
    ba7c:	0f b6 00             	movzbl (%eax),%eax
    ba7f:	0f b6 c0             	movzbl %al,%eax
    ba82:	01 c2                	add    %eax,%edx
    ba84:	8b 45 14             	mov    0x14(%ebp),%eax
    ba87:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    ba8a:	e9 e3 00 00 00       	jmp    bb72 <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    ba8f:	8b 45 20             	mov    0x20(%ebp),%eax
    ba92:	8b 00                	mov    (%eax),%eax
    ba94:	83 f8 06             	cmp    $0x6,%eax
    ba97:	0f 85 d5 00 00 00    	jne    bb72 <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    ba9d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    baa0:	c1 e0 03             	shl    $0x3,%eax
    baa3:	89 c2                	mov    %eax,%edx
    baa5:	8b 45 18             	mov    0x18(%ebp),%eax
    baa8:	01 d0                	add    %edx,%eax
    baaa:	0f b6 00             	movzbl (%eax),%eax
    baad:	0f b6 c0             	movzbl %al,%eax
    bab0:	c1 e0 08             	shl    $0x8,%eax
    bab3:	89 c2                	mov    %eax,%edx
    bab5:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bab8:	c1 e0 03             	shl    $0x3,%eax
    babb:	8d 48 01             	lea    0x1(%eax),%ecx
    babe:	8b 45 18             	mov    0x18(%ebp),%eax
    bac1:	01 c8                	add    %ecx,%eax
    bac3:	0f b6 00             	movzbl (%eax),%eax
    bac6:	0f b6 c0             	movzbl %al,%eax
    bac9:	01 c2                	add    %eax,%edx
    bacb:	8b 45 08             	mov    0x8(%ebp),%eax
    bace:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    bad1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bad4:	c1 e0 03             	shl    $0x3,%eax
    bad7:	8d 50 02             	lea    0x2(%eax),%edx
    bada:	8b 45 18             	mov    0x18(%ebp),%eax
    badd:	01 d0                	add    %edx,%eax
    badf:	0f b6 00             	movzbl (%eax),%eax
    bae2:	0f b6 c0             	movzbl %al,%eax
    bae5:	c1 e0 08             	shl    $0x8,%eax
    bae8:	89 c2                	mov    %eax,%edx
    baea:	8b 45 1c             	mov    0x1c(%ebp),%eax
    baed:	c1 e0 03             	shl    $0x3,%eax
    baf0:	8d 48 03             	lea    0x3(%eax),%ecx
    baf3:	8b 45 18             	mov    0x18(%ebp),%eax
    baf6:	01 c8                	add    %ecx,%eax
    baf8:	0f b6 00             	movzbl (%eax),%eax
    bafb:	0f b6 c0             	movzbl %al,%eax
    bafe:	01 c2                	add    %eax,%edx
    bb00:	8b 45 0c             	mov    0xc(%ebp),%eax
    bb03:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    bb06:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bb09:	c1 e0 03             	shl    $0x3,%eax
    bb0c:	8d 50 04             	lea    0x4(%eax),%edx
    bb0f:	8b 45 18             	mov    0x18(%ebp),%eax
    bb12:	01 d0                	add    %edx,%eax
    bb14:	0f b6 00             	movzbl (%eax),%eax
    bb17:	0f b6 c0             	movzbl %al,%eax
    bb1a:	c1 e0 08             	shl    $0x8,%eax
    bb1d:	89 c2                	mov    %eax,%edx
    bb1f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bb22:	c1 e0 03             	shl    $0x3,%eax
    bb25:	8d 48 05             	lea    0x5(%eax),%ecx
    bb28:	8b 45 18             	mov    0x18(%ebp),%eax
    bb2b:	01 c8                	add    %ecx,%eax
    bb2d:	0f b6 00             	movzbl (%eax),%eax
    bb30:	0f b6 c0             	movzbl %al,%eax
    bb33:	01 c2                	add    %eax,%edx
    bb35:	8b 45 10             	mov    0x10(%ebp),%eax
    bb38:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    bb3b:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bb3e:	c1 e0 03             	shl    $0x3,%eax
    bb41:	8d 50 06             	lea    0x6(%eax),%edx
    bb44:	8b 45 18             	mov    0x18(%ebp),%eax
    bb47:	01 d0                	add    %edx,%eax
    bb49:	0f b6 00             	movzbl (%eax),%eax
    bb4c:	0f b6 c0             	movzbl %al,%eax
    bb4f:	c1 e0 08             	shl    $0x8,%eax
    bb52:	89 c2                	mov    %eax,%edx
    bb54:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bb57:	c1 e0 03             	shl    $0x3,%eax
    bb5a:	8d 48 07             	lea    0x7(%eax),%ecx
    bb5d:	8b 45 18             	mov    0x18(%ebp),%eax
    bb60:	01 c8                	add    %ecx,%eax
    bb62:	0f b6 00             	movzbl (%eax),%eax
    bb65:	0f b6 c0             	movzbl %al,%eax
    bb68:	01 c2                	add    %eax,%edx
    bb6a:	8b 45 14             	mov    0x14(%ebp),%eax
    bb6d:	66 89 10             	mov    %dx,(%eax)
  }
}
    bb70:	eb 00                	jmp    bb72 <getPixelColorRGBA16+0x3ef>
    bb72:	90                   	nop
    bb73:	5d                   	pop    %ebp
    bb74:	c3                   	ret    

0000bb75 <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    bb75:	55                   	push   %ebp
    bb76:	89 e5                	mov    %esp,%ebp
    bb78:	56                   	push   %esi
    bb79:	53                   	push   %ebx
    bb7a:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    bb7d:	8b 55 18             	mov    0x18(%ebp),%edx
    bb80:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bb83:	0f af c2             	imul   %edx,%eax
    bb86:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    bb89:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    bb90:	8b 45 14             	mov    0x14(%ebp),%eax
    bb93:	8b 00                	mov    (%eax),%eax
    bb95:	83 f8 03             	cmp    $0x3,%eax
    bb98:	75 14                	jne    bbae <lodepng_convert+0x39>
    bb9a:	8b 45 14             	mov    0x14(%ebp),%eax
    bb9d:	8b 40 08             	mov    0x8(%eax),%eax
    bba0:	85 c0                	test   %eax,%eax
    bba2:	75 0a                	jne    bbae <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    bba4:	b8 6b 00 00 00       	mov    $0x6b,%eax
    bba9:	e9 19 03 00 00       	jmp    bec7 <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    bbae:	ff 75 14             	pushl  0x14(%ebp)
    bbb1:	ff 75 10             	pushl  0x10(%ebp)
    bbb4:	e8 b7 d1 ff ff       	call   8d70 <lodepng_color_mode_equal>
    bbb9:	83 c4 08             	add    $0x8,%esp
    bbbc:	85 c0                	test   %eax,%eax
    bbbe:	74 2f                	je     bbef <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bbc0:	ff 75 14             	pushl  0x14(%ebp)
    bbc3:	ff 75 1c             	pushl  0x1c(%ebp)
    bbc6:	ff 75 18             	pushl  0x18(%ebp)
    bbc9:	e8 fb d4 ff ff       	call   90c9 <lodepng_get_raw_size>
    bbce:	83 c4 0c             	add    $0xc,%esp
    bbd1:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    bbd4:	ff 75 dc             	pushl  -0x24(%ebp)
    bbd7:	ff 75 0c             	pushl  0xc(%ebp)
    bbda:	ff 75 08             	pushl  0x8(%ebp)
    bbdd:	e8 ca 78 ff ff       	call   34ac <lodepng_memcpy>
    bbe2:	83 c4 0c             	add    $0xc,%esp
    return 0;
    bbe5:	b8 00 00 00 00       	mov    $0x0,%eax
    bbea:	e9 d8 02 00 00       	jmp    bec7 <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    bbef:	8b 45 10             	mov    0x10(%ebp),%eax
    bbf2:	8b 00                	mov    (%eax),%eax
    bbf4:	83 f8 03             	cmp    $0x3,%eax
    bbf7:	0f 85 16 01 00 00    	jne    bd13 <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    bbfd:	8b 45 10             	mov    0x10(%ebp),%eax
    bc00:	8b 40 0c             	mov    0xc(%eax),%eax
    bc03:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    bc06:	8b 45 10             	mov    0x10(%ebp),%eax
    bc09:	8b 40 08             	mov    0x8(%eax),%eax
    bc0c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    bc0f:	8b 45 10             	mov    0x10(%ebp),%eax
    bc12:	8b 40 04             	mov    0x4(%eax),%eax
    bc15:	ba 01 00 00 00       	mov    $0x1,%edx
    bc1a:	89 c1                	mov    %eax,%ecx
    bc1c:	d3 e2                	shl    %cl,%edx
    bc1e:	89 d0                	mov    %edx,%eax
    bc20:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    bc23:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    bc27:	75 5b                	jne    bc84 <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    bc29:	8b 45 14             	mov    0x14(%ebp),%eax
    bc2c:	8b 40 0c             	mov    0xc(%eax),%eax
    bc2f:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    bc32:	8b 45 14             	mov    0x14(%ebp),%eax
    bc35:	8b 40 08             	mov    0x8(%eax),%eax
    bc38:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    bc3b:	8b 45 14             	mov    0x14(%ebp),%eax
    bc3e:	8b 00                	mov    (%eax),%eax
    bc40:	83 f8 03             	cmp    $0x3,%eax
    bc43:	75 3f                	jne    bc84 <lodepng_convert+0x10f>
    bc45:	8b 45 14             	mov    0x14(%ebp),%eax
    bc48:	8b 50 04             	mov    0x4(%eax),%edx
    bc4b:	8b 45 10             	mov    0x10(%ebp),%eax
    bc4e:	8b 40 04             	mov    0x4(%eax),%eax
    bc51:	39 c2                	cmp    %eax,%edx
    bc53:	75 2f                	jne    bc84 <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bc55:	ff 75 14             	pushl  0x14(%ebp)
    bc58:	ff 75 1c             	pushl  0x1c(%ebp)
    bc5b:	ff 75 18             	pushl  0x18(%ebp)
    bc5e:	e8 66 d4 ff ff       	call   90c9 <lodepng_get_raw_size>
    bc63:	83 c4 0c             	add    $0xc,%esp
    bc66:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    bc69:	ff 75 d8             	pushl  -0x28(%ebp)
    bc6c:	ff 75 0c             	pushl  0xc(%ebp)
    bc6f:	ff 75 08             	pushl  0x8(%ebp)
    bc72:	e8 35 78 ff ff       	call   34ac <lodepng_memcpy>
    bc77:	83 c4 0c             	add    $0xc,%esp
        return 0;
    bc7a:	b8 00 00 00 00       	mov    $0x0,%eax
    bc7f:	e9 43 02 00 00       	jmp    bec7 <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    bc84:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bc87:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bc8a:	7d 06                	jge    bc92 <lodepng_convert+0x11d>
    bc8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    bc8f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    bc92:	8d 45 90             	lea    -0x70(%ebp),%eax
    bc95:	50                   	push   %eax
    bc96:	e8 5f e1 ff ff       	call   9dfa <color_tree_init>
    bc9b:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    bc9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bca5:	eb 61                	jmp    bd08 <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    bca7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bcaa:	c1 e0 02             	shl    $0x2,%eax
    bcad:	89 c2                	mov    %eax,%edx
    bcaf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    bcb2:	01 d0                	add    %edx,%eax
    bcb4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    bcb7:	8b 75 f4             	mov    -0xc(%ebp),%esi
    bcba:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bcbd:	83 c0 03             	add    $0x3,%eax
    bcc0:	0f b6 00             	movzbl (%eax),%eax
    bcc3:	0f b6 d8             	movzbl %al,%ebx
    bcc6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bcc9:	83 c0 02             	add    $0x2,%eax
    bccc:	0f b6 00             	movzbl (%eax),%eax
    bccf:	0f b6 c8             	movzbl %al,%ecx
    bcd2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bcd5:	83 c0 01             	add    $0x1,%eax
    bcd8:	0f b6 00             	movzbl (%eax),%eax
    bcdb:	0f b6 d0             	movzbl %al,%edx
    bcde:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    bce1:	0f b6 00             	movzbl (%eax),%eax
    bce4:	0f b6 c0             	movzbl %al,%eax
    bce7:	83 ec 08             	sub    $0x8,%esp
    bcea:	56                   	push   %esi
    bceb:	53                   	push   %ebx
    bcec:	51                   	push   %ecx
    bced:	52                   	push   %edx
    bcee:	50                   	push   %eax
    bcef:	8d 45 90             	lea    -0x70(%ebp),%eax
    bcf2:	50                   	push   %eax
    bcf3:	e8 85 e2 ff ff       	call   9f7d <color_tree_add>
    bcf8:	83 c4 20             	add    $0x20,%esp
    bcfb:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    bcfe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bd02:	75 0e                	jne    bd12 <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    bd04:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bd08:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bd0b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    bd0e:	75 97                	jne    bca7 <lodepng_convert+0x132>
    bd10:	eb 01                	jmp    bd13 <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    bd12:	90                   	nop
    }
  }

  if(!error) {
    bd13:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    bd17:	0f 85 8e 01 00 00    	jne    beab <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bd1d:	8b 45 14             	mov    0x14(%ebp),%eax
    bd20:	8b 40 04             	mov    0x4(%eax),%eax
    bd23:	83 f8 10             	cmp    $0x10,%eax
    bd26:	0f 85 99 00 00 00    	jne    bdc5 <lodepng_convert+0x250>
    bd2c:	8b 45 10             	mov    0x10(%ebp),%eax
    bd2f:	8b 40 04             	mov    0x4(%eax),%eax
    bd32:	83 f8 10             	cmp    $0x10,%eax
    bd35:	0f 85 8a 00 00 00    	jne    bdc5 <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    bd3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bd42:	eb 74                	jmp    bdb8 <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    bd44:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    bd4a:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    bd50:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    bd56:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    bd5c:	83 ec 04             	sub    $0x4,%esp
    bd5f:	ff 75 14             	pushl  0x14(%ebp)
    bd62:	ff 75 f4             	pushl  -0xc(%ebp)
    bd65:	ff 75 0c             	pushl  0xc(%ebp)
    bd68:	8d 45 88             	lea    -0x78(%ebp),%eax
    bd6b:	50                   	push   %eax
    bd6c:	8d 45 8a             	lea    -0x76(%ebp),%eax
    bd6f:	50                   	push   %eax
    bd70:	8d 45 8c             	lea    -0x74(%ebp),%eax
    bd73:	50                   	push   %eax
    bd74:	8d 45 8e             	lea    -0x72(%ebp),%eax
    bd77:	50                   	push   %eax
    bd78:	e8 06 fa ff ff       	call   b783 <getPixelColorRGBA16>
    bd7d:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    bd80:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    bd84:	0f b7 d8             	movzwl %ax,%ebx
    bd87:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    bd8b:	0f b7 c8             	movzwl %ax,%ecx
    bd8e:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    bd92:	0f b7 d0             	movzwl %ax,%edx
    bd95:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    bd99:	0f b7 c0             	movzwl %ax,%eax
    bd9c:	83 ec 04             	sub    $0x4,%esp
    bd9f:	53                   	push   %ebx
    bda0:	51                   	push   %ecx
    bda1:	52                   	push   %edx
    bda2:	50                   	push   %eax
    bda3:	ff 75 10             	pushl  0x10(%ebp)
    bda6:	ff 75 f4             	pushl  -0xc(%ebp)
    bda9:	ff 75 08             	pushl  0x8(%ebp)
    bdac:	e8 d3 e6 ff ff       	call   a484 <rgba16ToPixel>
    bdb1:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    bdb4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bdb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bdbb:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bdbe:	75 84                	jne    bd44 <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bdc0:	e9 e6 00 00 00       	jmp    beab <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    bdc5:	8b 45 10             	mov    0x10(%ebp),%eax
    bdc8:	8b 40 04             	mov    0x4(%eax),%eax
    bdcb:	83 f8 08             	cmp    $0x8,%eax
    bdce:	75 23                	jne    bdf3 <lodepng_convert+0x27e>
    bdd0:	8b 45 10             	mov    0x10(%ebp),%eax
    bdd3:	8b 00                	mov    (%eax),%eax
    bdd5:	83 f8 06             	cmp    $0x6,%eax
    bdd8:	75 19                	jne    bdf3 <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    bdda:	ff 75 14             	pushl  0x14(%ebp)
    bddd:	ff 75 0c             	pushl  0xc(%ebp)
    bde0:	ff 75 e0             	pushl  -0x20(%ebp)
    bde3:	ff 75 08             	pushl  0x8(%ebp)
    bde6:	e8 ae ee ff ff       	call   ac99 <getPixelColorsRGBA8>
    bdeb:	83 c4 10             	add    $0x10,%esp
    bdee:	e9 b8 00 00 00       	jmp    beab <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    bdf3:	8b 45 10             	mov    0x10(%ebp),%eax
    bdf6:	8b 40 04             	mov    0x4(%eax),%eax
    bdf9:	83 f8 08             	cmp    $0x8,%eax
    bdfc:	75 23                	jne    be21 <lodepng_convert+0x2ac>
    bdfe:	8b 45 10             	mov    0x10(%ebp),%eax
    be01:	8b 00                	mov    (%eax),%eax
    be03:	83 f8 02             	cmp    $0x2,%eax
    be06:	75 19                	jne    be21 <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    be08:	ff 75 14             	pushl  0x14(%ebp)
    be0b:	ff 75 0c             	pushl  0xc(%ebp)
    be0e:	ff 75 e0             	pushl  -0x20(%ebp)
    be11:	ff 75 08             	pushl  0x8(%ebp)
    be14:	e8 50 f5 ff ff       	call   b369 <getPixelColorsRGB8>
    be19:	83 c4 10             	add    $0x10,%esp
    be1c:	e9 8a 00 00 00       	jmp    beab <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    be21:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    be25:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    be29:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    be2d:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    be31:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    be38:	eb 66                	jmp    bea0 <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    be3a:	83 ec 04             	sub    $0x4,%esp
    be3d:	ff 75 14             	pushl  0x14(%ebp)
    be40:	ff 75 f4             	pushl  -0xc(%ebp)
    be43:	ff 75 0c             	pushl  0xc(%ebp)
    be46:	8d 45 84             	lea    -0x7c(%ebp),%eax
    be49:	50                   	push   %eax
    be4a:	8d 45 85             	lea    -0x7b(%ebp),%eax
    be4d:	50                   	push   %eax
    be4e:	8d 45 86             	lea    -0x7a(%ebp),%eax
    be51:	50                   	push   %eax
    be52:	8d 45 87             	lea    -0x79(%ebp),%eax
    be55:	50                   	push   %eax
    be56:	e8 71 e8 ff ff       	call   a6cc <getPixelColorRGBA8>
    be5b:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    be5e:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    be62:	0f b6 d8             	movzbl %al,%ebx
    be65:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    be69:	0f b6 c8             	movzbl %al,%ecx
    be6c:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    be70:	0f b6 d0             	movzbl %al,%edx
    be73:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    be77:	0f b6 c0             	movzbl %al,%eax
    be7a:	53                   	push   %ebx
    be7b:	51                   	push   %ecx
    be7c:	52                   	push   %edx
    be7d:	50                   	push   %eax
    be7e:	8d 45 90             	lea    -0x70(%ebp),%eax
    be81:	50                   	push   %eax
    be82:	ff 75 10             	pushl  0x10(%ebp)
    be85:	ff 75 f4             	pushl  -0xc(%ebp)
    be88:	ff 75 08             	pushl  0x8(%ebp)
    be8b:	e8 e5 e1 ff ff       	call   a075 <rgba8ToPixel>
    be90:	83 c4 20             	add    $0x20,%esp
    be93:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    be96:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    be9a:	75 0e                	jne    beaa <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    be9c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bea0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bea3:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bea6:	75 92                	jne    be3a <lodepng_convert+0x2c5>
    bea8:	eb 01                	jmp    beab <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    beaa:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    beab:	8b 45 10             	mov    0x10(%ebp),%eax
    beae:	8b 00                	mov    (%eax),%eax
    beb0:	83 f8 03             	cmp    $0x3,%eax
    beb3:	75 0f                	jne    bec4 <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    beb5:	83 ec 0c             	sub    $0xc,%esp
    beb8:	8d 45 90             	lea    -0x70(%ebp),%eax
    bebb:	50                   	push   %eax
    bebc:	e8 59 df ff ff       	call   9e1a <color_tree_cleanup>
    bec1:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    bec4:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    bec7:	8d 65 f8             	lea    -0x8(%ebp),%esp
    beca:	5b                   	pop    %ebx
    becb:	5e                   	pop    %esi
    becc:	5d                   	pop    %ebp
    becd:	c3                   	ret    

0000bece <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    bece:	55                   	push   %ebp
    becf:	89 e5                	mov    %esp,%ebp
    bed1:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    bed4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    bedb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    bee2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    bee9:	8b 45 24             	mov    0x24(%ebp),%eax
    beec:	8b 40 04             	mov    0x4(%eax),%eax
    beef:	ba 01 00 00 00       	mov    $0x1,%edx
    bef4:	89 c1                	mov    %eax,%ecx
    bef6:	d3 e2                	shl    %cl,%edx
    bef8:	89 d0                	mov    %edx,%eax
    befa:	8d 48 ff             	lea    -0x1(%eax),%ecx
    befd:	b8 ff ff 00 00       	mov    $0xffff,%eax
    bf02:	ba 00 00 00 00       	mov    $0x0,%edx
    bf07:	f7 f1                	div    %ecx
    bf09:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    bf0c:	8b 45 20             	mov    0x20(%ebp),%eax
    bf0f:	8b 40 04             	mov    0x4(%eax),%eax
    bf12:	ba 10 00 00 00       	mov    $0x10,%edx
    bf17:	29 c2                	sub    %eax,%edx
    bf19:	89 d0                	mov    %edx,%eax
    bf1b:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    bf1e:	8b 45 24             	mov    0x24(%ebp),%eax
    bf21:	8b 00                	mov    (%eax),%eax
    bf23:	85 c0                	test   %eax,%eax
    bf25:	74 0a                	je     bf31 <lodepng_convert_rgb+0x63>
    bf27:	8b 45 24             	mov    0x24(%ebp),%eax
    bf2a:	8b 00                	mov    (%eax),%eax
    bf2c:	83 f8 04             	cmp    $0x4,%eax
    bf2f:	75 1b                	jne    bf4c <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    bf31:	8b 45 14             	mov    0x14(%ebp),%eax
    bf34:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bf38:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bf3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf3e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    bf41:	8b 45 f8             	mov    -0x8(%ebp),%eax
    bf44:	89 45 fc             	mov    %eax,-0x4(%ebp)
    bf47:	e9 c2 00 00 00       	jmp    c00e <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    bf4c:	8b 45 24             	mov    0x24(%ebp),%eax
    bf4f:	8b 00                	mov    (%eax),%eax
    bf51:	83 f8 02             	cmp    $0x2,%eax
    bf54:	74 0a                	je     bf60 <lodepng_convert_rgb+0x92>
    bf56:	8b 45 24             	mov    0x24(%ebp),%eax
    bf59:	8b 00                	mov    (%eax),%eax
    bf5b:	83 f8 06             	cmp    $0x6,%eax
    bf5e:	75 23                	jne    bf83 <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    bf60:	8b 45 14             	mov    0x14(%ebp),%eax
    bf63:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bf67:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    bf6a:	8b 45 18             	mov    0x18(%ebp),%eax
    bf6d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bf71:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    bf74:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bf77:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    bf7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bf7e:	e9 8b 00 00 00       	jmp    c00e <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    bf83:	8b 45 24             	mov    0x24(%ebp),%eax
    bf86:	8b 00                	mov    (%eax),%eax
    bf88:	83 f8 03             	cmp    $0x3,%eax
    bf8b:	75 77                	jne    c004 <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    bf8d:	8b 45 24             	mov    0x24(%ebp),%eax
    bf90:	8b 40 0c             	mov    0xc(%eax),%eax
    bf93:	3b 45 14             	cmp    0x14(%ebp),%eax
    bf96:	77 0a                	ja     bfa2 <lodepng_convert_rgb+0xd4>
    bf98:	b8 52 00 00 00       	mov    $0x52,%eax
    bf9d:	e9 cb 01 00 00       	jmp    c16d <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    bfa2:	8b 45 24             	mov    0x24(%ebp),%eax
    bfa5:	8b 40 08             	mov    0x8(%eax),%eax
    bfa8:	8b 55 14             	mov    0x14(%ebp),%edx
    bfab:	c1 e2 02             	shl    $0x2,%edx
    bfae:	01 d0                	add    %edx,%eax
    bfb0:	0f b6 00             	movzbl (%eax),%eax
    bfb3:	0f b6 d0             	movzbl %al,%edx
    bfb6:	89 d0                	mov    %edx,%eax
    bfb8:	c1 e0 08             	shl    $0x8,%eax
    bfbb:	01 d0                	add    %edx,%eax
    bfbd:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    bfc0:	8b 45 24             	mov    0x24(%ebp),%eax
    bfc3:	8b 40 08             	mov    0x8(%eax),%eax
    bfc6:	8b 55 14             	mov    0x14(%ebp),%edx
    bfc9:	c1 e2 02             	shl    $0x2,%edx
    bfcc:	83 c2 01             	add    $0x1,%edx
    bfcf:	01 d0                	add    %edx,%eax
    bfd1:	0f b6 00             	movzbl (%eax),%eax
    bfd4:	0f b6 d0             	movzbl %al,%edx
    bfd7:	89 d0                	mov    %edx,%eax
    bfd9:	c1 e0 08             	shl    $0x8,%eax
    bfdc:	01 d0                	add    %edx,%eax
    bfde:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    bfe1:	8b 45 24             	mov    0x24(%ebp),%eax
    bfe4:	8b 40 08             	mov    0x8(%eax),%eax
    bfe7:	8b 55 14             	mov    0x14(%ebp),%edx
    bfea:	c1 e2 02             	shl    $0x2,%edx
    bfed:	83 c2 02             	add    $0x2,%edx
    bff0:	01 d0                	add    %edx,%eax
    bff2:	0f b6 00             	movzbl (%eax),%eax
    bff5:	0f b6 d0             	movzbl %al,%edx
    bff8:	89 d0                	mov    %edx,%eax
    bffa:	c1 e0 08             	shl    $0x8,%eax
    bffd:	01 d0                	add    %edx,%eax
    bfff:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c002:	eb 0a                	jmp    c00e <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    c004:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c009:	e9 5f 01 00 00       	jmp    c16d <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    c00e:	8b 45 20             	mov    0x20(%ebp),%eax
    c011:	8b 00                	mov    (%eax),%eax
    c013:	85 c0                	test   %eax,%eax
    c015:	74 0a                	je     c021 <lodepng_convert_rgb+0x153>
    c017:	8b 45 20             	mov    0x20(%ebp),%eax
    c01a:	8b 00                	mov    (%eax),%eax
    c01c:	83 f8 04             	cmp    $0x4,%eax
    c01f:	75 14                	jne    c035 <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    c021:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c024:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c027:	89 c1                	mov    %eax,%ecx
    c029:	d3 ea                	shr    %cl,%edx
    c02b:	8b 45 08             	mov    0x8(%ebp),%eax
    c02e:	89 10                	mov    %edx,(%eax)
    c030:	e9 33 01 00 00       	jmp    c168 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    c035:	8b 45 20             	mov    0x20(%ebp),%eax
    c038:	8b 00                	mov    (%eax),%eax
    c03a:	83 f8 02             	cmp    $0x2,%eax
    c03d:	74 0a                	je     c049 <lodepng_convert_rgb+0x17b>
    c03f:	8b 45 20             	mov    0x20(%ebp),%eax
    c042:	8b 00                	mov    (%eax),%eax
    c044:	83 f8 06             	cmp    $0x6,%eax
    c047:	75 32                	jne    c07b <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    c049:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c04c:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c04f:	89 c1                	mov    %eax,%ecx
    c051:	d3 ea                	shr    %cl,%edx
    c053:	8b 45 08             	mov    0x8(%ebp),%eax
    c056:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    c058:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c05b:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c05e:	89 c1                	mov    %eax,%ecx
    c060:	d3 ea                	shr    %cl,%edx
    c062:	8b 45 0c             	mov    0xc(%ebp),%eax
    c065:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    c067:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c06a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    c06d:	89 c1                	mov    %eax,%ecx
    c06f:	d3 ea                	shr    %cl,%edx
    c071:	8b 45 10             	mov    0x10(%ebp),%eax
    c074:	89 10                	mov    %edx,(%eax)
    c076:	e9 ed 00 00 00       	jmp    c168 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    c07b:	8b 45 20             	mov    0x20(%ebp),%eax
    c07e:	8b 00                	mov    (%eax),%eax
    c080:	83 f8 03             	cmp    $0x3,%eax
    c083:	0f 85 d8 00 00 00    	jne    c161 <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    c089:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c08c:	c1 e8 08             	shr    $0x8,%eax
    c08f:	89 c2                	mov    %eax,%edx
    c091:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c094:	0f b6 c0             	movzbl %al,%eax
    c097:	39 c2                	cmp    %eax,%edx
    c099:	75 24                	jne    c0bf <lodepng_convert_rgb+0x1f1>
    c09b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c09e:	c1 e8 08             	shr    $0x8,%eax
    c0a1:	89 c2                	mov    %eax,%edx
    c0a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c0a6:	0f b6 c0             	movzbl %al,%eax
    c0a9:	39 c2                	cmp    %eax,%edx
    c0ab:	75 12                	jne    c0bf <lodepng_convert_rgb+0x1f1>
    c0ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c0b0:	c1 e8 08             	shr    $0x8,%eax
    c0b3:	89 c2                	mov    %eax,%edx
    c0b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c0b8:	0f b6 c0             	movzbl %al,%eax
    c0bb:	39 c2                	cmp    %eax,%edx
    c0bd:	74 0a                	je     c0c9 <lodepng_convert_rgb+0x1fb>
    c0bf:	b8 52 00 00 00       	mov    $0x52,%eax
    c0c4:	e9 a4 00 00 00       	jmp    c16d <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    c0c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    c0d0:	eb 79                	jmp    c14b <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    c0d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c0d5:	c1 e0 02             	shl    $0x2,%eax
    c0d8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c0db:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c0de:	c1 e8 08             	shr    $0x8,%eax
    c0e1:	89 c1                	mov    %eax,%ecx
    c0e3:	8b 45 20             	mov    0x20(%ebp),%eax
    c0e6:	8b 50 08             	mov    0x8(%eax),%edx
    c0e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c0ec:	01 d0                	add    %edx,%eax
    c0ee:	0f b6 00             	movzbl (%eax),%eax
    c0f1:	0f b6 c0             	movzbl %al,%eax
    c0f4:	39 c1                	cmp    %eax,%ecx
    c0f6:	75 4f                	jne    c147 <lodepng_convert_rgb+0x279>
    c0f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c0fb:	c1 e8 08             	shr    $0x8,%eax
    c0fe:	89 c1                	mov    %eax,%ecx
    c100:	8b 45 20             	mov    0x20(%ebp),%eax
    c103:	8b 40 08             	mov    0x8(%eax),%eax
    c106:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c109:	83 c2 01             	add    $0x1,%edx
    c10c:	01 d0                	add    %edx,%eax
    c10e:	0f b6 00             	movzbl (%eax),%eax
    c111:	0f b6 c0             	movzbl %al,%eax
    c114:	39 c1                	cmp    %eax,%ecx
    c116:	75 2f                	jne    c147 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    c118:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c11b:	c1 e8 08             	shr    $0x8,%eax
    c11e:	89 c1                	mov    %eax,%ecx
    c120:	8b 45 20             	mov    0x20(%ebp),%eax
    c123:	8b 40 08             	mov    0x8(%eax),%eax
    c126:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c129:	83 c2 02             	add    $0x2,%edx
    c12c:	01 d0                	add    %edx,%eax
    c12e:	0f b6 00             	movzbl (%eax),%eax
    c131:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c134:	39 c1                	cmp    %eax,%ecx
    c136:	75 0f                	jne    c147 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    c138:	8b 45 08             	mov    0x8(%ebp),%eax
    c13b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c13e:	89 10                	mov    %edx,(%eax)
        return 0;
    c140:	b8 00 00 00 00       	mov    $0x0,%eax
    c145:	eb 26                	jmp    c16d <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    c147:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c14b:	8b 45 20             	mov    0x20(%ebp),%eax
    c14e:	8b 40 0c             	mov    0xc(%eax),%eax
    c151:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    c154:	0f 87 78 ff ff ff    	ja     c0d2 <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    c15a:	b8 52 00 00 00       	mov    $0x52,%eax
    c15f:	eb 0c                	jmp    c16d <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    c161:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c166:	eb 05                	jmp    c16d <lodepng_convert_rgb+0x29f>
  }

  return 0;
    c168:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c16d:	c9                   	leave  
    c16e:	c3                   	ret    

0000c16f <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    c16f:	55                   	push   %ebp
    c170:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    c172:	8b 45 08             	mov    0x8(%ebp),%eax
    c175:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    c17b:	8b 45 08             	mov    0x8(%ebp),%eax
    c17e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    c185:	8b 45 08             	mov    0x8(%ebp),%eax
    c188:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    c18e:	8b 45 08             	mov    0x8(%ebp),%eax
    c191:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c195:	8b 45 08             	mov    0x8(%ebp),%eax
    c198:	66 89 50 0a          	mov    %dx,0xa(%eax)
    c19c:	8b 45 08             	mov    0x8(%ebp),%eax
    c19f:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c1a3:	8b 45 08             	mov    0x8(%ebp),%eax
    c1a6:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    c1aa:	8b 45 08             	mov    0x8(%ebp),%eax
    c1ad:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    c1b4:	8b 45 08             	mov    0x8(%ebp),%eax
    c1b7:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    c1be:	8b 45 08             	mov    0x8(%ebp),%eax
    c1c1:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    c1c8:	00 00 00 
  stats->numpixels = 0;
    c1cb:	8b 45 08             	mov    0x8(%ebp),%eax
    c1ce:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    c1d5:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    c1d8:	8b 45 08             	mov    0x8(%ebp),%eax
    c1db:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    c1e2:	00 00 00 
  stats->allow_greyscale = 1;
    c1e5:	8b 45 08             	mov    0x8(%ebp),%eax
    c1e8:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    c1ef:	00 00 00 
}
    c1f2:	90                   	nop
    c1f3:	5d                   	pop    %ebp
    c1f4:	c3                   	ret    

0000c1f5 <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    c1f5:	55                   	push   %ebp
    c1f6:	89 e5                	mov    %esp,%ebp
    c1f8:	53                   	push   %ebx
    c1f9:	83 ec 04             	sub    $0x4,%esp
    c1fc:	8b 45 08             	mov    0x8(%ebp),%eax
    c1ff:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    c202:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    c206:	74 06                	je     c20e <getValueRequiredBits+0x19>
    c208:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    c20c:	75 07                	jne    c215 <getValueRequiredBits+0x20>
    c20e:	b8 01 00 00 00       	mov    $0x1,%eax
    c213:	eb 6b                	jmp    c280 <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    c215:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c219:	0f b6 d9             	movzbl %cl,%ebx
    c21c:	89 da                	mov    %ebx,%edx
    c21e:	89 d0                	mov    %edx,%eax
    c220:	c1 e0 04             	shl    $0x4,%eax
    c223:	89 c2                	mov    %eax,%edx
    c225:	89 d0                	mov    %edx,%eax
    c227:	c1 e0 04             	shl    $0x4,%eax
    c22a:	29 d0                	sub    %edx,%eax
    c22c:	01 d8                	add    %ebx,%eax
    c22e:	66 c1 e8 08          	shr    $0x8,%ax
    c232:	c0 e8 04             	shr    $0x4,%al
    c235:	89 c2                	mov    %eax,%edx
    c237:	c1 e2 04             	shl    $0x4,%edx
    c23a:	01 c2                	add    %eax,%edx
    c23c:	89 c8                	mov    %ecx,%eax
    c23e:	29 d0                	sub    %edx,%eax
    c240:	84 c0                	test   %al,%al
    c242:	75 37                	jne    c27b <getValueRequiredBits+0x86>
    c244:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c248:	0f b6 d1             	movzbl %cl,%edx
    c24b:	89 d0                	mov    %edx,%eax
    c24d:	01 c0                	add    %eax,%eax
    c24f:	01 d0                	add    %edx,%eax
    c251:	c1 e0 06             	shl    $0x6,%eax
    c254:	01 d0                	add    %edx,%eax
    c256:	66 c1 e8 08          	shr    $0x8,%ax
    c25a:	c0 e8 06             	shr    $0x6,%al
    c25d:	ba 55 00 00 00       	mov    $0x55,%edx
    c262:	0f af c2             	imul   %edx,%eax
    c265:	29 c1                	sub    %eax,%ecx
    c267:	89 c8                	mov    %ecx,%eax
    c269:	84 c0                	test   %al,%al
    c26b:	75 07                	jne    c274 <getValueRequiredBits+0x7f>
    c26d:	b8 02 00 00 00       	mov    $0x2,%eax
    c272:	eb 0c                	jmp    c280 <getValueRequiredBits+0x8b>
    c274:	b8 04 00 00 00       	mov    $0x4,%eax
    c279:	eb 05                	jmp    c280 <getValueRequiredBits+0x8b>
  return 8;
    c27b:	b8 08 00 00 00       	mov    $0x8,%eax
}
    c280:	83 c4 04             	add    $0x4,%esp
    c283:	5b                   	pop    %ebx
    c284:	5d                   	pop    %ebp
    c285:	c3                   	ret    

0000c286 <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    c286:	55                   	push   %ebp
    c287:	89 e5                	mov    %esp,%ebp
    c289:	56                   	push   %esi
    c28a:	53                   	push   %ebx
    c28b:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c291:	8b 55 10             	mov    0x10(%ebp),%edx
    c294:	8b 45 14             	mov    0x14(%ebp),%eax
    c297:	0f af c2             	imul   %edx,%eax
    c29a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    c29d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    c2a4:	ff 75 18             	pushl  0x18(%ebp)
    c2a7:	e8 0b cd ff ff       	call   8fb7 <lodepng_is_greyscale_type>
    c2ac:	83 c4 04             	add    $0x4,%esp
    c2af:	85 c0                	test   %eax,%eax
    c2b1:	0f 95 c0             	setne  %al
    c2b4:	0f b6 c0             	movzbl %al,%eax
    c2b7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    c2ba:	ff 75 18             	pushl  0x18(%ebp)
    c2bd:	e8 85 cd ff ff       	call   9047 <lodepng_can_have_alpha>
    c2c2:	83 c4 04             	add    $0x4,%esp
    c2c5:	85 c0                	test   %eax,%eax
    c2c7:	0f 94 c0             	sete   %al
    c2ca:	0f b6 c0             	movzbl %al,%eax
    c2cd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    c2d0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    c2d7:	ff 75 18             	pushl  0x18(%ebp)
    c2da:	e8 ab cc ff ff       	call   8f8a <lodepng_get_bpp>
    c2df:	83 c4 04             	add    $0x4,%esp
    c2e2:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    c2e5:	8b 45 08             	mov    0x8(%ebp),%eax
    c2e8:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c2ee:	83 f8 01             	cmp    $0x1,%eax
    c2f1:	75 0d                	jne    c300 <lodepng_compute_color_stats+0x7a>
    c2f3:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    c2f7:	75 07                	jne    c300 <lodepng_compute_color_stats+0x7a>
    c2f9:	b8 01 00 00 00       	mov    $0x1,%eax
    c2fe:	eb 05                	jmp    c305 <lodepng_compute_color_stats+0x7f>
    c300:	b8 00 00 00 00       	mov    $0x0,%eax
    c305:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    c308:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    c30f:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    c316:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    c31a:	77 26                	ja     c342 <lodepng_compute_color_stats+0xbc>
    c31c:	8b 45 08             	mov    0x8(%ebp),%eax
    c31f:	8b 50 14             	mov    0x14(%eax),%edx
    c322:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c325:	bb 01 00 00 00       	mov    $0x1,%ebx
    c32a:	89 c1                	mov    %eax,%ecx
    c32c:	d3 e3                	shl    %cl,%ebx
    c32e:	89 d8                	mov    %ebx,%eax
    c330:	01 d0                	add    %edx,%eax
    c332:	ba 01 01 00 00       	mov    $0x101,%edx
    c337:	3d 01 01 00 00       	cmp    $0x101,%eax
    c33c:	0f 47 c2             	cmova  %edx,%eax
    c33f:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    c342:	8b 45 08             	mov    0x8(%ebp),%eax
    c345:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    c34b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c34e:	01 c2                	add    %eax,%edx
    c350:	8b 45 08             	mov    0x8(%ebp),%eax
    c353:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    c359:	8b 45 08             	mov    0x8(%ebp),%eax
    c35c:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    c362:	85 c0                	test   %eax,%eax
    c364:	75 07                	jne    c36d <lodepng_compute_color_stats+0xe7>
    c366:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    c36d:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c373:	50                   	push   %eax
    c374:	e8 81 da ff ff       	call   9dfa <color_tree_init>
    c379:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    c37c:	8b 45 08             	mov    0x8(%ebp),%eax
    c37f:	8b 40 10             	mov    0x10(%eax),%eax
    c382:	85 c0                	test   %eax,%eax
    c384:	74 07                	je     c38d <lodepng_compute_color_stats+0x107>
    c386:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    c38d:	8b 45 08             	mov    0x8(%ebp),%eax
    c390:	8b 00                	mov    (%eax),%eax
    c392:	85 c0                	test   %eax,%eax
    c394:	74 07                	je     c39d <lodepng_compute_color_stats+0x117>
    c396:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    c39d:	8b 45 08             	mov    0x8(%ebp),%eax
    c3a0:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c3a6:	83 f8 10             	cmp    $0x10,%eax
    c3a9:	75 07                	jne    c3b2 <lodepng_compute_color_stats+0x12c>
    c3ab:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    c3b2:	8b 45 08             	mov    0x8(%ebp),%eax
    c3b5:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c3bb:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c3be:	72 07                	jb     c3c7 <lodepng_compute_color_stats+0x141>
    c3c0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    c3c7:	8b 45 08             	mov    0x8(%ebp),%eax
    c3ca:	8b 40 14             	mov    0x14(%eax),%eax
    c3cd:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c3d0:	72 07                	jb     c3d9 <lodepng_compute_color_stats+0x153>
    c3d2:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    c3d9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c3dd:	0f 85 82 00 00 00    	jne    c465 <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    c3e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c3ea:	eb 6c                	jmp    c458 <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    c3ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c3ef:	c1 e0 02             	shl    $0x2,%eax
    c3f2:	8d 50 10             	lea    0x10(%eax),%edx
    c3f5:	8b 45 08             	mov    0x8(%ebp),%eax
    c3f8:	01 d0                	add    %edx,%eax
    c3fa:	83 c0 08             	add    $0x8,%eax
    c3fd:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    c400:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c403:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c406:	83 c0 03             	add    $0x3,%eax
    c409:	0f b6 00             	movzbl (%eax),%eax
    c40c:	0f b6 d8             	movzbl %al,%ebx
    c40f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c412:	83 c0 02             	add    $0x2,%eax
    c415:	0f b6 00             	movzbl (%eax),%eax
    c418:	0f b6 c8             	movzbl %al,%ecx
    c41b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c41e:	83 c0 01             	add    $0x1,%eax
    c421:	0f b6 00             	movzbl (%eax),%eax
    c424:	0f b6 d0             	movzbl %al,%edx
    c427:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c42a:	0f b6 00             	movzbl (%eax),%eax
    c42d:	0f b6 c0             	movzbl %al,%eax
    c430:	83 ec 08             	sub    $0x8,%esp
    c433:	56                   	push   %esi
    c434:	53                   	push   %ebx
    c435:	51                   	push   %ecx
    c436:	52                   	push   %edx
    c437:	50                   	push   %eax
    c438:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c43e:	50                   	push   %eax
    c43f:	e8 39 db ff ff       	call   9f7d <color_tree_add>
    c444:	83 c4 20             	add    $0x20,%esp
    c447:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    c44a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c44e:	0f 85 22 09 00 00    	jne    cd76 <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    c454:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c458:	8b 45 08             	mov    0x8(%ebp),%eax
    c45b:	8b 50 14             	mov    0x14(%eax),%edx
    c45e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c461:	39 c2                	cmp    %eax,%edx
    c463:	77 87                	ja     c3ec <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    c465:	8b 45 18             	mov    0x18(%ebp),%eax
    c468:	8b 40 04             	mov    0x4(%eax),%eax
    c46b:	83 f8 10             	cmp    $0x10,%eax
    c46e:	0f 85 1e 01 00 00    	jne    c592 <lodepng_compute_color_stats+0x30c>
    c474:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c478:	0f 85 14 01 00 00    	jne    c592 <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c47e:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    c485:	00 00 
    c487:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    c48e:	00 00 
    c490:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    c497:	00 00 
    c499:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    c4a0:	00 00 
    for(i = 0; i != numpixels; ++i) {
    c4a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c4a9:	e9 d8 00 00 00       	jmp    c586 <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c4ae:	83 ec 04             	sub    $0x4,%esp
    c4b1:	ff 75 18             	pushl  0x18(%ebp)
    c4b4:	ff 75 f4             	pushl  -0xc(%ebp)
    c4b7:	ff 75 0c             	pushl  0xc(%ebp)
    c4ba:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    c4c0:	50                   	push   %eax
    c4c1:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    c4c7:	50                   	push   %eax
    c4c8:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    c4ce:	50                   	push   %eax
    c4cf:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    c4d5:	50                   	push   %eax
    c4d6:	e8 a8 f2 ff ff       	call   b783 <getPixelColorRGBA16>
    c4db:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c4de:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c4e5:	66 c1 e8 08          	shr    $0x8,%ax
    c4e9:	89 c2                	mov    %eax,%edx
    c4eb:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c4f2:	31 d0                	xor    %edx,%eax
    c4f4:	0f b7 c0             	movzwl %ax,%eax
    c4f7:	0f b6 c0             	movzbl %al,%eax
    c4fa:	85 c0                	test   %eax,%eax
    c4fc:	75 60                	jne    c55e <lodepng_compute_color_stats+0x2d8>
    c4fe:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c505:	66 c1 e8 08          	shr    $0x8,%ax
    c509:	89 c2                	mov    %eax,%edx
    c50b:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c512:	31 d0                	xor    %edx,%eax
    c514:	0f b7 c0             	movzwl %ax,%eax
    c517:	0f b6 c0             	movzbl %al,%eax
    c51a:	85 c0                	test   %eax,%eax
    c51c:	75 40                	jne    c55e <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c51e:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c525:	66 c1 e8 08          	shr    $0x8,%ax
    c529:	89 c2                	mov    %eax,%edx
    c52b:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c532:	31 d0                	xor    %edx,%eax
    c534:	0f b7 c0             	movzwl %ax,%eax
    c537:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c53a:	85 c0                	test   %eax,%eax
    c53c:	75 20                	jne    c55e <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c53e:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c545:	66 c1 e8 08          	shr    $0x8,%ax
    c549:	89 c2                	mov    %eax,%edx
    c54b:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c552:	31 d0                	xor    %edx,%eax
    c554:	0f b7 c0             	movzwl %ax,%eax
    c557:	0f b6 c0             	movzbl %al,%eax
    c55a:	85 c0                	test   %eax,%eax
    c55c:	74 24                	je     c582 <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    c55e:	8b 45 08             	mov    0x8(%ebp),%eax
    c561:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    c568:	00 00 00 
        sixteen = 1;
    c56b:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    c572:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    c579:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    c580:	eb 10                	jmp    c592 <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    c582:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c586:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c589:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c58c:	0f 85 1c ff ff ff    	jne    c4ae <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    c592:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c596:	0f 84 bd 02 00 00    	je     c859 <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c59c:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    c5a3:	00 00 
    c5a5:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    c5ac:	00 00 
    c5ae:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    c5b5:	00 00 
    c5b7:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    c5be:	00 00 

    for(i = 0; i != numpixels; ++i) {
    c5c0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c5c7:	e9 b1 01 00 00       	jmp    c77d <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c5cc:	83 ec 04             	sub    $0x4,%esp
    c5cf:	ff 75 18             	pushl  0x18(%ebp)
    c5d2:	ff 75 f4             	pushl  -0xc(%ebp)
    c5d5:	ff 75 0c             	pushl  0xc(%ebp)
    c5d8:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c5de:	50                   	push   %eax
    c5df:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c5e5:	50                   	push   %eax
    c5e6:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c5ec:	50                   	push   %eax
    c5ed:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c5f3:	50                   	push   %eax
    c5f4:	e8 8a f1 ff ff       	call   b783 <getPixelColorRGBA16>
    c5f9:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    c5fc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c600:	75 36                	jne    c638 <lodepng_compute_color_stats+0x3b2>
    c602:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c609:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c610:	66 39 c2             	cmp    %ax,%dx
    c613:	75 13                	jne    c628 <lodepng_compute_color_stats+0x3a2>
    c615:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c61c:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c623:	66 39 c2             	cmp    %ax,%dx
    c626:	74 10                	je     c638 <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    c628:	8b 45 08             	mov    0x8(%ebp),%eax
    c62b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c631:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    c638:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c63c:	0f 85 1f 01 00 00    	jne    c761 <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c642:	8b 45 08             	mov    0x8(%ebp),%eax
    c645:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c649:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c650:	66 39 c2             	cmp    %ax,%dx
    c653:	75 2d                	jne    c682 <lodepng_compute_color_stats+0x3fc>
    c655:	8b 45 08             	mov    0x8(%ebp),%eax
    c658:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c65c:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c663:	66 39 c2             	cmp    %ax,%dx
    c666:	75 1a                	jne    c682 <lodepng_compute_color_stats+0x3fc>
    c668:	8b 45 08             	mov    0x8(%ebp),%eax
    c66b:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c66f:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c676:	66 39 c2             	cmp    %ax,%dx
    c679:	75 07                	jne    c682 <lodepng_compute_color_stats+0x3fc>
    c67b:	b8 01 00 00 00       	mov    $0x1,%eax
    c680:	eb 05                	jmp    c687 <lodepng_compute_color_stats+0x401>
    c682:	b8 00 00 00 00       	mov    $0x0,%eax
    c687:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    c68a:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c691:	66 83 f8 ff          	cmp    $0xffff,%ax
    c695:	74 3c                	je     c6d3 <lodepng_compute_color_stats+0x44d>
    c697:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c69e:	66 85 c0             	test   %ax,%ax
    c6a1:	75 10                	jne    c6b3 <lodepng_compute_color_stats+0x42d>
    c6a3:	8b 45 08             	mov    0x8(%ebp),%eax
    c6a6:	8b 40 04             	mov    0x4(%eax),%eax
    c6a9:	85 c0                	test   %eax,%eax
    c6ab:	74 26                	je     c6d3 <lodepng_compute_color_stats+0x44d>
    c6ad:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c6b1:	75 20                	jne    c6d3 <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    c6b3:	8b 45 08             	mov    0x8(%ebp),%eax
    c6b6:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c6bd:	8b 45 08             	mov    0x8(%ebp),%eax
    c6c0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c6c7:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    c6ce:	e9 8e 00 00 00       	jmp    c761 <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c6d3:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c6da:	66 85 c0             	test   %ax,%ax
    c6dd:	75 4a                	jne    c729 <lodepng_compute_color_stats+0x4a3>
    c6df:	8b 45 08             	mov    0x8(%ebp),%eax
    c6e2:	8b 40 10             	mov    0x10(%eax),%eax
    c6e5:	85 c0                	test   %eax,%eax
    c6e7:	75 40                	jne    c729 <lodepng_compute_color_stats+0x4a3>
    c6e9:	8b 45 08             	mov    0x8(%ebp),%eax
    c6ec:	8b 40 04             	mov    0x4(%eax),%eax
    c6ef:	85 c0                	test   %eax,%eax
    c6f1:	75 36                	jne    c729 <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    c6f3:	8b 45 08             	mov    0x8(%ebp),%eax
    c6f6:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c6fd:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c704:	8b 45 08             	mov    0x8(%ebp),%eax
    c707:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c70b:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    c712:	8b 45 08             	mov    0x8(%ebp),%eax
    c715:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c719:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    c720:	8b 45 08             	mov    0x8(%ebp),%eax
    c723:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c727:	eb 38                	jmp    c761 <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    c729:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c730:	66 83 f8 ff          	cmp    $0xffff,%ax
    c734:	75 2b                	jne    c761 <lodepng_compute_color_stats+0x4db>
    c736:	8b 45 08             	mov    0x8(%ebp),%eax
    c739:	8b 40 04             	mov    0x4(%eax),%eax
    c73c:	85 c0                	test   %eax,%eax
    c73e:	74 21                	je     c761 <lodepng_compute_color_stats+0x4db>
    c740:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c744:	74 1b                	je     c761 <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c746:	8b 45 08             	mov    0x8(%ebp),%eax
    c749:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c750:	8b 45 08             	mov    0x8(%ebp),%eax
    c753:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c75a:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c761:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c765:	74 12                	je     c779 <lodepng_compute_color_stats+0x4f3>
    c767:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c76b:	74 0c                	je     c779 <lodepng_compute_color_stats+0x4f3>
    c76d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c771:	74 06                	je     c779 <lodepng_compute_color_stats+0x4f3>
    c773:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c777:	75 12                	jne    c78b <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    c779:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c77d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c780:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c783:	0f 85 43 fe ff ff    	jne    c5cc <lodepng_compute_color_stats+0x346>
    c789:	eb 01                	jmp    c78c <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c78b:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    c78c:	8b 45 08             	mov    0x8(%ebp),%eax
    c78f:	8b 40 04             	mov    0x4(%eax),%eax
    c792:	85 c0                	test   %eax,%eax
    c794:	0f 84 e0 05 00 00    	je     cd7a <lodepng_compute_color_stats+0xaf4>
    c79a:	8b 45 08             	mov    0x8(%ebp),%eax
    c79d:	8b 40 10             	mov    0x10(%eax),%eax
    c7a0:	85 c0                	test   %eax,%eax
    c7a2:	0f 85 d2 05 00 00    	jne    cd7a <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    c7a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c7af:	e9 94 00 00 00       	jmp    c848 <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c7b4:	83 ec 04             	sub    $0x4,%esp
    c7b7:	ff 75 18             	pushl  0x18(%ebp)
    c7ba:	ff 75 f4             	pushl  -0xc(%ebp)
    c7bd:	ff 75 0c             	pushl  0xc(%ebp)
    c7c0:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c7c6:	50                   	push   %eax
    c7c7:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c7cd:	50                   	push   %eax
    c7ce:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c7d4:	50                   	push   %eax
    c7d5:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c7db:	50                   	push   %eax
    c7dc:	e8 a2 ef ff ff       	call   b783 <getPixelColorRGBA16>
    c7e1:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    c7e4:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c7eb:	66 85 c0             	test   %ax,%ax
    c7ee:	74 54                	je     c844 <lodepng_compute_color_stats+0x5be>
    c7f0:	8b 45 08             	mov    0x8(%ebp),%eax
    c7f3:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c7f7:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c7fe:	66 39 c2             	cmp    %ax,%dx
    c801:	75 41                	jne    c844 <lodepng_compute_color_stats+0x5be>
    c803:	8b 45 08             	mov    0x8(%ebp),%eax
    c806:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c80a:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c811:	66 39 c2             	cmp    %ax,%dx
    c814:	75 2e                	jne    c844 <lodepng_compute_color_stats+0x5be>
    c816:	8b 45 08             	mov    0x8(%ebp),%eax
    c819:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c81d:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c824:	66 39 c2             	cmp    %ax,%dx
    c827:	75 1b                	jne    c844 <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c829:	8b 45 08             	mov    0x8(%ebp),%eax
    c82c:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c833:	8b 45 08             	mov    0x8(%ebp),%eax
    c836:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c83d:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    c844:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c848:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c84b:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c84e:	0f 85 60 ff ff ff    	jne    c7b4 <lodepng_compute_color_stats+0x52e>
    c854:	e9 21 05 00 00       	jmp    cd7a <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    c859:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    c860:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    c867:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    c86e:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    c875:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c87c:	e9 ab 03 00 00       	jmp    cc2c <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    c881:	83 ec 04             	sub    $0x4,%esp
    c884:	ff 75 18             	pushl  0x18(%ebp)
    c887:	ff 75 f4             	pushl  -0xc(%ebp)
    c88a:	ff 75 0c             	pushl  0xc(%ebp)
    c88d:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    c893:	50                   	push   %eax
    c894:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    c89a:	50                   	push   %eax
    c89b:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    c8a1:	50                   	push   %eax
    c8a2:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    c8a8:	50                   	push   %eax
    c8a9:	e8 1e de ff ff       	call   a6cc <getPixelColorRGBA8>
    c8ae:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    c8b1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c8b5:	75 41                	jne    c8f8 <lodepng_compute_color_stats+0x672>
    c8b7:	8b 45 08             	mov    0x8(%ebp),%eax
    c8ba:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c8c0:	83 f8 07             	cmp    $0x7,%eax
    c8c3:	77 33                	ja     c8f8 <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    c8c5:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c8cc:	0f b6 c0             	movzbl %al,%eax
    c8cf:	83 ec 0c             	sub    $0xc,%esp
    c8d2:	50                   	push   %eax
    c8d3:	e8 1d f9 ff ff       	call   c1f5 <getValueRequiredBits>
    c8d8:	83 c4 10             	add    $0x10,%esp
    c8db:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    c8de:	8b 45 08             	mov    0x8(%ebp),%eax
    c8e1:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c8e7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    c8ea:	73 0c                	jae    c8f8 <lodepng_compute_color_stats+0x672>
    c8ec:	8b 45 08             	mov    0x8(%ebp),%eax
    c8ef:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    c8f2:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    c8f8:	8b 45 08             	mov    0x8(%ebp),%eax
    c8fb:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c901:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c904:	0f 93 c0             	setae  %al
    c907:	0f b6 c0             	movzbl %al,%eax
    c90a:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    c90d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c911:	75 4f                	jne    c962 <lodepng_compute_color_stats+0x6dc>
    c913:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c91a:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c921:	38 c2                	cmp    %al,%dl
    c923:	75 12                	jne    c937 <lodepng_compute_color_stats+0x6b1>
    c925:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    c92c:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c933:	38 c2                	cmp    %al,%dl
    c935:	74 2b                	je     c962 <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    c937:	8b 45 08             	mov    0x8(%ebp),%eax
    c93a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c940:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    c947:	8b 45 08             	mov    0x8(%ebp),%eax
    c94a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c950:	83 f8 07             	cmp    $0x7,%eax
    c953:	77 0d                	ja     c962 <lodepng_compute_color_stats+0x6dc>
    c955:	8b 45 08             	mov    0x8(%ebp),%eax
    c958:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    c95f:	00 00 00 
      }

      if(!alpha_done) {
    c962:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c966:	0f 85 65 01 00 00    	jne    cad1 <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c96c:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    c973:	0f b6 d0             	movzbl %al,%edx
    c976:	8b 45 08             	mov    0x8(%ebp),%eax
    c979:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    c97d:	66 39 c2             	cmp    %ax,%dx
    c980:	75 33                	jne    c9b5 <lodepng_compute_color_stats+0x72f>
    c982:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    c989:	0f b6 d0             	movzbl %al,%edx
    c98c:	8b 45 08             	mov    0x8(%ebp),%eax
    c98f:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    c993:	66 39 c2             	cmp    %ax,%dx
    c996:	75 1d                	jne    c9b5 <lodepng_compute_color_stats+0x72f>
    c998:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    c99f:	0f b6 d0             	movzbl %al,%edx
    c9a2:	8b 45 08             	mov    0x8(%ebp),%eax
    c9a5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    c9a9:	66 39 c2             	cmp    %ax,%dx
    c9ac:	75 07                	jne    c9b5 <lodepng_compute_color_stats+0x72f>
    c9ae:	b8 01 00 00 00       	mov    $0x1,%eax
    c9b3:	eb 05                	jmp    c9ba <lodepng_compute_color_stats+0x734>
    c9b5:	b8 00 00 00 00       	mov    $0x0,%eax
    c9ba:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    c9bd:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c9c4:	3c ff                	cmp    $0xff,%al
    c9c6:	74 5a                	je     ca22 <lodepng_compute_color_stats+0x79c>
    c9c8:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    c9cf:	84 c0                	test   %al,%al
    c9d1:	75 10                	jne    c9e3 <lodepng_compute_color_stats+0x75d>
    c9d3:	8b 45 08             	mov    0x8(%ebp),%eax
    c9d6:	8b 40 04             	mov    0x4(%eax),%eax
    c9d9:	85 c0                	test   %eax,%eax
    c9db:	74 45                	je     ca22 <lodepng_compute_color_stats+0x79c>
    c9dd:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    c9e1:	75 3f                	jne    ca22 <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    c9e3:	8b 45 08             	mov    0x8(%ebp),%eax
    c9e6:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c9ed:	8b 45 08             	mov    0x8(%ebp),%eax
    c9f0:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c9f7:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    c9fe:	8b 45 08             	mov    0x8(%ebp),%eax
    ca01:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ca07:	83 f8 07             	cmp    $0x7,%eax
    ca0a:	0f 87 c1 00 00 00    	ja     cad1 <lodepng_compute_color_stats+0x84b>
    ca10:	8b 45 08             	mov    0x8(%ebp),%eax
    ca13:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    ca1a:	00 00 00 
    ca1d:	e9 af 00 00 00       	jmp    cad1 <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    ca22:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ca29:	84 c0                	test   %al,%al
    ca2b:	75 53                	jne    ca80 <lodepng_compute_color_stats+0x7fa>
    ca2d:	8b 45 08             	mov    0x8(%ebp),%eax
    ca30:	8b 40 10             	mov    0x10(%eax),%eax
    ca33:	85 c0                	test   %eax,%eax
    ca35:	75 49                	jne    ca80 <lodepng_compute_color_stats+0x7fa>
    ca37:	8b 45 08             	mov    0x8(%ebp),%eax
    ca3a:	8b 40 04             	mov    0x4(%eax),%eax
    ca3d:	85 c0                	test   %eax,%eax
    ca3f:	75 3f                	jne    ca80 <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    ca41:	8b 45 08             	mov    0x8(%ebp),%eax
    ca44:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    ca4b:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca52:	0f b6 d0             	movzbl %al,%edx
    ca55:	8b 45 08             	mov    0x8(%ebp),%eax
    ca58:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    ca5c:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ca63:	0f b6 d0             	movzbl %al,%edx
    ca66:	8b 45 08             	mov    0x8(%ebp),%eax
    ca69:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    ca6d:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ca74:	0f b6 d0             	movzbl %al,%edx
    ca77:	8b 45 08             	mov    0x8(%ebp),%eax
    ca7a:	66 89 50 0c          	mov    %dx,0xc(%eax)
    ca7e:	eb 51                	jmp    cad1 <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    ca80:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ca87:	3c ff                	cmp    $0xff,%al
    ca89:	75 46                	jne    cad1 <lodepng_compute_color_stats+0x84b>
    ca8b:	8b 45 08             	mov    0x8(%ebp),%eax
    ca8e:	8b 40 04             	mov    0x4(%eax),%eax
    ca91:	85 c0                	test   %eax,%eax
    ca93:	74 3c                	je     cad1 <lodepng_compute_color_stats+0x84b>
    ca95:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    ca99:	74 36                	je     cad1 <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    ca9b:	8b 45 08             	mov    0x8(%ebp),%eax
    ca9e:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    caa5:	8b 45 08             	mov    0x8(%ebp),%eax
    caa8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    caaf:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cab6:	8b 45 08             	mov    0x8(%ebp),%eax
    cab9:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cabf:	83 f8 07             	cmp    $0x7,%eax
    cac2:	77 0d                	ja     cad1 <lodepng_compute_color_stats+0x84b>
    cac4:	8b 45 08             	mov    0x8(%ebp),%eax
    cac7:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cace:	00 00 00 
        }
      }

      if(!numcolors_done) {
    cad1:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cad5:	0f 85 35 01 00 00    	jne    cc10 <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    cadb:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cae2:	0f b6 d8             	movzbl %al,%ebx
    cae5:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    caec:	0f b6 c8             	movzbl %al,%ecx
    caef:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    caf6:	0f b6 d0             	movzbl %al,%edx
    caf9:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cb00:	0f b6 c0             	movzbl %al,%eax
    cb03:	83 ec 0c             	sub    $0xc,%esp
    cb06:	53                   	push   %ebx
    cb07:	51                   	push   %ecx
    cb08:	52                   	push   %edx
    cb09:	50                   	push   %eax
    cb0a:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cb10:	50                   	push   %eax
    cb11:	e8 1c d4 ff ff       	call   9f32 <color_tree_has>
    cb16:	83 c4 20             	add    $0x20,%esp
    cb19:	85 c0                	test   %eax,%eax
    cb1b:	0f 85 ef 00 00 00    	jne    cc10 <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    cb21:	8b 45 08             	mov    0x8(%ebp),%eax
    cb24:	8b 70 14             	mov    0x14(%eax),%esi
    cb27:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cb2e:	0f b6 d8             	movzbl %al,%ebx
    cb31:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cb38:	0f b6 c8             	movzbl %al,%ecx
    cb3b:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cb42:	0f b6 d0             	movzbl %al,%edx
    cb45:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cb4c:	0f b6 c0             	movzbl %al,%eax
    cb4f:	83 ec 08             	sub    $0x8,%esp
    cb52:	56                   	push   %esi
    cb53:	53                   	push   %ebx
    cb54:	51                   	push   %ecx
    cb55:	52                   	push   %edx
    cb56:	50                   	push   %eax
    cb57:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cb5d:	50                   	push   %eax
    cb5e:	e8 1a d4 ff ff       	call   9f7d <color_tree_add>
    cb63:	83 c4 20             	add    $0x20,%esp
    cb66:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    cb69:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    cb6d:	0f 85 06 02 00 00    	jne    cd79 <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    cb73:	8b 45 08             	mov    0x8(%ebp),%eax
    cb76:	8b 40 14             	mov    0x14(%eax),%eax
    cb79:	3d ff 00 00 00       	cmp    $0xff,%eax
    cb7e:	77 6f                	ja     cbef <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    cb80:	8b 45 08             	mov    0x8(%ebp),%eax
    cb83:	83 c0 18             	add    $0x18,%eax
    cb86:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    cb89:	8b 45 08             	mov    0x8(%ebp),%eax
    cb8c:	8b 40 14             	mov    0x14(%eax),%eax
    cb8f:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    cb92:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cb95:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    cb9c:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cb9f:	01 c2                	add    %eax,%edx
    cba1:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cba8:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    cbaa:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cbad:	c1 e0 02             	shl    $0x2,%eax
    cbb0:	8d 50 01             	lea    0x1(%eax),%edx
    cbb3:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cbb6:	01 c2                	add    %eax,%edx
    cbb8:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cbbf:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    cbc1:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cbc4:	c1 e0 02             	shl    $0x2,%eax
    cbc7:	8d 50 02             	lea    0x2(%eax),%edx
    cbca:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cbcd:	01 c2                	add    %eax,%edx
    cbcf:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cbd6:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    cbd8:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cbdb:	c1 e0 02             	shl    $0x2,%eax
    cbde:	8d 50 03             	lea    0x3(%eax),%edx
    cbe1:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cbe4:	01 c2                	add    %eax,%edx
    cbe6:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cbed:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    cbef:	8b 45 08             	mov    0x8(%ebp),%eax
    cbf2:	8b 40 14             	mov    0x14(%eax),%eax
    cbf5:	8d 50 01             	lea    0x1(%eax),%edx
    cbf8:	8b 45 08             	mov    0x8(%ebp),%eax
    cbfb:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    cbfe:	8b 45 08             	mov    0x8(%ebp),%eax
    cc01:	8b 40 14             	mov    0x14(%eax),%eax
    cc04:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cc07:	0f 93 c0             	setae  %al
    cc0a:	0f b6 c0             	movzbl %al,%eax
    cc0d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cc10:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cc14:	74 12                	je     cc28 <lodepng_compute_color_stats+0x9a2>
    cc16:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cc1a:	74 0c                	je     cc28 <lodepng_compute_color_stats+0x9a2>
    cc1c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cc20:	74 06                	je     cc28 <lodepng_compute_color_stats+0x9a2>
    cc22:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cc26:	75 12                	jne    cc3a <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    cc28:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cc2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cc2f:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cc32:	0f 85 49 fc ff ff    	jne    c881 <lodepng_compute_color_stats+0x5fb>
    cc38:	eb 01                	jmp    cc3b <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cc3a:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    cc3b:	8b 45 08             	mov    0x8(%ebp),%eax
    cc3e:	8b 40 04             	mov    0x4(%eax),%eax
    cc41:	85 c0                	test   %eax,%eax
    cc43:	0f 84 dd 00 00 00    	je     cd26 <lodepng_compute_color_stats+0xaa0>
    cc49:	8b 45 08             	mov    0x8(%ebp),%eax
    cc4c:	8b 40 10             	mov    0x10(%eax),%eax
    cc4f:	85 c0                	test   %eax,%eax
    cc51:	0f 85 cf 00 00 00    	jne    cd26 <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    cc57:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cc5e:	e9 b7 00 00 00       	jmp    cd1a <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    cc63:	83 ec 04             	sub    $0x4,%esp
    cc66:	ff 75 18             	pushl  0x18(%ebp)
    cc69:	ff 75 f4             	pushl  -0xc(%ebp)
    cc6c:	ff 75 0c             	pushl  0xc(%ebp)
    cc6f:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    cc75:	50                   	push   %eax
    cc76:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    cc7c:	50                   	push   %eax
    cc7d:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    cc83:	50                   	push   %eax
    cc84:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    cc8a:	50                   	push   %eax
    cc8b:	e8 3c da ff ff       	call   a6cc <getPixelColorRGBA8>
    cc90:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    cc93:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cc9a:	84 c0                	test   %al,%al
    cc9c:	74 78                	je     cd16 <lodepng_compute_color_stats+0xa90>
    cc9e:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cca5:	0f b6 d0             	movzbl %al,%edx
    cca8:	8b 45 08             	mov    0x8(%ebp),%eax
    ccab:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    ccaf:	66 39 c2             	cmp    %ax,%dx
    ccb2:	75 62                	jne    cd16 <lodepng_compute_color_stats+0xa90>
    ccb4:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ccbb:	0f b6 d0             	movzbl %al,%edx
    ccbe:	8b 45 08             	mov    0x8(%ebp),%eax
    ccc1:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    ccc5:	66 39 c2             	cmp    %ax,%dx
    ccc8:	75 4c                	jne    cd16 <lodepng_compute_color_stats+0xa90>
    ccca:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ccd1:	0f b6 d0             	movzbl %al,%edx
    ccd4:	8b 45 08             	mov    0x8(%ebp),%eax
    ccd7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    ccdb:	66 39 c2             	cmp    %ax,%dx
    ccde:	75 36                	jne    cd16 <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cce0:	8b 45 08             	mov    0x8(%ebp),%eax
    cce3:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    ccea:	8b 45 08             	mov    0x8(%ebp),%eax
    cced:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    ccf4:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    ccfb:	8b 45 08             	mov    0x8(%ebp),%eax
    ccfe:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cd04:	83 f8 07             	cmp    $0x7,%eax
    cd07:	77 0d                	ja     cd16 <lodepng_compute_color_stats+0xa90>
    cd09:	8b 45 08             	mov    0x8(%ebp),%eax
    cd0c:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cd13:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    cd16:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cd1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cd1d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cd20:	0f 85 3d ff ff ff    	jne    cc63 <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    cd26:	8b 45 08             	mov    0x8(%ebp),%eax
    cd29:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    cd2d:	8b 45 08             	mov    0x8(%ebp),%eax
    cd30:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cd34:	c1 e0 08             	shl    $0x8,%eax
    cd37:	01 c2                	add    %eax,%edx
    cd39:	8b 45 08             	mov    0x8(%ebp),%eax
    cd3c:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    cd40:	8b 45 08             	mov    0x8(%ebp),%eax
    cd43:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    cd47:	8b 45 08             	mov    0x8(%ebp),%eax
    cd4a:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cd4e:	c1 e0 08             	shl    $0x8,%eax
    cd51:	01 c2                	add    %eax,%edx
    cd53:	8b 45 08             	mov    0x8(%ebp),%eax
    cd56:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    cd5a:	8b 45 08             	mov    0x8(%ebp),%eax
    cd5d:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    cd61:	8b 45 08             	mov    0x8(%ebp),%eax
    cd64:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cd68:	c1 e0 08             	shl    $0x8,%eax
    cd6b:	01 c2                	add    %eax,%edx
    cd6d:	8b 45 08             	mov    0x8(%ebp),%eax
    cd70:	66 89 50 0c          	mov    %dx,0xc(%eax)
    cd74:	eb 04                	jmp    cd7a <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    cd76:	90                   	nop
    cd77:	eb 01                	jmp    cd7a <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    cd79:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    cd7a:	83 ec 0c             	sub    $0xc,%esp
    cd7d:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cd83:	50                   	push   %eax
    cd84:	e8 91 d0 ff ff       	call   9e1a <color_tree_cleanup>
    cd89:	83 c4 10             	add    $0x10,%esp
  return error;
    cd8c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    cd8f:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cd92:	5b                   	pop    %ebx
    cd93:	5e                   	pop    %esi
    cd94:	5d                   	pop    %ebp
    cd95:	c3                   	ret    

0000cd96 <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    cd96:	55                   	push   %ebp
    cd97:	89 e5                	mov    %esp,%ebp
    cd99:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    cd9c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    cda3:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cda6:	50                   	push   %eax
    cda7:	e8 d1 bd ff ff       	call   8b7d <lodepng_color_mode_init>
    cdac:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    cdaf:	8b 45 0c             	mov    0xc(%ebp),%eax
    cdb2:	c1 e8 08             	shr    $0x8,%eax
    cdb5:	88 45 ec             	mov    %al,-0x14(%ebp)
    cdb8:	8b 45 0c             	mov    0xc(%ebp),%eax
    cdbb:	88 45 ed             	mov    %al,-0x13(%ebp)
    cdbe:	8b 45 10             	mov    0x10(%ebp),%eax
    cdc1:	c1 e8 08             	shr    $0x8,%eax
    cdc4:	88 45 ee             	mov    %al,-0x12(%ebp)
    cdc7:	8b 45 10             	mov    0x10(%ebp),%eax
    cdca:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    cdcd:	8b 45 14             	mov    0x14(%ebp),%eax
    cdd0:	c1 e8 08             	shr    $0x8,%eax
    cdd3:	88 45 f0             	mov    %al,-0x10(%ebp)
    cdd6:	8b 45 14             	mov    0x14(%ebp),%eax
    cdd9:	88 45 f1             	mov    %al,-0xf(%ebp)
    cddc:	8b 45 18             	mov    0x18(%ebp),%eax
    cddf:	c1 e8 08             	shr    $0x8,%eax
    cde2:	88 45 f2             	mov    %al,-0xe(%ebp)
    cde5:	8b 45 18             	mov    0x18(%ebp),%eax
    cde8:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    cdeb:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    cdf2:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    cdf9:	83 ec 0c             	sub    $0xc,%esp
    cdfc:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cdff:	50                   	push   %eax
    ce00:	6a 01                	push   $0x1
    ce02:	6a 01                	push   $0x1
    ce04:	8d 45 ec             	lea    -0x14(%ebp),%eax
    ce07:	50                   	push   %eax
    ce08:	ff 75 08             	pushl  0x8(%ebp)
    ce0b:	e8 76 f4 ff ff       	call   c286 <lodepng_compute_color_stats>
    ce10:	83 c4 20             	add    $0x20,%esp
    ce13:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    ce16:	83 ec 0c             	sub    $0xc,%esp
    ce19:	8d 45 cc             	lea    -0x34(%ebp),%eax
    ce1c:	50                   	push   %eax
    ce1d:	e8 4e be ff ff       	call   8c70 <lodepng_color_mode_cleanup>
    ce22:	83 c4 10             	add    $0x10,%esp
  return error;
    ce25:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ce28:	c9                   	leave  
    ce29:	c3                   	ret    

0000ce2a <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    ce2a:	55                   	push   %ebp
    ce2b:	89 e5                	mov    %esp,%ebp
    ce2d:	56                   	push   %esi
    ce2e:	53                   	push   %ebx
    ce2f:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    ce32:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    ce39:	8b 45 10             	mov    0x10(%ebp),%eax
    ce3c:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    ce42:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    ce45:	8b 45 10             	mov    0x10(%ebp),%eax
    ce48:	8b 40 10             	mov    0x10(%eax),%eax
    ce4b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    ce4e:	8b 45 10             	mov    0x10(%ebp),%eax
    ce51:	8b 40 04             	mov    0x4(%eax),%eax
    ce54:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    ce57:	8b 45 10             	mov    0x10(%ebp),%eax
    ce5a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ce60:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    ce63:	8b 45 08             	mov    0x8(%ebp),%eax
    ce66:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    ce6d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ce71:	74 21                	je     ce94 <auto_choose_color+0x6a>
    ce73:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    ce77:	7f 1b                	jg     ce94 <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    ce79:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    ce80:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    ce87:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    ce8b:	77 07                	ja     ce94 <auto_choose_color+0x6a>
    ce8d:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    ce94:	8b 45 10             	mov    0x10(%ebp),%eax
    ce97:	8b 00                	mov    (%eax),%eax
    ce99:	85 c0                	test   %eax,%eax
    ce9b:	0f 94 c0             	sete   %al
    ce9e:	0f b6 c0             	movzbl %al,%eax
    cea1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    cea4:	8b 45 10             	mov    0x10(%ebp),%eax
    cea7:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    cead:	85 c0                	test   %eax,%eax
    ceaf:	75 07                	jne    ceb8 <auto_choose_color+0x8e>
    ceb1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    ceb8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cebc:	75 0d                	jne    cecb <auto_choose_color+0xa1>
    cebe:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    cec2:	77 07                	ja     cecb <auto_choose_color+0xa1>
    cec4:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    cecb:	8b 45 10             	mov    0x10(%ebp),%eax
    cece:	8b 40 14             	mov    0x14(%eax),%eax
    ced1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    ced4:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    ced8:	7e 21                	jle    cefb <auto_choose_color+0xd1>
    ceda:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    cede:	7e 14                	jle    cef4 <auto_choose_color+0xca>
    cee0:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    cee4:	7f 07                	jg     ceed <auto_choose_color+0xc3>
    cee6:	b8 04 00 00 00       	mov    $0x4,%eax
    ceeb:	eb 13                	jmp    cf00 <auto_choose_color+0xd6>
    ceed:	b8 08 00 00 00       	mov    $0x8,%eax
    cef2:	eb 0c                	jmp    cf00 <auto_choose_color+0xd6>
    cef4:	b8 02 00 00 00       	mov    $0x2,%eax
    cef9:	eb 05                	jmp    cf00 <auto_choose_color+0xd6>
    cefb:	b8 01 00 00 00       	mov    $0x1,%eax
    cf00:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    cf03:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    cf0a:	7f 13                	jg     cf1f <auto_choose_color+0xf5>
    cf0c:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    cf10:	77 0d                	ja     cf1f <auto_choose_color+0xf5>
    cf12:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    cf16:	74 07                	je     cf1f <auto_choose_color+0xf5>
    cf18:	b8 01 00 00 00       	mov    $0x1,%eax
    cf1d:	eb 05                	jmp    cf24 <auto_choose_color+0xfa>
    cf1f:	b8 00 00 00 00       	mov    $0x0,%eax
    cf24:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    cf27:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    cf2a:	01 c0                	add    %eax,%eax
    cf2c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cf2f:	7e 07                	jle    cf38 <auto_choose_color+0x10e>
    cf31:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    cf38:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cf3c:	74 15                	je     cf53 <auto_choose_color+0x129>
    cf3e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cf42:	75 0f                	jne    cf53 <auto_choose_color+0x129>
    cf44:	8b 45 dc             	mov    -0x24(%ebp),%eax
    cf47:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    cf4a:	77 07                	ja     cf53 <auto_choose_color+0x129>
    cf4c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    cf53:	8b 45 10             	mov    0x10(%ebp),%eax
    cf56:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    cf5c:	85 c0                	test   %eax,%eax
    cf5e:	75 07                	jne    cf67 <auto_choose_color+0x13d>
    cf60:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    cf67:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cf6b:	0f 84 0a 01 00 00    	je     d07b <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    cf71:	8b 45 10             	mov    0x10(%ebp),%eax
    cf74:	83 c0 18             	add    $0x18,%eax
    cf77:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    cf7a:	83 ec 0c             	sub    $0xc,%esp
    cf7d:	ff 75 08             	pushl  0x8(%ebp)
    cf80:	e8 ef be ff ff       	call   8e74 <lodepng_palette_clear>
    cf85:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    cf88:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    cf8f:	eb 6e                	jmp    cfff <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    cf91:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cf94:	c1 e0 02             	shl    $0x2,%eax
    cf97:	8d 50 03             	lea    0x3(%eax),%edx
    cf9a:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cf9d:	01 d0                	add    %edx,%eax
    cf9f:	0f b6 00             	movzbl (%eax),%eax
    cfa2:	0f b6 d8             	movzbl %al,%ebx
    cfa5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cfa8:	c1 e0 02             	shl    $0x2,%eax
    cfab:	8d 50 02             	lea    0x2(%eax),%edx
    cfae:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cfb1:	01 d0                	add    %edx,%eax
    cfb3:	0f b6 00             	movzbl (%eax),%eax
    cfb6:	0f b6 c8             	movzbl %al,%ecx
    cfb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cfbc:	c1 e0 02             	shl    $0x2,%eax
    cfbf:	8d 50 01             	lea    0x1(%eax),%edx
    cfc2:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cfc5:	01 d0                	add    %edx,%eax
    cfc7:	0f b6 00             	movzbl (%eax),%eax
    cfca:	0f b6 d0             	movzbl %al,%edx
    cfcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    cfd0:	c1 e0 02             	shl    $0x2,%eax
    cfd3:	89 c6                	mov    %eax,%esi
    cfd5:	8b 45 cc             	mov    -0x34(%ebp),%eax
    cfd8:	01 f0                	add    %esi,%eax
    cfda:	0f b6 00             	movzbl (%eax),%eax
    cfdd:	0f b6 c0             	movzbl %al,%eax
    cfe0:	83 ec 0c             	sub    $0xc,%esp
    cfe3:	53                   	push   %ebx
    cfe4:	51                   	push   %ecx
    cfe5:	52                   	push   %edx
    cfe6:	50                   	push   %eax
    cfe7:	ff 75 08             	pushl  0x8(%ebp)
    cfea:	e8 be be ff ff       	call   8ead <lodepng_palette_add>
    cfef:	83 c4 20             	add    $0x20,%esp
    cff2:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    cff5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    cff9:	75 13                	jne    d00e <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    cffb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    cfff:	8b 45 10             	mov    0x10(%ebp),%eax
    d002:	8b 50 14             	mov    0x14(%eax),%edx
    d005:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d008:	39 c2                	cmp    %eax,%edx
    d00a:	75 85                	jne    cf91 <auto_choose_color+0x167>
    d00c:	eb 01                	jmp    d00f <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    d00e:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    d00f:	8b 45 08             	mov    0x8(%ebp),%eax
    d012:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    d018:	8b 45 08             	mov    0x8(%ebp),%eax
    d01b:	8b 55 d0             	mov    -0x30(%ebp),%edx
    d01e:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    d021:	8b 45 0c             	mov    0xc(%ebp),%eax
    d024:	8b 00                	mov    (%eax),%eax
    d026:	83 f8 03             	cmp    $0x3,%eax
    d029:	0f 85 ec 00 00 00    	jne    d11b <auto_choose_color+0x2f1>
    d02f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d032:	8b 50 0c             	mov    0xc(%eax),%edx
    d035:	8b 45 08             	mov    0x8(%ebp),%eax
    d038:	8b 40 0c             	mov    0xc(%eax),%eax
    d03b:	39 c2                	cmp    %eax,%edx
    d03d:	0f 8c d8 00 00 00    	jl     d11b <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    d043:	8b 45 0c             	mov    0xc(%ebp),%eax
    d046:	8b 50 04             	mov    0x4(%eax),%edx
    d049:	8b 45 08             	mov    0x8(%ebp),%eax
    d04c:	8b 40 04             	mov    0x4(%eax),%eax
    d04f:	39 c2                	cmp    %eax,%edx
    d051:	0f 85 c4 00 00 00    	jne    d11b <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    d057:	83 ec 0c             	sub    $0xc,%esp
    d05a:	ff 75 08             	pushl  0x8(%ebp)
    d05d:	e8 0e bc ff ff       	call   8c70 <lodepng_color_mode_cleanup>
    d062:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    d065:	83 ec 08             	sub    $0x8,%esp
    d068:	ff 75 0c             	pushl  0xc(%ebp)
    d06b:	ff 75 08             	pushl  0x8(%ebp)
    d06e:	e8 14 bc ff ff       	call   8c87 <lodepng_color_mode_copy>
    d073:	83 c4 10             	add    $0x10,%esp
    d076:	e9 a0 00 00 00       	jmp    d11b <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    d07b:	8b 45 08             	mov    0x8(%ebp),%eax
    d07e:	8b 55 dc             	mov    -0x24(%ebp),%edx
    d081:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    d084:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d088:	74 14                	je     d09e <auto_choose_color+0x274>
    d08a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d08e:	74 07                	je     d097 <auto_choose_color+0x26d>
    d090:	b8 04 00 00 00       	mov    $0x4,%eax
    d095:	eb 19                	jmp    d0b0 <auto_choose_color+0x286>
    d097:	b8 06 00 00 00       	mov    $0x6,%eax
    d09c:	eb 12                	jmp    d0b0 <auto_choose_color+0x286>
    d09e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d0a2:	74 07                	je     d0ab <auto_choose_color+0x281>
    d0a4:	b8 00 00 00 00       	mov    $0x0,%eax
    d0a9:	eb 05                	jmp    d0b0 <auto_choose_color+0x286>
    d0ab:	b8 02 00 00 00       	mov    $0x2,%eax
    d0b0:	8b 55 08             	mov    0x8(%ebp),%edx
    d0b3:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    d0b5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d0b9:	74 60                	je     d11b <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    d0bb:	8b 45 08             	mov    0x8(%ebp),%eax
    d0be:	8b 40 04             	mov    0x4(%eax),%eax
    d0c1:	ba 01 00 00 00       	mov    $0x1,%edx
    d0c6:	89 c1                	mov    %eax,%ecx
    d0c8:	d3 e2                	shl    %cl,%edx
    d0ca:	89 d0                	mov    %edx,%eax
    d0cc:	83 e8 01             	sub    $0x1,%eax
    d0cf:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    d0d2:	8b 45 10             	mov    0x10(%ebp),%eax
    d0d5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d0d9:	0f b7 c0             	movzwl %ax,%eax
    d0dc:	23 45 c8             	and    -0x38(%ebp),%eax
    d0df:	89 c2                	mov    %eax,%edx
    d0e1:	8b 45 08             	mov    0x8(%ebp),%eax
    d0e4:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    d0e7:	8b 45 10             	mov    0x10(%ebp),%eax
    d0ea:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d0ee:	0f b7 c0             	movzwl %ax,%eax
    d0f1:	23 45 c8             	and    -0x38(%ebp),%eax
    d0f4:	89 c2                	mov    %eax,%edx
    d0f6:	8b 45 08             	mov    0x8(%ebp),%eax
    d0f9:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    d0fc:	8b 45 10             	mov    0x10(%ebp),%eax
    d0ff:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d103:	0f b7 c0             	movzwl %ax,%eax
    d106:	23 45 c8             	and    -0x38(%ebp),%eax
    d109:	89 c2                	mov    %eax,%edx
    d10b:	8b 45 08             	mov    0x8(%ebp),%eax
    d10e:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    d111:	8b 45 08             	mov    0x8(%ebp),%eax
    d114:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    d11b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    d11e:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d121:	5b                   	pop    %ebx
    d122:	5e                   	pop    %esi
    d123:	5d                   	pop    %ebp
    d124:	c3                   	ret    

0000d125 <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    d125:	55                   	push   %ebp
    d126:	89 e5                	mov    %esp,%ebp
    d128:	83 ec 1c             	sub    $0x1c,%esp
    d12b:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d12e:	8b 55 0c             	mov    0xc(%ebp),%edx
    d131:	8b 45 10             	mov    0x10(%ebp),%eax
    d134:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    d138:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    d13c:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    d140:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    d144:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d148:	29 c2                	sub    %eax,%edx
    d14a:	89 d0                	mov    %edx,%eax
    d14c:	99                   	cltd   
    d14d:	31 d0                	xor    %edx,%eax
    d14f:	29 d0                	sub    %edx,%eax
    d151:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    d155:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d159:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d15d:	29 c2                	sub    %eax,%edx
    d15f:	89 d0                	mov    %edx,%eax
    d161:	99                   	cltd   
    d162:	31 d0                	xor    %edx,%eax
    d164:	29 d0                	sub    %edx,%eax
    d166:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    d16a:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d16e:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    d172:	01 c2                	add    %eax,%edx
    d174:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d178:	29 c2                	sub    %eax,%edx
    d17a:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d17e:	29 c2                	sub    %eax,%edx
    d180:	89 d0                	mov    %edx,%eax
    d182:	99                   	cltd   
    d183:	31 d0                	xor    %edx,%eax
    d185:	29 d0                	sub    %edx,%eax
    d187:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    d18b:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d18f:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d193:	7d 10                	jge    d1a5 <paethPredictor+0x80>
    d195:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    d199:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    d19d:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d1a1:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    d1a5:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    d1a9:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d1ad:	7d 06                	jge    d1b5 <paethPredictor+0x90>
    d1af:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    d1b3:	eb 04                	jmp    d1b9 <paethPredictor+0x94>
    d1b5:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    d1b9:	c9                   	leave  
    d1ba:	c3                   	ret    

0000d1bb <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    d1bb:	55                   	push   %ebp
    d1bc:	89 e5                	mov    %esp,%ebp
    d1be:	56                   	push   %esi
    d1bf:	53                   	push   %ebx
    d1c0:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d1c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d1ca:	e9 e2 00 00 00       	jmp    d2b1 <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    d1cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1d2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d1d9:	8b 45 08             	mov    0x8(%ebp),%eax
    d1dc:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d1df:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1e2:	8b 14 85 54 a1 01 00 	mov    0x1a154(,%eax,4),%edx
    d1e9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d1ec:	01 c2                	add    %eax,%edx
    d1ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d1f1:	8b 04 85 1c a1 01 00 	mov    0x1a11c(,%eax,4),%eax
    d1f8:	29 c2                	sub    %eax,%edx
    d1fa:	89 d0                	mov    %edx,%eax
    d1fc:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d1ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d202:	8b 34 85 54 a1 01 00 	mov    0x1a154(,%eax,4),%esi
    d209:	89 d8                	mov    %ebx,%eax
    d20b:	ba 00 00 00 00       	mov    $0x0,%edx
    d210:	f7 f6                	div    %esi
    d212:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    d214:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d217:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d21e:	8b 45 0c             	mov    0xc(%ebp),%eax
    d221:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d224:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d227:	8b 14 85 70 a1 01 00 	mov    0x1a170(,%eax,4),%edx
    d22e:	8b 45 20             	mov    0x20(%ebp),%eax
    d231:	01 c2                	add    %eax,%edx
    d233:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d236:	8b 04 85 38 a1 01 00 	mov    0x1a138(,%eax,4),%eax
    d23d:	29 c2                	sub    %eax,%edx
    d23f:	89 d0                	mov    %edx,%eax
    d241:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d244:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d247:	8b 34 85 70 a1 01 00 	mov    0x1a170(,%eax,4),%esi
    d24e:	89 d8                	mov    %ebx,%eax
    d250:	ba 00 00 00 00       	mov    $0x0,%edx
    d255:	f7 f6                	div    %esi
    d257:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    d259:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d25c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d263:	8b 45 08             	mov    0x8(%ebp),%eax
    d266:	01 d0                	add    %edx,%eax
    d268:	8b 00                	mov    (%eax),%eax
    d26a:	85 c0                	test   %eax,%eax
    d26c:	75 15                	jne    d283 <Adam7_getpassvalues+0xc8>
    d26e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d271:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d278:	8b 45 0c             	mov    0xc(%ebp),%eax
    d27b:	01 d0                	add    %edx,%eax
    d27d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    d283:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d286:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d28d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d290:	01 d0                	add    %edx,%eax
    d292:	8b 00                	mov    (%eax),%eax
    d294:	85 c0                	test   %eax,%eax
    d296:	75 15                	jne    d2ad <Adam7_getpassvalues+0xf2>
    d298:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d29b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d2a2:	8b 45 08             	mov    0x8(%ebp),%eax
    d2a5:	01 d0                	add    %edx,%eax
    d2a7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d2ad:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d2b1:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d2b5:	0f 85 14 ff ff ff    	jne    d1cf <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    d2bb:	8b 45 18             	mov    0x18(%ebp),%eax
    d2be:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d2c4:	8b 45 18             	mov    0x18(%ebp),%eax
    d2c7:	8b 10                	mov    (%eax),%edx
    d2c9:	8b 45 14             	mov    0x14(%ebp),%eax
    d2cc:	89 10                	mov    %edx,(%eax)
    d2ce:	8b 45 14             	mov    0x14(%ebp),%eax
    d2d1:	8b 10                	mov    (%eax),%edx
    d2d3:	8b 45 10             	mov    0x10(%ebp),%eax
    d2d6:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    d2d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d2df:	e9 40 01 00 00       	jmp    d424 <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d2e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2e7:	83 c0 01             	add    $0x1,%eax
    d2ea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d2f1:	8b 45 10             	mov    0x10(%ebp),%eax
    d2f4:	01 c2                	add    %eax,%edx
    d2f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d2f9:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d300:	8b 45 10             	mov    0x10(%ebp),%eax
    d303:	01 c8                	add    %ecx,%eax
    d305:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    d307:	89 c6                	mov    %eax,%esi
    d309:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d30c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d313:	8b 45 08             	mov    0x8(%ebp),%eax
    d316:	01 c8                	add    %ecx,%eax
    d318:	8b 00                	mov    (%eax),%eax
    d31a:	85 c0                	test   %eax,%eax
    d31c:	74 49                	je     d367 <Adam7_getpassvalues+0x1ac>
    d31e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d321:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d328:	8b 45 0c             	mov    0xc(%ebp),%eax
    d32b:	01 c8                	add    %ecx,%eax
    d32d:	8b 00                	mov    (%eax),%eax
    d32f:	85 c0                	test   %eax,%eax
    d331:	74 34                	je     d367 <Adam7_getpassvalues+0x1ac>
    d333:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d336:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d33d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d340:	01 c8                	add    %ecx,%eax
    d342:	8b 08                	mov    (%eax),%ecx
    d344:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d347:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d34e:	8b 45 08             	mov    0x8(%ebp),%eax
    d351:	01 d8                	add    %ebx,%eax
    d353:	8b 00                	mov    (%eax),%eax
    d355:	0f af 45 24          	imul   0x24(%ebp),%eax
    d359:	83 c0 07             	add    $0x7,%eax
    d35c:	c1 e8 03             	shr    $0x3,%eax
    d35f:	83 c0 01             	add    $0x1,%eax
    d362:	0f af c1             	imul   %ecx,%eax
    d365:	eb 05                	jmp    d36c <Adam7_getpassvalues+0x1b1>
    d367:	b8 00 00 00 00       	mov    $0x0,%eax
    d36c:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d36e:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    d370:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d373:	83 c0 01             	add    $0x1,%eax
    d376:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d37d:	8b 45 14             	mov    0x14(%ebp),%eax
    d380:	01 c2                	add    %eax,%edx
    d382:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d385:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d38c:	8b 45 14             	mov    0x14(%ebp),%eax
    d38f:	01 c8                	add    %ecx,%eax
    d391:	8b 00                	mov    (%eax),%eax
    d393:	89 c6                	mov    %eax,%esi
    d395:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d398:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d39f:	8b 45 0c             	mov    0xc(%ebp),%eax
    d3a2:	01 c8                	add    %ecx,%eax
    d3a4:	8b 08                	mov    (%eax),%ecx
    d3a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3a9:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d3b0:	8b 45 08             	mov    0x8(%ebp),%eax
    d3b3:	01 d8                	add    %ebx,%eax
    d3b5:	8b 00                	mov    (%eax),%eax
    d3b7:	0f af 45 24          	imul   0x24(%ebp),%eax
    d3bb:	83 c0 07             	add    $0x7,%eax
    d3be:	c1 e8 03             	shr    $0x3,%eax
    d3c1:	0f af c1             	imul   %ecx,%eax
    d3c4:	01 f0                	add    %esi,%eax
    d3c6:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    d3c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3cb:	83 c0 01             	add    $0x1,%eax
    d3ce:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d3d5:	8b 45 18             	mov    0x18(%ebp),%eax
    d3d8:	01 c2                	add    %eax,%edx
    d3da:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3dd:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d3e4:	8b 45 18             	mov    0x18(%ebp),%eax
    d3e7:	01 c8                	add    %ecx,%eax
    d3e9:	8b 00                	mov    (%eax),%eax
    d3eb:	89 c6                	mov    %eax,%esi
    d3ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3f0:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d3f7:	8b 45 0c             	mov    0xc(%ebp),%eax
    d3fa:	01 c8                	add    %ecx,%eax
    d3fc:	8b 08                	mov    (%eax),%ecx
    d3fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d401:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d408:	8b 45 08             	mov    0x8(%ebp),%eax
    d40b:	01 d8                	add    %ebx,%eax
    d40d:	8b 00                	mov    (%eax),%eax
    d40f:	0f af c1             	imul   %ecx,%eax
    d412:	0f af 45 24          	imul   0x24(%ebp),%eax
    d416:	83 c0 07             	add    $0x7,%eax
    d419:	c1 e8 03             	shr    $0x3,%eax
    d41c:	01 f0                	add    %esi,%eax
    d41e:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    d420:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d424:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d428:	0f 85 b6 fe ff ff    	jne    d2e4 <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    d42e:	90                   	nop
    d42f:	83 c4 10             	add    $0x10,%esp
    d432:	5b                   	pop    %ebx
    d433:	5e                   	pop    %esi
    d434:	5d                   	pop    %ebp
    d435:	c3                   	ret    

0000d436 <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    d436:	55                   	push   %ebp
    d437:	89 e5                	mov    %esp,%ebp
    d439:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    d43c:	8b 45 10             	mov    0x10(%ebp),%eax
    d43f:	05 98 00 00 00       	add    $0x98,%eax
    d444:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    d447:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    d44b:	74 06                	je     d453 <lodepng_inspect+0x1d>
    d44d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d451:	75 17                	jne    d46a <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    d453:	8b 45 10             	mov    0x10(%ebp),%eax
    d456:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    d45d:	00 00 00 
    d460:	b8 30 00 00 00       	mov    $0x30,%eax
    d465:	e9 ce 02 00 00       	jmp    d738 <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    d46a:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    d46e:	7f 17                	jg     d487 <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    d470:	8b 45 10             	mov    0x10(%ebp),%eax
    d473:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    d47a:	00 00 00 
    d47d:	b8 1b 00 00 00       	mov    $0x1b,%eax
    d482:	e9 b1 02 00 00       	jmp    d738 <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    d487:	83 ec 0c             	sub    $0xc,%esp
    d48a:	ff 75 f4             	pushl  -0xc(%ebp)
    d48d:	e8 63 c7 ff ff       	call   9bf5 <lodepng_info_cleanup>
    d492:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    d495:	83 ec 0c             	sub    $0xc,%esp
    d498:	ff 75 f4             	pushl  -0xc(%ebp)
    d49b:	e8 74 c6 ff ff       	call   9b14 <lodepng_info_init>
    d4a0:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    d4a3:	8b 45 14             	mov    0x14(%ebp),%eax
    d4a6:	0f b6 00             	movzbl (%eax),%eax
    d4a9:	3c 89                	cmp    $0x89,%al
    d4ab:	75 5b                	jne    d508 <lodepng_inspect+0xd2>
    d4ad:	8b 45 14             	mov    0x14(%ebp),%eax
    d4b0:	83 c0 01             	add    $0x1,%eax
    d4b3:	0f b6 00             	movzbl (%eax),%eax
    d4b6:	3c 50                	cmp    $0x50,%al
    d4b8:	75 4e                	jne    d508 <lodepng_inspect+0xd2>
    d4ba:	8b 45 14             	mov    0x14(%ebp),%eax
    d4bd:	83 c0 02             	add    $0x2,%eax
    d4c0:	0f b6 00             	movzbl (%eax),%eax
    d4c3:	3c 4e                	cmp    $0x4e,%al
    d4c5:	75 41                	jne    d508 <lodepng_inspect+0xd2>
    d4c7:	8b 45 14             	mov    0x14(%ebp),%eax
    d4ca:	83 c0 03             	add    $0x3,%eax
    d4cd:	0f b6 00             	movzbl (%eax),%eax
    d4d0:	3c 47                	cmp    $0x47,%al
    d4d2:	75 34                	jne    d508 <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    d4d4:	8b 45 14             	mov    0x14(%ebp),%eax
    d4d7:	83 c0 04             	add    $0x4,%eax
    d4da:	0f b6 00             	movzbl (%eax),%eax
    d4dd:	3c 0d                	cmp    $0xd,%al
    d4df:	75 27                	jne    d508 <lodepng_inspect+0xd2>
    d4e1:	8b 45 14             	mov    0x14(%ebp),%eax
    d4e4:	83 c0 05             	add    $0x5,%eax
    d4e7:	0f b6 00             	movzbl (%eax),%eax
    d4ea:	3c 0a                	cmp    $0xa,%al
    d4ec:	75 1a                	jne    d508 <lodepng_inspect+0xd2>
    d4ee:	8b 45 14             	mov    0x14(%ebp),%eax
    d4f1:	83 c0 06             	add    $0x6,%eax
    d4f4:	0f b6 00             	movzbl (%eax),%eax
    d4f7:	3c 1a                	cmp    $0x1a,%al
    d4f9:	75 0d                	jne    d508 <lodepng_inspect+0xd2>
    d4fb:	8b 45 14             	mov    0x14(%ebp),%eax
    d4fe:	83 c0 07             	add    $0x7,%eax
    d501:	0f b6 00             	movzbl (%eax),%eax
    d504:	3c 0a                	cmp    $0xa,%al
    d506:	74 17                	je     d51f <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    d508:	8b 45 10             	mov    0x10(%ebp),%eax
    d50b:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    d512:	00 00 00 
    d515:	b8 1c 00 00 00       	mov    $0x1c,%eax
    d51a:	e9 19 02 00 00       	jmp    d738 <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    d51f:	8b 45 14             	mov    0x14(%ebp),%eax
    d522:	83 c0 08             	add    $0x8,%eax
    d525:	83 ec 0c             	sub    $0xc,%esp
    d528:	50                   	push   %eax
    d529:	e8 c2 ae ff ff       	call   83f0 <lodepng_chunk_length>
    d52e:	83 c4 10             	add    $0x10,%esp
    d531:	83 f8 0d             	cmp    $0xd,%eax
    d534:	74 17                	je     d54d <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    d536:	8b 45 10             	mov    0x10(%ebp),%eax
    d539:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    d540:	00 00 00 
    d543:	b8 5e 00 00 00       	mov    $0x5e,%eax
    d548:	e9 eb 01 00 00       	jmp    d738 <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    d54d:	8b 45 14             	mov    0x14(%ebp),%eax
    d550:	83 c0 08             	add    $0x8,%eax
    d553:	83 ec 08             	sub    $0x8,%esp
    d556:	68 8c a1 01 00       	push   $0x1a18c
    d55b:	50                   	push   %eax
    d55c:	e8 dc ae ff ff       	call   843d <lodepng_chunk_type_equals>
    d561:	83 c4 10             	add    $0x10,%esp
    d564:	84 c0                	test   %al,%al
    d566:	75 17                	jne    d57f <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    d568:	8b 45 10             	mov    0x10(%ebp),%eax
    d56b:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    d572:	00 00 00 
    d575:	b8 1d 00 00 00       	mov    $0x1d,%eax
    d57a:	e9 b9 01 00 00       	jmp    d738 <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    d57f:	8b 45 14             	mov    0x14(%ebp),%eax
    d582:	83 c0 10             	add    $0x10,%eax
    d585:	83 ec 0c             	sub    $0xc,%esp
    d588:	50                   	push   %eax
    d589:	e8 5e 62 ff ff       	call   37ec <lodepng_read32bitInt>
    d58e:	83 c4 10             	add    $0x10,%esp
    d591:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    d594:	8b 45 14             	mov    0x14(%ebp),%eax
    d597:	83 c0 14             	add    $0x14,%eax
    d59a:	83 ec 0c             	sub    $0xc,%esp
    d59d:	50                   	push   %eax
    d59e:	e8 49 62 ff ff       	call   37ec <lodepng_read32bitInt>
    d5a3:	83 c4 10             	add    $0x10,%esp
    d5a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    d5a9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    d5ad:	74 08                	je     d5b7 <lodepng_inspect+0x181>
    d5af:	8b 45 08             	mov    0x8(%ebp),%eax
    d5b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d5b5:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    d5b7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    d5bb:	74 08                	je     d5c5 <lodepng_inspect+0x18f>
    d5bd:	8b 45 0c             	mov    0xc(%ebp),%eax
    d5c0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d5c3:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    d5c5:	8b 45 14             	mov    0x14(%ebp),%eax
    d5c8:	83 c0 18             	add    $0x18,%eax
    d5cb:	0f b6 00             	movzbl (%eax),%eax
    d5ce:	0f b6 d0             	movzbl %al,%edx
    d5d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5d4:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    d5d7:	8b 45 14             	mov    0x14(%ebp),%eax
    d5da:	83 c0 19             	add    $0x19,%eax
    d5dd:	0f b6 00             	movzbl (%eax),%eax
    d5e0:	0f b6 d0             	movzbl %al,%edx
    d5e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5e6:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    d5e9:	8b 45 14             	mov    0x14(%ebp),%eax
    d5ec:	83 c0 1a             	add    $0x1a,%eax
    d5ef:	0f b6 00             	movzbl (%eax),%eax
    d5f2:	0f b6 d0             	movzbl %al,%edx
    d5f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d5f8:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    d5fa:	8b 45 14             	mov    0x14(%ebp),%eax
    d5fd:	83 c0 1b             	add    $0x1b,%eax
    d600:	0f b6 00             	movzbl (%eax),%eax
    d603:	0f b6 d0             	movzbl %al,%edx
    d606:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d609:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    d60c:	8b 45 14             	mov    0x14(%ebp),%eax
    d60f:	83 c0 1c             	add    $0x1c,%eax
    d612:	0f b6 00             	movzbl (%eax),%eax
    d615:	0f b6 d0             	movzbl %al,%edx
    d618:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d61b:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    d61e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d622:	74 06                	je     d62a <lodepng_inspect+0x1f4>
    d624:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d628:	75 17                	jne    d641 <lodepng_inspect+0x20b>
    d62a:	8b 45 10             	mov    0x10(%ebp),%eax
    d62d:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    d634:	00 00 00 
    d637:	b8 5d 00 00 00       	mov    $0x5d,%eax
    d63c:	e9 f7 00 00 00       	jmp    d738 <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    d641:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d644:	8b 50 10             	mov    0x10(%eax),%edx
    d647:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d64a:	8b 40 0c             	mov    0xc(%eax),%eax
    d64d:	83 ec 08             	sub    $0x8,%esp
    d650:	52                   	push   %edx
    d651:	50                   	push   %eax
    d652:	e8 d4 b3 ff ff       	call   8a2b <checkColorValidity>
    d657:	83 c4 10             	add    $0x10,%esp
    d65a:	89 c2                	mov    %eax,%edx
    d65c:	8b 45 10             	mov    0x10(%ebp),%eax
    d65f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    d665:	8b 45 10             	mov    0x10(%ebp),%eax
    d668:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d66e:	85 c0                	test   %eax,%eax
    d670:	74 0e                	je     d680 <lodepng_inspect+0x24a>
    d672:	8b 45 10             	mov    0x10(%ebp),%eax
    d675:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d67b:	e9 b8 00 00 00       	jmp    d738 <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    d680:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d683:	8b 00                	mov    (%eax),%eax
    d685:	85 c0                	test   %eax,%eax
    d687:	74 17                	je     d6a0 <lodepng_inspect+0x26a>
    d689:	8b 45 10             	mov    0x10(%ebp),%eax
    d68c:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    d693:	00 00 00 
    d696:	b8 20 00 00 00       	mov    $0x20,%eax
    d69b:	e9 98 00 00 00       	jmp    d738 <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    d6a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6a3:	8b 40 04             	mov    0x4(%eax),%eax
    d6a6:	85 c0                	test   %eax,%eax
    d6a8:	74 14                	je     d6be <lodepng_inspect+0x288>
    d6aa:	8b 45 10             	mov    0x10(%ebp),%eax
    d6ad:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    d6b4:	00 00 00 
    d6b7:	b8 21 00 00 00       	mov    $0x21,%eax
    d6bc:	eb 7a                	jmp    d738 <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    d6be:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d6c1:	8b 40 08             	mov    0x8(%eax),%eax
    d6c4:	83 f8 01             	cmp    $0x1,%eax
    d6c7:	76 14                	jbe    d6dd <lodepng_inspect+0x2a7>
    d6c9:	8b 45 10             	mov    0x10(%ebp),%eax
    d6cc:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    d6d3:	00 00 00 
    d6d6:	b8 22 00 00 00       	mov    $0x22,%eax
    d6db:	eb 5b                	jmp    d738 <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    d6dd:	8b 45 10             	mov    0x10(%ebp),%eax
    d6e0:	8b 40 18             	mov    0x18(%eax),%eax
    d6e3:	85 c0                	test   %eax,%eax
    d6e5:	75 48                	jne    d72f <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    d6e7:	8b 45 14             	mov    0x14(%ebp),%eax
    d6ea:	83 c0 1d             	add    $0x1d,%eax
    d6ed:	83 ec 0c             	sub    $0xc,%esp
    d6f0:	50                   	push   %eax
    d6f1:	e8 f6 60 ff ff       	call   37ec <lodepng_read32bitInt>
    d6f6:	83 c4 10             	add    $0x10,%esp
    d6f9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    d6fc:	8b 45 14             	mov    0x14(%ebp),%eax
    d6ff:	83 c0 0c             	add    $0xc,%eax
    d702:	83 ec 08             	sub    $0x8,%esp
    d705:	6a 11                	push   $0x11
    d707:	50                   	push   %eax
    d708:	e8 71 ab ff ff       	call   827e <lodepng_crc32>
    d70d:	83 c4 10             	add    $0x10,%esp
    d710:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    d713:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d716:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    d719:	74 14                	je     d72f <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    d71b:	8b 45 10             	mov    0x10(%ebp),%eax
    d71e:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    d725:	00 00 00 
    d728:	b8 39 00 00 00       	mov    $0x39,%eax
    d72d:	eb 09                	jmp    d738 <lodepng_inspect+0x302>
    }
  }

  return state->error;
    d72f:	8b 45 10             	mov    0x10(%ebp),%eax
    d732:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    d738:	c9                   	leave  
    d739:	c3                   	ret    

0000d73a <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    d73a:	55                   	push   %ebp
    d73b:	89 e5                	mov    %esp,%ebp
    d73d:	56                   	push   %esi
    d73e:	53                   	push   %ebx
    d73f:	83 ec 44             	sub    $0x44,%esp
    d742:	8b 45 18             	mov    0x18(%ebp),%eax
    d745:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    d748:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    d74c:	83 f8 04             	cmp    $0x4,%eax
    d74f:	0f 87 81 07 00 00    	ja     ded6 <unfilterScanline+0x79c>
    d755:	8b 04 85 94 a1 01 00 	mov    0x1a194(,%eax,4),%eax
    d75c:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d75e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d765:	eb 19                	jmp    d780 <unfilterScanline+0x46>
    d767:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d76a:	8b 45 08             	mov    0x8(%ebp),%eax
    d76d:	01 c2                	add    %eax,%edx
    d76f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d772:	8b 45 0c             	mov    0xc(%ebp),%eax
    d775:	01 c8                	add    %ecx,%eax
    d777:	0f b6 00             	movzbl (%eax),%eax
    d77a:	88 02                	mov    %al,(%edx)
    d77c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d780:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d783:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d786:	75 df                	jne    d767 <unfilterScanline+0x2d>
      break;
    d788:	e9 50 07 00 00       	jmp    dedd <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d78d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d794:	eb 19                	jmp    d7af <unfilterScanline+0x75>
    d796:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d799:	8b 45 08             	mov    0x8(%ebp),%eax
    d79c:	01 c2                	add    %eax,%edx
    d79e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7a4:	01 c8                	add    %ecx,%eax
    d7a6:	0f b6 00             	movzbl (%eax),%eax
    d7a9:	88 02                	mov    %al,(%edx)
    d7ab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7af:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7b2:	3b 45 14             	cmp    0x14(%ebp),%eax
    d7b5:	75 df                	jne    d796 <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    d7b7:	8b 45 14             	mov    0x14(%ebp),%eax
    d7ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d7bd:	eb 2b                	jmp    d7ea <unfilterScanline+0xb0>
    d7bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d7c2:	8b 45 08             	mov    0x8(%ebp),%eax
    d7c5:	01 c2                	add    %eax,%edx
    d7c7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d7ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    d7cd:	01 c8                	add    %ecx,%eax
    d7cf:	0f b6 08             	movzbl (%eax),%ecx
    d7d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7d5:	2b 45 14             	sub    0x14(%ebp),%eax
    d7d8:	89 c3                	mov    %eax,%ebx
    d7da:	8b 45 08             	mov    0x8(%ebp),%eax
    d7dd:	01 d8                	add    %ebx,%eax
    d7df:	0f b6 00             	movzbl (%eax),%eax
    d7e2:	01 c8                	add    %ecx,%eax
    d7e4:	88 02                	mov    %al,(%edx)
    d7e6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d7ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7ed:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d7f0:	7c cd                	jl     d7bf <unfilterScanline+0x85>
      break;
    d7f2:	e9 e6 06 00 00       	jmp    dedd <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    d7f7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d7fb:	74 3c                	je     d839 <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    d7fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d804:	eb 26                	jmp    d82c <unfilterScanline+0xf2>
    d806:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d809:	8b 45 08             	mov    0x8(%ebp),%eax
    d80c:	01 d0                	add    %edx,%eax
    d80e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d811:	8b 55 0c             	mov    0xc(%ebp),%edx
    d814:	01 ca                	add    %ecx,%edx
    d816:	0f b6 0a             	movzbl (%edx),%ecx
    d819:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d81c:	8b 55 10             	mov    0x10(%ebp),%edx
    d81f:	01 da                	add    %ebx,%edx
    d821:	0f b6 12             	movzbl (%edx),%edx
    d824:	01 ca                	add    %ecx,%edx
    d826:	88 10                	mov    %dl,(%eax)
    d828:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d82c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d82f:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d832:	75 d2                	jne    d806 <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    d834:	e9 a4 06 00 00       	jmp    dedd <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d839:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d840:	eb 19                	jmp    d85b <unfilterScanline+0x121>
    d842:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d845:	8b 45 08             	mov    0x8(%ebp),%eax
    d848:	01 c2                	add    %eax,%edx
    d84a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d84d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d850:	01 c8                	add    %ecx,%eax
    d852:	0f b6 00             	movzbl (%eax),%eax
    d855:	88 02                	mov    %al,(%edx)
    d857:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d85b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d85e:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d861:	75 df                	jne    d842 <unfilterScanline+0x108>
      }
      break;
    d863:	e9 75 06 00 00       	jmp    dedd <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    d868:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d86c:	0f 84 8e 00 00 00    	je     d900 <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    d872:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d879:	eb 28                	jmp    d8a3 <unfilterScanline+0x169>
    d87b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d87e:	8b 45 08             	mov    0x8(%ebp),%eax
    d881:	01 d0                	add    %edx,%eax
    d883:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d886:	8b 55 0c             	mov    0xc(%ebp),%edx
    d889:	01 ca                	add    %ecx,%edx
    d88b:	0f b6 12             	movzbl (%edx),%edx
    d88e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d891:	8b 4d 10             	mov    0x10(%ebp),%ecx
    d894:	01 d9                	add    %ebx,%ecx
    d896:	0f b6 09             	movzbl (%ecx),%ecx
    d899:	d0 e9                	shr    %cl
    d89b:	01 ca                	add    %ecx,%edx
    d89d:	88 10                	mov    %dl,(%eax)
    d89f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d8a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8a6:	3b 45 14             	cmp    0x14(%ebp),%eax
    d8a9:	75 d0                	jne    d87b <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    d8ab:	8b 45 14             	mov    0x14(%ebp),%eax
    d8ae:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d8b1:	eb 40                	jmp    d8f3 <unfilterScanline+0x1b9>
    d8b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d8b6:	8b 45 08             	mov    0x8(%ebp),%eax
    d8b9:	01 c2                	add    %eax,%edx
    d8bb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d8be:	8b 45 0c             	mov    0xc(%ebp),%eax
    d8c1:	01 c8                	add    %ecx,%eax
    d8c3:	0f b6 08             	movzbl (%eax),%ecx
    d8c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8c9:	2b 45 14             	sub    0x14(%ebp),%eax
    d8cc:	89 c3                	mov    %eax,%ebx
    d8ce:	8b 45 08             	mov    0x8(%ebp),%eax
    d8d1:	01 d8                	add    %ebx,%eax
    d8d3:	0f b6 00             	movzbl (%eax),%eax
    d8d6:	0f b6 d8             	movzbl %al,%ebx
    d8d9:	8b 75 f4             	mov    -0xc(%ebp),%esi
    d8dc:	8b 45 10             	mov    0x10(%ebp),%eax
    d8df:	01 f0                	add    %esi,%eax
    d8e1:	0f b6 00             	movzbl (%eax),%eax
    d8e4:	0f b6 c0             	movzbl %al,%eax
    d8e7:	01 d8                	add    %ebx,%eax
    d8e9:	d1 f8                	sar    %eax
    d8eb:	01 c8                	add    %ecx,%eax
    d8ed:	88 02                	mov    %al,(%edx)
    d8ef:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d8f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8f6:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d8f9:	7c b8                	jl     d8b3 <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    d8fb:	e9 dd 05 00 00       	jmp    dedd <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d900:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d907:	eb 19                	jmp    d922 <unfilterScanline+0x1e8>
    d909:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d90c:	8b 45 08             	mov    0x8(%ebp),%eax
    d90f:	01 c2                	add    %eax,%edx
    d911:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d914:	8b 45 0c             	mov    0xc(%ebp),%eax
    d917:	01 c8                	add    %ecx,%eax
    d919:	0f b6 00             	movzbl (%eax),%eax
    d91c:	88 02                	mov    %al,(%edx)
    d91e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d922:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d925:	3b 45 14             	cmp    0x14(%ebp),%eax
    d928:	75 df                	jne    d909 <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    d92a:	8b 45 14             	mov    0x14(%ebp),%eax
    d92d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d930:	eb 2d                	jmp    d95f <unfilterScanline+0x225>
    d932:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d935:	8b 45 08             	mov    0x8(%ebp),%eax
    d938:	01 c2                	add    %eax,%edx
    d93a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d93d:	8b 45 0c             	mov    0xc(%ebp),%eax
    d940:	01 c8                	add    %ecx,%eax
    d942:	0f b6 08             	movzbl (%eax),%ecx
    d945:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d948:	2b 45 14             	sub    0x14(%ebp),%eax
    d94b:	89 c3                	mov    %eax,%ebx
    d94d:	8b 45 08             	mov    0x8(%ebp),%eax
    d950:	01 d8                	add    %ebx,%eax
    d952:	0f b6 00             	movzbl (%eax),%eax
    d955:	d0 e8                	shr    %al
    d957:	01 c8                	add    %ecx,%eax
    d959:	88 02                	mov    %al,(%edx)
    d95b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d95f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d962:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d965:	7c cb                	jl     d932 <unfilterScanline+0x1f8>
      }
      break;
    d967:	e9 71 05 00 00       	jmp    dedd <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    d96c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d970:	0f 84 f9 04 00 00    	je     de6f <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    d976:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d97d:	eb 26                	jmp    d9a5 <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    d97f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d982:	8b 45 08             	mov    0x8(%ebp),%eax
    d985:	01 d0                	add    %edx,%eax
    d987:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d98a:	8b 55 0c             	mov    0xc(%ebp),%edx
    d98d:	01 ca                	add    %ecx,%edx
    d98f:	0f b6 0a             	movzbl (%edx),%ecx
    d992:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d995:	8b 55 10             	mov    0x10(%ebp),%edx
    d998:	01 da                	add    %ebx,%edx
    d99a:	0f b6 12             	movzbl (%edx),%edx
    d99d:	01 ca                	add    %ecx,%edx
    d99f:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    d9a1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d9a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9a8:	3b 45 14             	cmp    0x14(%ebp),%eax
    d9ab:	75 d2                	jne    d97f <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    d9ad:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    d9b1:	0f 8e db 01 00 00    	jle    db92 <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    d9b7:	e9 c2 01 00 00       	jmp    db7e <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    d9bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9bf:	2b 45 14             	sub    0x14(%ebp),%eax
    d9c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    d9c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d9c8:	8b 45 0c             	mov    0xc(%ebp),%eax
    d9cb:	01 d0                	add    %edx,%eax
    d9cd:	0f b6 00             	movzbl (%eax),%eax
    d9d0:	88 45 ef             	mov    %al,-0x11(%ebp)
    d9d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9d6:	8d 50 01             	lea    0x1(%eax),%edx
    d9d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    d9dc:	01 d0                	add    %edx,%eax
    d9de:	0f b6 00             	movzbl (%eax),%eax
    d9e1:	88 45 ee             	mov    %al,-0x12(%ebp)
    d9e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9e7:	8d 50 02             	lea    0x2(%eax),%edx
    d9ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    d9ed:	01 d0                	add    %edx,%eax
    d9ef:	0f b6 00             	movzbl (%eax),%eax
    d9f2:	88 45 ed             	mov    %al,-0x13(%ebp)
    d9f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9f8:	8d 50 03             	lea    0x3(%eax),%edx
    d9fb:	8b 45 0c             	mov    0xc(%ebp),%eax
    d9fe:	01 d0                	add    %edx,%eax
    da00:	0f b6 00             	movzbl (%eax),%eax
    da03:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    da06:	8b 55 f0             	mov    -0x10(%ebp),%edx
    da09:	8b 45 08             	mov    0x8(%ebp),%eax
    da0c:	01 d0                	add    %edx,%eax
    da0e:	0f b6 00             	movzbl (%eax),%eax
    da11:	88 45 eb             	mov    %al,-0x15(%ebp)
    da14:	8b 45 f0             	mov    -0x10(%ebp),%eax
    da17:	8d 50 01             	lea    0x1(%eax),%edx
    da1a:	8b 45 08             	mov    0x8(%ebp),%eax
    da1d:	01 d0                	add    %edx,%eax
    da1f:	0f b6 00             	movzbl (%eax),%eax
    da22:	88 45 ea             	mov    %al,-0x16(%ebp)
    da25:	8b 45 f0             	mov    -0x10(%ebp),%eax
    da28:	8d 50 02             	lea    0x2(%eax),%edx
    da2b:	8b 45 08             	mov    0x8(%ebp),%eax
    da2e:	01 d0                	add    %edx,%eax
    da30:	0f b6 00             	movzbl (%eax),%eax
    da33:	88 45 e9             	mov    %al,-0x17(%ebp)
    da36:	8b 45 f0             	mov    -0x10(%ebp),%eax
    da39:	8d 50 03             	lea    0x3(%eax),%edx
    da3c:	8b 45 08             	mov    0x8(%ebp),%eax
    da3f:	01 d0                	add    %edx,%eax
    da41:	0f b6 00             	movzbl (%eax),%eax
    da44:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    da47:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da4a:	8b 45 10             	mov    0x10(%ebp),%eax
    da4d:	01 d0                	add    %edx,%eax
    da4f:	0f b6 00             	movzbl (%eax),%eax
    da52:	88 45 e7             	mov    %al,-0x19(%ebp)
    da55:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da58:	8d 50 01             	lea    0x1(%eax),%edx
    da5b:	8b 45 10             	mov    0x10(%ebp),%eax
    da5e:	01 d0                	add    %edx,%eax
    da60:	0f b6 00             	movzbl (%eax),%eax
    da63:	88 45 e6             	mov    %al,-0x1a(%ebp)
    da66:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da69:	8d 50 02             	lea    0x2(%eax),%edx
    da6c:	8b 45 10             	mov    0x10(%ebp),%eax
    da6f:	01 d0                	add    %edx,%eax
    da71:	0f b6 00             	movzbl (%eax),%eax
    da74:	88 45 e5             	mov    %al,-0x1b(%ebp)
    da77:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da7a:	8d 50 03             	lea    0x3(%eax),%edx
    da7d:	8b 45 10             	mov    0x10(%ebp),%eax
    da80:	01 d0                	add    %edx,%eax
    da82:	0f b6 00             	movzbl (%eax),%eax
    da85:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    da88:	8b 55 f0             	mov    -0x10(%ebp),%edx
    da8b:	8b 45 10             	mov    0x10(%ebp),%eax
    da8e:	01 d0                	add    %edx,%eax
    da90:	0f b6 00             	movzbl (%eax),%eax
    da93:	88 45 e3             	mov    %al,-0x1d(%ebp)
    da96:	8b 45 f0             	mov    -0x10(%ebp),%eax
    da99:	8d 50 01             	lea    0x1(%eax),%edx
    da9c:	8b 45 10             	mov    0x10(%ebp),%eax
    da9f:	01 d0                	add    %edx,%eax
    daa1:	0f b6 00             	movzbl (%eax),%eax
    daa4:	88 45 e2             	mov    %al,-0x1e(%ebp)
    daa7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    daaa:	8d 50 02             	lea    0x2(%eax),%edx
    daad:	8b 45 10             	mov    0x10(%ebp),%eax
    dab0:	01 d0                	add    %edx,%eax
    dab2:	0f b6 00             	movzbl (%eax),%eax
    dab5:	88 45 e1             	mov    %al,-0x1f(%ebp)
    dab8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dabb:	8d 50 03             	lea    0x3(%eax),%edx
    dabe:	8b 45 10             	mov    0x10(%ebp),%eax
    dac1:	01 d0                	add    %edx,%eax
    dac3:	0f b6 00             	movzbl (%eax),%eax
    dac6:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dac9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dacc:	8b 45 08             	mov    0x8(%ebp),%eax
    dacf:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dad2:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    dad6:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    dada:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    dade:	51                   	push   %ecx
    dadf:	52                   	push   %edx
    dae0:	50                   	push   %eax
    dae1:	e8 3f f6 ff ff       	call   d125 <paethPredictor>
    dae6:	83 c4 0c             	add    $0xc,%esp
    dae9:	89 c2                	mov    %eax,%edx
    daeb:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    daef:	01 d0                	add    %edx,%eax
    daf1:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    daf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    daf6:	8d 50 01             	lea    0x1(%eax),%edx
    daf9:	8b 45 08             	mov    0x8(%ebp),%eax
    dafc:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    daff:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    db03:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    db07:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    db0b:	51                   	push   %ecx
    db0c:	52                   	push   %edx
    db0d:	50                   	push   %eax
    db0e:	e8 12 f6 ff ff       	call   d125 <paethPredictor>
    db13:	83 c4 0c             	add    $0xc,%esp
    db16:	89 c2                	mov    %eax,%edx
    db18:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    db1c:	01 d0                	add    %edx,%eax
    db1e:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    db20:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db23:	8d 50 02             	lea    0x2(%eax),%edx
    db26:	8b 45 08             	mov    0x8(%ebp),%eax
    db29:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db2c:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    db30:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    db34:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    db38:	51                   	push   %ecx
    db39:	52                   	push   %edx
    db3a:	50                   	push   %eax
    db3b:	e8 e5 f5 ff ff       	call   d125 <paethPredictor>
    db40:	83 c4 0c             	add    $0xc,%esp
    db43:	89 c2                	mov    %eax,%edx
    db45:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    db49:	01 d0                	add    %edx,%eax
    db4b:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    db4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db50:	8d 50 03             	lea    0x3(%eax),%edx
    db53:	8b 45 08             	mov    0x8(%ebp),%eax
    db56:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    db59:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    db5d:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    db61:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    db65:	51                   	push   %ecx
    db66:	52                   	push   %edx
    db67:	50                   	push   %eax
    db68:	e8 b8 f5 ff ff       	call   d125 <paethPredictor>
    db6d:	83 c4 0c             	add    $0xc,%esp
    db70:	89 c2                	mov    %eax,%edx
    db72:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    db76:	01 d0                	add    %edx,%eax
    db78:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    db7a:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    db7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db81:	83 c0 03             	add    $0x3,%eax
    db84:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    db87:	0f 8c 2f fe ff ff    	jl     d9bc <unfilterScanline+0x282>
    db8d:	e9 d3 02 00 00       	jmp    de65 <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    db92:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    db96:	0f 8e 6a 01 00 00    	jle    dd06 <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    db9c:	e9 51 01 00 00       	jmp    dcf2 <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    dba1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dba4:	2b 45 14             	sub    0x14(%ebp),%eax
    dba7:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    dbaa:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dbad:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbb0:	01 d0                	add    %edx,%eax
    dbb2:	0f b6 00             	movzbl (%eax),%eax
    dbb5:	88 45 db             	mov    %al,-0x25(%ebp)
    dbb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbbb:	8d 50 01             	lea    0x1(%eax),%edx
    dbbe:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbc1:	01 d0                	add    %edx,%eax
    dbc3:	0f b6 00             	movzbl (%eax),%eax
    dbc6:	88 45 da             	mov    %al,-0x26(%ebp)
    dbc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbcc:	8d 50 02             	lea    0x2(%eax),%edx
    dbcf:	8b 45 0c             	mov    0xc(%ebp),%eax
    dbd2:	01 d0                	add    %edx,%eax
    dbd4:	0f b6 00             	movzbl (%eax),%eax
    dbd7:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    dbda:	8b 55 dc             	mov    -0x24(%ebp),%edx
    dbdd:	8b 45 08             	mov    0x8(%ebp),%eax
    dbe0:	01 d0                	add    %edx,%eax
    dbe2:	0f b6 00             	movzbl (%eax),%eax
    dbe5:	88 45 d8             	mov    %al,-0x28(%ebp)
    dbe8:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dbeb:	8d 50 01             	lea    0x1(%eax),%edx
    dbee:	8b 45 08             	mov    0x8(%ebp),%eax
    dbf1:	01 d0                	add    %edx,%eax
    dbf3:	0f b6 00             	movzbl (%eax),%eax
    dbf6:	88 45 d7             	mov    %al,-0x29(%ebp)
    dbf9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dbfc:	8d 50 02             	lea    0x2(%eax),%edx
    dbff:	8b 45 08             	mov    0x8(%ebp),%eax
    dc02:	01 d0                	add    %edx,%eax
    dc04:	0f b6 00             	movzbl (%eax),%eax
    dc07:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    dc0a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc0d:	8b 45 10             	mov    0x10(%ebp),%eax
    dc10:	01 d0                	add    %edx,%eax
    dc12:	0f b6 00             	movzbl (%eax),%eax
    dc15:	88 45 d5             	mov    %al,-0x2b(%ebp)
    dc18:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc1b:	8d 50 01             	lea    0x1(%eax),%edx
    dc1e:	8b 45 10             	mov    0x10(%ebp),%eax
    dc21:	01 d0                	add    %edx,%eax
    dc23:	0f b6 00             	movzbl (%eax),%eax
    dc26:	88 45 d4             	mov    %al,-0x2c(%ebp)
    dc29:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc2c:	8d 50 02             	lea    0x2(%eax),%edx
    dc2f:	8b 45 10             	mov    0x10(%ebp),%eax
    dc32:	01 d0                	add    %edx,%eax
    dc34:	0f b6 00             	movzbl (%eax),%eax
    dc37:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    dc3a:	8b 55 dc             	mov    -0x24(%ebp),%edx
    dc3d:	8b 45 10             	mov    0x10(%ebp),%eax
    dc40:	01 d0                	add    %edx,%eax
    dc42:	0f b6 00             	movzbl (%eax),%eax
    dc45:	88 45 d2             	mov    %al,-0x2e(%ebp)
    dc48:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dc4b:	8d 50 01             	lea    0x1(%eax),%edx
    dc4e:	8b 45 10             	mov    0x10(%ebp),%eax
    dc51:	01 d0                	add    %edx,%eax
    dc53:	0f b6 00             	movzbl (%eax),%eax
    dc56:	88 45 d1             	mov    %al,-0x2f(%ebp)
    dc59:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dc5c:	8d 50 02             	lea    0x2(%eax),%edx
    dc5f:	8b 45 10             	mov    0x10(%ebp),%eax
    dc62:	01 d0                	add    %edx,%eax
    dc64:	0f b6 00             	movzbl (%eax),%eax
    dc67:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dc6a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc6d:	8b 45 08             	mov    0x8(%ebp),%eax
    dc70:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc73:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    dc77:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    dc7b:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    dc7f:	51                   	push   %ecx
    dc80:	52                   	push   %edx
    dc81:	50                   	push   %eax
    dc82:	e8 9e f4 ff ff       	call   d125 <paethPredictor>
    dc87:	83 c4 0c             	add    $0xc,%esp
    dc8a:	89 c2                	mov    %eax,%edx
    dc8c:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    dc90:	01 d0                	add    %edx,%eax
    dc92:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dc94:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc97:	8d 50 01             	lea    0x1(%eax),%edx
    dc9a:	8b 45 08             	mov    0x8(%ebp),%eax
    dc9d:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dca0:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    dca4:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    dca8:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    dcac:	51                   	push   %ecx
    dcad:	52                   	push   %edx
    dcae:	50                   	push   %eax
    dcaf:	e8 71 f4 ff ff       	call   d125 <paethPredictor>
    dcb4:	83 c4 0c             	add    $0xc,%esp
    dcb7:	89 c2                	mov    %eax,%edx
    dcb9:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    dcbd:	01 d0                	add    %edx,%eax
    dcbf:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    dcc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcc4:	8d 50 02             	lea    0x2(%eax),%edx
    dcc7:	8b 45 08             	mov    0x8(%ebp),%eax
    dcca:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dccd:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    dcd1:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    dcd5:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    dcd9:	51                   	push   %ecx
    dcda:	52                   	push   %edx
    dcdb:	50                   	push   %eax
    dcdc:	e8 44 f4 ff ff       	call   d125 <paethPredictor>
    dce1:	83 c4 0c             	add    $0xc,%esp
    dce4:	89 c2                	mov    %eax,%edx
    dce6:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    dcea:	01 d0                	add    %edx,%eax
    dcec:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    dcee:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    dcf2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcf5:	83 c0 02             	add    $0x2,%eax
    dcf8:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dcfb:	0f 8c a0 fe ff ff    	jl     dba1 <unfilterScanline+0x467>
    dd01:	e9 5f 01 00 00       	jmp    de65 <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    dd06:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    dd0a:	0f 8e 55 01 00 00    	jle    de65 <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    dd10:	e9 e0 00 00 00       	jmp    ddf5 <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    dd15:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd18:	2b 45 14             	sub    0x14(%ebp),%eax
    dd1b:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    dd1e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd21:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd24:	01 d0                	add    %edx,%eax
    dd26:	0f b6 00             	movzbl (%eax),%eax
    dd29:	88 45 cb             	mov    %al,-0x35(%ebp)
    dd2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd2f:	8d 50 01             	lea    0x1(%eax),%edx
    dd32:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd35:	01 d0                	add    %edx,%eax
    dd37:	0f b6 00             	movzbl (%eax),%eax
    dd3a:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    dd3d:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dd40:	8b 45 08             	mov    0x8(%ebp),%eax
    dd43:	01 d0                	add    %edx,%eax
    dd45:	0f b6 00             	movzbl (%eax),%eax
    dd48:	88 45 c9             	mov    %al,-0x37(%ebp)
    dd4b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dd4e:	8d 50 01             	lea    0x1(%eax),%edx
    dd51:	8b 45 08             	mov    0x8(%ebp),%eax
    dd54:	01 d0                	add    %edx,%eax
    dd56:	0f b6 00             	movzbl (%eax),%eax
    dd59:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    dd5c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd5f:	8b 45 10             	mov    0x10(%ebp),%eax
    dd62:	01 d0                	add    %edx,%eax
    dd64:	0f b6 00             	movzbl (%eax),%eax
    dd67:	88 45 c7             	mov    %al,-0x39(%ebp)
    dd6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd6d:	8d 50 01             	lea    0x1(%eax),%edx
    dd70:	8b 45 10             	mov    0x10(%ebp),%eax
    dd73:	01 d0                	add    %edx,%eax
    dd75:	0f b6 00             	movzbl (%eax),%eax
    dd78:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    dd7b:	8b 55 cc             	mov    -0x34(%ebp),%edx
    dd7e:	8b 45 10             	mov    0x10(%ebp),%eax
    dd81:	01 d0                	add    %edx,%eax
    dd83:	0f b6 00             	movzbl (%eax),%eax
    dd86:	88 45 c5             	mov    %al,-0x3b(%ebp)
    dd89:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dd8c:	8d 50 01             	lea    0x1(%eax),%edx
    dd8f:	8b 45 10             	mov    0x10(%ebp),%eax
    dd92:	01 d0                	add    %edx,%eax
    dd94:	0f b6 00             	movzbl (%eax),%eax
    dd97:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dd9a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd9d:	8b 45 08             	mov    0x8(%ebp),%eax
    dda0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dda3:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    dda7:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    ddab:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    ddaf:	51                   	push   %ecx
    ddb0:	52                   	push   %edx
    ddb1:	50                   	push   %eax
    ddb2:	e8 6e f3 ff ff       	call   d125 <paethPredictor>
    ddb7:	83 c4 0c             	add    $0xc,%esp
    ddba:	89 c2                	mov    %eax,%edx
    ddbc:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    ddc0:	01 d0                	add    %edx,%eax
    ddc2:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    ddc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddc7:	8d 50 01             	lea    0x1(%eax),%edx
    ddca:	8b 45 08             	mov    0x8(%ebp),%eax
    ddcd:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    ddd0:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    ddd4:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    ddd8:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    dddc:	51                   	push   %ecx
    dddd:	52                   	push   %edx
    ddde:	50                   	push   %eax
    dddf:	e8 41 f3 ff ff       	call   d125 <paethPredictor>
    dde4:	83 c4 0c             	add    $0xc,%esp
    dde7:	89 c2                	mov    %eax,%edx
    dde9:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    dded:	01 d0                	add    %edx,%eax
    ddef:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    ddf1:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    ddf5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ddf8:	83 c0 01             	add    $0x1,%eax
    ddfb:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ddfe:	0f 8c 11 ff ff ff    	jl     dd15 <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    de04:	eb 5f                	jmp    de65 <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    de06:	8b 55 f4             	mov    -0xc(%ebp),%edx
    de09:	8b 45 08             	mov    0x8(%ebp),%eax
    de0c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    de0f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    de12:	8b 45 0c             	mov    0xc(%ebp),%eax
    de15:	01 d0                	add    %edx,%eax
    de17:	0f b6 00             	movzbl (%eax),%eax
    de1a:	88 45 b7             	mov    %al,-0x49(%ebp)
    de1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de20:	2b 45 14             	sub    0x14(%ebp),%eax
    de23:	89 c2                	mov    %eax,%edx
    de25:	8b 45 10             	mov    0x10(%ebp),%eax
    de28:	01 d0                	add    %edx,%eax
    de2a:	0f b6 00             	movzbl (%eax),%eax
    de2d:	0f b6 c8             	movzbl %al,%ecx
    de30:	8b 55 f4             	mov    -0xc(%ebp),%edx
    de33:	8b 45 10             	mov    0x10(%ebp),%eax
    de36:	01 d0                	add    %edx,%eax
    de38:	0f b6 00             	movzbl (%eax),%eax
    de3b:	0f b6 d0             	movzbl %al,%edx
    de3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de41:	2b 45 14             	sub    0x14(%ebp),%eax
    de44:	89 c6                	mov    %eax,%esi
    de46:	8b 45 08             	mov    0x8(%ebp),%eax
    de49:	01 f0                	add    %esi,%eax
    de4b:	0f b6 00             	movzbl (%eax),%eax
    de4e:	0f b6 c0             	movzbl %al,%eax
    de51:	51                   	push   %ecx
    de52:	52                   	push   %edx
    de53:	50                   	push   %eax
    de54:	e8 cc f2 ff ff       	call   d125 <paethPredictor>
    de59:	83 c4 0c             	add    $0xc,%esp
    de5c:	02 45 b7             	add    -0x49(%ebp),%al
    de5f:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    de61:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    de65:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de68:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    de6b:	75 99                	jne    de06 <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    de6d:	eb 6e                	jmp    dedd <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    de6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    de76:	eb 19                	jmp    de91 <unfilterScanline+0x757>
          recon[i] = scanline[i];
    de78:	8b 55 f4             	mov    -0xc(%ebp),%edx
    de7b:	8b 45 08             	mov    0x8(%ebp),%eax
    de7e:	01 c2                	add    %eax,%edx
    de80:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    de83:	8b 45 0c             	mov    0xc(%ebp),%eax
    de86:	01 c8                	add    %ecx,%eax
    de88:	0f b6 00             	movzbl (%eax),%eax
    de8b:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    de8d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    de91:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de94:	3b 45 14             	cmp    0x14(%ebp),%eax
    de97:	75 df                	jne    de78 <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    de99:	8b 45 14             	mov    0x14(%ebp),%eax
    de9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    de9f:	eb 2b                	jmp    decc <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    dea1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dea4:	8b 45 08             	mov    0x8(%ebp),%eax
    dea7:	01 c2                	add    %eax,%edx
    dea9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    deac:	8b 45 0c             	mov    0xc(%ebp),%eax
    deaf:	01 c8                	add    %ecx,%eax
    deb1:	0f b6 08             	movzbl (%eax),%ecx
    deb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    deb7:	2b 45 14             	sub    0x14(%ebp),%eax
    deba:	89 c3                	mov    %eax,%ebx
    debc:	8b 45 08             	mov    0x8(%ebp),%eax
    debf:	01 d8                	add    %ebx,%eax
    dec1:	0f b6 00             	movzbl (%eax),%eax
    dec4:	01 c8                	add    %ecx,%eax
    dec6:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    dec8:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    decc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    decf:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    ded2:	7c cd                	jl     dea1 <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    ded4:	eb 07                	jmp    dedd <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    ded6:	b8 24 00 00 00       	mov    $0x24,%eax
    dedb:	eb 05                	jmp    dee2 <unfilterScanline+0x7a8>
  }
  return 0;
    dedd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    dee2:	8d 65 f8             	lea    -0x8(%ebp),%esp
    dee5:	5b                   	pop    %ebx
    dee6:	5e                   	pop    %esi
    dee7:	5d                   	pop    %ebp
    dee8:	c3                   	ret    

0000dee9 <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    dee9:	55                   	push   %ebp
    deea:	89 e5                	mov    %esp,%ebp
    deec:	53                   	push   %ebx
    deed:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    def0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    def7:	8b 45 18             	mov    0x18(%ebp),%eax
    defa:	83 c0 07             	add    $0x7,%eax
    defd:	c1 e8 03             	shr    $0x3,%eax
    df00:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    df03:	ff 75 18             	pushl  0x18(%ebp)
    df06:	6a 01                	push   $0x1
    df08:	ff 75 10             	pushl  0x10(%ebp)
    df0b:	e8 d9 b1 ff ff       	call   90e9 <lodepng_get_raw_size_idat>
    df10:	83 c4 0c             	add    $0xc,%esp
    df13:	83 e8 01             	sub    $0x1,%eax
    df16:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    df19:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    df20:	eb 6d                	jmp    df8f <unfilter+0xa6>
    size_t outindex = linebytes * y;
    df22:	8b 45 ec             	mov    -0x14(%ebp),%eax
    df25:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    df29:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    df2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    df2f:	83 c0 01             	add    $0x1,%eax
    df32:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    df36:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    df39:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    df3c:	8b 45 0c             	mov    0xc(%ebp),%eax
    df3f:	01 d0                	add    %edx,%eax
    df41:	0f b6 00             	movzbl (%eax),%eax
    df44:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    df47:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    df4b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    df4e:	8d 4a 01             	lea    0x1(%edx),%ecx
    df51:	8b 55 0c             	mov    0xc(%ebp),%edx
    df54:	01 d1                	add    %edx,%ecx
    df56:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    df59:	8b 55 08             	mov    0x8(%ebp),%edx
    df5c:	01 da                	add    %ebx,%edx
    df5e:	ff 75 ec             	pushl  -0x14(%ebp)
    df61:	50                   	push   %eax
    df62:	ff 75 f0             	pushl  -0x10(%ebp)
    df65:	ff 75 f4             	pushl  -0xc(%ebp)
    df68:	51                   	push   %ecx
    df69:	52                   	push   %edx
    df6a:	e8 cb f7 ff ff       	call   d73a <unfilterScanline>
    df6f:	83 c4 18             	add    $0x18,%esp
    df72:	89 45 dc             	mov    %eax,-0x24(%ebp)
    df75:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    df79:	74 05                	je     df80 <unfilter+0x97>
    df7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
    df7e:	eb 1c                	jmp    df9c <unfilter+0xb3>

    prevline = &out[outindex];
    df80:	8b 55 e8             	mov    -0x18(%ebp),%edx
    df83:	8b 45 08             	mov    0x8(%ebp),%eax
    df86:	01 d0                	add    %edx,%eax
    df88:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    df8b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    df8f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    df92:	3b 45 14             	cmp    0x14(%ebp),%eax
    df95:	72 8b                	jb     df22 <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    df97:	b8 00 00 00 00       	mov    $0x0,%eax
}
    df9c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    df9f:	c9                   	leave  
    dfa0:	c3                   	ret    

0000dfa1 <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    dfa1:	55                   	push   %ebp
    dfa2:	89 e5                	mov    %esp,%ebp
    dfa4:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    dfaa:	ff 75 18             	pushl  0x18(%ebp)
    dfad:	ff 75 14             	pushl  0x14(%ebp)
    dfb0:	ff 75 10             	pushl  0x10(%ebp)
    dfb3:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    dfb9:	50                   	push   %eax
    dfba:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    dfc0:	50                   	push   %eax
    dfc1:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    dfc7:	50                   	push   %eax
    dfc8:	8d 45 94             	lea    -0x6c(%ebp),%eax
    dfcb:	50                   	push   %eax
    dfcc:	8d 45 b0             	lea    -0x50(%ebp),%eax
    dfcf:	50                   	push   %eax
    dfd0:	e8 e6 f1 ff ff       	call   d1bb <Adam7_getpassvalues>
    dfd5:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    dfd8:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    dfdc:	0f 86 0a 01 00 00    	jbe    e0ec <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    dfe2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    dfe9:	e9 ef 00 00 00       	jmp    e0dd <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    dfee:	8b 45 18             	mov    0x18(%ebp),%eax
    dff1:	c1 e8 03             	shr    $0x3,%eax
    dff4:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    dff7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dffe:	e9 c6 00 00 00       	jmp    e0c9 <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    e003:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e00a:	e9 a6 00 00 00       	jmp    e0b5 <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    e00f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e012:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e019:	89 c1                	mov    %eax,%ecx
    e01b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e01e:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e022:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    e026:	89 c2                	mov    %eax,%edx
    e028:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e02b:	01 c2                	add    %eax,%edx
    e02d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e030:	0f af c2             	imul   %edx,%eax
    e033:	01 c8                	add    %ecx,%eax
    e035:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    e038:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e03b:	8b 14 85 38 a1 01 00 	mov    0x1a138(,%eax,4),%edx
    e042:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e045:	8b 04 85 70 a1 01 00 	mov    0x1a170(,%eax,4),%eax
    e04c:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    e050:	01 d0                	add    %edx,%eax
    e052:	0f af 45 10          	imul   0x10(%ebp),%eax
    e056:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    e058:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e05b:	8b 04 85 54 a1 01 00 	mov    0x1a154(,%eax,4),%eax
    e062:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e066:	01 c2                	add    %eax,%edx
    e068:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e06b:	8b 04 85 1c a1 01 00 	mov    0x1a11c(,%eax,4),%eax
    e072:	01 c2                	add    %eax,%edx
    e074:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e077:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    e07a:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    e07d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e084:	eb 23                	jmp    e0a9 <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    e086:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e089:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e08c:	01 c2                	add    %eax,%edx
    e08e:	8b 45 08             	mov    0x8(%ebp),%eax
    e091:	01 c2                	add    %eax,%edx
    e093:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    e096:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e099:	01 c1                	add    %eax,%ecx
    e09b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e09e:	01 c8                	add    %ecx,%eax
    e0a0:	0f b6 00             	movzbl (%eax),%eax
    e0a3:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    e0a5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e0a9:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e0ac:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e0af:	72 d5                	jb     e086 <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e0b1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e0b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0b8:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e0bc:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    e0bf:	0f 87 4a ff ff ff    	ja     e00f <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    e0c5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e0c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0cc:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e0d0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    e0d3:	0f 87 2a ff ff ff    	ja     e003 <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    e0d9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e0dd:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e0e1:	0f 85 07 ff ff ff    	jne    dfee <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e0e7:	e9 22 01 00 00       	jmp    e20e <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e0ec:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e0f3:	e9 0c 01 00 00       	jmp    e204 <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    e0f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e0fb:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e0ff:	0f af 45 18          	imul   0x18(%ebp),%eax
    e103:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    e106:	8b 45 18             	mov    0x18(%ebp),%eax
    e109:	0f af 45 10          	imul   0x10(%ebp),%eax
    e10d:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e110:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    e117:	e9 d4 00 00 00       	jmp    e1f0 <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    e11c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e123:	e9 b4 00 00 00       	jmp    e1dc <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    e128:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e12b:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e132:	c1 e0 03             	shl    $0x3,%eax
    e135:	89 c1                	mov    %eax,%ecx
    e137:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e13a:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    e13e:	89 c2                	mov    %eax,%edx
    e140:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e143:	0f af 45 18          	imul   0x18(%ebp),%eax
    e147:	01 d0                	add    %edx,%eax
    e149:	01 c8                	add    %ecx,%eax
    e14b:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    e151:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e154:	8b 14 85 38 a1 01 00 	mov    0x1a138(,%eax,4),%edx
    e15b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e15e:	8b 04 85 70 a1 01 00 	mov    0x1a170(,%eax,4),%eax
    e165:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    e169:	01 d0                	add    %edx,%eax
    e16b:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    e16f:	89 c2                	mov    %eax,%edx
    e171:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e174:	8b 0c 85 1c a1 01 00 	mov    0x1a11c(,%eax,4),%ecx
    e17b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e17e:	8b 04 85 54 a1 01 00 	mov    0x1a154(,%eax,4),%eax
    e185:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e189:	01 c8                	add    %ecx,%eax
    e18b:	0f af 45 18          	imul   0x18(%ebp),%eax
    e18f:	01 d0                	add    %edx,%eax
    e191:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    e197:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e19e:	eb 30                	jmp    e1d0 <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    e1a0:	ff 75 0c             	pushl  0xc(%ebp)
    e1a3:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    e1a9:	50                   	push   %eax
    e1aa:	e8 1e a1 ff ff       	call   82cd <readBitFromReversedStream>
    e1af:	83 c4 08             	add    $0x8,%esp
    e1b2:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    e1b5:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    e1b9:	50                   	push   %eax
    e1ba:	ff 75 08             	pushl  0x8(%ebp)
    e1bd:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    e1c3:	50                   	push   %eax
    e1c4:	e8 86 a1 ff ff       	call   834f <setBitOfReversedStream>
    e1c9:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    e1cc:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    e1d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e1d3:	3b 45 18             	cmp    0x18(%ebp),%eax
    e1d6:	72 c8                	jb     e1a0 <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e1d8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    e1dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e1df:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e1e3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e1e6:	0f 87 3c ff ff ff    	ja     e128 <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e1ec:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e1f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e1f3:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e1f7:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e1fa:	0f 87 1c ff ff ff    	ja     e11c <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e200:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e204:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e208:	0f 85 ea fe ff ff    	jne    e0f8 <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e20e:	90                   	nop
    e20f:	c9                   	leave  
    e210:	c3                   	ret    

0000e211 <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    e211:	55                   	push   %ebp
    e212:	89 e5                	mov    %esp,%ebp
    e214:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    e217:	8b 45 14             	mov    0x14(%ebp),%eax
    e21a:	2b 45 10             	sub    0x10(%ebp),%eax
    e21d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    e220:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e227:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    e22e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e235:	eb 4a                	jmp    e281 <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e237:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e23e:	eb 2a                	jmp    e26a <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    e240:	ff 75 0c             	pushl  0xc(%ebp)
    e243:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e246:	50                   	push   %eax
    e247:	e8 81 a0 ff ff       	call   82cd <readBitFromReversedStream>
    e24c:	83 c4 08             	add    $0x8,%esp
    e24f:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    e252:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e256:	50                   	push   %eax
    e257:	ff 75 08             	pushl  0x8(%ebp)
    e25a:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e25d:	50                   	push   %eax
    e25e:	e8 ec a0 ff ff       	call   834f <setBitOfReversedStream>
    e263:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e266:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e26a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e26d:	3b 45 10             	cmp    0x10(%ebp),%eax
    e270:	7c ce                	jl     e240 <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    e272:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e275:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e278:	01 d0                	add    %edx,%eax
    e27a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    e27d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e281:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e284:	3b 45 18             	cmp    0x18(%ebp),%eax
    e287:	72 ae                	jb     e237 <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    e289:	90                   	nop
    e28a:	c9                   	leave  
    e28b:	c3                   	ret    

0000e28c <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    e28c:	55                   	push   %ebp
    e28d:	89 e5                	mov    %esp,%ebp
    e28f:	57                   	push   %edi
    e290:	56                   	push   %esi
    e291:	53                   	push   %ebx
    e292:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    e298:	8b 45 18             	mov    0x18(%ebp),%eax
    e29b:	83 c0 0c             	add    $0xc,%eax
    e29e:	50                   	push   %eax
    e29f:	e8 e6 ac ff ff       	call   8f8a <lodepng_get_bpp>
    e2a4:	83 c4 04             	add    $0x4,%esp
    e2a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    e2aa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e2ae:	75 0a                	jne    e2ba <postProcessScanlines+0x2e>
    e2b0:	b8 1f 00 00 00       	mov    $0x1f,%eax
    e2b5:	e9 c3 01 00 00       	jmp    e47d <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    e2ba:	8b 45 18             	mov    0x18(%ebp),%eax
    e2bd:	8b 40 08             	mov    0x8(%eax),%eax
    e2c0:	85 c0                	test   %eax,%eax
    e2c2:	0f 85 a8 00 00 00    	jne    e370 <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    e2c8:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e2cc:	77 76                	ja     e344 <postProcessScanlines+0xb8>
    e2ce:	8b 45 10             	mov    0x10(%ebp),%eax
    e2d1:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e2d5:	89 c2                	mov    %eax,%edx
    e2d7:	8b 45 10             	mov    0x10(%ebp),%eax
    e2da:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e2de:	83 c0 07             	add    $0x7,%eax
    e2e1:	c1 e8 03             	shr    $0x3,%eax
    e2e4:	c1 e0 03             	shl    $0x3,%eax
    e2e7:	39 c2                	cmp    %eax,%edx
    e2e9:	74 59                	je     e344 <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    e2eb:	ff 75 ec             	pushl  -0x14(%ebp)
    e2ee:	ff 75 14             	pushl  0x14(%ebp)
    e2f1:	ff 75 10             	pushl  0x10(%ebp)
    e2f4:	ff 75 0c             	pushl  0xc(%ebp)
    e2f7:	ff 75 0c             	pushl  0xc(%ebp)
    e2fa:	e8 ea fb ff ff       	call   dee9 <unfilter>
    e2ff:	83 c4 14             	add    $0x14,%esp
    e302:	89 45 e8             	mov    %eax,-0x18(%ebp)
    e305:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e309:	74 08                	je     e313 <postProcessScanlines+0x87>
    e30b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e30e:	e9 6a 01 00 00       	jmp    e47d <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    e313:	8b 45 10             	mov    0x10(%ebp),%eax
    e316:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e31a:	83 c0 07             	add    $0x7,%eax
    e31d:	c1 e8 03             	shr    $0x3,%eax
    e320:	c1 e0 03             	shl    $0x3,%eax
    e323:	89 c2                	mov    %eax,%edx
    e325:	8b 45 10             	mov    0x10(%ebp),%eax
    e328:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e32c:	ff 75 14             	pushl  0x14(%ebp)
    e32f:	52                   	push   %edx
    e330:	50                   	push   %eax
    e331:	ff 75 0c             	pushl  0xc(%ebp)
    e334:	ff 75 08             	pushl  0x8(%ebp)
    e337:	e8 d5 fe ff ff       	call   e211 <removePaddingBits>
    e33c:	83 c4 14             	add    $0x14,%esp
    e33f:	e9 34 01 00 00       	jmp    e478 <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    e344:	ff 75 ec             	pushl  -0x14(%ebp)
    e347:	ff 75 14             	pushl  0x14(%ebp)
    e34a:	ff 75 10             	pushl  0x10(%ebp)
    e34d:	ff 75 0c             	pushl  0xc(%ebp)
    e350:	ff 75 08             	pushl  0x8(%ebp)
    e353:	e8 91 fb ff ff       	call   dee9 <unfilter>
    e358:	83 c4 14             	add    $0x14,%esp
    e35b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e35e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e362:	0f 84 10 01 00 00    	je     e478 <postProcessScanlines+0x1ec>
    e368:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e36b:	e9 0d 01 00 00       	jmp    e47d <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e370:	ff 75 ec             	pushl  -0x14(%ebp)
    e373:	ff 75 14             	pushl  0x14(%ebp)
    e376:	ff 75 10             	pushl  0x10(%ebp)
    e379:	8d 45 88             	lea    -0x78(%ebp),%eax
    e37c:	50                   	push   %eax
    e37d:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    e383:	50                   	push   %eax
    e384:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e38a:	50                   	push   %eax
    e38b:	8d 45 a8             	lea    -0x58(%ebp),%eax
    e38e:	50                   	push   %eax
    e38f:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e392:	50                   	push   %eax
    e393:	e8 23 ee ff ff       	call   d1bb <Adam7_getpassvalues>
    e398:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    e39b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e3a2:	e9 b0 00 00 00       	jmp    e457 <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    e3a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e3aa:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    e3ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e3b1:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    e3b5:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e3b8:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    e3bf:	89 cb                	mov    %ecx,%ebx
    e3c1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e3c4:	01 cb                	add    %ecx,%ebx
    e3c6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e3c9:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    e3d0:	89 ce                	mov    %ecx,%esi
    e3d2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e3d5:	01 f1                	add    %esi,%ecx
    e3d7:	ff 75 ec             	pushl  -0x14(%ebp)
    e3da:	52                   	push   %edx
    e3db:	50                   	push   %eax
    e3dc:	53                   	push   %ebx
    e3dd:	51                   	push   %ecx
    e3de:	e8 06 fb ff ff       	call   dee9 <unfilter>
    e3e3:	83 c4 14             	add    $0x14,%esp
    e3e6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e3e9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e3ed:	74 08                	je     e3f7 <postProcessScanlines+0x16b>
    e3ef:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e3f2:	e9 86 00 00 00       	jmp    e47d <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    e3f7:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e3fb:	77 56                	ja     e453 <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e3fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e400:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    e404:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e407:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e40b:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e40f:	83 c2 07             	add    $0x7,%edx
    e412:	c1 ea 03             	shr    $0x3,%edx
    e415:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e418:	89 d6                	mov    %edx,%esi
    e41a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e41d:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e421:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e425:	89 d3                	mov    %edx,%ebx
    e427:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e42a:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    e431:	89 d1                	mov    %edx,%ecx
    e433:	8b 55 0c             	mov    0xc(%ebp),%edx
    e436:	01 d1                	add    %edx,%ecx
    e438:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e43b:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    e43f:	89 d7                	mov    %edx,%edi
    e441:	8b 55 0c             	mov    0xc(%ebp),%edx
    e444:	01 fa                	add    %edi,%edx
    e446:	50                   	push   %eax
    e447:	56                   	push   %esi
    e448:	53                   	push   %ebx
    e449:	51                   	push   %ecx
    e44a:	52                   	push   %edx
    e44b:	e8 c1 fd ff ff       	call   e211 <removePaddingBits>
    e450:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    e453:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e457:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    e45b:	0f 85 46 ff ff ff    	jne    e3a7 <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    e461:	ff 75 ec             	pushl  -0x14(%ebp)
    e464:	ff 75 14             	pushl  0x14(%ebp)
    e467:	ff 75 10             	pushl  0x10(%ebp)
    e46a:	ff 75 0c             	pushl  0xc(%ebp)
    e46d:	ff 75 08             	pushl  0x8(%ebp)
    e470:	e8 2c fb ff ff       	call   dfa1 <Adam7_deinterlace>
    e475:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    e478:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e47d:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e480:	5b                   	pop    %ebx
    e481:	5e                   	pop    %esi
    e482:	5f                   	pop    %edi
    e483:	5d                   	pop    %ebp
    e484:	c3                   	ret    

0000e485 <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e485:	55                   	push   %ebp
    e486:	89 e5                	mov    %esp,%ebp
    e488:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    e48b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    e492:	8b 45 10             	mov    0x10(%ebp),%eax
    e495:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    e49a:	f7 e2                	mul    %edx
    e49c:	89 d0                	mov    %edx,%eax
    e49e:	d1 e8                	shr    %eax
    e4a0:	89 c2                	mov    %eax,%edx
    e4a2:	8b 45 08             	mov    0x8(%ebp),%eax
    e4a5:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    e4a8:	8b 45 08             	mov    0x8(%ebp),%eax
    e4ab:	8b 40 0c             	mov    0xc(%eax),%eax
    e4ae:	85 c0                	test   %eax,%eax
    e4b0:	74 0d                	je     e4bf <readChunk_PLTE+0x3a>
    e4b2:	8b 45 08             	mov    0x8(%ebp),%eax
    e4b5:	8b 40 0c             	mov    0xc(%eax),%eax
    e4b8:	3d 00 01 00 00       	cmp    $0x100,%eax
    e4bd:	7e 0a                	jle    e4c9 <readChunk_PLTE+0x44>
    e4bf:	b8 26 00 00 00       	mov    $0x26,%eax
    e4c4:	e9 da 00 00 00       	jmp    e5a3 <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    e4c9:	83 ec 0c             	sub    $0xc,%esp
    e4cc:	ff 75 08             	pushl  0x8(%ebp)
    e4cf:	e8 02 a7 ff ff       	call   8bd6 <lodepng_color_mode_alloc_palette>
    e4d4:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    e4d7:	8b 45 08             	mov    0x8(%ebp),%eax
    e4da:	8b 40 08             	mov    0x8(%eax),%eax
    e4dd:	85 c0                	test   %eax,%eax
    e4df:	75 1e                	jne    e4ff <readChunk_PLTE+0x7a>
    e4e1:	8b 45 08             	mov    0x8(%ebp),%eax
    e4e4:	8b 40 0c             	mov    0xc(%eax),%eax
    e4e7:	85 c0                	test   %eax,%eax
    e4e9:	74 14                	je     e4ff <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    e4eb:	8b 45 08             	mov    0x8(%ebp),%eax
    e4ee:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    e4f5:	b8 53 00 00 00       	mov    $0x53,%eax
    e4fa:	e9 a4 00 00 00       	jmp    e5a3 <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    e4ff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e506:	e9 84 00 00 00       	jmp    e58f <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    e50b:	8b 45 08             	mov    0x8(%ebp),%eax
    e50e:	8b 40 08             	mov    0x8(%eax),%eax
    e511:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e514:	c1 e2 02             	shl    $0x2,%edx
    e517:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e51a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e51d:	8d 50 01             	lea    0x1(%eax),%edx
    e520:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e523:	8b 55 0c             	mov    0xc(%ebp),%edx
    e526:	01 d0                	add    %edx,%eax
    e528:	0f b6 00             	movzbl (%eax),%eax
    e52b:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    e52d:	8b 45 08             	mov    0x8(%ebp),%eax
    e530:	8b 40 08             	mov    0x8(%eax),%eax
    e533:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e536:	c1 e2 02             	shl    $0x2,%edx
    e539:	83 c2 01             	add    $0x1,%edx
    e53c:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e53f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e542:	8d 50 01             	lea    0x1(%eax),%edx
    e545:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e548:	8b 55 0c             	mov    0xc(%ebp),%edx
    e54b:	01 d0                	add    %edx,%eax
    e54d:	0f b6 00             	movzbl (%eax),%eax
    e550:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    e552:	8b 45 08             	mov    0x8(%ebp),%eax
    e555:	8b 40 08             	mov    0x8(%eax),%eax
    e558:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e55b:	c1 e2 02             	shl    $0x2,%edx
    e55e:	83 c2 02             	add    $0x2,%edx
    e561:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e564:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e567:	8d 50 01             	lea    0x1(%eax),%edx
    e56a:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e56d:	8b 55 0c             	mov    0xc(%ebp),%edx
    e570:	01 d0                	add    %edx,%eax
    e572:	0f b6 00             	movzbl (%eax),%eax
    e575:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    e577:	8b 45 08             	mov    0x8(%ebp),%eax
    e57a:	8b 40 08             	mov    0x8(%eax),%eax
    e57d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e580:	c1 e2 02             	shl    $0x2,%edx
    e583:	83 c2 03             	add    $0x3,%edx
    e586:	01 d0                	add    %edx,%eax
    e588:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    e58b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e58f:	8b 45 08             	mov    0x8(%ebp),%eax
    e592:	8b 40 0c             	mov    0xc(%eax),%eax
    e595:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e598:	0f 85 6d ff ff ff    	jne    e50b <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    e59e:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e5a3:	c9                   	leave  
    e5a4:	c3                   	ret    

0000e5a5 <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e5a5:	55                   	push   %ebp
    e5a6:	89 e5                	mov    %esp,%ebp
    e5a8:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    e5ab:	8b 45 08             	mov    0x8(%ebp),%eax
    e5ae:	8b 00                	mov    (%eax),%eax
    e5b0:	83 f8 03             	cmp    $0x3,%eax
    e5b3:	75 4d                	jne    e602 <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    e5b5:	8b 45 08             	mov    0x8(%ebp),%eax
    e5b8:	8b 40 0c             	mov    0xc(%eax),%eax
    e5bb:	3b 45 10             	cmp    0x10(%ebp),%eax
    e5be:	7d 0a                	jge    e5ca <readChunk_tRNS+0x25>
    e5c0:	b8 27 00 00 00       	mov    $0x27,%eax
    e5c5:	e9 3c 01 00 00       	jmp    e706 <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    e5ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e5d1:	eb 22                	jmp    e5f5 <readChunk_tRNS+0x50>
    e5d3:	8b 45 08             	mov    0x8(%ebp),%eax
    e5d6:	8b 40 08             	mov    0x8(%eax),%eax
    e5d9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e5dc:	c1 e2 02             	shl    $0x2,%edx
    e5df:	83 c2 03             	add    $0x3,%edx
    e5e2:	01 c2                	add    %eax,%edx
    e5e4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e5e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e5ea:	01 c8                	add    %ecx,%eax
    e5ec:	0f b6 00             	movzbl (%eax),%eax
    e5ef:	88 02                	mov    %al,(%edx)
    e5f1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e5f5:	8b 45 10             	mov    0x10(%ebp),%eax
    e5f8:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    e5fb:	75 d6                	jne    e5d3 <readChunk_tRNS+0x2e>
    e5fd:	e9 ff 00 00 00       	jmp    e701 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    e602:	8b 45 08             	mov    0x8(%ebp),%eax
    e605:	8b 00                	mov    (%eax),%eax
    e607:	85 c0                	test   %eax,%eax
    e609:	75 59                	jne    e664 <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    e60b:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e60f:	74 0a                	je     e61b <readChunk_tRNS+0x76>
    e611:	b8 1e 00 00 00       	mov    $0x1e,%eax
    e616:	e9 eb 00 00 00       	jmp    e706 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e61b:	8b 45 08             	mov    0x8(%ebp),%eax
    e61e:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    e625:	8b 45 0c             	mov    0xc(%ebp),%eax
    e628:	0f b6 00             	movzbl (%eax),%eax
    e62b:	0f b6 c0             	movzbl %al,%eax
    e62e:	c1 e0 08             	shl    $0x8,%eax
    e631:	89 c2                	mov    %eax,%edx
    e633:	8b 45 0c             	mov    0xc(%ebp),%eax
    e636:	83 c0 01             	add    $0x1,%eax
    e639:	0f b6 00             	movzbl (%eax),%eax
    e63c:	0f b6 c0             	movzbl %al,%eax
    e63f:	01 c2                	add    %eax,%edx
    e641:	8b 45 08             	mov    0x8(%ebp),%eax
    e644:	89 50 1c             	mov    %edx,0x1c(%eax)
    e647:	8b 45 08             	mov    0x8(%ebp),%eax
    e64a:	8b 50 1c             	mov    0x1c(%eax),%edx
    e64d:	8b 45 08             	mov    0x8(%ebp),%eax
    e650:	89 50 18             	mov    %edx,0x18(%eax)
    e653:	8b 45 08             	mov    0x8(%ebp),%eax
    e656:	8b 50 18             	mov    0x18(%eax),%edx
    e659:	8b 45 08             	mov    0x8(%ebp),%eax
    e65c:	89 50 14             	mov    %edx,0x14(%eax)
    e65f:	e9 9d 00 00 00       	jmp    e701 <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    e664:	8b 45 08             	mov    0x8(%ebp),%eax
    e667:	8b 00                	mov    (%eax),%eax
    e669:	83 f8 02             	cmp    $0x2,%eax
    e66c:	0f 85 88 00 00 00    	jne    e6fa <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    e672:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e676:	74 0a                	je     e682 <readChunk_tRNS+0xdd>
    e678:	b8 29 00 00 00       	mov    $0x29,%eax
    e67d:	e9 84 00 00 00       	jmp    e706 <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e682:	8b 45 08             	mov    0x8(%ebp),%eax
    e685:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    e68c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e68f:	0f b6 00             	movzbl (%eax),%eax
    e692:	0f b6 c0             	movzbl %al,%eax
    e695:	c1 e0 08             	shl    $0x8,%eax
    e698:	89 c2                	mov    %eax,%edx
    e69a:	8b 45 0c             	mov    0xc(%ebp),%eax
    e69d:	83 c0 01             	add    $0x1,%eax
    e6a0:	0f b6 00             	movzbl (%eax),%eax
    e6a3:	0f b6 c0             	movzbl %al,%eax
    e6a6:	01 c2                	add    %eax,%edx
    e6a8:	8b 45 08             	mov    0x8(%ebp),%eax
    e6ab:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    e6ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6b1:	83 c0 02             	add    $0x2,%eax
    e6b4:	0f b6 00             	movzbl (%eax),%eax
    e6b7:	0f b6 c0             	movzbl %al,%eax
    e6ba:	c1 e0 08             	shl    $0x8,%eax
    e6bd:	89 c2                	mov    %eax,%edx
    e6bf:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6c2:	83 c0 03             	add    $0x3,%eax
    e6c5:	0f b6 00             	movzbl (%eax),%eax
    e6c8:	0f b6 c0             	movzbl %al,%eax
    e6cb:	01 c2                	add    %eax,%edx
    e6cd:	8b 45 08             	mov    0x8(%ebp),%eax
    e6d0:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    e6d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6d6:	83 c0 04             	add    $0x4,%eax
    e6d9:	0f b6 00             	movzbl (%eax),%eax
    e6dc:	0f b6 c0             	movzbl %al,%eax
    e6df:	c1 e0 08             	shl    $0x8,%eax
    e6e2:	89 c2                	mov    %eax,%edx
    e6e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    e6e7:	83 c0 05             	add    $0x5,%eax
    e6ea:	0f b6 00             	movzbl (%eax),%eax
    e6ed:	0f b6 c0             	movzbl %al,%eax
    e6f0:	01 c2                	add    %eax,%edx
    e6f2:	8b 45 08             	mov    0x8(%ebp),%eax
    e6f5:	89 50 1c             	mov    %edx,0x1c(%eax)
    e6f8:	eb 07                	jmp    e701 <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    e6fa:	b8 2a 00 00 00       	mov    $0x2a,%eax
    e6ff:	eb 05                	jmp    e706 <readChunk_tRNS+0x161>

  return 0; /* OK */
    e701:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e706:	c9                   	leave  
    e707:	c3                   	ret    

0000e708 <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e708:	55                   	push   %ebp
    e709:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    e70b:	8b 45 08             	mov    0x8(%ebp),%eax
    e70e:	8b 40 0c             	mov    0xc(%eax),%eax
    e711:	83 f8 03             	cmp    $0x3,%eax
    e714:	75 63                	jne    e779 <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    e716:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    e71a:	74 0a                	je     e726 <readChunk_bKGD+0x1e>
    e71c:	b8 2b 00 00 00       	mov    $0x2b,%eax
    e721:	e9 63 01 00 00       	jmp    e889 <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    e726:	8b 45 0c             	mov    0xc(%ebp),%eax
    e729:	0f b6 00             	movzbl (%eax),%eax
    e72c:	0f b6 d0             	movzbl %al,%edx
    e72f:	8b 45 08             	mov    0x8(%ebp),%eax
    e732:	8b 40 18             	mov    0x18(%eax),%eax
    e735:	39 c2                	cmp    %eax,%edx
    e737:	7c 0a                	jl     e743 <readChunk_bKGD+0x3b>
    e739:	b8 67 00 00 00       	mov    $0x67,%eax
    e73e:	e9 46 01 00 00       	jmp    e889 <readChunk_bKGD+0x181>

    info->background_defined = 1;
    e743:	8b 45 08             	mov    0x8(%ebp),%eax
    e746:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    e74d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e750:	0f b6 00             	movzbl (%eax),%eax
    e753:	0f b6 d0             	movzbl %al,%edx
    e756:	8b 45 08             	mov    0x8(%ebp),%eax
    e759:	89 50 38             	mov    %edx,0x38(%eax)
    e75c:	8b 45 08             	mov    0x8(%ebp),%eax
    e75f:	8b 50 38             	mov    0x38(%eax),%edx
    e762:	8b 45 08             	mov    0x8(%ebp),%eax
    e765:	89 50 34             	mov    %edx,0x34(%eax)
    e768:	8b 45 08             	mov    0x8(%ebp),%eax
    e76b:	8b 50 34             	mov    0x34(%eax),%edx
    e76e:	8b 45 08             	mov    0x8(%ebp),%eax
    e771:	89 50 30             	mov    %edx,0x30(%eax)
    e774:	e9 0b 01 00 00       	jmp    e884 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    e779:	8b 45 08             	mov    0x8(%ebp),%eax
    e77c:	8b 40 0c             	mov    0xc(%eax),%eax
    e77f:	85 c0                	test   %eax,%eax
    e781:	74 0b                	je     e78e <readChunk_bKGD+0x86>
    e783:	8b 45 08             	mov    0x8(%ebp),%eax
    e786:	8b 40 0c             	mov    0xc(%eax),%eax
    e789:	83 f8 04             	cmp    $0x4,%eax
    e78c:	75 59                	jne    e7e7 <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    e78e:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e792:	74 0a                	je     e79e <readChunk_bKGD+0x96>
    e794:	b8 2c 00 00 00       	mov    $0x2c,%eax
    e799:	e9 eb 00 00 00       	jmp    e889 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e79e:	8b 45 08             	mov    0x8(%ebp),%eax
    e7a1:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    e7a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7ab:	0f b6 00             	movzbl (%eax),%eax
    e7ae:	0f b6 c0             	movzbl %al,%eax
    e7b1:	c1 e0 08             	shl    $0x8,%eax
    e7b4:	89 c2                	mov    %eax,%edx
    e7b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7b9:	83 c0 01             	add    $0x1,%eax
    e7bc:	0f b6 00             	movzbl (%eax),%eax
    e7bf:	0f b6 c0             	movzbl %al,%eax
    e7c2:	01 c2                	add    %eax,%edx
    e7c4:	8b 45 08             	mov    0x8(%ebp),%eax
    e7c7:	89 50 38             	mov    %edx,0x38(%eax)
    e7ca:	8b 45 08             	mov    0x8(%ebp),%eax
    e7cd:	8b 50 38             	mov    0x38(%eax),%edx
    e7d0:	8b 45 08             	mov    0x8(%ebp),%eax
    e7d3:	89 50 34             	mov    %edx,0x34(%eax)
    e7d6:	8b 45 08             	mov    0x8(%ebp),%eax
    e7d9:	8b 50 34             	mov    0x34(%eax),%edx
    e7dc:	8b 45 08             	mov    0x8(%ebp),%eax
    e7df:	89 50 30             	mov    %edx,0x30(%eax)
    e7e2:	e9 9d 00 00 00       	jmp    e884 <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    e7e7:	8b 45 08             	mov    0x8(%ebp),%eax
    e7ea:	8b 40 0c             	mov    0xc(%eax),%eax
    e7ed:	83 f8 02             	cmp    $0x2,%eax
    e7f0:	74 0f                	je     e801 <readChunk_bKGD+0xf9>
    e7f2:	8b 45 08             	mov    0x8(%ebp),%eax
    e7f5:	8b 40 0c             	mov    0xc(%eax),%eax
    e7f8:	83 f8 06             	cmp    $0x6,%eax
    e7fb:	0f 85 83 00 00 00    	jne    e884 <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    e801:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e805:	74 07                	je     e80e <readChunk_bKGD+0x106>
    e807:	b8 2d 00 00 00       	mov    $0x2d,%eax
    e80c:	eb 7b                	jmp    e889 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e80e:	8b 45 08             	mov    0x8(%ebp),%eax
    e811:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    e818:	8b 45 0c             	mov    0xc(%ebp),%eax
    e81b:	0f b6 00             	movzbl (%eax),%eax
    e81e:	0f b6 c0             	movzbl %al,%eax
    e821:	c1 e0 08             	shl    $0x8,%eax
    e824:	89 c2                	mov    %eax,%edx
    e826:	8b 45 0c             	mov    0xc(%ebp),%eax
    e829:	83 c0 01             	add    $0x1,%eax
    e82c:	0f b6 00             	movzbl (%eax),%eax
    e82f:	0f b6 c0             	movzbl %al,%eax
    e832:	01 c2                	add    %eax,%edx
    e834:	8b 45 08             	mov    0x8(%ebp),%eax
    e837:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    e83a:	8b 45 0c             	mov    0xc(%ebp),%eax
    e83d:	83 c0 02             	add    $0x2,%eax
    e840:	0f b6 00             	movzbl (%eax),%eax
    e843:	0f b6 c0             	movzbl %al,%eax
    e846:	c1 e0 08             	shl    $0x8,%eax
    e849:	89 c2                	mov    %eax,%edx
    e84b:	8b 45 0c             	mov    0xc(%ebp),%eax
    e84e:	83 c0 03             	add    $0x3,%eax
    e851:	0f b6 00             	movzbl (%eax),%eax
    e854:	0f b6 c0             	movzbl %al,%eax
    e857:	01 c2                	add    %eax,%edx
    e859:	8b 45 08             	mov    0x8(%ebp),%eax
    e85c:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    e85f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e862:	83 c0 04             	add    $0x4,%eax
    e865:	0f b6 00             	movzbl (%eax),%eax
    e868:	0f b6 c0             	movzbl %al,%eax
    e86b:	c1 e0 08             	shl    $0x8,%eax
    e86e:	89 c2                	mov    %eax,%edx
    e870:	8b 45 0c             	mov    0xc(%ebp),%eax
    e873:	83 c0 05             	add    $0x5,%eax
    e876:	0f b6 00             	movzbl (%eax),%eax
    e879:	0f b6 c0             	movzbl %al,%eax
    e87c:	01 c2                	add    %eax,%edx
    e87e:	8b 45 08             	mov    0x8(%ebp),%eax
    e881:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    e884:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e889:	5d                   	pop    %ebp
    e88a:	c3                   	ret    

0000e88b <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e88b:	55                   	push   %ebp
    e88c:	89 e5                	mov    %esp,%ebp
    e88e:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    e891:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    e898:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e89f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    e8a6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    e8aa:	0f 85 06 01 00 00    	jne    e9b6 <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    e8b0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    e8b7:	eb 04                	jmp    e8bd <readChunk_tEXt+0x32>
    e8b9:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e8bd:	8b 45 10             	mov    0x10(%ebp),%eax
    e8c0:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    e8c3:	73 0f                	jae    e8d4 <readChunk_tEXt+0x49>
    e8c5:	8b 55 0c             	mov    0xc(%ebp),%edx
    e8c8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e8cb:	01 d0                	add    %edx,%eax
    e8cd:	0f b6 00             	movzbl (%eax),%eax
    e8d0:	84 c0                	test   %al,%al
    e8d2:	75 e5                	jne    e8b9 <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    e8d4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e8d8:	74 06                	je     e8e0 <readChunk_tEXt+0x55>
    e8da:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    e8de:	76 0c                	jbe    e8ec <readChunk_tEXt+0x61>
    e8e0:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    e8e7:	e9 ca 00 00 00       	jmp    e9b6 <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    e8ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e8ef:	83 c0 01             	add    $0x1,%eax
    e8f2:	83 ec 0c             	sub    $0xc,%esp
    e8f5:	50                   	push   %eax
    e8f6:	e8 73 4b ff ff       	call   346e <lodepng_malloc>
    e8fb:	83 c4 10             	add    $0x10,%esp
    e8fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    e901:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    e905:	75 0c                	jne    e913 <readChunk_tEXt+0x88>
    e907:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e90e:	e9 a3 00 00 00       	jmp    e9b6 <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    e913:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e916:	83 ec 04             	sub    $0x4,%esp
    e919:	50                   	push   %eax
    e91a:	ff 75 0c             	pushl  0xc(%ebp)
    e91d:	ff 75 f0             	pushl  -0x10(%ebp)
    e920:	e8 87 4b ff ff       	call   34ac <lodepng_memcpy>
    e925:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    e928:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e92b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e92e:	01 d0                	add    %edx,%eax
    e930:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    e933:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e936:	83 c0 01             	add    $0x1,%eax
    e939:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    e93c:	8b 45 10             	mov    0x10(%ebp),%eax
    e93f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    e942:	72 08                	jb     e94c <readChunk_tEXt+0xc1>
    e944:	8b 45 10             	mov    0x10(%ebp),%eax
    e947:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    e94a:	eb 05                	jmp    e951 <readChunk_tEXt+0xc6>
    e94c:	b8 00 00 00 00       	mov    $0x0,%eax
    e951:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    e954:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e957:	83 c0 01             	add    $0x1,%eax
    e95a:	83 ec 0c             	sub    $0xc,%esp
    e95d:	50                   	push   %eax
    e95e:	e8 0b 4b ff ff       	call   346e <lodepng_malloc>
    e963:	83 c4 10             	add    $0x10,%esp
    e966:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    e969:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e96d:	75 09                	jne    e978 <readChunk_tEXt+0xed>
    e96f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    e976:	eb 3e                	jmp    e9b6 <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    e978:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e97b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e97e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e981:	01 ca                	add    %ecx,%edx
    e983:	83 ec 04             	sub    $0x4,%esp
    e986:	50                   	push   %eax
    e987:	52                   	push   %edx
    e988:	ff 75 ec             	pushl  -0x14(%ebp)
    e98b:	e8 1c 4b ff ff       	call   34ac <lodepng_memcpy>
    e990:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    e993:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e996:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e999:	01 d0                	add    %edx,%eax
    e99b:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    e99e:	83 ec 04             	sub    $0x4,%esp
    e9a1:	ff 75 ec             	pushl  -0x14(%ebp)
    e9a4:	ff 75 f0             	pushl  -0x10(%ebp)
    e9a7:	ff 75 08             	pushl  0x8(%ebp)
    e9aa:	e8 3f ac ff ff       	call   95ee <lodepng_add_text>
    e9af:	83 c4 10             	add    $0x10,%esp
    e9b2:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    e9b5:	90                   	nop
  }

  lodepng_free(key);
    e9b6:	83 ec 0c             	sub    $0xc,%esp
    e9b9:	ff 75 f0             	pushl  -0x10(%ebp)
    e9bc:	e8 ce 4a ff ff       	call   348f <lodepng_free>
    e9c1:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    e9c4:	83 ec 0c             	sub    $0xc,%esp
    e9c7:	ff 75 ec             	pushl  -0x14(%ebp)
    e9ca:	e8 c0 4a ff ff       	call   348f <lodepng_free>
    e9cf:	83 c4 10             	add    $0x10,%esp

  return error;
    e9d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    e9d5:	c9                   	leave  
    e9d6:	c3                   	ret    

0000e9d7 <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    e9d7:	55                   	push   %ebp
    e9d8:	89 e5                	mov    %esp,%ebp
    e9da:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    e9dd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    e9e4:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9e7:	8b 10                	mov    (%eax),%edx
    e9e9:	89 55 d0             	mov    %edx,-0x30(%ebp)
    e9ec:	8b 50 04             	mov    0x4(%eax),%edx
    e9ef:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    e9f2:	8b 50 08             	mov    0x8(%eax),%edx
    e9f5:	89 55 d8             	mov    %edx,-0x28(%ebp)
    e9f8:	8b 50 0c             	mov    0xc(%eax),%edx
    e9fb:	89 55 dc             	mov    %edx,-0x24(%ebp)
    e9fe:	8b 50 10             	mov    0x10(%eax),%edx
    ea01:	89 55 e0             	mov    %edx,-0x20(%ebp)
    ea04:	8b 40 14             	mov    0x14(%eax),%eax
    ea07:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    ea0a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    ea11:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    ea18:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ea1f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ea23:	0f 85 48 01 00 00    	jne    eb71 <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    ea29:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ea30:	eb 04                	jmp    ea36 <readChunk_zTXt+0x5f>
    ea32:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ea36:	8b 45 14             	mov    0x14(%ebp),%eax
    ea39:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ea3c:	73 0f                	jae    ea4d <readChunk_zTXt+0x76>
    ea3e:	8b 55 10             	mov    0x10(%ebp),%edx
    ea41:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea44:	01 d0                	add    %edx,%eax
    ea46:	0f b6 00             	movzbl (%eax),%eax
    ea49:	84 c0                	test   %al,%al
    ea4b:	75 e5                	jne    ea32 <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    ea4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea50:	8d 50 02             	lea    0x2(%eax),%edx
    ea53:	8b 45 14             	mov    0x14(%ebp),%eax
    ea56:	39 c2                	cmp    %eax,%edx
    ea58:	72 0c                	jb     ea66 <readChunk_zTXt+0x8f>
    ea5a:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ea61:	e9 0b 01 00 00       	jmp    eb71 <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    ea66:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ea6a:	74 06                	je     ea72 <readChunk_zTXt+0x9b>
    ea6c:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    ea70:	76 0c                	jbe    ea7e <readChunk_zTXt+0xa7>
    ea72:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    ea79:	e9 f3 00 00 00       	jmp    eb71 <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    ea7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ea81:	83 c0 01             	add    $0x1,%eax
    ea84:	83 ec 0c             	sub    $0xc,%esp
    ea87:	50                   	push   %eax
    ea88:	e8 e1 49 ff ff       	call   346e <lodepng_malloc>
    ea8d:	83 c4 10             	add    $0x10,%esp
    ea90:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    ea93:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ea97:	75 0c                	jne    eaa5 <readChunk_zTXt+0xce>
    ea99:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eaa0:	e9 cc 00 00 00       	jmp    eb71 <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    eaa5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eaa8:	83 ec 04             	sub    $0x4,%esp
    eaab:	50                   	push   %eax
    eaac:	ff 75 10             	pushl  0x10(%ebp)
    eaaf:	ff 75 ec             	pushl  -0x14(%ebp)
    eab2:	e8 f5 49 ff ff       	call   34ac <lodepng_memcpy>
    eab7:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    eaba:	8b 55 ec             	mov    -0x14(%ebp),%edx
    eabd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eac0:	01 d0                	add    %edx,%eax
    eac2:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    eac5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eac8:	8d 50 01             	lea    0x1(%eax),%edx
    eacb:	8b 45 10             	mov    0x10(%ebp),%eax
    eace:	01 d0                	add    %edx,%eax
    ead0:	0f b6 00             	movzbl (%eax),%eax
    ead3:	84 c0                	test   %al,%al
    ead5:	74 0c                	je     eae3 <readChunk_zTXt+0x10c>
    ead7:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    eade:	e9 8e 00 00 00       	jmp    eb71 <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    eae3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eae6:	83 c0 02             	add    $0x2,%eax
    eae9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    eaec:	8b 45 14             	mov    0x14(%ebp),%eax
    eaef:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    eaf2:	76 09                	jbe    eafd <readChunk_zTXt+0x126>
    eaf4:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    eafb:	eb 74                	jmp    eb71 <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    eafd:	8b 45 14             	mov    0x14(%ebp),%eax
    eb00:	2b 45 e8             	sub    -0x18(%ebp),%eax
    eb03:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    eb06:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb09:	8b 40 30             	mov    0x30(%eax),%eax
    eb0c:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    eb0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eb12:	8b 4d 10             	mov    0x10(%ebp),%ecx
    eb15:	8b 55 e8             	mov    -0x18(%ebp),%edx
    eb18:	01 d1                	add    %edx,%ecx
    eb1a:	83 ec 08             	sub    $0x8,%esp
    eb1d:	8d 55 d0             	lea    -0x30(%ebp),%edx
    eb20:	52                   	push   %edx
    eb21:	50                   	push   %eax
    eb22:	51                   	push   %ecx
    eb23:	6a 00                	push   $0x0
    eb25:	8d 45 c8             	lea    -0x38(%ebp),%eax
    eb28:	50                   	push   %eax
    eb29:	8d 45 cc             	lea    -0x34(%ebp),%eax
    eb2c:	50                   	push   %eax
    eb2d:	e8 f7 93 ff ff       	call   7f29 <zlib_decompress>
    eb32:	83 c4 20             	add    $0x20,%esp
    eb35:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    eb38:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eb3c:	74 11                	je     eb4f <readChunk_zTXt+0x178>
    eb3e:	8b 55 d8             	mov    -0x28(%ebp),%edx
    eb41:	8b 45 c8             	mov    -0x38(%ebp),%eax
    eb44:	39 c2                	cmp    %eax,%edx
    eb46:	7d 07                	jge    eb4f <readChunk_zTXt+0x178>
    eb48:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    eb4f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eb53:	75 1b                	jne    eb70 <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    eb55:	8b 55 c8             	mov    -0x38(%ebp),%edx
    eb58:	8b 45 cc             	mov    -0x34(%ebp),%eax
    eb5b:	52                   	push   %edx
    eb5c:	50                   	push   %eax
    eb5d:	ff 75 ec             	pushl  -0x14(%ebp)
    eb60:	ff 75 08             	pushl  0x8(%ebp)
    eb63:	e8 60 a9 ff ff       	call   94c8 <lodepng_add_text_sized>
    eb68:	83 c4 10             	add    $0x10,%esp
    eb6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    eb6e:	eb 01                	jmp    eb71 <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    eb70:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    eb71:	83 ec 0c             	sub    $0xc,%esp
    eb74:	ff 75 ec             	pushl  -0x14(%ebp)
    eb77:	e8 13 49 ff ff       	call   348f <lodepng_free>
    eb7c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    eb7f:	8b 45 cc             	mov    -0x34(%ebp),%eax
    eb82:	83 ec 0c             	sub    $0xc,%esp
    eb85:	50                   	push   %eax
    eb86:	e8 04 49 ff ff       	call   348f <lodepng_free>
    eb8b:	83 c4 10             	add    $0x10,%esp

  return error;
    eb8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    eb91:	c9                   	leave  
    eb92:	c3                   	ret    

0000eb93 <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    eb93:	55                   	push   %ebp
    eb94:	89 e5                	mov    %esp,%ebp
    eb96:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    eb99:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    eba0:	8b 45 0c             	mov    0xc(%ebp),%eax
    eba3:	8b 10                	mov    (%eax),%edx
    eba5:	89 55 c0             	mov    %edx,-0x40(%ebp)
    eba8:	8b 50 04             	mov    0x4(%eax),%edx
    ebab:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    ebae:	8b 50 08             	mov    0x8(%eax),%edx
    ebb1:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ebb4:	8b 50 0c             	mov    0xc(%eax),%edx
    ebb7:	89 55 cc             	mov    %edx,-0x34(%ebp)
    ebba:	8b 50 10             	mov    0x10(%eax),%edx
    ebbd:	89 55 d0             	mov    %edx,-0x30(%ebp)
    ebc0:	8b 40 14             	mov    0x14(%eax),%eax
    ebc3:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    ebc6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ebcd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    ebd4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ebdb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ebdf:	0f 85 d5 02 00 00    	jne    eeba <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    ebe5:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    ebe9:	7f 0c                	jg     ebf7 <readChunk_iTXt+0x64>
    ebeb:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    ebf2:	e9 c3 02 00 00       	jmp    eeba <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    ebf7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    ebfe:	eb 04                	jmp    ec04 <readChunk_iTXt+0x71>
    ec00:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ec04:	8b 45 14             	mov    0x14(%ebp),%eax
    ec07:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    ec0a:	73 0f                	jae    ec1b <readChunk_iTXt+0x88>
    ec0c:	8b 55 10             	mov    0x10(%ebp),%edx
    ec0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec12:	01 d0                	add    %edx,%eax
    ec14:	0f b6 00             	movzbl (%eax),%eax
    ec17:	84 c0                	test   %al,%al
    ec19:	75 e5                	jne    ec00 <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    ec1b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec1e:	8d 50 03             	lea    0x3(%eax),%edx
    ec21:	8b 45 14             	mov    0x14(%ebp),%eax
    ec24:	39 c2                	cmp    %eax,%edx
    ec26:	72 0c                	jb     ec34 <readChunk_iTXt+0xa1>
    ec28:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ec2f:	e9 86 02 00 00       	jmp    eeba <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    ec34:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ec38:	74 06                	je     ec40 <readChunk_iTXt+0xad>
    ec3a:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    ec3e:	76 0c                	jbe    ec4c <readChunk_iTXt+0xb9>
    ec40:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    ec47:	e9 6e 02 00 00       	jmp    eeba <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    ec4c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec4f:	83 c0 01             	add    $0x1,%eax
    ec52:	83 ec 0c             	sub    $0xc,%esp
    ec55:	50                   	push   %eax
    ec56:	e8 13 48 ff ff       	call   346e <lodepng_malloc>
    ec5b:	83 c4 10             	add    $0x10,%esp
    ec5e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    ec61:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ec65:	75 0c                	jne    ec73 <readChunk_iTXt+0xe0>
    ec67:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ec6e:	e9 47 02 00 00       	jmp    eeba <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    ec73:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec76:	83 ec 04             	sub    $0x4,%esp
    ec79:	50                   	push   %eax
    ec7a:	ff 75 10             	pushl  0x10(%ebp)
    ec7d:	ff 75 e8             	pushl  -0x18(%ebp)
    ec80:	e8 27 48 ff ff       	call   34ac <lodepng_memcpy>
    ec85:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    ec88:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ec8b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec8e:	01 d0                	add    %edx,%eax
    ec90:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    ec93:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ec96:	8d 50 01             	lea    0x1(%eax),%edx
    ec99:	8b 45 10             	mov    0x10(%ebp),%eax
    ec9c:	01 d0                	add    %edx,%eax
    ec9e:	0f b6 00             	movzbl (%eax),%eax
    eca1:	0f b6 c0             	movzbl %al,%eax
    eca4:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    eca7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ecaa:	8d 50 02             	lea    0x2(%eax),%edx
    ecad:	8b 45 10             	mov    0x10(%ebp),%eax
    ecb0:	01 d0                	add    %edx,%eax
    ecb2:	0f b6 00             	movzbl (%eax),%eax
    ecb5:	84 c0                	test   %al,%al
    ecb7:	74 0c                	je     ecc5 <readChunk_iTXt+0x132>
    ecb9:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    ecc0:	e9 f5 01 00 00       	jmp    eeba <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    ecc5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ecc8:	83 c0 03             	add    $0x3,%eax
    eccb:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ecce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ecd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ecd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ecdb:	eb 08                	jmp    ece5 <readChunk_iTXt+0x152>
    ecdd:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ece1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ece5:	8b 45 14             	mov    0x14(%ebp),%eax
    ece8:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    eceb:	73 0f                	jae    ecfc <readChunk_iTXt+0x169>
    eced:	8b 55 10             	mov    0x10(%ebp),%edx
    ecf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ecf3:	01 d0                	add    %edx,%eax
    ecf5:	0f b6 00             	movzbl (%eax),%eax
    ecf8:	84 c0                	test   %al,%al
    ecfa:	75 e1                	jne    ecdd <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    ecfc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ecff:	83 c0 01             	add    $0x1,%eax
    ed02:	83 ec 0c             	sub    $0xc,%esp
    ed05:	50                   	push   %eax
    ed06:	e8 63 47 ff ff       	call   346e <lodepng_malloc>
    ed0b:	83 c4 10             	add    $0x10,%esp
    ed0e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    ed11:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ed15:	75 0c                	jne    ed23 <readChunk_iTXt+0x190>
    ed17:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ed1e:	e9 97 01 00 00       	jmp    eeba <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    ed23:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed26:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ed29:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ed2c:	01 ca                	add    %ecx,%edx
    ed2e:	83 ec 04             	sub    $0x4,%esp
    ed31:	50                   	push   %eax
    ed32:	52                   	push   %edx
    ed33:	ff 75 e4             	pushl  -0x1c(%ebp)
    ed36:	e8 71 47 ff ff       	call   34ac <lodepng_memcpy>
    ed3b:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    ed3e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    ed41:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed44:	01 d0                	add    %edx,%eax
    ed46:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    ed49:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ed4c:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ed4f:	01 d0                	add    %edx,%eax
    ed51:	83 c0 01             	add    $0x1,%eax
    ed54:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ed57:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ed5e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ed61:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ed64:	eb 08                	jmp    ed6e <readChunk_iTXt+0x1db>
    ed66:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ed6a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ed6e:	8b 45 14             	mov    0x14(%ebp),%eax
    ed71:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ed74:	73 0f                	jae    ed85 <readChunk_iTXt+0x1f2>
    ed76:	8b 55 10             	mov    0x10(%ebp),%edx
    ed79:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ed7c:	01 d0                	add    %edx,%eax
    ed7e:	0f b6 00             	movzbl (%eax),%eax
    ed81:	84 c0                	test   %al,%al
    ed83:	75 e1                	jne    ed66 <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    ed85:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed88:	83 c0 01             	add    $0x1,%eax
    ed8b:	83 ec 0c             	sub    $0xc,%esp
    ed8e:	50                   	push   %eax
    ed8f:	e8 da 46 ff ff       	call   346e <lodepng_malloc>
    ed94:	83 c4 10             	add    $0x10,%esp
    ed97:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    ed9a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ed9e:	75 0c                	jne    edac <readChunk_iTXt+0x219>
    eda0:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eda7:	e9 0e 01 00 00       	jmp    eeba <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    edac:	8b 45 ec             	mov    -0x14(%ebp),%eax
    edaf:	8b 4d 10             	mov    0x10(%ebp),%ecx
    edb2:	8b 55 d8             	mov    -0x28(%ebp),%edx
    edb5:	01 ca                	add    %ecx,%edx
    edb7:	83 ec 04             	sub    $0x4,%esp
    edba:	50                   	push   %eax
    edbb:	52                   	push   %edx
    edbc:	ff 75 e0             	pushl  -0x20(%ebp)
    edbf:	e8 e8 46 ff ff       	call   34ac <lodepng_memcpy>
    edc4:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    edc7:	8b 55 e0             	mov    -0x20(%ebp),%edx
    edca:	8b 45 ec             	mov    -0x14(%ebp),%eax
    edcd:	01 d0                	add    %edx,%eax
    edcf:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    edd2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    edd5:	8b 45 d8             	mov    -0x28(%ebp),%eax
    edd8:	01 d0                	add    %edx,%eax
    edda:	83 c0 01             	add    $0x1,%eax
    eddd:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    ede0:	8b 45 14             	mov    0x14(%ebp),%eax
    ede3:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ede6:	72 08                	jb     edf0 <readChunk_iTXt+0x25d>
    ede8:	8b 45 14             	mov    0x14(%ebp),%eax
    edeb:	2b 45 d8             	sub    -0x28(%ebp),%eax
    edee:	eb 05                	jmp    edf5 <readChunk_iTXt+0x262>
    edf0:	b8 00 00 00 00       	mov    $0x0,%eax
    edf5:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    edf8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    edfc:	0f 84 90 00 00 00    	je     ee92 <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    ee02:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    ee09:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    ee10:	8b 45 0c             	mov    0xc(%ebp),%eax
    ee13:	8b 40 30             	mov    0x30(%eax),%eax
    ee16:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    ee19:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee1c:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ee1f:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ee22:	01 d1                	add    %edx,%ecx
    ee24:	83 ec 08             	sub    $0x8,%esp
    ee27:	8d 55 c0             	lea    -0x40(%ebp),%edx
    ee2a:	52                   	push   %edx
    ee2b:	50                   	push   %eax
    ee2c:	51                   	push   %ecx
    ee2d:	6a 00                	push   $0x0
    ee2f:	8d 45 b8             	lea    -0x48(%ebp),%eax
    ee32:	50                   	push   %eax
    ee33:	8d 45 bc             	lea    -0x44(%ebp),%eax
    ee36:	50                   	push   %eax
    ee37:	e8 ed 90 ff ff       	call   7f29 <zlib_decompress>
    ee3c:	83 c4 20             	add    $0x20,%esp
    ee3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    ee42:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ee46:	74 11                	je     ee59 <readChunk_iTXt+0x2c6>
    ee48:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ee4b:	8b 45 b8             	mov    -0x48(%ebp),%eax
    ee4e:	39 c2                	cmp    %eax,%edx
    ee50:	7d 07                	jge    ee59 <readChunk_iTXt+0x2c6>
    ee52:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    ee59:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ee5d:	75 22                	jne    ee81 <readChunk_iTXt+0x2ee>
    ee5f:	8b 55 b8             	mov    -0x48(%ebp),%edx
    ee62:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ee65:	83 ec 08             	sub    $0x8,%esp
    ee68:	52                   	push   %edx
    ee69:	50                   	push   %eax
    ee6a:	ff 75 e0             	pushl  -0x20(%ebp)
    ee6d:	ff 75 e4             	pushl  -0x1c(%ebp)
    ee70:	ff 75 e8             	pushl  -0x18(%ebp)
    ee73:	ff 75 08             	pushl  0x8(%ebp)
    ee76:	e8 94 a9 ff ff       	call   980f <lodepng_add_itext_sized>
    ee7b:	83 c4 20             	add    $0x20,%esp
    ee7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    ee81:	8b 45 bc             	mov    -0x44(%ebp),%eax
    ee84:	83 ec 0c             	sub    $0xc,%esp
    ee87:	50                   	push   %eax
    ee88:	e8 02 46 ff ff       	call   348f <lodepng_free>
    ee8d:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    ee90:	eb 27                	jmp    eeb9 <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    ee92:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee95:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ee98:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ee9b:	01 ca                	add    %ecx,%edx
    ee9d:	83 ec 08             	sub    $0x8,%esp
    eea0:	50                   	push   %eax
    eea1:	52                   	push   %edx
    eea2:	ff 75 e0             	pushl  -0x20(%ebp)
    eea5:	ff 75 e4             	pushl  -0x1c(%ebp)
    eea8:	ff 75 e8             	pushl  -0x18(%ebp)
    eeab:	ff 75 08             	pushl  0x8(%ebp)
    eeae:	e8 5c a9 ff ff       	call   980f <lodepng_add_itext_sized>
    eeb3:	83 c4 20             	add    $0x20,%esp
    eeb6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    eeb9:	90                   	nop
  }

  lodepng_free(key);
    eeba:	83 ec 0c             	sub    $0xc,%esp
    eebd:	ff 75 e8             	pushl  -0x18(%ebp)
    eec0:	e8 ca 45 ff ff       	call   348f <lodepng_free>
    eec5:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    eec8:	83 ec 0c             	sub    $0xc,%esp
    eecb:	ff 75 e4             	pushl  -0x1c(%ebp)
    eece:	e8 bc 45 ff ff       	call   348f <lodepng_free>
    eed3:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    eed6:	83 ec 0c             	sub    $0xc,%esp
    eed9:	ff 75 e0             	pushl  -0x20(%ebp)
    eedc:	e8 ae 45 ff ff       	call   348f <lodepng_free>
    eee1:	83 c4 10             	add    $0x10,%esp

  return error;
    eee4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    eee7:	c9                   	leave  
    eee8:	c3                   	ret    

0000eee9 <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    eee9:	55                   	push   %ebp
    eeea:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    eeec:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    eef0:	74 0a                	je     eefc <readChunk_tIME+0x13>
    eef2:	b8 49 00 00 00       	mov    $0x49,%eax
    eef7:	e9 8b 00 00 00       	jmp    ef87 <readChunk_tIME+0x9e>

  info->time_defined = 1;
    eefc:	8b 45 08             	mov    0x8(%ebp),%eax
    eeff:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    ef06:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef09:	0f b6 00             	movzbl (%eax),%eax
    ef0c:	0f b6 c0             	movzbl %al,%eax
    ef0f:	c1 e0 08             	shl    $0x8,%eax
    ef12:	89 c2                	mov    %eax,%edx
    ef14:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef17:	83 c0 01             	add    $0x1,%eax
    ef1a:	0f b6 00             	movzbl (%eax),%eax
    ef1d:	0f b6 c0             	movzbl %al,%eax
    ef20:	01 c2                	add    %eax,%edx
    ef22:	8b 45 08             	mov    0x8(%ebp),%eax
    ef25:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    ef28:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef2b:	83 c0 02             	add    $0x2,%eax
    ef2e:	0f b6 00             	movzbl (%eax),%eax
    ef31:	0f b6 d0             	movzbl %al,%edx
    ef34:	8b 45 08             	mov    0x8(%ebp),%eax
    ef37:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    ef3a:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef3d:	83 c0 03             	add    $0x3,%eax
    ef40:	0f b6 00             	movzbl (%eax),%eax
    ef43:	0f b6 d0             	movzbl %al,%edx
    ef46:	8b 45 08             	mov    0x8(%ebp),%eax
    ef49:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    ef4c:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef4f:	83 c0 04             	add    $0x4,%eax
    ef52:	0f b6 00             	movzbl (%eax),%eax
    ef55:	0f b6 d0             	movzbl %al,%edx
    ef58:	8b 45 08             	mov    0x8(%ebp),%eax
    ef5b:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    ef5e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef61:	83 c0 05             	add    $0x5,%eax
    ef64:	0f b6 00             	movzbl (%eax),%eax
    ef67:	0f b6 d0             	movzbl %al,%edx
    ef6a:	8b 45 08             	mov    0x8(%ebp),%eax
    ef6d:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    ef70:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef73:	83 c0 06             	add    $0x6,%eax
    ef76:	0f b6 00             	movzbl (%eax),%eax
    ef79:	0f b6 d0             	movzbl %al,%edx
    ef7c:	8b 45 08             	mov    0x8(%ebp),%eax
    ef7f:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    ef82:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ef87:	5d                   	pop    %ebp
    ef88:	c3                   	ret    

0000ef89 <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ef89:	55                   	push   %ebp
    ef8a:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    ef8c:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    ef90:	74 0a                	je     ef9c <readChunk_pHYs+0x13>
    ef92:	b8 4a 00 00 00       	mov    $0x4a,%eax
    ef97:	e9 ba 00 00 00       	jmp    f056 <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    ef9c:	8b 45 08             	mov    0x8(%ebp),%eax
    ef9f:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    efa6:	8b 45 0c             	mov    0xc(%ebp),%eax
    efa9:	0f b6 00             	movzbl (%eax),%eax
    efac:	0f b6 c0             	movzbl %al,%eax
    efaf:	c1 e0 08             	shl    $0x8,%eax
    efb2:	89 c2                	mov    %eax,%edx
    efb4:	8b 45 0c             	mov    0xc(%ebp),%eax
    efb7:	83 c0 01             	add    $0x1,%eax
    efba:	0f b6 00             	movzbl (%eax),%eax
    efbd:	0f b6 c0             	movzbl %al,%eax
    efc0:	01 d0                	add    %edx,%eax
    efc2:	c1 e0 08             	shl    $0x8,%eax
    efc5:	89 c2                	mov    %eax,%edx
    efc7:	8b 45 0c             	mov    0xc(%ebp),%eax
    efca:	83 c0 02             	add    $0x2,%eax
    efcd:	0f b6 00             	movzbl (%eax),%eax
    efd0:	0f b6 c0             	movzbl %al,%eax
    efd3:	01 d0                	add    %edx,%eax
    efd5:	c1 e0 08             	shl    $0x8,%eax
    efd8:	89 c2                	mov    %eax,%edx
    efda:	8b 45 0c             	mov    0xc(%ebp),%eax
    efdd:	83 c0 03             	add    $0x3,%eax
    efe0:	0f b6 00             	movzbl (%eax),%eax
    efe3:	0f b6 c0             	movzbl %al,%eax
    efe6:	01 c2                	add    %eax,%edx
    efe8:	8b 45 08             	mov    0x8(%ebp),%eax
    efeb:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    efee:	8b 45 0c             	mov    0xc(%ebp),%eax
    eff1:	83 c0 04             	add    $0x4,%eax
    eff4:	0f b6 00             	movzbl (%eax),%eax
    eff7:	0f b6 c0             	movzbl %al,%eax
    effa:	c1 e0 08             	shl    $0x8,%eax
    effd:	89 c2                	mov    %eax,%edx
    efff:	8b 45 0c             	mov    0xc(%ebp),%eax
    f002:	83 c0 05             	add    $0x5,%eax
    f005:	0f b6 00             	movzbl (%eax),%eax
    f008:	0f b6 c0             	movzbl %al,%eax
    f00b:	01 d0                	add    %edx,%eax
    f00d:	c1 e0 08             	shl    $0x8,%eax
    f010:	89 c2                	mov    %eax,%edx
    f012:	8b 45 0c             	mov    0xc(%ebp),%eax
    f015:	83 c0 06             	add    $0x6,%eax
    f018:	0f b6 00             	movzbl (%eax),%eax
    f01b:	0f b6 c0             	movzbl %al,%eax
    f01e:	01 d0                	add    %edx,%eax
    f020:	c1 e0 08             	shl    $0x8,%eax
    f023:	89 c2                	mov    %eax,%edx
    f025:	8b 45 0c             	mov    0xc(%ebp),%eax
    f028:	83 c0 07             	add    $0x7,%eax
    f02b:	0f b6 00             	movzbl (%eax),%eax
    f02e:	0f b6 c0             	movzbl %al,%eax
    f031:	01 c2                	add    %eax,%edx
    f033:	8b 45 08             	mov    0x8(%ebp),%eax
    f036:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    f03c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f03f:	83 c0 08             	add    $0x8,%eax
    f042:	0f b6 00             	movzbl (%eax),%eax
    f045:	0f b6 d0             	movzbl %al,%edx
    f048:	8b 45 08             	mov    0x8(%ebp),%eax
    f04b:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    f051:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f056:	5d                   	pop    %ebp
    f057:	c3                   	ret    

0000f058 <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f058:	55                   	push   %ebp
    f059:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    f05b:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    f05f:	74 07                	je     f068 <readChunk_gAMA+0x10>
    f061:	b8 60 00 00 00       	mov    $0x60,%eax
    f066:	eb 5d                	jmp    f0c5 <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    f068:	8b 45 08             	mov    0x8(%ebp),%eax
    f06b:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    f072:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    f075:	8b 45 0c             	mov    0xc(%ebp),%eax
    f078:	0f b6 00             	movzbl (%eax),%eax
    f07b:	0f b6 c0             	movzbl %al,%eax
    f07e:	c1 e0 08             	shl    $0x8,%eax
    f081:	89 c2                	mov    %eax,%edx
    f083:	8b 45 0c             	mov    0xc(%ebp),%eax
    f086:	83 c0 01             	add    $0x1,%eax
    f089:	0f b6 00             	movzbl (%eax),%eax
    f08c:	0f b6 c0             	movzbl %al,%eax
    f08f:	01 d0                	add    %edx,%eax
    f091:	c1 e0 08             	shl    $0x8,%eax
    f094:	89 c2                	mov    %eax,%edx
    f096:	8b 45 0c             	mov    0xc(%ebp),%eax
    f099:	83 c0 02             	add    $0x2,%eax
    f09c:	0f b6 00             	movzbl (%eax),%eax
    f09f:	0f b6 c0             	movzbl %al,%eax
    f0a2:	01 d0                	add    %edx,%eax
    f0a4:	c1 e0 08             	shl    $0x8,%eax
    f0a7:	89 c2                	mov    %eax,%edx
    f0a9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0ac:	83 c0 03             	add    $0x3,%eax
    f0af:	0f b6 00             	movzbl (%eax),%eax
    f0b2:	0f b6 c0             	movzbl %al,%eax
    f0b5:	01 c2                	add    %eax,%edx
    f0b7:	8b 45 08             	mov    0x8(%ebp),%eax
    f0ba:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    f0c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f0c5:	5d                   	pop    %ebp
    f0c6:	c3                   	ret    

0000f0c7 <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f0c7:	55                   	push   %ebp
    f0c8:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    f0ca:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    f0ce:	74 0a                	je     f0da <readChunk_cHRM+0x13>
    f0d0:	b8 61 00 00 00       	mov    $0x61,%eax
    f0d5:	e9 7f 02 00 00       	jmp    f359 <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    f0da:	8b 45 08             	mov    0x8(%ebp),%eax
    f0dd:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    f0e4:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    f0e7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0ea:	0f b6 00             	movzbl (%eax),%eax
    f0ed:	0f b6 c0             	movzbl %al,%eax
    f0f0:	c1 e0 08             	shl    $0x8,%eax
    f0f3:	89 c2                	mov    %eax,%edx
    f0f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0f8:	83 c0 01             	add    $0x1,%eax
    f0fb:	0f b6 00             	movzbl (%eax),%eax
    f0fe:	0f b6 c0             	movzbl %al,%eax
    f101:	01 d0                	add    %edx,%eax
    f103:	c1 e0 08             	shl    $0x8,%eax
    f106:	89 c2                	mov    %eax,%edx
    f108:	8b 45 0c             	mov    0xc(%ebp),%eax
    f10b:	83 c0 02             	add    $0x2,%eax
    f10e:	0f b6 00             	movzbl (%eax),%eax
    f111:	0f b6 c0             	movzbl %al,%eax
    f114:	01 d0                	add    %edx,%eax
    f116:	c1 e0 08             	shl    $0x8,%eax
    f119:	89 c2                	mov    %eax,%edx
    f11b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f11e:	83 c0 03             	add    $0x3,%eax
    f121:	0f b6 00             	movzbl (%eax),%eax
    f124:	0f b6 c0             	movzbl %al,%eax
    f127:	01 c2                	add    %eax,%edx
    f129:	8b 45 08             	mov    0x8(%ebp),%eax
    f12c:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    f132:	8b 45 0c             	mov    0xc(%ebp),%eax
    f135:	83 c0 04             	add    $0x4,%eax
    f138:	0f b6 00             	movzbl (%eax),%eax
    f13b:	0f b6 c0             	movzbl %al,%eax
    f13e:	c1 e0 08             	shl    $0x8,%eax
    f141:	89 c2                	mov    %eax,%edx
    f143:	8b 45 0c             	mov    0xc(%ebp),%eax
    f146:	83 c0 05             	add    $0x5,%eax
    f149:	0f b6 00             	movzbl (%eax),%eax
    f14c:	0f b6 c0             	movzbl %al,%eax
    f14f:	01 d0                	add    %edx,%eax
    f151:	c1 e0 08             	shl    $0x8,%eax
    f154:	89 c2                	mov    %eax,%edx
    f156:	8b 45 0c             	mov    0xc(%ebp),%eax
    f159:	83 c0 06             	add    $0x6,%eax
    f15c:	0f b6 00             	movzbl (%eax),%eax
    f15f:	0f b6 c0             	movzbl %al,%eax
    f162:	01 d0                	add    %edx,%eax
    f164:	c1 e0 08             	shl    $0x8,%eax
    f167:	89 c2                	mov    %eax,%edx
    f169:	8b 45 0c             	mov    0xc(%ebp),%eax
    f16c:	83 c0 07             	add    $0x7,%eax
    f16f:	0f b6 00             	movzbl (%eax),%eax
    f172:	0f b6 c0             	movzbl %al,%eax
    f175:	01 c2                	add    %eax,%edx
    f177:	8b 45 08             	mov    0x8(%ebp),%eax
    f17a:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    f180:	8b 45 0c             	mov    0xc(%ebp),%eax
    f183:	83 c0 08             	add    $0x8,%eax
    f186:	0f b6 00             	movzbl (%eax),%eax
    f189:	0f b6 c0             	movzbl %al,%eax
    f18c:	c1 e0 08             	shl    $0x8,%eax
    f18f:	89 c2                	mov    %eax,%edx
    f191:	8b 45 0c             	mov    0xc(%ebp),%eax
    f194:	83 c0 09             	add    $0x9,%eax
    f197:	0f b6 00             	movzbl (%eax),%eax
    f19a:	0f b6 c0             	movzbl %al,%eax
    f19d:	01 d0                	add    %edx,%eax
    f19f:	c1 e0 08             	shl    $0x8,%eax
    f1a2:	89 c2                	mov    %eax,%edx
    f1a4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1a7:	83 c0 0a             	add    $0xa,%eax
    f1aa:	0f b6 00             	movzbl (%eax),%eax
    f1ad:	0f b6 c0             	movzbl %al,%eax
    f1b0:	01 d0                	add    %edx,%eax
    f1b2:	c1 e0 08             	shl    $0x8,%eax
    f1b5:	89 c2                	mov    %eax,%edx
    f1b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1ba:	83 c0 0b             	add    $0xb,%eax
    f1bd:	0f b6 00             	movzbl (%eax),%eax
    f1c0:	0f b6 c0             	movzbl %al,%eax
    f1c3:	01 c2                	add    %eax,%edx
    f1c5:	8b 45 08             	mov    0x8(%ebp),%eax
    f1c8:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    f1ce:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1d1:	83 c0 0c             	add    $0xc,%eax
    f1d4:	0f b6 00             	movzbl (%eax),%eax
    f1d7:	0f b6 c0             	movzbl %al,%eax
    f1da:	c1 e0 08             	shl    $0x8,%eax
    f1dd:	89 c2                	mov    %eax,%edx
    f1df:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1e2:	83 c0 0d             	add    $0xd,%eax
    f1e5:	0f b6 00             	movzbl (%eax),%eax
    f1e8:	0f b6 c0             	movzbl %al,%eax
    f1eb:	01 d0                	add    %edx,%eax
    f1ed:	c1 e0 08             	shl    $0x8,%eax
    f1f0:	89 c2                	mov    %eax,%edx
    f1f2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1f5:	83 c0 0e             	add    $0xe,%eax
    f1f8:	0f b6 00             	movzbl (%eax),%eax
    f1fb:	0f b6 c0             	movzbl %al,%eax
    f1fe:	01 d0                	add    %edx,%eax
    f200:	c1 e0 08             	shl    $0x8,%eax
    f203:	89 c2                	mov    %eax,%edx
    f205:	8b 45 0c             	mov    0xc(%ebp),%eax
    f208:	83 c0 0f             	add    $0xf,%eax
    f20b:	0f b6 00             	movzbl (%eax),%eax
    f20e:	0f b6 c0             	movzbl %al,%eax
    f211:	01 c2                	add    %eax,%edx
    f213:	8b 45 08             	mov    0x8(%ebp),%eax
    f216:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    f21c:	8b 45 0c             	mov    0xc(%ebp),%eax
    f21f:	83 c0 10             	add    $0x10,%eax
    f222:	0f b6 00             	movzbl (%eax),%eax
    f225:	0f b6 c0             	movzbl %al,%eax
    f228:	c1 e0 08             	shl    $0x8,%eax
    f22b:	89 c2                	mov    %eax,%edx
    f22d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f230:	83 c0 11             	add    $0x11,%eax
    f233:	0f b6 00             	movzbl (%eax),%eax
    f236:	0f b6 c0             	movzbl %al,%eax
    f239:	01 d0                	add    %edx,%eax
    f23b:	c1 e0 08             	shl    $0x8,%eax
    f23e:	89 c2                	mov    %eax,%edx
    f240:	8b 45 0c             	mov    0xc(%ebp),%eax
    f243:	83 c0 12             	add    $0x12,%eax
    f246:	0f b6 00             	movzbl (%eax),%eax
    f249:	0f b6 c0             	movzbl %al,%eax
    f24c:	01 d0                	add    %edx,%eax
    f24e:	c1 e0 08             	shl    $0x8,%eax
    f251:	89 c2                	mov    %eax,%edx
    f253:	8b 45 0c             	mov    0xc(%ebp),%eax
    f256:	83 c0 13             	add    $0x13,%eax
    f259:	0f b6 00             	movzbl (%eax),%eax
    f25c:	0f b6 c0             	movzbl %al,%eax
    f25f:	01 c2                	add    %eax,%edx
    f261:	8b 45 08             	mov    0x8(%ebp),%eax
    f264:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    f26a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f26d:	83 c0 14             	add    $0x14,%eax
    f270:	0f b6 00             	movzbl (%eax),%eax
    f273:	0f b6 c0             	movzbl %al,%eax
    f276:	c1 e0 08             	shl    $0x8,%eax
    f279:	89 c2                	mov    %eax,%edx
    f27b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f27e:	83 c0 15             	add    $0x15,%eax
    f281:	0f b6 00             	movzbl (%eax),%eax
    f284:	0f b6 c0             	movzbl %al,%eax
    f287:	01 d0                	add    %edx,%eax
    f289:	c1 e0 08             	shl    $0x8,%eax
    f28c:	89 c2                	mov    %eax,%edx
    f28e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f291:	83 c0 16             	add    $0x16,%eax
    f294:	0f b6 00             	movzbl (%eax),%eax
    f297:	0f b6 c0             	movzbl %al,%eax
    f29a:	01 d0                	add    %edx,%eax
    f29c:	c1 e0 08             	shl    $0x8,%eax
    f29f:	89 c2                	mov    %eax,%edx
    f2a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2a4:	83 c0 17             	add    $0x17,%eax
    f2a7:	0f b6 00             	movzbl (%eax),%eax
    f2aa:	0f b6 c0             	movzbl %al,%eax
    f2ad:	01 c2                	add    %eax,%edx
    f2af:	8b 45 08             	mov    0x8(%ebp),%eax
    f2b2:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    f2b8:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2bb:	83 c0 18             	add    $0x18,%eax
    f2be:	0f b6 00             	movzbl (%eax),%eax
    f2c1:	0f b6 c0             	movzbl %al,%eax
    f2c4:	c1 e0 08             	shl    $0x8,%eax
    f2c7:	89 c2                	mov    %eax,%edx
    f2c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2cc:	83 c0 19             	add    $0x19,%eax
    f2cf:	0f b6 00             	movzbl (%eax),%eax
    f2d2:	0f b6 c0             	movzbl %al,%eax
    f2d5:	01 d0                	add    %edx,%eax
    f2d7:	c1 e0 08             	shl    $0x8,%eax
    f2da:	89 c2                	mov    %eax,%edx
    f2dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2df:	83 c0 1a             	add    $0x1a,%eax
    f2e2:	0f b6 00             	movzbl (%eax),%eax
    f2e5:	0f b6 c0             	movzbl %al,%eax
    f2e8:	01 d0                	add    %edx,%eax
    f2ea:	c1 e0 08             	shl    $0x8,%eax
    f2ed:	89 c2                	mov    %eax,%edx
    f2ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2f2:	83 c0 1b             	add    $0x1b,%eax
    f2f5:	0f b6 00             	movzbl (%eax),%eax
    f2f8:	0f b6 c0             	movzbl %al,%eax
    f2fb:	01 c2                	add    %eax,%edx
    f2fd:	8b 45 08             	mov    0x8(%ebp),%eax
    f300:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    f306:	8b 45 0c             	mov    0xc(%ebp),%eax
    f309:	83 c0 1c             	add    $0x1c,%eax
    f30c:	0f b6 00             	movzbl (%eax),%eax
    f30f:	0f b6 c0             	movzbl %al,%eax
    f312:	c1 e0 08             	shl    $0x8,%eax
    f315:	89 c2                	mov    %eax,%edx
    f317:	8b 45 0c             	mov    0xc(%ebp),%eax
    f31a:	83 c0 1d             	add    $0x1d,%eax
    f31d:	0f b6 00             	movzbl (%eax),%eax
    f320:	0f b6 c0             	movzbl %al,%eax
    f323:	01 d0                	add    %edx,%eax
    f325:	c1 e0 08             	shl    $0x8,%eax
    f328:	89 c2                	mov    %eax,%edx
    f32a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f32d:	83 c0 1e             	add    $0x1e,%eax
    f330:	0f b6 00             	movzbl (%eax),%eax
    f333:	0f b6 c0             	movzbl %al,%eax
    f336:	01 d0                	add    %edx,%eax
    f338:	c1 e0 08             	shl    $0x8,%eax
    f33b:	89 c2                	mov    %eax,%edx
    f33d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f340:	83 c0 1f             	add    $0x1f,%eax
    f343:	0f b6 00             	movzbl (%eax),%eax
    f346:	0f b6 c0             	movzbl %al,%eax
    f349:	01 c2                	add    %eax,%edx
    f34b:	8b 45 08             	mov    0x8(%ebp),%eax
    f34e:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    f354:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f359:	5d                   	pop    %ebp
    f35a:	c3                   	ret    

0000f35b <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f35b:	55                   	push   %ebp
    f35c:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    f35e:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f362:	74 07                	je     f36b <readChunk_sRGB+0x10>
    f364:	b8 62 00 00 00       	mov    $0x62,%eax
    f369:	eb 24                	jmp    f38f <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    f36b:	8b 45 08             	mov    0x8(%ebp),%eax
    f36e:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    f375:	00 00 00 
  info->srgb_intent = data[0];
    f378:	8b 45 0c             	mov    0xc(%ebp),%eax
    f37b:	0f b6 00             	movzbl (%eax),%eax
    f37e:	0f b6 d0             	movzbl %al,%edx
    f381:	8b 45 08             	mov    0x8(%ebp),%eax
    f384:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    f38a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f38f:	5d                   	pop    %ebp
    f390:	c3                   	ret    

0000f391 <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f391:	55                   	push   %ebp
    f392:	89 e5                	mov    %esp,%ebp
    f394:	53                   	push   %ebx
    f395:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    f398:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    f39f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f3a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3a9:	8b 10                	mov    (%eax),%edx
    f3ab:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f3ae:	8b 50 04             	mov    0x4(%eax),%edx
    f3b1:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f3b4:	8b 50 08             	mov    0x8(%eax),%edx
    f3b7:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f3ba:	8b 50 0c             	mov    0xc(%eax),%edx
    f3bd:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f3c0:	8b 50 10             	mov    0x10(%eax),%edx
    f3c3:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f3c6:	8b 40 14             	mov    0x14(%eax),%eax
    f3c9:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    f3cc:	8b 45 08             	mov    0x8(%ebp),%eax
    f3cf:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    f3d6:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    f3d9:	8b 45 08             	mov    0x8(%ebp),%eax
    f3dc:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f3e2:	85 c0                	test   %eax,%eax
    f3e4:	74 0e                	je     f3f4 <readChunk_iCCP+0x63>
    f3e6:	83 ec 0c             	sub    $0xc,%esp
    f3e9:	ff 75 08             	pushl  0x8(%ebp)
    f3ec:	e8 ca a6 ff ff       	call   9abb <lodepng_clear_icc>
    f3f1:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f3f4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f3fb:	eb 04                	jmp    f401 <readChunk_iCCP+0x70>
    f3fd:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f401:	8b 45 14             	mov    0x14(%ebp),%eax
    f404:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f407:	73 0f                	jae    f418 <readChunk_iCCP+0x87>
    f409:	8b 55 10             	mov    0x10(%ebp),%edx
    f40c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f40f:	01 d0                	add    %edx,%eax
    f411:	0f b6 00             	movzbl (%eax),%eax
    f414:	84 c0                	test   %al,%al
    f416:	75 e5                	jne    f3fd <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    f418:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f41b:	8d 50 02             	lea    0x2(%eax),%edx
    f41e:	8b 45 14             	mov    0x14(%ebp),%eax
    f421:	39 c2                	cmp    %eax,%edx
    f423:	72 0a                	jb     f42f <readChunk_iCCP+0x9e>
    f425:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f42a:	e9 46 01 00 00       	jmp    f575 <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    f42f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f433:	74 06                	je     f43b <readChunk_iCCP+0xaa>
    f435:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f439:	76 0a                	jbe    f445 <readChunk_iCCP+0xb4>
    f43b:	b8 59 00 00 00       	mov    $0x59,%eax
    f440:	e9 30 01 00 00       	jmp    f575 <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    f445:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f448:	83 c0 01             	add    $0x1,%eax
    f44b:	83 ec 0c             	sub    $0xc,%esp
    f44e:	50                   	push   %eax
    f44f:	e8 1a 40 ff ff       	call   346e <lodepng_malloc>
    f454:	83 c4 10             	add    $0x10,%esp
    f457:	89 c2                	mov    %eax,%edx
    f459:	8b 45 08             	mov    0x8(%ebp),%eax
    f45c:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    f462:	8b 45 08             	mov    0x8(%ebp),%eax
    f465:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f46b:	85 c0                	test   %eax,%eax
    f46d:	75 0a                	jne    f479 <readChunk_iCCP+0xe8>
    f46f:	b8 53 00 00 00       	mov    $0x53,%eax
    f474:	e9 fc 00 00 00       	jmp    f575 <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    f479:	8b 45 08             	mov    0x8(%ebp),%eax
    f47c:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f482:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f485:	01 d0                	add    %edx,%eax
    f487:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    f48a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f491:	eb 1f                	jmp    f4b2 <readChunk_iCCP+0x121>
    f493:	8b 45 08             	mov    0x8(%ebp),%eax
    f496:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f49c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f49f:	01 d0                	add    %edx,%eax
    f4a1:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f4a4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f4a7:	01 ca                	add    %ecx,%edx
    f4a9:	0f b6 12             	movzbl (%edx),%edx
    f4ac:	88 10                	mov    %dl,(%eax)
    f4ae:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f4b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f4b5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f4b8:	75 d9                	jne    f493 <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    f4ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f4bd:	8d 50 01             	lea    0x1(%eax),%edx
    f4c0:	8b 45 10             	mov    0x10(%ebp),%eax
    f4c3:	01 d0                	add    %edx,%eax
    f4c5:	0f b6 00             	movzbl (%eax),%eax
    f4c8:	84 c0                	test   %al,%al
    f4ca:	74 0a                	je     f4d6 <readChunk_iCCP+0x145>
    f4cc:	b8 48 00 00 00       	mov    $0x48,%eax
    f4d1:	e9 9f 00 00 00       	jmp    f575 <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    f4d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f4d9:	83 c0 02             	add    $0x2,%eax
    f4dc:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    f4df:	8b 45 14             	mov    0x14(%ebp),%eax
    f4e2:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f4e5:	76 0a                	jbe    f4f1 <readChunk_iCCP+0x160>
    f4e7:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f4ec:	e9 84 00 00 00       	jmp    f575 <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    f4f1:	8b 45 14             	mov    0x14(%ebp),%eax
    f4f4:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f4f7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    f4fa:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4fd:	8b 40 34             	mov    0x34(%eax),%eax
    f500:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    f503:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f506:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f509:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f50c:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    f50f:	8b 55 08             	mov    0x8(%ebp),%edx
    f512:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    f518:	83 ec 08             	sub    $0x8,%esp
    f51b:	8d 55 cc             	lea    -0x34(%ebp),%edx
    f51e:	52                   	push   %edx
    f51f:	50                   	push   %eax
    f520:	53                   	push   %ebx
    f521:	6a 00                	push   $0x0
    f523:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    f526:	50                   	push   %eax
    f527:	51                   	push   %ecx
    f528:	e8 fc 89 ff ff       	call   7f29 <zlib_decompress>
    f52d:	83 c4 20             	add    $0x20,%esp
    f530:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    f533:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f537:	74 11                	je     f54a <readChunk_iCCP+0x1b9>
    f539:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    f53c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f53f:	39 c2                	cmp    %eax,%edx
    f541:	7d 07                	jge    f54a <readChunk_iCCP+0x1b9>
    f543:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    f54a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f54d:	89 c2                	mov    %eax,%edx
    f54f:	8b 45 08             	mov    0x8(%ebp),%eax
    f552:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    f558:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f55c:	75 14                	jne    f572 <readChunk_iCCP+0x1e1>
    f55e:	8b 45 08             	mov    0x8(%ebp),%eax
    f561:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    f567:	85 c0                	test   %eax,%eax
    f569:	75 07                	jne    f572 <readChunk_iCCP+0x1e1>
    f56b:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    f572:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f575:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f578:	c9                   	leave  
    f579:	c3                   	ret    

0000f57a <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    f57a:	55                   	push   %ebp
    f57b:	89 e5                	mov    %esp,%ebp
    f57d:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    f580:	8b 55 0c             	mov    0xc(%ebp),%edx
    f583:	8b 45 10             	mov    0x10(%ebp),%eax
    f586:	01 d0                	add    %edx,%eax
    f588:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    f58b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    f592:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    f599:	8b 45 0c             	mov    0xc(%ebp),%eax
    f59c:	83 c0 04             	add    $0x4,%eax
    f59f:	3b 45 14             	cmp    0x14(%ebp),%eax
    f5a2:	7e 0a                	jle    f5ae <lodepng_inspect_chunk+0x34>
    f5a4:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f5a9:	e9 43 03 00 00       	jmp    f8f1 <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    f5ae:	ff 75 ec             	pushl  -0x14(%ebp)
    f5b1:	e8 3a 8e ff ff       	call   83f0 <lodepng_chunk_length>
    f5b6:	83 c4 04             	add    $0x4,%esp
    f5b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    f5bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f5bf:	85 c0                	test   %eax,%eax
    f5c1:	79 0a                	jns    f5cd <lodepng_inspect_chunk+0x53>
    f5c3:	b8 3f 00 00 00       	mov    $0x3f,%eax
    f5c8:	e9 24 03 00 00       	jmp    f8f1 <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
    f5cd:	ff 75 ec             	pushl  -0x14(%ebp)
    f5d0:	e8 53 8f ff ff       	call   8528 <lodepng_chunk_data_const>
    f5d5:	83 c4 04             	add    $0x4,%esp
    f5d8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
    f5db:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f5de:	8d 50 04             	lea    0x4(%eax),%edx
    f5e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f5e4:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    f5e7:	8b 55 14             	mov    0x14(%ebp),%edx
    f5ea:	8b 45 10             	mov    0x10(%ebp),%eax
    f5ed:	01 d0                	add    %edx,%eax
    f5ef:	39 c1                	cmp    %eax,%ecx
    f5f1:	76 0a                	jbe    f5fd <lodepng_inspect_chunk+0x83>
    f5f3:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f5f8:	e9 f4 02 00 00       	jmp    f8f1 <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    f5fd:	68 a8 a1 01 00       	push   $0x1a1a8
    f602:	ff 75 ec             	pushl  -0x14(%ebp)
    f605:	e8 33 8e ff ff       	call   843d <lodepng_chunk_type_equals>
    f60a:	83 c4 08             	add    $0x8,%esp
    f60d:	84 c0                	test   %al,%al
    f60f:	74 24                	je     f635 <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    f611:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f614:	8b 55 08             	mov    0x8(%ebp),%edx
    f617:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f61d:	83 ec 04             	sub    $0x4,%esp
    f620:	50                   	push   %eax
    f621:	ff 75 e4             	pushl  -0x1c(%ebp)
    f624:	52                   	push   %edx
    f625:	e8 5b ee ff ff       	call   e485 <readChunk_PLTE>
    f62a:	83 c4 10             	add    $0x10,%esp
    f62d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f630:	e9 8a 02 00 00       	jmp    f8bf <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    f635:	83 ec 08             	sub    $0x8,%esp
    f638:	68 ad a1 01 00       	push   $0x1a1ad
    f63d:	ff 75 ec             	pushl  -0x14(%ebp)
    f640:	e8 f8 8d ff ff       	call   843d <lodepng_chunk_type_equals>
    f645:	83 c4 10             	add    $0x10,%esp
    f648:	84 c0                	test   %al,%al
    f64a:	74 24                	je     f670 <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    f64c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f64f:	8b 55 08             	mov    0x8(%ebp),%edx
    f652:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f658:	83 ec 04             	sub    $0x4,%esp
    f65b:	50                   	push   %eax
    f65c:	ff 75 e4             	pushl  -0x1c(%ebp)
    f65f:	52                   	push   %edx
    f660:	e8 40 ef ff ff       	call   e5a5 <readChunk_tRNS>
    f665:	83 c4 10             	add    $0x10,%esp
    f668:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f66b:	e9 4f 02 00 00       	jmp    f8bf <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    f670:	83 ec 08             	sub    $0x8,%esp
    f673:	68 b2 a1 01 00       	push   $0x1a1b2
    f678:	ff 75 ec             	pushl  -0x14(%ebp)
    f67b:	e8 bd 8d ff ff       	call   843d <lodepng_chunk_type_equals>
    f680:	83 c4 10             	add    $0x10,%esp
    f683:	84 c0                	test   %al,%al
    f685:	74 24                	je     f6ab <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
    f687:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f68a:	8b 55 08             	mov    0x8(%ebp),%edx
    f68d:	81 c2 98 00 00 00    	add    $0x98,%edx
    f693:	83 ec 04             	sub    $0x4,%esp
    f696:	50                   	push   %eax
    f697:	ff 75 e4             	pushl  -0x1c(%ebp)
    f69a:	52                   	push   %edx
    f69b:	e8 68 f0 ff ff       	call   e708 <readChunk_bKGD>
    f6a0:	83 c4 10             	add    $0x10,%esp
    f6a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6a6:	e9 14 02 00 00       	jmp    f8bf <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    f6ab:	83 ec 08             	sub    $0x8,%esp
    f6ae:	68 b7 a1 01 00       	push   $0x1a1b7
    f6b3:	ff 75 ec             	pushl  -0x14(%ebp)
    f6b6:	e8 82 8d ff ff       	call   843d <lodepng_chunk_type_equals>
    f6bb:	83 c4 10             	add    $0x10,%esp
    f6be:	84 c0                	test   %al,%al
    f6c0:	74 24                	je     f6e6 <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
    f6c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f6c5:	8b 55 08             	mov    0x8(%ebp),%edx
    f6c8:	81 c2 98 00 00 00    	add    $0x98,%edx
    f6ce:	83 ec 04             	sub    $0x4,%esp
    f6d1:	50                   	push   %eax
    f6d2:	ff 75 e4             	pushl  -0x1c(%ebp)
    f6d5:	52                   	push   %edx
    f6d6:	e8 b0 f1 ff ff       	call   e88b <readChunk_tEXt>
    f6db:	83 c4 10             	add    $0x10,%esp
    f6de:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f6e1:	e9 d9 01 00 00       	jmp    f8bf <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    f6e6:	83 ec 08             	sub    $0x8,%esp
    f6e9:	68 bc a1 01 00       	push   $0x1a1bc
    f6ee:	ff 75 ec             	pushl  -0x14(%ebp)
    f6f1:	e8 47 8d ff ff       	call   843d <lodepng_chunk_type_equals>
    f6f6:	83 c4 10             	add    $0x10,%esp
    f6f9:	84 c0                	test   %al,%al
    f6fb:	74 25                	je     f722 <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    f6fd:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f700:	8b 45 08             	mov    0x8(%ebp),%eax
    f703:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f706:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f70c:	52                   	push   %edx
    f70d:	ff 75 e4             	pushl  -0x1c(%ebp)
    f710:	50                   	push   %eax
    f711:	51                   	push   %ecx
    f712:	e8 c0 f2 ff ff       	call   e9d7 <readChunk_zTXt>
    f717:	83 c4 10             	add    $0x10,%esp
    f71a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f71d:	e9 9d 01 00 00       	jmp    f8bf <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    f722:	83 ec 08             	sub    $0x8,%esp
    f725:	68 c1 a1 01 00       	push   $0x1a1c1
    f72a:	ff 75 ec             	pushl  -0x14(%ebp)
    f72d:	e8 0b 8d ff ff       	call   843d <lodepng_chunk_type_equals>
    f732:	83 c4 10             	add    $0x10,%esp
    f735:	84 c0                	test   %al,%al
    f737:	74 25                	je     f75e <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    f739:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f73c:	8b 45 08             	mov    0x8(%ebp),%eax
    f73f:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f742:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f748:	52                   	push   %edx
    f749:	ff 75 e4             	pushl  -0x1c(%ebp)
    f74c:	50                   	push   %eax
    f74d:	51                   	push   %ecx
    f74e:	e8 40 f4 ff ff       	call   eb93 <readChunk_iTXt>
    f753:	83 c4 10             	add    $0x10,%esp
    f756:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f759:	e9 61 01 00 00       	jmp    f8bf <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    f75e:	83 ec 08             	sub    $0x8,%esp
    f761:	68 c6 a1 01 00       	push   $0x1a1c6
    f766:	ff 75 ec             	pushl  -0x14(%ebp)
    f769:	e8 cf 8c ff ff       	call   843d <lodepng_chunk_type_equals>
    f76e:	83 c4 10             	add    $0x10,%esp
    f771:	84 c0                	test   %al,%al
    f773:	74 24                	je     f799 <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
    f775:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f778:	8b 55 08             	mov    0x8(%ebp),%edx
    f77b:	81 c2 98 00 00 00    	add    $0x98,%edx
    f781:	83 ec 04             	sub    $0x4,%esp
    f784:	50                   	push   %eax
    f785:	ff 75 e4             	pushl  -0x1c(%ebp)
    f788:	52                   	push   %edx
    f789:	e8 5b f7 ff ff       	call   eee9 <readChunk_tIME>
    f78e:	83 c4 10             	add    $0x10,%esp
    f791:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f794:	e9 26 01 00 00       	jmp    f8bf <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    f799:	83 ec 08             	sub    $0x8,%esp
    f79c:	68 cb a1 01 00       	push   $0x1a1cb
    f7a1:	ff 75 ec             	pushl  -0x14(%ebp)
    f7a4:	e8 94 8c ff ff       	call   843d <lodepng_chunk_type_equals>
    f7a9:	83 c4 10             	add    $0x10,%esp
    f7ac:	84 c0                	test   %al,%al
    f7ae:	74 24                	je     f7d4 <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
    f7b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f7b3:	8b 55 08             	mov    0x8(%ebp),%edx
    f7b6:	81 c2 98 00 00 00    	add    $0x98,%edx
    f7bc:	83 ec 04             	sub    $0x4,%esp
    f7bf:	50                   	push   %eax
    f7c0:	ff 75 e4             	pushl  -0x1c(%ebp)
    f7c3:	52                   	push   %edx
    f7c4:	e8 c0 f7 ff ff       	call   ef89 <readChunk_pHYs>
    f7c9:	83 c4 10             	add    $0x10,%esp
    f7cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f7cf:	e9 eb 00 00 00       	jmp    f8bf <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    f7d4:	83 ec 08             	sub    $0x8,%esp
    f7d7:	68 d0 a1 01 00       	push   $0x1a1d0
    f7dc:	ff 75 ec             	pushl  -0x14(%ebp)
    f7df:	e8 59 8c ff ff       	call   843d <lodepng_chunk_type_equals>
    f7e4:	83 c4 10             	add    $0x10,%esp
    f7e7:	84 c0                	test   %al,%al
    f7e9:	74 24                	je     f80f <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
    f7eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f7ee:	8b 55 08             	mov    0x8(%ebp),%edx
    f7f1:	81 c2 98 00 00 00    	add    $0x98,%edx
    f7f7:	83 ec 04             	sub    $0x4,%esp
    f7fa:	50                   	push   %eax
    f7fb:	ff 75 e4             	pushl  -0x1c(%ebp)
    f7fe:	52                   	push   %edx
    f7ff:	e8 54 f8 ff ff       	call   f058 <readChunk_gAMA>
    f804:	83 c4 10             	add    $0x10,%esp
    f807:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f80a:	e9 b0 00 00 00       	jmp    f8bf <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    f80f:	83 ec 08             	sub    $0x8,%esp
    f812:	68 d5 a1 01 00       	push   $0x1a1d5
    f817:	ff 75 ec             	pushl  -0x14(%ebp)
    f81a:	e8 1e 8c ff ff       	call   843d <lodepng_chunk_type_equals>
    f81f:	83 c4 10             	add    $0x10,%esp
    f822:	84 c0                	test   %al,%al
    f824:	74 21                	je     f847 <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
    f826:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f829:	8b 55 08             	mov    0x8(%ebp),%edx
    f82c:	81 c2 98 00 00 00    	add    $0x98,%edx
    f832:	83 ec 04             	sub    $0x4,%esp
    f835:	50                   	push   %eax
    f836:	ff 75 e4             	pushl  -0x1c(%ebp)
    f839:	52                   	push   %edx
    f83a:	e8 88 f8 ff ff       	call   f0c7 <readChunk_cHRM>
    f83f:	83 c4 10             	add    $0x10,%esp
    f842:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f845:	eb 78                	jmp    f8bf <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    f847:	83 ec 08             	sub    $0x8,%esp
    f84a:	68 da a1 01 00       	push   $0x1a1da
    f84f:	ff 75 ec             	pushl  -0x14(%ebp)
    f852:	e8 e6 8b ff ff       	call   843d <lodepng_chunk_type_equals>
    f857:	83 c4 10             	add    $0x10,%esp
    f85a:	84 c0                	test   %al,%al
    f85c:	74 21                	je     f87f <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
    f85e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f861:	8b 55 08             	mov    0x8(%ebp),%edx
    f864:	81 c2 98 00 00 00    	add    $0x98,%edx
    f86a:	83 ec 04             	sub    $0x4,%esp
    f86d:	50                   	push   %eax
    f86e:	ff 75 e4             	pushl  -0x1c(%ebp)
    f871:	52                   	push   %edx
    f872:	e8 e4 fa ff ff       	call   f35b <readChunk_sRGB>
    f877:	83 c4 10             	add    $0x10,%esp
    f87a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f87d:	eb 40                	jmp    f8bf <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    f87f:	83 ec 08             	sub    $0x8,%esp
    f882:	68 df a1 01 00       	push   $0x1a1df
    f887:	ff 75 ec             	pushl  -0x14(%ebp)
    f88a:	e8 ae 8b ff ff       	call   843d <lodepng_chunk_type_equals>
    f88f:	83 c4 10             	add    $0x10,%esp
    f892:	84 c0                	test   %al,%al
    f894:	74 22                	je     f8b8 <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    f896:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f899:	8b 45 08             	mov    0x8(%ebp),%eax
    f89c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f89f:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f8a5:	52                   	push   %edx
    f8a6:	ff 75 e4             	pushl  -0x1c(%ebp)
    f8a9:	50                   	push   %eax
    f8aa:	51                   	push   %ecx
    f8ab:	e8 e1 fa ff ff       	call   f391 <readChunk_iCCP>
    f8b0:	83 c4 10             	add    $0x10,%esp
    f8b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f8b6:	eb 07                	jmp    f8bf <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
    f8b8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
    f8bf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    f8c3:	75 29                	jne    f8ee <lodepng_inspect_chunk+0x374>
    f8c5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f8c9:	75 23                	jne    f8ee <lodepng_inspect_chunk+0x374>
    f8cb:	8b 45 08             	mov    0x8(%ebp),%eax
    f8ce:	8b 40 18             	mov    0x18(%eax),%eax
    f8d1:	85 c0                	test   %eax,%eax
    f8d3:	75 19                	jne    f8ee <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
    f8d5:	83 ec 0c             	sub    $0xc,%esp
    f8d8:	ff 75 ec             	pushl  -0x14(%ebp)
    f8db:	e8 53 8c ff ff       	call   8533 <lodepng_chunk_check_crc>
    f8e0:	83 c4 10             	add    $0x10,%esp
    f8e3:	85 c0                	test   %eax,%eax
    f8e5:	74 07                	je     f8ee <lodepng_inspect_chunk+0x374>
    f8e7:	b8 39 00 00 00       	mov    $0x39,%eax
    f8ec:	eb 03                	jmp    f8f1 <lodepng_inspect_chunk+0x377>
  }

  return error;
    f8ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    f8f1:	c9                   	leave  
    f8f2:	c3                   	ret    

0000f8f3 <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
    f8f3:	55                   	push   %ebp
    f8f4:	89 e5                	mov    %esp,%ebp
    f8f6:	56                   	push   %esi
    f8f7:	53                   	push   %ebx
    f8f8:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
    f8fb:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
    f8ff:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
    f906:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
    f90d:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    f914:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
    f91b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
    f922:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
    f929:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
    f930:	8b 45 08             	mov    0x8(%ebp),%eax
    f933:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
    f939:	8b 45 10             	mov    0x10(%ebp),%eax
    f93c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    f942:	8b 45 10             	mov    0x10(%ebp),%eax
    f945:	8b 10                	mov    (%eax),%edx
    f947:	8b 45 0c             	mov    0xc(%ebp),%eax
    f94a:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
    f94c:	83 ec 0c             	sub    $0xc,%esp
    f94f:	ff 75 1c             	pushl  0x1c(%ebp)
    f952:	ff 75 18             	pushl  0x18(%ebp)
    f955:	ff 75 14             	pushl  0x14(%ebp)
    f958:	ff 75 10             	pushl  0x10(%ebp)
    f95b:	ff 75 0c             	pushl  0xc(%ebp)
    f95e:	e8 d3 da ff ff       	call   d436 <lodepng_inspect>
    f963:	83 c4 20             	add    $0x20,%esp
    f966:	89 c2                	mov    %eax,%edx
    f968:	8b 45 14             	mov    0x14(%ebp),%eax
    f96b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
    f971:	8b 45 14             	mov    0x14(%ebp),%eax
    f974:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    f97a:	85 c0                	test   %eax,%eax
    f97c:	0f 85 24 0a 00 00    	jne    103a6 <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
    f982:	8b 45 14             	mov    0x14(%ebp),%eax
    f985:	8d 58 78             	lea    0x78(%eax),%ebx
    f988:	8b 45 14             	mov    0x14(%ebp),%eax
    f98b:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
    f991:	8b 45 10             	mov    0x10(%ebp),%eax
    f994:	8b 10                	mov    (%eax),%edx
    f996:	8b 45 0c             	mov    0xc(%ebp),%eax
    f999:	8b 00                	mov    (%eax),%eax
    f99b:	53                   	push   %ebx
    f99c:	51                   	push   %ecx
    f99d:	52                   	push   %edx
    f99e:	50                   	push   %eax
    f99f:	e8 76 97 ff ff       	call   911a <lodepng_pixel_overflow>
    f9a4:	83 c4 10             	add    $0x10,%esp
    f9a7:	85 c0                	test   %eax,%eax
    f9a9:	74 12                	je     f9bd <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
    f9ab:	8b 45 14             	mov    0x14(%ebp),%eax
    f9ae:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
    f9b5:	00 00 00 
    f9b8:	e9 ea 09 00 00       	jmp    103a7 <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
    f9bd:	83 ec 0c             	sub    $0xc,%esp
    f9c0:	ff 75 1c             	pushl  0x1c(%ebp)
    f9c3:	e8 a6 3a ff ff       	call   346e <lodepng_malloc>
    f9c8:	83 c4 10             	add    $0x10,%esp
    f9cb:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
    f9ce:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    f9d2:	75 12                	jne    f9e6 <decodeGeneric+0xf3>
    f9d4:	8b 45 14             	mov    0x14(%ebp),%eax
    f9d7:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
    f9de:	00 00 00 
    f9e1:	e9 c1 09 00 00       	jmp    103a7 <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
    f9e6:	8b 45 18             	mov    0x18(%ebp),%eax
    f9e9:	83 c0 21             	add    $0x21,%eax
    f9ec:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    f9ef:	e9 81 06 00 00       	jmp    10075 <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
    f9f4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f9f7:	8b 45 18             	mov    0x18(%ebp),%eax
    f9fa:	29 c2                	sub    %eax,%edx
    f9fc:	89 d0                	mov    %edx,%eax
    f9fe:	83 c0 0c             	add    $0xc,%eax
    fa01:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fa04:	7f 08                	jg     fa0e <decodeGeneric+0x11b>
    fa06:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fa09:	3b 45 18             	cmp    0x18(%ebp),%eax
    fa0c:	73 20                	jae    fa2e <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    fa0e:	8b 45 14             	mov    0x14(%ebp),%eax
    fa11:	8b 40 20             	mov    0x20(%eax),%eax
    fa14:	85 c0                	test   %eax,%eax
    fa16:	0f 85 72 06 00 00    	jne    1008e <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
    fa1c:	8b 45 14             	mov    0x14(%ebp),%eax
    fa1f:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
    fa26:	00 00 00 
    fa29:	e9 6a 06 00 00       	jmp    10098 <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    fa2e:	83 ec 0c             	sub    $0xc,%esp
    fa31:	ff 75 f0             	pushl  -0x10(%ebp)
    fa34:	e8 b7 89 ff ff       	call   83f0 <lodepng_chunk_length>
    fa39:	83 c4 10             	add    $0x10,%esp
    fa3c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
    fa3f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa42:	85 c0                	test   %eax,%eax
    fa44:	79 20                	jns    fa66 <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    fa46:	8b 45 14             	mov    0x14(%ebp),%eax
    fa49:	8b 40 20             	mov    0x20(%eax),%eax
    fa4c:	85 c0                	test   %eax,%eax
    fa4e:	0f 85 3d 06 00 00    	jne    10091 <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
    fa54:	8b 45 14             	mov    0x14(%ebp),%eax
    fa57:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
    fa5e:	00 00 00 
    fa61:	e9 32 06 00 00       	jmp    10098 <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
    fa66:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fa69:	8b 45 18             	mov    0x18(%ebp),%eax
    fa6c:	29 c2                	sub    %eax,%edx
    fa6e:	89 d0                	mov    %edx,%eax
    fa70:	89 c2                	mov    %eax,%edx
    fa72:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa75:	01 d0                	add    %edx,%eax
    fa77:	83 c0 0c             	add    $0xc,%eax
    fa7a:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fa7d:	7f 10                	jg     fa8f <decodeGeneric+0x19c>
    fa7f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fa82:	8d 50 0c             	lea    0xc(%eax),%edx
    fa85:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fa88:	01 d0                	add    %edx,%eax
    fa8a:	3b 45 18             	cmp    0x18(%ebp),%eax
    fa8d:	73 12                	jae    faa1 <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    fa8f:	8b 45 14             	mov    0x14(%ebp),%eax
    fa92:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
    fa99:	00 00 00 
    fa9c:	e9 f7 05 00 00       	jmp    10098 <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
    faa1:	83 ec 0c             	sub    $0xc,%esp
    faa4:	ff 75 f0             	pushl  -0x10(%ebp)
    faa7:	e8 7c 8a ff ff       	call   8528 <lodepng_chunk_data_const>
    faac:	83 c4 10             	add    $0x10,%esp
    faaf:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
    fab2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
    fab9:	83 ec 08             	sub    $0x8,%esp
    fabc:	68 e4 a1 01 00       	push   $0x1a1e4
    fac1:	ff 75 f0             	pushl  -0x10(%ebp)
    fac4:	e8 74 89 ff ff       	call   843d <lodepng_chunk_type_equals>
    fac9:	83 c4 10             	add    $0x10,%esp
    facc:	84 c0                	test   %al,%al
    face:	74 79                	je     fb49 <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
    fad0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fad3:	83 ec 04             	sub    $0x4,%esp
    fad6:	8d 55 bc             	lea    -0x44(%ebp),%edx
    fad9:	52                   	push   %edx
    fada:	50                   	push   %eax
    fadb:	ff 75 ec             	pushl  -0x14(%ebp)
    fade:	e8 4f 3a ff ff       	call   3532 <lodepng_addofl>
    fae3:	83 c4 10             	add    $0x10,%esp
    fae6:	85 c0                	test   %eax,%eax
    fae8:	74 12                	je     fafc <decodeGeneric+0x209>
    faea:	8b 45 14             	mov    0x14(%ebp),%eax
    faed:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    faf4:	00 00 00 
    faf7:	e9 9c 05 00 00       	jmp    10098 <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
    fafc:	8b 45 bc             	mov    -0x44(%ebp),%eax
    faff:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fb02:	7e 13                	jle    fb17 <decodeGeneric+0x224>
    fb04:	8b 45 14             	mov    0x14(%ebp),%eax
    fb07:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    fb0e:	00 00 00 
    fb11:	90                   	nop
    fb12:	e9 81 05 00 00       	jmp    10098 <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
    fb17:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb1a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    fb1d:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fb20:	01 ca                	add    %ecx,%edx
    fb22:	83 ec 04             	sub    $0x4,%esp
    fb25:	50                   	push   %eax
    fb26:	ff 75 d0             	pushl  -0x30(%ebp)
    fb29:	52                   	push   %edx
    fb2a:	e8 7d 39 ff ff       	call   34ac <lodepng_memcpy>
    fb2f:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
    fb32:	8b 55 ec             	mov    -0x14(%ebp),%edx
    fb35:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb38:	01 d0                	add    %edx,%eax
    fb3a:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
    fb3d:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
    fb44:	e9 db 04 00 00       	jmp    10024 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
    fb49:	83 ec 08             	sub    $0x8,%esp
    fb4c:	68 e9 a1 01 00       	push   $0x1a1e9
    fb51:	ff 75 f0             	pushl  -0x10(%ebp)
    fb54:	e8 e4 88 ff ff       	call   843d <lodepng_chunk_type_equals>
    fb59:	83 c4 10             	add    $0x10,%esp
    fb5c:	84 c0                	test   %al,%al
    fb5e:	74 09                	je     fb69 <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
    fb60:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
    fb64:	e9 bb 04 00 00       	jmp    10024 <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    fb69:	83 ec 08             	sub    $0x8,%esp
    fb6c:	68 a8 a1 01 00       	push   $0x1a1a8
    fb71:	ff 75 f0             	pushl  -0x10(%ebp)
    fb74:	e8 c4 88 ff ff       	call   843d <lodepng_chunk_type_equals>
    fb79:	83 c4 10             	add    $0x10,%esp
    fb7c:	84 c0                	test   %al,%al
    fb7e:	74 44                	je     fbc4 <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    fb80:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fb83:	8b 55 14             	mov    0x14(%ebp),%edx
    fb86:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fb8c:	83 ec 04             	sub    $0x4,%esp
    fb8f:	50                   	push   %eax
    fb90:	ff 75 d0             	pushl  -0x30(%ebp)
    fb93:	52                   	push   %edx
    fb94:	e8 ec e8 ff ff       	call   e485 <readChunk_PLTE>
    fb99:	83 c4 10             	add    $0x10,%esp
    fb9c:	89 c2                	mov    %eax,%edx
    fb9e:	8b 45 14             	mov    0x14(%ebp),%eax
    fba1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fba7:	8b 45 14             	mov    0x14(%ebp),%eax
    fbaa:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fbb0:	85 c0                	test   %eax,%eax
    fbb2:	0f 85 dc 04 00 00    	jne    10094 <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
    fbb8:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
    fbbf:	e9 60 04 00 00       	jmp    10024 <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fbc4:	83 ec 08             	sub    $0x8,%esp
    fbc7:	68 ad a1 01 00       	push   $0x1a1ad
    fbcc:	ff 75 f0             	pushl  -0x10(%ebp)
    fbcf:	e8 69 88 ff ff       	call   843d <lodepng_chunk_type_equals>
    fbd4:	83 c4 10             	add    $0x10,%esp
    fbd7:	84 c0                	test   %al,%al
    fbd9:	74 3d                	je     fc18 <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    fbdb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fbde:	8b 55 14             	mov    0x14(%ebp),%edx
    fbe1:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fbe7:	83 ec 04             	sub    $0x4,%esp
    fbea:	50                   	push   %eax
    fbeb:	ff 75 d0             	pushl  -0x30(%ebp)
    fbee:	52                   	push   %edx
    fbef:	e8 b1 e9 ff ff       	call   e5a5 <readChunk_tRNS>
    fbf4:	83 c4 10             	add    $0x10,%esp
    fbf7:	89 c2                	mov    %eax,%edx
    fbf9:	8b 45 14             	mov    0x14(%ebp),%eax
    fbfc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fc02:	8b 45 14             	mov    0x14(%ebp),%eax
    fc05:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc0b:	85 c0                	test   %eax,%eax
    fc0d:	0f 84 11 04 00 00    	je     10024 <decodeGeneric+0x731>
    fc13:	e9 80 04 00 00       	jmp    10098 <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    fc18:	83 ec 08             	sub    $0x8,%esp
    fc1b:	68 b2 a1 01 00       	push   $0x1a1b2
    fc20:	ff 75 f0             	pushl  -0x10(%ebp)
    fc23:	e8 15 88 ff ff       	call   843d <lodepng_chunk_type_equals>
    fc28:	83 c4 10             	add    $0x10,%esp
    fc2b:	84 c0                	test   %al,%al
    fc2d:	74 3d                	je     fc6c <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
    fc2f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fc32:	8b 55 14             	mov    0x14(%ebp),%edx
    fc35:	81 c2 98 00 00 00    	add    $0x98,%edx
    fc3b:	83 ec 04             	sub    $0x4,%esp
    fc3e:	50                   	push   %eax
    fc3f:	ff 75 d0             	pushl  -0x30(%ebp)
    fc42:	52                   	push   %edx
    fc43:	e8 c0 ea ff ff       	call   e708 <readChunk_bKGD>
    fc48:	83 c4 10             	add    $0x10,%esp
    fc4b:	89 c2                	mov    %eax,%edx
    fc4d:	8b 45 14             	mov    0x14(%ebp),%eax
    fc50:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fc56:	8b 45 14             	mov    0x14(%ebp),%eax
    fc59:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fc5f:	85 c0                	test   %eax,%eax
    fc61:	0f 84 bd 03 00 00    	je     10024 <decodeGeneric+0x731>
    fc67:	e9 2c 04 00 00       	jmp    10098 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    fc6c:	83 ec 08             	sub    $0x8,%esp
    fc6f:	68 b7 a1 01 00       	push   $0x1a1b7
    fc74:	ff 75 f0             	pushl  -0x10(%ebp)
    fc77:	e8 c1 87 ff ff       	call   843d <lodepng_chunk_type_equals>
    fc7c:	83 c4 10             	add    $0x10,%esp
    fc7f:	84 c0                	test   %al,%al
    fc81:	74 4b                	je     fcce <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
    fc83:	8b 45 14             	mov    0x14(%ebp),%eax
    fc86:	8b 40 28             	mov    0x28(%eax),%eax
    fc89:	85 c0                	test   %eax,%eax
    fc8b:	0f 84 93 03 00 00    	je     10024 <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
    fc91:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fc94:	8b 55 14             	mov    0x14(%ebp),%edx
    fc97:	81 c2 98 00 00 00    	add    $0x98,%edx
    fc9d:	83 ec 04             	sub    $0x4,%esp
    fca0:	50                   	push   %eax
    fca1:	ff 75 d0             	pushl  -0x30(%ebp)
    fca4:	52                   	push   %edx
    fca5:	e8 e1 eb ff ff       	call   e88b <readChunk_tEXt>
    fcaa:	83 c4 10             	add    $0x10,%esp
    fcad:	89 c2                	mov    %eax,%edx
    fcaf:	8b 45 14             	mov    0x14(%ebp),%eax
    fcb2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fcb8:	8b 45 14             	mov    0x14(%ebp),%eax
    fcbb:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fcc1:	85 c0                	test   %eax,%eax
    fcc3:	0f 84 5b 03 00 00    	je     10024 <decodeGeneric+0x731>
    fcc9:	e9 ca 03 00 00       	jmp    10098 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    fcce:	83 ec 08             	sub    $0x8,%esp
    fcd1:	68 bc a1 01 00       	push   $0x1a1bc
    fcd6:	ff 75 f0             	pushl  -0x10(%ebp)
    fcd9:	e8 5f 87 ff ff       	call   843d <lodepng_chunk_type_equals>
    fcde:	83 c4 10             	add    $0x10,%esp
    fce1:	84 c0                	test   %al,%al
    fce3:	74 4c                	je     fd31 <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
    fce5:	8b 45 14             	mov    0x14(%ebp),%eax
    fce8:	8b 40 28             	mov    0x28(%eax),%eax
    fceb:	85 c0                	test   %eax,%eax
    fced:	0f 84 31 03 00 00    	je     10024 <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    fcf3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fcf6:	8b 45 14             	mov    0x14(%ebp),%eax
    fcf9:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fcfc:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fd02:	52                   	push   %edx
    fd03:	ff 75 d0             	pushl  -0x30(%ebp)
    fd06:	50                   	push   %eax
    fd07:	51                   	push   %ecx
    fd08:	e8 ca ec ff ff       	call   e9d7 <readChunk_zTXt>
    fd0d:	83 c4 10             	add    $0x10,%esp
    fd10:	89 c2                	mov    %eax,%edx
    fd12:	8b 45 14             	mov    0x14(%ebp),%eax
    fd15:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fd1b:	8b 45 14             	mov    0x14(%ebp),%eax
    fd1e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd24:	85 c0                	test   %eax,%eax
    fd26:	0f 84 f8 02 00 00    	je     10024 <decodeGeneric+0x731>
    fd2c:	e9 67 03 00 00       	jmp    10098 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    fd31:	83 ec 08             	sub    $0x8,%esp
    fd34:	68 c1 a1 01 00       	push   $0x1a1c1
    fd39:	ff 75 f0             	pushl  -0x10(%ebp)
    fd3c:	e8 fc 86 ff ff       	call   843d <lodepng_chunk_type_equals>
    fd41:	83 c4 10             	add    $0x10,%esp
    fd44:	84 c0                	test   %al,%al
    fd46:	74 4c                	je     fd94 <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
    fd48:	8b 45 14             	mov    0x14(%ebp),%eax
    fd4b:	8b 40 28             	mov    0x28(%eax),%eax
    fd4e:	85 c0                	test   %eax,%eax
    fd50:	0f 84 ce 02 00 00    	je     10024 <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    fd56:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fd59:	8b 45 14             	mov    0x14(%ebp),%eax
    fd5c:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fd5f:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fd65:	52                   	push   %edx
    fd66:	ff 75 d0             	pushl  -0x30(%ebp)
    fd69:	50                   	push   %eax
    fd6a:	51                   	push   %ecx
    fd6b:	e8 23 ee ff ff       	call   eb93 <readChunk_iTXt>
    fd70:	83 c4 10             	add    $0x10,%esp
    fd73:	89 c2                	mov    %eax,%edx
    fd75:	8b 45 14             	mov    0x14(%ebp),%eax
    fd78:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fd7e:	8b 45 14             	mov    0x14(%ebp),%eax
    fd81:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd87:	85 c0                	test   %eax,%eax
    fd89:	0f 84 95 02 00 00    	je     10024 <decodeGeneric+0x731>
    fd8f:	e9 04 03 00 00       	jmp    10098 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    fd94:	83 ec 08             	sub    $0x8,%esp
    fd97:	68 c6 a1 01 00       	push   $0x1a1c6
    fd9c:	ff 75 f0             	pushl  -0x10(%ebp)
    fd9f:	e8 99 86 ff ff       	call   843d <lodepng_chunk_type_equals>
    fda4:	83 c4 10             	add    $0x10,%esp
    fda7:	84 c0                	test   %al,%al
    fda9:	74 3d                	je     fde8 <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
    fdab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fdae:	8b 55 14             	mov    0x14(%ebp),%edx
    fdb1:	81 c2 98 00 00 00    	add    $0x98,%edx
    fdb7:	83 ec 04             	sub    $0x4,%esp
    fdba:	50                   	push   %eax
    fdbb:	ff 75 d0             	pushl  -0x30(%ebp)
    fdbe:	52                   	push   %edx
    fdbf:	e8 25 f1 ff ff       	call   eee9 <readChunk_tIME>
    fdc4:	83 c4 10             	add    $0x10,%esp
    fdc7:	89 c2                	mov    %eax,%edx
    fdc9:	8b 45 14             	mov    0x14(%ebp),%eax
    fdcc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fdd2:	8b 45 14             	mov    0x14(%ebp),%eax
    fdd5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fddb:	85 c0                	test   %eax,%eax
    fddd:	0f 84 41 02 00 00    	je     10024 <decodeGeneric+0x731>
    fde3:	e9 b0 02 00 00       	jmp    10098 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    fde8:	83 ec 08             	sub    $0x8,%esp
    fdeb:	68 cb a1 01 00       	push   $0x1a1cb
    fdf0:	ff 75 f0             	pushl  -0x10(%ebp)
    fdf3:	e8 45 86 ff ff       	call   843d <lodepng_chunk_type_equals>
    fdf8:	83 c4 10             	add    $0x10,%esp
    fdfb:	84 c0                	test   %al,%al
    fdfd:	74 3d                	je     fe3c <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
    fdff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fe02:	8b 55 14             	mov    0x14(%ebp),%edx
    fe05:	81 c2 98 00 00 00    	add    $0x98,%edx
    fe0b:	83 ec 04             	sub    $0x4,%esp
    fe0e:	50                   	push   %eax
    fe0f:	ff 75 d0             	pushl  -0x30(%ebp)
    fe12:	52                   	push   %edx
    fe13:	e8 71 f1 ff ff       	call   ef89 <readChunk_pHYs>
    fe18:	83 c4 10             	add    $0x10,%esp
    fe1b:	89 c2                	mov    %eax,%edx
    fe1d:	8b 45 14             	mov    0x14(%ebp),%eax
    fe20:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fe26:	8b 45 14             	mov    0x14(%ebp),%eax
    fe29:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe2f:	85 c0                	test   %eax,%eax
    fe31:	0f 84 ed 01 00 00    	je     10024 <decodeGeneric+0x731>
    fe37:	e9 5c 02 00 00       	jmp    10098 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    fe3c:	83 ec 08             	sub    $0x8,%esp
    fe3f:	68 d0 a1 01 00       	push   $0x1a1d0
    fe44:	ff 75 f0             	pushl  -0x10(%ebp)
    fe47:	e8 f1 85 ff ff       	call   843d <lodepng_chunk_type_equals>
    fe4c:	83 c4 10             	add    $0x10,%esp
    fe4f:	84 c0                	test   %al,%al
    fe51:	74 3d                	je     fe90 <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
    fe53:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fe56:	8b 55 14             	mov    0x14(%ebp),%edx
    fe59:	81 c2 98 00 00 00    	add    $0x98,%edx
    fe5f:	83 ec 04             	sub    $0x4,%esp
    fe62:	50                   	push   %eax
    fe63:	ff 75 d0             	pushl  -0x30(%ebp)
    fe66:	52                   	push   %edx
    fe67:	e8 ec f1 ff ff       	call   f058 <readChunk_gAMA>
    fe6c:	83 c4 10             	add    $0x10,%esp
    fe6f:	89 c2                	mov    %eax,%edx
    fe71:	8b 45 14             	mov    0x14(%ebp),%eax
    fe74:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fe7a:	8b 45 14             	mov    0x14(%ebp),%eax
    fe7d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe83:	85 c0                	test   %eax,%eax
    fe85:	0f 84 99 01 00 00    	je     10024 <decodeGeneric+0x731>
    fe8b:	e9 08 02 00 00       	jmp    10098 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    fe90:	83 ec 08             	sub    $0x8,%esp
    fe93:	68 d5 a1 01 00       	push   $0x1a1d5
    fe98:	ff 75 f0             	pushl  -0x10(%ebp)
    fe9b:	e8 9d 85 ff ff       	call   843d <lodepng_chunk_type_equals>
    fea0:	83 c4 10             	add    $0x10,%esp
    fea3:	84 c0                	test   %al,%al
    fea5:	74 3d                	je     fee4 <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
    fea7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    feaa:	8b 55 14             	mov    0x14(%ebp),%edx
    fead:	81 c2 98 00 00 00    	add    $0x98,%edx
    feb3:	83 ec 04             	sub    $0x4,%esp
    feb6:	50                   	push   %eax
    feb7:	ff 75 d0             	pushl  -0x30(%ebp)
    feba:	52                   	push   %edx
    febb:	e8 07 f2 ff ff       	call   f0c7 <readChunk_cHRM>
    fec0:	83 c4 10             	add    $0x10,%esp
    fec3:	89 c2                	mov    %eax,%edx
    fec5:	8b 45 14             	mov    0x14(%ebp),%eax
    fec8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fece:	8b 45 14             	mov    0x14(%ebp),%eax
    fed1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fed7:	85 c0                	test   %eax,%eax
    fed9:	0f 84 45 01 00 00    	je     10024 <decodeGeneric+0x731>
    fedf:	e9 b4 01 00 00       	jmp    10098 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    fee4:	83 ec 08             	sub    $0x8,%esp
    fee7:	68 da a1 01 00       	push   $0x1a1da
    feec:	ff 75 f0             	pushl  -0x10(%ebp)
    feef:	e8 49 85 ff ff       	call   843d <lodepng_chunk_type_equals>
    fef4:	83 c4 10             	add    $0x10,%esp
    fef7:	84 c0                	test   %al,%al
    fef9:	74 3d                	je     ff38 <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
    fefb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fefe:	8b 55 14             	mov    0x14(%ebp),%edx
    ff01:	81 c2 98 00 00 00    	add    $0x98,%edx
    ff07:	83 ec 04             	sub    $0x4,%esp
    ff0a:	50                   	push   %eax
    ff0b:	ff 75 d0             	pushl  -0x30(%ebp)
    ff0e:	52                   	push   %edx
    ff0f:	e8 47 f4 ff ff       	call   f35b <readChunk_sRGB>
    ff14:	83 c4 10             	add    $0x10,%esp
    ff17:	89 c2                	mov    %eax,%edx
    ff19:	8b 45 14             	mov    0x14(%ebp),%eax
    ff1c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    ff22:	8b 45 14             	mov    0x14(%ebp),%eax
    ff25:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff2b:	85 c0                	test   %eax,%eax
    ff2d:	0f 84 f1 00 00 00    	je     10024 <decodeGeneric+0x731>
    ff33:	e9 60 01 00 00       	jmp    10098 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    ff38:	83 ec 08             	sub    $0x8,%esp
    ff3b:	68 df a1 01 00       	push   $0x1a1df
    ff40:	ff 75 f0             	pushl  -0x10(%ebp)
    ff43:	e8 f5 84 ff ff       	call   843d <lodepng_chunk_type_equals>
    ff48:	83 c4 10             	add    $0x10,%esp
    ff4b:	84 c0                	test   %al,%al
    ff4d:	74 3e                	je     ff8d <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    ff4f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    ff52:	8b 45 14             	mov    0x14(%ebp),%eax
    ff55:	8b 4d 14             	mov    0x14(%ebp),%ecx
    ff58:	81 c1 98 00 00 00    	add    $0x98,%ecx
    ff5e:	52                   	push   %edx
    ff5f:	ff 75 d0             	pushl  -0x30(%ebp)
    ff62:	50                   	push   %eax
    ff63:	51                   	push   %ecx
    ff64:	e8 28 f4 ff ff       	call   f391 <readChunk_iCCP>
    ff69:	83 c4 10             	add    $0x10,%esp
    ff6c:	89 c2                	mov    %eax,%edx
    ff6e:	8b 45 14             	mov    0x14(%ebp),%eax
    ff71:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    ff77:	8b 45 14             	mov    0x14(%ebp),%eax
    ff7a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff80:	85 c0                	test   %eax,%eax
    ff82:	0f 84 9c 00 00 00    	je     10024 <decodeGeneric+0x731>
    ff88:	e9 0b 01 00 00       	jmp    10098 <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
    ff8d:	8b 45 14             	mov    0x14(%ebp),%eax
    ff90:	8b 40 1c             	mov    0x1c(%eax),%eax
    ff93:	85 c0                	test   %eax,%eax
    ff95:	75 24                	jne    ffbb <decodeGeneric+0x6c8>
    ff97:	83 ec 0c             	sub    $0xc,%esp
    ff9a:	ff 75 f0             	pushl  -0x10(%ebp)
    ff9d:	e8 30 85 ff ff       	call   84d2 <lodepng_chunk_ancillary>
    ffa2:	83 c4 10             	add    $0x10,%esp
    ffa5:	84 c0                	test   %al,%al
    ffa7:	75 12                	jne    ffbb <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
    ffa9:	8b 45 14             	mov    0x14(%ebp),%eax
    ffac:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
    ffb3:	00 00 00 
    ffb6:	e9 dd 00 00 00       	jmp    10098 <decodeGeneric+0x7a5>
      }

      unknown = 1;
    ffbb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
    ffc2:	8b 45 14             	mov    0x14(%ebp),%eax
    ffc5:	8b 40 2c             	mov    0x2c(%eax),%eax
    ffc8:	85 c0                	test   %eax,%eax
    ffca:	74 58                	je     10024 <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
    ffcc:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ffcf:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
    ffd2:	83 c0 58             	add    $0x58,%eax
    ffd5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    ffdc:	8b 45 14             	mov    0x14(%ebp),%eax
    ffdf:	01 d0                	add    %edx,%eax
    ffe1:	8d 50 10             	lea    0x10(%eax),%edx
    ffe4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ffe7:	83 e8 01             	sub    $0x1,%eax
    ffea:	83 c0 54             	add    $0x54,%eax
    ffed:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    fff4:	8b 45 14             	mov    0x14(%ebp),%eax
    fff7:	01 c8                	add    %ecx,%eax
    fff9:	83 c0 14             	add    $0x14,%eax
    fffc:	83 ec 04             	sub    $0x4,%esp
    ffff:	ff 75 f0             	pushl  -0x10(%ebp)
   10002:	52                   	push   %edx
   10003:	50                   	push   %eax
   10004:	e8 15 88 ff ff       	call   881e <lodepng_chunk_append>
   10009:	83 c4 10             	add    $0x10,%esp
   1000c:	89 c2                	mov    %eax,%edx
   1000e:	8b 45 14             	mov    0x14(%ebp),%eax
   10011:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   10017:	8b 45 14             	mov    0x14(%ebp),%eax
   1001a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10020:	85 c0                	test   %eax,%eax
   10022:	75 73                	jne    10097 <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
   10024:	8b 45 14             	mov    0x14(%ebp),%eax
   10027:	8b 40 18             	mov    0x18(%eax),%eax
   1002a:	85 c0                	test   %eax,%eax
   1002c:	75 27                	jne    10055 <decodeGeneric+0x762>
   1002e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   10032:	75 21                	jne    10055 <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
   10034:	83 ec 0c             	sub    $0xc,%esp
   10037:	ff 75 f0             	pushl  -0x10(%ebp)
   1003a:	e8 f4 84 ff ff       	call   8533 <lodepng_chunk_check_crc>
   1003f:	83 c4 10             	add    $0x10,%esp
   10042:	85 c0                	test   %eax,%eax
   10044:	74 0f                	je     10055 <decodeGeneric+0x762>
   10046:	8b 45 14             	mov    0x14(%ebp),%eax
   10049:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
   10050:	00 00 00 
   10053:	eb 43                	jmp    10098 <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
   10055:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   10059:	75 1a                	jne    10075 <decodeGeneric+0x782>
   1005b:	8b 55 1c             	mov    0x1c(%ebp),%edx
   1005e:	8b 45 18             	mov    0x18(%ebp),%eax
   10061:	01 d0                	add    %edx,%eax
   10063:	83 ec 08             	sub    $0x8,%esp
   10066:	50                   	push   %eax
   10067:	ff 75 f0             	pushl  -0x10(%ebp)
   1006a:	e8 3f 86 ff ff       	call   86ae <lodepng_chunk_next_const>
   1006f:	83 c4 10             	add    $0x10,%esp
   10072:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   10075:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   10079:	75 1d                	jne    10098 <decodeGeneric+0x7a5>
   1007b:	8b 45 14             	mov    0x14(%ebp),%eax
   1007e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10084:	85 c0                	test   %eax,%eax
   10086:	0f 84 68 f9 ff ff    	je     f9f4 <decodeGeneric+0x101>
   1008c:	eb 0a                	jmp    10098 <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   1008e:	90                   	nop
   1008f:	eb 07                	jmp    10098 <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   10091:	90                   	nop
   10092:	eb 04                	jmp    10098 <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
   10094:	90                   	nop
   10095:	eb 01                	jmp    10098 <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   10097:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
   10098:	8b 45 14             	mov    0x14(%ebp),%eax
   1009b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   100a1:	85 c0                	test   %eax,%eax
   100a3:	75 28                	jne    100cd <decodeGeneric+0x7da>
   100a5:	8b 45 14             	mov    0x14(%ebp),%eax
   100a8:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   100ae:	83 f8 03             	cmp    $0x3,%eax
   100b1:	75 1a                	jne    100cd <decodeGeneric+0x7da>
   100b3:	8b 45 14             	mov    0x14(%ebp),%eax
   100b6:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   100bc:	85 c0                	test   %eax,%eax
   100be:	75 0d                	jne    100cd <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
   100c0:	8b 45 14             	mov    0x14(%ebp),%eax
   100c3:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
   100ca:	00 00 00 
  }

  if(!state->error) {
   100cd:	8b 45 14             	mov    0x14(%ebp),%eax
   100d0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   100d6:	85 c0                	test   %eax,%eax
   100d8:	0f 85 d2 01 00 00    	jne    102b0 <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
   100de:	8b 45 14             	mov    0x14(%ebp),%eax
   100e1:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   100e7:	85 c0                	test   %eax,%eax
   100e9:	75 3a                	jne    10125 <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   100eb:	8b 45 14             	mov    0x14(%ebp),%eax
   100ee:	05 a4 00 00 00       	add    $0xa4,%eax
   100f3:	83 ec 0c             	sub    $0xc,%esp
   100f6:	50                   	push   %eax
   100f7:	e8 8e 8e ff ff       	call   8f8a <lodepng_get_bpp>
   100fc:	83 c4 10             	add    $0x10,%esp
   100ff:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
   10102:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   10105:	8b 45 10             	mov    0x10(%ebp),%eax
   10108:	8b 10                	mov    (%eax),%edx
   1010a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1010d:	8b 00                	mov    (%eax),%eax
   1010f:	83 ec 04             	sub    $0x4,%esp
   10112:	51                   	push   %ecx
   10113:	52                   	push   %edx
   10114:	50                   	push   %eax
   10115:	e8 cf 8f ff ff       	call   90e9 <lodepng_get_raw_size_idat>
   1011a:	83 c4 10             	add    $0x10,%esp
   1011d:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10120:	e9 60 01 00 00       	jmp    10285 <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   10125:	8b 45 14             	mov    0x14(%ebp),%eax
   10128:	05 a4 00 00 00       	add    $0xa4,%eax
   1012d:	83 ec 0c             	sub    $0xc,%esp
   10130:	50                   	push   %eax
   10131:	e8 54 8e ff ff       	call   8f8a <lodepng_get_bpp>
   10136:	83 c4 10             	add    $0x10,%esp
   10139:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   1013c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   10143:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10146:	8b 55 10             	mov    0x10(%ebp),%edx
   10149:	8b 12                	mov    (%edx),%edx
   1014b:	83 c2 07             	add    $0x7,%edx
   1014e:	89 d1                	mov    %edx,%ecx
   10150:	c1 e9 03             	shr    $0x3,%ecx
   10153:	8b 55 0c             	mov    0xc(%ebp),%edx
   10156:	8b 12                	mov    (%edx),%edx
   10158:	83 c2 07             	add    $0x7,%edx
   1015b:	c1 ea 03             	shr    $0x3,%edx
   1015e:	83 ec 04             	sub    $0x4,%esp
   10161:	50                   	push   %eax
   10162:	51                   	push   %ecx
   10163:	52                   	push   %edx
   10164:	e8 80 8f ff ff       	call   90e9 <lodepng_get_raw_size_idat>
   10169:	83 c4 10             	add    $0x10,%esp
   1016c:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   1016f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10172:	8b 00                	mov    (%eax),%eax
   10174:	83 f8 04             	cmp    $0x4,%eax
   10177:	76 2c                	jbe    101a5 <decodeGeneric+0x8b2>
   10179:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1017c:	8b 55 10             	mov    0x10(%ebp),%edx
   1017f:	8b 12                	mov    (%edx),%edx
   10181:	83 c2 07             	add    $0x7,%edx
   10184:	89 d1                	mov    %edx,%ecx
   10186:	c1 e9 03             	shr    $0x3,%ecx
   10189:	8b 55 0c             	mov    0xc(%ebp),%edx
   1018c:	8b 12                	mov    (%edx),%edx
   1018e:	83 c2 03             	add    $0x3,%edx
   10191:	c1 ea 03             	shr    $0x3,%edx
   10194:	83 ec 04             	sub    $0x4,%esp
   10197:	50                   	push   %eax
   10198:	51                   	push   %ecx
   10199:	52                   	push   %edx
   1019a:	e8 4a 8f ff ff       	call   90e9 <lodepng_get_raw_size_idat>
   1019f:	83 c4 10             	add    $0x10,%esp
   101a2:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   101a5:	8b 45 c8             	mov    -0x38(%ebp),%eax
   101a8:	8b 55 10             	mov    0x10(%ebp),%edx
   101ab:	8b 12                	mov    (%edx),%edx
   101ad:	83 c2 03             	add    $0x3,%edx
   101b0:	89 d1                	mov    %edx,%ecx
   101b2:	c1 e9 03             	shr    $0x3,%ecx
   101b5:	8b 55 0c             	mov    0xc(%ebp),%edx
   101b8:	8b 12                	mov    (%edx),%edx
   101ba:	83 c2 03             	add    $0x3,%edx
   101bd:	c1 ea 02             	shr    $0x2,%edx
   101c0:	83 ec 04             	sub    $0x4,%esp
   101c3:	50                   	push   %eax
   101c4:	51                   	push   %ecx
   101c5:	52                   	push   %edx
   101c6:	e8 1e 8f ff ff       	call   90e9 <lodepng_get_raw_size_idat>
   101cb:	83 c4 10             	add    $0x10,%esp
   101ce:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   101d1:	8b 45 0c             	mov    0xc(%ebp),%eax
   101d4:	8b 00                	mov    (%eax),%eax
   101d6:	83 f8 02             	cmp    $0x2,%eax
   101d9:	76 2c                	jbe    10207 <decodeGeneric+0x914>
   101db:	8b 45 c8             	mov    -0x38(%ebp),%eax
   101de:	8b 55 10             	mov    0x10(%ebp),%edx
   101e1:	8b 12                	mov    (%edx),%edx
   101e3:	83 c2 03             	add    $0x3,%edx
   101e6:	89 d1                	mov    %edx,%ecx
   101e8:	c1 e9 02             	shr    $0x2,%ecx
   101eb:	8b 55 0c             	mov    0xc(%ebp),%edx
   101ee:	8b 12                	mov    (%edx),%edx
   101f0:	83 c2 01             	add    $0x1,%edx
   101f3:	c1 ea 02             	shr    $0x2,%edx
   101f6:	83 ec 04             	sub    $0x4,%esp
   101f9:	50                   	push   %eax
   101fa:	51                   	push   %ecx
   101fb:	52                   	push   %edx
   101fc:	e8 e8 8e ff ff       	call   90e9 <lodepng_get_raw_size_idat>
   10201:	83 c4 10             	add    $0x10,%esp
   10204:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   10207:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1020a:	8b 55 10             	mov    0x10(%ebp),%edx
   1020d:	8b 12                	mov    (%edx),%edx
   1020f:	83 c2 01             	add    $0x1,%edx
   10212:	89 d1                	mov    %edx,%ecx
   10214:	c1 e9 02             	shr    $0x2,%ecx
   10217:	8b 55 0c             	mov    0xc(%ebp),%edx
   1021a:	8b 12                	mov    (%edx),%edx
   1021c:	83 c2 01             	add    $0x1,%edx
   1021f:	d1 ea                	shr    %edx
   10221:	83 ec 04             	sub    $0x4,%esp
   10224:	50                   	push   %eax
   10225:	51                   	push   %ecx
   10226:	52                   	push   %edx
   10227:	e8 bd 8e ff ff       	call   90e9 <lodepng_get_raw_size_idat>
   1022c:	83 c4 10             	add    $0x10,%esp
   1022f:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   10232:	8b 45 0c             	mov    0xc(%ebp),%eax
   10235:	8b 00                	mov    (%eax),%eax
   10237:	83 f8 01             	cmp    $0x1,%eax
   1023a:	76 27                	jbe    10263 <decodeGeneric+0x970>
   1023c:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1023f:	8b 55 10             	mov    0x10(%ebp),%edx
   10242:	8b 12                	mov    (%edx),%edx
   10244:	83 c2 01             	add    $0x1,%edx
   10247:	89 d1                	mov    %edx,%ecx
   10249:	d1 e9                	shr    %ecx
   1024b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1024e:	8b 12                	mov    (%edx),%edx
   10250:	d1 ea                	shr    %edx
   10252:	83 ec 04             	sub    $0x4,%esp
   10255:	50                   	push   %eax
   10256:	51                   	push   %ecx
   10257:	52                   	push   %edx
   10258:	e8 8c 8e ff ff       	call   90e9 <lodepng_get_raw_size_idat>
   1025d:	83 c4 10             	add    $0x10,%esp
   10260:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   10263:	8b 55 c8             	mov    -0x38(%ebp),%edx
   10266:	8b 45 10             	mov    0x10(%ebp),%eax
   10269:	8b 00                	mov    (%eax),%eax
   1026b:	d1 e8                	shr    %eax
   1026d:	89 c1                	mov    %eax,%ecx
   1026f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10272:	8b 00                	mov    (%eax),%eax
   10274:	83 ec 04             	sub    $0x4,%esp
   10277:	52                   	push   %edx
   10278:	51                   	push   %ecx
   10279:	50                   	push   %eax
   1027a:	e8 6a 8e ff ff       	call   90e9 <lodepng_get_raw_size_idat>
   1027f:	83 c4 10             	add    $0x10,%esp
   10282:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   10285:	8b 45 14             	mov    0x14(%ebp),%eax
   10288:	83 ec 08             	sub    $0x8,%esp
   1028b:	50                   	push   %eax
   1028c:	ff 75 ec             	pushl  -0x14(%ebp)
   1028f:	ff 75 d8             	pushl  -0x28(%ebp)
   10292:	ff 75 e8             	pushl  -0x18(%ebp)
   10295:	8d 45 c0             	lea    -0x40(%ebp),%eax
   10298:	50                   	push   %eax
   10299:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   1029c:	50                   	push   %eax
   1029d:	e8 87 7c ff ff       	call   7f29 <zlib_decompress>
   102a2:	83 c4 20             	add    $0x20,%esp
   102a5:	89 c2                	mov    %eax,%edx
   102a7:	8b 45 14             	mov    0x14(%ebp),%eax
   102aa:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   102b0:	8b 45 14             	mov    0x14(%ebp),%eax
   102b3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   102b9:	85 c0                	test   %eax,%eax
   102bb:	75 15                	jne    102d2 <decodeGeneric+0x9df>
   102bd:	8b 45 c0             	mov    -0x40(%ebp),%eax
   102c0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   102c3:	74 0d                	je     102d2 <decodeGeneric+0x9df>
   102c5:	8b 45 14             	mov    0x14(%ebp),%eax
   102c8:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   102cf:	00 00 00 
  lodepng_free(idat);
   102d2:	83 ec 0c             	sub    $0xc,%esp
   102d5:	ff 75 d8             	pushl  -0x28(%ebp)
   102d8:	e8 b2 31 ff ff       	call   348f <lodepng_free>
   102dd:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   102e0:	8b 45 14             	mov    0x14(%ebp),%eax
   102e3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   102e9:	85 c0                	test   %eax,%eax
   102eb:	75 4f                	jne    1033c <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   102ed:	8b 45 14             	mov    0x14(%ebp),%eax
   102f0:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   102f6:	8b 45 10             	mov    0x10(%ebp),%eax
   102f9:	8b 10                	mov    (%eax),%edx
   102fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   102fe:	8b 00                	mov    (%eax),%eax
   10300:	83 ec 04             	sub    $0x4,%esp
   10303:	51                   	push   %ecx
   10304:	52                   	push   %edx
   10305:	50                   	push   %eax
   10306:	e8 be 8d ff ff       	call   90c9 <lodepng_get_raw_size>
   1030b:	83 c4 10             	add    $0x10,%esp
   1030e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   10311:	83 ec 0c             	sub    $0xc,%esp
   10314:	ff 75 e4             	pushl  -0x1c(%ebp)
   10317:	e8 52 31 ff ff       	call   346e <lodepng_malloc>
   1031c:	83 c4 10             	add    $0x10,%esp
   1031f:	89 c2                	mov    %eax,%edx
   10321:	8b 45 08             	mov    0x8(%ebp),%eax
   10324:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   10326:	8b 45 08             	mov    0x8(%ebp),%eax
   10329:	8b 00                	mov    (%eax),%eax
   1032b:	85 c0                	test   %eax,%eax
   1032d:	75 0d                	jne    1033c <decodeGeneric+0xa49>
   1032f:	8b 45 14             	mov    0x14(%ebp),%eax
   10332:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   10339:	00 00 00 
  }
  if(!state->error) {
   1033c:	8b 45 14             	mov    0x14(%ebp),%eax
   1033f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10345:	85 c0                	test   %eax,%eax
   10347:	75 4c                	jne    10395 <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   10349:	8b 45 08             	mov    0x8(%ebp),%eax
   1034c:	8b 00                	mov    (%eax),%eax
   1034e:	83 ec 04             	sub    $0x4,%esp
   10351:	ff 75 e4             	pushl  -0x1c(%ebp)
   10354:	6a 00                	push   $0x0
   10356:	50                   	push   %eax
   10357:	e8 83 31 ff ff       	call   34df <lodepng_memset>
   1035c:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   1035f:	8b 45 14             	mov    0x14(%ebp),%eax
   10362:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   10368:	8b 45 10             	mov    0x10(%ebp),%eax
   1036b:	8b 18                	mov    (%eax),%ebx
   1036d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10370:	8b 08                	mov    (%eax),%ecx
   10372:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   10375:	8b 45 08             	mov    0x8(%ebp),%eax
   10378:	8b 00                	mov    (%eax),%eax
   1037a:	83 ec 0c             	sub    $0xc,%esp
   1037d:	56                   	push   %esi
   1037e:	53                   	push   %ebx
   1037f:	51                   	push   %ecx
   10380:	52                   	push   %edx
   10381:	50                   	push   %eax
   10382:	e8 05 df ff ff       	call   e28c <postProcessScanlines>
   10387:	83 c4 20             	add    $0x20,%esp
   1038a:	89 c2                	mov    %eax,%edx
   1038c:	8b 45 14             	mov    0x14(%ebp),%eax
   1038f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   10395:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10398:	83 ec 0c             	sub    $0xc,%esp
   1039b:	50                   	push   %eax
   1039c:	e8 ee 30 ff ff       	call   348f <lodepng_free>
   103a1:	83 c4 10             	add    $0x10,%esp
   103a4:	eb 01                	jmp    103a7 <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   103a6:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   103a7:	8d 65 f8             	lea    -0x8(%ebp),%esp
   103aa:	5b                   	pop    %ebx
   103ab:	5e                   	pop    %esi
   103ac:	5d                   	pop    %ebp
   103ad:	c3                   	ret    

000103ae <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   103ae:	55                   	push   %ebp
   103af:	89 e5                	mov    %esp,%ebp
   103b1:	56                   	push   %esi
   103b2:	53                   	push   %ebx
   103b3:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   103b6:	8b 45 08             	mov    0x8(%ebp),%eax
   103b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   103bf:	83 ec 08             	sub    $0x8,%esp
   103c2:	ff 75 1c             	pushl  0x1c(%ebp)
   103c5:	ff 75 18             	pushl  0x18(%ebp)
   103c8:	ff 75 14             	pushl  0x14(%ebp)
   103cb:	ff 75 10             	pushl  0x10(%ebp)
   103ce:	ff 75 0c             	pushl  0xc(%ebp)
   103d1:	ff 75 08             	pushl  0x8(%ebp)
   103d4:	e8 1a f5 ff ff       	call   f8f3 <decodeGeneric>
   103d9:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   103dc:	8b 45 14             	mov    0x14(%ebp),%eax
   103df:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   103e5:	85 c0                	test   %eax,%eax
   103e7:	74 0e                	je     103f7 <lodepng_decode+0x49>
   103e9:	8b 45 14             	mov    0x14(%ebp),%eax
   103ec:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   103f2:	e9 55 01 00 00       	jmp    1054c <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   103f7:	8b 45 14             	mov    0x14(%ebp),%eax
   103fa:	8b 40 24             	mov    0x24(%eax),%eax
   103fd:	85 c0                	test   %eax,%eax
   103ff:	74 20                	je     10421 <lodepng_decode+0x73>
   10401:	8b 45 14             	mov    0x14(%ebp),%eax
   10404:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   1040a:	8b 45 14             	mov    0x14(%ebp),%eax
   1040d:	83 c0 78             	add    $0x78,%eax
   10410:	83 ec 08             	sub    $0x8,%esp
   10413:	52                   	push   %edx
   10414:	50                   	push   %eax
   10415:	e8 56 89 ff ff       	call   8d70 <lodepng_color_mode_equal>
   1041a:	83 c4 10             	add    $0x10,%esp
   1041d:	85 c0                	test   %eax,%eax
   1041f:	74 54                	je     10475 <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   10421:	8b 45 14             	mov    0x14(%ebp),%eax
   10424:	8b 40 24             	mov    0x24(%eax),%eax
   10427:	85 c0                	test   %eax,%eax
   10429:	0f 85 13 01 00 00    	jne    10542 <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   1042f:	8b 45 14             	mov    0x14(%ebp),%eax
   10432:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   10438:	8b 45 14             	mov    0x14(%ebp),%eax
   1043b:	83 c0 78             	add    $0x78,%eax
   1043e:	83 ec 08             	sub    $0x8,%esp
   10441:	52                   	push   %edx
   10442:	50                   	push   %eax
   10443:	e8 3f 88 ff ff       	call   8c87 <lodepng_color_mode_copy>
   10448:	83 c4 10             	add    $0x10,%esp
   1044b:	89 c2                	mov    %eax,%edx
   1044d:	8b 45 14             	mov    0x14(%ebp),%eax
   10450:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   10456:	8b 45 14             	mov    0x14(%ebp),%eax
   10459:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1045f:	85 c0                	test   %eax,%eax
   10461:	0f 84 db 00 00 00    	je     10542 <lodepng_decode+0x194>
   10467:	8b 45 14             	mov    0x14(%ebp),%eax
   1046a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10470:	e9 d7 00 00 00       	jmp    1054c <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   10475:	8b 45 08             	mov    0x8(%ebp),%eax
   10478:	8b 00                	mov    (%eax),%eax
   1047a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   1047d:	8b 45 14             	mov    0x14(%ebp),%eax
   10480:	8b 40 78             	mov    0x78(%eax),%eax
   10483:	83 f8 02             	cmp    $0x2,%eax
   10486:	74 20                	je     104a8 <lodepng_decode+0xfa>
   10488:	8b 45 14             	mov    0x14(%ebp),%eax
   1048b:	8b 40 78             	mov    0x78(%eax),%eax
   1048e:	83 f8 06             	cmp    $0x6,%eax
   10491:	74 15                	je     104a8 <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   10493:	8b 45 14             	mov    0x14(%ebp),%eax
   10496:	8b 40 7c             	mov    0x7c(%eax),%eax
   10499:	83 f8 08             	cmp    $0x8,%eax
   1049c:	74 0a                	je     104a8 <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   1049e:	b8 38 00 00 00       	mov    $0x38,%eax
   104a3:	e9 a4 00 00 00       	jmp    1054c <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   104a8:	8b 45 14             	mov    0x14(%ebp),%eax
   104ab:	8d 48 78             	lea    0x78(%eax),%ecx
   104ae:	8b 45 10             	mov    0x10(%ebp),%eax
   104b1:	8b 10                	mov    (%eax),%edx
   104b3:	8b 45 0c             	mov    0xc(%ebp),%eax
   104b6:	8b 00                	mov    (%eax),%eax
   104b8:	83 ec 04             	sub    $0x4,%esp
   104bb:	51                   	push   %ecx
   104bc:	52                   	push   %edx
   104bd:	50                   	push   %eax
   104be:	e8 06 8c ff ff       	call   90c9 <lodepng_get_raw_size>
   104c3:	83 c4 10             	add    $0x10,%esp
   104c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   104c9:	83 ec 0c             	sub    $0xc,%esp
   104cc:	ff 75 f0             	pushl  -0x10(%ebp)
   104cf:	e8 9a 2f ff ff       	call   346e <lodepng_malloc>
   104d4:	83 c4 10             	add    $0x10,%esp
   104d7:	89 c2                	mov    %eax,%edx
   104d9:	8b 45 08             	mov    0x8(%ebp),%eax
   104dc:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   104de:	8b 45 08             	mov    0x8(%ebp),%eax
   104e1:	8b 00                	mov    (%eax),%eax
   104e3:	85 c0                	test   %eax,%eax
   104e5:	75 0f                	jne    104f6 <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   104e7:	8b 45 14             	mov    0x14(%ebp),%eax
   104ea:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   104f1:	00 00 00 
   104f4:	eb 3c                	jmp    10532 <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   104f6:	8b 45 10             	mov    0x10(%ebp),%eax
   104f9:	8b 08                	mov    (%eax),%ecx
   104fb:	8b 45 0c             	mov    0xc(%ebp),%eax
   104fe:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   10500:	8b 45 14             	mov    0x14(%ebp),%eax
   10503:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   10509:	8b 45 14             	mov    0x14(%ebp),%eax
   1050c:	8d 58 78             	lea    0x78(%eax),%ebx
   1050f:	8b 45 08             	mov    0x8(%ebp),%eax
   10512:	8b 00                	mov    (%eax),%eax
   10514:	83 ec 08             	sub    $0x8,%esp
   10517:	51                   	push   %ecx
   10518:	52                   	push   %edx
   10519:	56                   	push   %esi
   1051a:	53                   	push   %ebx
   1051b:	ff 75 f4             	pushl  -0xc(%ebp)
   1051e:	50                   	push   %eax
   1051f:	e8 51 b6 ff ff       	call   bb75 <lodepng_convert>
   10524:	83 c4 20             	add    $0x20,%esp
   10527:	89 c2                	mov    %eax,%edx
   10529:	8b 45 14             	mov    0x14(%ebp),%eax
   1052c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   10532:	83 ec 0c             	sub    $0xc,%esp
   10535:	ff 75 f4             	pushl  -0xc(%ebp)
   10538:	e8 52 2f ff ff       	call   348f <lodepng_free>
   1053d:	83 c4 10             	add    $0x10,%esp
   10540:	eb 01                	jmp    10543 <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   10542:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   10543:	8b 45 14             	mov    0x14(%ebp),%eax
   10546:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   1054c:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1054f:	5b                   	pop    %ebx
   10550:	5e                   	pop    %esi
   10551:	5d                   	pop    %ebp
   10552:	c3                   	ret    

00010553 <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   10553:	55                   	push   %ebp
   10554:	89 e5                	mov    %esp,%ebp
   10556:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   1055c:	83 ec 0c             	sub    $0xc,%esp
   1055f:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   10565:	50                   	push   %eax
   10566:	e8 d9 01 00 00       	call   10744 <lodepng_state_init>
   1056b:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   1056e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   10571:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   10577:	8b 45 20             	mov    0x20(%ebp),%eax
   1057a:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   10580:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   10587:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   1058a:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   10591:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   10594:	83 ec 08             	sub    $0x8,%esp
   10597:	ff 75 18             	pushl  0x18(%ebp)
   1059a:	ff 75 14             	pushl  0x14(%ebp)
   1059d:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   105a3:	50                   	push   %eax
   105a4:	ff 75 10             	pushl  0x10(%ebp)
   105a7:	ff 75 0c             	pushl  0xc(%ebp)
   105aa:	ff 75 08             	pushl  0x8(%ebp)
   105ad:	e8 fc fd ff ff       	call   103ae <lodepng_decode>
   105b2:	83 c4 20             	add    $0x20,%esp
   105b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   105b8:	83 ec 0c             	sub    $0xc,%esp
   105bb:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   105c1:	50                   	push   %eax
   105c2:	e8 d7 01 00 00       	call   1079e <lodepng_state_cleanup>
   105c7:	83 c4 10             	add    $0x10,%esp
  return error;
   105ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   105cd:	c9                   	leave  
   105ce:	c3                   	ret    

000105cf <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   105cf:	55                   	push   %ebp
   105d0:	89 e5                	mov    %esp,%ebp
   105d2:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   105d5:	83 ec 04             	sub    $0x4,%esp
   105d8:	6a 08                	push   $0x8
   105da:	6a 06                	push   $0x6
   105dc:	ff 75 18             	pushl  0x18(%ebp)
   105df:	ff 75 14             	pushl  0x14(%ebp)
   105e2:	ff 75 10             	pushl  0x10(%ebp)
   105e5:	ff 75 0c             	pushl  0xc(%ebp)
   105e8:	ff 75 08             	pushl  0x8(%ebp)
   105eb:	e8 63 ff ff ff       	call   10553 <lodepng_decode_memory>
   105f0:	83 c4 20             	add    $0x20,%esp
}
   105f3:	c9                   	leave  
   105f4:	c3                   	ret    

000105f5 <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   105f5:	55                   	push   %ebp
   105f6:	89 e5                	mov    %esp,%ebp
   105f8:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   105fb:	83 ec 04             	sub    $0x4,%esp
   105fe:	6a 08                	push   $0x8
   10600:	6a 02                	push   $0x2
   10602:	ff 75 18             	pushl  0x18(%ebp)
   10605:	ff 75 14             	pushl  0x14(%ebp)
   10608:	ff 75 10             	pushl  0x10(%ebp)
   1060b:	ff 75 0c             	pushl  0xc(%ebp)
   1060e:	ff 75 08             	pushl  0x8(%ebp)
   10611:	e8 3d ff ff ff       	call   10553 <lodepng_decode_memory>
   10616:	83 c4 20             	add    $0x20,%esp
}
   10619:	c9                   	leave  
   1061a:	c3                   	ret    

0001061b <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   1061b:	55                   	push   %ebp
   1061c:	89 e5                	mov    %esp,%ebp
   1061e:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   10621:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   10628:	8b 45 08             	mov    0x8(%ebp),%eax
   1062b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   10631:	8b 45 10             	mov    0x10(%ebp),%eax
   10634:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   1063a:	8b 45 10             	mov    0x10(%ebp),%eax
   1063d:	8b 10                	mov    (%eax),%edx
   1063f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10642:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   10644:	83 ec 04             	sub    $0x4,%esp
   10647:	ff 75 14             	pushl  0x14(%ebp)
   1064a:	8d 45 ec             	lea    -0x14(%ebp),%eax
   1064d:	50                   	push   %eax
   1064e:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10651:	50                   	push   %eax
   10652:	e8 70 32 ff ff       	call   38c7 <lodepng_load_file>
   10657:	83 c4 10             	add    $0x10,%esp
   1065a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   1065d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10661:	75 25                	jne    10688 <lodepng_decode_file+0x6d>
   10663:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10666:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10669:	83 ec 04             	sub    $0x4,%esp
   1066c:	ff 75 1c             	pushl  0x1c(%ebp)
   1066f:	ff 75 18             	pushl  0x18(%ebp)
   10672:	52                   	push   %edx
   10673:	50                   	push   %eax
   10674:	ff 75 10             	pushl  0x10(%ebp)
   10677:	ff 75 0c             	pushl  0xc(%ebp)
   1067a:	ff 75 08             	pushl  0x8(%ebp)
   1067d:	e8 d1 fe ff ff       	call   10553 <lodepng_decode_memory>
   10682:	83 c4 20             	add    $0x20,%esp
   10685:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   10688:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1068b:	83 ec 0c             	sub    $0xc,%esp
   1068e:	50                   	push   %eax
   1068f:	e8 fb 2d ff ff       	call   348f <lodepng_free>
   10694:	83 c4 10             	add    $0x10,%esp
  return error;
   10697:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1069a:	c9                   	leave  
   1069b:	c3                   	ret    

0001069c <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   1069c:	55                   	push   %ebp
   1069d:	89 e5                	mov    %esp,%ebp
   1069f:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   106a2:	83 ec 08             	sub    $0x8,%esp
   106a5:	6a 08                	push   $0x8
   106a7:	6a 06                	push   $0x6
   106a9:	ff 75 14             	pushl  0x14(%ebp)
   106ac:	ff 75 10             	pushl  0x10(%ebp)
   106af:	ff 75 0c             	pushl  0xc(%ebp)
   106b2:	ff 75 08             	pushl  0x8(%ebp)
   106b5:	e8 61 ff ff ff       	call   1061b <lodepng_decode_file>
   106ba:	83 c4 20             	add    $0x20,%esp
}
   106bd:	c9                   	leave  
   106be:	c3                   	ret    

000106bf <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   106bf:	55                   	push   %ebp
   106c0:	89 e5                	mov    %esp,%ebp
   106c2:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   106c5:	83 ec 08             	sub    $0x8,%esp
   106c8:	6a 08                	push   $0x8
   106ca:	6a 02                	push   $0x2
   106cc:	ff 75 14             	pushl  0x14(%ebp)
   106cf:	ff 75 10             	pushl  0x10(%ebp)
   106d2:	ff 75 0c             	pushl  0xc(%ebp)
   106d5:	ff 75 08             	pushl  0x8(%ebp)
   106d8:	e8 3e ff ff ff       	call   1061b <lodepng_decode_file>
   106dd:	83 c4 20             	add    $0x20,%esp
}
   106e0:	c9                   	leave  
   106e1:	c3                   	ret    

000106e2 <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   106e2:	55                   	push   %ebp
   106e3:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   106e5:	8b 45 08             	mov    0x8(%ebp),%eax
   106e8:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   106ef:	8b 45 08             	mov    0x8(%ebp),%eax
   106f2:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   106f9:	8b 45 08             	mov    0x8(%ebp),%eax
   106fc:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   10703:	8b 45 08             	mov    0x8(%ebp),%eax
   10706:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   1070d:	8b 45 08             	mov    0x8(%ebp),%eax
   10710:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   10717:	8b 45 08             	mov    0x8(%ebp),%eax
   1071a:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   10721:	8b 45 08             	mov    0x8(%ebp),%eax
   10724:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   1072b:	8b 45 08             	mov    0x8(%ebp),%eax
   1072e:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   10735:	8b 45 08             	mov    0x8(%ebp),%eax
   10738:	50                   	push   %eax
   10739:	e8 ff 7a ff ff       	call   823d <lodepng_decompress_settings_init>
   1073e:	83 c4 04             	add    $0x4,%esp
}
   10741:	90                   	nop
   10742:	c9                   	leave  
   10743:	c3                   	ret    

00010744 <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   10744:	55                   	push   %ebp
   10745:	89 e5                	mov    %esp,%ebp
   10747:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   1074a:	8b 45 08             	mov    0x8(%ebp),%eax
   1074d:	50                   	push   %eax
   1074e:	e8 8f ff ff ff       	call   106e2 <lodepng_decoder_settings_init>
   10753:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   10756:	8b 45 08             	mov    0x8(%ebp),%eax
   10759:	83 c0 38             	add    $0x38,%eax
   1075c:	83 ec 0c             	sub    $0xc,%esp
   1075f:	50                   	push   %eax
   10760:	e8 fc 30 00 00       	call   13861 <lodepng_encoder_settings_init>
   10765:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   10768:	8b 45 08             	mov    0x8(%ebp),%eax
   1076b:	83 c0 78             	add    $0x78,%eax
   1076e:	83 ec 0c             	sub    $0xc,%esp
   10771:	50                   	push   %eax
   10772:	e8 06 84 ff ff       	call   8b7d <lodepng_color_mode_init>
   10777:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   1077a:	8b 45 08             	mov    0x8(%ebp),%eax
   1077d:	05 98 00 00 00       	add    $0x98,%eax
   10782:	83 ec 0c             	sub    $0xc,%esp
   10785:	50                   	push   %eax
   10786:	e8 89 93 ff ff       	call   9b14 <lodepng_info_init>
   1078b:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   1078e:	8b 45 08             	mov    0x8(%ebp),%eax
   10791:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   10798:	00 00 00 
}
   1079b:	90                   	nop
   1079c:	c9                   	leave  
   1079d:	c3                   	ret    

0001079e <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   1079e:	55                   	push   %ebp
   1079f:	89 e5                	mov    %esp,%ebp
   107a1:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   107a4:	8b 45 08             	mov    0x8(%ebp),%eax
   107a7:	83 c0 78             	add    $0x78,%eax
   107aa:	83 ec 0c             	sub    $0xc,%esp
   107ad:	50                   	push   %eax
   107ae:	e8 bd 84 ff ff       	call   8c70 <lodepng_color_mode_cleanup>
   107b3:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   107b6:	8b 45 08             	mov    0x8(%ebp),%eax
   107b9:	05 98 00 00 00       	add    $0x98,%eax
   107be:	83 ec 0c             	sub    $0xc,%esp
   107c1:	50                   	push   %eax
   107c2:	e8 2e 94 ff ff       	call   9bf5 <lodepng_info_cleanup>
   107c7:	83 c4 10             	add    $0x10,%esp
}
   107ca:	90                   	nop
   107cb:	c9                   	leave  
   107cc:	c3                   	ret    

000107cd <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   107cd:	55                   	push   %ebp
   107ce:	89 e5                	mov    %esp,%ebp
   107d0:	57                   	push   %edi
   107d1:	56                   	push   %esi
   107d2:	53                   	push   %ebx
   107d3:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   107d6:	83 ec 0c             	sub    $0xc,%esp
   107d9:	ff 75 08             	pushl  0x8(%ebp)
   107dc:	e8 bd ff ff ff       	call   1079e <lodepng_state_cleanup>
   107e1:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   107e4:	8b 55 08             	mov    0x8(%ebp),%edx
   107e7:	8b 45 0c             	mov    0xc(%ebp),%eax
   107ea:	89 c3                	mov    %eax,%ebx
   107ec:	b8 60 00 00 00       	mov    $0x60,%eax
   107f1:	89 d7                	mov    %edx,%edi
   107f3:	89 de                	mov    %ebx,%esi
   107f5:	89 c1                	mov    %eax,%ecx
   107f7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   107f9:	8b 45 08             	mov    0x8(%ebp),%eax
   107fc:	83 c0 78             	add    $0x78,%eax
   107ff:	83 ec 0c             	sub    $0xc,%esp
   10802:	50                   	push   %eax
   10803:	e8 75 83 ff ff       	call   8b7d <lodepng_color_mode_init>
   10808:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   1080b:	8b 45 08             	mov    0x8(%ebp),%eax
   1080e:	05 98 00 00 00       	add    $0x98,%eax
   10813:	83 ec 0c             	sub    $0xc,%esp
   10816:	50                   	push   %eax
   10817:	e8 f8 92 ff ff       	call   9b14 <lodepng_info_init>
   1081c:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   1081f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10822:	8d 50 78             	lea    0x78(%eax),%edx
   10825:	8b 45 08             	mov    0x8(%ebp),%eax
   10828:	83 c0 78             	add    $0x78,%eax
   1082b:	83 ec 08             	sub    $0x8,%esp
   1082e:	52                   	push   %edx
   1082f:	50                   	push   %eax
   10830:	e8 52 84 ff ff       	call   8c87 <lodepng_color_mode_copy>
   10835:	83 c4 10             	add    $0x10,%esp
   10838:	89 c2                	mov    %eax,%edx
   1083a:	8b 45 08             	mov    0x8(%ebp),%eax
   1083d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   10843:	8b 45 08             	mov    0x8(%ebp),%eax
   10846:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1084c:	85 c0                	test   %eax,%eax
   1084e:	75 36                	jne    10886 <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   10850:	8b 45 0c             	mov    0xc(%ebp),%eax
   10853:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   10859:	8b 45 08             	mov    0x8(%ebp),%eax
   1085c:	05 98 00 00 00       	add    $0x98,%eax
   10861:	83 ec 08             	sub    $0x8,%esp
   10864:	52                   	push   %edx
   10865:	50                   	push   %eax
   10866:	e8 dd 93 ff ff       	call   9c48 <lodepng_info_copy>
   1086b:	83 c4 10             	add    $0x10,%esp
   1086e:	89 c2                	mov    %eax,%edx
   10870:	8b 45 08             	mov    0x8(%ebp),%eax
   10873:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   10879:	8b 45 08             	mov    0x8(%ebp),%eax
   1087c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10882:	85 c0                	test   %eax,%eax
   10884:	eb 01                	jmp    10887 <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   10886:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   10887:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1088a:	5b                   	pop    %ebx
   1088b:	5e                   	pop    %esi
   1088c:	5f                   	pop    %edi
   1088d:	5d                   	pop    %ebp
   1088e:	c3                   	ret    

0001088f <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   1088f:	55                   	push   %ebp
   10890:	89 e5                	mov    %esp,%ebp
   10892:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   10895:	8b 45 08             	mov    0x8(%ebp),%eax
   10898:	8b 40 04             	mov    0x4(%eax),%eax
   1089b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   1089e:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   108a2:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   108a6:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   108aa:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   108ae:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   108b2:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   108b6:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   108ba:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   108be:	8b 45 08             	mov    0x8(%ebp),%eax
   108c1:	8b 40 04             	mov    0x4(%eax),%eax
   108c4:	83 c0 08             	add    $0x8,%eax
   108c7:	50                   	push   %eax
   108c8:	ff 75 08             	pushl  0x8(%ebp)
   108cb:	e8 f8 2d ff ff       	call   36c8 <ucvector_resize>
   108d0:	83 c4 08             	add    $0x8,%esp
   108d3:	85 c0                	test   %eax,%eax
   108d5:	75 07                	jne    108de <writeSignature+0x4f>
   108d7:	b8 53 00 00 00       	mov    $0x53,%eax
   108dc:	eb 1e                	jmp    108fc <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   108de:	8b 45 08             	mov    0x8(%ebp),%eax
   108e1:	8b 10                	mov    (%eax),%edx
   108e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   108e6:	01 c2                	add    %eax,%edx
   108e8:	6a 08                	push   $0x8
   108ea:	8d 45 f4             	lea    -0xc(%ebp),%eax
   108ed:	50                   	push   %eax
   108ee:	52                   	push   %edx
   108ef:	e8 b8 2b ff ff       	call   34ac <lodepng_memcpy>
   108f4:	83 c4 0c             	add    $0xc,%esp
  return 0;
   108f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
   108fc:	c9                   	leave  
   108fd:	c3                   	ret    

000108fe <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   108fe:	55                   	push   %ebp
   108ff:	89 e5                	mov    %esp,%ebp
   10901:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   10904:	68 8c a1 01 00       	push   $0x1a18c
   10909:	6a 0d                	push   $0xd
   1090b:	ff 75 08             	pushl  0x8(%ebp)
   1090e:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10911:	50                   	push   %eax
   10912:	e8 cf 7f ff ff       	call   88e6 <lodepng_chunk_init>
   10917:	83 c4 10             	add    $0x10,%esp
   1091a:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1091d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10921:	74 05                	je     10928 <addChunk_IHDR+0x2a>
   10923:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10926:	eb 6d                	jmp    10995 <addChunk_IHDR+0x97>
  data = chunk + 8;
   10928:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1092b:	83 c0 08             	add    $0x8,%eax
   1092e:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   10931:	ff 75 0c             	pushl  0xc(%ebp)
   10934:	ff 75 f8             	pushl  -0x8(%ebp)
   10937:	e8 f3 2e ff ff       	call   382f <lodepng_set32bitInt>
   1093c:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   1093f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10942:	83 c0 04             	add    $0x4,%eax
   10945:	ff 75 10             	pushl  0x10(%ebp)
   10948:	50                   	push   %eax
   10949:	e8 e1 2e ff ff       	call   382f <lodepng_set32bitInt>
   1094e:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   10951:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10954:	83 c0 08             	add    $0x8,%eax
   10957:	8b 55 18             	mov    0x18(%ebp),%edx
   1095a:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   1095c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1095f:	83 c0 09             	add    $0x9,%eax
   10962:	8b 55 14             	mov    0x14(%ebp),%edx
   10965:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   10967:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1096a:	83 c0 0a             	add    $0xa,%eax
   1096d:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   10970:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10973:	83 c0 0b             	add    $0xb,%eax
   10976:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   10979:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1097c:	83 c0 0c             	add    $0xc,%eax
   1097f:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10982:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   10984:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10987:	50                   	push   %eax
   10988:	e8 02 7c ff ff       	call   858f <lodepng_chunk_generate_crc>
   1098d:	83 c4 04             	add    $0x4,%esp
  return 0;
   10990:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10995:	c9                   	leave  
   10996:	c3                   	ret    

00010997 <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   10997:	55                   	push   %ebp
   10998:	89 e5                	mov    %esp,%ebp
   1099a:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   1099d:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   109a4:	8b 45 0c             	mov    0xc(%ebp),%eax
   109a7:	8b 50 0c             	mov    0xc(%eax),%edx
   109aa:	89 d0                	mov    %edx,%eax
   109ac:	01 c0                	add    %eax,%eax
   109ae:	01 d0                	add    %edx,%eax
   109b0:	68 a8 a1 01 00       	push   $0x1a1a8
   109b5:	50                   	push   %eax
   109b6:	ff 75 08             	pushl  0x8(%ebp)
   109b9:	8d 45 f0             	lea    -0x10(%ebp),%eax
   109bc:	50                   	push   %eax
   109bd:	e8 24 7f ff ff       	call   88e6 <lodepng_chunk_init>
   109c2:	83 c4 10             	add    $0x10,%esp
   109c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
   109c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   109cc:	74 08                	je     109d6 <addChunk_PLTE+0x3f>
   109ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
   109d1:	e9 95 00 00 00       	jmp    10a6b <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   109d6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   109dd:	eb 70                	jmp    10a4f <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   109df:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   109e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   109e5:	8d 50 01             	lea    0x1(%eax),%edx
   109e8:	89 55 f8             	mov    %edx,-0x8(%ebp)
   109eb:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   109ee:	8b 45 0c             	mov    0xc(%ebp),%eax
   109f1:	8b 40 08             	mov    0x8(%eax),%eax
   109f4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   109f7:	c1 e1 02             	shl    $0x2,%ecx
   109fa:	01 c8                	add    %ecx,%eax
   109fc:	0f b6 00             	movzbl (%eax),%eax
   109ff:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   10a01:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10a04:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10a07:	8d 50 01             	lea    0x1(%eax),%edx
   10a0a:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10a0d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10a10:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a13:	8b 40 08             	mov    0x8(%eax),%eax
   10a16:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10a19:	c1 e1 02             	shl    $0x2,%ecx
   10a1c:	83 c1 01             	add    $0x1,%ecx
   10a1f:	01 c8                	add    %ecx,%eax
   10a21:	0f b6 00             	movzbl (%eax),%eax
   10a24:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   10a26:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10a29:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10a2c:	8d 50 01             	lea    0x1(%eax),%edx
   10a2f:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10a32:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10a35:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a38:	8b 40 08             	mov    0x8(%eax),%eax
   10a3b:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10a3e:	c1 e1 02             	shl    $0x2,%ecx
   10a41:	83 c1 02             	add    $0x2,%ecx
   10a44:	01 c8                	add    %ecx,%eax
   10a46:	0f b6 00             	movzbl (%eax),%eax
   10a49:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   10a4b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10a4f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a52:	8b 40 0c             	mov    0xc(%eax),%eax
   10a55:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   10a58:	75 85                	jne    109df <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   10a5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a5d:	50                   	push   %eax
   10a5e:	e8 2c 7b ff ff       	call   858f <lodepng_chunk_generate_crc>
   10a63:	83 c4 04             	add    $0x4,%esp
  return 0;
   10a66:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10a6b:	c9                   	leave  
   10a6c:	c3                   	ret    

00010a6d <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   10a6d:	55                   	push   %ebp
   10a6e:	89 e5                	mov    %esp,%ebp
   10a70:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10a73:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   10a7a:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a7d:	8b 00                	mov    (%eax),%eax
   10a7f:	83 f8 03             	cmp    $0x3,%eax
   10a82:	0f 85 ae 00 00 00    	jne    10b36 <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   10a88:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a8b:	8b 40 0c             	mov    0xc(%eax),%eax
   10a8e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10a91:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a94:	8b 40 0c             	mov    0xc(%eax),%eax
   10a97:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10a9a:	eb 23                	jmp    10abf <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
   10a9f:	8b 40 08             	mov    0x8(%eax),%eax
   10aa2:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10aa5:	83 ea 01             	sub    $0x1,%edx
   10aa8:	c1 e2 02             	shl    $0x2,%edx
   10aab:	83 c2 03             	add    $0x3,%edx
   10aae:	01 d0                	add    %edx,%eax
   10ab0:	0f b6 00             	movzbl (%eax),%eax
   10ab3:	3c ff                	cmp    $0xff,%al
   10ab5:	75 10                	jne    10ac7 <addChunk_tRNS+0x5a>
      --amount;
   10ab7:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10abb:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   10abf:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10ac3:	75 d7                	jne    10a9c <addChunk_tRNS+0x2f>
   10ac5:	eb 01                	jmp    10ac8 <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10ac7:	90                   	nop
      --amount;
    }
    if(amount) {
   10ac8:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   10acc:	0f 84 63 01 00 00    	je     10c35 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   10ad2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10ad5:	68 ad a1 01 00       	push   $0x1a1ad
   10ada:	50                   	push   %eax
   10adb:	ff 75 08             	pushl  0x8(%ebp)
   10ade:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10ae1:	50                   	push   %eax
   10ae2:	e8 ff 7d ff ff       	call   88e6 <lodepng_chunk_init>
   10ae7:	83 c4 10             	add    $0x10,%esp
   10aea:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10aed:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10af1:	74 08                	je     10afb <addChunk_tRNS+0x8e>
   10af3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10af6:	e9 52 01 00 00       	jmp    10c4d <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   10afb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10b02:	eb 25                	jmp    10b29 <addChunk_tRNS+0xbc>
   10b04:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b07:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10b0a:	83 c2 08             	add    $0x8,%edx
   10b0d:	01 c2                	add    %eax,%edx
   10b0f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b12:	8b 40 08             	mov    0x8(%eax),%eax
   10b15:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10b18:	c1 e1 02             	shl    $0x2,%ecx
   10b1b:	83 c1 03             	add    $0x3,%ecx
   10b1e:	01 c8                	add    %ecx,%eax
   10b20:	0f b6 00             	movzbl (%eax),%eax
   10b23:	88 02                	mov    %al,(%edx)
   10b25:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10b29:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10b2c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   10b2f:	75 d3                	jne    10b04 <addChunk_tRNS+0x97>
   10b31:	e9 ff 00 00 00       	jmp    10c35 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   10b36:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b39:	8b 00                	mov    (%eax),%eax
   10b3b:	85 c0                	test   %eax,%eax
   10b3d:	75 59                	jne    10b98 <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   10b3f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b42:	8b 40 10             	mov    0x10(%eax),%eax
   10b45:	85 c0                	test   %eax,%eax
   10b47:	0f 84 e8 00 00 00    	je     10c35 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   10b4d:	68 ad a1 01 00       	push   $0x1a1ad
   10b52:	6a 02                	push   $0x2
   10b54:	ff 75 08             	pushl  0x8(%ebp)
   10b57:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10b5a:	50                   	push   %eax
   10b5b:	e8 86 7d ff ff       	call   88e6 <lodepng_chunk_init>
   10b60:	83 c4 10             	add    $0x10,%esp
   10b63:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10b66:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10b6a:	74 08                	je     10b74 <addChunk_tRNS+0x107>
   10b6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10b6f:	e9 d9 00 00 00       	jmp    10c4d <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10b74:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b77:	8d 50 08             	lea    0x8(%eax),%edx
   10b7a:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b7d:	8b 40 14             	mov    0x14(%eax),%eax
   10b80:	c1 e8 08             	shr    $0x8,%eax
   10b83:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10b85:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10b88:	8d 50 09             	lea    0x9(%eax),%edx
   10b8b:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b8e:	8b 40 14             	mov    0x14(%eax),%eax
   10b91:	88 02                	mov    %al,(%edx)
   10b93:	e9 9d 00 00 00       	jmp    10c35 <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   10b98:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b9b:	8b 00                	mov    (%eax),%eax
   10b9d:	83 f8 02             	cmp    $0x2,%eax
   10ba0:	0f 85 8f 00 00 00    	jne    10c35 <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   10ba6:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ba9:	8b 40 10             	mov    0x10(%eax),%eax
   10bac:	85 c0                	test   %eax,%eax
   10bae:	0f 84 81 00 00 00    	je     10c35 <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   10bb4:	68 ad a1 01 00       	push   $0x1a1ad
   10bb9:	6a 06                	push   $0x6
   10bbb:	ff 75 08             	pushl  0x8(%ebp)
   10bbe:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10bc1:	50                   	push   %eax
   10bc2:	e8 1f 7d ff ff       	call   88e6 <lodepng_chunk_init>
   10bc7:	83 c4 10             	add    $0x10,%esp
   10bca:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10bcd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10bd1:	74 05                	je     10bd8 <addChunk_tRNS+0x16b>
   10bd3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10bd6:	eb 75                	jmp    10c4d <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10bd8:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10bdb:	8d 50 08             	lea    0x8(%eax),%edx
   10bde:	8b 45 0c             	mov    0xc(%ebp),%eax
   10be1:	8b 40 14             	mov    0x14(%eax),%eax
   10be4:	c1 e8 08             	shr    $0x8,%eax
   10be7:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10be9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10bec:	8d 50 09             	lea    0x9(%eax),%edx
   10bef:	8b 45 0c             	mov    0xc(%ebp),%eax
   10bf2:	8b 40 14             	mov    0x14(%eax),%eax
   10bf5:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   10bf7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10bfa:	8d 50 0a             	lea    0xa(%eax),%edx
   10bfd:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c00:	8b 40 18             	mov    0x18(%eax),%eax
   10c03:	c1 e8 08             	shr    $0x8,%eax
   10c06:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   10c08:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10c0b:	8d 50 0b             	lea    0xb(%eax),%edx
   10c0e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c11:	8b 40 18             	mov    0x18(%eax),%eax
   10c14:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   10c16:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10c19:	8d 50 0c             	lea    0xc(%eax),%edx
   10c1c:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c1f:	8b 40 1c             	mov    0x1c(%eax),%eax
   10c22:	c1 e8 08             	shr    $0x8,%eax
   10c25:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   10c27:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10c2a:	8d 50 0d             	lea    0xd(%eax),%edx
   10c2d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c30:	8b 40 1c             	mov    0x1c(%eax),%eax
   10c33:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   10c35:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10c38:	85 c0                	test   %eax,%eax
   10c3a:	74 0c                	je     10c48 <addChunk_tRNS+0x1db>
   10c3c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10c3f:	50                   	push   %eax
   10c40:	e8 4a 79 ff ff       	call   858f <lodepng_chunk_generate_crc>
   10c45:	83 c4 04             	add    $0x4,%esp
  return 0;
   10c48:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10c4d:	c9                   	leave  
   10c4e:	c3                   	ret    

00010c4f <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   10c4f:	55                   	push   %ebp
   10c50:	89 e5                	mov    %esp,%ebp
   10c52:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   10c55:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   10c5c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   10c63:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   10c6a:	83 ec 0c             	sub    $0xc,%esp
   10c6d:	ff 75 14             	pushl  0x14(%ebp)
   10c70:	ff 75 10             	pushl  0x10(%ebp)
   10c73:	ff 75 0c             	pushl  0xc(%ebp)
   10c76:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10c79:	50                   	push   %eax
   10c7a:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10c7d:	50                   	push   %eax
   10c7e:	e8 fb 74 ff ff       	call   817e <zlib_compress>
   10c83:	83 c4 20             	add    $0x20,%esp
   10c86:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   10c89:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10c8d:	75 1b                	jne    10caa <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   10c8f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10c92:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10c95:	50                   	push   %eax
   10c96:	68 e4 a1 01 00       	push   $0x1a1e4
   10c9b:	52                   	push   %edx
   10c9c:	ff 75 08             	pushl  0x8(%ebp)
   10c9f:	e8 ea 7c ff ff       	call   898e <lodepng_chunk_createv>
   10ca4:	83 c4 10             	add    $0x10,%esp
   10ca7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   10caa:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10cad:	83 ec 0c             	sub    $0xc,%esp
   10cb0:	50                   	push   %eax
   10cb1:	e8 d9 27 ff ff       	call   348f <lodepng_free>
   10cb6:	83 c4 10             	add    $0x10,%esp
  return error;
   10cb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10cbc:	c9                   	leave  
   10cbd:	c3                   	ret    

00010cbe <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   10cbe:	55                   	push   %ebp
   10cbf:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   10cc1:	6a 00                	push   $0x0
   10cc3:	68 e9 a1 01 00       	push   $0x1a1e9
   10cc8:	6a 00                	push   $0x0
   10cca:	ff 75 08             	pushl  0x8(%ebp)
   10ccd:	e8 bc 7c ff ff       	call   898e <lodepng_chunk_createv>
   10cd2:	83 c4 10             	add    $0x10,%esp
}
   10cd5:	c9                   	leave  
   10cd6:	c3                   	ret    

00010cd7 <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   10cd7:	55                   	push   %ebp
   10cd8:	89 e5                	mov    %esp,%ebp
   10cda:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10cdd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   10ce4:	ff 75 0c             	pushl  0xc(%ebp)
   10ce7:	e8 1e 28 ff ff       	call   350a <lodepng_strlen>
   10cec:	83 c4 04             	add    $0x4,%esp
   10cef:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10cf2:	ff 75 10             	pushl  0x10(%ebp)
   10cf5:	e8 10 28 ff ff       	call   350a <lodepng_strlen>
   10cfa:	83 c4 04             	add    $0x4,%esp
   10cfd:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   10d00:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10d03:	8d 50 01             	lea    0x1(%eax),%edx
   10d06:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10d09:	01 d0                	add    %edx,%eax
   10d0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10d0e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10d12:	7e 06                	jle    10d1a <addChunk_tEXt+0x43>
   10d14:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   10d18:	7e 07                	jle    10d21 <addChunk_tEXt+0x4a>
   10d1a:	b8 59 00 00 00       	mov    $0x59,%eax
   10d1f:	eb 74                	jmp    10d95 <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   10d21:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10d24:	68 b7 a1 01 00       	push   $0x1a1b7
   10d29:	50                   	push   %eax
   10d2a:	ff 75 08             	pushl  0x8(%ebp)
   10d2d:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10d30:	50                   	push   %eax
   10d31:	e8 b0 7b ff ff       	call   88e6 <lodepng_chunk_init>
   10d36:	83 c4 10             	add    $0x10,%esp
   10d39:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10d3c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10d40:	74 05                	je     10d47 <addChunk_tEXt+0x70>
   10d42:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10d45:	eb 4e                	jmp    10d95 <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   10d47:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d4a:	83 c0 08             	add    $0x8,%eax
   10d4d:	ff 75 fc             	pushl  -0x4(%ebp)
   10d50:	ff 75 0c             	pushl  0xc(%ebp)
   10d53:	50                   	push   %eax
   10d54:	e8 53 27 ff ff       	call   34ac <lodepng_memcpy>
   10d59:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   10d5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d5f:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10d62:	83 c2 08             	add    $0x8,%edx
   10d65:	01 d0                	add    %edx,%eax
   10d67:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   10d6a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d6d:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10d70:	83 c2 09             	add    $0x9,%edx
   10d73:	01 d0                	add    %edx,%eax
   10d75:	ff 75 f8             	pushl  -0x8(%ebp)
   10d78:	ff 75 10             	pushl  0x10(%ebp)
   10d7b:	50                   	push   %eax
   10d7c:	e8 2b 27 ff ff       	call   34ac <lodepng_memcpy>
   10d81:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   10d84:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d87:	50                   	push   %eax
   10d88:	e8 02 78 ff ff       	call   858f <lodepng_chunk_generate_crc>
   10d8d:	83 c4 04             	add    $0x4,%esp
  return 0;
   10d90:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10d95:	c9                   	leave  
   10d96:	c3                   	ret    

00010d97 <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   10d97:	55                   	push   %ebp
   10d98:	89 e5                	mov    %esp,%ebp
   10d9a:	53                   	push   %ebx
   10d9b:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   10d9e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10da5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   10dac:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   10db3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10dba:	ff 75 10             	pushl  0x10(%ebp)
   10dbd:	e8 48 27 ff ff       	call   350a <lodepng_strlen>
   10dc2:	83 c4 04             	add    $0x4,%esp
   10dc5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   10dc8:	ff 75 0c             	pushl  0xc(%ebp)
   10dcb:	e8 3a 27 ff ff       	call   350a <lodepng_strlen>
   10dd0:	83 c4 04             	add    $0x4,%esp
   10dd3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10dd6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10dda:	7e 06                	jle    10de2 <addChunk_zTXt+0x4b>
   10ddc:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10de0:	7e 0a                	jle    10dec <addChunk_zTXt+0x55>
   10de2:	b8 59 00 00 00       	mov    $0x59,%eax
   10de7:	e9 c8 00 00 00       	jmp    10eb4 <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   10dec:	83 ec 0c             	sub    $0xc,%esp
   10def:	ff 75 14             	pushl  0x14(%ebp)
   10df2:	ff 75 f0             	pushl  -0x10(%ebp)
   10df5:	ff 75 10             	pushl  0x10(%ebp)
   10df8:	8d 45 dc             	lea    -0x24(%ebp),%eax
   10dfb:	50                   	push   %eax
   10dfc:	8d 45 e0             	lea    -0x20(%ebp),%eax
   10dff:	50                   	push   %eax
   10e00:	e8 79 73 ff ff       	call   817e <zlib_compress>
   10e05:	83 c4 20             	add    $0x20,%esp
   10e08:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   10e0b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e0f:	75 29                	jne    10e3a <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   10e11:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10e14:	8d 50 02             	lea    0x2(%eax),%edx
   10e17:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10e1a:	01 d0                	add    %edx,%eax
   10e1c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   10e1f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10e22:	68 bc a1 01 00       	push   $0x1a1bc
   10e27:	50                   	push   %eax
   10e28:	ff 75 08             	pushl  0x8(%ebp)
   10e2b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   10e2e:	50                   	push   %eax
   10e2f:	e8 b2 7a ff ff       	call   88e6 <lodepng_chunk_init>
   10e34:	83 c4 10             	add    $0x10,%esp
   10e37:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10e3a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e3e:	75 62                	jne    10ea2 <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   10e40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10e43:	83 c0 08             	add    $0x8,%eax
   10e46:	83 ec 04             	sub    $0x4,%esp
   10e49:	ff 75 ec             	pushl  -0x14(%ebp)
   10e4c:	ff 75 0c             	pushl  0xc(%ebp)
   10e4f:	50                   	push   %eax
   10e50:	e8 57 26 ff ff       	call   34ac <lodepng_memcpy>
   10e55:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   10e58:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10e5b:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10e5e:	83 c2 08             	add    $0x8,%edx
   10e61:	01 d0                	add    %edx,%eax
   10e63:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   10e66:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10e69:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10e6c:	83 c2 09             	add    $0x9,%edx
   10e6f:	01 d0                	add    %edx,%eax
   10e71:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   10e74:	8b 55 dc             	mov    -0x24(%ebp),%edx
   10e77:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10e7a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   10e7d:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   10e80:	83 c3 0a             	add    $0xa,%ebx
   10e83:	01 d9                	add    %ebx,%ecx
   10e85:	83 ec 04             	sub    $0x4,%esp
   10e88:	52                   	push   %edx
   10e89:	50                   	push   %eax
   10e8a:	51                   	push   %ecx
   10e8b:	e8 1c 26 ff ff       	call   34ac <lodepng_memcpy>
   10e90:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   10e93:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10e96:	83 ec 0c             	sub    $0xc,%esp
   10e99:	50                   	push   %eax
   10e9a:	e8 f0 76 ff ff       	call   858f <lodepng_chunk_generate_crc>
   10e9f:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   10ea2:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10ea5:	83 ec 0c             	sub    $0xc,%esp
   10ea8:	50                   	push   %eax
   10ea9:	e8 e1 25 ff ff       	call   348f <lodepng_free>
   10eae:	83 c4 10             	add    $0x10,%esp
  return error;
   10eb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10eb4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10eb7:	c9                   	leave  
   10eb8:	c3                   	ret    

00010eb9 <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   10eb9:	55                   	push   %ebp
   10eba:	89 e5                	mov    %esp,%ebp
   10ebc:	53                   	push   %ebx
   10ebd:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   10ec0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10ec7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   10ece:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   10ed5:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10edc:	ff 75 1c             	pushl  0x1c(%ebp)
   10edf:	e8 26 26 ff ff       	call   350a <lodepng_strlen>
   10ee4:	83 c4 04             	add    $0x4,%esp
   10ee7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   10eea:	ff 75 10             	pushl  0x10(%ebp)
   10eed:	e8 18 26 ff ff       	call   350a <lodepng_strlen>
   10ef2:	83 c4 04             	add    $0x4,%esp
   10ef5:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10ef8:	ff 75 14             	pushl  0x14(%ebp)
   10efb:	e8 0a 26 ff ff       	call   350a <lodepng_strlen>
   10f00:	83 c4 04             	add    $0x4,%esp
   10f03:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10f06:	ff 75 18             	pushl  0x18(%ebp)
   10f09:	e8 fc 25 ff ff       	call   350a <lodepng_strlen>
   10f0e:	83 c4 04             	add    $0x4,%esp
   10f11:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10f14:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10f18:	7e 06                	jle    10f20 <addChunk_iTXt+0x67>
   10f1a:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10f1e:	7e 0a                	jle    10f2a <addChunk_iTXt+0x71>
   10f20:	b8 59 00 00 00       	mov    $0x59,%eax
   10f25:	e9 9a 01 00 00       	jmp    110c4 <addChunk_iTXt+0x20b>

  if(compress) {
   10f2a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10f2e:	74 1f                	je     10f4f <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   10f30:	83 ec 0c             	sub    $0xc,%esp
   10f33:	ff 75 20             	pushl  0x20(%ebp)
   10f36:	ff 75 f0             	pushl  -0x10(%ebp)
   10f39:	ff 75 1c             	pushl  0x1c(%ebp)
   10f3c:	8d 45 d0             	lea    -0x30(%ebp),%eax
   10f3f:	50                   	push   %eax
   10f40:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   10f43:	50                   	push   %eax
   10f44:	e8 35 72 ff ff       	call   817e <zlib_compress>
   10f49:	83 c4 20             	add    $0x20,%esp
   10f4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   10f4f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10f53:	75 44                	jne    10f99 <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   10f55:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10f58:	8d 50 03             	lea    0x3(%eax),%edx
   10f5b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10f5e:	01 d0                	add    %edx,%eax
   10f60:	8d 50 01             	lea    0x1(%eax),%edx
   10f63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10f66:	01 d0                	add    %edx,%eax
   10f68:	8d 50 01             	lea    0x1(%eax),%edx
   10f6b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10f6f:	74 05                	je     10f76 <addChunk_iTXt+0xbd>
   10f71:	8b 45 d0             	mov    -0x30(%ebp),%eax
   10f74:	eb 03                	jmp    10f79 <addChunk_iTXt+0xc0>
   10f76:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10f79:	01 d0                	add    %edx,%eax
   10f7b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   10f7e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10f81:	68 c1 a1 01 00       	push   $0x1a1c1
   10f86:	50                   	push   %eax
   10f87:	ff 75 08             	pushl  0x8(%ebp)
   10f8a:	8d 45 d8             	lea    -0x28(%ebp),%eax
   10f8d:	50                   	push   %eax
   10f8e:	e8 53 79 ff ff       	call   88e6 <lodepng_chunk_init>
   10f93:	83 c4 10             	add    $0x10,%esp
   10f96:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10f99:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10f9d:	0f 85 0f 01 00 00    	jne    110b2 <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   10fa3:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   10faa:	8b 55 d8             	mov    -0x28(%ebp),%edx
   10fad:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10fb0:	01 d0                	add    %edx,%eax
   10fb2:	83 ec 04             	sub    $0x4,%esp
   10fb5:	ff 75 ec             	pushl  -0x14(%ebp)
   10fb8:	ff 75 10             	pushl  0x10(%ebp)
   10fbb:	50                   	push   %eax
   10fbc:	e8 eb 24 ff ff       	call   34ac <lodepng_memcpy>
   10fc1:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   10fc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10fc7:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   10fca:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10fcd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10fd0:	8d 50 01             	lea    0x1(%eax),%edx
   10fd3:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10fd6:	01 c8                	add    %ecx,%eax
   10fd8:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   10fdb:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10fde:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10fe1:	8d 50 01             	lea    0x1(%eax),%edx
   10fe4:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10fe7:	01 c8                	add    %ecx,%eax
   10fe9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   10fed:	0f 95 c2             	setne  %dl
   10ff0:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   10ff2:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   10ff5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10ff8:	8d 50 01             	lea    0x1(%eax),%edx
   10ffb:	89 55 dc             	mov    %edx,-0x24(%ebp)
   10ffe:	01 c8                	add    %ecx,%eax
   11000:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   11003:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11006:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11009:	01 d0                	add    %edx,%eax
   1100b:	83 ec 04             	sub    $0x4,%esp
   1100e:	ff 75 e8             	pushl  -0x18(%ebp)
   11011:	ff 75 14             	pushl  0x14(%ebp)
   11014:	50                   	push   %eax
   11015:	e8 92 24 ff ff       	call   34ac <lodepng_memcpy>
   1101a:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   1101d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11020:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11023:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11026:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11029:	8d 50 01             	lea    0x1(%eax),%edx
   1102c:	89 55 dc             	mov    %edx,-0x24(%ebp)
   1102f:	01 c8                	add    %ecx,%eax
   11031:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   11034:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11037:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1103a:	01 d0                	add    %edx,%eax
   1103c:	83 ec 04             	sub    $0x4,%esp
   1103f:	ff 75 e4             	pushl  -0x1c(%ebp)
   11042:	ff 75 18             	pushl  0x18(%ebp)
   11045:	50                   	push   %eax
   11046:	e8 61 24 ff ff       	call   34ac <lodepng_memcpy>
   1104b:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   1104e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11051:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11054:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11057:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1105a:	8d 50 01             	lea    0x1(%eax),%edx
   1105d:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11060:	01 c8                	add    %ecx,%eax
   11062:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   11065:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11069:	74 1e                	je     11089 <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   1106b:	8b 55 d0             	mov    -0x30(%ebp),%edx
   1106e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   11071:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   11074:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   11077:	01 d9                	add    %ebx,%ecx
   11079:	83 ec 04             	sub    $0x4,%esp
   1107c:	52                   	push   %edx
   1107d:	50                   	push   %eax
   1107e:	51                   	push   %ecx
   1107f:	e8 28 24 ff ff       	call   34ac <lodepng_memcpy>
   11084:	83 c4 10             	add    $0x10,%esp
   11087:	eb 1a                	jmp    110a3 <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   11089:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1108c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1108f:	01 d0                	add    %edx,%eax
   11091:	83 ec 04             	sub    $0x4,%esp
   11094:	ff 75 f0             	pushl  -0x10(%ebp)
   11097:	ff 75 1c             	pushl  0x1c(%ebp)
   1109a:	50                   	push   %eax
   1109b:	e8 0c 24 ff ff       	call   34ac <lodepng_memcpy>
   110a0:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   110a3:	8b 45 d8             	mov    -0x28(%ebp),%eax
   110a6:	83 ec 0c             	sub    $0xc,%esp
   110a9:	50                   	push   %eax
   110aa:	e8 e0 74 ff ff       	call   858f <lodepng_chunk_generate_crc>
   110af:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   110b2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   110b5:	83 ec 0c             	sub    $0xc,%esp
   110b8:	50                   	push   %eax
   110b9:	e8 d1 23 ff ff       	call   348f <lodepng_free>
   110be:	83 c4 10             	add    $0x10,%esp
  return error;
   110c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   110c4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   110c7:	c9                   	leave  
   110c8:	c3                   	ret    

000110c9 <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   110c9:	55                   	push   %ebp
   110ca:	89 e5                	mov    %esp,%ebp
   110cc:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   110cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   110d6:	8b 45 0c             	mov    0xc(%ebp),%eax
   110d9:	8b 40 0c             	mov    0xc(%eax),%eax
   110dc:	85 c0                	test   %eax,%eax
   110de:	74 0b                	je     110eb <addChunk_bKGD+0x22>
   110e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   110e3:	8b 40 0c             	mov    0xc(%eax),%eax
   110e6:	83 f8 04             	cmp    $0x4,%eax
   110e9:	75 4b                	jne    11136 <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   110eb:	68 b2 a1 01 00       	push   $0x1a1b2
   110f0:	6a 02                	push   $0x2
   110f2:	ff 75 08             	pushl  0x8(%ebp)
   110f5:	8d 45 f0             	lea    -0x10(%ebp),%eax
   110f8:	50                   	push   %eax
   110f9:	e8 e8 77 ff ff       	call   88e6 <lodepng_chunk_init>
   110fe:	83 c4 10             	add    $0x10,%esp
   11101:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11104:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11108:	74 08                	je     11112 <addChunk_bKGD+0x49>
   1110a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1110d:	e9 19 01 00 00       	jmp    1122b <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   11112:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11115:	8d 50 08             	lea    0x8(%eax),%edx
   11118:	8b 45 0c             	mov    0xc(%ebp),%eax
   1111b:	8b 40 30             	mov    0x30(%eax),%eax
   1111e:	c1 e8 08             	shr    $0x8,%eax
   11121:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   11123:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11126:	8d 50 09             	lea    0x9(%eax),%edx
   11129:	8b 45 0c             	mov    0xc(%ebp),%eax
   1112c:	8b 40 30             	mov    0x30(%eax),%eax
   1112f:	88 02                	mov    %al,(%edx)
   11131:	e9 dd 00 00 00       	jmp    11213 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   11136:	8b 45 0c             	mov    0xc(%ebp),%eax
   11139:	8b 40 0c             	mov    0xc(%eax),%eax
   1113c:	83 f8 02             	cmp    $0x2,%eax
   1113f:	74 0f                	je     11150 <addChunk_bKGD+0x87>
   11141:	8b 45 0c             	mov    0xc(%ebp),%eax
   11144:	8b 40 0c             	mov    0xc(%eax),%eax
   11147:	83 f8 06             	cmp    $0x6,%eax
   1114a:	0f 85 86 00 00 00    	jne    111d6 <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   11150:	68 b2 a1 01 00       	push   $0x1a1b2
   11155:	6a 06                	push   $0x6
   11157:	ff 75 08             	pushl  0x8(%ebp)
   1115a:	8d 45 f0             	lea    -0x10(%ebp),%eax
   1115d:	50                   	push   %eax
   1115e:	e8 83 77 ff ff       	call   88e6 <lodepng_chunk_init>
   11163:	83 c4 10             	add    $0x10,%esp
   11166:	89 45 f8             	mov    %eax,-0x8(%ebp)
   11169:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   1116d:	74 08                	je     11177 <addChunk_bKGD+0xae>
   1116f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11172:	e9 b4 00 00 00       	jmp    1122b <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   11177:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1117a:	8d 50 08             	lea    0x8(%eax),%edx
   1117d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11180:	8b 40 30             	mov    0x30(%eax),%eax
   11183:	c1 e8 08             	shr    $0x8,%eax
   11186:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   11188:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1118b:	8d 50 09             	lea    0x9(%eax),%edx
   1118e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11191:	8b 40 30             	mov    0x30(%eax),%eax
   11194:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   11196:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11199:	8d 50 0a             	lea    0xa(%eax),%edx
   1119c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1119f:	8b 40 34             	mov    0x34(%eax),%eax
   111a2:	c1 e8 08             	shr    $0x8,%eax
   111a5:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   111a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   111aa:	8d 50 0b             	lea    0xb(%eax),%edx
   111ad:	8b 45 0c             	mov    0xc(%ebp),%eax
   111b0:	8b 40 34             	mov    0x34(%eax),%eax
   111b3:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   111b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   111b8:	8d 50 0c             	lea    0xc(%eax),%edx
   111bb:	8b 45 0c             	mov    0xc(%ebp),%eax
   111be:	8b 40 38             	mov    0x38(%eax),%eax
   111c1:	c1 e8 08             	shr    $0x8,%eax
   111c4:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   111c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   111c9:	8d 50 0d             	lea    0xd(%eax),%edx
   111cc:	8b 45 0c             	mov    0xc(%ebp),%eax
   111cf:	8b 40 38             	mov    0x38(%eax),%eax
   111d2:	88 02                	mov    %al,(%edx)
   111d4:	eb 3d                	jmp    11213 <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   111d6:	8b 45 0c             	mov    0xc(%ebp),%eax
   111d9:	8b 40 0c             	mov    0xc(%eax),%eax
   111dc:	83 f8 03             	cmp    $0x3,%eax
   111df:	75 32                	jne    11213 <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   111e1:	68 b2 a1 01 00       	push   $0x1a1b2
   111e6:	6a 01                	push   $0x1
   111e8:	ff 75 08             	pushl  0x8(%ebp)
   111eb:	8d 45 f0             	lea    -0x10(%ebp),%eax
   111ee:	50                   	push   %eax
   111ef:	e8 f2 76 ff ff       	call   88e6 <lodepng_chunk_init>
   111f4:	83 c4 10             	add    $0x10,%esp
   111f7:	89 45 fc             	mov    %eax,-0x4(%ebp)
   111fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   111fe:	74 05                	je     11205 <addChunk_bKGD+0x13c>
   11200:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11203:	eb 26                	jmp    1122b <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   11205:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11208:	8d 50 08             	lea    0x8(%eax),%edx
   1120b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1120e:	8b 40 30             	mov    0x30(%eax),%eax
   11211:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   11213:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11216:	85 c0                	test   %eax,%eax
   11218:	74 0c                	je     11226 <addChunk_bKGD+0x15d>
   1121a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1121d:	50                   	push   %eax
   1121e:	e8 6c 73 ff ff       	call   858f <lodepng_chunk_generate_crc>
   11223:	83 c4 04             	add    $0x4,%esp
  return 0;
   11226:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1122b:	c9                   	leave  
   1122c:	c3                   	ret    

0001122d <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   1122d:	55                   	push   %ebp
   1122e:	89 e5                	mov    %esp,%ebp
   11230:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   11233:	68 c6 a1 01 00       	push   $0x1a1c6
   11238:	6a 07                	push   $0x7
   1123a:	ff 75 08             	pushl  0x8(%ebp)
   1123d:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11240:	50                   	push   %eax
   11241:	e8 a0 76 ff ff       	call   88e6 <lodepng_chunk_init>
   11246:	83 c4 10             	add    $0x10,%esp
   11249:	89 45 fc             	mov    %eax,-0x4(%ebp)
   1124c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11250:	74 05                	je     11257 <addChunk_tIME+0x2a>
   11252:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11255:	eb 74                	jmp    112cb <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   11257:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1125a:	8d 50 08             	lea    0x8(%eax),%edx
   1125d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11260:	8b 00                	mov    (%eax),%eax
   11262:	c1 e8 08             	shr    $0x8,%eax
   11265:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   11267:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1126a:	8d 50 09             	lea    0x9(%eax),%edx
   1126d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11270:	8b 00                	mov    (%eax),%eax
   11272:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   11274:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11277:	8d 50 0a             	lea    0xa(%eax),%edx
   1127a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1127d:	8b 40 04             	mov    0x4(%eax),%eax
   11280:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   11282:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11285:	8d 50 0b             	lea    0xb(%eax),%edx
   11288:	8b 45 0c             	mov    0xc(%ebp),%eax
   1128b:	8b 40 08             	mov    0x8(%eax),%eax
   1128e:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   11290:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11293:	8d 50 0c             	lea    0xc(%eax),%edx
   11296:	8b 45 0c             	mov    0xc(%ebp),%eax
   11299:	8b 40 0c             	mov    0xc(%eax),%eax
   1129c:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   1129e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   112a1:	8d 50 0d             	lea    0xd(%eax),%edx
   112a4:	8b 45 0c             	mov    0xc(%ebp),%eax
   112a7:	8b 40 10             	mov    0x10(%eax),%eax
   112aa:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   112ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
   112af:	8d 50 0e             	lea    0xe(%eax),%edx
   112b2:	8b 45 0c             	mov    0xc(%ebp),%eax
   112b5:	8b 40 14             	mov    0x14(%eax),%eax
   112b8:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   112ba:	8b 45 f8             	mov    -0x8(%ebp),%eax
   112bd:	50                   	push   %eax
   112be:	e8 cc 72 ff ff       	call   858f <lodepng_chunk_generate_crc>
   112c3:	83 c4 04             	add    $0x4,%esp
  return 0;
   112c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
   112cb:	c9                   	leave  
   112cc:	c3                   	ret    

000112cd <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   112cd:	55                   	push   %ebp
   112ce:	89 e5                	mov    %esp,%ebp
   112d0:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   112d3:	68 cb a1 01 00       	push   $0x1a1cb
   112d8:	6a 09                	push   $0x9
   112da:	ff 75 08             	pushl  0x8(%ebp)
   112dd:	8d 45 f8             	lea    -0x8(%ebp),%eax
   112e0:	50                   	push   %eax
   112e1:	e8 00 76 ff ff       	call   88e6 <lodepng_chunk_init>
   112e6:	83 c4 10             	add    $0x10,%esp
   112e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
   112ec:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   112f0:	74 05                	je     112f7 <addChunk_pHYs+0x2a>
   112f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   112f5:	eb 51                	jmp    11348 <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   112f7:	8b 45 0c             	mov    0xc(%ebp),%eax
   112fa:	8b 40 7c             	mov    0x7c(%eax),%eax
   112fd:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11300:	83 c2 08             	add    $0x8,%edx
   11303:	50                   	push   %eax
   11304:	52                   	push   %edx
   11305:	e8 25 25 ff ff       	call   382f <lodepng_set32bitInt>
   1130a:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   1130d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11310:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   11316:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11319:	83 c2 0c             	add    $0xc,%edx
   1131c:	50                   	push   %eax
   1131d:	52                   	push   %edx
   1131e:	e8 0c 25 ff ff       	call   382f <lodepng_set32bitInt>
   11323:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   11326:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11329:	8d 50 10             	lea    0x10(%eax),%edx
   1132c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1132f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   11335:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   11337:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1133a:	50                   	push   %eax
   1133b:	e8 4f 72 ff ff       	call   858f <lodepng_chunk_generate_crc>
   11340:	83 c4 04             	add    $0x4,%esp
  return 0;
   11343:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11348:	c9                   	leave  
   11349:	c3                   	ret    

0001134a <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   1134a:	55                   	push   %ebp
   1134b:	89 e5                	mov    %esp,%ebp
   1134d:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   11350:	68 d0 a1 01 00       	push   $0x1a1d0
   11355:	6a 04                	push   $0x4
   11357:	ff 75 08             	pushl  0x8(%ebp)
   1135a:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1135d:	50                   	push   %eax
   1135e:	e8 83 75 ff ff       	call   88e6 <lodepng_chunk_init>
   11363:	83 c4 10             	add    $0x10,%esp
   11366:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11369:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1136d:	74 05                	je     11374 <addChunk_gAMA+0x2a>
   1136f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11372:	eb 2a                	jmp    1139e <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   11374:	8b 45 0c             	mov    0xc(%ebp),%eax
   11377:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   1137d:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11380:	83 c2 08             	add    $0x8,%edx
   11383:	50                   	push   %eax
   11384:	52                   	push   %edx
   11385:	e8 a5 24 ff ff       	call   382f <lodepng_set32bitInt>
   1138a:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   1138d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11390:	50                   	push   %eax
   11391:	e8 f9 71 ff ff       	call   858f <lodepng_chunk_generate_crc>
   11396:	83 c4 04             	add    $0x4,%esp
  return 0;
   11399:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1139e:	c9                   	leave  
   1139f:	c3                   	ret    

000113a0 <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   113a0:	55                   	push   %ebp
   113a1:	89 e5                	mov    %esp,%ebp
   113a3:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   113a6:	68 d5 a1 01 00       	push   $0x1a1d5
   113ab:	6a 20                	push   $0x20
   113ad:	ff 75 08             	pushl  0x8(%ebp)
   113b0:	8d 45 f8             	lea    -0x8(%ebp),%eax
   113b3:	50                   	push   %eax
   113b4:	e8 2d 75 ff ff       	call   88e6 <lodepng_chunk_init>
   113b9:	83 c4 10             	add    $0x10,%esp
   113bc:	89 45 fc             	mov    %eax,-0x4(%ebp)
   113bf:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   113c3:	74 08                	je     113cd <addChunk_cHRM+0x2d>
   113c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   113c8:	e9 d9 00 00 00       	jmp    114a6 <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   113cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   113d0:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   113d6:	8b 55 f8             	mov    -0x8(%ebp),%edx
   113d9:	83 c2 08             	add    $0x8,%edx
   113dc:	50                   	push   %eax
   113dd:	52                   	push   %edx
   113de:	e8 4c 24 ff ff       	call   382f <lodepng_set32bitInt>
   113e3:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   113e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   113e9:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   113ef:	8b 55 f8             	mov    -0x8(%ebp),%edx
   113f2:	83 c2 0c             	add    $0xc,%edx
   113f5:	50                   	push   %eax
   113f6:	52                   	push   %edx
   113f7:	e8 33 24 ff ff       	call   382f <lodepng_set32bitInt>
   113fc:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   113ff:	8b 45 0c             	mov    0xc(%ebp),%eax
   11402:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   11408:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1140b:	83 c2 10             	add    $0x10,%edx
   1140e:	50                   	push   %eax
   1140f:	52                   	push   %edx
   11410:	e8 1a 24 ff ff       	call   382f <lodepng_set32bitInt>
   11415:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   11418:	8b 45 0c             	mov    0xc(%ebp),%eax
   1141b:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   11421:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11424:	83 c2 14             	add    $0x14,%edx
   11427:	50                   	push   %eax
   11428:	52                   	push   %edx
   11429:	e8 01 24 ff ff       	call   382f <lodepng_set32bitInt>
   1142e:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   11431:	8b 45 0c             	mov    0xc(%ebp),%eax
   11434:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   1143a:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1143d:	83 c2 18             	add    $0x18,%edx
   11440:	50                   	push   %eax
   11441:	52                   	push   %edx
   11442:	e8 e8 23 ff ff       	call   382f <lodepng_set32bitInt>
   11447:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   1144a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1144d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   11453:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11456:	83 c2 1c             	add    $0x1c,%edx
   11459:	50                   	push   %eax
   1145a:	52                   	push   %edx
   1145b:	e8 cf 23 ff ff       	call   382f <lodepng_set32bitInt>
   11460:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   11463:	8b 45 0c             	mov    0xc(%ebp),%eax
   11466:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   1146c:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1146f:	83 c2 20             	add    $0x20,%edx
   11472:	50                   	push   %eax
   11473:	52                   	push   %edx
   11474:	e8 b6 23 ff ff       	call   382f <lodepng_set32bitInt>
   11479:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   1147c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1147f:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   11485:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11488:	83 c2 24             	add    $0x24,%edx
   1148b:	50                   	push   %eax
   1148c:	52                   	push   %edx
   1148d:	e8 9d 23 ff ff       	call   382f <lodepng_set32bitInt>
   11492:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   11495:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11498:	50                   	push   %eax
   11499:	e8 f1 70 ff ff       	call   858f <lodepng_chunk_generate_crc>
   1149e:	83 c4 04             	add    $0x4,%esp
  return 0;
   114a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
   114a6:	c9                   	leave  
   114a7:	c3                   	ret    

000114a8 <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   114a8:	55                   	push   %ebp
   114a9:	89 e5                	mov    %esp,%ebp
   114ab:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   114ae:	8b 45 0c             	mov    0xc(%ebp),%eax
   114b1:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   114b7:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   114ba:	8d 45 ff             	lea    -0x1(%ebp),%eax
   114bd:	50                   	push   %eax
   114be:	68 da a1 01 00       	push   $0x1a1da
   114c3:	6a 01                	push   $0x1
   114c5:	ff 75 08             	pushl  0x8(%ebp)
   114c8:	e8 c1 74 ff ff       	call   898e <lodepng_chunk_createv>
   114cd:	83 c4 10             	add    $0x10,%esp
}
   114d0:	c9                   	leave  
   114d1:	c3                   	ret    

000114d2 <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   114d2:	55                   	push   %ebp
   114d3:	89 e5                	mov    %esp,%ebp
   114d5:	53                   	push   %ebx
   114d6:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   114d9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   114e0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   114e7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   114ee:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   114f5:	8b 45 0c             	mov    0xc(%ebp),%eax
   114f8:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   114fe:	50                   	push   %eax
   114ff:	e8 06 20 ff ff       	call   350a <lodepng_strlen>
   11504:	83 c4 04             	add    $0x4,%esp
   11507:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   1150a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1150e:	7e 06                	jle    11516 <addChunk_iCCP+0x44>
   11510:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   11514:	7e 0a                	jle    11520 <addChunk_iCCP+0x4e>
   11516:	b8 59 00 00 00       	mov    $0x59,%eax
   1151b:	e9 df 00 00 00       	jmp    115ff <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   11520:	8b 45 0c             	mov    0xc(%ebp),%eax
   11523:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   11529:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   1152b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1152e:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   11534:	83 ec 0c             	sub    $0xc,%esp
   11537:	ff 75 10             	pushl  0x10(%ebp)
   1153a:	52                   	push   %edx
   1153b:	50                   	push   %eax
   1153c:	8d 45 e0             	lea    -0x20(%ebp),%eax
   1153f:	50                   	push   %eax
   11540:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   11543:	50                   	push   %eax
   11544:	e8 35 6c ff ff       	call   817e <zlib_compress>
   11549:	83 c4 20             	add    $0x20,%esp
   1154c:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   1154f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11553:	75 29                	jne    1157e <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   11555:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11558:	8d 50 02             	lea    0x2(%eax),%edx
   1155b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1155e:	01 d0                	add    %edx,%eax
   11560:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   11563:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11566:	68 df a1 01 00       	push   $0x1a1df
   1156b:	50                   	push   %eax
   1156c:	ff 75 08             	pushl  0x8(%ebp)
   1156f:	8d 45 e8             	lea    -0x18(%ebp),%eax
   11572:	50                   	push   %eax
   11573:	e8 6e 73 ff ff       	call   88e6 <lodepng_chunk_init>
   11578:	83 c4 10             	add    $0x10,%esp
   1157b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   1157e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11582:	75 69                	jne    115ed <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   11584:	8b 45 0c             	mov    0xc(%ebp),%eax
   11587:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   1158d:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11590:	83 c2 08             	add    $0x8,%edx
   11593:	83 ec 04             	sub    $0x4,%esp
   11596:	ff 75 f0             	pushl  -0x10(%ebp)
   11599:	50                   	push   %eax
   1159a:	52                   	push   %edx
   1159b:	e8 0c 1f ff ff       	call   34ac <lodepng_memcpy>
   115a0:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   115a3:	8b 45 e8             	mov    -0x18(%ebp),%eax
   115a6:	8b 55 f0             	mov    -0x10(%ebp),%edx
   115a9:	83 c2 08             	add    $0x8,%edx
   115ac:	01 d0                	add    %edx,%eax
   115ae:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   115b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   115b4:	8b 55 f0             	mov    -0x10(%ebp),%edx
   115b7:	83 c2 09             	add    $0x9,%edx
   115ba:	01 d0                	add    %edx,%eax
   115bc:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   115bf:	8b 55 e0             	mov    -0x20(%ebp),%edx
   115c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   115c5:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   115c8:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   115cb:	83 c3 0a             	add    $0xa,%ebx
   115ce:	01 d9                	add    %ebx,%ecx
   115d0:	83 ec 04             	sub    $0x4,%esp
   115d3:	52                   	push   %edx
   115d4:	50                   	push   %eax
   115d5:	51                   	push   %ecx
   115d6:	e8 d1 1e ff ff       	call   34ac <lodepng_memcpy>
   115db:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   115de:	8b 45 e8             	mov    -0x18(%ebp),%eax
   115e1:	83 ec 0c             	sub    $0xc,%esp
   115e4:	50                   	push   %eax
   115e5:	e8 a5 6f ff ff       	call   858f <lodepng_chunk_generate_crc>
   115ea:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   115ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   115f0:	83 ec 0c             	sub    $0xc,%esp
   115f3:	50                   	push   %eax
   115f4:	e8 96 1e ff ff       	call   348f <lodepng_free>
   115f9:	83 c4 10             	add    $0x10,%esp
  return error;
   115fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   115ff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11602:	c9                   	leave  
   11603:	c3                   	ret    

00011604 <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   11604:	55                   	push   %ebp
   11605:	89 e5                	mov    %esp,%ebp
   11607:	56                   	push   %esi
   11608:	53                   	push   %ebx
   11609:	83 ec 14             	sub    $0x14,%esp
   1160c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1160f:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   11612:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   11616:	83 f8 04             	cmp    $0x4,%eax
   11619:	0f 87 41 03 00 00    	ja     11960 <filterScanline+0x35c>
   1161f:	8b 04 85 f0 a1 01 00 	mov    0x1a1f0(,%eax,4),%eax
   11626:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   11628:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1162f:	eb 19                	jmp    1164a <filterScanline+0x46>
   11631:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11634:	8b 45 08             	mov    0x8(%ebp),%eax
   11637:	01 c2                	add    %eax,%edx
   11639:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1163c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1163f:	01 c8                	add    %ecx,%eax
   11641:	0f b6 00             	movzbl (%eax),%eax
   11644:	88 02                	mov    %al,(%edx)
   11646:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1164a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1164d:	3b 45 14             	cmp    0x14(%ebp),%eax
   11650:	75 df                	jne    11631 <filterScanline+0x2d>
      break;
   11652:	e9 0a 03 00 00       	jmp    11961 <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11657:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1165e:	eb 19                	jmp    11679 <filterScanline+0x75>
   11660:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11663:	8b 45 08             	mov    0x8(%ebp),%eax
   11666:	01 c2                	add    %eax,%edx
   11668:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1166b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1166e:	01 c8                	add    %ecx,%eax
   11670:	0f b6 00             	movzbl (%eax),%eax
   11673:	88 02                	mov    %al,(%edx)
   11675:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11679:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1167c:	3b 45 18             	cmp    0x18(%ebp),%eax
   1167f:	75 df                	jne    11660 <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   11681:	8b 45 18             	mov    0x18(%ebp),%eax
   11684:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11687:	eb 2d                	jmp    116b6 <filterScanline+0xb2>
   11689:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1168c:	8b 45 08             	mov    0x8(%ebp),%eax
   1168f:	01 c2                	add    %eax,%edx
   11691:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11694:	8b 45 0c             	mov    0xc(%ebp),%eax
   11697:	01 c8                	add    %ecx,%eax
   11699:	0f b6 08             	movzbl (%eax),%ecx
   1169c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1169f:	2b 45 18             	sub    0x18(%ebp),%eax
   116a2:	89 c3                	mov    %eax,%ebx
   116a4:	8b 45 0c             	mov    0xc(%ebp),%eax
   116a7:	01 d8                	add    %ebx,%eax
   116a9:	0f b6 00             	movzbl (%eax),%eax
   116ac:	29 c1                	sub    %eax,%ecx
   116ae:	89 c8                	mov    %ecx,%eax
   116b0:	88 02                	mov    %al,(%edx)
   116b2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   116b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116b9:	3b 45 14             	cmp    0x14(%ebp),%eax
   116bc:	7c cb                	jl     11689 <filterScanline+0x85>
      break;
   116be:	e9 9e 02 00 00       	jmp    11961 <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   116c3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   116c7:	74 3e                	je     11707 <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   116c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   116d0:	eb 28                	jmp    116fa <filterScanline+0xf6>
   116d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   116d5:	8b 45 08             	mov    0x8(%ebp),%eax
   116d8:	01 d0                	add    %edx,%eax
   116da:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   116dd:	8b 55 0c             	mov    0xc(%ebp),%edx
   116e0:	01 ca                	add    %ecx,%edx
   116e2:	0f b6 0a             	movzbl (%edx),%ecx
   116e5:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   116e8:	8b 55 10             	mov    0x10(%ebp),%edx
   116eb:	01 da                	add    %ebx,%edx
   116ed:	0f b6 12             	movzbl (%edx),%edx
   116f0:	29 d1                	sub    %edx,%ecx
   116f2:	89 ca                	mov    %ecx,%edx
   116f4:	88 10                	mov    %dl,(%eax)
   116f6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   116fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   116fd:	3b 45 14             	cmp    0x14(%ebp),%eax
   11700:	75 d0                	jne    116d2 <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   11702:	e9 5a 02 00 00       	jmp    11961 <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   11707:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1170e:	eb 19                	jmp    11729 <filterScanline+0x125>
   11710:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11713:	8b 45 08             	mov    0x8(%ebp),%eax
   11716:	01 c2                	add    %eax,%edx
   11718:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1171b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1171e:	01 c8                	add    %ecx,%eax
   11720:	0f b6 00             	movzbl (%eax),%eax
   11723:	88 02                	mov    %al,(%edx)
   11725:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11729:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1172c:	3b 45 14             	cmp    0x14(%ebp),%eax
   1172f:	75 df                	jne    11710 <filterScanline+0x10c>
      }
      break;
   11731:	e9 2b 02 00 00       	jmp    11961 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   11736:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1173a:	0f 84 90 00 00 00    	je     117d0 <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   11740:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11747:	eb 28                	jmp    11771 <filterScanline+0x16d>
   11749:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1174c:	8b 45 08             	mov    0x8(%ebp),%eax
   1174f:	01 d0                	add    %edx,%eax
   11751:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11754:	8b 55 0c             	mov    0xc(%ebp),%edx
   11757:	01 ca                	add    %ecx,%edx
   11759:	0f b6 12             	movzbl (%edx),%edx
   1175c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   1175f:	8b 4d 10             	mov    0x10(%ebp),%ecx
   11762:	01 d9                	add    %ebx,%ecx
   11764:	0f b6 09             	movzbl (%ecx),%ecx
   11767:	d0 e9                	shr    %cl
   11769:	29 ca                	sub    %ecx,%edx
   1176b:	88 10                	mov    %dl,(%eax)
   1176d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11771:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11774:	3b 45 18             	cmp    0x18(%ebp),%eax
   11777:	75 d0                	jne    11749 <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   11779:	8b 45 18             	mov    0x18(%ebp),%eax
   1177c:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1177f:	eb 42                	jmp    117c3 <filterScanline+0x1bf>
   11781:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11784:	8b 45 08             	mov    0x8(%ebp),%eax
   11787:	01 c2                	add    %eax,%edx
   11789:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1178c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1178f:	01 c8                	add    %ecx,%eax
   11791:	0f b6 08             	movzbl (%eax),%ecx
   11794:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11797:	2b 45 18             	sub    0x18(%ebp),%eax
   1179a:	89 c3                	mov    %eax,%ebx
   1179c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1179f:	01 d8                	add    %ebx,%eax
   117a1:	0f b6 00             	movzbl (%eax),%eax
   117a4:	0f b6 d8             	movzbl %al,%ebx
   117a7:	8b 75 f4             	mov    -0xc(%ebp),%esi
   117aa:	8b 45 10             	mov    0x10(%ebp),%eax
   117ad:	01 f0                	add    %esi,%eax
   117af:	0f b6 00             	movzbl (%eax),%eax
   117b2:	0f b6 c0             	movzbl %al,%eax
   117b5:	01 d8                	add    %ebx,%eax
   117b7:	d1 f8                	sar    %eax
   117b9:	29 c1                	sub    %eax,%ecx
   117bb:	89 c8                	mov    %ecx,%eax
   117bd:	88 02                	mov    %al,(%edx)
   117bf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117c6:	3b 45 14             	cmp    0x14(%ebp),%eax
   117c9:	7c b6                	jl     11781 <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   117cb:	e9 91 01 00 00       	jmp    11961 <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   117d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   117d7:	eb 19                	jmp    117f2 <filterScanline+0x1ee>
   117d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117dc:	8b 45 08             	mov    0x8(%ebp),%eax
   117df:	01 c2                	add    %eax,%edx
   117e1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117e4:	8b 45 0c             	mov    0xc(%ebp),%eax
   117e7:	01 c8                	add    %ecx,%eax
   117e9:	0f b6 00             	movzbl (%eax),%eax
   117ec:	88 02                	mov    %al,(%edx)
   117ee:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117f5:	3b 45 18             	cmp    0x18(%ebp),%eax
   117f8:	75 df                	jne    117d9 <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   117fa:	8b 45 18             	mov    0x18(%ebp),%eax
   117fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11800:	eb 2f                	jmp    11831 <filterScanline+0x22d>
   11802:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11805:	8b 45 08             	mov    0x8(%ebp),%eax
   11808:	01 c2                	add    %eax,%edx
   1180a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1180d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11810:	01 c8                	add    %ecx,%eax
   11812:	0f b6 08             	movzbl (%eax),%ecx
   11815:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11818:	2b 45 18             	sub    0x18(%ebp),%eax
   1181b:	89 c3                	mov    %eax,%ebx
   1181d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11820:	01 d8                	add    %ebx,%eax
   11822:	0f b6 00             	movzbl (%eax),%eax
   11825:	d0 e8                	shr    %al
   11827:	29 c1                	sub    %eax,%ecx
   11829:	89 c8                	mov    %ecx,%eax
   1182b:	88 02                	mov    %al,(%edx)
   1182d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11831:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11834:	3b 45 14             	cmp    0x14(%ebp),%eax
   11837:	7c c9                	jl     11802 <filterScanline+0x1fe>
      }
      break;
   11839:	e9 23 01 00 00       	jmp    11961 <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   1183e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11842:	0f 84 af 00 00 00    	je     118f7 <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   11848:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1184f:	eb 28                	jmp    11879 <filterScanline+0x275>
   11851:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11854:	8b 45 08             	mov    0x8(%ebp),%eax
   11857:	01 d0                	add    %edx,%eax
   11859:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1185c:	8b 55 0c             	mov    0xc(%ebp),%edx
   1185f:	01 ca                	add    %ecx,%edx
   11861:	0f b6 0a             	movzbl (%edx),%ecx
   11864:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11867:	8b 55 10             	mov    0x10(%ebp),%edx
   1186a:	01 da                	add    %ebx,%edx
   1186c:	0f b6 12             	movzbl (%edx),%edx
   1186f:	29 d1                	sub    %edx,%ecx
   11871:	89 ca                	mov    %ecx,%edx
   11873:	88 10                	mov    %dl,(%eax)
   11875:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11879:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1187c:	3b 45 18             	cmp    0x18(%ebp),%eax
   1187f:	75 d0                	jne    11851 <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   11881:	8b 45 18             	mov    0x18(%ebp),%eax
   11884:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11887:	eb 64                	jmp    118ed <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   11889:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1188c:	8b 45 08             	mov    0x8(%ebp),%eax
   1188f:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   11892:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11895:	8b 45 0c             	mov    0xc(%ebp),%eax
   11898:	01 d0                	add    %edx,%eax
   1189a:	0f b6 00             	movzbl (%eax),%eax
   1189d:	88 45 e7             	mov    %al,-0x19(%ebp)
   118a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118a3:	2b 45 18             	sub    0x18(%ebp),%eax
   118a6:	89 c2                	mov    %eax,%edx
   118a8:	8b 45 10             	mov    0x10(%ebp),%eax
   118ab:	01 d0                	add    %edx,%eax
   118ad:	0f b6 00             	movzbl (%eax),%eax
   118b0:	0f b6 c8             	movzbl %al,%ecx
   118b3:	8b 55 f4             	mov    -0xc(%ebp),%edx
   118b6:	8b 45 10             	mov    0x10(%ebp),%eax
   118b9:	01 d0                	add    %edx,%eax
   118bb:	0f b6 00             	movzbl (%eax),%eax
   118be:	0f b6 d0             	movzbl %al,%edx
   118c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118c4:	2b 45 18             	sub    0x18(%ebp),%eax
   118c7:	89 c6                	mov    %eax,%esi
   118c9:	8b 45 0c             	mov    0xc(%ebp),%eax
   118cc:	01 f0                	add    %esi,%eax
   118ce:	0f b6 00             	movzbl (%eax),%eax
   118d1:	0f b6 c0             	movzbl %al,%eax
   118d4:	51                   	push   %ecx
   118d5:	52                   	push   %edx
   118d6:	50                   	push   %eax
   118d7:	e8 49 b8 ff ff       	call   d125 <paethPredictor>
   118dc:	83 c4 0c             	add    $0xc,%esp
   118df:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   118e3:	29 c1                	sub    %eax,%ecx
   118e5:	89 c8                	mov    %ecx,%eax
   118e7:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   118e9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   118ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118f0:	3b 45 14             	cmp    0x14(%ebp),%eax
   118f3:	7c 94                	jl     11889 <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   118f5:	eb 6a                	jmp    11961 <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   118f7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   118fe:	eb 19                	jmp    11919 <filterScanline+0x315>
   11900:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11903:	8b 45 08             	mov    0x8(%ebp),%eax
   11906:	01 c2                	add    %eax,%edx
   11908:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1190b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1190e:	01 c8                	add    %ecx,%eax
   11910:	0f b6 00             	movzbl (%eax),%eax
   11913:	88 02                	mov    %al,(%edx)
   11915:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11919:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1191c:	3b 45 18             	cmp    0x18(%ebp),%eax
   1191f:	75 df                	jne    11900 <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   11921:	8b 45 18             	mov    0x18(%ebp),%eax
   11924:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11927:	eb 2d                	jmp    11956 <filterScanline+0x352>
   11929:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1192c:	8b 45 08             	mov    0x8(%ebp),%eax
   1192f:	01 c2                	add    %eax,%edx
   11931:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11934:	8b 45 0c             	mov    0xc(%ebp),%eax
   11937:	01 c8                	add    %ecx,%eax
   11939:	0f b6 08             	movzbl (%eax),%ecx
   1193c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1193f:	2b 45 18             	sub    0x18(%ebp),%eax
   11942:	89 c3                	mov    %eax,%ebx
   11944:	8b 45 0c             	mov    0xc(%ebp),%eax
   11947:	01 d8                	add    %ebx,%eax
   11949:	0f b6 00             	movzbl (%eax),%eax
   1194c:	29 c1                	sub    %eax,%ecx
   1194e:	89 c8                	mov    %ecx,%eax
   11950:	88 02                	mov    %al,(%edx)
   11952:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11956:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11959:	3b 45 14             	cmp    0x14(%ebp),%eax
   1195c:	7c cb                	jl     11929 <filterScanline+0x325>
      }
      break;
   1195e:	eb 01                	jmp    11961 <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   11960:	90                   	nop
  }
}
   11961:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11964:	5b                   	pop    %ebx
   11965:	5e                   	pop    %esi
   11966:	5d                   	pop    %ebp
   11967:	c3                   	ret    

00011968 <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   11968:	55                   	push   %ebp
   11969:	89 e5                	mov    %esp,%ebp
   1196b:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   1196e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   11975:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   1197c:	7e 08                	jle    11986 <ilog2+0x1e>
   1197e:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   11982:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   11986:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   1198d:	7e 08                	jle    11997 <ilog2+0x2f>
   1198f:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   11993:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   11997:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   1199b:	7e 08                	jle    119a5 <ilog2+0x3d>
   1199d:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   119a1:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   119a5:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   119a9:	7e 08                	jle    119b3 <ilog2+0x4b>
   119ab:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   119af:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   119b3:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   119b7:	7e 04                	jle    119bd <ilog2+0x55>
   119b9:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   119bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   119c0:	c9                   	leave  
   119c1:	c3                   	ret    

000119c2 <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   119c2:	55                   	push   %ebp
   119c3:	89 e5                	mov    %esp,%ebp
   119c5:	56                   	push   %esi
   119c6:	53                   	push   %ebx
   119c7:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   119ca:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   119ce:	75 07                	jne    119d7 <ilog2i+0x15>
   119d0:	b8 00 00 00 00       	mov    $0x0,%eax
   119d5:	eb 30                	jmp    11a07 <ilog2i+0x45>
  l = ilog2(i);
   119d7:	ff 75 08             	pushl  0x8(%ebp)
   119da:	e8 89 ff ff ff       	call   11968 <ilog2>
   119df:	83 c4 04             	add    $0x4,%esp
   119e2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   119e5:	8b 45 08             	mov    0x8(%ebp),%eax
   119e8:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   119ec:	89 c3                	mov    %eax,%ebx
   119ee:	8b 55 08             	mov    0x8(%ebp),%edx
   119f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   119f4:	be 01 00 00 00       	mov    $0x1,%esi
   119f9:	89 c1                	mov    %eax,%ecx
   119fb:	d3 e6                	shl    %cl,%esi
   119fd:	89 f0                	mov    %esi,%eax
   119ff:	29 c2                	sub    %eax,%edx
   11a01:	89 d0                	mov    %edx,%eax
   11a03:	01 c0                	add    %eax,%eax
   11a05:	01 d8                	add    %ebx,%eax
}
   11a07:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11a0a:	5b                   	pop    %ebx
   11a0b:	5e                   	pop    %esi
   11a0c:	5d                   	pop    %ebp
   11a0d:	c3                   	ret    

00011a0e <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   11a0e:	55                   	push   %ebp
   11a0f:	89 e5                	mov    %esp,%ebp
   11a11:	53                   	push   %ebx
   11a12:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   11a18:	ff 75 18             	pushl  0x18(%ebp)
   11a1b:	e8 6a 75 ff ff       	call   8f8a <lodepng_get_bpp>
   11a20:	83 c4 04             	add    $0x4,%esp
   11a23:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   11a26:	ff 75 b8             	pushl  -0x48(%ebp)
   11a29:	6a 01                	push   $0x1
   11a2b:	ff 75 10             	pushl  0x10(%ebp)
   11a2e:	e8 b6 76 ff ff       	call   90e9 <lodepng_get_raw_size_idat>
   11a33:	83 c4 0c             	add    $0xc,%esp
   11a36:	83 e8 01             	sub    $0x1,%eax
   11a39:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   11a3c:	8b 45 b8             	mov    -0x48(%ebp),%eax
   11a3f:	83 c0 07             	add    $0x7,%eax
   11a42:	c1 e8 03             	shr    $0x3,%eax
   11a45:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   11a48:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   11a4f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   11a56:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11a59:	8b 40 2c             	mov    0x2c(%eax),%eax
   11a5c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11a5f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11a62:	8b 40 28             	mov    0x28(%eax),%eax
   11a65:	85 c0                	test   %eax,%eax
   11a67:	74 1c                	je     11a85 <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11a69:	8b 45 18             	mov    0x18(%ebp),%eax
   11a6c:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11a6e:	83 f8 03             	cmp    $0x3,%eax
   11a71:	74 0b                	je     11a7e <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11a73:	8b 45 18             	mov    0x18(%ebp),%eax
   11a76:	8b 40 04             	mov    0x4(%eax),%eax
   11a79:	83 f8 07             	cmp    $0x7,%eax
   11a7c:	77 07                	ja     11a85 <filter+0x77>
   11a7e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   11a85:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   11a89:	75 0a                	jne    11a95 <filter+0x87>
   11a8b:	b8 1f 00 00 00       	mov    $0x1f,%eax
   11a90:	e9 5b 07 00 00       	jmp    121f0 <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   11a95:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   11a99:	77 7b                	ja     11b16 <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   11a9b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11a9e:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   11aa1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11aa8:	eb 5f                	jmp    11b09 <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11aaa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11aad:	83 c0 01             	add    $0x1,%eax
   11ab0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ab4:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   11ab7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11aba:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11abe:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   11ac1:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11ac4:	8b 45 08             	mov    0x8(%ebp),%eax
   11ac7:	01 c2                	add    %eax,%edx
   11ac9:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11acd:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11acf:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11ad3:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   11ad6:	8b 55 0c             	mov    0xc(%ebp),%edx
   11ad9:	01 d1                	add    %edx,%ecx
   11adb:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11ade:	8d 5a 01             	lea    0x1(%edx),%ebx
   11ae1:	8b 55 08             	mov    0x8(%ebp),%edx
   11ae4:	01 da                	add    %ebx,%edx
   11ae6:	50                   	push   %eax
   11ae7:	ff 75 b0             	pushl  -0x50(%ebp)
   11aea:	ff 75 b4             	pushl  -0x4c(%ebp)
   11aed:	ff 75 f4             	pushl  -0xc(%ebp)
   11af0:	51                   	push   %ecx
   11af1:	52                   	push   %edx
   11af2:	e8 0d fb ff ff       	call   11604 <filterScanline>
   11af7:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   11afa:	8b 55 98             	mov    -0x68(%ebp),%edx
   11afd:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b00:	01 d0                	add    %edx,%eax
   11b02:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   11b05:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11b09:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11b0c:	3b 45 14             	cmp    0x14(%ebp),%eax
   11b0f:	75 99                	jne    11aaa <filter+0x9c>
   11b11:	e9 d7 06 00 00       	jmp    121ed <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   11b16:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   11b1a:	0f 85 e3 01 00 00    	jne    11d03 <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11b20:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   11b27:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   11b2b:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11b2f:	eb 2d                	jmp    11b5e <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11b31:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   11b35:	83 ec 0c             	sub    $0xc,%esp
   11b38:	ff 75 b4             	pushl  -0x4c(%ebp)
   11b3b:	e8 2e 19 ff ff       	call   346e <lodepng_malloc>
   11b40:	83 c4 10             	add    $0x10,%esp
   11b43:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11b47:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11b4b:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11b4f:	85 c0                	test   %eax,%eax
   11b51:	75 07                	jne    11b5a <filter+0x14c>
   11b53:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   11b5a:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11b5e:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11b62:	75 cd                	jne    11b31 <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11b64:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11b68:	0f 85 6c 01 00 00    	jne    11cda <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   11b6e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11b75:	e9 54 01 00 00       	jmp    11cce <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11b7a:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11b7e:	e9 d5 00 00 00       	jmp    11c58 <filter+0x24a>
          size_t sum = 0;
   11b83:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11b8a:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   11b8e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11b91:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11b95:	89 c1                	mov    %eax,%ecx
   11b97:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b9a:	01 c1                	add    %eax,%ecx
   11b9c:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11ba0:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11ba4:	83 ec 08             	sub    $0x8,%esp
   11ba7:	52                   	push   %edx
   11ba8:	ff 75 b0             	pushl  -0x50(%ebp)
   11bab:	ff 75 b4             	pushl  -0x4c(%ebp)
   11bae:	ff 75 f4             	pushl  -0xc(%ebp)
   11bb1:	51                   	push   %ecx
   11bb2:	50                   	push   %eax
   11bb3:	e8 4c fa ff ff       	call   11604 <filterScanline>
   11bb8:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   11bbb:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11bbf:	75 2d                	jne    11bee <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   11bc1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11bc8:	eb 1a                	jmp    11be4 <filter+0x1d6>
   11bca:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11bce:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11bd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11bd5:	01 d0                	add    %edx,%eax
   11bd7:	0f b6 00             	movzbl (%eax),%eax
   11bda:	0f b6 c0             	movzbl %al,%eax
   11bdd:	01 45 d8             	add    %eax,-0x28(%ebp)
   11be0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11be4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11be7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11bea:	75 de                	jne    11bca <filter+0x1bc>
   11bec:	eb 4b                	jmp    11c39 <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   11bee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11bf5:	eb 3a                	jmp    11c31 <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   11bf7:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11bfb:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11bff:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11c02:	01 d0                	add    %edx,%eax
   11c04:	0f b6 00             	movzbl (%eax),%eax
   11c07:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   11c0a:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11c0e:	84 c0                	test   %al,%al
   11c10:	78 06                	js     11c18 <filter+0x20a>
   11c12:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11c16:	eb 0d                	jmp    11c25 <filter+0x217>
   11c18:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11c1c:	ba ff 00 00 00       	mov    $0xff,%edx
   11c21:	29 c2                	sub    %eax,%edx
   11c23:	89 d0                	mov    %edx,%eax
   11c25:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11c28:	01 d0                	add    %edx,%eax
   11c2a:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   11c2d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11c31:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c34:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11c37:	75 be                	jne    11bf7 <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   11c39:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11c3d:	74 08                	je     11c47 <filter+0x239>
   11c3f:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11c42:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   11c45:	7d 0d                	jge    11c54 <filter+0x246>
            bestType = type;
   11c47:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11c4b:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   11c4e:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11c51:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11c54:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11c58:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11c5c:	0f 85 21 ff ff ff    	jne    11b83 <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   11c62:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c65:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c69:	89 c2                	mov    %eax,%edx
   11c6b:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c6e:	01 d0                	add    %edx,%eax
   11c70:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11c73:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c76:	83 c0 01             	add    $0x1,%eax
   11c79:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c7d:	89 c2                	mov    %eax,%edx
   11c7f:	8b 45 08             	mov    0x8(%ebp),%eax
   11c82:	01 c2                	add    %eax,%edx
   11c84:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11c88:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11c8a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11c91:	eb 2f                	jmp    11cc2 <filter+0x2b4>
   11c93:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c96:	83 c0 01             	add    $0x1,%eax
   11c99:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c9d:	89 c2                	mov    %eax,%edx
   11c9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ca2:	01 d0                	add    %edx,%eax
   11ca4:	8d 50 01             	lea    0x1(%eax),%edx
   11ca7:	8b 45 08             	mov    0x8(%ebp),%eax
   11caa:	01 c2                	add    %eax,%edx
   11cac:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11cb0:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   11cb4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11cb7:	01 c8                	add    %ecx,%eax
   11cb9:	0f b6 00             	movzbl (%eax),%eax
   11cbc:	88 02                	mov    %al,(%edx)
   11cbe:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11cc2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11cc5:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11cc8:	75 c9                	jne    11c93 <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11cca:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11cce:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11cd1:	3b 45 14             	cmp    0x14(%ebp),%eax
   11cd4:	0f 85 a0 fe ff ff    	jne    11b7a <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11cda:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11cde:	eb 18                	jmp    11cf8 <filter+0x2ea>
   11ce0:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11ce4:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11ce8:	83 ec 0c             	sub    $0xc,%esp
   11ceb:	50                   	push   %eax
   11cec:	e8 9e 17 ff ff       	call   348f <lodepng_free>
   11cf1:	83 c4 10             	add    $0x10,%esp
   11cf4:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11cf8:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11cfc:	75 e2                	jne    11ce0 <filter+0x2d2>
   11cfe:	e9 ea 04 00 00       	jmp    121ed <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   11d03:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   11d07:	0f 85 17 02 00 00    	jne    11f24 <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   11d0d:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   11d14:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11d1b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11d22:	eb 33                	jmp    11d57 <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11d24:	83 ec 0c             	sub    $0xc,%esp
   11d27:	ff 75 b4             	pushl  -0x4c(%ebp)
   11d2a:	e8 3f 17 ff ff       	call   346e <lodepng_malloc>
   11d2f:	83 c4 10             	add    $0x10,%esp
   11d32:	89 c2                	mov    %eax,%edx
   11d34:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d37:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11d3e:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d41:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11d48:	85 c0                	test   %eax,%eax
   11d4a:	75 07                	jne    11d53 <filter+0x345>
   11d4c:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11d53:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11d57:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11d5b:	75 c7                	jne    11d24 <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11d5d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11d61:	0f 85 8f 01 00 00    	jne    11ef6 <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   11d67:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11d6e:	e9 77 01 00 00       	jmp    11eea <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11d73:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11d7a:	e9 f4 00 00 00       	jmp    11e73 <filter+0x465>
          size_t sum = 0;
   11d7f:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11d86:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d89:	0f b6 d0             	movzbl %al,%edx
   11d8c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d8f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d93:	89 c1                	mov    %eax,%ecx
   11d95:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d98:	01 c1                	add    %eax,%ecx
   11d9a:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11d9d:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11da4:	83 ec 08             	sub    $0x8,%esp
   11da7:	52                   	push   %edx
   11da8:	ff 75 b0             	pushl  -0x50(%ebp)
   11dab:	ff 75 b4             	pushl  -0x4c(%ebp)
   11dae:	ff 75 f4             	pushl  -0xc(%ebp)
   11db1:	51                   	push   %ecx
   11db2:	50                   	push   %eax
   11db3:	e8 4c f8 ff ff       	call   11604 <filterScanline>
   11db8:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   11dbb:	83 ec 04             	sub    $0x4,%esp
   11dbe:	68 00 04 00 00       	push   $0x400
   11dc3:	6a 00                	push   $0x0
   11dc5:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11dcb:	50                   	push   %eax
   11dcc:	e8 0e 17 ff ff       	call   34df <lodepng_memset>
   11dd1:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   11dd4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11ddb:	eb 2a                	jmp    11e07 <filter+0x3f9>
   11ddd:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11de0:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   11de7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11dea:	01 d0                	add    %edx,%eax
   11dec:	0f b6 00             	movzbl (%eax),%eax
   11def:	0f b6 c0             	movzbl %al,%eax
   11df2:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   11df9:	83 c2 01             	add    $0x1,%edx
   11dfc:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   11e03:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11e07:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e0a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11e0d:	75 ce                	jne    11ddd <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   11e0f:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11e12:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11e19:	8d 50 01             	lea    0x1(%eax),%edx
   11e1c:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11e1f:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   11e26:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11e2d:	eb 1d                	jmp    11e4c <filter+0x43e>
            sum += ilog2i(count[x]);
   11e2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e32:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11e39:	83 ec 0c             	sub    $0xc,%esp
   11e3c:	50                   	push   %eax
   11e3d:	e8 80 fb ff ff       	call   119c2 <ilog2i>
   11e42:	83 c4 10             	add    $0x10,%esp
   11e45:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   11e48:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11e4c:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   11e53:	75 da                	jne    11e2f <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   11e55:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   11e59:	74 08                	je     11e63 <filter+0x455>
   11e5b:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11e5e:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   11e61:	7e 0c                	jle    11e6f <filter+0x461>
            bestType = type;
   11e63:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11e66:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   11e69:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11e6c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11e6f:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11e73:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11e77:	0f 85 02 ff ff ff    	jne    11d7f <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   11e7d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e80:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e84:	89 c2                	mov    %eax,%edx
   11e86:	8b 45 0c             	mov    0xc(%ebp),%eax
   11e89:	01 d0                	add    %edx,%eax
   11e8b:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11e8e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e91:	83 c0 01             	add    $0x1,%eax
   11e94:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e98:	89 c2                	mov    %eax,%edx
   11e9a:	8b 45 08             	mov    0x8(%ebp),%eax
   11e9d:	01 d0                	add    %edx,%eax
   11e9f:	8b 55 cc             	mov    -0x34(%ebp),%edx
   11ea2:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11ea4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11eab:	eb 31                	jmp    11ede <filter+0x4d0>
   11ead:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11eb0:	83 c0 01             	add    $0x1,%eax
   11eb3:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11eb7:	89 c2                	mov    %eax,%edx
   11eb9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ebc:	01 d0                	add    %edx,%eax
   11ebe:	8d 50 01             	lea    0x1(%eax),%edx
   11ec1:	8b 45 08             	mov    0x8(%ebp),%eax
   11ec4:	01 c2                	add    %eax,%edx
   11ec6:	8b 45 cc             	mov    -0x34(%ebp),%eax
   11ec9:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   11ed0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11ed3:	01 c8                	add    %ecx,%eax
   11ed5:	0f b6 00             	movzbl (%eax),%eax
   11ed8:	88 02                	mov    %al,(%edx)
   11eda:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11ede:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ee1:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11ee4:	75 c7                	jne    11ead <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11ee6:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11eea:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11eed:	3b 45 14             	cmp    0x14(%ebp),%eax
   11ef0:	0f 85 7d fe ff ff    	jne    11d73 <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11ef6:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11efd:	eb 1a                	jmp    11f19 <filter+0x50b>
   11eff:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11f02:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11f09:	83 ec 0c             	sub    $0xc,%esp
   11f0c:	50                   	push   %eax
   11f0d:	e8 7d 15 ff ff       	call   348f <lodepng_free>
   11f12:	83 c4 10             	add    $0x10,%esp
   11f15:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11f19:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11f1d:	75 e0                	jne    11eff <filter+0x4f1>
   11f1f:	e9 c9 02 00 00       	jmp    121ed <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   11f24:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   11f28:	0f 85 89 00 00 00    	jne    11fb7 <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   11f2e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11f35:	eb 73                	jmp    11faa <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11f37:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f3a:	83 c0 01             	add    $0x1,%eax
   11f3d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11f41:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   11f44:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f47:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11f4b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   11f4e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11f51:	8b 50 30             	mov    0x30(%eax),%edx
   11f54:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11f57:	01 d0                	add    %edx,%eax
   11f59:	0f b6 00             	movzbl (%eax),%eax
   11f5c:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   11f5f:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11f62:	8b 45 08             	mov    0x8(%ebp),%eax
   11f65:	01 c2                	add    %eax,%edx
   11f67:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11f6b:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11f6d:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   11f71:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   11f74:	8b 55 0c             	mov    0xc(%ebp),%edx
   11f77:	01 d1                	add    %edx,%ecx
   11f79:	8b 55 a8             	mov    -0x58(%ebp),%edx
   11f7c:	8d 5a 01             	lea    0x1(%edx),%ebx
   11f7f:	8b 55 08             	mov    0x8(%ebp),%edx
   11f82:	01 da                	add    %ebx,%edx
   11f84:	83 ec 08             	sub    $0x8,%esp
   11f87:	50                   	push   %eax
   11f88:	ff 75 b0             	pushl  -0x50(%ebp)
   11f8b:	ff 75 b4             	pushl  -0x4c(%ebp)
   11f8e:	ff 75 f4             	pushl  -0xc(%ebp)
   11f91:	51                   	push   %ecx
   11f92:	52                   	push   %edx
   11f93:	e8 6c f6 ff ff       	call   11604 <filterScanline>
   11f98:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   11f9b:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   11f9e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11fa1:	01 d0                	add    %edx,%eax
   11fa3:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   11fa6:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11faa:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11fad:	3b 45 14             	cmp    0x14(%ebp),%eax
   11fb0:	75 85                	jne    11f37 <filter+0x529>
   11fb2:	e9 36 02 00 00       	jmp    121ed <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   11fb7:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   11fbb:	0f 85 25 02 00 00    	jne    121e6 <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11fc1:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   11fc8:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   11fcf:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   11fd6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11fd9:	83 ec 04             	sub    $0x4,%esp
   11fdc:	6a 24                	push   $0x24
   11fde:	50                   	push   %eax
   11fdf:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11fe5:	50                   	push   %eax
   11fe6:	e8 c1 14 ff ff       	call   34ac <lodepng_memcpy>
   11feb:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   11fee:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   11ff5:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   11ff8:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   11fff:	00 00 00 
    zlibsettings.custom_deflate = 0;
   12002:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   12009:	00 00 00 
    for(type = 0; type != 5; ++type) {
   1200c:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12013:	eb 33                	jmp    12048 <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   12015:	83 ec 0c             	sub    $0xc,%esp
   12018:	ff 75 b4             	pushl  -0x4c(%ebp)
   1201b:	e8 4e 14 ff ff       	call   346e <lodepng_malloc>
   12020:	83 c4 10             	add    $0x10,%esp
   12023:	89 c2                	mov    %eax,%edx
   12025:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12028:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   1202f:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12032:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12039:	85 c0                	test   %eax,%eax
   1203b:	75 07                	jne    12044 <filter+0x636>
   1203d:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   12044:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12048:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   1204c:	75 c7                	jne    12015 <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   1204e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12052:	0f 85 63 01 00 00    	jne    121bb <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   12058:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1205f:	e9 4b 01 00 00       	jmp    121af <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   12064:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   1206b:	e9 c8 00 00 00       	jmp    12138 <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   12070:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12073:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   12076:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12079:	0f b6 d0             	movzbl %al,%edx
   1207c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1207f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12083:	89 c1                	mov    %eax,%ecx
   12085:	8b 45 0c             	mov    0xc(%ebp),%eax
   12088:	01 c1                	add    %eax,%ecx
   1208a:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1208d:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12094:	83 ec 08             	sub    $0x8,%esp
   12097:	52                   	push   %edx
   12098:	ff 75 b0             	pushl  -0x50(%ebp)
   1209b:	ff 75 b4             	pushl  -0x4c(%ebp)
   1209e:	ff 75 f4             	pushl  -0xc(%ebp)
   120a1:	51                   	push   %ecx
   120a2:	50                   	push   %eax
   120a3:	e8 5c f5 ff ff       	call   11604 <filterScanline>
   120a8:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   120ab:	8b 45 c0             	mov    -0x40(%ebp),%eax
   120ae:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   120b5:	00 00 00 00 
          dummy = 0;
   120b9:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   120c0:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   120c3:	8b 55 ac             	mov    -0x54(%ebp),%edx
   120c6:	8b 45 c0             	mov    -0x40(%ebp),%eax
   120c9:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   120d0:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   120d6:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   120d9:	c1 e3 02             	shl    $0x2,%ebx
   120dc:	01 cb                	add    %ecx,%ebx
   120de:	83 ec 0c             	sub    $0xc,%esp
   120e1:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   120e7:	51                   	push   %ecx
   120e8:	52                   	push   %edx
   120e9:	50                   	push   %eax
   120ea:	53                   	push   %ebx
   120eb:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   120f1:	50                   	push   %eax
   120f2:	e8 87 60 ff ff       	call   817e <zlib_compress>
   120f7:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   120fa:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   12100:	83 ec 0c             	sub    $0xc,%esp
   12103:	50                   	push   %eax
   12104:	e8 86 13 ff ff       	call   348f <lodepng_free>
   12109:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   1210c:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   12110:	74 0f                	je     12121 <filter+0x713>
   12112:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12115:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   1211c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   1211f:	7d 13                	jge    12134 <filter+0x726>
            bestType = type;
   12121:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12124:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   12127:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1212a:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   12131:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   12134:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12138:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   1213c:	0f 85 2e ff ff ff    	jne    12070 <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   12142:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12145:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12149:	89 c2                	mov    %eax,%edx
   1214b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1214e:	01 d0                	add    %edx,%eax
   12150:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   12153:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12156:	83 c0 01             	add    $0x1,%eax
   12159:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1215d:	89 c2                	mov    %eax,%edx
   1215f:	8b 45 08             	mov    0x8(%ebp),%eax
   12162:	01 d0                	add    %edx,%eax
   12164:	8b 55 bc             	mov    -0x44(%ebp),%edx
   12167:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   12169:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12170:	eb 31                	jmp    121a3 <filter+0x795>
   12172:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12175:	83 c0 01             	add    $0x1,%eax
   12178:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1217c:	89 c2                	mov    %eax,%edx
   1217e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12181:	01 d0                	add    %edx,%eax
   12183:	8d 50 01             	lea    0x1(%eax),%edx
   12186:	8b 45 08             	mov    0x8(%ebp),%eax
   12189:	01 c2                	add    %eax,%edx
   1218b:	8b 45 bc             	mov    -0x44(%ebp),%eax
   1218e:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   12195:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12198:	01 c8                	add    %ecx,%eax
   1219a:	0f b6 00             	movzbl (%eax),%eax
   1219d:	88 02                	mov    %al,(%edx)
   1219f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   121a3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   121a6:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   121a9:	75 c7                	jne    12172 <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   121ab:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   121af:	8b 45 ec             	mov    -0x14(%ebp),%eax
   121b2:	3b 45 14             	cmp    0x14(%ebp),%eax
   121b5:	0f 85 a9 fe ff ff    	jne    12064 <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   121bb:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   121c2:	eb 1a                	jmp    121de <filter+0x7d0>
   121c4:	8b 45 c0             	mov    -0x40(%ebp),%eax
   121c7:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   121ce:	83 ec 0c             	sub    $0xc,%esp
   121d1:	50                   	push   %eax
   121d2:	e8 b8 12 ff ff       	call   348f <lodepng_free>
   121d7:	83 c4 10             	add    $0x10,%esp
   121da:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   121de:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   121e2:	75 e0                	jne    121c4 <filter+0x7b6>
   121e4:	eb 07                	jmp    121ed <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   121e6:	b8 58 00 00 00       	mov    $0x58,%eax
   121eb:	eb 03                	jmp    121f0 <filter+0x7e2>

  return error;
   121ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   121f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   121f3:	c9                   	leave  
   121f4:	c3                   	ret    

000121f5 <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   121f5:	55                   	push   %ebp
   121f6:	89 e5                	mov    %esp,%ebp
   121f8:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   121fb:	8b 45 10             	mov    0x10(%ebp),%eax
   121fe:	2b 45 14             	sub    0x14(%ebp),%eax
   12201:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   12204:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1220b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   12212:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12219:	eb 65                	jmp    12280 <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   1221b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   12222:	eb 2a                	jmp    1224e <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   12224:	ff 75 0c             	pushl  0xc(%ebp)
   12227:	8d 45 e8             	lea    -0x18(%ebp),%eax
   1222a:	50                   	push   %eax
   1222b:	e8 9d 60 ff ff       	call   82cd <readBitFromReversedStream>
   12230:	83 c4 08             	add    $0x8,%esp
   12233:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   12236:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   1223a:	50                   	push   %eax
   1223b:	ff 75 08             	pushl  0x8(%ebp)
   1223e:	8d 45 ec             	lea    -0x14(%ebp),%eax
   12241:	50                   	push   %eax
   12242:	e8 08 61 ff ff       	call   834f <setBitOfReversedStream>
   12247:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   1224a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1224e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12251:	3b 45 14             	cmp    0x14(%ebp),%eax
   12254:	7c ce                	jl     12224 <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   12256:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1225d:	eb 15                	jmp    12274 <addPaddingBits+0x7f>
   1225f:	6a 00                	push   $0x0
   12261:	ff 75 08             	pushl  0x8(%ebp)
   12264:	8d 45 ec             	lea    -0x14(%ebp),%eax
   12267:	50                   	push   %eax
   12268:	e8 e2 60 ff ff       	call   834f <setBitOfReversedStream>
   1226d:	83 c4 0c             	add    $0xc,%esp
   12270:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12274:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12277:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1227a:	75 e3                	jne    1225f <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   1227c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12280:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12283:	3b 45 18             	cmp    0x18(%ebp),%eax
   12286:	75 93                	jne    1221b <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   12288:	90                   	nop
   12289:	c9                   	leave  
   1228a:	c3                   	ret    

0001228b <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   1228b:	55                   	push   %ebp
   1228c:	89 e5                	mov    %esp,%ebp
   1228e:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   12294:	ff 75 18             	pushl  0x18(%ebp)
   12297:	ff 75 14             	pushl  0x14(%ebp)
   1229a:	ff 75 10             	pushl  0x10(%ebp)
   1229d:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   122a3:	50                   	push   %eax
   122a4:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   122aa:	50                   	push   %eax
   122ab:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   122b1:	50                   	push   %eax
   122b2:	8d 45 94             	lea    -0x6c(%ebp),%eax
   122b5:	50                   	push   %eax
   122b6:	8d 45 b0             	lea    -0x50(%ebp),%eax
   122b9:	50                   	push   %eax
   122ba:	e8 fc ae ff ff       	call   d1bb <Adam7_getpassvalues>
   122bf:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   122c2:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   122c6:	0f 86 0a 01 00 00    	jbe    123d6 <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   122cc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   122d3:	e9 ef 00 00 00       	jmp    123c7 <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   122d8:	8b 45 18             	mov    0x18(%ebp),%eax
   122db:	c1 e8 03             	shr    $0x3,%eax
   122de:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   122e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   122e8:	e9 c6 00 00 00       	jmp    123b3 <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   122ed:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   122f4:	e9 a6 00 00 00       	jmp    1239f <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   122f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   122fc:	8b 14 85 38 a1 01 00 	mov    0x1a138(,%eax,4),%edx
   12303:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12306:	8b 04 85 70 a1 01 00 	mov    0x1a170(,%eax,4),%eax
   1230d:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   12311:	01 d0                	add    %edx,%eax
   12313:	0f af 45 10          	imul   0x10(%ebp),%eax
   12317:	89 c2                	mov    %eax,%edx
   12319:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1231c:	8b 04 85 54 a1 01 00 	mov    0x1a154(,%eax,4),%eax
   12323:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   12327:	01 c2                	add    %eax,%edx
   12329:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1232c:	8b 04 85 1c a1 01 00 	mov    0x1a11c(,%eax,4),%eax
   12333:	01 c2                	add    %eax,%edx
   12335:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12338:	0f af c2             	imul   %edx,%eax
   1233b:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   1233e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12341:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   12348:	89 c1                	mov    %eax,%ecx
   1234a:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1234d:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12351:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   12355:	89 c2                	mov    %eax,%edx
   12357:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1235a:	01 c2                	add    %eax,%edx
   1235c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1235f:	0f af c2             	imul   %edx,%eax
   12362:	01 c8                	add    %ecx,%eax
   12364:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   12367:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1236e:	eb 23                	jmp    12393 <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   12370:	8b 55 d8             	mov    -0x28(%ebp),%edx
   12373:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12376:	01 c2                	add    %eax,%edx
   12378:	8b 45 08             	mov    0x8(%ebp),%eax
   1237b:	01 c2                	add    %eax,%edx
   1237d:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   12380:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12383:	01 c1                	add    %eax,%ecx
   12385:	8b 45 0c             	mov    0xc(%ebp),%eax
   12388:	01 c8                	add    %ecx,%eax
   1238a:	0f b6 00             	movzbl (%eax),%eax
   1238d:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   1238f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12393:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12396:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12399:	72 d5                	jb     12370 <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   1239b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1239f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123a2:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   123a6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   123a9:	0f 87 4a ff ff ff    	ja     122f9 <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   123af:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   123b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123b6:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   123ba:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   123bd:	0f 87 2a ff ff ff    	ja     122ed <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   123c3:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   123c7:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   123cb:	0f 85 07 ff ff ff    	jne    122d8 <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   123d1:	e9 22 01 00 00       	jmp    124f8 <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   123d6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   123dd:	e9 0c 01 00 00       	jmp    124ee <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   123e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123e5:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   123e9:	0f af 45 18          	imul   0x18(%ebp),%eax
   123ed:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   123f0:	8b 45 18             	mov    0x18(%ebp),%eax
   123f3:	0f af 45 10          	imul   0x10(%ebp),%eax
   123f7:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   123fa:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   12401:	e9 d4 00 00 00       	jmp    124da <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   12406:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   1240d:	e9 b4 00 00 00       	jmp    124c6 <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   12412:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12415:	8b 14 85 38 a1 01 00 	mov    0x1a138(,%eax,4),%edx
   1241c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1241f:	8b 04 85 70 a1 01 00 	mov    0x1a170(,%eax,4),%eax
   12426:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   1242a:	01 d0                	add    %edx,%eax
   1242c:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   12430:	89 c2                	mov    %eax,%edx
   12432:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12435:	8b 0c 85 1c a1 01 00 	mov    0x1a11c(,%eax,4),%ecx
   1243c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1243f:	8b 04 85 54 a1 01 00 	mov    0x1a154(,%eax,4),%eax
   12446:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1244a:	01 c8                	add    %ecx,%eax
   1244c:	0f af 45 18          	imul   0x18(%ebp),%eax
   12450:	01 d0                	add    %edx,%eax
   12452:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   12458:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1245b:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   12462:	c1 e0 03             	shl    $0x3,%eax
   12465:	89 c1                	mov    %eax,%ecx
   12467:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1246a:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   1246e:	89 c2                	mov    %eax,%edx
   12470:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12473:	0f af 45 18          	imul   0x18(%ebp),%eax
   12477:	01 d0                	add    %edx,%eax
   12479:	01 c8                	add    %ecx,%eax
   1247b:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   12481:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   12488:	eb 30                	jmp    124ba <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   1248a:	ff 75 0c             	pushl  0xc(%ebp)
   1248d:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   12493:	50                   	push   %eax
   12494:	e8 34 5e ff ff       	call   82cd <readBitFromReversedStream>
   12499:	83 c4 08             	add    $0x8,%esp
   1249c:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   1249f:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   124a3:	50                   	push   %eax
   124a4:	ff 75 08             	pushl  0x8(%ebp)
   124a7:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   124ad:	50                   	push   %eax
   124ae:	e8 9c 5e ff ff       	call   834f <setBitOfReversedStream>
   124b3:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   124b6:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   124ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   124bd:	3b 45 18             	cmp    0x18(%ebp),%eax
   124c0:	72 c8                	jb     1248a <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   124c2:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   124c6:	8b 45 fc             	mov    -0x4(%ebp),%eax
   124c9:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   124cd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   124d0:	0f 87 3c ff ff ff    	ja     12412 <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   124d6:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   124da:	8b 45 fc             	mov    -0x4(%ebp),%eax
   124dd:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   124e1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   124e4:	0f 87 1c ff ff ff    	ja     12406 <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   124ea:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   124ee:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   124f2:	0f 85 ea fe ff ff    	jne    123e2 <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   124f8:	90                   	nop
   124f9:	c9                   	leave  
   124fa:	c3                   	ret    

000124fb <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   124fb:	55                   	push   %ebp
   124fc:	89 e5                	mov    %esp,%ebp
   124fe:	57                   	push   %edi
   124ff:	56                   	push   %esi
   12500:	53                   	push   %ebx
   12501:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   12507:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1250a:	83 c0 0c             	add    $0xc,%eax
   1250d:	50                   	push   %eax
   1250e:	e8 77 6a ff ff       	call   8f8a <lodepng_get_bpp>
   12513:	83 c4 04             	add    $0x4,%esp
   12516:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   12519:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   12520:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12523:	8b 40 08             	mov    0x8(%eax),%eax
   12526:	85 c0                	test   %eax,%eax
   12528:	0f 85 49 01 00 00    	jne    12677 <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   1252e:	8b 45 14             	mov    0x14(%ebp),%eax
   12531:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12535:	83 c0 07             	add    $0x7,%eax
   12538:	c1 e8 03             	shr    $0x3,%eax
   1253b:	83 c0 01             	add    $0x1,%eax
   1253e:	0f af 45 18          	imul   0x18(%ebp),%eax
   12542:	89 c2                	mov    %eax,%edx
   12544:	8b 45 0c             	mov    0xc(%ebp),%eax
   12547:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   12549:	8b 45 0c             	mov    0xc(%ebp),%eax
   1254c:	8b 00                	mov    (%eax),%eax
   1254e:	83 ec 0c             	sub    $0xc,%esp
   12551:	50                   	push   %eax
   12552:	e8 17 0f ff ff       	call   346e <lodepng_malloc>
   12557:	83 c4 10             	add    $0x10,%esp
   1255a:	89 c2                	mov    %eax,%edx
   1255c:	8b 45 08             	mov    0x8(%ebp),%eax
   1255f:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   12561:	8b 45 08             	mov    0x8(%ebp),%eax
   12564:	8b 00                	mov    (%eax),%eax
   12566:	85 c0                	test   %eax,%eax
   12568:	75 10                	jne    1257a <preProcessScanlines+0x7f>
   1256a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1256d:	8b 00                	mov    (%eax),%eax
   1256f:	85 c0                	test   %eax,%eax
   12571:	74 07                	je     1257a <preProcessScanlines+0x7f>
   12573:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   1257a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1257e:	0f 85 fb 02 00 00    	jne    1287f <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   12584:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   12588:	0f 87 bd 00 00 00    	ja     1264b <preProcessScanlines+0x150>
   1258e:	8b 45 14             	mov    0x14(%ebp),%eax
   12591:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12595:	89 c2                	mov    %eax,%edx
   12597:	8b 45 14             	mov    0x14(%ebp),%eax
   1259a:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1259e:	83 c0 07             	add    $0x7,%eax
   125a1:	c1 e8 03             	shr    $0x3,%eax
   125a4:	c1 e0 03             	shl    $0x3,%eax
   125a7:	39 c2                	cmp    %eax,%edx
   125a9:	0f 84 9c 00 00 00    	je     1264b <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   125af:	8b 45 14             	mov    0x14(%ebp),%eax
   125b2:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   125b6:	83 c0 07             	add    $0x7,%eax
   125b9:	c1 e8 03             	shr    $0x3,%eax
   125bc:	0f af 45 18          	imul   0x18(%ebp),%eax
   125c0:	83 ec 0c             	sub    $0xc,%esp
   125c3:	50                   	push   %eax
   125c4:	e8 a5 0e ff ff       	call   346e <lodepng_malloc>
   125c9:	83 c4 10             	add    $0x10,%esp
   125cc:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   125cf:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   125d3:	75 07                	jne    125dc <preProcessScanlines+0xe1>
   125d5:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   125dc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   125e0:	75 56                	jne    12638 <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   125e2:	8b 45 14             	mov    0x14(%ebp),%eax
   125e5:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   125e9:	89 c2                	mov    %eax,%edx
   125eb:	8b 45 14             	mov    0x14(%ebp),%eax
   125ee:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   125f2:	83 c0 07             	add    $0x7,%eax
   125f5:	c1 e8 03             	shr    $0x3,%eax
   125f8:	c1 e0 03             	shl    $0x3,%eax
   125fb:	83 ec 0c             	sub    $0xc,%esp
   125fe:	ff 75 18             	pushl  0x18(%ebp)
   12601:	52                   	push   %edx
   12602:	50                   	push   %eax
   12603:	ff 75 10             	pushl  0x10(%ebp)
   12606:	ff 75 d8             	pushl  -0x28(%ebp)
   12609:	e8 e7 fb ff ff       	call   121f5 <addPaddingBits>
   1260e:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   12611:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12614:	8d 50 0c             	lea    0xc(%eax),%edx
   12617:	8b 45 08             	mov    0x8(%ebp),%eax
   1261a:	8b 00                	mov    (%eax),%eax
   1261c:	83 ec 08             	sub    $0x8,%esp
   1261f:	ff 75 20             	pushl  0x20(%ebp)
   12622:	52                   	push   %edx
   12623:	ff 75 18             	pushl  0x18(%ebp)
   12626:	ff 75 14             	pushl  0x14(%ebp)
   12629:	ff 75 d8             	pushl  -0x28(%ebp)
   1262c:	50                   	push   %eax
   1262d:	e8 dc f3 ff ff       	call   11a0e <filter>
   12632:	83 c4 20             	add    $0x20,%esp
   12635:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   12638:	83 ec 0c             	sub    $0xc,%esp
   1263b:	ff 75 d8             	pushl  -0x28(%ebp)
   1263e:	e8 4c 0e ff ff       	call   348f <lodepng_free>
   12643:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   12646:	e9 34 02 00 00       	jmp    1287f <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   1264b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1264e:	8d 50 0c             	lea    0xc(%eax),%edx
   12651:	8b 45 08             	mov    0x8(%ebp),%eax
   12654:	8b 00                	mov    (%eax),%eax
   12656:	83 ec 08             	sub    $0x8,%esp
   12659:	ff 75 20             	pushl  0x20(%ebp)
   1265c:	52                   	push   %edx
   1265d:	ff 75 18             	pushl  0x18(%ebp)
   12660:	ff 75 14             	pushl  0x14(%ebp)
   12663:	ff 75 10             	pushl  0x10(%ebp)
   12666:	50                   	push   %eax
   12667:	e8 a2 f3 ff ff       	call   11a0e <filter>
   1266c:	83 c4 20             	add    $0x20,%esp
   1266f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   12672:	e9 08 02 00 00       	jmp    1287f <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   12677:	ff 75 dc             	pushl  -0x24(%ebp)
   1267a:	ff 75 18             	pushl  0x18(%ebp)
   1267d:	ff 75 14             	pushl  0x14(%ebp)
   12680:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   12686:	50                   	push   %eax
   12687:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   1268d:	50                   	push   %eax
   1268e:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   12694:	50                   	push   %eax
   12695:	8d 45 98             	lea    -0x68(%ebp),%eax
   12698:	50                   	push   %eax
   12699:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   1269c:	50                   	push   %eax
   1269d:	e8 19 ab ff ff       	call   d1bb <Adam7_getpassvalues>
   126a2:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   126a5:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   126ab:	8b 45 0c             	mov    0xc(%ebp),%eax
   126ae:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   126b0:	8b 45 0c             	mov    0xc(%ebp),%eax
   126b3:	8b 00                	mov    (%eax),%eax
   126b5:	83 ec 0c             	sub    $0xc,%esp
   126b8:	50                   	push   %eax
   126b9:	e8 b0 0d ff ff       	call   346e <lodepng_malloc>
   126be:	83 c4 10             	add    $0x10,%esp
   126c1:	89 c2                	mov    %eax,%edx
   126c3:	8b 45 08             	mov    0x8(%ebp),%eax
   126c6:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   126c8:	8b 45 08             	mov    0x8(%ebp),%eax
   126cb:	8b 00                	mov    (%eax),%eax
   126cd:	85 c0                	test   %eax,%eax
   126cf:	75 07                	jne    126d8 <preProcessScanlines+0x1dd>
   126d1:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   126d8:	8b 45 94             	mov    -0x6c(%ebp),%eax
   126db:	83 ec 0c             	sub    $0xc,%esp
   126de:	50                   	push   %eax
   126df:	e8 8a 0d ff ff       	call   346e <lodepng_malloc>
   126e4:	83 c4 10             	add    $0x10,%esp
   126e7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   126ea:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   126ee:	75 0e                	jne    126fe <preProcessScanlines+0x203>
   126f0:	8b 45 94             	mov    -0x6c(%ebp),%eax
   126f3:	85 c0                	test   %eax,%eax
   126f5:	74 07                	je     126fe <preProcessScanlines+0x203>
   126f7:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   126fe:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12702:	0f 85 69 01 00 00    	jne    12871 <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   12708:	83 ec 0c             	sub    $0xc,%esp
   1270b:	ff 75 dc             	pushl  -0x24(%ebp)
   1270e:	ff 75 18             	pushl  0x18(%ebp)
   12711:	ff 75 14             	pushl  0x14(%ebp)
   12714:	ff 75 10             	pushl  0x10(%ebp)
   12717:	ff 75 d4             	pushl  -0x2c(%ebp)
   1271a:	e8 6c fb ff ff       	call   1228b <Adam7_interlace>
   1271f:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   12722:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   12729:	e9 36 01 00 00       	jmp    12864 <preProcessScanlines+0x369>
        if(bpp < 8) {
   1272e:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   12732:	0f 87 d6 00 00 00    	ja     1280e <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   12738:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1273b:	83 c0 01             	add    $0x1,%eax
   1273e:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   12745:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12748:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   1274f:	29 c2                	sub    %eax,%edx
   12751:	89 d0                	mov    %edx,%eax
   12753:	83 ec 0c             	sub    $0xc,%esp
   12756:	50                   	push   %eax
   12757:	e8 12 0d ff ff       	call   346e <lodepng_malloc>
   1275c:	83 c4 10             	add    $0x10,%esp
   1275f:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   12762:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   12766:	75 0c                	jne    12774 <preProcessScanlines+0x279>
   12768:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   1276f:	e9 fd 00 00 00       	jmp    12871 <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   12774:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12777:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   1277b:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1277e:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12782:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   12786:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   12788:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1278b:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   1278f:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   12793:	83 c2 07             	add    $0x7,%edx
   12796:	c1 ea 03             	shr    $0x3,%edx
   12799:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   1279c:	89 d1                	mov    %edx,%ecx
   1279e:	8b 55 e0             	mov    -0x20(%ebp),%edx
   127a1:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   127a8:	89 d6                	mov    %edx,%esi
   127aa:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   127ad:	01 f2                	add    %esi,%edx
   127af:	83 ec 0c             	sub    $0xc,%esp
   127b2:	50                   	push   %eax
   127b3:	53                   	push   %ebx
   127b4:	51                   	push   %ecx
   127b5:	52                   	push   %edx
   127b6:	ff 75 d0             	pushl  -0x30(%ebp)
   127b9:	e8 37 fa ff ff       	call   121f5 <addPaddingBits>
   127be:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   127c1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   127c4:	8d 58 0c             	lea    0xc(%eax),%ebx
   127c7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   127ca:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   127ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
   127d1:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   127d5:	8b 4d 08             	mov    0x8(%ebp),%ecx
   127d8:	8b 31                	mov    (%ecx),%esi
   127da:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   127dd:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   127e4:	01 f1                	add    %esi,%ecx
   127e6:	83 ec 08             	sub    $0x8,%esp
   127e9:	ff 75 20             	pushl  0x20(%ebp)
   127ec:	53                   	push   %ebx
   127ed:	52                   	push   %edx
   127ee:	50                   	push   %eax
   127ef:	ff 75 d0             	pushl  -0x30(%ebp)
   127f2:	51                   	push   %ecx
   127f3:	e8 16 f2 ff ff       	call   11a0e <filter>
   127f8:	83 c4 20             	add    $0x20,%esp
   127fb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   127fe:	83 ec 0c             	sub    $0xc,%esp
   12801:	ff 75 d0             	pushl  -0x30(%ebp)
   12804:	e8 86 0c ff ff       	call   348f <lodepng_free>
   12809:	83 c4 10             	add    $0x10,%esp
   1280c:	eb 4c                	jmp    1285a <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   1280e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12811:	8d 70 0c             	lea    0xc(%eax),%esi
   12814:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12817:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   1281b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1281e:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   12822:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12825:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   1282c:	89 cb                	mov    %ecx,%ebx
   1282e:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   12831:	01 cb                	add    %ecx,%ebx
   12833:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12836:	8b 39                	mov    (%ecx),%edi
   12838:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   1283b:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   12842:	01 f9                	add    %edi,%ecx
   12844:	83 ec 08             	sub    $0x8,%esp
   12847:	ff 75 20             	pushl  0x20(%ebp)
   1284a:	56                   	push   %esi
   1284b:	52                   	push   %edx
   1284c:	50                   	push   %eax
   1284d:	53                   	push   %ebx
   1284e:	51                   	push   %ecx
   1284f:	e8 ba f1 ff ff       	call   11a0e <filter>
   12854:	83 c4 20             	add    $0x20,%esp
   12857:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   1285a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1285e:	75 10                	jne    12870 <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   12860:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   12864:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   12868:	0f 85 c0 fe ff ff    	jne    1272e <preProcessScanlines+0x233>
   1286e:	eb 01                	jmp    12871 <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   12870:	90                   	nop
      }
    }

    lodepng_free(adam7);
   12871:	83 ec 0c             	sub    $0xc,%esp
   12874:	ff 75 d4             	pushl  -0x2c(%ebp)
   12877:	e8 13 0c ff ff       	call   348f <lodepng_free>
   1287c:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   1287f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   12882:	8d 65 f4             	lea    -0xc(%ebp),%esp
   12885:	5b                   	pop    %ebx
   12886:	5e                   	pop    %esi
   12887:	5f                   	pop    %edi
   12888:	5d                   	pop    %ebp
   12889:	c3                   	ret    

0001288a <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   1288a:	55                   	push   %ebp
   1288b:	89 e5                	mov    %esp,%ebp
   1288d:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   12890:	8b 45 0c             	mov    0xc(%ebp),%eax
   12893:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   12896:	eb 47                	jmp    128df <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   12898:	8b 45 08             	mov    0x8(%ebp),%eax
   1289b:	8d 50 04             	lea    0x4(%eax),%edx
   1289e:	8b 45 08             	mov    0x8(%ebp),%eax
   128a1:	ff 75 fc             	pushl  -0x4(%ebp)
   128a4:	52                   	push   %edx
   128a5:	50                   	push   %eax
   128a6:	e8 73 5f ff ff       	call   881e <lodepng_chunk_append>
   128ab:	83 c4 0c             	add    $0xc,%esp
   128ae:	89 45 f8             	mov    %eax,-0x8(%ebp)
   128b1:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   128b5:	74 05                	je     128bc <addUnknownChunks+0x32>
   128b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   128ba:	eb 37                	jmp    128f3 <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   128bc:	8b 45 08             	mov    0x8(%ebp),%eax
   128bf:	8b 50 04             	mov    0x4(%eax),%edx
   128c2:	8b 45 08             	mov    0x8(%ebp),%eax
   128c5:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   128c8:	8b 55 10             	mov    0x10(%ebp),%edx
   128cb:	8b 45 0c             	mov    0xc(%ebp),%eax
   128ce:	01 d0                	add    %edx,%eax
   128d0:	50                   	push   %eax
   128d1:	ff 75 fc             	pushl  -0x4(%ebp)
   128d4:	e8 ff 5c ff ff       	call   85d8 <lodepng_chunk_next>
   128d9:	83 c4 08             	add    $0x8,%esp
   128dc:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   128df:	8b 55 fc             	mov    -0x4(%ebp),%edx
   128e2:	8b 45 0c             	mov    0xc(%ebp),%eax
   128e5:	29 c2                	sub    %eax,%edx
   128e7:	89 d0                	mov    %edx,%eax
   128e9:	3b 45 10             	cmp    0x10(%ebp),%eax
   128ec:	7c aa                	jl     12898 <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   128ee:	b8 00 00 00 00       	mov    $0x0,%eax
}
   128f3:	c9                   	leave  
   128f4:	c3                   	ret    

000128f5 <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   128f5:	55                   	push   %ebp
   128f6:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   128f8:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   128fc:	77 07                	ja     12905 <isGrayICCProfile+0x10>
   128fe:	b8 00 00 00 00       	mov    $0x0,%eax
   12903:	eb 40                	jmp    12945 <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   12905:	8b 45 08             	mov    0x8(%ebp),%eax
   12908:	83 c0 10             	add    $0x10,%eax
   1290b:	0f b6 00             	movzbl (%eax),%eax
   1290e:	3c 47                	cmp    $0x47,%al
   12910:	75 2e                	jne    12940 <isGrayICCProfile+0x4b>
   12912:	8b 45 08             	mov    0x8(%ebp),%eax
   12915:	83 c0 11             	add    $0x11,%eax
   12918:	0f b6 00             	movzbl (%eax),%eax
   1291b:	3c 52                	cmp    $0x52,%al
   1291d:	75 21                	jne    12940 <isGrayICCProfile+0x4b>
   1291f:	8b 45 08             	mov    0x8(%ebp),%eax
   12922:	83 c0 12             	add    $0x12,%eax
   12925:	0f b6 00             	movzbl (%eax),%eax
   12928:	3c 41                	cmp    $0x41,%al
   1292a:	75 14                	jne    12940 <isGrayICCProfile+0x4b>
   1292c:	8b 45 08             	mov    0x8(%ebp),%eax
   1292f:	83 c0 13             	add    $0x13,%eax
   12932:	0f b6 00             	movzbl (%eax),%eax
   12935:	3c 59                	cmp    $0x59,%al
   12937:	75 07                	jne    12940 <isGrayICCProfile+0x4b>
   12939:	b8 01 00 00 00       	mov    $0x1,%eax
   1293e:	eb 05                	jmp    12945 <isGrayICCProfile+0x50>
   12940:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12945:	5d                   	pop    %ebp
   12946:	c3                   	ret    

00012947 <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   12947:	55                   	push   %ebp
   12948:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   1294a:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   1294e:	77 07                	ja     12957 <isRGBICCProfile+0x10>
   12950:	b8 00 00 00 00       	mov    $0x0,%eax
   12955:	eb 40                	jmp    12997 <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   12957:	8b 45 08             	mov    0x8(%ebp),%eax
   1295a:	83 c0 10             	add    $0x10,%eax
   1295d:	0f b6 00             	movzbl (%eax),%eax
   12960:	3c 52                	cmp    $0x52,%al
   12962:	75 2e                	jne    12992 <isRGBICCProfile+0x4b>
   12964:	8b 45 08             	mov    0x8(%ebp),%eax
   12967:	83 c0 11             	add    $0x11,%eax
   1296a:	0f b6 00             	movzbl (%eax),%eax
   1296d:	3c 47                	cmp    $0x47,%al
   1296f:	75 21                	jne    12992 <isRGBICCProfile+0x4b>
   12971:	8b 45 08             	mov    0x8(%ebp),%eax
   12974:	83 c0 12             	add    $0x12,%eax
   12977:	0f b6 00             	movzbl (%eax),%eax
   1297a:	3c 42                	cmp    $0x42,%al
   1297c:	75 14                	jne    12992 <isRGBICCProfile+0x4b>
   1297e:	8b 45 08             	mov    0x8(%ebp),%eax
   12981:	83 c0 13             	add    $0x13,%eax
   12984:	0f b6 00             	movzbl (%eax),%eax
   12987:	3c 20                	cmp    $0x20,%al
   12989:	75 07                	jne    12992 <isRGBICCProfile+0x4b>
   1298b:	b8 01 00 00 00       	mov    $0x1,%eax
   12990:	eb 05                	jmp    12997 <isRGBICCProfile+0x50>
   12992:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12997:	5d                   	pop    %ebp
   12998:	c3                   	ret    

00012999 <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   12999:	55                   	push   %ebp
   1299a:	89 e5                	mov    %esp,%ebp
   1299c:	57                   	push   %edi
   1299d:	56                   	push   %esi
   1299e:	53                   	push   %ebx
   1299f:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   129a5:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   129ac:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   129b3:	8d 45 b0             	lea    -0x50(%ebp),%eax
   129b6:	6a 00                	push   $0x0
   129b8:	6a 00                	push   $0x0
   129ba:	50                   	push   %eax
   129bb:	e8 6f 0d ff ff       	call   372f <ucvector_init>
   129c0:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   129c3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129c6:	05 98 00 00 00       	add    $0x98,%eax
   129cb:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   129ce:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   129d4:	50                   	push   %eax
   129d5:	e8 3a 71 ff ff       	call   9b14 <lodepng_info_init>
   129da:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   129dd:	8b 45 08             	mov    0x8(%ebp),%eax
   129e0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   129e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   129e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   129ef:	8b 45 1c             	mov    0x1c(%ebp),%eax
   129f2:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   129f9:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   129fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   129ff:	8b 40 0c             	mov    0xc(%eax),%eax
   12a02:	83 f8 03             	cmp    $0x3,%eax
   12a05:	74 0a                	je     12a11 <lodepng_encode+0x78>
   12a07:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a0a:	8b 40 6c             	mov    0x6c(%eax),%eax
   12a0d:	85 c0                	test   %eax,%eax
   12a0f:	74 29                	je     12a3a <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   12a11:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a14:	8b 40 18             	mov    0x18(%eax),%eax
   12a17:	85 c0                	test   %eax,%eax
   12a19:	74 0d                	je     12a28 <lodepng_encode+0x8f>
   12a1b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a1e:	8b 40 18             	mov    0x18(%eax),%eax
   12a21:	3d 00 01 00 00       	cmp    $0x100,%eax
   12a26:	7e 12                	jle    12a3a <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   12a28:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a2b:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   12a32:	00 00 00 
    goto cleanup;
   12a35:	e9 78 0c 00 00       	jmp    136b2 <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   12a3a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a3d:	8b 40 38             	mov    0x38(%eax),%eax
   12a40:	83 f8 02             	cmp    $0x2,%eax
   12a43:	76 12                	jbe    12a57 <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   12a45:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a48:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   12a4f:	00 00 00 
    goto cleanup;
   12a52:	e9 5b 0c 00 00       	jmp    136b2 <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   12a57:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a5a:	8b 40 08             	mov    0x8(%eax),%eax
   12a5d:	83 f8 01             	cmp    $0x1,%eax
   12a60:	76 12                	jbe    12a74 <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   12a62:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a65:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   12a6c:	00 00 00 
    goto cleanup;
   12a6f:	e9 3e 0c 00 00       	jmp    136b2 <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   12a74:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a77:	8b 50 10             	mov    0x10(%eax),%edx
   12a7a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12a7d:	8b 40 0c             	mov    0xc(%eax),%eax
   12a80:	52                   	push   %edx
   12a81:	50                   	push   %eax
   12a82:	e8 a4 5f ff ff       	call   8a2b <checkColorValidity>
   12a87:	83 c4 08             	add    $0x8,%esp
   12a8a:	89 c2                	mov    %eax,%edx
   12a8c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a8f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12a95:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12a98:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12a9e:	85 c0                	test   %eax,%eax
   12aa0:	0f 85 c6 0b 00 00    	jne    1366c <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   12aa6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12aa9:	8b 50 7c             	mov    0x7c(%eax),%edx
   12aac:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12aaf:	8b 40 78             	mov    0x78(%eax),%eax
   12ab2:	52                   	push   %edx
   12ab3:	50                   	push   %eax
   12ab4:	e8 72 5f ff ff       	call   8a2b <checkColorValidity>
   12ab9:	83 c4 08             	add    $0x8,%esp
   12abc:	89 c2                	mov    %eax,%edx
   12abe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ac1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12ac7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12aca:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12ad0:	85 c0                	test   %eax,%eax
   12ad2:	0f 85 97 0b 00 00    	jne    1366f <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   12ad8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12adb:	05 98 00 00 00       	add    $0x98,%eax
   12ae0:	83 ec 08             	sub    $0x8,%esp
   12ae3:	50                   	push   %eax
   12ae4:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12aea:	50                   	push   %eax
   12aeb:	e8 58 71 ff ff       	call   9c48 <lodepng_info_copy>
   12af0:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   12af3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12af6:	8b 40 5c             	mov    0x5c(%eax),%eax
   12af9:	85 c0                	test   %eax,%eax
   12afb:	0f 84 3c 02 00 00    	je     12d3d <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   12b01:	83 ec 0c             	sub    $0xc,%esp
   12b04:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12b0a:	50                   	push   %eax
   12b0b:	e8 5f 96 ff ff       	call   c16f <lodepng_color_stats_init>
   12b10:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12b13:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b16:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12b1c:	85 c0                	test   %eax,%eax
   12b1e:	74 2d                	je     12b4d <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12b20:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b23:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12b29:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b2c:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12b32:	83 ec 08             	sub    $0x8,%esp
   12b35:	52                   	push   %edx
   12b36:	50                   	push   %eax
   12b37:	e8 b9 fd ff ff       	call   128f5 <isGrayICCProfile>
   12b3c:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12b3f:	85 c0                	test   %eax,%eax
   12b41:	74 0a                	je     12b4d <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   12b43:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   12b4a:	00 00 00 
    }
    if(info_png->iccp_defined &&
   12b4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b50:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12b56:	85 c0                	test   %eax,%eax
   12b58:	74 2d                	je     12b87 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12b5a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b5d:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12b63:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b66:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12b6c:	83 ec 08             	sub    $0x8,%esp
   12b6f:	52                   	push   %edx
   12b70:	50                   	push   %eax
   12b71:	e8 d1 fd ff ff       	call   12947 <isRGBICCProfile>
   12b76:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   12b79:	85 c0                	test   %eax,%eax
   12b7b:	74 0a                	je     12b87 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   12b7d:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   12b84:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   12b87:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b8a:	83 c0 78             	add    $0x78,%eax
   12b8d:	83 ec 0c             	sub    $0xc,%esp
   12b90:	50                   	push   %eax
   12b91:	ff 75 18             	pushl  0x18(%ebp)
   12b94:	ff 75 14             	pushl  0x14(%ebp)
   12b97:	ff 75 10             	pushl  0x10(%ebp)
   12b9a:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12ba0:	50                   	push   %eax
   12ba1:	e8 e0 96 ff ff       	call   c286 <lodepng_compute_color_stats>
   12ba6:	83 c4 20             	add    $0x20,%esp
   12ba9:	89 c2                	mov    %eax,%edx
   12bab:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bae:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12bb4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bb7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12bbd:	85 c0                	test   %eax,%eax
   12bbf:	0f 85 ad 0a 00 00    	jne    13672 <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   12bc5:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bc8:	8b 40 2c             	mov    0x2c(%eax),%eax
   12bcb:	85 c0                	test   %eax,%eax
   12bcd:	0f 84 be 00 00 00    	je     12c91 <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   12bd3:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   12bda:	00 00 00 
   12bdd:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   12be4:	00 00 00 
   12be7:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   12bee:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   12bf1:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   12bf7:	83 ec 04             	sub    $0x4,%esp
   12bfa:	6a 10                	push   $0x10
   12bfc:	6a 02                	push   $0x2
   12bfe:	50                   	push   %eax
   12bff:	e8 15 61 ff ff       	call   8d19 <lodepng_color_mode_make>
   12c04:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   12c07:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c0a:	8d 58 0c             	lea    0xc(%eax),%ebx
   12c0d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c10:	8b 48 38             	mov    0x38(%eax),%ecx
   12c13:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c16:	8b 50 34             	mov    0x34(%eax),%edx
   12c19:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c1c:	8b 40 30             	mov    0x30(%eax),%eax
   12c1f:	53                   	push   %ebx
   12c20:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   12c26:	53                   	push   %ebx
   12c27:	51                   	push   %ecx
   12c28:	52                   	push   %edx
   12c29:	50                   	push   %eax
   12c2a:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   12c30:	50                   	push   %eax
   12c31:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   12c37:	50                   	push   %eax
   12c38:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   12c3e:	50                   	push   %eax
   12c3f:	e8 8a 92 ff ff       	call   bece <lodepng_convert_rgb>
   12c44:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   12c47:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   12c4d:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   12c53:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   12c59:	83 ec 0c             	sub    $0xc,%esp
   12c5c:	68 ff ff 00 00       	push   $0xffff
   12c61:	51                   	push   %ecx
   12c62:	52                   	push   %edx
   12c63:	50                   	push   %eax
   12c64:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12c6a:	50                   	push   %eax
   12c6b:	e8 26 a1 ff ff       	call   cd96 <lodepng_color_stats_add>
   12c70:	83 c4 20             	add    $0x20,%esp
   12c73:	89 c2                	mov    %eax,%edx
   12c75:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c78:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12c7e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c81:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12c87:	85 c0                	test   %eax,%eax
   12c89:	74 06                	je     12c91 <lodepng_encode+0x2f8>
   12c8b:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   12c8c:	e9 e1 09 00 00       	jmp    13672 <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   12c91:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c94:	8d 50 78             	lea    0x78(%eax),%edx
   12c97:	83 ec 04             	sub    $0x4,%esp
   12c9a:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12ca0:	50                   	push   %eax
   12ca1:	52                   	push   %edx
   12ca2:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12ca8:	83 c0 0c             	add    $0xc,%eax
   12cab:	50                   	push   %eax
   12cac:	e8 79 a1 ff ff       	call   ce2a <auto_choose_color>
   12cb1:	83 c4 10             	add    $0x10,%esp
   12cb4:	89 c2                	mov    %eax,%edx
   12cb6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cb9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12cbf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12cc2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12cc8:	85 c0                	test   %eax,%eax
   12cca:	0f 85 a5 09 00 00    	jne    13675 <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   12cd0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cd3:	8b 40 2c             	mov    0x2c(%eax),%eax
   12cd6:	85 c0                	test   %eax,%eax
   12cd8:	74 63                	je     12d3d <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   12cda:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cdd:	8d 58 0c             	lea    0xc(%eax),%ebx
   12ce0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ce3:	8b 48 38             	mov    0x38(%eax),%ecx
   12ce6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ce9:	8b 50 34             	mov    0x34(%eax),%edx
   12cec:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cef:	8b 40 30             	mov    0x30(%eax),%eax
   12cf2:	53                   	push   %ebx
   12cf3:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   12cf9:	83 c3 0c             	add    $0xc,%ebx
   12cfc:	53                   	push   %ebx
   12cfd:	51                   	push   %ecx
   12cfe:	52                   	push   %edx
   12cff:	50                   	push   %eax
   12d00:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d06:	83 c0 38             	add    $0x38,%eax
   12d09:	50                   	push   %eax
   12d0a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d10:	83 c0 34             	add    $0x34,%eax
   12d13:	50                   	push   %eax
   12d14:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12d1a:	83 c0 30             	add    $0x30,%eax
   12d1d:	50                   	push   %eax
   12d1e:	e8 ab 91 ff ff       	call   bece <lodepng_convert_rgb>
   12d23:	83 c4 20             	add    $0x20,%esp
   12d26:	85 c0                	test   %eax,%eax
   12d28:	74 13                	je     12d3d <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   12d2a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d2d:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   12d34:	00 00 00 
        goto cleanup;
   12d37:	90                   	nop
   12d38:	e9 75 09 00 00       	jmp    136b2 <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   12d3d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d40:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12d46:	85 c0                	test   %eax,%eax
   12d48:	0f 84 b2 00 00 00    	je     12e00 <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12d4e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d51:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12d57:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d5a:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12d60:	83 ec 08             	sub    $0x8,%esp
   12d63:	52                   	push   %edx
   12d64:	50                   	push   %eax
   12d65:	e8 8b fb ff ff       	call   128f5 <isGrayICCProfile>
   12d6a:	83 c4 10             	add    $0x10,%esp
   12d6d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12d70:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d73:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12d79:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d7c:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12d82:	83 ec 08             	sub    $0x8,%esp
   12d85:	52                   	push   %edx
   12d86:	50                   	push   %eax
   12d87:	e8 bb fb ff ff       	call   12947 <isRGBICCProfile>
   12d8c:	83 c4 10             	add    $0x10,%esp
   12d8f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   12d92:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12d98:	85 c0                	test   %eax,%eax
   12d9a:	74 0b                	je     12da7 <lodepng_encode+0x40e>
   12d9c:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12da2:	83 f8 04             	cmp    $0x4,%eax
   12da5:	75 07                	jne    12dae <lodepng_encode+0x415>
   12da7:	b8 01 00 00 00       	mov    $0x1,%eax
   12dac:	eb 05                	jmp    12db3 <lodepng_encode+0x41a>
   12dae:	b8 00 00 00 00       	mov    $0x0,%eax
   12db3:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   12db6:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12dba:	75 18                	jne    12dd4 <lodepng_encode+0x43b>
   12dbc:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12dc0:	75 12                	jne    12dd4 <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   12dc2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dc5:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   12dcc:	00 00 00 
      goto cleanup;
   12dcf:	e9 de 08 00 00       	jmp    136b2 <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   12dd4:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12dd7:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   12dda:	74 24                	je     12e00 <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   12ddc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ddf:	8b 40 5c             	mov    0x5c(%eax),%eax
   12de2:	85 c0                	test   %eax,%eax
   12de4:	74 07                	je     12ded <lodepng_encode+0x454>
   12de6:	ba 66 00 00 00       	mov    $0x66,%edx
   12deb:	eb 05                	jmp    12df2 <lodepng_encode+0x459>
   12ded:	ba 65 00 00 00       	mov    $0x65,%edx
   12df2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12df5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   12dfb:	e9 b2 08 00 00       	jmp    136b2 <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   12e00:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e03:	83 c0 78             	add    $0x78,%eax
   12e06:	83 ec 08             	sub    $0x8,%esp
   12e09:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   12e0f:	83 c2 0c             	add    $0xc,%edx
   12e12:	52                   	push   %edx
   12e13:	50                   	push   %eax
   12e14:	e8 57 5f ff ff       	call   8d70 <lodepng_color_mode_equal>
   12e19:	83 c4 10             	add    $0x10,%esp
   12e1c:	85 c0                	test   %eax,%eax
   12e1e:	0f 85 f8 00 00 00    	jne    12f1c <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   12e24:	8b 55 14             	mov    0x14(%ebp),%edx
   12e27:	8b 45 18             	mov    0x18(%ebp),%eax
   12e2a:	89 d3                	mov    %edx,%ebx
   12e2c:	0f af d8             	imul   %eax,%ebx
   12e2f:	83 ec 0c             	sub    $0xc,%esp
   12e32:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e38:	83 c0 0c             	add    $0xc,%eax
   12e3b:	50                   	push   %eax
   12e3c:	e8 49 61 ff ff       	call   8f8a <lodepng_get_bpp>
   12e41:	83 c4 10             	add    $0x10,%esp
   12e44:	0f af c3             	imul   %ebx,%eax
   12e47:	83 c0 07             	add    $0x7,%eax
   12e4a:	c1 e8 03             	shr    $0x3,%eax
   12e4d:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   12e50:	83 ec 0c             	sub    $0xc,%esp
   12e53:	ff 75 cc             	pushl  -0x34(%ebp)
   12e56:	e8 13 06 ff ff       	call   346e <lodepng_malloc>
   12e5b:	83 c4 10             	add    $0x10,%esp
   12e5e:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   12e61:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   12e65:	75 13                	jne    12e7a <lodepng_encode+0x4e1>
   12e67:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   12e6b:	74 0d                	je     12e7a <lodepng_encode+0x4e1>
   12e6d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e70:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   12e77:	00 00 00 
    if(!state->error) {
   12e7a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e7d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e83:	85 c0                	test   %eax,%eax
   12e85:	75 33                	jne    12eba <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   12e87:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e8a:	83 c0 78             	add    $0x78,%eax
   12e8d:	83 ec 08             	sub    $0x8,%esp
   12e90:	ff 75 18             	pushl  0x18(%ebp)
   12e93:	ff 75 14             	pushl  0x14(%ebp)
   12e96:	50                   	push   %eax
   12e97:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e9d:	83 c0 0c             	add    $0xc,%eax
   12ea0:	50                   	push   %eax
   12ea1:	ff 75 10             	pushl  0x10(%ebp)
   12ea4:	ff 75 c8             	pushl  -0x38(%ebp)
   12ea7:	e8 c9 8c ff ff       	call   bb75 <lodepng_convert>
   12eac:	83 c4 20             	add    $0x20,%esp
   12eaf:	89 c2                	mov    %eax,%edx
   12eb1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12eb4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   12eba:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ebd:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12ec3:	85 c0                	test   %eax,%eax
   12ec5:	75 35                	jne    12efc <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   12ec7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12eca:	83 c0 38             	add    $0x38,%eax
   12ecd:	83 ec 04             	sub    $0x4,%esp
   12ed0:	50                   	push   %eax
   12ed1:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12ed7:	50                   	push   %eax
   12ed8:	ff 75 18             	pushl  0x18(%ebp)
   12edb:	ff 75 14             	pushl  0x14(%ebp)
   12ede:	ff 75 c8             	pushl  -0x38(%ebp)
   12ee1:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12ee4:	50                   	push   %eax
   12ee5:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12ee8:	50                   	push   %eax
   12ee9:	e8 0d f6 ff ff       	call   124fb <preProcessScanlines>
   12eee:	83 c4 20             	add    $0x20,%esp
   12ef1:	89 c2                	mov    %eax,%edx
   12ef3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ef6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   12efc:	83 ec 0c             	sub    $0xc,%esp
   12eff:	ff 75 c8             	pushl  -0x38(%ebp)
   12f02:	e8 88 05 ff ff       	call   348f <lodepng_free>
   12f07:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   12f0a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f0d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f13:	85 c0                	test   %eax,%eax
   12f15:	74 4b                	je     12f62 <lodepng_encode+0x5c9>
   12f17:	e9 96 07 00 00       	jmp    136b2 <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   12f1c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f1f:	83 c0 38             	add    $0x38,%eax
   12f22:	83 ec 04             	sub    $0x4,%esp
   12f25:	50                   	push   %eax
   12f26:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12f2c:	50                   	push   %eax
   12f2d:	ff 75 18             	pushl  0x18(%ebp)
   12f30:	ff 75 14             	pushl  0x14(%ebp)
   12f33:	ff 75 10             	pushl  0x10(%ebp)
   12f36:	8d 45 bc             	lea    -0x44(%ebp),%eax
   12f39:	50                   	push   %eax
   12f3a:	8d 45 c0             	lea    -0x40(%ebp),%eax
   12f3d:	50                   	push   %eax
   12f3e:	e8 b8 f5 ff ff       	call   124fb <preProcessScanlines>
   12f43:	83 c4 20             	add    $0x20,%esp
   12f46:	89 c2                	mov    %eax,%edx
   12f48:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f4b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12f51:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f54:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f5a:	85 c0                	test   %eax,%eax
   12f5c:	0f 85 16 07 00 00    	jne    13678 <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   12f62:	83 ec 0c             	sub    $0xc,%esp
   12f65:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12f68:	50                   	push   %eax
   12f69:	e8 21 d9 ff ff       	call   1088f <writeSignature>
   12f6e:	83 c4 10             	add    $0x10,%esp
   12f71:	89 c2                	mov    %eax,%edx
   12f73:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f76:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12f7c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f7f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12f85:	85 c0                	test   %eax,%eax
   12f87:	0f 85 ee 06 00 00    	jne    1367b <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   12f8d:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   12f93:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   12f99:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12f9f:	83 ec 08             	sub    $0x8,%esp
   12fa2:	51                   	push   %ecx
   12fa3:	52                   	push   %edx
   12fa4:	50                   	push   %eax
   12fa5:	ff 75 18             	pushl  0x18(%ebp)
   12fa8:	ff 75 14             	pushl  0x14(%ebp)
   12fab:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12fae:	50                   	push   %eax
   12faf:	e8 4a d9 ff ff       	call   108fe <addChunk_IHDR>
   12fb4:	83 c4 20             	add    $0x20,%esp
   12fb7:	89 c2                	mov    %eax,%edx
   12fb9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fbc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12fc2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fc5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12fcb:	85 c0                	test   %eax,%eax
   12fcd:	0f 85 ab 06 00 00    	jne    1367e <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   12fd3:	8b 45 98             	mov    -0x68(%ebp),%eax
   12fd6:	85 c0                	test   %eax,%eax
   12fd8:	74 33                	je     1300d <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   12fda:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   12fdd:	8b 45 98             	mov    -0x68(%ebp),%eax
   12fe0:	83 ec 04             	sub    $0x4,%esp
   12fe3:	52                   	push   %edx
   12fe4:	50                   	push   %eax
   12fe5:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12fe8:	50                   	push   %eax
   12fe9:	e8 9c f8 ff ff       	call   1288a <addUnknownChunks>
   12fee:	83 c4 10             	add    $0x10,%esp
   12ff1:	89 c2                	mov    %eax,%edx
   12ff3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ff6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12ffc:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fff:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13005:	85 c0                	test   %eax,%eax
   13007:	0f 85 74 06 00 00    	jne    13681 <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   1300d:	8b 45 88             	mov    -0x78(%ebp),%eax
   13010:	85 c0                	test   %eax,%eax
   13012:	74 39                	je     1304d <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   13014:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13017:	83 c0 38             	add    $0x38,%eax
   1301a:	83 ec 04             	sub    $0x4,%esp
   1301d:	50                   	push   %eax
   1301e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13024:	50                   	push   %eax
   13025:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13028:	50                   	push   %eax
   13029:	e8 a4 e4 ff ff       	call   114d2 <addChunk_iCCP>
   1302e:	83 c4 10             	add    $0x10,%esp
   13031:	89 c2                	mov    %eax,%edx
   13033:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13036:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1303c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1303f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13045:	85 c0                	test   %eax,%eax
   13047:	0f 85 37 06 00 00    	jne    13684 <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   1304d:	8b 45 80             	mov    -0x80(%ebp),%eax
   13050:	85 c0                	test   %eax,%eax
   13052:	74 32                	je     13086 <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   13054:	83 ec 08             	sub    $0x8,%esp
   13057:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1305d:	50                   	push   %eax
   1305e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13061:	50                   	push   %eax
   13062:	e8 41 e4 ff ff       	call   114a8 <addChunk_sRGB>
   13067:	83 c4 10             	add    $0x10,%esp
   1306a:	89 c2                	mov    %eax,%edx
   1306c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1306f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13075:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13078:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1307e:	85 c0                	test   %eax,%eax
   13080:	0f 85 01 06 00 00    	jne    13687 <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   13086:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   1308c:	85 c0                	test   %eax,%eax
   1308e:	74 32                	je     130c2 <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   13090:	83 ec 08             	sub    $0x8,%esp
   13093:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13099:	50                   	push   %eax
   1309a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1309d:	50                   	push   %eax
   1309e:	e8 a7 e2 ff ff       	call   1134a <addChunk_gAMA>
   130a3:	83 c4 10             	add    $0x10,%esp
   130a6:	89 c2                	mov    %eax,%edx
   130a8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130ab:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   130b1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130b4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130ba:	85 c0                	test   %eax,%eax
   130bc:	0f 85 c8 05 00 00    	jne    1368a <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   130c2:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   130c8:	85 c0                	test   %eax,%eax
   130ca:	74 32                	je     130fe <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   130cc:	83 ec 08             	sub    $0x8,%esp
   130cf:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130d5:	50                   	push   %eax
   130d6:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130d9:	50                   	push   %eax
   130da:	e8 c1 e2 ff ff       	call   113a0 <addChunk_cHRM>
   130df:	83 c4 10             	add    $0x10,%esp
   130e2:	89 c2                	mov    %eax,%edx
   130e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130e7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   130ed:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130f0:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130f6:	85 c0                	test   %eax,%eax
   130f8:	0f 85 8f 05 00 00    	jne    1368d <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   130fe:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13104:	83 f8 03             	cmp    $0x3,%eax
   13107:	75 35                	jne    1313e <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   13109:	83 ec 08             	sub    $0x8,%esp
   1310c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13112:	83 c0 0c             	add    $0xc,%eax
   13115:	50                   	push   %eax
   13116:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13119:	50                   	push   %eax
   1311a:	e8 78 d8 ff ff       	call   10997 <addChunk_PLTE>
   1311f:	83 c4 10             	add    $0x10,%esp
   13122:	89 c2                	mov    %eax,%edx
   13124:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13127:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1312d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13130:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13136:	85 c0                	test   %eax,%eax
   13138:	0f 85 52 05 00 00    	jne    13690 <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   1313e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13141:	8b 40 6c             	mov    0x6c(%eax),%eax
   13144:	85 c0                	test   %eax,%eax
   13146:	74 4b                	je     13193 <lodepng_encode+0x7fa>
   13148:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1314e:	83 f8 02             	cmp    $0x2,%eax
   13151:	74 0b                	je     1315e <lodepng_encode+0x7c5>
   13153:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13159:	83 f8 06             	cmp    $0x6,%eax
   1315c:	75 35                	jne    13193 <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   1315e:	83 ec 08             	sub    $0x8,%esp
   13161:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13167:	83 c0 0c             	add    $0xc,%eax
   1316a:	50                   	push   %eax
   1316b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1316e:	50                   	push   %eax
   1316f:	e8 23 d8 ff ff       	call   10997 <addChunk_PLTE>
   13174:	83 c4 10             	add    $0x10,%esp
   13177:	89 c2                	mov    %eax,%edx
   13179:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1317c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13182:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13185:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1318b:	85 c0                	test   %eax,%eax
   1318d:	0f 85 00 05 00 00    	jne    13693 <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   13193:	83 ec 08             	sub    $0x8,%esp
   13196:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1319c:	83 c0 0c             	add    $0xc,%eax
   1319f:	50                   	push   %eax
   131a0:	8d 45 b0             	lea    -0x50(%ebp),%eax
   131a3:	50                   	push   %eax
   131a4:	e8 c4 d8 ff ff       	call   10a6d <addChunk_tRNS>
   131a9:	83 c4 10             	add    $0x10,%esp
   131ac:	89 c2                	mov    %eax,%edx
   131ae:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131b1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   131b7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131ba:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   131c0:	85 c0                	test   %eax,%eax
   131c2:	0f 85 ce 04 00 00    	jne    13696 <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   131c8:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   131ce:	85 c0                	test   %eax,%eax
   131d0:	74 32                	je     13204 <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   131d2:	83 ec 08             	sub    $0x8,%esp
   131d5:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   131db:	50                   	push   %eax
   131dc:	8d 45 b0             	lea    -0x50(%ebp),%eax
   131df:	50                   	push   %eax
   131e0:	e8 e4 de ff ff       	call   110c9 <addChunk_bKGD>
   131e5:	83 c4 10             	add    $0x10,%esp
   131e8:	89 c2                	mov    %eax,%edx
   131ea:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131ed:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   131f3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131f6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   131fc:	85 c0                	test   %eax,%eax
   131fe:	0f 85 95 04 00 00    	jne    13699 <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   13204:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   1320a:	85 c0                	test   %eax,%eax
   1320c:	74 32                	je     13240 <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   1320e:	83 ec 08             	sub    $0x8,%esp
   13211:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13217:	50                   	push   %eax
   13218:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1321b:	50                   	push   %eax
   1321c:	e8 ac e0 ff ff       	call   112cd <addChunk_pHYs>
   13221:	83 c4 10             	add    $0x10,%esp
   13224:	89 c2                	mov    %eax,%edx
   13226:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13229:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1322f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13232:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13238:	85 c0                	test   %eax,%eax
   1323a:	0f 85 5c 04 00 00    	jne    1369c <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   13240:	8b 45 9c             	mov    -0x64(%ebp),%eax
   13243:	85 c0                	test   %eax,%eax
   13245:	74 33                	je     1327a <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   13247:	8b 55 a8             	mov    -0x58(%ebp),%edx
   1324a:	8b 45 9c             	mov    -0x64(%ebp),%eax
   1324d:	83 ec 04             	sub    $0x4,%esp
   13250:	52                   	push   %edx
   13251:	50                   	push   %eax
   13252:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13255:	50                   	push   %eax
   13256:	e8 2f f6 ff ff       	call   1288a <addUnknownChunks>
   1325b:	83 c4 10             	add    $0x10,%esp
   1325e:	89 c2                	mov    %eax,%edx
   13260:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13263:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13269:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1326c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13272:	85 c0                	test   %eax,%eax
   13274:	0f 85 25 04 00 00    	jne    1369f <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   1327a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1327d:	8d 48 38             	lea    0x38(%eax),%ecx
   13280:	8b 55 bc             	mov    -0x44(%ebp),%edx
   13283:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13286:	51                   	push   %ecx
   13287:	52                   	push   %edx
   13288:	50                   	push   %eax
   13289:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1328c:	50                   	push   %eax
   1328d:	e8 bd d9 ff ff       	call   10c4f <addChunk_IDAT>
   13292:	83 c4 10             	add    $0x10,%esp
   13295:	89 c2                	mov    %eax,%edx
   13297:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1329a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   132a0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132a3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   132a9:	85 c0                	test   %eax,%eax
   132ab:	0f 85 f1 03 00 00    	jne    136a2 <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   132b1:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   132b7:	85 c0                	test   %eax,%eax
   132b9:	74 35                	je     132f0 <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   132bb:	83 ec 08             	sub    $0x8,%esp
   132be:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   132c4:	83 c0 60             	add    $0x60,%eax
   132c7:	50                   	push   %eax
   132c8:	8d 45 b0             	lea    -0x50(%ebp),%eax
   132cb:	50                   	push   %eax
   132cc:	e8 5c df ff ff       	call   1122d <addChunk_tIME>
   132d1:	83 c4 10             	add    $0x10,%esp
   132d4:	89 c2                	mov    %eax,%edx
   132d6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132d9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   132df:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132e2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   132e8:	85 c0                	test   %eax,%eax
   132ea:	0f 85 b5 03 00 00    	jne    136a5 <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   132f0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   132f7:	e9 12 01 00 00       	jmp    1340e <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   132fc:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13302:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13305:	c1 e2 02             	shl    $0x2,%edx
   13308:	01 d0                	add    %edx,%eax
   1330a:	8b 00                	mov    (%eax),%eax
   1330c:	83 ec 0c             	sub    $0xc,%esp
   1330f:	50                   	push   %eax
   13310:	e8 f5 01 ff ff       	call   350a <lodepng_strlen>
   13315:	83 c4 10             	add    $0x10,%esp
   13318:	83 f8 4f             	cmp    $0x4f,%eax
   1331b:	7e 12                	jle    1332f <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   1331d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13320:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   13327:	00 00 00 
        goto cleanup;
   1332a:	e9 83 03 00 00       	jmp    136b2 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   1332f:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13335:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13338:	c1 e2 02             	shl    $0x2,%edx
   1333b:	01 d0                	add    %edx,%eax
   1333d:	8b 00                	mov    (%eax),%eax
   1333f:	83 ec 0c             	sub    $0xc,%esp
   13342:	50                   	push   %eax
   13343:	e8 c2 01 ff ff       	call   350a <lodepng_strlen>
   13348:	83 c4 10             	add    $0x10,%esp
   1334b:	85 c0                	test   %eax,%eax
   1334d:	7f 12                	jg     13361 <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   1334f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13352:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   13359:	00 00 00 
        goto cleanup;
   1335c:	e9 51 03 00 00       	jmp    136b2 <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   13361:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13364:	8b 40 74             	mov    0x74(%eax),%eax
   13367:	85 c0                	test   %eax,%eax
   13369:	74 52                	je     133bd <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   1336b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1336e:	8d 48 38             	lea    0x38(%eax),%ecx
   13371:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   13377:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1337a:	c1 e2 02             	shl    $0x2,%edx
   1337d:	01 d0                	add    %edx,%eax
   1337f:	8b 10                	mov    (%eax),%edx
   13381:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13387:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   1338a:	c1 e3 02             	shl    $0x2,%ebx
   1338d:	01 d8                	add    %ebx,%eax
   1338f:	8b 00                	mov    (%eax),%eax
   13391:	51                   	push   %ecx
   13392:	52                   	push   %edx
   13393:	50                   	push   %eax
   13394:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13397:	50                   	push   %eax
   13398:	e8 fa d9 ff ff       	call   10d97 <addChunk_zTXt>
   1339d:	83 c4 10             	add    $0x10,%esp
   133a0:	89 c2                	mov    %eax,%edx
   133a2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133a5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   133ab:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133ae:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   133b4:	85 c0                	test   %eax,%eax
   133b6:	74 52                	je     1340a <lodepng_encode+0xa71>
   133b8:	e9 f5 02 00 00       	jmp    136b2 <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   133bd:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   133c3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   133c6:	c1 e2 02             	shl    $0x2,%edx
   133c9:	01 d0                	add    %edx,%eax
   133cb:	8b 10                	mov    (%eax),%edx
   133cd:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   133d3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   133d6:	c1 e1 02             	shl    $0x2,%ecx
   133d9:	01 c8                	add    %ecx,%eax
   133db:	8b 00                	mov    (%eax),%eax
   133dd:	83 ec 04             	sub    $0x4,%esp
   133e0:	52                   	push   %edx
   133e1:	50                   	push   %eax
   133e2:	8d 45 b0             	lea    -0x50(%ebp),%eax
   133e5:	50                   	push   %eax
   133e6:	e8 ec d8 ff ff       	call   10cd7 <addChunk_tEXt>
   133eb:	83 c4 10             	add    $0x10,%esp
   133ee:	89 c2                	mov    %eax,%edx
   133f0:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133f3:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   133f9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133fc:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13402:	85 c0                	test   %eax,%eax
   13404:	0f 85 9e 02 00 00    	jne    136a8 <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   1340a:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1340e:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   13414:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13417:	0f 85 df fe ff ff    	jne    132fc <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   1341d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13420:	8b 40 70             	mov    0x70(%eax),%eax
   13423:	85 c0                	test   %eax,%eax
   13425:	0f 84 e3 00 00 00    	je     1350e <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   1342b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   13432:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13439:	e9 85 00 00 00       	jmp    134c3 <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   1343e:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13444:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13447:	c1 e2 02             	shl    $0x2,%edx
   1344a:	01 d0                	add    %edx,%eax
   1344c:	8b 00                	mov    (%eax),%eax
   1344e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13451:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13454:	0f b6 00             	movzbl (%eax),%eax
   13457:	3c 4c                	cmp    $0x4c,%al
   13459:	75 64                	jne    134bf <lodepng_encode+0xb26>
   1345b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1345e:	83 c0 01             	add    $0x1,%eax
   13461:	0f b6 00             	movzbl (%eax),%eax
   13464:	3c 6f                	cmp    $0x6f,%al
   13466:	75 57                	jne    134bf <lodepng_encode+0xb26>
   13468:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1346b:	83 c0 02             	add    $0x2,%eax
   1346e:	0f b6 00             	movzbl (%eax),%eax
   13471:	3c 64                	cmp    $0x64,%al
   13473:	75 4a                	jne    134bf <lodepng_encode+0xb26>
   13475:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13478:	83 c0 03             	add    $0x3,%eax
   1347b:	0f b6 00             	movzbl (%eax),%eax
   1347e:	3c 65                	cmp    $0x65,%al
   13480:	75 3d                	jne    134bf <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13482:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13485:	83 c0 04             	add    $0x4,%eax
   13488:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   1348b:	3c 50                	cmp    $0x50,%al
   1348d:	75 30                	jne    134bf <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   1348f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13492:	83 c0 05             	add    $0x5,%eax
   13495:	0f b6 00             	movzbl (%eax),%eax
   13498:	3c 4e                	cmp    $0x4e,%al
   1349a:	75 23                	jne    134bf <lodepng_encode+0xb26>
   1349c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1349f:	83 c0 06             	add    $0x6,%eax
   134a2:	0f b6 00             	movzbl (%eax),%eax
   134a5:	3c 47                	cmp    $0x47,%al
   134a7:	75 16                	jne    134bf <lodepng_encode+0xb26>
   134a9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   134ac:	83 c0 07             	add    $0x7,%eax
   134af:	0f b6 00             	movzbl (%eax),%eax
   134b2:	84 c0                	test   %al,%al
   134b4:	75 09                	jne    134bf <lodepng_encode+0xb26>
          already_added_id_text = 1;
   134b6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   134bd:	eb 13                	jmp    134d2 <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   134bf:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   134c3:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   134c9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   134cc:	0f 85 6c ff ff ff    	jne    1343e <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   134d2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   134d6:	75 36                	jne    1350e <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   134d8:	a1 60 e2 01 00       	mov    0x1e260,%eax
   134dd:	83 ec 04             	sub    $0x4,%esp
   134e0:	50                   	push   %eax
   134e1:	68 04 a2 01 00       	push   $0x1a204
   134e6:	8d 45 b0             	lea    -0x50(%ebp),%eax
   134e9:	50                   	push   %eax
   134ea:	e8 e8 d7 ff ff       	call   10cd7 <addChunk_tEXt>
   134ef:	83 c4 10             	add    $0x10,%esp
   134f2:	89 c2                	mov    %eax,%edx
   134f4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134f7:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   134fd:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13500:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13506:	85 c0                	test   %eax,%eax
   13508:	0f 85 9d 01 00 00    	jne    136ab <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   1350e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13515:	e9 e6 00 00 00       	jmp    13600 <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   1351a:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13520:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13523:	c1 e2 02             	shl    $0x2,%edx
   13526:	01 d0                	add    %edx,%eax
   13528:	8b 00                	mov    (%eax),%eax
   1352a:	83 ec 0c             	sub    $0xc,%esp
   1352d:	50                   	push   %eax
   1352e:	e8 d7 ff fe ff       	call   350a <lodepng_strlen>
   13533:	83 c4 10             	add    $0x10,%esp
   13536:	83 f8 4f             	cmp    $0x4f,%eax
   13539:	7e 12                	jle    1354d <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   1353b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1353e:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   13545:	00 00 00 
        goto cleanup;
   13548:	e9 65 01 00 00       	jmp    136b2 <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   1354d:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13553:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13556:	c1 e2 02             	shl    $0x2,%edx
   13559:	01 d0                	add    %edx,%eax
   1355b:	8b 00                	mov    (%eax),%eax
   1355d:	83 ec 0c             	sub    $0xc,%esp
   13560:	50                   	push   %eax
   13561:	e8 a4 ff fe ff       	call   350a <lodepng_strlen>
   13566:	83 c4 10             	add    $0x10,%esp
   13569:	85 c0                	test   %eax,%eax
   1356b:	7f 12                	jg     1357f <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   1356d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13570:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   13577:	00 00 00 
        goto cleanup;
   1357a:	e9 33 01 00 00       	jmp    136b2 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   1357f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13582:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13585:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   1358b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1358e:	c1 e2 02             	shl    $0x2,%edx
   13591:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   13593:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   13595:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   1359b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1359e:	c1 e2 02             	shl    $0x2,%edx
   135a1:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   135a3:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   135a5:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   135ab:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   135ae:	c1 e2 02             	shl    $0x2,%edx
   135b1:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   135b3:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   135b5:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   135bb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   135be:	c1 e2 02             	shl    $0x2,%edx
   135c1:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   135c3:	8b 10                	mov    (%eax),%edx
   135c5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135c8:	8b 40 74             	mov    0x74(%eax),%eax
   135cb:	83 ec 04             	sub    $0x4,%esp
   135ce:	57                   	push   %edi
   135cf:	56                   	push   %esi
   135d0:	53                   	push   %ebx
   135d1:	51                   	push   %ecx
   135d2:	52                   	push   %edx
   135d3:	50                   	push   %eax
   135d4:	8d 45 b0             	lea    -0x50(%ebp),%eax
   135d7:	50                   	push   %eax
   135d8:	e8 dc d8 ff ff       	call   10eb9 <addChunk_iTXt>
   135dd:	83 c4 20             	add    $0x20,%esp
   135e0:	89 c2                	mov    %eax,%edx
   135e2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135e5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   135eb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   135ee:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   135f4:	85 c0                	test   %eax,%eax
   135f6:	0f 85 b2 00 00 00    	jne    136ae <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   135fc:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13600:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   13606:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13609:	0f 85 0b ff ff ff    	jne    1351a <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   1360f:	8b 45 a0             	mov    -0x60(%ebp),%eax
   13612:	85 c0                	test   %eax,%eax
   13614:	74 2f                	je     13645 <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   13616:	8b 55 ac             	mov    -0x54(%ebp),%edx
   13619:	8b 45 a0             	mov    -0x60(%ebp),%eax
   1361c:	83 ec 04             	sub    $0x4,%esp
   1361f:	52                   	push   %edx
   13620:	50                   	push   %eax
   13621:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13624:	50                   	push   %eax
   13625:	e8 60 f2 ff ff       	call   1288a <addUnknownChunks>
   1362a:	83 c4 10             	add    $0x10,%esp
   1362d:	89 c2                	mov    %eax,%edx
   1362f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13632:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13638:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1363b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13641:	85 c0                	test   %eax,%eax
   13643:	75 6c                	jne    136b1 <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   13645:	83 ec 0c             	sub    $0xc,%esp
   13648:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1364b:	50                   	push   %eax
   1364c:	e8 6d d6 ff ff       	call   10cbe <addChunk_IEND>
   13651:	83 c4 10             	add    $0x10,%esp
   13654:	89 c2                	mov    %eax,%edx
   13656:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13659:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1365f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13662:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13668:	85 c0                	test   %eax,%eax
   1366a:	eb 46                	jmp    136b2 <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   1366c:	90                   	nop
   1366d:	eb 43                	jmp    136b2 <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   1366f:	90                   	nop
   13670:	eb 40                	jmp    136b2 <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   13672:	90                   	nop
   13673:	eb 3d                	jmp    136b2 <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   13675:	90                   	nop
   13676:	eb 3a                	jmp    136b2 <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   13678:	90                   	nop
   13679:	eb 37                	jmp    136b2 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   1367b:	90                   	nop
   1367c:	eb 34                	jmp    136b2 <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   1367e:	90                   	nop
   1367f:	eb 31                	jmp    136b2 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   13681:	90                   	nop
   13682:	eb 2e                	jmp    136b2 <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13684:	90                   	nop
   13685:	eb 2b                	jmp    136b2 <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   13687:	90                   	nop
   13688:	eb 28                	jmp    136b2 <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   1368a:	90                   	nop
   1368b:	eb 25                	jmp    136b2 <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   1368d:	90                   	nop
   1368e:	eb 22                	jmp    136b2 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13690:	90                   	nop
   13691:	eb 1f                	jmp    136b2 <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13693:	90                   	nop
   13694:	eb 1c                	jmp    136b2 <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   13696:	90                   	nop
   13697:	eb 19                	jmp    136b2 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   13699:	90                   	nop
   1369a:	eb 16                	jmp    136b2 <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   1369c:	90                   	nop
   1369d:	eb 13                	jmp    136b2 <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   1369f:	90                   	nop
   136a0:	eb 10                	jmp    136b2 <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   136a2:	90                   	nop
   136a3:	eb 0d                	jmp    136b2 <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   136a5:	90                   	nop
   136a6:	eb 0a                	jmp    136b2 <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   136a8:	90                   	nop
   136a9:	eb 07                	jmp    136b2 <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   136ab:	90                   	nop
   136ac:	eb 04                	jmp    136b2 <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   136ae:	90                   	nop
   136af:	eb 01                	jmp    136b2 <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   136b1:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   136b2:	83 ec 0c             	sub    $0xc,%esp
   136b5:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   136bb:	50                   	push   %eax
   136bc:	e8 34 65 ff ff       	call   9bf5 <lodepng_info_cleanup>
   136c1:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   136c4:	8b 45 c0             	mov    -0x40(%ebp),%eax
   136c7:	83 ec 0c             	sub    $0xc,%esp
   136ca:	50                   	push   %eax
   136cb:	e8 bf fd fe ff       	call   348f <lodepng_free>
   136d0:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   136d3:	8b 55 b0             	mov    -0x50(%ebp),%edx
   136d6:	8b 45 08             	mov    0x8(%ebp),%eax
   136d9:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   136db:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   136de:	8b 45 0c             	mov    0xc(%ebp),%eax
   136e1:	89 10                	mov    %edx,(%eax)

  return state->error;
   136e3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136e6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   136ec:	8d 65 f4             	lea    -0xc(%ebp),%esp
   136ef:	5b                   	pop    %ebx
   136f0:	5e                   	pop    %esi
   136f1:	5f                   	pop    %edi
   136f2:	5d                   	pop    %ebp
   136f3:	c3                   	ret    

000136f4 <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   136f4:	55                   	push   %ebp
   136f5:	89 e5                	mov    %esp,%ebp
   136f7:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   136fd:	83 ec 0c             	sub    $0xc,%esp
   13700:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   13706:	50                   	push   %eax
   13707:	e8 38 d0 ff ff       	call   10744 <lodepng_state_init>
   1370c:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   1370f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13712:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   13718:	8b 45 20             	mov    0x20(%ebp),%eax
   1371b:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   13721:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13724:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   1372a:	8b 45 20             	mov    0x20(%ebp),%eax
   1372d:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   13733:	83 ec 08             	sub    $0x8,%esp
   13736:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1373c:	50                   	push   %eax
   1373d:	ff 75 18             	pushl  0x18(%ebp)
   13740:	ff 75 14             	pushl  0x14(%ebp)
   13743:	ff 75 10             	pushl  0x10(%ebp)
   13746:	ff 75 0c             	pushl  0xc(%ebp)
   13749:	ff 75 08             	pushl  0x8(%ebp)
   1374c:	e8 48 f2 ff ff       	call   12999 <lodepng_encode>
   13751:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   13754:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13757:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   1375a:	83 ec 0c             	sub    $0xc,%esp
   1375d:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   13763:	50                   	push   %eax
   13764:	e8 35 d0 ff ff       	call   1079e <lodepng_state_cleanup>
   13769:	83 c4 10             	add    $0x10,%esp
  return error;
   1376c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1376f:	c9                   	leave  
   13770:	c3                   	ret    

00013771 <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13771:	55                   	push   %ebp
   13772:	89 e5                	mov    %esp,%ebp
   13774:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   13777:	83 ec 04             	sub    $0x4,%esp
   1377a:	6a 08                	push   $0x8
   1377c:	6a 06                	push   $0x6
   1377e:	ff 75 18             	pushl  0x18(%ebp)
   13781:	ff 75 14             	pushl  0x14(%ebp)
   13784:	ff 75 10             	pushl  0x10(%ebp)
   13787:	ff 75 0c             	pushl  0xc(%ebp)
   1378a:	ff 75 08             	pushl  0x8(%ebp)
   1378d:	e8 62 ff ff ff       	call   136f4 <lodepng_encode_memory>
   13792:	83 c4 20             	add    $0x20,%esp
}
   13795:	c9                   	leave  
   13796:	c3                   	ret    

00013797 <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13797:	55                   	push   %ebp
   13798:	89 e5                	mov    %esp,%ebp
   1379a:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   1379d:	83 ec 04             	sub    $0x4,%esp
   137a0:	6a 08                	push   $0x8
   137a2:	6a 02                	push   $0x2
   137a4:	ff 75 18             	pushl  0x18(%ebp)
   137a7:	ff 75 14             	pushl  0x14(%ebp)
   137aa:	ff 75 10             	pushl  0x10(%ebp)
   137ad:	ff 75 0c             	pushl  0xc(%ebp)
   137b0:	ff 75 08             	pushl  0x8(%ebp)
   137b3:	e8 3c ff ff ff       	call   136f4 <lodepng_encode_memory>
   137b8:	83 c4 20             	add    $0x20,%esp
}
   137bb:	c9                   	leave  
   137bc:	c3                   	ret    

000137bd <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   137bd:	55                   	push   %ebp
   137be:	89 e5                	mov    %esp,%ebp
   137c0:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   137c3:	83 ec 04             	sub    $0x4,%esp
   137c6:	ff 75 1c             	pushl  0x1c(%ebp)
   137c9:	ff 75 18             	pushl  0x18(%ebp)
   137cc:	ff 75 14             	pushl  0x14(%ebp)
   137cf:	ff 75 10             	pushl  0x10(%ebp)
   137d2:	ff 75 0c             	pushl  0xc(%ebp)
   137d5:	8d 45 ec             	lea    -0x14(%ebp),%eax
   137d8:	50                   	push   %eax
   137d9:	8d 45 f0             	lea    -0x10(%ebp),%eax
   137dc:	50                   	push   %eax
   137dd:	e8 12 ff ff ff       	call   136f4 <lodepng_encode_memory>
   137e2:	83 c4 20             	add    $0x20,%esp
   137e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   137e8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   137ec:	75 19                	jne    13807 <lodepng_encode_file+0x4a>
   137ee:	8b 55 ec             	mov    -0x14(%ebp),%edx
   137f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   137f4:	83 ec 04             	sub    $0x4,%esp
   137f7:	ff 75 08             	pushl  0x8(%ebp)
   137fa:	52                   	push   %edx
   137fb:	50                   	push   %eax
   137fc:	e8 36 01 ff ff       	call   3937 <lodepng_save_file>
   13801:	83 c4 10             	add    $0x10,%esp
   13804:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   13807:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1380a:	83 ec 0c             	sub    $0xc,%esp
   1380d:	50                   	push   %eax
   1380e:	e8 7c fc fe ff       	call   348f <lodepng_free>
   13813:	83 c4 10             	add    $0x10,%esp
  return error;
   13816:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13819:	c9                   	leave  
   1381a:	c3                   	ret    

0001381b <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   1381b:	55                   	push   %ebp
   1381c:	89 e5                	mov    %esp,%ebp
   1381e:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   13821:	83 ec 08             	sub    $0x8,%esp
   13824:	6a 08                	push   $0x8
   13826:	6a 06                	push   $0x6
   13828:	ff 75 14             	pushl  0x14(%ebp)
   1382b:	ff 75 10             	pushl  0x10(%ebp)
   1382e:	ff 75 0c             	pushl  0xc(%ebp)
   13831:	ff 75 08             	pushl  0x8(%ebp)
   13834:	e8 84 ff ff ff       	call   137bd <lodepng_encode_file>
   13839:	83 c4 20             	add    $0x20,%esp
}
   1383c:	c9                   	leave  
   1383d:	c3                   	ret    

0001383e <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   1383e:	55                   	push   %ebp
   1383f:	89 e5                	mov    %esp,%ebp
   13841:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   13844:	83 ec 08             	sub    $0x8,%esp
   13847:	6a 08                	push   $0x8
   13849:	6a 02                	push   $0x2
   1384b:	ff 75 14             	pushl  0x14(%ebp)
   1384e:	ff 75 10             	pushl  0x10(%ebp)
   13851:	ff 75 0c             	pushl  0xc(%ebp)
   13854:	ff 75 08             	pushl  0x8(%ebp)
   13857:	e8 61 ff ff ff       	call   137bd <lodepng_encode_file>
   1385c:	83 c4 20             	add    $0x20,%esp
}
   1385f:	c9                   	leave  
   13860:	c3                   	ret    

00013861 <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   13861:	55                   	push   %ebp
   13862:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   13864:	8b 45 08             	mov    0x8(%ebp),%eax
   13867:	50                   	push   %eax
   13868:	e8 71 49 ff ff       	call   81de <lodepng_compress_settings_init>
   1386d:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   13870:	8b 45 08             	mov    0x8(%ebp),%eax
   13873:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   1387a:	8b 45 08             	mov    0x8(%ebp),%eax
   1387d:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   13884:	8b 45 08             	mov    0x8(%ebp),%eax
   13887:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   1388e:	8b 45 08             	mov    0x8(%ebp),%eax
   13891:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   13898:	8b 45 08             	mov    0x8(%ebp),%eax
   1389b:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   138a2:	8b 45 08             	mov    0x8(%ebp),%eax
   138a5:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   138ac:	8b 45 08             	mov    0x8(%ebp),%eax
   138af:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   138b6:	90                   	nop
   138b7:	c9                   	leave  
   138b8:	c3                   	ret    

000138b9 <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   138b9:	55                   	push   %ebp
   138ba:	89 e5                	mov    %esp,%ebp
  switch(code) {
   138bc:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   138c0:	0f 87 c1 03 00 00    	ja     13c87 <lodepng_error_text+0x3ce>
   138c6:	8b 45 08             	mov    0x8(%ebp),%eax
   138c9:	c1 e0 02             	shl    $0x2,%eax
   138cc:	05 40 b5 01 00       	add    $0x1b540,%eax
   138d1:	8b 00                	mov    (%eax),%eax
   138d3:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   138d5:	b8 0c a2 01 00       	mov    $0x1a20c,%eax
   138da:	e9 ad 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   138df:	b8 29 a2 01 00       	mov    $0x1a229,%eax
   138e4:	e9 a3 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   138e9:	b8 3c a2 01 00       	mov    $0x1a23c,%eax
   138ee:	e9 99 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   138f3:	b8 74 a2 01 00       	mov    $0x1a274,%eax
   138f8:	e9 8f 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   138fd:	b8 ac a2 01 00       	mov    $0x1a2ac,%eax
   13902:	e9 85 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   13907:	b8 ac a2 01 00       	mov    $0x1a2ac,%eax
   1390c:	e9 7b 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   13911:	b8 ac a2 01 00       	mov    $0x1a2ac,%eax
   13916:	e9 71 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   1391b:	b8 dc a2 01 00       	mov    $0x1a2dc,%eax
   13920:	e9 67 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   13925:	b8 10 a3 01 00       	mov    $0x1a310,%eax
   1392a:	e9 5d 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   1392f:	b8 44 a3 01 00       	mov    $0x1a344,%eax
   13934:	e9 53 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   13939:	b8 10 a3 01 00       	mov    $0x1a310,%eax
   1393e:	e9 49 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   13943:	b8 6c a3 01 00       	mov    $0x1a36c,%eax
   13948:	e9 3f 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   1394d:	b8 a4 a3 01 00       	mov    $0x1a3a4,%eax
   13952:	e9 35 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   13957:	b8 10 a3 01 00       	mov    $0x1a310,%eax
   1395c:	e9 2b 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   13961:	b8 dc a3 01 00       	mov    $0x1a3dc,%eax
   13966:	e9 21 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   1396b:	b8 0c a4 01 00       	mov    $0x1a40c,%eax
   13970:	e9 17 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   13975:	b8 2c a4 01 00       	mov    $0x1a42c,%eax
   1397a:	e9 0d 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   1397f:	b8 58 a4 01 00       	mov    $0x1a458,%eax
   13984:	e9 03 03 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   13989:	b8 98 a4 01 00       	mov    $0x1a498,%eax
   1398e:	e9 f9 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   13993:	b8 c0 a4 01 00       	mov    $0x1a4c0,%eax
   13998:	e9 ef 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   1399d:	b8 f4 a4 01 00       	mov    $0x1a4f4,%eax
   139a2:	e9 e5 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   139a7:	b8 18 a5 01 00       	mov    $0x1a518,%eax
   139ac:	e9 db 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   139b1:	b8 50 a5 01 00       	mov    $0x1a550,%eax
   139b6:	e9 d1 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   139bb:	b8 70 a5 01 00       	mov    $0x1a570,%eax
   139c0:	e9 c7 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   139c5:	b8 8f a5 01 00       	mov    $0x1a58f,%eax
   139ca:	e9 bd 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   139cf:	b8 a9 a5 01 00       	mov    $0x1a5a9,%eax
   139d4:	e9 b3 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   139d9:	b8 c8 a5 01 00       	mov    $0x1a5c8,%eax
   139de:	e9 a9 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   139e3:	b8 04 a6 01 00       	mov    $0x1a604,%eax
   139e8:	e9 9f 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   139ed:	b8 28 a6 01 00       	mov    $0x1a628,%eax
   139f2:	e9 95 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   139f7:	b8 54 a6 01 00       	mov    $0x1a654,%eax
   139fc:	e9 8b 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   13a01:	b8 78 a6 01 00       	mov    $0x1a678,%eax
   13a06:	e9 81 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   13a0b:	b8 b8 a6 01 00       	mov    $0x1a6b8,%eax
   13a10:	e9 77 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   13a15:	b8 e8 a6 01 00       	mov    $0x1a6e8,%eax
   13a1a:	e9 6d 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   13a1f:	b8 10 a7 01 00       	mov    $0x1a710,%eax
   13a24:	e9 63 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   13a29:	b8 54 a7 01 00       	mov    $0x1a754,%eax
   13a2e:	e9 59 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   13a33:	b8 80 a7 01 00       	mov    $0x1a780,%eax
   13a38:	e9 4f 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   13a3d:	b8 b0 a7 01 00       	mov    $0x1a7b0,%eax
   13a42:	e9 45 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   13a47:	b8 d8 a7 01 00       	mov    $0x1a7d8,%eax
   13a4c:	e9 3b 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   13a51:	b8 20 a8 01 00       	mov    $0x1a820,%eax
   13a56:	e9 31 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   13a5b:	b8 20 a8 01 00       	mov    $0x1a820,%eax
   13a60:	e9 27 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   13a65:	b8 5c a8 01 00       	mov    $0x1a85c,%eax
   13a6a:	e9 1d 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   13a6f:	b8 90 a8 01 00       	mov    $0x1a890,%eax
   13a74:	e9 13 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   13a79:	b8 b3 a8 01 00       	mov    $0x1a8b3,%eax
   13a7e:	e9 09 02 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   13a83:	b8 d0 a8 01 00       	mov    $0x1a8d0,%eax
   13a88:	e9 ff 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   13a8d:	b8 0c a9 01 00       	mov    $0x1a90c,%eax
   13a92:	e9 f5 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   13a97:	b8 3c a9 01 00       	mov    $0x1a93c,%eax
   13a9c:	e9 eb 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   13aa1:	b8 88 a9 01 00       	mov    $0x1a988,%eax
   13aa6:	e9 e1 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   13aab:	b8 c0 a9 01 00       	mov    $0x1a9c0,%eax
   13ab0:	e9 d7 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   13ab5:	b8 00 aa 01 00       	mov    $0x1aa00,%eax
   13aba:	e9 cd 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   13abf:	b8 2c aa 01 00       	mov    $0x1aa2c,%eax
   13ac4:	e9 c3 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   13ac9:	b8 78 aa 01 00       	mov    $0x1aa78,%eax
   13ace:	e9 b9 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   13ad3:	b8 cc aa 01 00       	mov    $0x1aacc,%eax
   13ad8:	e9 af 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   13add:	b8 00 ab 01 00       	mov    $0x1ab00,%eax
   13ae2:	e9 a5 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   13ae7:	b8 50 ab 01 00       	mov    $0x1ab50,%eax
   13aec:	e9 9b 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   13af1:	b8 8c ab 01 00       	mov    $0x1ab8c,%eax
   13af6:	e9 91 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   13afb:	b8 ec ab 01 00       	mov    $0x1abec,%eax
   13b00:	e9 87 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   13b05:	b8 4c ac 01 00       	mov    $0x1ac4c,%eax
   13b0a:	e9 7d 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   13b0f:	b8 a8 ac 01 00       	mov    $0x1aca8,%eax
   13b14:	e9 73 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   13b19:	b8 ec ac 01 00       	mov    $0x1acec,%eax
   13b1e:	e9 69 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   13b23:	b8 28 ad 01 00       	mov    $0x1ad28,%eax
   13b28:	e9 5f 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   13b2d:	b8 85 ad 01 00       	mov    $0x1ad85,%eax
   13b32:	e9 55 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   13b37:	b8 9d ad 01 00       	mov    $0x1ad9d,%eax
   13b3c:	e9 4b 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   13b41:	b8 b8 ad 01 00       	mov    $0x1adb8,%eax
   13b46:	e9 41 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   13b4b:	b8 f4 ad 01 00       	mov    $0x1adf4,%eax
   13b50:	e9 37 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   13b55:	b8 24 ae 01 00       	mov    $0x1ae24,%eax
   13b5a:	e9 2d 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   13b5f:	b8 44 ae 01 00       	mov    $0x1ae44,%eax
   13b64:	e9 23 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   13b69:	b8 64 ae 01 00       	mov    $0x1ae64,%eax
   13b6e:	e9 19 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   13b73:	b8 84 ae 01 00       	mov    $0x1ae84,%eax
   13b78:	e9 0f 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   13b7d:	b8 a8 ae 01 00       	mov    $0x1aea8,%eax
   13b82:	e9 05 01 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   13b87:	b8 d0 ae 01 00       	mov    $0x1aed0,%eax
   13b8c:	e9 fb 00 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   13b91:	b8 2d af 01 00       	mov    $0x1af2d,%eax
   13b96:	e9 f1 00 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   13b9b:	b8 48 af 01 00       	mov    $0x1af48,%eax
   13ba0:	e9 e7 00 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   13ba5:	b8 84 af 01 00       	mov    $0x1af84,%eax
   13baa:	e9 dd 00 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   13baf:	b8 b8 af 01 00       	mov    $0x1afb8,%eax
   13bb4:	e9 d3 00 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   13bb9:	b8 0c b0 01 00       	mov    $0x1b00c,%eax
   13bbe:	e9 c9 00 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   13bc3:	b8 58 b0 01 00       	mov    $0x1b058,%eax
   13bc8:	e9 bf 00 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   13bcd:	b8 94 b0 01 00       	mov    $0x1b094,%eax
   13bd2:	e9 b5 00 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   13bd7:	b8 b8 b0 01 00       	mov    $0x1b0b8,%eax
   13bdc:	e9 ab 00 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   13be1:	b8 d8 b0 01 00       	mov    $0x1b0d8,%eax
   13be6:	e9 a1 00 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   13beb:	b8 00 b1 01 00       	mov    $0x1b100,%eax
   13bf0:	e9 97 00 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   13bf5:	b8 20 b1 01 00       	mov    $0x1b120,%eax
   13bfa:	e9 8d 00 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   13bff:	b8 4c b1 01 00       	mov    $0x1b14c,%eax
   13c04:	e9 83 00 00 00       	jmp    13c8c <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   13c09:	b8 7b b1 01 00       	mov    $0x1b17b,%eax
   13c0e:	eb 7c                	jmp    13c8c <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   13c10:	b8 93 b1 01 00       	mov    $0x1b193,%eax
   13c15:	eb 75                	jmp    13c8c <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   13c17:	b8 ab b1 01 00       	mov    $0x1b1ab,%eax
   13c1c:	eb 6e                	jmp    13c8c <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   13c1e:	b8 c3 b1 01 00       	mov    $0x1b1c3,%eax
   13c23:	eb 67                	jmp    13c8c <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   13c25:	b8 e4 b1 01 00       	mov    $0x1b1e4,%eax
   13c2a:	eb 60                	jmp    13c8c <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   13c2c:	b8 34 b2 01 00       	mov    $0x1b234,%eax
   13c31:	eb 59                	jmp    13c8c <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   13c33:	b8 88 b2 01 00       	mov    $0x1b288,%eax
   13c38:	eb 52                	jmp    13c8c <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   13c3a:	b8 dc b2 01 00       	mov    $0x1b2dc,%eax
   13c3f:	eb 4b                	jmp    13c8c <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   13c41:	b8 24 b3 01 00       	mov    $0x1b324,%eax
   13c46:	eb 44                	jmp    13c8c <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   13c48:	b8 68 b3 01 00       	mov    $0x1b368,%eax
   13c4d:	eb 3d                	jmp    13c8c <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   13c4f:	b8 84 b3 01 00       	mov    $0x1b384,%eax
   13c54:	eb 36                	jmp    13c8c <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   13c56:	b8 bc b3 01 00       	mov    $0x1b3bc,%eax
   13c5b:	eb 2f                	jmp    13c8c <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   13c5d:	b8 10 b4 01 00       	mov    $0x1b410,%eax
   13c62:	eb 28                	jmp    13c8c <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   13c64:	b8 40 b4 01 00       	mov    $0x1b440,%eax
   13c69:	eb 21                	jmp    13c8c <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   13c6b:	b8 90 b4 01 00       	mov    $0x1b490,%eax
   13c70:	eb 1a                	jmp    13c8c <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   13c72:	b8 bc b4 01 00       	mov    $0x1b4bc,%eax
   13c77:	eb 13                	jmp    13c8c <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   13c79:	b8 e8 b4 01 00       	mov    $0x1b4e8,%eax
   13c7e:	eb 0c                	jmp    13c8c <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   13c80:	b8 0c b5 01 00       	mov    $0x1b50c,%eax
   13c85:	eb 05                	jmp    13c8c <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   13c87:	b8 2b b5 01 00       	mov    $0x1b52b,%eax
}
   13c8c:	5d                   	pop    %ebp
   13c8d:	c3                   	ret    

00013c8e <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   13c8e:	55                   	push   %ebp
   13c8f:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   13c91:	8b 45 08             	mov    0x8(%ebp),%eax
   13c94:	8b 40 28             	mov    0x28(%eax),%eax
   13c97:	83 f8 01             	cmp    $0x1,%eax
   13c9a:	75 08                	jne    13ca4 <GetImage+0x16>
   13c9c:	8b 45 08             	mov    0x8(%ebp),%eax
   13c9f:	8b 40 54             	mov    0x54(%eax),%eax
   13ca2:	eb 09                	jmp    13cad <GetImage+0x1f>
   13ca4:	8b 45 08             	mov    0x8(%ebp),%eax
   13ca7:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   13cad:	5d                   	pop    %ebp
   13cae:	c3                   	ret    

00013caf <GetWidth>:

int GetWidth(Context* ctx){
   13caf:	55                   	push   %ebp
   13cb0:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   13cb2:	8b 45 08             	mov    0x8(%ebp),%eax
   13cb5:	8b 40 10             	mov    0x10(%eax),%eax
}
   13cb8:	5d                   	pop    %ebp
   13cb9:	c3                   	ret    

00013cba <GetHeight>:

int GetHeight(Context* ctx){
   13cba:	55                   	push   %ebp
   13cbb:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   13cbd:	8b 45 08             	mov    0x8(%ebp),%eax
   13cc0:	8b 40 14             	mov    0x14(%eax),%eax
}
   13cc3:	5d                   	pop    %ebp
   13cc4:	c3                   	ret    

00013cc5 <GetImageSize>:

uint GetImageSize(Context* ctx){
   13cc5:	55                   	push   %ebp
   13cc6:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   13cc8:	8b 45 08             	mov    0x8(%ebp),%eax
   13ccb:	8b 50 10             	mov    0x10(%eax),%edx
   13cce:	8b 45 08             	mov    0x8(%ebp),%eax
   13cd1:	8b 40 14             	mov    0x14(%eax),%eax
   13cd4:	0f af d0             	imul   %eax,%edx
   13cd7:	8b 45 08             	mov    0x8(%ebp),%eax
   13cda:	8b 40 28             	mov    0x28(%eax),%eax
   13cdd:	0f af c2             	imul   %edx,%eax
}
   13ce0:	5d                   	pop    %ebp
   13ce1:	c3                   	ret    

00013ce2 <_Clip>:

uchar _Clip(const int x){
   13ce2:	55                   	push   %ebp
   13ce3:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   13ce5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13ce9:	78 15                	js     13d00 <_Clip+0x1e>
   13ceb:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   13cf2:	7f 05                	jg     13cf9 <_Clip+0x17>
   13cf4:	8b 45 08             	mov    0x8(%ebp),%eax
   13cf7:	eb 0c                	jmp    13d05 <_Clip+0x23>
   13cf9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13cfe:	eb 05                	jmp    13d05 <_Clip+0x23>
   13d00:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13d05:	5d                   	pop    %ebp
   13d06:	c3                   	ret    

00013d07 <_Skip>:

void _Skip(Context* ctx, int c){
   13d07:	55                   	push   %ebp
   13d08:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   13d0a:	8b 45 08             	mov    0x8(%ebp),%eax
   13d0d:	8b 50 04             	mov    0x4(%eax),%edx
   13d10:	8b 45 0c             	mov    0xc(%ebp),%eax
   13d13:	01 c2                	add    %eax,%edx
   13d15:	8b 45 08             	mov    0x8(%ebp),%eax
   13d18:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   13d1b:	8b 45 08             	mov    0x8(%ebp),%eax
   13d1e:	8b 40 08             	mov    0x8(%eax),%eax
   13d21:	2b 45 0c             	sub    0xc(%ebp),%eax
   13d24:	89 c2                	mov    %eax,%edx
   13d26:	8b 45 08             	mov    0x8(%ebp),%eax
   13d29:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   13d2c:	8b 45 08             	mov    0x8(%ebp),%eax
   13d2f:	8b 40 0c             	mov    0xc(%eax),%eax
   13d32:	2b 45 0c             	sub    0xc(%ebp),%eax
   13d35:	89 c2                	mov    %eax,%edx
   13d37:	8b 45 08             	mov    0x8(%ebp),%eax
   13d3a:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   13d3d:	8b 45 08             	mov    0x8(%ebp),%eax
   13d40:	8b 40 08             	mov    0x8(%eax),%eax
   13d43:	85 c0                	test   %eax,%eax
   13d45:	79 09                	jns    13d50 <_Skip+0x49>
   13d47:	8b 45 08             	mov    0x8(%ebp),%eax
   13d4a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   13d50:	90                   	nop
   13d51:	5d                   	pop    %ebp
   13d52:	c3                   	ret    

00013d53 <_DecodeLength>:

void _DecodeLength(Context* ctx){
   13d53:	55                   	push   %ebp
   13d54:	89 e5                	mov    %esp,%ebp
   13d56:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   13d59:	8b 45 08             	mov    0x8(%ebp),%eax
   13d5c:	8b 40 08             	mov    0x8(%eax),%eax
   13d5f:	83 f8 01             	cmp    $0x1,%eax
   13d62:	7f 0b                	jg     13d6f <_DecodeLength+0x1c>
   13d64:	8b 45 08             	mov    0x8(%ebp),%eax
   13d67:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13d6d:	eb 45                	jmp    13db4 <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   13d6f:	8b 45 08             	mov    0x8(%ebp),%eax
   13d72:	8b 40 04             	mov    0x4(%eax),%eax
   13d75:	83 ec 0c             	sub    $0xc,%esp
   13d78:	50                   	push   %eax
   13d79:	e8 38 00 00 00       	call   13db6 <_Decode2Bytes>
   13d7e:	83 c4 10             	add    $0x10,%esp
   13d81:	89 c2                	mov    %eax,%edx
   13d83:	8b 45 08             	mov    0x8(%ebp),%eax
   13d86:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   13d89:	8b 45 08             	mov    0x8(%ebp),%eax
   13d8c:	8b 50 0c             	mov    0xc(%eax),%edx
   13d8f:	8b 45 08             	mov    0x8(%ebp),%eax
   13d92:	8b 40 08             	mov    0x8(%eax),%eax
   13d95:	39 c2                	cmp    %eax,%edx
   13d97:	7e 0b                	jle    13da4 <_DecodeLength+0x51>
   13d99:	8b 45 08             	mov    0x8(%ebp),%eax
   13d9c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13da2:	eb 10                	jmp    13db4 <_DecodeLength+0x61>
    _Skip(ctx, 2);
   13da4:	83 ec 08             	sub    $0x8,%esp
   13da7:	6a 02                	push   $0x2
   13da9:	ff 75 08             	pushl  0x8(%ebp)
   13dac:	e8 56 ff ff ff       	call   13d07 <_Skip>
   13db1:	83 c4 10             	add    $0x10,%esp
}
   13db4:	c9                   	leave  
   13db5:	c3                   	ret    

00013db6 <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   13db6:	55                   	push   %ebp
   13db7:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   13db9:	8b 45 08             	mov    0x8(%ebp),%eax
   13dbc:	0f b6 00             	movzbl (%eax),%eax
   13dbf:	0f b6 c0             	movzbl %al,%eax
   13dc2:	c1 e0 08             	shl    $0x8,%eax
   13dc5:	89 c2                	mov    %eax,%edx
   13dc7:	8b 45 08             	mov    0x8(%ebp),%eax
   13dca:	83 c0 01             	add    $0x1,%eax
   13dcd:	0f b6 00             	movzbl (%eax),%eax
   13dd0:	0f b6 c0             	movzbl %al,%eax
   13dd3:	09 d0                	or     %edx,%eax
}
   13dd5:	5d                   	pop    %ebp
   13dd6:	c3                   	ret    

00013dd7 <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   13dd7:	55                   	push   %ebp
   13dd8:	89 e5                	mov    %esp,%ebp
   13dda:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   13ddd:	8b 45 08             	mov    0x8(%ebp),%eax
   13de0:	8b 55 10             	mov    0x10(%ebp),%edx
   13de3:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   13de6:	8b 45 14             	mov    0x14(%ebp),%eax
   13de9:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   13dee:	89 c2                	mov    %eax,%edx
   13df0:	8b 45 08             	mov    0x8(%ebp),%eax
   13df3:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   13df6:	8b 45 08             	mov    0x8(%ebp),%eax
   13df9:	8b 40 08             	mov    0x8(%eax),%eax
   13dfc:	83 f8 01             	cmp    $0x1,%eax
   13dff:	7e 1d                	jle    13e1e <_DecodeJPEG+0x47>
   13e01:	8b 45 08             	mov    0x8(%ebp),%eax
   13e04:	8b 40 04             	mov    0x4(%eax),%eax
   13e07:	0f b6 00             	movzbl (%eax),%eax
   13e0a:	3c ff                	cmp    $0xff,%al
   13e0c:	75 10                	jne    13e1e <_DecodeJPEG+0x47>
   13e0e:	8b 45 08             	mov    0x8(%ebp),%eax
   13e11:	8b 40 04             	mov    0x4(%eax),%eax
   13e14:	83 c0 01             	add    $0x1,%eax
   13e17:	0f b6 00             	movzbl (%eax),%eax
   13e1a:	3c d8                	cmp    $0xd8,%al
   13e1c:	74 0a                	je     13e28 <_DecodeJPEG+0x51>
   13e1e:	b8 01 00 00 00       	mov    $0x1,%eax
   13e23:	e9 56 01 00 00       	jmp    13f7e <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   13e28:	6a 02                	push   $0x2
   13e2a:	ff 75 08             	pushl  0x8(%ebp)
   13e2d:	e8 d5 fe ff ff       	call   13d07 <_Skip>
   13e32:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   13e35:	e9 0a 01 00 00       	jmp    13f44 <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   13e3a:	8b 45 08             	mov    0x8(%ebp),%eax
   13e3d:	8b 40 08             	mov    0x8(%eax),%eax
   13e40:	85 c0                	test   %eax,%eax
   13e42:	78 0d                	js     13e51 <_DecodeJPEG+0x7a>
   13e44:	8b 45 08             	mov    0x8(%ebp),%eax
   13e47:	8b 40 04             	mov    0x4(%eax),%eax
   13e4a:	0f b6 00             	movzbl (%eax),%eax
   13e4d:	3c ff                	cmp    $0xff,%al
   13e4f:	74 0a                	je     13e5b <_DecodeJPEG+0x84>
   13e51:	b8 05 00 00 00       	mov    $0x5,%eax
   13e56:	e9 23 01 00 00       	jmp    13f7e <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   13e5b:	6a 02                	push   $0x2
   13e5d:	ff 75 08             	pushl  0x8(%ebp)
   13e60:	e8 a2 fe ff ff       	call   13d07 <_Skip>
   13e65:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   13e68:	8b 45 08             	mov    0x8(%ebp),%eax
   13e6b:	8b 40 04             	mov    0x4(%eax),%eax
   13e6e:	83 e8 01             	sub    $0x1,%eax
   13e71:	0f b6 00             	movzbl (%eax),%eax
   13e74:	0f b6 c0             	movzbl %al,%eax
   13e77:	3d da 00 00 00       	cmp    $0xda,%eax
   13e7c:	74 71                	je     13eef <_DecodeJPEG+0x118>
   13e7e:	3d da 00 00 00       	cmp    $0xda,%eax
   13e83:	7f 10                	jg     13e95 <_DecodeJPEG+0xbe>
   13e85:	3d c0 00 00 00       	cmp    $0xc0,%eax
   13e8a:	74 20                	je     13eac <_DecodeJPEG+0xd5>
   13e8c:	3d c4 00 00 00       	cmp    $0xc4,%eax
   13e91:	74 2c                	je     13ebf <_DecodeJPEG+0xe8>
   13e93:	eb 7d                	jmp    13f12 <_DecodeJPEG+0x13b>
   13e95:	3d dd 00 00 00       	cmp    $0xdd,%eax
   13e9a:	74 43                	je     13edf <_DecodeJPEG+0x108>
   13e9c:	3d fe 00 00 00       	cmp    $0xfe,%eax
   13ea1:	74 5f                	je     13f02 <_DecodeJPEG+0x12b>
   13ea3:	3d db 00 00 00       	cmp    $0xdb,%eax
   13ea8:	74 25                	je     13ecf <_DecodeJPEG+0xf8>
   13eaa:	eb 66                	jmp    13f12 <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   13eac:	83 ec 0c             	sub    $0xc,%esp
   13eaf:	ff 75 08             	pushl  0x8(%ebp)
   13eb2:	e8 c9 00 00 00       	call   13f80 <_DecodeSOF>
   13eb7:	83 c4 10             	add    $0x10,%esp
   13eba:	e9 85 00 00 00       	jmp    13f44 <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   13ebf:	83 ec 0c             	sub    $0xc,%esp
   13ec2:	ff 75 08             	pushl  0x8(%ebp)
   13ec5:	e8 28 05 00 00       	call   143f2 <_DecodeDHT>
   13eca:	83 c4 10             	add    $0x10,%esp
   13ecd:	eb 75                	jmp    13f44 <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   13ecf:	83 ec 0c             	sub    $0xc,%esp
   13ed2:	ff 75 08             	pushl  0x8(%ebp)
   13ed5:	e8 05 07 00 00       	call   145df <_DecodeDQT>
   13eda:	83 c4 10             	add    $0x10,%esp
   13edd:	eb 65                	jmp    13f44 <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   13edf:	83 ec 0c             	sub    $0xc,%esp
   13ee2:	ff 75 08             	pushl  0x8(%ebp)
   13ee5:	e8 ff 07 00 00       	call   146e9 <_DecodeDRI>
   13eea:	83 c4 10             	add    $0x10,%esp
   13eed:	eb 55                	jmp    13f44 <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   13eef:	83 ec 08             	sub    $0x8,%esp
   13ef2:	ff 75 0c             	pushl  0xc(%ebp)
   13ef5:	ff 75 08             	pushl  0x8(%ebp)
   13ef8:	e8 56 08 00 00       	call   14753 <_DecodeSOS>
   13efd:	83 c4 10             	add    $0x10,%esp
   13f00:	eb 42                	jmp    13f44 <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   13f02:	83 ec 0c             	sub    $0xc,%esp
   13f05:	ff 75 08             	pushl  0x8(%ebp)
   13f08:	e8 a8 15 00 00       	call   154b5 <_SkipMarker>
   13f0d:	83 c4 10             	add    $0x10,%esp
   13f10:	eb 32                	jmp    13f44 <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   13f12:	8b 45 08             	mov    0x8(%ebp),%eax
   13f15:	8b 40 04             	mov    0x4(%eax),%eax
   13f18:	83 e8 01             	sub    $0x1,%eax
   13f1b:	0f b6 00             	movzbl (%eax),%eax
   13f1e:	0f b6 c0             	movzbl %al,%eax
   13f21:	25 f0 00 00 00       	and    $0xf0,%eax
   13f26:	3d e0 00 00 00       	cmp    $0xe0,%eax
   13f2b:	75 10                	jne    13f3d <_DecodeJPEG+0x166>
   13f2d:	83 ec 0c             	sub    $0xc,%esp
   13f30:	ff 75 08             	pushl  0x8(%ebp)
   13f33:	e8 7d 15 00 00       	call   154b5 <_SkipMarker>
   13f38:	83 c4 10             	add    $0x10,%esp
   13f3b:	eb 07                	jmp    13f44 <_DecodeJPEG+0x16d>
                else return Unsupported;
   13f3d:	b8 02 00 00 00       	mov    $0x2,%eax
   13f42:	eb 3a                	jmp    13f7e <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   13f44:	8b 45 08             	mov    0x8(%ebp),%eax
   13f47:	8b 00                	mov    (%eax),%eax
   13f49:	85 c0                	test   %eax,%eax
   13f4b:	0f 84 e9 fe ff ff    	je     13e3a <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   13f51:	8b 45 08             	mov    0x8(%ebp),%eax
   13f54:	8b 00                	mov    (%eax),%eax
   13f56:	83 f8 06             	cmp    $0x6,%eax
   13f59:	74 07                	je     13f62 <_DecodeJPEG+0x18b>
   13f5b:	8b 45 08             	mov    0x8(%ebp),%eax
   13f5e:	8b 00                	mov    (%eax),%eax
   13f60:	eb 1c                	jmp    13f7e <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   13f62:	8b 45 08             	mov    0x8(%ebp),%eax
   13f65:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   13f6b:	83 ec 0c             	sub    $0xc,%esp
   13f6e:	ff 75 08             	pushl  0x8(%ebp)
   13f71:	e8 6b 15 00 00       	call   154e1 <_Convert>
   13f76:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   13f79:	8b 45 08             	mov    0x8(%ebp),%eax
   13f7c:	8b 00                	mov    (%eax),%eax
 }
   13f7e:	c9                   	leave  
   13f7f:	c3                   	ret    

00013f80 <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   13f80:	55                   	push   %ebp
   13f81:	89 e5                	mov    %esp,%ebp
   13f83:	53                   	push   %ebx
   13f84:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   13f87:	83 ec 0c             	sub    $0xc,%esp
   13f8a:	ff 75 08             	pushl  0x8(%ebp)
   13f8d:	e8 c1 fd ff ff       	call   13d53 <_DecodeLength>
   13f92:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   13f95:	8b 45 08             	mov    0x8(%ebp),%eax
   13f98:	8b 00                	mov    (%eax),%eax
   13f9a:	85 c0                	test   %eax,%eax
   13f9c:	0f 85 4a 04 00 00    	jne    143ec <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   13fa2:	8b 45 08             	mov    0x8(%ebp),%eax
   13fa5:	8b 40 0c             	mov    0xc(%eax),%eax
   13fa8:	83 f8 08             	cmp    $0x8,%eax
   13fab:	7f 0e                	jg     13fbb <_DecodeSOF+0x3b>
   13fad:	8b 45 08             	mov    0x8(%ebp),%eax
   13fb0:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13fb6:	e9 32 04 00 00       	jmp    143ed <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   13fbb:	8b 45 08             	mov    0x8(%ebp),%eax
   13fbe:	8b 40 04             	mov    0x4(%eax),%eax
   13fc1:	0f b6 00             	movzbl (%eax),%eax
   13fc4:	3c 08                	cmp    $0x8,%al
   13fc6:	74 0e                	je     13fd6 <_DecodeSOF+0x56>
   13fc8:	8b 45 08             	mov    0x8(%ebp),%eax
   13fcb:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   13fd1:	e9 17 04 00 00       	jmp    143ed <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   13fd6:	8b 45 08             	mov    0x8(%ebp),%eax
   13fd9:	8b 40 04             	mov    0x4(%eax),%eax
   13fdc:	83 c0 01             	add    $0x1,%eax
   13fdf:	83 ec 0c             	sub    $0xc,%esp
   13fe2:	50                   	push   %eax
   13fe3:	e8 ce fd ff ff       	call   13db6 <_Decode2Bytes>
   13fe8:	83 c4 10             	add    $0x10,%esp
   13feb:	89 c2                	mov    %eax,%edx
   13fed:	8b 45 08             	mov    0x8(%ebp),%eax
   13ff0:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   13ff3:	8b 45 08             	mov    0x8(%ebp),%eax
   13ff6:	8b 40 04             	mov    0x4(%eax),%eax
   13ff9:	83 c0 03             	add    $0x3,%eax
   13ffc:	83 ec 0c             	sub    $0xc,%esp
   13fff:	50                   	push   %eax
   14000:	e8 b1 fd ff ff       	call   13db6 <_Decode2Bytes>
   14005:	83 c4 10             	add    $0x10,%esp
   14008:	89 c2                	mov    %eax,%edx
   1400a:	8b 45 08             	mov    0x8(%ebp),%eax
   1400d:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   14010:	8b 45 08             	mov    0x8(%ebp),%eax
   14013:	8b 40 04             	mov    0x4(%eax),%eax
   14016:	83 c0 05             	add    $0x5,%eax
   14019:	0f b6 00             	movzbl (%eax),%eax
   1401c:	0f b6 d0             	movzbl %al,%edx
   1401f:	8b 45 08             	mov    0x8(%ebp),%eax
   14022:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   14025:	83 ec 08             	sub    $0x8,%esp
   14028:	6a 06                	push   $0x6
   1402a:	ff 75 08             	pushl  0x8(%ebp)
   1402d:	e8 d5 fc ff ff       	call   13d07 <_Skip>
   14032:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   14035:	8b 45 08             	mov    0x8(%ebp),%eax
   14038:	8b 40 28             	mov    0x28(%eax),%eax
   1403b:	83 f8 01             	cmp    $0x1,%eax
   1403e:	74 13                	je     14053 <_DecodeSOF+0xd3>
   14040:	83 f8 03             	cmp    $0x3,%eax
   14043:	74 0e                	je     14053 <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   14045:	8b 45 08             	mov    0x8(%ebp),%eax
   14048:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1404e:	e9 9a 03 00 00       	jmp    143ed <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   14053:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   14054:	8b 45 08             	mov    0x8(%ebp),%eax
   14057:	8b 48 0c             	mov    0xc(%eax),%ecx
   1405a:	8b 45 08             	mov    0x8(%ebp),%eax
   1405d:	8b 50 28             	mov    0x28(%eax),%edx
   14060:	89 d0                	mov    %edx,%eax
   14062:	01 c0                	add    %eax,%eax
   14064:	01 d0                	add    %edx,%eax
   14066:	39 c1                	cmp    %eax,%ecx
   14068:	7d 0e                	jge    14078 <_DecodeSOF+0xf8>
   1406a:	8b 45 08             	mov    0x8(%ebp),%eax
   1406d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14073:	e9 75 03 00 00       	jmp    143ed <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   14078:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1407f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14086:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1408d:	8b 45 08             	mov    0x8(%ebp),%eax
   14090:	83 c0 2c             	add    $0x2c,%eax
   14093:	89 45 e8             	mov    %eax,-0x18(%ebp)
   14096:	e9 50 01 00 00       	jmp    141eb <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   1409b:	8b 45 08             	mov    0x8(%ebp),%eax
   1409e:	8b 40 04             	mov    0x4(%eax),%eax
   140a1:	0f b6 00             	movzbl (%eax),%eax
   140a4:	0f b6 d0             	movzbl %al,%edx
   140a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140aa:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   140ac:	8b 45 08             	mov    0x8(%ebp),%eax
   140af:	8b 40 04             	mov    0x4(%eax),%eax
   140b2:	83 c0 01             	add    $0x1,%eax
   140b5:	0f b6 00             	movzbl (%eax),%eax
   140b8:	c0 e8 04             	shr    $0x4,%al
   140bb:	0f b6 d0             	movzbl %al,%edx
   140be:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140c1:	89 50 04             	mov    %edx,0x4(%eax)
   140c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140c7:	8b 40 04             	mov    0x4(%eax),%eax
   140ca:	85 c0                	test   %eax,%eax
   140cc:	75 0e                	jne    140dc <_DecodeSOF+0x15c>
   140ce:	8b 45 08             	mov    0x8(%ebp),%eax
   140d1:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   140d7:	e9 11 03 00 00       	jmp    143ed <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   140dc:	8b 45 08             	mov    0x8(%ebp),%eax
   140df:	8b 40 04             	mov    0x4(%eax),%eax
   140e2:	83 c0 01             	add    $0x1,%eax
   140e5:	0f b6 00             	movzbl (%eax),%eax
   140e8:	0f b6 c0             	movzbl %al,%eax
   140eb:	83 e0 0f             	and    $0xf,%eax
   140ee:	89 c2                	mov    %eax,%edx
   140f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140f3:	89 50 08             	mov    %edx,0x8(%eax)
   140f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   140f9:	8b 40 08             	mov    0x8(%eax),%eax
   140fc:	85 c0                	test   %eax,%eax
   140fe:	75 0e                	jne    1410e <_DecodeSOF+0x18e>
   14100:	8b 45 08             	mov    0x8(%ebp),%eax
   14103:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14109:	e9 df 02 00 00       	jmp    143ed <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   1410e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14111:	8b 50 04             	mov    0x4(%eax),%edx
   14114:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14117:	8b 40 04             	mov    0x4(%eax),%eax
   1411a:	83 e8 01             	sub    $0x1,%eax
   1411d:	21 d0                	and    %edx,%eax
   1411f:	85 c0                	test   %eax,%eax
   14121:	74 0e                	je     14131 <_DecodeSOF+0x1b1>
   14123:	8b 45 08             	mov    0x8(%ebp),%eax
   14126:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1412c:	e9 bc 02 00 00       	jmp    143ed <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   14131:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14134:	8b 50 08             	mov    0x8(%eax),%edx
   14137:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1413a:	8b 40 08             	mov    0x8(%eax),%eax
   1413d:	83 e8 01             	sub    $0x1,%eax
   14140:	21 d0                	and    %edx,%eax
   14142:	85 c0                	test   %eax,%eax
   14144:	74 0e                	je     14154 <_DecodeSOF+0x1d4>
   14146:	8b 45 08             	mov    0x8(%ebp),%eax
   14149:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1414f:	e9 99 02 00 00       	jmp    143ed <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   14154:	8b 45 08             	mov    0x8(%ebp),%eax
   14157:	8b 40 04             	mov    0x4(%eax),%eax
   1415a:	83 c0 02             	add    $0x2,%eax
   1415d:	0f b6 00             	movzbl (%eax),%eax
   14160:	0f b6 d0             	movzbl %al,%edx
   14163:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14166:	89 50 18             	mov    %edx,0x18(%eax)
   14169:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1416c:	8b 40 18             	mov    0x18(%eax),%eax
   1416f:	25 fc 00 00 00       	and    $0xfc,%eax
   14174:	85 c0                	test   %eax,%eax
   14176:	74 0e                	je     14186 <_DecodeSOF+0x206>
   14178:	8b 45 08             	mov    0x8(%ebp),%eax
   1417b:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14181:	e9 67 02 00 00       	jmp    143ed <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   14186:	83 ec 08             	sub    $0x8,%esp
   14189:	6a 03                	push   $0x3
   1418b:	ff 75 08             	pushl  0x8(%ebp)
   1418e:	e8 74 fb ff ff       	call   13d07 <_Skip>
   14193:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   14196:	8b 45 08             	mov    0x8(%ebp),%eax
   14199:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   1419f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141a2:	8b 40 18             	mov    0x18(%eax),%eax
   141a5:	bb 01 00 00 00       	mov    $0x1,%ebx
   141aa:	89 c1                	mov    %eax,%ecx
   141ac:	d3 e3                	shl    %cl,%ebx
   141ae:	89 d8                	mov    %ebx,%eax
   141b0:	09 c2                	or     %eax,%edx
   141b2:	8b 45 08             	mov    0x8(%ebp),%eax
   141b5:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   141bb:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141be:	8b 40 04             	mov    0x4(%eax),%eax
   141c1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   141c4:	7e 09                	jle    141cf <_DecodeSOF+0x24f>
   141c6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141c9:	8b 40 04             	mov    0x4(%eax),%eax
   141cc:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   141cf:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141d2:	8b 40 08             	mov    0x8(%eax),%eax
   141d5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   141d8:	7e 09                	jle    141e3 <_DecodeSOF+0x263>
   141da:	8b 45 e8             	mov    -0x18(%ebp),%eax
   141dd:	8b 40 08             	mov    0x8(%eax),%eax
   141e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   141e3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   141e7:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   141eb:	8b 45 08             	mov    0x8(%ebp),%eax
   141ee:	8b 40 28             	mov    0x28(%eax),%eax
   141f1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   141f4:	0f 8f a1 fe ff ff    	jg     1409b <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   141fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
   141fd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   14204:	8b 45 08             	mov    0x8(%ebp),%eax
   14207:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   1420a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1420d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   14214:	8b 45 08             	mov    0x8(%ebp),%eax
   14217:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   1421a:	8b 45 08             	mov    0x8(%ebp),%eax
   1421d:	8b 50 10             	mov    0x10(%eax),%edx
   14220:	8b 45 08             	mov    0x8(%ebp),%eax
   14223:	8b 40 20             	mov    0x20(%eax),%eax
   14226:	01 d0                	add    %edx,%eax
   14228:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1422b:	8b 45 08             	mov    0x8(%ebp),%eax
   1422e:	8b 58 20             	mov    0x20(%eax),%ebx
   14231:	89 c8                	mov    %ecx,%eax
   14233:	99                   	cltd   
   14234:	f7 fb                	idiv   %ebx
   14236:	89 c2                	mov    %eax,%edx
   14238:	8b 45 08             	mov    0x8(%ebp),%eax
   1423b:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   1423e:	8b 45 08             	mov    0x8(%ebp),%eax
   14241:	8b 50 14             	mov    0x14(%eax),%edx
   14244:	8b 45 08             	mov    0x8(%ebp),%eax
   14247:	8b 40 24             	mov    0x24(%eax),%eax
   1424a:	01 d0                	add    %edx,%eax
   1424c:	8d 48 ff             	lea    -0x1(%eax),%ecx
   1424f:	8b 45 08             	mov    0x8(%ebp),%eax
   14252:	8b 58 24             	mov    0x24(%eax),%ebx
   14255:	89 c8                	mov    %ecx,%eax
   14257:	99                   	cltd   
   14258:	f7 fb                	idiv   %ebx
   1425a:	89 c2                	mov    %eax,%edx
   1425c:	8b 45 08             	mov    0x8(%ebp),%eax
   1425f:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   14262:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14269:	8b 45 08             	mov    0x8(%ebp),%eax
   1426c:	83 c0 2c             	add    $0x2c,%eax
   1426f:	89 45 e8             	mov    %eax,-0x18(%ebp)
   14272:	e9 fd 00 00 00       	jmp    14374 <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   14277:	8b 45 08             	mov    0x8(%ebp),%eax
   1427a:	8b 50 10             	mov    0x10(%eax),%edx
   1427d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14280:	8b 40 04             	mov    0x4(%eax),%eax
   14283:	0f af d0             	imul   %eax,%edx
   14286:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14289:	01 d0                	add    %edx,%eax
   1428b:	83 e8 01             	sub    $0x1,%eax
   1428e:	99                   	cltd   
   1428f:	f7 7d ec             	idivl  -0x14(%ebp)
   14292:	89 c2                	mov    %eax,%edx
   14294:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14297:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   1429a:	8b 45 08             	mov    0x8(%ebp),%eax
   1429d:	8b 50 14             	mov    0x14(%eax),%edx
   142a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142a3:	8b 40 08             	mov    0x8(%eax),%eax
   142a6:	0f af d0             	imul   %eax,%edx
   142a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   142ac:	01 d0                	add    %edx,%eax
   142ae:	83 e8 01             	sub    $0x1,%eax
   142b1:	99                   	cltd   
   142b2:	f7 7d f0             	idivl  -0x10(%ebp)
   142b5:	89 c2                	mov    %eax,%edx
   142b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142ba:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   142bd:	8b 45 08             	mov    0x8(%ebp),%eax
   142c0:	8b 50 18             	mov    0x18(%eax),%edx
   142c3:	8b 45 08             	mov    0x8(%ebp),%eax
   142c6:	8b 40 20             	mov    0x20(%eax),%eax
   142c9:	0f af d0             	imul   %eax,%edx
   142cc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142cf:	8b 40 04             	mov    0x4(%eax),%eax
   142d2:	0f af c2             	imul   %edx,%eax
   142d5:	99                   	cltd   
   142d6:	f7 7d ec             	idivl  -0x14(%ebp)
   142d9:	89 c2                	mov    %eax,%edx
   142db:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142de:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   142e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142e4:	8b 40 0c             	mov    0xc(%eax),%eax
   142e7:	83 f8 02             	cmp    $0x2,%eax
   142ea:	7f 0b                	jg     142f7 <_DecodeSOF+0x377>
   142ec:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142ef:	8b 40 04             	mov    0x4(%eax),%eax
   142f2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   142f5:	75 16                	jne    1430d <_DecodeSOF+0x38d>
   142f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142fa:	8b 40 10             	mov    0x10(%eax),%eax
   142fd:	83 f8 02             	cmp    $0x2,%eax
   14300:	7f 19                	jg     1431b <_DecodeSOF+0x39b>
   14302:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14305:	8b 40 08             	mov    0x8(%eax),%eax
   14308:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   1430b:	74 0e                	je     1431b <_DecodeSOF+0x39b>
   1430d:	8b 45 08             	mov    0x8(%ebp),%eax
   14310:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14316:	e9 d2 00 00 00       	jmp    143ed <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   1431b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1431e:	8b 48 14             	mov    0x14(%eax),%ecx
   14321:	8b 45 08             	mov    0x8(%ebp),%eax
   14324:	8b 50 1c             	mov    0x1c(%eax),%edx
   14327:	8b 45 08             	mov    0x8(%ebp),%eax
   1432a:	8b 40 24             	mov    0x24(%eax),%eax
   1432d:	0f af d0             	imul   %eax,%edx
   14330:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14333:	8b 40 08             	mov    0x8(%eax),%eax
   14336:	0f af c2             	imul   %edx,%eax
   14339:	99                   	cltd   
   1433a:	f7 7d f0             	idivl  -0x10(%ebp)
   1433d:	0f af c1             	imul   %ecx,%eax
   14340:	83 ec 0c             	sub    $0xc,%esp
   14343:	50                   	push   %eax
   14344:	e8 45 c5 fe ff       	call   88e <malloc>
   14349:	83 c4 10             	add    $0x10,%esp
   1434c:	89 c2                	mov    %eax,%edx
   1434e:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14351:	89 50 28             	mov    %edx,0x28(%eax)
   14354:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14357:	8b 40 28             	mov    0x28(%eax),%eax
   1435a:	85 c0                	test   %eax,%eax
   1435c:	75 0e                	jne    1436c <_DecodeSOF+0x3ec>
   1435e:	8b 45 08             	mov    0x8(%ebp),%eax
   14361:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   14367:	e9 81 00 00 00       	jmp    143ed <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   1436c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14370:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   14374:	8b 45 08             	mov    0x8(%ebp),%eax
   14377:	8b 40 28             	mov    0x28(%eax),%eax
   1437a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1437d:	0f 8f f4 fe ff ff    	jg     14277 <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   14383:	8b 45 08             	mov    0x8(%ebp),%eax
   14386:	8b 40 28             	mov    0x28(%eax),%eax
   14389:	83 f8 03             	cmp    $0x3,%eax
   1438c:	75 47                	jne    143d5 <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   1438e:	8b 45 08             	mov    0x8(%ebp),%eax
   14391:	8b 50 10             	mov    0x10(%eax),%edx
   14394:	8b 45 08             	mov    0x8(%ebp),%eax
   14397:	8b 40 14             	mov    0x14(%eax),%eax
   1439a:	0f af d0             	imul   %eax,%edx
   1439d:	8b 45 08             	mov    0x8(%ebp),%eax
   143a0:	8b 40 28             	mov    0x28(%eax),%eax
   143a3:	0f af c2             	imul   %edx,%eax
   143a6:	83 ec 0c             	sub    $0xc,%esp
   143a9:	50                   	push   %eax
   143aa:	e8 df c4 fe ff       	call   88e <malloc>
   143af:	83 c4 10             	add    $0x10,%esp
   143b2:	89 c2                	mov    %eax,%edx
   143b4:	8b 45 08             	mov    0x8(%ebp),%eax
   143b7:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   143bd:	8b 45 08             	mov    0x8(%ebp),%eax
   143c0:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   143c6:	85 c0                	test   %eax,%eax
   143c8:	75 0b                	jne    143d5 <_DecodeSOF+0x455>
   143ca:	8b 45 08             	mov    0x8(%ebp),%eax
   143cd:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   143d3:	eb 18                	jmp    143ed <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   143d5:	8b 45 08             	mov    0x8(%ebp),%eax
   143d8:	8b 40 0c             	mov    0xc(%eax),%eax
   143db:	83 ec 08             	sub    $0x8,%esp
   143de:	50                   	push   %eax
   143df:	ff 75 08             	pushl  0x8(%ebp)
   143e2:	e8 20 f9 ff ff       	call   13d07 <_Skip>
   143e7:	83 c4 10             	add    $0x10,%esp
   143ea:	eb 01                	jmp    143ed <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   143ec:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   143ed:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   143f0:	c9                   	leave  
   143f1:	c3                   	ret    

000143f2 <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   143f2:	55                   	push   %ebp
   143f3:	89 e5                	mov    %esp,%ebp
   143f5:	53                   	push   %ebx
   143f6:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   143f9:	83 ec 0c             	sub    $0xc,%esp
   143fc:	ff 75 08             	pushl  0x8(%ebp)
   143ff:	e8 4f f9 ff ff       	call   13d53 <_DecodeLength>
   14404:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14407:	8b 45 08             	mov    0x8(%ebp),%eax
   1440a:	8b 00                	mov    (%eax),%eax
   1440c:	85 c0                	test   %eax,%eax
   1440e:	0f 85 c5 01 00 00    	jne    145d9 <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   14414:	e9 9c 01 00 00       	jmp    145b5 <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   14419:	8b 45 08             	mov    0x8(%ebp),%eax
   1441c:	8b 40 04             	mov    0x4(%eax),%eax
   1441f:	0f b6 00             	movzbl (%eax),%eax
   14422:	0f b6 c0             	movzbl %al,%eax
   14425:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   14428:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1442b:	25 ec 00 00 00       	and    $0xec,%eax
   14430:	85 c0                	test   %eax,%eax
   14432:	74 0e                	je     14442 <_DecodeDHT+0x50>
   14434:	8b 45 08             	mov    0x8(%ebp),%eax
   14437:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1443d:	e9 98 01 00 00       	jmp    145da <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   14442:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14445:	83 e0 02             	and    $0x2,%eax
   14448:	85 c0                	test   %eax,%eax
   1444a:	74 0e                	je     1445a <_DecodeDHT+0x68>
   1444c:	8b 45 08             	mov    0x8(%ebp),%eax
   1444f:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14455:	e9 80 01 00 00       	jmp    145da <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   1445a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1445d:	c1 f8 03             	sar    $0x3,%eax
   14460:	0b 45 f4             	or     -0xc(%ebp),%eax
   14463:	83 e0 03             	and    $0x3,%eax
   14466:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   14469:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14470:	eb 1c                	jmp    1448e <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   14472:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14475:	8d 50 ff             	lea    -0x1(%eax),%edx
   14478:	8b 45 08             	mov    0x8(%ebp),%eax
   1447b:	8b 48 04             	mov    0x4(%eax),%ecx
   1447e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14481:	01 c8                	add    %ecx,%eax
   14483:	0f b6 00             	movzbl (%eax),%eax
   14486:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   1448a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1448e:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   14492:	7e de                	jle    14472 <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   14494:	83 ec 08             	sub    $0x8,%esp
   14497:	6a 11                	push   $0x11
   14499:	ff 75 08             	pushl  0x8(%ebp)
   1449c:	e8 66 f8 ff ff       	call   13d07 <_Skip>
   144a1:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   144a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   144a7:	c1 e0 11             	shl    $0x11,%eax
   144aa:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   144b0:	8b 45 08             	mov    0x8(%ebp),%eax
   144b3:	01 d0                	add    %edx,%eax
   144b5:	83 c0 08             	add    $0x8,%eax
   144b8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   144bb:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   144c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   144c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   144c8:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   144cf:	e9 be 00 00 00       	jmp    14592 <_DecodeDHT+0x1a0>
            spread >>= 1;
   144d4:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   144d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   144da:	83 e8 01             	sub    $0x1,%eax
   144dd:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   144e2:	0f b6 c0             	movzbl %al,%eax
   144e5:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   144e8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   144ec:	0f 84 9b 00 00 00    	je     1458d <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   144f2:	8b 45 08             	mov    0x8(%ebp),%eax
   144f5:	8b 40 0c             	mov    0xc(%eax),%eax
   144f8:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   144fb:	7d 0e                	jge    1450b <_DecodeDHT+0x119>
   144fd:	8b 45 08             	mov    0x8(%ebp),%eax
   14500:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14506:	e9 cf 00 00 00       	jmp    145da <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   1450b:	b8 10 00 00 00       	mov    $0x10,%eax
   14510:	2b 45 f0             	sub    -0x10(%ebp),%eax
   14513:	8b 55 e0             	mov    -0x20(%ebp),%edx
   14516:	89 c1                	mov    %eax,%ecx
   14518:	d3 e2                	shl    %cl,%edx
   1451a:	89 d0                	mov    %edx,%eax
   1451c:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   1451f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   14523:	79 0e                	jns    14533 <_DecodeDHT+0x141>
   14525:	8b 45 08             	mov    0x8(%ebp),%eax
   14528:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1452e:	e9 a7 00 00 00       	jmp    145da <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   14533:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1453a:	eb 36                	jmp    14572 <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   1453c:	8b 45 08             	mov    0x8(%ebp),%eax
   1453f:	8b 50 04             	mov    0x4(%eax),%edx
   14542:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14545:	01 d0                	add    %edx,%eax
   14547:	0f b6 00             	movzbl (%eax),%eax
   1454a:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   1454c:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   1454f:	eb 14                	jmp    14565 <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   14551:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14554:	89 c2                	mov    %eax,%edx
   14556:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14559:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   1455b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1455e:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   14561:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   14565:	89 d8                	mov    %ebx,%eax
   14567:	8d 58 ff             	lea    -0x1(%eax),%ebx
   1456a:	85 c0                	test   %eax,%eax
   1456c:	75 e3                	jne    14551 <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   1456e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14572:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14575:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   14578:	7c c2                	jl     1453c <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   1457a:	83 ec 08             	sub    $0x8,%esp
   1457d:	ff 75 e0             	pushl  -0x20(%ebp)
   14580:	ff 75 08             	pushl  0x8(%ebp)
   14583:	e8 7f f7 ff ff       	call   13d07 <_Skip>
   14588:	83 c4 10             	add    $0x10,%esp
   1458b:	eb 01                	jmp    1458e <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   1458d:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   1458e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14592:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   14596:	0f 8e 38 ff ff ff    	jle    144d4 <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   1459c:	eb 0a                	jmp    145a8 <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   1459e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   145a1:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   145a4:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   145a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   145ab:	8d 50 ff             	lea    -0x1(%eax),%edx
   145ae:	89 55 ec             	mov    %edx,-0x14(%ebp)
   145b1:	85 c0                	test   %eax,%eax
   145b3:	75 e9                	jne    1459e <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   145b5:	8b 45 08             	mov    0x8(%ebp),%eax
   145b8:	8b 40 0c             	mov    0xc(%eax),%eax
   145bb:	83 f8 10             	cmp    $0x10,%eax
   145be:	0f 8f 55 fe ff ff    	jg     14419 <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   145c4:	8b 45 08             	mov    0x8(%ebp),%eax
   145c7:	8b 40 0c             	mov    0xc(%eax),%eax
   145ca:	85 c0                	test   %eax,%eax
   145cc:	74 0c                	je     145da <_DecodeDHT+0x1e8>
   145ce:	8b 45 08             	mov    0x8(%ebp),%eax
   145d1:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   145d7:	eb 01                	jmp    145da <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   145d9:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   145da:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   145dd:	c9                   	leave  
   145de:	c3                   	ret    

000145df <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   145df:	55                   	push   %ebp
   145e0:	89 e5                	mov    %esp,%ebp
   145e2:	53                   	push   %ebx
   145e3:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   145e6:	83 ec 0c             	sub    $0xc,%esp
   145e9:	ff 75 08             	pushl  0x8(%ebp)
   145ec:	e8 62 f7 ff ff       	call   13d53 <_DecodeLength>
   145f1:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   145f4:	8b 45 08             	mov    0x8(%ebp),%eax
   145f7:	8b 00                	mov    (%eax),%eax
   145f9:	85 c0                	test   %eax,%eax
   145fb:	0f 85 e2 00 00 00    	jne    146e3 <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   14601:	e9 b8 00 00 00       	jmp    146be <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   14606:	8b 45 08             	mov    0x8(%ebp),%eax
   14609:	8b 40 04             	mov    0x4(%eax),%eax
   1460c:	0f b6 00             	movzbl (%eax),%eax
   1460f:	0f b6 c0             	movzbl %al,%eax
   14612:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   14615:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14618:	25 ec 00 00 00       	and    $0xec,%eax
   1461d:	85 c0                	test   %eax,%eax
   1461f:	74 0e                	je     1462f <_DecodeDQT+0x50>
   14621:	8b 45 08             	mov    0x8(%ebp),%eax
   14624:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1462a:	e9 b5 00 00 00       	jmp    146e4 <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   1462f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14632:	83 e0 10             	and    $0x10,%eax
   14635:	85 c0                	test   %eax,%eax
   14637:	74 0e                	je     14647 <_DecodeDQT+0x68>
   14639:	8b 45 08             	mov    0x8(%ebp),%eax
   1463c:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14642:	e9 9d 00 00 00       	jmp    146e4 <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   14647:	8b 45 08             	mov    0x8(%ebp),%eax
   1464a:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   14650:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14653:	bb 01 00 00 00       	mov    $0x1,%ebx
   14658:	89 c1                	mov    %eax,%ecx
   1465a:	d3 e3                	shl    %cl,%ebx
   1465c:	89 d8                	mov    %ebx,%eax
   1465e:	09 c2                	or     %eax,%edx
   14660:	8b 45 08             	mov    0x8(%ebp),%eax
   14663:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   14669:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1466c:	c1 e0 06             	shl    $0x6,%eax
   1466f:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   14675:	8b 45 08             	mov    0x8(%ebp),%eax
   14678:	01 d0                	add    %edx,%eax
   1467a:	83 c0 08             	add    $0x8,%eax
   1467d:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   14680:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14687:	eb 1f                	jmp    146a8 <_DecodeDQT+0xc9>
   14689:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1468c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1468f:	01 c2                	add    %eax,%edx
   14691:	8b 45 08             	mov    0x8(%ebp),%eax
   14694:	8b 40 04             	mov    0x4(%eax),%eax
   14697:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1469a:	83 c1 01             	add    $0x1,%ecx
   1469d:	01 c8                	add    %ecx,%eax
   1469f:	0f b6 00             	movzbl (%eax),%eax
   146a2:	88 02                	mov    %al,(%edx)
   146a4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   146a8:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   146ac:	7e db                	jle    14689 <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   146ae:	83 ec 08             	sub    $0x8,%esp
   146b1:	6a 41                	push   $0x41
   146b3:	ff 75 08             	pushl  0x8(%ebp)
   146b6:	e8 4c f6 ff ff       	call   13d07 <_Skip>
   146bb:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   146be:	8b 45 08             	mov    0x8(%ebp),%eax
   146c1:	8b 40 0c             	mov    0xc(%eax),%eax
   146c4:	83 f8 40             	cmp    $0x40,%eax
   146c7:	0f 8f 39 ff ff ff    	jg     14606 <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   146cd:	8b 45 08             	mov    0x8(%ebp),%eax
   146d0:	8b 40 0c             	mov    0xc(%eax),%eax
   146d3:	85 c0                	test   %eax,%eax
   146d5:	74 0d                	je     146e4 <_DecodeDQT+0x105>
   146d7:	8b 45 08             	mov    0x8(%ebp),%eax
   146da:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146e0:	90                   	nop
   146e1:	eb 01                	jmp    146e4 <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   146e3:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   146e4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   146e7:	c9                   	leave  
   146e8:	c3                   	ret    

000146e9 <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   146e9:	55                   	push   %ebp
   146ea:	89 e5                	mov    %esp,%ebp
   146ec:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   146ef:	83 ec 0c             	sub    $0xc,%esp
   146f2:	ff 75 08             	pushl  0x8(%ebp)
   146f5:	e8 59 f6 ff ff       	call   13d53 <_DecodeLength>
   146fa:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   146fd:	8b 45 08             	mov    0x8(%ebp),%eax
   14700:	8b 00                	mov    (%eax),%eax
   14702:	85 c0                	test   %eax,%eax
   14704:	75 4a                	jne    14750 <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   14706:	8b 45 08             	mov    0x8(%ebp),%eax
   14709:	8b 40 0c             	mov    0xc(%eax),%eax
   1470c:	83 f8 01             	cmp    $0x1,%eax
   1470f:	7f 0b                	jg     1471c <_DecodeDRI+0x33>
   14711:	8b 45 08             	mov    0x8(%ebp),%eax
   14714:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1471a:	eb 35                	jmp    14751 <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   1471c:	8b 45 08             	mov    0x8(%ebp),%eax
   1471f:	8b 40 04             	mov    0x4(%eax),%eax
   14722:	83 ec 0c             	sub    $0xc,%esp
   14725:	50                   	push   %eax
   14726:	e8 8b f6 ff ff       	call   13db6 <_Decode2Bytes>
   1472b:	83 c4 10             	add    $0x10,%esp
   1472e:	89 c2                	mov    %eax,%edx
   14730:	8b 45 08             	mov    0x8(%ebp),%eax
   14733:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   14739:	8b 45 08             	mov    0x8(%ebp),%eax
   1473c:	8b 40 0c             	mov    0xc(%eax),%eax
   1473f:	83 ec 08             	sub    $0x8,%esp
   14742:	50                   	push   %eax
   14743:	ff 75 08             	pushl  0x8(%ebp)
   14746:	e8 bc f5 ff ff       	call   13d07 <_Skip>
   1474b:	83 c4 10             	add    $0x10,%esp
   1474e:	eb 01                	jmp    14751 <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   14750:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   14751:	c9                   	leave  
   14752:	c3                   	ret    

00014753 <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   14753:	55                   	push   %ebp
   14754:	89 e5                	mov    %esp,%ebp
   14756:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   14759:	8b 45 08             	mov    0x8(%ebp),%eax
   1475c:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14762:	89 45 e0             	mov    %eax,-0x20(%ebp)
   14765:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   1476c:	83 ec 0c             	sub    $0xc,%esp
   1476f:	ff 75 08             	pushl  0x8(%ebp)
   14772:	e8 dc f5 ff ff       	call   13d53 <_DecodeLength>
   14777:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1477a:	8b 45 08             	mov    0x8(%ebp),%eax
   1477d:	8b 00                	mov    (%eax),%eax
   1477f:	85 c0                	test   %eax,%eax
   14781:	0f 85 c2 02 00 00    	jne    14a49 <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   14787:	8b 45 08             	mov    0x8(%ebp),%eax
   1478a:	8b 50 0c             	mov    0xc(%eax),%edx
   1478d:	8b 45 08             	mov    0x8(%ebp),%eax
   14790:	8b 40 28             	mov    0x28(%eax),%eax
   14793:	83 c0 02             	add    $0x2,%eax
   14796:	01 c0                	add    %eax,%eax
   14798:	39 c2                	cmp    %eax,%edx
   1479a:	7c 16                	jl     147b2 <_DecodeSOS+0x5f>
   1479c:	8b 45 08             	mov    0x8(%ebp),%eax
   1479f:	8b 40 04             	mov    0x4(%eax),%eax
   147a2:	0f b6 00             	movzbl (%eax),%eax
   147a5:	0f b6 d0             	movzbl %al,%edx
   147a8:	8b 45 08             	mov    0x8(%ebp),%eax
   147ab:	8b 40 28             	mov    0x28(%eax),%eax
   147ae:	39 c2                	cmp    %eax,%edx
   147b0:	74 0e                	je     147c0 <_DecodeSOS+0x6d>
   147b2:	8b 45 08             	mov    0x8(%ebp),%eax
   147b5:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   147bb:	e9 8d 02 00 00       	jmp    14a4d <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   147c0:	83 ec 08             	sub    $0x8,%esp
   147c3:	6a 01                	push   $0x1
   147c5:	ff 75 08             	pushl  0x8(%ebp)
   147c8:	e8 3a f5 ff ff       	call   13d07 <_Skip>
   147cd:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   147d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   147d7:	8b 45 08             	mov    0x8(%ebp),%eax
   147da:	83 c0 2c             	add    $0x2c,%eax
   147dd:	89 45 dc             	mov    %eax,-0x24(%ebp)
   147e0:	e9 ba 00 00 00       	jmp    1489f <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   147e5:	8b 45 08             	mov    0x8(%ebp),%eax
   147e8:	8b 40 04             	mov    0x4(%eax),%eax
   147eb:	0f b6 00             	movzbl (%eax),%eax
   147ee:	0f b6 d0             	movzbl %al,%edx
   147f1:	8b 45 dc             	mov    -0x24(%ebp),%eax
   147f4:	8b 00                	mov    (%eax),%eax
   147f6:	39 c2                	cmp    %eax,%edx
   147f8:	74 0e                	je     14808 <_DecodeSOS+0xb5>
   147fa:	8b 45 08             	mov    0x8(%ebp),%eax
   147fd:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14803:	e9 45 02 00 00       	jmp    14a4d <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   14808:	8b 45 08             	mov    0x8(%ebp),%eax
   1480b:	8b 40 04             	mov    0x4(%eax),%eax
   1480e:	83 c0 01             	add    $0x1,%eax
   14811:	0f b6 00             	movzbl (%eax),%eax
   14814:	0f b6 c0             	movzbl %al,%eax
   14817:	25 ec 00 00 00       	and    $0xec,%eax
   1481c:	85 c0                	test   %eax,%eax
   1481e:	74 0e                	je     1482e <_DecodeSOS+0xdb>
   14820:	8b 45 08             	mov    0x8(%ebp),%eax
   14823:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14829:	e9 1f 02 00 00       	jmp    14a4d <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   1482e:	8b 45 08             	mov    0x8(%ebp),%eax
   14831:	8b 40 04             	mov    0x4(%eax),%eax
   14834:	83 c0 01             	add    $0x1,%eax
   14837:	0f b6 00             	movzbl (%eax),%eax
   1483a:	0f b6 c0             	movzbl %al,%eax
   1483d:	83 e0 02             	and    $0x2,%eax
   14840:	85 c0                	test   %eax,%eax
   14842:	74 0e                	je     14852 <_DecodeSOS+0xff>
   14844:	8b 45 08             	mov    0x8(%ebp),%eax
   14847:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1484d:	e9 fb 01 00 00       	jmp    14a4d <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   14852:	8b 45 08             	mov    0x8(%ebp),%eax
   14855:	8b 40 04             	mov    0x4(%eax),%eax
   14858:	83 c0 01             	add    $0x1,%eax
   1485b:	0f b6 00             	movzbl (%eax),%eax
   1485e:	c0 e8 04             	shr    $0x4,%al
   14861:	0f b6 d0             	movzbl %al,%edx
   14864:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14867:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   1486a:	8b 45 08             	mov    0x8(%ebp),%eax
   1486d:	8b 40 04             	mov    0x4(%eax),%eax
   14870:	83 c0 01             	add    $0x1,%eax
   14873:	0f b6 00             	movzbl (%eax),%eax
   14876:	0f b6 c0             	movzbl %al,%eax
   14879:	83 e0 01             	and    $0x1,%eax
   1487c:	83 c8 02             	or     $0x2,%eax
   1487f:	89 c2                	mov    %eax,%edx
   14881:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14884:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   14887:	83 ec 08             	sub    $0x8,%esp
   1488a:	6a 02                	push   $0x2
   1488c:	ff 75 08             	pushl  0x8(%ebp)
   1488f:	e8 73 f4 ff ff       	call   13d07 <_Skip>
   14894:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14897:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1489b:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   1489f:	8b 45 08             	mov    0x8(%ebp),%eax
   148a2:	8b 40 28             	mov    0x28(%eax),%eax
   148a5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   148a8:	0f 8f 37 ff ff ff    	jg     147e5 <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   148ae:	8b 45 08             	mov    0x8(%ebp),%eax
   148b1:	8b 40 04             	mov    0x4(%eax),%eax
   148b4:	0f b6 00             	movzbl (%eax),%eax
   148b7:	84 c0                	test   %al,%al
   148b9:	75 10                	jne    148cb <_DecodeSOS+0x178>
   148bb:	8b 45 08             	mov    0x8(%ebp),%eax
   148be:	8b 40 04             	mov    0x4(%eax),%eax
   148c1:	83 c0 01             	add    $0x1,%eax
   148c4:	0f b6 00             	movzbl (%eax),%eax
   148c7:	3c 3f                	cmp    $0x3f,%al
   148c9:	74 0e                	je     148d9 <_DecodeSOS+0x186>
   148cb:	8b 45 08             	mov    0x8(%ebp),%eax
   148ce:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   148d4:	e9 74 01 00 00       	jmp    14a4d <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   148d9:	8b 45 08             	mov    0x8(%ebp),%eax
   148dc:	8b 40 04             	mov    0x4(%eax),%eax
   148df:	83 c0 02             	add    $0x2,%eax
   148e2:	0f b6 00             	movzbl (%eax),%eax
   148e5:	84 c0                	test   %al,%al
   148e7:	74 0e                	je     148f7 <_DecodeSOS+0x1a4>
   148e9:	8b 45 08             	mov    0x8(%ebp),%eax
   148ec:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   148f2:	e9 56 01 00 00       	jmp    14a4d <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   148f7:	8b 45 08             	mov    0x8(%ebp),%eax
   148fa:	8b 40 0c             	mov    0xc(%eax),%eax
   148fd:	83 ec 08             	sub    $0x8,%esp
   14900:	50                   	push   %eax
   14901:	ff 75 08             	pushl  0x8(%ebp)
   14904:	e8 fe f3 ff ff       	call   13d07 <_Skip>
   14909:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   1490c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   14913:	e9 17 01 00 00       	jmp    14a2f <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   14918:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   1491f:	e9 f8 00 00 00       	jmp    14a1c <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14924:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1492b:	8b 45 08             	mov    0x8(%ebp),%eax
   1492e:	83 c0 2c             	add    $0x2c,%eax
   14931:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14934:	e9 8d 00 00 00       	jmp    149c6 <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   14939:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   14940:	eb 71                	jmp    149b3 <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14942:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   14949:	eb 59                	jmp    149a4 <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   1494b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1494e:	8b 50 28             	mov    0x28(%eax),%edx
   14951:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14954:	8b 40 08             	mov    0x8(%eax),%eax
   14957:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   1495b:	89 c1                	mov    %eax,%ecx
   1495d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14960:	01 c1                	add    %eax,%ecx
   14962:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14965:	8b 40 14             	mov    0x14(%eax),%eax
   14968:	0f af c8             	imul   %eax,%ecx
   1496b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1496e:	8b 40 04             	mov    0x4(%eax),%eax
   14971:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14975:	01 c1                	add    %eax,%ecx
   14977:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1497a:	01 c8                	add    %ecx,%eax
   1497c:	c1 e0 03             	shl    $0x3,%eax
   1497f:	01 d0                	add    %edx,%eax
   14981:	50                   	push   %eax
   14982:	ff 75 dc             	pushl  -0x24(%ebp)
   14985:	ff 75 0c             	pushl  0xc(%ebp)
   14988:	ff 75 08             	pushl  0x8(%ebp)
   1498b:	e8 bf 00 00 00       	call   14a4f <_DecodeBlock>
   14990:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   14993:	8b 45 08             	mov    0x8(%ebp),%eax
   14996:	8b 00                	mov    (%eax),%eax
   14998:	85 c0                	test   %eax,%eax
   1499a:	0f 85 ac 00 00 00    	jne    14a4c <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   149a0:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   149a4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   149a7:	8b 40 04             	mov    0x4(%eax),%eax
   149aa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   149ad:	7f 9c                	jg     1494b <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   149af:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   149b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   149b6:	8b 40 08             	mov    0x8(%eax),%eax
   149b9:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   149bc:	7f 84                	jg     14942 <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   149be:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   149c2:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   149c6:	8b 45 08             	mov    0x8(%ebp),%eax
   149c9:	8b 40 28             	mov    0x28(%eax),%eax
   149cc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   149cf:	0f 8f 64 ff ff ff    	jg     14939 <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   149d5:	8b 45 08             	mov    0x8(%ebp),%eax
   149d8:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   149de:	85 c0                	test   %eax,%eax
   149e0:	74 36                	je     14a18 <_DecodeSOS+0x2c5>
   149e2:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   149e6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   149ea:	75 2c                	jne    14a18 <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   149ec:	83 ec 0c             	sub    $0xc,%esp
   149ef:	ff 75 08             	pushl  0x8(%ebp)
   149f2:	e8 9f 0a 00 00       	call   15496 <_ByteAlign>
   149f7:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   149fa:	83 ec 08             	sub    $0x8,%esp
   149fd:	6a 10                	push   $0x10
   149ff:	ff 75 08             	pushl  0x8(%ebp)
   14a02:	e8 ce 04 00 00       	call   14ed5 <_GetBits>
   14a07:	83 c4 10             	add    $0x10,%esp
   14a0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   14a0d:	8b 45 08             	mov    0x8(%ebp),%eax
   14a10:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a16:	eb 35                	jmp    14a4d <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   14a18:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14a1c:	8b 45 08             	mov    0x8(%ebp),%eax
   14a1f:	8b 40 18             	mov    0x18(%eax),%eax
   14a22:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14a25:	0f 8f f9 fe ff ff    	jg     14924 <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   14a2b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   14a2f:	8b 45 08             	mov    0x8(%ebp),%eax
   14a32:	8b 40 1c             	mov    0x1c(%eax),%eax
   14a35:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14a38:	0f 8f da fe ff ff    	jg     14918 <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   14a3e:	8b 45 08             	mov    0x8(%ebp),%eax
   14a41:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   14a47:	eb 04                	jmp    14a4d <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   14a49:	90                   	nop
   14a4a:	eb 01                	jmp    14a4d <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   14a4c:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   14a4d:	c9                   	leave  
   14a4e:	c3                   	ret    

00014a4f <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   14a4f:	55                   	push   %ebp
   14a50:	89 e5                	mov    %esp,%ebp
   14a52:	53                   	push   %ebx
   14a53:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   14a56:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   14a5d:	8b 45 08             	mov    0x8(%ebp),%eax
   14a60:	05 c0 01 08 00       	add    $0x801c0,%eax
   14a65:	83 ec 04             	sub    $0x4,%esp
   14a68:	68 00 01 00 00       	push   $0x100
   14a6d:	6a 00                	push   $0x0
   14a6f:	50                   	push   %eax
   14a70:	e8 04 b8 fe ff       	call   279 <memset>
   14a75:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   14a78:	8b 45 10             	mov    0x10(%ebp),%eax
   14a7b:	8b 40 20             	mov    0x20(%eax),%eax
   14a7e:	c1 e0 11             	shl    $0x11,%eax
   14a81:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14a87:	8b 45 08             	mov    0x8(%ebp),%eax
   14a8a:	01 d0                	add    %edx,%eax
   14a8c:	83 c0 08             	add    $0x8,%eax
   14a8f:	83 ec 04             	sub    $0x4,%esp
   14a92:	6a 00                	push   $0x0
   14a94:	50                   	push   %eax
   14a95:	ff 75 08             	pushl  0x8(%ebp)
   14a98:	e8 86 01 00 00       	call   14c23 <_GetVLC>
   14a9d:	83 c4 10             	add    $0x10,%esp
   14aa0:	89 c2                	mov    %eax,%edx
   14aa2:	8b 45 10             	mov    0x10(%ebp),%eax
   14aa5:	8b 40 24             	mov    0x24(%eax),%eax
   14aa8:	01 c2                	add    %eax,%edx
   14aaa:	8b 45 10             	mov    0x10(%ebp),%eax
   14aad:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   14ab0:	8b 45 10             	mov    0x10(%ebp),%eax
   14ab3:	8b 50 24             	mov    0x24(%eax),%edx
   14ab6:	8b 45 10             	mov    0x10(%ebp),%eax
   14ab9:	8b 48 18             	mov    0x18(%eax),%ecx
   14abc:	8b 45 08             	mov    0x8(%ebp),%eax
   14abf:	c1 e1 06             	shl    $0x6,%ecx
   14ac2:	01 c8                	add    %ecx,%eax
   14ac4:	05 b8 00 00 00       	add    $0xb8,%eax
   14ac9:	0f b6 00             	movzbl (%eax),%eax
   14acc:	0f b6 c0             	movzbl %al,%eax
   14acf:	0f af d0             	imul   %eax,%edx
   14ad2:	8b 45 08             	mov    0x8(%ebp),%eax
   14ad5:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   14adb:	8b 45 10             	mov    0x10(%ebp),%eax
   14ade:	8b 40 1c             	mov    0x1c(%eax),%eax
   14ae1:	c1 e0 11             	shl    $0x11,%eax
   14ae4:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14aea:	8b 45 08             	mov    0x8(%ebp),%eax
   14aed:	01 d0                	add    %edx,%eax
   14aef:	8d 50 08             	lea    0x8(%eax),%edx
   14af2:	83 ec 04             	sub    $0x4,%esp
   14af5:	8d 45 ef             	lea    -0x11(%ebp),%eax
   14af8:	50                   	push   %eax
   14af9:	52                   	push   %edx
   14afa:	ff 75 08             	pushl  0x8(%ebp)
   14afd:	e8 21 01 00 00       	call   14c23 <_GetVLC>
   14b02:	83 c4 10             	add    $0x10,%esp
   14b05:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   14b08:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14b0c:	84 c0                	test   %al,%al
   14b0e:	0f 84 92 00 00 00    	je     14ba6 <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   14b14:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14b18:	0f b6 c0             	movzbl %al,%eax
   14b1b:	83 e0 0f             	and    $0xf,%eax
   14b1e:	85 c0                	test   %eax,%eax
   14b20:	75 16                	jne    14b38 <_DecodeBlock+0xe9>
   14b22:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14b26:	3c f0                	cmp    $0xf0,%al
   14b28:	74 0e                	je     14b38 <_DecodeBlock+0xe9>
   14b2a:	8b 45 08             	mov    0x8(%ebp),%eax
   14b2d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14b33:	e9 e6 00 00 00       	jmp    14c1e <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   14b38:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14b3c:	c0 e8 04             	shr    $0x4,%al
   14b3f:	0f b6 c0             	movzbl %al,%eax
   14b42:	83 c0 01             	add    $0x1,%eax
   14b45:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   14b48:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14b4c:	7e 0e                	jle    14b5c <_DecodeBlock+0x10d>
   14b4e:	8b 45 08             	mov    0x8(%ebp),%eax
   14b51:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14b57:	e9 c2 00 00 00       	jmp    14c1e <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   14b5c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14b5f:	8b 45 0c             	mov    0xc(%ebp),%eax
   14b62:	01 d0                	add    %edx,%eax
   14b64:	0f b6 00             	movzbl (%eax),%eax
   14b67:	0f be c8             	movsbl %al,%ecx
   14b6a:	8b 45 10             	mov    0x10(%ebp),%eax
   14b6d:	8b 50 18             	mov    0x18(%eax),%edx
   14b70:	8b 45 08             	mov    0x8(%ebp),%eax
   14b73:	c1 e2 06             	shl    $0x6,%edx
   14b76:	01 c2                	add    %eax,%edx
   14b78:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14b7b:	01 d0                	add    %edx,%eax
   14b7d:	05 b8 00 00 00       	add    $0xb8,%eax
   14b82:	0f b6 00             	movzbl (%eax),%eax
   14b85:	0f b6 c0             	movzbl %al,%eax
   14b88:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14b8c:	89 c2                	mov    %eax,%edx
   14b8e:	8b 45 08             	mov    0x8(%ebp),%eax
   14b91:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   14b97:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   14b9a:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   14b9e:	0f 8e 37 ff ff ff    	jle    14adb <_DecodeBlock+0x8c>
   14ba4:	eb 01                	jmp    14ba7 <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   14ba6:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   14ba7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14bae:	eb 24                	jmp    14bd4 <_DecodeBlock+0x185>
   14bb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14bb3:	05 70 00 02 00       	add    $0x20070,%eax
   14bb8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14bbf:	8b 45 08             	mov    0x8(%ebp),%eax
   14bc2:	01 d0                	add    %edx,%eax
   14bc4:	83 ec 0c             	sub    $0xc,%esp
   14bc7:	50                   	push   %eax
   14bc8:	e8 32 03 00 00       	call   14eff <_RowIDCT>
   14bcd:	83 c4 10             	add    $0x10,%esp
   14bd0:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   14bd4:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14bd8:	7e d6                	jle    14bb0 <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   14bda:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14be1:	eb 35                	jmp    14c18 <_DecodeBlock+0x1c9>
   14be3:	8b 45 10             	mov    0x10(%ebp),%eax
   14be6:	8b 40 14             	mov    0x14(%eax),%eax
   14be9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14bec:	8b 55 14             	mov    0x14(%ebp),%edx
   14bef:	01 d1                	add    %edx,%ecx
   14bf1:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14bf4:	81 c2 70 00 02 00    	add    $0x20070,%edx
   14bfa:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   14c01:	8b 55 08             	mov    0x8(%ebp),%edx
   14c04:	01 da                	add    %ebx,%edx
   14c06:	83 ec 04             	sub    $0x4,%esp
   14c09:	50                   	push   %eax
   14c0a:	51                   	push   %ecx
   14c0b:	52                   	push   %edx
   14c0c:	e8 7b 05 00 00       	call   1518c <_ColIDCT>
   14c11:	83 c4 10             	add    $0x10,%esp
   14c14:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14c18:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14c1c:	7e c5                	jle    14be3 <_DecodeBlock+0x194>
}
   14c1e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14c21:	c9                   	leave  
   14c22:	c3                   	ret    

00014c23 <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   14c23:	55                   	push   %ebp
   14c24:	89 e5                	mov    %esp,%ebp
   14c26:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   14c29:	83 ec 08             	sub    $0x8,%esp
   14c2c:	6a 10                	push   $0x10
   14c2e:	ff 75 08             	pushl  0x8(%ebp)
   14c31:	e8 c2 00 00 00       	call   14cf8 <_ShowBits>
   14c36:	83 c4 10             	add    $0x10,%esp
   14c39:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   14c3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14c3f:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14c42:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c45:	01 d0                	add    %edx,%eax
   14c47:	0f b6 00             	movzbl (%eax),%eax
   14c4a:	0f b6 c0             	movzbl %al,%eax
   14c4d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   14c50:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14c54:	75 13                	jne    14c69 <_GetVLC+0x46>
   14c56:	8b 45 08             	mov    0x8(%ebp),%eax
   14c59:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14c5f:	b8 00 00 00 00       	mov    $0x0,%eax
   14c64:	e9 8d 00 00 00       	jmp    14cf6 <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   14c69:	83 ec 08             	sub    $0x8,%esp
   14c6c:	ff 75 f0             	pushl  -0x10(%ebp)
   14c6f:	ff 75 08             	pushl  0x8(%ebp)
   14c72:	e8 25 02 00 00       	call   14e9c <_SkipBits>
   14c77:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   14c7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14c7d:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14c80:	8b 45 0c             	mov    0xc(%ebp),%eax
   14c83:	01 d0                	add    %edx,%eax
   14c85:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   14c89:	0f b6 c0             	movzbl %al,%eax
   14c8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   14c8f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14c93:	74 0a                	je     14c9f <_GetVLC+0x7c>
   14c95:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14c98:	89 c2                	mov    %eax,%edx
   14c9a:	8b 45 10             	mov    0x10(%ebp),%eax
   14c9d:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   14c9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14ca2:	83 e0 0f             	and    $0xf,%eax
   14ca5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   14ca8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14cac:	75 07                	jne    14cb5 <_GetVLC+0x92>
   14cae:	b8 00 00 00 00       	mov    $0x0,%eax
   14cb3:	eb 41                	jmp    14cf6 <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   14cb5:	83 ec 08             	sub    $0x8,%esp
   14cb8:	ff 75 f0             	pushl  -0x10(%ebp)
   14cbb:	ff 75 08             	pushl  0x8(%ebp)
   14cbe:	e8 12 02 00 00       	call   14ed5 <_GetBits>
   14cc3:	83 c4 10             	add    $0x10,%esp
   14cc6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   14cc9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ccc:	83 e8 01             	sub    $0x1,%eax
   14ccf:	ba 01 00 00 00       	mov    $0x1,%edx
   14cd4:	89 c1                	mov    %eax,%ecx
   14cd6:	d3 e2                	shl    %cl,%edx
   14cd8:	89 d0                	mov    %edx,%eax
   14cda:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14cdd:	7e 14                	jle    14cf3 <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   14cdf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14ce2:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   14ce7:	89 c1                	mov    %eax,%ecx
   14ce9:	d3 e2                	shl    %cl,%edx
   14ceb:	89 d0                	mov    %edx,%eax
   14ced:	83 c0 01             	add    $0x1,%eax
   14cf0:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   14cf3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14cf6:	c9                   	leave  
   14cf7:	c3                   	ret    

00014cf8 <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   14cf8:	55                   	push   %ebp
   14cf9:	89 e5                	mov    %esp,%ebp
   14cfb:	53                   	push   %ebx
   14cfc:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   14cff:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14d03:	0f 85 4f 01 00 00    	jne    14e58 <_ShowBits+0x160>
   14d09:	b8 00 00 00 00       	mov    $0x0,%eax
   14d0e:	e9 83 01 00 00       	jmp    14e96 <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   14d13:	8b 45 08             	mov    0x8(%ebp),%eax
   14d16:	8b 40 08             	mov    0x8(%eax),%eax
   14d19:	85 c0                	test   %eax,%eax
   14d1b:	7f 33                	jg     14d50 <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   14d1d:	8b 45 08             	mov    0x8(%ebp),%eax
   14d20:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14d26:	c1 e0 08             	shl    $0x8,%eax
   14d29:	0c ff                	or     $0xff,%al
   14d2b:	89 c2                	mov    %eax,%edx
   14d2d:	8b 45 08             	mov    0x8(%ebp),%eax
   14d30:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   14d36:	8b 45 08             	mov    0x8(%ebp),%eax
   14d39:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d3f:	8d 50 08             	lea    0x8(%eax),%edx
   14d42:	8b 45 08             	mov    0x8(%ebp),%eax
   14d45:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   14d4b:	e9 08 01 00 00       	jmp    14e58 <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   14d50:	8b 45 08             	mov    0x8(%ebp),%eax
   14d53:	8b 40 04             	mov    0x4(%eax),%eax
   14d56:	8d 48 01             	lea    0x1(%eax),%ecx
   14d59:	8b 55 08             	mov    0x8(%ebp),%edx
   14d5c:	89 4a 04             	mov    %ecx,0x4(%edx)
   14d5f:	0f b6 00             	movzbl (%eax),%eax
   14d62:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   14d65:	8b 45 08             	mov    0x8(%ebp),%eax
   14d68:	8b 40 08             	mov    0x8(%eax),%eax
   14d6b:	8d 50 ff             	lea    -0x1(%eax),%edx
   14d6e:	8b 45 08             	mov    0x8(%ebp),%eax
   14d71:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   14d74:	8b 45 08             	mov    0x8(%ebp),%eax
   14d77:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14d7d:	8d 50 08             	lea    0x8(%eax),%edx
   14d80:	8b 45 08             	mov    0x8(%ebp),%eax
   14d83:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   14d89:	8b 45 08             	mov    0x8(%ebp),%eax
   14d8c:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14d92:	c1 e0 08             	shl    $0x8,%eax
   14d95:	89 c2                	mov    %eax,%edx
   14d97:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   14d9b:	09 c2                	or     %eax,%edx
   14d9d:	8b 45 08             	mov    0x8(%ebp),%eax
   14da0:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   14da6:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   14daa:	0f 85 a8 00 00 00    	jne    14e58 <_ShowBits+0x160>
            if(ctx->size){
   14db0:	8b 45 08             	mov    0x8(%ebp),%eax
   14db3:	8b 40 08             	mov    0x8(%eax),%eax
   14db6:	85 c0                	test   %eax,%eax
   14db8:	0f 84 91 00 00 00    	je     14e4f <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   14dbe:	8b 45 08             	mov    0x8(%ebp),%eax
   14dc1:	8b 40 04             	mov    0x4(%eax),%eax
   14dc4:	8d 48 01             	lea    0x1(%eax),%ecx
   14dc7:	8b 55 08             	mov    0x8(%ebp),%edx
   14dca:	89 4a 04             	mov    %ecx,0x4(%edx)
   14dcd:	0f b6 00             	movzbl (%eax),%eax
   14dd0:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   14dd3:	8b 45 08             	mov    0x8(%ebp),%eax
   14dd6:	8b 40 08             	mov    0x8(%eax),%eax
   14dd9:	8d 50 ff             	lea    -0x1(%eax),%edx
   14ddc:	8b 45 08             	mov    0x8(%ebp),%eax
   14ddf:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   14de2:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14de6:	85 c0                	test   %eax,%eax
   14de8:	74 62                	je     14e4c <_ShowBits+0x154>
   14dea:	3d d9 00 00 00       	cmp    $0xd9,%eax
   14def:	75 0c                	jne    14dfd <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   14df1:	8b 45 08             	mov    0x8(%ebp),%eax
   14df4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   14dfb:	eb 5b                	jmp    14e58 <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   14dfd:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14e01:	25 f8 00 00 00       	and    $0xf8,%eax
   14e06:	3d d0 00 00 00       	cmp    $0xd0,%eax
   14e0b:	74 0b                	je     14e18 <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   14e0d:	8b 45 08             	mov    0x8(%ebp),%eax
   14e10:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14e16:	eb 40                	jmp    14e58 <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   14e18:	8b 45 08             	mov    0x8(%ebp),%eax
   14e1b:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14e21:	c1 e0 08             	shl    $0x8,%eax
   14e24:	89 c2                	mov    %eax,%edx
   14e26:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14e2a:	09 c2                	or     %eax,%edx
   14e2c:	8b 45 08             	mov    0x8(%ebp),%eax
   14e2f:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   14e35:	8b 45 08             	mov    0x8(%ebp),%eax
   14e38:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14e3e:	8d 50 08             	lea    0x8(%eax),%edx
   14e41:	8b 45 08             	mov    0x8(%ebp),%eax
   14e44:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   14e4a:	eb 0c                	jmp    14e58 <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   14e4c:	90                   	nop
   14e4d:	eb 09                	jmp    14e58 <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   14e4f:	8b 45 08             	mov    0x8(%ebp),%eax
   14e52:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   14e58:	8b 45 08             	mov    0x8(%ebp),%eax
   14e5b:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14e61:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14e64:	0f 8c a9 fe ff ff    	jl     14d13 <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   14e6a:	8b 45 08             	mov    0x8(%ebp),%eax
   14e6d:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   14e73:	8b 45 08             	mov    0x8(%ebp),%eax
   14e76:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14e7c:	2b 45 0c             	sub    0xc(%ebp),%eax
   14e7f:	89 c1                	mov    %eax,%ecx
   14e81:	d3 fa                	sar    %cl,%edx
   14e83:	8b 45 0c             	mov    0xc(%ebp),%eax
   14e86:	bb 01 00 00 00       	mov    $0x1,%ebx
   14e8b:	89 c1                	mov    %eax,%ecx
   14e8d:	d3 e3                	shl    %cl,%ebx
   14e8f:	89 d8                	mov    %ebx,%eax
   14e91:	83 e8 01             	sub    $0x1,%eax
   14e94:	21 d0                	and    %edx,%eax
}
   14e96:	83 c4 10             	add    $0x10,%esp
   14e99:	5b                   	pop    %ebx
   14e9a:	5d                   	pop    %ebp
   14e9b:	c3                   	ret    

00014e9c <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   14e9c:	55                   	push   %ebp
   14e9d:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   14e9f:	8b 45 08             	mov    0x8(%ebp),%eax
   14ea2:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14ea8:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14eab:	7d 0e                	jge    14ebb <_SkipBits+0x1f>
   14ead:	ff 75 0c             	pushl  0xc(%ebp)
   14eb0:	ff 75 08             	pushl  0x8(%ebp)
   14eb3:	e8 40 fe ff ff       	call   14cf8 <_ShowBits>
   14eb8:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   14ebb:	8b 45 08             	mov    0x8(%ebp),%eax
   14ebe:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14ec4:	2b 45 0c             	sub    0xc(%ebp),%eax
   14ec7:	89 c2                	mov    %eax,%edx
   14ec9:	8b 45 08             	mov    0x8(%ebp),%eax
   14ecc:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   14ed2:	90                   	nop
   14ed3:	c9                   	leave  
   14ed4:	c3                   	ret    

00014ed5 <_GetBits>:

int _GetBits(Context* ctx, int bits){
   14ed5:	55                   	push   %ebp
   14ed6:	89 e5                	mov    %esp,%ebp
   14ed8:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   14edb:	ff 75 0c             	pushl  0xc(%ebp)
   14ede:	ff 75 08             	pushl  0x8(%ebp)
   14ee1:	e8 12 fe ff ff       	call   14cf8 <_ShowBits>
   14ee6:	83 c4 08             	add    $0x8,%esp
   14ee9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   14eec:	ff 75 0c             	pushl  0xc(%ebp)
   14eef:	ff 75 08             	pushl  0x8(%ebp)
   14ef2:	e8 a5 ff ff ff       	call   14e9c <_SkipBits>
   14ef7:	83 c4 08             	add    $0x8,%esp
    return res;
   14efa:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   14efd:	c9                   	leave  
   14efe:	c3                   	ret    

00014eff <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   14eff:	55                   	push   %ebp
   14f00:	89 e5                	mov    %esp,%ebp
   14f02:	57                   	push   %edi
   14f03:	56                   	push   %esi
   14f04:	53                   	push   %ebx
   14f05:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14f08:	8b 45 08             	mov    0x8(%ebp),%eax
   14f0b:	83 c0 10             	add    $0x10,%eax
   14f0e:	8b 00                	mov    (%eax),%eax
   14f10:	c1 e0 0b             	shl    $0xb,%eax
   14f13:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   14f16:	8b 45 08             	mov    0x8(%ebp),%eax
   14f19:	8b 40 18             	mov    0x18(%eax),%eax
   14f1c:	89 45 ec             	mov    %eax,-0x14(%ebp)
   14f1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14f22:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   14f25:	8b 55 08             	mov    0x8(%ebp),%edx
   14f28:	8b 52 08             	mov    0x8(%edx),%edx
   14f2b:	89 55 e8             	mov    %edx,-0x18(%ebp)
   14f2e:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   14f31:	8b 55 08             	mov    0x8(%ebp),%edx
   14f34:	8b 52 04             	mov    0x4(%edx),%edx
   14f37:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   14f3a:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   14f3d:	8b 55 08             	mov    0x8(%ebp),%edx
   14f40:	8b 52 1c             	mov    0x1c(%edx),%edx
   14f43:	89 55 e0             	mov    %edx,-0x20(%ebp)
   14f46:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   14f49:	8b 55 08             	mov    0x8(%ebp),%edx
   14f4c:	8b 52 14             	mov    0x14(%edx),%edx
   14f4f:	89 55 dc             	mov    %edx,-0x24(%ebp)
   14f52:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   14f55:	8b 55 08             	mov    0x8(%ebp),%edx
   14f58:	8b 52 0c             	mov    0xc(%edx),%edx
   14f5b:	89 55 d8             	mov    %edx,-0x28(%ebp)
   14f5e:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   14f61:	85 c0                	test   %eax,%eax
   14f63:	75 68                	jne    14fcd <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   14f65:	8b 45 08             	mov    0x8(%ebp),%eax
   14f68:	8d 48 04             	lea    0x4(%eax),%ecx
   14f6b:	8b 45 08             	mov    0x8(%ebp),%eax
   14f6e:	8d 58 08             	lea    0x8(%eax),%ebx
   14f71:	8b 45 08             	mov    0x8(%ebp),%eax
   14f74:	8d 70 0c             	lea    0xc(%eax),%esi
   14f77:	8b 45 08             	mov    0x8(%ebp),%eax
   14f7a:	8d 78 10             	lea    0x10(%eax),%edi
   14f7d:	8b 45 08             	mov    0x8(%ebp),%eax
   14f80:	83 c0 14             	add    $0x14,%eax
   14f83:	89 45 c0             	mov    %eax,-0x40(%ebp)
   14f86:	8b 45 08             	mov    0x8(%ebp),%eax
   14f89:	83 c0 18             	add    $0x18,%eax
   14f8c:	89 45 bc             	mov    %eax,-0x44(%ebp)
   14f8f:	8b 45 08             	mov    0x8(%ebp),%eax
   14f92:	8d 50 1c             	lea    0x1c(%eax),%edx
   14f95:	8b 45 08             	mov    0x8(%ebp),%eax
   14f98:	8b 00                	mov    (%eax),%eax
   14f9a:	c1 e0 03             	shl    $0x3,%eax
   14f9d:	89 02                	mov    %eax,(%edx)
   14f9f:	8b 02                	mov    (%edx),%eax
   14fa1:	8b 55 bc             	mov    -0x44(%ebp),%edx
   14fa4:	89 02                	mov    %eax,(%edx)
   14fa6:	89 d0                	mov    %edx,%eax
   14fa8:	8b 00                	mov    (%eax),%eax
   14faa:	8b 55 c0             	mov    -0x40(%ebp),%edx
   14fad:	89 02                	mov    %eax,(%edx)
   14faf:	89 d0                	mov    %edx,%eax
   14fb1:	8b 00                	mov    (%eax),%eax
   14fb3:	89 07                	mov    %eax,(%edi)
   14fb5:	8b 07                	mov    (%edi),%eax
   14fb7:	89 06                	mov    %eax,(%esi)
   14fb9:	8b 06                	mov    (%esi),%eax
   14fbb:	89 03                	mov    %eax,(%ebx)
   14fbd:	8b 03                	mov    (%ebx),%eax
   14fbf:	89 01                	mov    %eax,(%ecx)
   14fc1:	8b 11                	mov    (%ecx),%edx
   14fc3:	8b 45 08             	mov    0x8(%ebp),%eax
   14fc6:	89 10                	mov    %edx,(%eax)
        return;
   14fc8:	e9 b7 01 00 00       	jmp    15184 <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   14fcd:	8b 45 08             	mov    0x8(%ebp),%eax
   14fd0:	8b 00                	mov    (%eax),%eax
   14fd2:	c1 e0 0b             	shl    $0xb,%eax
   14fd5:	83 e8 80             	sub    $0xffffff80,%eax
   14fd8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   14fdb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   14fde:	8b 45 e0             	mov    -0x20(%ebp),%eax
   14fe1:	01 d0                	add    %edx,%eax
   14fe3:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   14fe9:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   14fec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14fef:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   14ff5:	8b 45 d0             	mov    -0x30(%ebp),%eax
   14ff8:	01 d0                	add    %edx,%eax
   14ffa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   14ffd:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15000:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   15006:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15009:	01 d0                	add    %edx,%eax
   1500b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   1500e:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15011:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15014:	01 d0                	add    %edx,%eax
   15016:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   1501c:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   1501f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15022:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   15028:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1502b:	01 d0                	add    %edx,%eax
   1502d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   15030:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15033:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   15039:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1503c:	01 d0                	add    %edx,%eax
   1503e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   15041:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   15044:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15047:	01 d0                	add    %edx,%eax
   15049:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   1504c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1504f:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   15052:	8b 55 e8             	mov    -0x18(%ebp),%edx
   15055:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15058:	01 d0                	add    %edx,%eax
   1505a:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   15060:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   15063:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15066:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   1506c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1506f:	01 d0                	add    %edx,%eax
   15071:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   15074:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15077:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   1507d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15080:	01 d0                	add    %edx,%eax
   15082:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   15085:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15088:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1508b:	01 d0                	add    %edx,%eax
   1508d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   15090:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15093:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   15096:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15099:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1509c:	01 d0                	add    %edx,%eax
   1509e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   150a1:	8b 45 d8             	mov    -0x28(%ebp),%eax
   150a4:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   150a7:	8b 55 d0             	mov    -0x30(%ebp),%edx
   150aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   150ad:	01 d0                	add    %edx,%eax
   150af:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   150b2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   150b5:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   150b8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   150bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
   150be:	01 d0                	add    %edx,%eax
   150c0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   150c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   150c6:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   150c9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   150cc:	8b 45 e0             	mov    -0x20(%ebp),%eax
   150cf:	01 d0                	add    %edx,%eax
   150d1:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   150d7:	83 e8 80             	sub    $0xffffff80,%eax
   150da:	c1 f8 08             	sar    $0x8,%eax
   150dd:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   150e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   150e3:	2b 45 e0             	sub    -0x20(%ebp),%eax
   150e6:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   150ec:	83 e8 80             	sub    $0xffffff80,%eax
   150ef:	c1 f8 08             	sar    $0x8,%eax
   150f2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   150f5:	8b 55 d8             	mov    -0x28(%ebp),%edx
   150f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   150fb:	01 d0                	add    %edx,%eax
   150fd:	c1 f8 08             	sar    $0x8,%eax
   15100:	89 c2                	mov    %eax,%edx
   15102:	8b 45 08             	mov    0x8(%ebp),%eax
   15105:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   15107:	8b 45 08             	mov    0x8(%ebp),%eax
   1510a:	83 c0 04             	add    $0x4,%eax
   1510d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   15110:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15113:	01 ca                	add    %ecx,%edx
   15115:	c1 fa 08             	sar    $0x8,%edx
   15118:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   1511a:	8b 45 08             	mov    0x8(%ebp),%eax
   1511d:	83 c0 08             	add    $0x8,%eax
   15120:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   15123:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15126:	01 ca                	add    %ecx,%edx
   15128:	c1 fa 08             	sar    $0x8,%edx
   1512b:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   1512d:	8b 45 08             	mov    0x8(%ebp),%eax
   15130:	83 c0 0c             	add    $0xc,%eax
   15133:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   15136:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15139:	01 ca                	add    %ecx,%edx
   1513b:	c1 fa 08             	sar    $0x8,%edx
   1513e:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   15140:	8b 45 08             	mov    0x8(%ebp),%eax
   15143:	8d 50 10             	lea    0x10(%eax),%edx
   15146:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15149:	2b 45 dc             	sub    -0x24(%ebp),%eax
   1514c:	c1 f8 08             	sar    $0x8,%eax
   1514f:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   15151:	8b 45 08             	mov    0x8(%ebp),%eax
   15154:	8d 50 14             	lea    0x14(%eax),%edx
   15157:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1515a:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   1515d:	c1 f8 08             	sar    $0x8,%eax
   15160:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   15162:	8b 45 08             	mov    0x8(%ebp),%eax
   15165:	8d 50 18             	lea    0x18(%eax),%edx
   15168:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1516b:	2b 45 ec             	sub    -0x14(%ebp),%eax
   1516e:	c1 f8 08             	sar    $0x8,%eax
   15171:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   15173:	8b 45 08             	mov    0x8(%ebp),%eax
   15176:	8d 50 1c             	lea    0x1c(%eax),%edx
   15179:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1517c:	2b 45 f0             	sub    -0x10(%ebp),%eax
   1517f:	c1 f8 08             	sar    $0x8,%eax
   15182:	89 02                	mov    %eax,(%edx)
}
   15184:	83 c4 38             	add    $0x38,%esp
   15187:	5b                   	pop    %ebx
   15188:	5e                   	pop    %esi
   15189:	5f                   	pop    %edi
   1518a:	5d                   	pop    %ebp
   1518b:	c3                   	ret    

0001518c <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   1518c:	55                   	push   %ebp
   1518d:	89 e5                	mov    %esp,%ebp
   1518f:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   15192:	8b 45 08             	mov    0x8(%ebp),%eax
   15195:	83 e8 80             	sub    $0xffffff80,%eax
   15198:	8b 00                	mov    (%eax),%eax
   1519a:	c1 e0 08             	shl    $0x8,%eax
   1519d:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   151a0:	8b 45 08             	mov    0x8(%ebp),%eax
   151a3:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   151a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
   151ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
   151af:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   151b2:	8b 55 08             	mov    0x8(%ebp),%edx
   151b5:	8b 52 40             	mov    0x40(%edx),%edx
   151b8:	89 55 f0             	mov    %edx,-0x10(%ebp)
   151bb:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   151be:	8b 55 08             	mov    0x8(%ebp),%edx
   151c1:	8b 52 20             	mov    0x20(%edx),%edx
   151c4:	89 55 ec             	mov    %edx,-0x14(%ebp)
   151c7:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   151ca:	8b 55 08             	mov    0x8(%ebp),%edx
   151cd:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   151d3:	89 55 e8             	mov    %edx,-0x18(%ebp)
   151d6:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   151d9:	8b 55 08             	mov    0x8(%ebp),%edx
   151dc:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   151e2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   151e5:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   151e8:	8b 55 08             	mov    0x8(%ebp),%edx
   151eb:	8b 52 60             	mov    0x60(%edx),%edx
   151ee:	89 55 e0             	mov    %edx,-0x20(%ebp)
   151f1:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   151f4:	85 c0                	test   %eax,%eax
   151f6:	75 45                	jne    1523d <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   151f8:	8b 45 08             	mov    0x8(%ebp),%eax
   151fb:	8b 00                	mov    (%eax),%eax
   151fd:	83 c0 20             	add    $0x20,%eax
   15200:	c1 f8 06             	sar    $0x6,%eax
   15203:	83 e8 80             	sub    $0xffffff80,%eax
   15206:	50                   	push   %eax
   15207:	e8 d6 ea ff ff       	call   13ce2 <_Clip>
   1520c:	83 c4 04             	add    $0x4,%esp
   1520f:	0f b6 c0             	movzbl %al,%eax
   15212:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   15215:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   1521c:	eb 14                	jmp    15232 <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   1521e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15221:	89 c2                	mov    %eax,%edx
   15223:	8b 45 0c             	mov    0xc(%ebp),%eax
   15226:	88 10                	mov    %dl,(%eax)
            out += stride;
   15228:	8b 45 10             	mov    0x10(%ebp),%eax
   1522b:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   1522e:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   15232:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   15236:	75 e6                	jne    1521e <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   15238:	e9 57 02 00 00       	jmp    15494 <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   1523d:	8b 45 08             	mov    0x8(%ebp),%eax
   15240:	8b 00                	mov    (%eax),%eax
   15242:	c1 e0 08             	shl    $0x8,%eax
   15245:	05 00 20 00 00       	add    $0x2000,%eax
   1524a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   1524d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15250:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15253:	01 d0                	add    %edx,%eax
   15255:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   1525b:	83 c0 04             	add    $0x4,%eax
   1525e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   15261:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15264:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   1526a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1526d:	01 d0                	add    %edx,%eax
   1526f:	c1 f8 03             	sar    $0x3,%eax
   15272:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   15275:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15278:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   1527e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15281:	01 d0                	add    %edx,%eax
   15283:	c1 f8 03             	sar    $0x3,%eax
   15286:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   15289:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1528c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1528f:	01 d0                	add    %edx,%eax
   15291:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   15297:	83 c0 04             	add    $0x4,%eax
   1529a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   1529d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   152a0:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   152a6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   152a9:	01 d0                	add    %edx,%eax
   152ab:	c1 f8 03             	sar    $0x3,%eax
   152ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   152b1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   152b4:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   152ba:	8b 45 dc             	mov    -0x24(%ebp),%eax
   152bd:	01 d0                	add    %edx,%eax
   152bf:	c1 f8 03             	sar    $0x3,%eax
   152c2:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   152c5:	8b 55 fc             	mov    -0x4(%ebp),%edx
   152c8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   152cb:	01 d0                	add    %edx,%eax
   152cd:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   152d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   152d3:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   152d6:	8b 55 f0             	mov    -0x10(%ebp),%edx
   152d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   152dc:	01 d0                	add    %edx,%eax
   152de:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   152e4:	83 c0 04             	add    $0x4,%eax
   152e7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   152ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
   152ed:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   152f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
   152f6:	01 d0                	add    %edx,%eax
   152f8:	c1 f8 03             	sar    $0x3,%eax
   152fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   152fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15301:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   15307:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1530a:	01 d0                	add    %edx,%eax
   1530c:	c1 f8 03             	sar    $0x3,%eax
   1530f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   15312:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15315:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15318:	01 d0                	add    %edx,%eax
   1531a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   1531d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15320:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   15323:	8b 55 e8             	mov    -0x18(%ebp),%edx
   15326:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15329:	01 d0                	add    %edx,%eax
   1532b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   1532e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15331:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   15334:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15337:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1533a:	01 d0                	add    %edx,%eax
   1533c:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   1533f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15342:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   15345:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15348:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1534b:	01 d0                	add    %edx,%eax
   1534d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   15350:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15353:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   15356:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15359:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1535c:	01 d0                	add    %edx,%eax
   1535e:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15364:	83 e8 80             	sub    $0xffffff80,%eax
   15367:	c1 f8 08             	sar    $0x8,%eax
   1536a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   1536d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15370:	2b 45 e8             	sub    -0x18(%ebp),%eax
   15373:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15379:	83 e8 80             	sub    $0xffffff80,%eax
   1537c:	c1 f8 08             	sar    $0x8,%eax
   1537f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   15382:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15385:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15388:	01 d0                	add    %edx,%eax
   1538a:	c1 f8 0e             	sar    $0xe,%eax
   1538d:	83 e8 80             	sub    $0xffffff80,%eax
   15390:	50                   	push   %eax
   15391:	e8 4c e9 ff ff       	call   13ce2 <_Clip>
   15396:	83 c4 04             	add    $0x4,%esp
   15399:	89 c2                	mov    %eax,%edx
   1539b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1539e:	88 10                	mov    %dl,(%eax)
   153a0:	8b 45 10             	mov    0x10(%ebp),%eax
   153a3:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   153a6:	8b 55 f0             	mov    -0x10(%ebp),%edx
   153a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   153ac:	01 d0                	add    %edx,%eax
   153ae:	c1 f8 0e             	sar    $0xe,%eax
   153b1:	83 e8 80             	sub    $0xffffff80,%eax
   153b4:	50                   	push   %eax
   153b5:	e8 28 e9 ff ff       	call   13ce2 <_Clip>
   153ba:	83 c4 04             	add    $0x4,%esp
   153bd:	89 c2                	mov    %eax,%edx
   153bf:	8b 45 0c             	mov    0xc(%ebp),%eax
   153c2:	88 10                	mov    %dl,(%eax)
   153c4:	8b 45 10             	mov    0x10(%ebp),%eax
   153c7:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   153ca:	8b 55 fc             	mov    -0x4(%ebp),%edx
   153cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   153d0:	01 d0                	add    %edx,%eax
   153d2:	c1 f8 0e             	sar    $0xe,%eax
   153d5:	83 e8 80             	sub    $0xffffff80,%eax
   153d8:	50                   	push   %eax
   153d9:	e8 04 e9 ff ff       	call   13ce2 <_Clip>
   153de:	83 c4 04             	add    $0x4,%esp
   153e1:	89 c2                	mov    %eax,%edx
   153e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   153e6:	88 10                	mov    %dl,(%eax)
   153e8:	8b 45 10             	mov    0x10(%ebp),%eax
   153eb:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   153ee:	8b 55 dc             	mov    -0x24(%ebp),%edx
   153f1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   153f4:	01 d0                	add    %edx,%eax
   153f6:	c1 f8 0e             	sar    $0xe,%eax
   153f9:	83 e8 80             	sub    $0xffffff80,%eax
   153fc:	50                   	push   %eax
   153fd:	e8 e0 e8 ff ff       	call   13ce2 <_Clip>
   15402:	83 c4 04             	add    $0x4,%esp
   15405:	89 c2                	mov    %eax,%edx
   15407:	8b 45 0c             	mov    0xc(%ebp),%eax
   1540a:	88 10                	mov    %dl,(%eax)
   1540c:	8b 45 10             	mov    0x10(%ebp),%eax
   1540f:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   15412:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15415:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   15418:	c1 f8 0e             	sar    $0xe,%eax
   1541b:	83 e8 80             	sub    $0xffffff80,%eax
   1541e:	50                   	push   %eax
   1541f:	e8 be e8 ff ff       	call   13ce2 <_Clip>
   15424:	83 c4 04             	add    $0x4,%esp
   15427:	89 c2                	mov    %eax,%edx
   15429:	8b 45 0c             	mov    0xc(%ebp),%eax
   1542c:	88 10                	mov    %dl,(%eax)
   1542e:	8b 45 10             	mov    0x10(%ebp),%eax
   15431:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   15434:	8b 45 fc             	mov    -0x4(%ebp),%eax
   15437:	2b 45 ec             	sub    -0x14(%ebp),%eax
   1543a:	c1 f8 0e             	sar    $0xe,%eax
   1543d:	83 e8 80             	sub    $0xffffff80,%eax
   15440:	50                   	push   %eax
   15441:	e8 9c e8 ff ff       	call   13ce2 <_Clip>
   15446:	83 c4 04             	add    $0x4,%esp
   15449:	89 c2                	mov    %eax,%edx
   1544b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1544e:	88 10                	mov    %dl,(%eax)
   15450:	8b 45 10             	mov    0x10(%ebp),%eax
   15453:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   15456:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15459:	2b 45 f4             	sub    -0xc(%ebp),%eax
   1545c:	c1 f8 0e             	sar    $0xe,%eax
   1545f:	83 e8 80             	sub    $0xffffff80,%eax
   15462:	50                   	push   %eax
   15463:	e8 7a e8 ff ff       	call   13ce2 <_Clip>
   15468:	83 c4 04             	add    $0x4,%esp
   1546b:	89 c2                	mov    %eax,%edx
   1546d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15470:	88 10                	mov    %dl,(%eax)
   15472:	8b 45 10             	mov    0x10(%ebp),%eax
   15475:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   15478:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1547b:	2b 45 f8             	sub    -0x8(%ebp),%eax
   1547e:	c1 f8 0e             	sar    $0xe,%eax
   15481:	83 e8 80             	sub    $0xffffff80,%eax
   15484:	50                   	push   %eax
   15485:	e8 58 e8 ff ff       	call   13ce2 <_Clip>
   1548a:	83 c4 04             	add    $0x4,%esp
   1548d:	89 c2                	mov    %eax,%edx
   1548f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15492:	88 10                	mov    %dl,(%eax)
}
   15494:	c9                   	leave  
   15495:	c3                   	ret    

00015496 <_ByteAlign>:

void _ByteAlign(Context* ctx){
   15496:	55                   	push   %ebp
   15497:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   15499:	8b 45 08             	mov    0x8(%ebp),%eax
   1549c:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   154a2:	25 f8 00 00 00       	and    $0xf8,%eax
   154a7:	89 c2                	mov    %eax,%edx
   154a9:	8b 45 08             	mov    0x8(%ebp),%eax
   154ac:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   154b2:	90                   	nop
   154b3:	5d                   	pop    %ebp
   154b4:	c3                   	ret    

000154b5 <_SkipMarker>:

void _SkipMarker(Context* ctx){
   154b5:	55                   	push   %ebp
   154b6:	89 e5                	mov    %esp,%ebp
   154b8:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   154bb:	83 ec 0c             	sub    $0xc,%esp
   154be:	ff 75 08             	pushl  0x8(%ebp)
   154c1:	e8 8d e8 ff ff       	call   13d53 <_DecodeLength>
   154c6:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   154c9:	8b 45 08             	mov    0x8(%ebp),%eax
   154cc:	8b 40 0c             	mov    0xc(%eax),%eax
   154cf:	83 ec 08             	sub    $0x8,%esp
   154d2:	50                   	push   %eax
   154d3:	ff 75 08             	pushl  0x8(%ebp)
   154d6:	e8 2c e8 ff ff       	call   13d07 <_Skip>
   154db:	83 c4 10             	add    $0x10,%esp
}
   154de:	90                   	nop
   154df:	c9                   	leave  
   154e0:	c3                   	ret    

000154e1 <_Convert>:

void _Convert(Context* ctx){
   154e1:	55                   	push   %ebp
   154e2:	89 e5                	mov    %esp,%ebp
   154e4:	57                   	push   %edi
   154e5:	56                   	push   %esi
   154e6:	53                   	push   %ebx
   154e7:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   154ea:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   154f1:	8b 45 08             	mov    0x8(%ebp),%eax
   154f4:	83 c0 2c             	add    $0x2c,%eax
   154f7:	89 45 e0             	mov    %eax,-0x20(%ebp)
   154fa:	e9 b2 00 00 00       	jmp    155b1 <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   154ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15502:	8b 50 0c             	mov    0xc(%eax),%edx
   15505:	8b 45 08             	mov    0x8(%ebp),%eax
   15508:	8b 40 10             	mov    0x10(%eax),%eax
   1550b:	39 c2                	cmp    %eax,%edx
   1550d:	7d 11                	jge    15520 <_Convert+0x3f>
   1550f:	83 ec 08             	sub    $0x8,%esp
   15512:	ff 75 e0             	pushl  -0x20(%ebp)
   15515:	ff 75 08             	pushl  0x8(%ebp)
   15518:	e8 79 02 00 00       	call   15796 <_UpsampleH>
   1551d:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   15520:	8b 45 08             	mov    0x8(%ebp),%eax
   15523:	8b 00                	mov    (%eax),%eax
   15525:	85 c0                	test   %eax,%eax
   15527:	0f 85 5d 02 00 00    	jne    1578a <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   1552d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15530:	8b 50 10             	mov    0x10(%eax),%edx
   15533:	8b 45 08             	mov    0x8(%ebp),%eax
   15536:	8b 40 14             	mov    0x14(%eax),%eax
   15539:	39 c2                	cmp    %eax,%edx
   1553b:	7d 11                	jge    1554e <_Convert+0x6d>
   1553d:	83 ec 08             	sub    $0x8,%esp
   15540:	ff 75 e0             	pushl  -0x20(%ebp)
   15543:	ff 75 08             	pushl  0x8(%ebp)
   15546:	e8 db 05 00 00       	call   15b26 <_UpsampleV>
   1554b:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   1554e:	8b 45 08             	mov    0x8(%ebp),%eax
   15551:	8b 00                	mov    (%eax),%eax
   15553:	85 c0                	test   %eax,%eax
   15555:	0f 85 32 02 00 00    	jne    1578d <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   1555b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1555e:	8b 50 0c             	mov    0xc(%eax),%edx
   15561:	8b 45 08             	mov    0x8(%ebp),%eax
   15564:	8b 40 10             	mov    0x10(%eax),%eax
   15567:	39 c2                	cmp    %eax,%edx
   15569:	7c 94                	jl     154ff <_Convert+0x1e>
   1556b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1556e:	8b 50 10             	mov    0x10(%eax),%edx
   15571:	8b 45 08             	mov    0x8(%ebp),%eax
   15574:	8b 40 14             	mov    0x14(%eax),%eax
   15577:	39 c2                	cmp    %eax,%edx
   15579:	7c 84                	jl     154ff <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   1557b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1557e:	8b 50 0c             	mov    0xc(%eax),%edx
   15581:	8b 45 08             	mov    0x8(%ebp),%eax
   15584:	8b 40 10             	mov    0x10(%eax),%eax
   15587:	39 c2                	cmp    %eax,%edx
   15589:	7c 10                	jl     1559b <_Convert+0xba>
   1558b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1558e:	8b 50 10             	mov    0x10(%eax),%edx
   15591:	8b 45 08             	mov    0x8(%ebp),%eax
   15594:	8b 40 14             	mov    0x14(%eax),%eax
   15597:	39 c2                	cmp    %eax,%edx
   15599:	7d 0e                	jge    155a9 <_Convert+0xc8>
   1559b:	8b 45 08             	mov    0x8(%ebp),%eax
   1559e:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   155a4:	e9 e5 01 00 00       	jmp    1578e <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   155a9:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   155ad:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   155b1:	8b 45 08             	mov    0x8(%ebp),%eax
   155b4:	8b 40 28             	mov    0x28(%eax),%eax
   155b7:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   155ba:	7f 9f                	jg     1555b <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   155bc:	8b 45 08             	mov    0x8(%ebp),%eax
   155bf:	8b 40 28             	mov    0x28(%eax),%eax
   155c2:	83 f8 03             	cmp    $0x3,%eax
   155c5:	0f 85 3d 01 00 00    	jne    15708 <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   155cb:	8b 45 08             	mov    0x8(%ebp),%eax
   155ce:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   155d4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   155d7:	8b 45 08             	mov    0x8(%ebp),%eax
   155da:	8b 40 54             	mov    0x54(%eax),%eax
   155dd:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   155e0:	8b 45 08             	mov    0x8(%ebp),%eax
   155e3:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   155e9:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   155ec:	8b 45 08             	mov    0x8(%ebp),%eax
   155ef:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   155f5:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   155f8:	8b 45 08             	mov    0x8(%ebp),%eax
   155fb:	8b 40 14             	mov    0x14(%eax),%eax
   155fe:	89 45 d8             	mov    %eax,-0x28(%ebp)
   15601:	e9 f3 00 00 00       	jmp    156f9 <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   15606:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   1560d:	e9 b6 00 00 00       	jmp    156c8 <_Convert+0x1e7>
                register int y = py[x] << 8;
   15612:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15615:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15618:	01 d0                	add    %edx,%eax
   1561a:	0f b6 00             	movzbl (%eax),%eax
   1561d:	0f b6 c0             	movzbl %al,%eax
   15620:	c1 e0 08             	shl    $0x8,%eax
   15623:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   15625:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15628:	8b 45 cc             	mov    -0x34(%ebp),%eax
   1562b:	01 d0                	add    %edx,%eax
   1562d:	0f b6 00             	movzbl (%eax),%eax
   15630:	0f b6 c0             	movzbl %al,%eax
   15633:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   15636:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15639:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1563c:	01 d0                	add    %edx,%eax
   1563e:	0f b6 00             	movzbl (%eax),%eax
   15641:	0f b6 c0             	movzbl %al,%eax
   15644:	83 c0 80             	add    $0xffffff80,%eax
   15647:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   15649:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1564c:	8d 46 01             	lea    0x1(%esi),%eax
   1564f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15652:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   15655:	89 c8                	mov    %ecx,%eax
   15657:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   1565d:	01 d8                	add    %ebx,%eax
   1565f:	83 e8 80             	sub    $0xffffff80,%eax
   15662:	c1 f8 08             	sar    $0x8,%eax
   15665:	83 ec 0c             	sub    $0xc,%esp
   15668:	50                   	push   %eax
   15669:	e8 74 e6 ff ff       	call   13ce2 <_Clip>
   1566e:	83 c4 10             	add    $0x10,%esp
   15671:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   15673:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   15676:	8d 46 01             	lea    0x1(%esi),%eax
   15679:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   1567c:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   1567f:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   15682:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   15689:	01 d0                	add    %edx,%eax
   1568b:	83 e8 80             	sub    $0xffffff80,%eax
   1568e:	c1 f8 08             	sar    $0x8,%eax
   15691:	83 ec 0c             	sub    $0xc,%esp
   15694:	50                   	push   %eax
   15695:	e8 48 e6 ff ff       	call   13ce2 <_Clip>
   1569a:	83 c4 10             	add    $0x10,%esp
   1569d:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   1569f:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   156a2:	8d 46 01             	lea    0x1(%esi),%eax
   156a5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   156a8:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   156ae:	01 d8                	add    %ebx,%eax
   156b0:	83 e8 80             	sub    $0xffffff80,%eax
   156b3:	c1 f8 08             	sar    $0x8,%eax
   156b6:	83 ec 0c             	sub    $0xc,%esp
   156b9:	50                   	push   %eax
   156ba:	e8 23 e6 ff ff       	call   13ce2 <_Clip>
   156bf:	83 c4 10             	add    $0x10,%esp
   156c2:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   156c4:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   156c8:	8b 45 08             	mov    0x8(%ebp),%eax
   156cb:	8b 40 10             	mov    0x10(%eax),%eax
   156ce:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   156d1:	0f 8f 3b ff ff ff    	jg     15612 <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   156d7:	8b 45 08             	mov    0x8(%ebp),%eax
   156da:	8b 40 40             	mov    0x40(%eax),%eax
   156dd:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   156e0:	8b 45 08             	mov    0x8(%ebp),%eax
   156e3:	8b 40 6c             	mov    0x6c(%eax),%eax
   156e6:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   156e9:	8b 45 08             	mov    0x8(%ebp),%eax
   156ec:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   156f2:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   156f5:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   156f9:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   156fd:	0f 85 03 ff ff ff    	jne    15606 <_Convert+0x125>
   15703:	e9 86 00 00 00       	jmp    1578e <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   15708:	8b 45 08             	mov    0x8(%ebp),%eax
   1570b:	8b 50 38             	mov    0x38(%eax),%edx
   1570e:	8b 45 08             	mov    0x8(%ebp),%eax
   15711:	8b 40 40             	mov    0x40(%eax),%eax
   15714:	39 c2                	cmp    %eax,%edx
   15716:	74 76                	je     1578e <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   15718:	8b 45 08             	mov    0x8(%ebp),%eax
   1571b:	8b 50 54             	mov    0x54(%eax),%edx
   1571e:	8b 45 08             	mov    0x8(%ebp),%eax
   15721:	8b 40 40             	mov    0x40(%eax),%eax
   15724:	01 d0                	add    %edx,%eax
   15726:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   15729:	8b 45 08             	mov    0x8(%ebp),%eax
   1572c:	8b 50 54             	mov    0x54(%eax),%edx
   1572f:	8b 45 08             	mov    0x8(%ebp),%eax
   15732:	8b 40 38             	mov    0x38(%eax),%eax
   15735:	01 d0                	add    %edx,%eax
   15737:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   1573a:	8b 45 08             	mov    0x8(%ebp),%eax
   1573d:	8b 40 3c             	mov    0x3c(%eax),%eax
   15740:	83 e8 01             	sub    $0x1,%eax
   15743:	89 45 bc             	mov    %eax,-0x44(%ebp)
   15746:	eb 2e                	jmp    15776 <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   15748:	8b 45 08             	mov    0x8(%ebp),%eax
   1574b:	8b 40 38             	mov    0x38(%eax),%eax
   1574e:	83 ec 04             	sub    $0x4,%esp
   15751:	50                   	push   %eax
   15752:	ff 75 c4             	pushl  -0x3c(%ebp)
   15755:	ff 75 c0             	pushl  -0x40(%ebp)
   15758:	e8 72 ac fe ff       	call   3cf <memmove>
   1575d:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   15760:	8b 45 08             	mov    0x8(%ebp),%eax
   15763:	8b 40 40             	mov    0x40(%eax),%eax
   15766:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   15769:	8b 45 08             	mov    0x8(%ebp),%eax
   1576c:	8b 40 38             	mov    0x38(%eax),%eax
   1576f:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   15772:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   15776:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   1577a:	75 cc                	jne    15748 <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   1577c:	8b 45 08             	mov    0x8(%ebp),%eax
   1577f:	8b 50 38             	mov    0x38(%eax),%edx
   15782:	8b 45 08             	mov    0x8(%ebp),%eax
   15785:	89 50 40             	mov    %edx,0x40(%eax)
   15788:	eb 04                	jmp    1578e <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   1578a:	90                   	nop
   1578b:	eb 01                	jmp    1578e <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   1578d:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   1578e:	8d 65 f4             	lea    -0xc(%ebp),%esp
   15791:	5b                   	pop    %ebx
   15792:	5e                   	pop    %esi
   15793:	5f                   	pop    %edi
   15794:	5d                   	pop    %ebp
   15795:	c3                   	ret    

00015796 <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   15796:	55                   	push   %ebp
   15797:	89 e5                	mov    %esp,%ebp
   15799:	53                   	push   %ebx
   1579a:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   1579d:	8b 45 0c             	mov    0xc(%ebp),%eax
   157a0:	8b 40 0c             	mov    0xc(%eax),%eax
   157a3:	83 e8 03             	sub    $0x3,%eax
   157a6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   157a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   157ac:	8b 50 0c             	mov    0xc(%eax),%edx
   157af:	8b 45 0c             	mov    0xc(%ebp),%eax
   157b2:	8b 40 10             	mov    0x10(%eax),%eax
   157b5:	0f af c2             	imul   %edx,%eax
   157b8:	01 c0                	add    %eax,%eax
   157ba:	83 ec 0c             	sub    $0xc,%esp
   157bd:	50                   	push   %eax
   157be:	e8 cb b0 fe ff       	call   88e <malloc>
   157c3:	83 c4 10             	add    $0x10,%esp
   157c6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   157c9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   157cd:	75 0e                	jne    157dd <_UpsampleH+0x47>
   157cf:	8b 45 08             	mov    0x8(%ebp),%eax
   157d2:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   157d8:	e9 44 03 00 00       	jmp    15b21 <_UpsampleH+0x38b>
    lin = c->pixels;
   157dd:	8b 45 0c             	mov    0xc(%ebp),%eax
   157e0:	8b 40 28             	mov    0x28(%eax),%eax
   157e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   157e6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   157e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   157ec:	8b 45 0c             	mov    0xc(%ebp),%eax
   157ef:	8b 40 10             	mov    0x10(%eax),%eax
   157f2:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   157f5:	e9 e0 02 00 00       	jmp    15ada <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   157fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   157fd:	0f b6 00             	movzbl (%eax),%eax
   15800:	0f b6 c0             	movzbl %al,%eax
   15803:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15809:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1580c:	83 c0 01             	add    $0x1,%eax
   1580f:	0f b6 00             	movzbl (%eax),%eax
   15812:	0f b6 c0             	movzbl %al,%eax
   15815:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15818:	01 d0                	add    %edx,%eax
   1581a:	83 ec 0c             	sub    $0xc,%esp
   1581d:	50                   	push   %eax
   1581e:	e8 c4 06 00 00       	call   15ee7 <CF>
   15823:	83 c4 10             	add    $0x10,%esp
   15826:	89 c2                	mov    %eax,%edx
   15828:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1582b:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   1582d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15830:	8d 58 01             	lea    0x1(%eax),%ebx
   15833:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15836:	0f b6 00             	movzbl (%eax),%eax
   15839:	0f b6 c0             	movzbl %al,%eax
   1583c:	6b c8 68             	imul   $0x68,%eax,%ecx
   1583f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15842:	83 c0 01             	add    $0x1,%eax
   15845:	0f b6 00             	movzbl (%eax),%eax
   15848:	0f b6 d0             	movzbl %al,%edx
   1584b:	89 d0                	mov    %edx,%eax
   1584d:	01 c0                	add    %eax,%eax
   1584f:	01 d0                	add    %edx,%eax
   15851:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15858:	01 d0                	add    %edx,%eax
   1585a:	01 c1                	add    %eax,%ecx
   1585c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1585f:	83 c0 02             	add    $0x2,%eax
   15862:	0f b6 00             	movzbl (%eax),%eax
   15865:	0f b6 d0             	movzbl %al,%edx
   15868:	89 d0                	mov    %edx,%eax
   1586a:	01 c0                	add    %eax,%eax
   1586c:	01 d0                	add    %edx,%eax
   1586e:	f7 d8                	neg    %eax
   15870:	01 c8                	add    %ecx,%eax
   15872:	83 ec 0c             	sub    $0xc,%esp
   15875:	50                   	push   %eax
   15876:	e8 6c 06 00 00       	call   15ee7 <CF>
   1587b:	83 c4 10             	add    $0x10,%esp
   1587e:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   15880:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15883:	8d 58 02             	lea    0x2(%eax),%ebx
   15886:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15889:	0f b6 00             	movzbl (%eax),%eax
   1588c:	0f b6 c0             	movzbl %al,%eax
   1588f:	c1 e0 02             	shl    $0x2,%eax
   15892:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15899:	29 c2                	sub    %eax,%edx
   1589b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1589e:	83 c0 01             	add    $0x1,%eax
   158a1:	0f b6 00             	movzbl (%eax),%eax
   158a4:	0f b6 c0             	movzbl %al,%eax
   158a7:	6b c0 6d             	imul   $0x6d,%eax,%eax
   158aa:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   158ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158b0:	83 c0 02             	add    $0x2,%eax
   158b3:	0f b6 00             	movzbl (%eax),%eax
   158b6:	0f b6 d0             	movzbl %al,%edx
   158b9:	89 d0                	mov    %edx,%eax
   158bb:	c1 e0 03             	shl    $0x3,%eax
   158be:	01 d0                	add    %edx,%eax
   158c0:	f7 d8                	neg    %eax
   158c2:	01 c8                	add    %ecx,%eax
   158c4:	83 ec 0c             	sub    $0xc,%esp
   158c7:	50                   	push   %eax
   158c8:	e8 1a 06 00 00       	call   15ee7 <CF>
   158cd:	83 c4 10             	add    $0x10,%esp
   158d0:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   158d2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   158d9:	e9 fa 00 00 00       	jmp    159d8 <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   158de:	8b 45 ec             	mov    -0x14(%ebp),%eax
   158e1:	01 c0                	add    %eax,%eax
   158e3:	8d 50 03             	lea    0x3(%eax),%edx
   158e6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   158e9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   158ec:	8b 55 ec             	mov    -0x14(%ebp),%edx
   158ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
   158f2:	01 d0                	add    %edx,%eax
   158f4:	0f b6 00             	movzbl (%eax),%eax
   158f7:	0f b6 d0             	movzbl %al,%edx
   158fa:	89 d0                	mov    %edx,%eax
   158fc:	c1 e0 03             	shl    $0x3,%eax
   158ff:	01 d0                	add    %edx,%eax
   15901:	f7 d8                	neg    %eax
   15903:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15906:	8d 4a 01             	lea    0x1(%edx),%ecx
   15909:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1590c:	01 ca                	add    %ecx,%edx
   1590e:	0f b6 12             	movzbl (%edx),%edx
   15911:	0f b6 d2             	movzbl %dl,%edx
   15914:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15917:	01 c2                	add    %eax,%edx
   15919:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1591c:	8d 48 02             	lea    0x2(%eax),%ecx
   1591f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15922:	01 c8                	add    %ecx,%eax
   15924:	0f b6 00             	movzbl (%eax),%eax
   15927:	0f b6 c0             	movzbl %al,%eax
   1592a:	6b c0 1d             	imul   $0x1d,%eax,%eax
   1592d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15930:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15933:	8d 50 03             	lea    0x3(%eax),%edx
   15936:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15939:	01 d0                	add    %edx,%eax
   1593b:	0f b6 00             	movzbl (%eax),%eax
   1593e:	0f b6 d0             	movzbl %al,%edx
   15941:	89 d0                	mov    %edx,%eax
   15943:	01 c0                	add    %eax,%eax
   15945:	01 d0                	add    %edx,%eax
   15947:	f7 d8                	neg    %eax
   15949:	01 c8                	add    %ecx,%eax
   1594b:	83 ec 0c             	sub    $0xc,%esp
   1594e:	50                   	push   %eax
   1594f:	e8 93 05 00 00       	call   15ee7 <CF>
   15954:	83 c4 10             	add    $0x10,%esp
   15957:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   15959:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1595c:	01 c0                	add    %eax,%eax
   1595e:	8d 50 04             	lea    0x4(%eax),%edx
   15961:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15964:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   15967:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1596a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1596d:	01 d0                	add    %edx,%eax
   1596f:	0f b6 00             	movzbl (%eax),%eax
   15972:	0f b6 d0             	movzbl %al,%edx
   15975:	89 d0                	mov    %edx,%eax
   15977:	01 c0                	add    %eax,%eax
   15979:	01 d0                	add    %edx,%eax
   1597b:	f7 d8                	neg    %eax
   1597d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15980:	8d 4a 01             	lea    0x1(%edx),%ecx
   15983:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15986:	01 ca                	add    %ecx,%edx
   15988:	0f b6 12             	movzbl (%edx),%edx
   1598b:	0f b6 d2             	movzbl %dl,%edx
   1598e:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15991:	01 c2                	add    %eax,%edx
   15993:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15996:	8d 48 02             	lea    0x2(%eax),%ecx
   15999:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1599c:	01 c8                	add    %ecx,%eax
   1599e:	0f b6 00             	movzbl (%eax),%eax
   159a1:	0f b6 c0             	movzbl %al,%eax
   159a4:	6b c0 6f             	imul   $0x6f,%eax,%eax
   159a7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   159aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
   159ad:	8d 50 03             	lea    0x3(%eax),%edx
   159b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159b3:	01 d0                	add    %edx,%eax
   159b5:	0f b6 00             	movzbl (%eax),%eax
   159b8:	0f b6 d0             	movzbl %al,%edx
   159bb:	89 d0                	mov    %edx,%eax
   159bd:	c1 e0 03             	shl    $0x3,%eax
   159c0:	01 d0                	add    %edx,%eax
   159c2:	f7 d8                	neg    %eax
   159c4:	01 c8                	add    %ecx,%eax
   159c6:	83 ec 0c             	sub    $0xc,%esp
   159c9:	50                   	push   %eax
   159ca:	e8 18 05 00 00       	call   15ee7 <CF>
   159cf:	83 c4 10             	add    $0x10,%esp
   159d2:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   159d4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   159d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   159db:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   159de:	0f 8c fa fe ff ff    	jl     158de <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   159e4:	8b 45 0c             	mov    0xc(%ebp),%eax
   159e7:	8b 40 14             	mov    0x14(%eax),%eax
   159ea:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   159ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   159f0:	8b 40 0c             	mov    0xc(%eax),%eax
   159f3:	01 c0                	add    %eax,%eax
   159f5:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   159f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   159fb:	8d 58 fd             	lea    -0x3(%eax),%ebx
   159fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a01:	83 e8 01             	sub    $0x1,%eax
   15a04:	0f b6 00             	movzbl (%eax),%eax
   15a07:	0f b6 c0             	movzbl %al,%eax
   15a0a:	c1 e0 02             	shl    $0x2,%eax
   15a0d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15a14:	29 c2                	sub    %eax,%edx
   15a16:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a19:	83 e8 02             	sub    $0x2,%eax
   15a1c:	0f b6 00             	movzbl (%eax),%eax
   15a1f:	0f b6 c0             	movzbl %al,%eax
   15a22:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15a25:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15a28:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a2b:	83 e8 03             	sub    $0x3,%eax
   15a2e:	0f b6 00             	movzbl (%eax),%eax
   15a31:	0f b6 d0             	movzbl %al,%edx
   15a34:	89 d0                	mov    %edx,%eax
   15a36:	c1 e0 03             	shl    $0x3,%eax
   15a39:	01 d0                	add    %edx,%eax
   15a3b:	f7 d8                	neg    %eax
   15a3d:	01 c8                	add    %ecx,%eax
   15a3f:	83 ec 0c             	sub    $0xc,%esp
   15a42:	50                   	push   %eax
   15a43:	e8 9f 04 00 00       	call   15ee7 <CF>
   15a48:	83 c4 10             	add    $0x10,%esp
   15a4b:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   15a4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a50:	8d 58 fe             	lea    -0x2(%eax),%ebx
   15a53:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a56:	83 e8 01             	sub    $0x1,%eax
   15a59:	0f b6 00             	movzbl (%eax),%eax
   15a5c:	0f b6 c0             	movzbl %al,%eax
   15a5f:	6b c8 68             	imul   $0x68,%eax,%ecx
   15a62:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a65:	83 e8 02             	sub    $0x2,%eax
   15a68:	0f b6 00             	movzbl (%eax),%eax
   15a6b:	0f b6 d0             	movzbl %al,%edx
   15a6e:	89 d0                	mov    %edx,%eax
   15a70:	01 c0                	add    %eax,%eax
   15a72:	01 d0                	add    %edx,%eax
   15a74:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15a7b:	01 d0                	add    %edx,%eax
   15a7d:	01 c1                	add    %eax,%ecx
   15a7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a82:	83 e8 03             	sub    $0x3,%eax
   15a85:	0f b6 00             	movzbl (%eax),%eax
   15a88:	0f b6 d0             	movzbl %al,%edx
   15a8b:	89 d0                	mov    %edx,%eax
   15a8d:	01 c0                	add    %eax,%eax
   15a8f:	01 d0                	add    %edx,%eax
   15a91:	f7 d8                	neg    %eax
   15a93:	01 c8                	add    %ecx,%eax
   15a95:	83 ec 0c             	sub    $0xc,%esp
   15a98:	50                   	push   %eax
   15a99:	e8 49 04 00 00       	call   15ee7 <CF>
   15a9e:	83 c4 10             	add    $0x10,%esp
   15aa1:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   15aa3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15aa6:	8d 58 ff             	lea    -0x1(%eax),%ebx
   15aa9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15aac:	83 e8 01             	sub    $0x1,%eax
   15aaf:	0f b6 00             	movzbl (%eax),%eax
   15ab2:	0f b6 c0             	movzbl %al,%eax
   15ab5:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15abb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15abe:	83 e8 02             	sub    $0x2,%eax
   15ac1:	0f b6 00             	movzbl (%eax),%eax
   15ac4:	0f b6 c0             	movzbl %al,%eax
   15ac7:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15aca:	01 d0                	add    %edx,%eax
   15acc:	83 ec 0c             	sub    $0xc,%esp
   15acf:	50                   	push   %eax
   15ad0:	e8 12 04 00 00       	call   15ee7 <CF>
   15ad5:	83 c4 10             	add    $0x10,%esp
   15ad8:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   15ada:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15add:	8d 50 ff             	lea    -0x1(%eax),%edx
   15ae0:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15ae3:	85 c0                	test   %eax,%eax
   15ae5:	0f 85 0f fd ff ff    	jne    157fa <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   15aeb:	8b 45 0c             	mov    0xc(%ebp),%eax
   15aee:	8b 40 0c             	mov    0xc(%eax),%eax
   15af1:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15af4:	8b 45 0c             	mov    0xc(%ebp),%eax
   15af7:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   15afa:	8b 45 0c             	mov    0xc(%ebp),%eax
   15afd:	8b 50 0c             	mov    0xc(%eax),%edx
   15b00:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b03:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15b06:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b09:	8b 40 28             	mov    0x28(%eax),%eax
   15b0c:	83 ec 0c             	sub    $0xc,%esp
   15b0f:	50                   	push   %eax
   15b10:	e8 37 ac fe ff       	call   74c <free>
   15b15:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15b18:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b1b:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15b1e:	89 50 28             	mov    %edx,0x28(%eax)
}
   15b21:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15b24:	c9                   	leave  
   15b25:	c3                   	ret    

00015b26 <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   15b26:	55                   	push   %ebp
   15b27:	89 e5                	mov    %esp,%ebp
   15b29:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   15b2c:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b2f:	8b 40 0c             	mov    0xc(%eax),%eax
   15b32:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   15b35:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b38:	8b 40 14             	mov    0x14(%eax),%eax
   15b3b:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15b3e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15b41:	01 c0                	add    %eax,%eax
   15b43:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15b46:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b49:	8b 50 0c             	mov    0xc(%eax),%edx
   15b4c:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b4f:	8b 40 10             	mov    0x10(%eax),%eax
   15b52:	0f af c2             	imul   %edx,%eax
   15b55:	01 c0                	add    %eax,%eax
   15b57:	83 ec 0c             	sub    $0xc,%esp
   15b5a:	50                   	push   %eax
   15b5b:	e8 2e ad fe ff       	call   88e <malloc>
   15b60:	83 c4 10             	add    $0x10,%esp
   15b63:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15b66:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15b6a:	75 0e                	jne    15b7a <_UpsampleV+0x54>
   15b6c:	8b 45 08             	mov    0x8(%ebp),%eax
   15b6f:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15b75:	e9 6b 03 00 00       	jmp    15ee5 <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   15b7a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15b81:	e9 1d 03 00 00       	jmp    15ea3 <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   15b86:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b89:	8b 50 28             	mov    0x28(%eax),%edx
   15b8c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15b8f:	01 d0                	add    %edx,%eax
   15b91:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   15b94:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15b97:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15b9a:	01 d0                	add    %edx,%eax
   15b9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   15b9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ba2:	0f b6 00             	movzbl (%eax),%eax
   15ba5:	0f b6 c0             	movzbl %al,%eax
   15ba8:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15bae:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   15bb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bb4:	01 c8                	add    %ecx,%eax
   15bb6:	0f b6 00             	movzbl (%eax),%eax
   15bb9:	0f b6 c0             	movzbl %al,%eax
   15bbc:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15bbf:	01 d0                	add    %edx,%eax
   15bc1:	83 ec 0c             	sub    $0xc,%esp
   15bc4:	50                   	push   %eax
   15bc5:	e8 1d 03 00 00       	call   15ee7 <CF>
   15bca:	83 c4 10             	add    $0x10,%esp
   15bcd:	89 c2                	mov    %eax,%edx
   15bcf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15bd2:	88 10                	mov    %dl,(%eax)
   15bd4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15bd7:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   15bda:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bdd:	0f b6 00             	movzbl (%eax),%eax
   15be0:	0f b6 c0             	movzbl %al,%eax
   15be3:	6b c8 68             	imul   $0x68,%eax,%ecx
   15be6:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15be9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bec:	01 d0                	add    %edx,%eax
   15bee:	0f b6 00             	movzbl (%eax),%eax
   15bf1:	0f b6 d0             	movzbl %al,%edx
   15bf4:	89 d0                	mov    %edx,%eax
   15bf6:	01 c0                	add    %eax,%eax
   15bf8:	01 d0                	add    %edx,%eax
   15bfa:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15c01:	01 d0                	add    %edx,%eax
   15c03:	01 c1                	add    %eax,%ecx
   15c05:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15c08:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c0b:	01 d0                	add    %edx,%eax
   15c0d:	0f b6 00             	movzbl (%eax),%eax
   15c10:	0f b6 d0             	movzbl %al,%edx
   15c13:	89 d0                	mov    %edx,%eax
   15c15:	01 c0                	add    %eax,%eax
   15c17:	01 d0                	add    %edx,%eax
   15c19:	f7 d8                	neg    %eax
   15c1b:	01 c8                	add    %ecx,%eax
   15c1d:	83 ec 0c             	sub    $0xc,%esp
   15c20:	50                   	push   %eax
   15c21:	e8 c1 02 00 00       	call   15ee7 <CF>
   15c26:	83 c4 10             	add    $0x10,%esp
   15c29:	89 c2                	mov    %eax,%edx
   15c2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c2e:	88 10                	mov    %dl,(%eax)
   15c30:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15c33:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   15c36:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c39:	0f b6 00             	movzbl (%eax),%eax
   15c3c:	0f b6 c0             	movzbl %al,%eax
   15c3f:	c1 e0 02             	shl    $0x2,%eax
   15c42:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15c49:	89 d1                	mov    %edx,%ecx
   15c4b:	29 c1                	sub    %eax,%ecx
   15c4d:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15c50:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c53:	01 d0                	add    %edx,%eax
   15c55:	0f b6 00             	movzbl (%eax),%eax
   15c58:	0f b6 c0             	movzbl %al,%eax
   15c5b:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15c5e:	01 c1                	add    %eax,%ecx
   15c60:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15c63:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c66:	01 d0                	add    %edx,%eax
   15c68:	0f b6 00             	movzbl (%eax),%eax
   15c6b:	0f b6 d0             	movzbl %al,%edx
   15c6e:	89 d0                	mov    %edx,%eax
   15c70:	c1 e0 03             	shl    $0x3,%eax
   15c73:	01 d0                	add    %edx,%eax
   15c75:	f7 d8                	neg    %eax
   15c77:	01 c8                	add    %ecx,%eax
   15c79:	83 ec 0c             	sub    $0xc,%esp
   15c7c:	50                   	push   %eax
   15c7d:	e8 65 02 00 00       	call   15ee7 <CF>
   15c82:	83 c4 10             	add    $0x10,%esp
   15c85:	89 c2                	mov    %eax,%edx
   15c87:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c8a:	88 10                	mov    %dl,(%eax)
   15c8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15c8f:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   15c92:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15c95:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   15c98:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c9b:	8b 40 10             	mov    0x10(%eax),%eax
   15c9e:	83 e8 03             	sub    $0x3,%eax
   15ca1:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15ca4:	e9 e6 00 00 00       	jmp    15d8f <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   15ca9:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15cac:	f7 d8                	neg    %eax
   15cae:	89 c2                	mov    %eax,%edx
   15cb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cb3:	01 d0                	add    %edx,%eax
   15cb5:	0f b6 00             	movzbl (%eax),%eax
   15cb8:	0f b6 d0             	movzbl %al,%edx
   15cbb:	89 d0                	mov    %edx,%eax
   15cbd:	c1 e0 03             	shl    $0x3,%eax
   15cc0:	01 d0                	add    %edx,%eax
   15cc2:	f7 d8                	neg    %eax
   15cc4:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15cc7:	0f b6 12             	movzbl (%edx),%edx
   15cca:	0f b6 d2             	movzbl %dl,%edx
   15ccd:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15cd0:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15cd3:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15cd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cd9:	01 d0                	add    %edx,%eax
   15cdb:	0f b6 00             	movzbl (%eax),%eax
   15cde:	0f b6 c0             	movzbl %al,%eax
   15ce1:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15ce4:	01 c1                	add    %eax,%ecx
   15ce6:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15ce9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15cec:	01 d0                	add    %edx,%eax
   15cee:	0f b6 00             	movzbl (%eax),%eax
   15cf1:	0f b6 d0             	movzbl %al,%edx
   15cf4:	89 d0                	mov    %edx,%eax
   15cf6:	01 c0                	add    %eax,%eax
   15cf8:	01 d0                	add    %edx,%eax
   15cfa:	f7 d8                	neg    %eax
   15cfc:	01 c8                	add    %ecx,%eax
   15cfe:	83 ec 0c             	sub    $0xc,%esp
   15d01:	50                   	push   %eax
   15d02:	e8 e0 01 00 00       	call   15ee7 <CF>
   15d07:	83 c4 10             	add    $0x10,%esp
   15d0a:	89 c2                	mov    %eax,%edx
   15d0c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d0f:	88 10                	mov    %dl,(%eax)
   15d11:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d14:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   15d17:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d1a:	f7 d8                	neg    %eax
   15d1c:	89 c2                	mov    %eax,%edx
   15d1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d21:	01 d0                	add    %edx,%eax
   15d23:	0f b6 00             	movzbl (%eax),%eax
   15d26:	0f b6 d0             	movzbl %al,%edx
   15d29:	89 d0                	mov    %edx,%eax
   15d2b:	01 c0                	add    %eax,%eax
   15d2d:	01 d0                	add    %edx,%eax
   15d2f:	f7 d8                	neg    %eax
   15d31:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15d34:	0f b6 12             	movzbl (%edx),%edx
   15d37:	0f b6 d2             	movzbl %dl,%edx
   15d3a:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15d3d:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15d40:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15d43:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d46:	01 d0                	add    %edx,%eax
   15d48:	0f b6 00             	movzbl (%eax),%eax
   15d4b:	0f b6 c0             	movzbl %al,%eax
   15d4e:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15d51:	01 c1                	add    %eax,%ecx
   15d53:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15d56:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d59:	01 d0                	add    %edx,%eax
   15d5b:	0f b6 00             	movzbl (%eax),%eax
   15d5e:	0f b6 d0             	movzbl %al,%edx
   15d61:	89 d0                	mov    %edx,%eax
   15d63:	c1 e0 03             	shl    $0x3,%eax
   15d66:	01 d0                	add    %edx,%eax
   15d68:	f7 d8                	neg    %eax
   15d6a:	01 c8                	add    %ecx,%eax
   15d6c:	83 ec 0c             	sub    $0xc,%esp
   15d6f:	50                   	push   %eax
   15d70:	e8 72 01 00 00       	call   15ee7 <CF>
   15d75:	83 c4 10             	add    $0x10,%esp
   15d78:	89 c2                	mov    %eax,%edx
   15d7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d7d:	88 10                	mov    %dl,(%eax)
   15d7f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d82:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   15d85:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d88:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   15d8b:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   15d8f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15d93:	0f 85 10 ff ff ff    	jne    15ca9 <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   15d99:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15d9c:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   15d9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15da2:	0f b6 00             	movzbl (%eax),%eax
   15da5:	0f b6 c0             	movzbl %al,%eax
   15da8:	c1 e0 02             	shl    $0x2,%eax
   15dab:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15db2:	29 c2                	sub    %eax,%edx
   15db4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15db7:	f7 d8                	neg    %eax
   15db9:	89 c1                	mov    %eax,%ecx
   15dbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dbe:	01 c8                	add    %ecx,%eax
   15dc0:	0f b6 00             	movzbl (%eax),%eax
   15dc3:	0f b6 c0             	movzbl %al,%eax
   15dc6:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15dc9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15dcc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15dcf:	f7 d8                	neg    %eax
   15dd1:	89 c2                	mov    %eax,%edx
   15dd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dd6:	01 d0                	add    %edx,%eax
   15dd8:	0f b6 00             	movzbl (%eax),%eax
   15ddb:	0f b6 d0             	movzbl %al,%edx
   15dde:	89 d0                	mov    %edx,%eax
   15de0:	c1 e0 03             	shl    $0x3,%eax
   15de3:	01 d0                	add    %edx,%eax
   15de5:	f7 d8                	neg    %eax
   15de7:	01 c8                	add    %ecx,%eax
   15de9:	83 ec 0c             	sub    $0xc,%esp
   15dec:	50                   	push   %eax
   15ded:	e8 f5 00 00 00       	call   15ee7 <CF>
   15df2:	83 c4 10             	add    $0x10,%esp
   15df5:	89 c2                	mov    %eax,%edx
   15df7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15dfa:	88 10                	mov    %dl,(%eax)
   15dfc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15dff:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   15e02:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e05:	0f b6 00             	movzbl (%eax),%eax
   15e08:	0f b6 c0             	movzbl %al,%eax
   15e0b:	6b c8 68             	imul   $0x68,%eax,%ecx
   15e0e:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15e11:	f7 d8                	neg    %eax
   15e13:	89 c2                	mov    %eax,%edx
   15e15:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e18:	01 d0                	add    %edx,%eax
   15e1a:	0f b6 00             	movzbl (%eax),%eax
   15e1d:	0f b6 d0             	movzbl %al,%edx
   15e20:	89 d0                	mov    %edx,%eax
   15e22:	01 c0                	add    %eax,%eax
   15e24:	01 d0                	add    %edx,%eax
   15e26:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15e2d:	01 d0                	add    %edx,%eax
   15e2f:	01 c1                	add    %eax,%ecx
   15e31:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15e34:	f7 d8                	neg    %eax
   15e36:	89 c2                	mov    %eax,%edx
   15e38:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e3b:	01 d0                	add    %edx,%eax
   15e3d:	0f b6 00             	movzbl (%eax),%eax
   15e40:	0f b6 d0             	movzbl %al,%edx
   15e43:	89 d0                	mov    %edx,%eax
   15e45:	01 c0                	add    %eax,%eax
   15e47:	01 d0                	add    %edx,%eax
   15e49:	f7 d8                	neg    %eax
   15e4b:	01 c8                	add    %ecx,%eax
   15e4d:	83 ec 0c             	sub    $0xc,%esp
   15e50:	50                   	push   %eax
   15e51:	e8 91 00 00 00       	call   15ee7 <CF>
   15e56:	83 c4 10             	add    $0x10,%esp
   15e59:	89 c2                	mov    %eax,%edx
   15e5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e5e:	88 10                	mov    %dl,(%eax)
   15e60:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15e63:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   15e66:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e69:	0f b6 00             	movzbl (%eax),%eax
   15e6c:	0f b6 c0             	movzbl %al,%eax
   15e6f:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15e75:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15e78:	f7 d8                	neg    %eax
   15e7a:	89 c1                	mov    %eax,%ecx
   15e7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e7f:	01 c8                	add    %ecx,%eax
   15e81:	0f b6 00             	movzbl (%eax),%eax
   15e84:	0f b6 c0             	movzbl %al,%eax
   15e87:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15e8a:	01 d0                	add    %edx,%eax
   15e8c:	83 ec 0c             	sub    $0xc,%esp
   15e8f:	50                   	push   %eax
   15e90:	e8 52 00 00 00       	call   15ee7 <CF>
   15e95:	83 c4 10             	add    $0x10,%esp
   15e98:	89 c2                	mov    %eax,%edx
   15e9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e9d:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   15e9f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15ea3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15ea6:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15ea9:	0f 8c d7 fc ff ff    	jl     15b86 <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   15eaf:	8b 45 0c             	mov    0xc(%ebp),%eax
   15eb2:	8b 40 10             	mov    0x10(%eax),%eax
   15eb5:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15eb8:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ebb:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   15ebe:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ec1:	8b 50 0c             	mov    0xc(%eax),%edx
   15ec4:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ec7:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15eca:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ecd:	8b 40 28             	mov    0x28(%eax),%eax
   15ed0:	83 ec 0c             	sub    $0xc,%esp
   15ed3:	50                   	push   %eax
   15ed4:	e8 73 a8 fe ff       	call   74c <free>
   15ed9:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15edc:	8b 45 0c             	mov    0xc(%ebp),%eax
   15edf:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15ee2:	89 50 28             	mov    %edx,0x28(%eax)
}
   15ee5:	c9                   	leave  
   15ee6:	c3                   	ret    

00015ee7 <CF>:

uchar CF(const int x){
   15ee7:	55                   	push   %ebp
   15ee8:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   15eea:	8b 45 08             	mov    0x8(%ebp),%eax
   15eed:	83 c0 40             	add    $0x40,%eax
   15ef0:	c1 f8 07             	sar    $0x7,%eax
   15ef3:	50                   	push   %eax
   15ef4:	e8 e9 dd ff ff       	call   13ce2 <_Clip>
   15ef9:	83 c4 04             	add    $0x4,%esp
}
   15efc:	c9                   	leave  
   15efd:	c3                   	ret    
