
_grep：     文件格式 elf32-i386


Disassembly of section .text:

00000000 <grep>:
char buf[1024];
int match(char*, char*);

void
grep(char *pattern, int fd)
{
       0:	55                   	push   %ebp
       1:	89 e5                	mov    %esp,%ebp
       3:	83 ec 18             	sub    $0x18,%esp
  int n, m;
  char *p, *q;
  
  m = 0;
       6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
       d:	e9 b6 00 00 00       	jmp    c8 <grep+0xc8>
    m += n;
      12:	8b 45 ec             	mov    -0x14(%ebp),%eax
      15:	01 45 f4             	add    %eax,-0xc(%ebp)
    buf[m] = '\0';
      18:	8b 45 f4             	mov    -0xc(%ebp),%eax
      1b:	05 80 e8 01 00       	add    $0x1e880,%eax
      20:	c6 00 00             	movb   $0x0,(%eax)
    p = buf;
      23:	c7 45 f0 80 e8 01 00 	movl   $0x1e880,-0x10(%ebp)
    while((q = strchr(p, '\n')) != 0){
      2a:	eb 4a                	jmp    76 <grep+0x76>
      *q = 0;
      2c:	8b 45 e8             	mov    -0x18(%ebp),%eax
      2f:	c6 00 00             	movb   $0x0,(%eax)
      if(match(pattern, p)){
      32:	83 ec 08             	sub    $0x8,%esp
      35:	ff 75 f0             	pushl  -0x10(%ebp)
      38:	ff 75 08             	pushl  0x8(%ebp)
      3b:	e8 9a 01 00 00       	call   1da <match>
      40:	83 c4 10             	add    $0x10,%esp
      43:	85 c0                	test   %eax,%eax
      45:	74 26                	je     6d <grep+0x6d>
        *q = '\n';
      47:	8b 45 e8             	mov    -0x18(%ebp),%eax
      4a:	c6 00 0a             	movb   $0xa,(%eax)
        write(1, p, q+1 - p);
      4d:	8b 45 e8             	mov    -0x18(%ebp),%eax
      50:	83 c0 01             	add    $0x1,%eax
      53:	89 c2                	mov    %eax,%edx
      55:	8b 45 f0             	mov    -0x10(%ebp),%eax
      58:	29 c2                	sub    %eax,%edx
      5a:	89 d0                	mov    %edx,%eax
      5c:	83 ec 04             	sub    $0x4,%esp
      5f:	50                   	push   %eax
      60:	ff 75 f0             	pushl  -0x10(%ebp)
      63:	6a 01                	push   $0x1
      65:	e8 43 05 00 00       	call   5ad <write>
      6a:	83 c4 10             	add    $0x10,%esp
      }
      p = q+1;
      6d:	8b 45 e8             	mov    -0x18(%ebp),%eax
      70:	83 c0 01             	add    $0x1,%eax
      73:	89 45 f0             	mov    %eax,-0x10(%ebp)
  m = 0;
  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
    m += n;
    buf[m] = '\0';
    p = buf;
    while((q = strchr(p, '\n')) != 0){
      76:	83 ec 08             	sub    $0x8,%esp
      79:	6a 0a                	push   $0xa
      7b:	ff 75 f0             	pushl  -0x10(%ebp)
      7e:	e8 89 03 00 00       	call   40c <strchr>
      83:	83 c4 10             	add    $0x10,%esp
      86:	89 45 e8             	mov    %eax,-0x18(%ebp)
      89:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
      8d:	75 9d                	jne    2c <grep+0x2c>
        *q = '\n';
        write(1, p, q+1 - p);
      }
      p = q+1;
    }
    if(p == buf)
      8f:	81 7d f0 80 e8 01 00 	cmpl   $0x1e880,-0x10(%ebp)
      96:	75 07                	jne    9f <grep+0x9f>
      m = 0;
      98:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if(m > 0){
      9f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
      a3:	7e 23                	jle    c8 <grep+0xc8>
      m -= p - buf;
      a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
      a8:	ba 80 e8 01 00       	mov    $0x1e880,%edx
      ad:	29 d0                	sub    %edx,%eax
      af:	29 45 f4             	sub    %eax,-0xc(%ebp)
      memmove(buf, p, m);
      b2:	83 ec 04             	sub    $0x4,%esp
      b5:	ff 75 f4             	pushl  -0xc(%ebp)
      b8:	ff 75 f0             	pushl  -0x10(%ebp)
      bb:	68 80 e8 01 00       	push   $0x1e880
      c0:	e8 83 04 00 00       	call   548 <memmove>
      c5:	83 c4 10             	add    $0x10,%esp
{
  int n, m;
  char *p, *q;
  
  m = 0;
  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
      c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
      cb:	ba ff 03 00 00       	mov    $0x3ff,%edx
      d0:	29 c2                	sub    %eax,%edx
      d2:	89 d0                	mov    %edx,%eax
      d4:	89 c2                	mov    %eax,%edx
      d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
      d9:	05 80 e8 01 00       	add    $0x1e880,%eax
      de:	83 ec 04             	sub    $0x4,%esp
      e1:	52                   	push   %edx
      e2:	50                   	push   %eax
      e3:	ff 75 0c             	pushl  0xc(%ebp)
      e6:	e8 ba 04 00 00       	call   5a5 <read>
      eb:	83 c4 10             	add    $0x10,%esp
      ee:	89 45 ec             	mov    %eax,-0x14(%ebp)
      f1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
      f5:	0f 8f 17 ff ff ff    	jg     12 <grep+0x12>
    if(m > 0){
      m -= p - buf;
      memmove(buf, p, m);
    }
  }
}
      fb:	90                   	nop
      fc:	c9                   	leave  
      fd:	c3                   	ret    

000000fe <main>:

int
main(int argc, char *argv[])
{
      fe:	8d 4c 24 04          	lea    0x4(%esp),%ecx
     102:	83 e4 f0             	and    $0xfffffff0,%esp
     105:	ff 71 fc             	pushl  -0x4(%ecx)
     108:	55                   	push   %ebp
     109:	89 e5                	mov    %esp,%ebp
     10b:	53                   	push   %ebx
     10c:	51                   	push   %ecx
     10d:	83 ec 10             	sub    $0x10,%esp
     110:	89 cb                	mov    %ecx,%ebx
  int fd, i;
  char *pattern;
  
  if(argc <= 1){
     112:	83 3b 01             	cmpl   $0x1,(%ebx)
     115:	7f 17                	jg     12e <main+0x30>
    printf(2, "usage: grep pattern [file ...]\n");
     117:	83 ec 08             	sub    $0x8,%esp
     11a:	68 80 60 01 00       	push   $0x16080
     11f:	6a 02                	push   $0x2
     121:	e8 0e 06 00 00       	call   734 <printf>
     126:	83 c4 10             	add    $0x10,%esp
    exit();
     129:	e8 5f 04 00 00       	call   58d <exit>
  }
  pattern = argv[1];
     12e:	8b 43 04             	mov    0x4(%ebx),%eax
     131:	8b 40 04             	mov    0x4(%eax),%eax
     134:	89 45 f0             	mov    %eax,-0x10(%ebp)
  
  if(argc <= 2){
     137:	83 3b 02             	cmpl   $0x2,(%ebx)
     13a:	7f 15                	jg     151 <main+0x53>
    grep(pattern, 0);
     13c:	83 ec 08             	sub    $0x8,%esp
     13f:	6a 00                	push   $0x0
     141:	ff 75 f0             	pushl  -0x10(%ebp)
     144:	e8 b7 fe ff ff       	call   0 <grep>
     149:	83 c4 10             	add    $0x10,%esp
    exit();
     14c:	e8 3c 04 00 00       	call   58d <exit>
  }

  for(i = 2; i < argc; i++){
     151:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
     158:	eb 74                	jmp    1ce <main+0xd0>
    if((fd = open(argv[i], 0)) < 0){
     15a:	8b 45 f4             	mov    -0xc(%ebp),%eax
     15d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
     164:	8b 43 04             	mov    0x4(%ebx),%eax
     167:	01 d0                	add    %edx,%eax
     169:	8b 00                	mov    (%eax),%eax
     16b:	83 ec 08             	sub    $0x8,%esp
     16e:	6a 00                	push   $0x0
     170:	50                   	push   %eax
     171:	e8 57 04 00 00       	call   5cd <open>
     176:	83 c4 10             	add    $0x10,%esp
     179:	89 45 ec             	mov    %eax,-0x14(%ebp)
     17c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     180:	79 29                	jns    1ab <main+0xad>
      printf(1, "grep: cannot open %s\n", argv[i]);
     182:	8b 45 f4             	mov    -0xc(%ebp),%eax
     185:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
     18c:	8b 43 04             	mov    0x4(%ebx),%eax
     18f:	01 d0                	add    %edx,%eax
     191:	8b 00                	mov    (%eax),%eax
     193:	83 ec 04             	sub    $0x4,%esp
     196:	50                   	push   %eax
     197:	68 a0 60 01 00       	push   $0x160a0
     19c:	6a 01                	push   $0x1
     19e:	e8 91 05 00 00       	call   734 <printf>
     1a3:	83 c4 10             	add    $0x10,%esp
      exit();
     1a6:	e8 e2 03 00 00       	call   58d <exit>
    }
    grep(pattern, fd);
     1ab:	83 ec 08             	sub    $0x8,%esp
     1ae:	ff 75 ec             	pushl  -0x14(%ebp)
     1b1:	ff 75 f0             	pushl  -0x10(%ebp)
     1b4:	e8 47 fe ff ff       	call   0 <grep>
     1b9:	83 c4 10             	add    $0x10,%esp
    close(fd);
     1bc:	83 ec 0c             	sub    $0xc,%esp
     1bf:	ff 75 ec             	pushl  -0x14(%ebp)
     1c2:	e8 ee 03 00 00       	call   5b5 <close>
     1c7:	83 c4 10             	add    $0x10,%esp
  if(argc <= 2){
    grep(pattern, 0);
    exit();
  }

  for(i = 2; i < argc; i++){
     1ca:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
     1ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
     1d1:	3b 03                	cmp    (%ebx),%eax
     1d3:	7c 85                	jl     15a <main+0x5c>
      exit();
    }
    grep(pattern, fd);
    close(fd);
  }
  exit();
     1d5:	e8 b3 03 00 00       	call   58d <exit>

000001da <match>:
int matchhere(char*, char*);
int matchstar(int, char*, char*);

int
match(char *re, char *text)
{
     1da:	55                   	push   %ebp
     1db:	89 e5                	mov    %esp,%ebp
     1dd:	83 ec 08             	sub    $0x8,%esp
  if(re[0] == '^')
     1e0:	8b 45 08             	mov    0x8(%ebp),%eax
     1e3:	0f b6 00             	movzbl (%eax),%eax
     1e6:	3c 5e                	cmp    $0x5e,%al
     1e8:	75 17                	jne    201 <match+0x27>
    return matchhere(re+1, text);
     1ea:	8b 45 08             	mov    0x8(%ebp),%eax
     1ed:	83 c0 01             	add    $0x1,%eax
     1f0:	83 ec 08             	sub    $0x8,%esp
     1f3:	ff 75 0c             	pushl  0xc(%ebp)
     1f6:	50                   	push   %eax
     1f7:	e8 38 00 00 00       	call   234 <matchhere>
     1fc:	83 c4 10             	add    $0x10,%esp
     1ff:	eb 31                	jmp    232 <match+0x58>
  do{  // must look at empty string
    if(matchhere(re, text))
     201:	83 ec 08             	sub    $0x8,%esp
     204:	ff 75 0c             	pushl  0xc(%ebp)
     207:	ff 75 08             	pushl  0x8(%ebp)
     20a:	e8 25 00 00 00       	call   234 <matchhere>
     20f:	83 c4 10             	add    $0x10,%esp
     212:	85 c0                	test   %eax,%eax
     214:	74 07                	je     21d <match+0x43>
      return 1;
     216:	b8 01 00 00 00       	mov    $0x1,%eax
     21b:	eb 15                	jmp    232 <match+0x58>
  }while(*text++ != '\0');
     21d:	8b 45 0c             	mov    0xc(%ebp),%eax
     220:	8d 50 01             	lea    0x1(%eax),%edx
     223:	89 55 0c             	mov    %edx,0xc(%ebp)
     226:	0f b6 00             	movzbl (%eax),%eax
     229:	84 c0                	test   %al,%al
     22b:	75 d4                	jne    201 <match+0x27>
  return 0;
     22d:	b8 00 00 00 00       	mov    $0x0,%eax
}
     232:	c9                   	leave  
     233:	c3                   	ret    

00000234 <matchhere>:

// matchhere: search for re at beginning of text
int matchhere(char *re, char *text)
{
     234:	55                   	push   %ebp
     235:	89 e5                	mov    %esp,%ebp
     237:	83 ec 08             	sub    $0x8,%esp
  if(re[0] == '\0')
     23a:	8b 45 08             	mov    0x8(%ebp),%eax
     23d:	0f b6 00             	movzbl (%eax),%eax
     240:	84 c0                	test   %al,%al
     242:	75 0a                	jne    24e <matchhere+0x1a>
    return 1;
     244:	b8 01 00 00 00       	mov    $0x1,%eax
     249:	e9 99 00 00 00       	jmp    2e7 <matchhere+0xb3>
  if(re[1] == '*')
     24e:	8b 45 08             	mov    0x8(%ebp),%eax
     251:	83 c0 01             	add    $0x1,%eax
     254:	0f b6 00             	movzbl (%eax),%eax
     257:	3c 2a                	cmp    $0x2a,%al
     259:	75 21                	jne    27c <matchhere+0x48>
    return matchstar(re[0], re+2, text);
     25b:	8b 45 08             	mov    0x8(%ebp),%eax
     25e:	8d 50 02             	lea    0x2(%eax),%edx
     261:	8b 45 08             	mov    0x8(%ebp),%eax
     264:	0f b6 00             	movzbl (%eax),%eax
     267:	0f be c0             	movsbl %al,%eax
     26a:	83 ec 04             	sub    $0x4,%esp
     26d:	ff 75 0c             	pushl  0xc(%ebp)
     270:	52                   	push   %edx
     271:	50                   	push   %eax
     272:	e8 72 00 00 00       	call   2e9 <matchstar>
     277:	83 c4 10             	add    $0x10,%esp
     27a:	eb 6b                	jmp    2e7 <matchhere+0xb3>
  if(re[0] == '$' && re[1] == '\0')
     27c:	8b 45 08             	mov    0x8(%ebp),%eax
     27f:	0f b6 00             	movzbl (%eax),%eax
     282:	3c 24                	cmp    $0x24,%al
     284:	75 1d                	jne    2a3 <matchhere+0x6f>
     286:	8b 45 08             	mov    0x8(%ebp),%eax
     289:	83 c0 01             	add    $0x1,%eax
     28c:	0f b6 00             	movzbl (%eax),%eax
     28f:	84 c0                	test   %al,%al
     291:	75 10                	jne    2a3 <matchhere+0x6f>
    return *text == '\0';
     293:	8b 45 0c             	mov    0xc(%ebp),%eax
     296:	0f b6 00             	movzbl (%eax),%eax
     299:	84 c0                	test   %al,%al
     29b:	0f 94 c0             	sete   %al
     29e:	0f b6 c0             	movzbl %al,%eax
     2a1:	eb 44                	jmp    2e7 <matchhere+0xb3>
  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
     2a3:	8b 45 0c             	mov    0xc(%ebp),%eax
     2a6:	0f b6 00             	movzbl (%eax),%eax
     2a9:	84 c0                	test   %al,%al
     2ab:	74 35                	je     2e2 <matchhere+0xae>
     2ad:	8b 45 08             	mov    0x8(%ebp),%eax
     2b0:	0f b6 00             	movzbl (%eax),%eax
     2b3:	3c 2e                	cmp    $0x2e,%al
     2b5:	74 10                	je     2c7 <matchhere+0x93>
     2b7:	8b 45 08             	mov    0x8(%ebp),%eax
     2ba:	0f b6 10             	movzbl (%eax),%edx
     2bd:	8b 45 0c             	mov    0xc(%ebp),%eax
     2c0:	0f b6 00             	movzbl (%eax),%eax
     2c3:	38 c2                	cmp    %al,%dl
     2c5:	75 1b                	jne    2e2 <matchhere+0xae>
    return matchhere(re+1, text+1);
     2c7:	8b 45 0c             	mov    0xc(%ebp),%eax
     2ca:	8d 50 01             	lea    0x1(%eax),%edx
     2cd:	8b 45 08             	mov    0x8(%ebp),%eax
     2d0:	83 c0 01             	add    $0x1,%eax
     2d3:	83 ec 08             	sub    $0x8,%esp
     2d6:	52                   	push   %edx
     2d7:	50                   	push   %eax
     2d8:	e8 57 ff ff ff       	call   234 <matchhere>
     2dd:	83 c4 10             	add    $0x10,%esp
     2e0:	eb 05                	jmp    2e7 <matchhere+0xb3>
  return 0;
     2e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
     2e7:	c9                   	leave  
     2e8:	c3                   	ret    

000002e9 <matchstar>:

// matchstar: search for c*re at beginning of text
int matchstar(int c, char *re, char *text)
{
     2e9:	55                   	push   %ebp
     2ea:	89 e5                	mov    %esp,%ebp
     2ec:	83 ec 08             	sub    $0x8,%esp
  do{  // a * matches zero or more instances
    if(matchhere(re, text))
     2ef:	83 ec 08             	sub    $0x8,%esp
     2f2:	ff 75 10             	pushl  0x10(%ebp)
     2f5:	ff 75 0c             	pushl  0xc(%ebp)
     2f8:	e8 37 ff ff ff       	call   234 <matchhere>
     2fd:	83 c4 10             	add    $0x10,%esp
     300:	85 c0                	test   %eax,%eax
     302:	74 07                	je     30b <matchstar+0x22>
      return 1;
     304:	b8 01 00 00 00       	mov    $0x1,%eax
     309:	eb 29                	jmp    334 <matchstar+0x4b>
  }while(*text!='\0' && (*text++==c || c=='.'));
     30b:	8b 45 10             	mov    0x10(%ebp),%eax
     30e:	0f b6 00             	movzbl (%eax),%eax
     311:	84 c0                	test   %al,%al
     313:	74 1a                	je     32f <matchstar+0x46>
     315:	8b 45 10             	mov    0x10(%ebp),%eax
     318:	8d 50 01             	lea    0x1(%eax),%edx
     31b:	89 55 10             	mov    %edx,0x10(%ebp)
     31e:	0f b6 00             	movzbl (%eax),%eax
     321:	0f be c0             	movsbl %al,%eax
     324:	3b 45 08             	cmp    0x8(%ebp),%eax
     327:	74 c6                	je     2ef <matchstar+0x6>
     329:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
     32d:	74 c0                	je     2ef <matchstar+0x6>
  return 0;
     32f:	b8 00 00 00 00       	mov    $0x0,%eax
}
     334:	c9                   	leave  
     335:	c3                   	ret    

00000336 <stosb>:
               "cc");
}

static inline void
stosb(void *addr, int data, int cnt)
{
     336:	55                   	push   %ebp
     337:	89 e5                	mov    %esp,%ebp
     339:	57                   	push   %edi
     33a:	53                   	push   %ebx
  asm volatile("cld; rep stosb" :
     33b:	8b 4d 08             	mov    0x8(%ebp),%ecx
     33e:	8b 55 10             	mov    0x10(%ebp),%edx
     341:	8b 45 0c             	mov    0xc(%ebp),%eax
     344:	89 cb                	mov    %ecx,%ebx
     346:	89 df                	mov    %ebx,%edi
     348:	89 d1                	mov    %edx,%ecx
     34a:	fc                   	cld    
     34b:	f3 aa                	rep stos %al,%es:(%edi)
     34d:	89 ca                	mov    %ecx,%edx
     34f:	89 fb                	mov    %edi,%ebx
     351:	89 5d 08             	mov    %ebx,0x8(%ebp)
     354:	89 55 10             	mov    %edx,0x10(%ebp)
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}
     357:	90                   	nop
     358:	5b                   	pop    %ebx
     359:	5f                   	pop    %edi
     35a:	5d                   	pop    %ebp
     35b:	c3                   	ret    

0000035c <strcpy>:
#include "user.h"
#include "x86.h"

char*
strcpy(char *s, char *t)
{
     35c:	55                   	push   %ebp
     35d:	89 e5                	mov    %esp,%ebp
     35f:	83 ec 10             	sub    $0x10,%esp
  char *os;

  os = s;
     362:	8b 45 08             	mov    0x8(%ebp),%eax
     365:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((*s++ = *t++) != 0)
     368:	90                   	nop
     369:	8b 45 08             	mov    0x8(%ebp),%eax
     36c:	8d 50 01             	lea    0x1(%eax),%edx
     36f:	89 55 08             	mov    %edx,0x8(%ebp)
     372:	8b 55 0c             	mov    0xc(%ebp),%edx
     375:	8d 4a 01             	lea    0x1(%edx),%ecx
     378:	89 4d 0c             	mov    %ecx,0xc(%ebp)
     37b:	0f b6 12             	movzbl (%edx),%edx
     37e:	88 10                	mov    %dl,(%eax)
     380:	0f b6 00             	movzbl (%eax),%eax
     383:	84 c0                	test   %al,%al
     385:	75 e2                	jne    369 <strcpy+0xd>
    ;
  return os;
     387:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     38a:	c9                   	leave  
     38b:	c3                   	ret    

0000038c <strcmp>:

int
strcmp(const char *p, const char *q)
{
     38c:	55                   	push   %ebp
     38d:	89 e5                	mov    %esp,%ebp
  while(*p && *p == *q)
     38f:	eb 08                	jmp    399 <strcmp+0xd>
    p++, q++;
     391:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     395:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
  while(*p && *p == *q)
     399:	8b 45 08             	mov    0x8(%ebp),%eax
     39c:	0f b6 00             	movzbl (%eax),%eax
     39f:	84 c0                	test   %al,%al
     3a1:	74 10                	je     3b3 <strcmp+0x27>
     3a3:	8b 45 08             	mov    0x8(%ebp),%eax
     3a6:	0f b6 10             	movzbl (%eax),%edx
     3a9:	8b 45 0c             	mov    0xc(%ebp),%eax
     3ac:	0f b6 00             	movzbl (%eax),%eax
     3af:	38 c2                	cmp    %al,%dl
     3b1:	74 de                	je     391 <strcmp+0x5>
    p++, q++;
  return (uchar)*p - (uchar)*q;
     3b3:	8b 45 08             	mov    0x8(%ebp),%eax
     3b6:	0f b6 00             	movzbl (%eax),%eax
     3b9:	0f b6 d0             	movzbl %al,%edx
     3bc:	8b 45 0c             	mov    0xc(%ebp),%eax
     3bf:	0f b6 00             	movzbl (%eax),%eax
     3c2:	0f b6 c0             	movzbl %al,%eax
     3c5:	29 c2                	sub    %eax,%edx
     3c7:	89 d0                	mov    %edx,%eax
}
     3c9:	5d                   	pop    %ebp
     3ca:	c3                   	ret    

000003cb <strlen>:

uint
strlen(char *s)
{
     3cb:	55                   	push   %ebp
     3cc:	89 e5                	mov    %esp,%ebp
     3ce:	83 ec 10             	sub    $0x10,%esp
  int n;

  for(n = 0; s[n]; n++)
     3d1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
     3d8:	eb 04                	jmp    3de <strlen+0x13>
     3da:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
     3de:	8b 55 fc             	mov    -0x4(%ebp),%edx
     3e1:	8b 45 08             	mov    0x8(%ebp),%eax
     3e4:	01 d0                	add    %edx,%eax
     3e6:	0f b6 00             	movzbl (%eax),%eax
     3e9:	84 c0                	test   %al,%al
     3eb:	75 ed                	jne    3da <strlen+0xf>
    ;
  return n;
     3ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     3f0:	c9                   	leave  
     3f1:	c3                   	ret    

000003f2 <memset>:

void*
memset(void *dst, int c, uint n)
{
     3f2:	55                   	push   %ebp
     3f3:	89 e5                	mov    %esp,%ebp
  stosb(dst, c, n);
     3f5:	8b 45 10             	mov    0x10(%ebp),%eax
     3f8:	50                   	push   %eax
     3f9:	ff 75 0c             	pushl  0xc(%ebp)
     3fc:	ff 75 08             	pushl  0x8(%ebp)
     3ff:	e8 32 ff ff ff       	call   336 <stosb>
     404:	83 c4 0c             	add    $0xc,%esp
  return dst;
     407:	8b 45 08             	mov    0x8(%ebp),%eax
}
     40a:	c9                   	leave  
     40b:	c3                   	ret    

0000040c <strchr>:

char*
strchr(const char *s, char c)
{
     40c:	55                   	push   %ebp
     40d:	89 e5                	mov    %esp,%ebp
     40f:	83 ec 04             	sub    $0x4,%esp
     412:	8b 45 0c             	mov    0xc(%ebp),%eax
     415:	88 45 fc             	mov    %al,-0x4(%ebp)
  for(; *s; s++)
     418:	eb 14                	jmp    42e <strchr+0x22>
    if(*s == c)
     41a:	8b 45 08             	mov    0x8(%ebp),%eax
     41d:	0f b6 00             	movzbl (%eax),%eax
     420:	3a 45 fc             	cmp    -0x4(%ebp),%al
     423:	75 05                	jne    42a <strchr+0x1e>
      return (char*)s;
     425:	8b 45 08             	mov    0x8(%ebp),%eax
     428:	eb 13                	jmp    43d <strchr+0x31>
}

char*
strchr(const char *s, char c)
{
  for(; *s; s++)
     42a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
     42e:	8b 45 08             	mov    0x8(%ebp),%eax
     431:	0f b6 00             	movzbl (%eax),%eax
     434:	84 c0                	test   %al,%al
     436:	75 e2                	jne    41a <strchr+0xe>
    if(*s == c)
      return (char*)s;
  return 0;
     438:	b8 00 00 00 00       	mov    $0x0,%eax
}
     43d:	c9                   	leave  
     43e:	c3                   	ret    

0000043f <gets>:

char*
gets(char *buf, int max)
{
     43f:	55                   	push   %ebp
     440:	89 e5                	mov    %esp,%ebp
     442:	83 ec 18             	sub    $0x18,%esp
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     445:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
     44c:	eb 42                	jmp    490 <gets+0x51>
    cc = read(0, &c, 1);
     44e:	83 ec 04             	sub    $0x4,%esp
     451:	6a 01                	push   $0x1
     453:	8d 45 ef             	lea    -0x11(%ebp),%eax
     456:	50                   	push   %eax
     457:	6a 00                	push   $0x0
     459:	e8 47 01 00 00       	call   5a5 <read>
     45e:	83 c4 10             	add    $0x10,%esp
     461:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(cc < 1)
     464:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     468:	7e 33                	jle    49d <gets+0x5e>
      break;
    buf[i++] = c;
     46a:	8b 45 f4             	mov    -0xc(%ebp),%eax
     46d:	8d 50 01             	lea    0x1(%eax),%edx
     470:	89 55 f4             	mov    %edx,-0xc(%ebp)
     473:	89 c2                	mov    %eax,%edx
     475:	8b 45 08             	mov    0x8(%ebp),%eax
     478:	01 c2                	add    %eax,%edx
     47a:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     47e:	88 02                	mov    %al,(%edx)
    if(c == '\n' || c == '\r')
     480:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     484:	3c 0a                	cmp    $0xa,%al
     486:	74 16                	je     49e <gets+0x5f>
     488:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
     48c:	3c 0d                	cmp    $0xd,%al
     48e:	74 0e                	je     49e <gets+0x5f>
gets(char *buf, int max)
{
  int i, cc;
  char c;

  for(i=0; i+1 < max; ){
     490:	8b 45 f4             	mov    -0xc(%ebp),%eax
     493:	83 c0 01             	add    $0x1,%eax
     496:	3b 45 0c             	cmp    0xc(%ebp),%eax
     499:	7c b3                	jl     44e <gets+0xf>
     49b:	eb 01                	jmp    49e <gets+0x5f>
    cc = read(0, &c, 1);
    if(cc < 1)
      break;
     49d:	90                   	nop
    buf[i++] = c;
    if(c == '\n' || c == '\r')
      break;
  }
  buf[i] = '\0';
     49e:	8b 55 f4             	mov    -0xc(%ebp),%edx
     4a1:	8b 45 08             	mov    0x8(%ebp),%eax
     4a4:	01 d0                	add    %edx,%eax
     4a6:	c6 00 00             	movb   $0x0,(%eax)
  return buf;
     4a9:	8b 45 08             	mov    0x8(%ebp),%eax
}
     4ac:	c9                   	leave  
     4ad:	c3                   	ret    

000004ae <stat>:

int
stat(char *n, struct stat *st)
{
     4ae:	55                   	push   %ebp
     4af:	89 e5                	mov    %esp,%ebp
     4b1:	83 ec 18             	sub    $0x18,%esp
  int fd;
  int r;

  fd = open(n, O_RDONLY);
     4b4:	83 ec 08             	sub    $0x8,%esp
     4b7:	6a 00                	push   $0x0
     4b9:	ff 75 08             	pushl  0x8(%ebp)
     4bc:	e8 0c 01 00 00       	call   5cd <open>
     4c1:	83 c4 10             	add    $0x10,%esp
     4c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(fd < 0)
     4c7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     4cb:	79 07                	jns    4d4 <stat+0x26>
    return -1;
     4cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     4d2:	eb 25                	jmp    4f9 <stat+0x4b>
  r = fstat(fd, st);
     4d4:	83 ec 08             	sub    $0x8,%esp
     4d7:	ff 75 0c             	pushl  0xc(%ebp)
     4da:	ff 75 f4             	pushl  -0xc(%ebp)
     4dd:	e8 03 01 00 00       	call   5e5 <fstat>
     4e2:	83 c4 10             	add    $0x10,%esp
     4e5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  close(fd);
     4e8:	83 ec 0c             	sub    $0xc,%esp
     4eb:	ff 75 f4             	pushl  -0xc(%ebp)
     4ee:	e8 c2 00 00 00       	call   5b5 <close>
     4f3:	83 c4 10             	add    $0x10,%esp
  return r;
     4f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
     4f9:	c9                   	leave  
     4fa:	c3                   	ret    

000004fb <atoi>:

int
atoi(const char *s)
{
     4fb:	55                   	push   %ebp
     4fc:	89 e5                	mov    %esp,%ebp
     4fe:	83 ec 10             	sub    $0x10,%esp
  int n;

  n = 0;
     501:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  while('0' <= *s && *s <= '9')
     508:	eb 25                	jmp    52f <atoi+0x34>
    n = n*10 + *s++ - '0';
     50a:	8b 55 fc             	mov    -0x4(%ebp),%edx
     50d:	89 d0                	mov    %edx,%eax
     50f:	c1 e0 02             	shl    $0x2,%eax
     512:	01 d0                	add    %edx,%eax
     514:	01 c0                	add    %eax,%eax
     516:	89 c1                	mov    %eax,%ecx
     518:	8b 45 08             	mov    0x8(%ebp),%eax
     51b:	8d 50 01             	lea    0x1(%eax),%edx
     51e:	89 55 08             	mov    %edx,0x8(%ebp)
     521:	0f b6 00             	movzbl (%eax),%eax
     524:	0f be c0             	movsbl %al,%eax
     527:	01 c8                	add    %ecx,%eax
     529:	83 e8 30             	sub    $0x30,%eax
     52c:	89 45 fc             	mov    %eax,-0x4(%ebp)
atoi(const char *s)
{
  int n;

  n = 0;
  while('0' <= *s && *s <= '9')
     52f:	8b 45 08             	mov    0x8(%ebp),%eax
     532:	0f b6 00             	movzbl (%eax),%eax
     535:	3c 2f                	cmp    $0x2f,%al
     537:	7e 0a                	jle    543 <atoi+0x48>
     539:	8b 45 08             	mov    0x8(%ebp),%eax
     53c:	0f b6 00             	movzbl (%eax),%eax
     53f:	3c 39                	cmp    $0x39,%al
     541:	7e c7                	jle    50a <atoi+0xf>
    n = n*10 + *s++ - '0';
  return n;
     543:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
     546:	c9                   	leave  
     547:	c3                   	ret    

00000548 <memmove>:

void*
memmove(void *vdst, void *vsrc, int n)
{
     548:	55                   	push   %ebp
     549:	89 e5                	mov    %esp,%ebp
     54b:	83 ec 10             	sub    $0x10,%esp
  char *dst, *src;
  
  dst = vdst;
     54e:	8b 45 08             	mov    0x8(%ebp),%eax
     551:	89 45 fc             	mov    %eax,-0x4(%ebp)
  src = vsrc;
     554:	8b 45 0c             	mov    0xc(%ebp),%eax
     557:	89 45 f8             	mov    %eax,-0x8(%ebp)
  while(n-- > 0)
     55a:	eb 17                	jmp    573 <memmove+0x2b>
    *dst++ = *src++;
     55c:	8b 45 fc             	mov    -0x4(%ebp),%eax
     55f:	8d 50 01             	lea    0x1(%eax),%edx
     562:	89 55 fc             	mov    %edx,-0x4(%ebp)
     565:	8b 55 f8             	mov    -0x8(%ebp),%edx
     568:	8d 4a 01             	lea    0x1(%edx),%ecx
     56b:	89 4d f8             	mov    %ecx,-0x8(%ebp)
     56e:	0f b6 12             	movzbl (%edx),%edx
     571:	88 10                	mov    %dl,(%eax)
{
  char *dst, *src;
  
  dst = vdst;
  src = vsrc;
  while(n-- > 0)
     573:	8b 45 10             	mov    0x10(%ebp),%eax
     576:	8d 50 ff             	lea    -0x1(%eax),%edx
     579:	89 55 10             	mov    %edx,0x10(%ebp)
     57c:	85 c0                	test   %eax,%eax
     57e:	7f dc                	jg     55c <memmove+0x14>
    *dst++ = *src++;
  return vdst;
     580:	8b 45 08             	mov    0x8(%ebp),%eax
}
     583:	c9                   	leave  
     584:	c3                   	ret    

00000585 <fork>:
  name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret

SYSCALL(fork)
     585:	b8 01 00 00 00       	mov    $0x1,%eax
     58a:	cd 40                	int    $0x40
     58c:	c3                   	ret    

0000058d <exit>:
SYSCALL(exit)
     58d:	b8 02 00 00 00       	mov    $0x2,%eax
     592:	cd 40                	int    $0x40
     594:	c3                   	ret    

00000595 <wait>:
SYSCALL(wait)
     595:	b8 03 00 00 00       	mov    $0x3,%eax
     59a:	cd 40                	int    $0x40
     59c:	c3                   	ret    

0000059d <pipe>:
SYSCALL(pipe)
     59d:	b8 04 00 00 00       	mov    $0x4,%eax
     5a2:	cd 40                	int    $0x40
     5a4:	c3                   	ret    

000005a5 <read>:
SYSCALL(read)
     5a5:	b8 05 00 00 00       	mov    $0x5,%eax
     5aa:	cd 40                	int    $0x40
     5ac:	c3                   	ret    

000005ad <write>:
SYSCALL(write)
     5ad:	b8 10 00 00 00       	mov    $0x10,%eax
     5b2:	cd 40                	int    $0x40
     5b4:	c3                   	ret    

000005b5 <close>:
SYSCALL(close)
     5b5:	b8 15 00 00 00       	mov    $0x15,%eax
     5ba:	cd 40                	int    $0x40
     5bc:	c3                   	ret    

000005bd <kill>:
SYSCALL(kill)
     5bd:	b8 06 00 00 00       	mov    $0x6,%eax
     5c2:	cd 40                	int    $0x40
     5c4:	c3                   	ret    

000005c5 <exec>:
SYSCALL(exec)
     5c5:	b8 07 00 00 00       	mov    $0x7,%eax
     5ca:	cd 40                	int    $0x40
     5cc:	c3                   	ret    

000005cd <open>:
SYSCALL(open)
     5cd:	b8 0f 00 00 00       	mov    $0xf,%eax
     5d2:	cd 40                	int    $0x40
     5d4:	c3                   	ret    

000005d5 <mknod>:
SYSCALL(mknod)
     5d5:	b8 11 00 00 00       	mov    $0x11,%eax
     5da:	cd 40                	int    $0x40
     5dc:	c3                   	ret    

000005dd <unlink>:
SYSCALL(unlink)
     5dd:	b8 12 00 00 00       	mov    $0x12,%eax
     5e2:	cd 40                	int    $0x40
     5e4:	c3                   	ret    

000005e5 <fstat>:
SYSCALL(fstat)
     5e5:	b8 08 00 00 00       	mov    $0x8,%eax
     5ea:	cd 40                	int    $0x40
     5ec:	c3                   	ret    

000005ed <link>:
SYSCALL(link)
     5ed:	b8 13 00 00 00       	mov    $0x13,%eax
     5f2:	cd 40                	int    $0x40
     5f4:	c3                   	ret    

000005f5 <mkdir>:
SYSCALL(mkdir)
     5f5:	b8 14 00 00 00       	mov    $0x14,%eax
     5fa:	cd 40                	int    $0x40
     5fc:	c3                   	ret    

000005fd <chdir>:
SYSCALL(chdir)
     5fd:	b8 09 00 00 00       	mov    $0x9,%eax
     602:	cd 40                	int    $0x40
     604:	c3                   	ret    

00000605 <dup>:
SYSCALL(dup)
     605:	b8 0a 00 00 00       	mov    $0xa,%eax
     60a:	cd 40                	int    $0x40
     60c:	c3                   	ret    

0000060d <getpid>:
SYSCALL(getpid)
     60d:	b8 0b 00 00 00       	mov    $0xb,%eax
     612:	cd 40                	int    $0x40
     614:	c3                   	ret    

00000615 <sbrk>:
SYSCALL(sbrk)
     615:	b8 0c 00 00 00       	mov    $0xc,%eax
     61a:	cd 40                	int    $0x40
     61c:	c3                   	ret    

0000061d <sleep>:
SYSCALL(sleep)
     61d:	b8 0d 00 00 00       	mov    $0xd,%eax
     622:	cd 40                	int    $0x40
     624:	c3                   	ret    

00000625 <uptime>:
SYSCALL(uptime)
     625:	b8 0e 00 00 00       	mov    $0xe,%eax
     62a:	cd 40                	int    $0x40
     62c:	c3                   	ret    

0000062d <createwindow>:
SYSCALL(createwindow)
     62d:	b8 16 00 00 00       	mov    $0x16,%eax
     632:	cd 40                	int    $0x40
     634:	c3                   	ret    

00000635 <repaintwindow>:
SYSCALL(repaintwindow)
     635:	b8 17 00 00 00       	mov    $0x17,%eax
     63a:	cd 40                	int    $0x40
     63c:	c3                   	ret    

0000063d <getmessage>:
SYSCALL(getmessage)
     63d:	b8 18 00 00 00       	mov    $0x18,%eax
     642:	cd 40                	int    $0x40
     644:	c3                   	ret    

00000645 <settimer>:
SYSCALL(settimer)
     645:	b8 19 00 00 00       	mov    $0x19,%eax
     64a:	cd 40                	int    $0x40
     64c:	c3                   	ret    

0000064d <updatewindow>:
SYSCALL(updatewindow)
     64d:	b8 1a 00 00 00       	mov    $0x1a,%eax
     652:	cd 40                	int    $0x40
     654:	c3                   	ret    

00000655 <destroywindow>:
SYSCALL(destroywindow)
     655:	b8 1b 00 00 00       	mov    $0x1b,%eax
     65a:	cd 40                	int    $0x40
     65c:	c3                   	ret    

0000065d <putc>:
#include "stat.h"
#include "user.h"

static void
putc(int fd, char c)
{
     65d:	55                   	push   %ebp
     65e:	89 e5                	mov    %esp,%ebp
     660:	83 ec 18             	sub    $0x18,%esp
     663:	8b 45 0c             	mov    0xc(%ebp),%eax
     666:	88 45 f4             	mov    %al,-0xc(%ebp)
  write(fd, &c, 1);
     669:	83 ec 04             	sub    $0x4,%esp
     66c:	6a 01                	push   $0x1
     66e:	8d 45 f4             	lea    -0xc(%ebp),%eax
     671:	50                   	push   %eax
     672:	ff 75 08             	pushl  0x8(%ebp)
     675:	e8 33 ff ff ff       	call   5ad <write>
     67a:	83 c4 10             	add    $0x10,%esp
}
     67d:	90                   	nop
     67e:	c9                   	leave  
     67f:	c3                   	ret    

00000680 <printint>:

static void
printint(int fd, int xx, int base, int sgn)
{
     680:	55                   	push   %ebp
     681:	89 e5                	mov    %esp,%ebp
     683:	53                   	push   %ebx
     684:	83 ec 24             	sub    $0x24,%esp
  static char digits[] = "0123456789ABCDEF";
  char buf[16];
  int i, neg;
  uint x;

  neg = 0;
     687:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(sgn && xx < 0){
     68e:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
     692:	74 17                	je     6ab <printint+0x2b>
     694:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     698:	79 11                	jns    6ab <printint+0x2b>
    neg = 1;
     69a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    x = -xx;
     6a1:	8b 45 0c             	mov    0xc(%ebp),%eax
     6a4:	f7 d8                	neg    %eax
     6a6:	89 45 ec             	mov    %eax,-0x14(%ebp)
     6a9:	eb 06                	jmp    6b1 <printint+0x31>
  } else {
    x = xx;
     6ab:	8b 45 0c             	mov    0xc(%ebp),%eax
     6ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
  }

  i = 0;
     6b1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  do{
    buf[i++] = digits[x % base];
     6b8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
     6bb:	8d 41 01             	lea    0x1(%ecx),%eax
     6be:	89 45 f4             	mov    %eax,-0xc(%ebp)
     6c1:	8b 5d 10             	mov    0x10(%ebp),%ebx
     6c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
     6c7:	ba 00 00 00 00       	mov    $0x0,%edx
     6cc:	f7 f3                	div    %ebx
     6ce:	89 d0                	mov    %edx,%eax
     6d0:	0f b6 80 20 e4 01 00 	movzbl 0x1e420(%eax),%eax
     6d7:	88 44 0d dc          	mov    %al,-0x24(%ebp,%ecx,1)
  }while((x /= base) != 0);
     6db:	8b 5d 10             	mov    0x10(%ebp),%ebx
     6de:	8b 45 ec             	mov    -0x14(%ebp),%eax
     6e1:	ba 00 00 00 00       	mov    $0x0,%edx
     6e6:	f7 f3                	div    %ebx
     6e8:	89 45 ec             	mov    %eax,-0x14(%ebp)
     6eb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     6ef:	75 c7                	jne    6b8 <printint+0x38>
  if(neg)
     6f1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     6f5:	74 2d                	je     724 <printint+0xa4>
    buf[i++] = '-';
     6f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
     6fa:	8d 50 01             	lea    0x1(%eax),%edx
     6fd:	89 55 f4             	mov    %edx,-0xc(%ebp)
     700:	c6 44 05 dc 2d       	movb   $0x2d,-0x24(%ebp,%eax,1)

  while(--i >= 0)
     705:	eb 1d                	jmp    724 <printint+0xa4>
    putc(fd, buf[i]);
     707:	8d 55 dc             	lea    -0x24(%ebp),%edx
     70a:	8b 45 f4             	mov    -0xc(%ebp),%eax
     70d:	01 d0                	add    %edx,%eax
     70f:	0f b6 00             	movzbl (%eax),%eax
     712:	0f be c0             	movsbl %al,%eax
     715:	83 ec 08             	sub    $0x8,%esp
     718:	50                   	push   %eax
     719:	ff 75 08             	pushl  0x8(%ebp)
     71c:	e8 3c ff ff ff       	call   65d <putc>
     721:	83 c4 10             	add    $0x10,%esp
    buf[i++] = digits[x % base];
  }while((x /= base) != 0);
  if(neg)
    buf[i++] = '-';

  while(--i >= 0)
     724:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
     728:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     72c:	79 d9                	jns    707 <printint+0x87>
    putc(fd, buf[i]);
}
     72e:	90                   	nop
     72f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
     732:	c9                   	leave  
     733:	c3                   	ret    

00000734 <printf>:

// Print to the given fd. Only understands %d, %x, %p, %s.
void
printf(int fd, char *fmt, ...)
{
     734:	55                   	push   %ebp
     735:	89 e5                	mov    %esp,%ebp
     737:	83 ec 28             	sub    $0x28,%esp
  char *s;
  int c, i, state;
  uint *ap;

  state = 0;
     73a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  ap = (uint*)(void*)&fmt + 1;
     741:	8d 45 0c             	lea    0xc(%ebp),%eax
     744:	83 c0 04             	add    $0x4,%eax
     747:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; fmt[i]; i++){
     74a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
     751:	e9 59 01 00 00       	jmp    8af <printf+0x17b>
    c = fmt[i] & 0xff;
     756:	8b 55 0c             	mov    0xc(%ebp),%edx
     759:	8b 45 f0             	mov    -0x10(%ebp),%eax
     75c:	01 d0                	add    %edx,%eax
     75e:	0f b6 00             	movzbl (%eax),%eax
     761:	0f be c0             	movsbl %al,%eax
     764:	25 ff 00 00 00       	and    $0xff,%eax
     769:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(state == 0){
     76c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     770:	75 2c                	jne    79e <printf+0x6a>
      if(c == '%'){
     772:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     776:	75 0c                	jne    784 <printf+0x50>
        state = '%';
     778:	c7 45 ec 25 00 00 00 	movl   $0x25,-0x14(%ebp)
     77f:	e9 27 01 00 00       	jmp    8ab <printf+0x177>
      } else {
        putc(fd, c);
     784:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     787:	0f be c0             	movsbl %al,%eax
     78a:	83 ec 08             	sub    $0x8,%esp
     78d:	50                   	push   %eax
     78e:	ff 75 08             	pushl  0x8(%ebp)
     791:	e8 c7 fe ff ff       	call   65d <putc>
     796:	83 c4 10             	add    $0x10,%esp
     799:	e9 0d 01 00 00       	jmp    8ab <printf+0x177>
      }
    } else if(state == '%'){
     79e:	83 7d ec 25          	cmpl   $0x25,-0x14(%ebp)
     7a2:	0f 85 03 01 00 00    	jne    8ab <printf+0x177>
      if(c == 'd'){
     7a8:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
     7ac:	75 1e                	jne    7cc <printf+0x98>
        printint(fd, *ap, 10, 1);
     7ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
     7b1:	8b 00                	mov    (%eax),%eax
     7b3:	6a 01                	push   $0x1
     7b5:	6a 0a                	push   $0xa
     7b7:	50                   	push   %eax
     7b8:	ff 75 08             	pushl  0x8(%ebp)
     7bb:	e8 c0 fe ff ff       	call   680 <printint>
     7c0:	83 c4 10             	add    $0x10,%esp
        ap++;
     7c3:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     7c7:	e9 d8 00 00 00       	jmp    8a4 <printf+0x170>
      } else if(c == 'x' || c == 'p'){
     7cc:	83 7d e4 78          	cmpl   $0x78,-0x1c(%ebp)
     7d0:	74 06                	je     7d8 <printf+0xa4>
     7d2:	83 7d e4 70          	cmpl   $0x70,-0x1c(%ebp)
     7d6:	75 1e                	jne    7f6 <printf+0xc2>
        printint(fd, *ap, 16, 0);
     7d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
     7db:	8b 00                	mov    (%eax),%eax
     7dd:	6a 00                	push   $0x0
     7df:	6a 10                	push   $0x10
     7e1:	50                   	push   %eax
     7e2:	ff 75 08             	pushl  0x8(%ebp)
     7e5:	e8 96 fe ff ff       	call   680 <printint>
     7ea:	83 c4 10             	add    $0x10,%esp
        ap++;
     7ed:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     7f1:	e9 ae 00 00 00       	jmp    8a4 <printf+0x170>
      } else if(c == 's'){
     7f6:	83 7d e4 73          	cmpl   $0x73,-0x1c(%ebp)
     7fa:	75 43                	jne    83f <printf+0x10b>
        s = (char*)*ap;
     7fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
     7ff:	8b 00                	mov    (%eax),%eax
     801:	89 45 f4             	mov    %eax,-0xc(%ebp)
        ap++;
     804:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
        if(s == 0)
     808:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     80c:	75 25                	jne    833 <printf+0xff>
          s = "(null)";
     80e:	c7 45 f4 b6 60 01 00 	movl   $0x160b6,-0xc(%ebp)
        while(*s != 0){
     815:	eb 1c                	jmp    833 <printf+0xff>
          putc(fd, *s);
     817:	8b 45 f4             	mov    -0xc(%ebp),%eax
     81a:	0f b6 00             	movzbl (%eax),%eax
     81d:	0f be c0             	movsbl %al,%eax
     820:	83 ec 08             	sub    $0x8,%esp
     823:	50                   	push   %eax
     824:	ff 75 08             	pushl  0x8(%ebp)
     827:	e8 31 fe ff ff       	call   65d <putc>
     82c:	83 c4 10             	add    $0x10,%esp
          s++;
     82f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      } else if(c == 's'){
        s = (char*)*ap;
        ap++;
        if(s == 0)
          s = "(null)";
        while(*s != 0){
     833:	8b 45 f4             	mov    -0xc(%ebp),%eax
     836:	0f b6 00             	movzbl (%eax),%eax
     839:	84 c0                	test   %al,%al
     83b:	75 da                	jne    817 <printf+0xe3>
     83d:	eb 65                	jmp    8a4 <printf+0x170>
          putc(fd, *s);
          s++;
        }
      } else if(c == 'c'){
     83f:	83 7d e4 63          	cmpl   $0x63,-0x1c(%ebp)
     843:	75 1d                	jne    862 <printf+0x12e>
        putc(fd, *ap);
     845:	8b 45 e8             	mov    -0x18(%ebp),%eax
     848:	8b 00                	mov    (%eax),%eax
     84a:	0f be c0             	movsbl %al,%eax
     84d:	83 ec 08             	sub    $0x8,%esp
     850:	50                   	push   %eax
     851:	ff 75 08             	pushl  0x8(%ebp)
     854:	e8 04 fe ff ff       	call   65d <putc>
     859:	83 c4 10             	add    $0x10,%esp
        ap++;
     85c:	83 45 e8 04          	addl   $0x4,-0x18(%ebp)
     860:	eb 42                	jmp    8a4 <printf+0x170>
      } else if(c == '%'){
     862:	83 7d e4 25          	cmpl   $0x25,-0x1c(%ebp)
     866:	75 17                	jne    87f <printf+0x14b>
        putc(fd, c);
     868:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     86b:	0f be c0             	movsbl %al,%eax
     86e:	83 ec 08             	sub    $0x8,%esp
     871:	50                   	push   %eax
     872:	ff 75 08             	pushl  0x8(%ebp)
     875:	e8 e3 fd ff ff       	call   65d <putc>
     87a:	83 c4 10             	add    $0x10,%esp
     87d:	eb 25                	jmp    8a4 <printf+0x170>
      } else {
        // Unknown % sequence.  Print it to draw attention.
        putc(fd, '%');
     87f:	83 ec 08             	sub    $0x8,%esp
     882:	6a 25                	push   $0x25
     884:	ff 75 08             	pushl  0x8(%ebp)
     887:	e8 d1 fd ff ff       	call   65d <putc>
     88c:	83 c4 10             	add    $0x10,%esp
        putc(fd, c);
     88f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
     892:	0f be c0             	movsbl %al,%eax
     895:	83 ec 08             	sub    $0x8,%esp
     898:	50                   	push   %eax
     899:	ff 75 08             	pushl  0x8(%ebp)
     89c:	e8 bc fd ff ff       	call   65d <putc>
     8a1:	83 c4 10             	add    $0x10,%esp
      }
      state = 0;
     8a4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  int c, i, state;
  uint *ap;

  state = 0;
  ap = (uint*)(void*)&fmt + 1;
  for(i = 0; fmt[i]; i++){
     8ab:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
     8af:	8b 55 0c             	mov    0xc(%ebp),%edx
     8b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
     8b5:	01 d0                	add    %edx,%eax
     8b7:	0f b6 00             	movzbl (%eax),%eax
     8ba:	84 c0                	test   %al,%al
     8bc:	0f 85 94 fe ff ff    	jne    756 <printf+0x22>
        putc(fd, c);
      }
      state = 0;
    }
  }
}
     8c2:	90                   	nop
     8c3:	c9                   	leave  
     8c4:	c3                   	ret    

000008c5 <free>:
static Header base;
static Header *freep;

void
free(void *ap)
{
     8c5:	55                   	push   %ebp
     8c6:	89 e5                	mov    %esp,%ebp
     8c8:	83 ec 10             	sub    $0x10,%esp
  Header *bp, *p;

  bp = (Header*)ap - 1;
     8cb:	8b 45 08             	mov    0x8(%ebp),%eax
     8ce:	83 e8 08             	sub    $0x8,%eax
     8d1:	89 45 f8             	mov    %eax,-0x8(%ebp)
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     8d4:	a1 68 e8 01 00       	mov    0x1e868,%eax
     8d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
     8dc:	eb 24                	jmp    902 <free+0x3d>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
     8de:	8b 45 fc             	mov    -0x4(%ebp),%eax
     8e1:	8b 00                	mov    (%eax),%eax
     8e3:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     8e6:	77 12                	ja     8fa <free+0x35>
     8e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
     8eb:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     8ee:	77 24                	ja     914 <free+0x4f>
     8f0:	8b 45 fc             	mov    -0x4(%ebp),%eax
     8f3:	8b 00                	mov    (%eax),%eax
     8f5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     8f8:	77 1a                	ja     914 <free+0x4f>
free(void *ap)
{
  Header *bp, *p;

  bp = (Header*)ap - 1;
  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
     8fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
     8fd:	8b 00                	mov    (%eax),%eax
     8ff:	89 45 fc             	mov    %eax,-0x4(%ebp)
     902:	8b 45 f8             	mov    -0x8(%ebp),%eax
     905:	3b 45 fc             	cmp    -0x4(%ebp),%eax
     908:	76 d4                	jbe    8de <free+0x19>
     90a:	8b 45 fc             	mov    -0x4(%ebp),%eax
     90d:	8b 00                	mov    (%eax),%eax
     90f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     912:	76 ca                	jbe    8de <free+0x19>
    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
      break;
  if(bp + bp->s.size == p->s.ptr){
     914:	8b 45 f8             	mov    -0x8(%ebp),%eax
     917:	8b 40 04             	mov    0x4(%eax),%eax
     91a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     921:	8b 45 f8             	mov    -0x8(%ebp),%eax
     924:	01 c2                	add    %eax,%edx
     926:	8b 45 fc             	mov    -0x4(%ebp),%eax
     929:	8b 00                	mov    (%eax),%eax
     92b:	39 c2                	cmp    %eax,%edx
     92d:	75 24                	jne    953 <free+0x8e>
    bp->s.size += p->s.ptr->s.size;
     92f:	8b 45 f8             	mov    -0x8(%ebp),%eax
     932:	8b 50 04             	mov    0x4(%eax),%edx
     935:	8b 45 fc             	mov    -0x4(%ebp),%eax
     938:	8b 00                	mov    (%eax),%eax
     93a:	8b 40 04             	mov    0x4(%eax),%eax
     93d:	01 c2                	add    %eax,%edx
     93f:	8b 45 f8             	mov    -0x8(%ebp),%eax
     942:	89 50 04             	mov    %edx,0x4(%eax)
    bp->s.ptr = p->s.ptr->s.ptr;
     945:	8b 45 fc             	mov    -0x4(%ebp),%eax
     948:	8b 00                	mov    (%eax),%eax
     94a:	8b 10                	mov    (%eax),%edx
     94c:	8b 45 f8             	mov    -0x8(%ebp),%eax
     94f:	89 10                	mov    %edx,(%eax)
     951:	eb 0a                	jmp    95d <free+0x98>
  } else
    bp->s.ptr = p->s.ptr;
     953:	8b 45 fc             	mov    -0x4(%ebp),%eax
     956:	8b 10                	mov    (%eax),%edx
     958:	8b 45 f8             	mov    -0x8(%ebp),%eax
     95b:	89 10                	mov    %edx,(%eax)
  if(p + p->s.size == bp){
     95d:	8b 45 fc             	mov    -0x4(%ebp),%eax
     960:	8b 40 04             	mov    0x4(%eax),%eax
     963:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
     96a:	8b 45 fc             	mov    -0x4(%ebp),%eax
     96d:	01 d0                	add    %edx,%eax
     96f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
     972:	75 20                	jne    994 <free+0xcf>
    p->s.size += bp->s.size;
     974:	8b 45 fc             	mov    -0x4(%ebp),%eax
     977:	8b 50 04             	mov    0x4(%eax),%edx
     97a:	8b 45 f8             	mov    -0x8(%ebp),%eax
     97d:	8b 40 04             	mov    0x4(%eax),%eax
     980:	01 c2                	add    %eax,%edx
     982:	8b 45 fc             	mov    -0x4(%ebp),%eax
     985:	89 50 04             	mov    %edx,0x4(%eax)
    p->s.ptr = bp->s.ptr;
     988:	8b 45 f8             	mov    -0x8(%ebp),%eax
     98b:	8b 10                	mov    (%eax),%edx
     98d:	8b 45 fc             	mov    -0x4(%ebp),%eax
     990:	89 10                	mov    %edx,(%eax)
     992:	eb 08                	jmp    99c <free+0xd7>
  } else
    p->s.ptr = bp;
     994:	8b 45 fc             	mov    -0x4(%ebp),%eax
     997:	8b 55 f8             	mov    -0x8(%ebp),%edx
     99a:	89 10                	mov    %edx,(%eax)
  freep = p;
     99c:	8b 45 fc             	mov    -0x4(%ebp),%eax
     99f:	a3 68 e8 01 00       	mov    %eax,0x1e868
}
     9a4:	90                   	nop
     9a5:	c9                   	leave  
     9a6:	c3                   	ret    

000009a7 <morecore>:

static Header*
morecore(uint nu)
{
     9a7:	55                   	push   %ebp
     9a8:	89 e5                	mov    %esp,%ebp
     9aa:	83 ec 18             	sub    $0x18,%esp
  char *p;
  Header *hp;

  if(nu < 4096)
     9ad:	81 7d 08 ff 0f 00 00 	cmpl   $0xfff,0x8(%ebp)
     9b4:	77 07                	ja     9bd <morecore+0x16>
    nu = 4096;
     9b6:	c7 45 08 00 10 00 00 	movl   $0x1000,0x8(%ebp)
  p = sbrk(nu * sizeof(Header));
     9bd:	8b 45 08             	mov    0x8(%ebp),%eax
     9c0:	c1 e0 03             	shl    $0x3,%eax
     9c3:	83 ec 0c             	sub    $0xc,%esp
     9c6:	50                   	push   %eax
     9c7:	e8 49 fc ff ff       	call   615 <sbrk>
     9cc:	83 c4 10             	add    $0x10,%esp
     9cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(p == (char*)-1)
     9d2:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
     9d6:	75 07                	jne    9df <morecore+0x38>
    return 0;
     9d8:	b8 00 00 00 00       	mov    $0x0,%eax
     9dd:	eb 26                	jmp    a05 <morecore+0x5e>
  hp = (Header*)p;
     9df:	8b 45 f4             	mov    -0xc(%ebp),%eax
     9e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
  hp->s.size = nu;
     9e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
     9e8:	8b 55 08             	mov    0x8(%ebp),%edx
     9eb:	89 50 04             	mov    %edx,0x4(%eax)
  free((void*)(hp + 1));
     9ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
     9f1:	83 c0 08             	add    $0x8,%eax
     9f4:	83 ec 0c             	sub    $0xc,%esp
     9f7:	50                   	push   %eax
     9f8:	e8 c8 fe ff ff       	call   8c5 <free>
     9fd:	83 c4 10             	add    $0x10,%esp
  return freep;
     a00:	a1 68 e8 01 00       	mov    0x1e868,%eax
}
     a05:	c9                   	leave  
     a06:	c3                   	ret    

00000a07 <malloc>:

void*
malloc(uint nbytes)
{
     a07:	55                   	push   %ebp
     a08:	89 e5                	mov    %esp,%ebp
     a0a:	83 ec 18             	sub    $0x18,%esp
  Header *p, *prevp;
  uint nunits;

  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
     a0d:	8b 45 08             	mov    0x8(%ebp),%eax
     a10:	83 c0 07             	add    $0x7,%eax
     a13:	c1 e8 03             	shr    $0x3,%eax
     a16:	83 c0 01             	add    $0x1,%eax
     a19:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if((prevp = freep) == 0){
     a1c:	a1 68 e8 01 00       	mov    0x1e868,%eax
     a21:	89 45 f0             	mov    %eax,-0x10(%ebp)
     a24:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
     a28:	75 23                	jne    a4d <malloc+0x46>
    base.s.ptr = freep = prevp = &base;
     a2a:	c7 45 f0 60 e8 01 00 	movl   $0x1e860,-0x10(%ebp)
     a31:	8b 45 f0             	mov    -0x10(%ebp),%eax
     a34:	a3 68 e8 01 00       	mov    %eax,0x1e868
     a39:	a1 68 e8 01 00       	mov    0x1e868,%eax
     a3e:	a3 60 e8 01 00       	mov    %eax,0x1e860
    base.s.size = 0;
     a43:	c7 05 64 e8 01 00 00 	movl   $0x0,0x1e864
     a4a:	00 00 00 
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     a4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
     a50:	8b 00                	mov    (%eax),%eax
     a52:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(p->s.size >= nunits){
     a55:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a58:	8b 40 04             	mov    0x4(%eax),%eax
     a5b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     a5e:	72 4d                	jb     aad <malloc+0xa6>
      if(p->s.size == nunits)
     a60:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a63:	8b 40 04             	mov    0x4(%eax),%eax
     a66:	3b 45 ec             	cmp    -0x14(%ebp),%eax
     a69:	75 0c                	jne    a77 <malloc+0x70>
        prevp->s.ptr = p->s.ptr;
     a6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a6e:	8b 10                	mov    (%eax),%edx
     a70:	8b 45 f0             	mov    -0x10(%ebp),%eax
     a73:	89 10                	mov    %edx,(%eax)
     a75:	eb 26                	jmp    a9d <malloc+0x96>
      else {
        p->s.size -= nunits;
     a77:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a7a:	8b 40 04             	mov    0x4(%eax),%eax
     a7d:	2b 45 ec             	sub    -0x14(%ebp),%eax
     a80:	89 c2                	mov    %eax,%edx
     a82:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a85:	89 50 04             	mov    %edx,0x4(%eax)
        p += p->s.size;
     a88:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a8b:	8b 40 04             	mov    0x4(%eax),%eax
     a8e:	c1 e0 03             	shl    $0x3,%eax
     a91:	01 45 f4             	add    %eax,-0xc(%ebp)
        p->s.size = nunits;
     a94:	8b 45 f4             	mov    -0xc(%ebp),%eax
     a97:	8b 55 ec             	mov    -0x14(%ebp),%edx
     a9a:	89 50 04             	mov    %edx,0x4(%eax)
      }
      freep = prevp;
     a9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
     aa0:	a3 68 e8 01 00       	mov    %eax,0x1e868
      return (void*)(p + 1);
     aa5:	8b 45 f4             	mov    -0xc(%ebp),%eax
     aa8:	83 c0 08             	add    $0x8,%eax
     aab:	eb 3b                	jmp    ae8 <malloc+0xe1>
    }
    if(p == freep)
     aad:	a1 68 e8 01 00       	mov    0x1e868,%eax
     ab2:	39 45 f4             	cmp    %eax,-0xc(%ebp)
     ab5:	75 1e                	jne    ad5 <malloc+0xce>
      if((p = morecore(nunits)) == 0)
     ab7:	83 ec 0c             	sub    $0xc,%esp
     aba:	ff 75 ec             	pushl  -0x14(%ebp)
     abd:	e8 e5 fe ff ff       	call   9a7 <morecore>
     ac2:	83 c4 10             	add    $0x10,%esp
     ac5:	89 45 f4             	mov    %eax,-0xc(%ebp)
     ac8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
     acc:	75 07                	jne    ad5 <malloc+0xce>
        return 0;
     ace:	b8 00 00 00 00       	mov    $0x0,%eax
     ad3:	eb 13                	jmp    ae8 <malloc+0xe1>
  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
  if((prevp = freep) == 0){
    base.s.ptr = freep = prevp = &base;
    base.s.size = 0;
  }
  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
     ad5:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ad8:	89 45 f0             	mov    %eax,-0x10(%ebp)
     adb:	8b 45 f4             	mov    -0xc(%ebp),%eax
     ade:	8b 00                	mov    (%eax),%eax
     ae0:	89 45 f4             	mov    %eax,-0xc(%ebp)
      return (void*)(p + 1);
    }
    if(p == freep)
      if((p = morecore(nunits)) == 0)
        return 0;
  }
     ae3:	e9 6d ff ff ff       	jmp    a55 <malloc+0x4e>
}
     ae8:	c9                   	leave  
     ae9:	c3                   	ret    

00000aea <fastrand>:
#include "math.h"

static unsigned int g_seed = 0;

int fastrand() {
     aea:	55                   	push   %ebp
     aeb:	89 e5                	mov    %esp,%ebp
    ++g_seed;
     aed:	a1 6c e8 01 00       	mov    0x1e86c,%eax
     af2:	83 c0 01             	add    $0x1,%eax
     af5:	a3 6c e8 01 00       	mov    %eax,0x1e86c
    g_seed = (214013*g_seed+2531011);
     afa:	a1 6c e8 01 00       	mov    0x1e86c,%eax
     aff:	69 c0 fd 43 03 00    	imul   $0x343fd,%eax,%eax
     b05:	05 c3 9e 26 00       	add    $0x269ec3,%eax
     b0a:	a3 6c e8 01 00       	mov    %eax,0x1e86c
    return (g_seed>>16)&0x7FFF;
     b0f:	a1 6c e8 01 00       	mov    0x1e86c,%eax
     b14:	c1 e8 10             	shr    $0x10,%eax
     b17:	25 ff 7f 00 00       	and    $0x7fff,%eax
}
     b1c:	5d                   	pop    %ebp
     b1d:	c3                   	ret    

00000b1e <abs>:

#define PI 3.1415926536

float abs(float x) 
{
     b1e:	55                   	push   %ebp
     b1f:	89 e5                	mov    %esp,%ebp
	if (x > 0) return x;
     b21:	d9 45 08             	flds   0x8(%ebp)
     b24:	d9 ee                	fldz   
     b26:	d9 c9                	fxch   %st(1)
     b28:	df e9                	fucomip %st(1),%st
     b2a:	dd d8                	fstp   %st(0)
     b2c:	76 05                	jbe    b33 <abs+0x15>
     b2e:	d9 45 08             	flds   0x8(%ebp)
     b31:	eb 05                	jmp    b38 <abs+0x1a>
	return -x;
     b33:	d9 45 08             	flds   0x8(%ebp)
     b36:	d9 e0                	fchs   
}
     b38:	5d                   	pop    %ebp
     b39:	c3                   	ret    

00000b3a <pow>:

float pow(float a, int b)
{
     b3a:	55                   	push   %ebp
     b3b:	89 e5                	mov    %esp,%ebp
     b3d:	83 ec 10             	sub    $0x10,%esp
	float r = a;
     b40:	d9 45 08             	flds   0x8(%ebp)
     b43:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
     b46:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     b4a:	7e 17                	jle    b63 <pow+0x29>
		while (--b)
     b4c:	eb 09                	jmp    b57 <pow+0x1d>
			r *= a;
     b4e:	d9 45 fc             	flds   -0x4(%ebp)
     b51:	d8 4d 08             	fmuls  0x8(%ebp)
     b54:	d9 5d fc             	fstps  -0x4(%ebp)

float pow(float a, int b)
{
	float r = a;
	if (b > 0) {
		while (--b)
     b57:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
     b5b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     b5f:	75 ed                	jne    b4e <pow+0x14>
     b61:	eb 2a                	jmp    b8d <pow+0x53>
			r *= a;
	}
	else if (b < 0) {
     b63:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     b67:	79 1f                	jns    b88 <pow+0x4e>
		while (++b)
     b69:	eb 09                	jmp    b74 <pow+0x3a>
			r *= a;
     b6b:	d9 45 fc             	flds   -0x4(%ebp)
     b6e:	d8 4d 08             	fmuls  0x8(%ebp)
     b71:	d9 5d fc             	fstps  -0x4(%ebp)
	if (b > 0) {
		while (--b)
			r *= a;
	}
	else if (b < 0) {
		while (++b)
     b74:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
     b78:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
     b7c:	75 ed                	jne    b6b <pow+0x31>
			r *= a;
		r = 1.0 / r;
     b7e:	d9 e8                	fld1   
     b80:	d8 75 fc             	fdivs  -0x4(%ebp)
     b83:	d9 5d fc             	fstps  -0x4(%ebp)
     b86:	eb 05                	jmp    b8d <pow+0x53>
	}
	else r = 0;
     b88:	d9 ee                	fldz   
     b8a:	d9 5d fc             	fstps  -0x4(%ebp)
	return r;
     b8d:	d9 45 fc             	flds   -0x4(%ebp)
}
     b90:	c9                   	leave  
     b91:	c3                   	ret    

00000b92 <sqrt>:

float sqrt(float number) {
     b92:	55                   	push   %ebp
     b93:	89 e5                	mov    %esp,%ebp
     b95:	83 ec 10             	sub    $0x10,%esp
	float new_guess;
	float last_guess;

	if (number < 0) {
     b98:	d9 ee                	fldz   
     b9a:	d9 45 08             	flds   0x8(%ebp)
     b9d:	d9 c9                	fxch   %st(1)
     b9f:	df e9                	fucomip %st(1),%st
     ba1:	dd d8                	fstp   %st(0)
     ba3:	76 06                	jbe    bab <sqrt+0x19>
		return -1;
     ba5:	d9 e8                	fld1   
     ba7:	d9 e0                	fchs   
     ba9:	eb 3a                	jmp    be5 <sqrt+0x53>
	}

	new_guess = 1;
     bab:	d9 e8                	fld1   
     bad:	d9 5d fc             	fstps  -0x4(%ebp)
	do {
		last_guess = new_guess;
     bb0:	d9 45 fc             	flds   -0x4(%ebp)
     bb3:	d9 5d f8             	fstps  -0x8(%ebp)
		new_guess = (last_guess + number / last_guess) / 2;
     bb6:	d9 45 08             	flds   0x8(%ebp)
     bb9:	d8 75 f8             	fdivs  -0x8(%ebp)
     bbc:	d8 45 f8             	fadds  -0x8(%ebp)
     bbf:	d9 05 c0 60 01 00    	flds   0x160c0
     bc5:	de f9                	fdivrp %st,%st(1)
     bc7:	d9 5d fc             	fstps  -0x4(%ebp)
	} while (new_guess != last_guess);
     bca:	d9 45 fc             	flds   -0x4(%ebp)
     bcd:	d9 45 f8             	flds   -0x8(%ebp)
     bd0:	df e9                	fucomip %st(1),%st
     bd2:	dd d8                	fstp   %st(0)
     bd4:	7a da                	jp     bb0 <sqrt+0x1e>
     bd6:	d9 45 fc             	flds   -0x4(%ebp)
     bd9:	d9 45 f8             	flds   -0x8(%ebp)
     bdc:	df e9                	fucomip %st(1),%st
     bde:	dd d8                	fstp   %st(0)
     be0:	75 ce                	jne    bb0 <sqrt+0x1e>

	return new_guess;
     be2:	d9 45 fc             	flds   -0x4(%ebp)
}
     be5:	c9                   	leave  
     be6:	c3                   	ret    

00000be7 <cos>:

float cos(float x)
{
     be7:	55                   	push   %ebp
     be8:	89 e5                	mov    %esp,%ebp
     bea:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     bed:	d9 e8                	fld1   
     bef:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     bf2:	d9 45 08             	flds   0x8(%ebp)
     bf5:	dd 05 c8 60 01 00    	fldl   0x160c8
     bfb:	d9 c9                	fxch   %st(1)
     bfd:	df e9                	fucomip %st(1),%st
     bff:	dd d8                	fstp   %st(0)
     c01:	77 0f                	ja     c12 <cos+0x2b>
     c03:	d9 45 08             	flds   0x8(%ebp)
     c06:	dd 05 d0 60 01 00    	fldl   0x160d0
     c0c:	df e9                	fucomip %st(1),%st
     c0e:	dd d8                	fstp   %st(0)
     c10:	76 3c                	jbe    c4e <cos+0x67>
     c12:	d9 45 08             	flds   0x8(%ebp)
     c15:	d9 45 08             	flds   0x8(%ebp)
     c18:	dd 05 c8 60 01 00    	fldl   0x160c8
     c1e:	de f9                	fdivrp %st,%st(1)
     c20:	d9 7d e2             	fnstcw -0x1e(%ebp)
     c23:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     c27:	b4 0c                	mov    $0xc,%ah
     c29:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     c2d:	d9 6d e0             	fldcw  -0x20(%ebp)
     c30:	db 5d dc             	fistpl -0x24(%ebp)
     c33:	d9 6d e2             	fldcw  -0x1e(%ebp)
     c36:	8b 45 dc             	mov    -0x24(%ebp),%eax
     c39:	01 c0                	add    %eax,%eax
     c3b:	89 45 d8             	mov    %eax,-0x28(%ebp)
     c3e:	db 45 d8             	fildl  -0x28(%ebp)
     c41:	dd 05 d8 60 01 00    	fldl   0x160d8
     c47:	de c9                	fmulp  %st,%st(1)
     c49:	de e9                	fsubrp %st,%st(1)
     c4b:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     c4e:	d9 45 08             	flds   0x8(%ebp)
     c51:	dd 05 d8 60 01 00    	fldl   0x160d8
     c57:	d9 c9                	fxch   %st(1)
     c59:	df e9                	fucomip %st(1),%st
     c5b:	dd d8                	fstp   %st(0)
     c5d:	76 0e                	jbe    c6d <cos+0x86>
     c5f:	d9 45 08             	flds   0x8(%ebp)
     c62:	dd 05 c8 60 01 00    	fldl   0x160c8
     c68:	de e9                	fsubrp %st,%st(1)
     c6a:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     c6d:	d9 45 08             	flds   0x8(%ebp)
     c70:	dd 05 e0 60 01 00    	fldl   0x160e0
     c76:	df e9                	fucomip %st(1),%st
     c78:	dd d8                	fstp   %st(0)
     c7a:	76 0e                	jbe    c8a <cos+0xa3>
     c7c:	d9 45 08             	flds   0x8(%ebp)
     c7f:	dd 05 c8 60 01 00    	fldl   0x160c8
     c85:	de c1                	faddp  %st,%st(1)
     c87:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     c8a:	d9 45 08             	flds   0x8(%ebp)
     c8d:	dd 05 e8 60 01 00    	fldl   0x160e8
     c93:	d9 c9                	fxch   %st(1)
     c95:	df e9                	fucomip %st(1),%st
     c97:	dd d8                	fstp   %st(0)
     c99:	76 16                	jbe    cb1 <cos+0xca>
    {
        x -= PI;
     c9b:	d9 45 08             	flds   0x8(%ebp)
     c9e:	dd 05 d8 60 01 00    	fldl   0x160d8
     ca4:	de e9                	fsubrp %st,%st(1)
     ca6:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     ca9:	d9 45 f4             	flds   -0xc(%ebp)
     cac:	d9 e0                	fchs   
     cae:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     cb1:	d9 45 08             	flds   0x8(%ebp)
     cb4:	dd 05 f0 60 01 00    	fldl   0x160f0
     cba:	df e9                	fucomip %st(1),%st
     cbc:	dd d8                	fstp   %st(0)
     cbe:	76 16                	jbe    cd6 <cos+0xef>
    {
        x += PI;
     cc0:	d9 45 08             	flds   0x8(%ebp)
     cc3:	dd 05 d8 60 01 00    	fldl   0x160d8
     cc9:	de c1                	faddp  %st,%st(1)
     ccb:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     cce:	d9 45 f4             	flds   -0xc(%ebp)
     cd1:	d9 e0                	fchs   
     cd3:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * sin(PI / 2 - x);
     cd6:	d9 45 08             	flds   0x8(%ebp)
     cd9:	dd 05 f8 60 01 00    	fldl   0x160f8
     cdf:	d9 c9                	fxch   %st(1)
     ce1:	df e9                	fucomip %st(1),%st
     ce3:	dd d8                	fstp   %st(0)
     ce5:	76 28                	jbe    d0f <cos+0x128>
     ce7:	d9 45 08             	flds   0x8(%ebp)
     cea:	dd 05 e8 60 01 00    	fldl   0x160e8
     cf0:	de e1                	fsubp  %st,%st(1)
     cf2:	d9 5d e4             	fstps  -0x1c(%ebp)
     cf5:	d9 45 e4             	flds   -0x1c(%ebp)
     cf8:	83 ec 0c             	sub    $0xc,%esp
     cfb:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     cff:	d9 1c 24             	fstps  (%esp)
     d02:	e8 83 00 00 00       	call   d8a <sin>
     d07:	83 c4 10             	add    $0x10,%esp
     d0a:	d8 4d f4             	fmuls  -0xc(%ebp)
     d0d:	eb 79                	jmp    d88 <cos+0x1a1>
    else return fl * (1 - pow(x, 2) / 2 + pow(x, 4) / 24 - pow(x, 6) / 720 + pow(x, 8) / 40320);//̩�չ�ʽ
     d0f:	83 ec 08             	sub    $0x8,%esp
     d12:	6a 02                	push   $0x2
     d14:	ff 75 08             	pushl  0x8(%ebp)
     d17:	e8 1e fe ff ff       	call   b3a <pow>
     d1c:	83 c4 10             	add    $0x10,%esp
     d1f:	d9 05 c0 60 01 00    	flds   0x160c0
     d25:	de f9                	fdivrp %st,%st(1)
     d27:	d9 e8                	fld1   
     d29:	de e1                	fsubp  %st,%st(1)
     d2b:	d9 5d d8             	fstps  -0x28(%ebp)
     d2e:	83 ec 08             	sub    $0x8,%esp
     d31:	6a 04                	push   $0x4
     d33:	ff 75 08             	pushl  0x8(%ebp)
     d36:	e8 ff fd ff ff       	call   b3a <pow>
     d3b:	83 c4 10             	add    $0x10,%esp
     d3e:	d9 05 00 61 01 00    	flds   0x16100
     d44:	de f9                	fdivrp %st,%st(1)
     d46:	d8 45 d8             	fadds  -0x28(%ebp)
     d49:	d9 5d d8             	fstps  -0x28(%ebp)
     d4c:	83 ec 08             	sub    $0x8,%esp
     d4f:	6a 06                	push   $0x6
     d51:	ff 75 08             	pushl  0x8(%ebp)
     d54:	e8 e1 fd ff ff       	call   b3a <pow>
     d59:	83 c4 10             	add    $0x10,%esp
     d5c:	d9 05 04 61 01 00    	flds   0x16104
     d62:	de f9                	fdivrp %st,%st(1)
     d64:	d8 6d d8             	fsubrs -0x28(%ebp)
     d67:	d9 5d d8             	fstps  -0x28(%ebp)
     d6a:	83 ec 08             	sub    $0x8,%esp
     d6d:	6a 08                	push   $0x8
     d6f:	ff 75 08             	pushl  0x8(%ebp)
     d72:	e8 c3 fd ff ff       	call   b3a <pow>
     d77:	83 c4 10             	add    $0x10,%esp
     d7a:	d9 05 08 61 01 00    	flds   0x16108
     d80:	de f9                	fdivrp %st,%st(1)
     d82:	d8 45 d8             	fadds  -0x28(%ebp)
     d85:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     d88:	c9                   	leave  
     d89:	c3                   	ret    

00000d8a <sin>:

float sin(float x)
{
     d8a:	55                   	push   %ebp
     d8b:	89 e5                	mov    %esp,%ebp
     d8d:	83 ec 28             	sub    $0x28,%esp
    float fl = 1;
     d90:	d9 e8                	fld1   
     d92:	d9 5d f4             	fstps  -0xc(%ebp)
    if (x > 2 * PI || x < -2 * PI) x -= (int)(x / (2 * PI)) * 2 * PI;
     d95:	d9 45 08             	flds   0x8(%ebp)
     d98:	dd 05 c8 60 01 00    	fldl   0x160c8
     d9e:	d9 c9                	fxch   %st(1)
     da0:	df e9                	fucomip %st(1),%st
     da2:	dd d8                	fstp   %st(0)
     da4:	77 0f                	ja     db5 <sin+0x2b>
     da6:	d9 45 08             	flds   0x8(%ebp)
     da9:	dd 05 d0 60 01 00    	fldl   0x160d0
     daf:	df e9                	fucomip %st(1),%st
     db1:	dd d8                	fstp   %st(0)
     db3:	76 3c                	jbe    df1 <sin+0x67>
     db5:	d9 45 08             	flds   0x8(%ebp)
     db8:	d9 45 08             	flds   0x8(%ebp)
     dbb:	dd 05 c8 60 01 00    	fldl   0x160c8
     dc1:	de f9                	fdivrp %st,%st(1)
     dc3:	d9 7d e2             	fnstcw -0x1e(%ebp)
     dc6:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
     dca:	b4 0c                	mov    $0xc,%ah
     dcc:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
     dd0:	d9 6d e0             	fldcw  -0x20(%ebp)
     dd3:	db 5d dc             	fistpl -0x24(%ebp)
     dd6:	d9 6d e2             	fldcw  -0x1e(%ebp)
     dd9:	8b 45 dc             	mov    -0x24(%ebp),%eax
     ddc:	01 c0                	add    %eax,%eax
     dde:	89 45 d8             	mov    %eax,-0x28(%ebp)
     de1:	db 45 d8             	fildl  -0x28(%ebp)
     de4:	dd 05 d8 60 01 00    	fldl   0x160d8
     dea:	de c9                	fmulp  %st,%st(1)
     dec:	de e9                	fsubrp %st,%st(1)
     dee:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI) x -= 2 * PI;
     df1:	d9 45 08             	flds   0x8(%ebp)
     df4:	dd 05 d8 60 01 00    	fldl   0x160d8
     dfa:	d9 c9                	fxch   %st(1)
     dfc:	df e9                	fucomip %st(1),%st
     dfe:	dd d8                	fstp   %st(0)
     e00:	76 0e                	jbe    e10 <sin+0x86>
     e02:	d9 45 08             	flds   0x8(%ebp)
     e05:	dd 05 c8 60 01 00    	fldl   0x160c8
     e0b:	de e9                	fsubrp %st,%st(1)
     e0d:	d9 5d 08             	fstps  0x8(%ebp)
    if (x < -PI) x += 2 * PI;
     e10:	d9 45 08             	flds   0x8(%ebp)
     e13:	dd 05 e0 60 01 00    	fldl   0x160e0
     e19:	df e9                	fucomip %st(1),%st
     e1b:	dd d8                	fstp   %st(0)
     e1d:	76 0e                	jbe    e2d <sin+0xa3>
     e1f:	d9 45 08             	flds   0x8(%ebp)
     e22:	dd 05 c8 60 01 00    	fldl   0x160c8
     e28:	de c1                	faddp  %st,%st(1)
     e2a:	d9 5d 08             	fstps  0x8(%ebp)
    if (x > PI / 2)
     e2d:	d9 45 08             	flds   0x8(%ebp)
     e30:	dd 05 e8 60 01 00    	fldl   0x160e8
     e36:	d9 c9                	fxch   %st(1)
     e38:	df e9                	fucomip %st(1),%st
     e3a:	dd d8                	fstp   %st(0)
     e3c:	76 16                	jbe    e54 <sin+0xca>
    {
        x -= PI;
     e3e:	d9 45 08             	flds   0x8(%ebp)
     e41:	dd 05 d8 60 01 00    	fldl   0x160d8
     e47:	de e9                	fsubrp %st,%st(1)
     e49:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     e4c:	d9 45 f4             	flds   -0xc(%ebp)
     e4f:	d9 e0                	fchs   
     e51:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < -PI / 2)
     e54:	d9 45 08             	flds   0x8(%ebp)
     e57:	dd 05 f0 60 01 00    	fldl   0x160f0
     e5d:	df e9                	fucomip %st(1),%st
     e5f:	dd d8                	fstp   %st(0)
     e61:	76 16                	jbe    e79 <sin+0xef>
    {
        x += PI;
     e63:	d9 45 08             	flds   0x8(%ebp)
     e66:	dd 05 d8 60 01 00    	fldl   0x160d8
     e6c:	de c1                	faddp  %st,%st(1)
     e6e:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     e71:	d9 45 f4             	flds   -0xc(%ebp)
     e74:	d9 e0                	fchs   
     e76:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x < 0)
     e79:	d9 ee                	fldz   
     e7b:	d9 45 08             	flds   0x8(%ebp)
     e7e:	d9 c9                	fxch   %st(1)
     e80:	df e9                	fucomip %st(1),%st
     e82:	dd d8                	fstp   %st(0)
     e84:	76 10                	jbe    e96 <sin+0x10c>
    {
        x *= -1;
     e86:	d9 45 08             	flds   0x8(%ebp)
     e89:	d9 e0                	fchs   
     e8b:	d9 5d 08             	fstps  0x8(%ebp)
        fl *= -1;
     e8e:	d9 45 f4             	flds   -0xc(%ebp)
     e91:	d9 e0                	fchs   
     e93:	d9 5d f4             	fstps  -0xc(%ebp)
    }
    if (x > PI / 4) return fl * cos(PI / 2 - x);
     e96:	d9 45 08             	flds   0x8(%ebp)
     e99:	dd 05 f8 60 01 00    	fldl   0x160f8
     e9f:	d9 c9                	fxch   %st(1)
     ea1:	df e9                	fucomip %st(1),%st
     ea3:	dd d8                	fstp   %st(0)
     ea5:	76 28                	jbe    ecf <sin+0x145>
     ea7:	d9 45 08             	flds   0x8(%ebp)
     eaa:	dd 05 e8 60 01 00    	fldl   0x160e8
     eb0:	de e1                	fsubp  %st,%st(1)
     eb2:	d9 5d e4             	fstps  -0x1c(%ebp)
     eb5:	d9 45 e4             	flds   -0x1c(%ebp)
     eb8:	83 ec 0c             	sub    $0xc,%esp
     ebb:	8d 64 24 fc          	lea    -0x4(%esp),%esp
     ebf:	d9 1c 24             	fstps  (%esp)
     ec2:	e8 20 fd ff ff       	call   be7 <cos>
     ec7:	83 c4 10             	add    $0x10,%esp
     eca:	d8 4d f4             	fmuls  -0xc(%ebp)
     ecd:	eb 7a                	jmp    f49 <sin+0x1bf>
    else return fl * (x - pow(x, 3) / 6 + pow(x, 5) / 120 - pow(x, 7) / 5040 + pow(x, 9) / 362880);//̩�չ�ʽ
     ecf:	83 ec 08             	sub    $0x8,%esp
     ed2:	6a 03                	push   $0x3
     ed4:	ff 75 08             	pushl  0x8(%ebp)
     ed7:	e8 5e fc ff ff       	call   b3a <pow>
     edc:	83 c4 10             	add    $0x10,%esp
     edf:	d9 05 0c 61 01 00    	flds   0x1610c
     ee5:	de f9                	fdivrp %st,%st(1)
     ee7:	d9 45 08             	flds   0x8(%ebp)
     eea:	de e1                	fsubp  %st,%st(1)
     eec:	d9 5d d8             	fstps  -0x28(%ebp)
     eef:	83 ec 08             	sub    $0x8,%esp
     ef2:	6a 05                	push   $0x5
     ef4:	ff 75 08             	pushl  0x8(%ebp)
     ef7:	e8 3e fc ff ff       	call   b3a <pow>
     efc:	83 c4 10             	add    $0x10,%esp
     eff:	d9 05 10 61 01 00    	flds   0x16110
     f05:	de f9                	fdivrp %st,%st(1)
     f07:	d8 45 d8             	fadds  -0x28(%ebp)
     f0a:	d9 5d d8             	fstps  -0x28(%ebp)
     f0d:	83 ec 08             	sub    $0x8,%esp
     f10:	6a 07                	push   $0x7
     f12:	ff 75 08             	pushl  0x8(%ebp)
     f15:	e8 20 fc ff ff       	call   b3a <pow>
     f1a:	83 c4 10             	add    $0x10,%esp
     f1d:	d9 05 14 61 01 00    	flds   0x16114
     f23:	de f9                	fdivrp %st,%st(1)
     f25:	d8 6d d8             	fsubrs -0x28(%ebp)
     f28:	d9 5d d8             	fstps  -0x28(%ebp)
     f2b:	83 ec 08             	sub    $0x8,%esp
     f2e:	6a 09                	push   $0x9
     f30:	ff 75 08             	pushl  0x8(%ebp)
     f33:	e8 02 fc ff ff       	call   b3a <pow>
     f38:	83 c4 10             	add    $0x10,%esp
     f3b:	d9 05 18 61 01 00    	flds   0x16118
     f41:	de f9                	fdivrp %st,%st(1)
     f43:	d8 45 d8             	fadds  -0x28(%ebp)
     f46:	d8 4d f4             	fmuls  -0xc(%ebp)
}
     f49:	c9                   	leave  
     f4a:	c3                   	ret    

00000f4b <readBitmapHeader>:
#include "user.h"
#include "x86.h"
#include "gui_base.h"
#include "bitmap.h"

void readBitmapHeader(int bmpFile, BITMAP_FILE_HEADER *bmpFileHeader, BITMAP_INFO_HEADER *bmpInfoHeader) {
     f4b:	55                   	push   %ebp
     f4c:	89 e5                	mov    %esp,%ebp
     f4e:	83 ec 08             	sub    $0x8,%esp
    // Read Bitmap file header
    read(bmpFile, bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
     f51:	83 ec 04             	sub    $0x4,%esp
     f54:	6a 0e                	push   $0xe
     f56:	ff 75 0c             	pushl  0xc(%ebp)
     f59:	ff 75 08             	pushl  0x8(%ebp)
     f5c:	e8 44 f6 ff ff       	call   5a5 <read>
     f61:	83 c4 10             	add    $0x10,%esp
    // Read Bitmap info header
    read(bmpFile, bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
     f64:	83 ec 04             	sub    $0x4,%esp
     f67:	6a 28                	push   $0x28
     f69:	ff 75 10             	pushl  0x10(%ebp)
     f6c:	ff 75 08             	pushl  0x8(%ebp)
     f6f:	e8 31 f6 ff ff       	call   5a5 <read>
     f74:	83 c4 10             	add    $0x10,%esp
}
     f77:	90                   	nop
     f78:	c9                   	leave  
     f79:	c3                   	ret    

00000f7a <readBitmapFile>:

int readBitmapFile(char *fileName, RGBA *result, int *height, int *width) {
     f7a:	55                   	push   %ebp
     f7b:	89 e5                	mov    %esp,%ebp
     f7d:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
     f83:	83 ec 08             	sub    $0x8,%esp
     f86:	6a 00                	push   $0x0
     f88:	ff 75 08             	pushl  0x8(%ebp)
     f8b:	e8 3d f6 ff ff       	call   5cd <open>
     f90:	83 c4 10             	add    $0x10,%esp
     f93:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
     f96:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
     f9a:	79 0a                	jns    fa6 <readBitmapFile+0x2c>
        return -1;
     f9c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
     fa1:	e9 6e 01 00 00       	jmp    1114 <readBitmapFile+0x19a>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
     fa6:	83 ec 04             	sub    $0x4,%esp
     fa9:	8d 45 a2             	lea    -0x5e(%ebp),%eax
     fac:	50                   	push   %eax
     fad:	8d 45 ca             	lea    -0x36(%ebp),%eax
     fb0:	50                   	push   %eax
     fb1:	ff 75 ec             	pushl  -0x14(%ebp)
     fb4:	e8 92 ff ff ff       	call   f4b <readBitmapHeader>
     fb9:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
     fbc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
     fbf:	83 e8 36             	sub    $0x36,%eax
     fc2:	83 ec 04             	sub    $0x4,%esp
     fc5:	50                   	push   %eax
     fc6:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
     fcc:	50                   	push   %eax
     fcd:	ff 75 ec             	pushl  -0x14(%ebp)
     fd0:	e8 d0 f5 ff ff       	call   5a5 <read>
     fd5:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
     fd8:	8b 55 a6             	mov    -0x5a(%ebp),%edx
     fdb:	8b 45 14             	mov    0x14(%ebp),%eax
     fde:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
     fe0:	8b 55 aa             	mov    -0x56(%ebp),%edx
     fe3:	8b 45 10             	mov    0x10(%ebp),%eax
     fe6:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
     fe8:	8b 45 a6             	mov    -0x5a(%ebp),%eax
     feb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
     fee:	8b 45 aa             	mov    -0x56(%ebp),%eax
     ff1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
     ff4:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
     ff8:	0f b7 c0             	movzwl %ax,%eax
     ffb:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
     ffe:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1001:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    1005:	8d 50 07             	lea    0x7(%eax),%edx
    1008:	85 c0                	test   %eax,%eax
    100a:	0f 48 c2             	cmovs  %edx,%eax
    100d:	c1 f8 03             	sar    $0x3,%eax
    1010:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    1013:	8b 45 0c             	mov    0xc(%ebp),%eax
    1016:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    1019:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    101c:	83 e8 01             	sub    $0x1,%eax
    101f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1022:	e9 d0 00 00 00       	jmp    10f7 <readBitmapFile+0x17d>
        if (bits == 32) {
    1027:	83 7d e0 20          	cmpl   $0x20,-0x20(%ebp)
    102b:	75 22                	jne    104f <readBitmapFile+0xd5>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    102d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1030:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    1034:	89 c2                	mov    %eax,%edx
    1036:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1039:	01 d0                	add    %edx,%eax
    103b:	83 ec 04             	sub    $0x4,%esp
    103e:	ff 75 dc             	pushl  -0x24(%ebp)
    1041:	50                   	push   %eax
    1042:	ff 75 ec             	pushl  -0x14(%ebp)
    1045:	e8 5b f5 ff ff       	call   5a5 <read>
    104a:	83 c4 10             	add    $0x10,%esp
    104d:	eb 65                	jmp    10b4 <readBitmapFile+0x13a>
        } else {
            int j = 0;
    104f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    1056:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    105d:	eb 4d                	jmp    10ac <readBitmapFile+0x132>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
    105f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1062:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    1066:	c1 e0 02             	shl    $0x2,%eax
    1069:	89 c2                	mov    %eax,%edx
    106b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    106e:	c1 e0 02             	shl    $0x2,%eax
    1071:	01 c2                	add    %eax,%edx
    1073:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1076:	01 d0                	add    %edx,%eax
    1078:	83 ec 04             	sub    $0x4,%esp
    107b:	6a 03                	push   $0x3
    107d:	50                   	push   %eax
    107e:	ff 75 ec             	pushl  -0x14(%ebp)
    1081:	e8 1f f5 ff ff       	call   5a5 <read>
    1086:	83 c4 10             	add    $0x10,%esp
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
    1089:	8b 45 f4             	mov    -0xc(%ebp),%eax
    108c:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    1090:	c1 e0 02             	shl    $0x2,%eax
    1093:	89 c2                	mov    %eax,%edx
    1095:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1098:	c1 e0 02             	shl    $0x2,%eax
    109b:	01 d0                	add    %edx,%eax
    109d:	8d 50 03             	lea    0x3(%eax),%edx
    10a0:	8b 45 d8             	mov    -0x28(%ebp),%eax
    10a3:	01 d0                	add    %edx,%eax
    10a5:	c6 00 ff             	movb   $0xff,(%eax)
    for (i = row - 1; i >= 0; i--) {
        if (bits == 32) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    10a8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    10ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
    10af:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    10b2:	7c ab                	jl     105f <readBitmapFile+0xe5>
                read(bmpFile, buf + i * column * 4 + j * sizeof(RGBA), 3);
                *(buf + i * column * 4 + j * sizeof(RGBA) + 3) = 255;
            }
        }
        if (rowBytes % 4 > 0) {
    10b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    10b7:	99                   	cltd   
    10b8:	c1 ea 1e             	shr    $0x1e,%edx
    10bb:	01 d0                	add    %edx,%eax
    10bd:	83 e0 03             	and    $0x3,%eax
    10c0:	29 d0                	sub    %edx,%eax
    10c2:	85 c0                	test   %eax,%eax
    10c4:	7e 2d                	jle    10f3 <readBitmapFile+0x179>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    10c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
    10c9:	99                   	cltd   
    10ca:	c1 ea 1e             	shr    $0x1e,%edx
    10cd:	01 d0                	add    %edx,%eax
    10cf:	83 e0 03             	and    $0x3,%eax
    10d2:	29 d0                	sub    %edx,%eax
    10d4:	ba 04 00 00 00       	mov    $0x4,%edx
    10d9:	29 c2                	sub    %eax,%edx
    10db:	89 d0                	mov    %edx,%eax
    10dd:	83 ec 04             	sub    $0x4,%esp
    10e0:	50                   	push   %eax
    10e1:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    10e7:	50                   	push   %eax
    10e8:	ff 75 ec             	pushl  -0x14(%ebp)
    10eb:	e8 b5 f4 ff ff       	call   5a5 <read>
    10f0:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * bits / 8;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    10f3:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    10f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    10fb:	0f 89 26 ff ff ff    	jns    1027 <readBitmapFile+0xad>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1101:	83 ec 0c             	sub    $0xc,%esp
    1104:	ff 75 ec             	pushl  -0x14(%ebp)
    1107:	e8 a9 f4 ff ff       	call   5b5 <close>
    110c:	83 c4 10             	add    $0x10,%esp
    return 0;
    110f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1114:	c9                   	leave  
    1115:	c3                   	ret    

00001116 <read24BitmapFile>:

int read24BitmapFile(char *fileName, RGB *result, int *height, int *width) {
    1116:	55                   	push   %ebp
    1117:	89 e5                	mov    %esp,%ebp
    1119:	81 ec c8 00 00 00    	sub    $0xc8,%esp
    int i;
    int bmpFile = open(fileName, 0);
    111f:	83 ec 08             	sub    $0x8,%esp
    1122:	6a 00                	push   $0x0
    1124:	ff 75 08             	pushl  0x8(%ebp)
    1127:	e8 a1 f4 ff ff       	call   5cd <open>
    112c:	83 c4 10             	add    $0x10,%esp
    112f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (bmpFile < 0) {
    1132:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    1136:	79 0a                	jns    1142 <read24BitmapFile+0x2c>
        return -1;
    1138:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    113d:	e9 66 01 00 00       	jmp    12a8 <read24BitmapFile+0x192>
    }

    BITMAP_FILE_HEADER bmpFileHeader;
    BITMAP_INFO_HEADER bmpInfoHeader;

    readBitmapHeader(bmpFile, &bmpFileHeader, &bmpInfoHeader);
    1142:	83 ec 04             	sub    $0x4,%esp
    1145:	8d 45 a2             	lea    -0x5e(%ebp),%eax
    1148:	50                   	push   %eax
    1149:	8d 45 ca             	lea    -0x36(%ebp),%eax
    114c:	50                   	push   %eax
    114d:	ff 75 ec             	pushl  -0x14(%ebp)
    1150:	e8 f6 fd ff ff       	call   f4b <readBitmapHeader>
    1155:	83 c4 10             	add    $0x10,%esp
    char headerbuf[100];
    read(bmpFile, headerbuf, bmpFileHeader.btOffBits - 54); // read out the extra header
    1158:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    115b:	83 e8 36             	sub    $0x36,%eax
    115e:	83 ec 04             	sub    $0x4,%esp
    1161:	50                   	push   %eax
    1162:	8d 85 3e ff ff ff    	lea    -0xc2(%ebp),%eax
    1168:	50                   	push   %eax
    1169:	ff 75 ec             	pushl  -0x14(%ebp)
    116c:	e8 34 f4 ff ff       	call   5a5 <read>
    1171:	83 c4 10             	add    $0x10,%esp
    *width = bmpInfoHeader.biWidth;
    1174:	8b 55 a6             	mov    -0x5a(%ebp),%edx
    1177:	8b 45 14             	mov    0x14(%ebp),%eax
    117a:	89 10                	mov    %edx,(%eax)
    *height = bmpInfoHeader.biHeight;
    117c:	8b 55 aa             	mov    -0x56(%ebp),%edx
    117f:	8b 45 10             	mov    0x10(%ebp),%eax
    1182:	89 10                	mov    %edx,(%eax)
    int column = bmpInfoHeader.biWidth;
    1184:	8b 45 a6             	mov    -0x5a(%ebp),%eax
    1187:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int row = bmpInfoHeader.biHeight;
    118a:	8b 45 aa             	mov    -0x56(%ebp),%eax
    118d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int bits = bmpInfoHeader.biBitCount;
    1190:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    1194:	0f b7 c0             	movzwl %ax,%eax
    1197:	89 45 e0             	mov    %eax,-0x20(%ebp)
    char tmpBytes[3];
    int rowBytes = column * 3;
    119a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    119d:	89 d0                	mov    %edx,%eax
    119f:	01 c0                	add    %eax,%eax
    11a1:	01 d0                	add    %edx,%eax
    11a3:	89 45 dc             	mov    %eax,-0x24(%ebp)
    char *buf = (char *) result;
    11a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    11a9:	89 45 d8             	mov    %eax,-0x28(%ebp)
    for (i = row - 1; i >= 0; i--) {
    11ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    11af:	83 e8 01             	sub    $0x1,%eax
    11b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    11b5:	e9 d1 00 00 00       	jmp    128b <read24BitmapFile+0x175>
        if (bits == 24) {
    11ba:	83 7d e0 18          	cmpl   $0x18,-0x20(%ebp)
    11be:	75 22                	jne    11e2 <read24BitmapFile+0xcc>
            read(bmpFile, buf + i * rowBytes, rowBytes);
    11c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    11c3:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    11c7:	89 c2                	mov    %eax,%edx
    11c9:	8b 45 d8             	mov    -0x28(%ebp),%eax
    11cc:	01 d0                	add    %edx,%eax
    11ce:	83 ec 04             	sub    $0x4,%esp
    11d1:	ff 75 dc             	pushl  -0x24(%ebp)
    11d4:	50                   	push   %eax
    11d5:	ff 75 ec             	pushl  -0x14(%ebp)
    11d8:	e8 c8 f3 ff ff       	call   5a5 <read>
    11dd:	83 c4 10             	add    $0x10,%esp
    11e0:	eb 66                	jmp    1248 <read24BitmapFile+0x132>
        } else {
            int j = 0;
    11e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            for (j = 0; j < column; j++) {
    11e9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    11f0:	eb 4e                	jmp    1240 <read24BitmapFile+0x12a>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
    11f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    11f5:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    11f9:	89 c2                	mov    %eax,%edx
    11fb:	89 d0                	mov    %edx,%eax
    11fd:	01 c0                	add    %eax,%eax
    11ff:	01 d0                	add    %edx,%eax
    1201:	89 c1                	mov    %eax,%ecx
    1203:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1206:	89 d0                	mov    %edx,%eax
    1208:	01 c0                	add    %eax,%eax
    120a:	01 d0                	add    %edx,%eax
    120c:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    120f:	8b 45 d8             	mov    -0x28(%ebp),%eax
    1212:	01 d0                	add    %edx,%eax
    1214:	83 ec 04             	sub    $0x4,%esp
    1217:	6a 03                	push   $0x3
    1219:	50                   	push   %eax
    121a:	ff 75 ec             	pushl  -0x14(%ebp)
    121d:	e8 83 f3 ff ff       	call   5a5 <read>
    1222:	83 c4 10             	add    $0x10,%esp
                read(bmpFile, tmpBytes, 1);
    1225:	83 ec 04             	sub    $0x4,%esp
    1228:	6a 01                	push   $0x1
    122a:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    1230:	50                   	push   %eax
    1231:	ff 75 ec             	pushl  -0x14(%ebp)
    1234:	e8 6c f3 ff ff       	call   5a5 <read>
    1239:	83 c4 10             	add    $0x10,%esp
    for (i = row - 1; i >= 0; i--) {
        if (bits == 24) {
            read(bmpFile, buf + i * rowBytes, rowBytes);
        } else {
            int j = 0;
            for (j = 0; j < column; j++) {
    123c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1240:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1243:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    1246:	7c aa                	jl     11f2 <read24BitmapFile+0xdc>
                read(bmpFile, buf + i * column * 3 + j * sizeof(RGB), 3);
                read(bmpFile, tmpBytes, 1);
            }
        }

        if (rowBytes % 4 > 0) {
    1248:	8b 45 dc             	mov    -0x24(%ebp),%eax
    124b:	99                   	cltd   
    124c:	c1 ea 1e             	shr    $0x1e,%edx
    124f:	01 d0                	add    %edx,%eax
    1251:	83 e0 03             	and    $0x3,%eax
    1254:	29 d0                	sub    %edx,%eax
    1256:	85 c0                	test   %eax,%eax
    1258:	7e 2d                	jle    1287 <read24BitmapFile+0x171>
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    125a:	8b 45 dc             	mov    -0x24(%ebp),%eax
    125d:	99                   	cltd   
    125e:	c1 ea 1e             	shr    $0x1e,%edx
    1261:	01 d0                	add    %edx,%eax
    1263:	83 e0 03             	and    $0x3,%eax
    1266:	29 d0                	sub    %edx,%eax
    1268:	ba 04 00 00 00       	mov    $0x4,%edx
    126d:	29 c2                	sub    %eax,%edx
    126f:	89 d0                	mov    %edx,%eax
    1271:	83 ec 04             	sub    $0x4,%esp
    1274:	50                   	push   %eax
    1275:	8d 85 3b ff ff ff    	lea    -0xc5(%ebp),%eax
    127b:	50                   	push   %eax
    127c:	ff 75 ec             	pushl  -0x14(%ebp)
    127f:	e8 21 f3 ff ff       	call   5a5 <read>
    1284:	83 c4 10             	add    $0x10,%esp
    int row = bmpInfoHeader.biHeight;
    int bits = bmpInfoHeader.biBitCount;
    char tmpBytes[3];
    int rowBytes = column * 3;
    char *buf = (char *) result;
    for (i = row - 1; i >= 0; i--) {
    1287:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    128b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    128f:	0f 89 25 ff ff ff    	jns    11ba <read24BitmapFile+0xa4>
        if (rowBytes % 4 > 0) {
            read(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    1295:	83 ec 0c             	sub    $0xc,%esp
    1298:	ff 75 ec             	pushl  -0x14(%ebp)
    129b:	e8 15 f3 ff ff       	call   5b5 <close>
    12a0:	83 c4 10             	add    $0x10,%esp
    return 0;
    12a3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    12a8:	c9                   	leave  
    12a9:	c3                   	ret    

000012aa <write24BitmapFileHeader>:

void write24BitmapFileHeader(int bmpFile, int height, int width) {
    12aa:	55                   	push   %ebp
    12ab:	89 e5                	mov    %esp,%ebp
    12ad:	83 ec 48             	sub    $0x48,%esp
    int rowSize = (24 * width + 31) / 32 * 4;  // zero padding
    12b0:	8b 55 10             	mov    0x10(%ebp),%edx
    12b3:	89 d0                	mov    %edx,%eax
    12b5:	01 c0                	add    %eax,%eax
    12b7:	01 d0                	add    %edx,%eax
    12b9:	c1 e0 03             	shl    $0x3,%eax
    12bc:	83 c0 1f             	add    $0x1f,%eax
    12bf:	8d 50 1f             	lea    0x1f(%eax),%edx
    12c2:	85 c0                	test   %eax,%eax
    12c4:	0f 48 c2             	cmovs  %edx,%eax
    12c7:	c1 f8 05             	sar    $0x5,%eax
    12ca:	c1 e0 02             	shl    $0x2,%eax
    12cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BITMAP_FILE_HEADER bmpFileHeader;
    bmpFileHeader.bfType = 0x4D42;  // "BM"
    12d0:	66 c7 45 e6 42 4d    	movw   $0x4d42,-0x1a(%ebp)
    bmpFileHeader.bfSize = rowSize * height + 54;
    12d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    12d9:	0f af 45 0c          	imul   0xc(%ebp),%eax
    12dd:	83 c0 36             	add    $0x36,%eax
    12e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bmpFileHeader.bfReserved1 = 0;
    12e3:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%ebp)
    bmpFileHeader.bfReserved2 = 0;
    12e9:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%ebp)
    bmpFileHeader.btOffBits = 54;  // size of header
    12ef:	c7 45 f0 36 00 00 00 	movl   $0x36,-0x10(%ebp)

    BITMAP_INFO_HEADER bmpInfoHeader;
    bmpInfoHeader.biSize = 40;  // header size
    12f6:	c7 45 be 28 00 00 00 	movl   $0x28,-0x42(%ebp)
    bmpInfoHeader.biWidth = width;
    12fd:	8b 45 10             	mov    0x10(%ebp),%eax
    1300:	89 45 c2             	mov    %eax,-0x3e(%ebp)
    bmpInfoHeader.biHeight = height;
    1303:	8b 45 0c             	mov    0xc(%ebp),%eax
    1306:	89 45 c6             	mov    %eax,-0x3a(%ebp)
    bmpInfoHeader.biPlanes = 1;
    1309:	66 c7 45 ca 01 00    	movw   $0x1,-0x36(%ebp)
    bmpInfoHeader.biBitCount = 24;
    130f:	66 c7 45 cc 18 00    	movw   $0x18,-0x34(%ebp)
    bmpInfoHeader.biCompression = 0;               // No Compression
    1315:	c7 45 ce 00 00 00 00 	movl   $0x0,-0x32(%ebp)
    bmpInfoHeader.biSizeImage = rowSize * height;  // TODO:
    131c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    131f:	0f af 45 0c          	imul   0xc(%ebp),%eax
    1323:	89 45 d2             	mov    %eax,-0x2e(%ebp)
    bmpInfoHeader.biXPelsPerMeter = 0;             //TODO:
    1326:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
    bmpInfoHeader.biYPelsPerMeter = 0;             //TODO:
    132d:	c7 45 da 00 00 00 00 	movl   $0x0,-0x26(%ebp)
    bmpInfoHeader.biCirUserd = 0;
    1334:	c7 45 de 00 00 00 00 	movl   $0x0,-0x22(%ebp)
    bmpInfoHeader.biCirImportant = 0;
    133b:	c7 45 e2 00 00 00 00 	movl   $0x0,-0x1e(%ebp)

    write(bmpFile, &bmpFileHeader, sizeof(BITMAP_FILE_HEADER));
    1342:	83 ec 04             	sub    $0x4,%esp
    1345:	6a 0e                	push   $0xe
    1347:	8d 45 e6             	lea    -0x1a(%ebp),%eax
    134a:	50                   	push   %eax
    134b:	ff 75 08             	pushl  0x8(%ebp)
    134e:	e8 5a f2 ff ff       	call   5ad <write>
    1353:	83 c4 10             	add    $0x10,%esp
    write(bmpFile, &bmpInfoHeader, sizeof(BITMAP_INFO_HEADER));
    1356:	83 ec 04             	sub    $0x4,%esp
    1359:	6a 28                	push   $0x28
    135b:	8d 45 be             	lea    -0x42(%ebp),%eax
    135e:	50                   	push   %eax
    135f:	ff 75 08             	pushl  0x8(%ebp)
    1362:	e8 46 f2 ff ff       	call   5ad <write>
    1367:	83 c4 10             	add    $0x10,%esp
}
    136a:	90                   	nop
    136b:	c9                   	leave  
    136c:	c3                   	ret    

0000136d <write24BitmapFile>:

int write24BitmapFile(char *filename, RGB *img, int height, int width) {
    136d:	55                   	push   %ebp
    136e:	89 e5                	mov    %esp,%ebp
    1370:	83 ec 18             	sub    $0x18,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    1373:	83 ec 08             	sub    $0x8,%esp
    1376:	68 02 02 00 00       	push   $0x202
    137b:	ff 75 08             	pushl  0x8(%ebp)
    137e:	e8 4a f2 ff ff       	call   5cd <open>
    1383:	83 c4 10             	add    $0x10,%esp
    1386:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int rowBytes = width * 3;
    1389:	8b 55 14             	mov    0x14(%ebp),%edx
    138c:	89 d0                	mov    %edx,%eax
    138e:	01 c0                	add    %eax,%eax
    1390:	01 d0                	add    %edx,%eax
    1392:	89 45 ec             	mov    %eax,-0x14(%ebp)
    char tmpBytes[3] = {0, 0, 0};
    1395:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
    1399:	c6 45 ea 00          	movb   $0x0,-0x16(%ebp)
    139d:	c6 45 eb 00          	movb   $0x0,-0x15(%ebp)

    write24BitmapFileHeader(bmpFile, height, width);
    13a1:	83 ec 04             	sub    $0x4,%esp
    13a4:	ff 75 14             	pushl  0x14(%ebp)
    13a7:	ff 75 10             	pushl  0x10(%ebp)
    13aa:	ff 75 f0             	pushl  -0x10(%ebp)
    13ad:	e8 f8 fe ff ff       	call   12aa <write24BitmapFileHeader>
    13b2:	83 c4 10             	add    $0x10,%esp
    for (int i = height - 1; i >= 0; i--) {
    13b5:	8b 45 10             	mov    0x10(%ebp),%eax
    13b8:	83 e8 01             	sub    $0x1,%eax
    13bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    13be:	eb 66                	jmp    1426 <write24BitmapFile+0xb9>
        write(bmpFile, img + i * width, rowBytes);
    13c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    13c3:	0f af 45 14          	imul   0x14(%ebp),%eax
    13c7:	89 c2                	mov    %eax,%edx
    13c9:	89 d0                	mov    %edx,%eax
    13cb:	01 c0                	add    %eax,%eax
    13cd:	01 c2                	add    %eax,%edx
    13cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    13d2:	01 d0                	add    %edx,%eax
    13d4:	83 ec 04             	sub    $0x4,%esp
    13d7:	ff 75 ec             	pushl  -0x14(%ebp)
    13da:	50                   	push   %eax
    13db:	ff 75 f0             	pushl  -0x10(%ebp)
    13de:	e8 ca f1 ff ff       	call   5ad <write>
    13e3:	83 c4 10             	add    $0x10,%esp
        if (rowBytes % 4 > 0) {
    13e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    13e9:	99                   	cltd   
    13ea:	c1 ea 1e             	shr    $0x1e,%edx
    13ed:	01 d0                	add    %edx,%eax
    13ef:	83 e0 03             	and    $0x3,%eax
    13f2:	29 d0                	sub    %edx,%eax
    13f4:	85 c0                	test   %eax,%eax
    13f6:	7e 2a                	jle    1422 <write24BitmapFile+0xb5>
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
    13f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
    13fb:	99                   	cltd   
    13fc:	c1 ea 1e             	shr    $0x1e,%edx
    13ff:	01 d0                	add    %edx,%eax
    1401:	83 e0 03             	and    $0x3,%eax
    1404:	29 d0                	sub    %edx,%eax
    1406:	ba 04 00 00 00       	mov    $0x4,%edx
    140b:	29 c2                	sub    %eax,%edx
    140d:	89 d0                	mov    %edx,%eax
    140f:	83 ec 04             	sub    $0x4,%esp
    1412:	50                   	push   %eax
    1413:	8d 45 e9             	lea    -0x17(%ebp),%eax
    1416:	50                   	push   %eax
    1417:	ff 75 f0             	pushl  -0x10(%ebp)
    141a:	e8 8e f1 ff ff       	call   5ad <write>
    141f:	83 c4 10             	add    $0x10,%esp
    int bmpFile = open(filename, O_CREATE | O_RDWR);
    int rowBytes = width * 3;
    char tmpBytes[3] = {0, 0, 0};

    write24BitmapFileHeader(bmpFile, height, width);
    for (int i = height - 1; i >= 0; i--) {
    1422:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
    1426:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    142a:	79 94                	jns    13c0 <write24BitmapFile+0x53>
        if (rowBytes % 4 > 0) {
            write(bmpFile, tmpBytes, 4 - (rowBytes % 4));
        }
    }

    close(bmpFile);
    142c:	83 ec 0c             	sub    $0xc,%esp
    142f:	ff 75 f0             	pushl  -0x10(%ebp)
    1432:	e8 7e f1 ff ff       	call   5b5 <close>
    1437:	83 c4 10             	add    $0x10,%esp
    return 0;
    143a:	b8 00 00 00 00       	mov    $0x0,%eax
    143f:	c9                   	leave  
    1440:	c3                   	ret    

00001441 <api_createwindow>:
#include "gui_base.h"
#include "msg.h"
#include "character.h"

int api_createwindow(Window* wnd)
{
    1441:	55                   	push   %ebp
    1442:	89 e5                	mov    %esp,%ebp
    1444:	57                   	push   %edi
    1445:	56                   	push   %esi
    1446:	53                   	push   %ebx
    1447:	83 ec 1c             	sub    $0x1c,%esp
    Size size = wnd->size;
    144a:	8b 45 08             	mov    0x8(%ebp),%eax
    144d:	8b 50 10             	mov    0x10(%eax),%edx
    1450:	8b 40 0c             	mov    0xc(%eax),%eax
    1453:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1456:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    wnd->wholeContent = malloc(size.w * (size.h + UTITLE_HEIGHT) * 3);
    1459:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    145c:	8b 55 e0             	mov    -0x20(%ebp),%edx
    145f:	83 c2 1e             	add    $0x1e,%edx
    1462:	0f af d0             	imul   %eax,%edx
    1465:	89 d0                	mov    %edx,%eax
    1467:	01 c0                	add    %eax,%eax
    1469:	01 d0                	add    %edx,%eax
    146b:	83 ec 0c             	sub    $0xc,%esp
    146e:	50                   	push   %eax
    146f:	e8 93 f5 ff ff       	call   a07 <malloc>
    1474:	83 c4 10             	add    $0x10,%esp
    1477:	89 c2                	mov    %eax,%edx
    1479:	8b 45 08             	mov    0x8(%ebp),%eax
    147c:	89 50 1c             	mov    %edx,0x1c(%eax)
    wnd->content = wnd->wholeContent + size.w * UTITLE_HEIGHT;
    147f:	8b 45 08             	mov    0x8(%ebp),%eax
    1482:	8b 40 1c             	mov    0x1c(%eax),%eax
    1485:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    1488:	6b d2 5a             	imul   $0x5a,%edx,%edx
    148b:	01 c2                	add    %eax,%edx
    148d:	8b 45 08             	mov    0x8(%ebp),%eax
    1490:	89 50 18             	mov    %edx,0x18(%eax)
    // set all content to zero
    memset(wnd->content, 255, size.w * size.h * 3);
    1493:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    1496:	8b 45 e0             	mov    -0x20(%ebp),%eax
    1499:	0f af d0             	imul   %eax,%edx
    149c:	89 d0                	mov    %edx,%eax
    149e:	01 c0                	add    %eax,%eax
    14a0:	01 d0                	add    %edx,%eax
    14a2:	89 c2                	mov    %eax,%edx
    14a4:	8b 45 08             	mov    0x8(%ebp),%eax
    14a7:	8b 40 18             	mov    0x18(%eax),%eax
    14aa:	83 ec 04             	sub    $0x4,%esp
    14ad:	52                   	push   %edx
    14ae:	68 ff 00 00 00       	push   $0xff
    14b3:	50                   	push   %eax
    14b4:	e8 39 ef ff ff       	call   3f2 <memset>
    14b9:	83 c4 10             	add    $0x10,%esp
    wnd->hwnd = createwindow(wnd->pos.x, wnd->pos.y,
    14bc:	8b 45 08             	mov    0x8(%ebp),%eax
    14bf:	8b 78 1c             	mov    0x1c(%eax),%edi
    14c2:	8b 45 08             	mov    0x8(%ebp),%eax
    14c5:	8b 70 14             	mov    0x14(%eax),%esi
    14c8:	8b 45 08             	mov    0x8(%ebp),%eax
    14cb:	8b 58 0c             	mov    0xc(%eax),%ebx
    14ce:	8b 45 08             	mov    0x8(%ebp),%eax
    14d1:	8b 48 10             	mov    0x10(%eax),%ecx
    14d4:	8b 45 08             	mov    0x8(%ebp),%eax
    14d7:	8b 50 08             	mov    0x8(%eax),%edx
    14da:	8b 45 08             	mov    0x8(%ebp),%eax
    14dd:	8b 40 04             	mov    0x4(%eax),%eax
    14e0:	83 ec 08             	sub    $0x8,%esp
    14e3:	57                   	push   %edi
    14e4:	56                   	push   %esi
    14e5:	53                   	push   %ebx
    14e6:	51                   	push   %ecx
    14e7:	52                   	push   %edx
    14e8:	50                   	push   %eax
    14e9:	e8 3f f1 ff ff       	call   62d <createwindow>
    14ee:	83 c4 20             	add    $0x20,%esp
    14f1:	89 c2                	mov    %eax,%edx
    14f3:	8b 45 08             	mov    0x8(%ebp),%eax
    14f6:	89 10                	mov    %edx,(%eax)
            wnd->size.w, wnd->size.h, wnd->title, wnd->wholeContent);
    return wnd->hwnd;
    14f8:	8b 45 08             	mov    0x8(%ebp),%eax
    14fb:	8b 00                	mov    (%eax),%eax
}
    14fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
    1500:	5b                   	pop    %ebx
    1501:	5e                   	pop    %esi
    1502:	5f                   	pop    %edi
    1503:	5d                   	pop    %ebp
    1504:	c3                   	ret    

00001505 <api_paint24Bitmap>:

int api_paint24Bitmap(Window* wnd, struct RGB* img, Point p, Size s)
{
    1505:	55                   	push   %ebp
    1506:	89 e5                	mov    %esp,%ebp
    1508:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, p, (Point){0, 0}, wnd->size, s, s);
    150b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1512:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1519:	8b 45 08             	mov    0x8(%ebp),%eax
    151c:	8b 40 18             	mov    0x18(%eax),%eax
    151f:	ff 75 1c             	pushl  0x1c(%ebp)
    1522:	ff 75 18             	pushl  0x18(%ebp)
    1525:	ff 75 1c             	pushl  0x1c(%ebp)
    1528:	ff 75 18             	pushl  0x18(%ebp)
    152b:	8b 55 08             	mov    0x8(%ebp),%edx
    152e:	ff 72 10             	pushl  0x10(%edx)
    1531:	ff 72 0c             	pushl  0xc(%edx)
    1534:	ff 75 f4             	pushl  -0xc(%ebp)
    1537:	ff 75 f0             	pushl  -0x10(%ebp)
    153a:	ff 75 14             	pushl  0x14(%ebp)
    153d:	ff 75 10             	pushl  0x10(%ebp)
    1540:	ff 75 0c             	pushl  0xc(%ebp)
    1543:	50                   	push   %eax
    1544:	e8 d5 07 00 00       	call   1d1e <drawBitmap>
    1549:	83 c4 30             	add    $0x30,%esp
    return 0;
    154c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1551:	c9                   	leave  
    1552:	c3                   	ret    

00001553 <api_paint24BitmapToContent>:

int api_paint24BitmapToContent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    1553:	55                   	push   %ebp
    1554:	89 e5                	mov    %esp,%ebp
    1556:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1559:	8b 45 08             	mov    0x8(%ebp),%eax
    155c:	8b 40 18             	mov    0x18(%eax),%eax
    155f:	ff 75 2c             	pushl  0x2c(%ebp)
    1562:	ff 75 28             	pushl  0x28(%ebp)
    1565:	ff 75 24             	pushl  0x24(%ebp)
    1568:	ff 75 20             	pushl  0x20(%ebp)
    156b:	8b 55 08             	mov    0x8(%ebp),%edx
    156e:	ff 72 10             	pushl  0x10(%edx)
    1571:	ff 72 0c             	pushl  0xc(%edx)
    1574:	ff 75 1c             	pushl  0x1c(%ebp)
    1577:	ff 75 18             	pushl  0x18(%ebp)
    157a:	ff 75 14             	pushl  0x14(%ebp)
    157d:	ff 75 10             	pushl  0x10(%ebp)
    1580:	ff 75 0c             	pushl  0xc(%ebp)
    1583:	50                   	push   %eax
    1584:	e8 95 07 00 00       	call   1d1e <drawBitmap>
    1589:	83 c4 30             	add    $0x30,%esp
    return 0;
    158c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1591:	c9                   	leave  
    1592:	c3                   	ret    

00001593 <api_paint24BitmapToContentTransparent>:

int api_paint24BitmapToContentTransparent(Window* wnd, struct RGB* img, Point pWnd, Point pBmp, Size sBmp, Size s)
{
    1593:	55                   	push   %ebp
    1594:	89 e5                	mov    %esp,%ebp
    1596:	83 ec 08             	sub    $0x8,%esp
    drawTransparentBitmap(wnd->content, img, pWnd, pBmp, wnd->size, sBmp, s);
    1599:	8b 45 08             	mov    0x8(%ebp),%eax
    159c:	8b 40 18             	mov    0x18(%eax),%eax
    159f:	ff 75 2c             	pushl  0x2c(%ebp)
    15a2:	ff 75 28             	pushl  0x28(%ebp)
    15a5:	ff 75 24             	pushl  0x24(%ebp)
    15a8:	ff 75 20             	pushl  0x20(%ebp)
    15ab:	8b 55 08             	mov    0x8(%ebp),%edx
    15ae:	ff 72 10             	pushl  0x10(%edx)
    15b1:	ff 72 0c             	pushl  0xc(%edx)
    15b4:	ff 75 1c             	pushl  0x1c(%ebp)
    15b7:	ff 75 18             	pushl  0x18(%ebp)
    15ba:	ff 75 14             	pushl  0x14(%ebp)
    15bd:	ff 75 10             	pushl  0x10(%ebp)
    15c0:	ff 75 0c             	pushl  0xc(%ebp)
    15c3:	50                   	push   %eax
    15c4:	e8 75 08 00 00       	call   1e3e <drawTransparentBitmap>
    15c9:	83 c4 30             	add    $0x30,%esp
    return 0;
    15cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
    15d1:	c9                   	leave  
    15d2:	c3                   	ret    

000015d3 <api_repaint>:

int api_repaint(Window* wnd)
{
    15d3:	55                   	push   %ebp
    15d4:	89 e5                	mov    %esp,%ebp
    15d6:	83 ec 08             	sub    $0x8,%esp
    repaintwindow(wnd->hwnd);
    15d9:	8b 45 08             	mov    0x8(%ebp),%eax
    15dc:	8b 00                	mov    (%eax),%eax
    15de:	83 ec 0c             	sub    $0xc,%esp
    15e1:	50                   	push   %eax
    15e2:	e8 4e f0 ff ff       	call   635 <repaintwindow>
    15e7:	83 c4 10             	add    $0x10,%esp
    return 0;
    15ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
    15ef:	c9                   	leave  
    15f0:	c3                   	ret    

000015f1 <api_update>:

int api_update(Window* wnd, Rect rect)
{
    15f1:	55                   	push   %ebp
    15f2:	89 e5                	mov    %esp,%ebp
    15f4:	56                   	push   %esi
    15f5:	53                   	push   %ebx
    updatewindow(wnd->hwnd, rect.x, rect.y, rect.h, rect.w);
    15f6:	8b 75 18             	mov    0x18(%ebp),%esi
    15f9:	8b 5d 14             	mov    0x14(%ebp),%ebx
    15fc:	8b 4d 10             	mov    0x10(%ebp),%ecx
    15ff:	8b 55 0c             	mov    0xc(%ebp),%edx
    1602:	8b 45 08             	mov    0x8(%ebp),%eax
    1605:	8b 00                	mov    (%eax),%eax
    1607:	83 ec 0c             	sub    $0xc,%esp
    160a:	56                   	push   %esi
    160b:	53                   	push   %ebx
    160c:	51                   	push   %ecx
    160d:	52                   	push   %edx
    160e:	50                   	push   %eax
    160f:	e8 39 f0 ff ff       	call   64d <updatewindow>
    1614:	83 c4 20             	add    $0x20,%esp
    return 0;
    1617:	b8 00 00 00 00       	mov    $0x0,%eax
}
    161c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    161f:	5b                   	pop    %ebx
    1620:	5e                   	pop    %esi
    1621:	5d                   	pop    %ebp
    1622:	c3                   	ret    

00001623 <api_exec>:

int api_exec(Window* wnd, ProcFun pf)
{
    1623:	55                   	push   %ebp
    1624:	89 e5                	mov    %esp,%ebp
    1626:	83 ec 38             	sub    $0x38,%esp
    message msg;
    int r = 0;
    1629:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while(1)
    {
        r = getmessage(wnd->hwnd, &msg);
    1630:	8b 45 08             	mov    0x8(%ebp),%eax
    1633:	8b 00                	mov    (%eax),%eax
    1635:	83 ec 08             	sub    $0x8,%esp
    1638:	8d 55 c8             	lea    -0x38(%ebp),%edx
    163b:	52                   	push   %edx
    163c:	50                   	push   %eax
    163d:	e8 fb ef ff ff       	call   63d <getmessage>
    1642:	83 c4 10             	add    $0x10,%esp
    1645:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(r)
    1648:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    164c:	74 e2                	je     1630 <api_exec+0xd>
        {
            pf(&msg);
    164e:	83 ec 0c             	sub    $0xc,%esp
    1651:	8d 45 c8             	lea    -0x38(%ebp),%eax
    1654:	50                   	push   %eax
    1655:	8b 45 0c             	mov    0xc(%ebp),%eax
    1658:	ff d0                	call   *%eax
    165a:	83 c4 10             	add    $0x10,%esp
        }
    }
    165d:	eb d1                	jmp    1630 <api_exec+0xd>

0000165f <api_settimer>:
    return -1;
}

int api_settimer(Window* wnd, int interval)
{
    165f:	55                   	push   %ebp
    1660:	89 e5                	mov    %esp,%ebp
    1662:	83 ec 08             	sub    $0x8,%esp
    settimer(wnd->hwnd, interval);
    1665:	8b 45 08             	mov    0x8(%ebp),%eax
    1668:	8b 00                	mov    (%eax),%eax
    166a:	83 ec 08             	sub    $0x8,%esp
    166d:	ff 75 0c             	pushl  0xc(%ebp)
    1670:	50                   	push   %eax
    1671:	e8 cf ef ff ff       	call   645 <settimer>
    1676:	83 c4 10             	add    $0x10,%esp
    return 0;
    1679:	b8 00 00 00 00       	mov    $0x0,%eax
}
    167e:	c9                   	leave  
    167f:	c3                   	ret    

00001680 <api_drawRect>:

int api_drawRect(Window *wnd, Point p, Size s, RGB color)
{
    1680:	55                   	push   %ebp
    1681:	89 e5                	mov    %esp,%ebp
    1683:	83 ec 08             	sub    $0x8,%esp
    drawRect(wnd->content, p, wnd->size, color, s);
    1686:	8b 45 08             	mov    0x8(%ebp),%eax
    1689:	8b 50 18             	mov    0x18(%eax),%edx
    168c:	ff 75 18             	pushl  0x18(%ebp)
    168f:	ff 75 14             	pushl  0x14(%ebp)
    1692:	83 ec 04             	sub    $0x4,%esp
    1695:	89 e0                	mov    %esp,%eax
    1697:	0f b7 4d 1c          	movzwl 0x1c(%ebp),%ecx
    169b:	66 89 08             	mov    %cx,(%eax)
    169e:	0f b6 4d 1e          	movzbl 0x1e(%ebp),%ecx
    16a2:	88 48 02             	mov    %cl,0x2(%eax)
    16a5:	8b 45 08             	mov    0x8(%ebp),%eax
    16a8:	ff 70 10             	pushl  0x10(%eax)
    16ab:	ff 70 0c             	pushl  0xc(%eax)
    16ae:	ff 75 10             	pushl  0x10(%ebp)
    16b1:	ff 75 0c             	pushl  0xc(%ebp)
    16b4:	52                   	push   %edx
    16b5:	e8 6f 04 00 00       	call   1b29 <drawRect>
    16ba:	83 c4 20             	add    $0x20,%esp
    return 0;
    16bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    16c2:	c9                   	leave  
    16c3:	c3                   	ret    

000016c4 <api_drawCharacter>:

int api_drawCharacter(Window *wnd, int x, int y, char ch, RGBA color) {
    16c4:	55                   	push   %ebp
    16c5:	89 e5                	mov    %esp,%ebp
    16c7:	83 ec 28             	sub    $0x28,%esp
    16ca:	8b 45 14             	mov    0x14(%ebp),%eax
    16cd:	88 45 e4             	mov    %al,-0x1c(%ebp)
    drawCharacter(wnd->content, (Point){x, y}, wnd->size, ch, color);
    16d0:	0f be 55 e4          	movsbl -0x1c(%ebp),%edx
    16d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    16d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
    16da:	8b 45 10             	mov    0x10(%ebp),%eax
    16dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    16e0:	8b 45 08             	mov    0x8(%ebp),%eax
    16e3:	8b 40 18             	mov    0x18(%eax),%eax
    16e6:	83 ec 04             	sub    $0x4,%esp
    16e9:	ff 75 18             	pushl  0x18(%ebp)
    16ec:	52                   	push   %edx
    16ed:	8b 55 08             	mov    0x8(%ebp),%edx
    16f0:	ff 72 10             	pushl  0x10(%edx)
    16f3:	ff 72 0c             	pushl  0xc(%edx)
    16f6:	ff 75 f4             	pushl  -0xc(%ebp)
    16f9:	ff 75 f0             	pushl  -0x10(%ebp)
    16fc:	50                   	push   %eax
    16fd:	e8 d4 02 00 00       	call   19d6 <drawCharacter>
    1702:	83 c4 20             	add    $0x20,%esp
    return 0;
    1705:	b8 00 00 00 00       	mov    $0x0,%eax
}
    170a:	c9                   	leave  
    170b:	c3                   	ret    

0000170c <api_drawString>:


int api_drawString(Window *wnd, int x, int y, char *str, RGBA color) {
    170c:	55                   	push   %ebp
    170d:	89 e5                	mov    %esp,%ebp
    170f:	83 ec 18             	sub    $0x18,%esp
    drawString(wnd->content, (Point){x, y}, wnd->size, str, color);
    1712:	8b 45 0c             	mov    0xc(%ebp),%eax
    1715:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1718:	8b 45 10             	mov    0x10(%ebp),%eax
    171b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    171e:	8b 45 08             	mov    0x8(%ebp),%eax
    1721:	8b 40 18             	mov    0x18(%eax),%eax
    1724:	83 ec 04             	sub    $0x4,%esp
    1727:	ff 75 18             	pushl  0x18(%ebp)
    172a:	ff 75 14             	pushl  0x14(%ebp)
    172d:	8b 55 08             	mov    0x8(%ebp),%edx
    1730:	ff 72 10             	pushl  0x10(%edx)
    1733:	ff 72 0c             	pushl  0xc(%edx)
    1736:	ff 75 f4             	pushl  -0xc(%ebp)
    1739:	ff 75 f0             	pushl  -0x10(%ebp)
    173c:	50                   	push   %eax
    173d:	e8 8e 03 00 00       	call   1ad0 <drawString>
    1742:	83 c4 20             	add    $0x20,%esp
    return 0;
    1745:	b8 00 00 00 00       	mov    $0x0,%eax
}
    174a:	c9                   	leave  
    174b:	c3                   	ret    

0000174c <api_drawButton>:

int api_drawButton(Window *wnd, Point p, Size s, char * str)
{
    174c:	55                   	push   %ebp
    174d:	89 e5                	mov    %esp,%ebp
    174f:	83 ec 18             	sub    $0x18,%esp
    RGB bColor;
    bColor.R = 9;
    1752:	c6 45 f3 09          	movb   $0x9,-0xd(%ebp)
    bColor.G = 163;
    1756:	c6 45 f2 a3          	movb   $0xa3,-0xe(%ebp)
    bColor.B = 220;
    175a:	c6 45 f1 dc          	movb   $0xdc,-0xf(%ebp)
    api_drawRect(wnd, p, s, bColor);
    175e:	83 ec 08             	sub    $0x8,%esp
    1761:	83 ec 04             	sub    $0x4,%esp
    1764:	89 e0                	mov    %esp,%eax
    1766:	0f b7 55 f1          	movzwl -0xf(%ebp),%edx
    176a:	66 89 10             	mov    %dx,(%eax)
    176d:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
    1771:	88 50 02             	mov    %dl,0x2(%eax)
    1774:	ff 75 18             	pushl  0x18(%ebp)
    1777:	ff 75 14             	pushl  0x14(%ebp)
    177a:	ff 75 10             	pushl  0x10(%ebp)
    177d:	ff 75 0c             	pushl  0xc(%ebp)
    1780:	ff 75 08             	pushl  0x8(%ebp)
    1783:	e8 f8 fe ff ff       	call   1680 <api_drawRect>
    1788:	83 c4 20             	add    $0x20,%esp
    api_drawString(wnd, p.x + 10, p.y + 10, str, (RGBA){255,255,255,255});
    178b:	c6 45 f4 ff          	movb   $0xff,-0xc(%ebp)
    178f:	c6 45 f5 ff          	movb   $0xff,-0xb(%ebp)
    1793:	c6 45 f6 ff          	movb   $0xff,-0xa(%ebp)
    1797:	c6 45 f7 ff          	movb   $0xff,-0x9(%ebp)
    179b:	8b 45 10             	mov    0x10(%ebp),%eax
    179e:	8d 50 0a             	lea    0xa(%eax),%edx
    17a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    17a4:	83 c0 0a             	add    $0xa,%eax
    17a7:	83 ec 0c             	sub    $0xc,%esp
    17aa:	ff 75 f4             	pushl  -0xc(%ebp)
    17ad:	ff 75 1c             	pushl  0x1c(%ebp)
    17b0:	52                   	push   %edx
    17b1:	50                   	push   %eax
    17b2:	ff 75 08             	pushl  0x8(%ebp)
    17b5:	e8 52 ff ff ff       	call   170c <api_drawString>
    17ba:	83 c4 20             	add    $0x20,%esp
    return 0;
    17bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    17c2:	c9                   	leave  
    17c3:	c3                   	ret    

000017c4 <api_drawImgButton>:


int api_drawImgButton(Window* wnd, struct RGB* img, Point pWnd, Size s, int borderWidth, RGB borderColor, int shift) {
    17c4:	55                   	push   %ebp
    17c5:	89 e5                	mov    %esp,%ebp
    17c7:	83 ec 18             	sub    $0x18,%esp
    drawBitmap(wnd->content, img, pWnd, (Point){0, 0}, wnd->size, s, s);
    17ca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    17d1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    17d8:	8b 45 08             	mov    0x8(%ebp),%eax
    17db:	8b 40 18             	mov    0x18(%eax),%eax
    17de:	ff 75 1c             	pushl  0x1c(%ebp)
    17e1:	ff 75 18             	pushl  0x18(%ebp)
    17e4:	ff 75 1c             	pushl  0x1c(%ebp)
    17e7:	ff 75 18             	pushl  0x18(%ebp)
    17ea:	8b 55 08             	mov    0x8(%ebp),%edx
    17ed:	ff 72 10             	pushl  0x10(%edx)
    17f0:	ff 72 0c             	pushl  0xc(%edx)
    17f3:	ff 75 f4             	pushl  -0xc(%ebp)
    17f6:	ff 75 f0             	pushl  -0x10(%ebp)
    17f9:	ff 75 14             	pushl  0x14(%ebp)
    17fc:	ff 75 10             	pushl  0x10(%ebp)
    17ff:	ff 75 0c             	pushl  0xc(%ebp)
    1802:	50                   	push   %eax
    1803:	e8 16 05 00 00       	call   1d1e <drawBitmap>
    1808:	83 c4 30             	add    $0x30,%esp
    colorShift(wnd->content, pWnd, wnd->size, s, shift);
    180b:	8b 45 08             	mov    0x8(%ebp),%eax
    180e:	8b 40 18             	mov    0x18(%eax),%eax
    1811:	ff 75 28             	pushl  0x28(%ebp)
    1814:	ff 75 1c             	pushl  0x1c(%ebp)
    1817:	ff 75 18             	pushl  0x18(%ebp)
    181a:	8b 55 08             	mov    0x8(%ebp),%edx
    181d:	ff 72 10             	pushl  0x10(%edx)
    1820:	ff 72 0c             	pushl  0xc(%edx)
    1823:	ff 75 14             	pushl  0x14(%ebp)
    1826:	ff 75 10             	pushl  0x10(%ebp)
    1829:	50                   	push   %eax
    182a:	e8 99 07 00 00       	call   1fc8 <colorShift>
    182f:	83 c4 20             	add    $0x20,%esp
    drawBorder(wnd->content, pWnd, wnd->size, borderColor, s, borderWidth);
    1832:	8b 45 08             	mov    0x8(%ebp),%eax
    1835:	8b 50 18             	mov    0x18(%eax),%edx
    1838:	83 ec 0c             	sub    $0xc,%esp
    183b:	ff 75 20             	pushl  0x20(%ebp)
    183e:	ff 75 1c             	pushl  0x1c(%ebp)
    1841:	ff 75 18             	pushl  0x18(%ebp)
    1844:	83 ec 04             	sub    $0x4,%esp
    1847:	89 e0                	mov    %esp,%eax
    1849:	0f b7 4d 24          	movzwl 0x24(%ebp),%ecx
    184d:	66 89 08             	mov    %cx,(%eax)
    1850:	0f b6 4d 26          	movzbl 0x26(%ebp),%ecx
    1854:	88 48 02             	mov    %cl,0x2(%eax)
    1857:	8b 45 08             	mov    0x8(%ebp),%eax
    185a:	ff 70 10             	pushl  0x10(%eax)
    185d:	ff 70 0c             	pushl  0xc(%eax)
    1860:	ff 75 14             	pushl  0x14(%ebp)
    1863:	ff 75 10             	pushl  0x10(%ebp)
    1866:	52                   	push   %edx
    1867:	e8 6d 03 00 00       	call   1bd9 <drawBorder>
    186c:	83 c4 30             	add    $0x30,%esp
    return 0;
    186f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1874:	c9                   	leave  
    1875:	c3                   	ret    

00001876 <api_destroywindow>:


int api_destroywindow(Window *wnd) {
    1876:	55                   	push   %ebp
    1877:	89 e5                	mov    %esp,%ebp
    1879:	83 ec 08             	sub    $0x8,%esp
    destroywindow(wnd->hwnd);
    187c:	8b 45 08             	mov    0x8(%ebp),%eax
    187f:	8b 00                	mov    (%eax),%eax
    1881:	83 ec 0c             	sub    $0xc,%esp
    1884:	50                   	push   %eax
    1885:	e8 cb ed ff ff       	call   655 <destroywindow>
    188a:	83 c4 10             	add    $0x10,%esp
    return 0;
    188d:	b8 00 00 00 00       	mov    $0x0,%eax
    1892:	c9                   	leave  
    1893:	c3                   	ret    

00001894 <drawPoint>:
#include "gui_base.h"
#include "mouse_shape.h"
#include "character.h"


void drawPoint(RGB* color, RGB origin) {
    1894:	55                   	push   %ebp
    1895:	89 e5                	mov    %esp,%ebp
    color->R = origin.R;
    1897:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    189b:	8b 45 08             	mov    0x8(%ebp),%eax
    189e:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = origin.G;
    18a1:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    18a5:	8b 45 08             	mov    0x8(%ebp),%eax
    18a8:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = origin.B;
    18ab:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
    18af:	8b 45 08             	mov    0x8(%ebp),%eax
    18b2:	88 10                	mov    %dl,(%eax)
}
    18b4:	90                   	nop
    18b5:	5d                   	pop    %ebp
    18b6:	c3                   	ret    

000018b7 <drawPointAlpha>:

void drawPointAlpha(RGB* color, RGBA origin) {
    18b7:	55                   	push   %ebp
    18b8:	89 e5                	mov    %esp,%ebp
    18ba:	83 ec 1c             	sub    $0x1c,%esp
    float alpha;
    if (origin.A == 255) {
    18bd:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    18c1:	3c ff                	cmp    $0xff,%al
    18c3:	75 22                	jne    18e7 <drawPointAlpha+0x30>
        color->R = origin.R;
    18c5:	0f b6 55 0f          	movzbl 0xf(%ebp),%edx
    18c9:	8b 45 08             	mov    0x8(%ebp),%eax
    18cc:	88 50 02             	mov    %dl,0x2(%eax)
        color->G = origin.G;
    18cf:	0f b6 55 0e          	movzbl 0xe(%ebp),%edx
    18d3:	8b 45 08             	mov    0x8(%ebp),%eax
    18d6:	88 50 01             	mov    %dl,0x1(%eax)
        color->B = origin.B;
    18d9:	0f b6 55 0d          	movzbl 0xd(%ebp),%edx
    18dd:	8b 45 08             	mov    0x8(%ebp),%eax
    18e0:	88 10                	mov    %dl,(%eax)
        return;
    18e2:	e9 ed 00 00 00       	jmp    19d4 <drawPointAlpha+0x11d>
    }
    if (origin.A == 0) {
    18e7:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    18eb:	84 c0                	test   %al,%al
    18ed:	0f 84 e0 00 00 00    	je     19d3 <drawPointAlpha+0x11c>
        return;
    }
    alpha = (float)origin.A / 255;
    18f3:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
    18f7:	0f b6 c0             	movzbl %al,%eax
    18fa:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    18fe:	df 45 e4             	fild   -0x1c(%ebp)
    1901:	d9 05 60 9f 01 00    	flds   0x19f60
    1907:	de f9                	fdivrp %st,%st(1)
    1909:	d9 5d fc             	fstps  -0x4(%ebp)
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    190c:	8b 45 08             	mov    0x8(%ebp),%eax
    190f:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1913:	0f b6 c0             	movzbl %al,%eax
    1916:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1919:	db 45 e4             	fildl  -0x1c(%ebp)
    191c:	d9 e8                	fld1   
    191e:	d8 65 fc             	fsubs  -0x4(%ebp)
    1921:	de c9                	fmulp  %st,%st(1)
    1923:	0f b6 45 0f          	movzbl 0xf(%ebp),%eax
    1927:	0f b6 c0             	movzbl %al,%eax
    192a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    192d:	db 45 e4             	fildl  -0x1c(%ebp)
    1930:	d8 4d fc             	fmuls  -0x4(%ebp)
    1933:	de c1                	faddp  %st,%st(1)
    1935:	d9 7d ee             	fnstcw -0x12(%ebp)
    1938:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    193c:	b4 0c                	mov    $0xc,%ah
    193e:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    1942:	d9 6d ec             	fldcw  -0x14(%ebp)
    1945:	df 5d ea             	fistp  -0x16(%ebp)
    1948:	d9 6d ee             	fldcw  -0x12(%ebp)
    194b:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    194f:	89 c2                	mov    %eax,%edx
    1951:	8b 45 08             	mov    0x8(%ebp),%eax
    1954:	88 50 02             	mov    %dl,0x2(%eax)
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    1957:	8b 45 08             	mov    0x8(%ebp),%eax
    195a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    195e:	0f b6 c0             	movzbl %al,%eax
    1961:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1964:	db 45 e4             	fildl  -0x1c(%ebp)
    1967:	d9 e8                	fld1   
    1969:	d8 65 fc             	fsubs  -0x4(%ebp)
    196c:	de c9                	fmulp  %st,%st(1)
    196e:	0f b6 45 0e          	movzbl 0xe(%ebp),%eax
    1972:	0f b6 c0             	movzbl %al,%eax
    1975:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1978:	db 45 e4             	fildl  -0x1c(%ebp)
    197b:	d8 4d fc             	fmuls  -0x4(%ebp)
    197e:	de c1                	faddp  %st,%st(1)
    1980:	d9 6d ec             	fldcw  -0x14(%ebp)
    1983:	df 5d ea             	fistp  -0x16(%ebp)
    1986:	d9 6d ee             	fldcw  -0x12(%ebp)
    1989:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    198d:	89 c2                	mov    %eax,%edx
    198f:	8b 45 08             	mov    0x8(%ebp),%eax
    1992:	88 50 01             	mov    %dl,0x1(%eax)
    color->B = color->B * (1 - alpha) + origin.B * alpha;
    1995:	8b 45 08             	mov    0x8(%ebp),%eax
    1998:	0f b6 00             	movzbl (%eax),%eax
    199b:	0f b6 c0             	movzbl %al,%eax
    199e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    19a1:	db 45 e4             	fildl  -0x1c(%ebp)
    19a4:	d9 e8                	fld1   
    19a6:	d8 65 fc             	fsubs  -0x4(%ebp)
    19a9:	de c9                	fmulp  %st,%st(1)
    19ab:	0f b6 45 0d          	movzbl 0xd(%ebp),%eax
    19af:	0f b6 c0             	movzbl %al,%eax
    19b2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    19b5:	db 45 e4             	fildl  -0x1c(%ebp)
    19b8:	d8 4d fc             	fmuls  -0x4(%ebp)
    19bb:	de c1                	faddp  %st,%st(1)
    19bd:	d9 6d ec             	fldcw  -0x14(%ebp)
    19c0:	df 5d ea             	fistp  -0x16(%ebp)
    19c3:	d9 6d ee             	fldcw  -0x12(%ebp)
    19c6:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
    19ca:	89 c2                	mov    %eax,%edx
    19cc:	8b 45 08             	mov    0x8(%ebp),%eax
    19cf:	88 10                	mov    %dl,(%eax)
    19d1:	eb 01                	jmp    19d4 <drawPointAlpha+0x11d>
        color->G = origin.G;
        color->B = origin.B;
        return;
    }
    if (origin.A == 0) {
        return;
    19d3:	90                   	nop
    }
    alpha = (float)origin.A / 255;
    color->R = color->R * (1 - alpha) + origin.R * alpha;
    color->G = color->G * (1 - alpha) + origin.G * alpha;
    color->B = color->B * (1 - alpha) + origin.B * alpha;
}
    19d4:	c9                   	leave  
    19d5:	c3                   	ret    

000019d6 <drawCharacter>:

void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    19d6:	55                   	push   %ebp
    19d7:	89 e5                	mov    %esp,%ebp
    19d9:	83 ec 14             	sub    $0x14,%esp
    19dc:	8b 45 1c             	mov    0x1c(%ebp),%eax
    19df:	88 45 ec             	mov    %al,-0x14(%ebp)
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    19e2:	0f be 45 ec          	movsbl -0x14(%ebp),%eax
    19e6:	83 e8 20             	sub    $0x20,%eax
    19e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
    19ec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    19f0:	0f 88 d7 00 00 00    	js     1acd <drawCharacter+0xf7>
    19f6:	83 7d f4 5e          	cmpl   $0x5e,-0xc(%ebp)
    19fa:	0f 8f cd 00 00 00    	jg     1acd <drawCharacter+0xf7>
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1a00:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    1a07:	e9 b5 00 00 00       	jmp    1ac1 <drawCharacter+0xeb>
        if (p.y + i > s.h || p.y + i < 0) {
    1a0c:	8b 55 10             	mov    0x10(%ebp),%edx
    1a0f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1a12:	01 c2                	add    %eax,%edx
    1a14:	8b 45 14             	mov    0x14(%ebp),%eax
    1a17:	39 c2                	cmp    %eax,%edx
    1a19:	0f 8f af 00 00 00    	jg     1ace <drawCharacter+0xf8>
    1a1f:	8b 55 10             	mov    0x10(%ebp),%edx
    1a22:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1a25:	01 d0                	add    %edx,%eax
    1a27:	85 c0                	test   %eax,%eax
    1a29:	0f 88 9f 00 00 00    	js     1ace <drawCharacter+0xf8>
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1a2f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    1a36:	eb 7b                	jmp    1ab3 <drawCharacter+0xdd>
            if (character[ord][i][j] == 1) {
    1a38:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1a3b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    1a3e:	89 d0                	mov    %edx,%eax
    1a40:	c1 e0 03             	shl    $0x3,%eax
    1a43:	01 d0                	add    %edx,%eax
    1a45:	69 d1 a2 00 00 00    	imul   $0xa2,%ecx,%edx
    1a4b:	01 c2                	add    %eax,%edx
    1a4d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1a50:	01 d0                	add    %edx,%eax
    1a52:	05 40 63 01 00       	add    $0x16340,%eax
    1a57:	0f b6 00             	movzbl (%eax),%eax
    1a5a:	3c 01                	cmp    $0x1,%al
    1a5c:	75 51                	jne    1aaf <drawCharacter+0xd9>
                if (p.x + j > s.w || p.x + j < 0) {
    1a5e:	8b 55 0c             	mov    0xc(%ebp),%edx
    1a61:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1a64:	01 c2                	add    %eax,%edx
    1a66:	8b 45 18             	mov    0x18(%ebp),%eax
    1a69:	39 c2                	cmp    %eax,%edx
    1a6b:	7f 50                	jg     1abd <drawCharacter+0xe7>
    1a6d:	8b 55 0c             	mov    0xc(%ebp),%edx
    1a70:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1a73:	01 d0                	add    %edx,%eax
    1a75:	85 c0                	test   %eax,%eax
    1a77:	78 44                	js     1abd <drawCharacter+0xe7>
                    break;
                }
                t = buf + (p.y + i) * s.w + p.x + j;
    1a79:	8b 55 10             	mov    0x10(%ebp),%edx
    1a7c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    1a7f:	01 c2                	add    %eax,%edx
    1a81:	8b 45 18             	mov    0x18(%ebp),%eax
    1a84:	0f af c2             	imul   %edx,%eax
    1a87:	89 c2                	mov    %eax,%edx
    1a89:	8b 45 0c             	mov    0xc(%ebp),%eax
    1a8c:	01 c2                	add    %eax,%edx
    1a8e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    1a91:	01 c2                	add    %eax,%edx
    1a93:	89 d0                	mov    %edx,%eax
    1a95:	01 c0                	add    %eax,%eax
    1a97:	01 c2                	add    %eax,%edx
    1a99:	8b 45 08             	mov    0x8(%ebp),%eax
    1a9c:	01 d0                	add    %edx,%eax
    1a9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPointAlpha(t, color);
    1aa1:	ff 75 20             	pushl  0x20(%ebp)
    1aa4:	ff 75 f0             	pushl  -0x10(%ebp)
    1aa7:	e8 0b fe ff ff       	call   18b7 <drawPointAlpha>
    1aac:	83 c4 08             	add    $0x8,%esp

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
        if (p.y + i > s.h || p.y + i < 0) {
            break;
        }
        for (j = 0; j < CHARACTER_WIDTH; j++) {
    1aaf:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    1ab3:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
    1ab7:	0f 8e 7b ff ff ff    	jle    1a38 <drawCharacter+0x62>
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    }

    for (i = 0; i < CHARACTER_HEIGHT; i++) {
    1abd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    1ac1:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    1ac5:	0f 8e 41 ff ff ff    	jle    1a0c <drawCharacter+0x36>
    1acb:	eb 01                	jmp    1ace <drawCharacter+0xf8>
void drawCharacter(RGB *buf, Point p, Size s, char ch, RGBA color) {
    int i, j;
    RGB *t;
    int ord = ch - 0x20; // omit control ASCII code.
    if (ord < 0 || ord >= (CHARACTER_NUMBER - 1)) {
        return;
    1acd:	90                   	nop
                t = buf + (p.y + i) * s.w + p.x + j;
                drawPointAlpha(t, color);
            }
        }
    }
}
    1ace:	c9                   	leave  
    1acf:	c3                   	ret    

00001ad0 <drawString>:

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    1ad0:	55                   	push   %ebp
    1ad1:	89 e5                	mov    %esp,%ebp
    1ad3:	83 ec 10             	sub    $0x10,%esp
    int offset_x = 0;
    1ad6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    while (*str != '\0') {
    1add:	eb 3d                	jmp    1b1c <drawString+0x4c>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
    1adf:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1ae2:	0f b6 00             	movzbl (%eax),%eax
    1ae5:	0f be c0             	movsbl %al,%eax
    1ae8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    1aeb:	8b 55 fc             	mov    -0x4(%ebp),%edx
    1aee:	01 ca                	add    %ecx,%edx
    1af0:	89 55 f4             	mov    %edx,-0xc(%ebp)
    1af3:	8b 55 10             	mov    0x10(%ebp),%edx
    1af6:	89 55 f8             	mov    %edx,-0x8(%ebp)
    1af9:	ff 75 20             	pushl  0x20(%ebp)
    1afc:	50                   	push   %eax
    1afd:	ff 75 18             	pushl  0x18(%ebp)
    1b00:	ff 75 14             	pushl  0x14(%ebp)
    1b03:	ff 75 f8             	pushl  -0x8(%ebp)
    1b06:	ff 75 f4             	pushl  -0xc(%ebp)
    1b09:	ff 75 08             	pushl  0x8(%ebp)
    1b0c:	e8 c5 fe ff ff       	call   19d6 <drawCharacter>
    1b11:	83 c4 1c             	add    $0x1c,%esp
        offset_x += CHARACTER_WIDTH;
    1b14:	83 45 fc 09          	addl   $0x9,-0x4(%ebp)
        str++;
    1b18:	83 45 1c 01          	addl   $0x1,0x1c(%ebp)
}

void drawString(RGB *buf, Point p, Size s, char *str, RGBA color) {
    int offset_x = 0;

    while (*str != '\0') {
    1b1c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1b1f:	0f b6 00             	movzbl (%eax),%eax
    1b22:	84 c0                	test   %al,%al
    1b24:	75 b9                	jne    1adf <drawString+0xf>
        drawCharacter(buf, (Point){p.x+offset_x, p.y}, s, *str, color);
        offset_x += CHARACTER_WIDTH;
        str++;
    }
}
    1b26:	90                   	nop
    1b27:	c9                   	leave  
    1b28:	c3                   	ret    

00001b29 <drawRect>:

void drawRect(RGB *buf, Point p, Size s, RGB color, Size rect_size) {
    1b29:	55                   	push   %ebp
    1b2a:	89 e5                	mov    %esp,%ebp
    1b2c:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1b2f:	8b 45 20             	mov    0x20(%ebp),%eax
    1b32:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1b35:	8b 45 24             	mov    0x24(%ebp),%eax
    1b38:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1b3b:	8b 55 14             	mov    0x14(%ebp),%edx
    1b3e:	8b 45 10             	mov    0x10(%ebp),%eax
    1b41:	29 c2                	sub    %eax,%edx
    1b43:	89 d0                	mov    %edx,%eax
    1b45:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1b48:	7d 0d                	jge    1b57 <drawRect+0x2e>
        draw_h = s.h - p.y;
    1b4a:	8b 55 14             	mov    0x14(%ebp),%edx
    1b4d:	8b 45 10             	mov    0x10(%ebp),%eax
    1b50:	29 c2                	sub    %eax,%edx
    1b52:	89 d0                	mov    %edx,%eax
    1b54:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1b57:	8b 55 18             	mov    0x18(%ebp),%edx
    1b5a:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b5d:	29 c2                	sub    %eax,%edx
    1b5f:	89 d0                	mov    %edx,%eax
    1b61:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1b64:	7d 0d                	jge    1b73 <drawRect+0x4a>
        draw_w = s.w - p.x;
    1b66:	8b 55 18             	mov    0x18(%ebp),%edx
    1b69:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b6c:	29 c2                	sub    %eax,%edx
    1b6e:	89 d0                	mov    %edx,%eax
    1b70:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1b73:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1b7a:	eb 52                	jmp    1bce <drawRect+0xa5>
        for(int j = 0; j < draw_w; j++) {
    1b7c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1b83:	eb 3d                	jmp    1bc2 <drawRect+0x99>
            t = buf + (p.y + i) * s.w + p.x + j;
    1b85:	8b 55 10             	mov    0x10(%ebp),%edx
    1b88:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1b8b:	01 c2                	add    %eax,%edx
    1b8d:	8b 45 18             	mov    0x18(%ebp),%eax
    1b90:	0f af c2             	imul   %edx,%eax
    1b93:	89 c2                	mov    %eax,%edx
    1b95:	8b 45 0c             	mov    0xc(%ebp),%eax
    1b98:	01 c2                	add    %eax,%edx
    1b9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1b9d:	01 c2                	add    %eax,%edx
    1b9f:	89 d0                	mov    %edx,%eax
    1ba1:	01 c0                	add    %eax,%eax
    1ba3:	01 c2                	add    %eax,%edx
    1ba5:	8b 45 08             	mov    0x8(%ebp),%eax
    1ba8:	01 d0                	add    %edx,%eax
    1baa:	89 45 ec             	mov    %eax,-0x14(%ebp)
            *t = color;
    1bad:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1bb0:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1bb4:	66 89 10             	mov    %dx,(%eax)
    1bb7:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1bbb:	88 50 02             	mov    %dl,0x2(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    1bbe:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1bc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1bc5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1bc8:	7c bb                	jl     1b85 <drawRect+0x5c>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1bca:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1bce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1bd1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1bd4:	7c a6                	jl     1b7c <drawRect+0x53>
        for(int j = 0; j < draw_w; j++) {
            t = buf + (p.y + i) * s.w + p.x + j;
            *t = color;
        }
    }
}
    1bd6:	90                   	nop
    1bd7:	c9                   	leave  
    1bd8:	c3                   	ret    

00001bd9 <drawBorder>:

void drawBorder(RGB* buf, Point p, Size s, RGB color, Size rect_size, int border) {
    1bd9:	55                   	push   %ebp
    1bda:	89 e5                	mov    %esp,%ebp
    1bdc:	83 ec 40             	sub    $0x40,%esp
    drawRect(buf, p, s, color, (Size){border, rect_size.w});
    1bdf:	8b 45 28             	mov    0x28(%ebp),%eax
    1be2:	89 45 c8             	mov    %eax,-0x38(%ebp)
    1be5:	8b 45 24             	mov    0x24(%ebp),%eax
    1be8:	89 45 cc             	mov    %eax,-0x34(%ebp)
    1beb:	ff 75 cc             	pushl  -0x34(%ebp)
    1bee:	ff 75 c8             	pushl  -0x38(%ebp)
    1bf1:	83 ec 04             	sub    $0x4,%esp
    1bf4:	89 e0                	mov    %esp,%eax
    1bf6:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1bfa:	66 89 10             	mov    %dx,(%eax)
    1bfd:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1c01:	88 50 02             	mov    %dl,0x2(%eax)
    1c04:	ff 75 18             	pushl  0x18(%ebp)
    1c07:	ff 75 14             	pushl  0x14(%ebp)
    1c0a:	ff 75 10             	pushl  0x10(%ebp)
    1c0d:	ff 75 0c             	pushl  0xc(%ebp)
    1c10:	ff 75 08             	pushl  0x8(%ebp)
    1c13:	e8 11 ff ff ff       	call   1b29 <drawRect>
    1c18:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x, p.y + rect_size.h - border}, s, color, (Size){border, rect_size.w});
    1c1b:	8b 45 28             	mov    0x28(%ebp),%eax
    1c1e:	89 45 d0             	mov    %eax,-0x30(%ebp)
    1c21:	8b 45 24             	mov    0x24(%ebp),%eax
    1c24:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    1c27:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c2a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    1c2d:	8b 55 10             	mov    0x10(%ebp),%edx
    1c30:	8b 45 20             	mov    0x20(%ebp),%eax
    1c33:	01 d0                	add    %edx,%eax
    1c35:	2b 45 28             	sub    0x28(%ebp),%eax
    1c38:	89 45 dc             	mov    %eax,-0x24(%ebp)
    1c3b:	ff 75 d4             	pushl  -0x2c(%ebp)
    1c3e:	ff 75 d0             	pushl  -0x30(%ebp)
    1c41:	83 ec 04             	sub    $0x4,%esp
    1c44:	89 e0                	mov    %esp,%eax
    1c46:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1c4a:	66 89 10             	mov    %dx,(%eax)
    1c4d:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1c51:	88 50 02             	mov    %dl,0x2(%eax)
    1c54:	ff 75 18             	pushl  0x18(%ebp)
    1c57:	ff 75 14             	pushl  0x14(%ebp)
    1c5a:	ff 75 dc             	pushl  -0x24(%ebp)
    1c5d:	ff 75 d8             	pushl  -0x28(%ebp)
    1c60:	ff 75 08             	pushl  0x8(%ebp)
    1c63:	e8 c1 fe ff ff       	call   1b29 <drawRect>
    1c68:	83 c4 20             	add    $0x20,%esp

    drawRect(buf, (Point){p.x, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1c6b:	8b 45 20             	mov    0x20(%ebp),%eax
    1c6e:	8b 55 28             	mov    0x28(%ebp),%edx
    1c71:	01 d2                	add    %edx,%edx
    1c73:	29 d0                	sub    %edx,%eax
    1c75:	89 45 e0             	mov    %eax,-0x20(%ebp)
    1c78:	8b 45 28             	mov    0x28(%ebp),%eax
    1c7b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    1c7e:	8b 45 0c             	mov    0xc(%ebp),%eax
    1c81:	89 45 e8             	mov    %eax,-0x18(%ebp)
    1c84:	8b 55 10             	mov    0x10(%ebp),%edx
    1c87:	8b 45 28             	mov    0x28(%ebp),%eax
    1c8a:	01 d0                	add    %edx,%eax
    1c8c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    1c8f:	ff 75 e4             	pushl  -0x1c(%ebp)
    1c92:	ff 75 e0             	pushl  -0x20(%ebp)
    1c95:	83 ec 04             	sub    $0x4,%esp
    1c98:	89 e0                	mov    %esp,%eax
    1c9a:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1c9e:	66 89 10             	mov    %dx,(%eax)
    1ca1:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1ca5:	88 50 02             	mov    %dl,0x2(%eax)
    1ca8:	ff 75 18             	pushl  0x18(%ebp)
    1cab:	ff 75 14             	pushl  0x14(%ebp)
    1cae:	ff 75 ec             	pushl  -0x14(%ebp)
    1cb1:	ff 75 e8             	pushl  -0x18(%ebp)
    1cb4:	ff 75 08             	pushl  0x8(%ebp)
    1cb7:	e8 6d fe ff ff       	call   1b29 <drawRect>
    1cbc:	83 c4 20             	add    $0x20,%esp
    drawRect(buf, (Point){p.x + rect_size.w - border, p.y + border}, s, color, (Size){rect_size.h - 2 * border, border});
    1cbf:	8b 45 20             	mov    0x20(%ebp),%eax
    1cc2:	8b 55 28             	mov    0x28(%ebp),%edx
    1cc5:	01 d2                	add    %edx,%edx
    1cc7:	29 d0                	sub    %edx,%eax
    1cc9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    1ccc:	8b 45 28             	mov    0x28(%ebp),%eax
    1ccf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    1cd2:	8b 55 0c             	mov    0xc(%ebp),%edx
    1cd5:	8b 45 24             	mov    0x24(%ebp),%eax
    1cd8:	01 d0                	add    %edx,%eax
    1cda:	2b 45 28             	sub    0x28(%ebp),%eax
    1cdd:	89 45 f8             	mov    %eax,-0x8(%ebp)
    1ce0:	8b 55 10             	mov    0x10(%ebp),%edx
    1ce3:	8b 45 28             	mov    0x28(%ebp),%eax
    1ce6:	01 d0                	add    %edx,%eax
    1ce8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    1ceb:	ff 75 f4             	pushl  -0xc(%ebp)
    1cee:	ff 75 f0             	pushl  -0x10(%ebp)
    1cf1:	83 ec 04             	sub    $0x4,%esp
    1cf4:	89 e0                	mov    %esp,%eax
    1cf6:	0f b7 55 1c          	movzwl 0x1c(%ebp),%edx
    1cfa:	66 89 10             	mov    %dx,(%eax)
    1cfd:	0f b6 55 1e          	movzbl 0x1e(%ebp),%edx
    1d01:	88 50 02             	mov    %dl,0x2(%eax)
    1d04:	ff 75 18             	pushl  0x18(%ebp)
    1d07:	ff 75 14             	pushl  0x14(%ebp)
    1d0a:	ff 75 fc             	pushl  -0x4(%ebp)
    1d0d:	ff 75 f8             	pushl  -0x8(%ebp)
    1d10:	ff 75 08             	pushl  0x8(%ebp)
    1d13:	e8 11 fe ff ff       	call   1b29 <drawRect>
    1d18:	83 c4 20             	add    $0x20,%esp
}
    1d1b:	90                   	nop
    1d1c:	c9                   	leave  
    1d1d:	c3                   	ret    

00001d1e <drawBitmap>:
// pt: start point of target
// pc: start point of content
// st: size of target
// sc: size of content
// s: size to be drawed
void drawBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1d1e:	55                   	push   %ebp
    1d1f:	89 e5                	mov    %esp,%ebp
    1d21:	83 ec 28             	sub    $0x28,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1d24:	8b 45 30             	mov    0x30(%ebp),%eax
    1d27:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int draw_w = s.w;
    1d2a:	8b 45 34             	mov    0x34(%ebp),%eax
    1d2d:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (draw_h > st.h - pt.y) {
    1d30:	8b 55 20             	mov    0x20(%ebp),%edx
    1d33:	8b 45 14             	mov    0x14(%ebp),%eax
    1d36:	29 c2                	sub    %eax,%edx
    1d38:	89 d0                	mov    %edx,%eax
    1d3a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1d3d:	7d 0d                	jge    1d4c <drawBitmap+0x2e>
        draw_h = st.h - pt.y;
    1d3f:	8b 55 20             	mov    0x20(%ebp),%edx
    1d42:	8b 45 14             	mov    0x14(%ebp),%eax
    1d45:	29 c2                	sub    %eax,%edx
    1d47:	89 d0                	mov    %edx,%eax
    1d49:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1d4c:	8b 55 28             	mov    0x28(%ebp),%edx
    1d4f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1d52:	29 c2                	sub    %eax,%edx
    1d54:	89 d0                	mov    %edx,%eax
    1d56:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1d59:	7d 0d                	jge    1d68 <drawBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1d5b:	8b 55 28             	mov    0x28(%ebp),%edx
    1d5e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1d61:	29 c2                	sub    %eax,%edx
    1d63:	89 d0                	mov    %edx,%eax
    1d65:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1d68:	8b 55 24             	mov    0x24(%ebp),%edx
    1d6b:	8b 45 10             	mov    0x10(%ebp),%eax
    1d6e:	29 c2                	sub    %eax,%edx
    1d70:	89 d0                	mov    %edx,%eax
    1d72:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1d75:	7d 0d                	jge    1d84 <drawBitmap+0x66>
        draw_w = st.w - pt.x;
    1d77:	8b 55 24             	mov    0x24(%ebp),%edx
    1d7a:	8b 45 10             	mov    0x10(%ebp),%eax
    1d7d:	29 c2                	sub    %eax,%edx
    1d7f:	89 d0                	mov    %edx,%eax
    1d81:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1d84:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1d87:	8b 45 18             	mov    0x18(%ebp),%eax
    1d8a:	29 c2                	sub    %eax,%edx
    1d8c:	89 d0                	mov    %edx,%eax
    1d8e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1d91:	7d 0d                	jge    1da0 <drawBitmap+0x82>
        draw_w = sc.w - pc.x;
    1d93:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1d96:	8b 45 18             	mov    0x18(%ebp),%eax
    1d99:	29 c2                	sub    %eax,%edx
    1d9b:	89 d0                	mov    %edx,%eax
    1d9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    1da0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    1da7:	e9 83 00 00 00       	jmp    1e2f <drawBitmap+0x111>
        if (pt.y + i < 0 || pt.y + i >= st.h) {
    1dac:	8b 55 14             	mov    0x14(%ebp),%edx
    1daf:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1db2:	01 d0                	add    %edx,%eax
    1db4:	85 c0                	test   %eax,%eax
    1db6:	78 72                	js     1e2a <drawBitmap+0x10c>
    1db8:	8b 55 14             	mov    0x14(%ebp),%edx
    1dbb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1dbe:	01 c2                	add    %eax,%edx
    1dc0:	8b 45 20             	mov    0x20(%ebp),%eax
    1dc3:	39 c2                	cmp    %eax,%edx
    1dc5:	7d 63                	jge    1e2a <drawBitmap+0x10c>
            continue;
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
    1dc7:	8b 55 14             	mov    0x14(%ebp),%edx
    1dca:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1dcd:	01 c2                	add    %eax,%edx
    1dcf:	8b 45 24             	mov    0x24(%ebp),%eax
    1dd2:	0f af c2             	imul   %edx,%eax
    1dd5:	89 c2                	mov    %eax,%edx
    1dd7:	8b 45 10             	mov    0x10(%ebp),%eax
    1dda:	01 c2                	add    %eax,%edx
    1ddc:	89 d0                	mov    %edx,%eax
    1dde:	01 c0                	add    %eax,%eax
    1de0:	01 c2                	add    %eax,%edx
    1de2:	8b 45 08             	mov    0x8(%ebp),%eax
    1de5:	01 d0                	add    %edx,%eax
    1de7:	89 45 e8             	mov    %eax,-0x18(%ebp)
        o = cont + (pc.y + i) * sc.w + pc.x;
    1dea:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1ded:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1df0:	01 c2                	add    %eax,%edx
    1df2:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1df5:	0f af c2             	imul   %edx,%eax
    1df8:	89 c2                	mov    %eax,%edx
    1dfa:	8b 45 18             	mov    0x18(%ebp),%eax
    1dfd:	01 c2                	add    %eax,%edx
    1dff:	89 d0                	mov    %edx,%eax
    1e01:	01 c0                	add    %eax,%eax
    1e03:	01 c2                	add    %eax,%edx
    1e05:	8b 45 0c             	mov    0xc(%ebp),%eax
    1e08:	01 d0                	add    %edx,%eax
    1e0a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        memmove(t, o, draw_w * 3);
    1e0d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    1e10:	89 d0                	mov    %edx,%eax
    1e12:	01 c0                	add    %eax,%eax
    1e14:	01 d0                	add    %edx,%eax
    1e16:	83 ec 04             	sub    $0x4,%esp
    1e19:	50                   	push   %eax
    1e1a:	ff 75 e4             	pushl  -0x1c(%ebp)
    1e1d:	ff 75 e8             	pushl  -0x18(%ebp)
    1e20:	e8 23 e7 ff ff       	call   548 <memmove>
    1e25:	83 c4 10             	add    $0x10,%esp
    1e28:	eb 01                	jmp    1e2b <drawBitmap+0x10d>
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
        if (pt.y + i < 0 || pt.y + i >= st.h) {
            continue;
    1e2a:	90                   	nop
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < draw_h; i++) {
    1e2b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    1e2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1e32:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1e35:	0f 8c 71 ff ff ff    	jl     1dac <drawBitmap+0x8e>
        }
        t = tgt + (pt.y + i) * st.w + pt.x;
        o = cont + (pc.y + i) * sc.w + pc.x;
        memmove(t, o, draw_w * 3);
    }
}
    1e3b:	90                   	nop
    1e3c:	c9                   	leave  
    1e3d:	c3                   	ret    

00001e3e <drawTransparentBitmap>:

void drawTransparentBitmap(struct RGB* tgt, struct RGB* cont, Point pt, Point pc, Size st, Size sc, Size s) {
    1e3e:	55                   	push   %ebp
    1e3f:	89 e5                	mov    %esp,%ebp
    1e41:	83 ec 20             	sub    $0x20,%esp
    struct RGB *t;
    struct RGB *o;
    int draw_h = s.h;
    1e44:	8b 45 30             	mov    0x30(%ebp),%eax
    1e47:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = s.w;
    1e4a:	8b 45 34             	mov    0x34(%ebp),%eax
    1e4d:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > st.h - pt.y) {
    1e50:	8b 55 20             	mov    0x20(%ebp),%edx
    1e53:	8b 45 14             	mov    0x14(%ebp),%eax
    1e56:	29 c2                	sub    %eax,%edx
    1e58:	89 d0                	mov    %edx,%eax
    1e5a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1e5d:	7d 0d                	jge    1e6c <drawTransparentBitmap+0x2e>
        draw_h = st.h - pt.y;
    1e5f:	8b 55 20             	mov    0x20(%ebp),%edx
    1e62:	8b 45 14             	mov    0x14(%ebp),%eax
    1e65:	29 c2                	sub    %eax,%edx
    1e67:	89 d0                	mov    %edx,%eax
    1e69:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    if (draw_h > sc.h - pc.y) {
    1e6c:	8b 55 28             	mov    0x28(%ebp),%edx
    1e6f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1e72:	29 c2                	sub    %eax,%edx
    1e74:	89 d0                	mov    %edx,%eax
    1e76:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1e79:	7d 0d                	jge    1e88 <drawTransparentBitmap+0x4a>
        draw_h = sc.h - pc.y;
    1e7b:	8b 55 28             	mov    0x28(%ebp),%edx
    1e7e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1e81:	29 c2                	sub    %eax,%edx
    1e83:	89 d0                	mov    %edx,%eax
    1e85:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > st.w - pt.x) {
    1e88:	8b 55 24             	mov    0x24(%ebp),%edx
    1e8b:	8b 45 10             	mov    0x10(%ebp),%eax
    1e8e:	29 c2                	sub    %eax,%edx
    1e90:	89 d0                	mov    %edx,%eax
    1e92:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1e95:	7d 0d                	jge    1ea4 <drawTransparentBitmap+0x66>
        draw_w = st.w - pt.x;
    1e97:	8b 55 24             	mov    0x24(%ebp),%edx
    1e9a:	8b 45 10             	mov    0x10(%ebp),%eax
    1e9d:	29 c2                	sub    %eax,%edx
    1e9f:	89 d0                	mov    %edx,%eax
    1ea1:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
    if (draw_w > sc.w - pc.x) {
    1ea4:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1ea7:	8b 45 18             	mov    0x18(%ebp),%eax
    1eaa:	29 c2                	sub    %eax,%edx
    1eac:	89 d0                	mov    %edx,%eax
    1eae:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    1eb1:	7d 0d                	jge    1ec0 <drawTransparentBitmap+0x82>
        draw_w = sc.w - pc.x;
    1eb3:	8b 55 2c             	mov    0x2c(%ebp),%edx
    1eb6:	8b 45 18             	mov    0x18(%ebp),%eax
    1eb9:	29 c2                	sub    %eax,%edx
    1ebb:	89 d0                	mov    %edx,%eax
    1ebd:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < s.h; ++i) {
    1ec0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    1ec7:	e9 b8 00 00 00       	jmp    1f84 <drawTransparentBitmap+0x146>
        for(int j = 0; j < s.w; ++j)
    1ecc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    1ed3:	e9 9c 00 00 00       	jmp    1f74 <drawTransparentBitmap+0x136>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
    1ed8:	8b 55 14             	mov    0x14(%ebp),%edx
    1edb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1ede:	01 c2                	add    %eax,%edx
    1ee0:	8b 45 24             	mov    0x24(%ebp),%eax
    1ee3:	0f af c2             	imul   %edx,%eax
    1ee6:	89 c2                	mov    %eax,%edx
    1ee8:	8b 45 10             	mov    0x10(%ebp),%eax
    1eeb:	01 c2                	add    %eax,%edx
    1eed:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1ef0:	01 c2                	add    %eax,%edx
    1ef2:	89 d0                	mov    %edx,%eax
    1ef4:	01 c0                	add    %eax,%eax
    1ef6:	01 c2                	add    %eax,%edx
    1ef8:	8b 45 08             	mov    0x8(%ebp),%eax
    1efb:	01 d0                	add    %edx,%eax
    1efd:	89 45 ec             	mov    %eax,-0x14(%ebp)
            o = cont + (pc.y + i) * sc.w + pc.x + j;
    1f00:	8b 55 1c             	mov    0x1c(%ebp),%edx
    1f03:	8b 45 f4             	mov    -0xc(%ebp),%eax
    1f06:	01 c2                	add    %eax,%edx
    1f08:	8b 45 2c             	mov    0x2c(%ebp),%eax
    1f0b:	0f af c2             	imul   %edx,%eax
    1f0e:	89 c2                	mov    %eax,%edx
    1f10:	8b 45 18             	mov    0x18(%ebp),%eax
    1f13:	01 c2                	add    %eax,%edx
    1f15:	8b 45 f0             	mov    -0x10(%ebp),%eax
    1f18:	01 c2                	add    %eax,%edx
    1f1a:	89 d0                	mov    %edx,%eax
    1f1c:	01 c0                	add    %eax,%eax
    1f1e:	01 c2                	add    %eax,%edx
    1f20:	8b 45 0c             	mov    0xc(%ebp),%eax
    1f23:	01 d0                	add    %edx,%eax
    1f25:	89 45 e8             	mov    %eax,-0x18(%ebp)

            if(o->R==255 && o->G == 255 && o->B==255)
    1f28:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1f2b:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    1f2f:	3c ff                	cmp    $0xff,%al
    1f31:	75 15                	jne    1f48 <drawTransparentBitmap+0x10a>
    1f33:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1f36:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    1f3a:	3c ff                	cmp    $0xff,%al
    1f3c:	75 0a                	jne    1f48 <drawTransparentBitmap+0x10a>
    1f3e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1f41:	0f b6 00             	movzbl (%eax),%eax
    1f44:	3c ff                	cmp    $0xff,%al
    1f46:	74 27                	je     1f6f <drawTransparentBitmap+0x131>
                continue;
            t->R = o->R;
    1f48:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1f4b:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    1f4f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f52:	88 50 02             	mov    %dl,0x2(%eax)
            t->G = o->G;
    1f55:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1f58:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    1f5c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f5f:	88 50 01             	mov    %dl,0x1(%eax)
            t->B = o->B;
    1f62:	8b 45 e8             	mov    -0x18(%ebp),%eax
    1f65:	0f b6 10             	movzbl (%eax),%edx
    1f68:	8b 45 ec             	mov    -0x14(%ebp),%eax
    1f6b:	88 10                	mov    %dl,(%eax)
    1f6d:	eb 01                	jmp    1f70 <drawTransparentBitmap+0x132>
        {
            t = tgt + (pt.y + i) * st.w + pt.x + j;
            o = cont + (pc.y + i) * sc.w + pc.x + j;

            if(o->R==255 && o->G == 255 && o->B==255)
                continue;
    1f6f:	90                   	nop
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
        for(int j = 0; j < s.w; ++j)
    1f70:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    1f74:	8b 45 34             	mov    0x34(%ebp),%eax
    1f77:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    1f7a:	0f 8f 58 ff ff ff    	jg     1ed8 <drawTransparentBitmap+0x9a>
    }
    if (draw_w > sc.w - pc.x) {
        draw_w = sc.w - pc.x;
    }

    for (int i = 0; i < s.h; ++i) {
    1f80:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    1f84:	8b 45 30             	mov    0x30(%ebp),%eax
    1f87:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    1f8a:	0f 8f 3c ff ff ff    	jg     1ecc <drawTransparentBitmap+0x8e>
            t->R = o->R;
            t->G = o->G;
            t->B = o->B;
        }
    }
}
    1f90:	90                   	nop
    1f91:	c9                   	leave  
    1f92:	c3                   	ret    

00001f93 <copyContent>:

void copyContent(RGB* tgt, RGB* src, Point p, Size s, Size copy_size) {
    1f93:	55                   	push   %ebp
    1f94:	89 e5                	mov    %esp,%ebp
    1f96:	83 ec 08             	sub    $0x8,%esp
    drawBitmap(tgt, src, p, p, s, s, copy_size);
    1f99:	ff 75 24             	pushl  0x24(%ebp)
    1f9c:	ff 75 20             	pushl  0x20(%ebp)
    1f9f:	ff 75 1c             	pushl  0x1c(%ebp)
    1fa2:	ff 75 18             	pushl  0x18(%ebp)
    1fa5:	ff 75 1c             	pushl  0x1c(%ebp)
    1fa8:	ff 75 18             	pushl  0x18(%ebp)
    1fab:	ff 75 14             	pushl  0x14(%ebp)
    1fae:	ff 75 10             	pushl  0x10(%ebp)
    1fb1:	ff 75 14             	pushl  0x14(%ebp)
    1fb4:	ff 75 10             	pushl  0x10(%ebp)
    1fb7:	ff 75 0c             	pushl  0xc(%ebp)
    1fba:	ff 75 08             	pushl  0x8(%ebp)
    1fbd:	e8 5c fd ff ff       	call   1d1e <drawBitmap>
    1fc2:	83 c4 30             	add    $0x30,%esp
}
    1fc5:	90                   	nop
    1fc6:	c9                   	leave  
    1fc7:	c3                   	ret    

00001fc8 <colorShift>:

void colorShift(RGB* buf, Point p, Size s, Size rect_size, int shift) {
    1fc8:	55                   	push   %ebp
    1fc9:	89 e5                	mov    %esp,%ebp
    1fcb:	83 ec 20             	sub    $0x20,%esp
    struct RGB * t;
    int draw_h = rect_size.h;
    1fce:	8b 45 1c             	mov    0x1c(%ebp),%eax
    1fd1:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int draw_w = rect_size.w;
    1fd4:	8b 45 20             	mov    0x20(%ebp),%eax
    1fd7:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if (draw_h > s.h - p.y) {
    1fda:	8b 55 14             	mov    0x14(%ebp),%edx
    1fdd:	8b 45 10             	mov    0x10(%ebp),%eax
    1fe0:	29 c2                	sub    %eax,%edx
    1fe2:	89 d0                	mov    %edx,%eax
    1fe4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    1fe7:	7d 0d                	jge    1ff6 <colorShift+0x2e>
        draw_h = s.h - p.y;
    1fe9:	8b 55 14             	mov    0x14(%ebp),%edx
    1fec:	8b 45 10             	mov    0x10(%ebp),%eax
    1fef:	29 c2                	sub    %eax,%edx
    1ff1:	89 d0                	mov    %edx,%eax
    1ff3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }

    if (draw_w > s.w - p.x) {
    1ff6:	8b 55 18             	mov    0x18(%ebp),%edx
    1ff9:	8b 45 0c             	mov    0xc(%ebp),%eax
    1ffc:	29 c2                	sub    %eax,%edx
    1ffe:	89 d0                	mov    %edx,%eax
    2000:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2003:	7d 0d                	jge    2012 <colorShift+0x4a>
        draw_w = s.w - p.x;
    2005:	8b 55 18             	mov    0x18(%ebp),%edx
    2008:	8b 45 0c             	mov    0xc(%ebp),%eax
    200b:	29 c2                	sub    %eax,%edx
    200d:	89 d0                	mov    %edx,%eax
    200f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }

    for (int i = 0; i < draw_h; i++) {
    2012:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2019:	e9 fc 00 00 00       	jmp    211a <colorShift+0x152>
        for(int j = 0; j < draw_w; j++) {
    201e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2025:	e9 e0 00 00 00       	jmp    210a <colorShift+0x142>
            t = buf + (p.y + i) * s.w + p.x + j;
    202a:	8b 55 10             	mov    0x10(%ebp),%edx
    202d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2030:	01 c2                	add    %eax,%edx
    2032:	8b 45 18             	mov    0x18(%ebp),%eax
    2035:	0f af c2             	imul   %edx,%eax
    2038:	89 c2                	mov    %eax,%edx
    203a:	8b 45 0c             	mov    0xc(%ebp),%eax
    203d:	01 c2                	add    %eax,%edx
    203f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2042:	01 c2                	add    %eax,%edx
    2044:	89 d0                	mov    %edx,%eax
    2046:	01 c0                	add    %eax,%eax
    2048:	01 c2                	add    %eax,%edx
    204a:	8b 45 08             	mov    0x8(%ebp),%eax
    204d:	01 d0                	add    %edx,%eax
    204f:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (t->R > 200 && t->G > 200 && t->B > 200) {
    2052:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2055:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2059:	3c c8                	cmp    $0xc8,%al
    205b:	0f 86 a5 00 00 00    	jbe    2106 <colorShift+0x13e>
    2061:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2064:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2068:	3c c8                	cmp    $0xc8,%al
    206a:	0f 86 96 00 00 00    	jbe    2106 <colorShift+0x13e>
    2070:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2073:	0f b6 00             	movzbl (%eax),%eax
    2076:	3c c8                	cmp    $0xc8,%al
    2078:	0f 86 88 00 00 00    	jbe    2106 <colorShift+0x13e>
                t->R = (t->R + shift + 256) % 256;
    207e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2081:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2085:	0f b6 d0             	movzbl %al,%edx
    2088:	8b 45 24             	mov    0x24(%ebp),%eax
    208b:	01 d0                	add    %edx,%eax
    208d:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    2093:	89 d0                	mov    %edx,%eax
    2095:	c1 f8 1f             	sar    $0x1f,%eax
    2098:	c1 e8 18             	shr    $0x18,%eax
    209b:	01 c2                	add    %eax,%edx
    209d:	0f b6 d2             	movzbl %dl,%edx
    20a0:	29 c2                	sub    %eax,%edx
    20a2:	89 d0                	mov    %edx,%eax
    20a4:	89 c2                	mov    %eax,%edx
    20a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
    20a9:	88 50 02             	mov    %dl,0x2(%eax)
                t->G = (t->G + shift + 256) % 256;
    20ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
    20af:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    20b3:	0f b6 d0             	movzbl %al,%edx
    20b6:	8b 45 24             	mov    0x24(%ebp),%eax
    20b9:	01 d0                	add    %edx,%eax
    20bb:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    20c1:	89 d0                	mov    %edx,%eax
    20c3:	c1 f8 1f             	sar    $0x1f,%eax
    20c6:	c1 e8 18             	shr    $0x18,%eax
    20c9:	01 c2                	add    %eax,%edx
    20cb:	0f b6 d2             	movzbl %dl,%edx
    20ce:	29 c2                	sub    %eax,%edx
    20d0:	89 d0                	mov    %edx,%eax
    20d2:	89 c2                	mov    %eax,%edx
    20d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    20d7:	88 50 01             	mov    %dl,0x1(%eax)
                t->B = (t->B + shift + 256) % 256;
    20da:	8b 45 ec             	mov    -0x14(%ebp),%eax
    20dd:	0f b6 00             	movzbl (%eax),%eax
    20e0:	0f b6 d0             	movzbl %al,%edx
    20e3:	8b 45 24             	mov    0x24(%ebp),%eax
    20e6:	01 d0                	add    %edx,%eax
    20e8:	8d 90 00 01 00 00    	lea    0x100(%eax),%edx
    20ee:	89 d0                	mov    %edx,%eax
    20f0:	c1 f8 1f             	sar    $0x1f,%eax
    20f3:	c1 e8 18             	shr    $0x18,%eax
    20f6:	01 c2                	add    %eax,%edx
    20f8:	0f b6 d2             	movzbl %dl,%edx
    20fb:	29 c2                	sub    %eax,%edx
    20fd:	89 d0                	mov    %edx,%eax
    20ff:	89 c2                	mov    %eax,%edx
    2101:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2104:	88 10                	mov    %dl,(%eax)
    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
        for(int j = 0; j < draw_w; j++) {
    2106:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    210a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    210d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2110:	0f 8c 14 ff ff ff    	jl     202a <colorShift+0x62>

    if (draw_w > s.w - p.x) {
        draw_w = s.w - p.x;
    }

    for (int i = 0; i < draw_h; i++) {
    2116:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    211a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    211d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2120:	0f 8c f8 fe ff ff    	jl     201e <colorShift+0x56>
                t->G = (t->G + shift + 256) % 256;
                t->B = (t->B + shift + 256) % 256;
            }
        }
    }
}
    2126:	90                   	nop
    2127:	c9                   	leave  
    2128:	c3                   	ret    

00002129 <drawMouse>:

void drawMouse(RGB *buf, int mode, int x, int y) {
    2129:	55                   	push   %ebp
    212a:	89 e5                	mov    %esp,%ebp
    212c:	83 ec 10             	sub    $0x10,%esp
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    212f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    2136:	e9 fb 00 00 00       	jmp    2236 <drawMouse+0x10d>
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
    213b:	8b 55 14             	mov    0x14(%ebp),%edx
    213e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2141:	01 c2                	add    %eax,%edx
    2143:	0f b7 05 82 ec 01 00 	movzwl 0x1ec82,%eax
    214a:	0f b7 c0             	movzwl %ax,%eax
    214d:	39 c2                	cmp    %eax,%edx
    214f:	0f 8f eb 00 00 00    	jg     2240 <drawMouse+0x117>
    2155:	8b 55 14             	mov    0x14(%ebp),%edx
    2158:	8b 45 fc             	mov    -0x4(%ebp),%eax
    215b:	01 d0                	add    %edx,%eax
    215d:	85 c0                	test   %eax,%eax
    215f:	0f 88 db 00 00 00    	js     2240 <drawMouse+0x117>
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    2165:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    216c:	e9 b7 00 00 00       	jmp    2228 <drawMouse+0xff>
            if (x + j > SCREEN_WIDTH || x + j < 0) {
    2171:	8b 55 10             	mov    0x10(%ebp),%edx
    2174:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2177:	01 c2                	add    %eax,%edx
    2179:	0f b7 05 80 ec 01 00 	movzwl 0x1ec80,%eax
    2180:	0f b7 c0             	movzwl %ax,%eax
    2183:	39 c2                	cmp    %eax,%edx
    2185:	0f 8f a7 00 00 00    	jg     2232 <drawMouse+0x109>
    218b:	8b 55 10             	mov    0x10(%ebp),%edx
    218e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2191:	01 d0                	add    %edx,%eax
    2193:	85 c0                	test   %eax,%eax
    2195:	0f 88 97 00 00 00    	js     2232 <drawMouse+0x109>
                break;
            }
            uchar temp = mouse_pointer[mode][i][j];
    219b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    219e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    21a1:	89 d0                	mov    %edx,%eax
    21a3:	c1 e0 04             	shl    $0x4,%eax
    21a6:	29 d0                	sub    %edx,%eax
    21a8:	69 d1 0e 01 00 00    	imul   $0x10e,%ecx,%edx
    21ae:	01 c2                	add    %eax,%edx
    21b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    21b3:	01 d0                	add    %edx,%eax
    21b5:	05 20 61 01 00       	add    $0x16120,%eax
    21ba:	0f b6 00             	movzbl (%eax),%eax
    21bd:	88 45 f7             	mov    %al,-0x9(%ebp)
            if (temp) {
    21c0:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
    21c4:	74 5e                	je     2224 <drawMouse+0xfb>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
    21c6:	8b 55 14             	mov    0x14(%ebp),%edx
    21c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    21cc:	01 c2                	add    %eax,%edx
    21ce:	0f b7 05 80 ec 01 00 	movzwl 0x1ec80,%eax
    21d5:	0f b7 c0             	movzwl %ax,%eax
    21d8:	0f af c2             	imul   %edx,%eax
    21db:	89 c2                	mov    %eax,%edx
    21dd:	8b 45 10             	mov    0x10(%ebp),%eax
    21e0:	01 c2                	add    %eax,%edx
    21e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    21e5:	01 c2                	add    %eax,%edx
    21e7:	89 d0                	mov    %edx,%eax
    21e9:	01 c0                	add    %eax,%eax
    21eb:	01 c2                	add    %eax,%edx
    21ed:	8b 45 08             	mov    0x8(%ebp),%eax
    21f0:	01 d0                	add    %edx,%eax
    21f2:	89 45 f0             	mov    %eax,-0x10(%ebp)
                drawPoint(t, mouse_color[temp - 1]);
    21f5:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    21f9:	8d 50 ff             	lea    -0x1(%eax),%edx
    21fc:	89 d0                	mov    %edx,%eax
    21fe:	01 c0                	add    %eax,%eax
    2200:	01 d0                	add    %edx,%eax
    2202:	05 88 ec 01 00       	add    $0x1ec88,%eax
    2207:	83 ec 04             	sub    $0x4,%esp
    220a:	89 e2                	mov    %esp,%edx
    220c:	0f b7 08             	movzwl (%eax),%ecx
    220f:	66 89 0a             	mov    %cx,(%edx)
    2212:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    2216:	88 42 02             	mov    %al,0x2(%edx)
    2219:	ff 75 f0             	pushl  -0x10(%ebp)
    221c:	e8 73 f6 ff ff       	call   1894 <drawPoint>
    2221:	83 c4 08             	add    $0x8,%esp
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
        if (y + i > SCREEN_HEIGHT || y + i < 0) {
            break;
        }
        for (j = 0; j < MOUSE_WIDTH; j++) {
    2224:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2228:	83 7d f8 0e          	cmpl   $0xe,-0x8(%ebp)
    222c:	0f 8e 3f ff ff ff    	jle    2171 <drawMouse+0x48>
}

void drawMouse(RGB *buf, int mode, int x, int y) {
    int i, j;
    RGB *t;
    for (i = 0; i < MOUSE_HEIGHT; i++) {
    2232:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    2236:	83 7d fc 11          	cmpl   $0x11,-0x4(%ebp)
    223a:	0f 8e fb fe ff ff    	jle    213b <drawMouse+0x12>
                t = buf + (y + i) * SCREEN_WIDTH + x + j;
                drawPoint(t, mouse_color[temp - 1]);
            }
        }
    }
}
    2240:	90                   	nop
    2241:	c9                   	leave  
    2242:	c3                   	ret    

00002243 <getColor>:
RGB whiteRGB = {255, 255, 255};
RGB blackRGB = {0, 0, 0};

// 排除边界，获取对应的RGB，对于错误的x，y，将isInPic置位0
struct RGB *getColor(PBitmap *pic, int y, int x, int *isInPic)
{
    2243:	55                   	push   %ebp
    2244:	89 e5                	mov    %esp,%ebp
    if (y < 0 || y > pic->height || x < 0 || x > pic->width)
    2246:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    224a:	78 1b                	js     2267 <getColor+0x24>
    224c:	8b 45 08             	mov    0x8(%ebp),%eax
    224f:	8b 40 04             	mov    0x4(%eax),%eax
    2252:	3b 45 0c             	cmp    0xc(%ebp),%eax
    2255:	7c 10                	jl     2267 <getColor+0x24>
    2257:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    225b:	78 0a                	js     2267 <getColor+0x24>
    225d:	8b 45 08             	mov    0x8(%ebp),%eax
    2260:	8b 00                	mov    (%eax),%eax
    2262:	3b 45 10             	cmp    0x10(%ebp),%eax
    2265:	7d 10                	jge    2277 <getColor+0x34>
    {
        *isInPic = 1;
    2267:	8b 45 14             	mov    0x14(%ebp),%eax
    226a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        return (&whiteRGB);
    2270:	b8 31 e4 01 00       	mov    $0x1e431,%eax
    2275:	eb 44                	jmp    22bb <getColor+0x78>
    }

    if (y == pic->height)
    2277:	8b 45 08             	mov    0x8(%ebp),%eax
    227a:	8b 40 04             	mov    0x4(%eax),%eax
    227d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    2280:	75 04                	jne    2286 <getColor+0x43>
        y--;
    2282:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
    if (x == pic->width)
    2286:	8b 45 08             	mov    0x8(%ebp),%eax
    2289:	8b 00                	mov    (%eax),%eax
    228b:	3b 45 10             	cmp    0x10(%ebp),%eax
    228e:	75 04                	jne    2294 <getColor+0x51>
        x--;
    2290:	83 6d 10 01          	subl   $0x1,0x10(%ebp)

    *isInPic = 1;
    2294:	8b 45 14             	mov    0x14(%ebp),%eax
    2297:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    return (pic->data + y * pic->width + x);
    229d:	8b 45 08             	mov    0x8(%ebp),%eax
    22a0:	8b 48 08             	mov    0x8(%eax),%ecx
    22a3:	8b 45 08             	mov    0x8(%ebp),%eax
    22a6:	8b 00                	mov    (%eax),%eax
    22a8:	0f af 45 0c          	imul   0xc(%ebp),%eax
    22ac:	89 c2                	mov    %eax,%edx
    22ae:	8b 45 10             	mov    0x10(%ebp),%eax
    22b1:	01 c2                	add    %eax,%edx
    22b3:	89 d0                	mov    %edx,%eax
    22b5:	01 c0                	add    %eax,%eax
    22b7:	01 d0                	add    %edx,%eax
    22b9:	01 c8                	add    %ecx,%eax
}
    22bb:	5d                   	pop    %ebp
    22bc:	c3                   	ret    

000022bd <setColor>:

int setColor(RGB *src, RGB *dst)
{
    22bd:	55                   	push   %ebp
    22be:	89 e5                	mov    %esp,%ebp
    dst->R = src->R;
    22c0:	8b 45 08             	mov    0x8(%ebp),%eax
    22c3:	0f b6 50 02          	movzbl 0x2(%eax),%edx
    22c7:	8b 45 0c             	mov    0xc(%ebp),%eax
    22ca:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = src->G;
    22cd:	8b 45 08             	mov    0x8(%ebp),%eax
    22d0:	0f b6 50 01          	movzbl 0x1(%eax),%edx
    22d4:	8b 45 0c             	mov    0xc(%ebp),%eax
    22d7:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = src->B;
    22da:	8b 45 08             	mov    0x8(%ebp),%eax
    22dd:	0f b6 10             	movzbl (%eax),%edx
    22e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    22e3:	88 10                	mov    %dl,(%eax)

    return 1;
    22e5:	b8 01 00 00 00       	mov    $0x1,%eax
}
    22ea:	5d                   	pop    %ebp
    22eb:	c3                   	ret    

000022ec <mixColor>:

// 获取经过二次插值之后的RGB
int mixColor(PBitmap *src, float fy, float fx, RGB *dst)
{
    22ec:	55                   	push   %ebp
    22ed:	89 e5                	mov    %esp,%ebp
    22ef:	83 ec 4c             	sub    $0x4c,%esp
    int x = (int)fx;
    22f2:	d9 45 10             	flds   0x10(%ebp)
    22f5:	d9 7d be             	fnstcw -0x42(%ebp)
    22f8:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    22fc:	b4 0c                	mov    $0xc,%ah
    22fe:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    2302:	d9 6d bc             	fldcw  -0x44(%ebp)
    2305:	db 5d fc             	fistpl -0x4(%ebp)
    2308:	d9 6d be             	fldcw  -0x42(%ebp)
    int y = (int)fy;
    230b:	d9 45 0c             	flds   0xc(%ebp)
    230e:	d9 6d bc             	fldcw  -0x44(%ebp)
    2311:	db 5d f8             	fistpl -0x8(%ebp)
    2314:	d9 6d be             	fldcw  -0x42(%ebp)
    if (x > fx)
    2317:	db 45 fc             	fildl  -0x4(%ebp)
    231a:	d9 45 10             	flds   0x10(%ebp)
    231d:	d9 c9                	fxch   %st(1)
    231f:	df e9                	fucomip %st(1),%st
    2321:	dd d8                	fstp   %st(0)
    2323:	76 04                	jbe    2329 <mixColor+0x3d>
        x--;
    2325:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    if (y > fy)
    2329:	db 45 f8             	fildl  -0x8(%ebp)
    232c:	d9 45 0c             	flds   0xc(%ebp)
    232f:	d9 c9                	fxch   %st(1)
    2331:	df e9                	fucomip %st(1),%st
    2333:	dd d8                	fstp   %st(0)
    2335:	76 04                	jbe    233b <mixColor+0x4f>
        y--;
    2337:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    233b:	8d 45 c0             	lea    -0x40(%ebp),%eax
    233e:	50                   	push   %eax
    233f:	ff 75 fc             	pushl  -0x4(%ebp)
    2342:	ff 75 f8             	pushl  -0x8(%ebp)
    2345:	ff 75 08             	pushl  0x8(%ebp)
    2348:	e8 f6 fe ff ff       	call   2243 <getColor>
    234d:	83 c4 10             	add    $0x10,%esp
    2350:	89 45 f4             	mov    %eax,-0xc(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    2353:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2356:	83 c0 01             	add    $0x1,%eax
    2359:	8d 55 c0             	lea    -0x40(%ebp),%edx
    235c:	83 c2 04             	add    $0x4,%edx
    235f:	52                   	push   %edx
    2360:	ff 75 fc             	pushl  -0x4(%ebp)
    2363:	50                   	push   %eax
    2364:	ff 75 08             	pushl  0x8(%ebp)
    2367:	e8 d7 fe ff ff       	call   2243 <getColor>
    236c:	83 c4 10             	add    $0x10,%esp
    236f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    2372:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2375:	83 c0 01             	add    $0x1,%eax
    2378:	8d 55 c0             	lea    -0x40(%ebp),%edx
    237b:	83 c2 08             	add    $0x8,%edx
    237e:	52                   	push   %edx
    237f:	50                   	push   %eax
    2380:	ff 75 f8             	pushl  -0x8(%ebp)
    2383:	ff 75 08             	pushl  0x8(%ebp)
    2386:	e8 b8 fe ff ff       	call   2243 <getColor>
    238b:	83 c4 10             	add    $0x10,%esp
    238e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    2391:	8b 45 fc             	mov    -0x4(%ebp),%eax
    2394:	8d 50 01             	lea    0x1(%eax),%edx
    2397:	8b 45 f8             	mov    -0x8(%ebp),%eax
    239a:	83 c0 01             	add    $0x1,%eax
    239d:	8d 4d c0             	lea    -0x40(%ebp),%ecx
    23a0:	83 c1 0c             	add    $0xc,%ecx
    23a3:	51                   	push   %ecx
    23a4:	52                   	push   %edx
    23a5:	50                   	push   %eax
    23a6:	ff 75 08             	pushl  0x8(%ebp)
    23a9:	e8 95 fe ff ff       	call   2243 <getColor>
    23ae:	83 c4 10             	add    $0x10,%esp
    23b1:	89 45 e8             	mov    %eax,-0x18(%ebp)

    float u = fx - x;
    23b4:	db 45 fc             	fildl  -0x4(%ebp)
    23b7:	d9 45 10             	flds   0x10(%ebp)
    23ba:	de e1                	fsubp  %st,%st(1)
    23bc:	d9 5d e4             	fstps  -0x1c(%ebp)
    float v = fy - y;
    23bf:	db 45 f8             	fildl  -0x8(%ebp)
    23c2:	d9 45 0c             	flds   0xc(%ebp)
    23c5:	de e1                	fsubp  %st,%st(1)
    23c7:	d9 5d e0             	fstps  -0x20(%ebp)

    float pm3 = u * v;
    23ca:	d9 45 e4             	flds   -0x1c(%ebp)
    23cd:	d8 4d e0             	fmuls  -0x20(%ebp)
    23d0:	d9 5d dc             	fstps  -0x24(%ebp)
    float pm2 = u * (1 - v);
    23d3:	d9 e8                	fld1   
    23d5:	d8 65 e0             	fsubs  -0x20(%ebp)
    23d8:	d8 4d e4             	fmuls  -0x1c(%ebp)
    23db:	d9 5d d8             	fstps  -0x28(%ebp)
    float pm1 = (1 - u) * v;
    23de:	d9 e8                	fld1   
    23e0:	d8 65 e4             	fsubs  -0x1c(%ebp)
    23e3:	d8 4d e0             	fmuls  -0x20(%ebp)
    23e6:	d9 5d d4             	fstps  -0x2c(%ebp)
    float pm0 = (1 - u) * (1 - v);
    23e9:	d9 e8                	fld1   
    23eb:	d8 65 e4             	fsubs  -0x1c(%ebp)
    23ee:	d9 e8                	fld1   
    23f0:	d8 65 e0             	fsubs  -0x20(%ebp)
    23f3:	de c9                	fmulp  %st,%st(1)
    23f5:	d9 5d d0             	fstps  -0x30(%ebp)

    dst->R = (int)(Color0->R * pm0 * flag[0] + Color1->R * pm1 * flag[1] + Color2->R * pm2 * flag[2] + Color3->R * pm3 * flag[3]);
    23f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    23fb:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    23ff:	0f b6 c0             	movzbl %al,%eax
    2402:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2405:	db 45 b4             	fildl  -0x4c(%ebp)
    2408:	d8 4d d0             	fmuls  -0x30(%ebp)
    240b:	8b 45 c0             	mov    -0x40(%ebp),%eax
    240e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2411:	db 45 b4             	fildl  -0x4c(%ebp)
    2414:	de c9                	fmulp  %st,%st(1)
    2416:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2419:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    241d:	0f b6 c0             	movzbl %al,%eax
    2420:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2423:	db 45 b4             	fildl  -0x4c(%ebp)
    2426:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2429:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    242c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    242f:	db 45 b4             	fildl  -0x4c(%ebp)
    2432:	de c9                	fmulp  %st,%st(1)
    2434:	de c1                	faddp  %st,%st(1)
    2436:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2439:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    243d:	0f b6 c0             	movzbl %al,%eax
    2440:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2443:	db 45 b4             	fildl  -0x4c(%ebp)
    2446:	d8 4d d8             	fmuls  -0x28(%ebp)
    2449:	8b 45 c8             	mov    -0x38(%ebp),%eax
    244c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    244f:	db 45 b4             	fildl  -0x4c(%ebp)
    2452:	de c9                	fmulp  %st,%st(1)
    2454:	de c1                	faddp  %st,%st(1)
    2456:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2459:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    245d:	0f b6 c0             	movzbl %al,%eax
    2460:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2463:	db 45 b4             	fildl  -0x4c(%ebp)
    2466:	d8 4d dc             	fmuls  -0x24(%ebp)
    2469:	8b 45 cc             	mov    -0x34(%ebp),%eax
    246c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    246f:	db 45 b4             	fildl  -0x4c(%ebp)
    2472:	de c9                	fmulp  %st,%st(1)
    2474:	de c1                	faddp  %st,%st(1)
    2476:	d9 7d be             	fnstcw -0x42(%ebp)
    2479:	0f b7 45 be          	movzwl -0x42(%ebp),%eax
    247d:	b4 0c                	mov    $0xc,%ah
    247f:	66 89 45 bc          	mov    %ax,-0x44(%ebp)
    2483:	d9 6d bc             	fldcw  -0x44(%ebp)
    2486:	db 5d b8             	fistpl -0x48(%ebp)
    2489:	d9 6d be             	fldcw  -0x42(%ebp)
    248c:	8b 45 b8             	mov    -0x48(%ebp),%eax
    248f:	89 c2                	mov    %eax,%edx
    2491:	8b 45 14             	mov    0x14(%ebp),%eax
    2494:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = (int)(Color0->G * pm0 * flag[0] + Color1->G * pm1 * flag[1] + Color2->G * pm2 * flag[2] + Color3->G * pm3 * flag[3]);
    2497:	8b 45 f4             	mov    -0xc(%ebp),%eax
    249a:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    249e:	0f b6 c0             	movzbl %al,%eax
    24a1:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    24a4:	db 45 b4             	fildl  -0x4c(%ebp)
    24a7:	d8 4d d0             	fmuls  -0x30(%ebp)
    24aa:	8b 45 c0             	mov    -0x40(%ebp),%eax
    24ad:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    24b0:	db 45 b4             	fildl  -0x4c(%ebp)
    24b3:	de c9                	fmulp  %st,%st(1)
    24b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    24b8:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    24bc:	0f b6 c0             	movzbl %al,%eax
    24bf:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    24c2:	db 45 b4             	fildl  -0x4c(%ebp)
    24c5:	d8 4d d4             	fmuls  -0x2c(%ebp)
    24c8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    24cb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    24ce:	db 45 b4             	fildl  -0x4c(%ebp)
    24d1:	de c9                	fmulp  %st,%st(1)
    24d3:	de c1                	faddp  %st,%st(1)
    24d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    24d8:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    24dc:	0f b6 c0             	movzbl %al,%eax
    24df:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    24e2:	db 45 b4             	fildl  -0x4c(%ebp)
    24e5:	d8 4d d8             	fmuls  -0x28(%ebp)
    24e8:	8b 45 c8             	mov    -0x38(%ebp),%eax
    24eb:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    24ee:	db 45 b4             	fildl  -0x4c(%ebp)
    24f1:	de c9                	fmulp  %st,%st(1)
    24f3:	de c1                	faddp  %st,%st(1)
    24f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    24f8:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    24fc:	0f b6 c0             	movzbl %al,%eax
    24ff:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2502:	db 45 b4             	fildl  -0x4c(%ebp)
    2505:	d8 4d dc             	fmuls  -0x24(%ebp)
    2508:	8b 45 cc             	mov    -0x34(%ebp),%eax
    250b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    250e:	db 45 b4             	fildl  -0x4c(%ebp)
    2511:	de c9                	fmulp  %st,%st(1)
    2513:	de c1                	faddp  %st,%st(1)
    2515:	d9 6d bc             	fldcw  -0x44(%ebp)
    2518:	db 5d b8             	fistpl -0x48(%ebp)
    251b:	d9 6d be             	fldcw  -0x42(%ebp)
    251e:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2521:	89 c2                	mov    %eax,%edx
    2523:	8b 45 14             	mov    0x14(%ebp),%eax
    2526:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = (int)(Color0->B * pm0 * flag[0] + Color1->B * pm1 * flag[1] + Color2->B * pm2 * flag[2] + Color3->B * pm3 * flag[3]);
    2529:	8b 45 f4             	mov    -0xc(%ebp),%eax
    252c:	0f b6 00             	movzbl (%eax),%eax
    252f:	0f b6 c0             	movzbl %al,%eax
    2532:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2535:	db 45 b4             	fildl  -0x4c(%ebp)
    2538:	d8 4d d0             	fmuls  -0x30(%ebp)
    253b:	8b 45 c0             	mov    -0x40(%ebp),%eax
    253e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2541:	db 45 b4             	fildl  -0x4c(%ebp)
    2544:	de c9                	fmulp  %st,%st(1)
    2546:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2549:	0f b6 00             	movzbl (%eax),%eax
    254c:	0f b6 c0             	movzbl %al,%eax
    254f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2552:	db 45 b4             	fildl  -0x4c(%ebp)
    2555:	d8 4d d4             	fmuls  -0x2c(%ebp)
    2558:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    255b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    255e:	db 45 b4             	fildl  -0x4c(%ebp)
    2561:	de c9                	fmulp  %st,%st(1)
    2563:	de c1                	faddp  %st,%st(1)
    2565:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2568:	0f b6 00             	movzbl (%eax),%eax
    256b:	0f b6 c0             	movzbl %al,%eax
    256e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2571:	db 45 b4             	fildl  -0x4c(%ebp)
    2574:	d8 4d d8             	fmuls  -0x28(%ebp)
    2577:	8b 45 c8             	mov    -0x38(%ebp),%eax
    257a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    257d:	db 45 b4             	fildl  -0x4c(%ebp)
    2580:	de c9                	fmulp  %st,%st(1)
    2582:	de c1                	faddp  %st,%st(1)
    2584:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2587:	0f b6 00             	movzbl (%eax),%eax
    258a:	0f b6 c0             	movzbl %al,%eax
    258d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    2590:	db 45 b4             	fildl  -0x4c(%ebp)
    2593:	d8 4d dc             	fmuls  -0x24(%ebp)
    2596:	8b 45 cc             	mov    -0x34(%ebp),%eax
    2599:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    259c:	db 45 b4             	fildl  -0x4c(%ebp)
    259f:	de c9                	fmulp  %st,%st(1)
    25a1:	de c1                	faddp  %st,%st(1)
    25a3:	d9 6d bc             	fldcw  -0x44(%ebp)
    25a6:	db 5d b8             	fistpl -0x48(%ebp)
    25a9:	d9 6d be             	fldcw  -0x42(%ebp)
    25ac:	8b 45 b8             	mov    -0x48(%ebp),%eax
    25af:	89 c2                	mov    %eax,%edx
    25b1:	8b 45 14             	mov    0x14(%ebp),%eax
    25b4:	88 10                	mov    %dl,(%eax)

    return 1;
    25b6:	b8 01 00 00 00       	mov    $0x1,%eax
}
    25bb:	c9                   	leave  
    25bc:	c3                   	ret    

000025bd <mixColorInt>:

// 将float改为int计算，加快速度
int mixColorInt(PBitmap *src, const int y_16, const int x_16, RGB *dst)
{
    25bd:	55                   	push   %ebp
    25be:	89 e5                	mov    %esp,%ebp
    25c0:	53                   	push   %ebx
    25c1:	83 ec 40             	sub    $0x40,%esp
    int x = x_16 >> 16;
    25c4:	8b 45 10             	mov    0x10(%ebp),%eax
    25c7:	c1 f8 10             	sar    $0x10,%eax
    25ca:	89 45 f8             	mov    %eax,-0x8(%ebp)
    int y = y_16 >> 16;
    25cd:	8b 45 0c             	mov    0xc(%ebp),%eax
    25d0:	c1 f8 10             	sar    $0x10,%eax
    25d3:	89 45 f4             	mov    %eax,-0xc(%ebp)

    int flag[4];
    RGB *Color0 = getColor(src, y, x, &flag[0]);
    25d6:	8d 45 bc             	lea    -0x44(%ebp),%eax
    25d9:	50                   	push   %eax
    25da:	ff 75 f8             	pushl  -0x8(%ebp)
    25dd:	ff 75 f4             	pushl  -0xc(%ebp)
    25e0:	ff 75 08             	pushl  0x8(%ebp)
    25e3:	e8 5b fc ff ff       	call   2243 <getColor>
    25e8:	83 c4 10             	add    $0x10,%esp
    25eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    RGB *Color1 = getColor(src, y + 1, x, &flag[1]);
    25ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    25f1:	83 c0 01             	add    $0x1,%eax
    25f4:	8d 55 bc             	lea    -0x44(%ebp),%edx
    25f7:	83 c2 04             	add    $0x4,%edx
    25fa:	52                   	push   %edx
    25fb:	ff 75 f8             	pushl  -0x8(%ebp)
    25fe:	50                   	push   %eax
    25ff:	ff 75 08             	pushl  0x8(%ebp)
    2602:	e8 3c fc ff ff       	call   2243 <getColor>
    2607:	83 c4 10             	add    $0x10,%esp
    260a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    RGB *Color2 = getColor(src, y, x + 1, &flag[2]);
    260d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2610:	83 c0 01             	add    $0x1,%eax
    2613:	8d 55 bc             	lea    -0x44(%ebp),%edx
    2616:	83 c2 08             	add    $0x8,%edx
    2619:	52                   	push   %edx
    261a:	50                   	push   %eax
    261b:	ff 75 f4             	pushl  -0xc(%ebp)
    261e:	ff 75 08             	pushl  0x8(%ebp)
    2621:	e8 1d fc ff ff       	call   2243 <getColor>
    2626:	83 c4 10             	add    $0x10,%esp
    2629:	89 45 e8             	mov    %eax,-0x18(%ebp)
    RGB *Color3 = getColor(src, y + 1, x + 1, &flag[3]);
    262c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    262f:	8d 50 01             	lea    0x1(%eax),%edx
    2632:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2635:	83 c0 01             	add    $0x1,%eax
    2638:	8d 4d bc             	lea    -0x44(%ebp),%ecx
    263b:	83 c1 0c             	add    $0xc,%ecx
    263e:	51                   	push   %ecx
    263f:	52                   	push   %edx
    2640:	50                   	push   %eax
    2641:	ff 75 08             	pushl  0x8(%ebp)
    2644:	e8 fa fb ff ff       	call   2243 <getColor>
    2649:	83 c4 10             	add    $0x10,%esp
    264c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    unsigned int u_8 = (x_16 & 0xFFFF) >> 8;
    264f:	8b 45 10             	mov    0x10(%ebp),%eax
    2652:	0f b7 c0             	movzwl %ax,%eax
    2655:	c1 f8 08             	sar    $0x8,%eax
    2658:	89 45 e0             	mov    %eax,-0x20(%ebp)
    unsigned int v_8 = (y_16 & 0xFFFF) >> 8;
    265b:	8b 45 0c             	mov    0xc(%ebp),%eax
    265e:	0f b7 c0             	movzwl %ax,%eax
    2661:	c1 f8 08             	sar    $0x8,%eax
    2664:	89 45 dc             	mov    %eax,-0x24(%ebp)

    unsigned int pm3_16 = (u_8 * v_8);
    2667:	8b 45 e0             	mov    -0x20(%ebp),%eax
    266a:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    266e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned int pm2_16 = (u_8 * (255 - v_8));
    2671:	b8 ff 00 00 00       	mov    $0xff,%eax
    2676:	2b 45 dc             	sub    -0x24(%ebp),%eax
    2679:	0f af 45 e0          	imul   -0x20(%ebp),%eax
    267d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned int pm1_16 = ((255 - u_8) * v_8);
    2680:	b8 ff 00 00 00       	mov    $0xff,%eax
    2685:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2688:	0f af 45 dc          	imul   -0x24(%ebp),%eax
    268c:	89 45 d0             	mov    %eax,-0x30(%ebp)
    unsigned int pm0_16 = ((255 - u_8) * (255 - v_8));
    268f:	b8 ff 00 00 00       	mov    $0xff,%eax
    2694:	2b 45 e0             	sub    -0x20(%ebp),%eax
    2697:	89 c2                	mov    %eax,%edx
    2699:	b8 ff 00 00 00       	mov    $0xff,%eax
    269e:	2b 45 dc             	sub    -0x24(%ebp),%eax
    26a1:	0f af c2             	imul   %edx,%eax
    26a4:	89 45 cc             	mov    %eax,-0x34(%ebp)

    dst->R = ((pm0_16 * Color0->R * flag[0] + pm1_16 * Color1->R * flag[1] + pm2_16 * Color2->R * flag[2] + pm3_16 * Color3->R * flag[3]) >> 16);
    26a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    26aa:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    26ae:	0f b6 c0             	movzbl %al,%eax
    26b1:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    26b5:	8b 55 bc             	mov    -0x44(%ebp),%edx
    26b8:	0f af d0             	imul   %eax,%edx
    26bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    26be:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    26c2:	0f b6 c0             	movzbl %al,%eax
    26c5:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    26c9:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    26cc:	0f af c1             	imul   %ecx,%eax
    26cf:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    26d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    26d5:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    26d9:	0f b6 c0             	movzbl %al,%eax
    26dc:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    26e0:	8b 55 c8             	mov    -0x38(%ebp),%edx
    26e3:	0f af d0             	imul   %eax,%edx
    26e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
    26e9:	0f b6 40 02          	movzbl 0x2(%eax),%eax
    26ed:	0f b6 c0             	movzbl %al,%eax
    26f0:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    26f4:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    26f7:	0f af c1             	imul   %ecx,%eax
    26fa:	01 d0                	add    %edx,%eax
    26fc:	01 d8                	add    %ebx,%eax
    26fe:	c1 e8 10             	shr    $0x10,%eax
    2701:	89 c2                	mov    %eax,%edx
    2703:	8b 45 14             	mov    0x14(%ebp),%eax
    2706:	88 50 02             	mov    %dl,0x2(%eax)
    dst->G = ((pm0_16 * Color0->G * flag[0] + pm1_16 * Color1->G * flag[1] + pm2_16 * Color2->G * flag[2] + pm3_16 * Color3->G * flag[3]) >> 16);
    2709:	8b 45 f0             	mov    -0x10(%ebp),%eax
    270c:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2710:	0f b6 c0             	movzbl %al,%eax
    2713:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2717:	8b 55 bc             	mov    -0x44(%ebp),%edx
    271a:	0f af d0             	imul   %eax,%edx
    271d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2720:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    2724:	0f b6 c0             	movzbl %al,%eax
    2727:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    272b:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    272e:	0f af c1             	imul   %ecx,%eax
    2731:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2734:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2737:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    273b:	0f b6 c0             	movzbl %al,%eax
    273e:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    2742:	8b 55 c8             	mov    -0x38(%ebp),%edx
    2745:	0f af d0             	imul   %eax,%edx
    2748:	8b 45 e8             	mov    -0x18(%ebp),%eax
    274b:	0f b6 40 01          	movzbl 0x1(%eax),%eax
    274f:	0f b6 c0             	movzbl %al,%eax
    2752:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    2756:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    2759:	0f af c1             	imul   %ecx,%eax
    275c:	01 d0                	add    %edx,%eax
    275e:	01 d8                	add    %ebx,%eax
    2760:	c1 e8 10             	shr    $0x10,%eax
    2763:	89 c2                	mov    %eax,%edx
    2765:	8b 45 14             	mov    0x14(%ebp),%eax
    2768:	88 50 01             	mov    %dl,0x1(%eax)
    dst->B = ((pm0_16 * Color0->B * flag[0] + pm1_16 * Color1->B * flag[1] + pm2_16 * Color2->B * flag[2] + pm3_16 * Color3->B * flag[3]) >> 16);
    276b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    276e:	0f b6 00             	movzbl (%eax),%eax
    2771:	0f b6 c0             	movzbl %al,%eax
    2774:	0f af 45 cc          	imul   -0x34(%ebp),%eax
    2778:	8b 55 bc             	mov    -0x44(%ebp),%edx
    277b:	0f af d0             	imul   %eax,%edx
    277e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2781:	0f b6 00             	movzbl (%eax),%eax
    2784:	0f b6 c0             	movzbl %al,%eax
    2787:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    278b:	8b 4d c0             	mov    -0x40(%ebp),%ecx
    278e:	0f af c1             	imul   %ecx,%eax
    2791:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    2794:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    2797:	0f b6 00             	movzbl (%eax),%eax
    279a:	0f b6 c0             	movzbl %al,%eax
    279d:	0f af 45 d8          	imul   -0x28(%ebp),%eax
    27a1:	8b 55 c8             	mov    -0x38(%ebp),%edx
    27a4:	0f af d0             	imul   %eax,%edx
    27a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    27aa:	0f b6 00             	movzbl (%eax),%eax
    27ad:	0f b6 c0             	movzbl %al,%eax
    27b0:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    27b4:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
    27b7:	0f af c1             	imul   %ecx,%eax
    27ba:	01 d0                	add    %edx,%eax
    27bc:	01 d8                	add    %ebx,%eax
    27be:	c1 e8 10             	shr    $0x10,%eax
    27c1:	89 c2                	mov    %eax,%edx
    27c3:	8b 45 14             	mov    0x14(%ebp),%eax
    27c6:	88 10                	mov    %dl,(%eax)
}
    27c8:	90                   	nop
    27c9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    27cc:	c9                   	leave  
    27cd:	c3                   	ret    

000027ce <picScale>:

int picScale(PBitmap *src, PBitmap *dst)
{
    27ce:	55                   	push   %ebp
    27cf:	89 e5                	mov    %esp,%ebp
    27d1:	53                   	push   %ebx
    27d2:	83 ec 20             	sub    $0x20,%esp
    // float xScale = (float)src->width / (float)dst->width;
    // float yScale = (float)src->height / (float)dst->height;

    int xrIntFloat_16 = ((src->width)<<16)/dst->width+1;
    27d5:	8b 45 08             	mov    0x8(%ebp),%eax
    27d8:	8b 00                	mov    (%eax),%eax
    27da:	c1 e0 10             	shl    $0x10,%eax
    27dd:	89 c1                	mov    %eax,%ecx
    27df:	8b 45 0c             	mov    0xc(%ebp),%eax
    27e2:	8b 18                	mov    (%eax),%ebx
    27e4:	89 c8                	mov    %ecx,%eax
    27e6:	99                   	cltd   
    27e7:	f7 fb                	idiv   %ebx
    27e9:	83 c0 01             	add    $0x1,%eax
    27ec:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    27ef:	8b 45 08             	mov    0x8(%ebp),%eax
    27f2:	8b 40 04             	mov    0x4(%eax),%eax
    27f5:	c1 e0 10             	shl    $0x10,%eax
    27f8:	89 c1                	mov    %eax,%ecx
    27fa:	8b 45 0c             	mov    0xc(%ebp),%eax
    27fd:	8b 58 04             	mov    0x4(%eax),%ebx
    2800:	89 c8                	mov    %ecx,%eax
    2802:	99                   	cltd   
    2803:	f7 fb                	idiv   %ebx
    2805:	83 c0 01             	add    $0x1,%eax
    2808:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    280b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    280e:	d1 f8                	sar    %eax
    2810:	2d 00 80 00 00       	sub    $0x8000,%eax
    2815:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);
    2818:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    281b:	d1 f8                	sar    %eax
    281d:	2d 00 80 00 00       	sub    $0x8000,%eax
    2822:	89 45 dc             	mov    %eax,-0x24(%ebp)

    int srcy_16=csdErrorY;
    2825:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2828:	89 45 f8             	mov    %eax,-0x8(%ebp)
    for (int y = 0; y < dst->height; y++)
    282b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2832:	eb 5d                	jmp    2891 <picScale+0xc3>
    {
        int srcx_16=csdErrorX;
    2834:	8b 45 e0             	mov    -0x20(%ebp),%eax
    2837:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for (int x = 0; x < dst->width; x++)
    283a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    2841:	eb 3a                	jmp    287d <picScale+0xaf>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
    2843:	8b 45 0c             	mov    0xc(%ebp),%eax
    2846:	8b 48 08             	mov    0x8(%eax),%ecx
    2849:	8b 45 0c             	mov    0xc(%ebp),%eax
    284c:	8b 00                	mov    (%eax),%eax
    284e:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2852:	89 c2                	mov    %eax,%edx
    2854:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2857:	01 c2                	add    %eax,%edx
    2859:	89 d0                	mov    %edx,%eax
    285b:	01 c0                	add    %eax,%eax
    285d:	01 d0                	add    %edx,%eax
    285f:	01 c8                	add    %ecx,%eax
    2861:	50                   	push   %eax
    2862:	ff 75 f0             	pushl  -0x10(%ebp)
    2865:	ff 75 f8             	pushl  -0x8(%ebp)
    2868:	ff 75 08             	pushl  0x8(%ebp)
    286b:	e8 4d fd ff ff       	call   25bd <mixColorInt>
    2870:	83 c4 10             	add    $0x10,%esp
            srcx_16+=xrIntFloat_16;
    2873:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2876:	01 45 f0             	add    %eax,-0x10(%ebp)

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    {
        int srcx_16=csdErrorX;
        for (int x = 0; x < dst->width; x++)
    2879:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    287d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2880:	8b 00                	mov    (%eax),%eax
    2882:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2885:	7f bc                	jg     2843 <picScale+0x75>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            mixColorInt(src, srcy_16, srcx_16, dst->data + y * dst->width + x);
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    2887:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    288a:	01 45 f8             	add    %eax,-0x8(%ebp)
    int yrIntFloat_16 = ((src->height)<<16)/dst->height+1;
    const int csdErrorX = -(1<<15)+(xrIntFloat_16>>1);
    const int csdErrorY = -(1<<15)+(yrIntFloat_16>>1);

    int srcy_16=csdErrorY;
    for (int y = 0; y < dst->height; y++)
    288d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2891:	8b 45 0c             	mov    0xc(%ebp),%eax
    2894:	8b 40 04             	mov    0x4(%eax),%eax
    2897:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    289a:	7f 98                	jg     2834 <picScale+0x66>
            srcx_16+=xrIntFloat_16;
        }
        srcy_16+=yrIntFloat_16;
    }

    return 1;
    289c:	b8 01 00 00 00       	mov    $0x1,%eax
}
    28a1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    28a4:	c9                   	leave  
    28a5:	c3                   	ret    

000028a6 <picFastScale>:

int picFastScale(PBitmap *src, PBitmap *dst)
{
    28a6:	55                   	push   %ebp
    28a7:	89 e5                	mov    %esp,%ebp
    28a9:	83 ec 1c             	sub    $0x1c,%esp
    float xScale = (float)src->width / (float)dst->width;
    28ac:	8b 45 08             	mov    0x8(%ebp),%eax
    28af:	8b 00                	mov    (%eax),%eax
    28b1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    28b4:	db 45 e4             	fildl  -0x1c(%ebp)
    28b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    28ba:	8b 00                	mov    (%eax),%eax
    28bc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    28bf:	db 45 e4             	fildl  -0x1c(%ebp)
    28c2:	de f9                	fdivrp %st,%st(1)
    28c4:	d9 5d f4             	fstps  -0xc(%ebp)
    float yScale = (float)src->height / (float)dst->height;
    28c7:	8b 45 08             	mov    0x8(%ebp),%eax
    28ca:	8b 40 04             	mov    0x4(%eax),%eax
    28cd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    28d0:	db 45 e4             	fildl  -0x1c(%ebp)
    28d3:	8b 45 0c             	mov    0xc(%ebp),%eax
    28d6:	8b 40 04             	mov    0x4(%eax),%eax
    28d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    28dc:	db 45 e4             	fildl  -0x1c(%ebp)
    28df:	de f9                	fdivrp %st,%st(1)
    28e1:	d9 5d f0             	fstps  -0x10(%ebp)

    for (int y = 0; y < dst->height; y++)
    28e4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    28eb:	eb 5e                	jmp    294b <picFastScale+0xa5>
    {
        for (int x = 0; x < dst->width; x++)
    28ed:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    28f4:	eb 47                	jmp    293d <picFastScale+0x97>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
    28f6:	db 45 f8             	fildl  -0x8(%ebp)
    28f9:	d8 4d f4             	fmuls  -0xc(%ebp)
    28fc:	d9 7d ee             	fnstcw -0x12(%ebp)
    28ff:	0f b7 45 ee          	movzwl -0x12(%ebp),%eax
    2903:	b4 0c                	mov    $0xc,%ah
    2905:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    2909:	d9 6d ec             	fldcw  -0x14(%ebp)
    290c:	db 5d e8             	fistpl -0x18(%ebp)
    290f:	d9 6d ee             	fldcw  -0x12(%ebp)
    2912:	8b 55 e8             	mov    -0x18(%ebp),%edx
    2915:	db 45 fc             	fildl  -0x4(%ebp)
    2918:	d8 4d f0             	fmuls  -0x10(%ebp)
    291b:	d9 6d ec             	fldcw  -0x14(%ebp)
    291e:	db 5d e8             	fistpl -0x18(%ebp)
    2921:	d9 6d ee             	fldcw  -0x12(%ebp)
    2924:	8b 45 e8             	mov    -0x18(%ebp),%eax
    2927:	6a 00                	push   $0x0
    2929:	52                   	push   %edx
    292a:	50                   	push   %eax
    292b:	ff 75 08             	pushl  0x8(%ebp)
    292e:	e8 10 f9 ff ff       	call   2243 <getColor>
    2933:	83 c4 10             	add    $0x10,%esp
    2936:	89 45 0c             	mov    %eax,0xc(%ebp)
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    {
        for (int x = 0; x < dst->width; x++)
    2939:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    293d:	8b 45 0c             	mov    0xc(%ebp),%eax
    2940:	8b 00                	mov    (%eax),%eax
    2942:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    2945:	7f af                	jg     28f6 <picFastScale+0x50>
int picFastScale(PBitmap *src, PBitmap *dst)
{
    float xScale = (float)src->width / (float)dst->width;
    float yScale = (float)src->height / (float)dst->height;

    for (int y = 0; y < dst->height; y++)
    2947:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    294b:	8b 45 0c             	mov    0xc(%ebp),%eax
    294e:	8b 40 04             	mov    0x4(%eax),%eax
    2951:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    2954:	7f 97                	jg     28ed <picFastScale+0x47>
        {
            // mixColor(src, (float)(y + 0.49999) * yScale - 0.5, (float)(x + 0.49999) * xScale - 0.5, (dst->data + y * dst->width + x));
            dst = getColor(src, (int)(y*yScale), (int)(x*xScale), 0);
        }
    }
    return 1;
    2956:	b8 01 00 00 00       	mov    $0x1,%eax
}
    295b:	c9                   	leave  
    295c:	c3                   	ret    

0000295d <getTurnSize>:

int getTurnSize(int *width, int *height, float angle)
{
    295d:	55                   	push   %ebp
    295e:	89 e5                	mov    %esp,%ebp
    2960:	83 ec 28             	sub    $0x28,%esp
    int w = (int)(*width * abs(cos(angle)) + *height * abs(sin(angle)));
    2963:	8b 45 08             	mov    0x8(%ebp),%eax
    2966:	8b 00                	mov    (%eax),%eax
    2968:	89 45 e0             	mov    %eax,-0x20(%ebp)
    296b:	db 45 e0             	fildl  -0x20(%ebp)
    296e:	d9 5d e0             	fstps  -0x20(%ebp)
    2971:	83 ec 0c             	sub    $0xc,%esp
    2974:	ff 75 10             	pushl  0x10(%ebp)
    2977:	e8 6b e2 ff ff       	call   be7 <cos>
    297c:	83 c4 10             	add    $0x10,%esp
    297f:	d9 5d dc             	fstps  -0x24(%ebp)
    2982:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2985:	83 ec 0c             	sub    $0xc,%esp
    2988:	50                   	push   %eax
    2989:	e8 90 e1 ff ff       	call   b1e <abs>
    298e:	83 c4 10             	add    $0x10,%esp
    2991:	d8 4d e0             	fmuls  -0x20(%ebp)
    2994:	d9 5d e0             	fstps  -0x20(%ebp)
    2997:	8b 45 0c             	mov    0xc(%ebp),%eax
    299a:	8b 00                	mov    (%eax),%eax
    299c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    299f:	db 45 dc             	fildl  -0x24(%ebp)
    29a2:	d9 5d dc             	fstps  -0x24(%ebp)
    29a5:	83 ec 0c             	sub    $0xc,%esp
    29a8:	ff 75 10             	pushl  0x10(%ebp)
    29ab:	e8 da e3 ff ff       	call   d8a <sin>
    29b0:	83 c4 10             	add    $0x10,%esp
    29b3:	d9 5d d8             	fstps  -0x28(%ebp)
    29b6:	8b 45 d8             	mov    -0x28(%ebp),%eax
    29b9:	83 ec 0c             	sub    $0xc,%esp
    29bc:	50                   	push   %eax
    29bd:	e8 5c e1 ff ff       	call   b1e <abs>
    29c2:	83 c4 10             	add    $0x10,%esp
    29c5:	d8 4d dc             	fmuls  -0x24(%ebp)
    29c8:	d8 45 e0             	fadds  -0x20(%ebp)
    29cb:	d9 7d e6             	fnstcw -0x1a(%ebp)
    29ce:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    29d2:	b4 0c                	mov    $0xc,%ah
    29d4:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    29d8:	d9 6d e4             	fldcw  -0x1c(%ebp)
    29db:	db 5d f4             	fistpl -0xc(%ebp)
    29de:	d9 6d e6             	fldcw  -0x1a(%ebp)
    int h = (int)(*width * abs(sin(angle)) + *height * abs(cos(angle)));
    29e1:	8b 45 08             	mov    0x8(%ebp),%eax
    29e4:	8b 00                	mov    (%eax),%eax
    29e6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    29e9:	db 45 e0             	fildl  -0x20(%ebp)
    29ec:	d9 5d e0             	fstps  -0x20(%ebp)
    29ef:	83 ec 0c             	sub    $0xc,%esp
    29f2:	ff 75 10             	pushl  0x10(%ebp)
    29f5:	e8 90 e3 ff ff       	call   d8a <sin>
    29fa:	83 c4 10             	add    $0x10,%esp
    29fd:	d9 5d dc             	fstps  -0x24(%ebp)
    2a00:	8b 45 dc             	mov    -0x24(%ebp),%eax
    2a03:	83 ec 0c             	sub    $0xc,%esp
    2a06:	50                   	push   %eax
    2a07:	e8 12 e1 ff ff       	call   b1e <abs>
    2a0c:	83 c4 10             	add    $0x10,%esp
    2a0f:	d8 4d e0             	fmuls  -0x20(%ebp)
    2a12:	d9 5d e0             	fstps  -0x20(%ebp)
    2a15:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a18:	8b 00                	mov    (%eax),%eax
    2a1a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    2a1d:	db 45 dc             	fildl  -0x24(%ebp)
    2a20:	d9 5d dc             	fstps  -0x24(%ebp)
    2a23:	83 ec 0c             	sub    $0xc,%esp
    2a26:	ff 75 10             	pushl  0x10(%ebp)
    2a29:	e8 b9 e1 ff ff       	call   be7 <cos>
    2a2e:	83 c4 10             	add    $0x10,%esp
    2a31:	d9 5d d8             	fstps  -0x28(%ebp)
    2a34:	8b 45 d8             	mov    -0x28(%ebp),%eax
    2a37:	83 ec 0c             	sub    $0xc,%esp
    2a3a:	50                   	push   %eax
    2a3b:	e8 de e0 ff ff       	call   b1e <abs>
    2a40:	83 c4 10             	add    $0x10,%esp
    2a43:	d8 4d dc             	fmuls  -0x24(%ebp)
    2a46:	d8 45 e0             	fadds  -0x20(%ebp)
    2a49:	d9 7d e6             	fnstcw -0x1a(%ebp)
    2a4c:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
    2a50:	b4 0c                	mov    $0xc,%ah
    2a52:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    2a56:	d9 6d e4             	fldcw  -0x1c(%ebp)
    2a59:	db 5d f0             	fistpl -0x10(%ebp)
    2a5c:	d9 6d e6             	fldcw  -0x1a(%ebp)

    *height = h;
    2a5f:	8b 45 0c             	mov    0xc(%ebp),%eax
    2a62:	8b 55 f0             	mov    -0x10(%ebp),%edx
    2a65:	89 10                	mov    %edx,(%eax)
    *width = w;
    2a67:	8b 45 08             	mov    0x8(%ebp),%eax
    2a6a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    2a6d:	89 10                	mov    %edx,(%eax)
    return 1;
    2a6f:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2a74:	c9                   	leave  
    2a75:	c3                   	ret    

00002a76 <picTurn>:

int picTurn(PBitmap *src, PBitmap *dst, float angle)
{
    2a76:	55                   	push   %ebp
    2a77:	89 e5                	mov    %esp,%ebp
    2a79:	83 ec 48             	sub    $0x48,%esp

    // 以中心为旋转中心，要找到目标图中的旋转中心
    const float my = (float)src->height / 2;
    2a7c:	8b 45 08             	mov    0x8(%ebp),%eax
    2a7f:	8b 40 04             	mov    0x4(%eax),%eax
    2a82:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2a85:	db 45 c4             	fildl  -0x3c(%ebp)
    2a88:	d9 05 64 9f 01 00    	flds   0x19f64
    2a8e:	de f9                	fdivrp %st,%st(1)
    2a90:	d9 5d ec             	fstps  -0x14(%ebp)
    const float mx = (float)src->width / 2;
    2a93:	8b 45 08             	mov    0x8(%ebp),%eax
    2a96:	8b 00                	mov    (%eax),%eax
    2a98:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2a9b:	db 45 c4             	fildl  -0x3c(%ebp)
    2a9e:	d9 05 64 9f 01 00    	flds   0x19f64
    2aa4:	de f9                	fdivrp %st,%st(1)
    2aa6:	d9 5d e8             	fstps  -0x18(%ebp)

    const float dy = (float)(dst->height - src->height) / 2;
    2aa9:	8b 45 0c             	mov    0xc(%ebp),%eax
    2aac:	8b 50 04             	mov    0x4(%eax),%edx
    2aaf:	8b 45 08             	mov    0x8(%ebp),%eax
    2ab2:	8b 40 04             	mov    0x4(%eax),%eax
    2ab5:	29 c2                	sub    %eax,%edx
    2ab7:	89 d0                	mov    %edx,%eax
    2ab9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2abc:	db 45 c4             	fildl  -0x3c(%ebp)
    2abf:	d9 05 64 9f 01 00    	flds   0x19f64
    2ac5:	de f9                	fdivrp %st,%st(1)
    2ac7:	d9 5d e4             	fstps  -0x1c(%ebp)
    const float dx = (float)(dst->width - src->width) / 2;
    2aca:	8b 45 0c             	mov    0xc(%ebp),%eax
    2acd:	8b 10                	mov    (%eax),%edx
    2acf:	8b 45 08             	mov    0x8(%ebp),%eax
    2ad2:	8b 00                	mov    (%eax),%eax
    2ad4:	29 c2                	sub    %eax,%edx
    2ad6:	89 d0                	mov    %edx,%eax
    2ad8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2adb:	db 45 c4             	fildl  -0x3c(%ebp)
    2ade:	d9 05 64 9f 01 00    	flds   0x19f64
    2ae4:	de f9                	fdivrp %st,%st(1)
    2ae6:	d9 5d e0             	fstps  -0x20(%ebp)

    const float COSX = cos(-angle);
    2ae9:	d9 45 10             	flds   0x10(%ebp)
    2aec:	d9 e0                	fchs   
    2aee:	83 ec 0c             	sub    $0xc,%esp
    2af1:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2af5:	d9 1c 24             	fstps  (%esp)
    2af8:	e8 ea e0 ff ff       	call   be7 <cos>
    2afd:	83 c4 10             	add    $0x10,%esp
    2b00:	d9 5d c4             	fstps  -0x3c(%ebp)
    2b03:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2b06:	89 45 dc             	mov    %eax,-0x24(%ebp)
    const float SINX = sin(-angle);
    2b09:	d9 45 10             	flds   0x10(%ebp)
    2b0c:	d9 e0                	fchs   
    2b0e:	83 ec 0c             	sub    $0xc,%esp
    2b11:	8d 64 24 fc          	lea    -0x4(%esp),%esp
    2b15:	d9 1c 24             	fstps  (%esp)
    2b18:	e8 6d e2 ff ff       	call   d8a <sin>
    2b1d:	83 c4 10             	add    $0x10,%esp
    2b20:	d9 5d c4             	fstps  -0x3c(%ebp)
    2b23:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    2b26:	89 45 d8             	mov    %eax,-0x28(%ebp)

    float srcI = 0;
    2b29:	d9 ee                	fldz   
    2b2b:	d9 5d d4             	fstps  -0x2c(%ebp)
    float srcJ = 0;
    2b2e:	d9 ee                	fldz   
    2b30:	d9 5d d0             	fstps  -0x30(%ebp)

    for (int i = 0; i < dst->height; i++)
    2b33:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2b3a:	e9 28 01 00 00       	jmp    2c67 <picTurn+0x1f1>
    {
        for (int j = 0; j < dst->width; j++)
    2b3f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    2b46:	e9 0a 01 00 00       	jmp    2c55 <picTurn+0x1df>
        {
            srcI = ((float)i - dy - my) * COSX + ((float)j - dx - mx) * SINX + my;
    2b4b:	db 45 f4             	fildl  -0xc(%ebp)
    2b4e:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2b51:	d8 65 ec             	fsubs  -0x14(%ebp)
    2b54:	d8 4d dc             	fmuls  -0x24(%ebp)
    2b57:	db 45 f0             	fildl  -0x10(%ebp)
    2b5a:	d8 65 e0             	fsubs  -0x20(%ebp)
    2b5d:	d8 65 e8             	fsubs  -0x18(%ebp)
    2b60:	d8 4d d8             	fmuls  -0x28(%ebp)
    2b63:	de c1                	faddp  %st,%st(1)
    2b65:	d8 45 ec             	fadds  -0x14(%ebp)
    2b68:	d9 5d d4             	fstps  -0x2c(%ebp)
            srcJ = ((float)j - dx - mx) * COSX - ((float)i - dy - my) * SINX + mx;
    2b6b:	db 45 f0             	fildl  -0x10(%ebp)
    2b6e:	d8 65 e0             	fsubs  -0x20(%ebp)
    2b71:	d8 65 e8             	fsubs  -0x18(%ebp)
    2b74:	d8 4d dc             	fmuls  -0x24(%ebp)
    2b77:	db 45 f4             	fildl  -0xc(%ebp)
    2b7a:	d8 65 e4             	fsubs  -0x1c(%ebp)
    2b7d:	d8 65 ec             	fsubs  -0x14(%ebp)
    2b80:	d8 4d d8             	fmuls  -0x28(%ebp)
    2b83:	de e9                	fsubrp %st,%st(1)
    2b85:	d8 45 e8             	fadds  -0x18(%ebp)
    2b88:	d9 5d d0             	fstps  -0x30(%ebp)
            if (!(srcI >= 0 && srcI < src->height && srcJ >= 0 && srcJ < src->width))
    2b8b:	d9 45 d4             	flds   -0x2c(%ebp)
    2b8e:	d9 ee                	fldz   
    2b90:	d9 c9                	fxch   %st(1)
    2b92:	df e9                	fucomip %st(1),%st
    2b94:	dd d8                	fstp   %st(0)
    2b96:	0f 93 c0             	setae  %al
    2b99:	83 f0 01             	xor    $0x1,%eax
    2b9c:	84 c0                	test   %al,%al
    2b9e:	75 52                	jne    2bf2 <picTurn+0x17c>
    2ba0:	8b 45 08             	mov    0x8(%ebp),%eax
    2ba3:	8b 40 04             	mov    0x4(%eax),%eax
    2ba6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2ba9:	db 45 c4             	fildl  -0x3c(%ebp)
    2bac:	d9 45 d4             	flds   -0x2c(%ebp)
    2baf:	d9 c9                	fxch   %st(1)
    2bb1:	df e9                	fucomip %st(1),%st
    2bb3:	dd d8                	fstp   %st(0)
    2bb5:	0f 97 c0             	seta   %al
    2bb8:	83 f0 01             	xor    $0x1,%eax
    2bbb:	84 c0                	test   %al,%al
    2bbd:	75 33                	jne    2bf2 <picTurn+0x17c>
    2bbf:	d9 45 d0             	flds   -0x30(%ebp)
    2bc2:	d9 ee                	fldz   
    2bc4:	d9 c9                	fxch   %st(1)
    2bc6:	df e9                	fucomip %st(1),%st
    2bc8:	dd d8                	fstp   %st(0)
    2bca:	0f 93 c0             	setae  %al
    2bcd:	83 f0 01             	xor    $0x1,%eax
    2bd0:	84 c0                	test   %al,%al
    2bd2:	75 1e                	jne    2bf2 <picTurn+0x17c>
    2bd4:	8b 45 08             	mov    0x8(%ebp),%eax
    2bd7:	8b 00                	mov    (%eax),%eax
    2bd9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    2bdc:	db 45 c4             	fildl  -0x3c(%ebp)
    2bdf:	d9 45 d0             	flds   -0x30(%ebp)
    2be2:	d9 c9                	fxch   %st(1)
    2be4:	df e9                	fucomip %st(1),%st
    2be6:	dd d8                	fstp   %st(0)
    2be8:	0f 97 c0             	seta   %al
    2beb:	83 f0 01             	xor    $0x1,%eax
    2bee:	84 c0                	test   %al,%al
    2bf0:	74 2f                	je     2c21 <picTurn+0x1ab>
            {
                setColor(&whiteRGB, (dst->data + i * dst->width + j));
    2bf2:	8b 45 0c             	mov    0xc(%ebp),%eax
    2bf5:	8b 48 08             	mov    0x8(%eax),%ecx
    2bf8:	8b 45 0c             	mov    0xc(%ebp),%eax
    2bfb:	8b 00                	mov    (%eax),%eax
    2bfd:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2c01:	89 c2                	mov    %eax,%edx
    2c03:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2c06:	01 c2                	add    %eax,%edx
    2c08:	89 d0                	mov    %edx,%eax
    2c0a:	01 c0                	add    %eax,%eax
    2c0c:	01 d0                	add    %edx,%eax
    2c0e:	01 c8                	add    %ecx,%eax
    2c10:	83 ec 08             	sub    $0x8,%esp
    2c13:	50                   	push   %eax
    2c14:	68 31 e4 01 00       	push   $0x1e431
    2c19:	e8 9f f6 ff ff       	call   22bd <setColor>
    2c1e:	83 c4 10             	add    $0x10,%esp
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
    2c21:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c24:	8b 48 08             	mov    0x8(%eax),%ecx
    2c27:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c2a:	8b 00                	mov    (%eax),%eax
    2c2c:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    2c30:	89 c2                	mov    %eax,%edx
    2c32:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2c35:	01 c2                	add    %eax,%edx
    2c37:	89 d0                	mov    %edx,%eax
    2c39:	01 c0                	add    %eax,%eax
    2c3b:	01 d0                	add    %edx,%eax
    2c3d:	01 c8                	add    %ecx,%eax
    2c3f:	50                   	push   %eax
    2c40:	ff 75 d0             	pushl  -0x30(%ebp)
    2c43:	ff 75 d4             	pushl  -0x2c(%ebp)
    2c46:	ff 75 08             	pushl  0x8(%ebp)
    2c49:	e8 9e f6 ff ff       	call   22ec <mixColor>
    2c4e:	83 c4 10             	add    $0x10,%esp
    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    {
        for (int j = 0; j < dst->width; j++)
    2c51:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    2c55:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c58:	8b 00                	mov    (%eax),%eax
    2c5a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2c5d:	0f 8f e8 fe ff ff    	jg     2b4b <picTurn+0xd5>
    const float SINX = sin(-angle);

    float srcI = 0;
    float srcJ = 0;

    for (int i = 0; i < dst->height; i++)
    2c63:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2c67:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c6a:	8b 40 04             	mov    0x4(%eax),%eax
    2c6d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    2c70:	0f 8f c9 fe ff ff    	jg     2b3f <picTurn+0xc9>
            }
            mixColor(src, srcI, srcJ, (dst->data + i * dst->width + j));
        }
    }

    return 1;
    2c76:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2c7b:	c9                   	leave  
    2c7c:	c3                   	ret    

00002c7d <picRollingOver>:

// （上下）翻转
int picRollingOver(PBitmap *src, PBitmap *dst)
{
    2c7d:	55                   	push   %ebp
    2c7e:	89 e5                	mov    %esp,%ebp
    2c80:	53                   	push   %ebx
    2c81:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2c84:	8b 45 08             	mov    0x8(%ebp),%eax
    2c87:	8b 10                	mov    (%eax),%edx
    2c89:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c8c:	8b 00                	mov    (%eax),%eax
    2c8e:	39 c2                	cmp    %eax,%edx
    2c90:	75 10                	jne    2ca2 <picRollingOver+0x25>
    2c92:	8b 45 08             	mov    0x8(%ebp),%eax
    2c95:	8b 50 04             	mov    0x4(%eax),%edx
    2c98:	8b 45 0c             	mov    0xc(%ebp),%eax
    2c9b:	8b 40 04             	mov    0x4(%eax),%eax
    2c9e:	39 c2                	cmp    %eax,%edx
    2ca0:	74 0a                	je     2cac <picRollingOver+0x2f>
        return 0;
    2ca2:	b8 00 00 00 00       	mov    $0x0,%eax
    2ca7:	e9 88 00 00 00       	jmp    2d34 <picRollingOver+0xb7>

    int h = src->height;
    2cac:	8b 45 08             	mov    0x8(%ebp),%eax
    2caf:	8b 40 04             	mov    0x4(%eax),%eax
    2cb2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2cb5:	8b 45 08             	mov    0x8(%ebp),%eax
    2cb8:	8b 00                	mov    (%eax),%eax
    2cba:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2cbd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2cc4:	eb 61                	jmp    2d27 <picRollingOver+0xaa>
    {
        for (int j = 0; j < w; j++)
    2cc6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2ccd:	eb 4c                	jmp    2d1b <picRollingOver+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
    2ccf:	8b 45 0c             	mov    0xc(%ebp),%eax
    2cd2:	8b 48 08             	mov    0x8(%eax),%ecx
    2cd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    2cd8:	2b 45 f8             	sub    -0x8(%ebp),%eax
    2cdb:	83 e8 01             	sub    $0x1,%eax
    2cde:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2ce2:	89 c2                	mov    %eax,%edx
    2ce4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ce7:	01 c2                	add    %eax,%edx
    2ce9:	89 d0                	mov    %edx,%eax
    2ceb:	01 c0                	add    %eax,%eax
    2ced:	01 d0                	add    %edx,%eax
    2cef:	01 c1                	add    %eax,%ecx
    2cf1:	8b 45 08             	mov    0x8(%ebp),%eax
    2cf4:	8b 58 08             	mov    0x8(%eax),%ebx
    2cf7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2cfa:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2cfe:	89 c2                	mov    %eax,%edx
    2d00:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2d03:	01 c2                	add    %eax,%edx
    2d05:	89 d0                	mov    %edx,%eax
    2d07:	01 c0                	add    %eax,%eax
    2d09:	01 d0                	add    %edx,%eax
    2d0b:	01 d8                	add    %ebx,%eax
    2d0d:	51                   	push   %ecx
    2d0e:	50                   	push   %eax
    2d0f:	e8 a9 f5 ff ff       	call   22bd <setColor>
    2d14:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2d17:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2d1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2d1e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2d21:	7c ac                	jl     2ccf <picRollingOver+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2d23:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2d27:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2d2a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2d2d:	7c 97                	jl     2cc6 <picRollingOver+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + (h - i - 1) * w + j));
        }
    }

    return 1;
    2d2f:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2d34:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2d37:	c9                   	leave  
    2d38:	c3                   	ret    

00002d39 <picTurnAround>:

int picTurnAround(PBitmap *src, PBitmap *dst)
{
    2d39:	55                   	push   %ebp
    2d3a:	89 e5                	mov    %esp,%ebp
    2d3c:	53                   	push   %ebx
    2d3d:	83 ec 10             	sub    $0x10,%esp
    // 如果原图与目标图尺寸不一样，则返回 0；
    if (src->width != dst->width || src->height != dst->height)
    2d40:	8b 45 08             	mov    0x8(%ebp),%eax
    2d43:	8b 10                	mov    (%eax),%edx
    2d45:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d48:	8b 00                	mov    (%eax),%eax
    2d4a:	39 c2                	cmp    %eax,%edx
    2d4c:	75 10                	jne    2d5e <picTurnAround+0x25>
    2d4e:	8b 45 08             	mov    0x8(%ebp),%eax
    2d51:	8b 50 04             	mov    0x4(%eax),%edx
    2d54:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d57:	8b 40 04             	mov    0x4(%eax),%eax
    2d5a:	39 c2                	cmp    %eax,%edx
    2d5c:	74 0a                	je     2d68 <picTurnAround+0x2f>
        return 0;
    2d5e:	b8 00 00 00 00       	mov    $0x0,%eax
    2d63:	e9 88 00 00 00       	jmp    2df0 <picTurnAround+0xb7>

    int h = src->height;
    2d68:	8b 45 08             	mov    0x8(%ebp),%eax
    2d6b:	8b 40 04             	mov    0x4(%eax),%eax
    2d6e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int w = src->width;
    2d71:	8b 45 08             	mov    0x8(%ebp),%eax
    2d74:	8b 00                	mov    (%eax),%eax
    2d76:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < h; i++)
    2d79:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    2d80:	eb 61                	jmp    2de3 <picTurnAround+0xaa>
    {
        for (int j = 0; j < w; j++)
    2d82:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    2d89:	eb 4c                	jmp    2dd7 <picTurnAround+0x9e>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
    2d8b:	8b 45 0c             	mov    0xc(%ebp),%eax
    2d8e:	8b 48 08             	mov    0x8(%eax),%ecx
    2d91:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2d94:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2d98:	89 c2                	mov    %eax,%edx
    2d9a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    2d9d:	2b 45 f4             	sub    -0xc(%ebp),%eax
    2da0:	01 c2                	add    %eax,%edx
    2da2:	89 d0                	mov    %edx,%eax
    2da4:	01 c0                	add    %eax,%eax
    2da6:	01 d0                	add    %edx,%eax
    2da8:	83 e8 03             	sub    $0x3,%eax
    2dab:	01 c1                	add    %eax,%ecx
    2dad:	8b 45 08             	mov    0x8(%ebp),%eax
    2db0:	8b 58 08             	mov    0x8(%eax),%ebx
    2db3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2db6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    2dba:	89 c2                	mov    %eax,%edx
    2dbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2dbf:	01 c2                	add    %eax,%edx
    2dc1:	89 d0                	mov    %edx,%eax
    2dc3:	01 c0                	add    %eax,%eax
    2dc5:	01 d0                	add    %edx,%eax
    2dc7:	01 d8                	add    %ebx,%eax
    2dc9:	51                   	push   %ecx
    2dca:	50                   	push   %eax
    2dcb:	e8 ed f4 ff ff       	call   22bd <setColor>
    2dd0:	83 c4 08             	add    $0x8,%esp
    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    {
        for (int j = 0; j < w; j++)
    2dd3:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    2dd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2dda:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    2ddd:	7c ac                	jl     2d8b <picTurnAround+0x52>
        return 0;

    int h = src->height;
    int w = src->width;

    for (int i = 0; i < h; i++)
    2ddf:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    2de3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    2de6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    2de9:	7c 97                	jl     2d82 <picTurnAround+0x49>
        {
            setColor((src->data + i * w + j), (dst->data + i * w + (w - j - 1)));
        }
    }

    return 1;
    2deb:	b8 01 00 00 00       	mov    $0x1,%eax
}
    2df0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    2df3:	c9                   	leave  
    2df4:	c3                   	ret    

00002df5 <type>:
#include "loader.h"
#include "fcntl.h"
#include "loadjpeg.h"
#include "loadpng.h"

int type(char* filename){
    2df5:	55                   	push   %ebp
    2df6:	89 e5                	mov    %esp,%ebp
    2df8:	83 ec 18             	sub    $0x18,%esp
    int len=strlen(filename);
    2dfb:	83 ec 0c             	sub    $0xc,%esp
    2dfe:	ff 75 08             	pushl  0x8(%ebp)
    2e01:	e8 c5 d5 ff ff       	call   3cb <strlen>
    2e06:	83 c4 10             	add    $0x10,%esp
    2e09:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filename[len-1]=='g'&&filename[len-2]=='p'&&filename[len-3]=='j') return JPG;
    2e0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e0f:	8d 50 ff             	lea    -0x1(%eax),%edx
    2e12:	8b 45 08             	mov    0x8(%ebp),%eax
    2e15:	01 d0                	add    %edx,%eax
    2e17:	0f b6 00             	movzbl (%eax),%eax
    2e1a:	3c 67                	cmp    $0x67,%al
    2e1c:	75 2b                	jne    2e49 <type+0x54>
    2e1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e21:	8d 50 fe             	lea    -0x2(%eax),%edx
    2e24:	8b 45 08             	mov    0x8(%ebp),%eax
    2e27:	01 d0                	add    %edx,%eax
    2e29:	0f b6 00             	movzbl (%eax),%eax
    2e2c:	3c 70                	cmp    $0x70,%al
    2e2e:	75 19                	jne    2e49 <type+0x54>
    2e30:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e33:	8d 50 fd             	lea    -0x3(%eax),%edx
    2e36:	8b 45 08             	mov    0x8(%ebp),%eax
    2e39:	01 d0                	add    %edx,%eax
    2e3b:	0f b6 00             	movzbl (%eax),%eax
    2e3e:	3c 6a                	cmp    $0x6a,%al
    2e40:	75 07                	jne    2e49 <type+0x54>
    2e42:	b8 00 00 00 00       	mov    $0x0,%eax
    2e47:	eb 7f                	jmp    2ec8 <type+0xd3>
    if(filename[len-1]=='p'&&filename[len-2]=='m'&&filename[len-3]=='b') return BMP;
    2e49:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e4c:	8d 50 ff             	lea    -0x1(%eax),%edx
    2e4f:	8b 45 08             	mov    0x8(%ebp),%eax
    2e52:	01 d0                	add    %edx,%eax
    2e54:	0f b6 00             	movzbl (%eax),%eax
    2e57:	3c 70                	cmp    $0x70,%al
    2e59:	75 2b                	jne    2e86 <type+0x91>
    2e5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e5e:	8d 50 fe             	lea    -0x2(%eax),%edx
    2e61:	8b 45 08             	mov    0x8(%ebp),%eax
    2e64:	01 d0                	add    %edx,%eax
    2e66:	0f b6 00             	movzbl (%eax),%eax
    2e69:	3c 6d                	cmp    $0x6d,%al
    2e6b:	75 19                	jne    2e86 <type+0x91>
    2e6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e70:	8d 50 fd             	lea    -0x3(%eax),%edx
    2e73:	8b 45 08             	mov    0x8(%ebp),%eax
    2e76:	01 d0                	add    %edx,%eax
    2e78:	0f b6 00             	movzbl (%eax),%eax
    2e7b:	3c 62                	cmp    $0x62,%al
    2e7d:	75 07                	jne    2e86 <type+0x91>
    2e7f:	b8 01 00 00 00       	mov    $0x1,%eax
    2e84:	eb 42                	jmp    2ec8 <type+0xd3>
    if(filename[len-1]=='g'&&filename[len-2]=='n'&&filename[len-3]=='p') return PNG;
    2e86:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e89:	8d 50 ff             	lea    -0x1(%eax),%edx
    2e8c:	8b 45 08             	mov    0x8(%ebp),%eax
    2e8f:	01 d0                	add    %edx,%eax
    2e91:	0f b6 00             	movzbl (%eax),%eax
    2e94:	3c 67                	cmp    $0x67,%al
    2e96:	75 2b                	jne    2ec3 <type+0xce>
    2e98:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2e9b:	8d 50 fe             	lea    -0x2(%eax),%edx
    2e9e:	8b 45 08             	mov    0x8(%ebp),%eax
    2ea1:	01 d0                	add    %edx,%eax
    2ea3:	0f b6 00             	movzbl (%eax),%eax
    2ea6:	3c 6e                	cmp    $0x6e,%al
    2ea8:	75 19                	jne    2ec3 <type+0xce>
    2eaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
    2ead:	8d 50 fd             	lea    -0x3(%eax),%edx
    2eb0:	8b 45 08             	mov    0x8(%ebp),%eax
    2eb3:	01 d0                	add    %edx,%eax
    2eb5:	0f b6 00             	movzbl (%eax),%eax
    2eb8:	3c 70                	cmp    $0x70,%al
    2eba:	75 07                	jne    2ec3 <type+0xce>
    2ebc:	b8 02 00 00 00       	mov    $0x2,%eax
    2ec1:	eb 05                	jmp    2ec8 <type+0xd3>
    else return NONE;
    2ec3:	b8 03 00 00 00       	mov    $0x3,%eax
}
    2ec8:	c9                   	leave  
    2ec9:	c3                   	ret    

00002eca <LoadBmp>:

PBitmap LoadBmp(char* filename){
    2eca:	55                   	push   %ebp
    2ecb:	89 e5                	mov    %esp,%ebp
    2ecd:	56                   	push   %esi
    2ece:	53                   	push   %ebx
    2ecf:	83 c4 80             	add    $0xffffff80,%esp
    PBitmap bmp = {0, 0, 0};
    2ed2:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
    2ed9:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    2ee0:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    int fd;
    if((fd = open(filename, O_RDONLY)) < 0){
    2ee7:	83 ec 08             	sub    $0x8,%esp
    2eea:	6a 00                	push   $0x0
    2eec:	ff 75 0c             	pushl  0xc(%ebp)
    2eef:	e8 d9 d6 ff ff       	call   5cd <open>
    2ef4:	83 c4 10             	add    $0x10,%esp
    2ef7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    2efa:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    2efe:	79 2c                	jns    2f2c <LoadBmp+0x62>
        printf("Can't open %s\n", filename);
    2f00:	83 ec 08             	sub    $0x8,%esp
    2f03:	ff 75 0c             	pushl  0xc(%ebp)
    2f06:	68 68 9f 01 00       	push   $0x19f68
    2f0b:	e8 24 d8 ff ff       	call   734 <printf>
    2f10:	83 c4 10             	add    $0x10,%esp
        return bmp;
    2f13:	8b 45 08             	mov    0x8(%ebp),%eax
    2f16:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2f19:	89 10                	mov    %edx,(%eax)
    2f1b:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2f1e:	89 50 04             	mov    %edx,0x4(%eax)
    2f21:	8b 55 c0             	mov    -0x40(%ebp),%edx
    2f24:	89 50 08             	mov    %edx,0x8(%eax)
    2f27:	e9 2d 02 00 00       	jmp    3159 <LoadBmp+0x28f>
    }
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    2f2c:	83 ec 04             	sub    $0x4,%esp
    2f2f:	6a 0e                	push   $0xe
    2f31:	8d 45 aa             	lea    -0x56(%ebp),%eax
    2f34:	50                   	push   %eax
    2f35:	ff 75 ec             	pushl  -0x14(%ebp)
    2f38:	e8 68 d6 ff ff       	call   5a5 <read>
    2f3d:	83 c4 10             	add    $0x10,%esp
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    2f40:	83 ec 04             	sub    $0x4,%esp
    2f43:	6a 28                	push   $0x28
    2f45:	8d 45 82             	lea    -0x7e(%ebp),%eax
    2f48:	50                   	push   %eax
    2f49:	ff 75 ec             	pushl  -0x14(%ebp)
    2f4c:	e8 54 d6 ff ff       	call   5a5 <read>
    2f51:	83 c4 10             	add    $0x10,%esp
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2f54:	0f b7 45 b2          	movzwl -0x4e(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2f58:	0f b7 f0             	movzwl %ax,%esi
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    2f5b:	0f b7 45 b0          	movzwl -0x50(%ebp),%eax
    PBitmapFileHeader fileHeader;
    read(fd, (char*)&fileHeader, sizeof(fileHeader));
    
    PBitmapInfoHeader infoHeader;
    read(fd, (char*)&infoHeader, sizeof(infoHeader));
    printf("\n info: %x %d %d %d %d, totalsize %d\n", fileHeader.bfType, fileHeader.bfSize,
    2f5f:	0f b7 d8             	movzwl %ax,%ebx
    2f62:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
    2f65:	8b 55 ac             	mov    -0x54(%ebp),%edx
    2f68:	0f b7 45 aa          	movzwl -0x56(%ebp),%eax
    2f6c:	0f b7 c0             	movzwl %ax,%eax
    2f6f:	83 ec 04             	sub    $0x4,%esp
    2f72:	6a 36                	push   $0x36
    2f74:	56                   	push   %esi
    2f75:	53                   	push   %ebx
    2f76:	51                   	push   %ecx
    2f77:	52                   	push   %edx
    2f78:	50                   	push   %eax
    2f79:	68 78 9f 01 00       	push   $0x19f78
    2f7e:	e8 b1 d7 ff ff       	call   734 <printf>
    2f83:	83 c4 20             	add    $0x20,%esp
    fileHeader.bfOffBits, fileHeader.bfReserved1, fileHeader.bfReserved2,sizeof(fileHeader)+sizeof(infoHeader));
    
    bmp.width = infoHeader.biWidth;
    2f86:	8b 45 86             	mov    -0x7a(%ebp),%eax
    2f89:	89 45 b8             	mov    %eax,-0x48(%ebp)
    bmp.height = infoHeader.biHeight;
    2f8c:	8b 45 8a             	mov    -0x76(%ebp),%eax
    2f8f:	89 45 bc             	mov    %eax,-0x44(%ebp)
    bmp.data = (RGB*)malloc(bmp.width * bmp.height * sizeof(RGB));
    2f92:	8b 55 b8             	mov    -0x48(%ebp),%edx
    2f95:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2f98:	0f af c2             	imul   %edx,%eax
    2f9b:	89 c2                	mov    %eax,%edx
    2f9d:	89 d0                	mov    %edx,%eax
    2f9f:	01 c0                	add    %eax,%eax
    2fa1:	01 d0                	add    %edx,%eax
    2fa3:	83 ec 0c             	sub    $0xc,%esp
    2fa6:	50                   	push   %eax
    2fa7:	e8 5b da ff ff       	call   a07 <malloc>
    2fac:	83 c4 10             	add    $0x10,%esp
    2faf:	89 45 c0             	mov    %eax,-0x40(%ebp)
    
    int count = infoHeader.biBitCount;
    2fb2:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    2fb6:	0f b7 c0             	movzwl %ax,%eax
    2fb9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    int length = (((bmp.width * count) + 31) >> 5) << 2;
    2fbc:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2fbf:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    2fc3:	83 c0 1f             	add    $0x1f,%eax
    2fc6:	c1 f8 05             	sar    $0x5,%eax
    2fc9:	c1 e0 02             	shl    $0x2,%eax
    2fcc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    int size = length * bmp.height;
    2fcf:	8b 45 bc             	mov    -0x44(%ebp),%eax
    2fd2:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    2fd6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    printf("load bitmap l: %d s: %d c: %d width: %d height: %d\n",length,size,count,bmp.width,bmp.height);
    2fd9:	8b 55 bc             	mov    -0x44(%ebp),%edx
    2fdc:	8b 45 b8             	mov    -0x48(%ebp),%eax
    2fdf:	83 ec 08             	sub    $0x8,%esp
    2fe2:	52                   	push   %edx
    2fe3:	50                   	push   %eax
    2fe4:	ff 75 e8             	pushl  -0x18(%ebp)
    2fe7:	ff 75 e0             	pushl  -0x20(%ebp)
    2fea:	ff 75 e4             	pushl  -0x1c(%ebp)
    2fed:	68 a0 9f 01 00       	push   $0x19fa0
    2ff2:	e8 3d d7 ff ff       	call   734 <printf>
    2ff7:	83 c4 20             	add    $0x20,%esp

    int wastedLen = fileHeader.bfOffBits - sizeof(fileHeader) - sizeof(infoHeader);
    2ffa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    2ffd:	83 e8 36             	sub    $0x36,%eax
    3000:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar* waste  = (uchar*)malloc(sizeof(uchar) * wastedLen);
    3003:	8b 45 dc             	mov    -0x24(%ebp),%eax
    3006:	83 ec 0c             	sub    $0xc,%esp
    3009:	50                   	push   %eax
    300a:	e8 f8 d9 ff ff       	call   a07 <malloc>
    300f:	83 c4 10             	add    $0x10,%esp
    3012:	89 45 d8             	mov    %eax,-0x28(%ebp)
    read(fd, (char*)waste, wastedLen);
    3015:	83 ec 04             	sub    $0x4,%esp
    3018:	ff 75 dc             	pushl  -0x24(%ebp)
    301b:	ff 75 d8             	pushl  -0x28(%ebp)
    301e:	ff 75 ec             	pushl  -0x14(%ebp)
    3021:	e8 7f d5 ff ff       	call   5a5 <read>
    3026:	83 c4 10             	add    $0x10,%esp

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    3029:	8b 45 ac             	mov    -0x54(%ebp),%eax
    302c:	83 ec 0c             	sub    $0xc,%esp
    302f:	50                   	push   %eax
    3030:	e8 d2 d9 ff ff       	call   a07 <malloc>
    3035:	83 c4 10             	add    $0x10,%esp
    3038:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);
    303b:	8b 45 ac             	mov    -0x54(%ebp),%eax
    303e:	83 ec 04             	sub    $0x4,%esp
    3041:	50                   	push   %eax
    3042:	ff 75 d4             	pushl  -0x2c(%ebp)
    3045:	ff 75 ec             	pushl  -0x14(%ebp)
    3048:	e8 58 d5 ff ff       	call   5a5 <read>
    304d:	83 c4 10             	add    $0x10,%esp

    int bits = infoHeader.biBitCount / 8;
    3050:	0f b7 45 90          	movzwl -0x70(%ebp),%eax
    3054:	66 c1 e8 03          	shr    $0x3,%ax
    3058:	0f b7 c0             	movzwl %ax,%eax
    305b:	89 45 d0             	mov    %eax,-0x30(%ebp)
    for(int j=0; j<bmp.height; ++j){
    305e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3065:	e9 c1 00 00 00       	jmp    312b <LoadBmp+0x261>
        int offset = (bmp.height - j - 1) * bmp.width;
    306a:	8b 45 bc             	mov    -0x44(%ebp),%eax
    306d:	2b 45 f4             	sub    -0xc(%ebp),%eax
    3070:	8d 50 ff             	lea    -0x1(%eax),%edx
    3073:	8b 45 b8             	mov    -0x48(%ebp),%eax
    3076:	0f af c2             	imul   %edx,%eax
    3079:	89 45 cc             	mov    %eax,-0x34(%ebp)
        int dataOffset = j * length;
    307c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    307f:	0f af 45 e4          	imul   -0x1c(%ebp),%eax
    3083:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(int i=0; i<bmp.width; ++i){
    3086:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    308d:	e9 89 00 00 00       	jmp    311b <LoadBmp+0x251>
            int specOffset = dataOffset + bits * (i + 1);
    3092:	8b 45 f0             	mov    -0x10(%ebp),%eax
    3095:	83 c0 01             	add    $0x1,%eax
    3098:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    309c:	89 c2                	mov    %eax,%edx
    309e:	8b 45 c8             	mov    -0x38(%ebp),%eax
    30a1:	01 d0                	add    %edx,%eax
    30a3:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            bmp.data[offset+i].R = (int)data[specOffset - 1];
    30a6:	8b 55 c0             	mov    -0x40(%ebp),%edx
    30a9:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    30ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
    30af:	01 c8                	add    %ecx,%eax
    30b1:	89 c1                	mov    %eax,%ecx
    30b3:	89 c8                	mov    %ecx,%eax
    30b5:	01 c0                	add    %eax,%eax
    30b7:	01 c8                	add    %ecx,%eax
    30b9:	01 c2                	add    %eax,%edx
    30bb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    30be:	8d 48 ff             	lea    -0x1(%eax),%ecx
    30c1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    30c4:	01 c8                	add    %ecx,%eax
    30c6:	0f b6 00             	movzbl (%eax),%eax
    30c9:	88 42 02             	mov    %al,0x2(%edx)
            bmp.data[offset+i].G = (int)data[specOffset - 2];
    30cc:	8b 55 c0             	mov    -0x40(%ebp),%edx
    30cf:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    30d2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    30d5:	01 c8                	add    %ecx,%eax
    30d7:	89 c1                	mov    %eax,%ecx
    30d9:	89 c8                	mov    %ecx,%eax
    30db:	01 c0                	add    %eax,%eax
    30dd:	01 c8                	add    %ecx,%eax
    30df:	01 c2                	add    %eax,%edx
    30e1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    30e4:	8d 48 fe             	lea    -0x2(%eax),%ecx
    30e7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    30ea:	01 c8                	add    %ecx,%eax
    30ec:	0f b6 00             	movzbl (%eax),%eax
    30ef:	88 42 01             	mov    %al,0x1(%edx)
            bmp.data[offset+i].B = (int)data[specOffset - 3];
    30f2:	8b 55 c0             	mov    -0x40(%ebp),%edx
    30f5:	8b 4d cc             	mov    -0x34(%ebp),%ecx
    30f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
    30fb:	01 c8                	add    %ecx,%eax
    30fd:	89 c1                	mov    %eax,%ecx
    30ff:	89 c8                	mov    %ecx,%eax
    3101:	01 c0                	add    %eax,%eax
    3103:	01 c8                	add    %ecx,%eax
    3105:	01 c2                	add    %eax,%edx
    3107:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    310a:	8d 48 fd             	lea    -0x3(%eax),%ecx
    310d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    3110:	01 c8                	add    %ecx,%eax
    3112:	0f b6 00             	movzbl (%eax),%eax
    3115:	88 02                	mov    %al,(%edx)

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
        int offset = (bmp.height - j - 1) * bmp.width;
        int dataOffset = j * length;
        for(int i=0; i<bmp.width; ++i){
    3117:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    311b:	8b 45 b8             	mov    -0x48(%ebp),%eax
    311e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3121:	0f 8f 6b ff ff ff    	jg     3092 <LoadBmp+0x1c8>

    uchar* data = (uchar*)malloc(sizeof(uchar) * fileHeader.bfSize);
    read(fd, (char*)data, sizeof(uchar) * fileHeader.bfSize);

    int bits = infoHeader.biBitCount / 8;
    for(int j=0; j<bmp.height; ++j){
    3127:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    312b:	8b 45 bc             	mov    -0x44(%ebp),%eax
    312e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    3131:	0f 8f 33 ff ff ff    	jg     306a <LoadBmp+0x1a0>
            bmp.data[offset+i].R = (int)data[specOffset - 1];
            bmp.data[offset+i].G = (int)data[specOffset - 2];
            bmp.data[offset+i].B = (int)data[specOffset - 3];
        }
    }
    close(fd);
    3137:	83 ec 0c             	sub    $0xc,%esp
    313a:	ff 75 ec             	pushl  -0x14(%ebp)
    313d:	e8 73 d4 ff ff       	call   5b5 <close>
    3142:	83 c4 10             	add    $0x10,%esp
    return bmp;
    3145:	8b 45 08             	mov    0x8(%ebp),%eax
    3148:	8b 55 b8             	mov    -0x48(%ebp),%edx
    314b:	89 10                	mov    %edx,(%eax)
    314d:	8b 55 bc             	mov    -0x44(%ebp),%edx
    3150:	89 50 04             	mov    %edx,0x4(%eax)
    3153:	8b 55 c0             	mov    -0x40(%ebp),%edx
    3156:	89 50 08             	mov    %edx,0x8(%eax)
}
    3159:	8b 45 08             	mov    0x8(%ebp),%eax
    315c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    315f:	5b                   	pop    %ebx
    3160:	5e                   	pop    %esi
    3161:	5d                   	pop    %ebp
    3162:	c2 04 00             	ret    $0x4

00003165 <LoadJpeg>:

PBitmap LoadJpeg(char* filename){
    3165:	55                   	push   %ebp
    3166:	89 e5                	mov    %esp,%ebp
    3168:	53                   	push   %ebx
    3169:	83 ec 74             	sub    $0x74,%esp
    char ZZ[64] = { 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18,
    316c:	c6 45 9c 00          	movb   $0x0,-0x64(%ebp)
    3170:	c6 45 9d 01          	movb   $0x1,-0x63(%ebp)
    3174:	c6 45 9e 08          	movb   $0x8,-0x62(%ebp)
    3178:	c6 45 9f 10          	movb   $0x10,-0x61(%ebp)
    317c:	c6 45 a0 09          	movb   $0x9,-0x60(%ebp)
    3180:	c6 45 a1 02          	movb   $0x2,-0x5f(%ebp)
    3184:	c6 45 a2 03          	movb   $0x3,-0x5e(%ebp)
    3188:	c6 45 a3 0a          	movb   $0xa,-0x5d(%ebp)
    318c:	c6 45 a4 11          	movb   $0x11,-0x5c(%ebp)
    3190:	c6 45 a5 18          	movb   $0x18,-0x5b(%ebp)
    3194:	c6 45 a6 20          	movb   $0x20,-0x5a(%ebp)
    3198:	c6 45 a7 19          	movb   $0x19,-0x59(%ebp)
    319c:	c6 45 a8 12          	movb   $0x12,-0x58(%ebp)
    31a0:	c6 45 a9 0b          	movb   $0xb,-0x57(%ebp)
    31a4:	c6 45 aa 04          	movb   $0x4,-0x56(%ebp)
    31a8:	c6 45 ab 05          	movb   $0x5,-0x55(%ebp)
    31ac:	c6 45 ac 0c          	movb   $0xc,-0x54(%ebp)
    31b0:	c6 45 ad 13          	movb   $0x13,-0x53(%ebp)
    31b4:	c6 45 ae 1a          	movb   $0x1a,-0x52(%ebp)
    31b8:	c6 45 af 21          	movb   $0x21,-0x51(%ebp)
    31bc:	c6 45 b0 28          	movb   $0x28,-0x50(%ebp)
    31c0:	c6 45 b1 30          	movb   $0x30,-0x4f(%ebp)
    31c4:	c6 45 b2 29          	movb   $0x29,-0x4e(%ebp)
    31c8:	c6 45 b3 22          	movb   $0x22,-0x4d(%ebp)
    31cc:	c6 45 b4 1b          	movb   $0x1b,-0x4c(%ebp)
    31d0:	c6 45 b5 14          	movb   $0x14,-0x4b(%ebp)
    31d4:	c6 45 b6 0d          	movb   $0xd,-0x4a(%ebp)
    31d8:	c6 45 b7 06          	movb   $0x6,-0x49(%ebp)
    31dc:	c6 45 b8 07          	movb   $0x7,-0x48(%ebp)
    31e0:	c6 45 b9 0e          	movb   $0xe,-0x47(%ebp)
    31e4:	c6 45 ba 15          	movb   $0x15,-0x46(%ebp)
    31e8:	c6 45 bb 1c          	movb   $0x1c,-0x45(%ebp)
    31ec:	c6 45 bc 23          	movb   $0x23,-0x44(%ebp)
    31f0:	c6 45 bd 2a          	movb   $0x2a,-0x43(%ebp)
    31f4:	c6 45 be 31          	movb   $0x31,-0x42(%ebp)
    31f8:	c6 45 bf 38          	movb   $0x38,-0x41(%ebp)
    31fc:	c6 45 c0 39          	movb   $0x39,-0x40(%ebp)
    3200:	c6 45 c1 32          	movb   $0x32,-0x3f(%ebp)
    3204:	c6 45 c2 2b          	movb   $0x2b,-0x3e(%ebp)
    3208:	c6 45 c3 24          	movb   $0x24,-0x3d(%ebp)
    320c:	c6 45 c4 1d          	movb   $0x1d,-0x3c(%ebp)
    3210:	c6 45 c5 16          	movb   $0x16,-0x3b(%ebp)
    3214:	c6 45 c6 0f          	movb   $0xf,-0x3a(%ebp)
    3218:	c6 45 c7 17          	movb   $0x17,-0x39(%ebp)
    321c:	c6 45 c8 1e          	movb   $0x1e,-0x38(%ebp)
    3220:	c6 45 c9 25          	movb   $0x25,-0x37(%ebp)
    3224:	c6 45 ca 2c          	movb   $0x2c,-0x36(%ebp)
    3228:	c6 45 cb 33          	movb   $0x33,-0x35(%ebp)
    322c:	c6 45 cc 3a          	movb   $0x3a,-0x34(%ebp)
    3230:	c6 45 cd 3b          	movb   $0x3b,-0x33(%ebp)
    3234:	c6 45 ce 34          	movb   $0x34,-0x32(%ebp)
    3238:	c6 45 cf 2d          	movb   $0x2d,-0x31(%ebp)
    323c:	c6 45 d0 26          	movb   $0x26,-0x30(%ebp)
    3240:	c6 45 d1 1f          	movb   $0x1f,-0x2f(%ebp)
    3244:	c6 45 d2 27          	movb   $0x27,-0x2e(%ebp)
    3248:	c6 45 d3 2e          	movb   $0x2e,-0x2d(%ebp)
    324c:	c6 45 d4 35          	movb   $0x35,-0x2c(%ebp)
    3250:	c6 45 d5 3c          	movb   $0x3c,-0x2b(%ebp)
    3254:	c6 45 d6 3d          	movb   $0x3d,-0x2a(%ebp)
    3258:	c6 45 d7 36          	movb   $0x36,-0x29(%ebp)
    325c:	c6 45 d8 2f          	movb   $0x2f,-0x28(%ebp)
    3260:	c6 45 d9 37          	movb   $0x37,-0x27(%ebp)
    3264:	c6 45 da 3e          	movb   $0x3e,-0x26(%ebp)
    3268:	c6 45 db 3f          	movb   $0x3f,-0x25(%ebp)
        11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35,
        42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45,
        38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 };
    Context* ctx=malloc(sizeof(Context));
    326c:	83 ec 0c             	sub    $0xc,%esp
    326f:	68 c8 02 08 00       	push   $0x802c8
    3274:	e8 8e d7 ff ff       	call   a07 <malloc>
    3279:	83 c4 10             	add    $0x10,%esp
    327c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    memset(ctx, 0, sizeof(Context));
    327f:	83 ec 04             	sub    $0x4,%esp
    3282:	68 c8 02 08 00       	push   $0x802c8
    3287:	6a 00                	push   $0x0
    3289:	ff 75 f0             	pushl  -0x10(%ebp)
    328c:	e8 61 d1 ff ff       	call   3f2 <memset>
    3291:	83 c4 10             	add    $0x10,%esp

    int fd;
    fd = open(filename, O_RDONLY);
    3294:	83 ec 08             	sub    $0x8,%esp
    3297:	6a 00                	push   $0x0
    3299:	ff 75 0c             	pushl  0xc(%ebp)
    329c:	e8 2c d3 ff ff       	call   5cd <open>
    32a1:	83 c4 10             	add    $0x10,%esp
    32a4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    uchar* buf = (uchar*)malloc(MAX_JPEG_SIZE);
    32a7:	83 ec 0c             	sub    $0xc,%esp
    32aa:	68 40 42 0f 00       	push   $0xf4240
    32af:	e8 53 d7 ff ff       	call   a07 <malloc>
    32b4:	83 c4 10             	add    $0x10,%esp
    32b7:	89 45 e8             	mov    %eax,-0x18(%ebp)

    read(fd, buf, MAX_JPEG_SIZE);
    32ba:	83 ec 04             	sub    $0x4,%esp
    32bd:	68 40 42 0f 00       	push   $0xf4240
    32c2:	ff 75 e8             	pushl  -0x18(%ebp)
    32c5:	ff 75 ec             	pushl  -0x14(%ebp)
    32c8:	e8 d8 d2 ff ff       	call   5a5 <read>
    32cd:	83 c4 10             	add    $0x10,%esp
    
    close(fd);
    32d0:	83 ec 0c             	sub    $0xc,%esp
    32d3:	ff 75 ec             	pushl  -0x14(%ebp)
    32d6:	e8 da d2 ff ff       	call   5b5 <close>
    32db:	83 c4 10             	add    $0x10,%esp

    _DecodeJPEG(ctx, ZZ, buf, MAX_JPEG_SIZE);
    32de:	68 40 42 0f 00       	push   $0xf4240
    32e3:	ff 75 e8             	pushl  -0x18(%ebp)
    32e6:	8d 45 9c             	lea    -0x64(%ebp),%eax
    32e9:	50                   	push   %eax
    32ea:	ff 75 f0             	pushl  -0x10(%ebp)
    32ed:	e8 5e 0c 01 00       	call   13f50 <_DecodeJPEG>
    32f2:	83 c4 10             	add    $0x10,%esp

   
    PBitmap bmp;
    bmp.height=0;
    32f5:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
    bmp.width=0;
    32fc:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
    bmp.data=0;
    3303:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%ebp)
    
    int imgsize = GetImageSize(ctx);
    330a:	83 ec 0c             	sub    $0xc,%esp
    330d:	ff 75 f0             	pushl  -0x10(%ebp)
    3310:	e8 29 0b 01 00       	call   13e3e <GetImageSize>
    3315:	83 c4 10             	add    $0x10,%esp
    3318:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar* c = GetImage(ctx);
    331b:	83 ec 0c             	sub    $0xc,%esp
    331e:	ff 75 f0             	pushl  -0x10(%ebp)
    3321:	e8 e1 0a 01 00       	call   13e07 <GetImage>
    3326:	83 c4 10             	add    $0x10,%esp
    3329:	89 45 e0             	mov    %eax,-0x20(%ebp)
    bmp.width = GetWidth(ctx);
    332c:	83 ec 0c             	sub    $0xc,%esp
    332f:	ff 75 f0             	pushl  -0x10(%ebp)
    3332:	e8 f1 0a 01 00       	call   13e28 <GetWidth>
    3337:	83 c4 10             	add    $0x10,%esp
    333a:	89 45 90             	mov    %eax,-0x70(%ebp)
    bmp.height = GetHeight(ctx);
    333d:	83 ec 0c             	sub    $0xc,%esp
    3340:	ff 75 f0             	pushl  -0x10(%ebp)
    3343:	e8 eb 0a 01 00       	call   13e33 <GetHeight>
    3348:	83 c4 10             	add    $0x10,%esp
    334b:	89 45 94             	mov    %eax,-0x6c(%ebp)
    int n = bmp.width * bmp.height;
    334e:	8b 55 90             	mov    -0x70(%ebp),%edx
    3351:	8b 45 94             	mov    -0x6c(%ebp),%eax
    3354:	0f af c2             	imul   %edx,%eax
    3357:	89 45 dc             	mov    %eax,-0x24(%ebp)
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    335a:	8b 55 dc             	mov    -0x24(%ebp),%edx
    335d:	89 d0                	mov    %edx,%eax
    335f:	01 c0                	add    %eax,%eax
    3361:	01 d0                	add    %edx,%eax
    3363:	83 ec 0c             	sub    $0xc,%esp
    3366:	50                   	push   %eax
    3367:	e8 9b d6 ff ff       	call   a07 <malloc>
    336c:	83 c4 10             	add    $0x10,%esp
    336f:	89 45 98             	mov    %eax,-0x68(%ebp)
    for(int i=0; i<imgsize; i+=3){
    3372:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3379:	e9 9c 00 00 00       	jmp    341a <LoadJpeg+0x2b5>
        bmp.data[i/3].R = c[i];
    337e:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    3381:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    3384:	ba 56 55 55 55       	mov    $0x55555556,%edx
    3389:	89 c8                	mov    %ecx,%eax
    338b:	f7 ea                	imul   %edx
    338d:	89 c8                	mov    %ecx,%eax
    338f:	c1 f8 1f             	sar    $0x1f,%eax
    3392:	29 c2                	sub    %eax,%edx
    3394:	89 d0                	mov    %edx,%eax
    3396:	89 c2                	mov    %eax,%edx
    3398:	89 d0                	mov    %edx,%eax
    339a:	01 c0                	add    %eax,%eax
    339c:	01 d0                	add    %edx,%eax
    339e:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    33a1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    33a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
    33a7:	01 c8                	add    %ecx,%eax
    33a9:	0f b6 00             	movzbl (%eax),%eax
    33ac:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i/3].G = c[i+1];
    33af:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    33b2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    33b5:	ba 56 55 55 55       	mov    $0x55555556,%edx
    33ba:	89 c8                	mov    %ecx,%eax
    33bc:	f7 ea                	imul   %edx
    33be:	89 c8                	mov    %ecx,%eax
    33c0:	c1 f8 1f             	sar    $0x1f,%eax
    33c3:	29 c2                	sub    %eax,%edx
    33c5:	89 d0                	mov    %edx,%eax
    33c7:	89 c2                	mov    %eax,%edx
    33c9:	89 d0                	mov    %edx,%eax
    33cb:	01 c0                	add    %eax,%eax
    33cd:	01 d0                	add    %edx,%eax
    33cf:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    33d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    33d5:	8d 48 01             	lea    0x1(%eax),%ecx
    33d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
    33db:	01 c8                	add    %ecx,%eax
    33dd:	0f b6 00             	movzbl (%eax),%eax
    33e0:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i/3].B = c[i+2];
    33e3:	8b 5d 98             	mov    -0x68(%ebp),%ebx
    33e6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    33e9:	ba 56 55 55 55       	mov    $0x55555556,%edx
    33ee:	89 c8                	mov    %ecx,%eax
    33f0:	f7 ea                	imul   %edx
    33f2:	89 c8                	mov    %ecx,%eax
    33f4:	c1 f8 1f             	sar    $0x1f,%eax
    33f7:	29 c2                	sub    %eax,%edx
    33f9:	89 d0                	mov    %edx,%eax
    33fb:	89 c2                	mov    %eax,%edx
    33fd:	89 d0                	mov    %edx,%eax
    33ff:	01 c0                	add    %eax,%eax
    3401:	01 d0                	add    %edx,%eax
    3403:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    3406:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3409:	8d 48 02             	lea    0x2(%eax),%ecx
    340c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    340f:	01 c8                	add    %ecx,%eax
    3411:	0f b6 00             	movzbl (%eax),%eax
    3414:	88 02                	mov    %al,(%edx)
    uchar* c = GetImage(ctx);
    bmp.width = GetWidth(ctx);
    bmp.height = GetHeight(ctx);
    int n = bmp.width * bmp.height;
    bmp.data = (RGB*)malloc(n * sizeof(RGB));
    for(int i=0; i<imgsize; i+=3){
    3416:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    341a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    341d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    3420:	0f 8c 58 ff ff ff    	jl     337e <LoadJpeg+0x219>
        bmp.data[i/3].R = c[i];
        bmp.data[i/3].G = c[i+1];
        bmp.data[i/3].B = c[i+2];
    }
    return bmp;
    3426:	8b 45 08             	mov    0x8(%ebp),%eax
    3429:	8b 55 90             	mov    -0x70(%ebp),%edx
    342c:	89 10                	mov    %edx,(%eax)
    342e:	8b 55 94             	mov    -0x6c(%ebp),%edx
    3431:	89 50 04             	mov    %edx,0x4(%eax)
    3434:	8b 55 98             	mov    -0x68(%ebp),%edx
    3437:	89 50 08             	mov    %edx,0x8(%eax)
}
    343a:	8b 45 08             	mov    0x8(%ebp),%eax
    343d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    3440:	c9                   	leave  
    3441:	c2 04 00             	ret    $0x4

00003444 <LoadPng>:

PBitmap LoadPng(char* filename){
    3444:	55                   	push   %ebp
    3445:	89 e5                	mov    %esp,%ebp
    3447:	83 ec 38             	sub    $0x38,%esp
    unsigned char* image = 0;
    344a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned width, height;
    lodepng_decode24_file(&image, &width, &height, filename);
    3451:	ff 75 0c             	pushl  0xc(%ebp)
    3454:	8d 45 e0             	lea    -0x20(%ebp),%eax
    3457:	50                   	push   %eax
    3458:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    345b:	50                   	push   %eax
    345c:	8d 45 e8             	lea    -0x18(%ebp),%eax
    345f:	50                   	push   %eax
    3460:	e8 d3 d3 00 00       	call   10838 <lodepng_decode24_file>
    3465:	83 c4 10             	add    $0x10,%esp
    PBitmap bmp;
    bmp.height=height;
    3468:	8b 45 e0             	mov    -0x20(%ebp),%eax
    346b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    bmp.width=width;
    346e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    3471:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    bmp.data=0;
    3474:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    347b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    347e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    3481:	0f af c2             	imul   %edx,%eax
    3484:	89 45 f0             	mov    %eax,-0x10(%ebp)
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    3487:	8b 55 f0             	mov    -0x10(%ebp),%edx
    348a:	89 d0                	mov    %edx,%eax
    348c:	01 c0                	add    %eax,%eax
    348e:	01 d0                	add    %edx,%eax
    3490:	83 ec 0c             	sub    $0xc,%esp
    3493:	50                   	push   %eax
    3494:	e8 6e d5 ff ff       	call   a07 <malloc>
    3499:	83 c4 10             	add    $0x10,%esp
    349c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    349f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    34a6:	e9 87 00 00 00       	jmp    3532 <LoadPng+0xee>
    {
        unsigned char R = image[i*3];
    34ab:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    34ae:	8b 55 f4             	mov    -0xc(%ebp),%edx
    34b1:	89 d0                	mov    %edx,%eax
    34b3:	01 c0                	add    %eax,%eax
    34b5:	01 d0                	add    %edx,%eax
    34b7:	01 c8                	add    %ecx,%eax
    34b9:	0f b6 00             	movzbl (%eax),%eax
    34bc:	88 45 ef             	mov    %al,-0x11(%ebp)
        unsigned char G = image[i*3 + 1];
    34bf:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    34c2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    34c5:	89 d0                	mov    %edx,%eax
    34c7:	01 c0                	add    %eax,%eax
    34c9:	01 d0                	add    %edx,%eax
    34cb:	83 c0 01             	add    $0x1,%eax
    34ce:	01 c8                	add    %ecx,%eax
    34d0:	0f b6 00             	movzbl (%eax),%eax
    34d3:	88 45 ee             	mov    %al,-0x12(%ebp)
        unsigned char B = image[i*3 + 2];
    34d6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    34d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    34dc:	89 d0                	mov    %edx,%eax
    34de:	01 c0                	add    %eax,%eax
    34e0:	01 d0                	add    %edx,%eax
    34e2:	83 c0 02             	add    $0x2,%eax
    34e5:	01 c8                	add    %ecx,%eax
    34e7:	0f b6 00             	movzbl (%eax),%eax
    34ea:	88 45 ed             	mov    %al,-0x13(%ebp)
        bmp.data[i].R = R;
    34ed:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    34f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    34f3:	89 d0                	mov    %edx,%eax
    34f5:	01 c0                	add    %eax,%eax
    34f7:	01 d0                	add    %edx,%eax
    34f9:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    34fc:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    3500:	88 42 02             	mov    %al,0x2(%edx)
        bmp.data[i].G = G;
    3503:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    3506:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3509:	89 d0                	mov    %edx,%eax
    350b:	01 c0                	add    %eax,%eax
    350d:	01 d0                	add    %edx,%eax
    350f:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3512:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    3516:	88 42 01             	mov    %al,0x1(%edx)
        bmp.data[i].B = B;
    3519:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    351c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    351f:	89 d0                	mov    %edx,%eax
    3521:	01 c0                	add    %eax,%eax
    3523:	01 d0                	add    %edx,%eax
    3525:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    3528:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    352c:	88 02                	mov    %al,(%edx)

    // int imgsize = width * height;
    int n = bmp.width * bmp.height;
    bmp.data = (RGB *)malloc(sizeof(RGB) * n);
    //这里是用decode24,所以是3个3个的读取
    for (int i = 0; i < n; i += 1)
    352e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3532:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3535:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    3538:	0f 8c 6d ff ff ff    	jl     34ab <LoadPng+0x67>
        bmp.data[i].G = G;
        bmp.data[i].B = B;

    }
    // printf(1, "read all png data.\n");
    free(image);
    353e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    3541:	83 ec 0c             	sub    $0xc,%esp
    3544:	50                   	push   %eax
    3545:	e8 7b d3 ff ff       	call   8c5 <free>
    354a:	83 c4 10             	add    $0x10,%esp
    return bmp;
    354d:	8b 45 08             	mov    0x8(%ebp),%eax
    3550:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    3553:	89 10                	mov    %edx,(%eax)
    3555:	8b 55 d8             	mov    -0x28(%ebp),%edx
    3558:	89 50 04             	mov    %edx,0x4(%eax)
    355b:	8b 55 dc             	mov    -0x24(%ebp),%edx
    355e:	89 50 08             	mov    %edx,0x8(%eax)

}
    3561:	8b 45 08             	mov    0x8(%ebp),%eax
    3564:	c9                   	leave  
    3565:	c2 04 00             	ret    $0x4

00003568 <LoadImg>:

PBitmap LoadImg(char* filename){
    3568:	55                   	push   %ebp
    3569:	89 e5                	mov    %esp,%ebp
    356b:	83 ec 18             	sub    $0x18,%esp
    int t = type(filename);
    356e:	83 ec 0c             	sub    $0xc,%esp
    3571:	ff 75 0c             	pushl  0xc(%ebp)
    3574:	e8 7c f8 ff ff       	call   2df5 <type>
    3579:	83 c4 10             	add    $0x10,%esp
    357c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    PBitmap bmp;
    switch(t){
    357f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3582:	83 f8 01             	cmp    $0x1,%eax
    3585:	74 1d                	je     35a4 <LoadImg+0x3c>
    3587:	83 f8 02             	cmp    $0x2,%eax
    358a:	74 2c                	je     35b8 <LoadImg+0x50>
    358c:	85 c0                	test   %eax,%eax
    358e:	75 3c                	jne    35cc <LoadImg+0x64>
        case JPG: return LoadJpeg(filename);
    3590:	8b 45 08             	mov    0x8(%ebp),%eax
    3593:	83 ec 08             	sub    $0x8,%esp
    3596:	ff 75 0c             	pushl  0xc(%ebp)
    3599:	50                   	push   %eax
    359a:	e8 c6 fb ff ff       	call   3165 <LoadJpeg>
    359f:	83 c4 0c             	add    $0xc,%esp
    35a2:	eb 3c                	jmp    35e0 <LoadImg+0x78>
        case BMP: return LoadBmp(filename);
    35a4:	8b 45 08             	mov    0x8(%ebp),%eax
    35a7:	83 ec 08             	sub    $0x8,%esp
    35aa:	ff 75 0c             	pushl  0xc(%ebp)
    35ad:	50                   	push   %eax
    35ae:	e8 17 f9 ff ff       	call   2eca <LoadBmp>
    35b3:	83 c4 0c             	add    $0xc,%esp
    35b6:	eb 28                	jmp    35e0 <LoadImg+0x78>
        case PNG: return LoadPng(filename);
    35b8:	8b 45 08             	mov    0x8(%ebp),%eax
    35bb:	83 ec 08             	sub    $0x8,%esp
    35be:	ff 75 0c             	pushl  0xc(%ebp)
    35c1:	50                   	push   %eax
    35c2:	e8 7d fe ff ff       	call   3444 <LoadPng>
    35c7:	83 c4 0c             	add    $0xc,%esp
    35ca:	eb 14                	jmp    35e0 <LoadImg+0x78>

        default: return bmp;
    35cc:	8b 45 08             	mov    0x8(%ebp),%eax
    35cf:	8b 55 e8             	mov    -0x18(%ebp),%edx
    35d2:	89 10                	mov    %edx,(%eax)
    35d4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    35d7:	89 50 04             	mov    %edx,0x4(%eax)
    35da:	8b 55 f0             	mov    -0x10(%ebp),%edx
    35dd:	89 50 08             	mov    %edx,0x8(%eax)
    }
}
    35e0:	8b 45 08             	mov    0x8(%ebp),%eax
    35e3:	c9                   	leave  
    35e4:	c2 04 00             	ret    $0x4

000035e7 <lodepng_malloc>:
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size) {
    35e7:	55                   	push   %ebp
    35e8:	89 e5                	mov    %esp,%ebp
    35ea:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_MAX_ALLOC
  if(size > LODEPNG_MAX_ALLOC) return 0;
#endif
  return malloc(size);
    35ed:	8b 45 08             	mov    0x8(%ebp),%eax
    35f0:	83 ec 0c             	sub    $0xc,%esp
    35f3:	50                   	push   %eax
    35f4:	e8 0e d4 ff ff       	call   a07 <malloc>
    35f9:	83 c4 10             	add    $0x10,%esp
}
    35fc:	c9                   	leave  
    35fd:	c3                   	ret    

000035fe <lodepng_realloc>:

/* NOTE: when realloc returns NULL, it leaves the original memory untouched */
static void* lodepng_realloc(void* ptr, size_t new_size) {
    35fe:	55                   	push   %ebp
    35ff:	89 e5                	mov    %esp,%ebp
#ifdef LODEPNG_MAX_ALLOC
  if(new_size > LODEPNG_MAX_ALLOC) return 0;
#endif
  // return realloc(ptr, new_size);
  return -1;
    3601:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3606:	5d                   	pop    %ebp
    3607:	c3                   	ret    

00003608 <lodepng_free>:

static void lodepng_free(void* ptr) {
    3608:	55                   	push   %ebp
    3609:	89 e5                	mov    %esp,%ebp
    360b:	83 ec 08             	sub    $0x8,%esp
  if(ptr)
    360e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    3612:	74 0e                	je     3622 <lodepng_free+0x1a>
    free(ptr);
    3614:	83 ec 0c             	sub    $0xc,%esp
    3617:	ff 75 08             	pushl  0x8(%ebp)
    361a:	e8 a6 d2 ff ff       	call   8c5 <free>
    361f:	83 c4 10             	add    $0x10,%esp
}
    3622:	90                   	nop
    3623:	c9                   	leave  
    3624:	c3                   	ret    

00003625 <lodepng_memcpy>:
/* Replacements for C library functions such as memcpy and strlen, to support platforms
where a full C library is not available. The compiler can recognize them and compile
to something as fast. */

static void lodepng_memcpy(void* LODEPNG_RESTRICT dst,
                           const void* LODEPNG_RESTRICT src, size_t size) {
    3625:	55                   	push   %ebp
    3626:	89 e5                	mov    %esp,%ebp
    3628:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];
    362b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3632:	eb 19                	jmp    364d <lodepng_memcpy+0x28>
    3634:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3637:	8b 45 08             	mov    0x8(%ebp),%eax
    363a:	01 c2                	add    %eax,%edx
    363c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    363f:	8b 45 0c             	mov    0xc(%ebp),%eax
    3642:	01 c8                	add    %ecx,%eax
    3644:	0f b6 00             	movzbl (%eax),%eax
    3647:	88 02                	mov    %al,(%edx)
    3649:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    364d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3650:	3b 45 10             	cmp    0x10(%ebp),%eax
    3653:	7c df                	jl     3634 <lodepng_memcpy+0xf>
}
    3655:	90                   	nop
    3656:	c9                   	leave  
    3657:	c3                   	ret    

00003658 <lodepng_memset>:

static void lodepng_memset(void* LODEPNG_RESTRICT dst,
                           int value, size_t num) {
    3658:	55                   	push   %ebp
    3659:	89 e5                	mov    %esp,%ebp
    365b:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i < num; i++) ((char*)dst)[i] = (char)value;
    365e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    3665:	eb 11                	jmp    3678 <lodepng_memset+0x20>
    3667:	8b 55 fc             	mov    -0x4(%ebp),%edx
    366a:	8b 45 08             	mov    0x8(%ebp),%eax
    366d:	01 d0                	add    %edx,%eax
    366f:	8b 55 0c             	mov    0xc(%ebp),%edx
    3672:	88 10                	mov    %dl,(%eax)
    3674:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    3678:	8b 45 fc             	mov    -0x4(%ebp),%eax
    367b:	3b 45 10             	cmp    0x10(%ebp),%eax
    367e:	7c e7                	jl     3667 <lodepng_memset+0xf>
}
    3680:	90                   	nop
    3681:	c9                   	leave  
    3682:	c3                   	ret    

00003683 <lodepng_strlen>:

/* does not check memory out of bounds, do not use on untrusted data */
static size_t lodepng_strlen(const char* a) {
    3683:	55                   	push   %ebp
    3684:	89 e5                	mov    %esp,%ebp
    3686:	83 ec 10             	sub    $0x10,%esp
  const char* orig = a;
    3689:	8b 45 08             	mov    0x8(%ebp),%eax
    368c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /* avoid warning about unused function in case of disabled COMPILE... macros */
  (void)(&lodepng_strlen);
  while(*a) a++;
    368f:	eb 04                	jmp    3695 <lodepng_strlen+0x12>
    3691:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    3695:	8b 45 08             	mov    0x8(%ebp),%eax
    3698:	0f b6 00             	movzbl (%eax),%eax
    369b:	84 c0                	test   %al,%al
    369d:	75 f2                	jne    3691 <lodepng_strlen+0xe>
  return (size_t)(a - orig);
    369f:	8b 55 08             	mov    0x8(%ebp),%edx
    36a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    36a5:	29 c2                	sub    %eax,%edx
    36a7:	89 d0                	mov    %edx,%eax
}
    36a9:	c9                   	leave  
    36aa:	c3                   	ret    

000036ab <lodepng_addofl>:
#define LODEPNG_ABS(x) ((x) < 0 ? -(x) : (x))

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)
/* Safely check if adding two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_addofl(size_t a, size_t b, size_t* result) {
    36ab:	55                   	push   %ebp
    36ac:	89 e5                	mov    %esp,%ebp
  *result = a + b; /* Unsigned addition is well defined and safe in C90 */
    36ae:	8b 55 08             	mov    0x8(%ebp),%edx
    36b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    36b4:	01 c2                	add    %eax,%edx
    36b6:	8b 45 10             	mov    0x10(%ebp),%eax
    36b9:	89 10                	mov    %edx,(%eax)
  return *result < a;
    36bb:	8b 45 10             	mov    0x10(%ebp),%eax
    36be:	8b 00                	mov    (%eax),%eax
    36c0:	3b 45 08             	cmp    0x8(%ebp),%eax
    36c3:	0f 9c c0             	setl   %al
    36c6:	0f b6 c0             	movzbl %al,%eax
}
    36c9:	5d                   	pop    %ebp
    36ca:	c3                   	ret    

000036cb <lodepng_mulofl>:
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_DECODER)*/

#ifdef LODEPNG_COMPILE_DECODER
/* Safely check if multiplying two integers will overflow (no undefined
behavior, compiler removing the code, etc...) and output result. */
static int lodepng_mulofl(size_t a, size_t b, size_t* result) {
    36cb:	55                   	push   %ebp
    36cc:	89 e5                	mov    %esp,%ebp
  *result = a * b; /* Unsigned multiplication is well defined and safe in C90 */
    36ce:	8b 45 08             	mov    0x8(%ebp),%eax
    36d1:	0f af 45 0c          	imul   0xc(%ebp),%eax
    36d5:	89 c2                	mov    %eax,%edx
    36d7:	8b 45 10             	mov    0x10(%ebp),%eax
    36da:	89 10                	mov    %edx,(%eax)
  return (a != 0 && *result / a != b);
    36dc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    36e0:	74 15                	je     36f7 <lodepng_mulofl+0x2c>
    36e2:	8b 45 10             	mov    0x10(%ebp),%eax
    36e5:	8b 00                	mov    (%eax),%eax
    36e7:	99                   	cltd   
    36e8:	f7 7d 08             	idivl  0x8(%ebp)
    36eb:	3b 45 0c             	cmp    0xc(%ebp),%eax
    36ee:	74 07                	je     36f7 <lodepng_mulofl+0x2c>
    36f0:	b8 01 00 00 00       	mov    $0x1,%eax
    36f5:	eb 05                	jmp    36fc <lodepng_mulofl+0x31>
    36f7:	b8 00 00 00 00       	mov    $0x0,%eax
}
    36fc:	5d                   	pop    %ebp
    36fd:	c3                   	ret    

000036fe <lodepng_gtofl>:

#ifdef LODEPNG_COMPILE_ZLIB
/* Safely check if a + b > c, even if overflow could happen. */
static int lodepng_gtofl(size_t a, size_t b, size_t c) {
    36fe:	55                   	push   %ebp
    36ff:	89 e5                	mov    %esp,%ebp
    3701:	83 ec 10             	sub    $0x10,%esp
  size_t d;
  if(lodepng_addofl(a, b, &d)) return 1;
    3704:	8d 45 fc             	lea    -0x4(%ebp),%eax
    3707:	50                   	push   %eax
    3708:	ff 75 0c             	pushl  0xc(%ebp)
    370b:	ff 75 08             	pushl  0x8(%ebp)
    370e:	e8 98 ff ff ff       	call   36ab <lodepng_addofl>
    3713:	83 c4 0c             	add    $0xc,%esp
    3716:	85 c0                	test   %eax,%eax
    3718:	74 07                	je     3721 <lodepng_gtofl+0x23>
    371a:	b8 01 00 00 00       	mov    $0x1,%eax
    371f:	eb 0c                	jmp    372d <lodepng_gtofl+0x2f>
  return d > c;
    3721:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3724:	3b 45 10             	cmp    0x10(%ebp),%eax
    3727:	0f 9f c0             	setg   %al
    372a:	0f b6 c0             	movzbl %al,%eax
}
    372d:	c9                   	leave  
    372e:	c3                   	ret    

0000372f <uivector_cleanup>:
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p) {
    372f:	55                   	push   %ebp
    3730:	89 e5                	mov    %esp,%ebp
    3732:	83 ec 08             	sub    $0x8,%esp
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
    3735:	8b 45 08             	mov    0x8(%ebp),%eax
    3738:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    373f:	8b 45 08             	mov    0x8(%ebp),%eax
    3742:	8b 50 08             	mov    0x8(%eax),%edx
    3745:	8b 45 08             	mov    0x8(%ebp),%eax
    3748:	89 50 04             	mov    %edx,0x4(%eax)
  lodepng_free(((uivector*)p)->data);
    374b:	8b 45 08             	mov    0x8(%ebp),%eax
    374e:	8b 00                	mov    (%eax),%eax
    3750:	83 ec 0c             	sub    $0xc,%esp
    3753:	50                   	push   %eax
    3754:	e8 af fe ff ff       	call   3608 <lodepng_free>
    3759:	83 c4 10             	add    $0x10,%esp
  ((uivector*)p)->data = NULL;
    375c:	8b 45 08             	mov    0x8(%ebp),%eax
    375f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    3765:	90                   	nop
    3766:	c9                   	leave  
    3767:	c3                   	ret    

00003768 <uivector_resize>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size) {
    3768:	55                   	push   %ebp
    3769:	89 e5                	mov    %esp,%ebp
    376b:	83 ec 10             	sub    $0x10,%esp
  size_t allocsize = size * sizeof(unsigned);
    376e:	8b 45 0c             	mov    0xc(%ebp),%eax
    3771:	c1 e0 02             	shl    $0x2,%eax
    3774:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(allocsize > p->allocsize) {
    3777:	8b 45 08             	mov    0x8(%ebp),%eax
    377a:	8b 40 08             	mov    0x8(%eax),%eax
    377d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    3780:	7d 46                	jge    37c8 <uivector_resize+0x60>
    size_t newsize = allocsize + (p->allocsize >> 1u);
    3782:	8b 45 08             	mov    0x8(%ebp),%eax
    3785:	8b 40 08             	mov    0x8(%eax),%eax
    3788:	d1 f8                	sar    %eax
    378a:	89 c2                	mov    %eax,%edx
    378c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    378f:	01 d0                	add    %edx,%eax
    3791:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    3794:	8b 45 08             	mov    0x8(%ebp),%eax
    3797:	8b 00                	mov    (%eax),%eax
    3799:	ff 75 f8             	pushl  -0x8(%ebp)
    379c:	50                   	push   %eax
    379d:	e8 5c fe ff ff       	call   35fe <lodepng_realloc>
    37a2:	83 c4 08             	add    $0x8,%esp
    37a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(data) {
    37a8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    37ac:	74 13                	je     37c1 <uivector_resize+0x59>
      p->allocsize = newsize;
    37ae:	8b 45 08             	mov    0x8(%ebp),%eax
    37b1:	8b 55 f8             	mov    -0x8(%ebp),%edx
    37b4:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned*)data;
    37b7:	8b 45 08             	mov    0x8(%ebp),%eax
    37ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
    37bd:	89 10                	mov    %edx,(%eax)
    37bf:	eb 07                	jmp    37c8 <uivector_resize+0x60>
    }
    else return 0; /*error: not enough memory*/
    37c1:	b8 00 00 00 00       	mov    $0x0,%eax
    37c6:	eb 0e                	jmp    37d6 <uivector_resize+0x6e>
  }
  p->size = size;
    37c8:	8b 45 08             	mov    0x8(%ebp),%eax
    37cb:	8b 55 0c             	mov    0xc(%ebp),%edx
    37ce:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    37d1:	b8 01 00 00 00       	mov    $0x1,%eax
}
    37d6:	c9                   	leave  
    37d7:	c3                   	ret    

000037d8 <uivector_init>:

static void uivector_init(uivector* p) {
    37d8:	55                   	push   %ebp
    37d9:	89 e5                	mov    %esp,%ebp
  p->data = NULL;
    37db:	8b 45 08             	mov    0x8(%ebp),%eax
    37de:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  p->size = p->allocsize = 0;
    37e4:	8b 45 08             	mov    0x8(%ebp),%eax
    37e7:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    37ee:	8b 45 08             	mov    0x8(%ebp),%eax
    37f1:	8b 50 08             	mov    0x8(%eax),%edx
    37f4:	8b 45 08             	mov    0x8(%ebp),%eax
    37f7:	89 50 04             	mov    %edx,0x4(%eax)
}
    37fa:	90                   	nop
    37fb:	5d                   	pop    %ebp
    37fc:	c3                   	ret    

000037fd <uivector_push_back>:

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c) {
    37fd:	55                   	push   %ebp
    37fe:	89 e5                	mov    %esp,%ebp
  if(!uivector_resize(p, p->size + 1)) return 0;
    3800:	8b 45 08             	mov    0x8(%ebp),%eax
    3803:	8b 40 04             	mov    0x4(%eax),%eax
    3806:	83 c0 01             	add    $0x1,%eax
    3809:	50                   	push   %eax
    380a:	ff 75 08             	pushl  0x8(%ebp)
    380d:	e8 56 ff ff ff       	call   3768 <uivector_resize>
    3812:	83 c4 08             	add    $0x8,%esp
    3815:	85 c0                	test   %eax,%eax
    3817:	75 07                	jne    3820 <uivector_push_back+0x23>
    3819:	b8 00 00 00 00       	mov    $0x0,%eax
    381e:	eb 1f                	jmp    383f <uivector_push_back+0x42>
  p->data[p->size - 1] = c;
    3820:	8b 45 08             	mov    0x8(%ebp),%eax
    3823:	8b 10                	mov    (%eax),%edx
    3825:	8b 45 08             	mov    0x8(%ebp),%eax
    3828:	8b 40 04             	mov    0x4(%eax),%eax
    382b:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    3830:	c1 e0 02             	shl    $0x2,%eax
    3833:	01 c2                	add    %eax,%edx
    3835:	8b 45 0c             	mov    0xc(%ebp),%eax
    3838:	89 02                	mov    %eax,(%edx)
  return 1;
    383a:	b8 01 00 00 00       	mov    $0x1,%eax
}
    383f:	c9                   	leave  
    3840:	c3                   	ret    

00003841 <ucvector_resize>:
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size) {
    3841:	55                   	push   %ebp
    3842:	89 e5                	mov    %esp,%ebp
    3844:	83 ec 10             	sub    $0x10,%esp
  if(size > p->allocsize) {
    3847:	8b 45 08             	mov    0x8(%ebp),%eax
    384a:	8b 40 08             	mov    0x8(%eax),%eax
    384d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    3850:	7d 46                	jge    3898 <ucvector_resize+0x57>
    size_t newsize = size + (p->allocsize >> 1u);
    3852:	8b 45 08             	mov    0x8(%ebp),%eax
    3855:	8b 40 08             	mov    0x8(%eax),%eax
    3858:	d1 f8                	sar    %eax
    385a:	89 c2                	mov    %eax,%edx
    385c:	8b 45 0c             	mov    0xc(%ebp),%eax
    385f:	01 d0                	add    %edx,%eax
    3861:	89 45 fc             	mov    %eax,-0x4(%ebp)
    void* data = lodepng_realloc(p->data, newsize);
    3864:	8b 45 08             	mov    0x8(%ebp),%eax
    3867:	8b 00                	mov    (%eax),%eax
    3869:	ff 75 fc             	pushl  -0x4(%ebp)
    386c:	50                   	push   %eax
    386d:	e8 8c fd ff ff       	call   35fe <lodepng_realloc>
    3872:	83 c4 08             	add    $0x8,%esp
    3875:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(data) {
    3878:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    387c:	74 13                	je     3891 <ucvector_resize+0x50>
      p->allocsize = newsize;
    387e:	8b 45 08             	mov    0x8(%ebp),%eax
    3881:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3884:	89 50 08             	mov    %edx,0x8(%eax)
      p->data = (unsigned char*)data;
    3887:	8b 45 08             	mov    0x8(%ebp),%eax
    388a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    388d:	89 10                	mov    %edx,(%eax)
    388f:	eb 07                	jmp    3898 <ucvector_resize+0x57>
    }
    else return 0; /*error: not enough memory*/
    3891:	b8 00 00 00 00       	mov    $0x0,%eax
    3896:	eb 0e                	jmp    38a6 <ucvector_resize+0x65>
  }
  p->size = size;
    3898:	8b 45 08             	mov    0x8(%ebp),%eax
    389b:	8b 55 0c             	mov    0xc(%ebp),%edx
    389e:	89 50 04             	mov    %edx,0x4(%eax)
  return 1; /*success*/
    38a1:	b8 01 00 00 00       	mov    $0x1,%eax
}
    38a6:	c9                   	leave  
    38a7:	c3                   	ret    

000038a8 <ucvector_init>:

static ucvector ucvector_init(unsigned char* buffer, size_t size) {
    38a8:	55                   	push   %ebp
    38a9:	89 e5                	mov    %esp,%ebp
    38ab:	83 ec 10             	sub    $0x10,%esp
  ucvector v;
  v.data = buffer;
    38ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    38b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  v.allocsize = v.size = size;
    38b4:	8b 45 10             	mov    0x10(%ebp),%eax
    38b7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    38ba:	8b 45 f8             	mov    -0x8(%ebp),%eax
    38bd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return v;
    38c0:	8b 45 08             	mov    0x8(%ebp),%eax
    38c3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    38c6:	89 10                	mov    %edx,(%eax)
    38c8:	8b 55 f8             	mov    -0x8(%ebp),%edx
    38cb:	89 50 04             	mov    %edx,0x4(%eax)
    38ce:	8b 55 fc             	mov    -0x4(%ebp),%edx
    38d1:	89 50 08             	mov    %edx,0x8(%eax)
}
    38d4:	8b 45 08             	mov    0x8(%ebp),%eax
    38d7:	c9                   	leave  
    38d8:	c2 04 00             	ret    $0x4

000038db <string_cleanup>:

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

/*free string pointer and set it to NULL*/
static void string_cleanup(char** out) {
    38db:	55                   	push   %ebp
    38dc:	89 e5                	mov    %esp,%ebp
    38de:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(*out);
    38e1:	8b 45 08             	mov    0x8(%ebp),%eax
    38e4:	8b 00                	mov    (%eax),%eax
    38e6:	83 ec 0c             	sub    $0xc,%esp
    38e9:	50                   	push   %eax
    38ea:	e8 19 fd ff ff       	call   3608 <lodepng_free>
    38ef:	83 c4 10             	add    $0x10,%esp
  *out = NULL;
    38f2:	8b 45 08             	mov    0x8(%ebp),%eax
    38f5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
    38fb:	90                   	nop
    38fc:	c9                   	leave  
    38fd:	c3                   	ret    

000038fe <alloc_string_sized>:

/*also appends null termination character*/
static char* alloc_string_sized(const char* in, size_t insize) {
    38fe:	55                   	push   %ebp
    38ff:	89 e5                	mov    %esp,%ebp
    3901:	83 ec 18             	sub    $0x18,%esp
  char* out = (char*)lodepng_malloc(insize + 1);
    3904:	8b 45 0c             	mov    0xc(%ebp),%eax
    3907:	83 c0 01             	add    $0x1,%eax
    390a:	83 ec 0c             	sub    $0xc,%esp
    390d:	50                   	push   %eax
    390e:	e8 d4 fc ff ff       	call   35e7 <lodepng_malloc>
    3913:	83 c4 10             	add    $0x10,%esp
    3916:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(out) {
    3919:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    391d:	74 1f                	je     393e <alloc_string_sized+0x40>
    lodepng_memcpy(out, in, insize);
    391f:	83 ec 04             	sub    $0x4,%esp
    3922:	ff 75 0c             	pushl  0xc(%ebp)
    3925:	ff 75 08             	pushl  0x8(%ebp)
    3928:	ff 75 f4             	pushl  -0xc(%ebp)
    392b:	e8 f5 fc ff ff       	call   3625 <lodepng_memcpy>
    3930:	83 c4 10             	add    $0x10,%esp
    out[insize] = 0;
    3933:	8b 55 0c             	mov    0xc(%ebp),%edx
    3936:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3939:	01 d0                	add    %edx,%eax
    393b:	c6 00 00             	movb   $0x0,(%eax)
  }
  return out;
    393e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    3941:	c9                   	leave  
    3942:	c3                   	ret    

00003943 <alloc_string>:

/* dynamically allocates a new string with a copy of the null terminated input text */
static char* alloc_string(const char* in) {
    3943:	55                   	push   %ebp
    3944:	89 e5                	mov    %esp,%ebp
    3946:	83 ec 08             	sub    $0x8,%esp
  return alloc_string_sized(in, lodepng_strlen(in));
    3949:	ff 75 08             	pushl  0x8(%ebp)
    394c:	e8 32 fd ff ff       	call   3683 <lodepng_strlen>
    3951:	83 c4 04             	add    $0x4,%esp
    3954:	83 ec 08             	sub    $0x8,%esp
    3957:	50                   	push   %eax
    3958:	ff 75 08             	pushl  0x8(%ebp)
    395b:	e8 9e ff ff ff       	call   38fe <alloc_string_sized>
    3960:	83 c4 10             	add    $0x10,%esp
}
    3963:	c9                   	leave  
    3964:	c3                   	ret    

00003965 <lodepng_read32bitInt>:
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
    3965:	55                   	push   %ebp
    3966:	89 e5                	mov    %esp,%ebp
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3968:	8b 45 08             	mov    0x8(%ebp),%eax
    396b:	0f b6 00             	movzbl (%eax),%eax
    396e:	0f b6 c0             	movzbl %al,%eax
    3971:	c1 e0 18             	shl    $0x18,%eax
    3974:	89 c2                	mov    %eax,%edx
    3976:	8b 45 08             	mov    0x8(%ebp),%eax
    3979:	83 c0 01             	add    $0x1,%eax
    397c:	0f b6 00             	movzbl (%eax),%eax
    397f:	0f b6 c0             	movzbl %al,%eax
    3982:	c1 e0 10             	shl    $0x10,%eax
    3985:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    3987:	8b 45 08             	mov    0x8(%ebp),%eax
    398a:	83 c0 02             	add    $0x2,%eax
    398d:	0f b6 00             	movzbl (%eax),%eax
    3990:	0f b6 c0             	movzbl %al,%eax
    3993:	c1 e0 08             	shl    $0x8,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    3996:	09 c2                	or     %eax,%edx
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
    3998:	8b 45 08             	mov    0x8(%ebp),%eax
    399b:	83 c0 03             	add    $0x3,%eax
    399e:	0f b6 00             	movzbl (%eax),%eax
    39a1:	0f b6 c0             	movzbl %al,%eax

/* ////////////////////////////////////////////////////////////////////////// */

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)
static unsigned lodepng_read32bitInt(const unsigned char* buffer) {
  return (((unsigned)buffer[0] << 24u) | ((unsigned)buffer[1] << 16u) |
    39a4:	09 d0                	or     %edx,%eax
         ((unsigned)buffer[2] << 8u) | (unsigned)buffer[3]);
}
    39a6:	5d                   	pop    %ebp
    39a7:	c3                   	ret    

000039a8 <lodepng_set32bitInt>:
#endif /*defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_PNG)*/

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value) {
    39a8:	55                   	push   %ebp
    39a9:	89 e5                	mov    %esp,%ebp
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
    39ab:	8b 45 0c             	mov    0xc(%ebp),%eax
    39ae:	c1 e8 18             	shr    $0x18,%eax
    39b1:	89 c2                	mov    %eax,%edx
    39b3:	8b 45 08             	mov    0x8(%ebp),%eax
    39b6:	88 10                	mov    %dl,(%eax)
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
    39b8:	8b 45 08             	mov    0x8(%ebp),%eax
    39bb:	83 c0 01             	add    $0x1,%eax
    39be:	8b 55 0c             	mov    0xc(%ebp),%edx
    39c1:	c1 ea 10             	shr    $0x10,%edx
    39c4:	88 10                	mov    %dl,(%eax)
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
    39c6:	8b 45 08             	mov    0x8(%ebp),%eax
    39c9:	83 c0 02             	add    $0x2,%eax
    39cc:	8b 55 0c             	mov    0xc(%ebp),%edx
    39cf:	c1 ea 08             	shr    $0x8,%edx
    39d2:	88 10                	mov    %dl,(%eax)
  buffer[3] = (unsigned char)((value      ) & 0xff);
    39d4:	8b 45 08             	mov    0x8(%ebp),%eax
    39d7:	83 c0 03             	add    $0x3,%eax
    39da:	8b 55 0c             	mov    0xc(%ebp),%edx
    39dd:	88 10                	mov    %dl,(%eax)
}
    39df:	90                   	nop
    39e0:	5d                   	pop    %ebp
    39e1:	c3                   	ret    

000039e2 <lodepng_filesize>:
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

/* returns negative value on error. This should be pure C compatible, so no fstat. */
static long lodepng_filesize(const char* filename) {
    39e2:	55                   	push   %ebp
    39e3:	89 e5                	mov    %esp,%ebp
    39e5:	83 ec 28             	sub    $0x28,%esp
  // if(size == LONG_MAX) size = -1;

  // fclose(file);
  // return size;
  struct stat s;
  stat(filename, &s);
    39e8:	83 ec 08             	sub    $0x8,%esp
    39eb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    39ee:	50                   	push   %eax
    39ef:	ff 75 08             	pushl  0x8(%ebp)
    39f2:	e8 b7 ca ff ff       	call   4ae <stat>
    39f7:	83 c4 10             	add    $0x10,%esp
  return s.size;
    39fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    39fd:	c9                   	leave  
    39fe:	c3                   	ret    

000039ff <lodepng_buffer_file>:

/* load file into buffer that already has the correct allocated size. Returns error code.*/
static unsigned lodepng_buffer_file(unsigned char* out, size_t size, const char* filename) {
    39ff:	55                   	push   %ebp
    3a00:	89 e5                	mov    %esp,%ebp
    3a02:	83 ec 18             	sub    $0x18,%esp
  // readsize = fread(out, 1, size, file);
  // fclose(file);

  // if(readsize != size) return 78;
  // return 0;
  int file = open(filename,  O_RDONLY);
    3a05:	83 ec 08             	sub    $0x8,%esp
    3a08:	6a 00                	push   $0x0
    3a0a:	ff 75 10             	pushl  0x10(%ebp)
    3a0d:	e8 bb cb ff ff       	call   5cd <open>
    3a12:	83 c4 10             	add    $0x10,%esp
    3a15:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (file<0)
    3a18:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3a1c:	79 07                	jns    3a25 <lodepng_buffer_file+0x26>
  {
      return -1;
    3a1e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    3a23:	eb 19                	jmp    3a3e <lodepng_buffer_file+0x3f>
  }
  read(file, out, size);
    3a25:	83 ec 04             	sub    $0x4,%esp
    3a28:	ff 75 0c             	pushl  0xc(%ebp)
    3a2b:	ff 75 08             	pushl  0x8(%ebp)
    3a2e:	ff 75 f4             	pushl  -0xc(%ebp)
    3a31:	e8 6f cb ff ff       	call   5a5 <read>
    3a36:	83 c4 10             	add    $0x10,%esp
  return 0;
    3a39:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3a3e:	c9                   	leave  
    3a3f:	c3                   	ret    

00003a40 <lodepng_load_file>:

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename) {
    3a40:	55                   	push   %ebp
    3a41:	89 e5                	mov    %esp,%ebp
    3a43:	83 ec 18             	sub    $0x18,%esp
  long size = lodepng_filesize(filename);
    3a46:	83 ec 0c             	sub    $0xc,%esp
    3a49:	ff 75 10             	pushl  0x10(%ebp)
    3a4c:	e8 91 ff ff ff       	call   39e2 <lodepng_filesize>
    3a51:	83 c4 10             	add    $0x10,%esp
    3a54:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(size < 0) return 78;
    3a57:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3a5b:	79 07                	jns    3a64 <lodepng_load_file+0x24>
    3a5d:	b8 4e 00 00 00       	mov    $0x4e,%eax
    3a62:	eb 4a                	jmp    3aae <lodepng_load_file+0x6e>
  *outsize = (size_t)size;
    3a64:	8b 45 0c             	mov    0xc(%ebp),%eax
    3a67:	8b 55 f4             	mov    -0xc(%ebp),%edx
    3a6a:	89 10                	mov    %edx,(%eax)

  *out = (unsigned char*)lodepng_malloc((size_t)size);
    3a6c:	83 ec 0c             	sub    $0xc,%esp
    3a6f:	ff 75 f4             	pushl  -0xc(%ebp)
    3a72:	e8 70 fb ff ff       	call   35e7 <lodepng_malloc>
    3a77:	83 c4 10             	add    $0x10,%esp
    3a7a:	89 c2                	mov    %eax,%edx
    3a7c:	8b 45 08             	mov    0x8(%ebp),%eax
    3a7f:	89 10                	mov    %edx,(%eax)
  if(!(*out) && size > 0) return 83; /*the above malloc failed*/
    3a81:	8b 45 08             	mov    0x8(%ebp),%eax
    3a84:	8b 00                	mov    (%eax),%eax
    3a86:	85 c0                	test   %eax,%eax
    3a88:	75 0d                	jne    3a97 <lodepng_load_file+0x57>
    3a8a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    3a8e:	7e 07                	jle    3a97 <lodepng_load_file+0x57>
    3a90:	b8 53 00 00 00       	mov    $0x53,%eax
    3a95:	eb 17                	jmp    3aae <lodepng_load_file+0x6e>

  return lodepng_buffer_file(*out, (size_t)size, filename);
    3a97:	8b 45 08             	mov    0x8(%ebp),%eax
    3a9a:	8b 00                	mov    (%eax),%eax
    3a9c:	83 ec 04             	sub    $0x4,%esp
    3a9f:	ff 75 10             	pushl  0x10(%ebp)
    3aa2:	ff 75 f4             	pushl  -0xc(%ebp)
    3aa5:	50                   	push   %eax
    3aa6:	e8 54 ff ff ff       	call   39ff <lodepng_buffer_file>
    3aab:	83 c4 10             	add    $0x10,%esp
}
    3aae:	c9                   	leave  
    3aaf:	c3                   	ret    

00003ab0 <lodepng_save_file>:

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename) {
    3ab0:	55                   	push   %ebp
    3ab1:	89 e5                	mov    %esp,%ebp
  // file = fopen(filename, "wb" );
  // if(!file) return 79;
  // fwrite(buffer, 1, buffersize, file);
  // fclose(file);
  // return 0;
  return -1;
    3ab3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
    3ab8:	5d                   	pop    %ebp
    3ab9:	c3                   	ret    

00003aba <LodePNGBitWriter_init>:
typedef struct {
  ucvector* data;
  unsigned char bp; /*ok to overflow, indicates bit pos inside byte*/
} LodePNGBitWriter;

static void LodePNGBitWriter_init(LodePNGBitWriter* writer, ucvector* data) {
    3aba:	55                   	push   %ebp
    3abb:	89 e5                	mov    %esp,%ebp
  writer->data = data;
    3abd:	8b 45 08             	mov    0x8(%ebp),%eax
    3ac0:	8b 55 0c             	mov    0xc(%ebp),%edx
    3ac3:	89 10                	mov    %edx,(%eax)
  writer->bp = 0;
    3ac5:	8b 45 08             	mov    0x8(%ebp),%eax
    3ac8:	c6 40 04 00          	movb   $0x0,0x4(%eax)
}
    3acc:	90                   	nop
    3acd:	5d                   	pop    %ebp
    3ace:	c3                   	ret    

00003acf <writeBits>:
  (writer->data->data[writer->data->size - 1]) |= (bit << ((writer->bp) & 7u));\
  ++writer->bp;\
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3acf:	55                   	push   %ebp
    3ad0:	89 e5                	mov    %esp,%ebp
    3ad2:	56                   	push   %esi
    3ad3:	53                   	push   %ebx
    3ad4:	83 ec 14             	sub    $0x14,%esp
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    3ad7:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    3adb:	0f 85 aa 00 00 00    	jne    3b8b <writeBits+0xbc>
    WRITEBIT(writer, value);
    3ae1:	8b 45 08             	mov    0x8(%ebp),%eax
    3ae4:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3ae8:	0f b6 c0             	movzbl %al,%eax
    3aeb:	83 e0 07             	and    $0x7,%eax
    3aee:	85 c0                	test   %eax,%eax
    3af0:	75 39                	jne    3b2b <writeBits+0x5c>
    3af2:	8b 45 08             	mov    0x8(%ebp),%eax
    3af5:	8b 00                	mov    (%eax),%eax
    3af7:	8b 40 04             	mov    0x4(%eax),%eax
    3afa:	8d 50 01             	lea    0x1(%eax),%edx
    3afd:	8b 45 08             	mov    0x8(%ebp),%eax
    3b00:	8b 00                	mov    (%eax),%eax
    3b02:	52                   	push   %edx
    3b03:	50                   	push   %eax
    3b04:	e8 38 fd ff ff       	call   3841 <ucvector_resize>
    3b09:	83 c4 08             	add    $0x8,%esp
    3b0c:	85 c0                	test   %eax,%eax
    3b0e:	0f 84 44 01 00 00    	je     3c58 <writeBits+0x189>
    3b14:	8b 45 08             	mov    0x8(%ebp),%eax
    3b17:	8b 00                	mov    (%eax),%eax
    3b19:	8b 10                	mov    (%eax),%edx
    3b1b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b1e:	8b 00                	mov    (%eax),%eax
    3b20:	8b 40 04             	mov    0x4(%eax),%eax
    3b23:	83 e8 01             	sub    $0x1,%eax
    3b26:	01 d0                	add    %edx,%eax
    3b28:	c6 00 00             	movb   $0x0,(%eax)
    3b2b:	8b 45 08             	mov    0x8(%ebp),%eax
    3b2e:	8b 00                	mov    (%eax),%eax
    3b30:	8b 10                	mov    (%eax),%edx
    3b32:	8b 45 08             	mov    0x8(%ebp),%eax
    3b35:	8b 00                	mov    (%eax),%eax
    3b37:	8b 40 04             	mov    0x4(%eax),%eax
    3b3a:	83 e8 01             	sub    $0x1,%eax
    3b3d:	01 c2                	add    %eax,%edx
    3b3f:	8b 45 08             	mov    0x8(%ebp),%eax
    3b42:	8b 00                	mov    (%eax),%eax
    3b44:	8b 08                	mov    (%eax),%ecx
    3b46:	8b 45 08             	mov    0x8(%ebp),%eax
    3b49:	8b 00                	mov    (%eax),%eax
    3b4b:	8b 40 04             	mov    0x4(%eax),%eax
    3b4e:	83 e8 01             	sub    $0x1,%eax
    3b51:	01 c8                	add    %ecx,%eax
    3b53:	0f b6 00             	movzbl (%eax),%eax
    3b56:	88 45 e7             	mov    %al,-0x19(%ebp)
    3b59:	8b 45 08             	mov    0x8(%ebp),%eax
    3b5c:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3b60:	0f b6 c0             	movzbl %al,%eax
    3b63:	83 e0 07             	and    $0x7,%eax
    3b66:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3b69:	89 de                	mov    %ebx,%esi
    3b6b:	89 c1                	mov    %eax,%ecx
    3b6d:	d3 e6                	shl    %cl,%esi
    3b6f:	89 f0                	mov    %esi,%eax
    3b71:	0a 45 e7             	or     -0x19(%ebp),%al
    3b74:	88 02                	mov    %al,(%edx)
    3b76:	8b 45 08             	mov    0x8(%ebp),%eax
    3b79:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3b7d:	8d 50 01             	lea    0x1(%eax),%edx
    3b80:	8b 45 08             	mov    0x8(%ebp),%eax
    3b83:	88 50 04             	mov    %dl,0x4(%eax)
    3b86:	e9 d1 00 00 00       	jmp    3c5c <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3b8b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3b92:	e9 b3 00 00 00       	jmp    3c4a <writeBits+0x17b>
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3b97:	8b 45 08             	mov    0x8(%ebp),%eax
    3b9a:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3b9e:	0f b6 c0             	movzbl %al,%eax
    3ba1:	83 e0 07             	and    $0x7,%eax
    3ba4:	85 c0                	test   %eax,%eax
    3ba6:	75 39                	jne    3be1 <writeBits+0x112>
    3ba8:	8b 45 08             	mov    0x8(%ebp),%eax
    3bab:	8b 00                	mov    (%eax),%eax
    3bad:	8b 40 04             	mov    0x4(%eax),%eax
    3bb0:	8d 50 01             	lea    0x1(%eax),%edx
    3bb3:	8b 45 08             	mov    0x8(%ebp),%eax
    3bb6:	8b 00                	mov    (%eax),%eax
    3bb8:	52                   	push   %edx
    3bb9:	50                   	push   %eax
    3bba:	e8 82 fc ff ff       	call   3841 <ucvector_resize>
    3bbf:	83 c4 08             	add    $0x8,%esp
    3bc2:	85 c0                	test   %eax,%eax
    3bc4:	0f 84 91 00 00 00    	je     3c5b <writeBits+0x18c>
    3bca:	8b 45 08             	mov    0x8(%ebp),%eax
    3bcd:	8b 00                	mov    (%eax),%eax
    3bcf:	8b 10                	mov    (%eax),%edx
    3bd1:	8b 45 08             	mov    0x8(%ebp),%eax
    3bd4:	8b 00                	mov    (%eax),%eax
    3bd6:	8b 40 04             	mov    0x4(%eax),%eax
    3bd9:	83 e8 01             	sub    $0x1,%eax
    3bdc:	01 d0                	add    %edx,%eax
    3bde:	c6 00 00             	movb   $0x0,(%eax)
    3be1:	8b 45 08             	mov    0x8(%ebp),%eax
    3be4:	8b 00                	mov    (%eax),%eax
    3be6:	8b 10                	mov    (%eax),%edx
    3be8:	8b 45 08             	mov    0x8(%ebp),%eax
    3beb:	8b 00                	mov    (%eax),%eax
    3bed:	8b 40 04             	mov    0x4(%eax),%eax
    3bf0:	83 e8 01             	sub    $0x1,%eax
    3bf3:	01 c2                	add    %eax,%edx
    3bf5:	8b 45 08             	mov    0x8(%ebp),%eax
    3bf8:	8b 00                	mov    (%eax),%eax
    3bfa:	8b 08                	mov    (%eax),%ecx
    3bfc:	8b 45 08             	mov    0x8(%ebp),%eax
    3bff:	8b 00                	mov    (%eax),%eax
    3c01:	8b 40 04             	mov    0x4(%eax),%eax
    3c04:	83 e8 01             	sub    $0x1,%eax
    3c07:	01 c8                	add    %ecx,%eax
    3c09:	0f b6 00             	movzbl (%eax),%eax
    3c0c:	89 c6                	mov    %eax,%esi
    3c0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3c11:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3c14:	89 c1                	mov    %eax,%ecx
    3c16:	d3 eb                	shr    %cl,%ebx
    3c18:	89 d8                	mov    %ebx,%eax
    3c1a:	83 e0 01             	and    $0x1,%eax
    3c1d:	89 c3                	mov    %eax,%ebx
    3c1f:	8b 45 08             	mov    0x8(%ebp),%eax
    3c22:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3c26:	0f b6 c0             	movzbl %al,%eax
    3c29:	83 e0 07             	and    $0x7,%eax
    3c2c:	89 c1                	mov    %eax,%ecx
    3c2e:	d3 e3                	shl    %cl,%ebx
    3c30:	89 d8                	mov    %ebx,%eax
    3c32:	09 f0                	or     %esi,%eax
    3c34:	88 02                	mov    %al,(%edx)
    3c36:	8b 45 08             	mov    0x8(%ebp),%eax
    3c39:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3c3d:	8d 50 01             	lea    0x1(%eax),%edx
    3c40:	8b 45 08             	mov    0x8(%ebp),%eax
    3c43:	88 50 04             	mov    %dl,0x4(%eax)
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
    3c46:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3c4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3c4d:	3b 45 10             	cmp    0x10(%ebp),%eax
    3c50:	0f 85 41 ff ff ff    	jne    3b97 <writeBits+0xc8>
    3c56:	eb 04                	jmp    3c5c <writeBits+0x18d>
}

/* LSB of value is written first, and LSB of bytes is used first */
static void writeBits(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  if(nbits == 1) { /* compiler should statically compile this case if nbits == 1 */
    WRITEBIT(writer, value);
    3c58:	90                   	nop
    3c59:	eb 01                	jmp    3c5c <writeBits+0x18d>
  } else {
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    size_t i;
    for(i = 0; i != nbits; ++i) {
      WRITEBIT(writer, (unsigned char)((value >> i) & 1));
    3c5b:	90                   	nop
    }
  }
}
    3c5c:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3c5f:	5b                   	pop    %ebx
    3c60:	5e                   	pop    %esi
    3c61:	5d                   	pop    %ebp
    3c62:	c3                   	ret    

00003c63 <writeBitsReversed>:

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
    3c63:	55                   	push   %ebp
    3c64:	89 e5                	mov    %esp,%ebp
    3c66:	56                   	push   %esi
    3c67:	53                   	push   %ebx
    3c68:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3c6b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    3c72:	e9 bd 00 00 00       	jmp    3d34 <writeBitsReversed+0xd1>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3c77:	8b 45 08             	mov    0x8(%ebp),%eax
    3c7a:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3c7e:	0f b6 c0             	movzbl %al,%eax
    3c81:	83 e0 07             	and    $0x7,%eax
    3c84:	85 c0                	test   %eax,%eax
    3c86:	75 39                	jne    3cc1 <writeBitsReversed+0x5e>
    3c88:	8b 45 08             	mov    0x8(%ebp),%eax
    3c8b:	8b 00                	mov    (%eax),%eax
    3c8d:	8b 40 04             	mov    0x4(%eax),%eax
    3c90:	8d 50 01             	lea    0x1(%eax),%edx
    3c93:	8b 45 08             	mov    0x8(%ebp),%eax
    3c96:	8b 00                	mov    (%eax),%eax
    3c98:	52                   	push   %edx
    3c99:	50                   	push   %eax
    3c9a:	e8 a2 fb ff ff       	call   3841 <ucvector_resize>
    3c9f:	83 c4 08             	add    $0x8,%esp
    3ca2:	85 c0                	test   %eax,%eax
    3ca4:	0f 84 98 00 00 00    	je     3d42 <writeBitsReversed+0xdf>
    3caa:	8b 45 08             	mov    0x8(%ebp),%eax
    3cad:	8b 00                	mov    (%eax),%eax
    3caf:	8b 10                	mov    (%eax),%edx
    3cb1:	8b 45 08             	mov    0x8(%ebp),%eax
    3cb4:	8b 00                	mov    (%eax),%eax
    3cb6:	8b 40 04             	mov    0x4(%eax),%eax
    3cb9:	83 e8 01             	sub    $0x1,%eax
    3cbc:	01 d0                	add    %edx,%eax
    3cbe:	c6 00 00             	movb   $0x0,(%eax)
    3cc1:	8b 45 08             	mov    0x8(%ebp),%eax
    3cc4:	8b 00                	mov    (%eax),%eax
    3cc6:	8b 10                	mov    (%eax),%edx
    3cc8:	8b 45 08             	mov    0x8(%ebp),%eax
    3ccb:	8b 00                	mov    (%eax),%eax
    3ccd:	8b 40 04             	mov    0x4(%eax),%eax
    3cd0:	83 e8 01             	sub    $0x1,%eax
    3cd3:	01 c2                	add    %eax,%edx
    3cd5:	8b 45 08             	mov    0x8(%ebp),%eax
    3cd8:	8b 00                	mov    (%eax),%eax
    3cda:	8b 08                	mov    (%eax),%ecx
    3cdc:	8b 45 08             	mov    0x8(%ebp),%eax
    3cdf:	8b 00                	mov    (%eax),%eax
    3ce1:	8b 40 04             	mov    0x4(%eax),%eax
    3ce4:	83 e8 01             	sub    $0x1,%eax
    3ce7:	01 c8                	add    %ecx,%eax
    3ce9:	0f b6 00             	movzbl (%eax),%eax
    3cec:	89 c6                	mov    %eax,%esi
    3cee:	8b 4d 10             	mov    0x10(%ebp),%ecx
    3cf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3cf4:	29 c1                	sub    %eax,%ecx
    3cf6:	89 c8                	mov    %ecx,%eax
    3cf8:	83 e8 01             	sub    $0x1,%eax
    3cfb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    3cfe:	89 c1                	mov    %eax,%ecx
    3d00:	d3 eb                	shr    %cl,%ebx
    3d02:	89 d8                	mov    %ebx,%eax
    3d04:	83 e0 01             	and    $0x1,%eax
    3d07:	89 c3                	mov    %eax,%ebx
    3d09:	8b 45 08             	mov    0x8(%ebp),%eax
    3d0c:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3d10:	0f b6 c0             	movzbl %al,%eax
    3d13:	83 e0 07             	and    $0x7,%eax
    3d16:	89 c1                	mov    %eax,%ecx
    3d18:	d3 e3                	shl    %cl,%ebx
    3d1a:	89 d8                	mov    %ebx,%eax
    3d1c:	09 f0                	or     %esi,%eax
    3d1e:	88 02                	mov    %al,(%edx)
    3d20:	8b 45 08             	mov    0x8(%ebp),%eax
    3d23:	0f b6 40 04          	movzbl 0x4(%eax),%eax
    3d27:	8d 50 01             	lea    0x1(%eax),%edx
    3d2a:	8b 45 08             	mov    0x8(%ebp),%eax
    3d2d:	88 50 04             	mov    %dl,0x4(%eax)
}

/* This one is to use for adding huffman symbol, the value bits are written MSB first */
static void writeBitsReversed(LodePNGBitWriter* writer, unsigned value, size_t nbits) {
  size_t i;
  for(i = 0; i != nbits; ++i) {
    3d30:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    3d34:	8b 45 f4             	mov    -0xc(%ebp),%eax
    3d37:	3b 45 10             	cmp    0x10(%ebp),%eax
    3d3a:	0f 85 37 ff ff ff    	jne    3c77 <writeBitsReversed+0x14>
    3d40:	eb 01                	jmp    3d43 <writeBitsReversed+0xe0>
    /* TODO: increase output size only once here rather than in each WRITEBIT */
    WRITEBIT(writer, (unsigned char)((value >> (nbits - 1u - i)) & 1u));
    3d42:	90                   	nop
  }
}
    3d43:	8d 65 f8             	lea    -0x8(%ebp),%esp
    3d46:	5b                   	pop    %ebx
    3d47:	5e                   	pop    %esi
    3d48:	5d                   	pop    %ebp
    3d49:	c3                   	ret    

00003d4a <LodePNGBitReader_init>:
  size_t bp;
  unsigned buffer; /*buffer for reading bits. NOTE: 'unsigned' must support at least 32 bits*/
} LodePNGBitReader;

/* data size argument is in bytes. Returns error if size too large causing overflow */
static unsigned LodePNGBitReader_init(LodePNGBitReader* reader, const unsigned char* data, size_t size) {
    3d4a:	55                   	push   %ebp
    3d4b:	89 e5                	mov    %esp,%ebp
    3d4d:	83 ec 10             	sub    $0x10,%esp
  size_t temp;
  reader->data = data;
    3d50:	8b 45 08             	mov    0x8(%ebp),%eax
    3d53:	8b 55 0c             	mov    0xc(%ebp),%edx
    3d56:	89 10                	mov    %edx,(%eax)
  reader->size = size;
    3d58:	8b 45 08             	mov    0x8(%ebp),%eax
    3d5b:	8b 55 10             	mov    0x10(%ebp),%edx
    3d5e:	89 50 04             	mov    %edx,0x4(%eax)
  /* size in bits, return error if overflow (if size_t is 32 bit this supports up to 500MB)  */
  if(lodepng_mulofl(size, 8u, &reader->bitsize)) return 105;
    3d61:	8b 45 08             	mov    0x8(%ebp),%eax
    3d64:	83 c0 08             	add    $0x8,%eax
    3d67:	50                   	push   %eax
    3d68:	6a 08                	push   $0x8
    3d6a:	ff 75 10             	pushl  0x10(%ebp)
    3d6d:	e8 59 f9 ff ff       	call   36cb <lodepng_mulofl>
    3d72:	83 c4 0c             	add    $0xc,%esp
    3d75:	85 c0                	test   %eax,%eax
    3d77:	74 07                	je     3d80 <LodePNGBitReader_init+0x36>
    3d79:	b8 69 00 00 00       	mov    $0x69,%eax
    3d7e:	eb 39                	jmp    3db9 <LodePNGBitReader_init+0x6f>
  /*ensure incremented bp can be compared to bitsize without overflow even when it would be incremented 32 too much and
  trying to ensure 32 more bits*/
  if(lodepng_addofl(reader->bitsize, 64u, &temp)) return 105;
    3d80:	8b 45 08             	mov    0x8(%ebp),%eax
    3d83:	8b 40 08             	mov    0x8(%eax),%eax
    3d86:	8d 55 fc             	lea    -0x4(%ebp),%edx
    3d89:	52                   	push   %edx
    3d8a:	6a 40                	push   $0x40
    3d8c:	50                   	push   %eax
    3d8d:	e8 19 f9 ff ff       	call   36ab <lodepng_addofl>
    3d92:	83 c4 0c             	add    $0xc,%esp
    3d95:	85 c0                	test   %eax,%eax
    3d97:	74 07                	je     3da0 <LodePNGBitReader_init+0x56>
    3d99:	b8 69 00 00 00       	mov    $0x69,%eax
    3d9e:	eb 19                	jmp    3db9 <LodePNGBitReader_init+0x6f>
  reader->bp = 0;
    3da0:	8b 45 08             	mov    0x8(%ebp),%eax
    3da3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  reader->buffer = 0;
    3daa:	8b 45 08             	mov    0x8(%ebp),%eax
    3dad:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  return 0; /*ok*/
    3db4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    3db9:	c9                   	leave  
    3dba:	c3                   	ret    

00003dbb <ensureBits9>:
  reader->buffer = (unsigned)reader->data[reader->bp >> 3u] >> (reader->bp & 7u);
  return 1;
}*/

/*See ensureBits documentation above. This one ensures up to 9 bits */
static unsigned ensureBits9(LodePNGBitReader* reader, size_t nbits) {
    3dbb:	55                   	push   %ebp
    3dbc:	89 e5                	mov    %esp,%ebp
    3dbe:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3dc1:	8b 45 08             	mov    0x8(%ebp),%eax
    3dc4:	8b 40 0c             	mov    0xc(%eax),%eax
    3dc7:	c1 f8 03             	sar    $0x3,%eax
    3dca:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3dcd:	8b 45 08             	mov    0x8(%ebp),%eax
    3dd0:	8b 40 04             	mov    0x4(%eax),%eax
    3dd3:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 1u < size) {
    3dd6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3dd9:	8d 50 01             	lea    0x1(%eax),%edx
    3ddc:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ddf:	39 c2                	cmp    %eax,%edx
    3de1:	73 4e                	jae    3e31 <ensureBits9+0x76>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u);
    3de3:	8b 45 08             	mov    0x8(%ebp),%eax
    3de6:	8b 10                	mov    (%eax),%edx
    3de8:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3deb:	01 d0                	add    %edx,%eax
    3ded:	0f b6 00             	movzbl (%eax),%eax
    3df0:	0f b6 d0             	movzbl %al,%edx
    3df3:	8b 45 08             	mov    0x8(%ebp),%eax
    3df6:	8b 00                	mov    (%eax),%eax
    3df8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3dfb:	83 c1 01             	add    $0x1,%ecx
    3dfe:	01 c8                	add    %ecx,%eax
    3e00:	0f b6 00             	movzbl (%eax),%eax
    3e03:	0f b6 c0             	movzbl %al,%eax
    3e06:	c1 e0 08             	shl    $0x8,%eax
    3e09:	09 c2                	or     %eax,%edx
    3e0b:	8b 45 08             	mov    0x8(%ebp),%eax
    3e0e:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3e11:	8b 45 08             	mov    0x8(%ebp),%eax
    3e14:	8b 50 10             	mov    0x10(%eax),%edx
    3e17:	8b 45 08             	mov    0x8(%ebp),%eax
    3e1a:	8b 40 0c             	mov    0xc(%eax),%eax
    3e1d:	83 e0 07             	and    $0x7,%eax
    3e20:	89 c1                	mov    %eax,%ecx
    3e22:	d3 ea                	shr    %cl,%edx
    3e24:	8b 45 08             	mov    0x8(%ebp),%eax
    3e27:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3e2a:	b8 01 00 00 00       	mov    $0x1,%eax
    3e2f:	eb 64                	jmp    3e95 <ensureBits9+0xda>
  } else {
    reader->buffer = 0;
    3e31:	8b 45 08             	mov    0x8(%ebp),%eax
    3e34:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3e3b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3e3e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3e41:	39 c2                	cmp    %eax,%edx
    3e43:	73 1e                	jae    3e63 <ensureBits9+0xa8>
    3e45:	8b 45 08             	mov    0x8(%ebp),%eax
    3e48:	8b 50 10             	mov    0x10(%eax),%edx
    3e4b:	8b 45 08             	mov    0x8(%ebp),%eax
    3e4e:	8b 08                	mov    (%eax),%ecx
    3e50:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3e53:	01 c8                	add    %ecx,%eax
    3e55:	0f b6 00             	movzbl (%eax),%eax
    3e58:	0f b6 c0             	movzbl %al,%eax
    3e5b:	09 c2                	or     %eax,%edx
    3e5d:	8b 45 08             	mov    0x8(%ebp),%eax
    3e60:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3e63:	8b 45 08             	mov    0x8(%ebp),%eax
    3e66:	8b 50 10             	mov    0x10(%eax),%edx
    3e69:	8b 45 08             	mov    0x8(%ebp),%eax
    3e6c:	8b 40 0c             	mov    0xc(%eax),%eax
    3e6f:	83 e0 07             	and    $0x7,%eax
    3e72:	89 c1                	mov    %eax,%ecx
    3e74:	d3 ea                	shr    %cl,%edx
    3e76:	8b 45 08             	mov    0x8(%ebp),%eax
    3e79:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3e7c:	8b 45 08             	mov    0x8(%ebp),%eax
    3e7f:	8b 50 0c             	mov    0xc(%eax),%edx
    3e82:	8b 45 0c             	mov    0xc(%ebp),%eax
    3e85:	01 c2                	add    %eax,%edx
    3e87:	8b 45 08             	mov    0x8(%ebp),%eax
    3e8a:	8b 40 08             	mov    0x8(%eax),%eax
    3e8d:	39 c2                	cmp    %eax,%edx
    3e8f:	0f 9e c0             	setle  %al
    3e92:	0f b6 c0             	movzbl %al,%eax
  }
}
    3e95:	c9                   	leave  
    3e96:	c3                   	ret    

00003e97 <ensureBits17>:

/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
    3e97:	55                   	push   %ebp
    3e98:	89 e5                	mov    %esp,%ebp
    3e9a:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3e9d:	8b 45 08             	mov    0x8(%ebp),%eax
    3ea0:	8b 40 0c             	mov    0xc(%eax),%eax
    3ea3:	c1 f8 03             	sar    $0x3,%eax
    3ea6:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3ea9:	8b 45 08             	mov    0x8(%ebp),%eax
    3eac:	8b 40 04             	mov    0x4(%eax),%eax
    3eaf:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 2u < size) {
    3eb2:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3eb5:	8d 50 02             	lea    0x2(%eax),%edx
    3eb8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3ebb:	39 c2                	cmp    %eax,%edx
    3ebd:	73 6d                	jae    3f2c <ensureBits17+0x95>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3ebf:	8b 45 08             	mov    0x8(%ebp),%eax
    3ec2:	8b 10                	mov    (%eax),%edx
    3ec4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ec7:	01 d0                	add    %edx,%eax
    3ec9:	0f b6 00             	movzbl (%eax),%eax
    3ecc:	0f b6 d0             	movzbl %al,%edx
    3ecf:	8b 45 08             	mov    0x8(%ebp),%eax
    3ed2:	8b 00                	mov    (%eax),%eax
    3ed4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3ed7:	83 c1 01             	add    $0x1,%ecx
    3eda:	01 c8                	add    %ecx,%eax
    3edc:	0f b6 00             	movzbl (%eax),%eax
    3edf:	0f b6 c0             	movzbl %al,%eax
    3ee2:	c1 e0 08             	shl    $0x8,%eax
    3ee5:	89 d1                	mov    %edx,%ecx
    3ee7:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u);
    3ee9:	8b 45 08             	mov    0x8(%ebp),%eax
    3eec:	8b 00                	mov    (%eax),%eax
    3eee:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3ef1:	83 c2 02             	add    $0x2,%edx
    3ef4:	01 d0                	add    %edx,%eax
    3ef6:	0f b6 00             	movzbl (%eax),%eax
    3ef9:	0f b6 c0             	movzbl %al,%eax
    3efc:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 17 bits */
static unsigned ensureBits17(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 2u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3eff:	09 c1                	or     %eax,%ecx
    3f01:	89 ca                	mov    %ecx,%edx
    3f03:	8b 45 08             	mov    0x8(%ebp),%eax
    3f06:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u);
    reader->buffer >>= (reader->bp & 7u);
    3f09:	8b 45 08             	mov    0x8(%ebp),%eax
    3f0c:	8b 50 10             	mov    0x10(%eax),%edx
    3f0f:	8b 45 08             	mov    0x8(%ebp),%eax
    3f12:	8b 40 0c             	mov    0xc(%eax),%eax
    3f15:	83 e0 07             	and    $0x7,%eax
    3f18:	89 c1                	mov    %eax,%ecx
    3f1a:	d3 ea                	shr    %cl,%edx
    3f1c:	8b 45 08             	mov    0x8(%ebp),%eax
    3f1f:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    3f22:	b8 01 00 00 00       	mov    $0x1,%eax
    3f27:	e9 95 00 00 00       	jmp    3fc1 <ensureBits17+0x12a>
  } else {
    reader->buffer = 0;
    3f2c:	8b 45 08             	mov    0x8(%ebp),%eax
    3f2f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    3f36:	8b 55 fc             	mov    -0x4(%ebp),%edx
    3f39:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f3c:	39 c2                	cmp    %eax,%edx
    3f3e:	73 1e                	jae    3f5e <ensureBits17+0xc7>
    3f40:	8b 45 08             	mov    0x8(%ebp),%eax
    3f43:	8b 50 10             	mov    0x10(%eax),%edx
    3f46:	8b 45 08             	mov    0x8(%ebp),%eax
    3f49:	8b 08                	mov    (%eax),%ecx
    3f4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3f4e:	01 c8                	add    %ecx,%eax
    3f50:	0f b6 00             	movzbl (%eax),%eax
    3f53:	0f b6 c0             	movzbl %al,%eax
    3f56:	09 c2                	or     %eax,%edx
    3f58:	8b 45 08             	mov    0x8(%ebp),%eax
    3f5b:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    3f5e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3f61:	8d 50 01             	lea    0x1(%eax),%edx
    3f64:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3f67:	39 c2                	cmp    %eax,%edx
    3f69:	73 24                	jae    3f8f <ensureBits17+0xf8>
    3f6b:	8b 45 08             	mov    0x8(%ebp),%eax
    3f6e:	8b 50 10             	mov    0x10(%eax),%edx
    3f71:	8b 45 08             	mov    0x8(%ebp),%eax
    3f74:	8b 00                	mov    (%eax),%eax
    3f76:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    3f79:	83 c1 01             	add    $0x1,%ecx
    3f7c:	01 c8                	add    %ecx,%eax
    3f7e:	0f b6 00             	movzbl (%eax),%eax
    3f81:	0f b6 c0             	movzbl %al,%eax
    3f84:	c1 e0 08             	shl    $0x8,%eax
    3f87:	09 c2                	or     %eax,%edx
    3f89:	8b 45 08             	mov    0x8(%ebp),%eax
    3f8c:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    3f8f:	8b 45 08             	mov    0x8(%ebp),%eax
    3f92:	8b 50 10             	mov    0x10(%eax),%edx
    3f95:	8b 45 08             	mov    0x8(%ebp),%eax
    3f98:	8b 40 0c             	mov    0xc(%eax),%eax
    3f9b:	83 e0 07             	and    $0x7,%eax
    3f9e:	89 c1                	mov    %eax,%ecx
    3fa0:	d3 ea                	shr    %cl,%edx
    3fa2:	8b 45 08             	mov    0x8(%ebp),%eax
    3fa5:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    3fa8:	8b 45 08             	mov    0x8(%ebp),%eax
    3fab:	8b 50 0c             	mov    0xc(%eax),%edx
    3fae:	8b 45 0c             	mov    0xc(%ebp),%eax
    3fb1:	01 c2                	add    %eax,%edx
    3fb3:	8b 45 08             	mov    0x8(%ebp),%eax
    3fb6:	8b 40 08             	mov    0x8(%eax),%eax
    3fb9:	39 c2                	cmp    %eax,%edx
    3fbb:	0f 9e c0             	setle  %al
    3fbe:	0f b6 c0             	movzbl %al,%eax
  }
}
    3fc1:	c9                   	leave  
    3fc2:	c3                   	ret    

00003fc3 <ensureBits25>:

/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
    3fc3:	55                   	push   %ebp
    3fc4:	89 e5                	mov    %esp,%ebp
    3fc6:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    3fc9:	8b 45 08             	mov    0x8(%ebp),%eax
    3fcc:	8b 40 0c             	mov    0xc(%eax),%eax
    3fcf:	c1 f8 03             	sar    $0x3,%eax
    3fd2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t size = reader->size;
    3fd5:	8b 45 08             	mov    0x8(%ebp),%eax
    3fd8:	8b 40 04             	mov    0x4(%eax),%eax
    3fdb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(start + 3u < size) {
    3fde:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3fe1:	8d 50 03             	lea    0x3(%eax),%edx
    3fe4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    3fe7:	39 c2                	cmp    %eax,%edx
    3fe9:	0f 83 85 00 00 00    	jae    4074 <ensureBits25+0xb1>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    3fef:	8b 45 08             	mov    0x8(%ebp),%eax
    3ff2:	8b 10                	mov    (%eax),%edx
    3ff4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    3ff7:	01 d0                	add    %edx,%eax
    3ff9:	0f b6 00             	movzbl (%eax),%eax
    3ffc:	0f b6 d0             	movzbl %al,%edx
    3fff:	8b 45 08             	mov    0x8(%ebp),%eax
    4002:	8b 00                	mov    (%eax),%eax
    4004:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    4007:	83 c1 01             	add    $0x1,%ecx
    400a:	01 c8                	add    %ecx,%eax
    400c:	0f b6 00             	movzbl (%eax),%eax
    400f:	0f b6 c0             	movzbl %al,%eax
    4012:	c1 e0 08             	shl    $0x8,%eax
    4015:	89 d1                	mov    %edx,%ecx
    4017:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4019:	8b 45 08             	mov    0x8(%ebp),%eax
    401c:	8b 00                	mov    (%eax),%eax
    401e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4021:	83 c2 02             	add    $0x2,%edx
    4024:	01 d0                	add    %edx,%eax
    4026:	0f b6 00             	movzbl (%eax),%eax
    4029:	0f b6 c0             	movzbl %al,%eax
    402c:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    402f:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4031:	8b 45 08             	mov    0x8(%ebp),%eax
    4034:	8b 00                	mov    (%eax),%eax
    4036:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4039:	83 c2 03             	add    $0x3,%edx
    403c:	01 d0                	add    %edx,%eax
    403e:	0f b6 00             	movzbl (%eax),%eax
    4041:	0f b6 c0             	movzbl %al,%eax
    4044:	c1 e0 18             	shl    $0x18,%eax
    4047:	09 c1                	or     %eax,%ecx
    4049:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 25 bits */
static LODEPNG_INLINE unsigned ensureBits25(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 3u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    404b:	8b 45 08             	mov    0x8(%ebp),%eax
    404e:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    4051:	8b 45 08             	mov    0x8(%ebp),%eax
    4054:	8b 50 10             	mov    0x10(%eax),%edx
    4057:	8b 45 08             	mov    0x8(%ebp),%eax
    405a:	8b 40 0c             	mov    0xc(%eax),%eax
    405d:	83 e0 07             	and    $0x7,%eax
    4060:	89 c1                	mov    %eax,%ecx
    4062:	d3 ea                	shr    %cl,%edx
    4064:	8b 45 08             	mov    0x8(%ebp),%eax
    4067:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    406a:	b8 01 00 00 00       	mov    $0x1,%eax
    406f:	e9 c6 00 00 00       	jmp    413a <ensureBits25+0x177>
  } else {
    reader->buffer = 0;
    4074:	8b 45 08             	mov    0x8(%ebp),%eax
    4077:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    407e:	8b 55 fc             	mov    -0x4(%ebp),%edx
    4081:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4084:	39 c2                	cmp    %eax,%edx
    4086:	73 1e                	jae    40a6 <ensureBits25+0xe3>
    4088:	8b 45 08             	mov    0x8(%ebp),%eax
    408b:	8b 50 10             	mov    0x10(%eax),%edx
    408e:	8b 45 08             	mov    0x8(%ebp),%eax
    4091:	8b 08                	mov    (%eax),%ecx
    4093:	8b 45 fc             	mov    -0x4(%ebp),%eax
    4096:	01 c8                	add    %ecx,%eax
    4098:	0f b6 00             	movzbl (%eax),%eax
    409b:	0f b6 c0             	movzbl %al,%eax
    409e:	09 c2                	or     %eax,%edx
    40a0:	8b 45 08             	mov    0x8(%ebp),%eax
    40a3:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    40a6:	8b 45 fc             	mov    -0x4(%ebp),%eax
    40a9:	8d 50 01             	lea    0x1(%eax),%edx
    40ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
    40af:	39 c2                	cmp    %eax,%edx
    40b1:	73 24                	jae    40d7 <ensureBits25+0x114>
    40b3:	8b 45 08             	mov    0x8(%ebp),%eax
    40b6:	8b 50 10             	mov    0x10(%eax),%edx
    40b9:	8b 45 08             	mov    0x8(%ebp),%eax
    40bc:	8b 00                	mov    (%eax),%eax
    40be:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    40c1:	83 c1 01             	add    $0x1,%ecx
    40c4:	01 c8                	add    %ecx,%eax
    40c6:	0f b6 00             	movzbl (%eax),%eax
    40c9:	0f b6 c0             	movzbl %al,%eax
    40cc:	c1 e0 08             	shl    $0x8,%eax
    40cf:	09 c2                	or     %eax,%edx
    40d1:	8b 45 08             	mov    0x8(%ebp),%eax
    40d4:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    40d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    40da:	8d 50 02             	lea    0x2(%eax),%edx
    40dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    40e0:	39 c2                	cmp    %eax,%edx
    40e2:	73 24                	jae    4108 <ensureBits25+0x145>
    40e4:	8b 45 08             	mov    0x8(%ebp),%eax
    40e7:	8b 50 10             	mov    0x10(%eax),%edx
    40ea:	8b 45 08             	mov    0x8(%ebp),%eax
    40ed:	8b 00                	mov    (%eax),%eax
    40ef:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    40f2:	83 c1 02             	add    $0x2,%ecx
    40f5:	01 c8                	add    %ecx,%eax
    40f7:	0f b6 00             	movzbl (%eax),%eax
    40fa:	0f b6 c0             	movzbl %al,%eax
    40fd:	c1 e0 10             	shl    $0x10,%eax
    4100:	09 c2                	or     %eax,%edx
    4102:	8b 45 08             	mov    0x8(%ebp),%eax
    4105:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    4108:	8b 45 08             	mov    0x8(%ebp),%eax
    410b:	8b 50 10             	mov    0x10(%eax),%edx
    410e:	8b 45 08             	mov    0x8(%ebp),%eax
    4111:	8b 40 0c             	mov    0xc(%eax),%eax
    4114:	83 e0 07             	and    $0x7,%eax
    4117:	89 c1                	mov    %eax,%ecx
    4119:	d3 ea                	shr    %cl,%edx
    411b:	8b 45 08             	mov    0x8(%ebp),%eax
    411e:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    4121:	8b 45 08             	mov    0x8(%ebp),%eax
    4124:	8b 50 0c             	mov    0xc(%eax),%edx
    4127:	8b 45 0c             	mov    0xc(%ebp),%eax
    412a:	01 c2                	add    %eax,%edx
    412c:	8b 45 08             	mov    0x8(%ebp),%eax
    412f:	8b 40 08             	mov    0x8(%eax),%eax
    4132:	39 c2                	cmp    %eax,%edx
    4134:	0f 9e c0             	setle  %al
    4137:	0f b6 c0             	movzbl %al,%eax
  }
}
    413a:	c9                   	leave  
    413b:	c3                   	ret    

0000413c <ensureBits32>:

/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
    413c:	55                   	push   %ebp
    413d:	89 e5                	mov    %esp,%ebp
    413f:	53                   	push   %ebx
    4140:	83 ec 10             	sub    $0x10,%esp
  size_t start = reader->bp >> 3u;
    4143:	8b 45 08             	mov    0x8(%ebp),%eax
    4146:	8b 40 0c             	mov    0xc(%eax),%eax
    4149:	c1 f8 03             	sar    $0x3,%eax
    414c:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = reader->size;
    414f:	8b 45 08             	mov    0x8(%ebp),%eax
    4152:	8b 40 04             	mov    0x4(%eax),%eax
    4155:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(start + 4u < size) {
    4158:	8b 45 f8             	mov    -0x8(%ebp),%eax
    415b:	8d 50 04             	lea    0x4(%eax),%edx
    415e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4161:	39 c2                	cmp    %eax,%edx
    4163:	0f 83 c3 00 00 00    	jae    422c <ensureBits32+0xf0>
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    4169:	8b 45 08             	mov    0x8(%ebp),%eax
    416c:	8b 10                	mov    (%eax),%edx
    416e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4171:	01 d0                	add    %edx,%eax
    4173:	0f b6 00             	movzbl (%eax),%eax
    4176:	0f b6 d0             	movzbl %al,%edx
    4179:	8b 45 08             	mov    0x8(%ebp),%eax
    417c:	8b 00                	mov    (%eax),%eax
    417e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4181:	83 c1 01             	add    $0x1,%ecx
    4184:	01 c8                	add    %ecx,%eax
    4186:	0f b6 00             	movzbl (%eax),%eax
    4189:	0f b6 c0             	movzbl %al,%eax
    418c:	c1 e0 08             	shl    $0x8,%eax
    418f:	89 d1                	mov    %edx,%ecx
    4191:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    4193:	8b 45 08             	mov    0x8(%ebp),%eax
    4196:	8b 00                	mov    (%eax),%eax
    4198:	8b 55 f8             	mov    -0x8(%ebp),%edx
    419b:	83 c2 02             	add    $0x2,%edx
    419e:	01 d0                	add    %edx,%eax
    41a0:	0f b6 00             	movzbl (%eax),%eax
    41a3:	0f b6 c0             	movzbl %al,%eax
    41a6:	c1 e0 10             	shl    $0x10,%eax
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    41a9:	09 c1                	or     %eax,%ecx
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    41ab:	8b 45 08             	mov    0x8(%ebp),%eax
    41ae:	8b 00                	mov    (%eax),%eax
    41b0:	8b 55 f8             	mov    -0x8(%ebp),%edx
    41b3:	83 c2 03             	add    $0x3,%edx
    41b6:	01 d0                	add    %edx,%eax
    41b8:	0f b6 00             	movzbl (%eax),%eax
    41bb:	0f b6 c0             	movzbl %al,%eax
    41be:	c1 e0 18             	shl    $0x18,%eax
    41c1:	09 c1                	or     %eax,%ecx
    41c3:	89 ca                	mov    %ecx,%edx
/*See ensureBits documentation above. This one ensures up to 32 bits */
static LODEPNG_INLINE unsigned ensureBits32(LodePNGBitReader* reader, size_t nbits) {
  size_t start = reader->bp >> 3u;
  size_t size = reader->size;
  if(start + 4u < size) {
    reader->buffer = (unsigned)reader->data[start + 0] | ((unsigned)reader->data[start + 1] << 8u) |
    41c5:	8b 45 08             	mov    0x8(%ebp),%eax
    41c8:	89 50 10             	mov    %edx,0x10(%eax)
                     ((unsigned)reader->data[start + 2] << 16u) | ((unsigned)reader->data[start + 3] << 24u);
    reader->buffer >>= (reader->bp & 7u);
    41cb:	8b 45 08             	mov    0x8(%ebp),%eax
    41ce:	8b 50 10             	mov    0x10(%eax),%edx
    41d1:	8b 45 08             	mov    0x8(%ebp),%eax
    41d4:	8b 40 0c             	mov    0xc(%eax),%eax
    41d7:	83 e0 07             	and    $0x7,%eax
    41da:	89 c1                	mov    %eax,%ecx
    41dc:	d3 ea                	shr    %cl,%edx
    41de:	8b 45 08             	mov    0x8(%ebp),%eax
    41e1:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer |= (((unsigned)reader->data[start + 4] << 24u) << (8u - (reader->bp & 7u)));
    41e4:	8b 45 08             	mov    0x8(%ebp),%eax
    41e7:	8b 50 10             	mov    0x10(%eax),%edx
    41ea:	8b 45 08             	mov    0x8(%ebp),%eax
    41ed:	8b 00                	mov    (%eax),%eax
    41ef:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    41f2:	83 c1 04             	add    $0x4,%ecx
    41f5:	01 c8                	add    %ecx,%eax
    41f7:	0f b6 00             	movzbl (%eax),%eax
    41fa:	0f b6 c0             	movzbl %al,%eax
    41fd:	c1 e0 18             	shl    $0x18,%eax
    4200:	89 c3                	mov    %eax,%ebx
    4202:	8b 45 08             	mov    0x8(%ebp),%eax
    4205:	8b 40 0c             	mov    0xc(%eax),%eax
    4208:	83 e0 07             	and    $0x7,%eax
    420b:	b9 08 00 00 00       	mov    $0x8,%ecx
    4210:	29 c1                	sub    %eax,%ecx
    4212:	89 c8                	mov    %ecx,%eax
    4214:	89 c1                	mov    %eax,%ecx
    4216:	d3 e3                	shl    %cl,%ebx
    4218:	89 d8                	mov    %ebx,%eax
    421a:	09 c2                	or     %eax,%edx
    421c:	8b 45 08             	mov    0x8(%ebp),%eax
    421f:	89 50 10             	mov    %edx,0x10(%eax)
    return 1;
    4222:	b8 01 00 00 00       	mov    $0x1,%eax
    4227:	e9 f7 00 00 00       	jmp    4323 <ensureBits32+0x1e7>
  } else {
    reader->buffer = 0;
    422c:	8b 45 08             	mov    0x8(%ebp),%eax
    422f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
    if(start + 0u < size) reader->buffer |= reader->data[start + 0];
    4236:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4239:	8b 45 f4             	mov    -0xc(%ebp),%eax
    423c:	39 c2                	cmp    %eax,%edx
    423e:	73 1e                	jae    425e <ensureBits32+0x122>
    4240:	8b 45 08             	mov    0x8(%ebp),%eax
    4243:	8b 50 10             	mov    0x10(%eax),%edx
    4246:	8b 45 08             	mov    0x8(%ebp),%eax
    4249:	8b 08                	mov    (%eax),%ecx
    424b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    424e:	01 c8                	add    %ecx,%eax
    4250:	0f b6 00             	movzbl (%eax),%eax
    4253:	0f b6 c0             	movzbl %al,%eax
    4256:	09 c2                	or     %eax,%edx
    4258:	8b 45 08             	mov    0x8(%ebp),%eax
    425b:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 1u < size) reader->buffer |= ((unsigned)reader->data[start + 1] << 8u);
    425e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4261:	8d 50 01             	lea    0x1(%eax),%edx
    4264:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4267:	39 c2                	cmp    %eax,%edx
    4269:	73 24                	jae    428f <ensureBits32+0x153>
    426b:	8b 45 08             	mov    0x8(%ebp),%eax
    426e:	8b 50 10             	mov    0x10(%eax),%edx
    4271:	8b 45 08             	mov    0x8(%ebp),%eax
    4274:	8b 00                	mov    (%eax),%eax
    4276:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4279:	83 c1 01             	add    $0x1,%ecx
    427c:	01 c8                	add    %ecx,%eax
    427e:	0f b6 00             	movzbl (%eax),%eax
    4281:	0f b6 c0             	movzbl %al,%eax
    4284:	c1 e0 08             	shl    $0x8,%eax
    4287:	09 c2                	or     %eax,%edx
    4289:	8b 45 08             	mov    0x8(%ebp),%eax
    428c:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 2u < size) reader->buffer |= ((unsigned)reader->data[start + 2] << 16u);
    428f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4292:	8d 50 02             	lea    0x2(%eax),%edx
    4295:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4298:	39 c2                	cmp    %eax,%edx
    429a:	73 24                	jae    42c0 <ensureBits32+0x184>
    429c:	8b 45 08             	mov    0x8(%ebp),%eax
    429f:	8b 50 10             	mov    0x10(%eax),%edx
    42a2:	8b 45 08             	mov    0x8(%ebp),%eax
    42a5:	8b 00                	mov    (%eax),%eax
    42a7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    42aa:	83 c1 02             	add    $0x2,%ecx
    42ad:	01 c8                	add    %ecx,%eax
    42af:	0f b6 00             	movzbl (%eax),%eax
    42b2:	0f b6 c0             	movzbl %al,%eax
    42b5:	c1 e0 10             	shl    $0x10,%eax
    42b8:	09 c2                	or     %eax,%edx
    42ba:	8b 45 08             	mov    0x8(%ebp),%eax
    42bd:	89 50 10             	mov    %edx,0x10(%eax)
    if(start + 3u < size) reader->buffer |= ((unsigned)reader->data[start + 3] << 24u);
    42c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    42c3:	8d 50 03             	lea    0x3(%eax),%edx
    42c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    42c9:	39 c2                	cmp    %eax,%edx
    42cb:	73 24                	jae    42f1 <ensureBits32+0x1b5>
    42cd:	8b 45 08             	mov    0x8(%ebp),%eax
    42d0:	8b 50 10             	mov    0x10(%eax),%edx
    42d3:	8b 45 08             	mov    0x8(%ebp),%eax
    42d6:	8b 00                	mov    (%eax),%eax
    42d8:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    42db:	83 c1 03             	add    $0x3,%ecx
    42de:	01 c8                	add    %ecx,%eax
    42e0:	0f b6 00             	movzbl (%eax),%eax
    42e3:	0f b6 c0             	movzbl %al,%eax
    42e6:	c1 e0 18             	shl    $0x18,%eax
    42e9:	09 c2                	or     %eax,%edx
    42eb:	8b 45 08             	mov    0x8(%ebp),%eax
    42ee:	89 50 10             	mov    %edx,0x10(%eax)
    reader->buffer >>= (reader->bp & 7u);
    42f1:	8b 45 08             	mov    0x8(%ebp),%eax
    42f4:	8b 50 10             	mov    0x10(%eax),%edx
    42f7:	8b 45 08             	mov    0x8(%ebp),%eax
    42fa:	8b 40 0c             	mov    0xc(%eax),%eax
    42fd:	83 e0 07             	and    $0x7,%eax
    4300:	89 c1                	mov    %eax,%ecx
    4302:	d3 ea                	shr    %cl,%edx
    4304:	8b 45 08             	mov    0x8(%ebp),%eax
    4307:	89 50 10             	mov    %edx,0x10(%eax)
    return reader->bp + nbits <= reader->bitsize;
    430a:	8b 45 08             	mov    0x8(%ebp),%eax
    430d:	8b 50 0c             	mov    0xc(%eax),%edx
    4310:	8b 45 0c             	mov    0xc(%ebp),%eax
    4313:	01 c2                	add    %eax,%edx
    4315:	8b 45 08             	mov    0x8(%ebp),%eax
    4318:	8b 40 08             	mov    0x8(%eax),%eax
    431b:	39 c2                	cmp    %eax,%edx
    431d:	0f 9e c0             	setle  %al
    4320:	0f b6 c0             	movzbl %al,%eax
  }
}
    4323:	83 c4 10             	add    $0x10,%esp
    4326:	5b                   	pop    %ebx
    4327:	5d                   	pop    %ebp
    4328:	c3                   	ret    

00004329 <peekBits>:

/* Get bits without advancing the bit pointer. Must have enough bits available with ensureBits. Max nbits is 31. */
static unsigned peekBits(LodePNGBitReader* reader, size_t nbits) {
    4329:	55                   	push   %ebp
    432a:	89 e5                	mov    %esp,%ebp
    432c:	53                   	push   %ebx
  /* The shift allows nbits to be only up to 31. */
  return reader->buffer & ((1u << nbits) - 1u);
    432d:	8b 45 08             	mov    0x8(%ebp),%eax
    4330:	8b 50 10             	mov    0x10(%eax),%edx
    4333:	8b 45 0c             	mov    0xc(%ebp),%eax
    4336:	bb 01 00 00 00       	mov    $0x1,%ebx
    433b:	89 c1                	mov    %eax,%ecx
    433d:	d3 e3                	shl    %cl,%ebx
    433f:	89 d8                	mov    %ebx,%eax
    4341:	83 e8 01             	sub    $0x1,%eax
    4344:	21 d0                	and    %edx,%eax
}
    4346:	5b                   	pop    %ebx
    4347:	5d                   	pop    %ebp
    4348:	c3                   	ret    

00004349 <advanceBits>:

/* Must have enough bits available with ensureBits */
static void advanceBits(LodePNGBitReader* reader, size_t nbits) {
    4349:	55                   	push   %ebp
    434a:	89 e5                	mov    %esp,%ebp
  reader->buffer >>= nbits;
    434c:	8b 45 08             	mov    0x8(%ebp),%eax
    434f:	8b 50 10             	mov    0x10(%eax),%edx
    4352:	8b 45 0c             	mov    0xc(%ebp),%eax
    4355:	89 c1                	mov    %eax,%ecx
    4357:	d3 ea                	shr    %cl,%edx
    4359:	8b 45 08             	mov    0x8(%ebp),%eax
    435c:	89 50 10             	mov    %edx,0x10(%eax)
  reader->bp += nbits;
    435f:	8b 45 08             	mov    0x8(%ebp),%eax
    4362:	8b 50 0c             	mov    0xc(%eax),%edx
    4365:	8b 45 0c             	mov    0xc(%ebp),%eax
    4368:	01 c2                	add    %eax,%edx
    436a:	8b 45 08             	mov    0x8(%ebp),%eax
    436d:	89 50 0c             	mov    %edx,0xc(%eax)
}
    4370:	90                   	nop
    4371:	5d                   	pop    %ebp
    4372:	c3                   	ret    

00004373 <readBits>:

/* Must have enough bits available with ensureBits */
static unsigned readBits(LodePNGBitReader* reader, size_t nbits) {
    4373:	55                   	push   %ebp
    4374:	89 e5                	mov    %esp,%ebp
    4376:	83 ec 10             	sub    $0x10,%esp
  unsigned result = peekBits(reader, nbits);
    4379:	ff 75 0c             	pushl  0xc(%ebp)
    437c:	ff 75 08             	pushl  0x8(%ebp)
    437f:	e8 a5 ff ff ff       	call   4329 <peekBits>
    4384:	83 c4 08             	add    $0x8,%esp
    4387:	89 45 fc             	mov    %eax,-0x4(%ebp)
  advanceBits(reader, nbits);
    438a:	ff 75 0c             	pushl  0xc(%ebp)
    438d:	ff 75 08             	pushl  0x8(%ebp)
    4390:	e8 b4 ff ff ff       	call   4349 <advanceBits>
    4395:	83 c4 08             	add    $0x8,%esp
  return result;
    4398:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    439b:	c9                   	leave  
    439c:	c3                   	ret    

0000439d <lode_png_test_bitreader>:

/* Public for testing only. steps and result must have numsteps values. */
unsigned lode_png_test_bitreader(const unsigned char* data, size_t size,
                                 size_t numsteps, const size_t* steps, unsigned* result) {
    439d:	55                   	push   %ebp
    439e:	89 e5                	mov    %esp,%ebp
    43a0:	53                   	push   %ebx
    43a1:	83 ec 30             	sub    $0x30,%esp
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
    43a4:	ff 75 0c             	pushl  0xc(%ebp)
    43a7:	ff 75 08             	pushl  0x8(%ebp)
    43aa:	8d 45 d8             	lea    -0x28(%ebp),%eax
    43ad:	50                   	push   %eax
    43ae:	e8 97 f9 ff ff       	call   3d4a <LodePNGBitReader_init>
    43b3:	83 c4 0c             	add    $0xc,%esp
    43b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if(error) return 0;
    43b9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    43bd:	74 0a                	je     43c9 <lode_png_test_bitreader+0x2c>
    43bf:	b8 00 00 00 00       	mov    $0x0,%eax
    43c4:	e9 c3 00 00 00       	jmp    448c <lode_png_test_bitreader+0xef>
  for(i = 0; i < numsteps; i++) {
    43c9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    43d0:	e9 a6 00 00 00       	jmp    447b <lode_png_test_bitreader+0xde>
    size_t step = steps[i];
    43d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
    43d8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    43df:	8b 45 14             	mov    0x14(%ebp),%eax
    43e2:	01 d0                	add    %edx,%eax
    43e4:	8b 00                	mov    (%eax),%eax
    43e6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    unsigned ok;
    if(step > 25) ok = ensureBits32(&reader, step);
    43e9:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
    43ed:	7e 14                	jle    4403 <lode_png_test_bitreader+0x66>
    43ef:	ff 75 ec             	pushl  -0x14(%ebp)
    43f2:	8d 45 d8             	lea    -0x28(%ebp),%eax
    43f5:	50                   	push   %eax
    43f6:	e8 41 fd ff ff       	call   413c <ensureBits32>
    43fb:	83 c4 08             	add    $0x8,%esp
    43fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4401:	eb 46                	jmp    4449 <lode_png_test_bitreader+0xac>
    else if(step > 17) ok = ensureBits25(&reader, step);
    4403:	83 7d ec 11          	cmpl   $0x11,-0x14(%ebp)
    4407:	7e 14                	jle    441d <lode_png_test_bitreader+0x80>
    4409:	ff 75 ec             	pushl  -0x14(%ebp)
    440c:	8d 45 d8             	lea    -0x28(%ebp),%eax
    440f:	50                   	push   %eax
    4410:	e8 ae fb ff ff       	call   3fc3 <ensureBits25>
    4415:	83 c4 08             	add    $0x8,%esp
    4418:	89 45 f4             	mov    %eax,-0xc(%ebp)
    441b:	eb 2c                	jmp    4449 <lode_png_test_bitreader+0xac>
    else if(step > 9) ok = ensureBits17(&reader, step);
    441d:	83 7d ec 09          	cmpl   $0x9,-0x14(%ebp)
    4421:	7e 14                	jle    4437 <lode_png_test_bitreader+0x9a>
    4423:	ff 75 ec             	pushl  -0x14(%ebp)
    4426:	8d 45 d8             	lea    -0x28(%ebp),%eax
    4429:	50                   	push   %eax
    442a:	e8 68 fa ff ff       	call   3e97 <ensureBits17>
    442f:	83 c4 08             	add    $0x8,%esp
    4432:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4435:	eb 12                	jmp    4449 <lode_png_test_bitreader+0xac>
    else ok = ensureBits9(&reader, step);
    4437:	ff 75 ec             	pushl  -0x14(%ebp)
    443a:	8d 45 d8             	lea    -0x28(%ebp),%eax
    443d:	50                   	push   %eax
    443e:	e8 78 f9 ff ff       	call   3dbb <ensureBits9>
    4443:	83 c4 08             	add    $0x8,%esp
    4446:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!ok) return 0;
    4449:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    444d:	75 07                	jne    4456 <lode_png_test_bitreader+0xb9>
    444f:	b8 00 00 00 00       	mov    $0x0,%eax
    4454:	eb 36                	jmp    448c <lode_png_test_bitreader+0xef>
    result[i] = readBits(&reader, step);
    4456:	8b 45 f8             	mov    -0x8(%ebp),%eax
    4459:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4460:	8b 45 18             	mov    0x18(%ebp),%eax
    4463:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    4466:	ff 75 ec             	pushl  -0x14(%ebp)
    4469:	8d 45 d8             	lea    -0x28(%ebp),%eax
    446c:	50                   	push   %eax
    446d:	e8 01 ff ff ff       	call   4373 <readBits>
    4472:	83 c4 08             	add    $0x8,%esp
    4475:	89 03                	mov    %eax,(%ebx)
                                 size_t numsteps, const size_t* steps, unsigned* result) {
  size_t i;
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, data, size);
  if(error) return 0;
  for(i = 0; i < numsteps; i++) {
    4477:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    447b:	8b 45 f8             	mov    -0x8(%ebp),%eax
    447e:	3b 45 10             	cmp    0x10(%ebp),%eax
    4481:	0f 8c 4e ff ff ff    	jl     43d5 <lode_png_test_bitreader+0x38>
    else if(step > 9) ok = ensureBits17(&reader, step);
    else ok = ensureBits9(&reader, step);
    if(!ok) return 0;
    result[i] = readBits(&reader, step);
  }
  return 1;
    4487:	b8 01 00 00 00       	mov    $0x1,%eax
}
    448c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    448f:	c9                   	leave  
    4490:	c3                   	ret    

00004491 <reverseBits>:
#endif /*LODEPNG_COMPILE_DECODER*/

static unsigned reverseBits(unsigned bits, unsigned num) {
    4491:	55                   	push   %ebp
    4492:	89 e5                	mov    %esp,%ebp
    4494:	83 ec 10             	sub    $0x10,%esp
  /*TODO: implement faster lookup table based version when needed*/
  unsigned i, result = 0;
    4497:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(i = 0; i < num; i++) result |= ((bits >> (num - i - 1u)) & 1u) << i;
    449e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    44a5:	eb 27                	jmp    44ce <reverseBits+0x3d>
    44a7:	8b 45 0c             	mov    0xc(%ebp),%eax
    44aa:	2b 45 fc             	sub    -0x4(%ebp),%eax
    44ad:	83 e8 01             	sub    $0x1,%eax
    44b0:	8b 55 08             	mov    0x8(%ebp),%edx
    44b3:	89 c1                	mov    %eax,%ecx
    44b5:	d3 ea                	shr    %cl,%edx
    44b7:	89 d0                	mov    %edx,%eax
    44b9:	83 e0 01             	and    $0x1,%eax
    44bc:	89 c2                	mov    %eax,%edx
    44be:	8b 45 fc             	mov    -0x4(%ebp),%eax
    44c1:	89 c1                	mov    %eax,%ecx
    44c3:	d3 e2                	shl    %cl,%edx
    44c5:	89 d0                	mov    %edx,%eax
    44c7:	09 45 f8             	or     %eax,-0x8(%ebp)
    44ca:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    44ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
    44d1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    44d4:	72 d1                	jb     44a7 <reverseBits+0x16>
  return result;
    44d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
    44d9:	c9                   	leave  
    44da:	c3                   	ret    

000044db <HuffmanTree_init>:
  /* for reading only */
  unsigned char* table_len; /*length of symbol from lookup table, or max length if secondary lookup needed*/
  unsigned short* table_value; /*value of symbol from lookup table, or pointer to secondary table if needed*/
} HuffmanTree;

static void HuffmanTree_init(HuffmanTree* tree) {
    44db:	55                   	push   %ebp
    44dc:	89 e5                	mov    %esp,%ebp
  tree->codes = 0;
    44de:	8b 45 08             	mov    0x8(%ebp),%eax
    44e1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  tree->lengths = 0;
    44e7:	8b 45 08             	mov    0x8(%ebp),%eax
    44ea:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  tree->table_len = 0;
    44f1:	8b 45 08             	mov    0x8(%ebp),%eax
    44f4:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  tree->table_value = 0;
    44fb:	8b 45 08             	mov    0x8(%ebp),%eax
    44fe:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    4505:	90                   	nop
    4506:	5d                   	pop    %ebp
    4507:	c3                   	ret    

00004508 <HuffmanTree_cleanup>:

static void HuffmanTree_cleanup(HuffmanTree* tree) {
    4508:	55                   	push   %ebp
    4509:	89 e5                	mov    %esp,%ebp
    450b:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(tree->codes);
    450e:	8b 45 08             	mov    0x8(%ebp),%eax
    4511:	8b 00                	mov    (%eax),%eax
    4513:	83 ec 0c             	sub    $0xc,%esp
    4516:	50                   	push   %eax
    4517:	e8 ec f0 ff ff       	call   3608 <lodepng_free>
    451c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->lengths);
    451f:	8b 45 08             	mov    0x8(%ebp),%eax
    4522:	8b 40 04             	mov    0x4(%eax),%eax
    4525:	83 ec 0c             	sub    $0xc,%esp
    4528:	50                   	push   %eax
    4529:	e8 da f0 ff ff       	call   3608 <lodepng_free>
    452e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_len);
    4531:	8b 45 08             	mov    0x8(%ebp),%eax
    4534:	8b 40 10             	mov    0x10(%eax),%eax
    4537:	83 ec 0c             	sub    $0xc,%esp
    453a:	50                   	push   %eax
    453b:	e8 c8 f0 ff ff       	call   3608 <lodepng_free>
    4540:	83 c4 10             	add    $0x10,%esp
  lodepng_free(tree->table_value);
    4543:	8b 45 08             	mov    0x8(%ebp),%eax
    4546:	8b 40 14             	mov    0x14(%eax),%eax
    4549:	83 ec 0c             	sub    $0xc,%esp
    454c:	50                   	push   %eax
    454d:	e8 b6 f0 ff ff       	call   3608 <lodepng_free>
    4552:	83 c4 10             	add    $0x10,%esp
}
    4555:	90                   	nop
    4556:	c9                   	leave  
    4557:	c3                   	ret    

00004558 <HuffmanTree_makeTable>:
/* a symbol value too big to represent any valid symbol, to indicate reading disallowed huffman bits combination,
which is possible in case of only 0 or 1 present symbols. */
#define INVALIDSYMBOL 65535u

/* make table for huffman decoding */
static unsigned HuffmanTree_makeTable(HuffmanTree* tree) {
    4558:	55                   	push   %ebp
    4559:	89 e5                	mov    %esp,%ebp
    455b:	83 ec 68             	sub    $0x68,%esp
  static const unsigned headsize = 1u << FIRSTBITS; /*size of the first table*/
  static const unsigned mask = (1u << FIRSTBITS) /*headsize*/ - 1u;
  size_t i, numpresent, pointer, size; /*total table size*/
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
    455e:	a1 88 b8 01 00       	mov    0x1b888,%eax
    4563:	c1 e0 02             	shl    $0x2,%eax
    4566:	83 ec 0c             	sub    $0xc,%esp
    4569:	50                   	push   %eax
    456a:	e8 78 f0 ff ff       	call   35e7 <lodepng_malloc>
    456f:	83 c4 10             	add    $0x10,%esp
    4572:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!maxlens) return 83; /*alloc fail*/
    4575:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    4579:	75 0a                	jne    4585 <HuffmanTree_makeTable+0x2d>
    457b:	b8 53 00 00 00       	mov    $0x53,%eax
    4580:	e9 61 04 00 00       	jmp    49e6 <HuffmanTree_makeTable+0x48e>

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
    4585:	a1 88 b8 01 00       	mov    0x1b888,%eax
    458a:	c1 e0 02             	shl    $0x2,%eax
    458d:	83 ec 04             	sub    $0x4,%esp
    4590:	50                   	push   %eax
    4591:	6a 00                	push   $0x0
    4593:	ff 75 dc             	pushl  -0x24(%ebp)
    4596:	e8 bd f0 ff ff       	call   3658 <lodepng_memset>
    459b:	83 c4 10             	add    $0x10,%esp
  for(i = 0; i < tree->numcodes; i++) {
    459e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    45a5:	eb 7d                	jmp    4624 <HuffmanTree_makeTable+0xcc>
    unsigned symbol = tree->codes[i];
    45a7:	8b 45 08             	mov    0x8(%ebp),%eax
    45aa:	8b 00                	mov    (%eax),%eax
    45ac:	8b 55 f4             	mov    -0xc(%ebp),%edx
    45af:	c1 e2 02             	shl    $0x2,%edx
    45b2:	01 d0                	add    %edx,%eax
    45b4:	8b 00                	mov    (%eax),%eax
    45b6:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned l = tree->lengths[i];
    45b9:	8b 45 08             	mov    0x8(%ebp),%eax
    45bc:	8b 40 04             	mov    0x4(%eax),%eax
    45bf:	8b 55 f4             	mov    -0xc(%ebp),%edx
    45c2:	c1 e2 02             	shl    $0x2,%edx
    45c5:	01 d0                	add    %edx,%eax
    45c7:	8b 00                	mov    (%eax),%eax
    45c9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    45cc:	83 7d d4 09          	cmpl   $0x9,-0x2c(%ebp)
    45d0:	76 4d                	jbe    461f <HuffmanTree_makeTable+0xc7>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    45d2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    45d5:	83 e8 09             	sub    $0x9,%eax
    45d8:	8b 55 d8             	mov    -0x28(%ebp),%edx
    45db:	89 c1                	mov    %eax,%ecx
    45dd:	d3 ea                	shr    %cl,%edx
    45df:	89 d0                	mov    %edx,%eax
    45e1:	83 ec 08             	sub    $0x8,%esp
    45e4:	6a 09                	push   $0x9
    45e6:	50                   	push   %eax
    45e7:	e8 a5 fe ff ff       	call   4491 <reverseBits>
    45ec:	83 c4 10             	add    $0x10,%esp
    45ef:	89 45 d0             	mov    %eax,-0x30(%ebp)
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
    45f2:	8b 45 d0             	mov    -0x30(%ebp),%eax
    45f5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    45fc:	8b 45 dc             	mov    -0x24(%ebp),%eax
    45ff:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    4602:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4605:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    460c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    460f:	01 d0                	add    %edx,%eax
    4611:	8b 10                	mov    (%eax),%edx
    4613:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4616:	39 c2                	cmp    %eax,%edx
    4618:	0f 43 c2             	cmovae %edx,%eax
    461b:	89 01                	mov    %eax,(%ecx)
    461d:	eb 01                	jmp    4620 <HuffmanTree_makeTable+0xc8>
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    unsigned symbol = tree->codes[i];
    unsigned l = tree->lengths[i];
    unsigned index;
    if(l <= FIRSTBITS) continue; /*symbols that fit in first table don't increase secondary table size*/
    461f:	90                   	nop
  unsigned* maxlens = (unsigned*)lodepng_malloc(headsize * sizeof(unsigned));
  if(!maxlens) return 83; /*alloc fail*/

  /* compute maxlens: max total bit length of symbols sharing prefix in the first table*/
  lodepng_memset(maxlens, 0, headsize * sizeof(*maxlens));
  for(i = 0; i < tree->numcodes; i++) {
    4620:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4624:	8b 45 08             	mov    0x8(%ebp),%eax
    4627:	8b 50 0c             	mov    0xc(%eax),%edx
    462a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    462d:	39 c2                	cmp    %eax,%edx
    462f:	0f 87 72 ff ff ff    	ja     45a7 <HuffmanTree_makeTable+0x4f>
    /*get the FIRSTBITS MSBs, the MSBs of the symbol are encoded first. See later comment about the reversing*/
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
    4635:	a1 88 b8 01 00       	mov    0x1b888,%eax
    463a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for(i = 0; i < headsize; ++i) {
    463d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4644:	eb 35                	jmp    467b <HuffmanTree_makeTable+0x123>
    unsigned l = maxlens[i];
    4646:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4649:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4650:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4653:	01 d0                	add    %edx,%eax
    4655:	8b 00                	mov    (%eax),%eax
    4657:	89 45 cc             	mov    %eax,-0x34(%ebp)
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
    465a:	83 7d cc 09          	cmpl   $0x9,-0x34(%ebp)
    465e:	76 17                	jbe    4677 <HuffmanTree_makeTable+0x11f>
    4660:	8b 45 cc             	mov    -0x34(%ebp),%eax
    4663:	83 e8 09             	sub    $0x9,%eax
    4666:	ba 01 00 00 00       	mov    $0x1,%edx
    466b:	89 c1                	mov    %eax,%ecx
    466d:	d3 e2                	shl    %cl,%edx
    466f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4672:	01 d0                	add    %edx,%eax
    4674:	89 45 e8             	mov    %eax,-0x18(%ebp)
    index = reverseBits(symbol >> (l - FIRSTBITS), FIRSTBITS);
    maxlens[index] = LODEPNG_MAX(maxlens[index], l);
  }
  /* compute total table size: size of first table plus all secondary tables for symbols longer than FIRSTBITS */
  size = headsize;
  for(i = 0; i < headsize; ++i) {
    4677:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    467b:	8b 55 f4             	mov    -0xc(%ebp),%edx
    467e:	a1 88 b8 01 00       	mov    0x1b888,%eax
    4683:	39 c2                	cmp    %eax,%edx
    4685:	72 bf                	jb     4646 <HuffmanTree_makeTable+0xee>
    unsigned l = maxlens[i];
    if(l > FIRSTBITS) size += (1u << (l - FIRSTBITS));
  }
  tree->table_len = (unsigned char*)lodepng_malloc(size * sizeof(*tree->table_len));
    4687:	83 ec 0c             	sub    $0xc,%esp
    468a:	ff 75 e8             	pushl  -0x18(%ebp)
    468d:	e8 55 ef ff ff       	call   35e7 <lodepng_malloc>
    4692:	83 c4 10             	add    $0x10,%esp
    4695:	89 c2                	mov    %eax,%edx
    4697:	8b 45 08             	mov    0x8(%ebp),%eax
    469a:	89 50 10             	mov    %edx,0x10(%eax)
  tree->table_value = (unsigned short*)lodepng_malloc(size * sizeof(*tree->table_value));
    469d:	8b 45 e8             	mov    -0x18(%ebp),%eax
    46a0:	01 c0                	add    %eax,%eax
    46a2:	83 ec 0c             	sub    $0xc,%esp
    46a5:	50                   	push   %eax
    46a6:	e8 3c ef ff ff       	call   35e7 <lodepng_malloc>
    46ab:	83 c4 10             	add    $0x10,%esp
    46ae:	89 c2                	mov    %eax,%edx
    46b0:	8b 45 08             	mov    0x8(%ebp),%eax
    46b3:	89 50 14             	mov    %edx,0x14(%eax)
  if(!tree->table_len || !tree->table_value) {
    46b6:	8b 45 08             	mov    0x8(%ebp),%eax
    46b9:	8b 40 10             	mov    0x10(%eax),%eax
    46bc:	85 c0                	test   %eax,%eax
    46be:	74 0a                	je     46ca <HuffmanTree_makeTable+0x172>
    46c0:	8b 45 08             	mov    0x8(%ebp),%eax
    46c3:	8b 40 14             	mov    0x14(%eax),%eax
    46c6:	85 c0                	test   %eax,%eax
    46c8:	75 18                	jne    46e2 <HuffmanTree_makeTable+0x18a>
    lodepng_free(maxlens);
    46ca:	83 ec 0c             	sub    $0xc,%esp
    46cd:	ff 75 dc             	pushl  -0x24(%ebp)
    46d0:	e8 33 ef ff ff       	call   3608 <lodepng_free>
    46d5:	83 c4 10             	add    $0x10,%esp
    /* freeing tree->table values is done at a higher scope */
    return 83; /*alloc fail*/
    46d8:	b8 53 00 00 00       	mov    $0x53,%eax
    46dd:	e9 04 03 00 00       	jmp    49e6 <HuffmanTree_makeTable+0x48e>
  }
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;
    46e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    46e9:	eb 12                	jmp    46fd <HuffmanTree_makeTable+0x1a5>
    46eb:	8b 45 08             	mov    0x8(%ebp),%eax
    46ee:	8b 50 10             	mov    0x10(%eax),%edx
    46f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    46f4:	01 d0                	add    %edx,%eax
    46f6:	c6 00 10             	movb   $0x10,(%eax)
    46f9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    46fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4700:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    4703:	7c e6                	jl     46eb <HuffmanTree_makeTable+0x193>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
    4705:	a1 88 b8 01 00       	mov    0x1b888,%eax
    470a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  for(i = 0; i < headsize; ++i) {
    470d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4714:	eb 5b                	jmp    4771 <HuffmanTree_makeTable+0x219>
    unsigned l = maxlens[i];
    4716:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4719:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4720:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4723:	01 d0                	add    %edx,%eax
    4725:	8b 00                	mov    (%eax),%eax
    4727:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(l <= FIRSTBITS) continue;
    472a:	83 7d c8 09          	cmpl   $0x9,-0x38(%ebp)
    472e:	76 3c                	jbe    476c <HuffmanTree_makeTable+0x214>
    tree->table_len[i] = l;
    4730:	8b 45 08             	mov    0x8(%ebp),%eax
    4733:	8b 50 10             	mov    0x10(%eax),%edx
    4736:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4739:	01 d0                	add    %edx,%eax
    473b:	8b 55 c8             	mov    -0x38(%ebp),%edx
    473e:	88 10                	mov    %dl,(%eax)
    tree->table_value[i] = pointer;
    4740:	8b 45 08             	mov    0x8(%ebp),%eax
    4743:	8b 40 14             	mov    0x14(%eax),%eax
    4746:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4749:	01 d2                	add    %edx,%edx
    474b:	01 d0                	add    %edx,%eax
    474d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4750:	66 89 10             	mov    %dx,(%eax)
    pointer += (1u << (l - FIRSTBITS));
    4753:	8b 45 c8             	mov    -0x38(%ebp),%eax
    4756:	83 e8 09             	sub    $0x9,%eax
    4759:	ba 01 00 00 00       	mov    $0x1,%edx
    475e:	89 c1                	mov    %eax,%ecx
    4760:	d3 e2                	shl    %cl,%edx
    4762:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4765:	01 d0                	add    %edx,%eax
    4767:	89 45 ec             	mov    %eax,-0x14(%ebp)
    476a:	eb 01                	jmp    476d <HuffmanTree_makeTable+0x215>

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    unsigned l = maxlens[i];
    if(l <= FIRSTBITS) continue;
    476c:	90                   	nop
  /*initialize with an invalid length to indicate unused entries*/
  for(i = 0; i < size; ++i) tree->table_len[i] = 16;

  /*fill in the first table for long symbols: max prefix size and pointer to secondary tables*/
  pointer = headsize;
  for(i = 0; i < headsize; ++i) {
    476d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4771:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4774:	a1 88 b8 01 00       	mov    0x1b888,%eax
    4779:	39 c2                	cmp    %eax,%edx
    477b:	72 99                	jb     4716 <HuffmanTree_makeTable+0x1be>
    if(l <= FIRSTBITS) continue;
    tree->table_len[i] = l;
    tree->table_value[i] = pointer;
    pointer += (1u << (l - FIRSTBITS));
  }
  lodepng_free(maxlens);
    477d:	83 ec 0c             	sub    $0xc,%esp
    4780:	ff 75 dc             	pushl  -0x24(%ebp)
    4783:	e8 80 ee ff ff       	call   3608 <lodepng_free>
    4788:	83 c4 10             	add    $0x10,%esp

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
    478b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(i = 0; i < tree->numcodes; ++i) {
    4792:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4799:	e9 9d 01 00 00       	jmp    493b <HuffmanTree_makeTable+0x3e3>
    unsigned l = tree->lengths[i];
    479e:	8b 45 08             	mov    0x8(%ebp),%eax
    47a1:	8b 40 04             	mov    0x4(%eax),%eax
    47a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    47a7:	c1 e2 02             	shl    $0x2,%edx
    47aa:	01 d0                	add    %edx,%eax
    47ac:	8b 00                	mov    (%eax),%eax
    47ae:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    47b1:	8b 45 08             	mov    0x8(%ebp),%eax
    47b4:	8b 00                	mov    (%eax),%eax
    47b6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    47b9:	c1 e2 02             	shl    $0x2,%edx
    47bc:	01 d0                	add    %edx,%eax
    47be:	8b 00                	mov    (%eax),%eax
    47c0:	89 45 c0             	mov    %eax,-0x40(%ebp)
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    47c3:	83 ec 08             	sub    $0x8,%esp
    47c6:	ff 75 c4             	pushl  -0x3c(%ebp)
    47c9:	ff 75 c0             	pushl  -0x40(%ebp)
    47cc:	e8 c0 fc ff ff       	call   4491 <reverseBits>
    47d1:	83 c4 10             	add    $0x10,%esp
    47d4:	89 45 bc             	mov    %eax,-0x44(%ebp)
    if(l == 0) continue;
    47d7:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
    47db:	0f 84 55 01 00 00    	je     4936 <HuffmanTree_makeTable+0x3de>
    numpresent++;
    47e1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

    if(l <= FIRSTBITS) {
    47e5:	83 7d c4 09          	cmpl   $0x9,-0x3c(%ebp)
    47e9:	0f 87 81 00 00 00    	ja     4870 <HuffmanTree_makeTable+0x318>
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
    47ef:	b8 09 00 00 00       	mov    $0x9,%eax
    47f4:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    47f7:	ba 01 00 00 00       	mov    $0x1,%edx
    47fc:	89 c1                	mov    %eax,%ecx
    47fe:	d3 e2                	shl    %cl,%edx
    4800:	89 d0                	mov    %edx,%eax
    4802:	89 45 9c             	mov    %eax,-0x64(%ebp)
      unsigned j;
      for(j = 0; j < num; ++j) {
    4805:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    480c:	eb 55                	jmp    4863 <HuffmanTree_makeTable+0x30b>
        /*bit reader will read the l bits of symbol first, the remaining FIRSTBITS - l bits go to the MSB's*/
        unsigned index = reverse | (j << l);
    480e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    4811:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4814:	89 c1                	mov    %eax,%ecx
    4816:	d3 e2                	shl    %cl,%edx
    4818:	89 d0                	mov    %edx,%eax
    481a:	0b 45 bc             	or     -0x44(%ebp),%eax
    481d:	89 45 98             	mov    %eax,-0x68(%ebp)
        if(tree->table_len[index] != 16) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    4820:	8b 45 08             	mov    0x8(%ebp),%eax
    4823:	8b 50 10             	mov    0x10(%eax),%edx
    4826:	8b 45 98             	mov    -0x68(%ebp),%eax
    4829:	01 d0                	add    %edx,%eax
    482b:	0f b6 00             	movzbl (%eax),%eax
    482e:	3c 10                	cmp    $0x10,%al
    4830:	74 0a                	je     483c <HuffmanTree_makeTable+0x2e4>
    4832:	b8 37 00 00 00       	mov    $0x37,%eax
    4837:	e9 aa 01 00 00       	jmp    49e6 <HuffmanTree_makeTable+0x48e>
        tree->table_len[index] = l;
    483c:	8b 45 08             	mov    0x8(%ebp),%eax
    483f:	8b 50 10             	mov    0x10(%eax),%edx
    4842:	8b 45 98             	mov    -0x68(%ebp),%eax
    4845:	01 d0                	add    %edx,%eax
    4847:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    484a:	88 10                	mov    %dl,(%eax)
        tree->table_value[index] = i;
    484c:	8b 45 08             	mov    0x8(%ebp),%eax
    484f:	8b 40 14             	mov    0x14(%eax),%eax
    4852:	8b 55 98             	mov    -0x68(%ebp),%edx
    4855:	01 d2                	add    %edx,%edx
    4857:	01 d0                	add    %edx,%eax
    4859:	8b 55 f4             	mov    -0xc(%ebp),%edx
    485c:	66 89 10             	mov    %dx,(%eax)

    if(l <= FIRSTBITS) {
      /*short symbol, fully in first table, replicated num times if l < FIRSTBITS*/
      unsigned num = 1u << (FIRSTBITS - l);
      unsigned j;
      for(j = 0; j < num; ++j) {
    485f:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    4863:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4866:	3b 45 9c             	cmp    -0x64(%ebp),%eax
    4869:	72 a3                	jb     480e <HuffmanTree_makeTable+0x2b6>
    486b:	e9 c7 00 00 00       	jmp    4937 <HuffmanTree_makeTable+0x3df>
        tree->table_value[index] = i;
      }
    } else {
      /*long symbol, shares prefix with other long symbols in first lookup table, needs second lookup*/
      /*the FIRSTBITS MSBs of the symbol are the first table index*/
      unsigned index = reverse & mask;
    4870:	a1 8c b8 01 00       	mov    0x1b88c,%eax
    4875:	23 45 bc             	and    -0x44(%ebp),%eax
    4878:	89 45 b8             	mov    %eax,-0x48(%ebp)
      unsigned maxlen = tree->table_len[index];
    487b:	8b 45 08             	mov    0x8(%ebp),%eax
    487e:	8b 50 10             	mov    0x10(%eax),%edx
    4881:	8b 45 b8             	mov    -0x48(%ebp),%eax
    4884:	01 d0                	add    %edx,%eax
    4886:	0f b6 00             	movzbl (%eax),%eax
    4889:	0f b6 c0             	movzbl %al,%eax
    488c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
      /*log2 of secondary table length, should be >= l - FIRSTBITS*/
      unsigned tablelen = maxlen - FIRSTBITS;
    488f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    4892:	83 e8 09             	sub    $0x9,%eax
    4895:	89 45 b0             	mov    %eax,-0x50(%ebp)
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
    4898:	8b 45 08             	mov    0x8(%ebp),%eax
    489b:	8b 40 14             	mov    0x14(%eax),%eax
    489e:	8b 55 b8             	mov    -0x48(%ebp),%edx
    48a1:	01 d2                	add    %edx,%edx
    48a3:	01 d0                	add    %edx,%eax
    48a5:	0f b7 00             	movzwl (%eax),%eax
    48a8:	0f b7 c0             	movzwl %ax,%eax
    48ab:	89 45 ac             	mov    %eax,-0x54(%ebp)
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
    48ae:	8b 45 b0             	mov    -0x50(%ebp),%eax
    48b1:	2b 45 c4             	sub    -0x3c(%ebp),%eax
    48b4:	83 c0 09             	add    $0x9,%eax
    48b7:	ba 01 00 00 00       	mov    $0x1,%edx
    48bc:	89 c1                	mov    %eax,%ecx
    48be:	d3 e2                	shl    %cl,%edx
    48c0:	89 d0                	mov    %edx,%eax
    48c2:	89 45 a8             	mov    %eax,-0x58(%ebp)
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
    48c5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    48c8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    48cb:	73 0a                	jae    48d7 <HuffmanTree_makeTable+0x37f>
    48cd:	b8 37 00 00 00       	mov    $0x37,%eax
    48d2:	e9 0f 01 00 00       	jmp    49e6 <HuffmanTree_makeTable+0x48e>
      for(j = 0; j < num; ++j) {
    48d7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    48de:	eb 4c                	jmp    492c <HuffmanTree_makeTable+0x3d4>
        unsigned reverse2 = reverse >> FIRSTBITS; /* l - FIRSTBITS bits */
    48e0:	8b 45 bc             	mov    -0x44(%ebp),%eax
    48e3:	c1 e8 09             	shr    $0x9,%eax
    48e6:	89 45 a4             	mov    %eax,-0x5c(%ebp)
        unsigned index2 = start + (reverse2 | (j << (l - FIRSTBITS)));
    48e9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    48ec:	83 e8 09             	sub    $0x9,%eax
    48ef:	8b 55 e0             	mov    -0x20(%ebp),%edx
    48f2:	89 c1                	mov    %eax,%ecx
    48f4:	d3 e2                	shl    %cl,%edx
    48f6:	89 d0                	mov    %edx,%eax
    48f8:	0b 45 a4             	or     -0x5c(%ebp),%eax
    48fb:	89 c2                	mov    %eax,%edx
    48fd:	8b 45 ac             	mov    -0x54(%ebp),%eax
    4900:	01 d0                	add    %edx,%eax
    4902:	89 45 a0             	mov    %eax,-0x60(%ebp)
        tree->table_len[index2] = l;
    4905:	8b 45 08             	mov    0x8(%ebp),%eax
    4908:	8b 50 10             	mov    0x10(%eax),%edx
    490b:	8b 45 a0             	mov    -0x60(%ebp),%eax
    490e:	01 d0                	add    %edx,%eax
    4910:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    4913:	88 10                	mov    %dl,(%eax)
        tree->table_value[index2] = i;
    4915:	8b 45 08             	mov    0x8(%ebp),%eax
    4918:	8b 40 14             	mov    0x14(%eax),%eax
    491b:	8b 55 a0             	mov    -0x60(%ebp),%edx
    491e:	01 d2                	add    %edx,%edx
    4920:	01 d0                	add    %edx,%eax
    4922:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4925:	66 89 10             	mov    %dx,(%eax)
      unsigned tablelen = maxlen - FIRSTBITS;
      unsigned start = tree->table_value[index]; /*starting index in secondary table*/
      unsigned num = 1u << (tablelen - (l - FIRSTBITS)); /*amount of entries of this symbol in secondary table*/
      unsigned j;
      if(maxlen < l) return 55; /*invalid tree: long symbol shares prefix with short symbol*/
      for(j = 0; j < num; ++j) {
    4928:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    492c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    492f:	3b 45 a8             	cmp    -0x58(%ebp),%eax
    4932:	72 ac                	jb     48e0 <HuffmanTree_makeTable+0x388>
    4934:	eb 01                	jmp    4937 <HuffmanTree_makeTable+0x3df>
  for(i = 0; i < tree->numcodes; ++i) {
    unsigned l = tree->lengths[i];
    unsigned symbol = tree->codes[i]; /*the huffman bit pattern. i itself is the value.*/
    /*reverse bits, because the huffman bits are given in MSB first order but the bit reader reads LSB first*/
    unsigned reverse = reverseBits(symbol, l);
    if(l == 0) continue;
    4936:	90                   	nop
  }
  lodepng_free(maxlens);

  /*fill in the first table for short symbols, or secondary table for long symbols*/
  numpresent = 0;
  for(i = 0; i < tree->numcodes; ++i) {
    4937:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    493b:	8b 45 08             	mov    0x8(%ebp),%eax
    493e:	8b 50 0c             	mov    0xc(%eax),%edx
    4941:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4944:	39 c2                	cmp    %eax,%edx
    4946:	0f 87 52 fe ff ff    	ja     479e <HuffmanTree_makeTable+0x246>
        tree->table_value[index2] = i;
      }
    }
  }

  if(numpresent < 2) {
    494c:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
    4950:	7f 61                	jg     49b3 <HuffmanTree_makeTable+0x45b>
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    4952:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4959:	eb 4e                	jmp    49a9 <HuffmanTree_makeTable+0x451>
      if(tree->table_len[i] == 16) {
    495b:	8b 45 08             	mov    0x8(%ebp),%eax
    495e:	8b 50 10             	mov    0x10(%eax),%edx
    4961:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4964:	01 d0                	add    %edx,%eax
    4966:	0f b6 00             	movzbl (%eax),%eax
    4969:	3c 10                	cmp    $0x10,%al
    496b:	75 38                	jne    49a5 <HuffmanTree_makeTable+0x44d>
        /* As length, use a value smaller than FIRSTBITS for the head table,
        and a value larger than FIRSTBITS for the secondary table, to ensure
        valid behavior for advanceBits when reading this symbol. */
        tree->table_len[i] = (i < headsize) ? 1 : (FIRSTBITS + 1);
    496d:	8b 45 08             	mov    0x8(%ebp),%eax
    4970:	8b 50 10             	mov    0x10(%eax),%edx
    4973:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4976:	01 d0                	add    %edx,%eax
    4978:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    497b:	8b 15 88 b8 01 00    	mov    0x1b888,%edx
    4981:	39 d1                	cmp    %edx,%ecx
    4983:	73 07                	jae    498c <HuffmanTree_makeTable+0x434>
    4985:	ba 01 00 00 00       	mov    $0x1,%edx
    498a:	eb 05                	jmp    4991 <HuffmanTree_makeTable+0x439>
    498c:	ba 0a 00 00 00       	mov    $0xa,%edx
    4991:	88 10                	mov    %dl,(%eax)
        tree->table_value[i] = INVALIDSYMBOL;
    4993:	8b 45 08             	mov    0x8(%ebp),%eax
    4996:	8b 40 14             	mov    0x14(%eax),%eax
    4999:	8b 55 f4             	mov    -0xc(%ebp),%edx
    499c:	01 d2                	add    %edx,%edx
    499e:	01 d0                	add    %edx,%eax
    49a0:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    but deflate uses 1 bit instead. In case of 0 symbols, no symbols can
    appear at all, but such huffman tree could still exist (e.g. if distance
    codes are never used). In both cases, not all symbols of the table will be
    filled in. Fill them in with an invalid symbol value so returning them from
    huffmanDecodeSymbol will cause error. */
    for(i = 0; i < size; ++i) {
    49a5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    49a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49ac:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    49af:	7c aa                	jl     495b <HuffmanTree_makeTable+0x403>
    49b1:	eb 2e                	jmp    49e1 <HuffmanTree_makeTable+0x489>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    49b3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    49ba:	eb 1d                	jmp    49d9 <HuffmanTree_makeTable+0x481>
      if(tree->table_len[i] == 16) return 55;
    49bc:	8b 45 08             	mov    0x8(%ebp),%eax
    49bf:	8b 50 10             	mov    0x10(%eax),%edx
    49c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49c5:	01 d0                	add    %edx,%eax
    49c7:	0f b6 00             	movzbl (%eax),%eax
    49ca:	3c 10                	cmp    $0x10,%al
    49cc:	75 07                	jne    49d5 <HuffmanTree_makeTable+0x47d>
    49ce:	b8 37 00 00 00       	mov    $0x37,%eax
    49d3:	eb 11                	jmp    49e6 <HuffmanTree_makeTable+0x48e>
  } else {
    /* A good huffman tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
    If that is not the case (due to too long length codes), the table will not
    have been fully used, and this is an error (not all bit combinations can be
    decoded): an oversubscribed huffman tree, indicated by error 55. */
    for(i = 0; i < size; ++i) {
    49d5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    49d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    49dc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    49df:	7c db                	jl     49bc <HuffmanTree_makeTable+0x464>
      if(tree->table_len[i] == 16) return 55;
    }
  }

  return 0;
    49e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    49e6:	c9                   	leave  
    49e7:	c3                   	ret    

000049e8 <HuffmanTree_makeFromLengths2>:
/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree) {
    49e8:	55                   	push   %ebp
    49e9:	89 e5                	mov    %esp,%ebp
    49eb:	56                   	push   %esi
    49ec:	53                   	push   %ebx
    49ed:	83 ec 20             	sub    $0x20,%esp
  unsigned* blcount;
  unsigned* nextcode;
  unsigned error = 0;
    49f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned bits, n;

  tree->codes = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
    49f7:	8b 45 08             	mov    0x8(%ebp),%eax
    49fa:	8b 40 0c             	mov    0xc(%eax),%eax
    49fd:	c1 e0 02             	shl    $0x2,%eax
    4a00:	83 ec 0c             	sub    $0xc,%esp
    4a03:	50                   	push   %eax
    4a04:	e8 de eb ff ff       	call   35e7 <lodepng_malloc>
    4a09:	83 c4 10             	add    $0x10,%esp
    4a0c:	89 c2                	mov    %eax,%edx
    4a0e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a11:	89 10                	mov    %edx,(%eax)
  blcount = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4a13:	8b 45 08             	mov    0x8(%ebp),%eax
    4a16:	8b 40 08             	mov    0x8(%eax),%eax
    4a19:	83 c0 01             	add    $0x1,%eax
    4a1c:	c1 e0 02             	shl    $0x2,%eax
    4a1f:	83 ec 0c             	sub    $0xc,%esp
    4a22:	50                   	push   %eax
    4a23:	e8 bf eb ff ff       	call   35e7 <lodepng_malloc>
    4a28:	83 c4 10             	add    $0x10,%esp
    4a2b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  nextcode = (unsigned*)lodepng_malloc((tree->maxbitlen + 1) * sizeof(unsigned));
    4a2e:	8b 45 08             	mov    0x8(%ebp),%eax
    4a31:	8b 40 08             	mov    0x8(%eax),%eax
    4a34:	83 c0 01             	add    $0x1,%eax
    4a37:	c1 e0 02             	shl    $0x2,%eax
    4a3a:	83 ec 0c             	sub    $0xc,%esp
    4a3d:	50                   	push   %eax
    4a3e:	e8 a4 eb ff ff       	call   35e7 <lodepng_malloc>
    4a43:	83 c4 10             	add    $0x10,%esp
    4a46:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!tree->codes || !blcount || !nextcode) error = 83; /*alloc fail*/
    4a49:	8b 45 08             	mov    0x8(%ebp),%eax
    4a4c:	8b 00                	mov    (%eax),%eax
    4a4e:	85 c0                	test   %eax,%eax
    4a50:	74 0c                	je     4a5e <HuffmanTree_makeFromLengths2+0x76>
    4a52:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    4a56:	74 06                	je     4a5e <HuffmanTree_makeFromLengths2+0x76>
    4a58:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    4a5c:	75 07                	jne    4a65 <HuffmanTree_makeFromLengths2+0x7d>
    4a5e:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  if(!error) {
    4a65:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4a69:	0f 85 7d 01 00 00    	jne    4bec <HuffmanTree_makeFromLengths2+0x204>
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    4a6f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4a76:	eb 2c                	jmp    4aa4 <HuffmanTree_makeFromLengths2+0xbc>
    4a78:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4a7b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4a82:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4a85:	01 c2                	add    %eax,%edx
    4a87:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4a8a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4a91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4a94:	01 c8                	add    %ecx,%eax
    4a96:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    4a9c:	8b 00                	mov    (%eax),%eax
    4a9e:	89 02                	mov    %eax,(%edx)
    4aa0:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    4aa4:	8b 45 08             	mov    0x8(%ebp),%eax
    4aa7:	8b 40 08             	mov    0x8(%eax),%eax
    4aaa:	83 c0 01             	add    $0x1,%eax
    4aad:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4ab0:	75 c6                	jne    4a78 <HuffmanTree_makeFromLengths2+0x90>
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    4ab2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    4ab9:	eb 27                	jmp    4ae2 <HuffmanTree_makeFromLengths2+0xfa>
    4abb:	8b 45 08             	mov    0x8(%ebp),%eax
    4abe:	8b 40 04             	mov    0x4(%eax),%eax
    4ac1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4ac4:	c1 e2 02             	shl    $0x2,%edx
    4ac7:	01 d0                	add    %edx,%eax
    4ac9:	8b 00                	mov    (%eax),%eax
    4acb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4ad2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4ad5:	01 d0                	add    %edx,%eax
    4ad7:	8b 10                	mov    (%eax),%edx
    4ad9:	83 c2 01             	add    $0x1,%edx
    4adc:	89 10                	mov    %edx,(%eax)
    4ade:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4ae2:	8b 45 08             	mov    0x8(%ebp),%eax
    4ae5:	8b 40 0c             	mov    0xc(%eax),%eax
    4ae8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4aeb:	75 ce                	jne    4abb <HuffmanTree_makeFromLengths2+0xd3>
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4aed:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
    4af4:	eb 47                	jmp    4b3d <HuffmanTree_makeFromLengths2+0x155>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    4af6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4af9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4b00:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4b03:	01 d0                	add    %edx,%eax
    4b05:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4b08:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4b0e:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    4b15:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4b18:	01 ca                	add    %ecx,%edx
    4b1a:	8b 0a                	mov    (%edx),%ecx
    4b1c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    4b1f:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    4b25:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
    4b2c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4b2f:	01 da                	add    %ebx,%edx
    4b31:	8b 12                	mov    (%edx),%edx
    4b33:	01 ca                	add    %ecx,%edx
    4b35:	01 d2                	add    %edx,%edx
    4b37:	89 10                	mov    %edx,(%eax)
  if(!error) {
    for(n = 0; n != tree->maxbitlen + 1; n++) blcount[n] = nextcode[n] = 0;
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits != tree->numcodes; ++bits) ++blcount[tree->lengths[bits]];
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
    4b39:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    4b3d:	8b 45 08             	mov    0x8(%ebp),%eax
    4b40:	8b 40 08             	mov    0x8(%eax),%eax
    4b43:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    4b46:	73 ae                	jae    4af6 <HuffmanTree_makeFromLengths2+0x10e>
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4b48:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4b4f:	e9 89 00 00 00       	jmp    4bdd <HuffmanTree_makeFromLengths2+0x1f5>
      if(tree->lengths[n] != 0) {
    4b54:	8b 45 08             	mov    0x8(%ebp),%eax
    4b57:	8b 40 04             	mov    0x4(%eax),%eax
    4b5a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4b5d:	c1 e2 02             	shl    $0x2,%edx
    4b60:	01 d0                	add    %edx,%eax
    4b62:	8b 00                	mov    (%eax),%eax
    4b64:	85 c0                	test   %eax,%eax
    4b66:	74 71                	je     4bd9 <HuffmanTree_makeFromLengths2+0x1f1>
        tree->codes[n] = nextcode[tree->lengths[n]]++;
    4b68:	8b 45 08             	mov    0x8(%ebp),%eax
    4b6b:	8b 00                	mov    (%eax),%eax
    4b6d:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4b70:	c1 e2 02             	shl    $0x2,%edx
    4b73:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    4b76:	8b 45 08             	mov    0x8(%ebp),%eax
    4b79:	8b 40 04             	mov    0x4(%eax),%eax
    4b7c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4b7f:	c1 e2 02             	shl    $0x2,%edx
    4b82:	01 d0                	add    %edx,%eax
    4b84:	8b 00                	mov    (%eax),%eax
    4b86:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    4b8d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4b90:	01 c2                	add    %eax,%edx
    4b92:	8b 02                	mov    (%edx),%eax
    4b94:	8d 48 01             	lea    0x1(%eax),%ecx
    4b97:	89 0a                	mov    %ecx,(%edx)
    4b99:	89 03                	mov    %eax,(%ebx)
        /*remove superfluous bits from the code*/
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
    4b9b:	8b 45 08             	mov    0x8(%ebp),%eax
    4b9e:	8b 00                	mov    (%eax),%eax
    4ba0:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4ba3:	c1 e2 02             	shl    $0x2,%edx
    4ba6:	01 c2                	add    %eax,%edx
    4ba8:	8b 45 08             	mov    0x8(%ebp),%eax
    4bab:	8b 00                	mov    (%eax),%eax
    4bad:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    4bb0:	c1 e1 02             	shl    $0x2,%ecx
    4bb3:	01 c8                	add    %ecx,%eax
    4bb5:	8b 18                	mov    (%eax),%ebx
    4bb7:	8b 45 08             	mov    0x8(%ebp),%eax
    4bba:	8b 40 04             	mov    0x4(%eax),%eax
    4bbd:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    4bc0:	c1 e1 02             	shl    $0x2,%ecx
    4bc3:	01 c8                	add    %ecx,%eax
    4bc5:	8b 00                	mov    (%eax),%eax
    4bc7:	be 01 00 00 00       	mov    $0x1,%esi
    4bcc:	89 c1                	mov    %eax,%ecx
    4bce:	d3 e6                	shl    %cl,%esi
    4bd0:	89 f0                	mov    %esi,%eax
    4bd2:	83 e8 01             	sub    $0x1,%eax
    4bd5:	21 d8                	and    %ebx,%eax
    4bd7:	89 02                	mov    %eax,(%edx)
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; ++bits) {
      nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1u;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n != tree->numcodes; ++n) {
    4bd9:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    4bdd:	8b 45 08             	mov    0x8(%ebp),%eax
    4be0:	8b 40 0c             	mov    0xc(%eax),%eax
    4be3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    4be6:	0f 85 68 ff ff ff    	jne    4b54 <HuffmanTree_makeFromLengths2+0x16c>
        tree->codes[n] &= ((1u << tree->lengths[n]) - 1u);
      }
    }
  }

  lodepng_free(blcount);
    4bec:	83 ec 0c             	sub    $0xc,%esp
    4bef:	ff 75 e8             	pushl  -0x18(%ebp)
    4bf2:	e8 11 ea ff ff       	call   3608 <lodepng_free>
    4bf7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(nextcode);
    4bfa:	83 ec 0c             	sub    $0xc,%esp
    4bfd:	ff 75 e4             	pushl  -0x1c(%ebp)
    4c00:	e8 03 ea ff ff       	call   3608 <lodepng_free>
    4c05:	83 c4 10             	add    $0x10,%esp

  if(!error) error = HuffmanTree_makeTable(tree);
    4c08:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4c0c:	75 11                	jne    4c1f <HuffmanTree_makeFromLengths2+0x237>
    4c0e:	83 ec 0c             	sub    $0xc,%esp
    4c11:	ff 75 08             	pushl  0x8(%ebp)
    4c14:	e8 3f f9 ff ff       	call   4558 <HuffmanTree_makeTable>
    4c19:	83 c4 10             	add    $0x10,%esp
    4c1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    4c1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    4c22:	8d 65 f8             	lea    -0x8(%ebp),%esp
    4c25:	5b                   	pop    %ebx
    4c26:	5e                   	pop    %esi
    4c27:	5d                   	pop    %ebp
    4c28:	c3                   	ret    

00004c29 <HuffmanTree_makeFromLengths>:
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen) {
    4c29:	55                   	push   %ebp
    4c2a:	89 e5                	mov    %esp,%ebp
    4c2c:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    4c2f:	8b 45 10             	mov    0x10(%ebp),%eax
    4c32:	c1 e0 02             	shl    $0x2,%eax
    4c35:	83 ec 0c             	sub    $0xc,%esp
    4c38:	50                   	push   %eax
    4c39:	e8 a9 e9 ff ff       	call   35e7 <lodepng_malloc>
    4c3e:	83 c4 10             	add    $0x10,%esp
    4c41:	89 c2                	mov    %eax,%edx
    4c43:	8b 45 08             	mov    0x8(%ebp),%eax
    4c46:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    4c49:	8b 45 08             	mov    0x8(%ebp),%eax
    4c4c:	8b 40 04             	mov    0x4(%eax),%eax
    4c4f:	85 c0                	test   %eax,%eax
    4c51:	75 07                	jne    4c5a <HuffmanTree_makeFromLengths+0x31>
    4c53:	b8 53 00 00 00       	mov    $0x53,%eax
    4c58:	eb 56                	jmp    4cb0 <HuffmanTree_makeFromLengths+0x87>
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
    4c5a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    4c61:	eb 25                	jmp    4c88 <HuffmanTree_makeFromLengths+0x5f>
    4c63:	8b 45 08             	mov    0x8(%ebp),%eax
    4c66:	8b 40 04             	mov    0x4(%eax),%eax
    4c69:	8b 55 f4             	mov    -0xc(%ebp),%edx
    4c6c:	c1 e2 02             	shl    $0x2,%edx
    4c6f:	01 c2                	add    %eax,%edx
    4c71:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4c74:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    4c7b:	8b 45 0c             	mov    0xc(%ebp),%eax
    4c7e:	01 c8                	add    %ecx,%eax
    4c80:	8b 00                	mov    (%eax),%eax
    4c82:	89 02                	mov    %eax,(%edx)
    4c84:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    4c88:	8b 45 10             	mov    0x10(%ebp),%eax
    4c8b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4c8e:	75 d3                	jne    4c63 <HuffmanTree_makeFromLengths+0x3a>
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    4c90:	8b 55 10             	mov    0x10(%ebp),%edx
    4c93:	8b 45 08             	mov    0x8(%ebp),%eax
    4c96:	89 50 0c             	mov    %edx,0xc(%eax)
  tree->maxbitlen = maxbitlen;
    4c99:	8b 45 08             	mov    0x8(%ebp),%eax
    4c9c:	8b 55 14             	mov    0x14(%ebp),%edx
    4c9f:	89 50 08             	mov    %edx,0x8(%eax)
  return HuffmanTree_makeFromLengths2(tree);
    4ca2:	83 ec 0c             	sub    $0xc,%esp
    4ca5:	ff 75 08             	pushl  0x8(%ebp)
    4ca8:	e8 3b fd ff ff       	call   49e8 <HuffmanTree_makeFromLengths2>
    4cad:	83 c4 10             	add    $0x10,%esp
}
    4cb0:	c9                   	leave  
    4cb1:	c3                   	ret    

00004cb2 <bpmnode_create>:
  BPMNode** chains0;
  BPMNode** chains1;
} BPMLists;

/*creates a new chain node with the given parameters, from the memory in the lists */
static BPMNode* bpmnode_create(BPMLists* lists, int weight, unsigned index, BPMNode* tail) {
    4cb2:	55                   	push   %ebp
    4cb3:	89 e5                	mov    %esp,%ebp
    4cb5:	53                   	push   %ebx
    4cb6:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  BPMNode* result;

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    4cb9:	8b 45 08             	mov    0x8(%ebp),%eax
    4cbc:	8b 50 0c             	mov    0xc(%eax),%edx
    4cbf:	8b 45 08             	mov    0x8(%ebp),%eax
    4cc2:	8b 40 08             	mov    0x8(%eax),%eax
    4cc5:	39 c2                	cmp    %eax,%edx
    4cc7:	0f 82 0b 01 00 00    	jb     4dd8 <bpmnode_create+0x126>
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    4ccd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4cd4:	eb 19                	jmp    4cef <bpmnode_create+0x3d>
    4cd6:	8b 45 08             	mov    0x8(%ebp),%eax
    4cd9:	8b 40 04             	mov    0x4(%eax),%eax
    4cdc:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4cdf:	c1 e2 04             	shl    $0x4,%edx
    4ce2:	01 d0                	add    %edx,%eax
    4ce4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    4ceb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4cef:	8b 45 08             	mov    0x8(%ebp),%eax
    4cf2:	8b 00                	mov    (%eax),%eax
    4cf4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4cf7:	75 dd                	jne    4cd6 <bpmnode_create+0x24>
    for(i = 0; i != lists->listsize; ++i) {
    4cf9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4d00:	eb 60                	jmp    4d62 <bpmnode_create+0xb0>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
    4d02:	8b 45 08             	mov    0x8(%ebp),%eax
    4d05:	8b 40 18             	mov    0x18(%eax),%eax
    4d08:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4d0b:	c1 e2 02             	shl    $0x2,%edx
    4d0e:	01 d0                	add    %edx,%eax
    4d10:	8b 00                	mov    (%eax),%eax
    4d12:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4d15:	eb 13                	jmp    4d2a <bpmnode_create+0x78>
    4d17:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d1a:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4d21:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d24:	8b 40 08             	mov    0x8(%eax),%eax
    4d27:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4d2a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4d2e:	75 e7                	jne    4d17 <bpmnode_create+0x65>
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    4d30:	8b 45 08             	mov    0x8(%ebp),%eax
    4d33:	8b 40 1c             	mov    0x1c(%eax),%eax
    4d36:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4d39:	c1 e2 02             	shl    $0x2,%edx
    4d3c:	01 d0                	add    %edx,%eax
    4d3e:	8b 00                	mov    (%eax),%eax
    4d40:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4d43:	eb 13                	jmp    4d58 <bpmnode_create+0xa6>
    4d45:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d48:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    4d4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4d52:	8b 40 08             	mov    0x8(%eax),%eax
    4d55:	89 45 f4             	mov    %eax,-0xc(%ebp)
    4d58:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    4d5c:	75 e7                	jne    4d45 <bpmnode_create+0x93>

  /*memory full, so garbage collect*/
  if(lists->nextfree >= lists->numfree) {
    /*mark only those that are in use*/
    for(i = 0; i != lists->memsize; ++i) lists->memory[i].in_use = 0;
    for(i = 0; i != lists->listsize; ++i) {
    4d5e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4d62:	8b 45 08             	mov    0x8(%ebp),%eax
    4d65:	8b 40 14             	mov    0x14(%eax),%eax
    4d68:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4d6b:	75 95                	jne    4d02 <bpmnode_create+0x50>
      BPMNode* node;
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    4d6d:	8b 45 08             	mov    0x8(%ebp),%eax
    4d70:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    for(i = 0; i != lists->memsize; ++i) {
    4d77:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    4d7e:	eb 44                	jmp    4dc4 <bpmnode_create+0x112>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    4d80:	8b 45 08             	mov    0x8(%ebp),%eax
    4d83:	8b 40 04             	mov    0x4(%eax),%eax
    4d86:	8b 55 f8             	mov    -0x8(%ebp),%edx
    4d89:	c1 e2 04             	shl    $0x4,%edx
    4d8c:	01 d0                	add    %edx,%eax
    4d8e:	8b 40 0c             	mov    0xc(%eax),%eax
    4d91:	85 c0                	test   %eax,%eax
    4d93:	75 2b                	jne    4dc0 <bpmnode_create+0x10e>
    4d95:	8b 45 08             	mov    0x8(%ebp),%eax
    4d98:	8b 58 10             	mov    0x10(%eax),%ebx
    4d9b:	8b 45 08             	mov    0x8(%ebp),%eax
    4d9e:	8b 40 08             	mov    0x8(%eax),%eax
    4da1:	8d 48 01             	lea    0x1(%eax),%ecx
    4da4:	8b 55 08             	mov    0x8(%ebp),%edx
    4da7:	89 4a 08             	mov    %ecx,0x8(%edx)
    4daa:	c1 e0 02             	shl    $0x2,%eax
    4dad:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    4db0:	8b 45 08             	mov    0x8(%ebp),%eax
    4db3:	8b 40 04             	mov    0x4(%eax),%eax
    4db6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    4db9:	c1 e1 04             	shl    $0x4,%ecx
    4dbc:	01 c8                	add    %ecx,%eax
    4dbe:	89 02                	mov    %eax,(%edx)
      for(node = lists->chains0[i]; node != 0; node = node->tail) node->in_use = 1;
      for(node = lists->chains1[i]; node != 0; node = node->tail) node->in_use = 1;
    }
    /*collect those that are free*/
    lists->numfree = 0;
    for(i = 0; i != lists->memsize; ++i) {
    4dc0:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    4dc4:	8b 45 08             	mov    0x8(%ebp),%eax
    4dc7:	8b 00                	mov    (%eax),%eax
    4dc9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    4dcc:	75 b2                	jne    4d80 <bpmnode_create+0xce>
      if(!lists->memory[i].in_use) lists->freelist[lists->numfree++] = &lists->memory[i];
    }
    lists->nextfree = 0;
    4dce:	8b 45 08             	mov    0x8(%ebp),%eax
    4dd1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  }

  result = lists->freelist[lists->nextfree++];
    4dd8:	8b 45 08             	mov    0x8(%ebp),%eax
    4ddb:	8b 58 10             	mov    0x10(%eax),%ebx
    4dde:	8b 45 08             	mov    0x8(%ebp),%eax
    4de1:	8b 40 0c             	mov    0xc(%eax),%eax
    4de4:	8d 48 01             	lea    0x1(%eax),%ecx
    4de7:	8b 55 08             	mov    0x8(%ebp),%edx
    4dea:	89 4a 0c             	mov    %ecx,0xc(%edx)
    4ded:	c1 e0 02             	shl    $0x2,%eax
    4df0:	01 d8                	add    %ebx,%eax
    4df2:	8b 00                	mov    (%eax),%eax
    4df4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  result->weight = weight;
    4df7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4dfa:	8b 55 0c             	mov    0xc(%ebp),%edx
    4dfd:	89 10                	mov    %edx,(%eax)
  result->index = index;
    4dff:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4e02:	8b 55 10             	mov    0x10(%ebp),%edx
    4e05:	89 50 04             	mov    %edx,0x4(%eax)
  result->tail = tail;
    4e08:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4e0b:	8b 55 14             	mov    0x14(%ebp),%edx
    4e0e:	89 50 08             	mov    %edx,0x8(%eax)
  return result;
    4e11:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    4e14:	83 c4 10             	add    $0x10,%esp
    4e17:	5b                   	pop    %ebx
    4e18:	5d                   	pop    %ebp
    4e19:	c3                   	ret    

00004e1a <bpmnode_sort>:

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
    4e1a:	55                   	push   %ebp
    4e1b:	89 e5                	mov    %esp,%ebp
    4e1d:	83 ec 38             	sub    $0x38,%esp
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
    4e20:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e23:	c1 e0 04             	shl    $0x4,%eax
    4e26:	83 ec 0c             	sub    $0xc,%esp
    4e29:	50                   	push   %eax
    4e2a:	e8 b8 e7 ff ff       	call   35e7 <lodepng_malloc>
    4e2f:	83 c4 10             	add    $0x10,%esp
    4e32:	89 45 dc             	mov    %eax,-0x24(%ebp)
  size_t width, counter = 0;
    4e35:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for(width = 1; width < num; width *= 2) {
    4e3c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    4e43:	e9 41 01 00 00       	jmp    4f89 <bpmnode_sort+0x16f>
    BPMNode* a = (counter & 1) ? mem : leaves;
    4e48:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4e4b:	83 e0 01             	and    $0x1,%eax
    4e4e:	85 c0                	test   %eax,%eax
    4e50:	74 05                	je     4e57 <bpmnode_sort+0x3d>
    4e52:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4e55:	eb 03                	jmp    4e5a <bpmnode_sort+0x40>
    4e57:	8b 45 08             	mov    0x8(%ebp),%eax
    4e5a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    BPMNode* b = (counter & 1) ? leaves : mem;
    4e5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4e60:	83 e0 01             	and    $0x1,%eax
    4e63:	85 c0                	test   %eax,%eax
    4e65:	74 05                	je     4e6c <bpmnode_sort+0x52>
    4e67:	8b 45 08             	mov    0x8(%ebp),%eax
    4e6a:	eb 03                	jmp    4e6f <bpmnode_sort+0x55>
    4e6c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    4e6f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4e72:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    4e79:	e9 f8 00 00 00       	jmp    4f76 <bpmnode_sort+0x15c>
      size_t q = (p + width > num) ? num : (p + width);
    4e7e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    4e81:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e84:	01 c2                	add    %eax,%edx
    4e86:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e89:	39 c2                	cmp    %eax,%edx
    4e8b:	0f 4e c2             	cmovle %edx,%eax
    4e8e:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
    4e91:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4e94:	8d 14 00             	lea    (%eax,%eax,1),%edx
    4e97:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4e9a:	01 c2                	add    %eax,%edx
    4e9c:	8b 45 0c             	mov    0xc(%ebp),%eax
    4e9f:	39 c2                	cmp    %eax,%edx
    4ea1:	0f 4e c2             	cmovle %edx,%eax
    4ea4:	89 45 cc             	mov    %eax,-0x34(%ebp)
      size_t i = p, j = q, k;
    4ea7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4eaa:	89 45 e8             	mov    %eax,-0x18(%ebp)
    4ead:	8b 45 d0             	mov    -0x30(%ebp),%eax
    4eb0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      for(k = p; k < r; k++) {
    4eb3:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4eb6:	89 45 e0             	mov    %eax,-0x20(%ebp)
    4eb9:	e9 a4 00 00 00       	jmp    4f62 <bpmnode_sort+0x148>
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
    4ebe:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4ec1:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    4ec4:	7d 62                	jge    4f28 <bpmnode_sort+0x10e>
    4ec6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4ec9:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4ecc:	7d 22                	jge    4ef0 <bpmnode_sort+0xd6>
    4ece:	8b 45 e8             	mov    -0x18(%ebp),%eax
    4ed1:	c1 e0 04             	shl    $0x4,%eax
    4ed4:	89 c2                	mov    %eax,%edx
    4ed6:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4ed9:	01 d0                	add    %edx,%eax
    4edb:	8b 10                	mov    (%eax),%edx
    4edd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    4ee0:	c1 e0 04             	shl    $0x4,%eax
    4ee3:	89 c1                	mov    %eax,%ecx
    4ee5:	8b 45 d8             	mov    -0x28(%ebp),%eax
    4ee8:	01 c8                	add    %ecx,%eax
    4eea:	8b 00                	mov    (%eax),%eax
    4eec:	39 c2                	cmp    %eax,%edx
    4eee:	7f 38                	jg     4f28 <bpmnode_sort+0x10e>
    4ef0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4ef3:	c1 e0 04             	shl    $0x4,%eax
    4ef6:	89 c2                	mov    %eax,%edx
    4ef8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4efb:	01 d0                	add    %edx,%eax
    4efd:	8b 55 e8             	mov    -0x18(%ebp),%edx
    4f00:	8d 4a 01             	lea    0x1(%edx),%ecx
    4f03:	89 4d e8             	mov    %ecx,-0x18(%ebp)
    4f06:	89 d1                	mov    %edx,%ecx
    4f08:	c1 e1 04             	shl    $0x4,%ecx
    4f0b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4f0e:	01 ca                	add    %ecx,%edx
    4f10:	8b 0a                	mov    (%edx),%ecx
    4f12:	89 08                	mov    %ecx,(%eax)
    4f14:	8b 4a 04             	mov    0x4(%edx),%ecx
    4f17:	89 48 04             	mov    %ecx,0x4(%eax)
    4f1a:	8b 4a 08             	mov    0x8(%edx),%ecx
    4f1d:	89 48 08             	mov    %ecx,0x8(%eax)
    4f20:	8b 52 0c             	mov    0xc(%edx),%edx
    4f23:	89 50 0c             	mov    %edx,0xc(%eax)
    4f26:	eb 36                	jmp    4f5e <bpmnode_sort+0x144>
        else b[k] = a[j++];
    4f28:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4f2b:	c1 e0 04             	shl    $0x4,%eax
    4f2e:	89 c2                	mov    %eax,%edx
    4f30:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    4f33:	01 d0                	add    %edx,%eax
    4f35:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    4f38:	8d 4a 01             	lea    0x1(%edx),%ecx
    4f3b:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    4f3e:	89 d1                	mov    %edx,%ecx
    4f40:	c1 e1 04             	shl    $0x4,%ecx
    4f43:	8b 55 d8             	mov    -0x28(%ebp),%edx
    4f46:	01 ca                	add    %ecx,%edx
    4f48:	8b 0a                	mov    (%edx),%ecx
    4f4a:	89 08                	mov    %ecx,(%eax)
    4f4c:	8b 4a 04             	mov    0x4(%edx),%ecx
    4f4f:	89 48 04             	mov    %ecx,0x4(%eax)
    4f52:	8b 4a 08             	mov    0x8(%edx),%ecx
    4f55:	89 48 08             	mov    %ecx,0x8(%eax)
    4f58:	8b 52 0c             	mov    0xc(%edx),%edx
    4f5b:	89 50 0c             	mov    %edx,0xc(%eax)
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
      size_t q = (p + width > num) ? num : (p + width);
      size_t r = (p + 2 * width > num) ? num : (p + 2 * width);
      size_t i = p, j = q, k;
      for(k = p; k < r; k++) {
    4f5e:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    4f62:	8b 45 e0             	mov    -0x20(%ebp),%eax
    4f65:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    4f68:	0f 8c 50 ff ff ff    	jl     4ebe <bpmnode_sort+0xa4>
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    BPMNode* a = (counter & 1) ? mem : leaves;
    BPMNode* b = (counter & 1) ? leaves : mem;
    size_t p;
    for(p = 0; p < num; p += 2 * width) {
    4f6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4f71:	01 c0                	add    %eax,%eax
    4f73:	01 45 ec             	add    %eax,-0x14(%ebp)
    4f76:	8b 45 ec             	mov    -0x14(%ebp),%eax
    4f79:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4f7c:	0f 8c fc fe ff ff    	jl     4e7e <bpmnode_sort+0x64>
      for(k = p; k < r; k++) {
        if(i < q && (j >= r || a[i].weight <= a[j].weight)) b[k] = a[i++];
        else b[k] = a[j++];
      }
    }
    counter++;
    4f82:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)

/*sort the leaves with stable mergesort*/
static void bpmnode_sort(BPMNode* leaves, size_t num) {
  BPMNode* mem = (BPMNode*)lodepng_malloc(sizeof(*leaves) * num);
  size_t width, counter = 0;
  for(width = 1; width < num; width *= 2) {
    4f86:	d1 65 f4             	shll   -0xc(%ebp)
    4f89:	8b 45 f4             	mov    -0xc(%ebp),%eax
    4f8c:	3b 45 0c             	cmp    0xc(%ebp),%eax
    4f8f:	0f 8c b3 fe ff ff    	jl     4e48 <bpmnode_sort+0x2e>
        else b[k] = a[j++];
      }
    }
    counter++;
  }
  if(counter & 1) lodepng_memcpy(leaves, mem, sizeof(*leaves) * num);
    4f95:	8b 45 f0             	mov    -0x10(%ebp),%eax
    4f98:	83 e0 01             	and    $0x1,%eax
    4f9b:	85 c0                	test   %eax,%eax
    4f9d:	74 18                	je     4fb7 <bpmnode_sort+0x19d>
    4f9f:	8b 45 0c             	mov    0xc(%ebp),%eax
    4fa2:	c1 e0 04             	shl    $0x4,%eax
    4fa5:	83 ec 04             	sub    $0x4,%esp
    4fa8:	50                   	push   %eax
    4fa9:	ff 75 dc             	pushl  -0x24(%ebp)
    4fac:	ff 75 08             	pushl  0x8(%ebp)
    4faf:	e8 71 e6 ff ff       	call   3625 <lodepng_memcpy>
    4fb4:	83 c4 10             	add    $0x10,%esp
  lodepng_free(mem);
    4fb7:	83 ec 0c             	sub    $0xc,%esp
    4fba:	ff 75 dc             	pushl  -0x24(%ebp)
    4fbd:	e8 46 e6 ff ff       	call   3608 <lodepng_free>
    4fc2:	83 c4 10             	add    $0x10,%esp
}
    4fc5:	90                   	nop
    4fc6:	c9                   	leave  
    4fc7:	c3                   	ret    

00004fc8 <boundaryPM>:

/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
    4fc8:	55                   	push   %ebp
    4fc9:	89 e5                	mov    %esp,%ebp
    4fcb:	56                   	push   %esi
    4fcc:	53                   	push   %ebx
    4fcd:	83 ec 10             	sub    $0x10,%esp
  unsigned lastindex = lists->chains1[c]->index;
    4fd0:	8b 45 08             	mov    0x8(%ebp),%eax
    4fd3:	8b 40 1c             	mov    0x1c(%eax),%eax
    4fd6:	8b 55 14             	mov    0x14(%ebp),%edx
    4fd9:	c1 e2 02             	shl    $0x2,%edx
    4fdc:	01 d0                	add    %edx,%eax
    4fde:	8b 00                	mov    (%eax),%eax
    4fe0:	8b 40 04             	mov    0x4(%eax),%eax
    4fe3:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(c == 0) {
    4fe6:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    4fea:	75 66                	jne    5052 <boundaryPM+0x8a>
    if(lastindex >= numpresent) return;
    4fec:	8b 45 10             	mov    0x10(%ebp),%eax
    4fef:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    4ff2:	0f 83 a0 01 00 00    	jae    5198 <boundaryPM+0x1d0>
    lists->chains0[c] = lists->chains1[c];
    4ff8:	8b 45 08             	mov    0x8(%ebp),%eax
    4ffb:	8b 40 18             	mov    0x18(%eax),%eax
    4ffe:	8b 55 14             	mov    0x14(%ebp),%edx
    5001:	c1 e2 02             	shl    $0x2,%edx
    5004:	01 c2                	add    %eax,%edx
    5006:	8b 45 08             	mov    0x8(%ebp),%eax
    5009:	8b 40 1c             	mov    0x1c(%eax),%eax
    500c:	8b 4d 14             	mov    0x14(%ebp),%ecx
    500f:	c1 e1 02             	shl    $0x2,%ecx
    5012:	01 c8                	add    %ecx,%eax
    5014:	8b 00                	mov    (%eax),%eax
    5016:	89 02                	mov    %eax,(%edx)
    lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, 0);
    5018:	8b 45 08             	mov    0x8(%ebp),%eax
    501b:	8b 40 1c             	mov    0x1c(%eax),%eax
    501e:	8b 55 14             	mov    0x14(%ebp),%edx
    5021:	c1 e2 02             	shl    $0x2,%edx
    5024:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    5027:	8b 45 f4             	mov    -0xc(%ebp),%eax
    502a:	8d 50 01             	lea    0x1(%eax),%edx
    502d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5030:	c1 e0 04             	shl    $0x4,%eax
    5033:	89 c1                	mov    %eax,%ecx
    5035:	8b 45 0c             	mov    0xc(%ebp),%eax
    5038:	01 c8                	add    %ecx,%eax
    503a:	8b 00                	mov    (%eax),%eax
    503c:	6a 00                	push   $0x0
    503e:	52                   	push   %edx
    503f:	50                   	push   %eax
    5040:	ff 75 08             	pushl  0x8(%ebp)
    5043:	e8 6a fc ff ff       	call   4cb2 <bpmnode_create>
    5048:	83 c4 10             	add    $0x10,%esp
    504b:	89 03                	mov    %eax,(%ebx)
    504d:	e9 47 01 00 00       	jmp    5199 <boundaryPM+0x1d1>
  } else {
    /*sum of the weights of the head nodes of the previous lookahead chains.*/
    int sum = lists->chains0[c - 1]->weight + lists->chains1[c - 1]->weight;
    5052:	8b 45 08             	mov    0x8(%ebp),%eax
    5055:	8b 40 18             	mov    0x18(%eax),%eax
    5058:	8b 55 14             	mov    0x14(%ebp),%edx
    505b:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    5061:	c1 e2 02             	shl    $0x2,%edx
    5064:	01 d0                	add    %edx,%eax
    5066:	8b 00                	mov    (%eax),%eax
    5068:	8b 10                	mov    (%eax),%edx
    506a:	8b 45 08             	mov    0x8(%ebp),%eax
    506d:	8b 40 1c             	mov    0x1c(%eax),%eax
    5070:	8b 4d 14             	mov    0x14(%ebp),%ecx
    5073:	81 c1 ff ff ff 3f    	add    $0x3fffffff,%ecx
    5079:	c1 e1 02             	shl    $0x2,%ecx
    507c:	01 c8                	add    %ecx,%eax
    507e:	8b 00                	mov    (%eax),%eax
    5080:	8b 00                	mov    (%eax),%eax
    5082:	01 d0                	add    %edx,%eax
    5084:	89 45 f0             	mov    %eax,-0x10(%ebp)
    lists->chains0[c] = lists->chains1[c];
    5087:	8b 45 08             	mov    0x8(%ebp),%eax
    508a:	8b 40 18             	mov    0x18(%eax),%eax
    508d:	8b 55 14             	mov    0x14(%ebp),%edx
    5090:	c1 e2 02             	shl    $0x2,%edx
    5093:	01 c2                	add    %eax,%edx
    5095:	8b 45 08             	mov    0x8(%ebp),%eax
    5098:	8b 40 1c             	mov    0x1c(%eax),%eax
    509b:	8b 4d 14             	mov    0x14(%ebp),%ecx
    509e:	c1 e1 02             	shl    $0x2,%ecx
    50a1:	01 c8                	add    %ecx,%eax
    50a3:	8b 00                	mov    (%eax),%eax
    50a5:	89 02                	mov    %eax,(%edx)
    if(lastindex < numpresent && sum > leaves[lastindex].weight) {
    50a7:	8b 45 10             	mov    0x10(%ebp),%eax
    50aa:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    50ad:	73 60                	jae    510f <boundaryPM+0x147>
    50af:	8b 45 f4             	mov    -0xc(%ebp),%eax
    50b2:	c1 e0 04             	shl    $0x4,%eax
    50b5:	89 c2                	mov    %eax,%edx
    50b7:	8b 45 0c             	mov    0xc(%ebp),%eax
    50ba:	01 d0                	add    %edx,%eax
    50bc:	8b 00                	mov    (%eax),%eax
    50be:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    50c1:	7d 4c                	jge    510f <boundaryPM+0x147>
      lists->chains1[c] = bpmnode_create(lists, leaves[lastindex].weight, lastindex + 1, lists->chains1[c]->tail);
    50c3:	8b 45 08             	mov    0x8(%ebp),%eax
    50c6:	8b 40 1c             	mov    0x1c(%eax),%eax
    50c9:	8b 55 14             	mov    0x14(%ebp),%edx
    50cc:	c1 e2 02             	shl    $0x2,%edx
    50cf:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    50d2:	8b 45 08             	mov    0x8(%ebp),%eax
    50d5:	8b 40 1c             	mov    0x1c(%eax),%eax
    50d8:	8b 55 14             	mov    0x14(%ebp),%edx
    50db:	c1 e2 02             	shl    $0x2,%edx
    50de:	01 d0                	add    %edx,%eax
    50e0:	8b 00                	mov    (%eax),%eax
    50e2:	8b 50 08             	mov    0x8(%eax),%edx
    50e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    50e8:	8d 48 01             	lea    0x1(%eax),%ecx
    50eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    50ee:	c1 e0 04             	shl    $0x4,%eax
    50f1:	89 c6                	mov    %eax,%esi
    50f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    50f6:	01 f0                	add    %esi,%eax
    50f8:	8b 00                	mov    (%eax),%eax
    50fa:	52                   	push   %edx
    50fb:	51                   	push   %ecx
    50fc:	50                   	push   %eax
    50fd:	ff 75 08             	pushl  0x8(%ebp)
    5100:	e8 ad fb ff ff       	call   4cb2 <bpmnode_create>
    5105:	83 c4 10             	add    $0x10,%esp
    5108:	89 03                	mov    %eax,(%ebx)
      return;
    510a:	e9 8a 00 00 00       	jmp    5199 <boundaryPM+0x1d1>
    }
    lists->chains1[c] = bpmnode_create(lists, sum, lastindex, lists->chains1[c - 1]);
    510f:	8b 45 08             	mov    0x8(%ebp),%eax
    5112:	8b 40 1c             	mov    0x1c(%eax),%eax
    5115:	8b 55 14             	mov    0x14(%ebp),%edx
    5118:	c1 e2 02             	shl    $0x2,%edx
    511b:	8d 1c 10             	lea    (%eax,%edx,1),%ebx
    511e:	8b 45 08             	mov    0x8(%ebp),%eax
    5121:	8b 40 1c             	mov    0x1c(%eax),%eax
    5124:	8b 55 14             	mov    0x14(%ebp),%edx
    5127:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    512d:	c1 e2 02             	shl    $0x2,%edx
    5130:	01 d0                	add    %edx,%eax
    5132:	8b 00                	mov    (%eax),%eax
    5134:	50                   	push   %eax
    5135:	ff 75 f4             	pushl  -0xc(%ebp)
    5138:	ff 75 f0             	pushl  -0x10(%ebp)
    513b:	ff 75 08             	pushl  0x8(%ebp)
    513e:	e8 6f fb ff ff       	call   4cb2 <bpmnode_create>
    5143:	83 c4 10             	add    $0x10,%esp
    5146:	89 03                	mov    %eax,(%ebx)
    /*in the end we are only interested in the chain of the last list, so no
    need to recurse if we're at the last one (this gives measurable speedup)*/
    if(num + 1 < (int)(2 * numpresent - 2)) {
    5148:	8b 45 18             	mov    0x18(%ebp),%eax
    514b:	8d 50 01             	lea    0x1(%eax),%edx
    514e:	8b 45 10             	mov    0x10(%ebp),%eax
    5151:	83 e8 01             	sub    $0x1,%eax
    5154:	01 c0                	add    %eax,%eax
    5156:	39 c2                	cmp    %eax,%edx
    5158:	7d 3f                	jge    5199 <boundaryPM+0x1d1>
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    515a:	8b 45 14             	mov    0x14(%ebp),%eax
    515d:	83 e8 01             	sub    $0x1,%eax
    5160:	83 ec 0c             	sub    $0xc,%esp
    5163:	ff 75 18             	pushl  0x18(%ebp)
    5166:	50                   	push   %eax
    5167:	ff 75 10             	pushl  0x10(%ebp)
    516a:	ff 75 0c             	pushl  0xc(%ebp)
    516d:	ff 75 08             	pushl  0x8(%ebp)
    5170:	e8 53 fe ff ff       	call   4fc8 <boundaryPM>
    5175:	83 c4 20             	add    $0x20,%esp
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    5178:	8b 45 14             	mov    0x14(%ebp),%eax
    517b:	83 e8 01             	sub    $0x1,%eax
    517e:	83 ec 0c             	sub    $0xc,%esp
    5181:	ff 75 18             	pushl  0x18(%ebp)
    5184:	50                   	push   %eax
    5185:	ff 75 10             	pushl  0x10(%ebp)
    5188:	ff 75 0c             	pushl  0xc(%ebp)
    518b:	ff 75 08             	pushl  0x8(%ebp)
    518e:	e8 35 fe ff ff       	call   4fc8 <boundaryPM>
    5193:	83 c4 20             	add    $0x20,%esp
    5196:	eb 01                	jmp    5199 <boundaryPM+0x1d1>
/*Boundary Package Merge step, numpresent is the amount of leaves, and c is the current chain.*/
static void boundaryPM(BPMLists* lists, BPMNode* leaves, size_t numpresent, int c, int num) {
  unsigned lastindex = lists->chains1[c]->index;

  if(c == 0) {
    if(lastindex >= numpresent) return;
    5198:	90                   	nop
    if(num + 1 < (int)(2 * numpresent - 2)) {
      boundaryPM(lists, leaves, numpresent, c - 1, num);
      boundaryPM(lists, leaves, numpresent, c - 1, num);
    }
  }
}
    5199:	8d 65 f8             	lea    -0x8(%ebp),%esp
    519c:	5b                   	pop    %ebx
    519d:	5e                   	pop    %esi
    519e:	5d                   	pop    %ebp
    519f:	c3                   	ret    

000051a0 <lodepng_huffman_code_lengths>:

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen) {
    51a0:	55                   	push   %ebp
    51a1:	89 e5                	mov    %esp,%ebp
    51a3:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    51a6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t numpresent = 0; /*number of symbols with non-zero frequency*/
    51ad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  BPMNode* leaves; /*the symbols, only those with > 0 frequency*/

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/
    51b4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    51b8:	75 0a                	jne    51c4 <lodepng_huffman_code_lengths+0x24>
    51ba:	b8 50 00 00 00       	mov    $0x50,%eax
    51bf:	e9 4d 03 00 00       	jmp    5511 <lodepng_huffman_code_lengths+0x371>
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/
    51c4:	8b 45 14             	mov    0x14(%ebp),%eax
    51c7:	ba 01 00 00 00       	mov    $0x1,%edx
    51cc:	89 c1                	mov    %eax,%ecx
    51ce:	d3 e2                	shl    %cl,%edx
    51d0:	8b 45 10             	mov    0x10(%ebp),%eax
    51d3:	39 c2                	cmp    %eax,%edx
    51d5:	73 0a                	jae    51e1 <lodepng_huffman_code_lengths+0x41>
    51d7:	b8 50 00 00 00       	mov    $0x50,%eax
    51dc:	e9 30 03 00 00       	jmp    5511 <lodepng_huffman_code_lengths+0x371>

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
    51e1:	8b 45 10             	mov    0x10(%ebp),%eax
    51e4:	c1 e0 04             	shl    $0x4,%eax
    51e7:	83 ec 0c             	sub    $0xc,%esp
    51ea:	50                   	push   %eax
    51eb:	e8 f7 e3 ff ff       	call   35e7 <lodepng_malloc>
    51f0:	83 c4 10             	add    $0x10,%esp
    51f3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(!leaves) return 83; /*alloc fail*/
    51f6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    51fa:	75 0a                	jne    5206 <lodepng_huffman_code_lengths+0x66>
    51fc:	b8 53 00 00 00       	mov    $0x53,%eax
    5201:	e9 0b 03 00 00       	jmp    5511 <lodepng_huffman_code_lengths+0x371>

  for(i = 0; i != numcodes; ++i) {
    5206:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    520d:	eb 50                	jmp    525f <lodepng_huffman_code_lengths+0xbf>
    if(frequencies[i] > 0) {
    520f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5212:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5219:	8b 45 0c             	mov    0xc(%ebp),%eax
    521c:	01 d0                	add    %edx,%eax
    521e:	8b 00                	mov    (%eax),%eax
    5220:	85 c0                	test   %eax,%eax
    5222:	74 37                	je     525b <lodepng_huffman_code_lengths+0xbb>
      leaves[numpresent].weight = (int)frequencies[i];
    5224:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5227:	c1 e0 04             	shl    $0x4,%eax
    522a:	89 c2                	mov    %eax,%edx
    522c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    522f:	01 d0                	add    %edx,%eax
    5231:	8b 55 f0             	mov    -0x10(%ebp),%edx
    5234:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    523b:	8b 55 0c             	mov    0xc(%ebp),%edx
    523e:	01 ca                	add    %ecx,%edx
    5240:	8b 12                	mov    (%edx),%edx
    5242:	89 10                	mov    %edx,(%eax)
      leaves[numpresent].index = i;
    5244:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5247:	c1 e0 04             	shl    $0x4,%eax
    524a:	89 c2                	mov    %eax,%edx
    524c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    524f:	01 c2                	add    %eax,%edx
    5251:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5254:	89 42 04             	mov    %eax,0x4(%edx)
      ++numpresent;
    5257:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  if((1u << maxbitlen) < (unsigned)numcodes) return 80; /*error: represent all symbols*/

  leaves = (BPMNode*)lodepng_malloc(numcodes * sizeof(*leaves));
  if(!leaves) return 83; /*alloc fail*/

  for(i = 0; i != numcodes; ++i) {
    525b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    525f:	8b 45 10             	mov    0x10(%ebp),%eax
    5262:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5265:	75 a8                	jne    520f <lodepng_huffman_code_lengths+0x6f>
      leaves[numpresent].index = i;
      ++numpresent;
    }
  }

  lodepng_memset(lengths, 0, numcodes * sizeof(*lengths));
    5267:	8b 45 10             	mov    0x10(%ebp),%eax
    526a:	c1 e0 02             	shl    $0x2,%eax
    526d:	83 ec 04             	sub    $0x4,%esp
    5270:	50                   	push   %eax
    5271:	6a 00                	push   $0x0
    5273:	ff 75 08             	pushl  0x8(%ebp)
    5276:	e8 dd e3 ff ff       	call   3658 <lodepng_memset>
    527b:	83 c4 10             	add    $0x10,%esp
  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. Some decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoretical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0) {
    527e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5282:	75 18                	jne    529c <lodepng_huffman_code_lengths+0xfc>
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
    5284:	8b 45 08             	mov    0x8(%ebp),%eax
    5287:	83 c0 04             	add    $0x4,%eax
    528a:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    5290:	8b 10                	mov    (%eax),%edx
    5292:	8b 45 08             	mov    0x8(%ebp),%eax
    5295:	89 10                	mov    %edx,(%eax)
    5297:	e9 64 02 00 00       	jmp    5500 <lodepng_huffman_code_lengths+0x360>
  } else if(numpresent == 1) {
    529c:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
    52a0:	75 3e                	jne    52e0 <lodepng_huffman_code_lengths+0x140>
    lengths[leaves[0].index] = 1;
    52a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    52a5:	8b 40 04             	mov    0x4(%eax),%eax
    52a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    52af:	8b 45 08             	mov    0x8(%ebp),%eax
    52b2:	01 d0                	add    %edx,%eax
    52b4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    lengths[leaves[0].index == 0 ? 1 : 0] = 1;
    52ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    52bd:	8b 40 04             	mov    0x4(%eax),%eax
    52c0:	85 c0                	test   %eax,%eax
    52c2:	75 07                	jne    52cb <lodepng_huffman_code_lengths+0x12b>
    52c4:	ba 04 00 00 00       	mov    $0x4,%edx
    52c9:	eb 05                	jmp    52d0 <lodepng_huffman_code_lengths+0x130>
    52cb:	ba 00 00 00 00       	mov    $0x0,%edx
    52d0:	8b 45 08             	mov    0x8(%ebp),%eax
    52d3:	01 d0                	add    %edx,%eax
    52d5:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    52db:	e9 20 02 00 00       	jmp    5500 <lodepng_huffman_code_lengths+0x360>
  } else {
    BPMLists lists;
    BPMNode* node;

    bpmnode_sort(leaves, numpresent);
    52e0:	83 ec 08             	sub    $0x8,%esp
    52e3:	ff 75 ec             	pushl  -0x14(%ebp)
    52e6:	ff 75 e4             	pushl  -0x1c(%ebp)
    52e9:	e8 2c fb ff ff       	call   4e1a <bpmnode_sort>
    52ee:	83 c4 10             	add    $0x10,%esp

    lists.listsize = maxbitlen;
    52f1:	8b 45 14             	mov    0x14(%ebp),%eax
    52f4:	89 45 d8             	mov    %eax,-0x28(%ebp)
    lists.memsize = 2 * maxbitlen * (maxbitlen + 1);
    52f7:	8b 45 14             	mov    0x14(%ebp),%eax
    52fa:	83 c0 01             	add    $0x1,%eax
    52fd:	0f af 45 14          	imul   0x14(%ebp),%eax
    5301:	01 c0                	add    %eax,%eax
    5303:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    lists.nextfree = 0;
    5306:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
    lists.numfree = lists.memsize;
    530d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5310:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lists.memory = (BPMNode*)lodepng_malloc(lists.memsize * sizeof(*lists.memory));
    5313:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    5316:	c1 e0 04             	shl    $0x4,%eax
    5319:	83 ec 0c             	sub    $0xc,%esp
    531c:	50                   	push   %eax
    531d:	e8 c5 e2 ff ff       	call   35e7 <lodepng_malloc>
    5322:	83 c4 10             	add    $0x10,%esp
    5325:	89 45 c8             	mov    %eax,-0x38(%ebp)
    lists.freelist = (BPMNode**)lodepng_malloc(lists.memsize * sizeof(BPMNode*));
    5328:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    532b:	c1 e0 02             	shl    $0x2,%eax
    532e:	83 ec 0c             	sub    $0xc,%esp
    5331:	50                   	push   %eax
    5332:	e8 b0 e2 ff ff       	call   35e7 <lodepng_malloc>
    5337:	83 c4 10             	add    $0x10,%esp
    533a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    lists.chains0 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    533d:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5340:	c1 e0 02             	shl    $0x2,%eax
    5343:	83 ec 0c             	sub    $0xc,%esp
    5346:	50                   	push   %eax
    5347:	e8 9b e2 ff ff       	call   35e7 <lodepng_malloc>
    534c:	83 c4 10             	add    $0x10,%esp
    534f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lists.chains1 = (BPMNode**)lodepng_malloc(lists.listsize * sizeof(BPMNode*));
    5352:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5355:	c1 e0 02             	shl    $0x2,%eax
    5358:	83 ec 0c             	sub    $0xc,%esp
    535b:	50                   	push   %eax
    535c:	e8 86 e2 ff ff       	call   35e7 <lodepng_malloc>
    5361:	83 c4 10             	add    $0x10,%esp
    5364:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!lists.memory || !lists.freelist || !lists.chains0 || !lists.chains1) error = 83; /*alloc fail*/
    5367:	8b 45 c8             	mov    -0x38(%ebp),%eax
    536a:	85 c0                	test   %eax,%eax
    536c:	74 15                	je     5383 <lodepng_huffman_code_lengths+0x1e3>
    536e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5371:	85 c0                	test   %eax,%eax
    5373:	74 0e                	je     5383 <lodepng_huffman_code_lengths+0x1e3>
    5375:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5378:	85 c0                	test   %eax,%eax
    537a:	74 07                	je     5383 <lodepng_huffman_code_lengths+0x1e3>
    537c:	8b 45 e0             	mov    -0x20(%ebp),%eax
    537f:	85 c0                	test   %eax,%eax
    5381:	75 07                	jne    538a <lodepng_huffman_code_lengths+0x1ea>
    5383:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

    if(!error) {
    538a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    538e:	0f 85 30 01 00 00    	jne    54c4 <lodepng_huffman_code_lengths+0x324>
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];
    5394:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    539b:	eb 1c                	jmp    53b9 <lodepng_huffman_code_lengths+0x219>
    539d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    53a0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    53a3:	c1 e2 02             	shl    $0x2,%edx
    53a6:	01 d0                	add    %edx,%eax
    53a8:	8b 55 c8             	mov    -0x38(%ebp),%edx
    53ab:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    53ae:	c1 e1 04             	shl    $0x4,%ecx
    53b1:	01 ca                	add    %ecx,%edx
    53b3:	89 10                	mov    %edx,(%eax)
    53b5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    53b9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    53bc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    53bf:	75 dc                	jne    539d <lodepng_huffman_code_lengths+0x1fd>

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
    53c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    53c4:	8b 00                	mov    (%eax),%eax
    53c6:	6a 00                	push   $0x0
    53c8:	6a 01                	push   $0x1
    53ca:	50                   	push   %eax
    53cb:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    53ce:	50                   	push   %eax
    53cf:	e8 de f8 ff ff       	call   4cb2 <bpmnode_create>
    53d4:	83 c4 10             	add    $0x10,%esp
      bpmnode_create(&lists, leaves[1].weight, 2, 0);
    53d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    53da:	83 c0 10             	add    $0x10,%eax
    53dd:	8b 00                	mov    (%eax),%eax
    53df:	6a 00                	push   $0x0
    53e1:	6a 02                	push   $0x2
    53e3:	50                   	push   %eax
    53e4:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    53e7:	50                   	push   %eax
    53e8:	e8 c5 f8 ff ff       	call   4cb2 <bpmnode_create>
    53ed:	83 c4 10             	add    $0x10,%esp

      for(i = 0; i != lists.listsize; ++i) {
    53f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    53f7:	eb 27                	jmp    5420 <lodepng_huffman_code_lengths+0x280>
        lists.chains0[i] = &lists.memory[0];
    53f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
    53fc:	8b 55 f0             	mov    -0x10(%ebp),%edx
    53ff:	c1 e2 02             	shl    $0x2,%edx
    5402:	01 c2                	add    %eax,%edx
    5404:	8b 45 c8             	mov    -0x38(%ebp),%eax
    5407:	89 02                	mov    %eax,(%edx)
        lists.chains1[i] = &lists.memory[1];
    5409:	8b 45 e0             	mov    -0x20(%ebp),%eax
    540c:	8b 55 f0             	mov    -0x10(%ebp),%edx
    540f:	c1 e2 02             	shl    $0x2,%edx
    5412:	01 d0                	add    %edx,%eax
    5414:	8b 55 c8             	mov    -0x38(%ebp),%edx
    5417:	83 c2 10             	add    $0x10,%edx
    541a:	89 10                	mov    %edx,(%eax)
      for(i = 0; i != lists.memsize; ++i) lists.freelist[i] = &lists.memory[i];

      bpmnode_create(&lists, leaves[0].weight, 1, 0);
      bpmnode_create(&lists, leaves[1].weight, 2, 0);

      for(i = 0; i != lists.listsize; ++i) {
    541c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5420:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5423:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5426:	75 d1                	jne    53f9 <lodepng_huffman_code_lengths+0x259>
        lists.chains0[i] = &lists.memory[0];
        lists.chains1[i] = &lists.memory[1];
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);
    5428:	c7 45 f0 02 00 00 00 	movl   $0x2,-0x10(%ebp)
    542f:	eb 24                	jmp    5455 <lodepng_huffman_code_lengths+0x2b5>
    5431:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5434:	8b 55 14             	mov    0x14(%ebp),%edx
    5437:	83 ea 01             	sub    $0x1,%edx
    543a:	83 ec 0c             	sub    $0xc,%esp
    543d:	50                   	push   %eax
    543e:	52                   	push   %edx
    543f:	ff 75 ec             	pushl  -0x14(%ebp)
    5442:	ff 75 e4             	pushl  -0x1c(%ebp)
    5445:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    5448:	50                   	push   %eax
    5449:	e8 7a fb ff ff       	call   4fc8 <boundaryPM>
    544e:	83 c4 20             	add    $0x20,%esp
    5451:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5455:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5458:	83 e8 01             	sub    $0x1,%eax
    545b:	01 c0                	add    %eax,%eax
    545d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    5460:	75 cf                	jne    5431 <lodepng_huffman_code_lengths+0x291>

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    5462:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5465:	8b 55 14             	mov    0x14(%ebp),%edx
    5468:	81 c2 ff ff ff 3f    	add    $0x3fffffff,%edx
    546e:	c1 e2 02             	shl    $0x2,%edx
    5471:	01 d0                	add    %edx,%eax
    5473:	8b 00                	mov    (%eax),%eax
    5475:	89 45 e8             	mov    %eax,-0x18(%ebp)
    5478:	eb 44                	jmp    54be <lodepng_huffman_code_lengths+0x31e>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
    547a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5481:	eb 27                	jmp    54aa <lodepng_huffman_code_lengths+0x30a>
    5483:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5486:	c1 e0 04             	shl    $0x4,%eax
    5489:	89 c2                	mov    %eax,%edx
    548b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    548e:	01 d0                	add    %edx,%eax
    5490:	8b 40 04             	mov    0x4(%eax),%eax
    5493:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    549a:	8b 45 08             	mov    0x8(%ebp),%eax
    549d:	01 d0                	add    %edx,%eax
    549f:	8b 10                	mov    (%eax),%edx
    54a1:	83 c2 01             	add    $0x1,%edx
    54a4:	89 10                	mov    %edx,(%eax)
    54a6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    54aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
    54ad:	8b 40 04             	mov    0x4(%eax),%eax
    54b0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    54b3:	75 ce                	jne    5483 <lodepng_huffman_code_lengths+0x2e3>
      }

      /*each boundaryPM call adds one chain to the last list, and we need 2 * numpresent - 2 chains.*/
      for(i = 2; i != 2 * numpresent - 2; ++i) boundaryPM(&lists, leaves, numpresent, (int)maxbitlen - 1, (int)i);

      for(node = lists.chains1[maxbitlen - 1]; node; node = node->tail) {
    54b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    54b8:	8b 40 08             	mov    0x8(%eax),%eax
    54bb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    54be:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    54c2:	75 b6                	jne    547a <lodepng_huffman_code_lengths+0x2da>
        for(i = 0; i != node->index; ++i) ++lengths[leaves[i].index];
      }
    }

    lodepng_free(lists.memory);
    54c4:	8b 45 c8             	mov    -0x38(%ebp),%eax
    54c7:	83 ec 0c             	sub    $0xc,%esp
    54ca:	50                   	push   %eax
    54cb:	e8 38 e1 ff ff       	call   3608 <lodepng_free>
    54d0:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.freelist);
    54d3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    54d6:	83 ec 0c             	sub    $0xc,%esp
    54d9:	50                   	push   %eax
    54da:	e8 29 e1 ff ff       	call   3608 <lodepng_free>
    54df:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains0);
    54e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    54e5:	83 ec 0c             	sub    $0xc,%esp
    54e8:	50                   	push   %eax
    54e9:	e8 1a e1 ff ff       	call   3608 <lodepng_free>
    54ee:	83 c4 10             	add    $0x10,%esp
    lodepng_free(lists.chains1);
    54f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    54f4:	83 ec 0c             	sub    $0xc,%esp
    54f7:	50                   	push   %eax
    54f8:	e8 0b e1 ff ff       	call   3608 <lodepng_free>
    54fd:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(leaves);
    5500:	83 ec 0c             	sub    $0xc,%esp
    5503:	ff 75 e4             	pushl  -0x1c(%ebp)
    5506:	e8 fd e0 ff ff       	call   3608 <lodepng_free>
    550b:	83 c4 10             	add    $0x10,%esp
  return error;
    550e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5511:	c9                   	leave  
    5512:	c3                   	ret    

00005513 <HuffmanTree_makeFromFrequencies>:

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen) {
    5513:	55                   	push   %ebp
    5514:	89 e5                	mov    %esp,%ebp
    5516:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
    5519:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
    5520:	eb 04                	jmp    5526 <HuffmanTree_makeFromFrequencies+0x13>
    5522:	83 6d 14 01          	subl   $0x1,0x14(%ebp)
    5526:	8b 45 14             	mov    0x14(%ebp),%eax
    5529:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    552e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5535:	8b 45 0c             	mov    0xc(%ebp),%eax
    5538:	01 d0                	add    %edx,%eax
    553a:	8b 00                	mov    (%eax),%eax
    553c:	85 c0                	test   %eax,%eax
    553e:	75 08                	jne    5548 <HuffmanTree_makeFromFrequencies+0x35>
    5540:	8b 45 14             	mov    0x14(%ebp),%eax
    5543:	3b 45 10             	cmp    0x10(%ebp),%eax
    5546:	7f da                	jg     5522 <HuffmanTree_makeFromFrequencies+0xf>
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
    5548:	8b 45 14             	mov    0x14(%ebp),%eax
    554b:	c1 e0 02             	shl    $0x2,%eax
    554e:	83 ec 0c             	sub    $0xc,%esp
    5551:	50                   	push   %eax
    5552:	e8 90 e0 ff ff       	call   35e7 <lodepng_malloc>
    5557:	83 c4 10             	add    $0x10,%esp
    555a:	89 c2                	mov    %eax,%edx
    555c:	8b 45 08             	mov    0x8(%ebp),%eax
    555f:	89 50 04             	mov    %edx,0x4(%eax)
  if(!tree->lengths) return 83; /*alloc fail*/
    5562:	8b 45 08             	mov    0x8(%ebp),%eax
    5565:	8b 40 04             	mov    0x4(%eax),%eax
    5568:	85 c0                	test   %eax,%eax
    556a:	75 07                	jne    5573 <HuffmanTree_makeFromFrequencies+0x60>
    556c:	b8 53 00 00 00       	mov    $0x53,%eax
    5571:	eb 47                	jmp    55ba <HuffmanTree_makeFromFrequencies+0xa7>
  tree->maxbitlen = maxbitlen;
    5573:	8b 45 08             	mov    0x8(%ebp),%eax
    5576:	8b 55 18             	mov    0x18(%ebp),%edx
    5579:	89 50 08             	mov    %edx,0x8(%eax)
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
    557c:	8b 55 14             	mov    0x14(%ebp),%edx
    557f:	8b 45 08             	mov    0x8(%ebp),%eax
    5582:	89 50 0c             	mov    %edx,0xc(%eax)

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
    5585:	8b 45 08             	mov    0x8(%ebp),%eax
    5588:	8b 40 04             	mov    0x4(%eax),%eax
    558b:	ff 75 18             	pushl  0x18(%ebp)
    558e:	ff 75 14             	pushl  0x14(%ebp)
    5591:	ff 75 0c             	pushl  0xc(%ebp)
    5594:	50                   	push   %eax
    5595:	e8 06 fc ff ff       	call   51a0 <lodepng_huffman_code_lengths>
    559a:	83 c4 10             	add    $0x10,%esp
    559d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
    55a0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    55a4:	75 11                	jne    55b7 <HuffmanTree_makeFromFrequencies+0xa4>
    55a6:	83 ec 0c             	sub    $0xc,%esp
    55a9:	ff 75 08             	pushl  0x8(%ebp)
    55ac:	e8 37 f4 ff ff       	call   49e8 <HuffmanTree_makeFromLengths2>
    55b1:	83 c4 10             	add    $0x10,%esp
    55b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return error;
    55b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    55ba:	c9                   	leave  
    55bb:	c3                   	ret    

000055bc <generateFixedLitLenTree>:
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree) {
    55bc:	55                   	push   %ebp
    55bd:	89 e5                	mov    %esp,%ebp
    55bf:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    55c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    55c9:	83 ec 0c             	sub    $0xc,%esp
    55cc:	68 80 04 00 00       	push   $0x480
    55d1:	e8 11 e0 ff ff       	call   35e7 <lodepng_malloc>
    55d6:	83 c4 10             	add    $0x10,%esp
    55d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    55dc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    55e0:	75 0a                	jne    55ec <generateFixedLitLenTree+0x30>
    55e2:	b8 53 00 00 00       	mov    $0x53,%eax
    55e7:	e9 d5 00 00 00       	jmp    56c1 <generateFixedLitLenTree+0x105>

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
    55ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    55f3:	eb 19                	jmp    560e <generateFixedLitLenTree+0x52>
    55f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    55f8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    55ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5602:	01 d0                	add    %edx,%eax
    5604:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    560a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    560e:	81 7d f4 8f 00 00 00 	cmpl   $0x8f,-0xc(%ebp)
    5615:	76 de                	jbe    55f5 <generateFixedLitLenTree+0x39>
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
    5617:	c7 45 f4 90 00 00 00 	movl   $0x90,-0xc(%ebp)
    561e:	eb 19                	jmp    5639 <generateFixedLitLenTree+0x7d>
    5620:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5623:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    562a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    562d:	01 d0                	add    %edx,%eax
    562f:	c7 00 09 00 00 00    	movl   $0x9,(%eax)
    5635:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5639:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
    5640:	76 de                	jbe    5620 <generateFixedLitLenTree+0x64>
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
    5642:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
    5649:	eb 19                	jmp    5664 <generateFixedLitLenTree+0xa8>
    564b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    564e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5655:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5658:	01 d0                	add    %edx,%eax
    565a:	c7 00 07 00 00 00    	movl   $0x7,(%eax)
    5660:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5664:	81 7d f4 17 01 00 00 	cmpl   $0x117,-0xc(%ebp)
    566b:	76 de                	jbe    564b <generateFixedLitLenTree+0x8f>
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;
    566d:	c7 45 f4 18 01 00 00 	movl   $0x118,-0xc(%ebp)
    5674:	eb 19                	jmp    568f <generateFixedLitLenTree+0xd3>
    5676:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5679:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5680:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5683:	01 d0                	add    %edx,%eax
    5685:	c7 00 08 00 00 00    	movl   $0x8,(%eax)
    568b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    568f:	81 7d f4 1f 01 00 00 	cmpl   $0x11f,-0xc(%ebp)
    5696:	76 de                	jbe    5676 <generateFixedLitLenTree+0xba>

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5698:	6a 0f                	push   $0xf
    569a:	68 20 01 00 00       	push   $0x120
    569f:	ff 75 ec             	pushl  -0x14(%ebp)
    56a2:	ff 75 08             	pushl  0x8(%ebp)
    56a5:	e8 7f f5 ff ff       	call   4c29 <HuffmanTree_makeFromLengths>
    56aa:	83 c4 10             	add    $0x10,%esp
    56ad:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    56b0:	83 ec 0c             	sub    $0xc,%esp
    56b3:	ff 75 ec             	pushl  -0x14(%ebp)
    56b6:	e8 4d df ff ff       	call   3608 <lodepng_free>
    56bb:	83 c4 10             	add    $0x10,%esp
  return error;
    56be:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    56c1:	c9                   	leave  
    56c2:	c3                   	ret    

000056c3 <generateFixedDistanceTree>:

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree) {
    56c3:	55                   	push   %ebp
    56c4:	89 e5                	mov    %esp,%ebp
    56c6:	83 ec 18             	sub    $0x18,%esp
  unsigned i, error = 0;
    56c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    56d0:	83 ec 0c             	sub    $0xc,%esp
    56d3:	68 80 00 00 00       	push   $0x80
    56d8:	e8 0a df ff ff       	call   35e7 <lodepng_malloc>
    56dd:	83 c4 10             	add    $0x10,%esp
    56e0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(!bitlen) return 83; /*alloc fail*/
    56e3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    56e7:	75 07                	jne    56f0 <generateFixedDistanceTree+0x2d>
    56e9:	b8 53 00 00 00       	mov    $0x53,%eax
    56ee:	eb 4e                	jmp    573e <generateFixedDistanceTree+0x7b>

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
    56f0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    56f7:	eb 19                	jmp    5712 <generateFixedDistanceTree+0x4f>
    56f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    56fc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5703:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5706:	01 d0                	add    %edx,%eax
    5708:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
    570e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    5712:	83 7d f4 20          	cmpl   $0x20,-0xc(%ebp)
    5716:	75 e1                	jne    56f9 <generateFixedDistanceTree+0x36>
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);
    5718:	6a 0f                	push   $0xf
    571a:	6a 20                	push   $0x20
    571c:	ff 75 ec             	pushl  -0x14(%ebp)
    571f:	ff 75 08             	pushl  0x8(%ebp)
    5722:	e8 02 f5 ff ff       	call   4c29 <HuffmanTree_makeFromLengths>
    5727:	83 c4 10             	add    $0x10,%esp
    572a:	89 45 f0             	mov    %eax,-0x10(%ebp)

  lodepng_free(bitlen);
    572d:	83 ec 0c             	sub    $0xc,%esp
    5730:	ff 75 ec             	pushl  -0x14(%ebp)
    5733:	e8 d0 de ff ff       	call   3608 <lodepng_free>
    5738:	83 c4 10             	add    $0x10,%esp
  return error;
    573b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    573e:	c9                   	leave  
    573f:	c3                   	ret    

00005740 <huffmanDecodeSymbol>:
#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code. The bit reader must already have been ensured at least 15 bits
*/
static unsigned huffmanDecodeSymbol(LodePNGBitReader* reader, const HuffmanTree* codetree) {
    5740:	55                   	push   %ebp
    5741:	89 e5                	mov    %esp,%ebp
    5743:	53                   	push   %ebx
    5744:	83 ec 10             	sub    $0x10,%esp
  unsigned short code = peekBits(reader, FIRSTBITS);
    5747:	6a 09                	push   $0x9
    5749:	ff 75 08             	pushl  0x8(%ebp)
    574c:	e8 d8 eb ff ff       	call   4329 <peekBits>
    5751:	83 c4 08             	add    $0x8,%esp
    5754:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  unsigned short l = codetree->table_len[code];
    5758:	8b 45 0c             	mov    0xc(%ebp),%eax
    575b:	8b 50 10             	mov    0x10(%eax),%edx
    575e:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    5762:	01 d0                	add    %edx,%eax
    5764:	0f b6 00             	movzbl (%eax),%eax
    5767:	0f b6 c0             	movzbl %al,%eax
    576a:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  unsigned short value = codetree->table_value[code];
    576e:	8b 45 0c             	mov    0xc(%ebp),%eax
    5771:	8b 40 14             	mov    0x14(%eax),%eax
    5774:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    5778:	01 d2                	add    %edx,%edx
    577a:	01 d0                	add    %edx,%eax
    577c:	0f b7 00             	movzwl (%eax),%eax
    577f:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
  if(l <= FIRSTBITS) {
    5783:	66 83 7d f8 09       	cmpw   $0x9,-0x8(%ebp)
    5788:	77 16                	ja     57a0 <huffmanDecodeSymbol+0x60>
    advanceBits(reader, l);
    578a:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    578e:	50                   	push   %eax
    578f:	ff 75 08             	pushl  0x8(%ebp)
    5792:	e8 b2 eb ff ff       	call   4349 <advanceBits>
    5797:	83 c4 08             	add    $0x8,%esp
    return value;
    579a:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
    579e:	eb 5c                	jmp    57fc <huffmanDecodeSymbol+0xbc>
  } else {
    unsigned index2;
    advanceBits(reader, FIRSTBITS);
    57a0:	6a 09                	push   $0x9
    57a2:	ff 75 08             	pushl  0x8(%ebp)
    57a5:	e8 9f eb ff ff       	call   4349 <advanceBits>
    57aa:	83 c4 08             	add    $0x8,%esp
    index2 = value + peekBits(reader, l - FIRSTBITS);
    57ad:	0f b7 5d f6          	movzwl -0xa(%ebp),%ebx
    57b1:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
    57b5:	83 e8 09             	sub    $0x9,%eax
    57b8:	50                   	push   %eax
    57b9:	ff 75 08             	pushl  0x8(%ebp)
    57bc:	e8 68 eb ff ff       	call   4329 <peekBits>
    57c1:	83 c4 08             	add    $0x8,%esp
    57c4:	01 d8                	add    %ebx,%eax
    57c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    advanceBits(reader, codetree->table_len[index2] - FIRSTBITS);
    57c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    57cc:	8b 50 10             	mov    0x10(%eax),%edx
    57cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    57d2:	01 d0                	add    %edx,%eax
    57d4:	0f b6 00             	movzbl (%eax),%eax
    57d7:	0f b6 c0             	movzbl %al,%eax
    57da:	83 e8 09             	sub    $0x9,%eax
    57dd:	50                   	push   %eax
    57de:	ff 75 08             	pushl  0x8(%ebp)
    57e1:	e8 63 eb ff ff       	call   4349 <advanceBits>
    57e6:	83 c4 08             	add    $0x8,%esp
    return codetree->table_value[index2];
    57e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    57ec:	8b 40 14             	mov    0x14(%eax),%eax
    57ef:	8b 55 f0             	mov    -0x10(%ebp),%edx
    57f2:	01 d2                	add    %edx,%edx
    57f4:	01 d0                	add    %edx,%eax
    57f6:	0f b7 00             	movzwl (%eax),%eax
    57f9:	0f b7 c0             	movzwl %ax,%eax
  }
}
    57fc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    57ff:	c9                   	leave  
    5800:	c3                   	ret    

00005801 <getTreeInflateFixed>:
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification
Returns error code.*/
static unsigned getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d) {
    5801:	55                   	push   %ebp
    5802:	89 e5                	mov    %esp,%ebp
    5804:	83 ec 18             	sub    $0x18,%esp
  unsigned error = generateFixedLitLenTree(tree_ll);
    5807:	83 ec 0c             	sub    $0xc,%esp
    580a:	ff 75 08             	pushl  0x8(%ebp)
    580d:	e8 aa fd ff ff       	call   55bc <generateFixedLitLenTree>
    5812:	83 c4 10             	add    $0x10,%esp
    5815:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    5818:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    581c:	74 05                	je     5823 <getTreeInflateFixed+0x22>
    581e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    5821:	eb 0e                	jmp    5831 <getTreeInflateFixed+0x30>
  return generateFixedDistanceTree(tree_d);
    5823:	83 ec 0c             	sub    $0xc,%esp
    5826:	ff 75 0c             	pushl  0xc(%ebp)
    5829:	e8 95 fe ff ff       	call   56c3 <generateFixedDistanceTree>
    582e:	83 c4 10             	add    $0x10,%esp
}
    5831:	c9                   	leave  
    5832:	c3                   	ret    

00005833 <getTreeInflateDynamic>:

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      LodePNGBitReader* reader) {
    5833:	55                   	push   %ebp
    5834:	89 e5                	mov    %esp,%ebp
    5836:	53                   	push   %ebx
    5837:	83 ec 54             	sub    $0x54,%esp
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
    583a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned n, HLIT, HDIST, HCLEN, i;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
    5841:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned* bitlen_d = 0; /*dist code lengths*/
    5848:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
    584f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if(!ensureBits17(reader, 14)) return 49; /*error: the bit pointer is or will go past the memory*/
    5856:	6a 0e                	push   $0xe
    5858:	ff 75 10             	pushl  0x10(%ebp)
    585b:	e8 37 e6 ff ff       	call   3e97 <ensureBits17>
    5860:	83 c4 08             	add    $0x8,%esp
    5863:	85 c0                	test   %eax,%eax
    5865:	75 0a                	jne    5871 <getTreeInflateDynamic+0x3e>
    5867:	b8 31 00 00 00       	mov    $0x31,%eax
    586c:	e9 ec 04 00 00       	jmp    5d5d <getTreeInflateDynamic+0x52a>

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBits(reader, 5) + 257;
    5871:	6a 05                	push   $0x5
    5873:	ff 75 10             	pushl  0x10(%ebp)
    5876:	e8 f8 ea ff ff       	call   4373 <readBits>
    587b:	83 c4 08             	add    $0x8,%esp
    587e:	05 01 01 00 00       	add    $0x101,%eax
    5883:	89 45 d8             	mov    %eax,-0x28(%ebp)
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBits(reader, 5) + 1;
    5886:	6a 05                	push   $0x5
    5888:	ff 75 10             	pushl  0x10(%ebp)
    588b:	e8 e3 ea ff ff       	call   4373 <readBits>
    5890:	83 c4 08             	add    $0x8,%esp
    5893:	83 c0 01             	add    $0x1,%eax
    5896:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBits(reader, 4) + 4;
    5899:	6a 04                	push   $0x4
    589b:	ff 75 10             	pushl  0x10(%ebp)
    589e:	e8 d0 ea ff ff       	call   4373 <readBits>
    58a3:	83 c4 08             	add    $0x8,%esp
    58a6:	83 c0 04             	add    $0x4,%eax
    58a9:	89 45 d0             	mov    %eax,-0x30(%ebp)

  bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    58ac:	83 ec 0c             	sub    $0xc,%esp
    58af:	6a 4c                	push   $0x4c
    58b1:	e8 31 dd ff ff       	call   35e7 <lodepng_malloc>
    58b6:	83 c4 10             	add    $0x10,%esp
    58b9:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if(!bitlen_cl) return 83 /*alloc fail*/;
    58bc:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    58c0:	75 0a                	jne    58cc <getTreeInflateDynamic+0x99>
    58c2:	b8 53 00 00 00       	mov    $0x53,%eax
    58c7:	e9 91 04 00 00       	jmp    5d5d <getTreeInflateDynamic+0x52a>

  HuffmanTree_init(&tree_cl);
    58cc:	83 ec 0c             	sub    $0xc,%esp
    58cf:	8d 45 a8             	lea    -0x58(%ebp),%eax
    58d2:	50                   	push   %eax
    58d3:	e8 03 ec ff ff       	call   44db <HuffmanTree_init>
    58d8:	83 c4 10             	add    $0x10,%esp

  while(!error) {
    58db:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    58df:	0f 85 3c 04 00 00    	jne    5d21 <getTreeInflateDynamic+0x4ee>
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
    58e5:	8b 45 10             	mov    0x10(%ebp),%eax
    58e8:	8b 48 08             	mov    0x8(%eax),%ecx
    58eb:	8b 55 d0             	mov    -0x30(%ebp),%edx
    58ee:	89 d0                	mov    %edx,%eax
    58f0:	01 c0                	add    %eax,%eax
    58f2:	01 d0                	add    %edx,%eax
    58f4:	89 c2                	mov    %eax,%edx
    58f6:	8b 45 10             	mov    0x10(%ebp),%eax
    58f9:	8b 40 0c             	mov    0xc(%eax),%eax
    58fc:	83 ec 04             	sub    $0x4,%esp
    58ff:	51                   	push   %ecx
    5900:	52                   	push   %edx
    5901:	50                   	push   %eax
    5902:	e8 f7 dd ff ff       	call   36fe <lodepng_gtofl>
    5907:	83 c4 10             	add    $0x10,%esp
    590a:	85 c0                	test   %eax,%eax
    590c:	74 0c                	je     591a <getTreeInflateDynamic+0xe7>
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    590e:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5915:	e9 07 04 00 00       	jmp    5d21 <getTreeInflateDynamic+0x4ee>
    }
    for(i = 0; i != HCLEN; ++i) {
    591a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    5921:	eb 3d                	jmp    5960 <getTreeInflateDynamic+0x12d>
      ensureBits9(reader, 3); /*out of bounds already checked above */
    5923:	83 ec 08             	sub    $0x8,%esp
    5926:	6a 03                	push   $0x3
    5928:	ff 75 10             	pushl  0x10(%ebp)
    592b:	e8 8b e4 ff ff       	call   3dbb <ensureBits9>
    5930:	83 c4 10             	add    $0x10,%esp
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    5933:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5936:	8b 04 85 00 a2 01 00 	mov    0x1a200(,%eax,4),%eax
    593d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5944:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5947:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    594a:	83 ec 08             	sub    $0x8,%esp
    594d:	6a 03                	push   $0x3
    594f:	ff 75 10             	pushl  0x10(%ebp)
    5952:	e8 1c ea ff ff       	call   4373 <readBits>
    5957:	83 c4 10             	add    $0x10,%esp
    595a:	89 03                	mov    %eax,(%ebx)
  while(!error) {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/
    if(lodepng_gtofl(reader->bp, HCLEN * 3, reader->bitsize)) {
      ERROR_BREAK(50); /*error: the bit pointer is or will go past the memory*/
    }
    for(i = 0; i != HCLEN; ++i) {
    595c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5960:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5963:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    5966:	75 bb                	jne    5923 <getTreeInflateDynamic+0xf0>
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    5968:	8b 45 d0             	mov    -0x30(%ebp),%eax
    596b:	89 45 ec             	mov    %eax,-0x14(%ebp)
    596e:	eb 20                	jmp    5990 <getTreeInflateDynamic+0x15d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    5970:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5973:	8b 04 85 00 a2 01 00 	mov    0x1a200(,%eax,4),%eax
    597a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5981:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5984:	01 d0                	add    %edx,%eax
    5986:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
    for(i = 0; i != HCLEN; ++i) {
      ensureBits9(reader, 3); /*out of bounds already checked above */
      bitlen_cl[CLCL_ORDER[i]] = readBits(reader, 3);
    }
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
    598c:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5990:	83 7d ec 13          	cmpl   $0x13,-0x14(%ebp)
    5994:	75 da                	jne    5970 <getTreeInflateDynamic+0x13d>
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    5996:	6a 07                	push   $0x7
    5998:	6a 13                	push   $0x13
    599a:	ff 75 dc             	pushl  -0x24(%ebp)
    599d:	8d 45 a8             	lea    -0x58(%ebp),%eax
    59a0:	50                   	push   %eax
    59a1:	e8 83 f2 ff ff       	call   4c29 <HuffmanTree_makeFromLengths>
    59a6:	83 c4 10             	add    $0x10,%esp
    59a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    59ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    59b0:	0f 85 64 03 00 00    	jne    5d1a <getTreeInflateDynamic+0x4e7>

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    59b6:	83 ec 0c             	sub    $0xc,%esp
    59b9:	68 80 04 00 00       	push   $0x480
    59be:	e8 24 dc ff ff       	call   35e7 <lodepng_malloc>
    59c3:	83 c4 10             	add    $0x10,%esp
    59c6:	89 45 e8             	mov    %eax,-0x18(%ebp)
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    59c9:	83 ec 0c             	sub    $0xc,%esp
    59cc:	68 80 00 00 00       	push   $0x80
    59d1:	e8 11 dc ff ff       	call   35e7 <lodepng_malloc>
    59d6:	83 c4 10             	add    $0x10,%esp
    59d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    59dc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    59e0:	74 06                	je     59e8 <getTreeInflateDynamic+0x1b5>
    59e2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    59e6:	75 0c                	jne    59f4 <getTreeInflateDynamic+0x1c1>
    59e8:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    59ef:	e9 2d 03 00 00       	jmp    5d21 <getTreeInflateDynamic+0x4ee>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    59f4:	83 ec 04             	sub    $0x4,%esp
    59f7:	68 80 04 00 00       	push   $0x480
    59fc:	6a 00                	push   $0x0
    59fe:	ff 75 e8             	pushl  -0x18(%ebp)
    5a01:	e8 52 dc ff ff       	call   3658 <lodepng_memset>
    5a06:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));
    5a09:	83 ec 04             	sub    $0x4,%esp
    5a0c:	68 80 00 00 00       	push   $0x80
    5a11:	6a 00                	push   $0x0
    5a13:	ff 75 e4             	pushl  -0x1c(%ebp)
    5a16:	e8 3d dc ff ff       	call   3658 <lodepng_memset>
    5a1b:	83 c4 10             	add    $0x10,%esp

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    5a1e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    while(i < HLIT + HDIST) {
    5a25:	e9 8d 02 00 00       	jmp    5cb7 <getTreeInflateDynamic+0x484>
      unsigned code;
      ensureBits25(reader, 22); /* up to 15 bits for huffman code, up to 7 extra bits below*/
    5a2a:	83 ec 08             	sub    $0x8,%esp
    5a2d:	6a 16                	push   $0x16
    5a2f:	ff 75 10             	pushl  0x10(%ebp)
    5a32:	e8 8c e5 ff ff       	call   3fc3 <ensureBits25>
    5a37:	83 c4 10             	add    $0x10,%esp
      code = huffmanDecodeSymbol(reader, &tree_cl);
    5a3a:	83 ec 08             	sub    $0x8,%esp
    5a3d:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5a40:	50                   	push   %eax
    5a41:	ff 75 10             	pushl  0x10(%ebp)
    5a44:	e8 f7 fc ff ff       	call   5740 <huffmanDecodeSymbol>
    5a49:	83 c4 10             	add    $0x10,%esp
    5a4c:	89 45 cc             	mov    %eax,-0x34(%ebp)
      if(code <= 15) /*a length code*/ {
    5a4f:	83 7d cc 0f          	cmpl   $0xf,-0x34(%ebp)
    5a53:	77 3e                	ja     5a93 <getTreeInflateDynamic+0x260>
        if(i < HLIT) bitlen_ll[i] = code;
    5a55:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a58:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5a5b:	73 16                	jae    5a73 <getTreeInflateDynamic+0x240>
    5a5d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a60:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a67:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5a6a:	01 c2                	add    %eax,%edx
    5a6c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5a6f:	89 02                	mov    %eax,(%edx)
    5a71:	eb 17                	jmp    5a8a <getTreeInflateDynamic+0x257>
        else bitlen_d[i - HLIT] = code;
    5a73:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5a76:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5a79:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5a80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5a83:	01 c2                	add    %eax,%edx
    5a85:	8b 45 cc             	mov    -0x34(%ebp),%eax
    5a88:	89 02                	mov    %eax,(%edx)
        ++i;
    5a8a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    5a8e:	e9 0b 02 00 00       	jmp    5c9e <getTreeInflateDynamic+0x46b>
      } else if(code == 16) /*repeat previous*/ {
    5a93:	83 7d cc 10          	cmpl   $0x10,-0x34(%ebp)
    5a97:	0f 85 da 00 00 00    	jne    5b77 <getTreeInflateDynamic+0x344>
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
    5a9d:	c7 45 c0 03 00 00 00 	movl   $0x3,-0x40(%ebp)
        unsigned value; /*set value to the previous code*/

        if(i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/
    5aa4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    5aa8:	75 0c                	jne    5ab6 <getTreeInflateDynamic+0x283>
    5aaa:	c7 45 f4 36 00 00 00 	movl   $0x36,-0xc(%ebp)
    5ab1:	e9 12 02 00 00       	jmp    5cc8 <getTreeInflateDynamic+0x495>

        replength += readBits(reader, 2);
    5ab6:	83 ec 08             	sub    $0x8,%esp
    5ab9:	6a 02                	push   $0x2
    5abb:	ff 75 10             	pushl  0x10(%ebp)
    5abe:	e8 b0 e8 ff ff       	call   4373 <readBits>
    5ac3:	83 c4 10             	add    $0x10,%esp
    5ac6:	01 45 c0             	add    %eax,-0x40(%ebp)

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
    5ac9:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5acc:	83 c0 01             	add    $0x1,%eax
    5acf:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5ad2:	76 1b                	jbe    5aef <getTreeInflateDynamic+0x2bc>
    5ad4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5ad7:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5adc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5ae3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5ae6:	01 d0                	add    %edx,%eax
    5ae8:	8b 00                	mov    (%eax),%eax
    5aea:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5aed:	eb 1c                	jmp    5b0b <getTreeInflateDynamic+0x2d8>
        else value = bitlen_d[i - HLIT - 1];
    5aef:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5af2:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5af5:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    5afa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5b01:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5b04:	01 d0                	add    %edx,%eax
    5b06:	8b 00                	mov    (%eax),%eax
    5b08:	89 45 e0             	mov    %eax,-0x20(%ebp)
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5b0b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5b12:	eb 56                	jmp    5b6a <getTreeInflateDynamic+0x337>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
    5b14:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5b17:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5b1a:	01 d0                	add    %edx,%eax
    5b1c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5b1f:	77 0c                	ja     5b2d <getTreeInflateDynamic+0x2fa>
    5b21:	c7 45 f4 0d 00 00 00 	movl   $0xd,-0xc(%ebp)
    5b28:	e9 71 01 00 00       	jmp    5c9e <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = value;
    5b2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5b30:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5b33:	73 16                	jae    5b4b <getTreeInflateDynamic+0x318>
    5b35:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5b38:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5b3f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5b42:	01 c2                	add    %eax,%edx
    5b44:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5b47:	89 02                	mov    %eax,(%edx)
    5b49:	eb 17                	jmp    5b62 <getTreeInflateDynamic+0x32f>
          else bitlen_d[i - HLIT] = value;
    5b4b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5b4e:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5b51:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5b58:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5b5b:	01 c2                	add    %eax,%edx
    5b5d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5b60:	89 02                	mov    %eax,(%edx)
          ++i;
    5b62:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
        replength += readBits(reader, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5b66:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5b6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5b6d:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    5b70:	72 a2                	jb     5b14 <getTreeInflateDynamic+0x2e1>
    5b72:	e9 27 01 00 00       	jmp    5c9e <getTreeInflateDynamic+0x46b>
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          ++i;
        }
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
    5b77:	83 7d cc 11          	cmpl   $0x11,-0x34(%ebp)
    5b7b:	0f 85 88 00 00 00    	jne    5c09 <getTreeInflateDynamic+0x3d6>
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
    5b81:	c7 45 c8 03 00 00 00 	movl   $0x3,-0x38(%ebp)
        replength += readBits(reader, 3);
    5b88:	83 ec 08             	sub    $0x8,%esp
    5b8b:	6a 03                	push   $0x3
    5b8d:	ff 75 10             	pushl  0x10(%ebp)
    5b90:	e8 de e7 ff ff       	call   4373 <readBits>
    5b95:	83 c4 10             	add    $0x10,%esp
    5b98:	01 45 c8             	add    %eax,-0x38(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5b9b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5ba2:	eb 58                	jmp    5bfc <getTreeInflateDynamic+0x3c9>
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/
    5ba4:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5ba7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5baa:	01 d0                	add    %edx,%eax
    5bac:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5baf:	77 0c                	ja     5bbd <getTreeInflateDynamic+0x38a>
    5bb1:	c7 45 f4 0e 00 00 00 	movl   $0xe,-0xc(%ebp)
    5bb8:	e9 e1 00 00 00       	jmp    5c9e <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5bbd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5bc0:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5bc3:	73 17                	jae    5bdc <getTreeInflateDynamic+0x3a9>
    5bc5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5bc8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5bcf:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5bd2:	01 d0                	add    %edx,%eax
    5bd4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5bda:	eb 18                	jmp    5bf4 <getTreeInflateDynamic+0x3c1>
          else bitlen_d[i - HLIT] = 0;
    5bdc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5bdf:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5be2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5be9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5bec:	01 d0                	add    %edx,%eax
    5bee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5bf4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 17) /*repeat "0" 3-10 times*/ {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5bf8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5bfc:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5bff:	3b 45 c8             	cmp    -0x38(%ebp),%eax
    5c02:	72 a0                	jb     5ba4 <getTreeInflateDynamic+0x371>
    5c04:	e9 95 00 00 00       	jmp    5c9e <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
    5c09:	83 7d cc 12          	cmpl   $0x12,-0x34(%ebp)
    5c0d:	0f 85 82 00 00 00    	jne    5c95 <getTreeInflateDynamic+0x462>
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
    5c13:	c7 45 c4 0b 00 00 00 	movl   $0xb,-0x3c(%ebp)
        replength += readBits(reader, 7);
    5c1a:	83 ec 08             	sub    $0x8,%esp
    5c1d:	6a 07                	push   $0x7
    5c1f:	ff 75 10             	pushl  0x10(%ebp)
    5c22:	e8 4c e7 ff ff       	call   4373 <readBits>
    5c27:	83 c4 10             	add    $0x10,%esp
    5c2a:	01 45 c4             	add    %eax,-0x3c(%ebp)

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5c2d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    5c34:	eb 55                	jmp    5c8b <getTreeInflateDynamic+0x458>
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/
    5c36:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5c39:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5c3c:	01 d0                	add    %edx,%eax
    5c3e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5c41:	77 09                	ja     5c4c <getTreeInflateDynamic+0x419>
    5c43:	c7 45 f4 0f 00 00 00 	movl   $0xf,-0xc(%ebp)
    5c4a:	eb 52                	jmp    5c9e <getTreeInflateDynamic+0x46b>

          if(i < HLIT) bitlen_ll[i] = 0;
    5c4c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c4f:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    5c52:	73 17                	jae    5c6b <getTreeInflateDynamic+0x438>
    5c54:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c57:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5c5e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5c61:	01 d0                	add    %edx,%eax
    5c63:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    5c69:	eb 18                	jmp    5c83 <getTreeInflateDynamic+0x450>
          else bitlen_d[i - HLIT] = 0;
    5c6b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5c6e:	2b 45 d8             	sub    -0x28(%ebp),%eax
    5c71:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    5c78:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5c7b:	01 d0                	add    %edx,%eax
    5c7d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          ++i;
    5c83:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
      } else if(code == 18) /*repeat "0" 11-138 times*/ {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        replength += readBits(reader, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; ++n) {
    5c87:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    5c8b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5c8e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    5c91:	72 a3                	jb     5c36 <getTreeInflateDynamic+0x403>
    5c93:	eb 09                	jmp    5c9e <getTreeInflateDynamic+0x46b>
          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          ++i;
        }
      } else /*if(code == INVALIDSYMBOL)*/ {
        ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5c95:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5c9c:	eb 2a                	jmp    5cc8 <getTreeInflateDynamic+0x495>
      }
      /*check if any of the ensureBits above went out of bounds*/
      if(reader->bp > reader->bitsize) {
    5c9e:	8b 45 10             	mov    0x10(%ebp),%eax
    5ca1:	8b 50 0c             	mov    0xc(%eax),%edx
    5ca4:	8b 45 10             	mov    0x10(%ebp),%eax
    5ca7:	8b 40 08             	mov    0x8(%eax),%eax
    5caa:	39 c2                	cmp    %eax,%edx
    5cac:	7e 09                	jle    5cb7 <getTreeInflateDynamic+0x484>
        /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
    5cae:	c7 45 f4 32 00 00 00 	movl   $0x32,-0xc(%ebp)
    5cb5:	eb 11                	jmp    5cc8 <getTreeInflateDynamic+0x495>
    lodepng_memset(bitlen_ll, 0, NUM_DEFLATE_CODE_SYMBOLS * sizeof(*bitlen_ll));
    lodepng_memset(bitlen_d, 0, NUM_DISTANCE_SYMBOLS * sizeof(*bitlen_d));

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST) {
    5cb7:	8b 55 d8             	mov    -0x28(%ebp),%edx
    5cba:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5cbd:	01 d0                	add    %edx,%eax
    5cbf:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    5cc2:	0f 87 62 fd ff ff    	ja     5a2a <getTreeInflateDynamic+0x1f7>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5cc8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5ccc:	75 4f                	jne    5d1d <getTreeInflateDynamic+0x4ea>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/
    5cce:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5cd1:	05 00 04 00 00       	add    $0x400,%eax
    5cd6:	8b 00                	mov    (%eax),%eax
    5cd8:	85 c0                	test   %eax,%eax
    5cda:	75 09                	jne    5ce5 <getTreeInflateDynamic+0x4b2>
    5cdc:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    5ce3:	eb 3c                	jmp    5d21 <getTreeInflateDynamic+0x4ee>

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    5ce5:	6a 0f                	push   $0xf
    5ce7:	68 20 01 00 00       	push   $0x120
    5cec:	ff 75 e8             	pushl  -0x18(%ebp)
    5cef:	ff 75 08             	pushl  0x8(%ebp)
    5cf2:	e8 32 ef ff ff       	call   4c29 <HuffmanTree_makeFromLengths>
    5cf7:	83 c4 10             	add    $0x10,%esp
    5cfa:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    5cfd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    5d01:	75 1d                	jne    5d20 <getTreeInflateDynamic+0x4ed>
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);
    5d03:	6a 0f                	push   $0xf
    5d05:	6a 20                	push   $0x20
    5d07:	ff 75 e4             	pushl  -0x1c(%ebp)
    5d0a:	ff 75 0c             	pushl  0xc(%ebp)
    5d0d:	e8 17 ef ff ff       	call   4c29 <HuffmanTree_makeFromLengths>
    5d12:	83 c4 10             	add    $0x10,%esp
    5d15:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break; /*end of error-while*/
    5d18:	eb 07                	jmp    5d21 <getTreeInflateDynamic+0x4ee>
    for(i = HCLEN; i != NUM_CODE_LENGTH_CODES; ++i) {
      bitlen_cl[CLCL_ORDER[i]] = 0;
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    5d1a:	90                   	nop
    5d1b:	eb 04                	jmp    5d21 <getTreeInflateDynamic+0x4ee>
        (10=no endcode, 11=wrong jump outside of tree)*/
        /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
        ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
      }
    }
    if(error) break;
    5d1d:	90                   	nop
    5d1e:	eb 01                	jmp    5d21 <getTreeInflateDynamic+0x4ee>

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    5d20:	90                   	nop
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
    5d21:	83 ec 0c             	sub    $0xc,%esp
    5d24:	ff 75 dc             	pushl  -0x24(%ebp)
    5d27:	e8 dc d8 ff ff       	call   3608 <lodepng_free>
    5d2c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_ll);
    5d2f:	83 ec 0c             	sub    $0xc,%esp
    5d32:	ff 75 e8             	pushl  -0x18(%ebp)
    5d35:	e8 ce d8 ff ff       	call   3608 <lodepng_free>
    5d3a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_d);
    5d3d:	83 ec 0c             	sub    $0xc,%esp
    5d40:	ff 75 e4             	pushl  -0x1c(%ebp)
    5d43:	e8 c0 d8 ff ff       	call   3608 <lodepng_free>
    5d48:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    5d4b:	83 ec 0c             	sub    $0xc,%esp
    5d4e:	8d 45 a8             	lea    -0x58(%ebp),%eax
    5d51:	50                   	push   %eax
    5d52:	e8 b1 e7 ff ff       	call   4508 <HuffmanTree_cleanup>
    5d57:	83 c4 10             	add    $0x10,%esp

  return error;
    5d5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    5d5d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    5d60:	c9                   	leave  
    5d61:	c3                   	ret    

00005d62 <inflateHuffmanBlock>:

/*inflate a block with dynamic of fixed Huffman tree. btype must be 1 or 2.*/
static unsigned inflateHuffmanBlock(ucvector* out, LodePNGBitReader* reader,
                                    unsigned btype, size_t max_output_size) {
    5d62:	55                   	push   %ebp
    5d63:	89 e5                	mov    %esp,%ebp
    5d65:	53                   	push   %ebx
    5d66:	83 ec 64             	sub    $0x64,%esp
  unsigned error = 0;
    5d69:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/

  HuffmanTree_init(&tree_ll);
    5d70:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5d73:	50                   	push   %eax
    5d74:	e8 62 e7 ff ff       	call   44db <HuffmanTree_init>
    5d79:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    5d7c:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5d7f:	50                   	push   %eax
    5d80:	e8 56 e7 ff ff       	call   44db <HuffmanTree_init>
    5d85:	83 c4 04             	add    $0x4,%esp

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
    5d88:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    5d8c:	75 1b                	jne    5da9 <inflateHuffmanBlock+0x47>
    5d8e:	83 ec 08             	sub    $0x8,%esp
    5d91:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5d94:	50                   	push   %eax
    5d95:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5d98:	50                   	push   %eax
    5d99:	e8 63 fa ff ff       	call   5801 <getTreeInflateFixed>
    5d9e:	83 c4 10             	add    $0x10,%esp
    5da1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    5da4:	e9 9a 02 00 00       	jmp    6043 <inflateHuffmanBlock+0x2e1>
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);
    5da9:	83 ec 04             	sub    $0x4,%esp
    5dac:	ff 75 0c             	pushl  0xc(%ebp)
    5daf:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5db2:	50                   	push   %eax
    5db3:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5db6:	50                   	push   %eax
    5db7:	e8 77 fa ff ff       	call   5833 <getTreeInflateDynamic>
    5dbc:	83 c4 10             	add    $0x10,%esp
    5dbf:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    5dc2:	e9 7c 02 00 00       	jmp    6043 <inflateHuffmanBlock+0x2e1>
    /*code_ll is literal, length or end code*/
    unsigned code_ll;
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    5dc7:	83 ec 08             	sub    $0x8,%esp
    5dca:	6a 14                	push   $0x14
    5dcc:	ff 75 0c             	pushl  0xc(%ebp)
    5dcf:	e8 ef e1 ff ff       	call   3fc3 <ensureBits25>
    5dd4:	83 c4 10             	add    $0x10,%esp
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    5dd7:	83 ec 08             	sub    $0x8,%esp
    5dda:	8d 45 b8             	lea    -0x48(%ebp),%eax
    5ddd:	50                   	push   %eax
    5dde:	ff 75 0c             	pushl  0xc(%ebp)
    5de1:	e8 5a f9 ff ff       	call   5740 <huffmanDecodeSymbol>
    5de6:	83 c4 10             	add    $0x10,%esp
    5de9:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(code_ll <= 255) /*literal symbol*/ {
    5dec:	81 7d dc ff 00 00 00 	cmpl   $0xff,-0x24(%ebp)
    5df3:	77 42                	ja     5e37 <inflateHuffmanBlock+0xd5>
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
    5df5:	8b 45 08             	mov    0x8(%ebp),%eax
    5df8:	8b 40 04             	mov    0x4(%eax),%eax
    5dfb:	83 c0 01             	add    $0x1,%eax
    5dfe:	83 ec 08             	sub    $0x8,%esp
    5e01:	50                   	push   %eax
    5e02:	ff 75 08             	pushl  0x8(%ebp)
    5e05:	e8 37 da ff ff       	call   3841 <ucvector_resize>
    5e0a:	83 c4 10             	add    $0x10,%esp
    5e0d:	85 c0                	test   %eax,%eax
    5e0f:	75 0c                	jne    5e1d <inflateHuffmanBlock+0xbb>
    5e11:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5e18:	e9 33 02 00 00       	jmp    6050 <inflateHuffmanBlock+0x2ee>
      out->data[out->size - 1] = (unsigned char)code_ll;
    5e1d:	8b 45 08             	mov    0x8(%ebp),%eax
    5e20:	8b 10                	mov    (%eax),%edx
    5e22:	8b 45 08             	mov    0x8(%ebp),%eax
    5e25:	8b 40 04             	mov    0x4(%eax),%eax
    5e28:	83 e8 01             	sub    $0x1,%eax
    5e2b:	01 d0                	add    %edx,%eax
    5e2d:	8b 55 dc             	mov    -0x24(%ebp),%edx
    5e30:	88 10                	mov    %dl,(%eax)
    5e32:	e9 d9 01 00 00       	jmp    6010 <inflateHuffmanBlock+0x2ae>
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5e37:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    5e3e:	0f 86 ba 01 00 00    	jbe    5ffe <inflateHuffmanBlock+0x29c>
    5e44:	81 7d dc 1d 01 00 00 	cmpl   $0x11d,-0x24(%ebp)
    5e4b:	0f 87 ad 01 00 00    	ja     5ffe <inflateHuffmanBlock+0x29c>
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];
    5e51:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5e54:	2d 01 01 00 00       	sub    $0x101,%eax
    5e59:	8b 04 85 00 a0 01 00 	mov    0x1a000(,%eax,4),%eax
    5e60:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
    5e63:	8b 45 dc             	mov    -0x24(%ebp),%eax
    5e66:	2d 01 01 00 00       	sub    $0x101,%eax
    5e6b:	8b 04 85 80 a0 01 00 	mov    0x1a080(,%eax,4),%eax
    5e72:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(numextrabits_l != 0) {
    5e75:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    5e79:	74 1c                	je     5e97 <inflateHuffmanBlock+0x135>
        /* bits already ensured above */
        length += readBits(reader, numextrabits_l);
    5e7b:	8b 45 d8             	mov    -0x28(%ebp),%eax
    5e7e:	83 ec 08             	sub    $0x8,%esp
    5e81:	50                   	push   %eax
    5e82:	ff 75 0c             	pushl  0xc(%ebp)
    5e85:	e8 e9 e4 ff ff       	call   4373 <readBits>
    5e8a:	83 c4 10             	add    $0x10,%esp
    5e8d:	89 c2                	mov    %eax,%edx
    5e8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5e92:	01 d0                	add    %edx,%eax
    5e94:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      }

      /*part 3: get distance code*/
      ensureBits32(reader, 28); /* up to 15 for the huffman symbol, up to 13 for the extra bits */
    5e97:	83 ec 08             	sub    $0x8,%esp
    5e9a:	6a 1c                	push   $0x1c
    5e9c:	ff 75 0c             	pushl  0xc(%ebp)
    5e9f:	e8 98 e2 ff ff       	call   413c <ensureBits32>
    5ea4:	83 c4 10             	add    $0x10,%esp
      code_d = huffmanDecodeSymbol(reader, &tree_d);
    5ea7:	83 ec 08             	sub    $0x8,%esp
    5eaa:	8d 45 a0             	lea    -0x60(%ebp),%eax
    5ead:	50                   	push   %eax
    5eae:	ff 75 0c             	pushl  0xc(%ebp)
    5eb1:	e8 8a f8 ff ff       	call   5740 <huffmanDecodeSymbol>
    5eb6:	83 c4 10             	add    $0x10,%esp
    5eb9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if(code_d > 29) {
    5ebc:	83 7d d4 1d          	cmpl   $0x1d,-0x2c(%ebp)
    5ec0:	76 1e                	jbe    5ee0 <inflateHuffmanBlock+0x17e>
        if(code_d <= 31) {
    5ec2:	83 7d d4 1f          	cmpl   $0x1f,-0x2c(%ebp)
    5ec6:	77 0c                	ja     5ed4 <inflateHuffmanBlock+0x172>
          ERROR_BREAK(18); /*error: invalid distance code (30-31 are never used)*/
    5ec8:	c7 45 f4 12 00 00 00 	movl   $0x12,-0xc(%ebp)
    5ecf:	e9 7c 01 00 00       	jmp    6050 <inflateHuffmanBlock+0x2ee>
        } else /* if(code_d == INVALIDSYMBOL) */{
          ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    5ed4:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    5edb:	e9 70 01 00 00       	jmp    6050 <inflateHuffmanBlock+0x2ee>
        }
      }
      distance = DISTANCEBASE[code_d];
    5ee0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5ee3:	8b 04 85 00 a1 01 00 	mov    0x1a100(,%eax,4),%eax
    5eea:	89 45 f0             	mov    %eax,-0x10(%ebp)

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
    5eed:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    5ef0:	8b 04 85 80 a1 01 00 	mov    0x1a180(,%eax,4),%eax
    5ef7:	89 45 d0             	mov    %eax,-0x30(%ebp)
      if(numextrabits_d != 0) {
    5efa:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    5efe:	74 15                	je     5f15 <inflateHuffmanBlock+0x1b3>
        /* bits already ensured above */
        distance += readBits(reader, numextrabits_d);
    5f00:	8b 45 d0             	mov    -0x30(%ebp),%eax
    5f03:	83 ec 08             	sub    $0x8,%esp
    5f06:	50                   	push   %eax
    5f07:	ff 75 0c             	pushl  0xc(%ebp)
    5f0a:	e8 64 e4 ff ff       	call   4373 <readBits>
    5f0f:	83 c4 10             	add    $0x10,%esp
    5f12:	01 45 f0             	add    %eax,-0x10(%ebp)
      }

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = out->size;
    5f15:	8b 45 08             	mov    0x8(%ebp),%eax
    5f18:	8b 40 04             	mov    0x4(%eax),%eax
    5f1b:	89 45 ec             	mov    %eax,-0x14(%ebp)
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
    5f1e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f21:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5f24:	76 0c                	jbe    5f32 <inflateHuffmanBlock+0x1d0>
    5f26:	c7 45 f4 34 00 00 00 	movl   $0x34,-0xc(%ebp)
    5f2d:	e9 1e 01 00 00       	jmp    6050 <inflateHuffmanBlock+0x2ee>
      backward = start - distance;
    5f32:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5f35:	2b 45 f0             	sub    -0x10(%ebp),%eax
    5f38:	89 45 e8             	mov    %eax,-0x18(%ebp)

      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
    5f3b:	8b 45 08             	mov    0x8(%ebp),%eax
    5f3e:	8b 50 04             	mov    0x4(%eax),%edx
    5f41:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5f44:	01 d0                	add    %edx,%eax
    5f46:	83 ec 08             	sub    $0x8,%esp
    5f49:	50                   	push   %eax
    5f4a:	ff 75 08             	pushl  0x8(%ebp)
    5f4d:	e8 ef d8 ff ff       	call   3841 <ucvector_resize>
    5f52:	83 c4 10             	add    $0x10,%esp
    5f55:	85 c0                	test   %eax,%eax
    5f57:	75 0c                	jne    5f65 <inflateHuffmanBlock+0x203>
    5f59:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    5f60:	e9 eb 00 00 00       	jmp    6050 <inflateHuffmanBlock+0x2ee>
      if(distance < length) {
    5f65:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    5f68:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    5f6b:	73 6b                	jae    5fd8 <inflateHuffmanBlock+0x276>
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
    5f6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f70:	8b 55 08             	mov    0x8(%ebp),%edx
    5f73:	8b 0a                	mov    (%edx),%ecx
    5f75:	8b 55 e8             	mov    -0x18(%ebp),%edx
    5f78:	01 d1                	add    %edx,%ecx
    5f7a:	8b 55 08             	mov    0x8(%ebp),%edx
    5f7d:	8b 1a                	mov    (%edx),%ebx
    5f7f:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5f82:	01 da                	add    %ebx,%edx
    5f84:	83 ec 04             	sub    $0x4,%esp
    5f87:	50                   	push   %eax
    5f88:	51                   	push   %ecx
    5f89:	52                   	push   %edx
    5f8a:	e8 96 d6 ff ff       	call   3625 <lodepng_memcpy>
    5f8f:	83 c4 10             	add    $0x10,%esp
        start += distance;
    5f92:	8b 55 ec             	mov    -0x14(%ebp),%edx
    5f95:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5f98:	01 d0                	add    %edx,%eax
    5f9a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(forward = distance; forward < length; ++forward) {
    5f9d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    5fa0:	89 45 e0             	mov    %eax,-0x20(%ebp)
    5fa3:	eb 29                	jmp    5fce <inflateHuffmanBlock+0x26c>
          out->data[start++] = out->data[backward++];
    5fa5:	8b 45 08             	mov    0x8(%ebp),%eax
    5fa8:	8b 08                	mov    (%eax),%ecx
    5faa:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5fad:	8d 50 01             	lea    0x1(%eax),%edx
    5fb0:	89 55 ec             	mov    %edx,-0x14(%ebp)
    5fb3:	01 c1                	add    %eax,%ecx
    5fb5:	8b 45 08             	mov    0x8(%ebp),%eax
    5fb8:	8b 18                	mov    (%eax),%ebx
    5fba:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5fbd:	8d 50 01             	lea    0x1(%eax),%edx
    5fc0:	89 55 e8             	mov    %edx,-0x18(%ebp)
    5fc3:	01 d8                	add    %ebx,%eax
    5fc5:	0f b6 00             	movzbl (%eax),%eax
    5fc8:	88 01                	mov    %al,(%ecx)
      if(!ucvector_resize(out, out->size + length)) ERROR_BREAK(83 /*alloc fail*/);
      if(distance < length) {
        size_t forward;
        lodepng_memcpy(out->data + start, out->data + backward, distance);
        start += distance;
        for(forward = distance; forward < length; ++forward) {
    5fca:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
    5fce:	8b 45 e0             	mov    -0x20(%ebp),%eax
    5fd1:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    5fd4:	7c cf                	jl     5fa5 <inflateHuffmanBlock+0x243>
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5fd6:	eb 38                	jmp    6010 <inflateHuffmanBlock+0x2ae>
        start += distance;
        for(forward = distance; forward < length; ++forward) {
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
    5fd8:	8b 45 08             	mov    0x8(%ebp),%eax
    5fdb:	8b 10                	mov    (%eax),%edx
    5fdd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    5fe0:	01 c2                	add    %eax,%edx
    5fe2:	8b 45 08             	mov    0x8(%ebp),%eax
    5fe5:	8b 08                	mov    (%eax),%ecx
    5fe7:	8b 45 ec             	mov    -0x14(%ebp),%eax
    5fea:	01 c8                	add    %ecx,%eax
    5fec:	83 ec 04             	sub    $0x4,%esp
    5fef:	ff 75 e4             	pushl  -0x1c(%ebp)
    5ff2:	52                   	push   %edx
    5ff3:	50                   	push   %eax
    5ff4:	e8 2c d6 ff ff       	call   3625 <lodepng_memcpy>
    5ff9:	83 c4 10             	add    $0x10,%esp
    ensureBits25(reader, 20); /* up to 15 for the huffman symbol, up to 5 for the length extra bits */
    code_ll = huffmanDecodeSymbol(reader, &tree_ll);
    if(code_ll <= 255) /*literal symbol*/ {
      if(!ucvector_resize(out, out->size + 1)) ERROR_BREAK(83 /*alloc fail*/);
      out->data[out->size - 1] = (unsigned char)code_ll;
    } else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/ {
    5ffc:	eb 12                	jmp    6010 <inflateHuffmanBlock+0x2ae>
          out->data[start++] = out->data[backward++];
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
    5ffe:	81 7d dc 00 01 00 00 	cmpl   $0x100,-0x24(%ebp)
    6005:	74 48                	je     604f <inflateHuffmanBlock+0x2ed>
      break; /*end code, break the loop*/
    } else /*if(code_ll == INVALIDSYMBOL)*/ {
      ERROR_BREAK(16); /*error: tried to read disallowed huffman symbol*/
    6007:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
    600e:	eb 40                	jmp    6050 <inflateHuffmanBlock+0x2ee>
    }
    /*check if any of the ensureBits above went out of bounds*/
    if(reader->bp > reader->bitsize) {
    6010:	8b 45 0c             	mov    0xc(%ebp),%eax
    6013:	8b 50 0c             	mov    0xc(%eax),%edx
    6016:	8b 45 0c             	mov    0xc(%ebp),%eax
    6019:	8b 40 08             	mov    0x8(%eax),%eax
    601c:	39 c2                	cmp    %eax,%edx
    601e:	7e 09                	jle    6029 <inflateHuffmanBlock+0x2c7>
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      /* TODO: revise error codes 10,11,50: the above comment is no longer valid */
      ERROR_BREAK(51); /*error, bit pointer jumps past memory*/
    6020:	c7 45 f4 33 00 00 00 	movl   $0x33,-0xc(%ebp)
    6027:	eb 27                	jmp    6050 <inflateHuffmanBlock+0x2ee>
    }
    if(max_output_size && out->size > max_output_size) {
    6029:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    602d:	74 14                	je     6043 <inflateHuffmanBlock+0x2e1>
    602f:	8b 45 08             	mov    0x8(%ebp),%eax
    6032:	8b 40 04             	mov    0x4(%eax),%eax
    6035:	3b 45 14             	cmp    0x14(%ebp),%eax
    6038:	7e 09                	jle    6043 <inflateHuffmanBlock+0x2e1>
      ERROR_BREAK(109); /*error, larger than max size*/
    603a:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    6041:	eb 0d                	jmp    6050 <inflateHuffmanBlock+0x2ee>
  HuffmanTree_init(&tree_d);

  if(btype == 1) error = getTreeInflateFixed(&tree_ll, &tree_d);
  else /*if(btype == 2)*/ error = getTreeInflateDynamic(&tree_ll, &tree_d, reader);

  while(!error) /*decode all symbols until end reached, breaks at end code*/ {
    6043:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    6047:	0f 84 7a fd ff ff    	je     5dc7 <inflateHuffmanBlock+0x65>
    604d:	eb 01                	jmp    6050 <inflateHuffmanBlock+0x2ee>
        }
      } else {
        lodepng_memcpy(out->data + start, out->data + backward, length);
      }
    } else if(code_ll == 256) {
      break; /*end code, break the loop*/
    604f:	90                   	nop
    if(max_output_size && out->size > max_output_size) {
      ERROR_BREAK(109); /*error, larger than max size*/
    }
  }

  HuffmanTree_cleanup(&tree_ll);
    6050:	83 ec 0c             	sub    $0xc,%esp
    6053:	8d 45 b8             	lea    -0x48(%ebp),%eax
    6056:	50                   	push   %eax
    6057:	e8 ac e4 ff ff       	call   4508 <HuffmanTree_cleanup>
    605c:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    605f:	83 ec 0c             	sub    $0xc,%esp
    6062:	8d 45 a0             	lea    -0x60(%ebp),%eax
    6065:	50                   	push   %eax
    6066:	e8 9d e4 ff ff       	call   4508 <HuffmanTree_cleanup>
    606b:	83 c4 10             	add    $0x10,%esp

  return error;
    606e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6071:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6074:	c9                   	leave  
    6075:	c3                   	ret    

00006076 <inflateNoCompression>:

static unsigned inflateNoCompression(ucvector* out, LodePNGBitReader* reader,
                                     const LodePNGDecompressSettings* settings) {
    6076:	55                   	push   %ebp
    6077:	89 e5                	mov    %esp,%ebp
    6079:	53                   	push   %ebx
    607a:	83 ec 20             	sub    $0x20,%esp
  size_t bytepos;
  size_t size = reader->size;
    607d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6080:	8b 40 04             	mov    0x4(%eax),%eax
    6083:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned LEN, NLEN, error = 0;
    6086:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*go to first boundary of byte*/
  bytepos = (reader->bp + 7u) >> 3u;
    608d:	8b 45 0c             	mov    0xc(%ebp),%eax
    6090:	8b 40 0c             	mov    0xc(%eax),%eax
    6093:	83 c0 07             	add    $0x7,%eax
    6096:	c1 e8 03             	shr    $0x3,%eax
    6099:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(bytepos + 4 >= size) return 52; /*error, bit pointer will jump past memory*/
    609c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    609f:	83 c0 04             	add    $0x4,%eax
    60a2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    60a5:	7c 0a                	jl     60b1 <inflateNoCompression+0x3b>
    60a7:	b8 34 00 00 00       	mov    $0x34,%eax
    60ac:	e9 01 01 00 00       	jmp    61b2 <inflateNoCompression+0x13c>
  LEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    60b1:	8b 45 0c             	mov    0xc(%ebp),%eax
    60b4:	8b 10                	mov    (%eax),%edx
    60b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    60b9:	01 d0                	add    %edx,%eax
    60bb:	0f b6 00             	movzbl (%eax),%eax
    60be:	0f b6 d0             	movzbl %al,%edx
    60c1:	8b 45 0c             	mov    0xc(%ebp),%eax
    60c4:	8b 00                	mov    (%eax),%eax
    60c6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    60c9:	83 c1 01             	add    $0x1,%ecx
    60cc:	01 c8                	add    %ecx,%eax
    60ce:	0f b6 00             	movzbl (%eax),%eax
    60d1:	0f b6 c0             	movzbl %al,%eax
    60d4:	c1 e0 08             	shl    $0x8,%eax
    60d7:	01 d0                	add    %edx,%eax
    60d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    60dc:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
  NLEN = (unsigned)reader->data[bytepos] + ((unsigned)reader->data[bytepos + 1] << 8u); bytepos += 2;
    60e0:	8b 45 0c             	mov    0xc(%ebp),%eax
    60e3:	8b 10                	mov    (%eax),%edx
    60e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    60e8:	01 d0                	add    %edx,%eax
    60ea:	0f b6 00             	movzbl (%eax),%eax
    60ed:	0f b6 d0             	movzbl %al,%edx
    60f0:	8b 45 0c             	mov    0xc(%ebp),%eax
    60f3:	8b 00                	mov    (%eax),%eax
    60f5:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    60f8:	83 c1 01             	add    $0x1,%ecx
    60fb:	01 c8                	add    %ecx,%eax
    60fd:	0f b6 00             	movzbl (%eax),%eax
    6100:	0f b6 c0             	movzbl %al,%eax
    6103:	c1 e0 08             	shl    $0x8,%eax
    6106:	01 d0                	add    %edx,%eax
    6108:	89 45 e8             	mov    %eax,-0x18(%ebp)
    610b:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(!settings->ignore_nlen && LEN + NLEN != 65535) {
    610f:	8b 45 10             	mov    0x10(%ebp),%eax
    6112:	8b 40 04             	mov    0x4(%eax),%eax
    6115:	85 c0                	test   %eax,%eax
    6117:	75 19                	jne    6132 <inflateNoCompression+0xbc>
    6119:	8b 55 ec             	mov    -0x14(%ebp),%edx
    611c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    611f:	01 d0                	add    %edx,%eax
    6121:	3d ff ff 00 00       	cmp    $0xffff,%eax
    6126:	74 0a                	je     6132 <inflateNoCompression+0xbc>
    return 21; /*error: NLEN is not one's complement of LEN*/
    6128:	b8 15 00 00 00       	mov    $0x15,%eax
    612d:	e9 80 00 00 00       	jmp    61b2 <inflateNoCompression+0x13c>
  }

  if(!ucvector_resize(out, out->size + LEN)) return 83; /*alloc fail*/
    6132:	8b 45 08             	mov    0x8(%ebp),%eax
    6135:	8b 40 04             	mov    0x4(%eax),%eax
    6138:	89 c2                	mov    %eax,%edx
    613a:	8b 45 ec             	mov    -0x14(%ebp),%eax
    613d:	01 d0                	add    %edx,%eax
    613f:	50                   	push   %eax
    6140:	ff 75 08             	pushl  0x8(%ebp)
    6143:	e8 f9 d6 ff ff       	call   3841 <ucvector_resize>
    6148:	83 c4 08             	add    $0x8,%esp
    614b:	85 c0                	test   %eax,%eax
    614d:	75 07                	jne    6156 <inflateNoCompression+0xe0>
    614f:	b8 53 00 00 00       	mov    $0x53,%eax
    6154:	eb 5c                	jmp    61b2 <inflateNoCompression+0x13c>

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(bytepos + LEN > size) return 23; /*error: reading outside of in buffer*/
    6156:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6159:	8b 45 ec             	mov    -0x14(%ebp),%eax
    615c:	01 c2                	add    %eax,%edx
    615e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6161:	39 c2                	cmp    %eax,%edx
    6163:	76 07                	jbe    616c <inflateNoCompression+0xf6>
    6165:	b8 17 00 00 00       	mov    $0x17,%eax
    616a:	eb 46                	jmp    61b2 <inflateNoCompression+0x13c>

  lodepng_memcpy(out->data + out->size - LEN, reader->data + bytepos, LEN);
    616c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    616f:	8b 55 0c             	mov    0xc(%ebp),%edx
    6172:	8b 0a                	mov    (%edx),%ecx
    6174:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6177:	01 d1                	add    %edx,%ecx
    6179:	8b 55 08             	mov    0x8(%ebp),%edx
    617c:	8b 1a                	mov    (%edx),%ebx
    617e:	8b 55 08             	mov    0x8(%ebp),%edx
    6181:	8b 52 04             	mov    0x4(%edx),%edx
    6184:	2b 55 ec             	sub    -0x14(%ebp),%edx
    6187:	01 da                	add    %ebx,%edx
    6189:	50                   	push   %eax
    618a:	51                   	push   %ecx
    618b:	52                   	push   %edx
    618c:	e8 94 d4 ff ff       	call   3625 <lodepng_memcpy>
    6191:	83 c4 0c             	add    $0xc,%esp
  bytepos += LEN;
    6194:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6197:	8b 45 ec             	mov    -0x14(%ebp),%eax
    619a:	01 d0                	add    %edx,%eax
    619c:	89 45 f0             	mov    %eax,-0x10(%ebp)

  reader->bp = bytepos << 3u;
    619f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    61a2:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
    61a9:	8b 45 0c             	mov    0xc(%ebp),%eax
    61ac:	89 50 0c             	mov    %edx,0xc(%eax)

  return error;
    61af:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    61b2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    61b5:	c9                   	leave  
    61b6:	c3                   	ret    

000061b7 <lodepng_inflatev>:

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings) {
    61b7:	55                   	push   %ebp
    61b8:	89 e5                	mov    %esp,%ebp
    61ba:	83 ec 28             	sub    $0x28,%esp
  unsigned BFINAL = 0;
    61bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);
    61c4:	ff 75 10             	pushl  0x10(%ebp)
    61c7:	ff 75 0c             	pushl  0xc(%ebp)
    61ca:	8d 45 d8             	lea    -0x28(%ebp),%eax
    61cd:	50                   	push   %eax
    61ce:	e8 77 db ff ff       	call   3d4a <LodePNGBitReader_init>
    61d3:	83 c4 0c             	add    $0xc,%esp
    61d6:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(error) return error;
    61d9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    61dd:	0f 84 b9 00 00 00    	je     629c <lodepng_inflatev+0xe5>
    61e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
    61e6:	e9 c1 00 00 00       	jmp    62ac <lodepng_inflatev+0xf5>

  while(!BFINAL) {
    unsigned BTYPE;
    if(!ensureBits9(&reader, 3)) return 52; /*error, bit pointer will jump past memory*/
    61eb:	6a 03                	push   $0x3
    61ed:	8d 45 d8             	lea    -0x28(%ebp),%eax
    61f0:	50                   	push   %eax
    61f1:	e8 c5 db ff ff       	call   3dbb <ensureBits9>
    61f6:	83 c4 08             	add    $0x8,%esp
    61f9:	85 c0                	test   %eax,%eax
    61fb:	75 0a                	jne    6207 <lodepng_inflatev+0x50>
    61fd:	b8 34 00 00 00       	mov    $0x34,%eax
    6202:	e9 a5 00 00 00       	jmp    62ac <lodepng_inflatev+0xf5>
    BFINAL = readBits(&reader, 1);
    6207:	6a 01                	push   $0x1
    6209:	8d 45 d8             	lea    -0x28(%ebp),%eax
    620c:	50                   	push   %eax
    620d:	e8 61 e1 ff ff       	call   4373 <readBits>
    6212:	83 c4 08             	add    $0x8,%esp
    6215:	89 45 f4             	mov    %eax,-0xc(%ebp)
    BTYPE = readBits(&reader, 2);
    6218:	6a 02                	push   $0x2
    621a:	8d 45 d8             	lea    -0x28(%ebp),%eax
    621d:	50                   	push   %eax
    621e:	e8 50 e1 ff ff       	call   4373 <readBits>
    6223:	83 c4 08             	add    $0x8,%esp
    6226:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    6229:	83 7d ec 03          	cmpl   $0x3,-0x14(%ebp)
    622d:	75 07                	jne    6236 <lodepng_inflatev+0x7f>
    622f:	b8 14 00 00 00       	mov    $0x14,%eax
    6234:	eb 76                	jmp    62ac <lodepng_inflatev+0xf5>
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    6236:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    623a:	75 17                	jne    6253 <lodepng_inflatev+0x9c>
    623c:	ff 75 14             	pushl  0x14(%ebp)
    623f:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6242:	50                   	push   %eax
    6243:	ff 75 08             	pushl  0x8(%ebp)
    6246:	e8 2b fe ff ff       	call   6076 <inflateNoCompression>
    624b:	83 c4 0c             	add    $0xc,%esp
    624e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6251:	eb 1c                	jmp    626f <lodepng_inflatev+0xb8>
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    6253:	8b 45 14             	mov    0x14(%ebp),%eax
    6256:	8b 40 08             	mov    0x8(%eax),%eax
    6259:	50                   	push   %eax
    625a:	ff 75 ec             	pushl  -0x14(%ebp)
    625d:	8d 45 d8             	lea    -0x28(%ebp),%eax
    6260:	50                   	push   %eax
    6261:	ff 75 08             	pushl  0x8(%ebp)
    6264:	e8 f9 fa ff ff       	call   5d62 <inflateHuffmanBlock>
    6269:	83 c4 10             	add    $0x10,%esp
    626c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    626f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6273:	75 21                	jne    6296 <lodepng_inflatev+0xdf>
    6275:	8b 45 14             	mov    0x14(%ebp),%eax
    6278:	8b 40 08             	mov    0x8(%eax),%eax
    627b:	85 c0                	test   %eax,%eax
    627d:	74 17                	je     6296 <lodepng_inflatev+0xdf>
    627f:	8b 45 08             	mov    0x8(%ebp),%eax
    6282:	8b 50 04             	mov    0x4(%eax),%edx
    6285:	8b 45 14             	mov    0x14(%ebp),%eax
    6288:	8b 40 08             	mov    0x8(%eax),%eax
    628b:	39 c2                	cmp    %eax,%edx
    628d:	7e 07                	jle    6296 <lodepng_inflatev+0xdf>
    628f:	c7 45 f0 6d 00 00 00 	movl   $0x6d,-0x10(%ebp)
    if(error) break;
    6296:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    629a:	75 0c                	jne    62a8 <lodepng_inflatev+0xf1>
  LodePNGBitReader reader;
  unsigned error = LodePNGBitReader_init(&reader, in, insize);

  if(error) return error;

  while(!BFINAL) {
    629c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    62a0:	0f 84 45 ff ff ff    	je     61eb <lodepng_inflatev+0x34>
    62a6:	eb 01                	jmp    62a9 <lodepng_inflatev+0xf2>

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, &reader, settings); /*no compression*/
    else error = inflateHuffmanBlock(out, &reader, BTYPE, settings->max_output_size); /*compression, BTYPE 01 or 10*/
    if(!error && settings->max_output_size && out->size > settings->max_output_size) error = 109;
    if(error) break;
    62a8:	90                   	nop
  }

  return error;
    62a9:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    62ac:	c9                   	leave  
    62ad:	c3                   	ret    

000062ae <lodepng_inflate>:

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings) {
    62ae:	55                   	push   %ebp
    62af:	89 e5                	mov    %esp,%ebp
    62b1:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    62b4:	8b 45 0c             	mov    0xc(%ebp),%eax
    62b7:	8b 08                	mov    (%eax),%ecx
    62b9:	8b 45 08             	mov    0x8(%ebp),%eax
    62bc:	8b 10                	mov    (%eax),%edx
    62be:	8d 45 e8             	lea    -0x18(%ebp),%eax
    62c1:	51                   	push   %ecx
    62c2:	52                   	push   %edx
    62c3:	50                   	push   %eax
    62c4:	e8 df d5 ff ff       	call   38a8 <ucvector_init>
    62c9:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_inflatev(&v, in, insize, settings);
    62cc:	ff 75 18             	pushl  0x18(%ebp)
    62cf:	ff 75 14             	pushl  0x14(%ebp)
    62d2:	ff 75 10             	pushl  0x10(%ebp)
    62d5:	8d 45 e8             	lea    -0x18(%ebp),%eax
    62d8:	50                   	push   %eax
    62d9:	e8 d9 fe ff ff       	call   61b7 <lodepng_inflatev>
    62de:	83 c4 10             	add    $0x10,%esp
    62e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    62e4:	8b 55 e8             	mov    -0x18(%ebp),%edx
    62e7:	8b 45 08             	mov    0x8(%ebp),%eax
    62ea:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    62ec:	8b 55 ec             	mov    -0x14(%ebp),%edx
    62ef:	8b 45 0c             	mov    0xc(%ebp),%eax
    62f2:	89 10                	mov    %edx,(%eax)
  return error;
    62f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    62f7:	c9                   	leave  
    62f8:	c3                   	ret    

000062f9 <inflatev>:

static unsigned inflatev(ucvector* out, const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings) {
    62f9:	55                   	push   %ebp
    62fa:	89 e5                	mov    %esp,%ebp
    62fc:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_inflate) {
    62ff:	8b 45 14             	mov    0x14(%ebp),%eax
    6302:	8b 40 10             	mov    0x10(%eax),%eax
    6305:	85 c0                	test   %eax,%eax
    6307:	74 64                	je     636d <inflatev+0x74>
    unsigned error = settings->custom_inflate(&out->data, &out->size, in, insize, settings);
    6309:	8b 45 14             	mov    0x14(%ebp),%eax
    630c:	8b 40 10             	mov    0x10(%eax),%eax
    630f:	8b 55 08             	mov    0x8(%ebp),%edx
    6312:	8d 4a 04             	lea    0x4(%edx),%ecx
    6315:	8b 55 08             	mov    0x8(%ebp),%edx
    6318:	83 ec 0c             	sub    $0xc,%esp
    631b:	ff 75 14             	pushl  0x14(%ebp)
    631e:	ff 75 10             	pushl  0x10(%ebp)
    6321:	ff 75 0c             	pushl  0xc(%ebp)
    6324:	51                   	push   %ecx
    6325:	52                   	push   %edx
    6326:	ff d0                	call   *%eax
    6328:	83 c4 20             	add    $0x20,%esp
    632b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    out->allocsize = out->size;
    632e:	8b 45 08             	mov    0x8(%ebp),%eax
    6331:	8b 50 04             	mov    0x4(%eax),%edx
    6334:	8b 45 08             	mov    0x8(%ebp),%eax
    6337:	89 50 08             	mov    %edx,0x8(%eax)
    if(error) {
    633a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    633e:	74 28                	je     6368 <inflatev+0x6f>
      /*the custom inflate is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    6340:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && out->size > settings->max_output_size) error = 109;
    6347:	8b 45 14             	mov    0x14(%ebp),%eax
    634a:	8b 40 08             	mov    0x8(%eax),%eax
    634d:	85 c0                	test   %eax,%eax
    634f:	74 17                	je     6368 <inflatev+0x6f>
    6351:	8b 45 08             	mov    0x8(%ebp),%eax
    6354:	8b 50 04             	mov    0x4(%eax),%edx
    6357:	8b 45 14             	mov    0x14(%ebp),%eax
    635a:	8b 40 08             	mov    0x8(%eax),%eax
    635d:	39 c2                	cmp    %eax,%edx
    635f:	7e 07                	jle    6368 <inflatev+0x6f>
    6361:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    }
    return error;
    6368:	8b 45 f4             	mov    -0xc(%ebp),%eax
    636b:	eb 14                	jmp    6381 <inflatev+0x88>
  } else {
    return lodepng_inflatev(out, in, insize, settings);
    636d:	ff 75 14             	pushl  0x14(%ebp)
    6370:	ff 75 10             	pushl  0x10(%ebp)
    6373:	ff 75 0c             	pushl  0xc(%ebp)
    6376:	ff 75 08             	pushl  0x8(%ebp)
    6379:	e8 39 fe ff ff       	call   61b7 <lodepng_inflatev>
    637e:	83 c4 10             	add    $0x10,%esp
  }
}
    6381:	c9                   	leave  
    6382:	c3                   	ret    

00006383 <searchCodeIndex>:

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
    6383:	55                   	push   %ebp
    6384:	89 e5                	mov    %esp,%ebp
    6386:	83 ec 10             	sub    $0x10,%esp
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
    6389:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  size_t right = array_size - 1;
    6390:	8b 45 0c             	mov    0xc(%ebp),%eax
    6393:	83 e8 01             	sub    $0x1,%eax
    6396:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(left <= right) {
    6399:	eb 39                	jmp    63d4 <searchCodeIndex+0x51>
    size_t mid = (left + right) >> 1;
    639b:	8b 55 fc             	mov    -0x4(%ebp),%edx
    639e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    63a1:	01 d0                	add    %edx,%eax
    63a3:	d1 f8                	sar    %eax
    63a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(array[mid] >= value) right = mid - 1;
    63a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    63ab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    63b2:	8b 45 08             	mov    0x8(%ebp),%eax
    63b5:	01 d0                	add    %edx,%eax
    63b7:	8b 10                	mov    (%eax),%edx
    63b9:	8b 45 10             	mov    0x10(%ebp),%eax
    63bc:	39 c2                	cmp    %eax,%edx
    63be:	72 0b                	jb     63cb <searchCodeIndex+0x48>
    63c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    63c3:	83 e8 01             	sub    $0x1,%eax
    63c6:	89 45 f8             	mov    %eax,-0x8(%ebp)
    63c9:	eb 09                	jmp    63d4 <searchCodeIndex+0x51>
    else left = mid + 1;
    63cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    63ce:	83 c0 01             	add    $0x1,%eax
    63d1:	89 45 fc             	mov    %eax,-0x4(%ebp)
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value) {
  /*binary search (only small gain over linear). TODO: use CPU log2 instruction for getting symbols instead*/
  size_t left = 1;
  size_t right = array_size - 1;

  while(left <= right) {
    63d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    63d7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    63da:	7e bf                	jle    639b <searchCodeIndex+0x18>
    size_t mid = (left + right) >> 1;
    if(array[mid] >= value) right = mid - 1;
    else left = mid + 1;
  }
  if(left >= array_size || array[left] > value) left--;
    63dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
    63df:	3b 45 0c             	cmp    0xc(%ebp),%eax
    63e2:	7d 18                	jge    63fc <searchCodeIndex+0x79>
    63e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    63e7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    63ee:	8b 45 08             	mov    0x8(%ebp),%eax
    63f1:	01 d0                	add    %edx,%eax
    63f3:	8b 10                	mov    (%eax),%edx
    63f5:	8b 45 10             	mov    0x10(%ebp),%eax
    63f8:	39 c2                	cmp    %eax,%edx
    63fa:	76 04                	jbe    6400 <searchCodeIndex+0x7d>
    63fc:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
  return left;
    6400:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    6403:	c9                   	leave  
    6404:	c3                   	ret    

00006405 <addLengthDistance>:

static void addLengthDistance(uivector* values, size_t length, size_t distance) {
    6405:	55                   	push   %ebp
    6406:	89 e5                	mov    %esp,%ebp
    6408:	83 ec 20             	sub    $0x20,%esp
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
    640b:	ff 75 0c             	pushl  0xc(%ebp)
    640e:	6a 1d                	push   $0x1d
    6410:	68 00 a0 01 00       	push   $0x1a000
    6415:	e8 69 ff ff ff       	call   6383 <searchCodeIndex>
    641a:	83 c4 0c             	add    $0xc,%esp
    641d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
    6420:	8b 55 0c             	mov    0xc(%ebp),%edx
    6423:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6426:	8b 04 85 00 a0 01 00 	mov    0x1a000(,%eax,4),%eax
    642d:	29 c2                	sub    %eax,%edx
    642f:	89 d0                	mov    %edx,%eax
    6431:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
    6434:	ff 75 10             	pushl  0x10(%ebp)
    6437:	6a 1e                	push   $0x1e
    6439:	68 00 a1 01 00       	push   $0x1a100
    643e:	e8 40 ff ff ff       	call   6383 <searchCodeIndex>
    6443:	83 c4 0c             	add    $0xc,%esp
    6446:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);
    6449:	8b 55 10             	mov    0x10(%ebp),%edx
    644c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    644f:	8b 04 85 00 a1 01 00 	mov    0x1a100(,%eax,4),%eax
    6456:	29 c2                	sub    %eax,%edx
    6458:	89 d0                	mov    %edx,%eax
    645a:	89 45 f0             	mov    %eax,-0x10(%ebp)

  size_t pos = values->size;
    645d:	8b 45 08             	mov    0x8(%ebp),%eax
    6460:	8b 40 04             	mov    0x4(%eax),%eax
    6463:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: return error when this fails (out of memory)*/
  unsigned ok = uivector_resize(values, values->size + 4);
    6466:	8b 45 08             	mov    0x8(%ebp),%eax
    6469:	8b 40 04             	mov    0x4(%eax),%eax
    646c:	83 c0 04             	add    $0x4,%eax
    646f:	50                   	push   %eax
    6470:	ff 75 08             	pushl  0x8(%ebp)
    6473:	e8 f0 d2 ff ff       	call   3768 <uivector_resize>
    6478:	83 c4 08             	add    $0x8,%esp
    647b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(ok) {
    647e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    6482:	74 57                	je     64db <addLengthDistance+0xd6>
    values->data[pos + 0] = length_code + FIRST_LENGTH_CODE_INDEX;
    6484:	8b 45 08             	mov    0x8(%ebp),%eax
    6487:	8b 00                	mov    (%eax),%eax
    6489:	8b 55 ec             	mov    -0x14(%ebp),%edx
    648c:	c1 e2 02             	shl    $0x2,%edx
    648f:	01 d0                	add    %edx,%eax
    6491:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6494:	81 c2 01 01 00 00    	add    $0x101,%edx
    649a:	89 10                	mov    %edx,(%eax)
    values->data[pos + 1] = extra_length;
    649c:	8b 45 08             	mov    0x8(%ebp),%eax
    649f:	8b 00                	mov    (%eax),%eax
    64a1:	8b 55 ec             	mov    -0x14(%ebp),%edx
    64a4:	83 c2 01             	add    $0x1,%edx
    64a7:	c1 e2 02             	shl    $0x2,%edx
    64aa:	01 c2                	add    %eax,%edx
    64ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
    64af:	89 02                	mov    %eax,(%edx)
    values->data[pos + 2] = dist_code;
    64b1:	8b 45 08             	mov    0x8(%ebp),%eax
    64b4:	8b 00                	mov    (%eax),%eax
    64b6:	8b 55 ec             	mov    -0x14(%ebp),%edx
    64b9:	83 c2 02             	add    $0x2,%edx
    64bc:	c1 e2 02             	shl    $0x2,%edx
    64bf:	01 c2                	add    %eax,%edx
    64c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    64c4:	89 02                	mov    %eax,(%edx)
    values->data[pos + 3] = extra_distance;
    64c6:	8b 45 08             	mov    0x8(%ebp),%eax
    64c9:	8b 00                	mov    (%eax),%eax
    64cb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    64ce:	83 c2 03             	add    $0x3,%edx
    64d1:	c1 e2 02             	shl    $0x2,%edx
    64d4:	01 c2                	add    %eax,%edx
    64d6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    64d9:	89 02                	mov    %eax,(%edx)
  }
}
    64db:	90                   	nop
    64dc:	c9                   	leave  
    64dd:	c3                   	ret    

000064de <hash_init>:
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize) {
    64de:	55                   	push   %ebp
    64df:	89 e5                	mov    %esp,%ebp
    64e1:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
    64e4:	b8 00 00 01 00       	mov    $0x10000,%eax
    64e9:	c1 e0 02             	shl    $0x2,%eax
    64ec:	83 ec 0c             	sub    $0xc,%esp
    64ef:	50                   	push   %eax
    64f0:	e8 f2 d0 ff ff       	call   35e7 <lodepng_malloc>
    64f5:	83 c4 10             	add    $0x10,%esp
    64f8:	89 c2                	mov    %eax,%edx
    64fa:	8b 45 08             	mov    0x8(%ebp),%eax
    64fd:	89 10                	mov    %edx,(%eax)
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
    64ff:	8b 45 0c             	mov    0xc(%ebp),%eax
    6502:	c1 e0 02             	shl    $0x2,%eax
    6505:	83 ec 0c             	sub    $0xc,%esp
    6508:	50                   	push   %eax
    6509:	e8 d9 d0 ff ff       	call   35e7 <lodepng_malloc>
    650e:	83 c4 10             	add    $0x10,%esp
    6511:	89 c2                	mov    %eax,%edx
    6513:	8b 45 08             	mov    0x8(%ebp),%eax
    6516:	89 50 08             	mov    %edx,0x8(%eax)
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6519:	8b 45 0c             	mov    0xc(%ebp),%eax
    651c:	01 c0                	add    %eax,%eax
    651e:	83 ec 0c             	sub    $0xc,%esp
    6521:	50                   	push   %eax
    6522:	e8 c0 d0 ff ff       	call   35e7 <lodepng_malloc>
    6527:	83 c4 10             	add    $0x10,%esp
    652a:	89 c2                	mov    %eax,%edx
    652c:	8b 45 08             	mov    0x8(%ebp),%eax
    652f:	89 50 04             	mov    %edx,0x4(%eax)

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    6532:	8b 45 0c             	mov    0xc(%ebp),%eax
    6535:	01 c0                	add    %eax,%eax
    6537:	83 ec 0c             	sub    $0xc,%esp
    653a:	50                   	push   %eax
    653b:	e8 a7 d0 ff ff       	call   35e7 <lodepng_malloc>
    6540:	83 c4 10             	add    $0x10,%esp
    6543:	89 c2                	mov    %eax,%edx
    6545:	8b 45 08             	mov    0x8(%ebp),%eax
    6548:	89 50 14             	mov    %edx,0x14(%eax)
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
    654b:	b8 02 01 00 00       	mov    $0x102,%eax
    6550:	83 c0 01             	add    $0x1,%eax
    6553:	c1 e0 02             	shl    $0x2,%eax
    6556:	83 ec 0c             	sub    $0xc,%esp
    6559:	50                   	push   %eax
    655a:	e8 88 d0 ff ff       	call   35e7 <lodepng_malloc>
    655f:	83 c4 10             	add    $0x10,%esp
    6562:	89 c2                	mov    %eax,%edx
    6564:	8b 45 08             	mov    0x8(%ebp),%eax
    6567:	89 50 0c             	mov    %edx,0xc(%eax)
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
    656a:	8b 45 0c             	mov    0xc(%ebp),%eax
    656d:	01 c0                	add    %eax,%eax
    656f:	83 ec 0c             	sub    $0xc,%esp
    6572:	50                   	push   %eax
    6573:	e8 6f d0 ff ff       	call   35e7 <lodepng_malloc>
    6578:	83 c4 10             	add    $0x10,%esp
    657b:	89 c2                	mov    %eax,%edx
    657d:	8b 45 08             	mov    0x8(%ebp),%eax
    6580:	89 50 10             	mov    %edx,0x10(%eax)

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros) {
    6583:	8b 45 08             	mov    0x8(%ebp),%eax
    6586:	8b 00                	mov    (%eax),%eax
    6588:	85 c0                	test   %eax,%eax
    658a:	74 32                	je     65be <hash_init+0xe0>
    658c:	8b 45 08             	mov    0x8(%ebp),%eax
    658f:	8b 40 04             	mov    0x4(%eax),%eax
    6592:	85 c0                	test   %eax,%eax
    6594:	74 28                	je     65be <hash_init+0xe0>
    6596:	8b 45 08             	mov    0x8(%ebp),%eax
    6599:	8b 40 08             	mov    0x8(%eax),%eax
    659c:	85 c0                	test   %eax,%eax
    659e:	74 1e                	je     65be <hash_init+0xe0>
    65a0:	8b 45 08             	mov    0x8(%ebp),%eax
    65a3:	8b 40 0c             	mov    0xc(%eax),%eax
    65a6:	85 c0                	test   %eax,%eax
    65a8:	74 14                	je     65be <hash_init+0xe0>
    65aa:	8b 45 08             	mov    0x8(%ebp),%eax
    65ad:	8b 40 10             	mov    0x10(%eax),%eax
    65b0:	85 c0                	test   %eax,%eax
    65b2:	74 0a                	je     65be <hash_init+0xe0>
    65b4:	8b 45 08             	mov    0x8(%ebp),%eax
    65b7:	8b 40 14             	mov    0x14(%eax),%eax
    65ba:	85 c0                	test   %eax,%eax
    65bc:	75 0a                	jne    65c8 <hash_init+0xea>
    return 83; /*alloc fail*/
    65be:	b8 53 00 00 00       	mov    $0x53,%eax
    65c3:	e9 d3 00 00 00       	jmp    669b <hash_init+0x1bd>
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
    65c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    65cf:	eb 17                	jmp    65e8 <hash_init+0x10a>
    65d1:	8b 45 08             	mov    0x8(%ebp),%eax
    65d4:	8b 00                	mov    (%eax),%eax
    65d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
    65d9:	c1 e2 02             	shl    $0x2,%edx
    65dc:	01 d0                	add    %edx,%eax
    65de:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    65e4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    65e8:	b8 00 00 01 00       	mov    $0x10000,%eax
    65ed:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    65f0:	75 df                	jne    65d1 <hash_init+0xf3>
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
    65f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    65f9:	eb 18                	jmp    6613 <hash_init+0x135>
    65fb:	8b 45 08             	mov    0x8(%ebp),%eax
    65fe:	8b 40 08             	mov    0x8(%eax),%eax
    6601:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6604:	c1 e2 02             	shl    $0x2,%edx
    6607:	01 d0                	add    %edx,%eax
    6609:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    660f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6613:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6616:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6619:	75 e0                	jne    65fb <hash_init+0x11d>
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/
    661b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6622:	eb 17                	jmp    663b <hash_init+0x15d>
    6624:	8b 45 08             	mov    0x8(%ebp),%eax
    6627:	8b 40 04             	mov    0x4(%eax),%eax
    662a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    662d:	01 d2                	add    %edx,%edx
    662f:	01 d0                	add    %edx,%eax
    6631:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6634:	66 89 10             	mov    %dx,(%eax)
    6637:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    663b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    663e:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6641:	75 e1                	jne    6624 <hash_init+0x146>

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
    6643:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    664a:	eb 18                	jmp    6664 <hash_init+0x186>
    664c:	8b 45 08             	mov    0x8(%ebp),%eax
    664f:	8b 40 0c             	mov    0xc(%eax),%eax
    6652:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6655:	c1 e2 02             	shl    $0x2,%edx
    6658:	01 d0                	add    %edx,%eax
    665a:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    6660:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    6664:	b8 02 01 00 00       	mov    $0x102,%eax
    6669:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    666c:	76 de                	jbe    664c <hash_init+0x16e>
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/
    666e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    6675:	eb 17                	jmp    668e <hash_init+0x1b0>
    6677:	8b 45 08             	mov    0x8(%ebp),%eax
    667a:	8b 40 10             	mov    0x10(%eax),%eax
    667d:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6680:	01 d2                	add    %edx,%edx
    6682:	01 d0                	add    %edx,%eax
    6684:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6687:	66 89 10             	mov    %dx,(%eax)
    668a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    668e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    6691:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6694:	75 e1                	jne    6677 <hash_init+0x199>

  return 0;
    6696:	b8 00 00 00 00       	mov    $0x0,%eax
}
    669b:	c9                   	leave  
    669c:	c3                   	ret    

0000669d <hash_cleanup>:

static void hash_cleanup(Hash* hash) {
    669d:	55                   	push   %ebp
    669e:	89 e5                	mov    %esp,%ebp
    66a0:	83 ec 08             	sub    $0x8,%esp
  lodepng_free(hash->head);
    66a3:	8b 45 08             	mov    0x8(%ebp),%eax
    66a6:	8b 00                	mov    (%eax),%eax
    66a8:	83 ec 0c             	sub    $0xc,%esp
    66ab:	50                   	push   %eax
    66ac:	e8 57 cf ff ff       	call   3608 <lodepng_free>
    66b1:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->val);
    66b4:	8b 45 08             	mov    0x8(%ebp),%eax
    66b7:	8b 40 08             	mov    0x8(%eax),%eax
    66ba:	83 ec 0c             	sub    $0xc,%esp
    66bd:	50                   	push   %eax
    66be:	e8 45 cf ff ff       	call   3608 <lodepng_free>
    66c3:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chain);
    66c6:	8b 45 08             	mov    0x8(%ebp),%eax
    66c9:	8b 40 04             	mov    0x4(%eax),%eax
    66cc:	83 ec 0c             	sub    $0xc,%esp
    66cf:	50                   	push   %eax
    66d0:	e8 33 cf ff ff       	call   3608 <lodepng_free>
    66d5:	83 c4 10             	add    $0x10,%esp

  lodepng_free(hash->zeros);
    66d8:	8b 45 08             	mov    0x8(%ebp),%eax
    66db:	8b 40 14             	mov    0x14(%eax),%eax
    66de:	83 ec 0c             	sub    $0xc,%esp
    66e1:	50                   	push   %eax
    66e2:	e8 21 cf ff ff       	call   3608 <lodepng_free>
    66e7:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->headz);
    66ea:	8b 45 08             	mov    0x8(%ebp),%eax
    66ed:	8b 40 0c             	mov    0xc(%eax),%eax
    66f0:	83 ec 0c             	sub    $0xc,%esp
    66f3:	50                   	push   %eax
    66f4:	e8 0f cf ff ff       	call   3608 <lodepng_free>
    66f9:	83 c4 10             	add    $0x10,%esp
  lodepng_free(hash->chainz);
    66fc:	8b 45 08             	mov    0x8(%ebp),%eax
    66ff:	8b 40 10             	mov    0x10(%eax),%eax
    6702:	83 ec 0c             	sub    $0xc,%esp
    6705:	50                   	push   %eax
    6706:	e8 fd ce ff ff       	call   3608 <lodepng_free>
    670b:	83 c4 10             	add    $0x10,%esp
}
    670e:	90                   	nop
    670f:	c9                   	leave  
    6710:	c3                   	ret    

00006711 <getHash>:



static unsigned getHash(const unsigned char* data, size_t size, size_t pos) {
    6711:	55                   	push   %ebp
    6712:	89 e5                	mov    %esp,%ebp
    6714:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    6717:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(pos + 2 < size) {
    671e:	8b 45 10             	mov    0x10(%ebp),%eax
    6721:	83 c0 02             	add    $0x2,%eax
    6724:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6727:	7d 41                	jge    676a <getHash+0x59>
    /*A simple shift and xor hash is used. Since the data of PNGs is dominated
    by zeroes due to the filters, a better hash does not have a significant
    effect on speed in traversing the chain, and causes more time spend on
    calculating the hash.*/
    result ^= ((unsigned)data[pos + 0] << 0u);
    6729:	8b 55 10             	mov    0x10(%ebp),%edx
    672c:	8b 45 08             	mov    0x8(%ebp),%eax
    672f:	01 d0                	add    %edx,%eax
    6731:	0f b6 00             	movzbl (%eax),%eax
    6734:	0f b6 c0             	movzbl %al,%eax
    6737:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 1] << 4u);
    673a:	8b 45 10             	mov    0x10(%ebp),%eax
    673d:	8d 50 01             	lea    0x1(%eax),%edx
    6740:	8b 45 08             	mov    0x8(%ebp),%eax
    6743:	01 d0                	add    %edx,%eax
    6745:	0f b6 00             	movzbl (%eax),%eax
    6748:	0f b6 c0             	movzbl %al,%eax
    674b:	c1 e0 04             	shl    $0x4,%eax
    674e:	31 45 fc             	xor    %eax,-0x4(%ebp)
    result ^= ((unsigned)data[pos + 2] << 8u);
    6751:	8b 45 10             	mov    0x10(%ebp),%eax
    6754:	8d 50 02             	lea    0x2(%eax),%edx
    6757:	8b 45 08             	mov    0x8(%ebp),%eax
    675a:	01 d0                	add    %edx,%eax
    675c:	0f b6 00             	movzbl (%eax),%eax
    675f:	0f b6 c0             	movzbl %al,%eax
    6762:	c1 e0 08             	shl    $0x8,%eax
    6765:	31 45 fc             	xor    %eax,-0x4(%ebp)
    6768:	eb 51                	jmp    67bb <getHash+0xaa>
  } else {
    size_t amount, i;
    if(pos >= size) return 0;
    676a:	8b 45 10             	mov    0x10(%ebp),%eax
    676d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    6770:	7c 07                	jl     6779 <getHash+0x68>
    6772:	b8 00 00 00 00       	mov    $0x0,%eax
    6777:	eb 4a                	jmp    67c3 <getHash+0xb2>
    amount = size - pos;
    6779:	8b 45 0c             	mov    0xc(%ebp),%eax
    677c:	2b 45 10             	sub    0x10(%ebp),%eax
    677f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; i != amount; ++i) result ^= ((unsigned)data[pos + i] << (i * 8u));
    6782:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6789:	eb 28                	jmp    67b3 <getHash+0xa2>
    678b:	8b 55 10             	mov    0x10(%ebp),%edx
    678e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6791:	01 d0                	add    %edx,%eax
    6793:	89 c2                	mov    %eax,%edx
    6795:	8b 45 08             	mov    0x8(%ebp),%eax
    6798:	01 d0                	add    %edx,%eax
    679a:	0f b6 00             	movzbl (%eax),%eax
    679d:	0f b6 d0             	movzbl %al,%edx
    67a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    67a3:	c1 e0 03             	shl    $0x3,%eax
    67a6:	89 c1                	mov    %eax,%ecx
    67a8:	d3 e2                	shl    %cl,%edx
    67aa:	89 d0                	mov    %edx,%eax
    67ac:	31 45 fc             	xor    %eax,-0x4(%ebp)
    67af:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    67b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    67b6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    67b9:	75 d0                	jne    678b <getHash+0x7a>
  }
  return result & HASH_BIT_MASK;
    67bb:	b8 ff ff 00 00       	mov    $0xffff,%eax
    67c0:	23 45 fc             	and    -0x4(%ebp),%eax
}
    67c3:	c9                   	leave  
    67c4:	c3                   	ret    

000067c5 <countZeros>:

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos) {
    67c5:	55                   	push   %ebp
    67c6:	89 e5                	mov    %esp,%ebp
    67c8:	83 ec 10             	sub    $0x10,%esp
  const unsigned char* start = data + pos;
    67cb:	8b 55 10             	mov    0x10(%ebp),%edx
    67ce:	8b 45 08             	mov    0x8(%ebp),%eax
    67d1:	01 d0                	add    %edx,%eax
    67d3:	89 45 f8             	mov    %eax,-0x8(%ebp)
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
    67d6:	b8 02 01 00 00       	mov    $0x102,%eax
    67db:	89 c2                	mov    %eax,%edx
    67dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    67e0:	01 d0                	add    %edx,%eax
    67e2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(end > data + size) end = data + size;
    67e5:	8b 55 0c             	mov    0xc(%ebp),%edx
    67e8:	8b 45 08             	mov    0x8(%ebp),%eax
    67eb:	01 d0                	add    %edx,%eax
    67ed:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    67f0:	73 0b                	jae    67fd <countZeros+0x38>
    67f2:	8b 55 0c             	mov    0xc(%ebp),%edx
    67f5:	8b 45 08             	mov    0x8(%ebp),%eax
    67f8:	01 d0                	add    %edx,%eax
    67fa:	89 45 fc             	mov    %eax,-0x4(%ebp)
  data = start;
    67fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6800:	89 45 08             	mov    %eax,0x8(%ebp)
  while(data != end && *data == 0) ++data;
    6803:	eb 04                	jmp    6809 <countZeros+0x44>
    6805:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    6809:	8b 45 08             	mov    0x8(%ebp),%eax
    680c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    680f:	74 0a                	je     681b <countZeros+0x56>
    6811:	8b 45 08             	mov    0x8(%ebp),%eax
    6814:	0f b6 00             	movzbl (%eax),%eax
    6817:	84 c0                	test   %al,%al
    6819:	74 ea                	je     6805 <countZeros+0x40>
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
    681b:	8b 55 08             	mov    0x8(%ebp),%edx
    681e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6821:	29 c2                	sub    %eax,%edx
    6823:	89 d0                	mov    %edx,%eax
}
    6825:	c9                   	leave  
    6826:	c3                   	ret    

00006827 <updateHashChain>:

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros) {
    6827:	55                   	push   %ebp
    6828:	89 e5                	mov    %esp,%ebp
    682a:	83 ec 04             	sub    $0x4,%esp
    682d:	8b 45 14             	mov    0x14(%ebp),%eax
    6830:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  hash->val[wpos] = (int)hashval;
    6834:	8b 45 08             	mov    0x8(%ebp),%eax
    6837:	8b 40 08             	mov    0x8(%eax),%eax
    683a:	8b 55 0c             	mov    0xc(%ebp),%edx
    683d:	c1 e2 02             	shl    $0x2,%edx
    6840:	01 c2                	add    %eax,%edx
    6842:	8b 45 10             	mov    0x10(%ebp),%eax
    6845:	89 02                	mov    %eax,(%edx)
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
    6847:	8b 45 08             	mov    0x8(%ebp),%eax
    684a:	8b 00                	mov    (%eax),%eax
    684c:	8b 55 10             	mov    0x10(%ebp),%edx
    684f:	c1 e2 02             	shl    $0x2,%edx
    6852:	01 d0                	add    %edx,%eax
    6854:	8b 00                	mov    (%eax),%eax
    6856:	83 f8 ff             	cmp    $0xffffffff,%eax
    6859:	74 1f                	je     687a <updateHashChain+0x53>
    685b:	8b 45 08             	mov    0x8(%ebp),%eax
    685e:	8b 40 04             	mov    0x4(%eax),%eax
    6861:	8b 55 0c             	mov    0xc(%ebp),%edx
    6864:	01 d2                	add    %edx,%edx
    6866:	01 c2                	add    %eax,%edx
    6868:	8b 45 08             	mov    0x8(%ebp),%eax
    686b:	8b 00                	mov    (%eax),%eax
    686d:	8b 4d 10             	mov    0x10(%ebp),%ecx
    6870:	c1 e1 02             	shl    $0x2,%ecx
    6873:	01 c8                	add    %ecx,%eax
    6875:	8b 00                	mov    (%eax),%eax
    6877:	66 89 02             	mov    %ax,(%edx)
  hash->head[hashval] = (int)wpos;
    687a:	8b 45 08             	mov    0x8(%ebp),%eax
    687d:	8b 00                	mov    (%eax),%eax
    687f:	8b 55 10             	mov    0x10(%ebp),%edx
    6882:	c1 e2 02             	shl    $0x2,%edx
    6885:	01 c2                	add    %eax,%edx
    6887:	8b 45 0c             	mov    0xc(%ebp),%eax
    688a:	89 02                	mov    %eax,(%edx)

  hash->zeros[wpos] = numzeros;
    688c:	8b 45 08             	mov    0x8(%ebp),%eax
    688f:	8b 40 14             	mov    0x14(%eax),%eax
    6892:	8b 55 0c             	mov    0xc(%ebp),%edx
    6895:	01 d2                	add    %edx,%edx
    6897:	01 c2                	add    %eax,%edx
    6899:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    689d:	66 89 02             	mov    %ax,(%edx)
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
    68a0:	8b 45 08             	mov    0x8(%ebp),%eax
    68a3:	8b 40 0c             	mov    0xc(%eax),%eax
    68a6:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    68aa:	c1 e2 02             	shl    $0x2,%edx
    68ad:	01 d0                	add    %edx,%eax
    68af:	8b 00                	mov    (%eax),%eax
    68b1:	83 f8 ff             	cmp    $0xffffffff,%eax
    68b4:	74 21                	je     68d7 <updateHashChain+0xb0>
    68b6:	8b 45 08             	mov    0x8(%ebp),%eax
    68b9:	8b 40 10             	mov    0x10(%eax),%eax
    68bc:	8b 55 0c             	mov    0xc(%ebp),%edx
    68bf:	01 d2                	add    %edx,%edx
    68c1:	01 c2                	add    %eax,%edx
    68c3:	8b 45 08             	mov    0x8(%ebp),%eax
    68c6:	8b 40 0c             	mov    0xc(%eax),%eax
    68c9:	0f b7 4d fc          	movzwl -0x4(%ebp),%ecx
    68cd:	c1 e1 02             	shl    $0x2,%ecx
    68d0:	01 c8                	add    %ecx,%eax
    68d2:	8b 00                	mov    (%eax),%eax
    68d4:	66 89 02             	mov    %ax,(%edx)
  hash->headz[numzeros] = (int)wpos;
    68d7:	8b 45 08             	mov    0x8(%ebp),%eax
    68da:	8b 40 0c             	mov    0xc(%eax),%eax
    68dd:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
    68e1:	c1 e2 02             	shl    $0x2,%edx
    68e4:	01 c2                	add    %eax,%edx
    68e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    68e9:	89 02                	mov    %eax,(%edx)
}
    68eb:	90                   	nop
    68ec:	c9                   	leave  
    68ed:	c3                   	ret    

000068ee <encodeLZ77>:
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching) {
    68ee:	55                   	push   %ebp
    68ef:	89 e5                	mov    %esp,%ebp
    68f1:	83 ec 60             	sub    $0x60,%esp
  size_t pos;
  unsigned i, error = 0;
    68f4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8u;
    68fb:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6902:	77 08                	ja     690c <encodeLZ77+0x1e>
    6904:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6907:	c1 e8 03             	shr    $0x3,%eax
    690a:	eb 03                	jmp    690f <encodeLZ77+0x21>
    690c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    690f:	89 45 c0             	mov    %eax,-0x40(%ebp)
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;
    6912:	81 7d 1c ff 1f 00 00 	cmpl   $0x1fff,0x1c(%ebp)
    6919:	76 07                	jbe    6922 <encodeLZ77+0x34>
    691b:	b8 02 01 00 00       	mov    $0x102,%eax
    6920:	eb 05                	jmp    6927 <encodeLZ77+0x39>
    6922:	b8 40 00 00 00       	mov    $0x40,%eax
    6927:	89 45 bc             	mov    %eax,-0x44(%ebp)

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
    692a:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%ebp)
  unsigned numzeros = 0;
    6931:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
    6938:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned lazylength = 0, lazyoffset = 0;
    693f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    6946:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
    694d:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
    6951:	74 09                	je     695c <encodeLZ77+0x6e>
    6953:	81 7d 1c 00 80 00 00 	cmpl   $0x8000,0x1c(%ebp)
    695a:	76 0a                	jbe    6966 <encodeLZ77+0x78>
    695c:	b8 3c 00 00 00       	mov    $0x3c,%eax
    6961:	e9 e3 04 00 00       	jmp    6e49 <encodeLZ77+0x55b>
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/
    6966:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6969:	83 e8 01             	sub    $0x1,%eax
    696c:	23 45 1c             	and    0x1c(%ebp),%eax
    696f:	85 c0                	test   %eax,%eax
    6971:	74 0a                	je     697d <encodeLZ77+0x8f>
    6973:	b8 5a 00 00 00       	mov    $0x5a,%eax
    6978:	e9 cc 04 00 00       	jmp    6e49 <encodeLZ77+0x55b>

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;
    697d:	b8 02 01 00 00       	mov    $0x102,%eax
    6982:	39 45 24             	cmp    %eax,0x24(%ebp)
    6985:	76 08                	jbe    698f <encodeLZ77+0xa1>
    6987:	b8 02 01 00 00       	mov    $0x102,%eax
    698c:	89 45 24             	mov    %eax,0x24(%ebp)

  for(pos = inpos; pos < insize; ++pos) {
    698f:	8b 45 14             	mov    0x14(%ebp),%eax
    6992:	89 45 fc             	mov    %eax,-0x4(%ebp)
    6995:	e9 a0 04 00 00       	jmp    6e3a <encodeLZ77+0x54c>
    size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
    699a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    699d:	8d 50 ff             	lea    -0x1(%eax),%edx
    69a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    69a3:	21 d0                	and    %edx,%eax
    69a5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    unsigned chainlength = 0;
    69a8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

    hashval = getHash(in, insize, pos);
    69af:	ff 75 fc             	pushl  -0x4(%ebp)
    69b2:	ff 75 18             	pushl  0x18(%ebp)
    69b5:	ff 75 10             	pushl  0x10(%ebp)
    69b8:	e8 54 fd ff ff       	call   6711 <getHash>
    69bd:	83 c4 0c             	add    $0xc,%esp
    69c0:	89 45 b0             	mov    %eax,-0x50(%ebp)

    if(usezeros && hashval == 0) {
    69c3:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    69c7:	74 4e                	je     6a17 <encodeLZ77+0x129>
    69c9:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    69cd:	75 48                	jne    6a17 <encodeLZ77+0x129>
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    69cf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    69d3:	75 16                	jne    69eb <encodeLZ77+0xfd>
    69d5:	ff 75 fc             	pushl  -0x4(%ebp)
    69d8:	ff 75 18             	pushl  0x18(%ebp)
    69db:	ff 75 10             	pushl  0x10(%ebp)
    69de:	e8 e2 fd ff ff       	call   67c5 <countZeros>
    69e3:	83 c4 0c             	add    $0xc,%esp
    69e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    69e9:	eb 35                	jmp    6a20 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    69eb:	8b 55 fc             	mov    -0x4(%ebp),%edx
    69ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
    69f1:	01 c2                	add    %eax,%edx
    69f3:	8b 45 18             	mov    0x18(%ebp),%eax
    69f6:	39 c2                	cmp    %eax,%edx
    69f8:	77 17                	ja     6a11 <encodeLZ77+0x123>
    69fa:	8b 55 fc             	mov    -0x4(%ebp),%edx
    69fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6a00:	01 d0                	add    %edx,%eax
    6a02:	8d 50 ff             	lea    -0x1(%eax),%edx
    6a05:	8b 45 10             	mov    0x10(%ebp),%eax
    6a08:	01 d0                	add    %edx,%eax
    6a0a:	0f b6 00             	movzbl (%eax),%eax
    6a0d:	84 c0                	test   %al,%al
    6a0f:	74 0f                	je     6a20 <encodeLZ77+0x132>
    6a11:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6a15:	eb 09                	jmp    6a20 <encodeLZ77+0x132>
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    6a17:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6a1e:	eb 01                	jmp    6a21 <encodeLZ77+0x133>
    unsigned chainlength = 0;

    hashval = getHash(in, insize, pos);

    if(usezeros && hashval == 0) {
      if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6a20:	90                   	nop
      else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    } else {
      numzeros = 0;
    }

    updateHashChain(hash, wpos, hashval, numzeros);
    6a21:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6a24:	0f b7 c0             	movzwl %ax,%eax
    6a27:	50                   	push   %eax
    6a28:	ff 75 b0             	pushl  -0x50(%ebp)
    6a2b:	ff 75 b4             	pushl  -0x4c(%ebp)
    6a2e:	ff 75 0c             	pushl  0xc(%ebp)
    6a31:	e8 f1 fd ff ff       	call   6827 <updateHashChain>
    6a36:	83 c4 10             	add    $0x10,%esp

    /*the length and offset found for the current position*/
    length = 0;
    6a39:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    offset = 0;
    6a40:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    hashpos = hash->chain[wpos];
    6a47:	8b 45 0c             	mov    0xc(%ebp),%eax
    6a4a:	8b 40 04             	mov    0x4(%eax),%eax
    6a4d:	8b 55 b4             	mov    -0x4c(%ebp),%edx
    6a50:	01 d2                	add    %edx,%edx
    6a52:	01 d0                	add    %edx,%eax
    6a54:	0f b7 00             	movzwl (%eax),%eax
    6a57:	0f b7 c0             	movzwl %ax,%eax
    6a5a:	89 45 cc             	mov    %eax,-0x34(%ebp)

    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];
    6a5d:	ba 02 01 00 00       	mov    $0x102,%edx
    6a62:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6a65:	01 c2                	add    %eax,%edx
    6a67:	8b 45 18             	mov    0x18(%ebp),%eax
    6a6a:	39 c2                	cmp    %eax,%edx
    6a6c:	0f 4e c2             	cmovle %edx,%eax
    6a6f:	89 c2                	mov    %eax,%edx
    6a71:	8b 45 10             	mov    0x10(%ebp),%eax
    6a74:	01 d0                	add    %edx,%eax
    6a76:	89 45 ac             	mov    %eax,-0x54(%ebp)

    /*search for the longest string*/
    prev_offset = 0;
    6a79:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6a80:	8b 45 c8             	mov    -0x38(%ebp),%eax
    6a83:	8d 50 01             	lea    0x1(%eax),%edx
    6a86:	89 55 c8             	mov    %edx,-0x38(%ebp)
    6a89:	3b 45 c0             	cmp    -0x40(%ebp),%eax
    6a8c:	0f 83 67 01 00 00    	jae    6bf9 <encodeLZ77+0x30b>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);
    6a92:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6a95:	39 45 cc             	cmp    %eax,-0x34(%ebp)
    6a98:	77 08                	ja     6aa2 <encodeLZ77+0x1b4>
    6a9a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6a9d:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6aa0:	eb 0d                	jmp    6aaf <encodeLZ77+0x1c1>
    6aa2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    6aa5:	2b 45 cc             	sub    -0x34(%ebp),%eax
    6aa8:	89 c2                	mov    %eax,%edx
    6aaa:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6aad:	01 d0                	add    %edx,%eax
    6aaf:	89 45 a8             	mov    %eax,-0x58(%ebp)

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    6ab2:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6ab5:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    6ab8:	0f 82 3e 01 00 00    	jb     6bfc <encodeLZ77+0x30e>
      prev_offset = current_offset;
    6abe:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6ac1:	89 45 d8             	mov    %eax,-0x28(%ebp)
      if(current_offset > 0) {
    6ac4:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
    6ac8:	0f 84 a3 00 00 00    	je     6b71 <encodeLZ77+0x283>
        /*test the next characters*/
        foreptr = &in[pos];
    6ace:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6ad1:	8b 45 10             	mov    0x10(%ebp),%eax
    6ad4:	01 d0                	add    %edx,%eax
    6ad6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        backptr = &in[pos - current_offset];
    6ad9:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6adc:	2b 45 a8             	sub    -0x58(%ebp),%eax
    6adf:	89 c2                	mov    %eax,%edx
    6ae1:	8b 45 10             	mov    0x10(%ebp),%eax
    6ae4:	01 d0                	add    %edx,%eax
    6ae6:	89 45 d0             	mov    %eax,-0x30(%ebp)

        /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
        if(numzeros >= 3) {
    6ae9:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6aed:	76 3a                	jbe    6b29 <encodeLZ77+0x23b>
          unsigned skip = hash->zeros[hashpos];
    6aef:	8b 45 0c             	mov    0xc(%ebp),%eax
    6af2:	8b 40 14             	mov    0x14(%eax),%eax
    6af5:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6af8:	01 d2                	add    %edx,%edx
    6afa:	01 d0                	add    %edx,%eax
    6afc:	0f b7 00             	movzwl (%eax),%eax
    6aff:	0f b7 c0             	movzwl %ax,%eax
    6b02:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          if(skip > numzeros) skip = numzeros;
    6b05:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6b08:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6b0b:	76 06                	jbe    6b13 <encodeLZ77+0x225>
    6b0d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6b10:	89 45 c4             	mov    %eax,-0x3c(%ebp)
          backptr += skip;
    6b13:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6b16:	01 45 d0             	add    %eax,-0x30(%ebp)
          foreptr += skip;
    6b19:	8b 45 c4             	mov    -0x3c(%ebp),%eax
    6b1c:	01 45 d4             	add    %eax,-0x2c(%ebp)
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6b1f:	eb 08                	jmp    6b29 <encodeLZ77+0x23b>
          ++backptr;
    6b21:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
          ++foreptr;
    6b25:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
          if(skip > numzeros) skip = numzeros;
          backptr += skip;
          foreptr += skip;
        }

        while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/ {
    6b29:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6b2c:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    6b2f:	74 10                	je     6b41 <encodeLZ77+0x253>
    6b31:	8b 45 d0             	mov    -0x30(%ebp),%eax
    6b34:	0f b6 10             	movzbl (%eax),%edx
    6b37:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6b3a:	0f b6 00             	movzbl (%eax),%eax
    6b3d:	38 c2                	cmp    %al,%dl
    6b3f:	74 e0                	je     6b21 <encodeLZ77+0x233>
          ++backptr;
          ++foreptr;
        }
        current_length = (unsigned)(foreptr - &in[pos]);
    6b41:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    6b44:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    6b47:	8b 55 10             	mov    0x10(%ebp),%edx
    6b4a:	01 ca                	add    %ecx,%edx
    6b4c:	29 d0                	sub    %edx,%eax
    6b4e:	89 45 a4             	mov    %eax,-0x5c(%ebp)

        if(current_length > length) {
    6b51:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6b54:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6b57:	76 18                	jbe    6b71 <encodeLZ77+0x283>
          length = current_length; /*the longest length*/
    6b59:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6b5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = current_offset; /*the offset that is related to this longest length*/
    6b5f:	8b 45 a8             	mov    -0x58(%ebp),%eax
    6b62:	89 45 ec             	mov    %eax,-0x14(%ebp)
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6b65:	8b 45 a4             	mov    -0x5c(%ebp),%eax
    6b68:	3b 45 24             	cmp    0x24(%ebp),%eax
    6b6b:	0f 83 8e 00 00 00    	jae    6bff <encodeLZ77+0x311>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    6b71:	8b 45 0c             	mov    0xc(%ebp),%eax
    6b74:	8b 40 04             	mov    0x4(%eax),%eax
    6b77:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6b7a:	01 d2                	add    %edx,%edx
    6b7c:	01 d0                	add    %edx,%eax
    6b7e:	0f b7 00             	movzwl (%eax),%eax
    6b81:	0f b7 c0             	movzwl %ax,%eax
    6b84:	3b 45 cc             	cmp    -0x34(%ebp),%eax
    6b87:	74 79                	je     6c02 <encodeLZ77+0x314>

      if(numzeros >= 3 && length > numzeros) {
    6b89:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
    6b8d:	76 38                	jbe    6bc7 <encodeLZ77+0x2d9>
    6b8f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6b92:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6b95:	76 30                	jbe    6bc7 <encodeLZ77+0x2d9>
        hashpos = hash->chainz[hashpos];
    6b97:	8b 45 0c             	mov    0xc(%ebp),%eax
    6b9a:	8b 40 10             	mov    0x10(%eax),%eax
    6b9d:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6ba0:	01 d2                	add    %edx,%edx
    6ba2:	01 d0                	add    %edx,%eax
    6ba4:	0f b7 00             	movzwl (%eax),%eax
    6ba7:	0f b7 c0             	movzwl %ax,%eax
    6baa:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(hash->zeros[hashpos] != numzeros) break;
    6bad:	8b 45 0c             	mov    0xc(%ebp),%eax
    6bb0:	8b 40 14             	mov    0x14(%eax),%eax
    6bb3:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6bb6:	01 d2                	add    %edx,%edx
    6bb8:	01 d0                	add    %edx,%eax
    6bba:	0f b7 00             	movzwl (%eax),%eax
    6bbd:	0f b7 c0             	movzwl %ax,%eax
    6bc0:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    6bc3:	74 2f                	je     6bf4 <encodeLZ77+0x306>
    6bc5:	eb 3f                	jmp    6c06 <encodeLZ77+0x318>
      } else {
        hashpos = hash->chain[hashpos];
    6bc7:	8b 45 0c             	mov    0xc(%ebp),%eax
    6bca:	8b 40 04             	mov    0x4(%eax),%eax
    6bcd:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6bd0:	01 d2                	add    %edx,%edx
    6bd2:	01 d0                	add    %edx,%eax
    6bd4:	0f b7 00             	movzwl (%eax),%eax
    6bd7:	0f b7 c0             	movzwl %ax,%eax
    6bda:	89 45 cc             	mov    %eax,-0x34(%ebp)
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6bdd:	8b 45 0c             	mov    0xc(%ebp),%eax
    6be0:	8b 40 08             	mov    0x8(%eax),%eax
    6be3:	8b 55 cc             	mov    -0x34(%ebp),%edx
    6be6:	c1 e2 02             	shl    $0x2,%edx
    6be9:	01 d0                	add    %edx,%eax
    6beb:	8b 10                	mov    (%eax),%edx
    6bed:	8b 45 b0             	mov    -0x50(%ebp),%eax
    6bf0:	39 c2                	cmp    %eax,%edx
    6bf2:	75 11                	jne    6c05 <encodeLZ77+0x317>
      }
    }
    6bf4:	e9 87 fe ff ff       	jmp    6a80 <encodeLZ77+0x192>
    lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

    /*search for the longest string*/
    prev_offset = 0;
    for(;;) {
      if(chainlength++ >= maxchainlength) break;
    6bf9:	90                   	nop
    6bfa:	eb 0a                	jmp    6c06 <encodeLZ77+0x318>
      current_offset = (unsigned)(hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize);

      if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
    6bfc:	90                   	nop
    6bfd:	eb 07                	jmp    6c06 <encodeLZ77+0x318>
        if(current_length > length) {
          length = current_length; /*the longest length*/
          offset = current_offset; /*the offset that is related to this longest length*/
          /*jump out once a length of max length is found (speed gain). This also jumps
          out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
          if(current_length >= nicematch) break;
    6bff:	90                   	nop
    6c00:	eb 04                	jmp    6c06 <encodeLZ77+0x318>
        }
      }

      if(hashpos == hash->chain[hashpos]) break;
    6c02:	90                   	nop
    6c03:	eb 01                	jmp    6c06 <encodeLZ77+0x318>
        hashpos = hash->chainz[hashpos];
        if(hash->zeros[hashpos] != numzeros) break;
      } else {
        hashpos = hash->chain[hashpos];
        /*outdated hash value, happens if particular value was not encountered in whole last window*/
        if(hash->val[hashpos] != (int)hashval) break;
    6c05:	90                   	nop
      }
    }

    if(lazymatching) {
    6c06:	83 7d 28 00          	cmpl   $0x0,0x28(%ebp)
    6c0a:	0f 84 c8 00 00 00    	je     6cd8 <encodeLZ77+0x3ea>
      if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH) {
    6c10:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6c14:	75 30                	jne    6c46 <encodeLZ77+0x358>
    6c16:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6c1a:	76 2a                	jbe    6c46 <encodeLZ77+0x358>
    6c1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6c1f:	3b 45 bc             	cmp    -0x44(%ebp),%eax
    6c22:	77 22                	ja     6c46 <encodeLZ77+0x358>
    6c24:	b8 02 01 00 00       	mov    $0x102,%eax
    6c29:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    6c2c:	73 18                	jae    6c46 <encodeLZ77+0x358>
        lazy = 1;
    6c2e:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        lazylength = length;
    6c35:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6c38:	89 45 e0             	mov    %eax,-0x20(%ebp)
        lazyoffset = offset;
    6c3b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6c3e:	89 45 dc             	mov    %eax,-0x24(%ebp)
        continue; /*try the next byte*/
    6c41:	e9 f0 01 00 00       	jmp    6e36 <encodeLZ77+0x548>
      }
      if(lazy) {
    6c46:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    6c4a:	0f 84 88 00 00 00    	je     6cd8 <encodeLZ77+0x3ea>
        lazy = 0;
    6c50:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
        if(pos == 0) ERROR_BREAK(81);
    6c57:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    6c5b:	75 0c                	jne    6c69 <encodeLZ77+0x37b>
    6c5d:	c7 45 f4 51 00 00 00 	movl   $0x51,-0xc(%ebp)
    6c64:	e9 dd 01 00 00       	jmp    6e46 <encodeLZ77+0x558>
        if(length > lazylength + 1) {
    6c69:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6c6c:	83 c0 01             	add    $0x1,%eax
    6c6f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6c72:	73 2d                	jae    6ca1 <encodeLZ77+0x3b3>
          /*push the previous character as literal*/
          if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
    6c74:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6c77:	8d 50 ff             	lea    -0x1(%eax),%edx
    6c7a:	8b 45 10             	mov    0x10(%ebp),%eax
    6c7d:	01 d0                	add    %edx,%eax
    6c7f:	0f b6 00             	movzbl (%eax),%eax
    6c82:	0f b6 c0             	movzbl %al,%eax
    6c85:	50                   	push   %eax
    6c86:	ff 75 08             	pushl  0x8(%ebp)
    6c89:	e8 6f cb ff ff       	call   37fd <uivector_push_back>
    6c8e:	83 c4 08             	add    $0x8,%esp
    6c91:	85 c0                	test   %eax,%eax
    6c93:	75 43                	jne    6cd8 <encodeLZ77+0x3ea>
    6c95:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6c9c:	e9 a5 01 00 00       	jmp    6e46 <encodeLZ77+0x558>
        } else {
          length = lazylength;
    6ca1:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6ca4:	89 45 e8             	mov    %eax,-0x18(%ebp)
          offset = lazyoffset;
    6ca7:	8b 45 dc             	mov    -0x24(%ebp),%eax
    6caa:	89 45 ec             	mov    %eax,-0x14(%ebp)
          hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
    6cad:	8b 45 0c             	mov    0xc(%ebp),%eax
    6cb0:	8b 00                	mov    (%eax),%eax
    6cb2:	8b 55 b0             	mov    -0x50(%ebp),%edx
    6cb5:	c1 e2 02             	shl    $0x2,%edx
    6cb8:	01 d0                	add    %edx,%eax
    6cba:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          hash->headz[numzeros] = -1; /*idem*/
    6cc0:	8b 45 0c             	mov    0xc(%ebp),%eax
    6cc3:	8b 40 0c             	mov    0xc(%eax),%eax
    6cc6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6cc9:	c1 e2 02             	shl    $0x2,%edx
    6ccc:	01 d0                	add    %edx,%eax
    6cce:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
          --pos;
    6cd4:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        }
      }
    }
    if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);
    6cd8:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6cdc:	76 14                	jbe    6cf2 <encodeLZ77+0x404>
    6cde:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6ce1:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    6ce4:	76 0c                	jbe    6cf2 <encodeLZ77+0x404>
    6ce6:	c7 45 f4 56 00 00 00 	movl   $0x56,-0xc(%ebp)
    6ced:	e9 54 01 00 00       	jmp    6e46 <encodeLZ77+0x558>

    /*encode it as length/distance pair or literal value*/
    if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/ {
    6cf2:	83 7d e8 02          	cmpl   $0x2,-0x18(%ebp)
    6cf6:	77 2e                	ja     6d26 <encodeLZ77+0x438>
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6cf8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6cfb:	8b 45 10             	mov    0x10(%ebp),%eax
    6cfe:	01 d0                	add    %edx,%eax
    6d00:	0f b6 00             	movzbl (%eax),%eax
    6d03:	0f b6 c0             	movzbl %al,%eax
    6d06:	50                   	push   %eax
    6d07:	ff 75 08             	pushl  0x8(%ebp)
    6d0a:	e8 ee ca ff ff       	call   37fd <uivector_push_back>
    6d0f:	83 c4 08             	add    $0x8,%esp
    6d12:	85 c0                	test   %eax,%eax
    6d14:	0f 85 1c 01 00 00    	jne    6e36 <encodeLZ77+0x548>
    6d1a:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6d21:	e9 20 01 00 00       	jmp    6e46 <encodeLZ77+0x558>
    } else if(length < minmatch || (length == 3 && offset > 4096)) {
    6d26:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6d29:	3b 45 20             	cmp    0x20(%ebp),%eax
    6d2c:	72 0f                	jb     6d3d <encodeLZ77+0x44f>
    6d2e:	83 7d e8 03          	cmpl   $0x3,-0x18(%ebp)
    6d32:	75 37                	jne    6d6b <encodeLZ77+0x47d>
    6d34:	81 7d ec 00 10 00 00 	cmpl   $0x1000,-0x14(%ebp)
    6d3b:	76 2e                	jbe    6d6b <encodeLZ77+0x47d>
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    6d3d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6d40:	8b 45 10             	mov    0x10(%ebp),%eax
    6d43:	01 d0                	add    %edx,%eax
    6d45:	0f b6 00             	movzbl (%eax),%eax
    6d48:	0f b6 c0             	movzbl %al,%eax
    6d4b:	50                   	push   %eax
    6d4c:	ff 75 08             	pushl  0x8(%ebp)
    6d4f:	e8 a9 ca ff ff       	call   37fd <uivector_push_back>
    6d54:	83 c4 08             	add    $0x8,%esp
    6d57:	85 c0                	test   %eax,%eax
    6d59:	0f 85 d7 00 00 00    	jne    6e36 <encodeLZ77+0x548>
    6d5f:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    6d66:	e9 db 00 00 00       	jmp    6e46 <encodeLZ77+0x558>
    } else {
      addLengthDistance(out, length, offset);
    6d6b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    6d6e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6d71:	52                   	push   %edx
    6d72:	50                   	push   %eax
    6d73:	ff 75 08             	pushl  0x8(%ebp)
    6d76:	e8 8a f6 ff ff       	call   6405 <addLengthDistance>
    6d7b:	83 c4 0c             	add    $0xc,%esp
      for(i = 1; i < length; ++i) {
    6d7e:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    6d85:	e9 a0 00 00 00       	jmp    6e2a <encodeLZ77+0x53c>
        ++pos;
    6d8a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        wpos = pos & (windowsize - 1);
    6d8e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    6d91:	8d 50 ff             	lea    -0x1(%eax),%edx
    6d94:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6d97:	21 d0                	and    %edx,%eax
    6d99:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        hashval = getHash(in, insize, pos);
    6d9c:	ff 75 fc             	pushl  -0x4(%ebp)
    6d9f:	ff 75 18             	pushl  0x18(%ebp)
    6da2:	ff 75 10             	pushl  0x10(%ebp)
    6da5:	e8 67 f9 ff ff       	call   6711 <getHash>
    6daa:	83 c4 0c             	add    $0xc,%esp
    6dad:	89 45 b0             	mov    %eax,-0x50(%ebp)
        if(usezeros && hashval == 0) {
    6db0:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
    6db4:	74 4e                	je     6e04 <encodeLZ77+0x516>
    6db6:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
    6dba:	75 48                	jne    6e04 <encodeLZ77+0x516>
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6dbc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    6dc0:	75 16                	jne    6dd8 <encodeLZ77+0x4ea>
    6dc2:	ff 75 fc             	pushl  -0x4(%ebp)
    6dc5:	ff 75 18             	pushl  0x18(%ebp)
    6dc8:	ff 75 10             	pushl  0x10(%ebp)
    6dcb:	e8 f5 f9 ff ff       	call   67c5 <countZeros>
    6dd0:	83 c4 0c             	add    $0xc,%esp
    6dd3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    6dd6:	eb 35                	jmp    6e0d <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
    6dd8:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6ddb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6dde:	01 c2                	add    %eax,%edx
    6de0:	8b 45 18             	mov    0x18(%ebp),%eax
    6de3:	39 c2                	cmp    %eax,%edx
    6de5:	77 17                	ja     6dfe <encodeLZ77+0x510>
    6de7:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6dea:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ded:	01 d0                	add    %edx,%eax
    6def:	8d 50 ff             	lea    -0x1(%eax),%edx
    6df2:	8b 45 10             	mov    0x10(%ebp),%eax
    6df5:	01 d0                	add    %edx,%eax
    6df7:	0f b6 00             	movzbl (%eax),%eax
    6dfa:	84 c0                	test   %al,%al
    6dfc:	74 0f                	je     6e0d <encodeLZ77+0x51f>
    6dfe:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6e02:	eb 09                	jmp    6e0d <encodeLZ77+0x51f>
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
    6e04:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    6e0b:	eb 01                	jmp    6e0e <encodeLZ77+0x520>
      for(i = 1; i < length; ++i) {
        ++pos;
        wpos = pos & (windowsize - 1);
        hashval = getHash(in, insize, pos);
        if(usezeros && hashval == 0) {
          if(numzeros == 0) numzeros = countZeros(in, insize, pos);
    6e0d:	90                   	nop
          else if(pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
        } else {
          numzeros = 0;
        }
        updateHashChain(hash, wpos, hashval, numzeros);
    6e0e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6e11:	0f b7 c0             	movzwl %ax,%eax
    6e14:	50                   	push   %eax
    6e15:	ff 75 b0             	pushl  -0x50(%ebp)
    6e18:	ff 75 b4             	pushl  -0x4c(%ebp)
    6e1b:	ff 75 0c             	pushl  0xc(%ebp)
    6e1e:	e8 04 fa ff ff       	call   6827 <updateHashChain>
    6e23:	83 c4 10             	add    $0x10,%esp
      /*compensate for the fact that longer offsets have more extra bits, a
      length of only 3 may be not worth it then*/
      if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
    } else {
      addLengthDistance(out, length, offset);
      for(i = 1; i < length; ++i) {
    6e26:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6e2a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6e2d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    6e30:	0f 82 54 ff ff ff    	jb     6d8a <encodeLZ77+0x49c>
  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos) {
    6e36:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    6e3a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    6e3d:	3b 45 18             	cmp    0x18(%ebp),%eax
    6e40:	0f 8c 54 fb ff ff    	jl     699a <encodeLZ77+0xac>
        updateHashChain(hash, wpos, hashval, numzeros);
      }
    }
  } /*end of the loop through each character of input*/

  return error;
    6e46:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    6e49:	c9                   	leave  
    6e4a:	c3                   	ret    

00006e4b <deflateNoCompression>:

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize) {
    6e4b:	55                   	push   %ebp
    6e4c:	89 e5                	mov    %esp,%ebp
    6e4e:	53                   	push   %ebx
    6e4f:	83 ec 30             	sub    $0x30,%esp
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
    6e52:	8b 45 10             	mov    0x10(%ebp),%eax
    6e55:	05 fe ff 00 00       	add    $0xfffe,%eax
    6e5a:	ba 01 80 00 80       	mov    $0x80008001,%edx
    6e5f:	f7 e2                	mul    %edx
    6e61:	89 d0                	mov    %edx,%eax
    6e63:	c1 e8 0f             	shr    $0xf,%eax
    6e66:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned datapos = 0;
    6e69:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for(i = 0; i != numdeflateblocks; ++i) {
    6e70:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    6e77:	e9 1b 01 00 00       	jmp    6f97 <deflateNoCompression+0x14c>
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;
    size_t pos = out->size;
    6e7c:	8b 45 08             	mov    0x8(%ebp),%eax
    6e7f:	8b 40 04             	mov    0x4(%eax),%eax
    6e82:	89 45 e8             	mov    %eax,-0x18(%ebp)

    BFINAL = (i == numdeflateblocks - 1);
    6e85:	8b 45 ec             	mov    -0x14(%ebp),%eax
    6e88:	83 e8 01             	sub    $0x1,%eax
    6e8b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    6e8e:	0f 94 c0             	sete   %al
    6e91:	0f b6 c0             	movzbl %al,%eax
    6e94:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    BTYPE = 0;
    6e97:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    LEN = 65535;
    6e9e:	c7 45 f0 ff ff 00 00 	movl   $0xffff,-0x10(%ebp)
    if(datasize - datapos < 65535u) LEN = (unsigned)datasize - datapos;
    6ea5:	8b 45 10             	mov    0x10(%ebp),%eax
    6ea8:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6eab:	3d fe ff 00 00       	cmp    $0xfffe,%eax
    6eb0:	77 09                	ja     6ebb <deflateNoCompression+0x70>
    6eb2:	8b 45 10             	mov    0x10(%ebp),%eax
    6eb5:	2b 45 f4             	sub    -0xc(%ebp),%eax
    6eb8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    NLEN = 65535 - LEN;
    6ebb:	b8 ff ff 00 00       	mov    $0xffff,%eax
    6ec0:	2b 45 f0             	sub    -0x10(%ebp),%eax
    6ec3:	89 45 dc             	mov    %eax,-0x24(%ebp)

    if(!ucvector_resize(out, out->size + LEN + 5)) return 83; /*alloc fail*/
    6ec6:	8b 45 08             	mov    0x8(%ebp),%eax
    6ec9:	8b 40 04             	mov    0x4(%eax),%eax
    6ecc:	89 c2                	mov    %eax,%edx
    6ece:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6ed1:	01 d0                	add    %edx,%eax
    6ed3:	83 c0 05             	add    $0x5,%eax
    6ed6:	50                   	push   %eax
    6ed7:	ff 75 08             	pushl  0x8(%ebp)
    6eda:	e8 62 c9 ff ff       	call   3841 <ucvector_resize>
    6edf:	83 c4 08             	add    $0x8,%esp
    6ee2:	85 c0                	test   %eax,%eax
    6ee4:	75 0a                	jne    6ef0 <deflateNoCompression+0xa5>
    6ee6:	b8 53 00 00 00       	mov    $0x53,%eax
    6eeb:	e9 b8 00 00 00       	jmp    6fa8 <deflateNoCompression+0x15d>

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1u) << 1u) + ((BTYPE & 2u) << 1u));
    6ef0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    6ef3:	89 c2                	mov    %eax,%edx
    6ef5:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6ef8:	83 e0 01             	and    $0x1,%eax
    6efb:	01 c0                	add    %eax,%eax
    6efd:	01 c2                	add    %eax,%edx
    6eff:	8b 45 e0             	mov    -0x20(%ebp),%eax
    6f02:	83 e0 02             	and    $0x2,%eax
    6f05:	01 c0                	add    %eax,%eax
    6f07:	01 d0                	add    %edx,%eax
    6f09:	88 45 db             	mov    %al,-0x25(%ebp)
    out->data[pos + 0] = firstbyte;
    6f0c:	8b 45 08             	mov    0x8(%ebp),%eax
    6f0f:	8b 10                	mov    (%eax),%edx
    6f11:	8b 45 e8             	mov    -0x18(%ebp),%eax
    6f14:	01 c2                	add    %eax,%edx
    6f16:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    6f1a:	88 02                	mov    %al,(%edx)
    out->data[pos + 1] = (unsigned char)(LEN & 255);
    6f1c:	8b 45 08             	mov    0x8(%ebp),%eax
    6f1f:	8b 00                	mov    (%eax),%eax
    6f21:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6f24:	83 c2 01             	add    $0x1,%edx
    6f27:	01 d0                	add    %edx,%eax
    6f29:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6f2c:	88 10                	mov    %dl,(%eax)
    out->data[pos + 2] = (unsigned char)(LEN >> 8u);
    6f2e:	8b 45 08             	mov    0x8(%ebp),%eax
    6f31:	8b 00                	mov    (%eax),%eax
    6f33:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6f36:	83 c2 02             	add    $0x2,%edx
    6f39:	01 d0                	add    %edx,%eax
    6f3b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    6f3e:	c1 ea 08             	shr    $0x8,%edx
    6f41:	88 10                	mov    %dl,(%eax)
    out->data[pos + 3] = (unsigned char)(NLEN & 255);
    6f43:	8b 45 08             	mov    0x8(%ebp),%eax
    6f46:	8b 00                	mov    (%eax),%eax
    6f48:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6f4b:	83 c2 03             	add    $0x3,%edx
    6f4e:	01 d0                	add    %edx,%eax
    6f50:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6f53:	88 10                	mov    %dl,(%eax)
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    6f55:	8b 45 08             	mov    0x8(%ebp),%eax
    6f58:	8b 00                	mov    (%eax),%eax
    6f5a:	8b 55 e8             	mov    -0x18(%ebp),%edx
    6f5d:	83 c2 04             	add    $0x4,%edx
    6f60:	01 d0                	add    %edx,%eax
    6f62:	8b 55 dc             	mov    -0x24(%ebp),%edx
    6f65:	c1 ea 08             	shr    $0x8,%edx
    6f68:	88 10                	mov    %dl,(%eax)
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    6f6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6f6d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    6f70:	8b 55 f4             	mov    -0xc(%ebp),%edx
    6f73:	01 d1                	add    %edx,%ecx
    6f75:	8b 55 08             	mov    0x8(%ebp),%edx
    6f78:	8b 12                	mov    (%edx),%edx
    6f7a:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    6f7d:	83 c3 05             	add    $0x5,%ebx
    6f80:	01 da                	add    %ebx,%edx
    6f82:	50                   	push   %eax
    6f83:	51                   	push   %ecx
    6f84:	52                   	push   %edx
    6f85:	e8 9b c6 ff ff       	call   3625 <lodepng_memcpy>
    6f8a:	83 c4 0c             	add    $0xc,%esp
    datapos += LEN;
    6f8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    6f90:	01 45 f4             	add    %eax,-0xc(%ebp)
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, numdeflateblocks = (datasize + 65534u) / 65535u;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i) {
    6f93:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    6f97:	8b 45 f8             	mov    -0x8(%ebp),%eax
    6f9a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    6f9d:	0f 85 d9 fe ff ff    	jne    6e7c <deflateNoCompression+0x31>
    out->data[pos + 4] = (unsigned char)(NLEN >> 8u);
    lodepng_memcpy(out->data + pos + 5, data + datapos, LEN);
    datapos += LEN;
  }

  return 0;
    6fa3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    6fa8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    6fab:	c9                   	leave  
    6fac:	c3                   	ret    

00006fad <writeLZ77data>:
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
    6fad:	55                   	push   %ebp
    6fae:	89 e5                	mov    %esp,%ebp
    6fb0:	83 ec 30             	sub    $0x30,%esp
  size_t i = 0;
    6fb3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for(i = 0; i != lz77_encoded->size; ++i) {
    6fba:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    6fc1:	e9 10 01 00 00       	jmp    70d6 <writeLZ77data+0x129>
    unsigned val = lz77_encoded->data[i];
    6fc6:	8b 45 0c             	mov    0xc(%ebp),%eax
    6fc9:	8b 00                	mov    (%eax),%eax
    6fcb:	8b 55 fc             	mov    -0x4(%ebp),%edx
    6fce:	c1 e2 02             	shl    $0x2,%edx
    6fd1:	01 d0                	add    %edx,%eax
    6fd3:	8b 00                	mov    (%eax),%eax
    6fd5:	89 45 f8             	mov    %eax,-0x8(%ebp)
    writeBitsReversed(writer, tree_ll->codes[val], tree_ll->lengths[val]);
    6fd8:	8b 45 10             	mov    0x10(%ebp),%eax
    6fdb:	8b 40 04             	mov    0x4(%eax),%eax
    6fde:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6fe1:	c1 e2 02             	shl    $0x2,%edx
    6fe4:	01 d0                	add    %edx,%eax
    6fe6:	8b 00                	mov    (%eax),%eax
    6fe8:	89 c1                	mov    %eax,%ecx
    6fea:	8b 45 10             	mov    0x10(%ebp),%eax
    6fed:	8b 00                	mov    (%eax),%eax
    6fef:	8b 55 f8             	mov    -0x8(%ebp),%edx
    6ff2:	c1 e2 02             	shl    $0x2,%edx
    6ff5:	01 d0                	add    %edx,%eax
    6ff7:	8b 00                	mov    (%eax),%eax
    6ff9:	51                   	push   %ecx
    6ffa:	50                   	push   %eax
    6ffb:	ff 75 08             	pushl  0x8(%ebp)
    6ffe:	e8 60 cc ff ff       	call   3c63 <writeBitsReversed>
    7003:	83 c4 0c             	add    $0xc,%esp
    if(val > 256) /*for a length code, 3 more things have to be added*/ {
    7006:	81 7d f8 00 01 00 00 	cmpl   $0x100,-0x8(%ebp)
    700d:	0f 86 bf 00 00 00    	jbe    70d2 <writeLZ77data+0x125>
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
    7013:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7016:	2d 01 01 00 00       	sub    $0x101,%eax
    701b:	89 45 f4             	mov    %eax,-0xc(%ebp)
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
    701e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7021:	8b 04 85 80 a0 01 00 	mov    0x1a080(,%eax,4),%eax
    7028:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned length_extra_bits = lz77_encoded->data[++i];
    702b:	8b 45 0c             	mov    0xc(%ebp),%eax
    702e:	8b 00                	mov    (%eax),%eax
    7030:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7034:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7037:	c1 e2 02             	shl    $0x2,%edx
    703a:	01 d0                	add    %edx,%eax
    703c:	8b 00                	mov    (%eax),%eax
    703e:	89 45 ec             	mov    %eax,-0x14(%ebp)

      unsigned distance_code = lz77_encoded->data[++i];
    7041:	8b 45 0c             	mov    0xc(%ebp),%eax
    7044:	8b 00                	mov    (%eax),%eax
    7046:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    704a:	8b 55 fc             	mov    -0x4(%ebp),%edx
    704d:	c1 e2 02             	shl    $0x2,%edx
    7050:	01 d0                	add    %edx,%eax
    7052:	8b 00                	mov    (%eax),%eax
    7054:	89 45 e8             	mov    %eax,-0x18(%ebp)

      unsigned distance_index = distance_code;
    7057:	8b 45 e8             	mov    -0x18(%ebp),%eax
    705a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
    705d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7060:	8b 04 85 80 a1 01 00 	mov    0x1a180(,%eax,4),%eax
    7067:	89 45 e0             	mov    %eax,-0x20(%ebp)
      unsigned distance_extra_bits = lz77_encoded->data[++i];
    706a:	8b 45 0c             	mov    0xc(%ebp),%eax
    706d:	8b 00                	mov    (%eax),%eax
    706f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    7073:	8b 55 fc             	mov    -0x4(%ebp),%edx
    7076:	c1 e2 02             	shl    $0x2,%edx
    7079:	01 d0                	add    %edx,%eax
    707b:	8b 00                	mov    (%eax),%eax
    707d:	89 45 dc             	mov    %eax,-0x24(%ebp)

      writeBits(writer, length_extra_bits, n_length_extra_bits);
    7080:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7083:	50                   	push   %eax
    7084:	ff 75 ec             	pushl  -0x14(%ebp)
    7087:	ff 75 08             	pushl  0x8(%ebp)
    708a:	e8 40 ca ff ff       	call   3acf <writeBits>
    708f:	83 c4 0c             	add    $0xc,%esp
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
    7092:	8b 45 14             	mov    0x14(%ebp),%eax
    7095:	8b 40 04             	mov    0x4(%eax),%eax
    7098:	8b 55 e8             	mov    -0x18(%ebp),%edx
    709b:	c1 e2 02             	shl    $0x2,%edx
    709e:	01 d0                	add    %edx,%eax
    70a0:	8b 00                	mov    (%eax),%eax
    70a2:	89 c1                	mov    %eax,%ecx
    70a4:	8b 45 14             	mov    0x14(%ebp),%eax
    70a7:	8b 00                	mov    (%eax),%eax
    70a9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    70ac:	c1 e2 02             	shl    $0x2,%edx
    70af:	01 d0                	add    %edx,%eax
    70b1:	8b 00                	mov    (%eax),%eax
    70b3:	51                   	push   %ecx
    70b4:	50                   	push   %eax
    70b5:	ff 75 08             	pushl  0x8(%ebp)
    70b8:	e8 a6 cb ff ff       	call   3c63 <writeBitsReversed>
    70bd:	83 c4 0c             	add    $0xc,%esp
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    70c0:	8b 45 e0             	mov    -0x20(%ebp),%eax
    70c3:	50                   	push   %eax
    70c4:	ff 75 dc             	pushl  -0x24(%ebp)
    70c7:	ff 75 08             	pushl  0x8(%ebp)
    70ca:	e8 00 ca ff ff       	call   3acf <writeBits>
    70cf:	83 c4 0c             	add    $0xc,%esp
tree_d: the tree for distance codes.
*/
static void writeLZ77data(LodePNGBitWriter* writer, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d) {
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i) {
    70d2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    70d6:	8b 45 0c             	mov    0xc(%ebp),%eax
    70d9:	8b 40 04             	mov    0x4(%eax),%eax
    70dc:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    70df:	0f 85 e1 fe ff ff    	jne    6fc6 <writeLZ77data+0x19>
      writeBits(writer, length_extra_bits, n_length_extra_bits);
      writeBitsReversed(writer, tree_d->codes[distance_code], tree_d->lengths[distance_code]);
      writeBits(writer, distance_extra_bits, n_distance_extra_bits);
    }
  }
}
    70e5:	90                   	nop
    70e6:	c9                   	leave  
    70e7:	c3                   	ret    

000070e8 <deflateDynamic>:

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(LodePNGBitWriter* writer, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, unsigned final) {
    70e8:	55                   	push   %ebp
    70e9:	89 e5                	mov    %esp,%ebp
    70eb:	53                   	push   %ebx
    70ec:	81 ec b4 00 00 00    	sub    $0xb4,%esp
  unsigned error = 0;
    70f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  unsigned* frequencies_ll = 0; /*frequency of lit,len codes*/
    70f9:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  unsigned* frequencies_d = 0; /*frequency of dist codes*/
    7100:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  unsigned* frequencies_cl = 0; /*frequency of code length codes*/
    7107:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  unsigned* bitlen_lld = 0; /*lit,len,dist code lengths (int bits), literally (without repeat codes).*/
    710e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  unsigned* bitlen_lld_e = 0; /*bitlen_lld encoded with repeat codes (this is a rudimentary run length compression)*/
    7115:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t datasize = dataend - datapos;
    711c:	8b 45 18             	mov    0x18(%ebp),%eax
    711f:	2b 45 14             	sub    0x14(%ebp),%eax
    7122:	89 45 c8             	mov    %eax,-0x38(%ebp)
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
    7125:	8b 45 20             	mov    0x20(%ebp),%eax
    7128:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  size_t i;
  size_t numcodes_ll, numcodes_d, numcodes_lld, numcodes_lld_e, numcodes_cl;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
    712b:	8d 45 90             	lea    -0x70(%ebp),%eax
    712e:	50                   	push   %eax
    712f:	e8 a4 c6 ff ff       	call   37d8 <uivector_init>
    7134:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_ll);
    7137:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    713d:	50                   	push   %eax
    713e:	e8 98 d3 ff ff       	call   44db <HuffmanTree_init>
    7143:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    7146:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    714c:	50                   	push   %eax
    714d:	e8 89 d3 ff ff       	call   44db <HuffmanTree_init>
    7152:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_cl);
    7155:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    715b:	50                   	push   %eax
    715c:	e8 7a d3 ff ff       	call   44db <HuffmanTree_init>
    7161:	83 c4 04             	add    $0x4,%esp
  /* could fit on stack, but >1KB is on the larger side so allocate instead */
  frequencies_ll = (unsigned*)lodepng_malloc(286 * sizeof(*frequencies_ll));
    7164:	83 ec 0c             	sub    $0xc,%esp
    7167:	68 78 04 00 00       	push   $0x478
    716c:	e8 76 c4 ff ff       	call   35e7 <lodepng_malloc>
    7171:	83 c4 10             	add    $0x10,%esp
    7174:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  frequencies_d = (unsigned*)lodepng_malloc(30 * sizeof(*frequencies_d));
    7177:	83 ec 0c             	sub    $0xc,%esp
    717a:	6a 78                	push   $0x78
    717c:	e8 66 c4 ff ff       	call   35e7 <lodepng_malloc>
    7181:	83 c4 10             	add    $0x10,%esp
    7184:	89 45 d0             	mov    %eax,-0x30(%ebp)
  frequencies_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    7187:	83 ec 0c             	sub    $0xc,%esp
    718a:	6a 4c                	push   $0x4c
    718c:	e8 56 c4 ff ff       	call   35e7 <lodepng_malloc>
    7191:	83 c4 10             	add    $0x10,%esp
    7194:	89 45 cc             	mov    %eax,-0x34(%ebp)

  if(!frequencies_ll || !frequencies_d || !frequencies_cl) error = 83; /*alloc fail*/
    7197:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    719b:	74 0c                	je     71a9 <deflateDynamic+0xc1>
    719d:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
    71a1:	74 06                	je     71a9 <deflateDynamic+0xc1>
    71a3:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
    71a7:	75 07                	jne    71b0 <deflateDynamic+0xc8>
    71a9:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error) {
    71b0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    71b4:	0f 85 f6 07 00 00    	jne    79b0 <deflateDynamic+0x8c8>
    lodepng_memset(frequencies_ll, 0, 286 * sizeof(*frequencies_ll));
    71ba:	83 ec 04             	sub    $0x4,%esp
    71bd:	68 78 04 00 00       	push   $0x478
    71c2:	6a 00                	push   $0x0
    71c4:	ff 75 d4             	pushl  -0x2c(%ebp)
    71c7:	e8 8c c4 ff ff       	call   3658 <lodepng_memset>
    71cc:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_d, 0, 30 * sizeof(*frequencies_d));
    71cf:	83 ec 04             	sub    $0x4,%esp
    71d2:	6a 78                	push   $0x78
    71d4:	6a 00                	push   $0x0
    71d6:	ff 75 d0             	pushl  -0x30(%ebp)
    71d9:	e8 7a c4 ff ff       	call   3658 <lodepng_memset>
    71de:	83 c4 10             	add    $0x10,%esp
    lodepng_memset(frequencies_cl, 0, NUM_CODE_LENGTH_CODES * sizeof(*frequencies_cl));
    71e1:	83 ec 04             	sub    $0x4,%esp
    71e4:	6a 4c                	push   $0x4c
    71e6:	6a 00                	push   $0x0
    71e8:	ff 75 cc             	pushl  -0x34(%ebp)
    71eb:	e8 68 c4 ff ff       	call   3658 <lodepng_memset>
    71f0:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) {
    71f3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    71f6:	8b 40 04             	mov    0x4(%eax),%eax
    71f9:	85 c0                	test   %eax,%eax
    71fb:	74 45                	je     7242 <deflateDynamic+0x15a>
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    71fd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7200:	8b 58 14             	mov    0x14(%eax),%ebx
    7203:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7206:	8b 48 10             	mov    0x10(%eax),%ecx
    7209:	8b 45 1c             	mov    0x1c(%ebp),%eax
    720c:	8b 50 0c             	mov    0xc(%eax),%edx
    720f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7212:	8b 40 08             	mov    0x8(%eax),%eax
    7215:	83 ec 0c             	sub    $0xc,%esp
    7218:	53                   	push   %ebx
    7219:	51                   	push   %ecx
    721a:	52                   	push   %edx
    721b:	50                   	push   %eax
    721c:	ff 75 18             	pushl  0x18(%ebp)
    721f:	ff 75 14             	pushl  0x14(%ebp)
    7222:	ff 75 10             	pushl  0x10(%ebp)
    7225:	ff 75 0c             	pushl  0xc(%ebp)
    7228:	8d 45 90             	lea    -0x70(%ebp),%eax
    722b:	50                   	push   %eax
    722c:	e8 bd f6 ff ff       	call   68ee <encodeLZ77>
    7231:	83 c4 30             	add    $0x30,%esp
    7234:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    7237:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    723b:	74 59                	je     7296 <deflateDynamic+0x1ae>
    723d:	e9 6e 07 00 00       	jmp    79b0 <deflateDynamic+0x8c8>
    } else {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
    7242:	83 ec 08             	sub    $0x8,%esp
    7245:	ff 75 c8             	pushl  -0x38(%ebp)
    7248:	8d 45 90             	lea    -0x70(%ebp),%eax
    724b:	50                   	push   %eax
    724c:	e8 17 c5 ff ff       	call   3768 <uivector_resize>
    7251:	83 c4 10             	add    $0x10,%esp
    7254:	85 c0                	test   %eax,%eax
    7256:	75 0c                	jne    7264 <deflateDynamic+0x17c>
    7258:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    725f:	e9 4c 07 00 00       	jmp    79b0 <deflateDynamic+0x8c8>
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    7264:	8b 45 14             	mov    0x14(%ebp),%eax
    7267:	89 45 e8             	mov    %eax,-0x18(%ebp)
    726a:	eb 22                	jmp    728e <deflateDynamic+0x1a6>
    726c:	8b 55 90             	mov    -0x70(%ebp),%edx
    726f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7272:	2b 45 14             	sub    0x14(%ebp),%eax
    7275:	c1 e0 02             	shl    $0x2,%eax
    7278:	01 c2                	add    %eax,%edx
    727a:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    727d:	8b 45 10             	mov    0x10(%ebp),%eax
    7280:	01 c8                	add    %ecx,%eax
    7282:	0f b6 00             	movzbl (%eax),%eax
    7285:	0f b6 c0             	movzbl %al,%eax
    7288:	89 02                	mov    %eax,(%edx)
    728a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    728e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7291:	3b 45 18             	cmp    0x18(%ebp),%eax
    7294:	7c d6                	jl     726c <deflateDynamic+0x184>
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    7296:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    729d:	eb 60                	jmp    72ff <deflateDynamic+0x217>
      unsigned symbol = lz77_encoded.data[i];
    729f:	8b 45 90             	mov    -0x70(%ebp),%eax
    72a2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    72a5:	c1 e2 02             	shl    $0x2,%edx
    72a8:	01 d0                	add    %edx,%eax
    72aa:	8b 00                	mov    (%eax),%eax
    72ac:	89 45 c0             	mov    %eax,-0x40(%ebp)
      ++frequencies_ll[symbol];
    72af:	8b 45 c0             	mov    -0x40(%ebp),%eax
    72b2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72b9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    72bc:	01 d0                	add    %edx,%eax
    72be:	8b 10                	mov    (%eax),%edx
    72c0:	83 c2 01             	add    $0x1,%edx
    72c3:	89 10                	mov    %edx,(%eax)
      if(symbol > 256) {
    72c5:	81 7d c0 00 01 00 00 	cmpl   $0x100,-0x40(%ebp)
    72cc:	76 2d                	jbe    72fb <deflateDynamic+0x213>
        unsigned dist = lz77_encoded.data[i + 2];
    72ce:	8b 45 90             	mov    -0x70(%ebp),%eax
    72d1:	8b 55 e8             	mov    -0x18(%ebp),%edx
    72d4:	83 c2 02             	add    $0x2,%edx
    72d7:	c1 e2 02             	shl    $0x2,%edx
    72da:	01 d0                	add    %edx,%eax
    72dc:	8b 00                	mov    (%eax),%eax
    72de:	89 45 bc             	mov    %eax,-0x44(%ebp)
        ++frequencies_d[dist];
    72e1:	8b 45 bc             	mov    -0x44(%ebp),%eax
    72e4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    72eb:	8b 45 d0             	mov    -0x30(%ebp),%eax
    72ee:	01 d0                	add    %edx,%eax
    72f0:	8b 10                	mov    (%eax),%edx
    72f2:	83 c2 01             	add    $0x1,%edx
    72f5:	89 10                	mov    %edx,(%eax)
        i += 3;
    72f7:	83 45 e8 03          	addl   $0x3,-0x18(%ebp)
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; ++i) lz77_encoded.data[i - datapos] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i != lz77_encoded.size; ++i) {
    72fb:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    72ff:	8b 45 94             	mov    -0x6c(%ebp),%eax
    7302:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7305:	75 98                	jne    729f <deflateDynamic+0x1b7>
        unsigned dist = lz77_encoded.data[i + 2];
        ++frequencies_d[dist];
        i += 3;
      }
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/
    7307:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    730a:	05 00 04 00 00       	add    $0x400,%eax
    730f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    7315:	83 ec 0c             	sub    $0xc,%esp
    7318:	6a 0f                	push   $0xf
    731a:	68 1e 01 00 00       	push   $0x11e
    731f:	68 01 01 00 00       	push   $0x101
    7324:	ff 75 d4             	pushl  -0x2c(%ebp)
    7327:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    732d:	50                   	push   %eax
    732e:	e8 e0 e1 ff ff       	call   5513 <HuffmanTree_makeFromFrequencies>
    7333:	83 c4 20             	add    $0x20,%esp
    7336:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7339:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    733d:	0f 85 66 06 00 00    	jne    79a9 <deflateDynamic+0x8c1>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    7343:	83 ec 0c             	sub    $0xc,%esp
    7346:	6a 0f                	push   $0xf
    7348:	6a 1e                	push   $0x1e
    734a:	6a 02                	push   $0x2
    734c:	ff 75 d0             	pushl  -0x30(%ebp)
    734f:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    7355:	50                   	push   %eax
    7356:	e8 b8 e1 ff ff       	call   5513 <HuffmanTree_makeFromFrequencies>
    735b:	83 c4 20             	add    $0x20,%esp
    735e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) break;
    7361:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7365:	0f 85 41 06 00 00    	jne    79ac <deflateDynamic+0x8c4>

    numcodes_ll = LODEPNG_MIN(tree_ll.numcodes, 286);
    736b:	8b 45 84             	mov    -0x7c(%ebp),%eax
    736e:	ba 1e 01 00 00       	mov    $0x11e,%edx
    7373:	3d 1e 01 00 00       	cmp    $0x11e,%eax
    7378:	0f 47 c2             	cmova  %edx,%eax
    737b:	89 45 b8             	mov    %eax,-0x48(%ebp)
    numcodes_d = LODEPNG_MIN(tree_d.numcodes, 30);
    737e:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
    7384:	ba 1e 00 00 00       	mov    $0x1e,%edx
    7389:	83 f8 1e             	cmp    $0x1e,%eax
    738c:	0f 47 c2             	cmova  %edx,%eax
    738f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    /*store the code lengths of both generated trees in bitlen_lld*/
    numcodes_lld = numcodes_ll + numcodes_d;
    7392:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7395:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    7398:	01 d0                	add    %edx,%eax
    739a:	89 45 b0             	mov    %eax,-0x50(%ebp)
    bitlen_lld = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld));
    739d:	8b 45 b0             	mov    -0x50(%ebp),%eax
    73a0:	c1 e0 02             	shl    $0x2,%eax
    73a3:	83 ec 0c             	sub    $0xc,%esp
    73a6:	50                   	push   %eax
    73a7:	e8 3b c2 ff ff       	call   35e7 <lodepng_malloc>
    73ac:	83 c4 10             	add    $0x10,%esp
    73af:	89 45 f0             	mov    %eax,-0x10(%ebp)
    /*numcodes_lld_e never needs more size than bitlen_lld*/
    bitlen_lld_e = (unsigned*)lodepng_malloc(numcodes_lld * sizeof(*bitlen_lld_e));
    73b2:	8b 45 b0             	mov    -0x50(%ebp),%eax
    73b5:	c1 e0 02             	shl    $0x2,%eax
    73b8:	83 ec 0c             	sub    $0xc,%esp
    73bb:	50                   	push   %eax
    73bc:	e8 26 c2 ff ff       	call   35e7 <lodepng_malloc>
    73c1:	83 c4 10             	add    $0x10,%esp
    73c4:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!bitlen_lld || !bitlen_lld_e) ERROR_BREAK(83); /*alloc fail*/
    73c7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    73cb:	74 06                	je     73d3 <deflateDynamic+0x2eb>
    73cd:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    73d1:	75 0c                	jne    73df <deflateDynamic+0x2f7>
    73d3:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    73da:	e9 d1 05 00 00       	jmp    79b0 <deflateDynamic+0x8c8>
    numcodes_lld_e = 0;
    73df:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    73e6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    73ed:	eb 25                	jmp    7414 <deflateDynamic+0x32c>
    73ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
    73f2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    73f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    73fc:	01 c2                	add    %eax,%edx
    73fe:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7404:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7407:	c1 e1 02             	shl    $0x2,%ecx
    740a:	01 c8                	add    %ecx,%eax
    740c:	8b 00                	mov    (%eax),%eax
    740e:	89 02                	mov    %eax,(%edx)
    7410:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7414:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7417:	3b 45 b8             	cmp    -0x48(%ebp),%eax
    741a:	75 d3                	jne    73ef <deflateDynamic+0x307>
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];
    741c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7423:	eb 2a                	jmp    744f <deflateDynamic+0x367>
    7425:	8b 55 b8             	mov    -0x48(%ebp),%edx
    7428:	8b 45 e8             	mov    -0x18(%ebp),%eax
    742b:	01 d0                	add    %edx,%eax
    742d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7434:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7437:	01 c2                	add    %eax,%edx
    7439:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
    743f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
    7442:	c1 e1 02             	shl    $0x2,%ecx
    7445:	01 c8                	add    %ecx,%eax
    7447:	8b 00                	mov    (%eax),%eax
    7449:	89 02                	mov    %eax,(%edx)
    744b:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    744f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7452:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
    7455:	75 ce                	jne    7425 <deflateDynamic+0x33d>

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    7457:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    745e:	e9 3b 02 00 00       	jmp    769e <deflateDynamic+0x5b6>
      unsigned j = 0; /*amount of repetitions*/
    7463:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      while(i + j + 1 < numcodes_lld && bitlen_lld[i + j + 1] == bitlen_lld[i]) ++j;
    746a:	eb 04                	jmp    7470 <deflateDynamic+0x388>
    746c:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
    7470:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7473:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7476:	01 d0                	add    %edx,%eax
    7478:	8d 50 01             	lea    0x1(%eax),%edx
    747b:	8b 45 b0             	mov    -0x50(%ebp),%eax
    747e:	39 c2                	cmp    %eax,%edx
    7480:	73 2e                	jae    74b0 <deflateDynamic+0x3c8>
    7482:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7485:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7488:	01 d0                	add    %edx,%eax
    748a:	83 c0 01             	add    $0x1,%eax
    748d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7494:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7497:	01 d0                	add    %edx,%eax
    7499:	8b 10                	mov    (%eax),%edx
    749b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    749e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    74a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    74a8:	01 c8                	add    %ecx,%eax
    74aa:	8b 00                	mov    (%eax),%eax
    74ac:	39 c2                	cmp    %eax,%edx
    74ae:	74 bc                	je     746c <deflateDynamic+0x384>

      if(bitlen_lld[i] == 0 && j >= 2) /*repeat code for zeroes*/ {
    74b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    74b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
    74bd:	01 d0                	add    %edx,%eax
    74bf:	8b 00                	mov    (%eax),%eax
    74c1:	85 c0                	test   %eax,%eax
    74c3:	0f 85 a9 00 00 00    	jne    7572 <deflateDynamic+0x48a>
    74c9:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
    74cd:	0f 86 9f 00 00 00    	jbe    7572 <deflateDynamic+0x48a>
        ++j; /*include the first zero*/
    74d3:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/ {
    74d7:	83 7d dc 0a          	cmpl   $0xa,-0x24(%ebp)
    74db:	77 3a                	ja     7517 <deflateDynamic+0x42f>
          bitlen_lld_e[numcodes_lld_e++] = 17;
    74dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    74e0:	8d 50 01             	lea    0x1(%eax),%edx
    74e3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    74e6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    74ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
    74f0:	01 d0                	add    %edx,%eax
    74f2:	c7 00 11 00 00 00    	movl   $0x11,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 3;
    74f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    74fb:	8d 50 01             	lea    0x1(%eax),%edx
    74fe:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7501:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7508:	8b 45 ec             	mov    -0x14(%ebp),%eax
    750b:	01 d0                	add    %edx,%eax
    750d:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7510:	83 ea 03             	sub    $0x3,%edx
    7513:	89 10                	mov    %edx,(%eax)
    7515:	eb 48                	jmp    755f <deflateDynamic+0x477>
        } else /*repeat code 18 supports max 138 zeroes*/ {
          if(j > 138) j = 138;
    7517:	81 7d dc 8a 00 00 00 	cmpl   $0x8a,-0x24(%ebp)
    751e:	76 07                	jbe    7527 <deflateDynamic+0x43f>
    7520:	c7 45 dc 8a 00 00 00 	movl   $0x8a,-0x24(%ebp)
          bitlen_lld_e[numcodes_lld_e++] = 18;
    7527:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    752a:	8d 50 01             	lea    0x1(%eax),%edx
    752d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7530:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7537:	8b 45 ec             	mov    -0x14(%ebp),%eax
    753a:	01 d0                	add    %edx,%eax
    753c:	c7 00 12 00 00 00    	movl   $0x12,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = j - 11;
    7542:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7545:	8d 50 01             	lea    0x1(%eax),%edx
    7548:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    754b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7552:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7555:	01 d0                	add    %edx,%eax
    7557:	8b 55 dc             	mov    -0x24(%ebp),%edx
    755a:	83 ea 0b             	sub    $0xb,%edx
    755d:	89 10                	mov    %edx,(%eax)
        }
        i += (j - 1);
    755f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7562:	8b 45 dc             	mov    -0x24(%ebp),%eax
    7565:	01 d0                	add    %edx,%eax
    7567:	83 e8 01             	sub    $0x1,%eax
    756a:	89 45 e8             	mov    %eax,-0x18(%ebp)
    756d:	e9 28 01 00 00       	jmp    769a <deflateDynamic+0x5b2>
      } else if(j >= 3) /*repeat code for value other than zero*/ {
    7572:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
    7576:	0f 86 f6 00 00 00    	jbe    7672 <deflateDynamic+0x58a>
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
    757c:	8b 45 dc             	mov    -0x24(%ebp),%eax
    757f:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    7584:	f7 e2                	mul    %edx
    7586:	89 d0                	mov    %edx,%eax
    7588:	c1 e8 02             	shr    $0x2,%eax
    758b:	89 45 ac             	mov    %eax,-0x54(%ebp)
    758e:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    7591:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    7596:	89 c8                	mov    %ecx,%eax
    7598:	f7 e2                	mul    %edx
    759a:	c1 ea 02             	shr    $0x2,%edx
    759d:	89 d0                	mov    %edx,%eax
    759f:	01 c0                	add    %eax,%eax
    75a1:	01 d0                	add    %edx,%eax
    75a3:	01 c0                	add    %eax,%eax
    75a5:	29 c1                	sub    %eax,%ecx
    75a7:	89 c8                	mov    %ecx,%eax
    75a9:	89 45 a8             	mov    %eax,-0x58(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    75ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    75af:	8d 50 01             	lea    0x1(%eax),%edx
    75b2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    75b5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75bc:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75bf:	01 c2                	add    %eax,%edx
    75c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    75c4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    75cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
    75ce:	01 c8                	add    %ecx,%eax
    75d0:	8b 00                	mov    (%eax),%eax
    75d2:	89 02                	mov    %eax,(%edx)
        for(k = 0; k < num; ++k) {
    75d4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    75db:	eb 3a                	jmp    7617 <deflateDynamic+0x52f>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    75dd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    75e0:	8d 50 01             	lea    0x1(%eax),%edx
    75e3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    75e6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    75ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
    75f0:	01 d0                	add    %edx,%eax
    75f2:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
    75f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    75fb:	8d 50 01             	lea    0x1(%eax),%edx
    75fe:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7601:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7608:	8b 45 ec             	mov    -0x14(%ebp),%eax
    760b:	01 d0                	add    %edx,%eax
    760d:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
        i += (j - 1);
      } else if(j >= 3) /*repeat code for value other than zero*/ {
        size_t k;
        unsigned num = j / 6u, rest = j % 6u;
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
        for(k = 0; k < num; ++k) {
    7613:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
    7617:	8b 45 d8             	mov    -0x28(%ebp),%eax
    761a:	3b 45 ac             	cmp    -0x54(%ebp),%eax
    761d:	72 be                	jb     75dd <deflateDynamic+0x4f5>
          bitlen_lld_e[numcodes_lld_e++] = 16;
          bitlen_lld_e[numcodes_lld_e++] = 6 - 3;
        }
        if(rest >= 3) {
    761f:	83 7d a8 02          	cmpl   $0x2,-0x58(%ebp)
    7623:	76 3a                	jbe    765f <deflateDynamic+0x577>
          bitlen_lld_e[numcodes_lld_e++] = 16;
    7625:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7628:	8d 50 01             	lea    0x1(%eax),%edx
    762b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    762e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7635:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7638:	01 d0                	add    %edx,%eax
    763a:	c7 00 10 00 00 00    	movl   $0x10,(%eax)
          bitlen_lld_e[numcodes_lld_e++] = rest - 3;
    7640:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7643:	8d 50 01             	lea    0x1(%eax),%edx
    7646:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    7649:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7650:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7653:	01 d0                	add    %edx,%eax
    7655:	8b 55 a8             	mov    -0x58(%ebp),%edx
    7658:	83 ea 03             	sub    $0x3,%edx
    765b:	89 10                	mov    %edx,(%eax)
    765d:	eb 06                	jmp    7665 <deflateDynamic+0x57d>
        }
        else j -= rest;
    765f:	8b 45 a8             	mov    -0x58(%ebp),%eax
    7662:	29 45 dc             	sub    %eax,-0x24(%ebp)
        i += j;
    7665:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7668:	8b 45 dc             	mov    -0x24(%ebp),%eax
    766b:	01 d0                	add    %edx,%eax
    766d:	89 45 e8             	mov    %eax,-0x18(%ebp)
    7670:	eb 28                	jmp    769a <deflateDynamic+0x5b2>
      } else /*too short to benefit from repeat code*/ {
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
    7672:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7675:	8d 50 01             	lea    0x1(%eax),%edx
    7678:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    767b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7682:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7685:	01 c2                	add    %eax,%edx
    7687:	8b 45 e8             	mov    -0x18(%ebp),%eax
    768a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    7691:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7694:	01 c8                	add    %ecx,%eax
    7696:	8b 00                	mov    (%eax),%eax
    7698:	89 02                	mov    %eax,(%edx)
    for(i = 0; i != numcodes_ll; ++i) bitlen_lld[i] = tree_ll.lengths[i];
    for(i = 0; i != numcodes_d; ++i) bitlen_lld[numcodes_ll + i] = tree_d.lengths[i];

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i != numcodes_lld; ++i) {
    769a:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    769e:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76a1:	3b 45 b0             	cmp    -0x50(%ebp),%eax
    76a4:	0f 85 b9 fd ff ff    	jne    7463 <deflateDynamic+0x37b>
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    76aa:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    76b1:	eb 42                	jmp    76f5 <deflateDynamic+0x60d>
      ++frequencies_cl[bitlen_lld_e[i]];
    76b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76b6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76c0:	01 d0                	add    %edx,%eax
    76c2:	8b 00                	mov    (%eax),%eax
    76c4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76cb:	8b 45 cc             	mov    -0x34(%ebp),%eax
    76ce:	01 d0                	add    %edx,%eax
    76d0:	8b 10                	mov    (%eax),%edx
    76d2:	83 c2 01             	add    $0x1,%edx
    76d5:	89 10                	mov    %edx,(%eax)
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    76d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76da:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    76e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
    76e4:	01 d0                	add    %edx,%eax
    76e6:	8b 00                	mov    (%eax),%eax
    76e8:	83 f8 0f             	cmp    $0xf,%eax
    76eb:	76 04                	jbe    76f1 <deflateDynamic+0x609>
    76ed:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
        bitlen_lld_e[numcodes_lld_e++] = bitlen_lld[i];
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    76f1:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    76f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    76f8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    76fb:	75 b6                	jne    76b3 <deflateDynamic+0x5cb>
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
    76fd:	83 ec 0c             	sub    $0xc,%esp
    7700:	6a 07                	push   $0x7
    7702:	6a 13                	push   $0x13
    7704:	6a 13                	push   $0x13
    7706:	ff 75 cc             	pushl  -0x34(%ebp)
    7709:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    770f:	50                   	push   %eax
    7710:	e8 fe dd ff ff       	call   5513 <HuffmanTree_makeFromFrequencies>
    7715:	83 c4 20             	add    $0x20,%esp
    7718:	89 45 f4             	mov    %eax,-0xc(%ebp)
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    771b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    771f:	0f 85 8a 02 00 00    	jne    79af <deflateDynamic+0x8c7>

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    7725:	c7 45 e0 13 00 00 00 	movl   $0x13,-0x20(%ebp)
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    772c:	eb 04                	jmp    7732 <deflateDynamic+0x64a>
      numcodes_cl--;
    772e:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
    if(error) break;

    /*compute amount of code-length-code-lengths to output*/
    numcodes_cl = NUM_CODE_LENGTH_CODES;
    /*trim zeros at the end (using CLCL_ORDER), but minimum size must be 4 (see HCLEN below)*/
    while(numcodes_cl > 4u && tree_cl.lengths[CLCL_ORDER[numcodes_cl - 1u]] == 0) {
    7732:	8b 45 e0             	mov    -0x20(%ebp),%eax
    7735:	83 f8 04             	cmp    $0x4,%eax
    7738:	76 1e                	jbe    7758 <deflateDynamic+0x670>
    773a:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7740:	8b 55 e0             	mov    -0x20(%ebp),%edx
    7743:	83 ea 01             	sub    $0x1,%edx
    7746:	8b 14 95 00 a2 01 00 	mov    0x1a200(,%edx,4),%edx
    774d:	c1 e2 02             	shl    $0x2,%edx
    7750:	01 d0                	add    %edx,%eax
    7752:	8b 00                	mov    (%eax),%eax
    7754:	85 c0                	test   %eax,%eax
    7756:	74 d6                	je     772e <deflateDynamic+0x646>
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    writeBits(writer, BFINAL, 1);
    7758:	83 ec 04             	sub    $0x4,%esp
    775b:	6a 01                	push   $0x1
    775d:	ff 75 c4             	pushl  -0x3c(%ebp)
    7760:	ff 75 08             	pushl  0x8(%ebp)
    7763:	e8 67 c3 ff ff       	call   3acf <writeBits>
    7768:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*first bit of BTYPE "dynamic"*/
    776b:	83 ec 04             	sub    $0x4,%esp
    776e:	6a 01                	push   $0x1
    7770:	6a 00                	push   $0x0
    7772:	ff 75 08             	pushl  0x8(%ebp)
    7775:	e8 55 c3 ff ff       	call   3acf <writeBits>
    777a:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*second bit of BTYPE "dynamic"*/
    777d:	83 ec 04             	sub    $0x4,%esp
    7780:	6a 01                	push   $0x1
    7782:	6a 01                	push   $0x1
    7784:	ff 75 08             	pushl  0x8(%ebp)
    7787:	e8 43 c3 ff ff       	call   3acf <writeBits>
    778c:	83 c4 10             	add    $0x10,%esp

    /*write the HLIT, HDIST and HCLEN values*/
    /*all three sizes take trimmed ending zeroes into account, done either by HuffmanTree_makeFromFrequencies
    or in the loop for numcodes_cl above, which saves space. */
    HLIT = (unsigned)(numcodes_ll - 257);
    778f:	8b 45 b8             	mov    -0x48(%ebp),%eax
    7792:	2d 01 01 00 00       	sub    $0x101,%eax
    7797:	89 45 a4             	mov    %eax,-0x5c(%ebp)
    HDIST = (unsigned)(numcodes_d - 1);
    779a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
    779d:	83 e8 01             	sub    $0x1,%eax
    77a0:	89 45 a0             	mov    %eax,-0x60(%ebp)
    HCLEN = (unsigned)(numcodes_cl - 4);
    77a3:	8b 45 e0             	mov    -0x20(%ebp),%eax
    77a6:	83 e8 04             	sub    $0x4,%eax
    77a9:	89 45 9c             	mov    %eax,-0x64(%ebp)
    writeBits(writer, HLIT, 5);
    77ac:	83 ec 04             	sub    $0x4,%esp
    77af:	6a 05                	push   $0x5
    77b1:	ff 75 a4             	pushl  -0x5c(%ebp)
    77b4:	ff 75 08             	pushl  0x8(%ebp)
    77b7:	e8 13 c3 ff ff       	call   3acf <writeBits>
    77bc:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HDIST, 5);
    77bf:	83 ec 04             	sub    $0x4,%esp
    77c2:	6a 05                	push   $0x5
    77c4:	ff 75 a0             	pushl  -0x60(%ebp)
    77c7:	ff 75 08             	pushl  0x8(%ebp)
    77ca:	e8 00 c3 ff ff       	call   3acf <writeBits>
    77cf:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, HCLEN, 4);
    77d2:	83 ec 04             	sub    $0x4,%esp
    77d5:	6a 04                	push   $0x4
    77d7:	ff 75 9c             	pushl  -0x64(%ebp)
    77da:	ff 75 08             	pushl  0x8(%ebp)
    77dd:	e8 ed c2 ff ff       	call   3acf <writeBits>
    77e2:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);
    77e5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    77ec:	eb 2c                	jmp    781a <deflateDynamic+0x732>
    77ee:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
    77f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    77f7:	8b 04 85 00 a2 01 00 	mov    0x1a200(,%eax,4),%eax
    77fe:	c1 e0 02             	shl    $0x2,%eax
    7801:	01 d0                	add    %edx,%eax
    7803:	8b 00                	mov    (%eax),%eax
    7805:	83 ec 04             	sub    $0x4,%esp
    7808:	6a 03                	push   $0x3
    780a:	50                   	push   %eax
    780b:	ff 75 08             	pushl  0x8(%ebp)
    780e:	e8 bc c2 ff ff       	call   3acf <writeBits>
    7813:	83 c4 10             	add    $0x10,%esp
    7816:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    781a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    781d:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    7820:	75 cc                	jne    77ee <deflateDynamic+0x706>

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7822:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    7829:	e9 0a 01 00 00       	jmp    7938 <deflateDynamic+0x850>
      writeBitsReversed(writer, tree_cl.codes[bitlen_lld_e[i]], tree_cl.lengths[bitlen_lld_e[i]]);
    782e:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
    7834:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7837:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    783e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7841:	01 ca                	add    %ecx,%edx
    7843:	8b 12                	mov    (%edx),%edx
    7845:	c1 e2 02             	shl    $0x2,%edx
    7848:	01 d0                	add    %edx,%eax
    784a:	8b 00                	mov    (%eax),%eax
    784c:	89 c3                	mov    %eax,%ebx
    784e:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
    7854:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7857:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
    785e:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7861:	01 ca                	add    %ecx,%edx
    7863:	8b 12                	mov    (%edx),%edx
    7865:	c1 e2 02             	shl    $0x2,%edx
    7868:	01 d0                	add    %edx,%eax
    786a:	8b 00                	mov    (%eax),%eax
    786c:	83 ec 04             	sub    $0x4,%esp
    786f:	53                   	push   %ebx
    7870:	50                   	push   %eax
    7871:	ff 75 08             	pushl  0x8(%ebp)
    7874:	e8 ea c3 ff ff       	call   3c63 <writeBitsReversed>
    7879:	83 c4 10             	add    $0x10,%esp
      /*extra bits of repeat codes*/
      if(bitlen_lld_e[i] == 16) writeBits(writer, bitlen_lld_e[++i], 2);
    787c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    787f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7886:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7889:	01 d0                	add    %edx,%eax
    788b:	8b 00                	mov    (%eax),%eax
    788d:	83 f8 10             	cmp    $0x10,%eax
    7890:	75 28                	jne    78ba <deflateDynamic+0x7d2>
    7892:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7896:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7899:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    78a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
    78a3:	01 d0                	add    %edx,%eax
    78a5:	8b 00                	mov    (%eax),%eax
    78a7:	83 ec 04             	sub    $0x4,%esp
    78aa:	6a 02                	push   $0x2
    78ac:	50                   	push   %eax
    78ad:	ff 75 08             	pushl  0x8(%ebp)
    78b0:	e8 1a c2 ff ff       	call   3acf <writeBits>
    78b5:	83 c4 10             	add    $0x10,%esp
    78b8:	eb 7a                	jmp    7934 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
    78ba:	8b 45 e8             	mov    -0x18(%ebp),%eax
    78bd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    78c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
    78c7:	01 d0                	add    %edx,%eax
    78c9:	8b 00                	mov    (%eax),%eax
    78cb:	83 f8 11             	cmp    $0x11,%eax
    78ce:	75 28                	jne    78f8 <deflateDynamic+0x810>
    78d0:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    78d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    78d7:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    78de:	8b 45 ec             	mov    -0x14(%ebp),%eax
    78e1:	01 d0                	add    %edx,%eax
    78e3:	8b 00                	mov    (%eax),%eax
    78e5:	83 ec 04             	sub    $0x4,%esp
    78e8:	6a 03                	push   $0x3
    78ea:	50                   	push   %eax
    78eb:	ff 75 08             	pushl  0x8(%ebp)
    78ee:	e8 dc c1 ff ff       	call   3acf <writeBits>
    78f3:	83 c4 10             	add    $0x10,%esp
    78f6:	eb 3c                	jmp    7934 <deflateDynamic+0x84c>
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    78f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
    78fb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    7902:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7905:	01 d0                	add    %edx,%eax
    7907:	8b 00                	mov    (%eax),%eax
    7909:	83 f8 12             	cmp    $0x12,%eax
    790c:	75 26                	jne    7934 <deflateDynamic+0x84c>
    790e:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7912:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7915:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    791c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    791f:	01 d0                	add    %edx,%eax
    7921:	8b 00                	mov    (%eax),%eax
    7923:	83 ec 04             	sub    $0x4,%esp
    7926:	6a 07                	push   $0x7
    7928:	50                   	push   %eax
    7929:	ff 75 08             	pushl  0x8(%ebp)
    792c:	e8 9e c1 ff ff       	call   3acf <writeBits>
    7931:	83 c4 10             	add    $0x10,%esp

    /*write the code lengths of the code length alphabet ("bitlen_cl")*/
    for(i = 0; i != numcodes_cl; ++i) writeBits(writer, tree_cl.lengths[CLCL_ORDER[i]], 3);

    /*write the lengths of the lit/len AND the dist alphabet*/
    for(i = 0; i != numcodes_lld_e; ++i) {
    7934:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    7938:	8b 45 e8             	mov    -0x18(%ebp),%eax
    793b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    793e:	0f 85 ea fe ff ff    	jne    782e <deflateDynamic+0x746>
      else if(bitlen_lld_e[i] == 17) writeBits(writer, bitlen_lld_e[++i], 3);
      else if(bitlen_lld_e[i] == 18) writeBits(writer, bitlen_lld_e[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7944:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    794a:	50                   	push   %eax
    794b:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    7951:	50                   	push   %eax
    7952:	8d 45 90             	lea    -0x70(%ebp),%eax
    7955:	50                   	push   %eax
    7956:	ff 75 08             	pushl  0x8(%ebp)
    7959:	e8 4f f6 ff ff       	call   6fad <writeLZ77data>
    795e:	83 c4 10             	add    $0x10,%esp
    /*error: the length of the end code 256 must be larger than 0*/
    if(tree_ll.lengths[256] == 0) ERROR_BREAK(64);
    7961:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7967:	05 00 04 00 00       	add    $0x400,%eax
    796c:	8b 00                	mov    (%eax),%eax
    796e:	85 c0                	test   %eax,%eax
    7970:	75 09                	jne    797b <deflateDynamic+0x893>
    7972:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
    7979:	eb 35                	jmp    79b0 <deflateDynamic+0x8c8>

    /*write the end code*/
    writeBitsReversed(writer, tree_ll.codes[256], tree_ll.lengths[256]);
    797b:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
    7981:	05 00 04 00 00       	add    $0x400,%eax
    7986:	8b 00                	mov    (%eax),%eax
    7988:	89 c2                	mov    %eax,%edx
    798a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
    7990:	05 00 04 00 00       	add    $0x400,%eax
    7995:	8b 00                	mov    (%eax),%eax
    7997:	83 ec 04             	sub    $0x4,%esp
    799a:	52                   	push   %edx
    799b:	50                   	push   %eax
    799c:	ff 75 08             	pushl  0x8(%ebp)
    799f:	e8 bf c2 ff ff       	call   3c63 <writeBitsReversed>
    79a4:	83 c4 10             	add    $0x10,%esp

    break; /*end of error-while*/
    79a7:	eb 07                	jmp    79b0 <deflateDynamic+0x8c8>
    }
    frequencies_ll[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll, 257, 286, 15);
    if(error) break;
    79a9:	90                   	nop
    79aa:	eb 04                	jmp    79b0 <deflateDynamic+0x8c8>
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d, 2, 30, 15);
    if(error) break;
    79ac:	90                   	nop
    79ad:	eb 01                	jmp    79b0 <deflateDynamic+0x8c8>
      if(bitlen_lld_e[i] >= 16) ++i;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl,
                                            NUM_CODE_LENGTH_CODES, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;
    79af:	90                   	nop

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
    79b0:	83 ec 0c             	sub    $0xc,%esp
    79b3:	8d 45 90             	lea    -0x70(%ebp),%eax
    79b6:	50                   	push   %eax
    79b7:	e8 73 bd ff ff       	call   372f <uivector_cleanup>
    79bc:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_ll);
    79bf:	83 ec 0c             	sub    $0xc,%esp
    79c2:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
    79c8:	50                   	push   %eax
    79c9:	e8 3a cb ff ff       	call   4508 <HuffmanTree_cleanup>
    79ce:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    79d1:	83 ec 0c             	sub    $0xc,%esp
    79d4:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    79da:	50                   	push   %eax
    79db:	e8 28 cb ff ff       	call   4508 <HuffmanTree_cleanup>
    79e0:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_cl);
    79e3:	83 ec 0c             	sub    $0xc,%esp
    79e6:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    79ec:	50                   	push   %eax
    79ed:	e8 16 cb ff ff       	call   4508 <HuffmanTree_cleanup>
    79f2:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_ll);
    79f5:	83 ec 0c             	sub    $0xc,%esp
    79f8:	ff 75 d4             	pushl  -0x2c(%ebp)
    79fb:	e8 08 bc ff ff       	call   3608 <lodepng_free>
    7a00:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_d);
    7a03:	83 ec 0c             	sub    $0xc,%esp
    7a06:	ff 75 d0             	pushl  -0x30(%ebp)
    7a09:	e8 fa bb ff ff       	call   3608 <lodepng_free>
    7a0e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(frequencies_cl);
    7a11:	83 ec 0c             	sub    $0xc,%esp
    7a14:	ff 75 cc             	pushl  -0x34(%ebp)
    7a17:	e8 ec bb ff ff       	call   3608 <lodepng_free>
    7a1c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld);
    7a1f:	83 ec 0c             	sub    $0xc,%esp
    7a22:	ff 75 f0             	pushl  -0x10(%ebp)
    7a25:	e8 de bb ff ff       	call   3608 <lodepng_free>
    7a2a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(bitlen_lld_e);
    7a2d:	83 ec 0c             	sub    $0xc,%esp
    7a30:	ff 75 ec             	pushl  -0x14(%ebp)
    7a33:	e8 d0 bb ff ff       	call   3608 <lodepng_free>
    7a38:	83 c4 10             	add    $0x10,%esp

  return error;
    7a3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7a3e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7a41:	c9                   	leave  
    7a42:	c3                   	ret    

00007a43 <deflateFixed>:

static unsigned deflateFixed(LodePNGBitWriter* writer, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, unsigned final) {
    7a43:	55                   	push   %ebp
    7a44:	89 e5                	mov    %esp,%ebp
    7a46:	53                   	push   %ebx
    7a47:	83 ec 54             	sub    $0x54,%esp
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
    7a4a:	8b 45 20             	mov    0x20(%ebp),%eax
    7a4d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned error = 0;
    7a50:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i;

  HuffmanTree_init(&tree_ll);
    7a57:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7a5a:	50                   	push   %eax
    7a5b:	e8 7b ca ff ff       	call   44db <HuffmanTree_init>
    7a60:	83 c4 04             	add    $0x4,%esp
  HuffmanTree_init(&tree_d);
    7a63:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a66:	50                   	push   %eax
    7a67:	e8 6f ca ff ff       	call   44db <HuffmanTree_init>
    7a6c:	83 c4 04             	add    $0x4,%esp

  error = generateFixedLitLenTree(&tree_ll);
    7a6f:	83 ec 0c             	sub    $0xc,%esp
    7a72:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7a75:	50                   	push   %eax
    7a76:	e8 41 db ff ff       	call   55bc <generateFixedLitLenTree>
    7a7b:	83 c4 10             	add    $0x10,%esp
    7a7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = generateFixedDistanceTree(&tree_d);
    7a81:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7a85:	75 12                	jne    7a99 <deflateFixed+0x56>
    7a87:	83 ec 0c             	sub    $0xc,%esp
    7a8a:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7a8d:	50                   	push   %eax
    7a8e:	e8 30 dc ff ff       	call   56c3 <generateFixedDistanceTree>
    7a93:	83 c4 10             	add    $0x10,%esp
    7a96:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7a99:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7a9d:	0f 85 3a 01 00 00    	jne    7bdd <deflateFixed+0x19a>
    writeBits(writer, BFINAL, 1);
    7aa3:	83 ec 04             	sub    $0x4,%esp
    7aa6:	6a 01                	push   $0x1
    7aa8:	ff 75 ec             	pushl  -0x14(%ebp)
    7aab:	ff 75 08             	pushl  0x8(%ebp)
    7aae:	e8 1c c0 ff ff       	call   3acf <writeBits>
    7ab3:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 1, 1); /*first bit of BTYPE*/
    7ab6:	83 ec 04             	sub    $0x4,%esp
    7ab9:	6a 01                	push   $0x1
    7abb:	6a 01                	push   $0x1
    7abd:	ff 75 08             	pushl  0x8(%ebp)
    7ac0:	e8 0a c0 ff ff       	call   3acf <writeBits>
    7ac5:	83 c4 10             	add    $0x10,%esp
    writeBits(writer, 0, 1); /*second bit of BTYPE*/
    7ac8:	83 ec 04             	sub    $0x4,%esp
    7acb:	6a 01                	push   $0x1
    7acd:	6a 00                	push   $0x0
    7acf:	ff 75 08             	pushl  0x8(%ebp)
    7ad2:	e8 f8 bf ff ff       	call   3acf <writeBits>
    7ad7:	83 c4 10             	add    $0x10,%esp

    if(settings->use_lz77) /*LZ77 encoded*/ {
    7ada:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7add:	8b 40 04             	mov    0x4(%eax),%eax
    7ae0:	85 c0                	test   %eax,%eax
    7ae2:	74 77                	je     7b5b <deflateFixed+0x118>
      uivector lz77_encoded;
      uivector_init(&lz77_encoded);
    7ae4:	83 ec 0c             	sub    $0xc,%esp
    7ae7:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7aea:	50                   	push   %eax
    7aeb:	e8 e8 bc ff ff       	call   37d8 <uivector_init>
    7af0:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
    7af3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7af6:	8b 58 14             	mov    0x14(%eax),%ebx
    7af9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7afc:	8b 48 10             	mov    0x10(%eax),%ecx
    7aff:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7b02:	8b 50 0c             	mov    0xc(%eax),%edx
    7b05:	8b 45 1c             	mov    0x1c(%ebp),%eax
    7b08:	8b 40 08             	mov    0x8(%eax),%eax
    7b0b:	83 ec 0c             	sub    $0xc,%esp
    7b0e:	53                   	push   %ebx
    7b0f:	51                   	push   %ecx
    7b10:	52                   	push   %edx
    7b11:	50                   	push   %eax
    7b12:	ff 75 18             	pushl  0x18(%ebp)
    7b15:	ff 75 14             	pushl  0x14(%ebp)
    7b18:	ff 75 10             	pushl  0x10(%ebp)
    7b1b:	ff 75 0c             	pushl  0xc(%ebp)
    7b1e:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7b21:	50                   	push   %eax
    7b22:	e8 c7 ed ff ff       	call   68ee <encodeLZ77>
    7b27:	83 c4 30             	add    $0x30,%esp
    7b2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
    7b2d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7b31:	75 17                	jne    7b4a <deflateFixed+0x107>
    7b33:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7b36:	50                   	push   %eax
    7b37:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7b3a:	50                   	push   %eax
    7b3b:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7b3e:	50                   	push   %eax
    7b3f:	ff 75 08             	pushl  0x8(%ebp)
    7b42:	e8 66 f4 ff ff       	call   6fad <writeLZ77data>
    7b47:	83 c4 10             	add    $0x10,%esp
      uivector_cleanup(&lz77_encoded);
    7b4a:	83 ec 0c             	sub    $0xc,%esp
    7b4d:	8d 45 b0             	lea    -0x50(%ebp),%eax
    7b50:	50                   	push   %eax
    7b51:	e8 d9 bb ff ff       	call   372f <uivector_cleanup>
    7b56:	83 c4 10             	add    $0x10,%esp
    7b59:	eb 56                	jmp    7bb1 <deflateFixed+0x16e>
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7b5b:	8b 45 14             	mov    0x14(%ebp),%eax
    7b5e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    7b61:	eb 46                	jmp    7ba9 <deflateFixed+0x166>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
    7b63:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7b66:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7b69:	8b 55 10             	mov    0x10(%ebp),%edx
    7b6c:	01 ca                	add    %ecx,%edx
    7b6e:	0f b6 12             	movzbl (%edx),%edx
    7b71:	0f b6 d2             	movzbl %dl,%edx
    7b74:	c1 e2 02             	shl    $0x2,%edx
    7b77:	01 d0                	add    %edx,%eax
    7b79:	8b 00                	mov    (%eax),%eax
    7b7b:	89 c3                	mov    %eax,%ebx
    7b7d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7b80:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    7b83:	8b 55 10             	mov    0x10(%ebp),%edx
    7b86:	01 ca                	add    %ecx,%edx
    7b88:	0f b6 12             	movzbl (%edx),%edx
    7b8b:	0f b6 d2             	movzbl %dl,%edx
    7b8e:	c1 e2 02             	shl    $0x2,%edx
    7b91:	01 d0                	add    %edx,%eax
    7b93:	8b 00                	mov    (%eax),%eax
    7b95:	83 ec 04             	sub    $0x4,%esp
    7b98:	53                   	push   %ebx
    7b99:	50                   	push   %eax
    7b9a:	ff 75 08             	pushl  0x8(%ebp)
    7b9d:	e8 c1 c0 ff ff       	call   3c63 <writeBitsReversed>
    7ba2:	83 c4 10             	add    $0x10,%esp
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(!error) writeLZ77data(writer, &lz77_encoded, &tree_ll, &tree_d);
      uivector_cleanup(&lz77_encoded);
    } else /*no LZ77, but still will be Huffman compressed*/ {
      for(i = datapos; i < dataend; ++i) {
    7ba5:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7ba9:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7bac:	3b 45 18             	cmp    0x18(%ebp),%eax
    7baf:	7c b2                	jl     7b63 <deflateFixed+0x120>
        writeBitsReversed(writer, tree_ll.codes[data[i]], tree_ll.lengths[data[i]]);
      }
    }
    /*add END code*/
    if(!error) writeBitsReversed(writer,tree_ll.codes[256], tree_ll.lengths[256]);
    7bb1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7bb5:	75 26                	jne    7bdd <deflateFixed+0x19a>
    7bb7:	8b 45 d8             	mov    -0x28(%ebp),%eax
    7bba:	05 00 04 00 00       	add    $0x400,%eax
    7bbf:	8b 00                	mov    (%eax),%eax
    7bc1:	89 c2                	mov    %eax,%edx
    7bc3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    7bc6:	05 00 04 00 00       	add    $0x400,%eax
    7bcb:	8b 00                	mov    (%eax),%eax
    7bcd:	83 ec 04             	sub    $0x4,%esp
    7bd0:	52                   	push   %edx
    7bd1:	50                   	push   %eax
    7bd2:	ff 75 08             	pushl  0x8(%ebp)
    7bd5:	e8 89 c0 ff ff       	call   3c63 <writeBitsReversed>
    7bda:	83 c4 10             	add    $0x10,%esp
  }

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
    7bdd:	83 ec 0c             	sub    $0xc,%esp
    7be0:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    7be3:	50                   	push   %eax
    7be4:	e8 1f c9 ff ff       	call   4508 <HuffmanTree_cleanup>
    7be9:	83 c4 10             	add    $0x10,%esp
  HuffmanTree_cleanup(&tree_d);
    7bec:	83 ec 0c             	sub    $0xc,%esp
    7bef:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7bf2:	50                   	push   %eax
    7bf3:	e8 10 c9 ff ff       	call   4508 <HuffmanTree_cleanup>
    7bf8:	83 c4 10             	add    $0x10,%esp

  return error;
    7bfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7bfe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    7c01:	c9                   	leave  
    7c02:	c3                   	ret    

00007c03 <lodepng_deflatev>:

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings) {
    7c03:	55                   	push   %ebp
    7c04:	89 e5                	mov    %esp,%ebp
    7c06:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    7c09:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  size_t i, blocksize, numdeflateblocks;
  Hash hash;
  LodePNGBitWriter writer;

  LodePNGBitWriter_init(&writer, out);
    7c10:	ff 75 08             	pushl  0x8(%ebp)
    7c13:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7c16:	50                   	push   %eax
    7c17:	e8 9e be ff ff       	call   3aba <LodePNGBitWriter_init>
    7c1c:	83 c4 08             	add    $0x8,%esp

  if(settings->btype > 2) return 61;
    7c1f:	8b 45 14             	mov    0x14(%ebp),%eax
    7c22:	8b 00                	mov    (%eax),%eax
    7c24:	83 f8 02             	cmp    $0x2,%eax
    7c27:	76 0a                	jbe    7c33 <lodepng_deflatev+0x30>
    7c29:	b8 3d 00 00 00       	mov    $0x3d,%eax
    7c2e:	e9 68 01 00 00       	jmp    7d9b <lodepng_deflatev+0x198>
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
    7c33:	8b 45 14             	mov    0x14(%ebp),%eax
    7c36:	8b 00                	mov    (%eax),%eax
    7c38:	85 c0                	test   %eax,%eax
    7c3a:	75 16                	jne    7c52 <lodepng_deflatev+0x4f>
    7c3c:	ff 75 10             	pushl  0x10(%ebp)
    7c3f:	ff 75 0c             	pushl  0xc(%ebp)
    7c42:	ff 75 08             	pushl  0x8(%ebp)
    7c45:	e8 01 f2 ff ff       	call   6e4b <deflateNoCompression>
    7c4a:	83 c4 0c             	add    $0xc,%esp
    7c4d:	e9 49 01 00 00       	jmp    7d9b <lodepng_deflatev+0x198>
  else if(settings->btype == 1) blocksize = insize;
    7c52:	8b 45 14             	mov    0x14(%ebp),%eax
    7c55:	8b 00                	mov    (%eax),%eax
    7c57:	83 f8 01             	cmp    $0x1,%eax
    7c5a:	75 08                	jne    7c64 <lodepng_deflatev+0x61>
    7c5c:	8b 45 10             	mov    0x10(%ebp),%eax
    7c5f:	89 45 ec             	mov    %eax,-0x14(%ebp)
    7c62:	eb 2c                	jmp    7c90 <lodepng_deflatev+0x8d>
  else /*if(settings->btype == 2)*/ {
    /*on PNGs, deflate blocks of 65-262k seem to give most dense encoding*/
    blocksize = insize / 8u + 8;
    7c64:	8b 45 10             	mov    0x10(%ebp),%eax
    7c67:	c1 e8 03             	shr    $0x3,%eax
    7c6a:	83 c0 08             	add    $0x8,%eax
    7c6d:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(blocksize < 65536) blocksize = 65536;
    7c70:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%ebp)
    7c77:	7f 07                	jg     7c80 <lodepng_deflatev+0x7d>
    7c79:	c7 45 ec 00 00 01 00 	movl   $0x10000,-0x14(%ebp)
    if(blocksize > 262144) blocksize = 262144;
    7c80:	81 7d ec 00 00 04 00 	cmpl   $0x40000,-0x14(%ebp)
    7c87:	7e 07                	jle    7c90 <lodepng_deflatev+0x8d>
    7c89:	c7 45 ec 00 00 04 00 	movl   $0x40000,-0x14(%ebp)
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
    7c90:	8b 55 10             	mov    0x10(%ebp),%edx
    7c93:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7c96:	01 d0                	add    %edx,%eax
    7c98:	83 e8 01             	sub    $0x1,%eax
    7c9b:	99                   	cltd   
    7c9c:	f7 7d ec             	idivl  -0x14(%ebp)
    7c9f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;
    7ca2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7ca6:	75 07                	jne    7caf <lodepng_deflatev+0xac>
    7ca8:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

  error = hash_init(&hash, settings->windowsize);
    7caf:	8b 45 14             	mov    0x14(%ebp),%eax
    7cb2:	8b 40 08             	mov    0x8(%eax),%eax
    7cb5:	83 ec 08             	sub    $0x8,%esp
    7cb8:	50                   	push   %eax
    7cb9:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7cbc:	50                   	push   %eax
    7cbd:	e8 1c e8 ff ff       	call   64de <hash_init>
    7cc2:	83 c4 10             	add    $0x10,%esp
    7cc5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(!error) {
    7cc8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7ccc:	0f 85 b7 00 00 00    	jne    7d89 <lodepng_deflatev+0x186>
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7cd2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    7cd9:	e9 99 00 00 00       	jmp    7d77 <lodepng_deflatev+0x174>
      unsigned final = (i == numdeflateblocks - 1);
    7cde:	8b 45 e8             	mov    -0x18(%ebp),%eax
    7ce1:	83 e8 01             	sub    $0x1,%eax
    7ce4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7ce7:	0f 94 c0             	sete   %al
    7cea:	0f b6 c0             	movzbl %al,%eax
    7ced:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t start = i * blocksize;
    7cf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7cf3:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    7cf7:	89 45 dc             	mov    %eax,-0x24(%ebp)
      size_t end = start + blocksize;
    7cfa:	8b 55 dc             	mov    -0x24(%ebp),%edx
    7cfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    7d00:	01 d0                	add    %edx,%eax
    7d02:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if(end > insize) end = insize;
    7d05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    7d08:	3b 45 10             	cmp    0x10(%ebp),%eax
    7d0b:	7e 06                	jle    7d13 <lodepng_deflatev+0x110>
    7d0d:	8b 45 10             	mov    0x10(%ebp),%eax
    7d10:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
    7d13:	8b 45 14             	mov    0x14(%ebp),%eax
    7d16:	8b 00                	mov    (%eax),%eax
    7d18:	83 f8 01             	cmp    $0x1,%eax
    7d1b:	75 27                	jne    7d44 <lodepng_deflatev+0x141>
    7d1d:	83 ec 04             	sub    $0x4,%esp
    7d20:	ff 75 e0             	pushl  -0x20(%ebp)
    7d23:	ff 75 14             	pushl  0x14(%ebp)
    7d26:	ff 75 e4             	pushl  -0x1c(%ebp)
    7d29:	ff 75 dc             	pushl  -0x24(%ebp)
    7d2c:	ff 75 0c             	pushl  0xc(%ebp)
    7d2f:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7d32:	50                   	push   %eax
    7d33:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7d36:	50                   	push   %eax
    7d37:	e8 07 fd ff ff       	call   7a43 <deflateFixed>
    7d3c:	83 c4 20             	add    $0x20,%esp
    7d3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    7d42:	eb 2f                	jmp    7d73 <lodepng_deflatev+0x170>
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    7d44:	8b 45 14             	mov    0x14(%ebp),%eax
    7d47:	8b 00                	mov    (%eax),%eax
    7d49:	83 f8 02             	cmp    $0x2,%eax
    7d4c:	75 25                	jne    7d73 <lodepng_deflatev+0x170>
    7d4e:	83 ec 04             	sub    $0x4,%esp
    7d51:	ff 75 e0             	pushl  -0x20(%ebp)
    7d54:	ff 75 14             	pushl  0x14(%ebp)
    7d57:	ff 75 e4             	pushl  -0x1c(%ebp)
    7d5a:	ff 75 dc             	pushl  -0x24(%ebp)
    7d5d:	ff 75 0c             	pushl  0xc(%ebp)
    7d60:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7d63:	50                   	push   %eax
    7d64:	8d 45 bc             	lea    -0x44(%ebp),%eax
    7d67:	50                   	push   %eax
    7d68:	e8 7b f3 ff ff       	call   70e8 <deflateDynamic>
    7d6d:	83 c4 20             	add    $0x20,%esp
    7d70:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);

  if(!error) {
    for(i = 0; i != numdeflateblocks && !error; ++i) {
    7d73:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    7d77:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7d7a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    7d7d:	74 0a                	je     7d89 <lodepng_deflatev+0x186>
    7d7f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7d83:	0f 84 55 ff ff ff    	je     7cde <lodepng_deflatev+0xdb>
      if(settings->btype == 1) error = deflateFixed(&writer, &hash, in, start, end, settings, final);
      else if(settings->btype == 2) error = deflateDynamic(&writer, &hash, in, start, end, settings, final);
    }
  }

  hash_cleanup(&hash);
    7d89:	83 ec 0c             	sub    $0xc,%esp
    7d8c:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    7d8f:	50                   	push   %eax
    7d90:	e8 08 e9 ff ff       	call   669d <hash_cleanup>
    7d95:	83 c4 10             	add    $0x10,%esp

  return error;
    7d98:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7d9b:	c9                   	leave  
    7d9c:	c3                   	ret    

00007d9d <lodepng_deflate>:

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings) {
    7d9d:	55                   	push   %ebp
    7d9e:	89 e5                	mov    %esp,%ebp
    7da0:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    7da3:	8b 45 0c             	mov    0xc(%ebp),%eax
    7da6:	8b 08                	mov    (%eax),%ecx
    7da8:	8b 45 08             	mov    0x8(%ebp),%eax
    7dab:	8b 10                	mov    (%eax),%edx
    7dad:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7db0:	51                   	push   %ecx
    7db1:	52                   	push   %edx
    7db2:	50                   	push   %eax
    7db3:	e8 f0 ba ff ff       	call   38a8 <ucvector_init>
    7db8:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_deflatev(&v, in, insize, settings);
    7dbb:	ff 75 18             	pushl  0x18(%ebp)
    7dbe:	ff 75 14             	pushl  0x14(%ebp)
    7dc1:	ff 75 10             	pushl  0x10(%ebp)
    7dc4:	8d 45 e8             	lea    -0x18(%ebp),%eax
    7dc7:	50                   	push   %eax
    7dc8:	e8 36 fe ff ff       	call   7c03 <lodepng_deflatev>
    7dcd:	83 c4 10             	add    $0x10,%esp
    7dd0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    7dd3:	8b 55 e8             	mov    -0x18(%ebp),%edx
    7dd6:	8b 45 08             	mov    0x8(%ebp),%eax
    7dd9:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    7ddb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    7dde:	8b 45 0c             	mov    0xc(%ebp),%eax
    7de1:	89 10                	mov    %edx,(%eax)
  return error;
    7de3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    7de6:	c9                   	leave  
    7de7:	c3                   	ret    

00007de8 <deflate>:

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings) {
    7de8:	55                   	push   %ebp
    7de9:	89 e5                	mov    %esp,%ebp
    7deb:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_deflate) {
    7dee:	8b 45 18             	mov    0x18(%ebp),%eax
    7df1:	8b 40 1c             	mov    0x1c(%eax),%eax
    7df4:	85 c0                	test   %eax,%eax
    7df6:	74 34                	je     7e2c <deflate+0x44>
    unsigned error = settings->custom_deflate(out, outsize, in, insize, settings);
    7df8:	8b 45 18             	mov    0x18(%ebp),%eax
    7dfb:	8b 40 1c             	mov    0x1c(%eax),%eax
    7dfe:	83 ec 0c             	sub    $0xc,%esp
    7e01:	ff 75 18             	pushl  0x18(%ebp)
    7e04:	ff 75 14             	pushl  0x14(%ebp)
    7e07:	ff 75 10             	pushl  0x10(%ebp)
    7e0a:	ff 75 0c             	pushl  0xc(%ebp)
    7e0d:	ff 75 08             	pushl  0x8(%ebp)
    7e10:	ff d0                	call   *%eax
    7e12:	83 c4 20             	add    $0x20,%esp
    7e15:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom deflate is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    7e18:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7e1c:	74 07                	je     7e25 <deflate+0x3d>
    7e1e:	b8 6f 00 00 00       	mov    $0x6f,%eax
    7e23:	eb 21                	jmp    7e46 <deflate+0x5e>
    7e25:	b8 00 00 00 00       	mov    $0x0,%eax
    7e2a:	eb 1a                	jmp    7e46 <deflate+0x5e>
  } else {
    return lodepng_deflate(out, outsize, in, insize, settings);
    7e2c:	83 ec 0c             	sub    $0xc,%esp
    7e2f:	ff 75 18             	pushl  0x18(%ebp)
    7e32:	ff 75 14             	pushl  0x14(%ebp)
    7e35:	ff 75 10             	pushl  0x10(%ebp)
    7e38:	ff 75 0c             	pushl  0xc(%ebp)
    7e3b:	ff 75 08             	pushl  0x8(%ebp)
    7e3e:	e8 5a ff ff ff       	call   7d9d <lodepng_deflate>
    7e43:	83 c4 20             	add    $0x20,%esp
  }
}
    7e46:	c9                   	leave  
    7e47:	c3                   	ret    

00007e48 <update_adler32>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
    7e48:	55                   	push   %ebp
    7e49:	89 e5                	mov    %esp,%ebp
    7e4b:	83 ec 10             	sub    $0x10,%esp
  unsigned s1 = adler & 0xffffu;
    7e4e:	8b 45 08             	mov    0x8(%ebp),%eax
    7e51:	0f b7 c0             	movzwl %ax,%eax
    7e54:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned s2 = (adler >> 16u) & 0xffffu;
    7e57:	8b 45 08             	mov    0x8(%ebp),%eax
    7e5a:	c1 e8 10             	shr    $0x10,%eax
    7e5d:	89 45 f8             	mov    %eax,-0x8(%ebp)

  while(len != 0u) {
    7e60:	e9 82 00 00 00       	jmp    7ee7 <update_adler32+0x9f>
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    7e65:	b8 b0 15 00 00       	mov    $0x15b0,%eax
    7e6a:	81 7d 10 b0 15 00 00 	cmpl   $0x15b0,0x10(%ebp)
    7e71:	0f 46 45 10          	cmovbe 0x10(%ebp),%eax
    7e75:	89 45 f0             	mov    %eax,-0x10(%ebp)
    len -= amount;
    7e78:	8b 45 f0             	mov    -0x10(%ebp),%eax
    7e7b:	29 45 10             	sub    %eax,0x10(%ebp)
    for(i = 0; i != amount; ++i) {
    7e7e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    7e85:	eb 1c                	jmp    7ea3 <update_adler32+0x5b>
      s1 += (*data++);
    7e87:	8b 45 0c             	mov    0xc(%ebp),%eax
    7e8a:	8d 50 01             	lea    0x1(%eax),%edx
    7e8d:	89 55 0c             	mov    %edx,0xc(%ebp)
    7e90:	0f b6 00             	movzbl (%eax),%eax
    7e93:	0f b6 c0             	movzbl %al,%eax
    7e96:	01 45 fc             	add    %eax,-0x4(%ebp)
      s2 += s1;
    7e99:	8b 45 fc             	mov    -0x4(%ebp),%eax
    7e9c:	01 45 f8             	add    %eax,-0x8(%ebp)
  while(len != 0u) {
    unsigned i;
    /*at least 5552 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5552u ? 5552u : len;
    len -= amount;
    for(i = 0; i != amount; ++i) {
    7e9f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    7ea3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7ea6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    7ea9:	75 dc                	jne    7e87 <update_adler32+0x3f>
      s1 += (*data++);
      s2 += s1;
    }
    s1 %= 65521u;
    7eab:	8b 4d fc             	mov    -0x4(%ebp),%ecx
    7eae:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7eb3:	89 c8                	mov    %ecx,%eax
    7eb5:	f7 e2                	mul    %edx
    7eb7:	89 d0                	mov    %edx,%eax
    7eb9:	c1 e8 0f             	shr    $0xf,%eax
    7ebc:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7ec2:	29 c1                	sub    %eax,%ecx
    7ec4:	89 c8                	mov    %ecx,%eax
    7ec6:	89 45 fc             	mov    %eax,-0x4(%ebp)
    s2 %= 65521u;
    7ec9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    7ecc:	ba 71 80 07 80       	mov    $0x80078071,%edx
    7ed1:	89 c8                	mov    %ecx,%eax
    7ed3:	f7 e2                	mul    %edx
    7ed5:	89 d0                	mov    %edx,%eax
    7ed7:	c1 e8 0f             	shr    $0xf,%eax
    7eda:	69 c0 f1 ff 00 00    	imul   $0xfff1,%eax,%eax
    7ee0:	29 c1                	sub    %eax,%ecx
    7ee2:	89 c8                	mov    %ecx,%eax
    7ee4:	89 45 f8             	mov    %eax,-0x8(%ebp)

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len) {
  unsigned s1 = adler & 0xffffu;
  unsigned s2 = (adler >> 16u) & 0xffffu;

  while(len != 0u) {
    7ee7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    7eeb:	0f 85 74 ff ff ff    	jne    7e65 <update_adler32+0x1d>
    }
    s1 %= 65521u;
    s2 %= 65521u;
  }

  return (s2 << 16u) | s1;
    7ef1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    7ef4:	c1 e0 10             	shl    $0x10,%eax
    7ef7:	0b 45 fc             	or     -0x4(%ebp),%eax
}
    7efa:	c9                   	leave  
    7efb:	c3                   	ret    

00007efc <adler32>:

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len) {
    7efc:	55                   	push   %ebp
    7efd:	89 e5                	mov    %esp,%ebp
  return update_adler32(1u, data, len);
    7eff:	ff 75 0c             	pushl  0xc(%ebp)
    7f02:	ff 75 08             	pushl  0x8(%ebp)
    7f05:	6a 01                	push   $0x1
    7f07:	e8 3c ff ff ff       	call   7e48 <update_adler32>
    7f0c:	83 c4 0c             	add    $0xc,%esp
}
    7f0f:	c9                   	leave  
    7f10:	c3                   	ret    

00007f11 <lodepng_zlib_decompressv>:

#ifdef LODEPNG_COMPILE_DECODER

static unsigned lodepng_zlib_decompressv(ucvector* out,
                                         const unsigned char* in, size_t insize,
                                         const LodePNGDecompressSettings* settings) {
    7f11:	55                   	push   %ebp
    7f12:	89 e5                	mov    %esp,%ebp
    7f14:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    7f17:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
    7f1e:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    7f22:	7f 0a                	jg     7f2e <lodepng_zlib_decompressv+0x1d>
    7f24:	b8 35 00 00 00       	mov    $0x35,%eax
    7f29:	e9 27 01 00 00       	jmp    8055 <lodepng_zlib_decompressv+0x144>
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0) {
    7f2e:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f31:	0f b6 00             	movzbl (%eax),%eax
    7f34:	0f b6 c0             	movzbl %al,%eax
    7f37:	c1 e0 08             	shl    $0x8,%eax
    7f3a:	89 c2                	mov    %eax,%edx
    7f3c:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f3f:	83 c0 01             	add    $0x1,%eax
    7f42:	0f b6 00             	movzbl (%eax),%eax
    7f45:	0f b6 c0             	movzbl %al,%eax
    7f48:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    7f4b:	ba 43 08 21 84       	mov    $0x84210843,%edx
    7f50:	89 c8                	mov    %ecx,%eax
    7f52:	f7 ea                	imul   %edx
    7f54:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
    7f57:	c1 f8 04             	sar    $0x4,%eax
    7f5a:	89 c2                	mov    %eax,%edx
    7f5c:	89 c8                	mov    %ecx,%eax
    7f5e:	c1 f8 1f             	sar    $0x1f,%eax
    7f61:	29 c2                	sub    %eax,%edx
    7f63:	89 d0                	mov    %edx,%eax
    7f65:	89 c2                	mov    %eax,%edx
    7f67:	c1 e2 05             	shl    $0x5,%edx
    7f6a:	29 c2                	sub    %eax,%edx
    7f6c:	89 c8                	mov    %ecx,%eax
    7f6e:	29 d0                	sub    %edx,%eax
    7f70:	85 c0                	test   %eax,%eax
    7f72:	74 0a                	je     7f7e <lodepng_zlib_decompressv+0x6d>
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
    7f74:	b8 18 00 00 00       	mov    $0x18,%eax
    7f79:	e9 d7 00 00 00       	jmp    8055 <lodepng_zlib_decompressv+0x144>
  }

  CM = in[0] & 15;
    7f7e:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f81:	0f b6 00             	movzbl (%eax),%eax
    7f84:	0f b6 c0             	movzbl %al,%eax
    7f87:	83 e0 0f             	and    $0xf,%eax
    7f8a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  CINFO = (in[0] >> 4) & 15;
    7f8d:	8b 45 0c             	mov    0xc(%ebp),%eax
    7f90:	0f b6 00             	movzbl (%eax),%eax
    7f93:	c0 e8 04             	shr    $0x4,%al
    7f96:	0f b6 c0             	movzbl %al,%eax
    7f99:	83 e0 0f             	and    $0xf,%eax
    7f9c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
    7f9f:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fa2:	83 c0 01             	add    $0x1,%eax
    7fa5:	0f b6 00             	movzbl (%eax),%eax
    7fa8:	c0 e8 05             	shr    $0x5,%al
    7fab:	0f b6 c0             	movzbl %al,%eax
    7fae:	83 e0 01             	and    $0x1,%eax
    7fb1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7) {
    7fb4:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
    7fb8:	75 06                	jne    7fc0 <lodepng_zlib_decompressv+0xaf>
    7fba:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    7fbe:	76 0a                	jbe    7fca <lodepng_zlib_decompressv+0xb9>
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
    7fc0:	b8 19 00 00 00       	mov    $0x19,%eax
    7fc5:	e9 8b 00 00 00       	jmp    8055 <lodepng_zlib_decompressv+0x144>
  }
  if(FDICT != 0) {
    7fca:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    7fce:	74 07                	je     7fd7 <lodepng_zlib_decompressv+0xc6>
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
    7fd0:	b8 1a 00 00 00       	mov    $0x1a,%eax
    7fd5:	eb 7e                	jmp    8055 <lodepng_zlib_decompressv+0x144>
  }

  error = inflatev(out, in + 2, insize - 2, settings);
    7fd7:	8b 45 10             	mov    0x10(%ebp),%eax
    7fda:	8d 50 fe             	lea    -0x2(%eax),%edx
    7fdd:	8b 45 0c             	mov    0xc(%ebp),%eax
    7fe0:	83 c0 02             	add    $0x2,%eax
    7fe3:	ff 75 14             	pushl  0x14(%ebp)
    7fe6:	52                   	push   %edx
    7fe7:	50                   	push   %eax
    7fe8:	ff 75 08             	pushl  0x8(%ebp)
    7feb:	e8 09 e3 ff ff       	call   62f9 <inflatev>
    7ff0:	83 c4 10             	add    $0x10,%esp
    7ff3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(error) return error;
    7ff6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    7ffa:	74 05                	je     8001 <lodepng_zlib_decompressv+0xf0>
    7ffc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    7fff:	eb 54                	jmp    8055 <lodepng_zlib_decompressv+0x144>

  if(!settings->ignore_adler32) {
    8001:	8b 45 14             	mov    0x14(%ebp),%eax
    8004:	8b 00                	mov    (%eax),%eax
    8006:	85 c0                	test   %eax,%eax
    8008:	75 46                	jne    8050 <lodepng_zlib_decompressv+0x13f>
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    800a:	8b 45 10             	mov    0x10(%ebp),%eax
    800d:	8d 50 fc             	lea    -0x4(%eax),%edx
    8010:	8b 45 0c             	mov    0xc(%ebp),%eax
    8013:	01 d0                	add    %edx,%eax
    8015:	83 ec 0c             	sub    $0xc,%esp
    8018:	50                   	push   %eax
    8019:	e8 47 b9 ff ff       	call   3965 <lodepng_read32bitInt>
    801e:	83 c4 10             	add    $0x10,%esp
    8021:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned checksum = adler32(out->data, (unsigned)(out->size));
    8024:	8b 45 08             	mov    0x8(%ebp),%eax
    8027:	8b 40 04             	mov    0x4(%eax),%eax
    802a:	89 c2                	mov    %eax,%edx
    802c:	8b 45 08             	mov    0x8(%ebp),%eax
    802f:	8b 00                	mov    (%eax),%eax
    8031:	83 ec 08             	sub    $0x8,%esp
    8034:	52                   	push   %edx
    8035:	50                   	push   %eax
    8036:	e8 c1 fe ff ff       	call   7efc <adler32>
    803b:	83 c4 10             	add    $0x10,%esp
    803e:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
    8041:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8044:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    8047:	74 07                	je     8050 <lodepng_zlib_decompressv+0x13f>
    8049:	b8 3a 00 00 00       	mov    $0x3a,%eax
    804e:	eb 05                	jmp    8055 <lodepng_zlib_decompressv+0x144>
  }

  return 0; /*no error*/
    8050:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8055:	c9                   	leave  
    8056:	c3                   	ret    

00008057 <lodepng_zlib_decompress>:


unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings) {
    8057:	55                   	push   %ebp
    8058:	89 e5                	mov    %esp,%ebp
    805a:	83 ec 18             	sub    $0x18,%esp
  ucvector v = ucvector_init(*out, *outsize);
    805d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8060:	8b 08                	mov    (%eax),%ecx
    8062:	8b 45 08             	mov    0x8(%ebp),%eax
    8065:	8b 10                	mov    (%eax),%edx
    8067:	8d 45 e8             	lea    -0x18(%ebp),%eax
    806a:	51                   	push   %ecx
    806b:	52                   	push   %edx
    806c:	50                   	push   %eax
    806d:	e8 36 b8 ff ff       	call   38a8 <ucvector_init>
    8072:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_zlib_decompressv(&v, in, insize, settings);
    8075:	ff 75 18             	pushl  0x18(%ebp)
    8078:	ff 75 14             	pushl  0x14(%ebp)
    807b:	ff 75 10             	pushl  0x10(%ebp)
    807e:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8081:	50                   	push   %eax
    8082:	e8 8a fe ff ff       	call   7f11 <lodepng_zlib_decompressv>
    8087:	83 c4 10             	add    $0x10,%esp
    808a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  *out = v.data;
    808d:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8090:	8b 45 08             	mov    0x8(%ebp),%eax
    8093:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8095:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8098:	8b 45 0c             	mov    0xc(%ebp),%eax
    809b:	89 10                	mov    %edx,(%eax)
  return error;
    809d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    80a0:	c9                   	leave  
    80a1:	c3                   	ret    

000080a2 <zlib_decompress>:

/*expected_size is expected output size, to avoid intermediate allocations. Set to 0 if not known. */
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, size_t expected_size,
                                const unsigned char* in, size_t insize, const LodePNGDecompressSettings* settings) {
    80a2:	55                   	push   %ebp
    80a3:	89 e5                	mov    %esp,%ebp
    80a5:	83 ec 18             	sub    $0x18,%esp
  unsigned error;
  if(settings->custom_zlib) {
    80a8:	8b 45 1c             	mov    0x1c(%ebp),%eax
    80ab:	8b 40 0c             	mov    0xc(%eax),%eax
    80ae:	85 c0                	test   %eax,%eax
    80b0:	74 57                	je     8109 <zlib_decompress+0x67>
    error = settings->custom_zlib(out, outsize, in, insize, settings);
    80b2:	8b 45 1c             	mov    0x1c(%ebp),%eax
    80b5:	8b 40 0c             	mov    0xc(%eax),%eax
    80b8:	83 ec 0c             	sub    $0xc,%esp
    80bb:	ff 75 1c             	pushl  0x1c(%ebp)
    80be:	ff 75 18             	pushl  0x18(%ebp)
    80c1:	ff 75 14             	pushl  0x14(%ebp)
    80c4:	ff 75 0c             	pushl  0xc(%ebp)
    80c7:	ff 75 08             	pushl  0x8(%ebp)
    80ca:	ff d0                	call   *%eax
    80cc:	83 c4 20             	add    $0x20,%esp
    80cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(error) {
    80d2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    80d6:	0f 84 98 00 00 00    	je     8174 <zlib_decompress+0xd2>
      /*the custom zlib is allowed to have its own error codes, however, we translate it to code 110*/
      error = 110;
    80dc:	c7 45 f4 6e 00 00 00 	movl   $0x6e,-0xc(%ebp)
      /*if there's a max output size, and the custom zlib returned error, then indicate that error instead*/
      if(settings->max_output_size && *outsize > settings->max_output_size) error = 109;
    80e3:	8b 45 1c             	mov    0x1c(%ebp),%eax
    80e6:	8b 40 08             	mov    0x8(%eax),%eax
    80e9:	85 c0                	test   %eax,%eax
    80eb:	0f 84 83 00 00 00    	je     8174 <zlib_decompress+0xd2>
    80f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    80f4:	8b 10                	mov    (%eax),%edx
    80f6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    80f9:	8b 40 08             	mov    0x8(%eax),%eax
    80fc:	39 c2                	cmp    %eax,%edx
    80fe:	7e 74                	jle    8174 <zlib_decompress+0xd2>
    8100:	c7 45 f4 6d 00 00 00 	movl   $0x6d,-0xc(%ebp)
    8107:	eb 6b                	jmp    8174 <zlib_decompress+0xd2>
    }
  } else {
    ucvector v = ucvector_init(*out, *outsize);
    8109:	8b 45 0c             	mov    0xc(%ebp),%eax
    810c:	8b 08                	mov    (%eax),%ecx
    810e:	8b 45 08             	mov    0x8(%ebp),%eax
    8111:	8b 10                	mov    (%eax),%edx
    8113:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8116:	83 ec 04             	sub    $0x4,%esp
    8119:	51                   	push   %ecx
    811a:	52                   	push   %edx
    811b:	50                   	push   %eax
    811c:	e8 87 b7 ff ff       	call   38a8 <ucvector_init>
    8121:	83 c4 0c             	add    $0xc,%esp
    if(expected_size) {
    8124:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    8128:	74 22                	je     814c <zlib_decompress+0xaa>
      /*reserve the memory to avoid intermediate reallocations*/
      ucvector_resize(&v, *outsize + expected_size);
    812a:	8b 45 0c             	mov    0xc(%ebp),%eax
    812d:	8b 10                	mov    (%eax),%edx
    812f:	8b 45 10             	mov    0x10(%ebp),%eax
    8132:	01 d0                	add    %edx,%eax
    8134:	83 ec 08             	sub    $0x8,%esp
    8137:	50                   	push   %eax
    8138:	8d 45 e8             	lea    -0x18(%ebp),%eax
    813b:	50                   	push   %eax
    813c:	e8 00 b7 ff ff       	call   3841 <ucvector_resize>
    8141:	83 c4 10             	add    $0x10,%esp
      v.size = *outsize;
    8144:	8b 45 0c             	mov    0xc(%ebp),%eax
    8147:	8b 00                	mov    (%eax),%eax
    8149:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
    error = lodepng_zlib_decompressv(&v, in, insize, settings);
    814c:	ff 75 1c             	pushl  0x1c(%ebp)
    814f:	ff 75 18             	pushl  0x18(%ebp)
    8152:	ff 75 14             	pushl  0x14(%ebp)
    8155:	8d 45 e8             	lea    -0x18(%ebp),%eax
    8158:	50                   	push   %eax
    8159:	e8 b3 fd ff ff       	call   7f11 <lodepng_zlib_decompressv>
    815e:	83 c4 10             	add    $0x10,%esp
    8161:	89 45 f4             	mov    %eax,-0xc(%ebp)
    *out = v.data;
    8164:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8167:	8b 45 08             	mov    0x8(%ebp),%eax
    816a:	89 10                	mov    %edx,(%eax)
    *outsize = v.size;
    816c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    816f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8172:	89 10                	mov    %edx,(%eax)
  }
  return error;
    8174:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    8177:	c9                   	leave  
    8178:	c3                   	ret    

00008179 <lodepng_zlib_compress>:
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings) {
    8179:	55                   	push   %ebp
    817a:	89 e5                	mov    %esp,%ebp
    817c:	83 ec 38             	sub    $0x38,%esp
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
    817f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t deflatesize = 0;
    8186:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);
    818d:	83 ec 0c             	sub    $0xc,%esp
    8190:	ff 75 18             	pushl  0x18(%ebp)
    8193:	ff 75 14             	pushl  0x14(%ebp)
    8196:	ff 75 10             	pushl  0x10(%ebp)
    8199:	8d 45 d0             	lea    -0x30(%ebp),%eax
    819c:	50                   	push   %eax
    819d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
    81a0:	50                   	push   %eax
    81a1:	e8 42 fc ff ff       	call   7de8 <deflate>
    81a6:	83 c4 20             	add    $0x20,%esp
    81a9:	89 45 f0             	mov    %eax,-0x10(%ebp)

  *out = NULL;
    81ac:	8b 45 08             	mov    0x8(%ebp),%eax
    81af:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
    81b5:	8b 45 0c             	mov    0xc(%ebp),%eax
    81b8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  if(!error) {
    81be:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    81c2:	75 33                	jne    81f7 <lodepng_zlib_compress+0x7e>
    *outsize = deflatesize + 6;
    81c4:	8b 45 d0             	mov    -0x30(%ebp),%eax
    81c7:	8d 50 06             	lea    0x6(%eax),%edx
    81ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    81cd:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
    81cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    81d2:	8b 00                	mov    (%eax),%eax
    81d4:	83 ec 0c             	sub    $0xc,%esp
    81d7:	50                   	push   %eax
    81d8:	e8 0a b4 ff ff       	call   35e7 <lodepng_malloc>
    81dd:	83 c4 10             	add    $0x10,%esp
    81e0:	89 c2                	mov    %eax,%edx
    81e2:	8b 45 08             	mov    0x8(%ebp),%eax
    81e5:	89 10                	mov    %edx,(%eax)
    if(!*out) error = 83; /*alloc fail*/
    81e7:	8b 45 08             	mov    0x8(%ebp),%eax
    81ea:	8b 00                	mov    (%eax),%eax
    81ec:	85 c0                	test   %eax,%eax
    81ee:	75 07                	jne    81f7 <lodepng_zlib_compress+0x7e>
    81f0:	c7 45 f0 53 00 00 00 	movl   $0x53,-0x10(%ebp)
  }

  if(!error) {
    81f7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    81fb:	0f 85 e2 00 00 00    	jne    82e3 <lodepng_zlib_compress+0x16a>
    unsigned ADLER32 = adler32(in, (unsigned)insize);
    8201:	8b 45 14             	mov    0x14(%ebp),%eax
    8204:	83 ec 08             	sub    $0x8,%esp
    8207:	50                   	push   %eax
    8208:	ff 75 10             	pushl  0x10(%ebp)
    820b:	e8 ec fc ff ff       	call   7efc <adler32>
    8210:	83 c4 10             	add    $0x10,%esp
    8213:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
    unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
    8216:	c7 45 e8 78 00 00 00 	movl   $0x78,-0x18(%ebp)
    unsigned FLEVEL = 0;
    821d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned FDICT = 0;
    8224:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
    822b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    822e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    8235:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    8238:	01 d0                	add    %edx,%eax
    823a:	8d 14 00             	lea    (%eax,%eax,1),%edx
    823d:	8b 45 e0             	mov    -0x20(%ebp),%eax
    8240:	01 d0                	add    %edx,%eax
    8242:	c1 e0 05             	shl    $0x5,%eax
    8245:	89 45 dc             	mov    %eax,-0x24(%ebp)
    unsigned FCHECK = 31 - CMFFLG % 31;
    8248:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    824b:	ba 85 10 42 08       	mov    $0x8421085,%edx
    8250:	89 c8                	mov    %ecx,%eax
    8252:	f7 e2                	mul    %edx
    8254:	89 c8                	mov    %ecx,%eax
    8256:	29 d0                	sub    %edx,%eax
    8258:	d1 e8                	shr    %eax
    825a:	01 d0                	add    %edx,%eax
    825c:	c1 e8 04             	shr    $0x4,%eax
    825f:	89 c2                	mov    %eax,%edx
    8261:	c1 e2 05             	shl    $0x5,%edx
    8264:	29 c2                	sub    %eax,%edx
    8266:	89 c8                	mov    %ecx,%eax
    8268:	29 d0                	sub    %edx,%eax
    826a:	ba 1f 00 00 00       	mov    $0x1f,%edx
    826f:	29 c2                	sub    %eax,%edx
    8271:	89 d0                	mov    %edx,%eax
    8273:	89 45 d8             	mov    %eax,-0x28(%ebp)
    CMFFLG += FCHECK;
    8276:	8b 45 d8             	mov    -0x28(%ebp),%eax
    8279:	01 45 dc             	add    %eax,-0x24(%ebp)

    (*out)[0] = (unsigned char)(CMFFLG >> 8);
    827c:	8b 45 08             	mov    0x8(%ebp),%eax
    827f:	8b 00                	mov    (%eax),%eax
    8281:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8284:	c1 ea 08             	shr    $0x8,%edx
    8287:	88 10                	mov    %dl,(%eax)
    (*out)[1] = (unsigned char)(CMFFLG & 255);
    8289:	8b 45 08             	mov    0x8(%ebp),%eax
    828c:	8b 00                	mov    (%eax),%eax
    828e:	83 c0 01             	add    $0x1,%eax
    8291:	8b 55 dc             	mov    -0x24(%ebp),%edx
    8294:	88 10                	mov    %dl,(%eax)
    for(i = 0; i != deflatesize; ++i) (*out)[i + 2] = deflatedata[i];
    8296:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    829d:	eb 1e                	jmp    82bd <lodepng_zlib_compress+0x144>
    829f:	8b 45 08             	mov    0x8(%ebp),%eax
    82a2:	8b 00                	mov    (%eax),%eax
    82a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    82a7:	83 c2 02             	add    $0x2,%edx
    82aa:	01 c2                	add    %eax,%edx
    82ac:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
    82af:	8b 45 f4             	mov    -0xc(%ebp),%eax
    82b2:	01 c8                	add    %ecx,%eax
    82b4:	0f b6 00             	movzbl (%eax),%eax
    82b7:	88 02                	mov    %al,(%edx)
    82b9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    82bd:	8b 45 d0             	mov    -0x30(%ebp),%eax
    82c0:	39 45 f4             	cmp    %eax,-0xc(%ebp)
    82c3:	75 da                	jne    829f <lodepng_zlib_compress+0x126>
    lodepng_set32bitInt(&(*out)[*outsize - 4], ADLER32);
    82c5:	8b 45 08             	mov    0x8(%ebp),%eax
    82c8:	8b 10                	mov    (%eax),%edx
    82ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    82cd:	8b 00                	mov    (%eax),%eax
    82cf:	83 e8 04             	sub    $0x4,%eax
    82d2:	01 d0                	add    %edx,%eax
    82d4:	83 ec 08             	sub    $0x8,%esp
    82d7:	ff 75 ec             	pushl  -0x14(%ebp)
    82da:	50                   	push   %eax
    82db:	e8 c8 b6 ff ff       	call   39a8 <lodepng_set32bitInt>
    82e0:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(deflatedata);
    82e3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    82e6:	83 ec 0c             	sub    $0xc,%esp
    82e9:	50                   	push   %eax
    82ea:	e8 19 b3 ff ff       	call   3608 <lodepng_free>
    82ef:	83 c4 10             	add    $0x10,%esp
  return error;
    82f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    82f5:	c9                   	leave  
    82f6:	c3                   	ret    

000082f7 <zlib_compress>:

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings) {
    82f7:	55                   	push   %ebp
    82f8:	89 e5                	mov    %esp,%ebp
    82fa:	83 ec 18             	sub    $0x18,%esp
  if(settings->custom_zlib) {
    82fd:	8b 45 18             	mov    0x18(%ebp),%eax
    8300:	8b 40 18             	mov    0x18(%eax),%eax
    8303:	85 c0                	test   %eax,%eax
    8305:	74 34                	je     833b <zlib_compress+0x44>
    unsigned error = settings->custom_zlib(out, outsize, in, insize, settings);
    8307:	8b 45 18             	mov    0x18(%ebp),%eax
    830a:	8b 40 18             	mov    0x18(%eax),%eax
    830d:	83 ec 0c             	sub    $0xc,%esp
    8310:	ff 75 18             	pushl  0x18(%ebp)
    8313:	ff 75 14             	pushl  0x14(%ebp)
    8316:	ff 75 10             	pushl  0x10(%ebp)
    8319:	ff 75 0c             	pushl  0xc(%ebp)
    831c:	ff 75 08             	pushl  0x8(%ebp)
    831f:	ff d0                	call   *%eax
    8321:	83 c4 20             	add    $0x20,%esp
    8324:	89 45 f4             	mov    %eax,-0xc(%ebp)
    /*the custom zlib is allowed to have its own error codes, however, we translate it to code 111*/
    return error ? 111 : 0;
    8327:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    832b:	74 07                	je     8334 <zlib_compress+0x3d>
    832d:	b8 6f 00 00 00       	mov    $0x6f,%eax
    8332:	eb 21                	jmp    8355 <zlib_compress+0x5e>
    8334:	b8 00 00 00 00       	mov    $0x0,%eax
    8339:	eb 1a                	jmp    8355 <zlib_compress+0x5e>
  } else {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
    833b:	83 ec 0c             	sub    $0xc,%esp
    833e:	ff 75 18             	pushl  0x18(%ebp)
    8341:	ff 75 14             	pushl  0x14(%ebp)
    8344:	ff 75 10             	pushl  0x10(%ebp)
    8347:	ff 75 0c             	pushl  0xc(%ebp)
    834a:	ff 75 08             	pushl  0x8(%ebp)
    834d:	e8 27 fe ff ff       	call   8179 <lodepng_zlib_compress>
    8352:	83 c4 20             	add    $0x20,%esp
  }
}
    8355:	c9                   	leave  
    8356:	c3                   	ret    

00008357 <lodepng_compress_settings_init>:
#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings) {
    8357:	55                   	push   %ebp
    8358:	89 e5                	mov    %esp,%ebp
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
    835a:	8b 45 08             	mov    0x8(%ebp),%eax
    835d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
  settings->use_lz77 = 1;
    8363:	8b 45 08             	mov    0x8(%ebp),%eax
    8366:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  settings->windowsize = DEFAULT_WINDOWSIZE;
    836d:	8b 45 08             	mov    0x8(%ebp),%eax
    8370:	c7 40 08 00 08 00 00 	movl   $0x800,0x8(%eax)
  settings->minmatch = 3;
    8377:	8b 45 08             	mov    0x8(%ebp),%eax
    837a:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  settings->nicematch = 128;
    8381:	8b 45 08             	mov    0x8(%ebp),%eax
    8384:	c7 40 10 80 00 00 00 	movl   $0x80,0x10(%eax)
  settings->lazymatching = 1;
    838b:	8b 45 08             	mov    0x8(%ebp),%eax
    838e:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)

  settings->custom_zlib = 0;
    8395:	8b 45 08             	mov    0x8(%ebp),%eax
    8398:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->custom_deflate = 0;
    839f:	8b 45 08             	mov    0x8(%ebp),%eax
    83a2:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->custom_context = 0;
    83a9:	8b 45 08             	mov    0x8(%ebp),%eax
    83ac:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
}
    83b3:	90                   	nop
    83b4:	5d                   	pop    %ebp
    83b5:	c3                   	ret    

000083b6 <lodepng_decompress_settings_init>:

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings) {
    83b6:	55                   	push   %ebp
    83b7:	89 e5                	mov    %esp,%ebp
  settings->ignore_adler32 = 0;
    83b9:	8b 45 08             	mov    0x8(%ebp),%eax
    83bc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  settings->ignore_nlen = 0;
    83c2:	8b 45 08             	mov    0x8(%ebp),%eax
    83c5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  settings->max_output_size = 0;
    83cc:	8b 45 08             	mov    0x8(%ebp),%eax
    83cf:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  settings->custom_zlib = 0;
    83d6:	8b 45 08             	mov    0x8(%ebp),%eax
    83d9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  settings->custom_inflate = 0;
    83e0:	8b 45 08             	mov    0x8(%ebp),%eax
    83e3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  settings->custom_context = 0;
    83ea:	8b 45 08             	mov    0x8(%ebp),%eax
    83ed:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
}
    83f4:	90                   	nop
    83f5:	5d                   	pop    %ebp
    83f6:	c3                   	ret    

000083f7 <lodepng_crc32>:
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
    83f7:	55                   	push   %ebp
    83f8:	89 e5                	mov    %esp,%ebp
    83fa:	83 ec 10             	sub    $0x10,%esp
  unsigned r = 0xffffffffu;
    83fd:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  size_t i;
  for(i = 0; i < length; ++i) {
    8404:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    840b:	eb 2a                	jmp    8437 <lodepng_crc32+0x40>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
    840d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8410:	8b 45 08             	mov    0x8(%ebp),%eax
    8413:	01 d0                	add    %edx,%eax
    8415:	0f b6 00             	movzbl (%eax),%eax
    8418:	0f b6 c0             	movzbl %al,%eax
    841b:	33 45 fc             	xor    -0x4(%ebp),%eax
    841e:	0f b6 c0             	movzbl %al,%eax
    8421:	8b 04 85 60 e4 01 00 	mov    0x1e460(,%eax,4),%eax
    8428:	8b 55 fc             	mov    -0x4(%ebp),%edx
    842b:	c1 ea 08             	shr    $0x8,%edx
    842e:	31 d0                	xor    %edx,%eax
    8430:	89 45 fc             	mov    %eax,-0x4(%ebp)

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* data, size_t length) {
  unsigned r = 0xffffffffu;
  size_t i;
  for(i = 0; i < length; ++i) {
    8433:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    8437:	8b 45 f8             	mov    -0x8(%ebp),%eax
    843a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    843d:	7c ce                	jl     840d <lodepng_crc32+0x16>
    r = lodepng_crc32_table[(r ^ data[i]) & 0xffu] ^ (r >> 8u);
  }
  return r ^ 0xffffffffu;
    843f:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8442:	f7 d0                	not    %eax
}
    8444:	c9                   	leave  
    8445:	c3                   	ret    

00008446 <readBitFromReversedStream>:
/* ////////////////////////////////////////////////////////////////////////// */

/* The color channel bits of less-than-8-bit pixels are read with the MSB of bytes first,
so LodePNGBitWriter and LodePNGBitReader can't be used for those. */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream) {
    8446:	55                   	push   %ebp
    8447:	89 e5                	mov    %esp,%ebp
    8449:	83 ec 10             	sub    $0x10,%esp
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
    844c:	8b 45 08             	mov    0x8(%ebp),%eax
    844f:	8b 00                	mov    (%eax),%eax
    8451:	c1 f8 03             	sar    $0x3,%eax
    8454:	89 c2                	mov    %eax,%edx
    8456:	8b 45 0c             	mov    0xc(%ebp),%eax
    8459:	01 d0                	add    %edx,%eax
    845b:	0f b6 00             	movzbl (%eax),%eax
    845e:	0f b6 d0             	movzbl %al,%edx
    8461:	8b 45 08             	mov    0x8(%ebp),%eax
    8464:	8b 00                	mov    (%eax),%eax
    8466:	f7 d0                	not    %eax
    8468:	83 e0 07             	and    $0x7,%eax
    846b:	89 c1                	mov    %eax,%ecx
    846d:	d3 fa                	sar    %cl,%edx
    846f:	89 d0                	mov    %edx,%eax
    8471:	83 e0 01             	and    $0x1,%eax
    8474:	88 45 ff             	mov    %al,-0x1(%ebp)
  ++(*bitpointer);
    8477:	8b 45 08             	mov    0x8(%ebp),%eax
    847a:	8b 00                	mov    (%eax),%eax
    847c:	8d 50 01             	lea    0x1(%eax),%edx
    847f:	8b 45 08             	mov    0x8(%ebp),%eax
    8482:	89 10                	mov    %edx,(%eax)
  return result;
    8484:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
    8488:	c9                   	leave  
    8489:	c3                   	ret    

0000848a <readBitsFromReversedStream>:

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
    848a:	55                   	push   %ebp
    848b:	89 e5                	mov    %esp,%ebp
    848d:	83 ec 10             	sub    $0x10,%esp
  unsigned result = 0;
    8490:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    8497:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    849e:	eb 1b                	jmp    84bb <readBitsFromReversedStream+0x31>
    result <<= 1u;
    84a0:	d1 65 fc             	shll   -0x4(%ebp)
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
    84a3:	ff 75 0c             	pushl  0xc(%ebp)
    84a6:	ff 75 08             	pushl  0x8(%ebp)
    84a9:	e8 98 ff ff ff       	call   8446 <readBitFromReversedStream>
    84ae:	83 c4 08             	add    $0x8,%esp
    84b1:	0f b6 c0             	movzbl %al,%eax
    84b4:	09 45 fc             	or     %eax,-0x4(%ebp)

/* TODO: make this faster */
static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits) {
  unsigned result = 0;
  size_t i;
  for(i = 0 ; i < nbits; ++i) {
    84b7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    84bb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    84be:	3b 45 10             	cmp    0x10(%ebp),%eax
    84c1:	7c dd                	jl     84a0 <readBitsFromReversedStream+0x16>
    result <<= 1u;
    result |= (unsigned)readBitFromReversedStream(bitpointer, bitstream);
  }
  return result;
    84c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    84c6:	c9                   	leave  
    84c7:	c3                   	ret    

000084c8 <setBitOfReversedStream>:

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit) {
    84c8:	55                   	push   %ebp
    84c9:	89 e5                	mov    %esp,%ebp
    84cb:	56                   	push   %esi
    84cc:	53                   	push   %ebx
    84cd:	83 ec 04             	sub    $0x4,%esp
    84d0:	8b 45 10             	mov    0x10(%ebp),%eax
    84d3:	88 45 f4             	mov    %al,-0xc(%ebp)
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3u] &=  (unsigned char)(~(1u << (7u - ((*bitpointer) & 7u))));
    84d6:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
    84da:	75 3e                	jne    851a <setBitOfReversedStream+0x52>
    84dc:	8b 45 08             	mov    0x8(%ebp),%eax
    84df:	8b 00                	mov    (%eax),%eax
    84e1:	c1 f8 03             	sar    $0x3,%eax
    84e4:	89 c2                	mov    %eax,%edx
    84e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    84e9:	01 c2                	add    %eax,%edx
    84eb:	8b 45 08             	mov    0x8(%ebp),%eax
    84ee:	8b 00                	mov    (%eax),%eax
    84f0:	c1 f8 03             	sar    $0x3,%eax
    84f3:	89 c1                	mov    %eax,%ecx
    84f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    84f8:	01 c8                	add    %ecx,%eax
    84fa:	0f b6 18             	movzbl (%eax),%ebx
    84fd:	8b 45 08             	mov    0x8(%ebp),%eax
    8500:	8b 00                	mov    (%eax),%eax
    8502:	f7 d0                	not    %eax
    8504:	83 e0 07             	and    $0x7,%eax
    8507:	be 01 00 00 00       	mov    $0x1,%esi
    850c:	89 c1                	mov    %eax,%ecx
    850e:	d3 e6                	shl    %cl,%esi
    8510:	89 f0                	mov    %esi,%eax
    8512:	f7 d0                	not    %eax
    8514:	21 d8                	and    %ebx,%eax
    8516:	88 02                	mov    %al,(%edx)
    8518:	eb 3a                	jmp    8554 <setBitOfReversedStream+0x8c>
  else         bitstream[(*bitpointer) >> 3u] |=  (1u << (7u - ((*bitpointer) & 7u)));
    851a:	8b 45 08             	mov    0x8(%ebp),%eax
    851d:	8b 00                	mov    (%eax),%eax
    851f:	c1 f8 03             	sar    $0x3,%eax
    8522:	89 c2                	mov    %eax,%edx
    8524:	8b 45 0c             	mov    0xc(%ebp),%eax
    8527:	01 c2                	add    %eax,%edx
    8529:	8b 45 08             	mov    0x8(%ebp),%eax
    852c:	8b 00                	mov    (%eax),%eax
    852e:	c1 f8 03             	sar    $0x3,%eax
    8531:	89 c1                	mov    %eax,%ecx
    8533:	8b 45 0c             	mov    0xc(%ebp),%eax
    8536:	01 c8                	add    %ecx,%eax
    8538:	0f b6 18             	movzbl (%eax),%ebx
    853b:	8b 45 08             	mov    0x8(%ebp),%eax
    853e:	8b 00                	mov    (%eax),%eax
    8540:	f7 d0                	not    %eax
    8542:	83 e0 07             	and    $0x7,%eax
    8545:	be 01 00 00 00       	mov    $0x1,%esi
    854a:	89 c1                	mov    %eax,%ecx
    854c:	d3 e6                	shl    %cl,%esi
    854e:	89 f0                	mov    %esi,%eax
    8550:	09 d8                	or     %ebx,%eax
    8552:	88 02                	mov    %al,(%edx)
  ++(*bitpointer);
    8554:	8b 45 08             	mov    0x8(%ebp),%eax
    8557:	8b 00                	mov    (%eax),%eax
    8559:	8d 50 01             	lea    0x1(%eax),%edx
    855c:	8b 45 08             	mov    0x8(%ebp),%eax
    855f:	89 10                	mov    %edx,(%eax)
}
    8561:	90                   	nop
    8562:	83 c4 04             	add    $0x4,%esp
    8565:	5b                   	pop    %ebx
    8566:	5e                   	pop    %esi
    8567:	5d                   	pop    %ebp
    8568:	c3                   	ret    

00008569 <lodepng_chunk_length>:

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk) {
    8569:	55                   	push   %ebp
    856a:	89 e5                	mov    %esp,%ebp
  return lodepng_read32bitInt(&chunk[0]);
    856c:	ff 75 08             	pushl  0x8(%ebp)
    856f:	e8 f1 b3 ff ff       	call   3965 <lodepng_read32bitInt>
    8574:	83 c4 04             	add    $0x4,%esp
}
    8577:	c9                   	leave  
    8578:	c3                   	ret    

00008579 <lodepng_chunk_type>:

void lodepng_chunk_type(char type[5], const unsigned char* chunk) {
    8579:	55                   	push   %ebp
    857a:	89 e5                	mov    %esp,%ebp
    857c:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
    857f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8586:	eb 1c                	jmp    85a4 <lodepng_chunk_type+0x2b>
    8588:	8b 55 08             	mov    0x8(%ebp),%edx
    858b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    858e:	01 d0                	add    %edx,%eax
    8590:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8593:	8d 4a 04             	lea    0x4(%edx),%ecx
    8596:	8b 55 0c             	mov    0xc(%ebp),%edx
    8599:	01 ca                	add    %ecx,%edx
    859b:	0f b6 12             	movzbl (%edx),%edx
    859e:	88 10                	mov    %dl,(%eax)
    85a0:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    85a4:	83 7d fc 04          	cmpl   $0x4,-0x4(%ebp)
    85a8:	75 de                	jne    8588 <lodepng_chunk_type+0xf>
  type[4] = 0; /*null termination char*/
    85aa:	8b 45 08             	mov    0x8(%ebp),%eax
    85ad:	83 c0 04             	add    $0x4,%eax
    85b0:	c6 00 00             	movb   $0x0,(%eax)
}
    85b3:	90                   	nop
    85b4:	c9                   	leave  
    85b5:	c3                   	ret    

000085b6 <lodepng_chunk_type_equals>:

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type) {
    85b6:	55                   	push   %ebp
    85b7:	89 e5                	mov    %esp,%ebp
  if(lodepng_strlen(type) != 4) return 0;
    85b9:	ff 75 0c             	pushl  0xc(%ebp)
    85bc:	e8 c2 b0 ff ff       	call   3683 <lodepng_strlen>
    85c1:	83 c4 04             	add    $0x4,%esp
    85c4:	83 f8 04             	cmp    $0x4,%eax
    85c7:	74 07                	je     85d0 <lodepng_chunk_type_equals+0x1a>
    85c9:	b8 00 00 00 00       	mov    $0x0,%eax
    85ce:	eb 79                	jmp    8649 <lodepng_chunk_type_equals+0x93>
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
    85d0:	8b 45 08             	mov    0x8(%ebp),%eax
    85d3:	83 c0 04             	add    $0x4,%eax
    85d6:	0f b6 00             	movzbl (%eax),%eax
    85d9:	0f b6 d0             	movzbl %al,%edx
    85dc:	8b 45 0c             	mov    0xc(%ebp),%eax
    85df:	0f b6 00             	movzbl (%eax),%eax
    85e2:	0f be c0             	movsbl %al,%eax
    85e5:	39 c2                	cmp    %eax,%edx
    85e7:	75 5b                	jne    8644 <lodepng_chunk_type_equals+0x8e>
    85e9:	8b 45 08             	mov    0x8(%ebp),%eax
    85ec:	83 c0 05             	add    $0x5,%eax
    85ef:	0f b6 00             	movzbl (%eax),%eax
    85f2:	0f b6 d0             	movzbl %al,%edx
    85f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    85f8:	83 c0 01             	add    $0x1,%eax
    85fb:	0f b6 00             	movzbl (%eax),%eax
    85fe:	0f be c0             	movsbl %al,%eax
    8601:	39 c2                	cmp    %eax,%edx
    8603:	75 3f                	jne    8644 <lodepng_chunk_type_equals+0x8e>
    8605:	8b 45 08             	mov    0x8(%ebp),%eax
    8608:	83 c0 06             	add    $0x6,%eax
    860b:	0f b6 00             	movzbl (%eax),%eax
    860e:	0f b6 d0             	movzbl %al,%edx
    8611:	8b 45 0c             	mov    0xc(%ebp),%eax
    8614:	83 c0 02             	add    $0x2,%eax
    8617:	0f b6 00             	movzbl (%eax),%eax
    861a:	0f be c0             	movsbl %al,%eax
    861d:	39 c2                	cmp    %eax,%edx
    861f:	75 23                	jne    8644 <lodepng_chunk_type_equals+0x8e>
    8621:	8b 45 08             	mov    0x8(%ebp),%eax
    8624:	83 c0 07             	add    $0x7,%eax
    8627:	0f b6 00             	movzbl (%eax),%eax
    862a:	0f b6 d0             	movzbl %al,%edx
    862d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8630:	83 c0 03             	add    $0x3,%eax
    8633:	0f b6 00             	movzbl (%eax),%eax
    8636:	0f be c0             	movsbl %al,%eax
    8639:	39 c2                	cmp    %eax,%edx
    863b:	75 07                	jne    8644 <lodepng_chunk_type_equals+0x8e>
    863d:	b8 01 00 00 00       	mov    $0x1,%eax
    8642:	eb 05                	jmp    8649 <lodepng_chunk_type_equals+0x93>
    8644:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8649:	c9                   	leave  
    864a:	c3                   	ret    

0000864b <lodepng_chunk_ancillary>:

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk) {
    864b:	55                   	push   %ebp
    864c:	89 e5                	mov    %esp,%ebp
  return((chunk[4] & 32) != 0);
    864e:	8b 45 08             	mov    0x8(%ebp),%eax
    8651:	83 c0 04             	add    $0x4,%eax
    8654:	0f b6 00             	movzbl (%eax),%eax
    8657:	0f b6 c0             	movzbl %al,%eax
    865a:	83 e0 20             	and    $0x20,%eax
    865d:	85 c0                	test   %eax,%eax
    865f:	0f 95 c0             	setne  %al
}
    8662:	5d                   	pop    %ebp
    8663:	c3                   	ret    

00008664 <lodepng_chunk_private>:

unsigned char lodepng_chunk_private(const unsigned char* chunk) {
    8664:	55                   	push   %ebp
    8665:	89 e5                	mov    %esp,%ebp
  return((chunk[6] & 32) != 0);
    8667:	8b 45 08             	mov    0x8(%ebp),%eax
    866a:	83 c0 06             	add    $0x6,%eax
    866d:	0f b6 00             	movzbl (%eax),%eax
    8670:	0f b6 c0             	movzbl %al,%eax
    8673:	83 e0 20             	and    $0x20,%eax
    8676:	85 c0                	test   %eax,%eax
    8678:	0f 95 c0             	setne  %al
}
    867b:	5d                   	pop    %ebp
    867c:	c3                   	ret    

0000867d <lodepng_chunk_safetocopy>:

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk) {
    867d:	55                   	push   %ebp
    867e:	89 e5                	mov    %esp,%ebp
  return((chunk[7] & 32) != 0);
    8680:	8b 45 08             	mov    0x8(%ebp),%eax
    8683:	83 c0 07             	add    $0x7,%eax
    8686:	0f b6 00             	movzbl (%eax),%eax
    8689:	0f b6 c0             	movzbl %al,%eax
    868c:	83 e0 20             	and    $0x20,%eax
    868f:	85 c0                	test   %eax,%eax
    8691:	0f 95 c0             	setne  %al
}
    8694:	5d                   	pop    %ebp
    8695:	c3                   	ret    

00008696 <lodepng_chunk_data>:

unsigned char* lodepng_chunk_data(unsigned char* chunk) {
    8696:	55                   	push   %ebp
    8697:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    8699:	8b 45 08             	mov    0x8(%ebp),%eax
    869c:	83 c0 08             	add    $0x8,%eax
}
    869f:	5d                   	pop    %ebp
    86a0:	c3                   	ret    

000086a1 <lodepng_chunk_data_const>:

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk) {
    86a1:	55                   	push   %ebp
    86a2:	89 e5                	mov    %esp,%ebp
  return &chunk[8];
    86a4:	8b 45 08             	mov    0x8(%ebp),%eax
    86a7:	83 c0 08             	add    $0x8,%eax
}
    86aa:	5d                   	pop    %ebp
    86ab:	c3                   	ret    

000086ac <lodepng_chunk_check_crc>:

unsigned lodepng_chunk_check_crc(const unsigned char* chunk) {
    86ac:	55                   	push   %ebp
    86ad:	89 e5                	mov    %esp,%ebp
    86af:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    86b2:	ff 75 08             	pushl  0x8(%ebp)
    86b5:	e8 af fe ff ff       	call   8569 <lodepng_chunk_length>
    86ba:	83 c4 04             	add    $0x4,%esp
    86bd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
    86c0:	8b 45 fc             	mov    -0x4(%ebp),%eax
    86c3:	8d 50 08             	lea    0x8(%eax),%edx
    86c6:	8b 45 08             	mov    0x8(%ebp),%eax
    86c9:	01 d0                	add    %edx,%eax
    86cb:	50                   	push   %eax
    86cc:	e8 94 b2 ff ff       	call   3965 <lodepng_read32bitInt>
    86d1:	83 c4 04             	add    $0x4,%esp
    86d4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
    86d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
    86da:	83 c0 04             	add    $0x4,%eax
    86dd:	89 c2                	mov    %eax,%edx
    86df:	8b 45 08             	mov    0x8(%ebp),%eax
    86e2:	83 c0 04             	add    $0x4,%eax
    86e5:	52                   	push   %edx
    86e6:	50                   	push   %eax
    86e7:	e8 0b fd ff ff       	call   83f7 <lodepng_crc32>
    86ec:	83 c4 08             	add    $0x8,%esp
    86ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(CRC != checksum) return 1;
    86f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
    86f5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    86f8:	74 07                	je     8701 <lodepng_chunk_check_crc+0x55>
    86fa:	b8 01 00 00 00       	mov    $0x1,%eax
    86ff:	eb 05                	jmp    8706 <lodepng_chunk_check_crc+0x5a>
  else return 0;
    8701:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8706:	c9                   	leave  
    8707:	c3                   	ret    

00008708 <lodepng_chunk_generate_crc>:

void lodepng_chunk_generate_crc(unsigned char* chunk) {
    8708:	55                   	push   %ebp
    8709:	89 e5                	mov    %esp,%ebp
    870b:	83 ec 10             	sub    $0x10,%esp
  unsigned length = lodepng_chunk_length(chunk);
    870e:	ff 75 08             	pushl  0x8(%ebp)
    8711:	e8 53 fe ff ff       	call   8569 <lodepng_chunk_length>
    8716:	83 c4 04             	add    $0x4,%esp
    8719:	89 45 fc             	mov    %eax,-0x4(%ebp)
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
    871c:	8b 45 fc             	mov    -0x4(%ebp),%eax
    871f:	83 c0 04             	add    $0x4,%eax
    8722:	89 c2                	mov    %eax,%edx
    8724:	8b 45 08             	mov    0x8(%ebp),%eax
    8727:	83 c0 04             	add    $0x4,%eax
    872a:	52                   	push   %edx
    872b:	50                   	push   %eax
    872c:	e8 c6 fc ff ff       	call   83f7 <lodepng_crc32>
    8731:	83 c4 08             	add    $0x8,%esp
    8734:	89 45 f8             	mov    %eax,-0x8(%ebp)
  lodepng_set32bitInt(chunk + 8 + length, CRC);
    8737:	8b 45 fc             	mov    -0x4(%ebp),%eax
    873a:	8d 50 08             	lea    0x8(%eax),%edx
    873d:	8b 45 08             	mov    0x8(%ebp),%eax
    8740:	01 d0                	add    %edx,%eax
    8742:	ff 75 f8             	pushl  -0x8(%ebp)
    8745:	50                   	push   %eax
    8746:	e8 5d b2 ff ff       	call   39a8 <lodepng_set32bitInt>
    874b:	83 c4 08             	add    $0x8,%esp
}
    874e:	90                   	nop
    874f:	c9                   	leave  
    8750:	c3                   	ret    

00008751 <lodepng_chunk_next>:

unsigned char* lodepng_chunk_next(unsigned char* chunk, unsigned char* end) {
    8751:	55                   	push   %ebp
    8752:	89 e5                	mov    %esp,%ebp
    8754:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    8757:	8b 45 08             	mov    0x8(%ebp),%eax
    875a:	3b 45 0c             	cmp    0xc(%ebp),%eax
    875d:	73 0f                	jae    876e <lodepng_chunk_next+0x1d>
    875f:	8b 55 0c             	mov    0xc(%ebp),%edx
    8762:	8b 45 08             	mov    0x8(%ebp),%eax
    8765:	29 c2                	sub    %eax,%edx
    8767:	89 d0                	mov    %edx,%eax
    8769:	83 f8 0b             	cmp    $0xb,%eax
    876c:	7f 08                	jg     8776 <lodepng_chunk_next+0x25>
    876e:	8b 45 0c             	mov    0xc(%ebp),%eax
    8771:	e9 af 00 00 00       	jmp    8825 <lodepng_chunk_next+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    8776:	8b 45 08             	mov    0x8(%ebp),%eax
    8779:	0f b6 00             	movzbl (%eax),%eax
    877c:	3c 89                	cmp    $0x89,%al
    877e:	75 63                	jne    87e3 <lodepng_chunk_next+0x92>
    8780:	8b 45 08             	mov    0x8(%ebp),%eax
    8783:	83 c0 01             	add    $0x1,%eax
    8786:	0f b6 00             	movzbl (%eax),%eax
    8789:	3c 50                	cmp    $0x50,%al
    878b:	75 56                	jne    87e3 <lodepng_chunk_next+0x92>
    878d:	8b 45 08             	mov    0x8(%ebp),%eax
    8790:	83 c0 02             	add    $0x2,%eax
    8793:	0f b6 00             	movzbl (%eax),%eax
    8796:	3c 4e                	cmp    $0x4e,%al
    8798:	75 49                	jne    87e3 <lodepng_chunk_next+0x92>
    879a:	8b 45 08             	mov    0x8(%ebp),%eax
    879d:	83 c0 03             	add    $0x3,%eax
    87a0:	0f b6 00             	movzbl (%eax),%eax
    87a3:	3c 47                	cmp    $0x47,%al
    87a5:	75 3c                	jne    87e3 <lodepng_chunk_next+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    87a7:	8b 45 08             	mov    0x8(%ebp),%eax
    87aa:	83 c0 04             	add    $0x4,%eax
    87ad:	0f b6 00             	movzbl (%eax),%eax
    87b0:	3c 0d                	cmp    $0xd,%al
    87b2:	75 2f                	jne    87e3 <lodepng_chunk_next+0x92>
    87b4:	8b 45 08             	mov    0x8(%ebp),%eax
    87b7:	83 c0 05             	add    $0x5,%eax
    87ba:	0f b6 00             	movzbl (%eax),%eax
    87bd:	3c 0a                	cmp    $0xa,%al
    87bf:	75 22                	jne    87e3 <lodepng_chunk_next+0x92>
    87c1:	8b 45 08             	mov    0x8(%ebp),%eax
    87c4:	83 c0 06             	add    $0x6,%eax
    87c7:	0f b6 00             	movzbl (%eax),%eax
    87ca:	3c 1a                	cmp    $0x1a,%al
    87cc:	75 15                	jne    87e3 <lodepng_chunk_next+0x92>
    87ce:	8b 45 08             	mov    0x8(%ebp),%eax
    87d1:	83 c0 07             	add    $0x7,%eax
    87d4:	0f b6 00             	movzbl (%eax),%eax
    87d7:	3c 0a                	cmp    $0xa,%al
    87d9:	75 08                	jne    87e3 <lodepng_chunk_next+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    87db:	8b 45 08             	mov    0x8(%ebp),%eax
    87de:	83 c0 08             	add    $0x8,%eax
    87e1:	eb 42                	jmp    8825 <lodepng_chunk_next+0xd4>
  } else {
    size_t total_chunk_length;
    unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    87e3:	ff 75 08             	pushl  0x8(%ebp)
    87e6:	e8 7e fd ff ff       	call   8569 <lodepng_chunk_length>
    87eb:	83 c4 04             	add    $0x4,%esp
    87ee:	89 c2                	mov    %eax,%edx
    87f0:	8d 45 f8             	lea    -0x8(%ebp),%eax
    87f3:	50                   	push   %eax
    87f4:	6a 0c                	push   $0xc
    87f6:	52                   	push   %edx
    87f7:	e8 af ae ff ff       	call   36ab <lodepng_addofl>
    87fc:	83 c4 0c             	add    $0xc,%esp
    87ff:	85 c0                	test   %eax,%eax
    8801:	74 05                	je     8808 <lodepng_chunk_next+0xb7>
    8803:	8b 45 0c             	mov    0xc(%ebp),%eax
    8806:	eb 1d                	jmp    8825 <lodepng_chunk_next+0xd4>
    result = chunk + total_chunk_length;
    8808:	8b 45 f8             	mov    -0x8(%ebp),%eax
    880b:	89 c2                	mov    %eax,%edx
    880d:	8b 45 08             	mov    0x8(%ebp),%eax
    8810:	01 d0                	add    %edx,%eax
    8812:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    8815:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8818:	3b 45 08             	cmp    0x8(%ebp),%eax
    881b:	73 05                	jae    8822 <lodepng_chunk_next+0xd1>
    881d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8820:	eb 03                	jmp    8825 <lodepng_chunk_next+0xd4>
    return result;
    8822:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    8825:	c9                   	leave  
    8826:	c3                   	ret    

00008827 <lodepng_chunk_next_const>:

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk, const unsigned char* end) {
    8827:	55                   	push   %ebp
    8828:	89 e5                	mov    %esp,%ebp
    882a:	83 ec 10             	sub    $0x10,%esp
  if(chunk >= end || end - chunk < 12) return end; /*too small to contain a chunk*/
    882d:	8b 45 08             	mov    0x8(%ebp),%eax
    8830:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8833:	73 0f                	jae    8844 <lodepng_chunk_next_const+0x1d>
    8835:	8b 55 0c             	mov    0xc(%ebp),%edx
    8838:	8b 45 08             	mov    0x8(%ebp),%eax
    883b:	29 c2                	sub    %eax,%edx
    883d:	89 d0                	mov    %edx,%eax
    883f:	83 f8 0b             	cmp    $0xb,%eax
    8842:	7f 08                	jg     884c <lodepng_chunk_next_const+0x25>
    8844:	8b 45 0c             	mov    0xc(%ebp),%eax
    8847:	e9 af 00 00 00       	jmp    88fb <lodepng_chunk_next_const+0xd4>
  if(chunk[0] == 0x89 && chunk[1] == 0x50 && chunk[2] == 0x4e && chunk[3] == 0x47
    884c:	8b 45 08             	mov    0x8(%ebp),%eax
    884f:	0f b6 00             	movzbl (%eax),%eax
    8852:	3c 89                	cmp    $0x89,%al
    8854:	75 63                	jne    88b9 <lodepng_chunk_next_const+0x92>
    8856:	8b 45 08             	mov    0x8(%ebp),%eax
    8859:	83 c0 01             	add    $0x1,%eax
    885c:	0f b6 00             	movzbl (%eax),%eax
    885f:	3c 50                	cmp    $0x50,%al
    8861:	75 56                	jne    88b9 <lodepng_chunk_next_const+0x92>
    8863:	8b 45 08             	mov    0x8(%ebp),%eax
    8866:	83 c0 02             	add    $0x2,%eax
    8869:	0f b6 00             	movzbl (%eax),%eax
    886c:	3c 4e                	cmp    $0x4e,%al
    886e:	75 49                	jne    88b9 <lodepng_chunk_next_const+0x92>
    8870:	8b 45 08             	mov    0x8(%ebp),%eax
    8873:	83 c0 03             	add    $0x3,%eax
    8876:	0f b6 00             	movzbl (%eax),%eax
    8879:	3c 47                	cmp    $0x47,%al
    887b:	75 3c                	jne    88b9 <lodepng_chunk_next_const+0x92>
    && chunk[4] == 0x0d && chunk[5] == 0x0a && chunk[6] == 0x1a && chunk[7] == 0x0a) {
    887d:	8b 45 08             	mov    0x8(%ebp),%eax
    8880:	83 c0 04             	add    $0x4,%eax
    8883:	0f b6 00             	movzbl (%eax),%eax
    8886:	3c 0d                	cmp    $0xd,%al
    8888:	75 2f                	jne    88b9 <lodepng_chunk_next_const+0x92>
    888a:	8b 45 08             	mov    0x8(%ebp),%eax
    888d:	83 c0 05             	add    $0x5,%eax
    8890:	0f b6 00             	movzbl (%eax),%eax
    8893:	3c 0a                	cmp    $0xa,%al
    8895:	75 22                	jne    88b9 <lodepng_chunk_next_const+0x92>
    8897:	8b 45 08             	mov    0x8(%ebp),%eax
    889a:	83 c0 06             	add    $0x6,%eax
    889d:	0f b6 00             	movzbl (%eax),%eax
    88a0:	3c 1a                	cmp    $0x1a,%al
    88a2:	75 15                	jne    88b9 <lodepng_chunk_next_const+0x92>
    88a4:	8b 45 08             	mov    0x8(%ebp),%eax
    88a7:	83 c0 07             	add    $0x7,%eax
    88aa:	0f b6 00             	movzbl (%eax),%eax
    88ad:	3c 0a                	cmp    $0xa,%al
    88af:	75 08                	jne    88b9 <lodepng_chunk_next_const+0x92>
    /* Is PNG magic header at start of PNG file. Jump to first actual chunk. */
    return chunk + 8;
    88b1:	8b 45 08             	mov    0x8(%ebp),%eax
    88b4:	83 c0 08             	add    $0x8,%eax
    88b7:	eb 42                	jmp    88fb <lodepng_chunk_next_const+0xd4>
  } else {
    size_t total_chunk_length;
    const unsigned char* result;
    if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return end;
    88b9:	ff 75 08             	pushl  0x8(%ebp)
    88bc:	e8 a8 fc ff ff       	call   8569 <lodepng_chunk_length>
    88c1:	83 c4 04             	add    $0x4,%esp
    88c4:	89 c2                	mov    %eax,%edx
    88c6:	8d 45 f8             	lea    -0x8(%ebp),%eax
    88c9:	50                   	push   %eax
    88ca:	6a 0c                	push   $0xc
    88cc:	52                   	push   %edx
    88cd:	e8 d9 ad ff ff       	call   36ab <lodepng_addofl>
    88d2:	83 c4 0c             	add    $0xc,%esp
    88d5:	85 c0                	test   %eax,%eax
    88d7:	74 05                	je     88de <lodepng_chunk_next_const+0xb7>
    88d9:	8b 45 0c             	mov    0xc(%ebp),%eax
    88dc:	eb 1d                	jmp    88fb <lodepng_chunk_next_const+0xd4>
    result = chunk + total_chunk_length;
    88de:	8b 45 f8             	mov    -0x8(%ebp),%eax
    88e1:	89 c2                	mov    %eax,%edx
    88e3:	8b 45 08             	mov    0x8(%ebp),%eax
    88e6:	01 d0                	add    %edx,%eax
    88e8:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(result < chunk) return end; /*pointer overflow*/
    88eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    88ee:	3b 45 08             	cmp    0x8(%ebp),%eax
    88f1:	73 05                	jae    88f8 <lodepng_chunk_next_const+0xd1>
    88f3:	8b 45 0c             	mov    0xc(%ebp),%eax
    88f6:	eb 03                	jmp    88fb <lodepng_chunk_next_const+0xd4>
    return result;
    88f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  }
}
    88fb:	c9                   	leave  
    88fc:	c3                   	ret    

000088fd <lodepng_chunk_find>:

unsigned char* lodepng_chunk_find(unsigned char* chunk, unsigned char* end, const char type[5]) {
    88fd:	55                   	push   %ebp
    88fe:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    8900:	8b 45 08             	mov    0x8(%ebp),%eax
    8903:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8906:	73 0f                	jae    8917 <lodepng_chunk_find+0x1a>
    8908:	8b 55 0c             	mov    0xc(%ebp),%edx
    890b:	8b 45 08             	mov    0x8(%ebp),%eax
    890e:	29 c2                	sub    %eax,%edx
    8910:	89 d0                	mov    %edx,%eax
    8912:	83 f8 0b             	cmp    $0xb,%eax
    8915:	7f 07                	jg     891e <lodepng_chunk_find+0x21>
    8917:	b8 00 00 00 00       	mov    $0x0,%eax
    891c:	eb 2a                	jmp    8948 <lodepng_chunk_find+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    891e:	ff 75 10             	pushl  0x10(%ebp)
    8921:	ff 75 08             	pushl  0x8(%ebp)
    8924:	e8 8d fc ff ff       	call   85b6 <lodepng_chunk_type_equals>
    8929:	83 c4 08             	add    $0x8,%esp
    892c:	84 c0                	test   %al,%al
    892e:	74 05                	je     8935 <lodepng_chunk_find+0x38>
    8930:	8b 45 08             	mov    0x8(%ebp),%eax
    8933:	eb 13                	jmp    8948 <lodepng_chunk_find+0x4b>
    chunk = lodepng_chunk_next(chunk, end);
    8935:	ff 75 0c             	pushl  0xc(%ebp)
    8938:	ff 75 08             	pushl  0x8(%ebp)
    893b:	e8 11 fe ff ff       	call   8751 <lodepng_chunk_next>
    8940:	83 c4 08             	add    $0x8,%esp
    8943:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8946:	eb b8                	jmp    8900 <lodepng_chunk_find+0x3>
}
    8948:	c9                   	leave  
    8949:	c3                   	ret    

0000894a <lodepng_chunk_find_const>:

const unsigned char* lodepng_chunk_find_const(const unsigned char* chunk, const unsigned char* end, const char type[5]) {
    894a:	55                   	push   %ebp
    894b:	89 e5                	mov    %esp,%ebp
  for(;;) {
    if(chunk >= end || end - chunk < 12) return 0; /* past file end: chunk + 12 > end */
    894d:	8b 45 08             	mov    0x8(%ebp),%eax
    8950:	3b 45 0c             	cmp    0xc(%ebp),%eax
    8953:	73 0f                	jae    8964 <lodepng_chunk_find_const+0x1a>
    8955:	8b 55 0c             	mov    0xc(%ebp),%edx
    8958:	8b 45 08             	mov    0x8(%ebp),%eax
    895b:	29 c2                	sub    %eax,%edx
    895d:	89 d0                	mov    %edx,%eax
    895f:	83 f8 0b             	cmp    $0xb,%eax
    8962:	7f 07                	jg     896b <lodepng_chunk_find_const+0x21>
    8964:	b8 00 00 00 00       	mov    $0x0,%eax
    8969:	eb 2a                	jmp    8995 <lodepng_chunk_find_const+0x4b>
    if(lodepng_chunk_type_equals(chunk, type)) return chunk;
    896b:	ff 75 10             	pushl  0x10(%ebp)
    896e:	ff 75 08             	pushl  0x8(%ebp)
    8971:	e8 40 fc ff ff       	call   85b6 <lodepng_chunk_type_equals>
    8976:	83 c4 08             	add    $0x8,%esp
    8979:	84 c0                	test   %al,%al
    897b:	74 05                	je     8982 <lodepng_chunk_find_const+0x38>
    897d:	8b 45 08             	mov    0x8(%ebp),%eax
    8980:	eb 13                	jmp    8995 <lodepng_chunk_find_const+0x4b>
    chunk = lodepng_chunk_next_const(chunk, end);
    8982:	ff 75 0c             	pushl  0xc(%ebp)
    8985:	ff 75 08             	pushl  0x8(%ebp)
    8988:	e8 9a fe ff ff       	call   8827 <lodepng_chunk_next_const>
    898d:	83 c4 08             	add    $0x8,%esp
    8990:	89 45 08             	mov    %eax,0x8(%ebp)
  }
    8993:	eb b8                	jmp    894d <lodepng_chunk_find_const+0x3>
}
    8995:	c9                   	leave  
    8996:	c3                   	ret    

00008997 <lodepng_chunk_append>:

unsigned lodepng_chunk_append(unsigned char** out, size_t* outsize, const unsigned char* chunk) {
    8997:	55                   	push   %ebp
    8998:	89 e5                	mov    %esp,%ebp
    899a:	83 ec 20             	sub    $0x20,%esp
  unsigned i;
  size_t total_chunk_length, new_length;
  unsigned char *chunk_start, *new_buffer;

  if(lodepng_addofl(lodepng_chunk_length(chunk), 12, &total_chunk_length)) return 77;
    899d:	ff 75 10             	pushl  0x10(%ebp)
    89a0:	e8 c4 fb ff ff       	call   8569 <lodepng_chunk_length>
    89a5:	83 c4 04             	add    $0x4,%esp
    89a8:	89 c2                	mov    %eax,%edx
    89aa:	8d 45 f0             	lea    -0x10(%ebp),%eax
    89ad:	50                   	push   %eax
    89ae:	6a 0c                	push   $0xc
    89b0:	52                   	push   %edx
    89b1:	e8 f5 ac ff ff       	call   36ab <lodepng_addofl>
    89b6:	83 c4 0c             	add    $0xc,%esp
    89b9:	85 c0                	test   %eax,%eax
    89bb:	74 0a                	je     89c7 <lodepng_chunk_append+0x30>
    89bd:	b8 4d 00 00 00       	mov    $0x4d,%eax
    89c2:	e9 96 00 00 00       	jmp    8a5d <lodepng_chunk_append+0xc6>
  if(lodepng_addofl(*outsize, total_chunk_length, &new_length)) return 77;
    89c7:	8b 55 f0             	mov    -0x10(%ebp),%edx
    89ca:	8b 45 0c             	mov    0xc(%ebp),%eax
    89cd:	8b 00                	mov    (%eax),%eax
    89cf:	8d 4d ec             	lea    -0x14(%ebp),%ecx
    89d2:	51                   	push   %ecx
    89d3:	52                   	push   %edx
    89d4:	50                   	push   %eax
    89d5:	e8 d1 ac ff ff       	call   36ab <lodepng_addofl>
    89da:	83 c4 0c             	add    $0xc,%esp
    89dd:	85 c0                	test   %eax,%eax
    89df:	74 07                	je     89e8 <lodepng_chunk_append+0x51>
    89e1:	b8 4d 00 00 00       	mov    $0x4d,%eax
    89e6:	eb 75                	jmp    8a5d <lodepng_chunk_append+0xc6>

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
    89e8:	8b 55 ec             	mov    -0x14(%ebp),%edx
    89eb:	8b 45 08             	mov    0x8(%ebp),%eax
    89ee:	8b 00                	mov    (%eax),%eax
    89f0:	52                   	push   %edx
    89f1:	50                   	push   %eax
    89f2:	e8 07 ac ff ff       	call   35fe <lodepng_realloc>
    89f7:	83 c4 08             	add    $0x8,%esp
    89fa:	89 45 f8             	mov    %eax,-0x8(%ebp)
  if(!new_buffer) return 83; /*alloc fail*/
    89fd:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    8a01:	75 07                	jne    8a0a <lodepng_chunk_append+0x73>
    8a03:	b8 53 00 00 00       	mov    $0x53,%eax
    8a08:	eb 53                	jmp    8a5d <lodepng_chunk_append+0xc6>
  (*out) = new_buffer;
    8a0a:	8b 45 08             	mov    0x8(%ebp),%eax
    8a0d:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8a10:	89 10                	mov    %edx,(%eax)
  (*outsize) = new_length;
    8a12:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8a15:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a18:	89 10                	mov    %edx,(%eax)
  chunk_start = &(*out)[new_length - total_chunk_length];
    8a1a:	8b 45 08             	mov    0x8(%ebp),%eax
    8a1d:	8b 00                	mov    (%eax),%eax
    8a1f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    8a22:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8a25:	29 d1                	sub    %edx,%ecx
    8a27:	89 ca                	mov    %ecx,%edx
    8a29:	01 d0                	add    %edx,%eax
    8a2b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];
    8a2e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8a35:	eb 19                	jmp    8a50 <lodepng_chunk_append+0xb9>
    8a37:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8a3a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8a3d:	01 c2                	add    %eax,%edx
    8a3f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    8a42:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8a45:	01 c8                	add    %ecx,%eax
    8a47:	0f b6 00             	movzbl (%eax),%eax
    8a4a:	88 02                	mov    %al,(%edx)
    8a4c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8a50:	8b 45 f0             	mov    -0x10(%ebp),%eax
    8a53:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    8a56:	75 df                	jne    8a37 <lodepng_chunk_append+0xa0>

  return 0;
    8a58:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8a5d:	c9                   	leave  
    8a5e:	c3                   	ret    

00008a5f <lodepng_chunk_init>:
set data or crc yet. Returns the start of the chunk in chunk. The start of
the data is at chunk + 8. To finalize chunk, add the data, then use
lodepng_chunk_generate_crc */
static unsigned lodepng_chunk_init(unsigned char** chunk,
                                   ucvector* out,
                                   unsigned length, const char* type) {
    8a5f:	55                   	push   %ebp
    8a60:	89 e5                	mov    %esp,%ebp
    8a62:	83 ec 10             	sub    $0x10,%esp
  size_t new_length = out->size;
    8a65:	8b 45 0c             	mov    0xc(%ebp),%eax
    8a68:	8b 40 04             	mov    0x4(%eax),%eax
    8a6b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  if(lodepng_addofl(new_length, length, &new_length)) return 77;
    8a6e:	8b 55 10             	mov    0x10(%ebp),%edx
    8a71:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8a74:	8d 4d fc             	lea    -0x4(%ebp),%ecx
    8a77:	51                   	push   %ecx
    8a78:	52                   	push   %edx
    8a79:	50                   	push   %eax
    8a7a:	e8 2c ac ff ff       	call   36ab <lodepng_addofl>
    8a7f:	83 c4 0c             	add    $0xc,%esp
    8a82:	85 c0                	test   %eax,%eax
    8a84:	74 07                	je     8a8d <lodepng_chunk_init+0x2e>
    8a86:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8a8b:	eb 78                	jmp    8b05 <lodepng_chunk_init+0xa6>
  if(lodepng_addofl(new_length, 12, &new_length)) return 77;
    8a8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8a90:	8d 55 fc             	lea    -0x4(%ebp),%edx
    8a93:	52                   	push   %edx
    8a94:	6a 0c                	push   $0xc
    8a96:	50                   	push   %eax
    8a97:	e8 0f ac ff ff       	call   36ab <lodepng_addofl>
    8a9c:	83 c4 0c             	add    $0xc,%esp
    8a9f:	85 c0                	test   %eax,%eax
    8aa1:	74 07                	je     8aaa <lodepng_chunk_init+0x4b>
    8aa3:	b8 4d 00 00 00       	mov    $0x4d,%eax
    8aa8:	eb 5b                	jmp    8b05 <lodepng_chunk_init+0xa6>
  if(!ucvector_resize(out, new_length)) return 83; /*alloc fail*/
    8aaa:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8aad:	50                   	push   %eax
    8aae:	ff 75 0c             	pushl  0xc(%ebp)
    8ab1:	e8 8b ad ff ff       	call   3841 <ucvector_resize>
    8ab6:	83 c4 08             	add    $0x8,%esp
    8ab9:	85 c0                	test   %eax,%eax
    8abb:	75 07                	jne    8ac4 <lodepng_chunk_init+0x65>
    8abd:	b8 53 00 00 00       	mov    $0x53,%eax
    8ac2:	eb 41                	jmp    8b05 <lodepng_chunk_init+0xa6>
  *chunk = out->data + new_length - length - 12u;
    8ac4:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ac7:	8b 00                	mov    (%eax),%eax
    8ac9:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8acc:	2b 55 10             	sub    0x10(%ebp),%edx
    8acf:	83 ea 0c             	sub    $0xc,%edx
    8ad2:	01 c2                	add    %eax,%edx
    8ad4:	8b 45 08             	mov    0x8(%ebp),%eax
    8ad7:	89 10                	mov    %edx,(%eax)

  /*1: length*/
  lodepng_set32bitInt(*chunk, length);
    8ad9:	8b 45 08             	mov    0x8(%ebp),%eax
    8adc:	8b 00                	mov    (%eax),%eax
    8ade:	ff 75 10             	pushl  0x10(%ebp)
    8ae1:	50                   	push   %eax
    8ae2:	e8 c1 ae ff ff       	call   39a8 <lodepng_set32bitInt>
    8ae7:	83 c4 08             	add    $0x8,%esp

  /*2: chunk name (4 letters)*/
  lodepng_memcpy(*chunk + 4, type, 4);
    8aea:	8b 45 08             	mov    0x8(%ebp),%eax
    8aed:	8b 00                	mov    (%eax),%eax
    8aef:	83 c0 04             	add    $0x4,%eax
    8af2:	6a 04                	push   $0x4
    8af4:	ff 75 14             	pushl  0x14(%ebp)
    8af7:	50                   	push   %eax
    8af8:	e8 28 ab ff ff       	call   3625 <lodepng_memcpy>
    8afd:	83 c4 0c             	add    $0xc,%esp

  return 0;
    8b00:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8b05:	c9                   	leave  
    8b06:	c3                   	ret    

00008b07 <lodepng_chunk_createv>:

/* like lodepng_chunk_create but with custom allocsize */
static unsigned lodepng_chunk_createv(ucvector* out,
                                      unsigned length, const char* type, const unsigned char* data) {
    8b07:	55                   	push   %ebp
    8b08:	89 e5                	mov    %esp,%ebp
    8b0a:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, length, type));
    8b0d:	ff 75 10             	pushl  0x10(%ebp)
    8b10:	ff 75 0c             	pushl  0xc(%ebp)
    8b13:	ff 75 08             	pushl  0x8(%ebp)
    8b16:	8d 45 f8             	lea    -0x8(%ebp),%eax
    8b19:	50                   	push   %eax
    8b1a:	e8 40 ff ff ff       	call   8a5f <lodepng_chunk_init>
    8b1f:	83 c4 10             	add    $0x10,%esp
    8b22:	89 45 fc             	mov    %eax,-0x4(%ebp)
    8b25:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
    8b29:	74 05                	je     8b30 <lodepng_chunk_createv+0x29>
    8b2b:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8b2e:	eb 27                	jmp    8b57 <lodepng_chunk_createv+0x50>

  /*3: the data*/
  lodepng_memcpy(chunk + 8, data, length);
    8b30:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b33:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8b36:	83 c2 08             	add    $0x8,%edx
    8b39:	50                   	push   %eax
    8b3a:	ff 75 14             	pushl  0x14(%ebp)
    8b3d:	52                   	push   %edx
    8b3e:	e8 e2 aa ff ff       	call   3625 <lodepng_memcpy>
    8b43:	83 c4 0c             	add    $0xc,%esp

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);
    8b46:	8b 45 f8             	mov    -0x8(%ebp),%eax
    8b49:	50                   	push   %eax
    8b4a:	e8 b9 fb ff ff       	call   8708 <lodepng_chunk_generate_crc>
    8b4f:	83 c4 04             	add    $0x4,%esp

  return 0;
    8b52:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8b57:	c9                   	leave  
    8b58:	c3                   	ret    

00008b59 <lodepng_chunk_create>:

unsigned lodepng_chunk_create(unsigned char** out, size_t* outsize,
                              unsigned length, const char* type, const unsigned char* data) {
    8b59:	55                   	push   %ebp
    8b5a:	89 e5                	mov    %esp,%ebp
    8b5c:	83 ec 10             	sub    $0x10,%esp
  ucvector v = ucvector_init(*out, *outsize);
    8b5f:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b62:	8b 08                	mov    (%eax),%ecx
    8b64:	8b 45 08             	mov    0x8(%ebp),%eax
    8b67:	8b 10                	mov    (%eax),%edx
    8b69:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8b6c:	51                   	push   %ecx
    8b6d:	52                   	push   %edx
    8b6e:	50                   	push   %eax
    8b6f:	e8 34 ad ff ff       	call   38a8 <ucvector_init>
    8b74:	83 c4 08             	add    $0x8,%esp
  unsigned error = lodepng_chunk_createv(&v, length, type, data);
    8b77:	ff 75 18             	pushl  0x18(%ebp)
    8b7a:	ff 75 14             	pushl  0x14(%ebp)
    8b7d:	ff 75 10             	pushl  0x10(%ebp)
    8b80:	8d 45 f0             	lea    -0x10(%ebp),%eax
    8b83:	50                   	push   %eax
    8b84:	e8 7e ff ff ff       	call   8b07 <lodepng_chunk_createv>
    8b89:	83 c4 10             	add    $0x10,%esp
    8b8c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *out = v.data;
    8b8f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8b92:	8b 45 08             	mov    0x8(%ebp),%eax
    8b95:	89 10                	mov    %edx,(%eax)
  *outsize = v.size;
    8b97:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8b9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    8b9d:	89 10                	mov    %edx,(%eax)
  return error;
    8b9f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
    8ba2:	c9                   	leave  
    8ba3:	c3                   	ret    

00008ba4 <checkColorValidity>:
/* / Color types, channels, bits                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
    8ba4:	55                   	push   %ebp
    8ba5:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8ba7:	8b 45 08             	mov    0x8(%ebp),%eax
    8baa:	83 f8 03             	cmp    $0x3,%eax
    8bad:	74 6d                	je     8c1c <checkColorValidity+0x78>
    8baf:	83 f8 03             	cmp    $0x3,%eax
    8bb2:	77 0e                	ja     8bc2 <checkColorValidity+0x1e>
    8bb4:	85 c0                	test   %eax,%eax
    8bb6:	74 28                	je     8be0 <checkColorValidity+0x3c>
    8bb8:	83 f8 02             	cmp    $0x2,%eax
    8bbb:	74 4c                	je     8c09 <checkColorValidity+0x65>
    8bbd:	e9 a6 00 00 00       	jmp    8c68 <checkColorValidity+0xc4>
    8bc2:	83 f8 06             	cmp    $0x6,%eax
    8bc5:	0f 84 83 00 00 00    	je     8c4e <checkColorValidity+0xaa>
    8bcb:	3d ff 00 00 00       	cmp    $0xff,%eax
    8bd0:	0f 84 8b 00 00 00    	je     8c61 <checkColorValidity+0xbd>
    8bd6:	83 f8 04             	cmp    $0x4,%eax
    8bd9:	74 60                	je     8c3b <checkColorValidity+0x97>
    8bdb:	e9 88 00 00 00       	jmp    8c68 <checkColorValidity+0xc4>
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    8be0:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8be4:	0f 84 85 00 00 00    	je     8c6f <checkColorValidity+0xcb>
    8bea:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8bee:	74 7f                	je     8c6f <checkColorValidity+0xcb>
    8bf0:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8bf4:	74 79                	je     8c6f <checkColorValidity+0xcb>
    8bf6:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8bfa:	74 73                	je     8c6f <checkColorValidity+0xcb>
    8bfc:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8c00:	74 6d                	je     8c6f <checkColorValidity+0xcb>
    8c02:	b8 25 00 00 00       	mov    $0x25,%eax
    8c07:	eb 78                	jmp    8c81 <checkColorValidity+0xdd>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8c09:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8c0d:	74 63                	je     8c72 <checkColorValidity+0xce>
    8c0f:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8c13:	74 5d                	je     8c72 <checkColorValidity+0xce>
    8c15:	b8 25 00 00 00       	mov    $0x25,%eax
    8c1a:	eb 65                	jmp    8c81 <checkColorValidity+0xdd>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8c1c:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
    8c20:	74 53                	je     8c75 <checkColorValidity+0xd1>
    8c22:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
    8c26:	74 4d                	je     8c75 <checkColorValidity+0xd1>
    8c28:	83 7d 0c 04          	cmpl   $0x4,0xc(%ebp)
    8c2c:	74 47                	je     8c75 <checkColorValidity+0xd1>
    8c2e:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8c32:	74 41                	je     8c75 <checkColorValidity+0xd1>
    8c34:	b8 25 00 00 00       	mov    $0x25,%eax
    8c39:	eb 46                	jmp    8c81 <checkColorValidity+0xdd>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8c3b:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8c3f:	74 37                	je     8c78 <checkColorValidity+0xd4>
    8c41:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8c45:	74 31                	je     8c78 <checkColorValidity+0xd4>
    8c47:	b8 25 00 00 00       	mov    $0x25,%eax
    8c4c:	eb 33                	jmp    8c81 <checkColorValidity+0xdd>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8c4e:	83 7d 0c 08          	cmpl   $0x8,0xc(%ebp)
    8c52:	74 27                	je     8c7b <checkColorValidity+0xd7>
    8c54:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
    8c58:	74 21                	je     8c7b <checkColorValidity+0xd7>
    8c5a:	b8 25 00 00 00       	mov    $0x25,%eax
    8c5f:	eb 20                	jmp    8c81 <checkColorValidity+0xdd>
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    8c61:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8c66:	eb 19                	jmp    8c81 <checkColorValidity+0xdd>
    default: return 31; /* invalid color type */
    8c68:	b8 1f 00 00 00       	mov    $0x1f,%eax
    8c6d:	eb 12                	jmp    8c81 <checkColorValidity+0xdd>

/*checks if the colortype is valid and the bitdepth bd is allowed for this colortype.
Return value is a LodePNG error code.*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) {
  switch(colortype) {
    case LCT_GREY:       if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break;
    8c6f:	90                   	nop
    8c70:	eb 0a                	jmp    8c7c <checkColorValidity+0xd8>
    case LCT_RGB:        if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8c72:	90                   	nop
    8c73:	eb 07                	jmp    8c7c <checkColorValidity+0xd8>
    case LCT_PALETTE:    if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break;
    8c75:	90                   	nop
    8c76:	eb 04                	jmp    8c7c <checkColorValidity+0xd8>
    case LCT_GREY_ALPHA: if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8c78:	90                   	nop
    8c79:	eb 01                	jmp    8c7c <checkColorValidity+0xd8>
    case LCT_RGBA:       if(!(                                 bd == 8 || bd == 16)) return 37; break;
    8c7b:	90                   	nop
    case LCT_MAX_OCTET_VALUE: return 31; /* invalid color type */
    default: return 31; /* invalid color type */
  }
  return 0; /*allowed color type / bits combination*/
    8c7c:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8c81:	5d                   	pop    %ebp
    8c82:	c3                   	ret    

00008c83 <getNumColorChannels>:

static unsigned getNumColorChannels(LodePNGColorType colortype) {
    8c83:	55                   	push   %ebp
    8c84:	89 e5                	mov    %esp,%ebp
  switch(colortype) {
    8c86:	8b 45 08             	mov    0x8(%ebp),%eax
    8c89:	83 f8 03             	cmp    $0x3,%eax
    8c8c:	74 31                	je     8cbf <getNumColorChannels+0x3c>
    8c8e:	83 f8 03             	cmp    $0x3,%eax
    8c91:	77 0b                	ja     8c9e <getNumColorChannels+0x1b>
    8c93:	85 c0                	test   %eax,%eax
    8c95:	74 1a                	je     8cb1 <getNumColorChannels+0x2e>
    8c97:	83 f8 02             	cmp    $0x2,%eax
    8c9a:	74 1c                	je     8cb8 <getNumColorChannels+0x35>
    8c9c:	eb 3d                	jmp    8cdb <getNumColorChannels+0x58>
    8c9e:	83 f8 06             	cmp    $0x6,%eax
    8ca1:	74 2a                	je     8ccd <getNumColorChannels+0x4a>
    8ca3:	3d ff 00 00 00       	cmp    $0xff,%eax
    8ca8:	74 2a                	je     8cd4 <getNumColorChannels+0x51>
    8caa:	83 f8 04             	cmp    $0x4,%eax
    8cad:	74 17                	je     8cc6 <getNumColorChannels+0x43>
    8caf:	eb 2a                	jmp    8cdb <getNumColorChannels+0x58>
    case LCT_GREY: return 1;
    8cb1:	b8 01 00 00 00       	mov    $0x1,%eax
    8cb6:	eb 28                	jmp    8ce0 <getNumColorChannels+0x5d>
    case LCT_RGB: return 3;
    8cb8:	b8 03 00 00 00       	mov    $0x3,%eax
    8cbd:	eb 21                	jmp    8ce0 <getNumColorChannels+0x5d>
    case LCT_PALETTE: return 1;
    8cbf:	b8 01 00 00 00       	mov    $0x1,%eax
    8cc4:	eb 1a                	jmp    8ce0 <getNumColorChannels+0x5d>
    case LCT_GREY_ALPHA: return 2;
    8cc6:	b8 02 00 00 00       	mov    $0x2,%eax
    8ccb:	eb 13                	jmp    8ce0 <getNumColorChannels+0x5d>
    case LCT_RGBA: return 4;
    8ccd:	b8 04 00 00 00       	mov    $0x4,%eax
    8cd2:	eb 0c                	jmp    8ce0 <getNumColorChannels+0x5d>
    case LCT_MAX_OCTET_VALUE: return 0; /* invalid color type */
    8cd4:	b8 00 00 00 00       	mov    $0x0,%eax
    8cd9:	eb 05                	jmp    8ce0 <getNumColorChannels+0x5d>
    default: return 0; /*invalid color type*/
    8cdb:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
    8ce0:	5d                   	pop    %ebp
    8ce1:	c3                   	ret    

00008ce2 <lodepng_get_bpp_lct>:

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth) {
    8ce2:	55                   	push   %ebp
    8ce3:	89 e5                	mov    %esp,%ebp
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
    8ce5:	ff 75 08             	pushl  0x8(%ebp)
    8ce8:	e8 96 ff ff ff       	call   8c83 <getNumColorChannels>
    8ced:	83 c4 04             	add    $0x4,%esp
    8cf0:	0f af 45 0c          	imul   0xc(%ebp),%eax
}
    8cf4:	c9                   	leave  
    8cf5:	c3                   	ret    

00008cf6 <lodepng_color_mode_init>:

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info) {
    8cf6:	55                   	push   %ebp
    8cf7:	89 e5                	mov    %esp,%ebp
  info->key_defined = 0;
    8cf9:	8b 45 08             	mov    0x8(%ebp),%eax
    8cfc:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  info->key_r = info->key_g = info->key_b = 0;
    8d03:	8b 45 08             	mov    0x8(%ebp),%eax
    8d06:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    8d0d:	8b 45 08             	mov    0x8(%ebp),%eax
    8d10:	8b 50 1c             	mov    0x1c(%eax),%edx
    8d13:	8b 45 08             	mov    0x8(%ebp),%eax
    8d16:	89 50 18             	mov    %edx,0x18(%eax)
    8d19:	8b 45 08             	mov    0x8(%ebp),%eax
    8d1c:	8b 50 18             	mov    0x18(%eax),%edx
    8d1f:	8b 45 08             	mov    0x8(%ebp),%eax
    8d22:	89 50 14             	mov    %edx,0x14(%eax)
  info->colortype = LCT_RGBA;
    8d25:	8b 45 08             	mov    0x8(%ebp),%eax
    8d28:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
  info->bitdepth = 8;
    8d2e:	8b 45 08             	mov    0x8(%ebp),%eax
    8d31:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
  info->palette = 0;
    8d38:	8b 45 08             	mov    0x8(%ebp),%eax
    8d3b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    8d42:	8b 45 08             	mov    0x8(%ebp),%eax
    8d45:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    8d4c:	90                   	nop
    8d4d:	5d                   	pop    %ebp
    8d4e:	c3                   	ret    

00008d4f <lodepng_color_mode_alloc_palette>:

/*allocates palette memory if needed, and initializes all colors to black*/
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
    8d4f:	55                   	push   %ebp
    8d50:	89 e5                	mov    %esp,%ebp
    8d52:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
    8d55:	8b 45 08             	mov    0x8(%ebp),%eax
    8d58:	8b 40 08             	mov    0x8(%eax),%eax
    8d5b:	85 c0                	test   %eax,%eax
    8d5d:	75 18                	jne    8d77 <lodepng_color_mode_alloc_palette+0x28>
    8d5f:	83 ec 0c             	sub    $0xc,%esp
    8d62:	68 00 04 00 00       	push   $0x400
    8d67:	e8 7b a8 ff ff       	call   35e7 <lodepng_malloc>
    8d6c:	83 c4 10             	add    $0x10,%esp
    8d6f:	89 c2                	mov    %eax,%edx
    8d71:	8b 45 08             	mov    0x8(%ebp),%eax
    8d74:	89 50 08             	mov    %edx,0x8(%eax)
  if(!info->palette) return; /*alloc fail*/
    8d77:	8b 45 08             	mov    0x8(%ebp),%eax
    8d7a:	8b 40 08             	mov    0x8(%eax),%eax
    8d7d:	85 c0                	test   %eax,%eax
    8d7f:	74 65                	je     8de6 <lodepng_color_mode_alloc_palette+0x97>
  for(i = 0; i != 256; ++i) {
    8d81:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    8d88:	eb 51                	jmp    8ddb <lodepng_color_mode_alloc_palette+0x8c>
    /*Initialize all unused colors with black, the value used for invalid palette indices.
    This is an error according to the PNG spec, but common PNG decoders make it black instead.
    That makes color conversion slightly faster due to no error handling needed.*/
    info->palette[i * 4 + 0] = 0;
    8d8a:	8b 45 08             	mov    0x8(%ebp),%eax
    8d8d:	8b 40 08             	mov    0x8(%eax),%eax
    8d90:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8d93:	c1 e2 02             	shl    $0x2,%edx
    8d96:	01 d0                	add    %edx,%eax
    8d98:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 1] = 0;
    8d9b:	8b 45 08             	mov    0x8(%ebp),%eax
    8d9e:	8b 40 08             	mov    0x8(%eax),%eax
    8da1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8da4:	c1 e2 02             	shl    $0x2,%edx
    8da7:	83 c2 01             	add    $0x1,%edx
    8daa:	01 d0                	add    %edx,%eax
    8dac:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 2] = 0;
    8daf:	8b 45 08             	mov    0x8(%ebp),%eax
    8db2:	8b 40 08             	mov    0x8(%eax),%eax
    8db5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8db8:	c1 e2 02             	shl    $0x2,%edx
    8dbb:	83 c2 02             	add    $0x2,%edx
    8dbe:	01 d0                	add    %edx,%eax
    8dc0:	c6 00 00             	movb   $0x0,(%eax)
    info->palette[i * 4 + 3] = 255;
    8dc3:	8b 45 08             	mov    0x8(%ebp),%eax
    8dc6:	8b 40 08             	mov    0x8(%eax),%eax
    8dc9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8dcc:	c1 e2 02             	shl    $0x2,%edx
    8dcf:	83 c2 03             	add    $0x3,%edx
    8dd2:	01 d0                	add    %edx,%eax
    8dd4:	c6 00 ff             	movb   $0xff,(%eax)
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
  for(i = 0; i != 256; ++i) {
    8dd7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    8ddb:	81 7d f4 00 01 00 00 	cmpl   $0x100,-0xc(%ebp)
    8de2:	75 a6                	jne    8d8a <lodepng_color_mode_alloc_palette+0x3b>
    8de4:	eb 01                	jmp    8de7 <lodepng_color_mode_alloc_palette+0x98>
static void lodepng_color_mode_alloc_palette(LodePNGColorMode* info) {
  size_t i;
  /*if the palette is already allocated, it will have size 1024 so no reallocation needed in that case*/
  /*the palette must have room for up to 256 colors with 4 bytes each.*/
  if(!info->palette) info->palette = (unsigned char*)lodepng_malloc(1024);
  if(!info->palette) return; /*alloc fail*/
    8de6:	90                   	nop
    info->palette[i * 4 + 0] = 0;
    info->palette[i * 4 + 1] = 0;
    info->palette[i * 4 + 2] = 0;
    info->palette[i * 4 + 3] = 255;
  }
}
    8de7:	c9                   	leave  
    8de8:	c3                   	ret    

00008de9 <lodepng_color_mode_cleanup>:

void lodepng_color_mode_cleanup(LodePNGColorMode* info) {
    8de9:	55                   	push   %ebp
    8dea:	89 e5                	mov    %esp,%ebp
    8dec:	83 ec 08             	sub    $0x8,%esp
  lodepng_palette_clear(info);
    8def:	83 ec 0c             	sub    $0xc,%esp
    8df2:	ff 75 08             	pushl  0x8(%ebp)
    8df5:	e8 f3 01 00 00       	call   8fed <lodepng_palette_clear>
    8dfa:	83 c4 10             	add    $0x10,%esp
}
    8dfd:	90                   	nop
    8dfe:	c9                   	leave  
    8dff:	c3                   	ret    

00008e00 <lodepng_color_mode_copy>:

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source) {
    8e00:	55                   	push   %ebp
    8e01:	89 e5                	mov    %esp,%ebp
    8e03:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(dest);
    8e06:	83 ec 0c             	sub    $0xc,%esp
    8e09:	ff 75 08             	pushl  0x8(%ebp)
    8e0c:	e8 d8 ff ff ff       	call   8de9 <lodepng_color_mode_cleanup>
    8e11:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGColorMode));
    8e14:	83 ec 04             	sub    $0x4,%esp
    8e17:	6a 20                	push   $0x20
    8e19:	ff 75 0c             	pushl  0xc(%ebp)
    8e1c:	ff 75 08             	pushl  0x8(%ebp)
    8e1f:	e8 01 a8 ff ff       	call   3625 <lodepng_memcpy>
    8e24:	83 c4 10             	add    $0x10,%esp
  if(source->palette) {
    8e27:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e2a:	8b 40 08             	mov    0x8(%eax),%eax
    8e2d:	85 c0                	test   %eax,%eax
    8e2f:	74 5a                	je     8e8b <lodepng_color_mode_copy+0x8b>
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    8e31:	83 ec 0c             	sub    $0xc,%esp
    8e34:	68 00 04 00 00       	push   $0x400
    8e39:	e8 a9 a7 ff ff       	call   35e7 <lodepng_malloc>
    8e3e:	83 c4 10             	add    $0x10,%esp
    8e41:	89 c2                	mov    %eax,%edx
    8e43:	8b 45 08             	mov    0x8(%ebp),%eax
    8e46:	89 50 08             	mov    %edx,0x8(%eax)
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    8e49:	8b 45 08             	mov    0x8(%ebp),%eax
    8e4c:	8b 40 08             	mov    0x8(%eax),%eax
    8e4f:	85 c0                	test   %eax,%eax
    8e51:	75 11                	jne    8e64 <lodepng_color_mode_copy+0x64>
    8e53:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e56:	8b 40 0c             	mov    0xc(%eax),%eax
    8e59:	85 c0                	test   %eax,%eax
    8e5b:	74 07                	je     8e64 <lodepng_color_mode_copy+0x64>
    8e5d:	b8 53 00 00 00       	mov    $0x53,%eax
    8e62:	eb 2c                	jmp    8e90 <lodepng_color_mode_copy+0x90>
    lodepng_memcpy(dest->palette, source->palette, source->palettesize * 4);
    8e64:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e67:	8b 40 0c             	mov    0xc(%eax),%eax
    8e6a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    8e71:	8b 45 0c             	mov    0xc(%ebp),%eax
    8e74:	8b 50 08             	mov    0x8(%eax),%edx
    8e77:	8b 45 08             	mov    0x8(%ebp),%eax
    8e7a:	8b 40 08             	mov    0x8(%eax),%eax
    8e7d:	83 ec 04             	sub    $0x4,%esp
    8e80:	51                   	push   %ecx
    8e81:	52                   	push   %edx
    8e82:	50                   	push   %eax
    8e83:	e8 9d a7 ff ff       	call   3625 <lodepng_memcpy>
    8e88:	83 c4 10             	add    $0x10,%esp
  }
  return 0;
    8e8b:	b8 00 00 00 00       	mov    $0x0,%eax
}
    8e90:	c9                   	leave  
    8e91:	c3                   	ret    

00008e92 <lodepng_color_mode_make>:

LodePNGColorMode lodepng_color_mode_make(LodePNGColorType colortype, unsigned bitdepth) {
    8e92:	55                   	push   %ebp
    8e93:	89 e5                	mov    %esp,%ebp
    8e95:	83 ec 20             	sub    $0x20,%esp
  LodePNGColorMode result;
  lodepng_color_mode_init(&result);
    8e98:	8d 45 e0             	lea    -0x20(%ebp),%eax
    8e9b:	50                   	push   %eax
    8e9c:	e8 55 fe ff ff       	call   8cf6 <lodepng_color_mode_init>
    8ea1:	83 c4 04             	add    $0x4,%esp
  result.colortype = colortype;
    8ea4:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ea7:	89 45 e0             	mov    %eax,-0x20(%ebp)
  result.bitdepth = bitdepth;
    8eaa:	8b 45 10             	mov    0x10(%ebp),%eax
    8ead:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  return result;
    8eb0:	8b 45 08             	mov    0x8(%ebp),%eax
    8eb3:	8b 55 e0             	mov    -0x20(%ebp),%edx
    8eb6:	89 10                	mov    %edx,(%eax)
    8eb8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    8ebb:	89 50 04             	mov    %edx,0x4(%eax)
    8ebe:	8b 55 e8             	mov    -0x18(%ebp),%edx
    8ec1:	89 50 08             	mov    %edx,0x8(%eax)
    8ec4:	8b 55 ec             	mov    -0x14(%ebp),%edx
    8ec7:	89 50 0c             	mov    %edx,0xc(%eax)
    8eca:	8b 55 f0             	mov    -0x10(%ebp),%edx
    8ecd:	89 50 10             	mov    %edx,0x10(%eax)
    8ed0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    8ed3:	89 50 14             	mov    %edx,0x14(%eax)
    8ed6:	8b 55 f8             	mov    -0x8(%ebp),%edx
    8ed9:	89 50 18             	mov    %edx,0x18(%eax)
    8edc:	8b 55 fc             	mov    -0x4(%ebp),%edx
    8edf:	89 50 1c             	mov    %edx,0x1c(%eax)
}
    8ee2:	8b 45 08             	mov    0x8(%ebp),%eax
    8ee5:	c9                   	leave  
    8ee6:	c2 04 00             	ret    $0x4

00008ee9 <lodepng_color_mode_equal>:

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b) {
    8ee9:	55                   	push   %ebp
    8eea:	89 e5                	mov    %esp,%ebp
    8eec:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  if(a->colortype != b->colortype) return 0;
    8eef:	8b 45 08             	mov    0x8(%ebp),%eax
    8ef2:	8b 10                	mov    (%eax),%edx
    8ef4:	8b 45 0c             	mov    0xc(%ebp),%eax
    8ef7:	8b 00                	mov    (%eax),%eax
    8ef9:	39 c2                	cmp    %eax,%edx
    8efb:	74 0a                	je     8f07 <lodepng_color_mode_equal+0x1e>
    8efd:	b8 00 00 00 00       	mov    $0x0,%eax
    8f02:	e9 e4 00 00 00       	jmp    8feb <lodepng_color_mode_equal+0x102>
  if(a->bitdepth != b->bitdepth) return 0;
    8f07:	8b 45 08             	mov    0x8(%ebp),%eax
    8f0a:	8b 50 04             	mov    0x4(%eax),%edx
    8f0d:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f10:	8b 40 04             	mov    0x4(%eax),%eax
    8f13:	39 c2                	cmp    %eax,%edx
    8f15:	74 0a                	je     8f21 <lodepng_color_mode_equal+0x38>
    8f17:	b8 00 00 00 00       	mov    $0x0,%eax
    8f1c:	e9 ca 00 00 00       	jmp    8feb <lodepng_color_mode_equal+0x102>
  if(a->key_defined != b->key_defined) return 0;
    8f21:	8b 45 08             	mov    0x8(%ebp),%eax
    8f24:	8b 50 10             	mov    0x10(%eax),%edx
    8f27:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f2a:	8b 40 10             	mov    0x10(%eax),%eax
    8f2d:	39 c2                	cmp    %eax,%edx
    8f2f:	74 0a                	je     8f3b <lodepng_color_mode_equal+0x52>
    8f31:	b8 00 00 00 00       	mov    $0x0,%eax
    8f36:	e9 b0 00 00 00       	jmp    8feb <lodepng_color_mode_equal+0x102>
  if(a->key_defined) {
    8f3b:	8b 45 08             	mov    0x8(%ebp),%eax
    8f3e:	8b 40 10             	mov    0x10(%eax),%eax
    8f41:	85 c0                	test   %eax,%eax
    8f43:	74 48                	je     8f8d <lodepng_color_mode_equal+0xa4>
    if(a->key_r != b->key_r) return 0;
    8f45:	8b 45 08             	mov    0x8(%ebp),%eax
    8f48:	8b 50 14             	mov    0x14(%eax),%edx
    8f4b:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f4e:	8b 40 14             	mov    0x14(%eax),%eax
    8f51:	39 c2                	cmp    %eax,%edx
    8f53:	74 0a                	je     8f5f <lodepng_color_mode_equal+0x76>
    8f55:	b8 00 00 00 00       	mov    $0x0,%eax
    8f5a:	e9 8c 00 00 00       	jmp    8feb <lodepng_color_mode_equal+0x102>
    if(a->key_g != b->key_g) return 0;
    8f5f:	8b 45 08             	mov    0x8(%ebp),%eax
    8f62:	8b 50 18             	mov    0x18(%eax),%edx
    8f65:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f68:	8b 40 18             	mov    0x18(%eax),%eax
    8f6b:	39 c2                	cmp    %eax,%edx
    8f6d:	74 07                	je     8f76 <lodepng_color_mode_equal+0x8d>
    8f6f:	b8 00 00 00 00       	mov    $0x0,%eax
    8f74:	eb 75                	jmp    8feb <lodepng_color_mode_equal+0x102>
    if(a->key_b != b->key_b) return 0;
    8f76:	8b 45 08             	mov    0x8(%ebp),%eax
    8f79:	8b 50 1c             	mov    0x1c(%eax),%edx
    8f7c:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f7f:	8b 40 1c             	mov    0x1c(%eax),%eax
    8f82:	39 c2                	cmp    %eax,%edx
    8f84:	74 07                	je     8f8d <lodepng_color_mode_equal+0xa4>
    8f86:	b8 00 00 00 00       	mov    $0x0,%eax
    8f8b:	eb 5e                	jmp    8feb <lodepng_color_mode_equal+0x102>
  }
  if(a->palettesize != b->palettesize) return 0;
    8f8d:	8b 45 08             	mov    0x8(%ebp),%eax
    8f90:	8b 50 0c             	mov    0xc(%eax),%edx
    8f93:	8b 45 0c             	mov    0xc(%ebp),%eax
    8f96:	8b 40 0c             	mov    0xc(%eax),%eax
    8f99:	39 c2                	cmp    %eax,%edx
    8f9b:	74 07                	je     8fa4 <lodepng_color_mode_equal+0xbb>
    8f9d:	b8 00 00 00 00       	mov    $0x0,%eax
    8fa2:	eb 47                	jmp    8feb <lodepng_color_mode_equal+0x102>
  for(i = 0; i != a->palettesize * 4; ++i) {
    8fa4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    8fab:	eb 2b                	jmp    8fd8 <lodepng_color_mode_equal+0xef>
    if(a->palette[i] != b->palette[i]) return 0;
    8fad:	8b 45 08             	mov    0x8(%ebp),%eax
    8fb0:	8b 50 08             	mov    0x8(%eax),%edx
    8fb3:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8fb6:	01 d0                	add    %edx,%eax
    8fb8:	0f b6 10             	movzbl (%eax),%edx
    8fbb:	8b 45 0c             	mov    0xc(%ebp),%eax
    8fbe:	8b 48 08             	mov    0x8(%eax),%ecx
    8fc1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    8fc4:	01 c8                	add    %ecx,%eax
    8fc6:	0f b6 00             	movzbl (%eax),%eax
    8fc9:	38 c2                	cmp    %al,%dl
    8fcb:	74 07                	je     8fd4 <lodepng_color_mode_equal+0xeb>
    8fcd:	b8 00 00 00 00       	mov    $0x0,%eax
    8fd2:	eb 17                	jmp    8feb <lodepng_color_mode_equal+0x102>
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i) {
    8fd4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    8fd8:	8b 45 08             	mov    0x8(%ebp),%eax
    8fdb:	8b 40 0c             	mov    0xc(%eax),%eax
    8fde:	c1 e0 02             	shl    $0x2,%eax
    8fe1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    8fe4:	75 c7                	jne    8fad <lodepng_color_mode_equal+0xc4>
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
    8fe6:	b8 01 00 00 00       	mov    $0x1,%eax
}
    8feb:	c9                   	leave  
    8fec:	c3                   	ret    

00008fed <lodepng_palette_clear>:

void lodepng_palette_clear(LodePNGColorMode* info) {
    8fed:	55                   	push   %ebp
    8fee:	89 e5                	mov    %esp,%ebp
    8ff0:	83 ec 08             	sub    $0x8,%esp
  if(info->palette) lodepng_free(info->palette);
    8ff3:	8b 45 08             	mov    0x8(%ebp),%eax
    8ff6:	8b 40 08             	mov    0x8(%eax),%eax
    8ff9:	85 c0                	test   %eax,%eax
    8ffb:	74 12                	je     900f <lodepng_palette_clear+0x22>
    8ffd:	8b 45 08             	mov    0x8(%ebp),%eax
    9000:	8b 40 08             	mov    0x8(%eax),%eax
    9003:	83 ec 0c             	sub    $0xc,%esp
    9006:	50                   	push   %eax
    9007:	e8 fc a5 ff ff       	call   3608 <lodepng_free>
    900c:	83 c4 10             	add    $0x10,%esp
  info->palette = 0;
    900f:	8b 45 08             	mov    0x8(%ebp),%eax
    9012:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->palettesize = 0;
    9019:	8b 45 08             	mov    0x8(%ebp),%eax
    901c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
    9023:	90                   	nop
    9024:	c9                   	leave  
    9025:	c3                   	ret    

00009026 <lodepng_palette_add>:

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9026:	55                   	push   %ebp
    9027:	89 e5                	mov    %esp,%ebp
    9029:	53                   	push   %ebx
    902a:	83 ec 14             	sub    $0x14,%esp
    902d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9030:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9033:	8b 55 14             	mov    0x14(%ebp),%edx
    9036:	8b 45 18             	mov    0x18(%ebp),%eax
    9039:	88 5d f4             	mov    %bl,-0xc(%ebp)
    903c:	88 4d f0             	mov    %cl,-0x10(%ebp)
    903f:	88 55 ec             	mov    %dl,-0x14(%ebp)
    9042:	88 45 e8             	mov    %al,-0x18(%ebp)
  if(!info->palette) /*allocate palette if empty*/ {
    9045:	8b 45 08             	mov    0x8(%ebp),%eax
    9048:	8b 40 08             	mov    0x8(%eax),%eax
    904b:	85 c0                	test   %eax,%eax
    904d:	75 22                	jne    9071 <lodepng_palette_add+0x4b>
    lodepng_color_mode_alloc_palette(info);
    904f:	83 ec 0c             	sub    $0xc,%esp
    9052:	ff 75 08             	pushl  0x8(%ebp)
    9055:	e8 f5 fc ff ff       	call   8d4f <lodepng_color_mode_alloc_palette>
    905a:	83 c4 10             	add    $0x10,%esp
    if(!info->palette) return 83; /*alloc fail*/
    905d:	8b 45 08             	mov    0x8(%ebp),%eax
    9060:	8b 40 08             	mov    0x8(%eax),%eax
    9063:	85 c0                	test   %eax,%eax
    9065:	75 0a                	jne    9071 <lodepng_palette_add+0x4b>
    9067:	b8 53 00 00 00       	mov    $0x53,%eax
    906c:	e9 8d 00 00 00       	jmp    90fe <lodepng_palette_add+0xd8>
  }
  if(info->palettesize >= 256) {
    9071:	8b 45 08             	mov    0x8(%ebp),%eax
    9074:	8b 40 0c             	mov    0xc(%eax),%eax
    9077:	3d ff 00 00 00       	cmp    $0xff,%eax
    907c:	7e 07                	jle    9085 <lodepng_palette_add+0x5f>
    return 108; /*too many palette values*/
    907e:	b8 6c 00 00 00       	mov    $0x6c,%eax
    9083:	eb 79                	jmp    90fe <lodepng_palette_add+0xd8>
  }
  info->palette[4 * info->palettesize + 0] = r;
    9085:	8b 45 08             	mov    0x8(%ebp),%eax
    9088:	8b 50 08             	mov    0x8(%eax),%edx
    908b:	8b 45 08             	mov    0x8(%ebp),%eax
    908e:	8b 40 0c             	mov    0xc(%eax),%eax
    9091:	c1 e0 02             	shl    $0x2,%eax
    9094:	01 c2                	add    %eax,%edx
    9096:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
    909a:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 1] = g;
    909c:	8b 45 08             	mov    0x8(%ebp),%eax
    909f:	8b 50 08             	mov    0x8(%eax),%edx
    90a2:	8b 45 08             	mov    0x8(%ebp),%eax
    90a5:	8b 40 0c             	mov    0xc(%eax),%eax
    90a8:	c1 e0 02             	shl    $0x2,%eax
    90ab:	83 c0 01             	add    $0x1,%eax
    90ae:	01 c2                	add    %eax,%edx
    90b0:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
    90b4:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 2] = b;
    90b6:	8b 45 08             	mov    0x8(%ebp),%eax
    90b9:	8b 50 08             	mov    0x8(%eax),%edx
    90bc:	8b 45 08             	mov    0x8(%ebp),%eax
    90bf:	8b 40 0c             	mov    0xc(%eax),%eax
    90c2:	c1 e0 02             	shl    $0x2,%eax
    90c5:	83 c0 02             	add    $0x2,%eax
    90c8:	01 c2                	add    %eax,%edx
    90ca:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    90ce:	88 02                	mov    %al,(%edx)
  info->palette[4 * info->palettesize + 3] = a;
    90d0:	8b 45 08             	mov    0x8(%ebp),%eax
    90d3:	8b 50 08             	mov    0x8(%eax),%edx
    90d6:	8b 45 08             	mov    0x8(%ebp),%eax
    90d9:	8b 40 0c             	mov    0xc(%eax),%eax
    90dc:	c1 e0 02             	shl    $0x2,%eax
    90df:	83 c0 03             	add    $0x3,%eax
    90e2:	01 c2                	add    %eax,%edx
    90e4:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    90e8:	88 02                	mov    %al,(%edx)
  ++info->palettesize;
    90ea:	8b 45 08             	mov    0x8(%ebp),%eax
    90ed:	8b 40 0c             	mov    0xc(%eax),%eax
    90f0:	8d 50 01             	lea    0x1(%eax),%edx
    90f3:	8b 45 08             	mov    0x8(%ebp),%eax
    90f6:	89 50 0c             	mov    %edx,0xc(%eax)
  return 0;
    90f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    90fe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9101:	c9                   	leave  
    9102:	c3                   	ret    

00009103 <lodepng_get_bpp>:

/*calculate bits per pixel out of colortype and bitdepth*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info) {
    9103:	55                   	push   %ebp
    9104:	89 e5                	mov    %esp,%ebp
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
    9106:	8b 45 08             	mov    0x8(%ebp),%eax
    9109:	8b 50 04             	mov    0x4(%eax),%edx
    910c:	8b 45 08             	mov    0x8(%ebp),%eax
    910f:	8b 00                	mov    (%eax),%eax
    9111:	52                   	push   %edx
    9112:	50                   	push   %eax
    9113:	e8 ca fb ff ff       	call   8ce2 <lodepng_get_bpp_lct>
    9118:	83 c4 08             	add    $0x8,%esp
}
    911b:	c9                   	leave  
    911c:	c3                   	ret    

0000911d <lodepng_get_channels>:

unsigned lodepng_get_channels(const LodePNGColorMode* info) {
    911d:	55                   	push   %ebp
    911e:	89 e5                	mov    %esp,%ebp
  return getNumColorChannels(info->colortype);
    9120:	8b 45 08             	mov    0x8(%ebp),%eax
    9123:	8b 00                	mov    (%eax),%eax
    9125:	50                   	push   %eax
    9126:	e8 58 fb ff ff       	call   8c83 <getNumColorChannels>
    912b:	83 c4 04             	add    $0x4,%esp
}
    912e:	c9                   	leave  
    912f:	c3                   	ret    

00009130 <lodepng_is_greyscale_type>:

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info) {
    9130:	55                   	push   %ebp
    9131:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
    9133:	8b 45 08             	mov    0x8(%ebp),%eax
    9136:	8b 00                	mov    (%eax),%eax
    9138:	85 c0                	test   %eax,%eax
    913a:	74 0a                	je     9146 <lodepng_is_greyscale_type+0x16>
    913c:	8b 45 08             	mov    0x8(%ebp),%eax
    913f:	8b 00                	mov    (%eax),%eax
    9141:	83 f8 04             	cmp    $0x4,%eax
    9144:	75 07                	jne    914d <lodepng_is_greyscale_type+0x1d>
    9146:	b8 01 00 00 00       	mov    $0x1,%eax
    914b:	eb 05                	jmp    9152 <lodepng_is_greyscale_type+0x22>
    914d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9152:	5d                   	pop    %ebp
    9153:	c3                   	ret    

00009154 <lodepng_is_alpha_type>:

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info) {
    9154:	55                   	push   %ebp
    9155:	89 e5                	mov    %esp,%ebp
  return (info->colortype & 4) != 0; /*4 or 6*/
    9157:	8b 45 08             	mov    0x8(%ebp),%eax
    915a:	8b 00                	mov    (%eax),%eax
    915c:	83 e0 04             	and    $0x4,%eax
    915f:	85 c0                	test   %eax,%eax
    9161:	0f 95 c0             	setne  %al
    9164:	0f b6 c0             	movzbl %al,%eax
}
    9167:	5d                   	pop    %ebp
    9168:	c3                   	ret    

00009169 <lodepng_is_palette_type>:

unsigned lodepng_is_palette_type(const LodePNGColorMode* info) {
    9169:	55                   	push   %ebp
    916a:	89 e5                	mov    %esp,%ebp
  return info->colortype == LCT_PALETTE;
    916c:	8b 45 08             	mov    0x8(%ebp),%eax
    916f:	8b 00                	mov    (%eax),%eax
    9171:	83 f8 03             	cmp    $0x3,%eax
    9174:	0f 94 c0             	sete   %al
    9177:	0f b6 c0             	movzbl %al,%eax
}
    917a:	5d                   	pop    %ebp
    917b:	c3                   	ret    

0000917c <lodepng_has_palette_alpha>:

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
    917c:	55                   	push   %ebp
    917d:	89 e5                	mov    %esp,%ebp
    917f:	83 ec 10             	sub    $0x10,%esp
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    9182:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    9189:	eb 23                	jmp    91ae <lodepng_has_palette_alpha+0x32>
    if(info->palette[i * 4 + 3] < 255) return 1;
    918b:	8b 45 08             	mov    0x8(%ebp),%eax
    918e:	8b 40 08             	mov    0x8(%eax),%eax
    9191:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9194:	c1 e2 02             	shl    $0x2,%edx
    9197:	83 c2 03             	add    $0x3,%edx
    919a:	01 d0                	add    %edx,%eax
    919c:	0f b6 00             	movzbl (%eax),%eax
    919f:	3c ff                	cmp    $0xff,%al
    91a1:	74 07                	je     91aa <lodepng_has_palette_alpha+0x2e>
    91a3:	b8 01 00 00 00       	mov    $0x1,%eax
    91a8:	eb 14                	jmp    91be <lodepng_has_palette_alpha+0x42>
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info) {
  size_t i;
  for(i = 0; i != info->palettesize; ++i) {
    91aa:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    91ae:	8b 45 08             	mov    0x8(%ebp),%eax
    91b1:	8b 40 0c             	mov    0xc(%eax),%eax
    91b4:	3b 45 fc             	cmp    -0x4(%ebp),%eax
    91b7:	75 d2                	jne    918b <lodepng_has_palette_alpha+0xf>
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
    91b9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    91be:	c9                   	leave  
    91bf:	c3                   	ret    

000091c0 <lodepng_can_have_alpha>:

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
    91c0:	55                   	push   %ebp
    91c1:	89 e5                	mov    %esp,%ebp
  return info->key_defined
    91c3:	8b 45 08             	mov    0x8(%ebp),%eax
    91c6:	8b 40 10             	mov    0x10(%eax),%eax
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
    91c9:	85 c0                	test   %eax,%eax
    91cb:	75 1e                	jne    91eb <lodepng_can_have_alpha+0x2b>
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info) {
  return info->key_defined
      || lodepng_is_alpha_type(info)
    91cd:	ff 75 08             	pushl  0x8(%ebp)
    91d0:	e8 7f ff ff ff       	call   9154 <lodepng_is_alpha_type>
    91d5:	83 c4 04             	add    $0x4,%esp
    91d8:	85 c0                	test   %eax,%eax
    91da:	75 0f                	jne    91eb <lodepng_can_have_alpha+0x2b>
      || lodepng_has_palette_alpha(info);
    91dc:	ff 75 08             	pushl  0x8(%ebp)
    91df:	e8 98 ff ff ff       	call   917c <lodepng_has_palette_alpha>
    91e4:	83 c4 04             	add    $0x4,%esp
    91e7:	85 c0                	test   %eax,%eax
    91e9:	74 07                	je     91f2 <lodepng_can_have_alpha+0x32>
    91eb:	b8 01 00 00 00       	mov    $0x1,%eax
    91f0:	eb 05                	jmp    91f7 <lodepng_can_have_alpha+0x37>
    91f2:	b8 00 00 00 00       	mov    $0x0,%eax
}
    91f7:	c9                   	leave  
    91f8:	c3                   	ret    

000091f9 <lodepng_get_raw_size_lct>:

static size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
    91f9:	55                   	push   %ebp
    91fa:	89 e5                	mov    %esp,%ebp
    91fc:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = lodepng_get_bpp_lct(colortype, bitdepth);
    91ff:	ff 75 14             	pushl  0x14(%ebp)
    9202:	ff 75 10             	pushl  0x10(%ebp)
    9205:	e8 d8 fa ff ff       	call   8ce2 <lodepng_get_bpp_lct>
    920a:	83 c4 08             	add    $0x8,%esp
    920d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  size_t n = (size_t)w * (size_t)h;
    9210:	8b 55 08             	mov    0x8(%ebp),%edx
    9213:	8b 45 0c             	mov    0xc(%ebp),%eax
    9216:	0f af c2             	imul   %edx,%eax
    9219:	89 45 f8             	mov    %eax,-0x8(%ebp)
  return ((n / 8u) * bpp) + ((n & 7u) * bpp + 7u) / 8u;
    921c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    921f:	c1 e8 03             	shr    $0x3,%eax
    9222:	89 c2                	mov    %eax,%edx
    9224:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9227:	0f af c2             	imul   %edx,%eax
    922a:	8b 55 f8             	mov    -0x8(%ebp),%edx
    922d:	89 d1                	mov    %edx,%ecx
    922f:	83 e1 07             	and    $0x7,%ecx
    9232:	8b 55 fc             	mov    -0x4(%ebp),%edx
    9235:	0f af d1             	imul   %ecx,%edx
    9238:	83 c2 07             	add    $0x7,%edx
    923b:	c1 ea 03             	shr    $0x3,%edx
    923e:	01 d0                	add    %edx,%eax
}
    9240:	c9                   	leave  
    9241:	c3                   	ret    

00009242 <lodepng_get_raw_size>:

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color) {
    9242:	55                   	push   %ebp
    9243:	89 e5                	mov    %esp,%ebp
  return lodepng_get_raw_size_lct(w, h, color->colortype, color->bitdepth);
    9245:	8b 45 10             	mov    0x10(%ebp),%eax
    9248:	8b 50 04             	mov    0x4(%eax),%edx
    924b:	8b 45 10             	mov    0x10(%ebp),%eax
    924e:	8b 00                	mov    (%eax),%eax
    9250:	52                   	push   %edx
    9251:	50                   	push   %eax
    9252:	ff 75 0c             	pushl  0xc(%ebp)
    9255:	ff 75 08             	pushl  0x8(%ebp)
    9258:	e8 9c ff ff ff       	call   91f9 <lodepng_get_raw_size_lct>
    925d:	83 c4 10             	add    $0x10,%esp
}
    9260:	c9                   	leave  
    9261:	c3                   	ret    

00009262 <lodepng_get_raw_size_idat>:
#ifdef LODEPNG_COMPILE_PNG

/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer,
and in addition has one extra byte per line: the filter byte. So this gives a larger
result than lodepng_get_raw_size. Set h to 1 to get the size of 1 row including filter byte. */
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, unsigned bpp) {
    9262:	55                   	push   %ebp
    9263:	89 e5                	mov    %esp,%ebp
    9265:	83 ec 10             	sub    $0x10,%esp
  /* + 1 for the filter byte, and possibly plus padding bits per line. */
  /* Ignoring casts, the expression is equal to (w * bpp + 7) / 8 + 1, but avoids overflow of w * bpp */
  size_t line = ((size_t)(w / 8u) * bpp) + 1u + ((w & 7u) * bpp + 7u) / 8u;
    9268:	8b 45 08             	mov    0x8(%ebp),%eax
    926b:	c1 e8 03             	shr    $0x3,%eax
    926e:	0f af 45 10          	imul   0x10(%ebp),%eax
    9272:	8b 55 08             	mov    0x8(%ebp),%edx
    9275:	83 e2 07             	and    $0x7,%edx
    9278:	0f af 55 10          	imul   0x10(%ebp),%edx
    927c:	83 c2 07             	add    $0x7,%edx
    927f:	c1 ea 03             	shr    $0x3,%edx
    9282:	01 d0                	add    %edx,%eax
    9284:	83 c0 01             	add    $0x1,%eax
    9287:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return (size_t)h * line;
    928a:	8b 45 0c             	mov    0xc(%ebp),%eax
    928d:	0f af 45 fc          	imul   -0x4(%ebp),%eax
}
    9291:	c9                   	leave  
    9292:	c3                   	ret    

00009293 <lodepng_pixel_overflow>:
-amount of bytes in IDAT (including filter, padding and Adam7 bytes)
-amount of bytes in raw color model
Returns 1 if overflow possible, 0 if not.
*/
static int lodepng_pixel_overflow(unsigned w, unsigned h,
                                  const LodePNGColorMode* pngcolor, const LodePNGColorMode* rawcolor) {
    9293:	55                   	push   %ebp
    9294:	89 e5                	mov    %esp,%ebp
    9296:	53                   	push   %ebx
    9297:	83 ec 10             	sub    $0x10,%esp
  size_t bpp = LODEPNG_MAX(lodepng_get_bpp(pngcolor), lodepng_get_bpp(rawcolor));
    929a:	ff 75 10             	pushl  0x10(%ebp)
    929d:	e8 61 fe ff ff       	call   9103 <lodepng_get_bpp>
    92a2:	83 c4 04             	add    $0x4,%esp
    92a5:	89 c3                	mov    %eax,%ebx
    92a7:	ff 75 14             	pushl  0x14(%ebp)
    92aa:	e8 54 fe ff ff       	call   9103 <lodepng_get_bpp>
    92af:	83 c4 04             	add    $0x4,%esp
    92b2:	39 c3                	cmp    %eax,%ebx
    92b4:	76 0d                	jbe    92c3 <lodepng_pixel_overflow+0x30>
    92b6:	ff 75 10             	pushl  0x10(%ebp)
    92b9:	e8 45 fe ff ff       	call   9103 <lodepng_get_bpp>
    92be:	83 c4 04             	add    $0x4,%esp
    92c1:	eb 0b                	jmp    92ce <lodepng_pixel_overflow+0x3b>
    92c3:	ff 75 14             	pushl  0x14(%ebp)
    92c6:	e8 38 fe ff ff       	call   9103 <lodepng_get_bpp>
    92cb:	83 c4 04             	add    $0x4,%esp
    92ce:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t numpixels, total;
  size_t line; /* bytes per line in worst case */

  if(lodepng_mulofl((size_t)w, (size_t)h, &numpixels)) return 1;
    92d1:	8b 55 0c             	mov    0xc(%ebp),%edx
    92d4:	8b 45 08             	mov    0x8(%ebp),%eax
    92d7:	8d 4d f4             	lea    -0xc(%ebp),%ecx
    92da:	51                   	push   %ecx
    92db:	52                   	push   %edx
    92dc:	50                   	push   %eax
    92dd:	e8 e9 a3 ff ff       	call   36cb <lodepng_mulofl>
    92e2:	83 c4 0c             	add    $0xc,%esp
    92e5:	85 c0                	test   %eax,%eax
    92e7:	74 0a                	je     92f3 <lodepng_pixel_overflow+0x60>
    92e9:	b8 01 00 00 00       	mov    $0x1,%eax
    92ee:	e9 b6 00 00 00       	jmp    93a9 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(numpixels, 8, &total)) return 1; /* bit pointer with 8-bit color, or 8 bytes per channel color */
    92f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    92f6:	8d 55 f0             	lea    -0x10(%ebp),%edx
    92f9:	52                   	push   %edx
    92fa:	6a 08                	push   $0x8
    92fc:	50                   	push   %eax
    92fd:	e8 c9 a3 ff ff       	call   36cb <lodepng_mulofl>
    9302:	83 c4 0c             	add    $0xc,%esp
    9305:	85 c0                	test   %eax,%eax
    9307:	74 0a                	je     9313 <lodepng_pixel_overflow+0x80>
    9309:	b8 01 00 00 00       	mov    $0x1,%eax
    930e:	e9 96 00 00 00       	jmp    93a9 <lodepng_pixel_overflow+0x116>

  /* Bytes per scanline with the expression "(w / 8u) * bpp) + ((w & 7u) * bpp + 7u) / 8u" */
  if(lodepng_mulofl((size_t)(w / 8u), bpp, &line)) return 1;
    9313:	8b 45 08             	mov    0x8(%ebp),%eax
    9316:	c1 e8 03             	shr    $0x3,%eax
    9319:	89 c2                	mov    %eax,%edx
    931b:	8d 45 ec             	lea    -0x14(%ebp),%eax
    931e:	50                   	push   %eax
    931f:	ff 75 f8             	pushl  -0x8(%ebp)
    9322:	52                   	push   %edx
    9323:	e8 a3 a3 ff ff       	call   36cb <lodepng_mulofl>
    9328:	83 c4 0c             	add    $0xc,%esp
    932b:	85 c0                	test   %eax,%eax
    932d:	74 07                	je     9336 <lodepng_pixel_overflow+0xa3>
    932f:	b8 01 00 00 00       	mov    $0x1,%eax
    9334:	eb 73                	jmp    93a9 <lodepng_pixel_overflow+0x116>
  if(lodepng_addofl(line, ((w & 7u) * bpp + 7u) / 8u, &line)) return 1;
    9336:	8b 45 08             	mov    0x8(%ebp),%eax
    9339:	83 e0 07             	and    $0x7,%eax
    933c:	89 c2                	mov    %eax,%edx
    933e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    9341:	0f af c2             	imul   %edx,%eax
    9344:	83 c0 07             	add    $0x7,%eax
    9347:	c1 e8 03             	shr    $0x3,%eax
    934a:	89 c1                	mov    %eax,%ecx
    934c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    934f:	8d 55 ec             	lea    -0x14(%ebp),%edx
    9352:	52                   	push   %edx
    9353:	51                   	push   %ecx
    9354:	50                   	push   %eax
    9355:	e8 51 a3 ff ff       	call   36ab <lodepng_addofl>
    935a:	83 c4 0c             	add    $0xc,%esp
    935d:	85 c0                	test   %eax,%eax
    935f:	74 07                	je     9368 <lodepng_pixel_overflow+0xd5>
    9361:	b8 01 00 00 00       	mov    $0x1,%eax
    9366:	eb 41                	jmp    93a9 <lodepng_pixel_overflow+0x116>

  if(lodepng_addofl(line, 5, &line)) return 1; /* 5 bytes overhead per line: 1 filterbyte, 4 for Adam7 worst case */
    9368:	8b 45 ec             	mov    -0x14(%ebp),%eax
    936b:	8d 55 ec             	lea    -0x14(%ebp),%edx
    936e:	52                   	push   %edx
    936f:	6a 05                	push   $0x5
    9371:	50                   	push   %eax
    9372:	e8 34 a3 ff ff       	call   36ab <lodepng_addofl>
    9377:	83 c4 0c             	add    $0xc,%esp
    937a:	85 c0                	test   %eax,%eax
    937c:	74 07                	je     9385 <lodepng_pixel_overflow+0xf2>
    937e:	b8 01 00 00 00       	mov    $0x1,%eax
    9383:	eb 24                	jmp    93a9 <lodepng_pixel_overflow+0x116>
  if(lodepng_mulofl(line, h, &total)) return 1; /* Total bytes in worst case */
    9385:	8b 55 0c             	mov    0xc(%ebp),%edx
    9388:	8b 45 ec             	mov    -0x14(%ebp),%eax
    938b:	8d 4d f0             	lea    -0x10(%ebp),%ecx
    938e:	51                   	push   %ecx
    938f:	52                   	push   %edx
    9390:	50                   	push   %eax
    9391:	e8 35 a3 ff ff       	call   36cb <lodepng_mulofl>
    9396:	83 c4 0c             	add    $0xc,%esp
    9399:	85 c0                	test   %eax,%eax
    939b:	74 07                	je     93a4 <lodepng_pixel_overflow+0x111>
    939d:	b8 01 00 00 00       	mov    $0x1,%eax
    93a2:	eb 05                	jmp    93a9 <lodepng_pixel_overflow+0x116>

  return 0; /* no overflow */
    93a4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    93a9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    93ac:	c9                   	leave  
    93ad:	c3                   	ret    

000093ae <LodePNGUnknownChunks_init>:
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info) {
    93ae:	55                   	push   %ebp
    93af:	89 e5                	mov    %esp,%ebp
    93b1:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
    93b4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    93bb:	eb 15                	jmp    93d2 <LodePNGUnknownChunks_init+0x24>
    93bd:	8b 45 08             	mov    0x8(%ebp),%eax
    93c0:	8b 55 fc             	mov    -0x4(%ebp),%edx
    93c3:	83 c2 30             	add    $0x30,%edx
    93c6:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)
    93cd:	00 
    93ce:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    93d2:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    93d6:	75 e5                	jne    93bd <LodePNGUnknownChunks_init+0xf>
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
    93d8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    93df:	eb 15                	jmp    93f6 <LodePNGUnknownChunks_init+0x48>
    93e1:	8b 45 08             	mov    0x8(%ebp),%eax
    93e4:	8b 55 fc             	mov    -0x4(%ebp),%edx
    93e7:	83 c2 34             	add    $0x34,%edx
    93ea:	c7 44 90 08 00 00 00 	movl   $0x0,0x8(%eax,%edx,4)
    93f1:	00 
    93f2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    93f6:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
    93fa:	75 e5                	jne    93e1 <LodePNGUnknownChunks_init+0x33>
}
    93fc:	90                   	nop
    93fd:	c9                   	leave  
    93fe:	c3                   	ret    

000093ff <LodePNGUnknownChunks_cleanup>:

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info) {
    93ff:	55                   	push   %ebp
    9400:	89 e5                	mov    %esp,%ebp
    9402:	83 ec 18             	sub    $0x18,%esp
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
    9405:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    940c:	eb 1d                	jmp    942b <LodePNGUnknownChunks_cleanup+0x2c>
    940e:	8b 45 08             	mov    0x8(%ebp),%eax
    9411:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9414:	83 c2 30             	add    $0x30,%edx
    9417:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    941b:	83 ec 0c             	sub    $0xc,%esp
    941e:	50                   	push   %eax
    941f:	e8 e4 a1 ff ff       	call   3608 <lodepng_free>
    9424:	83 c4 10             	add    $0x10,%esp
    9427:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    942b:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    942f:	75 dd                	jne    940e <LodePNGUnknownChunks_cleanup+0xf>
}
    9431:	90                   	nop
    9432:	c9                   	leave  
    9433:	c3                   	ret    

00009434 <LodePNGUnknownChunks_copy>:

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
    9434:	55                   	push   %ebp
    9435:	89 e5                	mov    %esp,%ebp
    9437:	83 ec 18             	sub    $0x18,%esp
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);
    943a:	83 ec 0c             	sub    $0xc,%esp
    943d:	ff 75 08             	pushl  0x8(%ebp)
    9440:	e8 ba ff ff ff       	call   93ff <LodePNGUnknownChunks_cleanup>
    9445:	83 c4 10             	add    $0x10,%esp

  for(i = 0; i != 3; ++i) {
    9448:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    944f:	e9 b7 00 00 00       	jmp    950b <LodePNGUnknownChunks_copy+0xd7>
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    9454:	8b 45 0c             	mov    0xc(%ebp),%eax
    9457:	8b 55 f4             	mov    -0xc(%ebp),%edx
    945a:	83 c2 34             	add    $0x34,%edx
    945d:	8b 54 90 08          	mov    0x8(%eax,%edx,4),%edx
    9461:	8b 45 08             	mov    0x8(%ebp),%eax
    9464:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9467:	83 c1 34             	add    $0x34,%ecx
    946a:	89 54 88 08          	mov    %edx,0x8(%eax,%ecx,4)
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    946e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9471:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9474:	83 c2 34             	add    $0x34,%edx
    9477:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    947b:	83 ec 0c             	sub    $0xc,%esp
    947e:	50                   	push   %eax
    947f:	e8 63 a1 ff ff       	call   35e7 <lodepng_malloc>
    9484:	83 c4 10             	add    $0x10,%esp
    9487:	89 c1                	mov    %eax,%ecx
    9489:	8b 45 08             	mov    0x8(%ebp),%eax
    948c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    948f:	83 c2 30             	add    $0x30,%edx
    9492:	89 4c 90 0c          	mov    %ecx,0xc(%eax,%edx,4)
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    9496:	8b 45 08             	mov    0x8(%ebp),%eax
    9499:	8b 55 f4             	mov    -0xc(%ebp),%edx
    949c:	83 c2 30             	add    $0x30,%edx
    949f:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax
    94a3:	85 c0                	test   %eax,%eax
    94a5:	75 18                	jne    94bf <LodePNGUnknownChunks_copy+0x8b>
    94a7:	8b 45 08             	mov    0x8(%ebp),%eax
    94aa:	8b 55 f4             	mov    -0xc(%ebp),%edx
    94ad:	83 c2 34             	add    $0x34,%edx
    94b0:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    94b4:	85 c0                	test   %eax,%eax
    94b6:	74 07                	je     94bf <LodePNGUnknownChunks_copy+0x8b>
    94b8:	b8 53 00 00 00       	mov    $0x53,%eax
    94bd:	eb 5b                	jmp    951a <LodePNGUnknownChunks_copy+0xe6>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    94bf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    94c6:	eb 2d                	jmp    94f5 <LodePNGUnknownChunks_copy+0xc1>
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    94c8:	8b 45 08             	mov    0x8(%ebp),%eax
    94cb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    94ce:	83 c2 30             	add    $0x30,%edx
    94d1:	8b 54 90 0c          	mov    0xc(%eax,%edx,4),%edx
    94d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
    94d8:	01 c2                	add    %eax,%edx
    94da:	8b 45 0c             	mov    0xc(%ebp),%eax
    94dd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    94e0:	83 c1 30             	add    $0x30,%ecx
    94e3:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
    94e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    94ea:	01 c8                	add    %ecx,%eax
    94ec:	0f b6 00             	movzbl (%eax),%eax
    94ef:	88 02                	mov    %al,(%edx)
  for(i = 0; i != 3; ++i) {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
    94f1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    94f5:	8b 45 0c             	mov    0xc(%ebp),%eax
    94f8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    94fb:	83 c2 34             	add    $0x34,%edx
    94fe:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
    9502:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    9505:	7f c1                	jg     94c8 <LodePNGUnknownChunks_copy+0x94>
static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src) {
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i) {
    9507:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    950b:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
    950f:	0f 85 3f ff ff ff    	jne    9454 <LodePNGUnknownChunks_copy+0x20>
    for(j = 0; j < src->unknown_chunks_size[i]; ++j) {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
    9515:	b8 00 00 00 00       	mov    $0x0,%eax
}
    951a:	c9                   	leave  
    951b:	c3                   	ret    

0000951c <LodePNGText_init>:

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info) {
    951c:	55                   	push   %ebp
    951d:	89 e5                	mov    %esp,%ebp
  info->text_num = 0;
    951f:	8b 45 08             	mov    0x8(%ebp),%eax
    9522:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  info->text_keys = NULL;
    9529:	8b 45 08             	mov    0x8(%ebp),%eax
    952c:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  info->text_strings = NULL;
    9533:	8b 45 08             	mov    0x8(%ebp),%eax
    9536:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
    953d:	90                   	nop
    953e:	5d                   	pop    %ebp
    953f:	c3                   	ret    

00009540 <LodePNGText_cleanup>:

static void LodePNGText_cleanup(LodePNGInfo* info) {
    9540:	55                   	push   %ebp
    9541:	89 e5                	mov    %esp,%ebp
    9543:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9546:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    954d:	eb 38                	jmp    9587 <LodePNGText_cleanup+0x47>
    string_cleanup(&info->text_keys[i]);
    954f:	8b 45 08             	mov    0x8(%ebp),%eax
    9552:	8b 40 40             	mov    0x40(%eax),%eax
    9555:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9558:	c1 e2 02             	shl    $0x2,%edx
    955b:	01 d0                	add    %edx,%eax
    955d:	83 ec 0c             	sub    $0xc,%esp
    9560:	50                   	push   %eax
    9561:	e8 75 a3 ff ff       	call   38db <string_cleanup>
    9566:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->text_strings[i]);
    9569:	8b 45 08             	mov    0x8(%ebp),%eax
    956c:	8b 40 44             	mov    0x44(%eax),%eax
    956f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9572:	c1 e2 02             	shl    $0x2,%edx
    9575:	01 d0                	add    %edx,%eax
    9577:	83 ec 0c             	sub    $0xc,%esp
    957a:	50                   	push   %eax
    957b:	e8 5b a3 ff ff       	call   38db <string_cleanup>
    9580:	83 c4 10             	add    $0x10,%esp
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->text_num; ++i) {
    9583:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9587:	8b 45 08             	mov    0x8(%ebp),%eax
    958a:	8b 40 3c             	mov    0x3c(%eax),%eax
    958d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9590:	75 bd                	jne    954f <LodePNGText_cleanup+0xf>
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
    9592:	8b 45 08             	mov    0x8(%ebp),%eax
    9595:	8b 40 40             	mov    0x40(%eax),%eax
    9598:	83 ec 0c             	sub    $0xc,%esp
    959b:	50                   	push   %eax
    959c:	e8 67 a0 ff ff       	call   3608 <lodepng_free>
    95a1:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->text_strings);
    95a4:	8b 45 08             	mov    0x8(%ebp),%eax
    95a7:	8b 40 44             	mov    0x44(%eax),%eax
    95aa:	83 ec 0c             	sub    $0xc,%esp
    95ad:	50                   	push   %eax
    95ae:	e8 55 a0 ff ff       	call   3608 <lodepng_free>
    95b3:	83 c4 10             	add    $0x10,%esp
}
    95b6:	90                   	nop
    95b7:	c9                   	leave  
    95b8:	c3                   	ret    

000095b9 <LodePNGText_copy>:

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    95b9:	55                   	push   %ebp
    95ba:	89 e5                	mov    %esp,%ebp
    95bc:	83 ec 18             	sub    $0x18,%esp
  size_t i = 0;
    95bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->text_keys = NULL;
    95c6:	8b 45 08             	mov    0x8(%ebp),%eax
    95c9:	c7 40 40 00 00 00 00 	movl   $0x0,0x40(%eax)
  dest->text_strings = NULL;
    95d0:	8b 45 08             	mov    0x8(%ebp),%eax
    95d3:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
  dest->text_num = 0;
    95da:	8b 45 08             	mov    0x8(%ebp),%eax
    95dd:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)
  for(i = 0; i != source->text_num; ++i) {
    95e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    95eb:	eb 42                	jmp    962f <LodePNGText_copy+0x76>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
    95ed:	8b 45 0c             	mov    0xc(%ebp),%eax
    95f0:	8b 40 44             	mov    0x44(%eax),%eax
    95f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    95f6:	c1 e2 02             	shl    $0x2,%edx
    95f9:	01 d0                	add    %edx,%eax
    95fb:	8b 10                	mov    (%eax),%edx
    95fd:	8b 45 0c             	mov    0xc(%ebp),%eax
    9600:	8b 40 40             	mov    0x40(%eax),%eax
    9603:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    9606:	c1 e1 02             	shl    $0x2,%ecx
    9609:	01 c8                	add    %ecx,%eax
    960b:	8b 00                	mov    (%eax),%eax
    960d:	83 ec 04             	sub    $0x4,%esp
    9610:	52                   	push   %edx
    9611:	50                   	push   %eax
    9612:	ff 75 08             	pushl  0x8(%ebp)
    9615:	e8 4d 01 00 00       	call   9767 <lodepng_add_text>
    961a:	83 c4 10             	add    $0x10,%esp
    961d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9620:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9624:	74 05                	je     962b <LodePNGText_copy+0x72>
    9626:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9629:	eb 14                	jmp    963f <LodePNGText_copy+0x86>
static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
  size_t i = 0;
  dest->text_keys = NULL;
  dest->text_strings = NULL;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i) {
    962b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    962f:	8b 45 0c             	mov    0xc(%ebp),%eax
    9632:	8b 40 3c             	mov    0x3c(%eax),%eax
    9635:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9638:	75 b3                	jne    95ed <LodePNGText_copy+0x34>
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
    963a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    963f:	c9                   	leave  
    9640:	c3                   	ret    

00009641 <lodepng_add_text_sized>:

static unsigned lodepng_add_text_sized(LodePNGInfo* info, const char* key, const char* str, size_t size) {
    9641:	55                   	push   %ebp
    9642:	89 e5                	mov    %esp,%ebp
    9644:	53                   	push   %ebx
    9645:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
    9648:	8b 45 08             	mov    0x8(%ebp),%eax
    964b:	8b 40 3c             	mov    0x3c(%eax),%eax
    964e:	83 c0 01             	add    $0x1,%eax
    9651:	c1 e0 02             	shl    $0x2,%eax
    9654:	89 c2                	mov    %eax,%edx
    9656:	8b 45 08             	mov    0x8(%ebp),%eax
    9659:	8b 40 40             	mov    0x40(%eax),%eax
    965c:	52                   	push   %edx
    965d:	50                   	push   %eax
    965e:	e8 9b 9f ff ff       	call   35fe <lodepng_realloc>
    9663:	83 c4 08             	add    $0x8,%esp
    9666:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
    9669:	8b 45 08             	mov    0x8(%ebp),%eax
    966c:	8b 40 3c             	mov    0x3c(%eax),%eax
    966f:	83 c0 01             	add    $0x1,%eax
    9672:	c1 e0 02             	shl    $0x2,%eax
    9675:	89 c2                	mov    %eax,%edx
    9677:	8b 45 08             	mov    0x8(%ebp),%eax
    967a:	8b 40 44             	mov    0x44(%eax),%eax
    967d:	52                   	push   %edx
    967e:	50                   	push   %eax
    967f:	e8 7a 9f ff ff       	call   35fe <lodepng_realloc>
    9684:	83 c4 08             	add    $0x8,%esp
    9687:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(new_keys) info->text_keys = new_keys;
    968a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    968e:	74 09                	je     9699 <lodepng_add_text_sized+0x58>
    9690:	8b 45 08             	mov    0x8(%ebp),%eax
    9693:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9696:	89 50 40             	mov    %edx,0x40(%eax)
  if(new_strings) info->text_strings = new_strings;
    9699:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    969d:	74 09                	je     96a8 <lodepng_add_text_sized+0x67>
    969f:	8b 45 08             	mov    0x8(%ebp),%eax
    96a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
    96a5:	89 50 44             	mov    %edx,0x44(%eax)

  if(!new_keys || !new_strings) return 83; /*alloc fail*/
    96a8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    96ac:	74 06                	je     96b4 <lodepng_add_text_sized+0x73>
    96ae:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    96b2:	75 0a                	jne    96be <lodepng_add_text_sized+0x7d>
    96b4:	b8 53 00 00 00       	mov    $0x53,%eax
    96b9:	e9 a4 00 00 00       	jmp    9762 <lodepng_add_text_sized+0x121>

  ++info->text_num;
    96be:	8b 45 08             	mov    0x8(%ebp),%eax
    96c1:	8b 40 3c             	mov    0x3c(%eax),%eax
    96c4:	8d 50 01             	lea    0x1(%eax),%edx
    96c7:	8b 45 08             	mov    0x8(%ebp),%eax
    96ca:	89 50 3c             	mov    %edx,0x3c(%eax)
  info->text_keys[info->text_num - 1] = alloc_string(key);
    96cd:	8b 45 08             	mov    0x8(%ebp),%eax
    96d0:	8b 50 40             	mov    0x40(%eax),%edx
    96d3:	8b 45 08             	mov    0x8(%ebp),%eax
    96d6:	8b 40 3c             	mov    0x3c(%eax),%eax
    96d9:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    96de:	c1 e0 02             	shl    $0x2,%eax
    96e1:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    96e4:	83 ec 0c             	sub    $0xc,%esp
    96e7:	ff 75 0c             	pushl  0xc(%ebp)
    96ea:	e8 54 a2 ff ff       	call   3943 <alloc_string>
    96ef:	83 c4 10             	add    $0x10,%esp
    96f2:	89 03                	mov    %eax,(%ebx)
  info->text_strings[info->text_num - 1] = alloc_string_sized(str, size);
    96f4:	8b 45 08             	mov    0x8(%ebp),%eax
    96f7:	8b 50 44             	mov    0x44(%eax),%edx
    96fa:	8b 45 08             	mov    0x8(%ebp),%eax
    96fd:	8b 40 3c             	mov    0x3c(%eax),%eax
    9700:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9705:	c1 e0 02             	shl    $0x2,%eax
    9708:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    970b:	83 ec 08             	sub    $0x8,%esp
    970e:	ff 75 14             	pushl  0x14(%ebp)
    9711:	ff 75 10             	pushl  0x10(%ebp)
    9714:	e8 e5 a1 ff ff       	call   38fe <alloc_string_sized>
    9719:	83 c4 10             	add    $0x10,%esp
    971c:	89 03                	mov    %eax,(%ebx)
  if(!info->text_keys[info->text_num - 1] || !info->text_strings[info->text_num - 1]) return 83; /*alloc fail*/
    971e:	8b 45 08             	mov    0x8(%ebp),%eax
    9721:	8b 50 40             	mov    0x40(%eax),%edx
    9724:	8b 45 08             	mov    0x8(%ebp),%eax
    9727:	8b 40 3c             	mov    0x3c(%eax),%eax
    972a:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    972f:	c1 e0 02             	shl    $0x2,%eax
    9732:	01 d0                	add    %edx,%eax
    9734:	8b 00                	mov    (%eax),%eax
    9736:	85 c0                	test   %eax,%eax
    9738:	74 1c                	je     9756 <lodepng_add_text_sized+0x115>
    973a:	8b 45 08             	mov    0x8(%ebp),%eax
    973d:	8b 50 44             	mov    0x44(%eax),%edx
    9740:	8b 45 08             	mov    0x8(%ebp),%eax
    9743:	8b 40 3c             	mov    0x3c(%eax),%eax
    9746:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    974b:	c1 e0 02             	shl    $0x2,%eax
    974e:	01 d0                	add    %edx,%eax
    9750:	8b 00                	mov    (%eax),%eax
    9752:	85 c0                	test   %eax,%eax
    9754:	75 07                	jne    975d <lodepng_add_text_sized+0x11c>
    9756:	b8 53 00 00 00       	mov    $0x53,%eax
    975b:	eb 05                	jmp    9762 <lodepng_add_text_sized+0x121>

  return 0;
    975d:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9762:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9765:	c9                   	leave  
    9766:	c3                   	ret    

00009767 <lodepng_add_text>:

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str) {
    9767:	55                   	push   %ebp
    9768:	89 e5                	mov    %esp,%ebp
    976a:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_text_sized(info, key, str, lodepng_strlen(str));
    976d:	ff 75 10             	pushl  0x10(%ebp)
    9770:	e8 0e 9f ff ff       	call   3683 <lodepng_strlen>
    9775:	83 c4 04             	add    $0x4,%esp
    9778:	50                   	push   %eax
    9779:	ff 75 10             	pushl  0x10(%ebp)
    977c:	ff 75 0c             	pushl  0xc(%ebp)
    977f:	ff 75 08             	pushl  0x8(%ebp)
    9782:	e8 ba fe ff ff       	call   9641 <lodepng_add_text_sized>
    9787:	83 c4 10             	add    $0x10,%esp
}
    978a:	c9                   	leave  
    978b:	c3                   	ret    

0000978c <lodepng_clear_text>:

void lodepng_clear_text(LodePNGInfo* info) {
    978c:	55                   	push   %ebp
    978d:	89 e5                	mov    %esp,%ebp
    978f:	83 ec 08             	sub    $0x8,%esp
  LodePNGText_cleanup(info);
    9792:	83 ec 0c             	sub    $0xc,%esp
    9795:	ff 75 08             	pushl  0x8(%ebp)
    9798:	e8 a3 fd ff ff       	call   9540 <LodePNGText_cleanup>
    979d:	83 c4 10             	add    $0x10,%esp
}
    97a0:	90                   	nop
    97a1:	c9                   	leave  
    97a2:	c3                   	ret    

000097a3 <LodePNGIText_init>:

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info) {
    97a3:	55                   	push   %ebp
    97a4:	89 e5                	mov    %esp,%ebp
  info->itext_num = 0;
    97a6:	8b 45 08             	mov    0x8(%ebp),%eax
    97a9:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  info->itext_keys = NULL;
    97b0:	8b 45 08             	mov    0x8(%ebp),%eax
    97b3:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  info->itext_langtags = NULL;
    97ba:	8b 45 08             	mov    0x8(%ebp),%eax
    97bd:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  info->itext_transkeys = NULL;
    97c4:	8b 45 08             	mov    0x8(%ebp),%eax
    97c7:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  info->itext_strings = NULL;
    97ce:	8b 45 08             	mov    0x8(%ebp),%eax
    97d1:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
}
    97d8:	90                   	nop
    97d9:	5d                   	pop    %ebp
    97da:	c3                   	ret    

000097db <LodePNGIText_cleanup>:

static void LodePNGIText_cleanup(LodePNGInfo* info) {
    97db:	55                   	push   %ebp
    97dc:	89 e5                	mov    %esp,%ebp
    97de:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    97e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    97e8:	eb 6c                	jmp    9856 <LodePNGIText_cleanup+0x7b>
    string_cleanup(&info->itext_keys[i]);
    97ea:	8b 45 08             	mov    0x8(%ebp),%eax
    97ed:	8b 40 4c             	mov    0x4c(%eax),%eax
    97f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    97f3:	c1 e2 02             	shl    $0x2,%edx
    97f6:	01 d0                	add    %edx,%eax
    97f8:	83 ec 0c             	sub    $0xc,%esp
    97fb:	50                   	push   %eax
    97fc:	e8 da a0 ff ff       	call   38db <string_cleanup>
    9801:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_langtags[i]);
    9804:	8b 45 08             	mov    0x8(%ebp),%eax
    9807:	8b 40 50             	mov    0x50(%eax),%eax
    980a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    980d:	c1 e2 02             	shl    $0x2,%edx
    9810:	01 d0                	add    %edx,%eax
    9812:	83 ec 0c             	sub    $0xc,%esp
    9815:	50                   	push   %eax
    9816:	e8 c0 a0 ff ff       	call   38db <string_cleanup>
    981b:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_transkeys[i]);
    981e:	8b 45 08             	mov    0x8(%ebp),%eax
    9821:	8b 40 54             	mov    0x54(%eax),%eax
    9824:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9827:	c1 e2 02             	shl    $0x2,%edx
    982a:	01 d0                	add    %edx,%eax
    982c:	83 ec 0c             	sub    $0xc,%esp
    982f:	50                   	push   %eax
    9830:	e8 a6 a0 ff ff       	call   38db <string_cleanup>
    9835:	83 c4 10             	add    $0x10,%esp
    string_cleanup(&info->itext_strings[i]);
    9838:	8b 45 08             	mov    0x8(%ebp),%eax
    983b:	8b 40 58             	mov    0x58(%eax),%eax
    983e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9841:	c1 e2 02             	shl    $0x2,%edx
    9844:	01 d0                	add    %edx,%eax
    9846:	83 ec 0c             	sub    $0xc,%esp
    9849:	50                   	push   %eax
    984a:	e8 8c a0 ff ff       	call   38db <string_cleanup>
    984f:	83 c4 10             	add    $0x10,%esp
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info) {
  size_t i;
  for(i = 0; i != info->itext_num; ++i) {
    9852:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9856:	8b 45 08             	mov    0x8(%ebp),%eax
    9859:	8b 40 48             	mov    0x48(%eax),%eax
    985c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    985f:	75 89                	jne    97ea <LodePNGIText_cleanup+0xf>
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
    9861:	8b 45 08             	mov    0x8(%ebp),%eax
    9864:	8b 40 4c             	mov    0x4c(%eax),%eax
    9867:	83 ec 0c             	sub    $0xc,%esp
    986a:	50                   	push   %eax
    986b:	e8 98 9d ff ff       	call   3608 <lodepng_free>
    9870:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_langtags);
    9873:	8b 45 08             	mov    0x8(%ebp),%eax
    9876:	8b 40 50             	mov    0x50(%eax),%eax
    9879:	83 ec 0c             	sub    $0xc,%esp
    987c:	50                   	push   %eax
    987d:	e8 86 9d ff ff       	call   3608 <lodepng_free>
    9882:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_transkeys);
    9885:	8b 45 08             	mov    0x8(%ebp),%eax
    9888:	8b 40 54             	mov    0x54(%eax),%eax
    988b:	83 ec 0c             	sub    $0xc,%esp
    988e:	50                   	push   %eax
    988f:	e8 74 9d ff ff       	call   3608 <lodepng_free>
    9894:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->itext_strings);
    9897:	8b 45 08             	mov    0x8(%ebp),%eax
    989a:	8b 40 58             	mov    0x58(%eax),%eax
    989d:	83 ec 0c             	sub    $0xc,%esp
    98a0:	50                   	push   %eax
    98a1:	e8 62 9d ff ff       	call   3608 <lodepng_free>
    98a6:	83 c4 10             	add    $0x10,%esp
}
    98a9:	90                   	nop
    98aa:	c9                   	leave  
    98ab:	c3                   	ret    

000098ac <LodePNGIText_copy>:

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    98ac:	55                   	push   %ebp
    98ad:	89 e5                	mov    %esp,%ebp
    98af:	56                   	push   %esi
    98b0:	53                   	push   %ebx
    98b1:	83 ec 10             	sub    $0x10,%esp
  size_t i = 0;
    98b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  dest->itext_keys = NULL;
    98bb:	8b 45 08             	mov    0x8(%ebp),%eax
    98be:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
  dest->itext_langtags = NULL;
    98c5:	8b 45 08             	mov    0x8(%ebp),%eax
    98c8:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%eax)
  dest->itext_transkeys = NULL;
    98cf:	8b 45 08             	mov    0x8(%ebp),%eax
    98d2:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%eax)
  dest->itext_strings = NULL;
    98d9:	8b 45 08             	mov    0x8(%ebp),%eax
    98dc:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%eax)
  dest->itext_num = 0;
    98e3:	8b 45 08             	mov    0x8(%ebp),%eax
    98e6:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
  for(i = 0; i != source->itext_num; ++i) {
    98ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    98f4:	eb 64                	jmp    995a <LodePNGIText_copy+0xae>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
    98f6:	8b 45 0c             	mov    0xc(%ebp),%eax
    98f9:	8b 40 58             	mov    0x58(%eax),%eax
    98fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
    98ff:	c1 e2 02             	shl    $0x2,%edx
    9902:	01 d0                	add    %edx,%eax
    9904:	8b 18                	mov    (%eax),%ebx
    9906:	8b 45 0c             	mov    0xc(%ebp),%eax
    9909:	8b 40 54             	mov    0x54(%eax),%eax
    990c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    990f:	c1 e2 02             	shl    $0x2,%edx
    9912:	01 d0                	add    %edx,%eax
    9914:	8b 08                	mov    (%eax),%ecx
    9916:	8b 45 0c             	mov    0xc(%ebp),%eax
    9919:	8b 40 50             	mov    0x50(%eax),%eax
    991c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    991f:	c1 e2 02             	shl    $0x2,%edx
    9922:	01 d0                	add    %edx,%eax
    9924:	8b 10                	mov    (%eax),%edx
    9926:	8b 45 0c             	mov    0xc(%ebp),%eax
    9929:	8b 40 4c             	mov    0x4c(%eax),%eax
    992c:	8b 75 f4             	mov    -0xc(%ebp),%esi
    992f:	c1 e6 02             	shl    $0x2,%esi
    9932:	01 f0                	add    %esi,%eax
    9934:	8b 00                	mov    (%eax),%eax
    9936:	83 ec 0c             	sub    $0xc,%esp
    9939:	53                   	push   %ebx
    993a:	51                   	push   %ecx
    993b:	52                   	push   %edx
    993c:	50                   	push   %eax
    993d:	ff 75 08             	pushl  0x8(%ebp)
    9940:	e8 e4 01 00 00       	call   9b29 <lodepng_add_itext>
    9945:	83 c4 20             	add    $0x20,%esp
    9948:	89 45 f0             	mov    %eax,-0x10(%ebp)
    994b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    994f:	74 05                	je     9956 <LodePNGIText_copy+0xaa>
    9951:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9954:	eb 14                	jmp    996a <LodePNGIText_copy+0xbe>
  dest->itext_keys = NULL;
  dest->itext_langtags = NULL;
  dest->itext_transkeys = NULL;
  dest->itext_strings = NULL;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i) {
    9956:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    995a:	8b 45 0c             	mov    0xc(%ebp),%eax
    995d:	8b 40 48             	mov    0x48(%eax),%eax
    9960:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    9963:	75 91                	jne    98f6 <LodePNGIText_copy+0x4a>
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
    9965:	b8 00 00 00 00       	mov    $0x0,%eax
}
    996a:	8d 65 f8             	lea    -0x8(%ebp),%esp
    996d:	5b                   	pop    %ebx
    996e:	5e                   	pop    %esi
    996f:	5d                   	pop    %ebp
    9970:	c3                   	ret    

00009971 <lodepng_clear_itext>:

void lodepng_clear_itext(LodePNGInfo* info) {
    9971:	55                   	push   %ebp
    9972:	89 e5                	mov    %esp,%ebp
    9974:	83 ec 08             	sub    $0x8,%esp
  LodePNGIText_cleanup(info);
    9977:	83 ec 0c             	sub    $0xc,%esp
    997a:	ff 75 08             	pushl  0x8(%ebp)
    997d:	e8 59 fe ff ff       	call   97db <LodePNGIText_cleanup>
    9982:	83 c4 10             	add    $0x10,%esp
}
    9985:	90                   	nop
    9986:	c9                   	leave  
    9987:	c3                   	ret    

00009988 <lodepng_add_itext_sized>:

static unsigned lodepng_add_itext_sized(LodePNGInfo* info, const char* key, const char* langtag,
                                        const char* transkey, const char* str, size_t size) {
    9988:	55                   	push   %ebp
    9989:	89 e5                	mov    %esp,%ebp
    998b:	53                   	push   %ebx
    998c:	83 ec 14             	sub    $0x14,%esp
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
    998f:	8b 45 08             	mov    0x8(%ebp),%eax
    9992:	8b 40 48             	mov    0x48(%eax),%eax
    9995:	83 c0 01             	add    $0x1,%eax
    9998:	c1 e0 02             	shl    $0x2,%eax
    999b:	89 c2                	mov    %eax,%edx
    999d:	8b 45 08             	mov    0x8(%ebp),%eax
    99a0:	8b 40 4c             	mov    0x4c(%eax),%eax
    99a3:	52                   	push   %edx
    99a4:	50                   	push   %eax
    99a5:	e8 54 9c ff ff       	call   35fe <lodepng_realloc>
    99aa:	83 c4 08             	add    $0x8,%esp
    99ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
    99b0:	8b 45 08             	mov    0x8(%ebp),%eax
    99b3:	8b 40 48             	mov    0x48(%eax),%eax
    99b6:	83 c0 01             	add    $0x1,%eax
    99b9:	c1 e0 02             	shl    $0x2,%eax
    99bc:	89 c2                	mov    %eax,%edx
    99be:	8b 45 08             	mov    0x8(%ebp),%eax
    99c1:	8b 40 50             	mov    0x50(%eax),%eax
    99c4:	52                   	push   %edx
    99c5:	50                   	push   %eax
    99c6:	e8 33 9c ff ff       	call   35fe <lodepng_realloc>
    99cb:	83 c4 08             	add    $0x8,%esp
    99ce:	89 45 f0             	mov    %eax,-0x10(%ebp)
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
    99d1:	8b 45 08             	mov    0x8(%ebp),%eax
    99d4:	8b 40 48             	mov    0x48(%eax),%eax
    99d7:	83 c0 01             	add    $0x1,%eax
    99da:	c1 e0 02             	shl    $0x2,%eax
    99dd:	89 c2                	mov    %eax,%edx
    99df:	8b 45 08             	mov    0x8(%ebp),%eax
    99e2:	8b 40 54             	mov    0x54(%eax),%eax
    99e5:	52                   	push   %edx
    99e6:	50                   	push   %eax
    99e7:	e8 12 9c ff ff       	call   35fe <lodepng_realloc>
    99ec:	83 c4 08             	add    $0x8,%esp
    99ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
    99f2:	8b 45 08             	mov    0x8(%ebp),%eax
    99f5:	8b 40 48             	mov    0x48(%eax),%eax
    99f8:	83 c0 01             	add    $0x1,%eax
    99fb:	c1 e0 02             	shl    $0x2,%eax
    99fe:	89 c2                	mov    %eax,%edx
    9a00:	8b 45 08             	mov    0x8(%ebp),%eax
    9a03:	8b 40 58             	mov    0x58(%eax),%eax
    9a06:	52                   	push   %edx
    9a07:	50                   	push   %eax
    9a08:	e8 f1 9b ff ff       	call   35fe <lodepng_realloc>
    9a0d:	83 c4 08             	add    $0x8,%esp
    9a10:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(new_keys) info->itext_keys = new_keys;
    9a13:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9a17:	74 09                	je     9a22 <lodepng_add_itext_sized+0x9a>
    9a19:	8b 45 08             	mov    0x8(%ebp),%eax
    9a1c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9a1f:	89 50 4c             	mov    %edx,0x4c(%eax)
  if(new_langtags) info->itext_langtags = new_langtags;
    9a22:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9a26:	74 09                	je     9a31 <lodepng_add_itext_sized+0xa9>
    9a28:	8b 45 08             	mov    0x8(%ebp),%eax
    9a2b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    9a2e:	89 50 50             	mov    %edx,0x50(%eax)
  if(new_transkeys) info->itext_transkeys = new_transkeys;
    9a31:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9a35:	74 09                	je     9a40 <lodepng_add_itext_sized+0xb8>
    9a37:	8b 45 08             	mov    0x8(%ebp),%eax
    9a3a:	8b 55 ec             	mov    -0x14(%ebp),%edx
    9a3d:	89 50 54             	mov    %edx,0x54(%eax)
  if(new_strings) info->itext_strings = new_strings;
    9a40:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9a44:	74 09                	je     9a4f <lodepng_add_itext_sized+0xc7>
    9a46:	8b 45 08             	mov    0x8(%ebp),%eax
    9a49:	8b 55 e8             	mov    -0x18(%ebp),%edx
    9a4c:	89 50 58             	mov    %edx,0x58(%eax)

  if(!new_keys || !new_langtags || !new_transkeys || !new_strings) return 83; /*alloc fail*/
    9a4f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9a53:	74 12                	je     9a67 <lodepng_add_itext_sized+0xdf>
    9a55:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9a59:	74 0c                	je     9a67 <lodepng_add_itext_sized+0xdf>
    9a5b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9a5f:	74 06                	je     9a67 <lodepng_add_itext_sized+0xdf>
    9a61:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9a65:	75 0a                	jne    9a71 <lodepng_add_itext_sized+0xe9>
    9a67:	b8 53 00 00 00       	mov    $0x53,%eax
    9a6c:	e9 b3 00 00 00       	jmp    9b24 <lodepng_add_itext_sized+0x19c>

  ++info->itext_num;
    9a71:	8b 45 08             	mov    0x8(%ebp),%eax
    9a74:	8b 40 48             	mov    0x48(%eax),%eax
    9a77:	8d 50 01             	lea    0x1(%eax),%edx
    9a7a:	8b 45 08             	mov    0x8(%ebp),%eax
    9a7d:	89 50 48             	mov    %edx,0x48(%eax)

  info->itext_keys[info->itext_num - 1] = alloc_string(key);
    9a80:	8b 45 08             	mov    0x8(%ebp),%eax
    9a83:	8b 50 4c             	mov    0x4c(%eax),%edx
    9a86:	8b 45 08             	mov    0x8(%ebp),%eax
    9a89:	8b 40 48             	mov    0x48(%eax),%eax
    9a8c:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9a91:	c1 e0 02             	shl    $0x2,%eax
    9a94:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9a97:	83 ec 0c             	sub    $0xc,%esp
    9a9a:	ff 75 0c             	pushl  0xc(%ebp)
    9a9d:	e8 a1 9e ff ff       	call   3943 <alloc_string>
    9aa2:	83 c4 10             	add    $0x10,%esp
    9aa5:	89 03                	mov    %eax,(%ebx)
  info->itext_langtags[info->itext_num - 1] = alloc_string(langtag);
    9aa7:	8b 45 08             	mov    0x8(%ebp),%eax
    9aaa:	8b 50 50             	mov    0x50(%eax),%edx
    9aad:	8b 45 08             	mov    0x8(%ebp),%eax
    9ab0:	8b 40 48             	mov    0x48(%eax),%eax
    9ab3:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9ab8:	c1 e0 02             	shl    $0x2,%eax
    9abb:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9abe:	83 ec 0c             	sub    $0xc,%esp
    9ac1:	ff 75 10             	pushl  0x10(%ebp)
    9ac4:	e8 7a 9e ff ff       	call   3943 <alloc_string>
    9ac9:	83 c4 10             	add    $0x10,%esp
    9acc:	89 03                	mov    %eax,(%ebx)
  info->itext_transkeys[info->itext_num - 1] = alloc_string(transkey);
    9ace:	8b 45 08             	mov    0x8(%ebp),%eax
    9ad1:	8b 50 54             	mov    0x54(%eax),%edx
    9ad4:	8b 45 08             	mov    0x8(%ebp),%eax
    9ad7:	8b 40 48             	mov    0x48(%eax),%eax
    9ada:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9adf:	c1 e0 02             	shl    $0x2,%eax
    9ae2:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9ae5:	83 ec 0c             	sub    $0xc,%esp
    9ae8:	ff 75 14             	pushl  0x14(%ebp)
    9aeb:	e8 53 9e ff ff       	call   3943 <alloc_string>
    9af0:	83 c4 10             	add    $0x10,%esp
    9af3:	89 03                	mov    %eax,(%ebx)
  info->itext_strings[info->itext_num - 1] = alloc_string_sized(str, size);
    9af5:	8b 45 08             	mov    0x8(%ebp),%eax
    9af8:	8b 50 58             	mov    0x58(%eax),%edx
    9afb:	8b 45 08             	mov    0x8(%ebp),%eax
    9afe:	8b 40 48             	mov    0x48(%eax),%eax
    9b01:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
    9b06:	c1 e0 02             	shl    $0x2,%eax
    9b09:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    9b0c:	83 ec 08             	sub    $0x8,%esp
    9b0f:	ff 75 1c             	pushl  0x1c(%ebp)
    9b12:	ff 75 18             	pushl  0x18(%ebp)
    9b15:	e8 e4 9d ff ff       	call   38fe <alloc_string_sized>
    9b1a:	83 c4 10             	add    $0x10,%esp
    9b1d:	89 03                	mov    %eax,(%ebx)

  return 0;
    9b1f:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9b24:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    9b27:	c9                   	leave  
    9b28:	c3                   	ret    

00009b29 <lodepng_add_itext>:

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str) {
    9b29:	55                   	push   %ebp
    9b2a:	89 e5                	mov    %esp,%ebp
    9b2c:	83 ec 08             	sub    $0x8,%esp
  return lodepng_add_itext_sized(info, key, langtag, transkey, str, lodepng_strlen(str));
    9b2f:	ff 75 18             	pushl  0x18(%ebp)
    9b32:	e8 4c 9b ff ff       	call   3683 <lodepng_strlen>
    9b37:	83 c4 04             	add    $0x4,%esp
    9b3a:	83 ec 08             	sub    $0x8,%esp
    9b3d:	50                   	push   %eax
    9b3e:	ff 75 18             	pushl  0x18(%ebp)
    9b41:	ff 75 14             	pushl  0x14(%ebp)
    9b44:	ff 75 10             	pushl  0x10(%ebp)
    9b47:	ff 75 0c             	pushl  0xc(%ebp)
    9b4a:	ff 75 08             	pushl  0x8(%ebp)
    9b4d:	e8 36 fe ff ff       	call   9988 <lodepng_add_itext_sized>
    9b52:	83 c4 20             	add    $0x20,%esp
}
    9b55:	c9                   	leave  
    9b56:	c3                   	ret    

00009b57 <lodepng_assign_icc>:

/* same as set but does not delete */
static unsigned lodepng_assign_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9b57:	55                   	push   %ebp
    9b58:	89 e5                	mov    %esp,%ebp
    9b5a:	83 ec 08             	sub    $0x8,%esp
  if(profile_size == 0) return 100; /*invalid ICC profile size*/
    9b5d:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    9b61:	75 0a                	jne    9b6d <lodepng_assign_icc+0x16>
    9b63:	b8 64 00 00 00       	mov    $0x64,%eax
    9b68:	e9 81 00 00 00       	jmp    9bee <lodepng_assign_icc+0x97>

  info->iccp_name = alloc_string(name);
    9b6d:	83 ec 0c             	sub    $0xc,%esp
    9b70:	ff 75 0c             	pushl  0xc(%ebp)
    9b73:	e8 cb 9d ff ff       	call   3943 <alloc_string>
    9b78:	83 c4 10             	add    $0x10,%esp
    9b7b:	89 c2                	mov    %eax,%edx
    9b7d:	8b 45 08             	mov    0x8(%ebp),%eax
    9b80:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  info->iccp_profile = (unsigned char*)lodepng_malloc(profile_size);
    9b86:	8b 45 14             	mov    0x14(%ebp),%eax
    9b89:	83 ec 0c             	sub    $0xc,%esp
    9b8c:	50                   	push   %eax
    9b8d:	e8 55 9a ff ff       	call   35e7 <lodepng_malloc>
    9b92:	83 c4 10             	add    $0x10,%esp
    9b95:	89 c2                	mov    %eax,%edx
    9b97:	8b 45 08             	mov    0x8(%ebp),%eax
    9b9a:	89 90 c4 00 00 00    	mov    %edx,0xc4(%eax)

  if(!info->iccp_name || !info->iccp_profile) return 83; /*alloc fail*/
    9ba0:	8b 45 08             	mov    0x8(%ebp),%eax
    9ba3:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9ba9:	85 c0                	test   %eax,%eax
    9bab:	74 0d                	je     9bba <lodepng_assign_icc+0x63>
    9bad:	8b 45 08             	mov    0x8(%ebp),%eax
    9bb0:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9bb6:	85 c0                	test   %eax,%eax
    9bb8:	75 07                	jne    9bc1 <lodepng_assign_icc+0x6a>
    9bba:	b8 53 00 00 00       	mov    $0x53,%eax
    9bbf:	eb 2d                	jmp    9bee <lodepng_assign_icc+0x97>

  lodepng_memcpy(info->iccp_profile, profile, profile_size);
    9bc1:	8b 55 14             	mov    0x14(%ebp),%edx
    9bc4:	8b 45 08             	mov    0x8(%ebp),%eax
    9bc7:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9bcd:	83 ec 04             	sub    $0x4,%esp
    9bd0:	52                   	push   %edx
    9bd1:	ff 75 10             	pushl  0x10(%ebp)
    9bd4:	50                   	push   %eax
    9bd5:	e8 4b 9a ff ff       	call   3625 <lodepng_memcpy>
    9bda:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile_size = profile_size;
    9bdd:	8b 45 08             	mov    0x8(%ebp),%eax
    9be0:	8b 55 14             	mov    0x14(%ebp),%edx
    9be3:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)

  return 0; /*ok*/
    9be9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9bee:	c9                   	leave  
    9bef:	c3                   	ret    

00009bf0 <lodepng_set_icc>:

unsigned lodepng_set_icc(LodePNGInfo* info, const char* name, const unsigned char* profile, unsigned profile_size) {
    9bf0:	55                   	push   %ebp
    9bf1:	89 e5                	mov    %esp,%ebp
    9bf3:	83 ec 08             	sub    $0x8,%esp
  if(info->iccp_name) lodepng_clear_icc(info);
    9bf6:	8b 45 08             	mov    0x8(%ebp),%eax
    9bf9:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9bff:	85 c0                	test   %eax,%eax
    9c01:	74 0e                	je     9c11 <lodepng_set_icc+0x21>
    9c03:	83 ec 0c             	sub    $0xc,%esp
    9c06:	ff 75 08             	pushl  0x8(%ebp)
    9c09:	e8 26 00 00 00       	call   9c34 <lodepng_clear_icc>
    9c0e:	83 c4 10             	add    $0x10,%esp
  info->iccp_defined = 1;
    9c11:	8b 45 08             	mov    0x8(%ebp),%eax
    9c14:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    9c1b:	00 00 00 

  return lodepng_assign_icc(info, name, profile, profile_size);
    9c1e:	ff 75 14             	pushl  0x14(%ebp)
    9c21:	ff 75 10             	pushl  0x10(%ebp)
    9c24:	ff 75 0c             	pushl  0xc(%ebp)
    9c27:	ff 75 08             	pushl  0x8(%ebp)
    9c2a:	e8 28 ff ff ff       	call   9b57 <lodepng_assign_icc>
    9c2f:	83 c4 10             	add    $0x10,%esp
}
    9c32:	c9                   	leave  
    9c33:	c3                   	ret    

00009c34 <lodepng_clear_icc>:

void lodepng_clear_icc(LodePNGInfo* info) {
    9c34:	55                   	push   %ebp
    9c35:	89 e5                	mov    %esp,%ebp
    9c37:	83 ec 08             	sub    $0x8,%esp
  string_cleanup(&info->iccp_name);
    9c3a:	8b 45 08             	mov    0x8(%ebp),%eax
    9c3d:	05 c0 00 00 00       	add    $0xc0,%eax
    9c42:	83 ec 0c             	sub    $0xc,%esp
    9c45:	50                   	push   %eax
    9c46:	e8 90 9c ff ff       	call   38db <string_cleanup>
    9c4b:	83 c4 10             	add    $0x10,%esp
  lodepng_free(info->iccp_profile);
    9c4e:	8b 45 08             	mov    0x8(%ebp),%eax
    9c51:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
    9c57:	83 ec 0c             	sub    $0xc,%esp
    9c5a:	50                   	push   %eax
    9c5b:	e8 a8 99 ff ff       	call   3608 <lodepng_free>
    9c60:	83 c4 10             	add    $0x10,%esp
  info->iccp_profile = NULL;
    9c63:	8b 45 08             	mov    0x8(%ebp),%eax
    9c66:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9c6d:	00 00 00 
  info->iccp_profile_size = 0;
    9c70:	8b 45 08             	mov    0x8(%ebp),%eax
    9c73:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%eax)
    9c7a:	00 00 00 
  info->iccp_defined = 0;
    9c7d:	8b 45 08             	mov    0x8(%ebp),%eax
    9c80:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9c87:	00 00 00 
}
    9c8a:	90                   	nop
    9c8b:	c9                   	leave  
    9c8c:	c3                   	ret    

00009c8d <lodepng_info_init>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info) {
    9c8d:	55                   	push   %ebp
    9c8e:	89 e5                	mov    %esp,%ebp
  lodepng_color_mode_init(&info->color);
    9c90:	8b 45 08             	mov    0x8(%ebp),%eax
    9c93:	83 c0 0c             	add    $0xc,%eax
    9c96:	50                   	push   %eax
    9c97:	e8 5a f0 ff ff       	call   8cf6 <lodepng_color_mode_init>
    9c9c:	83 c4 04             	add    $0x4,%esp
  info->interlace_method = 0;
    9c9f:	8b 45 08             	mov    0x8(%ebp),%eax
    9ca2:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  info->compression_method = 0;
    9ca9:	8b 45 08             	mov    0x8(%ebp),%eax
    9cac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  info->filter_method = 0;
    9cb2:	8b 45 08             	mov    0x8(%ebp),%eax
    9cb5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
    9cbc:	8b 45 08             	mov    0x8(%ebp),%eax
    9cbf:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  info->background_r = info->background_g = info->background_b = 0;
    9cc6:	8b 45 08             	mov    0x8(%ebp),%eax
    9cc9:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    9cd0:	8b 45 08             	mov    0x8(%ebp),%eax
    9cd3:	8b 50 38             	mov    0x38(%eax),%edx
    9cd6:	8b 45 08             	mov    0x8(%ebp),%eax
    9cd9:	89 50 34             	mov    %edx,0x34(%eax)
    9cdc:	8b 45 08             	mov    0x8(%ebp),%eax
    9cdf:	8b 50 34             	mov    0x34(%eax),%edx
    9ce2:	8b 45 08             	mov    0x8(%ebp),%eax
    9ce5:	89 50 30             	mov    %edx,0x30(%eax)

  LodePNGText_init(info);
    9ce8:	ff 75 08             	pushl  0x8(%ebp)
    9ceb:	e8 2c f8 ff ff       	call   951c <LodePNGText_init>
    9cf0:	83 c4 04             	add    $0x4,%esp
  LodePNGIText_init(info);
    9cf3:	ff 75 08             	pushl  0x8(%ebp)
    9cf6:	e8 a8 fa ff ff       	call   97a3 <LodePNGIText_init>
    9cfb:	83 c4 04             	add    $0x4,%esp

  info->time_defined = 0;
    9cfe:	8b 45 08             	mov    0x8(%ebp),%eax
    9d01:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%eax)
  info->phys_defined = 0;
    9d08:	8b 45 08             	mov    0x8(%ebp),%eax
    9d0b:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

  info->gama_defined = 0;
    9d12:	8b 45 08             	mov    0x8(%ebp),%eax
    9d15:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
    9d1c:	00 00 00 
  info->chrm_defined = 0;
    9d1f:	8b 45 08             	mov    0x8(%ebp),%eax
    9d22:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%eax)
    9d29:	00 00 00 
  info->srgb_defined = 0;
    9d2c:	8b 45 08             	mov    0x8(%ebp),%eax
    9d2f:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
    9d36:	00 00 00 
  info->iccp_defined = 0;
    9d39:	8b 45 08             	mov    0x8(%ebp),%eax
    9d3c:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%eax)
    9d43:	00 00 00 
  info->iccp_name = NULL;
    9d46:	8b 45 08             	mov    0x8(%ebp),%eax
    9d49:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
    9d50:	00 00 00 
  info->iccp_profile = NULL;
    9d53:	8b 45 08             	mov    0x8(%ebp),%eax
    9d56:	c7 80 c4 00 00 00 00 	movl   $0x0,0xc4(%eax)
    9d5d:	00 00 00 

  LodePNGUnknownChunks_init(info);
    9d60:	ff 75 08             	pushl  0x8(%ebp)
    9d63:	e8 46 f6 ff ff       	call   93ae <LodePNGUnknownChunks_init>
    9d68:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9d6b:	90                   	nop
    9d6c:	c9                   	leave  
    9d6d:	c3                   	ret    

00009d6e <lodepng_info_cleanup>:

void lodepng_info_cleanup(LodePNGInfo* info) {
    9d6e:	55                   	push   %ebp
    9d6f:	89 e5                	mov    %esp,%ebp
    9d71:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&info->color);
    9d74:	8b 45 08             	mov    0x8(%ebp),%eax
    9d77:	83 c0 0c             	add    $0xc,%eax
    9d7a:	83 ec 0c             	sub    $0xc,%esp
    9d7d:	50                   	push   %eax
    9d7e:	e8 66 f0 ff ff       	call   8de9 <lodepng_color_mode_cleanup>
    9d83:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
    9d86:	83 ec 0c             	sub    $0xc,%esp
    9d89:	ff 75 08             	pushl  0x8(%ebp)
    9d8c:	e8 af f7 ff ff       	call   9540 <LodePNGText_cleanup>
    9d91:	83 c4 10             	add    $0x10,%esp
  LodePNGIText_cleanup(info);
    9d94:	83 ec 0c             	sub    $0xc,%esp
    9d97:	ff 75 08             	pushl  0x8(%ebp)
    9d9a:	e8 3c fa ff ff       	call   97db <LodePNGIText_cleanup>
    9d9f:	83 c4 10             	add    $0x10,%esp

  lodepng_clear_icc(info);
    9da2:	83 ec 0c             	sub    $0xc,%esp
    9da5:	ff 75 08             	pushl  0x8(%ebp)
    9da8:	e8 87 fe ff ff       	call   9c34 <lodepng_clear_icc>
    9dad:	83 c4 10             	add    $0x10,%esp

  LodePNGUnknownChunks_cleanup(info);
    9db0:	83 ec 0c             	sub    $0xc,%esp
    9db3:	ff 75 08             	pushl  0x8(%ebp)
    9db6:	e8 44 f6 ff ff       	call   93ff <LodePNGUnknownChunks_cleanup>
    9dbb:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
    9dbe:	90                   	nop
    9dbf:	c9                   	leave  
    9dc0:	c3                   	ret    

00009dc1 <lodepng_info_copy>:

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source) {
    9dc1:	55                   	push   %ebp
    9dc2:	89 e5                	mov    %esp,%ebp
    9dc4:	83 ec 28             	sub    $0x28,%esp
  lodepng_info_cleanup(dest);
    9dc7:	83 ec 0c             	sub    $0xc,%esp
    9dca:	ff 75 08             	pushl  0x8(%ebp)
    9dcd:	e8 9c ff ff ff       	call   9d6e <lodepng_info_cleanup>
    9dd2:	83 c4 10             	add    $0x10,%esp
  lodepng_memcpy(dest, source, sizeof(LodePNGInfo));
    9dd5:	83 ec 04             	sub    $0x4,%esp
    9dd8:	68 e4 00 00 00       	push   $0xe4
    9ddd:	ff 75 0c             	pushl  0xc(%ebp)
    9de0:	ff 75 08             	pushl  0x8(%ebp)
    9de3:	e8 3d 98 ff ff       	call   3625 <lodepng_memcpy>
    9de8:	83 c4 10             	add    $0x10,%esp
  lodepng_color_mode_init(&dest->color);
    9deb:	8b 45 08             	mov    0x8(%ebp),%eax
    9dee:	83 c0 0c             	add    $0xc,%eax
    9df1:	83 ec 0c             	sub    $0xc,%esp
    9df4:	50                   	push   %eax
    9df5:	e8 fc ee ff ff       	call   8cf6 <lodepng_color_mode_init>
    9dfa:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));
    9dfd:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e00:	8d 50 0c             	lea    0xc(%eax),%edx
    9e03:	8b 45 08             	mov    0x8(%ebp),%eax
    9e06:	83 c0 0c             	add    $0xc,%eax
    9e09:	83 ec 08             	sub    $0x8,%esp
    9e0c:	52                   	push   %edx
    9e0d:	50                   	push   %eax
    9e0e:	e8 ed ef ff ff       	call   8e00 <lodepng_color_mode_copy>
    9e13:	83 c4 10             	add    $0x10,%esp
    9e16:	89 45 f4             	mov    %eax,-0xc(%ebp)
    9e19:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    9e1d:	74 08                	je     9e27 <lodepng_info_copy+0x66>
    9e1f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    9e22:	e9 b7 00 00 00       	jmp    9ede <lodepng_info_copy+0x11d>

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
    9e27:	83 ec 08             	sub    $0x8,%esp
    9e2a:	ff 75 0c             	pushl  0xc(%ebp)
    9e2d:	ff 75 08             	pushl  0x8(%ebp)
    9e30:	e8 84 f7 ff ff       	call   95b9 <LodePNGText_copy>
    9e35:	83 c4 10             	add    $0x10,%esp
    9e38:	89 45 f0             	mov    %eax,-0x10(%ebp)
    9e3b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    9e3f:	74 08                	je     9e49 <lodepng_info_copy+0x88>
    9e41:	8b 45 f0             	mov    -0x10(%ebp),%eax
    9e44:	e9 95 00 00 00       	jmp    9ede <lodepng_info_copy+0x11d>
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));
    9e49:	83 ec 08             	sub    $0x8,%esp
    9e4c:	ff 75 0c             	pushl  0xc(%ebp)
    9e4f:	ff 75 08             	pushl  0x8(%ebp)
    9e52:	e8 55 fa ff ff       	call   98ac <LodePNGIText_copy>
    9e57:	83 c4 10             	add    $0x10,%esp
    9e5a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    9e5d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    9e61:	74 05                	je     9e68 <lodepng_info_copy+0xa7>
    9e63:	8b 45 ec             	mov    -0x14(%ebp),%eax
    9e66:	eb 76                	jmp    9ede <lodepng_info_copy+0x11d>
  if(source->iccp_defined) {
    9e68:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e6b:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
    9e71:	85 c0                	test   %eax,%eax
    9e73:	74 37                	je     9eac <lodepng_info_copy+0xeb>
    CERROR_TRY_RETURN(lodepng_assign_icc(dest, source->iccp_name, source->iccp_profile, source->iccp_profile_size));
    9e75:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e78:	8b 88 c8 00 00 00    	mov    0xc8(%eax),%ecx
    9e7e:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e81:	8b 90 c4 00 00 00    	mov    0xc4(%eax),%edx
    9e87:	8b 45 0c             	mov    0xc(%ebp),%eax
    9e8a:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    9e90:	51                   	push   %ecx
    9e91:	52                   	push   %edx
    9e92:	50                   	push   %eax
    9e93:	ff 75 08             	pushl  0x8(%ebp)
    9e96:	e8 bc fc ff ff       	call   9b57 <lodepng_assign_icc>
    9e9b:	83 c4 10             	add    $0x10,%esp
    9e9e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    9ea1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    9ea5:	74 05                	je     9eac <lodepng_info_copy+0xeb>
    9ea7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    9eaa:	eb 32                	jmp    9ede <lodepng_info_copy+0x11d>
  }

  LodePNGUnknownChunks_init(dest);
    9eac:	83 ec 0c             	sub    $0xc,%esp
    9eaf:	ff 75 08             	pushl  0x8(%ebp)
    9eb2:	e8 f7 f4 ff ff       	call   93ae <LodePNGUnknownChunks_init>
    9eb7:	83 c4 10             	add    $0x10,%esp
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
    9eba:	83 ec 08             	sub    $0x8,%esp
    9ebd:	ff 75 0c             	pushl  0xc(%ebp)
    9ec0:	ff 75 08             	pushl  0x8(%ebp)
    9ec3:	e8 6c f5 ff ff       	call   9434 <LodePNGUnknownChunks_copy>
    9ec8:	83 c4 10             	add    $0x10,%esp
    9ecb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    9ece:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    9ed2:	74 05                	je     9ed9 <lodepng_info_copy+0x118>
    9ed4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    9ed7:	eb 05                	jmp    9ede <lodepng_info_copy+0x11d>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
    9ed9:	b8 00 00 00 00       	mov    $0x0,%eax
}
    9ede:	c9                   	leave  
    9edf:	c3                   	ret    

00009ee0 <addColorBits>:

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in) {
    9ee0:	55                   	push   %ebp
    9ee1:	89 e5                	mov    %esp,%ebp
    9ee3:	83 ec 10             	sub    $0x10,%esp
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
    9ee6:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    9eea:	74 14                	je     9f00 <addColorBits+0x20>
    9eec:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    9ef0:	75 07                	jne    9ef9 <addColorBits+0x19>
    9ef2:	b8 03 00 00 00       	mov    $0x3,%eax
    9ef7:	eb 0c                	jmp    9f05 <addColorBits+0x25>
    9ef9:	b8 01 00 00 00       	mov    $0x1,%eax
    9efe:	eb 05                	jmp    9f05 <addColorBits+0x25>
    9f00:	b8 07 00 00 00       	mov    $0x7,%eax
    9f05:	89 45 fc             	mov    %eax,-0x4(%ebp)
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
    9f08:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f0b:	23 45 fc             	and    -0x4(%ebp),%eax
    9f0e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
    9f11:	8b 45 10             	mov    0x10(%ebp),%eax
    9f14:	ba 01 00 00 00       	mov    $0x1,%edx
    9f19:	89 c1                	mov    %eax,%ecx
    9f1b:	d3 e2                	shl    %cl,%edx
    9f1d:	89 d0                	mov    %edx,%eax
    9f1f:	83 e8 01             	sub    $0x1,%eax
    9f22:	21 45 14             	and    %eax,0x14(%ebp)
  in = in << (bits * (m - p));
    9f25:	8b 45 fc             	mov    -0x4(%ebp),%eax
    9f28:	2b 45 f8             	sub    -0x8(%ebp),%eax
    9f2b:	0f af 45 10          	imul   0x10(%ebp),%eax
    9f2f:	89 c1                	mov    %eax,%ecx
    9f31:	d3 65 14             	shll   %cl,0x14(%ebp)
  if(p == 0) out[index * bits / 8u] = in;
    9f34:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    9f38:	75 18                	jne    9f52 <addColorBits+0x72>
    9f3a:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f3d:	0f af 45 10          	imul   0x10(%ebp),%eax
    9f41:	c1 e8 03             	shr    $0x3,%eax
    9f44:	89 c2                	mov    %eax,%edx
    9f46:	8b 45 08             	mov    0x8(%ebp),%eax
    9f49:	01 d0                	add    %edx,%eax
    9f4b:	8b 55 14             	mov    0x14(%ebp),%edx
    9f4e:	88 10                	mov    %dl,(%eax)
  else out[index * bits / 8u] |= in;
}
    9f50:	eb 1e                	jmp    9f70 <addColorBits+0x90>
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8u] = in;
  else out[index * bits / 8u] |= in;
    9f52:	8b 45 0c             	mov    0xc(%ebp),%eax
    9f55:	0f af 45 10          	imul   0x10(%ebp),%eax
    9f59:	c1 e8 03             	shr    $0x3,%eax
    9f5c:	8b 55 08             	mov    0x8(%ebp),%edx
    9f5f:	01 c2                	add    %eax,%edx
    9f61:	8b 4d 08             	mov    0x8(%ebp),%ecx
    9f64:	01 c8                	add    %ecx,%eax
    9f66:	0f b6 08             	movzbl (%eax),%ecx
    9f69:	8b 45 14             	mov    0x14(%ebp),%eax
    9f6c:	09 c8                	or     %ecx,%eax
    9f6e:	88 02                	mov    %al,(%edx)
}
    9f70:	90                   	nop
    9f71:	c9                   	leave  
    9f72:	c3                   	ret    

00009f73 <color_tree_init>:
struct ColorTree {
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree) {
    9f73:	55                   	push   %ebp
    9f74:	89 e5                	mov    %esp,%ebp
  lodepng_memset(tree->children, 0, 16 * sizeof(*tree->children));
    9f76:	8b 45 08             	mov    0x8(%ebp),%eax
    9f79:	6a 40                	push   $0x40
    9f7b:	6a 00                	push   $0x0
    9f7d:	50                   	push   %eax
    9f7e:	e8 d5 96 ff ff       	call   3658 <lodepng_memset>
    9f83:	83 c4 0c             	add    $0xc,%esp
  tree->index = -1;
    9f86:	8b 45 08             	mov    0x8(%ebp),%eax
    9f89:	c7 40 40 ff ff ff ff 	movl   $0xffffffff,0x40(%eax)
}
    9f90:	90                   	nop
    9f91:	c9                   	leave  
    9f92:	c3                   	ret    

00009f93 <color_tree_cleanup>:

static void color_tree_cleanup(ColorTree* tree) {
    9f93:	55                   	push   %ebp
    9f94:	89 e5                	mov    %esp,%ebp
    9f96:	83 ec 18             	sub    $0x18,%esp
  int i;
  for(i = 0; i != 16; ++i) {
    9f99:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    9fa0:	eb 3b                	jmp    9fdd <color_tree_cleanup+0x4a>
    if(tree->children[i]) {
    9fa2:	8b 45 08             	mov    0x8(%ebp),%eax
    9fa5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9fa8:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9fab:	85 c0                	test   %eax,%eax
    9fad:	74 2a                	je     9fd9 <color_tree_cleanup+0x46>
      color_tree_cleanup(tree->children[i]);
    9faf:	8b 45 08             	mov    0x8(%ebp),%eax
    9fb2:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9fb5:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9fb8:	83 ec 0c             	sub    $0xc,%esp
    9fbb:	50                   	push   %eax
    9fbc:	e8 d2 ff ff ff       	call   9f93 <color_tree_cleanup>
    9fc1:	83 c4 10             	add    $0x10,%esp
      lodepng_free(tree->children[i]);
    9fc4:	8b 45 08             	mov    0x8(%ebp),%eax
    9fc7:	8b 55 f4             	mov    -0xc(%ebp),%edx
    9fca:	8b 04 90             	mov    (%eax,%edx,4),%eax
    9fcd:	83 ec 0c             	sub    $0xc,%esp
    9fd0:	50                   	push   %eax
    9fd1:	e8 32 96 ff ff       	call   3608 <lodepng_free>
    9fd6:	83 c4 10             	add    $0x10,%esp
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree) {
  int i;
  for(i = 0; i != 16; ++i) {
    9fd9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    9fdd:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
    9fe1:	75 bf                	jne    9fa2 <color_tree_cleanup+0xf>
    if(tree->children[i]) {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}
    9fe3:	90                   	nop
    9fe4:	c9                   	leave  
    9fe5:	c3                   	ret    

00009fe6 <color_tree_get>:

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    9fe6:	55                   	push   %ebp
    9fe7:	89 e5                	mov    %esp,%ebp
    9fe9:	53                   	push   %ebx
    9fea:	83 ec 20             	sub    $0x20,%esp
    9fed:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    9ff0:	8b 4d 10             	mov    0x10(%ebp),%ecx
    9ff3:	8b 55 14             	mov    0x14(%ebp),%edx
    9ff6:	8b 45 18             	mov    0x18(%ebp),%eax
    9ff9:	88 5d e8             	mov    %bl,-0x18(%ebp)
    9ffc:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    9fff:	88 55 e0             	mov    %dl,-0x20(%ebp)
    a002:	88 45 dc             	mov    %al,-0x24(%ebp)
  int bit = 0;
    a005:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  for(bit = 0; bit < 8; ++bit) {
    a00c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    a013:	eb 76                	jmp    a08b <color_tree_get+0xa5>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    a015:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a019:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a01c:	89 c1                	mov    %eax,%ecx
    a01e:	d3 fa                	sar    %cl,%edx
    a020:	89 d0                	mov    %edx,%eax
    a022:	83 e0 01             	and    $0x1,%eax
    a025:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a028:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a02c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a02f:	89 c1                	mov    %eax,%ecx
    a031:	d3 fa                	sar    %cl,%edx
    a033:	89 d0                	mov    %edx,%eax
    a035:	83 e0 01             	and    $0x1,%eax
    a038:	01 d8                	add    %ebx,%eax
    a03a:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a03d:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a041:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a044:	89 c1                	mov    %eax,%ecx
    a046:	d3 fa                	sar    %cl,%edx
    a048:	89 d0                	mov    %edx,%eax
    a04a:	83 e0 01             	and    $0x1,%eax
    a04d:	01 d8                	add    %ebx,%eax
    a04f:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a052:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a056:	8b 45 f8             	mov    -0x8(%ebp),%eax
    a059:	89 c1                	mov    %eax,%ecx
    a05b:	d3 fa                	sar    %cl,%edx
    a05d:	89 d0                	mov    %edx,%eax
    a05f:	83 e0 01             	and    $0x1,%eax
    a062:	01 d8                	add    %ebx,%eax
    a064:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(!tree->children[i]) return -1;
    a067:	8b 45 08             	mov    0x8(%ebp),%eax
    a06a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a06d:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a070:	85 c0                	test   %eax,%eax
    a072:	75 07                	jne    a07b <color_tree_get+0x95>
    a074:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a079:	eb 2a                	jmp    a0a5 <color_tree_get+0xbf>
    else tree = tree->children[i];
    a07b:	8b 45 08             	mov    0x8(%ebp),%eax
    a07e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a081:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a084:	89 45 08             	mov    %eax,0x8(%ebp)
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
  int bit = 0;
  for(bit = 0; bit < 8; ++bit) {
    a087:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    a08b:	83 7d f8 07          	cmpl   $0x7,-0x8(%ebp)
    a08f:	7e 84                	jle    a015 <color_tree_get+0x2f>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
    a091:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    a095:	74 08                	je     a09f <color_tree_get+0xb9>
    a097:	8b 45 08             	mov    0x8(%ebp),%eax
    a09a:	8b 40 40             	mov    0x40(%eax),%eax
    a09d:	eb 05                	jmp    a0a4 <color_tree_get+0xbe>
    a09f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    a0a4:	90                   	nop
}
    a0a5:	83 c4 20             	add    $0x20,%esp
    a0a8:	5b                   	pop    %ebx
    a0a9:	5d                   	pop    %ebp
    a0aa:	c3                   	ret    

0000a0ab <color_tree_has>:

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a0ab:	55                   	push   %ebp
    a0ac:	89 e5                	mov    %esp,%ebp
    a0ae:	53                   	push   %ebx
    a0af:	83 ec 10             	sub    $0x10,%esp
    a0b2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a0b5:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a0b8:	8b 55 14             	mov    0x14(%ebp),%edx
    a0bb:	8b 45 18             	mov    0x18(%ebp),%eax
    a0be:	88 5d f8             	mov    %bl,-0x8(%ebp)
    a0c1:	88 4d f4             	mov    %cl,-0xc(%ebp)
    a0c4:	88 55 f0             	mov    %dl,-0x10(%ebp)
    a0c7:	88 45 ec             	mov    %al,-0x14(%ebp)
  return color_tree_get(tree, r, g, b, a) >= 0;
    a0ca:	0f b6 5d ec          	movzbl -0x14(%ebp),%ebx
    a0ce:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
    a0d2:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
    a0d6:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
    a0da:	53                   	push   %ebx
    a0db:	51                   	push   %ecx
    a0dc:	52                   	push   %edx
    a0dd:	50                   	push   %eax
    a0de:	ff 75 08             	pushl  0x8(%ebp)
    a0e1:	e8 00 ff ff ff       	call   9fe6 <color_tree_get>
    a0e6:	83 c4 14             	add    $0x14,%esp
    a0e9:	f7 d0                	not    %eax
    a0eb:	c1 e8 1f             	shr    $0x1f,%eax
    a0ee:	0f b6 c0             	movzbl %al,%eax
}
    a0f1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a0f4:	c9                   	leave  
    a0f5:	c3                   	ret    

0000a0f6 <color_tree_add>:

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
    a0f6:	55                   	push   %ebp
    a0f7:	89 e5                	mov    %esp,%ebp
    a0f9:	53                   	push   %ebx
    a0fa:	83 ec 24             	sub    $0x24,%esp
    a0fd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    a100:	8b 4d 10             	mov    0x10(%ebp),%ecx
    a103:	8b 55 14             	mov    0x14(%ebp),%edx
    a106:	8b 45 18             	mov    0x18(%ebp),%eax
    a109:	88 5d e4             	mov    %bl,-0x1c(%ebp)
    a10c:	88 4d e0             	mov    %cl,-0x20(%ebp)
    a10f:	88 55 dc             	mov    %dl,-0x24(%ebp)
    a112:	88 45 d8             	mov    %al,-0x28(%ebp)
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    a115:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    a11c:	e9 b0 00 00 00       	jmp    a1d1 <color_tree_add+0xdb>
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    a121:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a125:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a128:	89 c1                	mov    %eax,%ecx
    a12a:	d3 fa                	sar    %cl,%edx
    a12c:	89 d0                	mov    %edx,%eax
    a12e:	83 e0 01             	and    $0x1,%eax
    a131:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a134:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a138:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a13b:	89 c1                	mov    %eax,%ecx
    a13d:	d3 fa                	sar    %cl,%edx
    a13f:	89 d0                	mov    %edx,%eax
    a141:	83 e0 01             	and    $0x1,%eax
    a144:	01 d8                	add    %ebx,%eax
    a146:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a149:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a14d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a150:	89 c1                	mov    %eax,%ecx
    a152:	d3 fa                	sar    %cl,%edx
    a154:	89 d0                	mov    %edx,%eax
    a156:	83 e0 01             	and    $0x1,%eax
    a159:	01 d8                	add    %ebx,%eax
    a15b:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
    a15e:	0f b6 55 d8          	movzbl -0x28(%ebp),%edx
    a162:	8b 45 f4             	mov    -0xc(%ebp),%eax
    a165:	89 c1                	mov    %eax,%ecx
    a167:	d3 fa                	sar    %cl,%edx
    a169:	89 d0                	mov    %edx,%eax
    a16b:	83 e0 01             	and    $0x1,%eax
    a16e:	01 d8                	add    %ebx,%eax
    a170:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!tree->children[i]) {
    a173:	8b 45 08             	mov    0x8(%ebp),%eax
    a176:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a179:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a17c:	85 c0                	test   %eax,%eax
    a17e:	75 41                	jne    a1c1 <color_tree_add+0xcb>
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
    a180:	83 ec 0c             	sub    $0xc,%esp
    a183:	6a 44                	push   $0x44
    a185:	e8 5d 94 ff ff       	call   35e7 <lodepng_malloc>
    a18a:	83 c4 10             	add    $0x10,%esp
    a18d:	89 c1                	mov    %eax,%ecx
    a18f:	8b 45 08             	mov    0x8(%ebp),%eax
    a192:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a195:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
      if(!tree->children[i]) return 83; /*alloc fail*/
    a198:	8b 45 08             	mov    0x8(%ebp),%eax
    a19b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a19e:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a1a1:	85 c0                	test   %eax,%eax
    a1a3:	75 07                	jne    a1ac <color_tree_add+0xb6>
    a1a5:	b8 53 00 00 00       	mov    $0x53,%eax
    a1aa:	eb 3d                	jmp    a1e9 <color_tree_add+0xf3>
      color_tree_init(tree->children[i]);
    a1ac:	8b 45 08             	mov    0x8(%ebp),%eax
    a1af:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a1b2:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a1b5:	83 ec 0c             	sub    $0xc,%esp
    a1b8:	50                   	push   %eax
    a1b9:	e8 b5 fd ff ff       	call   9f73 <color_tree_init>
    a1be:	83 c4 10             	add    $0x10,%esp
    }
    tree = tree->children[i];
    a1c1:	8b 45 08             	mov    0x8(%ebp),%eax
    a1c4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    a1c7:	8b 04 90             	mov    (%eax,%edx,4),%eax
    a1ca:	89 45 08             	mov    %eax,0x8(%ebp)
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")
Returns error code, or 0 if ok*/
static unsigned color_tree_add(ColorTree* tree,
                               unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index) {
  int bit;
  for(bit = 0; bit < 8; ++bit) {
    a1cd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    a1d1:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    a1d5:	0f 8e 46 ff ff ff    	jle    a121 <color_tree_add+0x2b>
      if(!tree->children[i]) return 83; /*alloc fail*/
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = (int)index;
    a1db:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a1de:	8b 45 08             	mov    0x8(%ebp),%eax
    a1e1:	89 50 40             	mov    %edx,0x40(%eax)
  return 0;
    a1e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a1e9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a1ec:	c9                   	leave  
    a1ed:	c3                   	ret    

0000a1ee <rgba8ToPixel>:

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a) {
    a1ee:	55                   	push   %ebp
    a1ef:	89 e5                	mov    %esp,%ebp
    a1f1:	53                   	push   %ebx
    a1f2:	83 ec 20             	sub    $0x20,%esp
    a1f5:	8b 5d 18             	mov    0x18(%ebp),%ebx
    a1f8:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
    a1fb:	8b 55 20             	mov    0x20(%ebp),%edx
    a1fe:	8b 45 24             	mov    0x24(%ebp),%eax
    a201:	88 5d e8             	mov    %bl,-0x18(%ebp)
    a204:	88 4d e4             	mov    %cl,-0x1c(%ebp)
    a207:	88 55 e0             	mov    %dl,-0x20(%ebp)
    a20a:	88 45 dc             	mov    %al,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a20d:	8b 45 10             	mov    0x10(%ebp),%eax
    a210:	8b 00                	mov    (%eax),%eax
    a212:	85 c0                	test   %eax,%eax
    a214:	0f 85 ad 00 00 00    	jne    a2c7 <rgba8ToPixel+0xd9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a21a:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a21e:	88 45 f6             	mov    %al,-0xa(%ebp)
    if(mode->bitdepth == 8) out[i] = gray;
    a221:	8b 45 10             	mov    0x10(%ebp),%eax
    a224:	8b 40 04             	mov    0x4(%eax),%eax
    a227:	83 f8 08             	cmp    $0x8,%eax
    a22a:	75 13                	jne    a23f <rgba8ToPixel+0x51>
    a22c:	8b 55 0c             	mov    0xc(%ebp),%edx
    a22f:	8b 45 08             	mov    0x8(%ebp),%eax
    a232:	01 c2                	add    %eax,%edx
    a234:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
    a238:	88 02                	mov    %al,(%edx)
    a23a:	e9 b4 03 00 00       	jmp    a5f3 <rgba8ToPixel+0x405>
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = gray;
    a23f:	8b 45 10             	mov    0x10(%ebp),%eax
    a242:	8b 40 04             	mov    0x4(%eax),%eax
    a245:	83 f8 10             	cmp    $0x10,%eax
    a248:	75 2a                	jne    a274 <rgba8ToPixel+0x86>
    a24a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a24d:	01 c0                	add    %eax,%eax
    a24f:	89 c2                	mov    %eax,%edx
    a251:	8b 45 08             	mov    0x8(%ebp),%eax
    a254:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a257:	8b 45 0c             	mov    0xc(%ebp),%eax
    a25a:	01 c0                	add    %eax,%eax
    a25c:	8d 50 01             	lea    0x1(%eax),%edx
    a25f:	8b 45 08             	mov    0x8(%ebp),%eax
    a262:	01 d0                	add    %edx,%eax
    a264:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a268:	88 10                	mov    %dl,(%eax)
    a26a:	0f b6 00             	movzbl (%eax),%eax
    a26d:	88 01                	mov    %al,(%ecx)
    a26f:	e9 7f 03 00 00       	jmp    a5f3 <rgba8ToPixel+0x405>
    else {
      /*take the most significant bits of gray*/
      gray = ((unsigned)gray >> (8u - mode->bitdepth)) & ((1u << mode->bitdepth) - 1u);
    a274:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a278:	8b 45 10             	mov    0x10(%ebp),%eax
    a27b:	8b 40 04             	mov    0x4(%eax),%eax
    a27e:	b9 08 00 00 00       	mov    $0x8,%ecx
    a283:	29 c1                	sub    %eax,%ecx
    a285:	89 c8                	mov    %ecx,%eax
    a287:	89 c1                	mov    %eax,%ecx
    a289:	d3 ea                	shr    %cl,%edx
    a28b:	89 d0                	mov    %edx,%eax
    a28d:	89 c2                	mov    %eax,%edx
    a28f:	8b 45 10             	mov    0x10(%ebp),%eax
    a292:	8b 40 04             	mov    0x4(%eax),%eax
    a295:	bb 01 00 00 00       	mov    $0x1,%ebx
    a29a:	89 c1                	mov    %eax,%ecx
    a29c:	d3 e3                	shl    %cl,%ebx
    a29e:	89 d8                	mov    %ebx,%eax
    a2a0:	83 e8 01             	sub    $0x1,%eax
    a2a3:	21 d0                	and    %edx,%eax
    a2a5:	88 45 f6             	mov    %al,-0xa(%ebp)
      addColorBits(out, i, mode->bitdepth, gray);
    a2a8:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
    a2ac:	8b 45 10             	mov    0x10(%ebp),%eax
    a2af:	8b 40 04             	mov    0x4(%eax),%eax
    a2b2:	52                   	push   %edx
    a2b3:	50                   	push   %eax
    a2b4:	ff 75 0c             	pushl  0xc(%ebp)
    a2b7:	ff 75 08             	pushl  0x8(%ebp)
    a2ba:	e8 21 fc ff ff       	call   9ee0 <addColorBits>
    a2bf:	83 c4 10             	add    $0x10,%esp
    a2c2:	e9 2c 03 00 00       	jmp    a5f3 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGB) {
    a2c7:	8b 45 10             	mov    0x10(%ebp),%eax
    a2ca:	8b 00                	mov    (%eax),%eax
    a2cc:	83 f8 02             	cmp    $0x2,%eax
    a2cf:	0f 85 ee 00 00 00    	jne    a3c3 <rgba8ToPixel+0x1d5>
    if(mode->bitdepth == 8) {
    a2d5:	8b 45 10             	mov    0x10(%ebp),%eax
    a2d8:	8b 40 04             	mov    0x4(%eax),%eax
    a2db:	83 f8 08             	cmp    $0x8,%eax
    a2de:	75 49                	jne    a329 <rgba8ToPixel+0x13b>
      out[i * 3 + 0] = r;
    a2e0:	8b 55 0c             	mov    0xc(%ebp),%edx
    a2e3:	89 d0                	mov    %edx,%eax
    a2e5:	01 c0                	add    %eax,%eax
    a2e7:	01 d0                	add    %edx,%eax
    a2e9:	89 c2                	mov    %eax,%edx
    a2eb:	8b 45 08             	mov    0x8(%ebp),%eax
    a2ee:	01 c2                	add    %eax,%edx
    a2f0:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a2f4:	88 02                	mov    %al,(%edx)
      out[i * 3 + 1] = g;
    a2f6:	8b 55 0c             	mov    0xc(%ebp),%edx
    a2f9:	89 d0                	mov    %edx,%eax
    a2fb:	01 c0                	add    %eax,%eax
    a2fd:	01 d0                	add    %edx,%eax
    a2ff:	8d 50 01             	lea    0x1(%eax),%edx
    a302:	8b 45 08             	mov    0x8(%ebp),%eax
    a305:	01 c2                	add    %eax,%edx
    a307:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a30b:	88 02                	mov    %al,(%edx)
      out[i * 3 + 2] = b;
    a30d:	8b 55 0c             	mov    0xc(%ebp),%edx
    a310:	89 d0                	mov    %edx,%eax
    a312:	01 c0                	add    %eax,%eax
    a314:	01 d0                	add    %edx,%eax
    a316:	8d 50 02             	lea    0x2(%eax),%edx
    a319:	8b 45 08             	mov    0x8(%ebp),%eax
    a31c:	01 c2                	add    %eax,%edx
    a31e:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a322:	88 02                	mov    %al,(%edx)
    a324:	e9 ca 02 00 00       	jmp    a5f3 <rgba8ToPixel+0x405>
    } else {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
    a329:	8b 55 0c             	mov    0xc(%ebp),%edx
    a32c:	89 d0                	mov    %edx,%eax
    a32e:	01 c0                	add    %eax,%eax
    a330:	01 d0                	add    %edx,%eax
    a332:	01 c0                	add    %eax,%eax
    a334:	89 c2                	mov    %eax,%edx
    a336:	8b 45 08             	mov    0x8(%ebp),%eax
    a339:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a33c:	8b 55 0c             	mov    0xc(%ebp),%edx
    a33f:	89 d0                	mov    %edx,%eax
    a341:	01 c0                	add    %eax,%eax
    a343:	01 d0                	add    %edx,%eax
    a345:	01 c0                	add    %eax,%eax
    a347:	8d 50 01             	lea    0x1(%eax),%edx
    a34a:	8b 45 08             	mov    0x8(%ebp),%eax
    a34d:	01 d0                	add    %edx,%eax
    a34f:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a353:	88 10                	mov    %dl,(%eax)
    a355:	0f b6 00             	movzbl (%eax),%eax
    a358:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 2] = out[i * 6 + 3] = g;
    a35a:	8b 55 0c             	mov    0xc(%ebp),%edx
    a35d:	89 d0                	mov    %edx,%eax
    a35f:	01 c0                	add    %eax,%eax
    a361:	01 d0                	add    %edx,%eax
    a363:	01 c0                	add    %eax,%eax
    a365:	8d 50 02             	lea    0x2(%eax),%edx
    a368:	8b 45 08             	mov    0x8(%ebp),%eax
    a36b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a36e:	8b 55 0c             	mov    0xc(%ebp),%edx
    a371:	89 d0                	mov    %edx,%eax
    a373:	01 c0                	add    %eax,%eax
    a375:	01 d0                	add    %edx,%eax
    a377:	01 c0                	add    %eax,%eax
    a379:	8d 50 03             	lea    0x3(%eax),%edx
    a37c:	8b 45 08             	mov    0x8(%ebp),%eax
    a37f:	01 d0                	add    %edx,%eax
    a381:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a385:	88 10                	mov    %dl,(%eax)
    a387:	0f b6 00             	movzbl (%eax),%eax
    a38a:	88 01                	mov    %al,(%ecx)
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    a38c:	8b 55 0c             	mov    0xc(%ebp),%edx
    a38f:	89 d0                	mov    %edx,%eax
    a391:	01 c0                	add    %eax,%eax
    a393:	01 d0                	add    %edx,%eax
    a395:	01 c0                	add    %eax,%eax
    a397:	8d 50 04             	lea    0x4(%eax),%edx
    a39a:	8b 45 08             	mov    0x8(%ebp),%eax
    a39d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a3a0:	8b 55 0c             	mov    0xc(%ebp),%edx
    a3a3:	89 d0                	mov    %edx,%eax
    a3a5:	01 c0                	add    %eax,%eax
    a3a7:	01 d0                	add    %edx,%eax
    a3a9:	01 c0                	add    %eax,%eax
    a3ab:	8d 50 05             	lea    0x5(%eax),%edx
    a3ae:	8b 45 08             	mov    0x8(%ebp),%eax
    a3b1:	01 d0                	add    %edx,%eax
    a3b3:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a3b7:	88 10                	mov    %dl,(%eax)
    a3b9:	0f b6 00             	movzbl (%eax),%eax
    a3bc:	88 01                	mov    %al,(%ecx)
    a3be:	e9 30 02 00 00       	jmp    a5f3 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_PALETTE) {
    a3c3:	8b 45 10             	mov    0x10(%ebp),%eax
    a3c6:	8b 00                	mov    (%eax),%eax
    a3c8:	83 f8 03             	cmp    $0x3,%eax
    a3cb:	75 6d                	jne    a43a <rgba8ToPixel+0x24c>
    int index = color_tree_get(tree, r, g, b, a);
    a3cd:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
    a3d1:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    a3d5:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a3d9:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a3dd:	53                   	push   %ebx
    a3de:	51                   	push   %ecx
    a3df:	52                   	push   %edx
    a3e0:	50                   	push   %eax
    a3e1:	ff 75 14             	pushl  0x14(%ebp)
    a3e4:	e8 fd fb ff ff       	call   9fe6 <color_tree_get>
    a3e9:	83 c4 14             	add    $0x14,%esp
    a3ec:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(index < 0) return 82; /*color not in palette*/
    a3ef:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
    a3f3:	79 0a                	jns    a3ff <rgba8ToPixel+0x211>
    a3f5:	b8 52 00 00 00       	mov    $0x52,%eax
    a3fa:	e9 f9 01 00 00       	jmp    a5f8 <rgba8ToPixel+0x40a>
    if(mode->bitdepth == 8) out[i] = index;
    a3ff:	8b 45 10             	mov    0x10(%ebp),%eax
    a402:	8b 40 04             	mov    0x4(%eax),%eax
    a405:	83 f8 08             	cmp    $0x8,%eax
    a408:	75 12                	jne    a41c <rgba8ToPixel+0x22e>
    a40a:	8b 55 0c             	mov    0xc(%ebp),%edx
    a40d:	8b 45 08             	mov    0x8(%ebp),%eax
    a410:	01 d0                	add    %edx,%eax
    a412:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a415:	88 10                	mov    %dl,(%eax)
    a417:	e9 d7 01 00 00       	jmp    a5f3 <rgba8ToPixel+0x405>
    else addColorBits(out, i, mode->bitdepth, (unsigned)index);
    a41c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    a41f:	8b 45 10             	mov    0x10(%ebp),%eax
    a422:	8b 40 04             	mov    0x4(%eax),%eax
    a425:	52                   	push   %edx
    a426:	50                   	push   %eax
    a427:	ff 75 0c             	pushl  0xc(%ebp)
    a42a:	ff 75 08             	pushl  0x8(%ebp)
    a42d:	e8 ae fa ff ff       	call   9ee0 <addColorBits>
    a432:	83 c4 10             	add    $0x10,%esp
    a435:	e9 b9 01 00 00       	jmp    a5f3 <rgba8ToPixel+0x405>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a43a:	8b 45 10             	mov    0x10(%ebp),%eax
    a43d:	8b 00                	mov    (%eax),%eax
    a43f:	83 f8 04             	cmp    $0x4,%eax
    a442:	0f 85 9f 00 00 00    	jne    a4e7 <rgba8ToPixel+0x2f9>
    unsigned char gray = r; /*((unsigned short)r + g + b) / 3u;*/
    a448:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a44c:	88 45 f7             	mov    %al,-0x9(%ebp)
    if(mode->bitdepth == 8) {
    a44f:	8b 45 10             	mov    0x10(%ebp),%eax
    a452:	8b 40 04             	mov    0x4(%eax),%eax
    a455:	83 f8 08             	cmp    $0x8,%eax
    a458:	75 2a                	jne    a484 <rgba8ToPixel+0x296>
      out[i * 2 + 0] = gray;
    a45a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a45d:	01 c0                	add    %eax,%eax
    a45f:	89 c2                	mov    %eax,%edx
    a461:	8b 45 08             	mov    0x8(%ebp),%eax
    a464:	01 c2                	add    %eax,%edx
    a466:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
    a46a:	88 02                	mov    %al,(%edx)
      out[i * 2 + 1] = a;
    a46c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a46f:	01 c0                	add    %eax,%eax
    a471:	8d 50 01             	lea    0x1(%eax),%edx
    a474:	8b 45 08             	mov    0x8(%ebp),%eax
    a477:	01 c2                	add    %eax,%edx
    a479:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a47d:	88 02                	mov    %al,(%edx)
    a47f:	e9 6f 01 00 00       	jmp    a5f3 <rgba8ToPixel+0x405>
    } else if(mode->bitdepth == 16) {
    a484:	8b 45 10             	mov    0x10(%ebp),%eax
    a487:	8b 40 04             	mov    0x4(%eax),%eax
    a48a:	83 f8 10             	cmp    $0x10,%eax
    a48d:	0f 85 60 01 00 00    	jne    a5f3 <rgba8ToPixel+0x405>
      out[i * 4 + 0] = out[i * 4 + 1] = gray;
    a493:	8b 45 0c             	mov    0xc(%ebp),%eax
    a496:	c1 e0 02             	shl    $0x2,%eax
    a499:	89 c2                	mov    %eax,%edx
    a49b:	8b 45 08             	mov    0x8(%ebp),%eax
    a49e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a4a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4a4:	c1 e0 02             	shl    $0x2,%eax
    a4a7:	8d 50 01             	lea    0x1(%eax),%edx
    a4aa:	8b 45 08             	mov    0x8(%ebp),%eax
    a4ad:	01 d0                	add    %edx,%eax
    a4af:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
    a4b3:	88 10                	mov    %dl,(%eax)
    a4b5:	0f b6 00             	movzbl (%eax),%eax
    a4b8:	88 01                	mov    %al,(%ecx)
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    a4ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4bd:	c1 e0 02             	shl    $0x2,%eax
    a4c0:	8d 50 02             	lea    0x2(%eax),%edx
    a4c3:	8b 45 08             	mov    0x8(%ebp),%eax
    a4c6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a4c9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a4cc:	c1 e0 02             	shl    $0x2,%eax
    a4cf:	8d 50 03             	lea    0x3(%eax),%edx
    a4d2:	8b 45 08             	mov    0x8(%ebp),%eax
    a4d5:	01 d0                	add    %edx,%eax
    a4d7:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a4db:	88 10                	mov    %dl,(%eax)
    a4dd:	0f b6 00             	movzbl (%eax),%eax
    a4e0:	88 01                	mov    %al,(%ecx)
    a4e2:	e9 0c 01 00 00       	jmp    a5f3 <rgba8ToPixel+0x405>
    }
  } else if(mode->colortype == LCT_RGBA) {
    a4e7:	8b 45 10             	mov    0x10(%ebp),%eax
    a4ea:	8b 00                	mov    (%eax),%eax
    a4ec:	83 f8 06             	cmp    $0x6,%eax
    a4ef:	0f 85 fe 00 00 00    	jne    a5f3 <rgba8ToPixel+0x405>
    if(mode->bitdepth == 8) {
    a4f5:	8b 45 10             	mov    0x10(%ebp),%eax
    a4f8:	8b 40 04             	mov    0x4(%eax),%eax
    a4fb:	83 f8 08             	cmp    $0x8,%eax
    a4fe:	75 54                	jne    a554 <rgba8ToPixel+0x366>
      out[i * 4 + 0] = r;
    a500:	8b 45 0c             	mov    0xc(%ebp),%eax
    a503:	c1 e0 02             	shl    $0x2,%eax
    a506:	89 c2                	mov    %eax,%edx
    a508:	8b 45 08             	mov    0x8(%ebp),%eax
    a50b:	01 c2                	add    %eax,%edx
    a50d:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    a511:	88 02                	mov    %al,(%edx)
      out[i * 4 + 1] = g;
    a513:	8b 45 0c             	mov    0xc(%ebp),%eax
    a516:	c1 e0 02             	shl    $0x2,%eax
    a519:	8d 50 01             	lea    0x1(%eax),%edx
    a51c:	8b 45 08             	mov    0x8(%ebp),%eax
    a51f:	01 c2                	add    %eax,%edx
    a521:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
    a525:	88 02                	mov    %al,(%edx)
      out[i * 4 + 2] = b;
    a527:	8b 45 0c             	mov    0xc(%ebp),%eax
    a52a:	c1 e0 02             	shl    $0x2,%eax
    a52d:	8d 50 02             	lea    0x2(%eax),%edx
    a530:	8b 45 08             	mov    0x8(%ebp),%eax
    a533:	01 c2                	add    %eax,%edx
    a535:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
    a539:	88 02                	mov    %al,(%edx)
      out[i * 4 + 3] = a;
    a53b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a53e:	c1 e0 02             	shl    $0x2,%eax
    a541:	8d 50 03             	lea    0x3(%eax),%edx
    a544:	8b 45 08             	mov    0x8(%ebp),%eax
    a547:	01 c2                	add    %eax,%edx
    a549:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
    a54d:	88 02                	mov    %al,(%edx)
    a54f:	e9 9f 00 00 00       	jmp    a5f3 <rgba8ToPixel+0x405>
    } else {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
    a554:	8b 45 0c             	mov    0xc(%ebp),%eax
    a557:	c1 e0 03             	shl    $0x3,%eax
    a55a:	89 c2                	mov    %eax,%edx
    a55c:	8b 45 08             	mov    0x8(%ebp),%eax
    a55f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a562:	8b 45 0c             	mov    0xc(%ebp),%eax
    a565:	c1 e0 03             	shl    $0x3,%eax
    a568:	8d 50 01             	lea    0x1(%eax),%edx
    a56b:	8b 45 08             	mov    0x8(%ebp),%eax
    a56e:	01 d0                	add    %edx,%eax
    a570:	0f b6 55 e8          	movzbl -0x18(%ebp),%edx
    a574:	88 10                	mov    %dl,(%eax)
    a576:	0f b6 00             	movzbl (%eax),%eax
    a579:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 2] = out[i * 8 + 3] = g;
    a57b:	8b 45 0c             	mov    0xc(%ebp),%eax
    a57e:	c1 e0 03             	shl    $0x3,%eax
    a581:	8d 50 02             	lea    0x2(%eax),%edx
    a584:	8b 45 08             	mov    0x8(%ebp),%eax
    a587:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a58a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a58d:	c1 e0 03             	shl    $0x3,%eax
    a590:	8d 50 03             	lea    0x3(%eax),%edx
    a593:	8b 45 08             	mov    0x8(%ebp),%eax
    a596:	01 d0                	add    %edx,%eax
    a598:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    a59c:	88 10                	mov    %dl,(%eax)
    a59e:	0f b6 00             	movzbl (%eax),%eax
    a5a1:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 4] = out[i * 8 + 5] = b;
    a5a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5a6:	c1 e0 03             	shl    $0x3,%eax
    a5a9:	8d 50 04             	lea    0x4(%eax),%edx
    a5ac:	8b 45 08             	mov    0x8(%ebp),%eax
    a5af:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a5b2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5b5:	c1 e0 03             	shl    $0x3,%eax
    a5b8:	8d 50 05             	lea    0x5(%eax),%edx
    a5bb:	8b 45 08             	mov    0x8(%ebp),%eax
    a5be:	01 d0                	add    %edx,%eax
    a5c0:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
    a5c4:	88 10                	mov    %dl,(%eax)
    a5c6:	0f b6 00             	movzbl (%eax),%eax
    a5c9:	88 01                	mov    %al,(%ecx)
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    a5cb:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5ce:	c1 e0 03             	shl    $0x3,%eax
    a5d1:	8d 50 06             	lea    0x6(%eax),%edx
    a5d4:	8b 45 08             	mov    0x8(%ebp),%eax
    a5d7:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    a5da:	8b 45 0c             	mov    0xc(%ebp),%eax
    a5dd:	c1 e0 03             	shl    $0x3,%eax
    a5e0:	8d 50 07             	lea    0x7(%eax),%edx
    a5e3:	8b 45 08             	mov    0x8(%ebp),%eax
    a5e6:	01 d0                	add    %edx,%eax
    a5e8:	0f b6 55 dc          	movzbl -0x24(%ebp),%edx
    a5ec:	88 10                	mov    %dl,(%eax)
    a5ee:	0f b6 00             	movzbl (%eax),%eax
    a5f1:	88 01                	mov    %al,(%ecx)
    }
  }

  return 0; /*no error*/
    a5f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
    a5f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    a5fb:	c9                   	leave  
    a5fc:	c3                   	ret    

0000a5fd <rgba16ToPixel>:

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
                         const LodePNGColorMode* mode,
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
    a5fd:	55                   	push   %ebp
    a5fe:	89 e5                	mov    %esp,%ebp
    a600:	53                   	push   %ebx
    a601:	83 ec 20             	sub    $0x20,%esp
    a604:	8b 5d 14             	mov    0x14(%ebp),%ebx
    a607:	8b 4d 18             	mov    0x18(%ebp),%ecx
    a60a:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a60d:	8b 45 20             	mov    0x20(%ebp),%eax
    a610:	66 89 5d e8          	mov    %bx,-0x18(%ebp)
    a614:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
    a618:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    a61c:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  if(mode->colortype == LCT_GREY) {
    a620:	8b 45 10             	mov    0x10(%ebp),%eax
    a623:	8b 00                	mov    (%eax),%eax
    a625:	85 c0                	test   %eax,%eax
    a627:	75 36                	jne    a65f <rgba16ToPixel+0x62>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a629:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a62d:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
    out[i * 2 + 0] = (gray >> 8) & 255;
    a631:	8b 45 0c             	mov    0xc(%ebp),%eax
    a634:	01 c0                	add    %eax,%eax
    a636:	89 c2                	mov    %eax,%edx
    a638:	8b 45 08             	mov    0x8(%ebp),%eax
    a63b:	01 d0                	add    %edx,%eax
    a63d:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a641:	66 c1 ea 08          	shr    $0x8,%dx
    a645:	88 10                	mov    %dl,(%eax)
    out[i * 2 + 1] = gray & 255;
    a647:	8b 45 0c             	mov    0xc(%ebp),%eax
    a64a:	01 c0                	add    %eax,%eax
    a64c:	8d 50 01             	lea    0x1(%eax),%edx
    a64f:	8b 45 08             	mov    0x8(%ebp),%eax
    a652:	01 d0                	add    %edx,%eax
    a654:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
    a658:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a65a:	e9 df 01 00 00       	jmp    a83e <rgba16ToPixel+0x241>
                         unsigned short r, unsigned short g, unsigned short b, unsigned short a) {
  if(mode->colortype == LCT_GREY) {
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 2 + 0] = (gray >> 8) & 255;
    out[i * 2 + 1] = gray & 255;
  } else if(mode->colortype == LCT_RGB) {
    a65f:	8b 45 10             	mov    0x10(%ebp),%eax
    a662:	8b 00                	mov    (%eax),%eax
    a664:	83 f8 02             	cmp    $0x2,%eax
    a667:	0f 85 a6 00 00 00    	jne    a713 <rgba16ToPixel+0x116>
    out[i * 6 + 0] = (r >> 8) & 255;
    a66d:	8b 55 0c             	mov    0xc(%ebp),%edx
    a670:	89 d0                	mov    %edx,%eax
    a672:	01 c0                	add    %eax,%eax
    a674:	01 d0                	add    %edx,%eax
    a676:	01 c0                	add    %eax,%eax
    a678:	89 c2                	mov    %eax,%edx
    a67a:	8b 45 08             	mov    0x8(%ebp),%eax
    a67d:	01 d0                	add    %edx,%eax
    a67f:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a683:	66 c1 ea 08          	shr    $0x8,%dx
    a687:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 1] = r & 255;
    a689:	8b 55 0c             	mov    0xc(%ebp),%edx
    a68c:	89 d0                	mov    %edx,%eax
    a68e:	01 c0                	add    %eax,%eax
    a690:	01 d0                	add    %edx,%eax
    a692:	01 c0                	add    %eax,%eax
    a694:	8d 50 01             	lea    0x1(%eax),%edx
    a697:	8b 45 08             	mov    0x8(%ebp),%eax
    a69a:	01 d0                	add    %edx,%eax
    a69c:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a6a0:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 2] = (g >> 8) & 255;
    a6a2:	8b 55 0c             	mov    0xc(%ebp),%edx
    a6a5:	89 d0                	mov    %edx,%eax
    a6a7:	01 c0                	add    %eax,%eax
    a6a9:	01 d0                	add    %edx,%eax
    a6ab:	01 c0                	add    %eax,%eax
    a6ad:	8d 50 02             	lea    0x2(%eax),%edx
    a6b0:	8b 45 08             	mov    0x8(%ebp),%eax
    a6b3:	01 d0                	add    %edx,%eax
    a6b5:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a6b9:	66 c1 ea 08          	shr    $0x8,%dx
    a6bd:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 3] = g & 255;
    a6bf:	8b 55 0c             	mov    0xc(%ebp),%edx
    a6c2:	89 d0                	mov    %edx,%eax
    a6c4:	01 c0                	add    %eax,%eax
    a6c6:	01 d0                	add    %edx,%eax
    a6c8:	01 c0                	add    %eax,%eax
    a6ca:	8d 50 03             	lea    0x3(%eax),%edx
    a6cd:	8b 45 08             	mov    0x8(%ebp),%eax
    a6d0:	01 d0                	add    %edx,%eax
    a6d2:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a6d6:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 4] = (b >> 8) & 255;
    a6d8:	8b 55 0c             	mov    0xc(%ebp),%edx
    a6db:	89 d0                	mov    %edx,%eax
    a6dd:	01 c0                	add    %eax,%eax
    a6df:	01 d0                	add    %edx,%eax
    a6e1:	01 c0                	add    %eax,%eax
    a6e3:	8d 50 04             	lea    0x4(%eax),%edx
    a6e6:	8b 45 08             	mov    0x8(%ebp),%eax
    a6e9:	01 d0                	add    %edx,%eax
    a6eb:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a6ef:	66 c1 ea 08          	shr    $0x8,%dx
    a6f3:	88 10                	mov    %dl,(%eax)
    out[i * 6 + 5] = b & 255;
    a6f5:	8b 55 0c             	mov    0xc(%ebp),%edx
    a6f8:	89 d0                	mov    %edx,%eax
    a6fa:	01 c0                	add    %eax,%eax
    a6fc:	01 d0                	add    %edx,%eax
    a6fe:	01 c0                	add    %eax,%eax
    a700:	8d 50 05             	lea    0x5(%eax),%edx
    a703:	8b 45 08             	mov    0x8(%ebp),%eax
    a706:	01 d0                	add    %edx,%eax
    a708:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a70c:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a70e:	e9 2b 01 00 00       	jmp    a83e <rgba16ToPixel+0x241>
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    a713:	8b 45 10             	mov    0x10(%ebp),%eax
    a716:	8b 00                	mov    (%eax),%eax
    a718:	83 f8 04             	cmp    $0x4,%eax
    a71b:	75 64                	jne    a781 <rgba16ToPixel+0x184>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    a71d:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    a721:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
    out[i * 4 + 0] = (gray >> 8) & 255;
    a725:	8b 45 0c             	mov    0xc(%ebp),%eax
    a728:	c1 e0 02             	shl    $0x2,%eax
    a72b:	89 c2                	mov    %eax,%edx
    a72d:	8b 45 08             	mov    0x8(%ebp),%eax
    a730:	01 d0                	add    %edx,%eax
    a732:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a736:	66 c1 ea 08          	shr    $0x8,%dx
    a73a:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 1] = gray & 255;
    a73c:	8b 45 0c             	mov    0xc(%ebp),%eax
    a73f:	c1 e0 02             	shl    $0x2,%eax
    a742:	8d 50 01             	lea    0x1(%eax),%edx
    a745:	8b 45 08             	mov    0x8(%ebp),%eax
    a748:	01 d0                	add    %edx,%eax
    a74a:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
    a74e:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 2] = (a >> 8) & 255;
    a750:	8b 45 0c             	mov    0xc(%ebp),%eax
    a753:	c1 e0 02             	shl    $0x2,%eax
    a756:	8d 50 02             	lea    0x2(%eax),%edx
    a759:	8b 45 08             	mov    0x8(%ebp),%eax
    a75c:	01 d0                	add    %edx,%eax
    a75e:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a762:	66 c1 ea 08          	shr    $0x8,%dx
    a766:	88 10                	mov    %dl,(%eax)
    out[i * 4 + 3] = a & 255;
    a768:	8b 45 0c             	mov    0xc(%ebp),%eax
    a76b:	c1 e0 02             	shl    $0x2,%eax
    a76e:	8d 50 03             	lea    0x3(%eax),%edx
    a771:	8b 45 08             	mov    0x8(%ebp),%eax
    a774:	01 d0                	add    %edx,%eax
    a776:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a77a:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }
}
    a77c:	e9 bd 00 00 00       	jmp    a83e <rgba16ToPixel+0x241>
    unsigned short gray = r; /*((unsigned)r + g + b) / 3u;*/
    out[i * 4 + 0] = (gray >> 8) & 255;
    out[i * 4 + 1] = gray & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  } else if(mode->colortype == LCT_RGBA) {
    a781:	8b 45 10             	mov    0x10(%ebp),%eax
    a784:	8b 00                	mov    (%eax),%eax
    a786:	83 f8 06             	cmp    $0x6,%eax
    a789:	0f 85 af 00 00 00    	jne    a83e <rgba16ToPixel+0x241>
    out[i * 8 + 0] = (r >> 8) & 255;
    a78f:	8b 45 0c             	mov    0xc(%ebp),%eax
    a792:	c1 e0 03             	shl    $0x3,%eax
    a795:	89 c2                	mov    %eax,%edx
    a797:	8b 45 08             	mov    0x8(%ebp),%eax
    a79a:	01 d0                	add    %edx,%eax
    a79c:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a7a0:	66 c1 ea 08          	shr    $0x8,%dx
    a7a4:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 1] = r & 255;
    a7a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7a9:	c1 e0 03             	shl    $0x3,%eax
    a7ac:	8d 50 01             	lea    0x1(%eax),%edx
    a7af:	8b 45 08             	mov    0x8(%ebp),%eax
    a7b2:	01 d0                	add    %edx,%eax
    a7b4:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
    a7b8:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 2] = (g >> 8) & 255;
    a7ba:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7bd:	c1 e0 03             	shl    $0x3,%eax
    a7c0:	8d 50 02             	lea    0x2(%eax),%edx
    a7c3:	8b 45 08             	mov    0x8(%ebp),%eax
    a7c6:	01 d0                	add    %edx,%eax
    a7c8:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a7cc:	66 c1 ea 08          	shr    $0x8,%dx
    a7d0:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 3] = g & 255;
    a7d2:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7d5:	c1 e0 03             	shl    $0x3,%eax
    a7d8:	8d 50 03             	lea    0x3(%eax),%edx
    a7db:	8b 45 08             	mov    0x8(%ebp),%eax
    a7de:	01 d0                	add    %edx,%eax
    a7e0:	0f b7 55 e4          	movzwl -0x1c(%ebp),%edx
    a7e4:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 4] = (b >> 8) & 255;
    a7e6:	8b 45 0c             	mov    0xc(%ebp),%eax
    a7e9:	c1 e0 03             	shl    $0x3,%eax
    a7ec:	8d 50 04             	lea    0x4(%eax),%edx
    a7ef:	8b 45 08             	mov    0x8(%ebp),%eax
    a7f2:	01 d0                	add    %edx,%eax
    a7f4:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a7f8:	66 c1 ea 08          	shr    $0x8,%dx
    a7fc:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 5] = b & 255;
    a7fe:	8b 45 0c             	mov    0xc(%ebp),%eax
    a801:	c1 e0 03             	shl    $0x3,%eax
    a804:	8d 50 05             	lea    0x5(%eax),%edx
    a807:	8b 45 08             	mov    0x8(%ebp),%eax
    a80a:	01 d0                	add    %edx,%eax
    a80c:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
    a810:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 6] = (a >> 8) & 255;
    a812:	8b 45 0c             	mov    0xc(%ebp),%eax
    a815:	c1 e0 03             	shl    $0x3,%eax
    a818:	8d 50 06             	lea    0x6(%eax),%edx
    a81b:	8b 45 08             	mov    0x8(%ebp),%eax
    a81e:	01 d0                	add    %edx,%eax
    a820:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a824:	66 c1 ea 08          	shr    $0x8,%dx
    a828:	88 10                	mov    %dl,(%eax)
    out[i * 8 + 7] = a & 255;
    a82a:	8b 45 0c             	mov    0xc(%ebp),%eax
    a82d:	c1 e0 03             	shl    $0x3,%eax
    a830:	8d 50 07             	lea    0x7(%eax),%edx
    a833:	8b 45 08             	mov    0x8(%ebp),%eax
    a836:	01 d0                	add    %edx,%eax
    a838:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
    a83c:	88 10                	mov    %dl,(%eax)
  }
}
    a83e:	90                   	nop
    a83f:	83 c4 20             	add    $0x20,%esp
    a842:	5b                   	pop    %ebx
    a843:	5d                   	pop    %ebp
    a844:	c3                   	ret    

0000a845 <getPixelColorRGBA8>:

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                               unsigned char* b, unsigned char* a,
                               const unsigned char* in, size_t i,
                               const LodePNGColorMode* mode) {
    a845:	55                   	push   %ebp
    a846:	89 e5                	mov    %esp,%ebp
    a848:	83 ec 20             	sub    $0x20,%esp
  if(mode->colortype == LCT_GREY) {
    a84b:	8b 45 20             	mov    0x20(%ebp),%eax
    a84e:	8b 00                	mov    (%eax),%eax
    a850:	85 c0                	test   %eax,%eax
    a852:	0f 85 8c 01 00 00    	jne    a9e4 <getPixelColorRGBA8+0x19f>
    if(mode->bitdepth == 8) {
    a858:	8b 45 20             	mov    0x20(%ebp),%eax
    a85b:	8b 40 04             	mov    0x4(%eax),%eax
    a85e:	83 f8 08             	cmp    $0x8,%eax
    a861:	75 59                	jne    a8bc <getPixelColorRGBA8+0x77>
      *r = *g = *b = in[i];
    a863:	8b 55 1c             	mov    0x1c(%ebp),%edx
    a866:	8b 45 18             	mov    0x18(%ebp),%eax
    a869:	01 d0                	add    %edx,%eax
    a86b:	0f b6 10             	movzbl (%eax),%edx
    a86e:	8b 45 10             	mov    0x10(%ebp),%eax
    a871:	88 10                	mov    %dl,(%eax)
    a873:	8b 45 10             	mov    0x10(%ebp),%eax
    a876:	0f b6 10             	movzbl (%eax),%edx
    a879:	8b 45 0c             	mov    0xc(%ebp),%eax
    a87c:	88 10                	mov    %dl,(%eax)
    a87e:	8b 45 0c             	mov    0xc(%ebp),%eax
    a881:	0f b6 10             	movzbl (%eax),%edx
    a884:	8b 45 08             	mov    0x8(%ebp),%eax
    a887:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r) *a = 0;
    a889:	8b 45 20             	mov    0x20(%ebp),%eax
    a88c:	8b 40 10             	mov    0x10(%eax),%eax
    a88f:	85 c0                	test   %eax,%eax
    a891:	74 1e                	je     a8b1 <getPixelColorRGBA8+0x6c>
    a893:	8b 45 08             	mov    0x8(%ebp),%eax
    a896:	0f b6 00             	movzbl (%eax),%eax
    a899:	0f b6 d0             	movzbl %al,%edx
    a89c:	8b 45 20             	mov    0x20(%ebp),%eax
    a89f:	8b 40 14             	mov    0x14(%eax),%eax
    a8a2:	39 c2                	cmp    %eax,%edx
    a8a4:	75 0b                	jne    a8b1 <getPixelColorRGBA8+0x6c>
    a8a6:	8b 45 14             	mov    0x14(%ebp),%eax
    a8a9:	c6 00 00             	movb   $0x0,(%eax)
    a8ac:	e9 5e 05 00 00       	jmp    ae0f <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a8b1:	8b 45 14             	mov    0x14(%ebp),%eax
    a8b4:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a8b7:	e9 53 05 00 00       	jmp    ae0f <getPixelColorRGBA8+0x5ca>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    } else if(mode->bitdepth == 16) {
    a8bc:	8b 45 20             	mov    0x20(%ebp),%eax
    a8bf:	8b 40 04             	mov    0x4(%eax),%eax
    a8c2:	83 f8 10             	cmp    $0x10,%eax
    a8c5:	0f 85 80 00 00 00    	jne    a94b <getPixelColorRGBA8+0x106>
      *r = *g = *b = in[i * 2 + 0];
    a8cb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a8ce:	01 c0                	add    %eax,%eax
    a8d0:	89 c2                	mov    %eax,%edx
    a8d2:	8b 45 18             	mov    0x18(%ebp),%eax
    a8d5:	01 d0                	add    %edx,%eax
    a8d7:	0f b6 10             	movzbl (%eax),%edx
    a8da:	8b 45 10             	mov    0x10(%ebp),%eax
    a8dd:	88 10                	mov    %dl,(%eax)
    a8df:	8b 45 10             	mov    0x10(%ebp),%eax
    a8e2:	0f b6 10             	movzbl (%eax),%edx
    a8e5:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8e8:	88 10                	mov    %dl,(%eax)
    a8ea:	8b 45 0c             	mov    0xc(%ebp),%eax
    a8ed:	0f b6 10             	movzbl (%eax),%edx
    a8f0:	8b 45 08             	mov    0x8(%ebp),%eax
    a8f3:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    a8f5:	8b 45 20             	mov    0x20(%ebp),%eax
    a8f8:	8b 40 10             	mov    0x10(%eax),%eax
    a8fb:	85 c0                	test   %eax,%eax
    a8fd:	74 41                	je     a940 <getPixelColorRGBA8+0xfb>
    a8ff:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a902:	01 c0                	add    %eax,%eax
    a904:	89 c2                	mov    %eax,%edx
    a906:	8b 45 18             	mov    0x18(%ebp),%eax
    a909:	01 d0                	add    %edx,%eax
    a90b:	0f b6 00             	movzbl (%eax),%eax
    a90e:	0f b6 c0             	movzbl %al,%eax
    a911:	c1 e0 08             	shl    $0x8,%eax
    a914:	89 c2                	mov    %eax,%edx
    a916:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a919:	01 c0                	add    %eax,%eax
    a91b:	8d 48 01             	lea    0x1(%eax),%ecx
    a91e:	8b 45 18             	mov    0x18(%ebp),%eax
    a921:	01 c8                	add    %ecx,%eax
    a923:	0f b6 00             	movzbl (%eax),%eax
    a926:	0f b6 c0             	movzbl %al,%eax
    a929:	01 c2                	add    %eax,%edx
    a92b:	8b 45 20             	mov    0x20(%ebp),%eax
    a92e:	8b 40 14             	mov    0x14(%eax),%eax
    a931:	39 c2                	cmp    %eax,%edx
    a933:	75 0b                	jne    a940 <getPixelColorRGBA8+0xfb>
    a935:	8b 45 14             	mov    0x14(%ebp),%eax
    a938:	c6 00 00             	movb   $0x0,(%eax)
    a93b:	e9 cf 04 00 00       	jmp    ae0f <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a940:	8b 45 14             	mov    0x14(%ebp),%eax
    a943:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a946:	e9 c4 04 00 00       	jmp    ae0f <getPixelColorRGBA8+0x5ca>
    } else if(mode->bitdepth == 16) {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    a94b:	8b 45 20             	mov    0x20(%ebp),%eax
    a94e:	8b 40 04             	mov    0x4(%eax),%eax
    a951:	ba 01 00 00 00       	mov    $0x1,%edx
    a956:	89 c1                	mov    %eax,%ecx
    a958:	d3 e2                	shl    %cl,%edx
    a95a:	89 d0                	mov    %edx,%eax
    a95c:	83 e8 01             	sub    $0x1,%eax
    a95f:	89 45 f8             	mov    %eax,-0x8(%ebp)
      size_t j = i * mode->bitdepth;
    a962:	8b 45 20             	mov    0x20(%ebp),%eax
    a965:	8b 50 04             	mov    0x4(%eax),%edx
    a968:	8b 45 1c             	mov    0x1c(%ebp),%eax
    a96b:	0f af c2             	imul   %edx,%eax
    a96e:	89 45 f0             	mov    %eax,-0x10(%ebp)
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    a971:	8b 45 20             	mov    0x20(%ebp),%eax
    a974:	8b 40 04             	mov    0x4(%eax),%eax
    a977:	50                   	push   %eax
    a978:	ff 75 18             	pushl  0x18(%ebp)
    a97b:	8d 45 f0             	lea    -0x10(%ebp),%eax
    a97e:	50                   	push   %eax
    a97f:	e8 06 db ff ff       	call   848a <readBitsFromReversedStream>
    a984:	83 c4 0c             	add    $0xc,%esp
    a987:	89 45 f4             	mov    %eax,-0xc(%ebp)
      *r = *g = *b = (value * 255) / highest;
    a98a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    a98d:	89 d0                	mov    %edx,%eax
    a98f:	c1 e0 08             	shl    $0x8,%eax
    a992:	29 d0                	sub    %edx,%eax
    a994:	ba 00 00 00 00       	mov    $0x0,%edx
    a999:	f7 75 f8             	divl   -0x8(%ebp)
    a99c:	89 c2                	mov    %eax,%edx
    a99e:	8b 45 10             	mov    0x10(%ebp),%eax
    a9a1:	88 10                	mov    %dl,(%eax)
    a9a3:	8b 45 10             	mov    0x10(%ebp),%eax
    a9a6:	0f b6 10             	movzbl (%eax),%edx
    a9a9:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9ac:	88 10                	mov    %dl,(%eax)
    a9ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    a9b1:	0f b6 10             	movzbl (%eax),%edx
    a9b4:	8b 45 08             	mov    0x8(%ebp),%eax
    a9b7:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && value == mode->key_r) *a = 0;
    a9b9:	8b 45 20             	mov    0x20(%ebp),%eax
    a9bc:	8b 40 10             	mov    0x10(%eax),%eax
    a9bf:	85 c0                	test   %eax,%eax
    a9c1:	74 16                	je     a9d9 <getPixelColorRGBA8+0x194>
    a9c3:	8b 45 20             	mov    0x20(%ebp),%eax
    a9c6:	8b 40 14             	mov    0x14(%eax),%eax
    a9c9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    a9cc:	75 0b                	jne    a9d9 <getPixelColorRGBA8+0x194>
    a9ce:	8b 45 14             	mov    0x14(%ebp),%eax
    a9d1:	c6 00 00             	movb   $0x0,(%eax)
    a9d4:	e9 36 04 00 00       	jmp    ae0f <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    a9d9:	8b 45 14             	mov    0x14(%ebp),%eax
    a9dc:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    a9df:	e9 2b 04 00 00       	jmp    ae0f <getPixelColorRGBA8+0x5ca>
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_RGB) {
    a9e4:	8b 45 20             	mov    0x20(%ebp),%eax
    a9e7:	8b 00                	mov    (%eax),%eax
    a9e9:	83 f8 02             	cmp    $0x2,%eax
    a9ec:	0f 85 f5 01 00 00    	jne    abe7 <getPixelColorRGBA8+0x3a2>
    if(mode->bitdepth == 8) {
    a9f2:	8b 45 20             	mov    0x20(%ebp),%eax
    a9f5:	8b 40 04             	mov    0x4(%eax),%eax
    a9f8:	83 f8 08             	cmp    $0x8,%eax
    a9fb:	0f 85 a3 00 00 00    	jne    aaa4 <getPixelColorRGBA8+0x25f>
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
    aa01:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aa04:	89 d0                	mov    %edx,%eax
    aa06:	01 c0                	add    %eax,%eax
    aa08:	01 d0                	add    %edx,%eax
    aa0a:	89 c2                	mov    %eax,%edx
    aa0c:	8b 45 18             	mov    0x18(%ebp),%eax
    aa0f:	01 d0                	add    %edx,%eax
    aa11:	0f b6 10             	movzbl (%eax),%edx
    aa14:	8b 45 08             	mov    0x8(%ebp),%eax
    aa17:	88 10                	mov    %dl,(%eax)
    aa19:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aa1c:	89 d0                	mov    %edx,%eax
    aa1e:	01 c0                	add    %eax,%eax
    aa20:	01 d0                	add    %edx,%eax
    aa22:	8d 50 01             	lea    0x1(%eax),%edx
    aa25:	8b 45 18             	mov    0x18(%ebp),%eax
    aa28:	01 d0                	add    %edx,%eax
    aa2a:	0f b6 10             	movzbl (%eax),%edx
    aa2d:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa30:	88 10                	mov    %dl,(%eax)
    aa32:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aa35:	89 d0                	mov    %edx,%eax
    aa37:	01 c0                	add    %eax,%eax
    aa39:	01 d0                	add    %edx,%eax
    aa3b:	8d 50 02             	lea    0x2(%eax),%edx
    aa3e:	8b 45 18             	mov    0x18(%ebp),%eax
    aa41:	01 d0                	add    %edx,%eax
    aa43:	0f b6 10             	movzbl (%eax),%edx
    aa46:	8b 45 10             	mov    0x10(%ebp),%eax
    aa49:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
    aa4b:	8b 45 20             	mov    0x20(%ebp),%eax
    aa4e:	8b 40 10             	mov    0x10(%eax),%eax
    aa51:	85 c0                	test   %eax,%eax
    aa53:	74 44                	je     aa99 <getPixelColorRGBA8+0x254>
    aa55:	8b 45 08             	mov    0x8(%ebp),%eax
    aa58:	0f b6 00             	movzbl (%eax),%eax
    aa5b:	0f b6 d0             	movzbl %al,%edx
    aa5e:	8b 45 20             	mov    0x20(%ebp),%eax
    aa61:	8b 40 14             	mov    0x14(%eax),%eax
    aa64:	39 c2                	cmp    %eax,%edx
    aa66:	75 31                	jne    aa99 <getPixelColorRGBA8+0x254>
    aa68:	8b 45 0c             	mov    0xc(%ebp),%eax
    aa6b:	0f b6 00             	movzbl (%eax),%eax
    aa6e:	0f b6 d0             	movzbl %al,%edx
    aa71:	8b 45 20             	mov    0x20(%ebp),%eax
    aa74:	8b 40 18             	mov    0x18(%eax),%eax
    aa77:	39 c2                	cmp    %eax,%edx
    aa79:	75 1e                	jne    aa99 <getPixelColorRGBA8+0x254>
    aa7b:	8b 45 10             	mov    0x10(%ebp),%eax
    aa7e:	0f b6 00             	movzbl (%eax),%eax
    aa81:	0f b6 d0             	movzbl %al,%edx
    aa84:	8b 45 20             	mov    0x20(%ebp),%eax
    aa87:	8b 40 1c             	mov    0x1c(%eax),%eax
    aa8a:	39 c2                	cmp    %eax,%edx
    aa8c:	75 0b                	jne    aa99 <getPixelColorRGBA8+0x254>
    aa8e:	8b 45 14             	mov    0x14(%ebp),%eax
    aa91:	c6 00 00             	movb   $0x0,(%eax)
    aa94:	e9 76 03 00 00       	jmp    ae0f <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    aa99:	8b 45 14             	mov    0x14(%ebp),%eax
    aa9c:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    aa9f:	e9 6b 03 00 00       	jmp    ae0f <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    } else {
      *r = in[i * 6 + 0];
    aaa4:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aaa7:	89 d0                	mov    %edx,%eax
    aaa9:	01 c0                	add    %eax,%eax
    aaab:	01 d0                	add    %edx,%eax
    aaad:	01 c0                	add    %eax,%eax
    aaaf:	89 c2                	mov    %eax,%edx
    aab1:	8b 45 18             	mov    0x18(%ebp),%eax
    aab4:	01 d0                	add    %edx,%eax
    aab6:	0f b6 10             	movzbl (%eax),%edx
    aab9:	8b 45 08             	mov    0x8(%ebp),%eax
    aabc:	88 10                	mov    %dl,(%eax)
      *g = in[i * 6 + 2];
    aabe:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aac1:	89 d0                	mov    %edx,%eax
    aac3:	01 c0                	add    %eax,%eax
    aac5:	01 d0                	add    %edx,%eax
    aac7:	01 c0                	add    %eax,%eax
    aac9:	8d 50 02             	lea    0x2(%eax),%edx
    aacc:	8b 45 18             	mov    0x18(%ebp),%eax
    aacf:	01 d0                	add    %edx,%eax
    aad1:	0f b6 10             	movzbl (%eax),%edx
    aad4:	8b 45 0c             	mov    0xc(%ebp),%eax
    aad7:	88 10                	mov    %dl,(%eax)
      *b = in[i * 6 + 4];
    aad9:	8b 55 1c             	mov    0x1c(%ebp),%edx
    aadc:	89 d0                	mov    %edx,%eax
    aade:	01 c0                	add    %eax,%eax
    aae0:	01 d0                	add    %edx,%eax
    aae2:	01 c0                	add    %eax,%eax
    aae4:	8d 50 04             	lea    0x4(%eax),%edx
    aae7:	8b 45 18             	mov    0x18(%ebp),%eax
    aaea:	01 d0                	add    %edx,%eax
    aaec:	0f b6 10             	movzbl (%eax),%edx
    aaef:	8b 45 10             	mov    0x10(%ebp),%eax
    aaf2:	88 10                	mov    %dl,(%eax)
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    aaf4:	8b 45 20             	mov    0x20(%ebp),%eax
    aaf7:	8b 40 10             	mov    0x10(%eax),%eax
    aafa:	85 c0                	test   %eax,%eax
    aafc:	0f 84 da 00 00 00    	je     abdc <getPixelColorRGBA8+0x397>
    ab02:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ab05:	89 d0                	mov    %edx,%eax
    ab07:	01 c0                	add    %eax,%eax
    ab09:	01 d0                	add    %edx,%eax
    ab0b:	01 c0                	add    %eax,%eax
    ab0d:	89 c2                	mov    %eax,%edx
    ab0f:	8b 45 18             	mov    0x18(%ebp),%eax
    ab12:	01 d0                	add    %edx,%eax
    ab14:	0f b6 00             	movzbl (%eax),%eax
    ab17:	0f b6 c0             	movzbl %al,%eax
    ab1a:	c1 e0 08             	shl    $0x8,%eax
    ab1d:	89 c1                	mov    %eax,%ecx
    ab1f:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ab22:	89 d0                	mov    %edx,%eax
    ab24:	01 c0                	add    %eax,%eax
    ab26:	01 d0                	add    %edx,%eax
    ab28:	01 c0                	add    %eax,%eax
    ab2a:	8d 50 01             	lea    0x1(%eax),%edx
    ab2d:	8b 45 18             	mov    0x18(%ebp),%eax
    ab30:	01 d0                	add    %edx,%eax
    ab32:	0f b6 00             	movzbl (%eax),%eax
    ab35:	0f b6 c0             	movzbl %al,%eax
    ab38:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ab3b:	8b 45 20             	mov    0x20(%ebp),%eax
    ab3e:	8b 40 14             	mov    0x14(%eax),%eax
    ab41:	39 c2                	cmp    %eax,%edx
    ab43:	0f 85 93 00 00 00    	jne    abdc <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    ab49:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ab4c:	89 d0                	mov    %edx,%eax
    ab4e:	01 c0                	add    %eax,%eax
    ab50:	01 d0                	add    %edx,%eax
    ab52:	01 c0                	add    %eax,%eax
    ab54:	8d 50 02             	lea    0x2(%eax),%edx
    ab57:	8b 45 18             	mov    0x18(%ebp),%eax
    ab5a:	01 d0                	add    %edx,%eax
    ab5c:	0f b6 00             	movzbl (%eax),%eax
    ab5f:	0f b6 c0             	movzbl %al,%eax
    ab62:	c1 e0 08             	shl    $0x8,%eax
    ab65:	89 c1                	mov    %eax,%ecx
    ab67:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ab6a:	89 d0                	mov    %edx,%eax
    ab6c:	01 c0                	add    %eax,%eax
    ab6e:	01 d0                	add    %edx,%eax
    ab70:	01 c0                	add    %eax,%eax
    ab72:	8d 50 03             	lea    0x3(%eax),%edx
    ab75:	8b 45 18             	mov    0x18(%ebp),%eax
    ab78:	01 d0                	add    %edx,%eax
    ab7a:	0f b6 00             	movzbl (%eax),%eax
    ab7d:	0f b6 c0             	movzbl %al,%eax
    ab80:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ab83:	8b 45 20             	mov    0x20(%ebp),%eax
    ab86:	8b 40 18             	mov    0x18(%eax),%eax
    ab89:	39 c2                	cmp    %eax,%edx
    ab8b:	75 4f                	jne    abdc <getPixelColorRGBA8+0x397>
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    ab8d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ab90:	89 d0                	mov    %edx,%eax
    ab92:	01 c0                	add    %eax,%eax
    ab94:	01 d0                	add    %edx,%eax
    ab96:	01 c0                	add    %eax,%eax
    ab98:	8d 50 04             	lea    0x4(%eax),%edx
    ab9b:	8b 45 18             	mov    0x18(%ebp),%eax
    ab9e:	01 d0                	add    %edx,%eax
    aba0:	0f b6 00             	movzbl (%eax),%eax
    aba3:	0f b6 c0             	movzbl %al,%eax
    aba6:	c1 e0 08             	shl    $0x8,%eax
    aba9:	89 c1                	mov    %eax,%ecx
    abab:	8b 55 1c             	mov    0x1c(%ebp),%edx
    abae:	89 d0                	mov    %edx,%eax
    abb0:	01 c0                	add    %eax,%eax
    abb2:	01 d0                	add    %edx,%eax
    abb4:	01 c0                	add    %eax,%eax
    abb6:	8d 50 05             	lea    0x5(%eax),%edx
    abb9:	8b 45 18             	mov    0x18(%ebp),%eax
    abbc:	01 d0                	add    %edx,%eax
    abbe:	0f b6 00             	movzbl (%eax),%eax
    abc1:	0f b6 c0             	movzbl %al,%eax
    abc4:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    abc7:	8b 45 20             	mov    0x20(%ebp),%eax
    abca:	8b 40 1c             	mov    0x1c(%eax),%eax
    abcd:	39 c2                	cmp    %eax,%edx
    abcf:	75 0b                	jne    abdc <getPixelColorRGBA8+0x397>
    abd1:	8b 45 14             	mov    0x14(%ebp),%eax
    abd4:	c6 00 00             	movb   $0x0,(%eax)
    abd7:	e9 33 02 00 00       	jmp    ae0f <getPixelColorRGBA8+0x5ca>
      else *a = 255;
    abdc:	8b 45 14             	mov    0x14(%ebp),%eax
    abdf:	c6 00 ff             	movb   $0xff,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    abe2:	e9 28 02 00 00       	jmp    ae0f <getPixelColorRGBA8+0x5ca>
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  } else if(mode->colortype == LCT_PALETTE) {
    abe7:	8b 45 20             	mov    0x20(%ebp),%eax
    abea:	8b 00                	mov    (%eax),%eax
    abec:	83 f8 03             	cmp    $0x3,%eax
    abef:	0f 85 ac 00 00 00    	jne    aca1 <getPixelColorRGBA8+0x45c>
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    abf5:	8b 45 20             	mov    0x20(%ebp),%eax
    abf8:	8b 40 04             	mov    0x4(%eax),%eax
    abfb:	83 f8 08             	cmp    $0x8,%eax
    abfe:	75 13                	jne    ac13 <getPixelColorRGBA8+0x3ce>
    ac00:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ac03:	8b 45 18             	mov    0x18(%ebp),%eax
    ac06:	01 d0                	add    %edx,%eax
    ac08:	0f b6 00             	movzbl (%eax),%eax
    ac0b:	0f b6 c0             	movzbl %al,%eax
    ac0e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    ac11:	eb 28                	jmp    ac3b <getPixelColorRGBA8+0x3f6>
    else {
      size_t j = i * mode->bitdepth;
    ac13:	8b 45 20             	mov    0x20(%ebp),%eax
    ac16:	8b 50 04             	mov    0x4(%eax),%edx
    ac19:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ac1c:	0f af c2             	imul   %edx,%eax
    ac1f:	89 45 ec             	mov    %eax,-0x14(%ebp)
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    ac22:	8b 45 20             	mov    0x20(%ebp),%eax
    ac25:	8b 40 04             	mov    0x4(%eax),%eax
    ac28:	50                   	push   %eax
    ac29:	ff 75 18             	pushl  0x18(%ebp)
    ac2c:	8d 45 ec             	lea    -0x14(%ebp),%eax
    ac2f:	50                   	push   %eax
    ac30:	e8 55 d8 ff ff       	call   848a <readBitsFromReversedStream>
    ac35:	83 c4 0c             	add    $0xc,%esp
    ac38:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    ac3b:	8b 45 20             	mov    0x20(%ebp),%eax
    ac3e:	8b 40 08             	mov    0x8(%eax),%eax
    ac41:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ac44:	c1 e2 02             	shl    $0x2,%edx
    ac47:	01 d0                	add    %edx,%eax
    ac49:	0f b6 10             	movzbl (%eax),%edx
    ac4c:	8b 45 08             	mov    0x8(%ebp),%eax
    ac4f:	88 10                	mov    %dl,(%eax)
    *g = mode->palette[index * 4 + 1];
    ac51:	8b 45 20             	mov    0x20(%ebp),%eax
    ac54:	8b 40 08             	mov    0x8(%eax),%eax
    ac57:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ac5a:	c1 e2 02             	shl    $0x2,%edx
    ac5d:	83 c2 01             	add    $0x1,%edx
    ac60:	01 d0                	add    %edx,%eax
    ac62:	0f b6 10             	movzbl (%eax),%edx
    ac65:	8b 45 0c             	mov    0xc(%ebp),%eax
    ac68:	88 10                	mov    %dl,(%eax)
    *b = mode->palette[index * 4 + 2];
    ac6a:	8b 45 20             	mov    0x20(%ebp),%eax
    ac6d:	8b 40 08             	mov    0x8(%eax),%eax
    ac70:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ac73:	c1 e2 02             	shl    $0x2,%edx
    ac76:	83 c2 02             	add    $0x2,%edx
    ac79:	01 d0                	add    %edx,%eax
    ac7b:	0f b6 10             	movzbl (%eax),%edx
    ac7e:	8b 45 10             	mov    0x10(%ebp),%eax
    ac81:	88 10                	mov    %dl,(%eax)
    *a = mode->palette[index * 4 + 3];
    ac83:	8b 45 20             	mov    0x20(%ebp),%eax
    ac86:	8b 40 08             	mov    0x8(%eax),%eax
    ac89:	8b 55 fc             	mov    -0x4(%ebp),%edx
    ac8c:	c1 e2 02             	shl    $0x2,%edx
    ac8f:	83 c2 03             	add    $0x3,%edx
    ac92:	01 d0                	add    %edx,%eax
    ac94:	0f b6 10             	movzbl (%eax),%edx
    ac97:	8b 45 14             	mov    0x14(%ebp),%eax
    ac9a:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ac9c:	e9 6e 01 00 00       	jmp    ae0f <getPixelColorRGBA8+0x5ca>
    /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
    *r = mode->palette[index * 4 + 0];
    *g = mode->palette[index * 4 + 1];
    *b = mode->palette[index * 4 + 2];
    *a = mode->palette[index * 4 + 3];
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    aca1:	8b 45 20             	mov    0x20(%ebp),%eax
    aca4:	8b 00                	mov    (%eax),%eax
    aca6:	83 f8 04             	cmp    $0x4,%eax
    aca9:	0f 85 95 00 00 00    	jne    ad44 <getPixelColorRGBA8+0x4ff>
    if(mode->bitdepth == 8) {
    acaf:	8b 45 20             	mov    0x20(%ebp),%eax
    acb2:	8b 40 04             	mov    0x4(%eax),%eax
    acb5:	83 f8 08             	cmp    $0x8,%eax
    acb8:	75 44                	jne    acfe <getPixelColorRGBA8+0x4b9>
      *r = *g = *b = in[i * 2 + 0];
    acba:	8b 45 1c             	mov    0x1c(%ebp),%eax
    acbd:	01 c0                	add    %eax,%eax
    acbf:	89 c2                	mov    %eax,%edx
    acc1:	8b 45 18             	mov    0x18(%ebp),%eax
    acc4:	01 d0                	add    %edx,%eax
    acc6:	0f b6 10             	movzbl (%eax),%edx
    acc9:	8b 45 10             	mov    0x10(%ebp),%eax
    accc:	88 10                	mov    %dl,(%eax)
    acce:	8b 45 10             	mov    0x10(%ebp),%eax
    acd1:	0f b6 10             	movzbl (%eax),%edx
    acd4:	8b 45 0c             	mov    0xc(%ebp),%eax
    acd7:	88 10                	mov    %dl,(%eax)
    acd9:	8b 45 0c             	mov    0xc(%ebp),%eax
    acdc:	0f b6 10             	movzbl (%eax),%edx
    acdf:	8b 45 08             	mov    0x8(%ebp),%eax
    ace2:	88 10                	mov    %dl,(%eax)
      *a = in[i * 2 + 1];
    ace4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ace7:	01 c0                	add    %eax,%eax
    ace9:	8d 50 01             	lea    0x1(%eax),%edx
    acec:	8b 45 18             	mov    0x18(%ebp),%eax
    acef:	01 d0                	add    %edx,%eax
    acf1:	0f b6 10             	movzbl (%eax),%edx
    acf4:	8b 45 14             	mov    0x14(%ebp),%eax
    acf7:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    acf9:	e9 11 01 00 00       	jmp    ae0f <getPixelColorRGBA8+0x5ca>
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
    acfe:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ad01:	c1 e0 02             	shl    $0x2,%eax
    ad04:	89 c2                	mov    %eax,%edx
    ad06:	8b 45 18             	mov    0x18(%ebp),%eax
    ad09:	01 d0                	add    %edx,%eax
    ad0b:	0f b6 10             	movzbl (%eax),%edx
    ad0e:	8b 45 10             	mov    0x10(%ebp),%eax
    ad11:	88 10                	mov    %dl,(%eax)
    ad13:	8b 45 10             	mov    0x10(%ebp),%eax
    ad16:	0f b6 10             	movzbl (%eax),%edx
    ad19:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad1c:	88 10                	mov    %dl,(%eax)
    ad1e:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad21:	0f b6 10             	movzbl (%eax),%edx
    ad24:	8b 45 08             	mov    0x8(%ebp),%eax
    ad27:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 2];
    ad29:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ad2c:	c1 e0 02             	shl    $0x2,%eax
    ad2f:	8d 50 02             	lea    0x2(%eax),%edx
    ad32:	8b 45 18             	mov    0x18(%ebp),%eax
    ad35:	01 d0                	add    %edx,%eax
    ad37:	0f b6 10             	movzbl (%eax),%edx
    ad3a:	8b 45 14             	mov    0x14(%ebp),%eax
    ad3d:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    ad3f:	e9 cb 00 00 00       	jmp    ae0f <getPixelColorRGBA8+0x5ca>
      *a = in[i * 2 + 1];
    } else {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  } else if(mode->colortype == LCT_RGBA) {
    ad44:	8b 45 20             	mov    0x20(%ebp),%eax
    ad47:	8b 00                	mov    (%eax),%eax
    ad49:	83 f8 06             	cmp    $0x6,%eax
    ad4c:	0f 85 bd 00 00 00    	jne    ae0f <getPixelColorRGBA8+0x5ca>
    if(mode->bitdepth == 8) {
    ad52:	8b 45 20             	mov    0x20(%ebp),%eax
    ad55:	8b 40 04             	mov    0x4(%eax),%eax
    ad58:	83 f8 08             	cmp    $0x8,%eax
    ad5b:	75 59                	jne    adb6 <getPixelColorRGBA8+0x571>
      *r = in[i * 4 + 0];
    ad5d:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ad60:	c1 e0 02             	shl    $0x2,%eax
    ad63:	89 c2                	mov    %eax,%edx
    ad65:	8b 45 18             	mov    0x18(%ebp),%eax
    ad68:	01 d0                	add    %edx,%eax
    ad6a:	0f b6 10             	movzbl (%eax),%edx
    ad6d:	8b 45 08             	mov    0x8(%ebp),%eax
    ad70:	88 10                	mov    %dl,(%eax)
      *g = in[i * 4 + 1];
    ad72:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ad75:	c1 e0 02             	shl    $0x2,%eax
    ad78:	8d 50 01             	lea    0x1(%eax),%edx
    ad7b:	8b 45 18             	mov    0x18(%ebp),%eax
    ad7e:	01 d0                	add    %edx,%eax
    ad80:	0f b6 10             	movzbl (%eax),%edx
    ad83:	8b 45 0c             	mov    0xc(%ebp),%eax
    ad86:	88 10                	mov    %dl,(%eax)
      *b = in[i * 4 + 2];
    ad88:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ad8b:	c1 e0 02             	shl    $0x2,%eax
    ad8e:	8d 50 02             	lea    0x2(%eax),%edx
    ad91:	8b 45 18             	mov    0x18(%ebp),%eax
    ad94:	01 d0                	add    %edx,%eax
    ad96:	0f b6 10             	movzbl (%eax),%edx
    ad99:	8b 45 10             	mov    0x10(%ebp),%eax
    ad9c:	88 10                	mov    %dl,(%eax)
      *a = in[i * 4 + 3];
    ad9e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ada1:	c1 e0 02             	shl    $0x2,%eax
    ada4:	8d 50 03             	lea    0x3(%eax),%edx
    ada7:	8b 45 18             	mov    0x18(%ebp),%eax
    adaa:	01 d0                	add    %edx,%eax
    adac:	0f b6 10             	movzbl (%eax),%edx
    adaf:	8b 45 14             	mov    0x14(%ebp),%eax
    adb2:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }
}
    adb4:	eb 59                	jmp    ae0f <getPixelColorRGBA8+0x5ca>
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    } else {
      *r = in[i * 8 + 0];
    adb6:	8b 45 1c             	mov    0x1c(%ebp),%eax
    adb9:	c1 e0 03             	shl    $0x3,%eax
    adbc:	89 c2                	mov    %eax,%edx
    adbe:	8b 45 18             	mov    0x18(%ebp),%eax
    adc1:	01 d0                	add    %edx,%eax
    adc3:	0f b6 10             	movzbl (%eax),%edx
    adc6:	8b 45 08             	mov    0x8(%ebp),%eax
    adc9:	88 10                	mov    %dl,(%eax)
      *g = in[i * 8 + 2];
    adcb:	8b 45 1c             	mov    0x1c(%ebp),%eax
    adce:	c1 e0 03             	shl    $0x3,%eax
    add1:	8d 50 02             	lea    0x2(%eax),%edx
    add4:	8b 45 18             	mov    0x18(%ebp),%eax
    add7:	01 d0                	add    %edx,%eax
    add9:	0f b6 10             	movzbl (%eax),%edx
    addc:	8b 45 0c             	mov    0xc(%ebp),%eax
    addf:	88 10                	mov    %dl,(%eax)
      *b = in[i * 8 + 4];
    ade1:	8b 45 1c             	mov    0x1c(%ebp),%eax
    ade4:	c1 e0 03             	shl    $0x3,%eax
    ade7:	8d 50 04             	lea    0x4(%eax),%edx
    adea:	8b 45 18             	mov    0x18(%ebp),%eax
    aded:	01 d0                	add    %edx,%eax
    adef:	0f b6 10             	movzbl (%eax),%edx
    adf2:	8b 45 10             	mov    0x10(%ebp),%eax
    adf5:	88 10                	mov    %dl,(%eax)
      *a = in[i * 8 + 6];
    adf7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    adfa:	c1 e0 03             	shl    $0x3,%eax
    adfd:	8d 50 06             	lea    0x6(%eax),%edx
    ae00:	8b 45 18             	mov    0x18(%ebp),%eax
    ae03:	01 d0                	add    %edx,%eax
    ae05:	0f b6 10             	movzbl (%eax),%edx
    ae08:	8b 45 14             	mov    0x14(%ebp),%eax
    ae0b:	88 10                	mov    %dl,(%eax)
    }
  }
}
    ae0d:	eb 00                	jmp    ae0f <getPixelColorRGBA8+0x5ca>
    ae0f:	90                   	nop
    ae10:	c9                   	leave  
    ae11:	c3                   	ret    

0000ae12 <getPixelColorsRGBA8>:
mode test cases, optimized to convert the colors much faster, when converting
to the common case of RGBA with 8 bit per channel. buffer must be RGBA with
enough memory.*/
static void getPixelColorsRGBA8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                                const unsigned char* LODEPNG_RESTRICT in,
                                const LodePNGColorMode* mode) {
    ae12:	55                   	push   %ebp
    ae13:	89 e5                	mov    %esp,%ebp
    ae15:	53                   	push   %ebx
    ae16:	83 ec 20             	sub    $0x20,%esp
  unsigned num_channels = 4;
    ae19:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    ae20:	8b 45 14             	mov    0x14(%ebp),%eax
    ae23:	8b 00                	mov    (%eax),%eax
    ae25:	85 c0                	test   %eax,%eax
    ae27:	0f 85 14 02 00 00    	jne    b041 <getPixelColorsRGBA8+0x22f>
    if(mode->bitdepth == 8) {
    ae2d:	8b 45 14             	mov    0x14(%ebp),%eax
    ae30:	8b 40 04             	mov    0x4(%eax),%eax
    ae33:	83 f8 08             	cmp    $0x8,%eax
    ae36:	0f 85 a0 00 00 00    	jne    aedc <getPixelColorsRGBA8+0xca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae3c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    ae43:	eb 39                	jmp    ae7e <getPixelColorsRGBA8+0x6c>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    ae45:	8b 45 08             	mov    0x8(%ebp),%eax
    ae48:	83 c0 01             	add    $0x1,%eax
    ae4b:	8b 55 08             	mov    0x8(%ebp),%edx
    ae4e:	83 c2 02             	add    $0x2,%edx
    ae51:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    ae54:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ae57:	01 d9                	add    %ebx,%ecx
    ae59:	0f b6 09             	movzbl (%ecx),%ecx
    ae5c:	88 0a                	mov    %cl,(%edx)
    ae5e:	0f b6 12             	movzbl (%edx),%edx
    ae61:	88 10                	mov    %dl,(%eax)
    ae63:	0f b6 10             	movzbl (%eax),%edx
    ae66:	8b 45 08             	mov    0x8(%ebp),%eax
    ae69:	88 10                	mov    %dl,(%eax)
        buffer[3] = 255;
    ae6b:	8b 45 08             	mov    0x8(%ebp),%eax
    ae6e:	83 c0 03             	add    $0x3,%eax
    ae71:	c6 00 ff             	movb   $0xff,(%eax)
                                const LodePNGColorMode* mode) {
  unsigned num_channels = 4;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    ae74:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    ae78:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ae7b:	01 45 08             	add    %eax,0x8(%ebp)
    ae7e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    ae81:	3b 45 0c             	cmp    0xc(%ebp),%eax
    ae84:	75 bf                	jne    ae45 <getPixelColorsRGBA8+0x33>
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    ae86:	8b 45 14             	mov    0x14(%ebp),%eax
    ae89:	8b 40 10             	mov    0x10(%eax),%eax
    ae8c:	85 c0                	test   %eax,%eax
    ae8e:	0f 84 48 06 00 00    	je     b4dc <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    ae94:	8b 45 0c             	mov    0xc(%ebp),%eax
    ae97:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    ae9b:	f7 d8                	neg    %eax
    ae9d:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aea0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    aea7:	eb 26                	jmp    aecf <getPixelColorsRGBA8+0xbd>
          if(buffer[0] == mode->key_r) buffer[3] = 0;
    aea9:	8b 45 08             	mov    0x8(%ebp),%eax
    aeac:	0f b6 00             	movzbl (%eax),%eax
    aeaf:	0f b6 d0             	movzbl %al,%edx
    aeb2:	8b 45 14             	mov    0x14(%ebp),%eax
    aeb5:	8b 40 14             	mov    0x14(%eax),%eax
    aeb8:	39 c2                	cmp    %eax,%edx
    aeba:	75 09                	jne    aec5 <getPixelColorsRGBA8+0xb3>
    aebc:	8b 45 08             	mov    0x8(%ebp),%eax
    aebf:	83 c0 03             	add    $0x3,%eax
    aec2:	c6 00 00             	movb   $0x0,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i];
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aec5:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    aec9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    aecc:	01 45 08             	add    %eax,0x8(%ebp)
    aecf:	8b 45 f8             	mov    -0x8(%ebp),%eax
    aed2:	3b 45 0c             	cmp    0xc(%ebp),%eax
    aed5:	75 d2                	jne    aea9 <getPixelColorsRGBA8+0x97>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    aed7:	e9 00 06 00 00       	jmp    b4dc <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
    aedc:	8b 45 14             	mov    0x14(%ebp),%eax
    aedf:	8b 40 04             	mov    0x4(%eax),%eax
    aee2:	83 f8 10             	cmp    $0x10,%eax
    aee5:	0f 85 a5 00 00 00    	jne    af90 <getPixelColorsRGBA8+0x17e>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    aeeb:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    aef2:	e9 88 00 00 00       	jmp    af7f <getPixelColorsRGBA8+0x16d>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    aef7:	8b 45 08             	mov    0x8(%ebp),%eax
    aefa:	83 c0 01             	add    $0x1,%eax
    aefd:	8b 55 08             	mov    0x8(%ebp),%edx
    af00:	83 c2 02             	add    $0x2,%edx
    af03:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    af06:	01 c9                	add    %ecx,%ecx
    af08:	89 cb                	mov    %ecx,%ebx
    af0a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    af0d:	01 d9                	add    %ebx,%ecx
    af0f:	0f b6 09             	movzbl (%ecx),%ecx
    af12:	88 0a                	mov    %cl,(%edx)
    af14:	0f b6 12             	movzbl (%edx),%edx
    af17:	88 10                	mov    %dl,(%eax)
    af19:	0f b6 10             	movzbl (%eax),%edx
    af1c:	8b 45 08             	mov    0x8(%ebp),%eax
    af1f:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
    af21:	8b 45 08             	mov    0x8(%ebp),%eax
    af24:	8d 50 03             	lea    0x3(%eax),%edx
    af27:	8b 45 14             	mov    0x14(%ebp),%eax
    af2a:	8b 40 10             	mov    0x10(%eax),%eax
    af2d:	85 c0                	test   %eax,%eax
    af2f:	74 3d                	je     af6e <getPixelColorsRGBA8+0x15c>
    af31:	8b 45 f8             	mov    -0x8(%ebp),%eax
    af34:	01 c0                	add    %eax,%eax
    af36:	89 c1                	mov    %eax,%ecx
    af38:	8b 45 10             	mov    0x10(%ebp),%eax
    af3b:	01 c8                	add    %ecx,%eax
    af3d:	0f b6 00             	movzbl (%eax),%eax
    af40:	0f b6 c0             	movzbl %al,%eax
    af43:	c1 e0 08             	shl    $0x8,%eax
    af46:	89 c1                	mov    %eax,%ecx
    af48:	8b 45 f8             	mov    -0x8(%ebp),%eax
    af4b:	01 c0                	add    %eax,%eax
    af4d:	8d 58 01             	lea    0x1(%eax),%ebx
    af50:	8b 45 10             	mov    0x10(%ebp),%eax
    af53:	01 d8                	add    %ebx,%eax
    af55:	0f b6 00             	movzbl (%eax),%eax
    af58:	0f b6 c0             	movzbl %al,%eax
    af5b:	01 c1                	add    %eax,%ecx
    af5d:	8b 45 14             	mov    0x14(%ebp),%eax
    af60:	8b 40 14             	mov    0x14(%eax),%eax
    af63:	39 c1                	cmp    %eax,%ecx
    af65:	75 07                	jne    af6e <getPixelColorsRGBA8+0x15c>
    af67:	b8 00 00 00 00       	mov    $0x0,%eax
    af6c:	eb 05                	jmp    af73 <getPixelColorsRGBA8+0x161>
    af6e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    af73:	88 02                	mov    %al,(%edx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r) buffer[3] = 0;
        }
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    af75:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    af79:	8b 45 f4             	mov    -0xc(%ebp),%eax
    af7c:	01 45 08             	add    %eax,0x8(%ebp)
    af7f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    af82:	3b 45 0c             	cmp    0xc(%ebp),%eax
    af85:	0f 85 6c ff ff ff    	jne    aef7 <getPixelColorsRGBA8+0xe5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    af8b:	e9 4c 05 00 00       	jmp    b4dc <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    af90:	8b 45 14             	mov    0x14(%ebp),%eax
    af93:	8b 40 04             	mov    0x4(%eax),%eax
    af96:	ba 01 00 00 00       	mov    $0x1,%edx
    af9b:	89 c1                	mov    %eax,%ecx
    af9d:	d3 e2                	shl    %cl,%edx
    af9f:	89 d0                	mov    %edx,%eax
    afa1:	83 e8 01             	sub    $0x1,%eax
    afa4:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    afa7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    afae:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    afb5:	eb 79                	jmp    b030 <getPixelColorsRGBA8+0x21e>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    afb7:	8b 45 14             	mov    0x14(%ebp),%eax
    afba:	8b 40 04             	mov    0x4(%eax),%eax
    afbd:	50                   	push   %eax
    afbe:	ff 75 10             	pushl  0x10(%ebp)
    afc1:	8d 45 e0             	lea    -0x20(%ebp),%eax
    afc4:	50                   	push   %eax
    afc5:	e8 c0 d4 ff ff       	call   848a <readBitsFromReversedStream>
    afca:	83 c4 0c             	add    $0xc,%esp
    afcd:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    afd0:	8b 45 08             	mov    0x8(%ebp),%eax
    afd3:	8d 48 01             	lea    0x1(%eax),%ecx
    afd6:	8b 45 08             	mov    0x8(%ebp),%eax
    afd9:	8d 58 02             	lea    0x2(%eax),%ebx
    afdc:	8b 55 ec             	mov    -0x14(%ebp),%edx
    afdf:	89 d0                	mov    %edx,%eax
    afe1:	c1 e0 08             	shl    $0x8,%eax
    afe4:	29 d0                	sub    %edx,%eax
    afe6:	ba 00 00 00 00       	mov    $0x0,%edx
    afeb:	f7 75 f0             	divl   -0x10(%ebp)
    afee:	88 03                	mov    %al,(%ebx)
    aff0:	0f b6 03             	movzbl (%ebx),%eax
    aff3:	88 01                	mov    %al,(%ecx)
    aff5:	0f b6 11             	movzbl (%ecx),%edx
    aff8:	8b 45 08             	mov    0x8(%ebp),%eax
    affb:	88 10                	mov    %dl,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
    affd:	8b 45 08             	mov    0x8(%ebp),%eax
    b000:	8d 50 03             	lea    0x3(%eax),%edx
    b003:	8b 45 14             	mov    0x14(%ebp),%eax
    b006:	8b 40 10             	mov    0x10(%eax),%eax
    b009:	85 c0                	test   %eax,%eax
    b00b:	74 12                	je     b01f <getPixelColorsRGBA8+0x20d>
    b00d:	8b 45 14             	mov    0x14(%ebp),%eax
    b010:	8b 40 14             	mov    0x14(%eax),%eax
    b013:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    b016:	75 07                	jne    b01f <getPixelColorsRGBA8+0x20d>
    b018:	b8 00 00 00 00       	mov    $0x0,%eax
    b01d:	eb 05                	jmp    b024 <getPixelColorsRGBA8+0x212>
    b01f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b024:	88 02                	mov    %al,(%edx)
        buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b026:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b02a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b02d:	01 45 08             	add    %eax,0x8(%ebp)
    b030:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b033:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b036:	0f 85 7b ff ff ff    	jne    afb7 <getPixelColorsRGBA8+0x1a5>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b03c:	e9 9b 04 00 00       	jmp    b4dc <getPixelColorsRGBA8+0x6ca>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b041:	8b 45 14             	mov    0x14(%ebp),%eax
    b044:	8b 00                	mov    (%eax),%eax
    b046:	83 f8 02             	cmp    $0x2,%eax
    b049:	0f 85 41 02 00 00    	jne    b290 <getPixelColorsRGBA8+0x47e>
    if(mode->bitdepth == 8) {
    b04f:	8b 45 14             	mov    0x14(%ebp),%eax
    b052:	8b 40 04             	mov    0x4(%eax),%eax
    b055:	83 f8 08             	cmp    $0x8,%eax
    b058:	0f 85 c4 00 00 00    	jne    b122 <getPixelColorsRGBA8+0x310>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b05e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b065:	eb 31                	jmp    b098 <getPixelColorsRGBA8+0x286>
        lodepng_memcpy(buffer, &in[i * 3], 3);
    b067:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b06a:	89 d0                	mov    %edx,%eax
    b06c:	01 c0                	add    %eax,%eax
    b06e:	01 d0                	add    %edx,%eax
    b070:	89 c2                	mov    %eax,%edx
    b072:	8b 45 10             	mov    0x10(%ebp),%eax
    b075:	01 d0                	add    %edx,%eax
    b077:	6a 03                	push   $0x3
    b079:	50                   	push   %eax
    b07a:	ff 75 08             	pushl  0x8(%ebp)
    b07d:	e8 a3 85 ff ff       	call   3625 <lodepng_memcpy>
    b082:	83 c4 0c             	add    $0xc,%esp
        buffer[3] = 255;
    b085:	8b 45 08             	mov    0x8(%ebp),%eax
    b088:	83 c0 03             	add    $0x3,%eax
    b08b:	c6 00 ff             	movb   $0xff,(%eax)
        buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b08e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b092:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b095:	01 45 08             	add    %eax,0x8(%ebp)
    b098:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b09b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b09e:	75 c7                	jne    b067 <getPixelColorsRGBA8+0x255>
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
    b0a0:	8b 45 14             	mov    0x14(%ebp),%eax
    b0a3:	8b 40 10             	mov    0x10(%eax),%eax
    b0a6:	85 c0                	test   %eax,%eax
    b0a8:	0f 84 2e 04 00 00    	je     b4dc <getPixelColorsRGBA8+0x6ca>
        buffer -= numpixels * num_channels;
    b0ae:	8b 45 0c             	mov    0xc(%ebp),%eax
    b0b1:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    b0b5:	f7 d8                	neg    %eax
    b0b7:	01 45 08             	add    %eax,0x8(%ebp)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b0ba:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b0c1:	eb 52                	jmp    b115 <getPixelColorsRGBA8+0x303>
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
    b0c3:	8b 45 08             	mov    0x8(%ebp),%eax
    b0c6:	0f b6 00             	movzbl (%eax),%eax
    b0c9:	0f b6 d0             	movzbl %al,%edx
    b0cc:	8b 45 14             	mov    0x14(%ebp),%eax
    b0cf:	8b 40 14             	mov    0x14(%eax),%eax
    b0d2:	39 c2                	cmp    %eax,%edx
    b0d4:	75 35                	jne    b10b <getPixelColorsRGBA8+0x2f9>
    b0d6:	8b 45 08             	mov    0x8(%ebp),%eax
    b0d9:	83 c0 01             	add    $0x1,%eax
    b0dc:	0f b6 00             	movzbl (%eax),%eax
    b0df:	0f b6 d0             	movzbl %al,%edx
    b0e2:	8b 45 14             	mov    0x14(%ebp),%eax
    b0e5:	8b 40 18             	mov    0x18(%eax),%eax
    b0e8:	39 c2                	cmp    %eax,%edx
    b0ea:	75 1f                	jne    b10b <getPixelColorsRGBA8+0x2f9>
    b0ec:	8b 45 08             	mov    0x8(%ebp),%eax
    b0ef:	83 c0 02             	add    $0x2,%eax
    b0f2:	0f b6 00             	movzbl (%eax),%eax
    b0f5:	0f b6 d0             	movzbl %al,%edx
    b0f8:	8b 45 14             	mov    0x14(%ebp),%eax
    b0fb:	8b 40 1c             	mov    0x1c(%eax),%eax
    b0fe:	39 c2                	cmp    %eax,%edx
    b100:	75 09                	jne    b10b <getPixelColorsRGBA8+0x2f9>
    b102:	8b 45 08             	mov    0x8(%ebp),%eax
    b105:	83 c0 03             	add    $0x3,%eax
    b108:	c6 00 00             	movb   $0x0,(%eax)
        lodepng_memcpy(buffer, &in[i * 3], 3);
        buffer[3] = 255;
      }
      if(mode->key_defined) {
        buffer -= numpixels * num_channels;
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b10b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b10f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b112:	01 45 08             	add    %eax,0x8(%ebp)
    b115:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b118:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b11b:	75 a6                	jne    b0c3 <getPixelColorsRGBA8+0x2b1>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b11d:	e9 ba 03 00 00       	jmp    b4dc <getPixelColorsRGBA8+0x6ca>
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b122:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b129:	e9 51 01 00 00       	jmp    b27f <getPixelColorsRGBA8+0x46d>
        buffer[0] = in[i * 6 + 0];
    b12e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b131:	89 d0                	mov    %edx,%eax
    b133:	01 c0                	add    %eax,%eax
    b135:	01 d0                	add    %edx,%eax
    b137:	01 c0                	add    %eax,%eax
    b139:	89 c2                	mov    %eax,%edx
    b13b:	8b 45 10             	mov    0x10(%ebp),%eax
    b13e:	01 d0                	add    %edx,%eax
    b140:	0f b6 10             	movzbl (%eax),%edx
    b143:	8b 45 08             	mov    0x8(%ebp),%eax
    b146:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b148:	8b 45 08             	mov    0x8(%ebp),%eax
    b14b:	8d 48 01             	lea    0x1(%eax),%ecx
    b14e:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b151:	89 d0                	mov    %edx,%eax
    b153:	01 c0                	add    %eax,%eax
    b155:	01 d0                	add    %edx,%eax
    b157:	01 c0                	add    %eax,%eax
    b159:	8d 50 02             	lea    0x2(%eax),%edx
    b15c:	8b 45 10             	mov    0x10(%ebp),%eax
    b15f:	01 d0                	add    %edx,%eax
    b161:	0f b6 00             	movzbl (%eax),%eax
    b164:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b166:	8b 45 08             	mov    0x8(%ebp),%eax
    b169:	8d 48 02             	lea    0x2(%eax),%ecx
    b16c:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b16f:	89 d0                	mov    %edx,%eax
    b171:	01 c0                	add    %eax,%eax
    b173:	01 d0                	add    %edx,%eax
    b175:	01 c0                	add    %eax,%eax
    b177:	8d 50 04             	lea    0x4(%eax),%edx
    b17a:	8b 45 10             	mov    0x10(%ebp),%eax
    b17d:	01 d0                	add    %edx,%eax
    b17f:	0f b6 00             	movzbl (%eax),%eax
    b182:	88 01                	mov    %al,(%ecx)
        buffer[3] = mode->key_defined
    b184:	8b 45 08             	mov    0x8(%ebp),%eax
    b187:	8d 48 03             	lea    0x3(%eax),%ecx
    b18a:	8b 45 14             	mov    0x14(%ebp),%eax
    b18d:	8b 40 10             	mov    0x10(%eax),%eax
    b190:	85 c0                	test   %eax,%eax
    b192:	0f 84 d6 00 00 00    	je     b26e <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    b198:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b19b:	89 d0                	mov    %edx,%eax
    b19d:	01 c0                	add    %eax,%eax
    b19f:	01 d0                	add    %edx,%eax
    b1a1:	01 c0                	add    %eax,%eax
    b1a3:	89 c2                	mov    %eax,%edx
    b1a5:	8b 45 10             	mov    0x10(%ebp),%eax
    b1a8:	01 d0                	add    %edx,%eax
    b1aa:	0f b6 00             	movzbl (%eax),%eax
    b1ad:	0f b6 c0             	movzbl %al,%eax
    b1b0:	c1 e0 08             	shl    $0x8,%eax
    b1b3:	89 c3                	mov    %eax,%ebx
    b1b5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b1b8:	89 d0                	mov    %edx,%eax
    b1ba:	01 c0                	add    %eax,%eax
    b1bc:	01 d0                	add    %edx,%eax
    b1be:	01 c0                	add    %eax,%eax
    b1c0:	8d 50 01             	lea    0x1(%eax),%edx
    b1c3:	8b 45 10             	mov    0x10(%ebp),%eax
    b1c6:	01 d0                	add    %edx,%eax
    b1c8:	0f b6 00             	movzbl (%eax),%eax
    b1cb:	0f b6 c0             	movzbl %al,%eax
    b1ce:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b1d1:	8b 45 14             	mov    0x14(%ebp),%eax
    b1d4:	8b 40 14             	mov    0x14(%eax),%eax
    b1d7:	39 c2                	cmp    %eax,%edx
    b1d9:	0f 85 8f 00 00 00    	jne    b26e <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    b1df:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b1e2:	89 d0                	mov    %edx,%eax
    b1e4:	01 c0                	add    %eax,%eax
    b1e6:	01 d0                	add    %edx,%eax
    b1e8:	01 c0                	add    %eax,%eax
    b1ea:	8d 50 02             	lea    0x2(%eax),%edx
    b1ed:	8b 45 10             	mov    0x10(%ebp),%eax
    b1f0:	01 d0                	add    %edx,%eax
    b1f2:	0f b6 00             	movzbl (%eax),%eax
    b1f5:	0f b6 c0             	movzbl %al,%eax
    b1f8:	c1 e0 08             	shl    $0x8,%eax
    b1fb:	89 c3                	mov    %eax,%ebx
    b1fd:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b200:	89 d0                	mov    %edx,%eax
    b202:	01 c0                	add    %eax,%eax
    b204:	01 d0                	add    %edx,%eax
    b206:	01 c0                	add    %eax,%eax
    b208:	8d 50 03             	lea    0x3(%eax),%edx
    b20b:	8b 45 10             	mov    0x10(%ebp),%eax
    b20e:	01 d0                	add    %edx,%eax
    b210:	0f b6 00             	movzbl (%eax),%eax
    b213:	0f b6 c0             	movzbl %al,%eax
    b216:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b219:	8b 45 14             	mov    0x14(%ebp),%eax
    b21c:	8b 40 18             	mov    0x18(%eax),%eax
    b21f:	39 c2                	cmp    %eax,%edx
    b221:	75 4b                	jne    b26e <getPixelColorsRGBA8+0x45c>
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
    b223:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b226:	89 d0                	mov    %edx,%eax
    b228:	01 c0                	add    %eax,%eax
    b22a:	01 d0                	add    %edx,%eax
    b22c:	01 c0                	add    %eax,%eax
    b22e:	8d 50 04             	lea    0x4(%eax),%edx
    b231:	8b 45 10             	mov    0x10(%ebp),%eax
    b234:	01 d0                	add    %edx,%eax
    b236:	0f b6 00             	movzbl (%eax),%eax
    b239:	0f b6 c0             	movzbl %al,%eax
    b23c:	c1 e0 08             	shl    $0x8,%eax
    b23f:	89 c3                	mov    %eax,%ebx
    b241:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b244:	89 d0                	mov    %edx,%eax
    b246:	01 c0                	add    %eax,%eax
    b248:	01 d0                	add    %edx,%eax
    b24a:	01 c0                	add    %eax,%eax
    b24c:	8d 50 05             	lea    0x5(%eax),%edx
    b24f:	8b 45 10             	mov    0x10(%ebp),%eax
    b252:	01 d0                	add    %edx,%eax
    b254:	0f b6 00             	movzbl (%eax),%eax
    b257:	0f b6 c0             	movzbl %al,%eax
    b25a:	8d 14 03             	lea    (%ebx,%eax,1),%edx
    b25d:	8b 45 14             	mov    0x14(%ebp),%eax
    b260:	8b 40 1c             	mov    0x1c(%eax),%eax
    b263:	39 c2                	cmp    %eax,%edx
    b265:	75 07                	jne    b26e <getPixelColorsRGBA8+0x45c>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        buffer[3] = mode->key_defined
    b267:	b8 00 00 00 00       	mov    $0x0,%eax
    b26c:	eb 05                	jmp    b273 <getPixelColorsRGBA8+0x461>
    b26e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    b273:	88 01                	mov    %al,(%ecx)
        for(i = 0; i != numpixels; ++i, buffer += num_channels) {
          if(buffer[0] == mode->key_r && buffer[1]== mode->key_g && buffer[2] == mode->key_b) buffer[3] = 0;
        }
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b275:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b279:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b27c:	01 45 08             	add    %eax,0x8(%ebp)
    b27f:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b282:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b285:	0f 85 a3 fe ff ff    	jne    b12e <getPixelColorsRGBA8+0x31c>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b28b:	e9 4c 02 00 00       	jmp    b4dc <getPixelColorsRGBA8+0x6ca>
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b290:	8b 45 14             	mov    0x14(%ebp),%eax
    b293:	8b 00                	mov    (%eax),%eax
    b295:	83 f8 03             	cmp    $0x3,%eax
    b298:	0f 85 b4 00 00 00    	jne    b352 <getPixelColorsRGBA8+0x540>
    if(mode->bitdepth == 8) {
    b29e:	8b 45 14             	mov    0x14(%ebp),%eax
    b2a1:	8b 40 04             	mov    0x4(%eax),%eax
    b2a4:	83 f8 08             	cmp    $0x8,%eax
    b2a7:	75 4d                	jne    b2f6 <getPixelColorsRGBA8+0x4e4>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2a9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b2b0:	eb 37                	jmp    b2e9 <getPixelColorsRGBA8+0x4d7>
        unsigned index = in[i];
    b2b2:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b2b5:	8b 45 10             	mov    0x10(%ebp),%eax
    b2b8:	01 d0                	add    %edx,%eax
    b2ba:	0f b6 00             	movzbl (%eax),%eax
    b2bd:	0f b6 c0             	movzbl %al,%eax
    b2c0:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b2c3:	8b 45 14             	mov    0x14(%ebp),%eax
    b2c6:	8b 40 08             	mov    0x8(%eax),%eax
    b2c9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b2cc:	c1 e2 02             	shl    $0x2,%edx
    b2cf:	01 d0                	add    %edx,%eax
    b2d1:	6a 04                	push   $0x4
    b2d3:	50                   	push   %eax
    b2d4:	ff 75 08             	pushl  0x8(%ebp)
    b2d7:	e8 49 83 ff ff       	call   3625 <lodepng_memcpy>
    b2dc:	83 c4 0c             	add    $0xc,%esp
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2df:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b2e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b2e6:	01 45 08             	add    %eax,0x8(%ebp)
    b2e9:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b2ec:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b2ef:	75 c1                	jne    b2b2 <getPixelColorsRGBA8+0x4a0>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b2f1:	e9 e6 01 00 00       	jmp    b4dc <getPixelColorsRGBA8+0x6ca>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
    b2f6:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b2fd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b304:	eb 3f                	jmp    b345 <getPixelColorsRGBA8+0x533>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b306:	8b 45 14             	mov    0x14(%ebp),%eax
    b309:	8b 40 04             	mov    0x4(%eax),%eax
    b30c:	50                   	push   %eax
    b30d:	ff 75 10             	pushl  0x10(%ebp)
    b310:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b313:	50                   	push   %eax
    b314:	e8 71 d1 ff ff       	call   848a <readBitsFromReversedStream>
    b319:	83 c4 0c             	add    $0xc,%esp
    b31c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
    b31f:	8b 45 14             	mov    0x14(%ebp),%eax
    b322:	8b 40 08             	mov    0x8(%eax),%eax
    b325:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b328:	c1 e2 02             	shl    $0x2,%edx
    b32b:	01 d0                	add    %edx,%eax
    b32d:	6a 04                	push   $0x4
    b32f:	50                   	push   %eax
    b330:	ff 75 08             	pushl  0x8(%ebp)
    b333:	e8 ed 82 ff ff       	call   3625 <lodepng_memcpy>
    b338:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b33b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b33f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b342:	01 45 08             	add    %eax,0x8(%ebp)
    b345:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b348:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b34b:	75 b9                	jne    b306 <getPixelColorsRGBA8+0x4f4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b34d:	e9 8a 01 00 00       	jmp    b4dc <getPixelColorsRGBA8+0x6ca>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b352:	8b 45 14             	mov    0x14(%ebp),%eax
    b355:	8b 00                	mov    (%eax),%eax
    b357:	83 f8 04             	cmp    $0x4,%eax
    b35a:	0f 85 d1 00 00 00    	jne    b431 <getPixelColorsRGBA8+0x61f>
    if(mode->bitdepth == 8) {
    b360:	8b 45 14             	mov    0x14(%ebp),%eax
    b363:	8b 40 04             	mov    0x4(%eax),%eax
    b366:	83 f8 08             	cmp    $0x8,%eax
    b369:	75 62                	jne    b3cd <getPixelColorsRGBA8+0x5bb>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b36b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b372:	eb 4c                	jmp    b3c0 <getPixelColorsRGBA8+0x5ae>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b374:	8b 45 08             	mov    0x8(%ebp),%eax
    b377:	83 c0 01             	add    $0x1,%eax
    b37a:	8b 55 08             	mov    0x8(%ebp),%edx
    b37d:	83 c2 02             	add    $0x2,%edx
    b380:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b383:	01 c9                	add    %ecx,%ecx
    b385:	89 cb                	mov    %ecx,%ebx
    b387:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b38a:	01 d9                	add    %ebx,%ecx
    b38c:	0f b6 09             	movzbl (%ecx),%ecx
    b38f:	88 0a                	mov    %cl,(%edx)
    b391:	0f b6 12             	movzbl (%edx),%edx
    b394:	88 10                	mov    %dl,(%eax)
    b396:	0f b6 10             	movzbl (%eax),%edx
    b399:	8b 45 08             	mov    0x8(%ebp),%eax
    b39c:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 2 + 1];
    b39e:	8b 45 08             	mov    0x8(%ebp),%eax
    b3a1:	8d 50 03             	lea    0x3(%eax),%edx
    b3a4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b3a7:	01 c0                	add    %eax,%eax
    b3a9:	8d 48 01             	lea    0x1(%eax),%ecx
    b3ac:	8b 45 10             	mov    0x10(%ebp),%eax
    b3af:	01 c8                	add    %ecx,%eax
    b3b1:	0f b6 00             	movzbl (%eax),%eax
    b3b4:	88 02                	mov    %al,(%edx)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 4);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3b6:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b3ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b3bd:	01 45 08             	add    %eax,0x8(%ebp)
    b3c0:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b3c3:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b3c6:	75 ac                	jne    b374 <getPixelColorsRGBA8+0x562>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b3c8:	e9 0f 01 00 00       	jmp    b4dc <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b3cd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b3d4:	eb 4e                	jmp    b424 <getPixelColorsRGBA8+0x612>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b3d6:	8b 45 08             	mov    0x8(%ebp),%eax
    b3d9:	83 c0 01             	add    $0x1,%eax
    b3dc:	8b 55 08             	mov    0x8(%ebp),%edx
    b3df:	83 c2 02             	add    $0x2,%edx
    b3e2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b3e5:	c1 e1 02             	shl    $0x2,%ecx
    b3e8:	89 cb                	mov    %ecx,%ebx
    b3ea:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b3ed:	01 d9                	add    %ebx,%ecx
    b3ef:	0f b6 09             	movzbl (%ecx),%ecx
    b3f2:	88 0a                	mov    %cl,(%edx)
    b3f4:	0f b6 12             	movzbl (%edx),%edx
    b3f7:	88 10                	mov    %dl,(%eax)
    b3f9:	0f b6 10             	movzbl (%eax),%edx
    b3fc:	8b 45 08             	mov    0x8(%ebp),%eax
    b3ff:	88 10                	mov    %dl,(%eax)
        buffer[3] = in[i * 4 + 2];
    b401:	8b 45 08             	mov    0x8(%ebp),%eax
    b404:	8d 50 03             	lea    0x3(%eax),%edx
    b407:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b40a:	c1 e0 02             	shl    $0x2,%eax
    b40d:	8d 48 02             	lea    0x2(%eax),%ecx
    b410:	8b 45 10             	mov    0x10(%ebp),%eax
    b413:	01 c8                	add    %ecx,%eax
    b415:	0f b6 00             	movzbl (%eax),%eax
    b418:	88 02                	mov    %al,(%edx)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        buffer[3] = in[i * 2 + 1];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b41a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b41e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b421:	01 45 08             	add    %eax,0x8(%ebp)
    b424:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b427:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b42a:	75 aa                	jne    b3d6 <getPixelColorsRGBA8+0x5c4>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b42c:	e9 ab 00 00 00       	jmp    b4dc <getPixelColorsRGBA8+0x6ca>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        buffer[3] = in[i * 4 + 2];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b431:	8b 45 14             	mov    0x14(%ebp),%eax
    b434:	8b 00                	mov    (%eax),%eax
    b436:	83 f8 06             	cmp    $0x6,%eax
    b439:	0f 85 9d 00 00 00    	jne    b4dc <getPixelColorsRGBA8+0x6ca>
    if(mode->bitdepth == 8) {
    b43f:	8b 45 14             	mov    0x14(%ebp),%eax
    b442:	8b 40 04             	mov    0x4(%eax),%eax
    b445:	83 f8 08             	cmp    $0x8,%eax
    b448:	75 17                	jne    b461 <getPixelColorsRGBA8+0x64f>
      lodepng_memcpy(buffer, in, numpixels * 4);
    b44a:	8b 45 0c             	mov    0xc(%ebp),%eax
    b44d:	c1 e0 02             	shl    $0x2,%eax
    b450:	50                   	push   %eax
    b451:	ff 75 10             	pushl  0x10(%ebp)
    b454:	ff 75 08             	pushl  0x8(%ebp)
    b457:	e8 c9 81 ff ff       	call   3625 <lodepng_memcpy>
    b45c:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b45f:	eb 7b                	jmp    b4dc <getPixelColorsRGBA8+0x6ca>
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b461:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b468:	eb 6a                	jmp    b4d4 <getPixelColorsRGBA8+0x6c2>
        buffer[0] = in[i * 8 + 0];
    b46a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b46d:	c1 e0 03             	shl    $0x3,%eax
    b470:	89 c2                	mov    %eax,%edx
    b472:	8b 45 10             	mov    0x10(%ebp),%eax
    b475:	01 d0                	add    %edx,%eax
    b477:	0f b6 10             	movzbl (%eax),%edx
    b47a:	8b 45 08             	mov    0x8(%ebp),%eax
    b47d:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b47f:	8b 45 08             	mov    0x8(%ebp),%eax
    b482:	8d 50 01             	lea    0x1(%eax),%edx
    b485:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b488:	c1 e0 03             	shl    $0x3,%eax
    b48b:	8d 48 02             	lea    0x2(%eax),%ecx
    b48e:	8b 45 10             	mov    0x10(%ebp),%eax
    b491:	01 c8                	add    %ecx,%eax
    b493:	0f b6 00             	movzbl (%eax),%eax
    b496:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b498:	8b 45 08             	mov    0x8(%ebp),%eax
    b49b:	8d 50 02             	lea    0x2(%eax),%edx
    b49e:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4a1:	c1 e0 03             	shl    $0x3,%eax
    b4a4:	8d 48 04             	lea    0x4(%eax),%ecx
    b4a7:	8b 45 10             	mov    0x10(%ebp),%eax
    b4aa:	01 c8                	add    %ecx,%eax
    b4ac:	0f b6 00             	movzbl (%eax),%eax
    b4af:	88 02                	mov    %al,(%edx)
        buffer[3] = in[i * 8 + 6];
    b4b1:	8b 45 08             	mov    0x8(%ebp),%eax
    b4b4:	8d 50 03             	lea    0x3(%eax),%edx
    b4b7:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4ba:	c1 e0 03             	shl    $0x3,%eax
    b4bd:	8d 48 06             	lea    0x6(%eax),%ecx
    b4c0:	8b 45 10             	mov    0x10(%ebp),%eax
    b4c3:	01 c8                	add    %ecx,%eax
    b4c5:	0f b6 00             	movzbl (%eax),%eax
    b4c8:	88 02                	mov    %al,(%edx)
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 4);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b4ca:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b4ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b4d1:	01 45 08             	add    %eax,0x8(%ebp)
    b4d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b4d7:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b4da:	75 8e                	jne    b46a <getPixelColorsRGBA8+0x658>
        buffer[2] = in[i * 8 + 4];
        buffer[3] = in[i * 8 + 6];
      }
    }
  }
}
    b4dc:	90                   	nop
    b4dd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b4e0:	c9                   	leave  
    b4e1:	c3                   	ret    

0000b4e2 <getPixelColorsRGB8>:

/*Similar to getPixelColorsRGBA8, but with 3-channel RGB output.*/
static void getPixelColorsRGB8(unsigned char* LODEPNG_RESTRICT buffer, size_t numpixels,
                               const unsigned char* LODEPNG_RESTRICT in,
                               const LodePNGColorMode* mode) {
    b4e2:	55                   	push   %ebp
    b4e3:	89 e5                	mov    %esp,%ebp
    b4e5:	53                   	push   %ebx
    b4e6:	83 ec 20             	sub    $0x20,%esp
  const unsigned num_channels = 3;
    b4e9:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
  size_t i;
  if(mode->colortype == LCT_GREY) {
    b4f0:	8b 45 14             	mov    0x14(%ebp),%eax
    b4f3:	8b 00                	mov    (%eax),%eax
    b4f5:	85 c0                	test   %eax,%eax
    b4f7:	0f 85 2a 01 00 00    	jne    b627 <getPixelColorsRGB8+0x145>
    if(mode->bitdepth == 8) {
    b4fd:	8b 45 14             	mov    0x14(%ebp),%eax
    b500:	8b 40 04             	mov    0x4(%eax),%eax
    b503:	83 f8 08             	cmp    $0x8,%eax
    b506:	75 46                	jne    b54e <getPixelColorsRGB8+0x6c>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b508:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b50f:	eb 30                	jmp    b541 <getPixelColorsRGB8+0x5f>
        buffer[0] = buffer[1] = buffer[2] = in[i];
    b511:	8b 45 08             	mov    0x8(%ebp),%eax
    b514:	83 c0 01             	add    $0x1,%eax
    b517:	8b 55 08             	mov    0x8(%ebp),%edx
    b51a:	83 c2 02             	add    $0x2,%edx
    b51d:	8b 5d f8             	mov    -0x8(%ebp),%ebx
    b520:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b523:	01 d9                	add    %ebx,%ecx
    b525:	0f b6 09             	movzbl (%ecx),%ecx
    b528:	88 0a                	mov    %cl,(%edx)
    b52a:	0f b6 12             	movzbl (%edx),%edx
    b52d:	88 10                	mov    %dl,(%eax)
    b52f:	0f b6 10             	movzbl (%eax),%edx
    b532:	8b 45 08             	mov    0x8(%ebp),%eax
    b535:	88 10                	mov    %dl,(%eax)
                               const LodePNGColorMode* mode) {
  const unsigned num_channels = 3;
  size_t i;
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b537:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b53b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b53e:	01 45 08             	add    %eax,0x8(%ebp)
    b541:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b544:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b547:	75 c8                	jne    b511 <getPixelColorsRGB8+0x2f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b549:	e9 a8 03 00 00       	jmp    b8f6 <getPixelColorsRGB8+0x414>
  if(mode->colortype == LCT_GREY) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
    b54e:	8b 45 14             	mov    0x14(%ebp),%eax
    b551:	8b 40 04             	mov    0x4(%eax),%eax
    b554:	83 f8 10             	cmp    $0x10,%eax
    b557:	75 4a                	jne    b5a3 <getPixelColorsRGB8+0xc1>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b559:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b560:	eb 34                	jmp    b596 <getPixelColorsRGB8+0xb4>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
    b562:	8b 45 08             	mov    0x8(%ebp),%eax
    b565:	83 c0 01             	add    $0x1,%eax
    b568:	8b 55 08             	mov    0x8(%ebp),%edx
    b56b:	83 c2 02             	add    $0x2,%edx
    b56e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b571:	01 c9                	add    %ecx,%ecx
    b573:	89 cb                	mov    %ecx,%ebx
    b575:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b578:	01 d9                	add    %ebx,%ecx
    b57a:	0f b6 09             	movzbl (%ecx),%ecx
    b57d:	88 0a                	mov    %cl,(%edx)
    b57f:	0f b6 12             	movzbl (%edx),%edx
    b582:	88 10                	mov    %dl,(%eax)
    b584:	0f b6 10             	movzbl (%eax),%edx
    b587:	8b 45 08             	mov    0x8(%ebp),%eax
    b58a:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i];
      }
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b58c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b590:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b593:	01 45 08             	add    %eax,0x8(%ebp)
    b596:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b599:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b59c:	75 c4                	jne    b562 <getPixelColorsRGB8+0x80>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b59e:	e9 53 03 00 00       	jmp    b8f6 <getPixelColorsRGB8+0x414>
    } else if(mode->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
    b5a3:	8b 45 14             	mov    0x14(%ebp),%eax
    b5a6:	8b 40 04             	mov    0x4(%eax),%eax
    b5a9:	ba 01 00 00 00       	mov    $0x1,%edx
    b5ae:	89 c1                	mov    %eax,%ecx
    b5b0:	d3 e2                	shl    %cl,%edx
    b5b2:	89 d0                	mov    %edx,%eax
    b5b4:	83 e8 01             	sub    $0x1,%eax
    b5b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t j = 0;
    b5ba:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b5c1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b5c8:	eb 50                	jmp    b61a <getPixelColorsRGB8+0x138>
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b5ca:	8b 45 14             	mov    0x14(%ebp),%eax
    b5cd:	8b 40 04             	mov    0x4(%eax),%eax
    b5d0:	50                   	push   %eax
    b5d1:	ff 75 10             	pushl  0x10(%ebp)
    b5d4:	8d 45 e0             	lea    -0x20(%ebp),%eax
    b5d7:	50                   	push   %eax
    b5d8:	e8 ad ce ff ff       	call   848a <readBitsFromReversedStream>
    b5dd:	83 c4 0c             	add    $0xc,%esp
    b5e0:	89 45 ec             	mov    %eax,-0x14(%ebp)
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
    b5e3:	8b 45 08             	mov    0x8(%ebp),%eax
    b5e6:	8d 48 01             	lea    0x1(%eax),%ecx
    b5e9:	8b 45 08             	mov    0x8(%ebp),%eax
    b5ec:	8d 58 02             	lea    0x2(%eax),%ebx
    b5ef:	8b 55 ec             	mov    -0x14(%ebp),%edx
    b5f2:	89 d0                	mov    %edx,%eax
    b5f4:	c1 e0 08             	shl    $0x8,%eax
    b5f7:	29 d0                	sub    %edx,%eax
    b5f9:	ba 00 00 00 00       	mov    $0x0,%edx
    b5fe:	f7 75 f0             	divl   -0x10(%ebp)
    b601:	88 03                	mov    %al,(%ebx)
    b603:	0f b6 03             	movzbl (%ebx),%eax
    b606:	88 01                	mov    %al,(%ecx)
    b608:	0f b6 11             	movzbl (%ecx),%edx
    b60b:	8b 45 08             	mov    0x8(%ebp),%eax
    b60e:	88 10                	mov    %dl,(%eax)
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
      }
    } else {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b610:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b614:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b617:	01 45 08             	add    %eax,0x8(%ebp)
    b61a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b61d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b620:	75 a8                	jne    b5ca <getPixelColorsRGB8+0xe8>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b622:	e9 cf 02 00 00       	jmp    b8f6 <getPixelColorsRGB8+0x414>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
      }
    }
  } else if(mode->colortype == LCT_RGB) {
    b627:	8b 45 14             	mov    0x14(%ebp),%eax
    b62a:	8b 00                	mov    (%eax),%eax
    b62c:	83 f8 02             	cmp    $0x2,%eax
    b62f:	0f 85 9e 00 00 00    	jne    b6d3 <getPixelColorsRGB8+0x1f1>
    if(mode->bitdepth == 8) {
    b635:	8b 45 14             	mov    0x14(%ebp),%eax
    b638:	8b 40 04             	mov    0x4(%eax),%eax
    b63b:	83 f8 08             	cmp    $0x8,%eax
    b63e:	75 1d                	jne    b65d <getPixelColorsRGB8+0x17b>
      lodepng_memcpy(buffer, in, numpixels * 3);
    b640:	8b 55 0c             	mov    0xc(%ebp),%edx
    b643:	89 d0                	mov    %edx,%eax
    b645:	01 c0                	add    %eax,%eax
    b647:	01 d0                	add    %edx,%eax
    b649:	50                   	push   %eax
    b64a:	ff 75 10             	pushl  0x10(%ebp)
    b64d:	ff 75 08             	pushl  0x8(%ebp)
    b650:	e8 d0 7f ff ff       	call   3625 <lodepng_memcpy>
    b655:	83 c4 0c             	add    $0xc,%esp
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b658:	e9 99 02 00 00       	jmp    b8f6 <getPixelColorsRGB8+0x414>
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b65d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b664:	eb 60                	jmp    b6c6 <getPixelColorsRGB8+0x1e4>
        buffer[0] = in[i * 6 + 0];
    b666:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b669:	89 d0                	mov    %edx,%eax
    b66b:	01 c0                	add    %eax,%eax
    b66d:	01 d0                	add    %edx,%eax
    b66f:	01 c0                	add    %eax,%eax
    b671:	89 c2                	mov    %eax,%edx
    b673:	8b 45 10             	mov    0x10(%ebp),%eax
    b676:	01 d0                	add    %edx,%eax
    b678:	0f b6 10             	movzbl (%eax),%edx
    b67b:	8b 45 08             	mov    0x8(%ebp),%eax
    b67e:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 6 + 2];
    b680:	8b 45 08             	mov    0x8(%ebp),%eax
    b683:	8d 48 01             	lea    0x1(%eax),%ecx
    b686:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b689:	89 d0                	mov    %edx,%eax
    b68b:	01 c0                	add    %eax,%eax
    b68d:	01 d0                	add    %edx,%eax
    b68f:	01 c0                	add    %eax,%eax
    b691:	8d 50 02             	lea    0x2(%eax),%edx
    b694:	8b 45 10             	mov    0x10(%ebp),%eax
    b697:	01 d0                	add    %edx,%eax
    b699:	0f b6 00             	movzbl (%eax),%eax
    b69c:	88 01                	mov    %al,(%ecx)
        buffer[2] = in[i * 6 + 4];
    b69e:	8b 45 08             	mov    0x8(%ebp),%eax
    b6a1:	8d 48 02             	lea    0x2(%eax),%ecx
    b6a4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b6a7:	89 d0                	mov    %edx,%eax
    b6a9:	01 c0                	add    %eax,%eax
    b6ab:	01 d0                	add    %edx,%eax
    b6ad:	01 c0                	add    %eax,%eax
    b6af:	8d 50 04             	lea    0x4(%eax),%edx
    b6b2:	8b 45 10             	mov    0x10(%ebp),%eax
    b6b5:	01 d0                	add    %edx,%eax
    b6b7:	0f b6 00             	movzbl (%eax),%eax
    b6ba:	88 01                	mov    %al,(%ecx)
    }
  } else if(mode->colortype == LCT_RGB) {
    if(mode->bitdepth == 8) {
      lodepng_memcpy(buffer, in, numpixels * 3);
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b6bc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b6c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b6c3:	01 45 08             	add    %eax,0x8(%ebp)
    b6c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b6c9:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b6cc:	75 98                	jne    b666 <getPixelColorsRGB8+0x184>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b6ce:	e9 23 02 00 00       	jmp    b8f6 <getPixelColorsRGB8+0x414>
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    b6d3:	8b 45 14             	mov    0x14(%ebp),%eax
    b6d6:	8b 00                	mov    (%eax),%eax
    b6d8:	83 f8 03             	cmp    $0x3,%eax
    b6db:	0f 85 b4 00 00 00    	jne    b795 <getPixelColorsRGB8+0x2b3>
    if(mode->bitdepth == 8) {
    b6e1:	8b 45 14             	mov    0x14(%ebp),%eax
    b6e4:	8b 40 04             	mov    0x4(%eax),%eax
    b6e7:	83 f8 08             	cmp    $0x8,%eax
    b6ea:	75 4d                	jne    b739 <getPixelColorsRGB8+0x257>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b6ec:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b6f3:	eb 37                	jmp    b72c <getPixelColorsRGB8+0x24a>
        unsigned index = in[i];
    b6f5:	8b 55 f8             	mov    -0x8(%ebp),%edx
    b6f8:	8b 45 10             	mov    0x10(%ebp),%eax
    b6fb:	01 d0                	add    %edx,%eax
    b6fd:	0f b6 00             	movzbl (%eax),%eax
    b700:	0f b6 c0             	movzbl %al,%eax
    b703:	89 45 e8             	mov    %eax,-0x18(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b706:	8b 45 14             	mov    0x14(%ebp),%eax
    b709:	8b 40 08             	mov    0x8(%eax),%eax
    b70c:	8b 55 e8             	mov    -0x18(%ebp),%edx
    b70f:	c1 e2 02             	shl    $0x2,%edx
    b712:	01 d0                	add    %edx,%eax
    b714:	6a 03                	push   $0x3
    b716:	50                   	push   %eax
    b717:	ff 75 08             	pushl  0x8(%ebp)
    b71a:	e8 06 7f ff ff       	call   3625 <lodepng_memcpy>
    b71f:	83 c4 0c             	add    $0xc,%esp
        buffer[2] = in[i * 6 + 4];
      }
    }
  } else if(mode->colortype == LCT_PALETTE) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b722:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b726:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b729:	01 45 08             	add    %eax,0x8(%ebp)
    b72c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b72f:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b732:	75 c1                	jne    b6f5 <getPixelColorsRGB8+0x213>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b734:	e9 bd 01 00 00       	jmp    b8f6 <getPixelColorsRGB8+0x414>
        unsigned index = in[i];
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
    b739:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b740:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b747:	eb 3f                	jmp    b788 <getPixelColorsRGB8+0x2a6>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    b749:	8b 45 14             	mov    0x14(%ebp),%eax
    b74c:	8b 40 04             	mov    0x4(%eax),%eax
    b74f:	50                   	push   %eax
    b750:	ff 75 10             	pushl  0x10(%ebp)
    b753:	8d 45 dc             	lea    -0x24(%ebp),%eax
    b756:	50                   	push   %eax
    b757:	e8 2e cd ff ff       	call   848a <readBitsFromReversedStream>
    b75c:	83 c4 0c             	add    $0xc,%esp
    b75f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
    b762:	8b 45 14             	mov    0x14(%ebp),%eax
    b765:	8b 40 08             	mov    0x8(%eax),%eax
    b768:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    b76b:	c1 e2 02             	shl    $0x2,%edx
    b76e:	01 d0                	add    %edx,%eax
    b770:	6a 03                	push   $0x3
    b772:	50                   	push   %eax
    b773:	ff 75 08             	pushl  0x8(%ebp)
    b776:	e8 aa 7e ff ff       	call   3625 <lodepng_memcpy>
    b77b:	83 c4 0c             	add    $0xc,%esp
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    } else {
      size_t j = 0;
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b77e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b782:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b785:	01 45 08             	add    %eax,0x8(%ebp)
    b788:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b78b:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b78e:	75 b9                	jne    b749 <getPixelColorsRGB8+0x267>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b790:	e9 61 01 00 00       	jmp    b8f6 <getPixelColorsRGB8+0x414>
        unsigned index = readBitsFromReversedStream(&j, in, mode->bitdepth);
        /*out of bounds of palette not checked: see lodepng_color_mode_alloc_palette.*/
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    b795:	8b 45 14             	mov    0x14(%ebp),%eax
    b798:	8b 00                	mov    (%eax),%eax
    b79a:	83 f8 04             	cmp    $0x4,%eax
    b79d:	0f 85 a0 00 00 00    	jne    b843 <getPixelColorsRGB8+0x361>
    if(mode->bitdepth == 8) {
    b7a3:	8b 45 14             	mov    0x14(%ebp),%eax
    b7a6:	8b 40 04             	mov    0x4(%eax),%eax
    b7a9:	83 f8 08             	cmp    $0x8,%eax
    b7ac:	75 4a                	jne    b7f8 <getPixelColorsRGB8+0x316>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b7ae:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b7b5:	eb 34                	jmp    b7eb <getPixelColorsRGB8+0x309>
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
    b7b7:	8b 45 08             	mov    0x8(%ebp),%eax
    b7ba:	83 c0 01             	add    $0x1,%eax
    b7bd:	8b 55 08             	mov    0x8(%ebp),%edx
    b7c0:	83 c2 02             	add    $0x2,%edx
    b7c3:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b7c6:	01 c9                	add    %ecx,%ecx
    b7c8:	89 cb                	mov    %ecx,%ebx
    b7ca:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b7cd:	01 d9                	add    %ebx,%ecx
    b7cf:	0f b6 09             	movzbl (%ecx),%ecx
    b7d2:	88 0a                	mov    %cl,(%edx)
    b7d4:	0f b6 12             	movzbl (%edx),%edx
    b7d7:	88 10                	mov    %dl,(%eax)
    b7d9:	0f b6 10             	movzbl (%eax),%edx
    b7dc:	8b 45 08             	mov    0x8(%ebp),%eax
    b7df:	88 10                	mov    %dl,(%eax)
        lodepng_memcpy(buffer, &mode->palette[index * 4], 3);
      }
    }
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b7e1:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b7e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b7e8:	01 45 08             	add    %eax,0x8(%ebp)
    b7eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b7ee:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b7f1:	75 c4                	jne    b7b7 <getPixelColorsRGB8+0x2d5>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b7f3:	e9 fe 00 00 00       	jmp    b8f6 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b7f8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b7ff:	eb 35                	jmp    b836 <getPixelColorsRGB8+0x354>
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
    b801:	8b 45 08             	mov    0x8(%ebp),%eax
    b804:	83 c0 01             	add    $0x1,%eax
    b807:	8b 55 08             	mov    0x8(%ebp),%edx
    b80a:	83 c2 02             	add    $0x2,%edx
    b80d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
    b810:	c1 e1 02             	shl    $0x2,%ecx
    b813:	89 cb                	mov    %ecx,%ebx
    b815:	8b 4d 10             	mov    0x10(%ebp),%ecx
    b818:	01 d9                	add    %ebx,%ecx
    b81a:	0f b6 09             	movzbl (%ecx),%ecx
    b81d:	88 0a                	mov    %cl,(%edx)
    b81f:	0f b6 12             	movzbl (%edx),%edx
    b822:	88 10                	mov    %dl,(%eax)
    b824:	0f b6 10             	movzbl (%eax),%edx
    b827:	8b 45 08             	mov    0x8(%ebp),%eax
    b82a:	88 10                	mov    %dl,(%eax)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b82c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b830:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b833:	01 45 08             	add    %eax,0x8(%ebp)
    b836:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b839:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b83c:	75 c3                	jne    b801 <getPixelColorsRGB8+0x31f>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b83e:	e9 b3 00 00 00       	jmp    b8f6 <getPixelColorsRGB8+0x414>
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    b843:	8b 45 14             	mov    0x14(%ebp),%eax
    b846:	8b 00                	mov    (%eax),%eax
    b848:	83 f8 06             	cmp    $0x6,%eax
    b84b:	0f 85 a5 00 00 00    	jne    b8f6 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
    b851:	8b 45 14             	mov    0x14(%ebp),%eax
    b854:	8b 40 04             	mov    0x4(%eax),%eax
    b857:	83 f8 08             	cmp    $0x8,%eax
    b85a:	75 38                	jne    b894 <getPixelColorsRGB8+0x3b2>
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b85c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b863:	eb 25                	jmp    b88a <getPixelColorsRGB8+0x3a8>
        lodepng_memcpy(buffer, &in[i * 4], 3);
    b865:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b868:	c1 e0 02             	shl    $0x2,%eax
    b86b:	89 c2                	mov    %eax,%edx
    b86d:	8b 45 10             	mov    0x10(%ebp),%eax
    b870:	01 d0                	add    %edx,%eax
    b872:	6a 03                	push   $0x3
    b874:	50                   	push   %eax
    b875:	ff 75 08             	pushl  0x8(%ebp)
    b878:	e8 a8 7d ff ff       	call   3625 <lodepng_memcpy>
    b87d:	83 c4 0c             	add    $0xc,%esp
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
      }
    }
  } else if(mode->colortype == LCT_RGBA) {
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b880:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b884:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b887:	01 45 08             	add    %eax,0x8(%ebp)
    b88a:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b88d:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b890:	75 d3                	jne    b865 <getPixelColorsRGB8+0x383>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b892:	eb 62                	jmp    b8f6 <getPixelColorsRGB8+0x414>
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b894:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    b89b:	eb 51                	jmp    b8ee <getPixelColorsRGB8+0x40c>
        buffer[0] = in[i * 8 + 0];
    b89d:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b8a0:	c1 e0 03             	shl    $0x3,%eax
    b8a3:	89 c2                	mov    %eax,%edx
    b8a5:	8b 45 10             	mov    0x10(%ebp),%eax
    b8a8:	01 d0                	add    %edx,%eax
    b8aa:	0f b6 10             	movzbl (%eax),%edx
    b8ad:	8b 45 08             	mov    0x8(%ebp),%eax
    b8b0:	88 10                	mov    %dl,(%eax)
        buffer[1] = in[i * 8 + 2];
    b8b2:	8b 45 08             	mov    0x8(%ebp),%eax
    b8b5:	8d 50 01             	lea    0x1(%eax),%edx
    b8b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b8bb:	c1 e0 03             	shl    $0x3,%eax
    b8be:	8d 48 02             	lea    0x2(%eax),%ecx
    b8c1:	8b 45 10             	mov    0x10(%ebp),%eax
    b8c4:	01 c8                	add    %ecx,%eax
    b8c6:	0f b6 00             	movzbl (%eax),%eax
    b8c9:	88 02                	mov    %al,(%edx)
        buffer[2] = in[i * 8 + 4];
    b8cb:	8b 45 08             	mov    0x8(%ebp),%eax
    b8ce:	8d 50 02             	lea    0x2(%eax),%edx
    b8d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b8d4:	c1 e0 03             	shl    $0x3,%eax
    b8d7:	8d 48 04             	lea    0x4(%eax),%ecx
    b8da:	8b 45 10             	mov    0x10(%ebp),%eax
    b8dd:	01 c8                	add    %ecx,%eax
    b8df:	0f b6 00             	movzbl (%eax),%eax
    b8e2:	88 02                	mov    %al,(%edx)
    if(mode->bitdepth == 8) {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
        lodepng_memcpy(buffer, &in[i * 4], 3);
      }
    } else {
      for(i = 0; i != numpixels; ++i, buffer += num_channels) {
    b8e4:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    b8e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    b8eb:	01 45 08             	add    %eax,0x8(%ebp)
    b8ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
    b8f1:	3b 45 0c             	cmp    0xc(%ebp),%eax
    b8f4:	75 a7                	jne    b89d <getPixelColorsRGB8+0x3bb>
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
      }
    }
  }
}
    b8f6:	90                   	nop
    b8f7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    b8fa:	c9                   	leave  
    b8fb:	c3                   	ret    

0000b8fc <getPixelColorRGBA16>:

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
    b8fc:	55                   	push   %ebp
    b8fd:	89 e5                	mov    %esp,%ebp
  if(mode->colortype == LCT_GREY) {
    b8ff:	8b 45 20             	mov    0x20(%ebp),%eax
    b902:	8b 00                	mov    (%eax),%eax
    b904:	85 c0                	test   %eax,%eax
    b906:	0f 85 a4 00 00 00    	jne    b9b0 <getPixelColorRGBA16+0xb4>
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    b90c:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b90f:	01 c0                	add    %eax,%eax
    b911:	89 c2                	mov    %eax,%edx
    b913:	8b 45 18             	mov    0x18(%ebp),%eax
    b916:	01 d0                	add    %edx,%eax
    b918:	0f b6 00             	movzbl (%eax),%eax
    b91b:	0f b6 c0             	movzbl %al,%eax
    b91e:	c1 e0 08             	shl    $0x8,%eax
    b921:	89 c2                	mov    %eax,%edx
    b923:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b926:	01 c0                	add    %eax,%eax
    b928:	8d 48 01             	lea    0x1(%eax),%ecx
    b92b:	8b 45 18             	mov    0x18(%ebp),%eax
    b92e:	01 c8                	add    %ecx,%eax
    b930:	0f b6 00             	movzbl (%eax),%eax
    b933:	0f b6 c0             	movzbl %al,%eax
    b936:	01 c2                	add    %eax,%edx
    b938:	8b 45 10             	mov    0x10(%ebp),%eax
    b93b:	66 89 10             	mov    %dx,(%eax)
    b93e:	8b 45 10             	mov    0x10(%ebp),%eax
    b941:	0f b7 10             	movzwl (%eax),%edx
    b944:	8b 45 0c             	mov    0xc(%ebp),%eax
    b947:	66 89 10             	mov    %dx,(%eax)
    b94a:	8b 45 0c             	mov    0xc(%ebp),%eax
    b94d:	0f b7 10             	movzwl (%eax),%edx
    b950:	8b 45 08             	mov    0x8(%ebp),%eax
    b953:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    b956:	8b 45 20             	mov    0x20(%ebp),%eax
    b959:	8b 40 10             	mov    0x10(%eax),%eax
    b95c:	85 c0                	test   %eax,%eax
    b95e:	74 43                	je     b9a3 <getPixelColorRGBA16+0xa7>
    b960:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b963:	01 c0                	add    %eax,%eax
    b965:	89 c2                	mov    %eax,%edx
    b967:	8b 45 18             	mov    0x18(%ebp),%eax
    b96a:	01 d0                	add    %edx,%eax
    b96c:	0f b6 00             	movzbl (%eax),%eax
    b96f:	0f b6 c0             	movzbl %al,%eax
    b972:	c1 e0 08             	shl    $0x8,%eax
    b975:	89 c2                	mov    %eax,%edx
    b977:	8b 45 1c             	mov    0x1c(%ebp),%eax
    b97a:	01 c0                	add    %eax,%eax
    b97c:	8d 48 01             	lea    0x1(%eax),%ecx
    b97f:	8b 45 18             	mov    0x18(%ebp),%eax
    b982:	01 c8                	add    %ecx,%eax
    b984:	0f b6 00             	movzbl (%eax),%eax
    b987:	0f b6 c0             	movzbl %al,%eax
    b98a:	01 c2                	add    %eax,%edx
    b98c:	8b 45 20             	mov    0x20(%ebp),%eax
    b98f:	8b 40 14             	mov    0x14(%eax),%eax
    b992:	39 c2                	cmp    %eax,%edx
    b994:	75 0d                	jne    b9a3 <getPixelColorRGBA16+0xa7>
    b996:	8b 45 14             	mov    0x14(%ebp),%eax
    b999:	66 c7 00 00 00       	movw   $0x0,(%eax)
    b99e:	e9 48 03 00 00       	jmp    bceb <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    b9a3:	8b 45 14             	mov    0x14(%ebp),%eax
    b9a6:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    b9ab:	e9 3b 03 00 00       	jmp    bceb <getPixelColorRGBA16+0x3ef>
                                const unsigned char* in, size_t i, const LodePNGColorMode* mode) {
  if(mode->colortype == LCT_GREY) {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_RGB) {
    b9b0:	8b 45 20             	mov    0x20(%ebp),%eax
    b9b3:	8b 00                	mov    (%eax),%eax
    b9b5:	83 f8 02             	cmp    $0x2,%eax
    b9b8:	0f 85 b6 01 00 00    	jne    bb74 <getPixelColorRGBA16+0x278>
    *r = 256u * in[i * 6 + 0] + in[i * 6 + 1];
    b9be:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b9c1:	89 d0                	mov    %edx,%eax
    b9c3:	01 c0                	add    %eax,%eax
    b9c5:	01 d0                	add    %edx,%eax
    b9c7:	01 c0                	add    %eax,%eax
    b9c9:	89 c2                	mov    %eax,%edx
    b9cb:	8b 45 18             	mov    0x18(%ebp),%eax
    b9ce:	01 d0                	add    %edx,%eax
    b9d0:	0f b6 00             	movzbl (%eax),%eax
    b9d3:	0f b6 c0             	movzbl %al,%eax
    b9d6:	c1 e0 08             	shl    $0x8,%eax
    b9d9:	89 c1                	mov    %eax,%ecx
    b9db:	8b 55 1c             	mov    0x1c(%ebp),%edx
    b9de:	89 d0                	mov    %edx,%eax
    b9e0:	01 c0                	add    %eax,%eax
    b9e2:	01 d0                	add    %edx,%eax
    b9e4:	01 c0                	add    %eax,%eax
    b9e6:	8d 50 01             	lea    0x1(%eax),%edx
    b9e9:	8b 45 18             	mov    0x18(%ebp),%eax
    b9ec:	01 d0                	add    %edx,%eax
    b9ee:	0f b6 00             	movzbl (%eax),%eax
    b9f1:	0f b6 c0             	movzbl %al,%eax
    b9f4:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    b9f7:	8b 45 08             	mov    0x8(%ebp),%eax
    b9fa:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 6 + 2] + in[i * 6 + 3];
    b9fd:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ba00:	89 d0                	mov    %edx,%eax
    ba02:	01 c0                	add    %eax,%eax
    ba04:	01 d0                	add    %edx,%eax
    ba06:	01 c0                	add    %eax,%eax
    ba08:	8d 50 02             	lea    0x2(%eax),%edx
    ba0b:	8b 45 18             	mov    0x18(%ebp),%eax
    ba0e:	01 d0                	add    %edx,%eax
    ba10:	0f b6 00             	movzbl (%eax),%eax
    ba13:	0f b6 c0             	movzbl %al,%eax
    ba16:	c1 e0 08             	shl    $0x8,%eax
    ba19:	89 c1                	mov    %eax,%ecx
    ba1b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ba1e:	89 d0                	mov    %edx,%eax
    ba20:	01 c0                	add    %eax,%eax
    ba22:	01 d0                	add    %edx,%eax
    ba24:	01 c0                	add    %eax,%eax
    ba26:	8d 50 03             	lea    0x3(%eax),%edx
    ba29:	8b 45 18             	mov    0x18(%ebp),%eax
    ba2c:	01 d0                	add    %edx,%eax
    ba2e:	0f b6 00             	movzbl (%eax),%eax
    ba31:	0f b6 c0             	movzbl %al,%eax
    ba34:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ba37:	8b 45 0c             	mov    0xc(%ebp),%eax
    ba3a:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 6 + 4] + in[i * 6 + 5];
    ba3d:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ba40:	89 d0                	mov    %edx,%eax
    ba42:	01 c0                	add    %eax,%eax
    ba44:	01 d0                	add    %edx,%eax
    ba46:	01 c0                	add    %eax,%eax
    ba48:	8d 50 04             	lea    0x4(%eax),%edx
    ba4b:	8b 45 18             	mov    0x18(%ebp),%eax
    ba4e:	01 d0                	add    %edx,%eax
    ba50:	0f b6 00             	movzbl (%eax),%eax
    ba53:	0f b6 c0             	movzbl %al,%eax
    ba56:	c1 e0 08             	shl    $0x8,%eax
    ba59:	89 c1                	mov    %eax,%ecx
    ba5b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ba5e:	89 d0                	mov    %edx,%eax
    ba60:	01 c0                	add    %eax,%eax
    ba62:	01 d0                	add    %edx,%eax
    ba64:	01 c0                	add    %eax,%eax
    ba66:	8d 50 05             	lea    0x5(%eax),%edx
    ba69:	8b 45 18             	mov    0x18(%ebp),%eax
    ba6c:	01 d0                	add    %edx,%eax
    ba6e:	0f b6 00             	movzbl (%eax),%eax
    ba71:	0f b6 c0             	movzbl %al,%eax
    ba74:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    ba77:	8b 45 10             	mov    0x10(%ebp),%eax
    ba7a:	66 89 10             	mov    %dx,(%eax)
    if(mode->key_defined
    ba7d:	8b 45 20             	mov    0x20(%ebp),%eax
    ba80:	8b 40 10             	mov    0x10(%eax),%eax
    ba83:	85 c0                	test   %eax,%eax
    ba85:	0f 84 dc 00 00 00    	je     bb67 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
    ba8b:	8b 55 1c             	mov    0x1c(%ebp),%edx
    ba8e:	89 d0                	mov    %edx,%eax
    ba90:	01 c0                	add    %eax,%eax
    ba92:	01 d0                	add    %edx,%eax
    ba94:	01 c0                	add    %eax,%eax
    ba96:	89 c2                	mov    %eax,%edx
    ba98:	8b 45 18             	mov    0x18(%ebp),%eax
    ba9b:	01 d0                	add    %edx,%eax
    ba9d:	0f b6 00             	movzbl (%eax),%eax
    baa0:	0f b6 c0             	movzbl %al,%eax
    baa3:	c1 e0 08             	shl    $0x8,%eax
    baa6:	89 c1                	mov    %eax,%ecx
    baa8:	8b 55 1c             	mov    0x1c(%ebp),%edx
    baab:	89 d0                	mov    %edx,%eax
    baad:	01 c0                	add    %eax,%eax
    baaf:	01 d0                	add    %edx,%eax
    bab1:	01 c0                	add    %eax,%eax
    bab3:	8d 50 01             	lea    0x1(%eax),%edx
    bab6:	8b 45 18             	mov    0x18(%ebp),%eax
    bab9:	01 d0                	add    %edx,%eax
    babb:	0f b6 00             	movzbl (%eax),%eax
    babe:	0f b6 c0             	movzbl %al,%eax
    bac1:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bac4:	8b 45 20             	mov    0x20(%ebp),%eax
    bac7:	8b 40 14             	mov    0x14(%eax),%eax
    baca:	39 c2                	cmp    %eax,%edx
    bacc:	0f 85 95 00 00 00    	jne    bb67 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
    bad2:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bad5:	89 d0                	mov    %edx,%eax
    bad7:	01 c0                	add    %eax,%eax
    bad9:	01 d0                	add    %edx,%eax
    badb:	01 c0                	add    %eax,%eax
    badd:	8d 50 02             	lea    0x2(%eax),%edx
    bae0:	8b 45 18             	mov    0x18(%ebp),%eax
    bae3:	01 d0                	add    %edx,%eax
    bae5:	0f b6 00             	movzbl (%eax),%eax
    bae8:	0f b6 c0             	movzbl %al,%eax
    baeb:	c1 e0 08             	shl    $0x8,%eax
    baee:	89 c1                	mov    %eax,%ecx
    baf0:	8b 55 1c             	mov    0x1c(%ebp),%edx
    baf3:	89 d0                	mov    %edx,%eax
    baf5:	01 c0                	add    %eax,%eax
    baf7:	01 d0                	add    %edx,%eax
    baf9:	01 c0                	add    %eax,%eax
    bafb:	8d 50 03             	lea    0x3(%eax),%edx
    bafe:	8b 45 18             	mov    0x18(%ebp),%eax
    bb01:	01 d0                	add    %edx,%eax
    bb03:	0f b6 00             	movzbl (%eax),%eax
    bb06:	0f b6 c0             	movzbl %al,%eax
    bb09:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bb0c:	8b 45 20             	mov    0x20(%ebp),%eax
    bb0f:	8b 40 18             	mov    0x18(%eax),%eax
    bb12:	39 c2                	cmp    %eax,%edx
    bb14:	75 51                	jne    bb67 <getPixelColorRGBA16+0x26b>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    bb16:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bb19:	89 d0                	mov    %edx,%eax
    bb1b:	01 c0                	add    %eax,%eax
    bb1d:	01 d0                	add    %edx,%eax
    bb1f:	01 c0                	add    %eax,%eax
    bb21:	8d 50 04             	lea    0x4(%eax),%edx
    bb24:	8b 45 18             	mov    0x18(%ebp),%eax
    bb27:	01 d0                	add    %edx,%eax
    bb29:	0f b6 00             	movzbl (%eax),%eax
    bb2c:	0f b6 c0             	movzbl %al,%eax
    bb2f:	c1 e0 08             	shl    $0x8,%eax
    bb32:	89 c1                	mov    %eax,%ecx
    bb34:	8b 55 1c             	mov    0x1c(%ebp),%edx
    bb37:	89 d0                	mov    %edx,%eax
    bb39:	01 c0                	add    %eax,%eax
    bb3b:	01 d0                	add    %edx,%eax
    bb3d:	01 c0                	add    %eax,%eax
    bb3f:	8d 50 05             	lea    0x5(%eax),%edx
    bb42:	8b 45 18             	mov    0x18(%ebp),%eax
    bb45:	01 d0                	add    %edx,%eax
    bb47:	0f b6 00             	movzbl (%eax),%eax
    bb4a:	0f b6 c0             	movzbl %al,%eax
    bb4d:	8d 14 01             	lea    (%ecx,%eax,1),%edx
    bb50:	8b 45 20             	mov    0x20(%ebp),%eax
    bb53:	8b 40 1c             	mov    0x1c(%eax),%eax
    bb56:	39 c2                	cmp    %eax,%edx
    bb58:	75 0d                	jne    bb67 <getPixelColorRGBA16+0x26b>
    bb5a:	8b 45 14             	mov    0x14(%ebp),%eax
    bb5d:	66 c7 00 00 00       	movw   $0x0,(%eax)
    bb62:	e9 84 01 00 00       	jmp    bceb <getPixelColorRGBA16+0x3ef>
    else *a = 65535;
    bb67:	8b 45 14             	mov    0x14(%ebp),%eax
    bb6a:	66 c7 00 ff ff       	movw   $0xffff,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    bb6f:	e9 77 01 00 00       	jmp    bceb <getPixelColorRGBA16+0x3ef>
    if(mode->key_defined
       && 256u * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256u * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    bb74:	8b 45 20             	mov    0x20(%ebp),%eax
    bb77:	8b 00                	mov    (%eax),%eax
    bb79:	83 f8 04             	cmp    $0x4,%eax
    bb7c:	0f 85 86 00 00 00    	jne    bc08 <getPixelColorRGBA16+0x30c>
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    bb82:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bb85:	c1 e0 02             	shl    $0x2,%eax
    bb88:	89 c2                	mov    %eax,%edx
    bb8a:	8b 45 18             	mov    0x18(%ebp),%eax
    bb8d:	01 d0                	add    %edx,%eax
    bb8f:	0f b6 00             	movzbl (%eax),%eax
    bb92:	0f b6 c0             	movzbl %al,%eax
    bb95:	c1 e0 08             	shl    $0x8,%eax
    bb98:	89 c2                	mov    %eax,%edx
    bb9a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bb9d:	c1 e0 02             	shl    $0x2,%eax
    bba0:	8d 48 01             	lea    0x1(%eax),%ecx
    bba3:	8b 45 18             	mov    0x18(%ebp),%eax
    bba6:	01 c8                	add    %ecx,%eax
    bba8:	0f b6 00             	movzbl (%eax),%eax
    bbab:	0f b6 c0             	movzbl %al,%eax
    bbae:	01 c2                	add    %eax,%edx
    bbb0:	8b 45 10             	mov    0x10(%ebp),%eax
    bbb3:	66 89 10             	mov    %dx,(%eax)
    bbb6:	8b 45 10             	mov    0x10(%ebp),%eax
    bbb9:	0f b7 10             	movzwl (%eax),%edx
    bbbc:	8b 45 0c             	mov    0xc(%ebp),%eax
    bbbf:	66 89 10             	mov    %dx,(%eax)
    bbc2:	8b 45 0c             	mov    0xc(%ebp),%eax
    bbc5:	0f b7 10             	movzwl (%eax),%edx
    bbc8:	8b 45 08             	mov    0x8(%ebp),%eax
    bbcb:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
    bbce:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bbd1:	c1 e0 02             	shl    $0x2,%eax
    bbd4:	8d 50 02             	lea    0x2(%eax),%edx
    bbd7:	8b 45 18             	mov    0x18(%ebp),%eax
    bbda:	01 d0                	add    %edx,%eax
    bbdc:	0f b6 00             	movzbl (%eax),%eax
    bbdf:	0f b6 c0             	movzbl %al,%eax
    bbe2:	c1 e0 08             	shl    $0x8,%eax
    bbe5:	89 c2                	mov    %eax,%edx
    bbe7:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bbea:	c1 e0 02             	shl    $0x2,%eax
    bbed:	8d 48 03             	lea    0x3(%eax),%ecx
    bbf0:	8b 45 18             	mov    0x18(%ebp),%eax
    bbf3:	01 c8                	add    %ecx,%eax
    bbf5:	0f b6 00             	movzbl (%eax),%eax
    bbf8:	0f b6 c0             	movzbl %al,%eax
    bbfb:	01 c2                	add    %eax,%edx
    bbfd:	8b 45 14             	mov    0x14(%ebp),%eax
    bc00:	66 89 10             	mov    %dx,(%eax)
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
  }
}
    bc03:	e9 e3 00 00 00       	jmp    bceb <getPixelColorRGBA16+0x3ef>
       && 256u * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  } else if(mode->colortype == LCT_GREY_ALPHA) {
    *r = *g = *b = 256u * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256u * in[i * 4 + 2] + in[i * 4 + 3];
  } else if(mode->colortype == LCT_RGBA) {
    bc08:	8b 45 20             	mov    0x20(%ebp),%eax
    bc0b:	8b 00                	mov    (%eax),%eax
    bc0d:	83 f8 06             	cmp    $0x6,%eax
    bc10:	0f 85 d5 00 00 00    	jne    bceb <getPixelColorRGBA16+0x3ef>
    *r = 256u * in[i * 8 + 0] + in[i * 8 + 1];
    bc16:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc19:	c1 e0 03             	shl    $0x3,%eax
    bc1c:	89 c2                	mov    %eax,%edx
    bc1e:	8b 45 18             	mov    0x18(%ebp),%eax
    bc21:	01 d0                	add    %edx,%eax
    bc23:	0f b6 00             	movzbl (%eax),%eax
    bc26:	0f b6 c0             	movzbl %al,%eax
    bc29:	c1 e0 08             	shl    $0x8,%eax
    bc2c:	89 c2                	mov    %eax,%edx
    bc2e:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc31:	c1 e0 03             	shl    $0x3,%eax
    bc34:	8d 48 01             	lea    0x1(%eax),%ecx
    bc37:	8b 45 18             	mov    0x18(%ebp),%eax
    bc3a:	01 c8                	add    %ecx,%eax
    bc3c:	0f b6 00             	movzbl (%eax),%eax
    bc3f:	0f b6 c0             	movzbl %al,%eax
    bc42:	01 c2                	add    %eax,%edx
    bc44:	8b 45 08             	mov    0x8(%ebp),%eax
    bc47:	66 89 10             	mov    %dx,(%eax)
    *g = 256u * in[i * 8 + 2] + in[i * 8 + 3];
    bc4a:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc4d:	c1 e0 03             	shl    $0x3,%eax
    bc50:	8d 50 02             	lea    0x2(%eax),%edx
    bc53:	8b 45 18             	mov    0x18(%ebp),%eax
    bc56:	01 d0                	add    %edx,%eax
    bc58:	0f b6 00             	movzbl (%eax),%eax
    bc5b:	0f b6 c0             	movzbl %al,%eax
    bc5e:	c1 e0 08             	shl    $0x8,%eax
    bc61:	89 c2                	mov    %eax,%edx
    bc63:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc66:	c1 e0 03             	shl    $0x3,%eax
    bc69:	8d 48 03             	lea    0x3(%eax),%ecx
    bc6c:	8b 45 18             	mov    0x18(%ebp),%eax
    bc6f:	01 c8                	add    %ecx,%eax
    bc71:	0f b6 00             	movzbl (%eax),%eax
    bc74:	0f b6 c0             	movzbl %al,%eax
    bc77:	01 c2                	add    %eax,%edx
    bc79:	8b 45 0c             	mov    0xc(%ebp),%eax
    bc7c:	66 89 10             	mov    %dx,(%eax)
    *b = 256u * in[i * 8 + 4] + in[i * 8 + 5];
    bc7f:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc82:	c1 e0 03             	shl    $0x3,%eax
    bc85:	8d 50 04             	lea    0x4(%eax),%edx
    bc88:	8b 45 18             	mov    0x18(%ebp),%eax
    bc8b:	01 d0                	add    %edx,%eax
    bc8d:	0f b6 00             	movzbl (%eax),%eax
    bc90:	0f b6 c0             	movzbl %al,%eax
    bc93:	c1 e0 08             	shl    $0x8,%eax
    bc96:	89 c2                	mov    %eax,%edx
    bc98:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bc9b:	c1 e0 03             	shl    $0x3,%eax
    bc9e:	8d 48 05             	lea    0x5(%eax),%ecx
    bca1:	8b 45 18             	mov    0x18(%ebp),%eax
    bca4:	01 c8                	add    %ecx,%eax
    bca6:	0f b6 00             	movzbl (%eax),%eax
    bca9:	0f b6 c0             	movzbl %al,%eax
    bcac:	01 c2                	add    %eax,%edx
    bcae:	8b 45 10             	mov    0x10(%ebp),%eax
    bcb1:	66 89 10             	mov    %dx,(%eax)
    *a = 256u * in[i * 8 + 6] + in[i * 8 + 7];
    bcb4:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bcb7:	c1 e0 03             	shl    $0x3,%eax
    bcba:	8d 50 06             	lea    0x6(%eax),%edx
    bcbd:	8b 45 18             	mov    0x18(%ebp),%eax
    bcc0:	01 d0                	add    %edx,%eax
    bcc2:	0f b6 00             	movzbl (%eax),%eax
    bcc5:	0f b6 c0             	movzbl %al,%eax
    bcc8:	c1 e0 08             	shl    $0x8,%eax
    bccb:	89 c2                	mov    %eax,%edx
    bccd:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bcd0:	c1 e0 03             	shl    $0x3,%eax
    bcd3:	8d 48 07             	lea    0x7(%eax),%ecx
    bcd6:	8b 45 18             	mov    0x18(%ebp),%eax
    bcd9:	01 c8                	add    %ecx,%eax
    bcdb:	0f b6 00             	movzbl (%eax),%eax
    bcde:	0f b6 c0             	movzbl %al,%eax
    bce1:	01 c2                	add    %eax,%edx
    bce3:	8b 45 14             	mov    0x14(%ebp),%eax
    bce6:	66 89 10             	mov    %dx,(%eax)
  }
}
    bce9:	eb 00                	jmp    bceb <getPixelColorRGBA16+0x3ef>
    bceb:	90                   	nop
    bcec:	5d                   	pop    %ebp
    bced:	c3                   	ret    

0000bcee <lodepng_convert>:

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
                         unsigned w, unsigned h) {
    bcee:	55                   	push   %ebp
    bcef:	89 e5                	mov    %esp,%ebp
    bcf1:	56                   	push   %esi
    bcf2:	53                   	push   %ebx
    bcf3:	83 c4 80             	add    $0xffffff80,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    bcf6:	8b 55 18             	mov    0x18(%ebp),%edx
    bcf9:	8b 45 1c             	mov    0x1c(%ebp),%eax
    bcfc:	0f af c2             	imul   %edx,%eax
    bcff:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned error = 0;
    bd02:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(mode_in->colortype == LCT_PALETTE && !mode_in->palette) {
    bd09:	8b 45 14             	mov    0x14(%ebp),%eax
    bd0c:	8b 00                	mov    (%eax),%eax
    bd0e:	83 f8 03             	cmp    $0x3,%eax
    bd11:	75 14                	jne    bd27 <lodepng_convert+0x39>
    bd13:	8b 45 14             	mov    0x14(%ebp),%eax
    bd16:	8b 40 08             	mov    0x8(%eax),%eax
    bd19:	85 c0                	test   %eax,%eax
    bd1b:	75 0a                	jne    bd27 <lodepng_convert+0x39>
    return 107; /* error: must provide palette if input mode is palette */
    bd1d:	b8 6b 00 00 00       	mov    $0x6b,%eax
    bd22:	e9 19 03 00 00       	jmp    c040 <lodepng_convert+0x352>
  }

  if(lodepng_color_mode_equal(mode_out, mode_in)) {
    bd27:	ff 75 14             	pushl  0x14(%ebp)
    bd2a:	ff 75 10             	pushl  0x10(%ebp)
    bd2d:	e8 b7 d1 ff ff       	call   8ee9 <lodepng_color_mode_equal>
    bd32:	83 c4 08             	add    $0x8,%esp
    bd35:	85 c0                	test   %eax,%eax
    bd37:	74 2f                	je     bd68 <lodepng_convert+0x7a>
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bd39:	ff 75 14             	pushl  0x14(%ebp)
    bd3c:	ff 75 1c             	pushl  0x1c(%ebp)
    bd3f:	ff 75 18             	pushl  0x18(%ebp)
    bd42:	e8 fb d4 ff ff       	call   9242 <lodepng_get_raw_size>
    bd47:	83 c4 0c             	add    $0xc,%esp
    bd4a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    lodepng_memcpy(out, in, numbytes);
    bd4d:	ff 75 dc             	pushl  -0x24(%ebp)
    bd50:	ff 75 0c             	pushl  0xc(%ebp)
    bd53:	ff 75 08             	pushl  0x8(%ebp)
    bd56:	e8 ca 78 ff ff       	call   3625 <lodepng_memcpy>
    bd5b:	83 c4 0c             	add    $0xc,%esp
    return 0;
    bd5e:	b8 00 00 00 00       	mov    $0x0,%eax
    bd63:	e9 d8 02 00 00       	jmp    c040 <lodepng_convert+0x352>
  }

  if(mode_out->colortype == LCT_PALETTE) {
    bd68:	8b 45 10             	mov    0x10(%ebp),%eax
    bd6b:	8b 00                	mov    (%eax),%eax
    bd6d:	83 f8 03             	cmp    $0x3,%eax
    bd70:	0f 85 16 01 00 00    	jne    be8c <lodepng_convert+0x19e>
    size_t palettesize = mode_out->palettesize;
    bd76:	8b 45 10             	mov    0x10(%ebp),%eax
    bd79:	8b 40 0c             	mov    0xc(%eax),%eax
    bd7c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const unsigned char* palette = mode_out->palette;
    bd7f:	8b 45 10             	mov    0x10(%ebp),%eax
    bd82:	8b 40 08             	mov    0x8(%eax),%eax
    bd85:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t palsize = (size_t)1u << mode_out->bitdepth;
    bd88:	8b 45 10             	mov    0x10(%ebp),%eax
    bd8b:	8b 40 04             	mov    0x4(%eax),%eax
    bd8e:	ba 01 00 00 00       	mov    $0x1,%edx
    bd93:	89 c1                	mov    %eax,%ecx
    bd95:	d3 e2                	shl    %cl,%edx
    bd97:	89 d0                	mov    %edx,%eax
    bd99:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /*if the user specified output palette but did not give the values, assume
    they want the values of the input color type (assuming that one is palette).
    Note that we never create a new palette ourselves.*/
    if(palettesize == 0) {
    bd9c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    bda0:	75 5b                	jne    bdfd <lodepng_convert+0x10f>
      palettesize = mode_in->palettesize;
    bda2:	8b 45 14             	mov    0x14(%ebp),%eax
    bda5:	8b 40 0c             	mov    0xc(%eax),%eax
    bda8:	89 45 ec             	mov    %eax,-0x14(%ebp)
      palette = mode_in->palette;
    bdab:	8b 45 14             	mov    0x14(%ebp),%eax
    bdae:	8b 40 08             	mov    0x8(%eax),%eax
    bdb1:	89 45 e8             	mov    %eax,-0x18(%ebp)
      /*if the input was also palette with same bitdepth, then the color types are also
      equal, so copy literally. This to preserve the exact indices that were in the PNG
      even in case there are duplicate colors in the palette.*/
      if(mode_in->colortype == LCT_PALETTE && mode_in->bitdepth == mode_out->bitdepth) {
    bdb4:	8b 45 14             	mov    0x14(%ebp),%eax
    bdb7:	8b 00                	mov    (%eax),%eax
    bdb9:	83 f8 03             	cmp    $0x3,%eax
    bdbc:	75 3f                	jne    bdfd <lodepng_convert+0x10f>
    bdbe:	8b 45 14             	mov    0x14(%ebp),%eax
    bdc1:	8b 50 04             	mov    0x4(%eax),%edx
    bdc4:	8b 45 10             	mov    0x10(%ebp),%eax
    bdc7:	8b 40 04             	mov    0x4(%eax),%eax
    bdca:	39 c2                	cmp    %eax,%edx
    bdcc:	75 2f                	jne    bdfd <lodepng_convert+0x10f>
        size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    bdce:	ff 75 14             	pushl  0x14(%ebp)
    bdd1:	ff 75 1c             	pushl  0x1c(%ebp)
    bdd4:	ff 75 18             	pushl  0x18(%ebp)
    bdd7:	e8 66 d4 ff ff       	call   9242 <lodepng_get_raw_size>
    bddc:	83 c4 0c             	add    $0xc,%esp
    bddf:	89 45 d8             	mov    %eax,-0x28(%ebp)
        lodepng_memcpy(out, in, numbytes);
    bde2:	ff 75 d8             	pushl  -0x28(%ebp)
    bde5:	ff 75 0c             	pushl  0xc(%ebp)
    bde8:	ff 75 08             	pushl  0x8(%ebp)
    bdeb:	e8 35 78 ff ff       	call   3625 <lodepng_memcpy>
    bdf0:	83 c4 0c             	add    $0xc,%esp
        return 0;
    bdf3:	b8 00 00 00 00       	mov    $0x0,%eax
    bdf8:	e9 43 02 00 00       	jmp    c040 <lodepng_convert+0x352>
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    bdfd:	8b 45 ec             	mov    -0x14(%ebp),%eax
    be00:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    be03:	7d 06                	jge    be0b <lodepng_convert+0x11d>
    be05:	8b 45 ec             	mov    -0x14(%ebp),%eax
    be08:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    color_tree_init(&tree);
    be0b:	8d 45 90             	lea    -0x70(%ebp),%eax
    be0e:	50                   	push   %eax
    be0f:	e8 5f e1 ff ff       	call   9f73 <color_tree_init>
    be14:	83 c4 04             	add    $0x4,%esp
    for(i = 0; i != palsize; ++i) {
    be17:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    be1e:	eb 61                	jmp    be81 <lodepng_convert+0x193>
      const unsigned char* p = &palette[i * 4];
    be20:	8b 45 f4             	mov    -0xc(%ebp),%eax
    be23:	c1 e0 02             	shl    $0x2,%eax
    be26:	89 c2                	mov    %eax,%edx
    be28:	8b 45 e8             	mov    -0x18(%ebp),%eax
    be2b:	01 d0                	add    %edx,%eax
    be2d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
    be30:	8b 75 f4             	mov    -0xc(%ebp),%esi
    be33:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    be36:	83 c0 03             	add    $0x3,%eax
    be39:	0f b6 00             	movzbl (%eax),%eax
    be3c:	0f b6 d8             	movzbl %al,%ebx
    be3f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    be42:	83 c0 02             	add    $0x2,%eax
    be45:	0f b6 00             	movzbl (%eax),%eax
    be48:	0f b6 c8             	movzbl %al,%ecx
    be4b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    be4e:	83 c0 01             	add    $0x1,%eax
    be51:	0f b6 00             	movzbl (%eax),%eax
    be54:	0f b6 d0             	movzbl %al,%edx
    be57:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    be5a:	0f b6 00             	movzbl (%eax),%eax
    be5d:	0f b6 c0             	movzbl %al,%eax
    be60:	83 ec 08             	sub    $0x8,%esp
    be63:	56                   	push   %esi
    be64:	53                   	push   %ebx
    be65:	51                   	push   %ecx
    be66:	52                   	push   %edx
    be67:	50                   	push   %eax
    be68:	8d 45 90             	lea    -0x70(%ebp),%eax
    be6b:	50                   	push   %eax
    be6c:	e8 85 e2 ff ff       	call   a0f6 <color_tree_add>
    be71:	83 c4 20             	add    $0x20,%esp
    be74:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) break;
    be77:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    be7b:	75 0e                	jne    be8b <lodepng_convert+0x19d>
        return 0;
      }
    }
    if(palettesize < palsize) palsize = palettesize;
    color_tree_init(&tree);
    for(i = 0; i != palsize; ++i) {
    be7d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    be81:	8b 45 f4             	mov    -0xc(%ebp),%eax
    be84:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    be87:	75 97                	jne    be20 <lodepng_convert+0x132>
    be89:	eb 01                	jmp    be8c <lodepng_convert+0x19e>
      const unsigned char* p = &palette[i * 4];
      error = color_tree_add(&tree, p[0], p[1], p[2], p[3], (unsigned)i);
      if(error) break;
    be8b:	90                   	nop
    }
  }

  if(!error) {
    be8c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    be90:	0f 85 8e 01 00 00    	jne    c024 <lodepng_convert+0x336>
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    be96:	8b 45 14             	mov    0x14(%ebp),%eax
    be99:	8b 40 04             	mov    0x4(%eax),%eax
    be9c:	83 f8 10             	cmp    $0x10,%eax
    be9f:	0f 85 99 00 00 00    	jne    bf3e <lodepng_convert+0x250>
    bea5:	8b 45 10             	mov    0x10(%ebp),%eax
    bea8:	8b 40 04             	mov    0x4(%eax),%eax
    beab:	83 f8 10             	cmp    $0x10,%eax
    beae:	0f 85 8a 00 00 00    	jne    bf3e <lodepng_convert+0x250>
      for(i = 0; i != numpixels; ++i) {
    beb4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bebb:	eb 74                	jmp    bf31 <lodepng_convert+0x243>
        unsigned short r = 0, g = 0, b = 0, a = 0;
    bebd:	66 c7 45 8e 00 00    	movw   $0x0,-0x72(%ebp)
    bec3:	66 c7 45 8c 00 00    	movw   $0x0,-0x74(%ebp)
    bec9:	66 c7 45 8a 00 00    	movw   $0x0,-0x76(%ebp)
    becf:	66 c7 45 88 00 00    	movw   $0x0,-0x78(%ebp)
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    bed5:	83 ec 04             	sub    $0x4,%esp
    bed8:	ff 75 14             	pushl  0x14(%ebp)
    bedb:	ff 75 f4             	pushl  -0xc(%ebp)
    bede:	ff 75 0c             	pushl  0xc(%ebp)
    bee1:	8d 45 88             	lea    -0x78(%ebp),%eax
    bee4:	50                   	push   %eax
    bee5:	8d 45 8a             	lea    -0x76(%ebp),%eax
    bee8:	50                   	push   %eax
    bee9:	8d 45 8c             	lea    -0x74(%ebp),%eax
    beec:	50                   	push   %eax
    beed:	8d 45 8e             	lea    -0x72(%ebp),%eax
    bef0:	50                   	push   %eax
    bef1:	e8 06 fa ff ff       	call   b8fc <getPixelColorRGBA16>
    bef6:	83 c4 20             	add    $0x20,%esp
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
    bef9:	0f b7 45 88          	movzwl -0x78(%ebp),%eax
    befd:	0f b7 d8             	movzwl %ax,%ebx
    bf00:	0f b7 45 8a          	movzwl -0x76(%ebp),%eax
    bf04:	0f b7 c8             	movzwl %ax,%ecx
    bf07:	0f b7 45 8c          	movzwl -0x74(%ebp),%eax
    bf0b:	0f b7 d0             	movzwl %ax,%edx
    bf0e:	0f b7 45 8e          	movzwl -0x72(%ebp),%eax
    bf12:	0f b7 c0             	movzwl %ax,%eax
    bf15:	83 ec 04             	sub    $0x4,%esp
    bf18:	53                   	push   %ebx
    bf19:	51                   	push   %ecx
    bf1a:	52                   	push   %edx
    bf1b:	50                   	push   %eax
    bf1c:	ff 75 10             	pushl  0x10(%ebp)
    bf1f:	ff 75 f4             	pushl  -0xc(%ebp)
    bf22:	ff 75 08             	pushl  0x8(%ebp)
    bf25:	e8 d3 e6 ff ff       	call   a5fd <rgba16ToPixel>
    bf2a:	83 c4 20             	add    $0x20,%esp
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
      for(i = 0; i != numpixels; ++i) {
    bf2d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    bf31:	8b 45 f4             	mov    -0xc(%ebp),%eax
    bf34:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    bf37:	75 84                	jne    bebd <lodepng_convert+0x1cf>
      if(error) break;
    }
  }

  if(!error) {
    if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16) {
    bf39:	e9 e6 00 00 00       	jmp    c024 <lodepng_convert+0x336>
      for(i = 0; i != numpixels; ++i) {
        unsigned short r = 0, g = 0, b = 0, a = 0;
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
        rgba16ToPixel(out, i, mode_out, r, g, b, a);
      }
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA) {
    bf3e:	8b 45 10             	mov    0x10(%ebp),%eax
    bf41:	8b 40 04             	mov    0x4(%eax),%eax
    bf44:	83 f8 08             	cmp    $0x8,%eax
    bf47:	75 23                	jne    bf6c <lodepng_convert+0x27e>
    bf49:	8b 45 10             	mov    0x10(%ebp),%eax
    bf4c:	8b 00                	mov    (%eax),%eax
    bf4e:	83 f8 06             	cmp    $0x6,%eax
    bf51:	75 19                	jne    bf6c <lodepng_convert+0x27e>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    bf53:	ff 75 14             	pushl  0x14(%ebp)
    bf56:	ff 75 0c             	pushl  0xc(%ebp)
    bf59:	ff 75 e0             	pushl  -0x20(%ebp)
    bf5c:	ff 75 08             	pushl  0x8(%ebp)
    bf5f:	e8 ae ee ff ff       	call   ae12 <getPixelColorsRGBA8>
    bf64:	83 c4 10             	add    $0x10,%esp
    bf67:	e9 b8 00 00 00       	jmp    c024 <lodepng_convert+0x336>
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
    bf6c:	8b 45 10             	mov    0x10(%ebp),%eax
    bf6f:	8b 40 04             	mov    0x4(%eax),%eax
    bf72:	83 f8 08             	cmp    $0x8,%eax
    bf75:	75 23                	jne    bf9a <lodepng_convert+0x2ac>
    bf77:	8b 45 10             	mov    0x10(%ebp),%eax
    bf7a:	8b 00                	mov    (%eax),%eax
    bf7c:	83 f8 02             	cmp    $0x2,%eax
    bf7f:	75 19                	jne    bf9a <lodepng_convert+0x2ac>
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    bf81:	ff 75 14             	pushl  0x14(%ebp)
    bf84:	ff 75 0c             	pushl  0xc(%ebp)
    bf87:	ff 75 e0             	pushl  -0x20(%ebp)
    bf8a:	ff 75 08             	pushl  0x8(%ebp)
    bf8d:	e8 50 f5 ff ff       	call   b4e2 <getPixelColorsRGB8>
    bf92:	83 c4 10             	add    $0x10,%esp
    bf95:	e9 8a 00 00 00       	jmp    c024 <lodepng_convert+0x336>
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
    bf9a:	c6 45 87 00          	movb   $0x0,-0x79(%ebp)
    bf9e:	c6 45 86 00          	movb   $0x0,-0x7a(%ebp)
    bfa2:	c6 45 85 00          	movb   $0x0,-0x7b(%ebp)
    bfa6:	c6 45 84 00          	movb   $0x0,-0x7c(%ebp)
      for(i = 0; i != numpixels; ++i) {
    bfaa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    bfb1:	eb 66                	jmp    c019 <lodepng_convert+0x32b>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    bfb3:	83 ec 04             	sub    $0x4,%esp
    bfb6:	ff 75 14             	pushl  0x14(%ebp)
    bfb9:	ff 75 f4             	pushl  -0xc(%ebp)
    bfbc:	ff 75 0c             	pushl  0xc(%ebp)
    bfbf:	8d 45 84             	lea    -0x7c(%ebp),%eax
    bfc2:	50                   	push   %eax
    bfc3:	8d 45 85             	lea    -0x7b(%ebp),%eax
    bfc6:	50                   	push   %eax
    bfc7:	8d 45 86             	lea    -0x7a(%ebp),%eax
    bfca:	50                   	push   %eax
    bfcb:	8d 45 87             	lea    -0x79(%ebp),%eax
    bfce:	50                   	push   %eax
    bfcf:	e8 71 e8 ff ff       	call   a845 <getPixelColorRGBA8>
    bfd4:	83 c4 20             	add    $0x20,%esp
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
    bfd7:	0f b6 45 84          	movzbl -0x7c(%ebp),%eax
    bfdb:	0f b6 d8             	movzbl %al,%ebx
    bfde:	0f b6 45 85          	movzbl -0x7b(%ebp),%eax
    bfe2:	0f b6 c8             	movzbl %al,%ecx
    bfe5:	0f b6 45 86          	movzbl -0x7a(%ebp),%eax
    bfe9:	0f b6 d0             	movzbl %al,%edx
    bfec:	0f b6 45 87          	movzbl -0x79(%ebp),%eax
    bff0:	0f b6 c0             	movzbl %al,%eax
    bff3:	53                   	push   %ebx
    bff4:	51                   	push   %ecx
    bff5:	52                   	push   %edx
    bff6:	50                   	push   %eax
    bff7:	8d 45 90             	lea    -0x70(%ebp),%eax
    bffa:	50                   	push   %eax
    bffb:	ff 75 10             	pushl  0x10(%ebp)
    bffe:	ff 75 f4             	pushl  -0xc(%ebp)
    c001:	ff 75 08             	pushl  0x8(%ebp)
    c004:	e8 e5 e1 ff ff       	call   a1ee <rgba8ToPixel>
    c009:	83 c4 20             	add    $0x20,%esp
    c00c:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(error) break;
    c00f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c013:	75 0e                	jne    c023 <lodepng_convert+0x335>
      getPixelColorsRGBA8(out, numpixels, in, mode_in);
    } else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB) {
      getPixelColorsRGB8(out, numpixels, in, mode_in);
    } else {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      for(i = 0; i != numpixels; ++i) {
    c015:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c019:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c01c:	3b 45 e0             	cmp    -0x20(%ebp),%eax
    c01f:	75 92                	jne    bfb3 <lodepng_convert+0x2c5>
    c021:	eb 01                	jmp    c024 <lodepng_convert+0x336>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
        error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
        if(error) break;
    c023:	90                   	nop
      }
    }
  }

  if(mode_out->colortype == LCT_PALETTE) {
    c024:	8b 45 10             	mov    0x10(%ebp),%eax
    c027:	8b 00                	mov    (%eax),%eax
    c029:	83 f8 03             	cmp    $0x3,%eax
    c02c:	75 0f                	jne    c03d <lodepng_convert+0x34f>
    color_tree_cleanup(&tree);
    c02e:	83 ec 0c             	sub    $0xc,%esp
    c031:	8d 45 90             	lea    -0x70(%ebp),%eax
    c034:	50                   	push   %eax
    c035:	e8 59 df ff ff       	call   9f93 <color_tree_cleanup>
    c03a:	83 c4 10             	add    $0x10,%esp
  }

  return error;
    c03d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    c040:	8d 65 f8             	lea    -0x8(%ebp),%esp
    c043:	5b                   	pop    %ebx
    c044:	5e                   	pop    %esi
    c045:	5d                   	pop    %ebp
    c046:	c3                   	ret    

0000c047 <lodepng_convert_rgb>:
specification it looks like bKGD should ignore the alpha values of the palette since it can use
any palette index but doesn't have an alpha channel. Idem with ignoring color key. */
unsigned lodepng_convert_rgb(
    unsigned* r_out, unsigned* g_out, unsigned* b_out,
    unsigned r_in, unsigned g_in, unsigned b_in,
    const LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in) {
    c047:	55                   	push   %ebp
    c048:	89 e5                	mov    %esp,%ebp
    c04a:	83 ec 20             	sub    $0x20,%esp
  unsigned r = 0, g = 0, b = 0;
    c04d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    c054:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    c05b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned mul = 65535 / ((1u << mode_in->bitdepth) - 1u); /*65535, 21845, 4369, 257, 1*/
    c062:	8b 45 24             	mov    0x24(%ebp),%eax
    c065:	8b 40 04             	mov    0x4(%eax),%eax
    c068:	ba 01 00 00 00       	mov    $0x1,%edx
    c06d:	89 c1                	mov    %eax,%ecx
    c06f:	d3 e2                	shl    %cl,%edx
    c071:	89 d0                	mov    %edx,%eax
    c073:	8d 48 ff             	lea    -0x1(%eax),%ecx
    c076:	b8 ff ff 00 00       	mov    $0xffff,%eax
    c07b:	ba 00 00 00 00       	mov    $0x0,%edx
    c080:	f7 f1                	div    %ecx
    c082:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned shift = 16 - mode_out->bitdepth;
    c085:	8b 45 20             	mov    0x20(%ebp),%eax
    c088:	8b 40 04             	mov    0x4(%eax),%eax
    c08b:	ba 10 00 00 00       	mov    $0x10,%edx
    c090:	29 c2                	sub    %eax,%edx
    c092:	89 d0                	mov    %edx,%eax
    c094:	89 45 e8             	mov    %eax,-0x18(%ebp)

  if(mode_in->colortype == LCT_GREY || mode_in->colortype == LCT_GREY_ALPHA) {
    c097:	8b 45 24             	mov    0x24(%ebp),%eax
    c09a:	8b 00                	mov    (%eax),%eax
    c09c:	85 c0                	test   %eax,%eax
    c09e:	74 0a                	je     c0aa <lodepng_convert_rgb+0x63>
    c0a0:	8b 45 24             	mov    0x24(%ebp),%eax
    c0a3:	8b 00                	mov    (%eax),%eax
    c0a5:	83 f8 04             	cmp    $0x4,%eax
    c0a8:	75 1b                	jne    c0c5 <lodepng_convert_rgb+0x7e>
    r = g = b = r_in * mul;
    c0aa:	8b 45 14             	mov    0x14(%ebp),%eax
    c0ad:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c0b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c0b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c0b7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    c0ba:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c0bd:	89 45 fc             	mov    %eax,-0x4(%ebp)
    c0c0:	e9 c2 00 00 00       	jmp    c187 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_RGB || mode_in->colortype == LCT_RGBA) {
    c0c5:	8b 45 24             	mov    0x24(%ebp),%eax
    c0c8:	8b 00                	mov    (%eax),%eax
    c0ca:	83 f8 02             	cmp    $0x2,%eax
    c0cd:	74 0a                	je     c0d9 <lodepng_convert_rgb+0x92>
    c0cf:	8b 45 24             	mov    0x24(%ebp),%eax
    c0d2:	8b 00                	mov    (%eax),%eax
    c0d4:	83 f8 06             	cmp    $0x6,%eax
    c0d7:	75 23                	jne    c0fc <lodepng_convert_rgb+0xb5>
    r = r_in * mul;
    c0d9:	8b 45 14             	mov    0x14(%ebp),%eax
    c0dc:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c0e0:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = g_in * mul;
    c0e3:	8b 45 18             	mov    0x18(%ebp),%eax
    c0e6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c0ea:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = b_in * mul;
    c0ed:	8b 45 1c             	mov    0x1c(%ebp),%eax
    c0f0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    c0f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c0f7:	e9 8b 00 00 00       	jmp    c187 <lodepng_convert_rgb+0x140>
  } else if(mode_in->colortype == LCT_PALETTE) {
    c0fc:	8b 45 24             	mov    0x24(%ebp),%eax
    c0ff:	8b 00                	mov    (%eax),%eax
    c101:	83 f8 03             	cmp    $0x3,%eax
    c104:	75 77                	jne    c17d <lodepng_convert_rgb+0x136>
    if(r_in >= mode_in->palettesize) return 82;
    c106:	8b 45 24             	mov    0x24(%ebp),%eax
    c109:	8b 40 0c             	mov    0xc(%eax),%eax
    c10c:	3b 45 14             	cmp    0x14(%ebp),%eax
    c10f:	77 0a                	ja     c11b <lodepng_convert_rgb+0xd4>
    c111:	b8 52 00 00 00       	mov    $0x52,%eax
    c116:	e9 cb 01 00 00       	jmp    c2e6 <lodepng_convert_rgb+0x29f>
    r = mode_in->palette[r_in * 4 + 0] * 257u;
    c11b:	8b 45 24             	mov    0x24(%ebp),%eax
    c11e:	8b 40 08             	mov    0x8(%eax),%eax
    c121:	8b 55 14             	mov    0x14(%ebp),%edx
    c124:	c1 e2 02             	shl    $0x2,%edx
    c127:	01 d0                	add    %edx,%eax
    c129:	0f b6 00             	movzbl (%eax),%eax
    c12c:	0f b6 d0             	movzbl %al,%edx
    c12f:	89 d0                	mov    %edx,%eax
    c131:	c1 e0 08             	shl    $0x8,%eax
    c134:	01 d0                	add    %edx,%eax
    c136:	89 45 fc             	mov    %eax,-0x4(%ebp)
    g = mode_in->palette[r_in * 4 + 1] * 257u;
    c139:	8b 45 24             	mov    0x24(%ebp),%eax
    c13c:	8b 40 08             	mov    0x8(%eax),%eax
    c13f:	8b 55 14             	mov    0x14(%ebp),%edx
    c142:	c1 e2 02             	shl    $0x2,%edx
    c145:	83 c2 01             	add    $0x1,%edx
    c148:	01 d0                	add    %edx,%eax
    c14a:	0f b6 00             	movzbl (%eax),%eax
    c14d:	0f b6 d0             	movzbl %al,%edx
    c150:	89 d0                	mov    %edx,%eax
    c152:	c1 e0 08             	shl    $0x8,%eax
    c155:	01 d0                	add    %edx,%eax
    c157:	89 45 f8             	mov    %eax,-0x8(%ebp)
    b = mode_in->palette[r_in * 4 + 2] * 257u;
    c15a:	8b 45 24             	mov    0x24(%ebp),%eax
    c15d:	8b 40 08             	mov    0x8(%eax),%eax
    c160:	8b 55 14             	mov    0x14(%ebp),%edx
    c163:	c1 e2 02             	shl    $0x2,%edx
    c166:	83 c2 02             	add    $0x2,%edx
    c169:	01 d0                	add    %edx,%eax
    c16b:	0f b6 00             	movzbl (%eax),%eax
    c16e:	0f b6 d0             	movzbl %al,%edx
    c171:	89 d0                	mov    %edx,%eax
    c173:	c1 e0 08             	shl    $0x8,%eax
    c176:	01 d0                	add    %edx,%eax
    c178:	89 45 f4             	mov    %eax,-0xc(%ebp)
    c17b:	eb 0a                	jmp    c187 <lodepng_convert_rgb+0x140>
  } else {
    return 31;
    c17d:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c182:	e9 5f 01 00 00       	jmp    c2e6 <lodepng_convert_rgb+0x29f>
  }

  /* now convert to output format */
  if(mode_out->colortype == LCT_GREY || mode_out->colortype == LCT_GREY_ALPHA) {
    c187:	8b 45 20             	mov    0x20(%ebp),%eax
    c18a:	8b 00                	mov    (%eax),%eax
    c18c:	85 c0                	test   %eax,%eax
    c18e:	74 0a                	je     c19a <lodepng_convert_rgb+0x153>
    c190:	8b 45 20             	mov    0x20(%ebp),%eax
    c193:	8b 00                	mov    (%eax),%eax
    c195:	83 f8 04             	cmp    $0x4,%eax
    c198:	75 14                	jne    c1ae <lodepng_convert_rgb+0x167>
    *r_out = r >> shift ;
    c19a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c19d:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c1a0:	89 c1                	mov    %eax,%ecx
    c1a2:	d3 ea                	shr    %cl,%edx
    c1a4:	8b 45 08             	mov    0x8(%ebp),%eax
    c1a7:	89 10                	mov    %edx,(%eax)
    c1a9:	e9 33 01 00 00       	jmp    c2e1 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_RGB || mode_out->colortype == LCT_RGBA) {
    c1ae:	8b 45 20             	mov    0x20(%ebp),%eax
    c1b1:	8b 00                	mov    (%eax),%eax
    c1b3:	83 f8 02             	cmp    $0x2,%eax
    c1b6:	74 0a                	je     c1c2 <lodepng_convert_rgb+0x17b>
    c1b8:	8b 45 20             	mov    0x20(%ebp),%eax
    c1bb:	8b 00                	mov    (%eax),%eax
    c1bd:	83 f8 06             	cmp    $0x6,%eax
    c1c0:	75 32                	jne    c1f4 <lodepng_convert_rgb+0x1ad>
    *r_out = r >> shift ;
    c1c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c1c5:	8b 55 fc             	mov    -0x4(%ebp),%edx
    c1c8:	89 c1                	mov    %eax,%ecx
    c1ca:	d3 ea                	shr    %cl,%edx
    c1cc:	8b 45 08             	mov    0x8(%ebp),%eax
    c1cf:	89 10                	mov    %edx,(%eax)
    *g_out = g >> shift ;
    c1d1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c1d4:	8b 55 f8             	mov    -0x8(%ebp),%edx
    c1d7:	89 c1                	mov    %eax,%ecx
    c1d9:	d3 ea                	shr    %cl,%edx
    c1db:	8b 45 0c             	mov    0xc(%ebp),%eax
    c1de:	89 10                	mov    %edx,(%eax)
    *b_out = b >> shift ;
    c1e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    c1e3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    c1e6:	89 c1                	mov    %eax,%ecx
    c1e8:	d3 ea                	shr    %cl,%edx
    c1ea:	8b 45 10             	mov    0x10(%ebp),%eax
    c1ed:	89 10                	mov    %edx,(%eax)
    c1ef:	e9 ed 00 00 00       	jmp    c2e1 <lodepng_convert_rgb+0x29a>
  } else if(mode_out->colortype == LCT_PALETTE) {
    c1f4:	8b 45 20             	mov    0x20(%ebp),%eax
    c1f7:	8b 00                	mov    (%eax),%eax
    c1f9:	83 f8 03             	cmp    $0x3,%eax
    c1fc:	0f 85 d8 00 00 00    	jne    c2da <lodepng_convert_rgb+0x293>
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    c202:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c205:	c1 e8 08             	shr    $0x8,%eax
    c208:	89 c2                	mov    %eax,%edx
    c20a:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c20d:	0f b6 c0             	movzbl %al,%eax
    c210:	39 c2                	cmp    %eax,%edx
    c212:	75 24                	jne    c238 <lodepng_convert_rgb+0x1f1>
    c214:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c217:	c1 e8 08             	shr    $0x8,%eax
    c21a:	89 c2                	mov    %eax,%edx
    c21c:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c21f:	0f b6 c0             	movzbl %al,%eax
    c222:	39 c2                	cmp    %eax,%edx
    c224:	75 12                	jne    c238 <lodepng_convert_rgb+0x1f1>
    c226:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c229:	c1 e8 08             	shr    $0x8,%eax
    c22c:	89 c2                	mov    %eax,%edx
    c22e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c231:	0f b6 c0             	movzbl %al,%eax
    c234:	39 c2                	cmp    %eax,%edx
    c236:	74 0a                	je     c242 <lodepng_convert_rgb+0x1fb>
    c238:	b8 52 00 00 00       	mov    $0x52,%eax
    c23d:	e9 a4 00 00 00       	jmp    c2e6 <lodepng_convert_rgb+0x29f>
    for(i = 0; i < mode_out->palettesize; i++) {
    c242:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    c249:	eb 79                	jmp    c2c4 <lodepng_convert_rgb+0x27d>
      unsigned j = i * 4;
    c24b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    c24e:	c1 e0 02             	shl    $0x2,%eax
    c251:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c254:	8b 45 fc             	mov    -0x4(%ebp),%eax
    c257:	c1 e8 08             	shr    $0x8,%eax
    c25a:	89 c1                	mov    %eax,%ecx
    c25c:	8b 45 20             	mov    0x20(%ebp),%eax
    c25f:	8b 50 08             	mov    0x8(%eax),%edx
    c262:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    c265:	01 d0                	add    %edx,%eax
    c267:	0f b6 00             	movzbl (%eax),%eax
    c26a:	0f b6 c0             	movzbl %al,%eax
    c26d:	39 c1                	cmp    %eax,%ecx
    c26f:	75 4f                	jne    c2c0 <lodepng_convert_rgb+0x279>
    c271:	8b 45 f8             	mov    -0x8(%ebp),%eax
    c274:	c1 e8 08             	shr    $0x8,%eax
    c277:	89 c1                	mov    %eax,%ecx
    c279:	8b 45 20             	mov    0x20(%ebp),%eax
    c27c:	8b 40 08             	mov    0x8(%eax),%eax
    c27f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c282:	83 c2 01             	add    $0x1,%edx
    c285:	01 d0                	add    %edx,%eax
    c287:	0f b6 00             	movzbl (%eax),%eax
    c28a:	0f b6 c0             	movzbl %al,%eax
    c28d:	39 c1                	cmp    %eax,%ecx
    c28f:	75 2f                	jne    c2c0 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
    c291:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c294:	c1 e8 08             	shr    $0x8,%eax
    c297:	89 c1                	mov    %eax,%ecx
    c299:	8b 45 20             	mov    0x20(%ebp),%eax
    c29c:	8b 40 08             	mov    0x8(%eax),%eax
    c29f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    c2a2:	83 c2 02             	add    $0x2,%edx
    c2a5:	01 d0                	add    %edx,%eax
    c2a7:	0f b6 00             	movzbl (%eax),%eax
    c2aa:	0f b6 c0             	movzbl %al,%eax
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
      unsigned j = i * 4;
      if((r >> 8) == mode_out->palette[j + 0] && (g >> 8) == mode_out->palette[j + 1] &&
    c2ad:	39 c1                	cmp    %eax,%ecx
    c2af:	75 0f                	jne    c2c0 <lodepng_convert_rgb+0x279>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
    c2b1:	8b 45 08             	mov    0x8(%ebp),%eax
    c2b4:	8b 55 f0             	mov    -0x10(%ebp),%edx
    c2b7:	89 10                	mov    %edx,(%eax)
        return 0;
    c2b9:	b8 00 00 00 00       	mov    $0x0,%eax
    c2be:	eb 26                	jmp    c2e6 <lodepng_convert_rgb+0x29f>
    *b_out = b >> shift ;
  } else if(mode_out->colortype == LCT_PALETTE) {
    unsigned i;
    /* a 16-bit color cannot be in the palette */
    if((r >> 8) != (r & 255) || (g >> 8) != (g & 255) || (b >> 8) != (b & 255)) return 82;
    for(i = 0; i < mode_out->palettesize; i++) {
    c2c0:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    c2c4:	8b 45 20             	mov    0x20(%ebp),%eax
    c2c7:	8b 40 0c             	mov    0xc(%eax),%eax
    c2ca:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    c2cd:	0f 87 78 ff ff ff    	ja     c24b <lodepng_convert_rgb+0x204>
          (b >> 8) == mode_out->palette[j + 2]) {
        *r_out = i;
        return 0;
      }
    }
    return 82;
    c2d3:	b8 52 00 00 00       	mov    $0x52,%eax
    c2d8:	eb 0c                	jmp    c2e6 <lodepng_convert_rgb+0x29f>
  } else {
    return 31;
    c2da:	b8 1f 00 00 00       	mov    $0x1f,%eax
    c2df:	eb 05                	jmp    c2e6 <lodepng_convert_rgb+0x29f>
  }

  return 0;
    c2e1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    c2e6:	c9                   	leave  
    c2e7:	c3                   	ret    

0000c2e8 <lodepng_color_stats_init>:

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_stats_init(LodePNGColorStats* stats) {
    c2e8:	55                   	push   %ebp
    c2e9:	89 e5                	mov    %esp,%ebp
  /*stats*/
  stats->colored = 0;
    c2eb:	8b 45 08             	mov    0x8(%ebp),%eax
    c2ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  stats->key = 0;
    c2f4:	8b 45 08             	mov    0x8(%ebp),%eax
    c2f7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  stats->key_r = stats->key_g = stats->key_b = 0;
    c2fe:	8b 45 08             	mov    0x8(%ebp),%eax
    c301:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    c307:	8b 45 08             	mov    0x8(%ebp),%eax
    c30a:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c30e:	8b 45 08             	mov    0x8(%ebp),%eax
    c311:	66 89 50 0a          	mov    %dx,0xa(%eax)
    c315:	8b 45 08             	mov    0x8(%ebp),%eax
    c318:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c31c:	8b 45 08             	mov    0x8(%ebp),%eax
    c31f:	66 89 50 08          	mov    %dx,0x8(%eax)
  stats->alpha = 0;
    c323:	8b 45 08             	mov    0x8(%ebp),%eax
    c326:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  stats->numcolors = 0;
    c32d:	8b 45 08             	mov    0x8(%ebp),%eax
    c330:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  stats->bits = 1;
    c337:	8b 45 08             	mov    0x8(%ebp),%eax
    c33a:	c7 80 18 04 00 00 01 	movl   $0x1,0x418(%eax)
    c341:	00 00 00 
  stats->numpixels = 0;
    c344:	8b 45 08             	mov    0x8(%ebp),%eax
    c347:	c7 80 1c 04 00 00 00 	movl   $0x0,0x41c(%eax)
    c34e:	00 00 00 
  /*settings*/
  stats->allow_palette = 1;
    c351:	8b 45 08             	mov    0x8(%ebp),%eax
    c354:	c7 80 20 04 00 00 01 	movl   $0x1,0x420(%eax)
    c35b:	00 00 00 
  stats->allow_greyscale = 1;
    c35e:	8b 45 08             	mov    0x8(%ebp),%eax
    c361:	c7 80 24 04 00 00 01 	movl   $0x1,0x424(%eax)
    c368:	00 00 00 
}
    c36b:	90                   	nop
    c36c:	5d                   	pop    %ebp
    c36d:	c3                   	ret    

0000c36e <getValueRequiredBits>:
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value) {
    c36e:	55                   	push   %ebp
    c36f:	89 e5                	mov    %esp,%ebp
    c371:	53                   	push   %ebx
    c372:	83 ec 04             	sub    $0x4,%esp
    c375:	8b 45 08             	mov    0x8(%ebp),%eax
    c378:	88 45 f8             	mov    %al,-0x8(%ebp)
  if(value == 0 || value == 255) return 1;
    c37b:	80 7d f8 00          	cmpb   $0x0,-0x8(%ebp)
    c37f:	74 06                	je     c387 <getValueRequiredBits+0x19>
    c381:	80 7d f8 ff          	cmpb   $0xff,-0x8(%ebp)
    c385:	75 07                	jne    c38e <getValueRequiredBits+0x20>
    c387:	b8 01 00 00 00       	mov    $0x1,%eax
    c38c:	eb 6b                	jmp    c3f9 <getValueRequiredBits+0x8b>
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
    c38e:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c392:	0f b6 d9             	movzbl %cl,%ebx
    c395:	89 da                	mov    %ebx,%edx
    c397:	89 d0                	mov    %edx,%eax
    c399:	c1 e0 04             	shl    $0x4,%eax
    c39c:	89 c2                	mov    %eax,%edx
    c39e:	89 d0                	mov    %edx,%eax
    c3a0:	c1 e0 04             	shl    $0x4,%eax
    c3a3:	29 d0                	sub    %edx,%eax
    c3a5:	01 d8                	add    %ebx,%eax
    c3a7:	66 c1 e8 08          	shr    $0x8,%ax
    c3ab:	c0 e8 04             	shr    $0x4,%al
    c3ae:	89 c2                	mov    %eax,%edx
    c3b0:	c1 e2 04             	shl    $0x4,%edx
    c3b3:	01 c2                	add    %eax,%edx
    c3b5:	89 c8                	mov    %ecx,%eax
    c3b7:	29 d0                	sub    %edx,%eax
    c3b9:	84 c0                	test   %al,%al
    c3bb:	75 37                	jne    c3f4 <getValueRequiredBits+0x86>
    c3bd:	0f b6 4d f8          	movzbl -0x8(%ebp),%ecx
    c3c1:	0f b6 d1             	movzbl %cl,%edx
    c3c4:	89 d0                	mov    %edx,%eax
    c3c6:	01 c0                	add    %eax,%eax
    c3c8:	01 d0                	add    %edx,%eax
    c3ca:	c1 e0 06             	shl    $0x6,%eax
    c3cd:	01 d0                	add    %edx,%eax
    c3cf:	66 c1 e8 08          	shr    $0x8,%ax
    c3d3:	c0 e8 06             	shr    $0x6,%al
    c3d6:	ba 55 00 00 00       	mov    $0x55,%edx
    c3db:	0f af c2             	imul   %edx,%eax
    c3de:	29 c1                	sub    %eax,%ecx
    c3e0:	89 c8                	mov    %ecx,%eax
    c3e2:	84 c0                	test   %al,%al
    c3e4:	75 07                	jne    c3ed <getValueRequiredBits+0x7f>
    c3e6:	b8 02 00 00 00       	mov    $0x2,%eax
    c3eb:	eb 0c                	jmp    c3f9 <getValueRequiredBits+0x8b>
    c3ed:	b8 04 00 00 00       	mov    $0x4,%eax
    c3f2:	eb 05                	jmp    c3f9 <getValueRequiredBits+0x8b>
  return 8;
    c3f4:	b8 08 00 00 00       	mov    $0x8,%eax
}
    c3f9:	83 c4 04             	add    $0x4,%esp
    c3fc:	5b                   	pop    %ebx
    c3fd:	5d                   	pop    %ebp
    c3fe:	c3                   	ret    

0000c3ff <lodepng_compute_color_stats>:

/*stats must already have been inited. */
unsigned lodepng_compute_color_stats(LodePNGColorStats* stats,
                                     const unsigned char* in, unsigned w, unsigned h,
                                     const LodePNGColorMode* mode_in) {
    c3ff:	55                   	push   %ebp
    c400:	89 e5                	mov    %esp,%ebp
    c402:	56                   	push   %esi
    c403:	53                   	push   %ebx
    c404:	81 ec a0 00 00 00    	sub    $0xa0,%esp
  size_t i;
  ColorTree tree;
  size_t numpixels = (size_t)w * (size_t)h;
    c40a:	8b 55 10             	mov    0x10(%ebp),%edx
    c40d:	8b 45 14             	mov    0x14(%ebp),%eax
    c410:	0f af c2             	imul   %edx,%eax
    c413:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  unsigned error = 0;
    c416:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  /* mark things as done already if it would be impossible to have a more expensive case */
  unsigned colored_done = lodepng_is_greyscale_type(mode_in) ? 1 : 0;
    c41d:	ff 75 18             	pushl  0x18(%ebp)
    c420:	e8 0b cd ff ff       	call   9130 <lodepng_is_greyscale_type>
    c425:	83 c4 04             	add    $0x4,%esp
    c428:	85 c0                	test   %eax,%eax
    c42a:	0f 95 c0             	setne  %al
    c42d:	0f b6 c0             	movzbl %al,%eax
    c430:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned alpha_done = lodepng_can_have_alpha(mode_in) ? 0 : 1;
    c433:	ff 75 18             	pushl  0x18(%ebp)
    c436:	e8 85 cd ff ff       	call   91c0 <lodepng_can_have_alpha>
    c43b:	83 c4 04             	add    $0x4,%esp
    c43e:	85 c0                	test   %eax,%eax
    c440:	0f 94 c0             	sete   %al
    c443:	0f b6 c0             	movzbl %al,%eax
    c446:	89 45 e8             	mov    %eax,-0x18(%ebp)
  unsigned numcolors_done = 0;
    c449:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned bpp = lodepng_get_bpp(mode_in);
    c450:	ff 75 18             	pushl  0x18(%ebp)
    c453:	e8 ab cc ff ff       	call   9103 <lodepng_get_bpp>
    c458:	83 c4 04             	add    $0x4,%esp
    c45b:	89 45 d0             	mov    %eax,-0x30(%ebp)
  unsigned bits_done = (stats->bits == 1 && bpp == 1) ? 1 : 0;
    c45e:	8b 45 08             	mov    0x8(%ebp),%eax
    c461:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c467:	83 f8 01             	cmp    $0x1,%eax
    c46a:	75 0d                	jne    c479 <lodepng_compute_color_stats+0x7a>
    c46c:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
    c470:	75 07                	jne    c479 <lodepng_compute_color_stats+0x7a>
    c472:	b8 01 00 00 00       	mov    $0x1,%eax
    c477:	eb 05                	jmp    c47e <lodepng_compute_color_stats+0x7f>
    c479:	b8 00 00 00 00       	mov    $0x0,%eax
    c47e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned sixteen = 0; /* whether the input image is 16 bit */
    c481:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  unsigned maxnumcolors = 257;
    c488:	c7 45 d8 01 01 00 00 	movl   $0x101,-0x28(%ebp)
  if(bpp <= 8) maxnumcolors = LODEPNG_MIN(257, stats->numcolors + (1u << bpp));
    c48f:	83 7d d0 08          	cmpl   $0x8,-0x30(%ebp)
    c493:	77 26                	ja     c4bb <lodepng_compute_color_stats+0xbc>
    c495:	8b 45 08             	mov    0x8(%ebp),%eax
    c498:	8b 50 14             	mov    0x14(%eax),%edx
    c49b:	8b 45 d0             	mov    -0x30(%ebp),%eax
    c49e:	bb 01 00 00 00       	mov    $0x1,%ebx
    c4a3:	89 c1                	mov    %eax,%ecx
    c4a5:	d3 e3                	shl    %cl,%ebx
    c4a7:	89 d8                	mov    %ebx,%eax
    c4a9:	01 d0                	add    %edx,%eax
    c4ab:	ba 01 01 00 00       	mov    $0x101,%edx
    c4b0:	3d 01 01 00 00       	cmp    $0x101,%eax
    c4b5:	0f 47 c2             	cmova  %edx,%eax
    c4b8:	89 45 d8             	mov    %eax,-0x28(%ebp)

  stats->numpixels += numpixels;
    c4bb:	8b 45 08             	mov    0x8(%ebp),%eax
    c4be:	8b 90 1c 04 00 00    	mov    0x41c(%eax),%edx
    c4c4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    c4c7:	01 c2                	add    %eax,%edx
    c4c9:	8b 45 08             	mov    0x8(%ebp),%eax
    c4cc:	89 90 1c 04 00 00    	mov    %edx,0x41c(%eax)

  /*if palette not allowed, no need to compute numcolors*/
  if(!stats->allow_palette) numcolors_done = 1;
    c4d2:	8b 45 08             	mov    0x8(%ebp),%eax
    c4d5:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    c4db:	85 c0                	test   %eax,%eax
    c4dd:	75 07                	jne    c4e6 <lodepng_compute_color_stats+0xe7>
    c4df:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  color_tree_init(&tree);
    c4e6:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c4ec:	50                   	push   %eax
    c4ed:	e8 81 da ff ff       	call   9f73 <color_tree_init>
    c4f2:	83 c4 04             	add    $0x4,%esp

  /*If the stats was already filled in from previous data, fill its palette in tree
  and mark things as done already if we know they are the most expensive case already*/
  if(stats->alpha) alpha_done = 1;
    c4f5:	8b 45 08             	mov    0x8(%ebp),%eax
    c4f8:	8b 40 10             	mov    0x10(%eax),%eax
    c4fb:	85 c0                	test   %eax,%eax
    c4fd:	74 07                	je     c506 <lodepng_compute_color_stats+0x107>
    c4ff:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
  if(stats->colored) colored_done = 1;
    c506:	8b 45 08             	mov    0x8(%ebp),%eax
    c509:	8b 00                	mov    (%eax),%eax
    c50b:	85 c0                	test   %eax,%eax
    c50d:	74 07                	je     c516 <lodepng_compute_color_stats+0x117>
    c50f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
  if(stats->bits == 16) numcolors_done = 1;
    c516:	8b 45 08             	mov    0x8(%ebp),%eax
    c519:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c51f:	83 f8 10             	cmp    $0x10,%eax
    c522:	75 07                	jne    c52b <lodepng_compute_color_stats+0x12c>
    c524:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
  if(stats->bits >= bpp) bits_done = 1;
    c52b:	8b 45 08             	mov    0x8(%ebp),%eax
    c52e:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    c534:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    c537:	72 07                	jb     c540 <lodepng_compute_color_stats+0x141>
    c539:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;
    c540:	8b 45 08             	mov    0x8(%ebp),%eax
    c543:	8b 40 14             	mov    0x14(%eax),%eax
    c546:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    c549:	72 07                	jb     c552 <lodepng_compute_color_stats+0x153>
    c54b:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)

  if(!numcolors_done) {
    c552:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c556:	0f 85 82 00 00 00    	jne    c5de <lodepng_compute_color_stats+0x1df>
    for(i = 0; i < stats->numcolors; i++) {
    c55c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c563:	eb 6c                	jmp    c5d1 <lodepng_compute_color_stats+0x1d2>
      const unsigned char* color = &stats->palette[i * 4];
    c565:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c568:	c1 e0 02             	shl    $0x2,%eax
    c56b:	8d 50 10             	lea    0x10(%eax),%edx
    c56e:	8b 45 08             	mov    0x8(%ebp),%eax
    c571:	01 d0                	add    %edx,%eax
    c573:	83 c0 08             	add    $0x8,%eax
    c576:	89 45 cc             	mov    %eax,-0x34(%ebp)
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
    c579:	8b 75 f4             	mov    -0xc(%ebp),%esi
    c57c:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c57f:	83 c0 03             	add    $0x3,%eax
    c582:	0f b6 00             	movzbl (%eax),%eax
    c585:	0f b6 d8             	movzbl %al,%ebx
    c588:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c58b:	83 c0 02             	add    $0x2,%eax
    c58e:	0f b6 00             	movzbl (%eax),%eax
    c591:	0f b6 c8             	movzbl %al,%ecx
    c594:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c597:	83 c0 01             	add    $0x1,%eax
    c59a:	0f b6 00             	movzbl (%eax),%eax
    c59d:	0f b6 d0             	movzbl %al,%edx
    c5a0:	8b 45 cc             	mov    -0x34(%ebp),%eax
    c5a3:	0f b6 00             	movzbl (%eax),%eax
    c5a6:	0f b6 c0             	movzbl %al,%eax
    c5a9:	83 ec 08             	sub    $0x8,%esp
    c5ac:	56                   	push   %esi
    c5ad:	53                   	push   %ebx
    c5ae:	51                   	push   %ecx
    c5af:	52                   	push   %edx
    c5b0:	50                   	push   %eax
    c5b1:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    c5b7:	50                   	push   %eax
    c5b8:	e8 39 db ff ff       	call   a0f6 <color_tree_add>
    c5bd:	83 c4 20             	add    $0x20,%esp
    c5c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if(error) goto cleanup;
    c5c3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    c5c7:	0f 85 22 09 00 00    	jne    ceef <lodepng_compute_color_stats+0xaf0>
  if(stats->bits == 16) numcolors_done = 1;
  if(stats->bits >= bpp) bits_done = 1;
  if(stats->numcolors >= maxnumcolors) numcolors_done = 1;

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
    c5cd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c5d1:	8b 45 08             	mov    0x8(%ebp),%eax
    c5d4:	8b 50 14             	mov    0x14(%eax),%edx
    c5d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c5da:	39 c2                	cmp    %eax,%edx
    c5dc:	77 87                	ja     c565 <lodepng_compute_color_stats+0x166>
      if(error) goto cleanup;
    }
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    c5de:	8b 45 18             	mov    0x18(%ebp),%eax
    c5e1:	8b 40 04             	mov    0x4(%eax),%eax
    c5e4:	83 f8 10             	cmp    $0x10,%eax
    c5e7:	0f 85 1e 01 00 00    	jne    c70b <lodepng_compute_color_stats+0x30c>
    c5ed:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c5f1:	0f 85 14 01 00 00    	jne    c70b <lodepng_compute_color_stats+0x30c>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c5f7:	66 c7 85 72 ff ff ff 	movw   $0x0,-0x8e(%ebp)
    c5fe:	00 00 
    c600:	66 c7 85 70 ff ff ff 	movw   $0x0,-0x90(%ebp)
    c607:	00 00 
    c609:	66 c7 85 6e ff ff ff 	movw   $0x0,-0x92(%ebp)
    c610:	00 00 
    c612:	66 c7 85 6c ff ff ff 	movw   $0x0,-0x94(%ebp)
    c619:	00 00 
    for(i = 0; i != numpixels; ++i) {
    c61b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c622:	e9 d8 00 00 00       	jmp    c6ff <lodepng_compute_color_stats+0x300>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c627:	83 ec 04             	sub    $0x4,%esp
    c62a:	ff 75 18             	pushl  0x18(%ebp)
    c62d:	ff 75 f4             	pushl  -0xc(%ebp)
    c630:	ff 75 0c             	pushl  0xc(%ebp)
    c633:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
    c639:	50                   	push   %eax
    c63a:	8d 85 6e ff ff ff    	lea    -0x92(%ebp),%eax
    c640:	50                   	push   %eax
    c641:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
    c647:	50                   	push   %eax
    c648:	8d 85 72 ff ff ff    	lea    -0x8e(%ebp),%eax
    c64e:	50                   	push   %eax
    c64f:	e8 a8 f2 ff ff       	call   b8fc <getPixelColorRGBA16>
    c654:	83 c4 20             	add    $0x20,%esp
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c657:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c65e:	66 c1 e8 08          	shr    $0x8,%ax
    c662:	89 c2                	mov    %eax,%edx
    c664:	0f b7 85 72 ff ff ff 	movzwl -0x8e(%ebp),%eax
    c66b:	31 d0                	xor    %edx,%eax
    c66d:	0f b7 c0             	movzwl %ax,%eax
    c670:	0f b6 c0             	movzbl %al,%eax
    c673:	85 c0                	test   %eax,%eax
    c675:	75 60                	jne    c6d7 <lodepng_compute_color_stats+0x2d8>
    c677:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c67e:	66 c1 e8 08          	shr    $0x8,%ax
    c682:	89 c2                	mov    %eax,%edx
    c684:	0f b7 85 70 ff ff ff 	movzwl -0x90(%ebp),%eax
    c68b:	31 d0                	xor    %edx,%eax
    c68d:	0f b7 c0             	movzwl %ax,%eax
    c690:	0f b6 c0             	movzbl %al,%eax
    c693:	85 c0                	test   %eax,%eax
    c695:	75 40                	jne    c6d7 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c697:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c69e:	66 c1 e8 08          	shr    $0x8,%ax
    c6a2:	89 c2                	mov    %eax,%edx
    c6a4:	0f b7 85 6e ff ff ff 	movzwl -0x92(%ebp),%eax
    c6ab:	31 d0                	xor    %edx,%eax
    c6ad:	0f b7 c0             	movzwl %ax,%eax
    c6b0:	0f b6 c0             	movzbl %al,%eax
  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if((r & 255) != ((r >> 8) & 255) || (g & 255) != ((g >> 8) & 255) ||
    c6b3:	85 c0                	test   %eax,%eax
    c6b5:	75 20                	jne    c6d7 <lodepng_compute_color_stats+0x2d8>
         (b & 255) != ((b >> 8) & 255) || (a & 255) != ((a >> 8) & 255)) /*first and second byte differ*/ {
    c6b7:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c6be:	66 c1 e8 08          	shr    $0x8,%ax
    c6c2:	89 c2                	mov    %eax,%edx
    c6c4:	0f b7 85 6c ff ff ff 	movzwl -0x94(%ebp),%eax
    c6cb:	31 d0                	xor    %edx,%eax
    c6cd:	0f b7 c0             	movzwl %ax,%eax
    c6d0:	0f b6 c0             	movzbl %al,%eax
    c6d3:	85 c0                	test   %eax,%eax
    c6d5:	74 24                	je     c6fb <lodepng_compute_color_stats+0x2fc>
        stats->bits = 16;
    c6d7:	8b 45 08             	mov    0x8(%ebp),%eax
    c6da:	c7 80 18 04 00 00 10 	movl   $0x10,0x418(%eax)
    c6e1:	00 00 00 
        sixteen = 1;
    c6e4:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
        bits_done = 1;
    c6eb:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
        numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
    c6f2:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
        break;
    c6f9:	eb 10                	jmp    c70b <lodepng_compute_color_stats+0x30c>
  }

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode_in->bitdepth == 16 && !sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    c6fb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c6ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c702:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c705:	0f 85 1c ff ff ff    	jne    c627 <lodepng_compute_color_stats+0x228>
        break;
      }
    }
  }

  if(sixteen) {
    c70b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    c70f:	0f 84 bd 02 00 00    	je     c9d2 <lodepng_compute_color_stats+0x5d3>
    unsigned short r = 0, g = 0, b = 0, a = 0;
    c715:	66 c7 85 6a ff ff ff 	movw   $0x0,-0x96(%ebp)
    c71c:	00 00 
    c71e:	66 c7 85 68 ff ff ff 	movw   $0x0,-0x98(%ebp)
    c725:	00 00 
    c727:	66 c7 85 66 ff ff ff 	movw   $0x0,-0x9a(%ebp)
    c72e:	00 00 
    c730:	66 c7 85 64 ff ff ff 	movw   $0x0,-0x9c(%ebp)
    c737:	00 00 

    for(i = 0; i != numpixels; ++i) {
    c739:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c740:	e9 b1 01 00 00       	jmp    c8f6 <lodepng_compute_color_stats+0x4f7>
      getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c745:	83 ec 04             	sub    $0x4,%esp
    c748:	ff 75 18             	pushl  0x18(%ebp)
    c74b:	ff 75 f4             	pushl  -0xc(%ebp)
    c74e:	ff 75 0c             	pushl  0xc(%ebp)
    c751:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c757:	50                   	push   %eax
    c758:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c75e:	50                   	push   %eax
    c75f:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c765:	50                   	push   %eax
    c766:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c76c:	50                   	push   %eax
    c76d:	e8 8a f1 ff ff       	call   b8fc <getPixelColorRGBA16>
    c772:	83 c4 20             	add    $0x20,%esp

      if(!colored_done && (r != g || r != b)) {
    c775:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c779:	75 36                	jne    c7b1 <lodepng_compute_color_stats+0x3b2>
    c77b:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c782:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c789:	66 39 c2             	cmp    %ax,%dx
    c78c:	75 13                	jne    c7a1 <lodepng_compute_color_stats+0x3a2>
    c78e:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c795:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c79c:	66 39 c2             	cmp    %ax,%dx
    c79f:	74 10                	je     c7b1 <lodepng_compute_color_stats+0x3b2>
        stats->colored = 1;
    c7a1:	8b 45 08             	mov    0x8(%ebp),%eax
    c7a4:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    c7aa:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      }

      if(!alpha_done) {
    c7b1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c7b5:	0f 85 1f 01 00 00    	jne    c8da <lodepng_compute_color_stats+0x4db>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    c7bb:	8b 45 08             	mov    0x8(%ebp),%eax
    c7be:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c7c2:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c7c9:	66 39 c2             	cmp    %ax,%dx
    c7cc:	75 2d                	jne    c7fb <lodepng_compute_color_stats+0x3fc>
    c7ce:	8b 45 08             	mov    0x8(%ebp),%eax
    c7d1:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c7d5:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c7dc:	66 39 c2             	cmp    %ax,%dx
    c7df:	75 1a                	jne    c7fb <lodepng_compute_color_stats+0x3fc>
    c7e1:	8b 45 08             	mov    0x8(%ebp),%eax
    c7e4:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c7e8:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c7ef:	66 39 c2             	cmp    %ax,%dx
    c7f2:	75 07                	jne    c7fb <lodepng_compute_color_stats+0x3fc>
    c7f4:	b8 01 00 00 00       	mov    $0x1,%eax
    c7f9:	eb 05                	jmp    c800 <lodepng_compute_color_stats+0x401>
    c7fb:	b8 00 00 00 00       	mov    $0x0,%eax
    c800:	89 45 c8             	mov    %eax,-0x38(%ebp)
        if(a != 65535 && (a != 0 || (stats->key && !matchkey))) {
    c803:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c80a:	66 83 f8 ff          	cmp    $0xffff,%ax
    c80e:	74 3c                	je     c84c <lodepng_compute_color_stats+0x44d>
    c810:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c817:	66 85 c0             	test   %ax,%ax
    c81a:	75 10                	jne    c82c <lodepng_compute_color_stats+0x42d>
    c81c:	8b 45 08             	mov    0x8(%ebp),%eax
    c81f:	8b 40 04             	mov    0x4(%eax),%eax
    c822:	85 c0                	test   %eax,%eax
    c824:	74 26                	je     c84c <lodepng_compute_color_stats+0x44d>
    c826:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c82a:	75 20                	jne    c84c <lodepng_compute_color_stats+0x44d>
          stats->alpha = 1;
    c82c:	8b 45 08             	mov    0x8(%ebp),%eax
    c82f:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c836:	8b 45 08             	mov    0x8(%ebp),%eax
    c839:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c840:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
    c847:	e9 8e 00 00 00       	jmp    c8da <lodepng_compute_color_stats+0x4db>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    c84c:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c853:	66 85 c0             	test   %ax,%ax
    c856:	75 4a                	jne    c8a2 <lodepng_compute_color_stats+0x4a3>
    c858:	8b 45 08             	mov    0x8(%ebp),%eax
    c85b:	8b 40 10             	mov    0x10(%eax),%eax
    c85e:	85 c0                	test   %eax,%eax
    c860:	75 40                	jne    c8a2 <lodepng_compute_color_stats+0x4a3>
    c862:	8b 45 08             	mov    0x8(%ebp),%eax
    c865:	8b 40 04             	mov    0x4(%eax),%eax
    c868:	85 c0                	test   %eax,%eax
    c86a:	75 36                	jne    c8a2 <lodepng_compute_color_stats+0x4a3>
          stats->key = 1;
    c86c:	8b 45 08             	mov    0x8(%ebp),%eax
    c86f:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    c876:	0f b7 95 6a ff ff ff 	movzwl -0x96(%ebp),%edx
    c87d:	8b 45 08             	mov    0x8(%ebp),%eax
    c880:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    c884:	0f b7 95 68 ff ff ff 	movzwl -0x98(%ebp),%edx
    c88b:	8b 45 08             	mov    0x8(%ebp),%eax
    c88e:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    c892:	0f b7 95 66 ff ff ff 	movzwl -0x9a(%ebp),%edx
    c899:	8b 45 08             	mov    0x8(%ebp),%eax
    c89c:	66 89 50 0c          	mov    %dx,0xc(%eax)
    c8a0:	eb 38                	jmp    c8da <lodepng_compute_color_stats+0x4db>
        } else if(a == 65535 && stats->key && matchkey) {
    c8a2:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c8a9:	66 83 f8 ff          	cmp    $0xffff,%ax
    c8ad:	75 2b                	jne    c8da <lodepng_compute_color_stats+0x4db>
    c8af:	8b 45 08             	mov    0x8(%ebp),%eax
    c8b2:	8b 40 04             	mov    0x4(%eax),%eax
    c8b5:	85 c0                	test   %eax,%eax
    c8b7:	74 21                	je     c8da <lodepng_compute_color_stats+0x4db>
    c8b9:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
    c8bd:	74 1b                	je     c8da <lodepng_compute_color_stats+0x4db>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c8bf:	8b 45 08             	mov    0x8(%ebp),%eax
    c8c2:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c8c9:	8b 45 08             	mov    0x8(%ebp),%eax
    c8cc:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c8d3:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c8da:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    c8de:	74 12                	je     c8f2 <lodepng_compute_color_stats+0x4f3>
    c8e0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    c8e4:	74 0c                	je     c8f2 <lodepng_compute_color_stats+0x4f3>
    c8e6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    c8ea:	74 06                	je     c8f2 <lodepng_compute_color_stats+0x4f3>
    c8ec:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    c8f0:	75 12                	jne    c904 <lodepng_compute_color_stats+0x505>
  }

  if(sixteen) {
    unsigned short r = 0, g = 0, b = 0, a = 0;

    for(i = 0; i != numpixels; ++i) {
    c8f2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c8f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c8f9:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c8fc:	0f 85 43 fe ff ff    	jne    c745 <lodepng_compute_color_stats+0x346>
    c902:	eb 01                	jmp    c905 <lodepng_compute_color_stats+0x506>
          stats->alpha = 1;
          stats->key = 0;
          alpha_done = 1;
        }
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    c904:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    c905:	8b 45 08             	mov    0x8(%ebp),%eax
    c908:	8b 40 04             	mov    0x4(%eax),%eax
    c90b:	85 c0                	test   %eax,%eax
    c90d:	0f 84 e0 05 00 00    	je     cef3 <lodepng_compute_color_stats+0xaf4>
    c913:	8b 45 08             	mov    0x8(%ebp),%eax
    c916:	8b 40 10             	mov    0x10(%eax),%eax
    c919:	85 c0                	test   %eax,%eax
    c91b:	0f 85 d2 05 00 00    	jne    cef3 <lodepng_compute_color_stats+0xaf4>
      for(i = 0; i != numpixels; ++i) {
    c921:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c928:	e9 94 00 00 00       	jmp    c9c1 <lodepng_compute_color_stats+0x5c2>
        getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
    c92d:	83 ec 04             	sub    $0x4,%esp
    c930:	ff 75 18             	pushl  0x18(%ebp)
    c933:	ff 75 f4             	pushl  -0xc(%ebp)
    c936:	ff 75 0c             	pushl  0xc(%ebp)
    c939:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
    c93f:	50                   	push   %eax
    c940:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
    c946:	50                   	push   %eax
    c947:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    c94d:	50                   	push   %eax
    c94e:	8d 85 6a ff ff ff    	lea    -0x96(%ebp),%eax
    c954:	50                   	push   %eax
    c955:	e8 a2 ef ff ff       	call   b8fc <getPixelColorRGBA16>
    c95a:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    c95d:	0f b7 85 64 ff ff ff 	movzwl -0x9c(%ebp),%eax
    c964:	66 85 c0             	test   %ax,%ax
    c967:	74 54                	je     c9bd <lodepng_compute_color_stats+0x5be>
    c969:	8b 45 08             	mov    0x8(%ebp),%eax
    c96c:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    c970:	0f b7 85 6a ff ff ff 	movzwl -0x96(%ebp),%eax
    c977:	66 39 c2             	cmp    %ax,%dx
    c97a:	75 41                	jne    c9bd <lodepng_compute_color_stats+0x5be>
    c97c:	8b 45 08             	mov    0x8(%ebp),%eax
    c97f:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    c983:	0f b7 85 68 ff ff ff 	movzwl -0x98(%ebp),%eax
    c98a:	66 39 c2             	cmp    %ax,%dx
    c98d:	75 2e                	jne    c9bd <lodepng_compute_color_stats+0x5be>
    c98f:	8b 45 08             	mov    0x8(%ebp),%eax
    c992:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    c996:	0f b7 85 66 ff ff ff 	movzwl -0x9a(%ebp),%eax
    c99d:	66 39 c2             	cmp    %ax,%dx
    c9a0:	75 1b                	jne    c9bd <lodepng_compute_color_stats+0x5be>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    c9a2:	8b 45 08             	mov    0x8(%ebp),%eax
    c9a5:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    c9ac:	8b 45 08             	mov    0x8(%ebp),%eax
    c9af:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    c9b6:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
      }
      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    c9bd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    c9c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
    c9c4:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    c9c7:	0f 85 60 ff ff ff    	jne    c92d <lodepng_compute_color_stats+0x52e>
    c9cd:	e9 21 05 00 00       	jmp    cef3 <lodepng_compute_color_stats+0xaf4>
          alpha_done = 1;
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    c9d2:	c6 85 63 ff ff ff 00 	movb   $0x0,-0x9d(%ebp)
    c9d9:	c6 85 62 ff ff ff 00 	movb   $0x0,-0x9e(%ebp)
    c9e0:	c6 85 61 ff ff ff 00 	movb   $0x0,-0x9f(%ebp)
    c9e7:	c6 85 60 ff ff ff 00 	movb   $0x0,-0xa0(%ebp)
    for(i = 0; i != numpixels; ++i) {
    c9ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    c9f5:	e9 ab 03 00 00       	jmp    cda5 <lodepng_compute_color_stats+0x9a6>
      getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    c9fa:	83 ec 04             	sub    $0x4,%esp
    c9fd:	ff 75 18             	pushl  0x18(%ebp)
    ca00:	ff 75 f4             	pushl  -0xc(%ebp)
    ca03:	ff 75 0c             	pushl  0xc(%ebp)
    ca06:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    ca0c:	50                   	push   %eax
    ca0d:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    ca13:	50                   	push   %eax
    ca14:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    ca1a:	50                   	push   %eax
    ca1b:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    ca21:	50                   	push   %eax
    ca22:	e8 1e de ff ff       	call   a845 <getPixelColorRGBA8>
    ca27:	83 c4 20             	add    $0x20,%esp

      if(!bits_done && stats->bits < 8) {
    ca2a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ca2e:	75 41                	jne    ca71 <lodepng_compute_color_stats+0x672>
    ca30:	8b 45 08             	mov    0x8(%ebp),%eax
    ca33:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ca39:	83 f8 07             	cmp    $0x7,%eax
    ca3c:	77 33                	ja     ca71 <lodepng_compute_color_stats+0x672>
        /*only r is checked, < 8 bits is only relevant for grayscale*/
        unsigned bits = getValueRequiredBits(r);
    ca3e:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ca45:	0f b6 c0             	movzbl %al,%eax
    ca48:	83 ec 0c             	sub    $0xc,%esp
    ca4b:	50                   	push   %eax
    ca4c:	e8 1d f9 ff ff       	call   c36e <getValueRequiredBits>
    ca51:	83 c4 10             	add    $0x10,%esp
    ca54:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        if(bits > stats->bits) stats->bits = bits;
    ca57:	8b 45 08             	mov    0x8(%ebp),%eax
    ca5a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ca60:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
    ca63:	73 0c                	jae    ca71 <lodepng_compute_color_stats+0x672>
    ca65:	8b 45 08             	mov    0x8(%ebp),%eax
    ca68:	8b 55 c4             	mov    -0x3c(%ebp),%edx
    ca6b:	89 90 18 04 00 00    	mov    %edx,0x418(%eax)
      }
      bits_done = (stats->bits >= bpp);
    ca71:	8b 45 08             	mov    0x8(%ebp),%eax
    ca74:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ca7a:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    ca7d:	0f 93 c0             	setae  %al
    ca80:	0f b6 c0             	movzbl %al,%eax
    ca83:	89 45 e0             	mov    %eax,-0x20(%ebp)

      if(!colored_done && (r != g || r != b)) {
    ca86:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ca8a:	75 4f                	jne    cadb <lodepng_compute_color_stats+0x6dc>
    ca8c:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    ca93:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ca9a:	38 c2                	cmp    %al,%dl
    ca9c:	75 12                	jne    cab0 <lodepng_compute_color_stats+0x6b1>
    ca9e:	0f b6 95 63 ff ff ff 	movzbl -0x9d(%ebp),%edx
    caa5:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    caac:	38 c2                	cmp    %al,%dl
    caae:	74 2b                	je     cadb <lodepng_compute_color_stats+0x6dc>
        stats->colored = 1;
    cab0:	8b 45 08             	mov    0x8(%ebp),%eax
    cab3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        colored_done = 1;
    cab9:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
        if(stats->bits < 8) stats->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
    cac0:	8b 45 08             	mov    0x8(%ebp),%eax
    cac3:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cac9:	83 f8 07             	cmp    $0x7,%eax
    cacc:	77 0d                	ja     cadb <lodepng_compute_color_stats+0x6dc>
    cace:	8b 45 08             	mov    0x8(%ebp),%eax
    cad1:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cad8:	00 00 00 
      }

      if(!alpha_done) {
    cadb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cadf:	0f 85 65 01 00 00    	jne    cc4a <lodepng_compute_color_stats+0x84b>
        unsigned matchkey = (r == stats->key_r && g == stats->key_g && b == stats->key_b);
    cae5:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    caec:	0f b6 d0             	movzbl %al,%edx
    caef:	8b 45 08             	mov    0x8(%ebp),%eax
    caf2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    caf6:	66 39 c2             	cmp    %ax,%dx
    caf9:	75 33                	jne    cb2e <lodepng_compute_color_stats+0x72f>
    cafb:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cb02:	0f b6 d0             	movzbl %al,%edx
    cb05:	8b 45 08             	mov    0x8(%ebp),%eax
    cb08:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cb0c:	66 39 c2             	cmp    %ax,%dx
    cb0f:	75 1d                	jne    cb2e <lodepng_compute_color_stats+0x72f>
    cb11:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cb18:	0f b6 d0             	movzbl %al,%edx
    cb1b:	8b 45 08             	mov    0x8(%ebp),%eax
    cb1e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cb22:	66 39 c2             	cmp    %ax,%dx
    cb25:	75 07                	jne    cb2e <lodepng_compute_color_stats+0x72f>
    cb27:	b8 01 00 00 00       	mov    $0x1,%eax
    cb2c:	eb 05                	jmp    cb33 <lodepng_compute_color_stats+0x734>
    cb2e:	b8 00 00 00 00       	mov    $0x0,%eax
    cb33:	89 45 c0             	mov    %eax,-0x40(%ebp)
        if(a != 255 && (a != 0 || (stats->key && !matchkey))) {
    cb36:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cb3d:	3c ff                	cmp    $0xff,%al
    cb3f:	74 5a                	je     cb9b <lodepng_compute_color_stats+0x79c>
    cb41:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cb48:	84 c0                	test   %al,%al
    cb4a:	75 10                	jne    cb5c <lodepng_compute_color_stats+0x75d>
    cb4c:	8b 45 08             	mov    0x8(%ebp),%eax
    cb4f:	8b 40 04             	mov    0x4(%eax),%eax
    cb52:	85 c0                	test   %eax,%eax
    cb54:	74 45                	je     cb9b <lodepng_compute_color_stats+0x79c>
    cb56:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    cb5a:	75 3f                	jne    cb9b <lodepng_compute_color_stats+0x79c>
          stats->alpha = 1;
    cb5c:	8b 45 08             	mov    0x8(%ebp),%eax
    cb5f:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cb66:	8b 45 08             	mov    0x8(%ebp),%eax
    cb69:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cb70:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cb77:	8b 45 08             	mov    0x8(%ebp),%eax
    cb7a:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cb80:	83 f8 07             	cmp    $0x7,%eax
    cb83:	0f 87 c1 00 00 00    	ja     cc4a <lodepng_compute_color_stats+0x84b>
    cb89:	8b 45 08             	mov    0x8(%ebp),%eax
    cb8c:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cb93:	00 00 00 
    cb96:	e9 af 00 00 00       	jmp    cc4a <lodepng_compute_color_stats+0x84b>
        } else if(a == 0 && !stats->alpha && !stats->key) {
    cb9b:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cba2:	84 c0                	test   %al,%al
    cba4:	75 53                	jne    cbf9 <lodepng_compute_color_stats+0x7fa>
    cba6:	8b 45 08             	mov    0x8(%ebp),%eax
    cba9:	8b 40 10             	mov    0x10(%eax),%eax
    cbac:	85 c0                	test   %eax,%eax
    cbae:	75 49                	jne    cbf9 <lodepng_compute_color_stats+0x7fa>
    cbb0:	8b 45 08             	mov    0x8(%ebp),%eax
    cbb3:	8b 40 04             	mov    0x4(%eax),%eax
    cbb6:	85 c0                	test   %eax,%eax
    cbb8:	75 3f                	jne    cbf9 <lodepng_compute_color_stats+0x7fa>
          stats->key = 1;
    cbba:	8b 45 08             	mov    0x8(%ebp),%eax
    cbbd:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
          stats->key_r = r;
    cbc4:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cbcb:	0f b6 d0             	movzbl %al,%edx
    cbce:	8b 45 08             	mov    0x8(%ebp),%eax
    cbd1:	66 89 50 08          	mov    %dx,0x8(%eax)
          stats->key_g = g;
    cbd5:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cbdc:	0f b6 d0             	movzbl %al,%edx
    cbdf:	8b 45 08             	mov    0x8(%ebp),%eax
    cbe2:	66 89 50 0a          	mov    %dx,0xa(%eax)
          stats->key_b = b;
    cbe6:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cbed:	0f b6 d0             	movzbl %al,%edx
    cbf0:	8b 45 08             	mov    0x8(%ebp),%eax
    cbf3:	66 89 50 0c          	mov    %dx,0xc(%eax)
    cbf7:	eb 51                	jmp    cc4a <lodepng_compute_color_stats+0x84b>
        } else if(a == 255 && stats->key && matchkey) {
    cbf9:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cc00:	3c ff                	cmp    $0xff,%al
    cc02:	75 46                	jne    cc4a <lodepng_compute_color_stats+0x84b>
    cc04:	8b 45 08             	mov    0x8(%ebp),%eax
    cc07:	8b 40 04             	mov    0x4(%eax),%eax
    cc0a:	85 c0                	test   %eax,%eax
    cc0c:	74 3c                	je     cc4a <lodepng_compute_color_stats+0x84b>
    cc0e:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
    cc12:	74 36                	je     cc4a <lodepng_compute_color_stats+0x84b>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    cc14:	8b 45 08             	mov    0x8(%ebp),%eax
    cc17:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    cc1e:	8b 45 08             	mov    0x8(%ebp),%eax
    cc21:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    cc28:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    cc2f:	8b 45 08             	mov    0x8(%ebp),%eax
    cc32:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cc38:	83 f8 07             	cmp    $0x7,%eax
    cc3b:	77 0d                	ja     cc4a <lodepng_compute_color_stats+0x84b>
    cc3d:	8b 45 08             	mov    0x8(%ebp),%eax
    cc40:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    cc47:	00 00 00 
        }
      }

      if(!numcolors_done) {
    cc4a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cc4e:	0f 85 35 01 00 00    	jne    cd89 <lodepng_compute_color_stats+0x98a>
        if(!color_tree_has(&tree, r, g, b, a)) {
    cc54:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cc5b:	0f b6 d8             	movzbl %al,%ebx
    cc5e:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cc65:	0f b6 c8             	movzbl %al,%ecx
    cc68:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cc6f:	0f b6 d0             	movzbl %al,%edx
    cc72:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cc79:	0f b6 c0             	movzbl %al,%eax
    cc7c:	83 ec 0c             	sub    $0xc,%esp
    cc7f:	53                   	push   %ebx
    cc80:	51                   	push   %ecx
    cc81:	52                   	push   %edx
    cc82:	50                   	push   %eax
    cc83:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cc89:	50                   	push   %eax
    cc8a:	e8 1c d4 ff ff       	call   a0ab <color_tree_has>
    cc8f:	83 c4 20             	add    $0x20,%esp
    cc92:	85 c0                	test   %eax,%eax
    cc94:	0f 85 ef 00 00 00    	jne    cd89 <lodepng_compute_color_stats+0x98a>
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
    cc9a:	8b 45 08             	mov    0x8(%ebp),%eax
    cc9d:	8b 70 14             	mov    0x14(%eax),%esi
    cca0:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cca7:	0f b6 d8             	movzbl %al,%ebx
    ccaa:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ccb1:	0f b6 c8             	movzbl %al,%ecx
    ccb4:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ccbb:	0f b6 d0             	movzbl %al,%edx
    ccbe:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ccc5:	0f b6 c0             	movzbl %al,%eax
    ccc8:	83 ec 08             	sub    $0x8,%esp
    cccb:	56                   	push   %esi
    cccc:	53                   	push   %ebx
    cccd:	51                   	push   %ecx
    ccce:	52                   	push   %edx
    cccf:	50                   	push   %eax
    ccd0:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    ccd6:	50                   	push   %eax
    ccd7:	e8 1a d4 ff ff       	call   a0f6 <color_tree_add>
    ccdc:	83 c4 20             	add    $0x20,%esp
    ccdf:	89 45 f0             	mov    %eax,-0x10(%ebp)
          if(error) goto cleanup;
    cce2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    cce6:	0f 85 06 02 00 00    	jne    cef2 <lodepng_compute_color_stats+0xaf3>
          if(stats->numcolors < 256) {
    ccec:	8b 45 08             	mov    0x8(%ebp),%eax
    ccef:	8b 40 14             	mov    0x14(%eax),%eax
    ccf2:	3d ff 00 00 00       	cmp    $0xff,%eax
    ccf7:	77 6f                	ja     cd68 <lodepng_compute_color_stats+0x969>
            unsigned char* p = stats->palette;
    ccf9:	8b 45 08             	mov    0x8(%ebp),%eax
    ccfc:	83 c0 18             	add    $0x18,%eax
    ccff:	89 45 bc             	mov    %eax,-0x44(%ebp)
            unsigned n = stats->numcolors;
    cd02:	8b 45 08             	mov    0x8(%ebp),%eax
    cd05:	8b 40 14             	mov    0x14(%eax),%eax
    cd08:	89 45 b8             	mov    %eax,-0x48(%ebp)
            p[n * 4 + 0] = r;
    cd0b:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cd0e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    cd15:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cd18:	01 c2                	add    %eax,%edx
    cd1a:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    cd21:	88 02                	mov    %al,(%edx)
            p[n * 4 + 1] = g;
    cd23:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cd26:	c1 e0 02             	shl    $0x2,%eax
    cd29:	8d 50 01             	lea    0x1(%eax),%edx
    cd2c:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cd2f:	01 c2                	add    %eax,%edx
    cd31:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    cd38:	88 02                	mov    %al,(%edx)
            p[n * 4 + 2] = b;
    cd3a:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cd3d:	c1 e0 02             	shl    $0x2,%eax
    cd40:	8d 50 02             	lea    0x2(%eax),%edx
    cd43:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cd46:	01 c2                	add    %eax,%edx
    cd48:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    cd4f:	88 02                	mov    %al,(%edx)
            p[n * 4 + 3] = a;
    cd51:	8b 45 b8             	mov    -0x48(%ebp),%eax
    cd54:	c1 e0 02             	shl    $0x2,%eax
    cd57:	8d 50 03             	lea    0x3(%eax),%edx
    cd5a:	8b 45 bc             	mov    -0x44(%ebp),%eax
    cd5d:	01 c2                	add    %eax,%edx
    cd5f:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    cd66:	88 02                	mov    %al,(%edx)
          }
          ++stats->numcolors;
    cd68:	8b 45 08             	mov    0x8(%ebp),%eax
    cd6b:	8b 40 14             	mov    0x14(%eax),%eax
    cd6e:	8d 50 01             	lea    0x1(%eax),%edx
    cd71:	8b 45 08             	mov    0x8(%ebp),%eax
    cd74:	89 50 14             	mov    %edx,0x14(%eax)
          numcolors_done = stats->numcolors >= maxnumcolors;
    cd77:	8b 45 08             	mov    0x8(%ebp),%eax
    cd7a:	8b 40 14             	mov    0x14(%eax),%eax
    cd7d:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    cd80:	0f 93 c0             	setae  %al
    cd83:	0f b6 c0             	movzbl %al,%eax
    cd86:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cd89:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    cd8d:	74 12                	je     cda1 <lodepng_compute_color_stats+0x9a2>
    cd8f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    cd93:	74 0c                	je     cda1 <lodepng_compute_color_stats+0x9a2>
    cd95:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    cd99:	74 06                	je     cda1 <lodepng_compute_color_stats+0x9a2>
    cd9b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cd9f:	75 12                	jne    cdb3 <lodepng_compute_color_stats+0x9b4>
        }
      }
    }
  } else /* < 16-bit */ {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i != numpixels; ++i) {
    cda1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    cda5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    cda8:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    cdab:	0f 85 49 fc ff ff    	jne    c9fa <lodepng_compute_color_stats+0x5fb>
    cdb1:	eb 01                	jmp    cdb4 <lodepng_compute_color_stats+0x9b5>
          ++stats->numcolors;
          numcolors_done = stats->numcolors >= maxnumcolors;
        }
      }

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    cdb3:	90                   	nop
    }

    if(stats->key && !stats->alpha) {
    cdb4:	8b 45 08             	mov    0x8(%ebp),%eax
    cdb7:	8b 40 04             	mov    0x4(%eax),%eax
    cdba:	85 c0                	test   %eax,%eax
    cdbc:	0f 84 dd 00 00 00    	je     ce9f <lodepng_compute_color_stats+0xaa0>
    cdc2:	8b 45 08             	mov    0x8(%ebp),%eax
    cdc5:	8b 40 10             	mov    0x10(%eax),%eax
    cdc8:	85 c0                	test   %eax,%eax
    cdca:	0f 85 cf 00 00 00    	jne    ce9f <lodepng_compute_color_stats+0xaa0>
      for(i = 0; i != numpixels; ++i) {
    cdd0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cdd7:	e9 b7 00 00 00       	jmp    ce93 <lodepng_compute_color_stats+0xa94>
        getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
    cddc:	83 ec 04             	sub    $0x4,%esp
    cddf:	ff 75 18             	pushl  0x18(%ebp)
    cde2:	ff 75 f4             	pushl  -0xc(%ebp)
    cde5:	ff 75 0c             	pushl  0xc(%ebp)
    cde8:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
    cdee:	50                   	push   %eax
    cdef:	8d 85 61 ff ff ff    	lea    -0x9f(%ebp),%eax
    cdf5:	50                   	push   %eax
    cdf6:	8d 85 62 ff ff ff    	lea    -0x9e(%ebp),%eax
    cdfc:	50                   	push   %eax
    cdfd:	8d 85 63 ff ff ff    	lea    -0x9d(%ebp),%eax
    ce03:	50                   	push   %eax
    ce04:	e8 3c da ff ff       	call   a845 <getPixelColorRGBA8>
    ce09:	83 c4 20             	add    $0x20,%esp
        if(a != 0 && r == stats->key_r && g == stats->key_g && b == stats->key_b) {
    ce0c:	0f b6 85 60 ff ff ff 	movzbl -0xa0(%ebp),%eax
    ce13:	84 c0                	test   %al,%al
    ce15:	74 78                	je     ce8f <lodepng_compute_color_stats+0xa90>
    ce17:	0f b6 85 63 ff ff ff 	movzbl -0x9d(%ebp),%eax
    ce1e:	0f b6 d0             	movzbl %al,%edx
    ce21:	8b 45 08             	mov    0x8(%ebp),%eax
    ce24:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    ce28:	66 39 c2             	cmp    %ax,%dx
    ce2b:	75 62                	jne    ce8f <lodepng_compute_color_stats+0xa90>
    ce2d:	0f b6 85 62 ff ff ff 	movzbl -0x9e(%ebp),%eax
    ce34:	0f b6 d0             	movzbl %al,%edx
    ce37:	8b 45 08             	mov    0x8(%ebp),%eax
    ce3a:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    ce3e:	66 39 c2             	cmp    %ax,%dx
    ce41:	75 4c                	jne    ce8f <lodepng_compute_color_stats+0xa90>
    ce43:	0f b6 85 61 ff ff ff 	movzbl -0x9f(%ebp),%eax
    ce4a:	0f b6 d0             	movzbl %al,%edx
    ce4d:	8b 45 08             	mov    0x8(%ebp),%eax
    ce50:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    ce54:	66 39 c2             	cmp    %ax,%dx
    ce57:	75 36                	jne    ce8f <lodepng_compute_color_stats+0xa90>
          /* Color key cannot be used if an opaque pixel also has that RGB color. */
          stats->alpha = 1;
    ce59:	8b 45 08             	mov    0x8(%ebp),%eax
    ce5c:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
          stats->key = 0;
    ce63:	8b 45 08             	mov    0x8(%ebp),%eax
    ce66:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
          alpha_done = 1;
    ce6d:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
          if(stats->bits < 8) stats->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    ce74:	8b 45 08             	mov    0x8(%ebp),%eax
    ce77:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    ce7d:	83 f8 07             	cmp    $0x7,%eax
    ce80:	77 0d                	ja     ce8f <lodepng_compute_color_stats+0xa90>
    ce82:	8b 45 08             	mov    0x8(%ebp),%eax
    ce85:	c7 80 18 04 00 00 08 	movl   $0x8,0x418(%eax)
    ce8c:	00 00 00 

      if(alpha_done && numcolors_done && colored_done && bits_done) break;
    }

    if(stats->key && !stats->alpha) {
      for(i = 0; i != numpixels; ++i) {
    ce8f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    ce93:	8b 45 f4             	mov    -0xc(%ebp),%eax
    ce96:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
    ce99:	0f 85 3d ff ff ff    	jne    cddc <lodepng_compute_color_stats+0x9dd>
        }
      }
    }

    /*make the stats's key always 16-bit for consistency - repeat each byte twice*/
    stats->key_r += (stats->key_r << 8);
    ce9f:	8b 45 08             	mov    0x8(%ebp),%eax
    cea2:	0f b7 50 08          	movzwl 0x8(%eax),%edx
    cea6:	8b 45 08             	mov    0x8(%ebp),%eax
    cea9:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    cead:	c1 e0 08             	shl    $0x8,%eax
    ceb0:	01 c2                	add    %eax,%edx
    ceb2:	8b 45 08             	mov    0x8(%ebp),%eax
    ceb5:	66 89 50 08          	mov    %dx,0x8(%eax)
    stats->key_g += (stats->key_g << 8);
    ceb9:	8b 45 08             	mov    0x8(%ebp),%eax
    cebc:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
    cec0:	8b 45 08             	mov    0x8(%ebp),%eax
    cec3:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    cec7:	c1 e0 08             	shl    $0x8,%eax
    ceca:	01 c2                	add    %eax,%edx
    cecc:	8b 45 08             	mov    0x8(%ebp),%eax
    cecf:	66 89 50 0a          	mov    %dx,0xa(%eax)
    stats->key_b += (stats->key_b << 8);
    ced3:	8b 45 08             	mov    0x8(%ebp),%eax
    ced6:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
    ceda:	8b 45 08             	mov    0x8(%ebp),%eax
    cedd:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    cee1:	c1 e0 08             	shl    $0x8,%eax
    cee4:	01 c2                	add    %eax,%edx
    cee6:	8b 45 08             	mov    0x8(%ebp),%eax
    cee9:	66 89 50 0c          	mov    %dx,0xc(%eax)
    ceed:	eb 04                	jmp    cef3 <lodepng_compute_color_stats+0xaf4>

  if(!numcolors_done) {
    for(i = 0; i < stats->numcolors; i++) {
      const unsigned char* color = &stats->palette[i * 4];
      error = color_tree_add(&tree, color[0], color[1], color[2], color[3], i);
      if(error) goto cleanup;
    ceef:	90                   	nop
    cef0:	eb 01                	jmp    cef3 <lodepng_compute_color_stats+0xaf4>
      }

      if(!numcolors_done) {
        if(!color_tree_has(&tree, r, g, b, a)) {
          error = color_tree_add(&tree, r, g, b, a, stats->numcolors);
          if(error) goto cleanup;
    cef2:	90                   	nop
    stats->key_g += (stats->key_g << 8);
    stats->key_b += (stats->key_b << 8);
  }

cleanup:
  color_tree_cleanup(&tree);
    cef3:	83 ec 0c             	sub    $0xc,%esp
    cef6:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    cefc:	50                   	push   %eax
    cefd:	e8 91 d0 ff ff       	call   9f93 <color_tree_cleanup>
    cf02:	83 c4 10             	add    $0x10,%esp
  return error;
    cf05:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    cf08:	8d 65 f8             	lea    -0x8(%ebp),%esp
    cf0b:	5b                   	pop    %ebx
    cf0c:	5e                   	pop    %esi
    cf0d:	5d                   	pop    %ebp
    cf0e:	c3                   	ret    

0000cf0f <lodepng_color_stats_add>:
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*Adds a single color to the color stats. The stats must already have been inited. The color must be given as 16-bit
(with 2 bytes repeating for 8-bit and 65535 for opaque alpha channel). This function is expensive, do not call it for
all pixels of an image but only for a few additional values. */
static unsigned lodepng_color_stats_add(LodePNGColorStats* stats,
                                        unsigned r, unsigned g, unsigned b, unsigned a) {
    cf0f:	55                   	push   %ebp
    cf10:	89 e5                	mov    %esp,%ebp
    cf12:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    cf15:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char image[8];
  LodePNGColorMode mode;
  lodepng_color_mode_init(&mode);
    cf1c:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cf1f:	50                   	push   %eax
    cf20:	e8 d1 bd ff ff       	call   8cf6 <lodepng_color_mode_init>
    cf25:	83 c4 04             	add    $0x4,%esp
  image[0] = r >> 8; image[1] = r; image[2] = g >> 8; image[3] = g;
    cf28:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf2b:	c1 e8 08             	shr    $0x8,%eax
    cf2e:	88 45 ec             	mov    %al,-0x14(%ebp)
    cf31:	8b 45 0c             	mov    0xc(%ebp),%eax
    cf34:	88 45 ed             	mov    %al,-0x13(%ebp)
    cf37:	8b 45 10             	mov    0x10(%ebp),%eax
    cf3a:	c1 e8 08             	shr    $0x8,%eax
    cf3d:	88 45 ee             	mov    %al,-0x12(%ebp)
    cf40:	8b 45 10             	mov    0x10(%ebp),%eax
    cf43:	88 45 ef             	mov    %al,-0x11(%ebp)
  image[4] = b >> 8; image[5] = b; image[6] = a >> 8; image[7] = a;
    cf46:	8b 45 14             	mov    0x14(%ebp),%eax
    cf49:	c1 e8 08             	shr    $0x8,%eax
    cf4c:	88 45 f0             	mov    %al,-0x10(%ebp)
    cf4f:	8b 45 14             	mov    0x14(%ebp),%eax
    cf52:	88 45 f1             	mov    %al,-0xf(%ebp)
    cf55:	8b 45 18             	mov    0x18(%ebp),%eax
    cf58:	c1 e8 08             	shr    $0x8,%eax
    cf5b:	88 45 f2             	mov    %al,-0xe(%ebp)
    cf5e:	8b 45 18             	mov    0x18(%ebp),%eax
    cf61:	88 45 f3             	mov    %al,-0xd(%ebp)
  mode.bitdepth = 16;
    cf64:	c7 45 d0 10 00 00 00 	movl   $0x10,-0x30(%ebp)
  mode.colortype = LCT_RGBA;
    cf6b:	c7 45 cc 06 00 00 00 	movl   $0x6,-0x34(%ebp)
  error = lodepng_compute_color_stats(stats, image, 1, 1, &mode);
    cf72:	83 ec 0c             	sub    $0xc,%esp
    cf75:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cf78:	50                   	push   %eax
    cf79:	6a 01                	push   $0x1
    cf7b:	6a 01                	push   $0x1
    cf7d:	8d 45 ec             	lea    -0x14(%ebp),%eax
    cf80:	50                   	push   %eax
    cf81:	ff 75 08             	pushl  0x8(%ebp)
    cf84:	e8 76 f4 ff ff       	call   c3ff <lodepng_compute_color_stats>
    cf89:	83 c4 20             	add    $0x20,%esp
    cf8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_color_mode_cleanup(&mode);
    cf8f:	83 ec 0c             	sub    $0xc,%esp
    cf92:	8d 45 cc             	lea    -0x34(%ebp),%eax
    cf95:	50                   	push   %eax
    cf96:	e8 4e be ff ff       	call   8de9 <lodepng_color_mode_cleanup>
    cf9b:	83 c4 10             	add    $0x10,%esp
  return error;
    cf9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    cfa1:	c9                   	leave  
    cfa2:	c3                   	ret    

0000cfa3 <auto_choose_color>:
e.g. gray if only grayscale pixels, palette if less than 256 colors, color key if only single transparent color, ...
This is used if auto_convert is enabled (it is by default).
*/
static unsigned auto_choose_color(LodePNGColorMode* mode_out,
                                  const LodePNGColorMode* mode_in,
                                  const LodePNGColorStats* stats) {
    cfa3:	55                   	push   %ebp
    cfa4:	89 e5                	mov    %esp,%ebp
    cfa6:	56                   	push   %esi
    cfa7:	53                   	push   %ebx
    cfa8:	83 ec 30             	sub    $0x30,%esp
  unsigned error = 0;
    cfab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned palettebits;
  size_t i, n;
  size_t numpixels = stats->numpixels;
    cfb2:	8b 45 10             	mov    0x10(%ebp),%eax
    cfb5:	8b 80 1c 04 00 00    	mov    0x41c(%eax),%eax
    cfbb:	89 45 d8             	mov    %eax,-0x28(%ebp)
  unsigned palette_ok, gray_ok;

  unsigned alpha = stats->alpha;
    cfbe:	8b 45 10             	mov    0x10(%ebp),%eax
    cfc1:	8b 40 10             	mov    0x10(%eax),%eax
    cfc4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  unsigned key = stats->key;
    cfc7:	8b 45 10             	mov    0x10(%ebp),%eax
    cfca:	8b 40 04             	mov    0x4(%eax),%eax
    cfcd:	89 45 e0             	mov    %eax,-0x20(%ebp)
  unsigned bits = stats->bits;
    cfd0:	8b 45 10             	mov    0x10(%ebp),%eax
    cfd3:	8b 80 18 04 00 00    	mov    0x418(%eax),%eax
    cfd9:	89 45 dc             	mov    %eax,-0x24(%ebp)

  mode_out->key_defined = 0;
    cfdc:	8b 45 08             	mov    0x8(%ebp),%eax
    cfdf:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

  if(key && numpixels <= 16) {
    cfe6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    cfea:	74 21                	je     d00d <auto_choose_color+0x6a>
    cfec:	83 7d d8 10          	cmpl   $0x10,-0x28(%ebp)
    cff0:	7f 1b                	jg     d00d <auto_choose_color+0x6a>
    alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
    cff2:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    key = 0;
    cff9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    if(bits < 8) bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
    d000:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    d004:	77 07                	ja     d00d <auto_choose_color+0x6a>
    d006:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
  }

  gray_ok = !stats->colored;
    d00d:	8b 45 10             	mov    0x10(%ebp),%eax
    d010:	8b 00                	mov    (%eax),%eax
    d012:	85 c0                	test   %eax,%eax
    d014:	0f 94 c0             	sete   %al
    d017:	0f b6 c0             	movzbl %al,%eax
    d01a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(!stats->allow_greyscale) gray_ok = 0;
    d01d:	8b 45 10             	mov    0x10(%ebp),%eax
    d020:	8b 80 24 04 00 00    	mov    0x424(%eax),%eax
    d026:	85 c0                	test   %eax,%eax
    d028:	75 07                	jne    d031 <auto_choose_color+0x8e>
    d02a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  if(!gray_ok && bits < 8) bits = 8;
    d031:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d035:	75 0d                	jne    d044 <auto_choose_color+0xa1>
    d037:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
    d03b:	77 07                	ja     d044 <auto_choose_color+0xa1>
    d03d:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)

  n = stats->numcolors;
    d044:	8b 45 10             	mov    0x10(%ebp),%eax
    d047:	8b 40 14             	mov    0x14(%eax),%eax
    d04a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
    d04d:	83 7d d4 02          	cmpl   $0x2,-0x2c(%ebp)
    d051:	7e 21                	jle    d074 <auto_choose_color+0xd1>
    d053:	83 7d d4 04          	cmpl   $0x4,-0x2c(%ebp)
    d057:	7e 14                	jle    d06d <auto_choose_color+0xca>
    d059:	83 7d d4 10          	cmpl   $0x10,-0x2c(%ebp)
    d05d:	7f 07                	jg     d066 <auto_choose_color+0xc3>
    d05f:	b8 04 00 00 00       	mov    $0x4,%eax
    d064:	eb 13                	jmp    d079 <auto_choose_color+0xd6>
    d066:	b8 08 00 00 00       	mov    $0x8,%eax
    d06b:	eb 0c                	jmp    d079 <auto_choose_color+0xd6>
    d06d:	b8 02 00 00 00       	mov    $0x2,%eax
    d072:	eb 05                	jmp    d079 <auto_choose_color+0xd6>
    d074:	b8 01 00 00 00       	mov    $0x1,%eax
    d079:	89 45 d0             	mov    %eax,-0x30(%ebp)
  palette_ok = n <= 256 && bits <= 8 && n != 0; /*n==0 means likely numcolors wasn't computed*/
    d07c:	81 7d d4 00 01 00 00 	cmpl   $0x100,-0x2c(%ebp)
    d083:	7f 13                	jg     d098 <auto_choose_color+0xf5>
    d085:	83 7d dc 08          	cmpl   $0x8,-0x24(%ebp)
    d089:	77 0d                	ja     d098 <auto_choose_color+0xf5>
    d08b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
    d08f:	74 07                	je     d098 <auto_choose_color+0xf5>
    d091:	b8 01 00 00 00       	mov    $0x1,%eax
    d096:	eb 05                	jmp    d09d <auto_choose_color+0xfa>
    d098:	b8 00 00 00 00       	mov    $0x0,%eax
    d09d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(numpixels < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
    d0a0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    d0a3:	01 c0                	add    %eax,%eax
    d0a5:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    d0a8:	7e 07                	jle    d0b1 <auto_choose_color+0x10e>
    d0aa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(gray_ok && !alpha && bits <= palettebits) palette_ok = 0; /*gray is less overhead*/
    d0b1:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d0b5:	74 15                	je     d0cc <auto_choose_color+0x129>
    d0b7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d0bb:	75 0f                	jne    d0cc <auto_choose_color+0x129>
    d0bd:	8b 45 dc             	mov    -0x24(%ebp),%eax
    d0c0:	3b 45 d0             	cmp    -0x30(%ebp),%eax
    d0c3:	77 07                	ja     d0cc <auto_choose_color+0x129>
    d0c5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  if(!stats->allow_palette) palette_ok = 0;
    d0cc:	8b 45 10             	mov    0x10(%ebp),%eax
    d0cf:	8b 80 20 04 00 00    	mov    0x420(%eax),%eax
    d0d5:	85 c0                	test   %eax,%eax
    d0d7:	75 07                	jne    d0e0 <auto_choose_color+0x13d>
    d0d9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  if(palette_ok) {
    d0e0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d0e4:	0f 84 0a 01 00 00    	je     d1f4 <auto_choose_color+0x251>
    const unsigned char* p = stats->palette;
    d0ea:	8b 45 10             	mov    0x10(%ebp),%eax
    d0ed:	83 c0 18             	add    $0x18,%eax
    d0f0:	89 45 cc             	mov    %eax,-0x34(%ebp)
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    d0f3:	83 ec 0c             	sub    $0xc,%esp
    d0f6:	ff 75 08             	pushl  0x8(%ebp)
    d0f9:	e8 ef be ff ff       	call   8fed <lodepng_palette_clear>
    d0fe:	83 c4 10             	add    $0x10,%esp
    for(i = 0; i != stats->numcolors; ++i) {
    d101:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    d108:	eb 6e                	jmp    d178 <auto_choose_color+0x1d5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
    d10a:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d10d:	c1 e0 02             	shl    $0x2,%eax
    d110:	8d 50 03             	lea    0x3(%eax),%edx
    d113:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d116:	01 d0                	add    %edx,%eax
    d118:	0f b6 00             	movzbl (%eax),%eax
    d11b:	0f b6 d8             	movzbl %al,%ebx
    d11e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d121:	c1 e0 02             	shl    $0x2,%eax
    d124:	8d 50 02             	lea    0x2(%eax),%edx
    d127:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d12a:	01 d0                	add    %edx,%eax
    d12c:	0f b6 00             	movzbl (%eax),%eax
    d12f:	0f b6 c8             	movzbl %al,%ecx
    d132:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d135:	c1 e0 02             	shl    $0x2,%eax
    d138:	8d 50 01             	lea    0x1(%eax),%edx
    d13b:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d13e:	01 d0                	add    %edx,%eax
    d140:	0f b6 00             	movzbl (%eax),%eax
    d143:	0f b6 d0             	movzbl %al,%edx
    d146:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d149:	c1 e0 02             	shl    $0x2,%eax
    d14c:	89 c6                	mov    %eax,%esi
    d14e:	8b 45 cc             	mov    -0x34(%ebp),%eax
    d151:	01 f0                	add    %esi,%eax
    d153:	0f b6 00             	movzbl (%eax),%eax
    d156:	0f b6 c0             	movzbl %al,%eax
    d159:	83 ec 0c             	sub    $0xc,%esp
    d15c:	53                   	push   %ebx
    d15d:	51                   	push   %ecx
    d15e:	52                   	push   %edx
    d15f:	50                   	push   %eax
    d160:	ff 75 08             	pushl  0x8(%ebp)
    d163:	e8 be be ff ff       	call   9026 <lodepng_palette_add>
    d168:	83 c4 20             	add    $0x20,%esp
    d16b:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if(error) break;
    d16e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    d172:	75 13                	jne    d187 <auto_choose_color+0x1e4>
  if(!stats->allow_palette) palette_ok = 0;

  if(palette_ok) {
    const unsigned char* p = stats->palette;
    lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
    for(i = 0; i != stats->numcolors; ++i) {
    d174:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    d178:	8b 45 10             	mov    0x10(%ebp),%eax
    d17b:	8b 50 14             	mov    0x14(%eax),%edx
    d17e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    d181:	39 c2                	cmp    %eax,%edx
    d183:	75 85                	jne    d10a <auto_choose_color+0x167>
    d185:	eb 01                	jmp    d188 <auto_choose_color+0x1e5>
      error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
      if(error) break;
    d187:	90                   	nop
    }

    mode_out->colortype = LCT_PALETTE;
    d188:	8b 45 08             	mov    0x8(%ebp),%eax
    d18b:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    mode_out->bitdepth = palettebits;
    d191:	8b 45 08             	mov    0x8(%ebp),%eax
    d194:	8b 55 d0             	mov    -0x30(%ebp),%edx
    d197:	89 50 04             	mov    %edx,0x4(%eax)

    if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
    d19a:	8b 45 0c             	mov    0xc(%ebp),%eax
    d19d:	8b 00                	mov    (%eax),%eax
    d19f:	83 f8 03             	cmp    $0x3,%eax
    d1a2:	0f 85 ec 00 00 00    	jne    d294 <auto_choose_color+0x2f1>
    d1a8:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1ab:	8b 50 0c             	mov    0xc(%eax),%edx
    d1ae:	8b 45 08             	mov    0x8(%ebp),%eax
    d1b1:	8b 40 0c             	mov    0xc(%eax),%eax
    d1b4:	39 c2                	cmp    %eax,%edx
    d1b6:	0f 8c d8 00 00 00    	jl     d294 <auto_choose_color+0x2f1>
        && mode_in->bitdepth == mode_out->bitdepth) {
    d1bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    d1bf:	8b 50 04             	mov    0x4(%eax),%edx
    d1c2:	8b 45 08             	mov    0x8(%ebp),%eax
    d1c5:	8b 40 04             	mov    0x4(%eax),%eax
    d1c8:	39 c2                	cmp    %eax,%edx
    d1ca:	0f 85 c4 00 00 00    	jne    d294 <auto_choose_color+0x2f1>
      /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
      lodepng_color_mode_cleanup(mode_out);
    d1d0:	83 ec 0c             	sub    $0xc,%esp
    d1d3:	ff 75 08             	pushl  0x8(%ebp)
    d1d6:	e8 0e bc ff ff       	call   8de9 <lodepng_color_mode_cleanup>
    d1db:	83 c4 10             	add    $0x10,%esp
      lodepng_color_mode_copy(mode_out, mode_in);
    d1de:	83 ec 08             	sub    $0x8,%esp
    d1e1:	ff 75 0c             	pushl  0xc(%ebp)
    d1e4:	ff 75 08             	pushl  0x8(%ebp)
    d1e7:	e8 14 bc ff ff       	call   8e00 <lodepng_color_mode_copy>
    d1ec:	83 c4 10             	add    $0x10,%esp
    d1ef:	e9 a0 00 00 00       	jmp    d294 <auto_choose_color+0x2f1>
    }
  } else /*8-bit or 16-bit per channel*/ {
    mode_out->bitdepth = bits;
    d1f4:	8b 45 08             	mov    0x8(%ebp),%eax
    d1f7:	8b 55 dc             	mov    -0x24(%ebp),%edx
    d1fa:	89 50 04             	mov    %edx,0x4(%eax)
    mode_out->colortype = alpha ? (gray_ok ? LCT_GREY_ALPHA : LCT_RGBA)
    d1fd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    d201:	74 14                	je     d217 <auto_choose_color+0x274>
    d203:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d207:	74 07                	je     d210 <auto_choose_color+0x26d>
    d209:	b8 04 00 00 00       	mov    $0x4,%eax
    d20e:	eb 19                	jmp    d229 <auto_choose_color+0x286>
    d210:	b8 06 00 00 00       	mov    $0x6,%eax
    d215:	eb 12                	jmp    d229 <auto_choose_color+0x286>
    d217:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    d21b:	74 07                	je     d224 <auto_choose_color+0x281>
    d21d:	b8 00 00 00 00       	mov    $0x0,%eax
    d222:	eb 05                	jmp    d229 <auto_choose_color+0x286>
    d224:	b8 02 00 00 00       	mov    $0x2,%eax
    d229:	8b 55 08             	mov    0x8(%ebp),%edx
    d22c:	89 02                	mov    %eax,(%edx)
                                : (gray_ok ? LCT_GREY : LCT_RGB);
    if(key) {
    d22e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    d232:	74 60                	je     d294 <auto_choose_color+0x2f1>
      unsigned mask = (1u << mode_out->bitdepth) - 1u; /*stats always uses 16-bit, mask converts it*/
    d234:	8b 45 08             	mov    0x8(%ebp),%eax
    d237:	8b 40 04             	mov    0x4(%eax),%eax
    d23a:	ba 01 00 00 00       	mov    $0x1,%edx
    d23f:	89 c1                	mov    %eax,%ecx
    d241:	d3 e2                	shl    %cl,%edx
    d243:	89 d0                	mov    %edx,%eax
    d245:	83 e8 01             	sub    $0x1,%eax
    d248:	89 45 c8             	mov    %eax,-0x38(%ebp)
      mode_out->key_r = stats->key_r & mask;
    d24b:	8b 45 10             	mov    0x10(%ebp),%eax
    d24e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
    d252:	0f b7 c0             	movzwl %ax,%eax
    d255:	23 45 c8             	and    -0x38(%ebp),%eax
    d258:	89 c2                	mov    %eax,%edx
    d25a:	8b 45 08             	mov    0x8(%ebp),%eax
    d25d:	89 50 14             	mov    %edx,0x14(%eax)
      mode_out->key_g = stats->key_g & mask;
    d260:	8b 45 10             	mov    0x10(%ebp),%eax
    d263:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
    d267:	0f b7 c0             	movzwl %ax,%eax
    d26a:	23 45 c8             	and    -0x38(%ebp),%eax
    d26d:	89 c2                	mov    %eax,%edx
    d26f:	8b 45 08             	mov    0x8(%ebp),%eax
    d272:	89 50 18             	mov    %edx,0x18(%eax)
      mode_out->key_b = stats->key_b & mask;
    d275:	8b 45 10             	mov    0x10(%ebp),%eax
    d278:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
    d27c:	0f b7 c0             	movzwl %ax,%eax
    d27f:	23 45 c8             	and    -0x38(%ebp),%eax
    d282:	89 c2                	mov    %eax,%edx
    d284:	8b 45 08             	mov    0x8(%ebp),%eax
    d287:	89 50 1c             	mov    %edx,0x1c(%eax)
      mode_out->key_defined = 1;
    d28a:	8b 45 08             	mov    0x8(%ebp),%eax
    d28d:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    }
  }

  return error;
    d294:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    d297:	8d 65 f8             	lea    -0x8(%ebp),%esp
    d29a:	5b                   	pop    %ebx
    d29b:	5e                   	pop    %esi
    d29c:	5d                   	pop    %ebp
    d29d:	c3                   	ret    

0000d29e <paethPredictor>:
/*
Paeth predictor, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c) {
    d29e:	55                   	push   %ebp
    d29f:	89 e5                	mov    %esp,%ebp
    d2a1:	83 ec 1c             	sub    $0x1c,%esp
    d2a4:	8b 4d 08             	mov    0x8(%ebp),%ecx
    d2a7:	8b 55 0c             	mov    0xc(%ebp),%edx
    d2aa:	8b 45 10             	mov    0x10(%ebp),%eax
    d2ad:	66 89 4d ec          	mov    %cx,-0x14(%ebp)
    d2b1:	66 89 55 e8          	mov    %dx,-0x18(%ebp)
    d2b5:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  short pa = LODEPNG_ABS(b - c);
    d2b9:	0f bf 55 e8          	movswl -0x18(%ebp),%edx
    d2bd:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d2c1:	29 c2                	sub    %eax,%edx
    d2c3:	89 d0                	mov    %edx,%eax
    d2c5:	99                   	cltd   
    d2c6:	31 d0                	xor    %edx,%eax
    d2c8:	29 d0                	sub    %edx,%eax
    d2ca:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  short pb = LODEPNG_ABS(a - c);
    d2ce:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d2d2:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d2d6:	29 c2                	sub    %eax,%edx
    d2d8:	89 d0                	mov    %edx,%eax
    d2da:	99                   	cltd   
    d2db:	31 d0                	xor    %edx,%eax
    d2dd:	29 d0                	sub    %edx,%eax
    d2df:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
  short pc = LODEPNG_ABS(a + b - c - c);
    d2e3:	0f bf 55 ec          	movswl -0x14(%ebp),%edx
    d2e7:	0f bf 45 e8          	movswl -0x18(%ebp),%eax
    d2eb:	01 c2                	add    %eax,%edx
    d2ed:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d2f1:	29 c2                	sub    %eax,%edx
    d2f3:	0f bf 45 e4          	movswl -0x1c(%ebp),%eax
    d2f7:	29 c2                	sub    %eax,%edx
    d2f9:	89 d0                	mov    %edx,%eax
    d2fb:	99                   	cltd   
    d2fc:	31 d0                	xor    %edx,%eax
    d2fe:	29 d0                	sub    %edx,%eax
    d300:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
  /* return input value associated with smallest of pa, pb, pc (with certain priority if equal) */
  if(pb < pa) { a = b; pa = pb; }
    d304:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d308:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d30c:	7d 10                	jge    d31e <paethPredictor+0x80>
    d30e:	0f b7 45 e8          	movzwl -0x18(%ebp),%eax
    d312:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    d316:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
    d31a:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  return (pc < pa) ? c : a;
    d31e:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
    d322:	66 3b 45 fe          	cmp    -0x2(%ebp),%ax
    d326:	7d 06                	jge    d32e <paethPredictor+0x90>
    d328:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
    d32c:	eb 04                	jmp    d332 <paethPredictor+0x94>
    d32e:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
}
    d332:	c9                   	leave  
    d333:	c3                   	ret    

0000d334 <Adam7_getpassvalues>:
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
    d334:	55                   	push   %ebp
    d335:	89 e5                	mov    %esp,%ebp
    d337:	56                   	push   %esi
    d338:	53                   	push   %ebx
    d339:	83 ec 10             	sub    $0x10,%esp
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d33c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d343:	e9 e2 00 00 00       	jmp    d42a <Adam7_getpassvalues+0xf6>
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    d348:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d34b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d352:	8b 45 08             	mov    0x8(%ebp),%eax
    d355:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d358:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d35b:	8b 14 85 d4 a2 01 00 	mov    0x1a2d4(,%eax,4),%edx
    d362:	8b 45 1c             	mov    0x1c(%ebp),%eax
    d365:	01 c2                	add    %eax,%edx
    d367:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d36a:	8b 04 85 9c a2 01 00 	mov    0x1a29c(,%eax,4),%eax
    d371:	29 c2                	sub    %eax,%edx
    d373:	89 d0                	mov    %edx,%eax
    d375:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d378:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d37b:	8b 34 85 d4 a2 01 00 	mov    0x1a2d4(,%eax,4),%esi
    d382:	89 d8                	mov    %ebx,%eax
    d384:	ba 00 00 00 00       	mov    $0x0,%edx
    d389:	f7 f6                	div    %esi
    d38b:	89 01                	mov    %eax,(%ecx)
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    d38d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d390:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d397:	8b 45 0c             	mov    0xc(%ebp),%eax
    d39a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    d39d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3a0:	8b 14 85 f0 a2 01 00 	mov    0x1a2f0(,%eax,4),%edx
    d3a7:	8b 45 20             	mov    0x20(%ebp),%eax
    d3aa:	01 c2                	add    %eax,%edx
    d3ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3af:	8b 04 85 b8 a2 01 00 	mov    0x1a2b8(,%eax,4),%eax
    d3b6:	29 c2                	sub    %eax,%edx
    d3b8:	89 d0                	mov    %edx,%eax
    d3ba:	8d 58 ff             	lea    -0x1(%eax),%ebx
    d3bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3c0:	8b 34 85 f0 a2 01 00 	mov    0x1a2f0(,%eax,4),%esi
    d3c7:	89 d8                	mov    %ebx,%eax
    d3c9:	ba 00 00 00 00       	mov    $0x0,%edx
    d3ce:	f7 f6                	div    %esi
    d3d0:	89 01                	mov    %eax,(%ecx)
    if(passw[i] == 0) passh[i] = 0;
    d3d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3d5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d3dc:	8b 45 08             	mov    0x8(%ebp),%eax
    d3df:	01 d0                	add    %edx,%eax
    d3e1:	8b 00                	mov    (%eax),%eax
    d3e3:	85 c0                	test   %eax,%eax
    d3e5:	75 15                	jne    d3fc <Adam7_getpassvalues+0xc8>
    d3e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3ea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d3f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    d3f4:	01 d0                	add    %edx,%eax
    d3f6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    if(passh[i] == 0) passw[i] = 0;
    d3fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d3ff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d406:	8b 45 0c             	mov    0xc(%ebp),%eax
    d409:	01 d0                	add    %edx,%eax
    d40b:	8b 00                	mov    (%eax),%eax
    d40d:	85 c0                	test   %eax,%eax
    d40f:	75 15                	jne    d426 <Adam7_getpassvalues+0xf2>
    d411:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d414:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d41b:	8b 45 08             	mov    0x8(%ebp),%eax
    d41e:	01 d0                	add    %edx,%eax
    d420:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp) {
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i) {
    d426:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d42a:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d42e:	0f 85 14 ff ff ff    	jne    d348 <Adam7_getpassvalues+0x14>
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
    d434:	8b 45 18             	mov    0x18(%ebp),%eax
    d437:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    d43d:	8b 45 18             	mov    0x18(%ebp),%eax
    d440:	8b 10                	mov    (%eax),%edx
    d442:	8b 45 14             	mov    0x14(%ebp),%eax
    d445:	89 10                	mov    %edx,(%eax)
    d447:	8b 45 14             	mov    0x14(%ebp),%eax
    d44a:	8b 10                	mov    (%eax),%edx
    d44c:	8b 45 10             	mov    0x10(%ebp),%eax
    d44f:	89 10                	mov    %edx,(%eax)
  for(i = 0; i != 7; ++i) {
    d451:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d458:	e9 40 01 00 00       	jmp    d59d <Adam7_getpassvalues+0x269>
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d45d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d460:	83 c0 01             	add    $0x1,%eax
    d463:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d46a:	8b 45 10             	mov    0x10(%ebp),%eax
    d46d:	01 c2                	add    %eax,%edx
    d46f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d472:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d479:	8b 45 10             	mov    0x10(%ebp),%eax
    d47c:	01 c8                	add    %ecx,%eax
    d47e:	8b 00                	mov    (%eax),%eax
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    d480:	89 c6                	mov    %eax,%esi
    d482:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d485:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d48c:	8b 45 08             	mov    0x8(%ebp),%eax
    d48f:	01 c8                	add    %ecx,%eax
    d491:	8b 00                	mov    (%eax),%eax
    d493:	85 c0                	test   %eax,%eax
    d495:	74 49                	je     d4e0 <Adam7_getpassvalues+0x1ac>
    d497:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d49a:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d4a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    d4a4:	01 c8                	add    %ecx,%eax
    d4a6:	8b 00                	mov    (%eax),%eax
    d4a8:	85 c0                	test   %eax,%eax
    d4aa:	74 34                	je     d4e0 <Adam7_getpassvalues+0x1ac>
    d4ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4af:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d4b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    d4b9:	01 c8                	add    %ecx,%eax
    d4bb:	8b 08                	mov    (%eax),%ecx
    d4bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4c0:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d4c7:	8b 45 08             	mov    0x8(%ebp),%eax
    d4ca:	01 d8                	add    %ebx,%eax
    d4cc:	8b 00                	mov    (%eax),%eax
    d4ce:	0f af 45 24          	imul   0x24(%ebp),%eax
    d4d2:	83 c0 07             	add    $0x7,%eax
    d4d5:	c1 e8 03             	shr    $0x3,%eax
    d4d8:	83 c0 01             	add    $0x1,%eax
    d4db:	0f af c1             	imul   %ecx,%eax
    d4de:	eb 05                	jmp    d4e5 <Adam7_getpassvalues+0x1b1>
    d4e0:	b8 00 00 00 00       	mov    $0x0,%eax
    d4e5:	01 f0                	add    %esi,%eax
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
    d4e7:	89 02                	mov    %eax,(%edx)
                            + ((passw[i] && passh[i]) ? passh[i] * (1u + (passw[i] * bpp + 7u) / 8u) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    d4e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4ec:	83 c0 01             	add    $0x1,%eax
    d4ef:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d4f6:	8b 45 14             	mov    0x14(%ebp),%eax
    d4f9:	01 c2                	add    %eax,%edx
    d4fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d4fe:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d505:	8b 45 14             	mov    0x14(%ebp),%eax
    d508:	01 c8                	add    %ecx,%eax
    d50a:	8b 00                	mov    (%eax),%eax
    d50c:	89 c6                	mov    %eax,%esi
    d50e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d511:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d518:	8b 45 0c             	mov    0xc(%ebp),%eax
    d51b:	01 c8                	add    %ecx,%eax
    d51d:	8b 08                	mov    (%eax),%ecx
    d51f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d522:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d529:	8b 45 08             	mov    0x8(%ebp),%eax
    d52c:	01 d8                	add    %ebx,%eax
    d52e:	8b 00                	mov    (%eax),%eax
    d530:	0f af 45 24          	imul   0x24(%ebp),%eax
    d534:	83 c0 07             	add    $0x7,%eax
    d537:	c1 e8 03             	shr    $0x3,%eax
    d53a:	0f af c1             	imul   %ecx,%eax
    d53d:	01 f0                	add    %esi,%eax
    d53f:	89 02                	mov    %eax,(%edx)
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
    d541:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d544:	83 c0 01             	add    $0x1,%eax
    d547:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
    d54e:	8b 45 18             	mov    0x18(%ebp),%eax
    d551:	01 c2                	add    %eax,%edx
    d553:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d556:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d55d:	8b 45 18             	mov    0x18(%ebp),%eax
    d560:	01 c8                	add    %ecx,%eax
    d562:	8b 00                	mov    (%eax),%eax
    d564:	89 c6                	mov    %eax,%esi
    d566:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d569:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
    d570:	8b 45 0c             	mov    0xc(%ebp),%eax
    d573:	01 c8                	add    %ecx,%eax
    d575:	8b 08                	mov    (%eax),%ecx
    d577:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d57a:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
    d581:	8b 45 08             	mov    0x8(%ebp),%eax
    d584:	01 d8                	add    %ebx,%eax
    d586:	8b 00                	mov    (%eax),%eax
    d588:	0f af c1             	imul   %ecx,%eax
    d58b:	0f af 45 24          	imul   0x24(%ebp),%eax
    d58f:	83 c0 07             	add    $0x7,%eax
    d592:	c1 e8 03             	shr    $0x3,%eax
    d595:	01 f0                	add    %esi,%eax
    d597:	89 02                	mov    %eax,(%edx)
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i) {
    d599:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d59d:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
    d5a1:	0f 85 b6 fe ff ff    	jne    d45d <Adam7_getpassvalues+0x129>
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7u) / 8u);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7u) / 8u;
  }
}
    d5a7:	90                   	nop
    d5a8:	83 c4 10             	add    $0x10,%esp
    d5ab:	5b                   	pop    %ebx
    d5ac:	5e                   	pop    %esi
    d5ad:	5d                   	pop    %ebp
    d5ae:	c3                   	ret    

0000d5af <lodepng_inspect>:
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize) {
    d5af:	55                   	push   %ebp
    d5b0:	89 e5                	mov    %esp,%ebp
    d5b2:	83 ec 28             	sub    $0x28,%esp
  unsigned width, height;
  LodePNGInfo* info = &state->info_png;
    d5b5:	8b 45 10             	mov    0x10(%ebp),%eax
    d5b8:	05 98 00 00 00       	add    $0x98,%eax
    d5bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(insize == 0 || in == 0) {
    d5c0:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
    d5c4:	74 06                	je     d5cc <lodepng_inspect+0x1d>
    d5c6:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
    d5ca:	75 17                	jne    d5e3 <lodepng_inspect+0x34>
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
    d5cc:	8b 45 10             	mov    0x10(%ebp),%eax
    d5cf:	c7 80 7c 01 00 00 30 	movl   $0x30,0x17c(%eax)
    d5d6:	00 00 00 
    d5d9:	b8 30 00 00 00       	mov    $0x30,%eax
    d5de:	e9 ce 02 00 00       	jmp    d8b1 <lodepng_inspect+0x302>
  }
  if(insize < 33) {
    d5e3:	83 7d 18 20          	cmpl   $0x20,0x18(%ebp)
    d5e7:	7f 17                	jg     d600 <lodepng_inspect+0x51>
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
    d5e9:	8b 45 10             	mov    0x10(%ebp),%eax
    d5ec:	c7 80 7c 01 00 00 1b 	movl   $0x1b,0x17c(%eax)
    d5f3:	00 00 00 
    d5f6:	b8 1b 00 00 00       	mov    $0x1b,%eax
    d5fb:	e9 b1 02 00 00       	jmp    d8b1 <lodepng_inspect+0x302>
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  /* TODO: remove this. One should use a new LodePNGState for new sessions */
  lodepng_info_cleanup(info);
    d600:	83 ec 0c             	sub    $0xc,%esp
    d603:	ff 75 f4             	pushl  -0xc(%ebp)
    d606:	e8 63 c7 ff ff       	call   9d6e <lodepng_info_cleanup>
    d60b:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(info);
    d60e:	83 ec 0c             	sub    $0xc,%esp
    d611:	ff 75 f4             	pushl  -0xc(%ebp)
    d614:	e8 74 c6 ff ff       	call   9c8d <lodepng_info_init>
    d619:	83 c4 10             	add    $0x10,%esp

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
    d61c:	8b 45 14             	mov    0x14(%ebp),%eax
    d61f:	0f b6 00             	movzbl (%eax),%eax
    d622:	3c 89                	cmp    $0x89,%al
    d624:	75 5b                	jne    d681 <lodepng_inspect+0xd2>
    d626:	8b 45 14             	mov    0x14(%ebp),%eax
    d629:	83 c0 01             	add    $0x1,%eax
    d62c:	0f b6 00             	movzbl (%eax),%eax
    d62f:	3c 50                	cmp    $0x50,%al
    d631:	75 4e                	jne    d681 <lodepng_inspect+0xd2>
    d633:	8b 45 14             	mov    0x14(%ebp),%eax
    d636:	83 c0 02             	add    $0x2,%eax
    d639:	0f b6 00             	movzbl (%eax),%eax
    d63c:	3c 4e                	cmp    $0x4e,%al
    d63e:	75 41                	jne    d681 <lodepng_inspect+0xd2>
    d640:	8b 45 14             	mov    0x14(%ebp),%eax
    d643:	83 c0 03             	add    $0x3,%eax
    d646:	0f b6 00             	movzbl (%eax),%eax
    d649:	3c 47                	cmp    $0x47,%al
    d64b:	75 34                	jne    d681 <lodepng_inspect+0xd2>
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) {
    d64d:	8b 45 14             	mov    0x14(%ebp),%eax
    d650:	83 c0 04             	add    $0x4,%eax
    d653:	0f b6 00             	movzbl (%eax),%eax
    d656:	3c 0d                	cmp    $0xd,%al
    d658:	75 27                	jne    d681 <lodepng_inspect+0xd2>
    d65a:	8b 45 14             	mov    0x14(%ebp),%eax
    d65d:	83 c0 05             	add    $0x5,%eax
    d660:	0f b6 00             	movzbl (%eax),%eax
    d663:	3c 0a                	cmp    $0xa,%al
    d665:	75 1a                	jne    d681 <lodepng_inspect+0xd2>
    d667:	8b 45 14             	mov    0x14(%ebp),%eax
    d66a:	83 c0 06             	add    $0x6,%eax
    d66d:	0f b6 00             	movzbl (%eax),%eax
    d670:	3c 1a                	cmp    $0x1a,%al
    d672:	75 0d                	jne    d681 <lodepng_inspect+0xd2>
    d674:	8b 45 14             	mov    0x14(%ebp),%eax
    d677:	83 c0 07             	add    $0x7,%eax
    d67a:	0f b6 00             	movzbl (%eax),%eax
    d67d:	3c 0a                	cmp    $0xa,%al
    d67f:	74 17                	je     d698 <lodepng_inspect+0xe9>
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
    d681:	8b 45 10             	mov    0x10(%ebp),%eax
    d684:	c7 80 7c 01 00 00 1c 	movl   $0x1c,0x17c(%eax)
    d68b:	00 00 00 
    d68e:	b8 1c 00 00 00       	mov    $0x1c,%eax
    d693:	e9 19 02 00 00       	jmp    d8b1 <lodepng_inspect+0x302>
  }
  if(lodepng_chunk_length(in + 8) != 13) {
    d698:	8b 45 14             	mov    0x14(%ebp),%eax
    d69b:	83 c0 08             	add    $0x8,%eax
    d69e:	83 ec 0c             	sub    $0xc,%esp
    d6a1:	50                   	push   %eax
    d6a2:	e8 c2 ae ff ff       	call   8569 <lodepng_chunk_length>
    d6a7:	83 c4 10             	add    $0x10,%esp
    d6aa:	83 f8 0d             	cmp    $0xd,%eax
    d6ad:	74 17                	je     d6c6 <lodepng_inspect+0x117>
    CERROR_RETURN_ERROR(state->error, 94); /*error: header size must be 13 bytes*/
    d6af:	8b 45 10             	mov    0x10(%ebp),%eax
    d6b2:	c7 80 7c 01 00 00 5e 	movl   $0x5e,0x17c(%eax)
    d6b9:	00 00 00 
    d6bc:	b8 5e 00 00 00       	mov    $0x5e,%eax
    d6c1:	e9 eb 01 00 00       	jmp    d8b1 <lodepng_inspect+0x302>
  }
  if(!lodepng_chunk_type_equals(in + 8, "IHDR")) {
    d6c6:	8b 45 14             	mov    0x14(%ebp),%eax
    d6c9:	83 c0 08             	add    $0x8,%eax
    d6cc:	83 ec 08             	sub    $0x8,%esp
    d6cf:	68 0c a3 01 00       	push   $0x1a30c
    d6d4:	50                   	push   %eax
    d6d5:	e8 dc ae ff ff       	call   85b6 <lodepng_chunk_type_equals>
    d6da:	83 c4 10             	add    $0x10,%esp
    d6dd:	84 c0                	test   %al,%al
    d6df:	75 17                	jne    d6f8 <lodepng_inspect+0x149>
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
    d6e1:	8b 45 10             	mov    0x10(%ebp),%eax
    d6e4:	c7 80 7c 01 00 00 1d 	movl   $0x1d,0x17c(%eax)
    d6eb:	00 00 00 
    d6ee:	b8 1d 00 00 00       	mov    $0x1d,%eax
    d6f3:	e9 b9 01 00 00       	jmp    d8b1 <lodepng_inspect+0x302>
  }

  /*read the values given in the header*/
  width = lodepng_read32bitInt(&in[16]);
    d6f8:	8b 45 14             	mov    0x14(%ebp),%eax
    d6fb:	83 c0 10             	add    $0x10,%eax
    d6fe:	83 ec 0c             	sub    $0xc,%esp
    d701:	50                   	push   %eax
    d702:	e8 5e 62 ff ff       	call   3965 <lodepng_read32bitInt>
    d707:	83 c4 10             	add    $0x10,%esp
    d70a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  height = lodepng_read32bitInt(&in[20]);
    d70d:	8b 45 14             	mov    0x14(%ebp),%eax
    d710:	83 c0 14             	add    $0x14,%eax
    d713:	83 ec 0c             	sub    $0xc,%esp
    d716:	50                   	push   %eax
    d717:	e8 49 62 ff ff       	call   3965 <lodepng_read32bitInt>
    d71c:	83 c4 10             	add    $0x10,%esp
    d71f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  /*TODO: remove the undocumented feature that allows to give null pointers to width or height*/
  if(w) *w = width;
    d722:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
    d726:	74 08                	je     d730 <lodepng_inspect+0x181>
    d728:	8b 45 08             	mov    0x8(%ebp),%eax
    d72b:	8b 55 f0             	mov    -0x10(%ebp),%edx
    d72e:	89 10                	mov    %edx,(%eax)
  if(h) *h = height;
    d730:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
    d734:	74 08                	je     d73e <lodepng_inspect+0x18f>
    d736:	8b 45 0c             	mov    0xc(%ebp),%eax
    d739:	8b 55 ec             	mov    -0x14(%ebp),%edx
    d73c:	89 10                	mov    %edx,(%eax)
  info->color.bitdepth = in[24];
    d73e:	8b 45 14             	mov    0x14(%ebp),%eax
    d741:	83 c0 18             	add    $0x18,%eax
    d744:	0f b6 00             	movzbl (%eax),%eax
    d747:	0f b6 d0             	movzbl %al,%edx
    d74a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d74d:	89 50 10             	mov    %edx,0x10(%eax)
  info->color.colortype = (LodePNGColorType)in[25];
    d750:	8b 45 14             	mov    0x14(%ebp),%eax
    d753:	83 c0 19             	add    $0x19,%eax
    d756:	0f b6 00             	movzbl (%eax),%eax
    d759:	0f b6 d0             	movzbl %al,%edx
    d75c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d75f:	89 50 0c             	mov    %edx,0xc(%eax)
  info->compression_method = in[26];
    d762:	8b 45 14             	mov    0x14(%ebp),%eax
    d765:	83 c0 1a             	add    $0x1a,%eax
    d768:	0f b6 00             	movzbl (%eax),%eax
    d76b:	0f b6 d0             	movzbl %al,%edx
    d76e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d771:	89 10                	mov    %edx,(%eax)
  info->filter_method = in[27];
    d773:	8b 45 14             	mov    0x14(%ebp),%eax
    d776:	83 c0 1b             	add    $0x1b,%eax
    d779:	0f b6 00             	movzbl (%eax),%eax
    d77c:	0f b6 d0             	movzbl %al,%edx
    d77f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d782:	89 50 04             	mov    %edx,0x4(%eax)
  info->interlace_method = in[28];
    d785:	8b 45 14             	mov    0x14(%ebp),%eax
    d788:	83 c0 1c             	add    $0x1c,%eax
    d78b:	0f b6 00             	movzbl (%eax),%eax
    d78e:	0f b6 d0             	movzbl %al,%edx
    d791:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d794:	89 50 08             	mov    %edx,0x8(%eax)

  /*errors returned only after the parsing so other values are still output*/

  /*error: invalid image size*/
  if(width == 0 || height == 0) CERROR_RETURN_ERROR(state->error, 93);
    d797:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    d79b:	74 06                	je     d7a3 <lodepng_inspect+0x1f4>
    d79d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    d7a1:	75 17                	jne    d7ba <lodepng_inspect+0x20b>
    d7a3:	8b 45 10             	mov    0x10(%ebp),%eax
    d7a6:	c7 80 7c 01 00 00 5d 	movl   $0x5d,0x17c(%eax)
    d7ad:	00 00 00 
    d7b0:	b8 5d 00 00 00       	mov    $0x5d,%eax
    d7b5:	e9 f7 00 00 00       	jmp    d8b1 <lodepng_inspect+0x302>
  /*error: invalid colortype or bitdepth combination*/
  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
    d7ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7bd:	8b 50 10             	mov    0x10(%eax),%edx
    d7c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7c3:	8b 40 0c             	mov    0xc(%eax),%eax
    d7c6:	83 ec 08             	sub    $0x8,%esp
    d7c9:	52                   	push   %edx
    d7ca:	50                   	push   %eax
    d7cb:	e8 d4 b3 ff ff       	call   8ba4 <checkColorValidity>
    d7d0:	83 c4 10             	add    $0x10,%esp
    d7d3:	89 c2                	mov    %eax,%edx
    d7d5:	8b 45 10             	mov    0x10(%ebp),%eax
    d7d8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return state->error;
    d7de:	8b 45 10             	mov    0x10(%ebp),%eax
    d7e1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d7e7:	85 c0                	test   %eax,%eax
    d7e9:	74 0e                	je     d7f9 <lodepng_inspect+0x24a>
    d7eb:	8b 45 10             	mov    0x10(%ebp),%eax
    d7ee:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    d7f4:	e9 b8 00 00 00       	jmp    d8b1 <lodepng_inspect+0x302>
  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
    d7f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d7fc:	8b 00                	mov    (%eax),%eax
    d7fe:	85 c0                	test   %eax,%eax
    d800:	74 17                	je     d819 <lodepng_inspect+0x26a>
    d802:	8b 45 10             	mov    0x10(%ebp),%eax
    d805:	c7 80 7c 01 00 00 20 	movl   $0x20,0x17c(%eax)
    d80c:	00 00 00 
    d80f:	b8 20 00 00 00       	mov    $0x20,%eax
    d814:	e9 98 00 00 00       	jmp    d8b1 <lodepng_inspect+0x302>
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
    d819:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d81c:	8b 40 04             	mov    0x4(%eax),%eax
    d81f:	85 c0                	test   %eax,%eax
    d821:	74 14                	je     d837 <lodepng_inspect+0x288>
    d823:	8b 45 10             	mov    0x10(%ebp),%eax
    d826:	c7 80 7c 01 00 00 21 	movl   $0x21,0x17c(%eax)
    d82d:	00 00 00 
    d830:	b8 21 00 00 00       	mov    $0x21,%eax
    d835:	eb 7a                	jmp    d8b1 <lodepng_inspect+0x302>
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);
    d837:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d83a:	8b 40 08             	mov    0x8(%eax),%eax
    d83d:	83 f8 01             	cmp    $0x1,%eax
    d840:	76 14                	jbe    d856 <lodepng_inspect+0x2a7>
    d842:	8b 45 10             	mov    0x10(%ebp),%eax
    d845:	c7 80 7c 01 00 00 22 	movl   $0x22,0x17c(%eax)
    d84c:	00 00 00 
    d84f:	b8 22 00 00 00       	mov    $0x22,%eax
    d854:	eb 5b                	jmp    d8b1 <lodepng_inspect+0x302>

  if(!state->decoder.ignore_crc) {
    d856:	8b 45 10             	mov    0x10(%ebp),%eax
    d859:	8b 40 18             	mov    0x18(%eax),%eax
    d85c:	85 c0                	test   %eax,%eax
    d85e:	75 48                	jne    d8a8 <lodepng_inspect+0x2f9>
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    d860:	8b 45 14             	mov    0x14(%ebp),%eax
    d863:	83 c0 1d             	add    $0x1d,%eax
    d866:	83 ec 0c             	sub    $0xc,%esp
    d869:	50                   	push   %eax
    d86a:	e8 f6 60 ff ff       	call   3965 <lodepng_read32bitInt>
    d86f:	83 c4 10             	add    $0x10,%esp
    d872:	89 45 e8             	mov    %eax,-0x18(%ebp)
    unsigned checksum = lodepng_crc32(&in[12], 17);
    d875:	8b 45 14             	mov    0x14(%ebp),%eax
    d878:	83 c0 0c             	add    $0xc,%eax
    d87b:	83 ec 08             	sub    $0x8,%esp
    d87e:	6a 11                	push   $0x11
    d880:	50                   	push   %eax
    d881:	e8 71 ab ff ff       	call   83f7 <lodepng_crc32>
    d886:	83 c4 10             	add    $0x10,%esp
    d889:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(CRC != checksum) {
    d88c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    d88f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    d892:	74 14                	je     d8a8 <lodepng_inspect+0x2f9>
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    d894:	8b 45 10             	mov    0x10(%ebp),%eax
    d897:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
    d89e:	00 00 00 
    d8a1:	b8 39 00 00 00       	mov    $0x39,%eax
    d8a6:	eb 09                	jmp    d8b1 <lodepng_inspect+0x302>
    }
  }

  return state->error;
    d8a8:	8b 45 10             	mov    0x10(%ebp),%eax
    d8ab:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
    d8b1:	c9                   	leave  
    d8b2:	c3                   	ret    

0000d8b3 <unfilterScanline>:

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length) {
    d8b3:	55                   	push   %ebp
    d8b4:	89 e5                	mov    %esp,%ebp
    d8b6:	56                   	push   %esi
    d8b7:	53                   	push   %ebx
    d8b8:	83 ec 44             	sub    $0x44,%esp
    d8bb:	8b 45 18             	mov    0x18(%ebp),%eax
    d8be:	88 45 b4             	mov    %al,-0x4c(%ebp)
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType) {
    d8c1:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
    d8c5:	83 f8 04             	cmp    $0x4,%eax
    d8c8:	0f 87 81 07 00 00    	ja     e04f <unfilterScanline+0x79c>
    d8ce:	8b 04 85 14 a3 01 00 	mov    0x1a314(,%eax,4),%eax
    d8d5:	ff e0                	jmp    *%eax
    case 0:
      for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d8d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d8de:	eb 19                	jmp    d8f9 <unfilterScanline+0x46>
    d8e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d8e3:	8b 45 08             	mov    0x8(%ebp),%eax
    d8e6:	01 c2                	add    %eax,%edx
    d8e8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d8eb:	8b 45 0c             	mov    0xc(%ebp),%eax
    d8ee:	01 c8                	add    %ecx,%eax
    d8f0:	0f b6 00             	movzbl (%eax),%eax
    d8f3:	88 02                	mov    %al,(%edx)
    d8f5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d8f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d8fc:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d8ff:	75 df                	jne    d8e0 <unfilterScanline+0x2d>
      break;
    d901:	e9 50 07 00 00       	jmp    e056 <unfilterScanline+0x7a3>
    case 1:
      for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    d906:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d90d:	eb 19                	jmp    d928 <unfilterScanline+0x75>
    d90f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d912:	8b 45 08             	mov    0x8(%ebp),%eax
    d915:	01 c2                	add    %eax,%edx
    d917:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d91a:	8b 45 0c             	mov    0xc(%ebp),%eax
    d91d:	01 c8                	add    %ecx,%eax
    d91f:	0f b6 00             	movzbl (%eax),%eax
    d922:	88 02                	mov    %al,(%edx)
    d924:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d928:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d92b:	3b 45 14             	cmp    0x14(%ebp),%eax
    d92e:	75 df                	jne    d90f <unfilterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
    d930:	8b 45 14             	mov    0x14(%ebp),%eax
    d933:	89 45 f4             	mov    %eax,-0xc(%ebp)
    d936:	eb 2b                	jmp    d963 <unfilterScanline+0xb0>
    d938:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d93b:	8b 45 08             	mov    0x8(%ebp),%eax
    d93e:	01 c2                	add    %eax,%edx
    d940:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d943:	8b 45 0c             	mov    0xc(%ebp),%eax
    d946:	01 c8                	add    %ecx,%eax
    d948:	0f b6 08             	movzbl (%eax),%ecx
    d94b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d94e:	2b 45 14             	sub    0x14(%ebp),%eax
    d951:	89 c3                	mov    %eax,%ebx
    d953:	8b 45 08             	mov    0x8(%ebp),%eax
    d956:	01 d8                	add    %ebx,%eax
    d958:	0f b6 00             	movzbl (%eax),%eax
    d95b:	01 c8                	add    %ecx,%eax
    d95d:	88 02                	mov    %al,(%edx)
    d95f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d963:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d966:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d969:	7c cd                	jl     d938 <unfilterScanline+0x85>
      break;
    d96b:	e9 e6 06 00 00       	jmp    e056 <unfilterScanline+0x7a3>
    case 2:
      if(precon) {
    d970:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d974:	74 3c                	je     d9b2 <unfilterScanline+0xff>
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
    d976:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d97d:	eb 26                	jmp    d9a5 <unfilterScanline+0xf2>
    d97f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d982:	8b 45 08             	mov    0x8(%ebp),%eax
    d985:	01 d0                	add    %edx,%eax
    d987:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d98a:	8b 55 0c             	mov    0xc(%ebp),%edx
    d98d:	01 ca                	add    %ecx,%edx
    d98f:	0f b6 0a             	movzbl (%edx),%ecx
    d992:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    d995:	8b 55 10             	mov    0x10(%ebp),%edx
    d998:	01 da                	add    %ebx,%edx
    d99a:	0f b6 12             	movzbl (%edx),%edx
    d99d:	01 ca                	add    %ecx,%edx
    d99f:	88 10                	mov    %dl,(%eax)
    d9a1:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d9a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9a8:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d9ab:	75 d2                	jne    d97f <unfilterScanline+0xcc>
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
      }
      break;
    d9ad:	e9 a4 06 00 00       	jmp    e056 <unfilterScanline+0x7a3>
      break;
    case 2:
      if(precon) {
        for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
      } else {
        for(i = 0; i != length; ++i) recon[i] = scanline[i];
    d9b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d9b9:	eb 19                	jmp    d9d4 <unfilterScanline+0x121>
    d9bb:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d9be:	8b 45 08             	mov    0x8(%ebp),%eax
    d9c1:	01 c2                	add    %eax,%edx
    d9c3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d9c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    d9c9:	01 c8                	add    %ecx,%eax
    d9cb:	0f b6 00             	movzbl (%eax),%eax
    d9ce:	88 02                	mov    %al,(%edx)
    d9d0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    d9d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
    d9d7:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    d9da:	75 df                	jne    d9bb <unfilterScanline+0x108>
      }
      break;
    d9dc:	e9 75 06 00 00       	jmp    e056 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
    d9e1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    d9e5:	0f 84 8e 00 00 00    	je     da79 <unfilterScanline+0x1c6>
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
    d9eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    d9f2:	eb 28                	jmp    da1c <unfilterScanline+0x169>
    d9f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
    d9f7:	8b 45 08             	mov    0x8(%ebp),%eax
    d9fa:	01 d0                	add    %edx,%eax
    d9fc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    d9ff:	8b 55 0c             	mov    0xc(%ebp),%edx
    da02:	01 ca                	add    %ecx,%edx
    da04:	0f b6 12             	movzbl (%edx),%edx
    da07:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    da0a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    da0d:	01 d9                	add    %ebx,%ecx
    da0f:	0f b6 09             	movzbl (%ecx),%ecx
    da12:	d0 e9                	shr    %cl
    da14:	01 ca                	add    %ecx,%edx
    da16:	88 10                	mov    %dl,(%eax)
    da18:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    da1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da1f:	3b 45 14             	cmp    0x14(%ebp),%eax
    da22:	75 d0                	jne    d9f4 <unfilterScanline+0x141>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
    da24:	8b 45 14             	mov    0x14(%ebp),%eax
    da27:	89 45 f4             	mov    %eax,-0xc(%ebp)
    da2a:	eb 40                	jmp    da6c <unfilterScanline+0x1b9>
    da2c:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da2f:	8b 45 08             	mov    0x8(%ebp),%eax
    da32:	01 c2                	add    %eax,%edx
    da34:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    da37:	8b 45 0c             	mov    0xc(%ebp),%eax
    da3a:	01 c8                	add    %ecx,%eax
    da3c:	0f b6 08             	movzbl (%eax),%ecx
    da3f:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da42:	2b 45 14             	sub    0x14(%ebp),%eax
    da45:	89 c3                	mov    %eax,%ebx
    da47:	8b 45 08             	mov    0x8(%ebp),%eax
    da4a:	01 d8                	add    %ebx,%eax
    da4c:	0f b6 00             	movzbl (%eax),%eax
    da4f:	0f b6 d8             	movzbl %al,%ebx
    da52:	8b 75 f4             	mov    -0xc(%ebp),%esi
    da55:	8b 45 10             	mov    0x10(%ebp),%eax
    da58:	01 f0                	add    %esi,%eax
    da5a:	0f b6 00             	movzbl (%eax),%eax
    da5d:	0f b6 c0             	movzbl %al,%eax
    da60:	01 d8                	add    %ebx,%eax
    da62:	d1 f8                	sar    %eax
    da64:	01 c8                	add    %ecx,%eax
    da66:	88 02                	mov    %al,(%edx)
    da68:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    da6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da6f:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    da72:	7c b8                	jl     da2c <unfilterScanline+0x179>
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    da74:	e9 dd 05 00 00       	jmp    e056 <unfilterScanline+0x7a3>
    case 3:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + (precon[i] >> 1u);
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) >> 1u);
      } else {
        for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
    da79:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    da80:	eb 19                	jmp    da9b <unfilterScanline+0x1e8>
    da82:	8b 55 f4             	mov    -0xc(%ebp),%edx
    da85:	8b 45 08             	mov    0x8(%ebp),%eax
    da88:	01 c2                	add    %eax,%edx
    da8a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    da8d:	8b 45 0c             	mov    0xc(%ebp),%eax
    da90:	01 c8                	add    %ecx,%eax
    da92:	0f b6 00             	movzbl (%eax),%eax
    da95:	88 02                	mov    %al,(%edx)
    da97:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    da9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    da9e:	3b 45 14             	cmp    0x14(%ebp),%eax
    daa1:	75 df                	jne    da82 <unfilterScanline+0x1cf>
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
    daa3:	8b 45 14             	mov    0x14(%ebp),%eax
    daa6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    daa9:	eb 2d                	jmp    dad8 <unfilterScanline+0x225>
    daab:	8b 55 f4             	mov    -0xc(%ebp),%edx
    daae:	8b 45 08             	mov    0x8(%ebp),%eax
    dab1:	01 c2                	add    %eax,%edx
    dab3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dab6:	8b 45 0c             	mov    0xc(%ebp),%eax
    dab9:	01 c8                	add    %ecx,%eax
    dabb:	0f b6 08             	movzbl (%eax),%ecx
    dabe:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dac1:	2b 45 14             	sub    0x14(%ebp),%eax
    dac4:	89 c3                	mov    %eax,%ebx
    dac6:	8b 45 08             	mov    0x8(%ebp),%eax
    dac9:	01 d8                	add    %ebx,%eax
    dacb:	0f b6 00             	movzbl (%eax),%eax
    dace:	d0 e8                	shr    %al
    dad0:	01 c8                	add    %ecx,%eax
    dad2:	88 02                	mov    %al,(%edx)
    dad4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dad8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dadb:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dade:	7c cb                	jl     daab <unfilterScanline+0x1f8>
      }
      break;
    dae0:	e9 71 05 00 00       	jmp    e056 <unfilterScanline+0x7a3>
    case 4:
      if(precon) {
    dae5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
    dae9:	0f 84 f9 04 00 00    	je     dfe8 <unfilterScanline+0x735>
        for(i = 0; i != bytewidth; ++i) {
    daef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    daf6:	eb 26                	jmp    db1e <unfilterScanline+0x26b>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
    daf8:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dafb:	8b 45 08             	mov    0x8(%ebp),%eax
    dafe:	01 d0                	add    %edx,%eax
    db00:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    db03:	8b 55 0c             	mov    0xc(%ebp),%edx
    db06:	01 ca                	add    %ecx,%edx
    db08:	0f b6 0a             	movzbl (%edx),%ecx
    db0b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
    db0e:	8b 55 10             	mov    0x10(%ebp),%edx
    db11:	01 da                	add    %ebx,%edx
    db13:	0f b6 12             	movzbl (%edx),%edx
    db16:	01 ca                	add    %ecx,%edx
    db18:	88 10                	mov    %dl,(%eax)
        for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + (recon[i - bytewidth] >> 1u);
      }
      break;
    case 4:
      if(precon) {
        for(i = 0; i != bytewidth; ++i) {
    db1a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    db1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db21:	3b 45 14             	cmp    0x14(%ebp),%eax
    db24:	75 d2                	jne    daf8 <unfilterScanline+0x245>
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
    db26:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
    db2a:	0f 8e db 01 00 00    	jle    dd0b <unfilterScanline+0x458>
          for(; i + 3 < length; i += 4) {
    db30:	e9 c2 01 00 00       	jmp    dcf7 <unfilterScanline+0x444>
            size_t j = i - bytewidth;
    db35:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db38:	2b 45 14             	sub    0x14(%ebp),%eax
    db3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2], s3 = scanline[i + 3];
    db3e:	8b 55 f4             	mov    -0xc(%ebp),%edx
    db41:	8b 45 0c             	mov    0xc(%ebp),%eax
    db44:	01 d0                	add    %edx,%eax
    db46:	0f b6 00             	movzbl (%eax),%eax
    db49:	88 45 ef             	mov    %al,-0x11(%ebp)
    db4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db4f:	8d 50 01             	lea    0x1(%eax),%edx
    db52:	8b 45 0c             	mov    0xc(%ebp),%eax
    db55:	01 d0                	add    %edx,%eax
    db57:	0f b6 00             	movzbl (%eax),%eax
    db5a:	88 45 ee             	mov    %al,-0x12(%ebp)
    db5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db60:	8d 50 02             	lea    0x2(%eax),%edx
    db63:	8b 45 0c             	mov    0xc(%ebp),%eax
    db66:	01 d0                	add    %edx,%eax
    db68:	0f b6 00             	movzbl (%eax),%eax
    db6b:	88 45 ed             	mov    %al,-0x13(%ebp)
    db6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    db71:	8d 50 03             	lea    0x3(%eax),%edx
    db74:	8b 45 0c             	mov    0xc(%ebp),%eax
    db77:	01 d0                	add    %edx,%eax
    db79:	0f b6 00             	movzbl (%eax),%eax
    db7c:	88 45 ec             	mov    %al,-0x14(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2], r3 = recon[j + 3];
    db7f:	8b 55 f0             	mov    -0x10(%ebp),%edx
    db82:	8b 45 08             	mov    0x8(%ebp),%eax
    db85:	01 d0                	add    %edx,%eax
    db87:	0f b6 00             	movzbl (%eax),%eax
    db8a:	88 45 eb             	mov    %al,-0x15(%ebp)
    db8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
    db90:	8d 50 01             	lea    0x1(%eax),%edx
    db93:	8b 45 08             	mov    0x8(%ebp),%eax
    db96:	01 d0                	add    %edx,%eax
    db98:	0f b6 00             	movzbl (%eax),%eax
    db9b:	88 45 ea             	mov    %al,-0x16(%ebp)
    db9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dba1:	8d 50 02             	lea    0x2(%eax),%edx
    dba4:	8b 45 08             	mov    0x8(%ebp),%eax
    dba7:	01 d0                	add    %edx,%eax
    dba9:	0f b6 00             	movzbl (%eax),%eax
    dbac:	88 45 e9             	mov    %al,-0x17(%ebp)
    dbaf:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dbb2:	8d 50 03             	lea    0x3(%eax),%edx
    dbb5:	8b 45 08             	mov    0x8(%ebp),%eax
    dbb8:	01 d0                	add    %edx,%eax
    dbba:	0f b6 00             	movzbl (%eax),%eax
    dbbd:	88 45 e8             	mov    %al,-0x18(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2], p3 = precon[i + 3];
    dbc0:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dbc3:	8b 45 10             	mov    0x10(%ebp),%eax
    dbc6:	01 d0                	add    %edx,%eax
    dbc8:	0f b6 00             	movzbl (%eax),%eax
    dbcb:	88 45 e7             	mov    %al,-0x19(%ebp)
    dbce:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbd1:	8d 50 01             	lea    0x1(%eax),%edx
    dbd4:	8b 45 10             	mov    0x10(%ebp),%eax
    dbd7:	01 d0                	add    %edx,%eax
    dbd9:	0f b6 00             	movzbl (%eax),%eax
    dbdc:	88 45 e6             	mov    %al,-0x1a(%ebp)
    dbdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbe2:	8d 50 02             	lea    0x2(%eax),%edx
    dbe5:	8b 45 10             	mov    0x10(%ebp),%eax
    dbe8:	01 d0                	add    %edx,%eax
    dbea:	0f b6 00             	movzbl (%eax),%eax
    dbed:	88 45 e5             	mov    %al,-0x1b(%ebp)
    dbf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dbf3:	8d 50 03             	lea    0x3(%eax),%edx
    dbf6:	8b 45 10             	mov    0x10(%ebp),%eax
    dbf9:	01 d0                	add    %edx,%eax
    dbfb:	0f b6 00             	movzbl (%eax),%eax
    dbfe:	88 45 e4             	mov    %al,-0x1c(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2], q3 = precon[j + 3];
    dc01:	8b 55 f0             	mov    -0x10(%ebp),%edx
    dc04:	8b 45 10             	mov    0x10(%ebp),%eax
    dc07:	01 d0                	add    %edx,%eax
    dc09:	0f b6 00             	movzbl (%eax),%eax
    dc0c:	88 45 e3             	mov    %al,-0x1d(%ebp)
    dc0f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dc12:	8d 50 01             	lea    0x1(%eax),%edx
    dc15:	8b 45 10             	mov    0x10(%ebp),%eax
    dc18:	01 d0                	add    %edx,%eax
    dc1a:	0f b6 00             	movzbl (%eax),%eax
    dc1d:	88 45 e2             	mov    %al,-0x1e(%ebp)
    dc20:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dc23:	8d 50 02             	lea    0x2(%eax),%edx
    dc26:	8b 45 10             	mov    0x10(%ebp),%eax
    dc29:	01 d0                	add    %edx,%eax
    dc2b:	0f b6 00             	movzbl (%eax),%eax
    dc2e:	88 45 e1             	mov    %al,-0x1f(%ebp)
    dc31:	8b 45 f0             	mov    -0x10(%ebp),%eax
    dc34:	8d 50 03             	lea    0x3(%eax),%edx
    dc37:	8b 45 10             	mov    0x10(%ebp),%eax
    dc3a:	01 d0                	add    %edx,%eax
    dc3c:	0f b6 00             	movzbl (%eax),%eax
    dc3f:	88 45 e0             	mov    %al,-0x20(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dc42:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dc45:	8b 45 08             	mov    0x8(%ebp),%eax
    dc48:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc4b:	0f b6 4d e3          	movzbl -0x1d(%ebp),%ecx
    dc4f:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
    dc53:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
    dc57:	51                   	push   %ecx
    dc58:	52                   	push   %edx
    dc59:	50                   	push   %eax
    dc5a:	e8 3f f6 ff ff       	call   d29e <paethPredictor>
    dc5f:	83 c4 0c             	add    $0xc,%esp
    dc62:	89 c2                	mov    %eax,%edx
    dc64:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
    dc68:	01 d0                	add    %edx,%eax
    dc6a:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    dc6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc6f:	8d 50 01             	lea    0x1(%eax),%edx
    dc72:	8b 45 08             	mov    0x8(%ebp),%eax
    dc75:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dc78:	0f b6 4d e2          	movzbl -0x1e(%ebp),%ecx
    dc7c:	0f b6 55 e6          	movzbl -0x1a(%ebp),%edx
    dc80:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
    dc84:	51                   	push   %ecx
    dc85:	52                   	push   %edx
    dc86:	50                   	push   %eax
    dc87:	e8 12 f6 ff ff       	call   d29e <paethPredictor>
    dc8c:	83 c4 0c             	add    $0xc,%esp
    dc8f:	89 c2                	mov    %eax,%edx
    dc91:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
    dc95:	01 d0                	add    %edx,%eax
    dc97:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    dc99:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dc9c:	8d 50 02             	lea    0x2(%eax),%edx
    dc9f:	8b 45 08             	mov    0x8(%ebp),%eax
    dca2:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dca5:	0f b6 4d e1          	movzbl -0x1f(%ebp),%ecx
    dca9:	0f b6 55 e5          	movzbl -0x1b(%ebp),%edx
    dcad:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
    dcb1:	51                   	push   %ecx
    dcb2:	52                   	push   %edx
    dcb3:	50                   	push   %eax
    dcb4:	e8 e5 f5 ff ff       	call   d29e <paethPredictor>
    dcb9:	83 c4 0c             	add    $0xc,%esp
    dcbc:	89 c2                	mov    %eax,%edx
    dcbe:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
    dcc2:	01 d0                	add    %edx,%eax
    dcc4:	88 03                	mov    %al,(%ebx)
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
    dcc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcc9:	8d 50 03             	lea    0x3(%eax),%edx
    dccc:	8b 45 08             	mov    0x8(%ebp),%eax
    dccf:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    dcd2:	0f b6 4d e0          	movzbl -0x20(%ebp),%ecx
    dcd6:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
    dcda:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
    dcde:	51                   	push   %ecx
    dcdf:	52                   	push   %edx
    dce0:	50                   	push   %eax
    dce1:	e8 b8 f5 ff ff       	call   d29e <paethPredictor>
    dce6:	83 c4 0c             	add    $0xc,%esp
    dce9:	89 c2                	mov    %eax,%edx
    dceb:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
    dcef:	01 d0                	add    %edx,%eax
    dcf1:	88 03                	mov    %al,(%ebx)
        }

        /* Unroll independent paths of the paeth predictor. A 6x and 8x version would also be possible but that
        adds too much code. Whether this actually speeds anything up at all depends on compiler and settings. */
        if(bytewidth >= 4) {
          for(; i + 3 < length; i += 4) {
    dcf3:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
    dcf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dcfa:	83 c0 03             	add    $0x3,%eax
    dcfd:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dd00:	0f 8c 2f fe ff ff    	jl     db35 <unfilterScanline+0x282>
    dd06:	e9 d3 02 00 00       	jmp    dfde <unfilterScanline+0x72b>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
    dd0b:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
    dd0f:	0f 8e 6a 01 00 00    	jle    de7f <unfilterScanline+0x5cc>
          for(; i + 2 < length; i += 3) {
    dd15:	e9 51 01 00 00       	jmp    de6b <unfilterScanline+0x5b8>
            size_t j = i - bytewidth;
    dd1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd1d:	2b 45 14             	sub    0x14(%ebp),%eax
    dd20:	89 45 dc             	mov    %eax,-0x24(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1], s2 = scanline[i + 2];
    dd23:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd26:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd29:	01 d0                	add    %edx,%eax
    dd2b:	0f b6 00             	movzbl (%eax),%eax
    dd2e:	88 45 db             	mov    %al,-0x25(%ebp)
    dd31:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd34:	8d 50 01             	lea    0x1(%eax),%edx
    dd37:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd3a:	01 d0                	add    %edx,%eax
    dd3c:	0f b6 00             	movzbl (%eax),%eax
    dd3f:	88 45 da             	mov    %al,-0x26(%ebp)
    dd42:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd45:	8d 50 02             	lea    0x2(%eax),%edx
    dd48:	8b 45 0c             	mov    0xc(%ebp),%eax
    dd4b:	01 d0                	add    %edx,%eax
    dd4d:	0f b6 00             	movzbl (%eax),%eax
    dd50:	88 45 d9             	mov    %al,-0x27(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1], r2 = recon[j + 2];
    dd53:	8b 55 dc             	mov    -0x24(%ebp),%edx
    dd56:	8b 45 08             	mov    0x8(%ebp),%eax
    dd59:	01 d0                	add    %edx,%eax
    dd5b:	0f b6 00             	movzbl (%eax),%eax
    dd5e:	88 45 d8             	mov    %al,-0x28(%ebp)
    dd61:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dd64:	8d 50 01             	lea    0x1(%eax),%edx
    dd67:	8b 45 08             	mov    0x8(%ebp),%eax
    dd6a:	01 d0                	add    %edx,%eax
    dd6c:	0f b6 00             	movzbl (%eax),%eax
    dd6f:	88 45 d7             	mov    %al,-0x29(%ebp)
    dd72:	8b 45 dc             	mov    -0x24(%ebp),%eax
    dd75:	8d 50 02             	lea    0x2(%eax),%edx
    dd78:	8b 45 08             	mov    0x8(%ebp),%eax
    dd7b:	01 d0                	add    %edx,%eax
    dd7d:	0f b6 00             	movzbl (%eax),%eax
    dd80:	88 45 d6             	mov    %al,-0x2a(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1], p2 = precon[i + 2];
    dd83:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dd86:	8b 45 10             	mov    0x10(%ebp),%eax
    dd89:	01 d0                	add    %edx,%eax
    dd8b:	0f b6 00             	movzbl (%eax),%eax
    dd8e:	88 45 d5             	mov    %al,-0x2b(%ebp)
    dd91:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dd94:	8d 50 01             	lea    0x1(%eax),%edx
    dd97:	8b 45 10             	mov    0x10(%ebp),%eax
    dd9a:	01 d0                	add    %edx,%eax
    dd9c:	0f b6 00             	movzbl (%eax),%eax
    dd9f:	88 45 d4             	mov    %al,-0x2c(%ebp)
    dda2:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dda5:	8d 50 02             	lea    0x2(%eax),%edx
    dda8:	8b 45 10             	mov    0x10(%ebp),%eax
    ddab:	01 d0                	add    %edx,%eax
    ddad:	0f b6 00             	movzbl (%eax),%eax
    ddb0:	88 45 d3             	mov    %al,-0x2d(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
    ddb3:	8b 55 dc             	mov    -0x24(%ebp),%edx
    ddb6:	8b 45 10             	mov    0x10(%ebp),%eax
    ddb9:	01 d0                	add    %edx,%eax
    ddbb:	0f b6 00             	movzbl (%eax),%eax
    ddbe:	88 45 d2             	mov    %al,-0x2e(%ebp)
    ddc1:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ddc4:	8d 50 01             	lea    0x1(%eax),%edx
    ddc7:	8b 45 10             	mov    0x10(%ebp),%eax
    ddca:	01 d0                	add    %edx,%eax
    ddcc:	0f b6 00             	movzbl (%eax),%eax
    ddcf:	88 45 d1             	mov    %al,-0x2f(%ebp)
    ddd2:	8b 45 dc             	mov    -0x24(%ebp),%eax
    ddd5:	8d 50 02             	lea    0x2(%eax),%edx
    ddd8:	8b 45 10             	mov    0x10(%ebp),%eax
    dddb:	01 d0                	add    %edx,%eax
    dddd:	0f b6 00             	movzbl (%eax),%eax
    dde0:	88 45 d0             	mov    %al,-0x30(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    dde3:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dde6:	8b 45 08             	mov    0x8(%ebp),%eax
    dde9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    ddec:	0f b6 4d d2          	movzbl -0x2e(%ebp),%ecx
    ddf0:	0f b6 55 d5          	movzbl -0x2b(%ebp),%edx
    ddf4:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
    ddf8:	51                   	push   %ecx
    ddf9:	52                   	push   %edx
    ddfa:	50                   	push   %eax
    ddfb:	e8 9e f4 ff ff       	call   d29e <paethPredictor>
    de00:	83 c4 0c             	add    $0xc,%esp
    de03:	89 c2                	mov    %eax,%edx
    de05:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
    de09:	01 d0                	add    %edx,%eax
    de0b:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    de0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de10:	8d 50 01             	lea    0x1(%eax),%edx
    de13:	8b 45 08             	mov    0x8(%ebp),%eax
    de16:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    de19:	0f b6 4d d1          	movzbl -0x2f(%ebp),%ecx
    de1d:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
    de21:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
    de25:	51                   	push   %ecx
    de26:	52                   	push   %edx
    de27:	50                   	push   %eax
    de28:	e8 71 f4 ff ff       	call   d29e <paethPredictor>
    de2d:	83 c4 0c             	add    $0xc,%esp
    de30:	89 c2                	mov    %eax,%edx
    de32:	0f b6 45 da          	movzbl -0x26(%ebp),%eax
    de36:	01 d0                	add    %edx,%eax
    de38:	88 03                	mov    %al,(%ebx)
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
    de3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de3d:	8d 50 02             	lea    0x2(%eax),%edx
    de40:	8b 45 08             	mov    0x8(%ebp),%eax
    de43:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    de46:	0f b6 4d d0          	movzbl -0x30(%ebp),%ecx
    de4a:	0f b6 55 d3          	movzbl -0x2d(%ebp),%edx
    de4e:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
    de52:	51                   	push   %ecx
    de53:	52                   	push   %edx
    de54:	50                   	push   %eax
    de55:	e8 44 f4 ff ff       	call   d29e <paethPredictor>
    de5a:	83 c4 0c             	add    $0xc,%esp
    de5d:	89 c2                	mov    %eax,%edx
    de5f:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
    de63:	01 d0                	add    %edx,%eax
    de65:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
            recon[i + 3] = s3 + paethPredictor(r3, p3, q3);
          }
        } else if(bytewidth >= 3) {
          for(; i + 2 < length; i += 3) {
    de67:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
    de6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de6e:	83 c0 02             	add    $0x2,%eax
    de71:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    de74:	0f 8c a0 fe ff ff    	jl     dd1a <unfilterScanline+0x467>
    de7a:	e9 5f 01 00 00       	jmp    dfde <unfilterScanline+0x72b>
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1], q2 = precon[j + 2];
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
    de7f:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
    de83:	0f 8e 55 01 00 00    	jle    dfde <unfilterScanline+0x72b>
          for(; i + 1 < length; i += 2) {
    de89:	e9 e0 00 00 00       	jmp    df6e <unfilterScanline+0x6bb>
            size_t j = i - bytewidth;
    de8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    de91:	2b 45 14             	sub    0x14(%ebp),%eax
    de94:	89 45 cc             	mov    %eax,-0x34(%ebp)
            unsigned char s0 = scanline[i + 0], s1 = scanline[i + 1];
    de97:	8b 55 f4             	mov    -0xc(%ebp),%edx
    de9a:	8b 45 0c             	mov    0xc(%ebp),%eax
    de9d:	01 d0                	add    %edx,%eax
    de9f:	0f b6 00             	movzbl (%eax),%eax
    dea2:	88 45 cb             	mov    %al,-0x35(%ebp)
    dea5:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dea8:	8d 50 01             	lea    0x1(%eax),%edx
    deab:	8b 45 0c             	mov    0xc(%ebp),%eax
    deae:	01 d0                	add    %edx,%eax
    deb0:	0f b6 00             	movzbl (%eax),%eax
    deb3:	88 45 ca             	mov    %al,-0x36(%ebp)
            unsigned char r0 = recon[j + 0], r1 = recon[j + 1];
    deb6:	8b 55 cc             	mov    -0x34(%ebp),%edx
    deb9:	8b 45 08             	mov    0x8(%ebp),%eax
    debc:	01 d0                	add    %edx,%eax
    debe:	0f b6 00             	movzbl (%eax),%eax
    dec1:	88 45 c9             	mov    %al,-0x37(%ebp)
    dec4:	8b 45 cc             	mov    -0x34(%ebp),%eax
    dec7:	8d 50 01             	lea    0x1(%eax),%edx
    deca:	8b 45 08             	mov    0x8(%ebp),%eax
    decd:	01 d0                	add    %edx,%eax
    decf:	0f b6 00             	movzbl (%eax),%eax
    ded2:	88 45 c8             	mov    %al,-0x38(%ebp)
            unsigned char p0 = precon[i + 0], p1 = precon[i + 1];
    ded5:	8b 55 f4             	mov    -0xc(%ebp),%edx
    ded8:	8b 45 10             	mov    0x10(%ebp),%eax
    dedb:	01 d0                	add    %edx,%eax
    dedd:	0f b6 00             	movzbl (%eax),%eax
    dee0:	88 45 c7             	mov    %al,-0x39(%ebp)
    dee3:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dee6:	8d 50 01             	lea    0x1(%eax),%edx
    dee9:	8b 45 10             	mov    0x10(%ebp),%eax
    deec:	01 d0                	add    %edx,%eax
    deee:	0f b6 00             	movzbl (%eax),%eax
    def1:	88 45 c6             	mov    %al,-0x3a(%ebp)
            unsigned char q0 = precon[j + 0], q1 = precon[j + 1];
    def4:	8b 55 cc             	mov    -0x34(%ebp),%edx
    def7:	8b 45 10             	mov    0x10(%ebp),%eax
    defa:	01 d0                	add    %edx,%eax
    defc:	0f b6 00             	movzbl (%eax),%eax
    deff:	88 45 c5             	mov    %al,-0x3b(%ebp)
    df02:	8b 45 cc             	mov    -0x34(%ebp),%eax
    df05:	8d 50 01             	lea    0x1(%eax),%edx
    df08:	8b 45 10             	mov    0x10(%ebp),%eax
    df0b:	01 d0                	add    %edx,%eax
    df0d:	0f b6 00             	movzbl (%eax),%eax
    df10:	88 45 c4             	mov    %al,-0x3c(%ebp)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
    df13:	8b 55 f4             	mov    -0xc(%ebp),%edx
    df16:	8b 45 08             	mov    0x8(%ebp),%eax
    df19:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    df1c:	0f b6 4d c5          	movzbl -0x3b(%ebp),%ecx
    df20:	0f b6 55 c7          	movzbl -0x39(%ebp),%edx
    df24:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
    df28:	51                   	push   %ecx
    df29:	52                   	push   %edx
    df2a:	50                   	push   %eax
    df2b:	e8 6e f3 ff ff       	call   d29e <paethPredictor>
    df30:	83 c4 0c             	add    $0xc,%esp
    df33:	89 c2                	mov    %eax,%edx
    df35:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
    df39:	01 d0                	add    %edx,%eax
    df3b:	88 03                	mov    %al,(%ebx)
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
    df3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df40:	8d 50 01             	lea    0x1(%eax),%edx
    df43:	8b 45 08             	mov    0x8(%ebp),%eax
    df46:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    df49:	0f b6 4d c4          	movzbl -0x3c(%ebp),%ecx
    df4d:	0f b6 55 c6          	movzbl -0x3a(%ebp),%edx
    df51:	0f b6 45 c8          	movzbl -0x38(%ebp),%eax
    df55:	51                   	push   %ecx
    df56:	52                   	push   %edx
    df57:	50                   	push   %eax
    df58:	e8 41 f3 ff ff       	call   d29e <paethPredictor>
    df5d:	83 c4 0c             	add    $0xc,%esp
    df60:	89 c2                	mov    %eax,%edx
    df62:	0f b6 45 ca          	movzbl -0x36(%ebp),%eax
    df66:	01 d0                	add    %edx,%eax
    df68:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
            recon[i + 2] = s2 + paethPredictor(r2, p2, q2);
          }
        } else if(bytewidth >= 2) {
          for(; i + 1 < length; i += 2) {
    df6a:	83 45 f4 02          	addl   $0x2,-0xc(%ebp)
    df6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df71:	83 c0 01             	add    $0x1,%eax
    df74:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    df77:	0f 8c 11 ff ff ff    	jl     de8e <unfilterScanline+0x5db>
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    df7d:	eb 5f                	jmp    dfde <unfilterScanline+0x72b>
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
    df7f:	8b 55 f4             	mov    -0xc(%ebp),%edx
    df82:	8b 45 08             	mov    0x8(%ebp),%eax
    df85:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
    df88:	8b 55 f4             	mov    -0xc(%ebp),%edx
    df8b:	8b 45 0c             	mov    0xc(%ebp),%eax
    df8e:	01 d0                	add    %edx,%eax
    df90:	0f b6 00             	movzbl (%eax),%eax
    df93:	88 45 b7             	mov    %al,-0x49(%ebp)
    df96:	8b 45 f4             	mov    -0xc(%ebp),%eax
    df99:	2b 45 14             	sub    0x14(%ebp),%eax
    df9c:	89 c2                	mov    %eax,%edx
    df9e:	8b 45 10             	mov    0x10(%ebp),%eax
    dfa1:	01 d0                	add    %edx,%eax
    dfa3:	0f b6 00             	movzbl (%eax),%eax
    dfa6:	0f b6 c8             	movzbl %al,%ecx
    dfa9:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dfac:	8b 45 10             	mov    0x10(%ebp),%eax
    dfaf:	01 d0                	add    %edx,%eax
    dfb1:	0f b6 00             	movzbl (%eax),%eax
    dfb4:	0f b6 d0             	movzbl %al,%edx
    dfb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dfba:	2b 45 14             	sub    0x14(%ebp),%eax
    dfbd:	89 c6                	mov    %eax,%esi
    dfbf:	8b 45 08             	mov    0x8(%ebp),%eax
    dfc2:	01 f0                	add    %esi,%eax
    dfc4:	0f b6 00             	movzbl (%eax),%eax
    dfc7:	0f b6 c0             	movzbl %al,%eax
    dfca:	51                   	push   %ecx
    dfcb:	52                   	push   %edx
    dfcc:	50                   	push   %eax
    dfcd:	e8 cc f2 ff ff       	call   d29e <paethPredictor>
    dfd2:	83 c4 0c             	add    $0xc,%esp
    dfd5:	02 45 b7             	add    -0x49(%ebp),%al
    dfd8:	88 03                	mov    %al,(%ebx)
            recon[i + 0] = s0 + paethPredictor(r0, p0, q0);
            recon[i + 1] = s1 + paethPredictor(r1, p1, q1);
          }
        }

        for(; i != length; ++i) {
    dfda:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    dfde:	8b 45 f4             	mov    -0xc(%ebp),%eax
    dfe1:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    dfe4:	75 99                	jne    df7f <unfilterScanline+0x6cc>
        for(i = bytewidth; i < length; ++i) {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    dfe6:	eb 6e                	jmp    e056 <unfilterScanline+0x7a3>

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    dfe8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    dfef:	eb 19                	jmp    e00a <unfilterScanline+0x757>
          recon[i] = scanline[i];
    dff1:	8b 55 f4             	mov    -0xc(%ebp),%edx
    dff4:	8b 45 08             	mov    0x8(%ebp),%eax
    dff7:	01 c2                	add    %eax,%edx
    dff9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    dffc:	8b 45 0c             	mov    0xc(%ebp),%eax
    dfff:	01 c8                	add    %ecx,%eax
    e001:	0f b6 00             	movzbl (%eax),%eax
    e004:	88 02                	mov    %al,(%edx)

        for(; i != length; ++i) {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
    e006:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e00a:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e00d:	3b 45 14             	cmp    0x14(%ebp),%eax
    e010:	75 df                	jne    dff1 <unfilterScanline+0x73e>
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    e012:	8b 45 14             	mov    0x14(%ebp),%eax
    e015:	89 45 f4             	mov    %eax,-0xc(%ebp)
    e018:	eb 2b                	jmp    e045 <unfilterScanline+0x792>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
    e01a:	8b 55 f4             	mov    -0xc(%ebp),%edx
    e01d:	8b 45 08             	mov    0x8(%ebp),%eax
    e020:	01 c2                	add    %eax,%edx
    e022:	8b 4d f4             	mov    -0xc(%ebp),%ecx
    e025:	8b 45 0c             	mov    0xc(%ebp),%eax
    e028:	01 c8                	add    %ecx,%eax
    e02a:	0f b6 08             	movzbl (%eax),%ecx
    e02d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e030:	2b 45 14             	sub    0x14(%ebp),%eax
    e033:	89 c3                	mov    %eax,%ebx
    e035:	8b 45 08             	mov    0x8(%ebp),%eax
    e038:	01 d8                	add    %ebx,%eax
    e03a:	0f b6 00             	movzbl (%eax),%eax
    e03d:	01 c8                	add    %ecx,%eax
    e03f:	88 02                	mov    %al,(%edx)
        }
      } else {
        for(i = 0; i != bytewidth; ++i) {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; ++i) {
    e041:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e045:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e048:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    e04b:	7c cd                	jl     e01a <unfilterScanline+0x767>
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    e04d:	eb 07                	jmp    e056 <unfilterScanline+0x7a3>
    default: return 36; /*error: invalid filter type given*/
    e04f:	b8 24 00 00 00       	mov    $0x24,%eax
    e054:	eb 05                	jmp    e05b <unfilterScanline+0x7a8>
  }
  return 0;
    e056:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e05b:	8d 65 f8             	lea    -0x8(%ebp),%esp
    e05e:	5b                   	pop    %ebx
    e05f:	5e                   	pop    %esi
    e060:	5d                   	pop    %ebp
    e061:	c3                   	ret    

0000e062 <unfilter>:

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    e062:	55                   	push   %ebp
    e063:	89 e5                	mov    %esp,%ebp
    e065:	53                   	push   %ebx
    e066:	83 ec 20             	sub    $0x20,%esp
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;
    e069:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
    e070:	8b 45 18             	mov    0x18(%ebp),%eax
    e073:	83 c0 07             	add    $0x7,%eax
    e076:	c1 e8 03             	shr    $0x3,%eax
    e079:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
    e07c:	ff 75 18             	pushl  0x18(%ebp)
    e07f:	6a 01                	push   $0x1
    e081:	ff 75 10             	pushl  0x10(%ebp)
    e084:	e8 d9 b1 ff ff       	call   9262 <lodepng_get_raw_size_idat>
    e089:	83 c4 0c             	add    $0xc,%esp
    e08c:	83 e8 01             	sub    $0x1,%eax
    e08f:	89 45 ec             	mov    %eax,-0x14(%ebp)

  for(y = 0; y < h; ++y) {
    e092:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e099:	eb 6d                	jmp    e108 <unfilter+0xa6>
    size_t outindex = linebytes * y;
    e09b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e09e:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e0a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    e0a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e0a8:	83 c0 01             	add    $0x1,%eax
    e0ab:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e0af:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char filterType = in[inindex];
    e0b2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e0b5:	8b 45 0c             	mov    0xc(%ebp),%eax
    e0b8:	01 d0                	add    %edx,%eax
    e0ba:	0f b6 00             	movzbl (%eax),%eax
    e0bd:	88 45 e3             	mov    %al,-0x1d(%ebp)

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));
    e0c0:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
    e0c4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    e0c7:	8d 4a 01             	lea    0x1(%edx),%ecx
    e0ca:	8b 55 0c             	mov    0xc(%ebp),%edx
    e0cd:	01 d1                	add    %edx,%ecx
    e0cf:	8b 5d e8             	mov    -0x18(%ebp),%ebx
    e0d2:	8b 55 08             	mov    0x8(%ebp),%edx
    e0d5:	01 da                	add    %ebx,%edx
    e0d7:	ff 75 ec             	pushl  -0x14(%ebp)
    e0da:	50                   	push   %eax
    e0db:	ff 75 f0             	pushl  -0x10(%ebp)
    e0de:	ff 75 f4             	pushl  -0xc(%ebp)
    e0e1:	51                   	push   %ecx
    e0e2:	52                   	push   %edx
    e0e3:	e8 cb f7 ff ff       	call   d8b3 <unfilterScanline>
    e0e8:	83 c4 18             	add    $0x18,%esp
    e0eb:	89 45 dc             	mov    %eax,-0x24(%ebp)
    e0ee:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    e0f2:	74 05                	je     e0f9 <unfilter+0x97>
    e0f4:	8b 45 dc             	mov    -0x24(%ebp),%eax
    e0f7:	eb 1c                	jmp    e115 <unfilter+0xb3>

    prevline = &out[outindex];
    e0f9:	8b 55 e8             	mov    -0x18(%ebp),%edx
    e0fc:	8b 45 08             	mov    0x8(%ebp),%eax
    e0ff:	01 d0                	add    %edx,%eax
    e101:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;

  for(y = 0; y < h; ++y) {
    e104:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e108:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e10b:	3b 45 14             	cmp    0x14(%ebp),%eax
    e10e:	72 8b                	jb     e09b <unfilter+0x39>
    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
    e110:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e115:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    e118:	c9                   	leave  
    e119:	c3                   	ret    

0000e11a <Adam7_deinterlace>:
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
    e11a:	55                   	push   %ebp
    e11b:	89 e5                	mov    %esp,%ebp
    e11d:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e123:	ff 75 18             	pushl  0x18(%ebp)
    e126:	ff 75 14             	pushl  0x14(%ebp)
    e129:	ff 75 10             	pushl  0x10(%ebp)
    e12c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
    e132:	50                   	push   %eax
    e133:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
    e139:	50                   	push   %eax
    e13a:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
    e140:	50                   	push   %eax
    e141:	8d 45 94             	lea    -0x6c(%ebp),%eax
    e144:	50                   	push   %eax
    e145:	8d 45 b0             	lea    -0x50(%ebp),%eax
    e148:	50                   	push   %eax
    e149:	e8 e6 f1 ff ff       	call   d334 <Adam7_getpassvalues>
    e14e:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
    e151:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
    e155:	0f 86 0a 01 00 00    	jbe    e265 <Adam7_deinterlace+0x14b>
    for(i = 0; i != 7; ++i) {
    e15b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e162:	e9 ef 00 00 00       	jmp    e256 <Adam7_deinterlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
    e167:	8b 45 18             	mov    0x18(%ebp),%eax
    e16a:	c1 e8 03             	shr    $0x3,%eax
    e16d:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
    e170:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    e177:	e9 c6 00 00 00       	jmp    e242 <Adam7_deinterlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
    e17c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e183:	e9 a6 00 00 00       	jmp    e22e <Adam7_deinterlace+0x114>
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
    e188:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e18b:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e192:	89 c1                	mov    %eax,%ecx
    e194:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e197:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e19b:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    e19f:	89 c2                	mov    %eax,%edx
    e1a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e1a4:	01 c2                	add    %eax,%edx
    e1a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e1a9:	0f af c2             	imul   %edx,%eax
    e1ac:	01 c8                	add    %ecx,%eax
    e1ae:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    e1b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e1b4:	8b 14 85 b8 a2 01 00 	mov    0x1a2b8(,%eax,4),%edx
    e1bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e1be:	8b 04 85 f0 a2 01 00 	mov    0x1a2f0(,%eax,4),%eax
    e1c5:	0f af 45 f4          	imul   -0xc(%ebp),%eax
    e1c9:	01 d0                	add    %edx,%eax
    e1cb:	0f af 45 10          	imul   0x10(%ebp),%eax
    e1cf:	89 c2                	mov    %eax,%edx
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
    e1d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e1d4:	8b 04 85 d4 a2 01 00 	mov    0x1a2d4(,%eax,4),%eax
    e1db:	0f af 45 f8          	imul   -0x8(%ebp),%eax
    e1df:	01 c2                	add    %eax,%edx
    e1e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e1e4:	8b 04 85 9c a2 01 00 	mov    0x1a29c(,%eax,4),%eax
    e1eb:	01 c2                	add    %eax,%edx
    e1ed:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e1f0:	0f af c2             	imul   %edx,%eax
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
    e1f3:	89 45 d8             	mov    %eax,-0x28(%ebp)
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    e1f6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e1fd:	eb 23                	jmp    e222 <Adam7_deinterlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
    e1ff:	8b 55 d8             	mov    -0x28(%ebp),%edx
    e202:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e205:	01 c2                	add    %eax,%edx
    e207:	8b 45 08             	mov    0x8(%ebp),%eax
    e20a:	01 c2                	add    %eax,%edx
    e20c:	8b 4d dc             	mov    -0x24(%ebp),%ecx
    e20f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e212:	01 c1                	add    %eax,%ecx
    e214:	8b 45 0c             	mov    0xc(%ebp),%eax
    e217:	01 c8                	add    %ecx,%eax
    e219:	0f b6 00             	movzbl (%eax),%eax
    e21c:	88 02                	mov    %al,(%edx)
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * (size_t)w
                             + ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
    e21e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e222:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e225:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    e228:	72 d5                	jb     e1ff <Adam7_deinterlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e22a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e22e:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e231:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e235:	3b 45 f8             	cmp    -0x8(%ebp),%eax
    e238:	0f 87 4a ff ff ff    	ja     e188 <Adam7_deinterlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
    e23e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
    e242:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e245:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e249:	3b 45 f4             	cmp    -0xc(%ebp),%eax
    e24c:	0f 87 2a ff ff ff    	ja     e17c <Adam7_deinterlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
    e252:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e256:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e25a:	0f 85 07 ff ff ff    	jne    e167 <Adam7_deinterlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e260:	e9 22 01 00 00       	jmp    e387 <Adam7_deinterlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e265:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e26c:	e9 0c 01 00 00       	jmp    e37d <Adam7_deinterlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
    e271:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e274:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e278:	0f af 45 18          	imul   0x18(%ebp),%eax
    e27c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
    e27f:	8b 45 18             	mov    0x18(%ebp),%eax
    e282:	0f af 45 10          	imul   0x10(%ebp),%eax
    e286:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e289:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    e290:	e9 d4 00 00 00       	jmp    e369 <Adam7_deinterlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
    e295:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e29c:	e9 b4 00 00 00       	jmp    e355 <Adam7_deinterlace+0x23b>
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
    e2a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e2a4:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
    e2ab:	c1 e0 03             	shl    $0x3,%eax
    e2ae:	89 c1                	mov    %eax,%ecx
    e2b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e2b3:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
    e2b7:	89 c2                	mov    %eax,%edx
    e2b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
    e2bc:	0f af 45 18          	imul   0x18(%ebp),%eax
    e2c0:	01 d0                	add    %edx,%eax
    e2c2:	01 c8                	add    %ecx,%eax
    e2c4:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
    e2ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e2cd:	8b 14 85 b8 a2 01 00 	mov    0x1a2b8(,%eax,4),%edx
    e2d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e2d7:	8b 04 85 f0 a2 01 00 	mov    0x1a2f0(,%eax,4),%eax
    e2de:	0f af 45 e8          	imul   -0x18(%ebp),%eax
    e2e2:	01 d0                	add    %edx,%eax
    e2e4:	0f af 45 d0          	imul   -0x30(%ebp),%eax
    e2e8:	89 c2                	mov    %eax,%edx
    e2ea:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e2ed:	8b 0c 85 9c a2 01 00 	mov    0x1a29c(,%eax,4),%ecx
    e2f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e2f7:	8b 04 85 d4 a2 01 00 	mov    0x1a2d4(,%eax,4),%eax
    e2fe:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e302:	01 c8                	add    %ecx,%eax
    e304:	0f af 45 18          	imul   0x18(%ebp),%eax
    e308:	01 d0                	add    %edx,%eax
    e30a:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
    e310:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    e317:	eb 30                	jmp    e349 <Adam7_deinterlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
    e319:	ff 75 0c             	pushl  0xc(%ebp)
    e31c:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
    e322:	50                   	push   %eax
    e323:	e8 1e a1 ff ff       	call   8446 <readBitFromReversedStream>
    e328:	83 c4 08             	add    $0x8,%esp
    e32b:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
    e32e:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
    e332:	50                   	push   %eax
    e333:	ff 75 08             	pushl  0x8(%ebp)
    e336:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
    e33c:	50                   	push   %eax
    e33d:	e8 86 a1 ff ff       	call   84c8 <setBitOfReversedStream>
    e342:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + (size_t)y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + (size_t)x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; ++b) {
    e345:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    e349:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e34c:	3b 45 18             	cmp    0x18(%ebp),%eax
    e34f:	72 c8                	jb     e319 <Adam7_deinterlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
    e351:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    e355:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e358:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
    e35c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    e35f:	0f 87 3c ff ff ff    	ja     e2a1 <Adam7_deinterlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
    e365:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    e369:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e36c:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
    e370:	3b 45 e8             	cmp    -0x18(%ebp),%eax
    e373:	0f 87 1c ff ff ff    	ja     e295 <Adam7_deinterlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
    e379:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e37d:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
    e381:	0f 85 ea fe ff ff    	jne    e271 <Adam7_deinterlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
    e387:	90                   	nop
    e388:	c9                   	leave  
    e389:	c3                   	ret    

0000e38a <removePaddingBits>:

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h) {
    e38a:	55                   	push   %ebp
    e38b:	89 e5                	mov    %esp,%ebp
    e38d:	83 ec 20             	sub    $0x20,%esp
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
    e390:	8b 45 14             	mov    0x14(%ebp),%eax
    e393:	2b 45 10             	sub    0x10(%ebp),%eax
    e396:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
    e399:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    e3a0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y < h; ++y) {
    e3a7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e3ae:	eb 4a                	jmp    e3fa <removePaddingBits+0x70>
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e3b0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    e3b7:	eb 2a                	jmp    e3e3 <removePaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
    e3b9:	ff 75 0c             	pushl  0xc(%ebp)
    e3bc:	8d 45 ec             	lea    -0x14(%ebp),%eax
    e3bf:	50                   	push   %eax
    e3c0:	e8 81 a0 ff ff       	call   8446 <readBitFromReversedStream>
    e3c5:	83 c4 08             	add    $0x8,%esp
    e3c8:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
    e3cb:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
    e3cf:	50                   	push   %eax
    e3d0:	ff 75 08             	pushl  0x8(%ebp)
    e3d3:	8d 45 e8             	lea    -0x18(%ebp),%eax
    e3d6:	50                   	push   %eax
    e3d7:	e8 ec a0 ff ff       	call   84c8 <setBitOfReversedStream>
    e3dc:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    size_t x;
    for(x = 0; x < olinebits; ++x) {
    e3df:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    e3e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
    e3e6:	3b 45 10             	cmp    0x10(%ebp),%eax
    e3e9:	7c ce                	jl     e3b9 <removePaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
    e3eb:	8b 55 ec             	mov    -0x14(%ebp),%edx
    e3ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e3f1:	01 d0                	add    %edx,%eax
    e3f3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y) {
    e3f6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e3fa:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e3fd:	3b 45 18             	cmp    0x18(%ebp),%eax
    e400:	72 ae                	jb     e3b0 <removePaddingBits+0x26>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}
    e402:	90                   	nop
    e403:	c9                   	leave  
    e404:	c3                   	ret    

0000e405 <postProcessScanlines>:

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png) {
    e405:	55                   	push   %ebp
    e406:	89 e5                	mov    %esp,%ebp
    e408:	57                   	push   %edi
    e409:	56                   	push   %esi
    e40a:	53                   	push   %ebx
    e40b:	81 ec b0 00 00 00    	sub    $0xb0,%esp
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= possible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
    e411:	8b 45 18             	mov    0x18(%ebp),%eax
    e414:	83 c0 0c             	add    $0xc,%eax
    e417:	50                   	push   %eax
    e418:	e8 e6 ac ff ff       	call   9103 <lodepng_get_bpp>
    e41d:	83 c4 04             	add    $0x4,%esp
    e420:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(bpp == 0) return 31; /*error: invalid colortype*/
    e423:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    e427:	75 0a                	jne    e433 <postProcessScanlines+0x2e>
    e429:	b8 1f 00 00 00       	mov    $0x1f,%eax
    e42e:	e9 c3 01 00 00       	jmp    e5f6 <postProcessScanlines+0x1f1>

  if(info_png->interlace_method == 0) {
    e433:	8b 45 18             	mov    0x18(%ebp),%eax
    e436:	8b 40 08             	mov    0x8(%eax),%eax
    e439:	85 c0                	test   %eax,%eax
    e43b:	0f 85 a8 00 00 00    	jne    e4e9 <postProcessScanlines+0xe4>
    if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
    e441:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e445:	77 76                	ja     e4bd <postProcessScanlines+0xb8>
    e447:	8b 45 10             	mov    0x10(%ebp),%eax
    e44a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e44e:	89 c2                	mov    %eax,%edx
    e450:	8b 45 10             	mov    0x10(%ebp),%eax
    e453:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e457:	83 c0 07             	add    $0x7,%eax
    e45a:	c1 e8 03             	shr    $0x3,%eax
    e45d:	c1 e0 03             	shl    $0x3,%eax
    e460:	39 c2                	cmp    %eax,%edx
    e462:	74 59                	je     e4bd <postProcessScanlines+0xb8>
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
    e464:	ff 75 ec             	pushl  -0x14(%ebp)
    e467:	ff 75 14             	pushl  0x14(%ebp)
    e46a:	ff 75 10             	pushl  0x10(%ebp)
    e46d:	ff 75 0c             	pushl  0xc(%ebp)
    e470:	ff 75 0c             	pushl  0xc(%ebp)
    e473:	e8 ea fb ff ff       	call   e062 <unfilter>
    e478:	83 c4 14             	add    $0x14,%esp
    e47b:	89 45 e8             	mov    %eax,-0x18(%ebp)
    e47e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    e482:	74 08                	je     e48c <postProcessScanlines+0x87>
    e484:	8b 45 e8             	mov    -0x18(%ebp),%eax
    e487:	e9 6a 01 00 00       	jmp    e5f6 <postProcessScanlines+0x1f1>
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7u) / 8u) * 8u, h);
    e48c:	8b 45 10             	mov    0x10(%ebp),%eax
    e48f:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e493:	83 c0 07             	add    $0x7,%eax
    e496:	c1 e8 03             	shr    $0x3,%eax
    e499:	c1 e0 03             	shl    $0x3,%eax
    e49c:	89 c2                	mov    %eax,%edx
    e49e:	8b 45 10             	mov    0x10(%ebp),%eax
    e4a1:	0f af 45 ec          	imul   -0x14(%ebp),%eax
    e4a5:	ff 75 14             	pushl  0x14(%ebp)
    e4a8:	52                   	push   %edx
    e4a9:	50                   	push   %eax
    e4aa:	ff 75 0c             	pushl  0xc(%ebp)
    e4ad:	ff 75 08             	pushl  0x8(%ebp)
    e4b0:	e8 d5 fe ff ff       	call   e38a <removePaddingBits>
    e4b5:	83 c4 14             	add    $0x14,%esp
    e4b8:	e9 34 01 00 00       	jmp    e5f1 <postProcessScanlines+0x1ec>
    }
    /*we can immediately filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
    e4bd:	ff 75 ec             	pushl  -0x14(%ebp)
    e4c0:	ff 75 14             	pushl  0x14(%ebp)
    e4c3:	ff 75 10             	pushl  0x10(%ebp)
    e4c6:	ff 75 0c             	pushl  0xc(%ebp)
    e4c9:	ff 75 08             	pushl  0x8(%ebp)
    e4cc:	e8 91 fb ff ff       	call   e062 <unfilter>
    e4d1:	83 c4 14             	add    $0x14,%esp
    e4d4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    e4d7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    e4db:	0f 84 10 01 00 00    	je     e5f1 <postProcessScanlines+0x1ec>
    e4e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    e4e4:	e9 0d 01 00 00       	jmp    e5f6 <postProcessScanlines+0x1f1>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
    e4e9:	ff 75 ec             	pushl  -0x14(%ebp)
    e4ec:	ff 75 14             	pushl  0x14(%ebp)
    e4ef:	ff 75 10             	pushl  0x10(%ebp)
    e4f2:	8d 45 88             	lea    -0x78(%ebp),%eax
    e4f5:	50                   	push   %eax
    e4f6:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
    e4fc:	50                   	push   %eax
    e4fd:	8d 85 48 ff ff ff    	lea    -0xb8(%ebp),%eax
    e503:	50                   	push   %eax
    e504:	8d 45 a8             	lea    -0x58(%ebp),%eax
    e507:	50                   	push   %eax
    e508:	8d 45 c4             	lea    -0x3c(%ebp),%eax
    e50b:	50                   	push   %eax
    e50c:	e8 23 ee ff ff       	call   d334 <Adam7_getpassvalues>
    e511:	83 c4 20             	add    $0x20,%esp

    for(i = 0; i != 7; ++i) {
    e514:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e51b:	e9 b0 00 00 00       	jmp    e5d0 <postProcessScanlines+0x1cb>
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
    e520:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e523:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
    e527:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e52a:	8b 44 85 c4          	mov    -0x3c(%ebp,%eax,4),%eax
    e52e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e531:	8b 8c 8d 48 ff ff ff 	mov    -0xb8(%ebp,%ecx,4),%ecx
    e538:	89 cb                	mov    %ecx,%ebx
    e53a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e53d:	01 cb                	add    %ecx,%ebx
    e53f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
    e542:	8b 8c 8d 68 ff ff ff 	mov    -0x98(%ebp,%ecx,4),%ecx
    e549:	89 ce                	mov    %ecx,%esi
    e54b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e54e:	01 f1                	add    %esi,%ecx
    e550:	ff 75 ec             	pushl  -0x14(%ebp)
    e553:	52                   	push   %edx
    e554:	50                   	push   %eax
    e555:	53                   	push   %ebx
    e556:	51                   	push   %ecx
    e557:	e8 06 fb ff ff       	call   e062 <unfilter>
    e55c:	83 c4 14             	add    $0x14,%esp
    e55f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    e562:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    e566:	74 08                	je     e570 <postProcessScanlines+0x16b>
    e568:	8b 45 e0             	mov    -0x20(%ebp),%eax
    e56b:	e9 86 00 00 00       	jmp    e5f6 <postProcessScanlines+0x1f1>
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
    e570:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
    e574:	77 56                	ja     e5cc <postProcessScanlines+0x1c7>
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e576:	8b 45 f0             	mov    -0x10(%ebp),%eax
    e579:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
    e57d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e580:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e584:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e588:	83 c2 07             	add    $0x7,%edx
    e58b:	c1 ea 03             	shr    $0x3,%edx
    e58e:	c1 e2 03             	shl    $0x3,%edx
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8) {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
    e591:	89 d6                	mov    %edx,%esi
    e593:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e596:	8b 54 95 c4          	mov    -0x3c(%ebp,%edx,4),%edx
    e59a:	0f af 55 ec          	imul   -0x14(%ebp),%edx
    e59e:	89 d3                	mov    %edx,%ebx
    e5a0:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e5a3:	8b 94 95 68 ff ff ff 	mov    -0x98(%ebp,%edx,4),%edx
    e5aa:	89 d1                	mov    %edx,%ecx
    e5ac:	8b 55 0c             	mov    0xc(%ebp),%edx
    e5af:	01 d1                	add    %edx,%ecx
    e5b1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e5b4:	8b 54 95 88          	mov    -0x78(%ebp,%edx,4),%edx
    e5b8:	89 d7                	mov    %edx,%edi
    e5ba:	8b 55 0c             	mov    0xc(%ebp),%edx
    e5bd:	01 fa                	add    %edi,%edx
    e5bf:	50                   	push   %eax
    e5c0:	56                   	push   %esi
    e5c1:	53                   	push   %ebx
    e5c2:	51                   	push   %ecx
    e5c3:	52                   	push   %edx
    e5c4:	e8 c1 fd ff ff       	call   e38a <removePaddingBits>
    e5c9:	83 c4 14             	add    $0x14,%esp
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i != 7; ++i) {
    e5cc:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e5d0:	83 7d f0 07          	cmpl   $0x7,-0x10(%ebp)
    e5d4:	0f 85 46 ff ff ff    	jne    e520 <postProcessScanlines+0x11b>
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7u) / 8u) * 8u, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
    e5da:	ff 75 ec             	pushl  -0x14(%ebp)
    e5dd:	ff 75 14             	pushl  0x14(%ebp)
    e5e0:	ff 75 10             	pushl  0x10(%ebp)
    e5e3:	ff 75 0c             	pushl  0xc(%ebp)
    e5e6:	ff 75 08             	pushl  0x8(%ebp)
    e5e9:	e8 2c fb ff ff       	call   e11a <Adam7_deinterlace>
    e5ee:	83 c4 14             	add    $0x14,%esp
  }

  return 0;
    e5f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e5f6:	8d 65 f4             	lea    -0xc(%ebp),%esp
    e5f9:	5b                   	pop    %ebx
    e5fa:	5e                   	pop    %esi
    e5fb:	5f                   	pop    %edi
    e5fc:	5d                   	pop    %ebp
    e5fd:	c3                   	ret    

0000e5fe <readChunk_PLTE>:

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e5fe:	55                   	push   %ebp
    e5ff:	89 e5                	mov    %esp,%ebp
    e601:	83 ec 18             	sub    $0x18,%esp
  unsigned pos = 0, i;
    e604:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  color->palettesize = chunkLength / 3u;
    e60b:	8b 45 10             	mov    0x10(%ebp),%eax
    e60e:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
    e613:	f7 e2                	mul    %edx
    e615:	89 d0                	mov    %edx,%eax
    e617:	d1 e8                	shr    %eax
    e619:	89 c2                	mov    %eax,%edx
    e61b:	8b 45 08             	mov    0x8(%ebp),%eax
    e61e:	89 50 0c             	mov    %edx,0xc(%eax)
  if(color->palettesize == 0 || color->palettesize > 256) return 38; /*error: palette too small or big*/
    e621:	8b 45 08             	mov    0x8(%ebp),%eax
    e624:	8b 40 0c             	mov    0xc(%eax),%eax
    e627:	85 c0                	test   %eax,%eax
    e629:	74 0d                	je     e638 <readChunk_PLTE+0x3a>
    e62b:	8b 45 08             	mov    0x8(%ebp),%eax
    e62e:	8b 40 0c             	mov    0xc(%eax),%eax
    e631:	3d 00 01 00 00       	cmp    $0x100,%eax
    e636:	7e 0a                	jle    e642 <readChunk_PLTE+0x44>
    e638:	b8 26 00 00 00       	mov    $0x26,%eax
    e63d:	e9 da 00 00 00       	jmp    e71c <readChunk_PLTE+0x11e>
  lodepng_color_mode_alloc_palette(color);
    e642:	83 ec 0c             	sub    $0xc,%esp
    e645:	ff 75 08             	pushl  0x8(%ebp)
    e648:	e8 02 a7 ff ff       	call   8d4f <lodepng_color_mode_alloc_palette>
    e64d:	83 c4 10             	add    $0x10,%esp
  if(!color->palette && color->palettesize) {
    e650:	8b 45 08             	mov    0x8(%ebp),%eax
    e653:	8b 40 08             	mov    0x8(%eax),%eax
    e656:	85 c0                	test   %eax,%eax
    e658:	75 1e                	jne    e678 <readChunk_PLTE+0x7a>
    e65a:	8b 45 08             	mov    0x8(%ebp),%eax
    e65d:	8b 40 0c             	mov    0xc(%eax),%eax
    e660:	85 c0                	test   %eax,%eax
    e662:	74 14                	je     e678 <readChunk_PLTE+0x7a>
    color->palettesize = 0;
    e664:	8b 45 08             	mov    0x8(%ebp),%eax
    e667:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    return 83; /*alloc fail*/
    e66e:	b8 53 00 00 00       	mov    $0x53,%eax
    e673:	e9 a4 00 00 00       	jmp    e71c <readChunk_PLTE+0x11e>
  }

  for(i = 0; i != color->palettesize; ++i) {
    e678:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    e67f:	e9 84 00 00 00       	jmp    e708 <readChunk_PLTE+0x10a>
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    e684:	8b 45 08             	mov    0x8(%ebp),%eax
    e687:	8b 40 08             	mov    0x8(%eax),%eax
    e68a:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e68d:	c1 e2 02             	shl    $0x2,%edx
    e690:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e693:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e696:	8d 50 01             	lea    0x1(%eax),%edx
    e699:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e69c:	8b 55 0c             	mov    0xc(%ebp),%edx
    e69f:	01 d0                	add    %edx,%eax
    e6a1:	0f b6 00             	movzbl (%eax),%eax
    e6a4:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    e6a6:	8b 45 08             	mov    0x8(%ebp),%eax
    e6a9:	8b 40 08             	mov    0x8(%eax),%eax
    e6ac:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e6af:	c1 e2 02             	shl    $0x2,%edx
    e6b2:	83 c2 01             	add    $0x1,%edx
    e6b5:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e6b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e6bb:	8d 50 01             	lea    0x1(%eax),%edx
    e6be:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e6c1:	8b 55 0c             	mov    0xc(%ebp),%edx
    e6c4:	01 d0                	add    %edx,%eax
    e6c6:	0f b6 00             	movzbl (%eax),%eax
    e6c9:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    e6cb:	8b 45 08             	mov    0x8(%ebp),%eax
    e6ce:	8b 40 08             	mov    0x8(%eax),%eax
    e6d1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e6d4:	c1 e2 02             	shl    $0x2,%edx
    e6d7:	83 c2 02             	add    $0x2,%edx
    e6da:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
    e6dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
    e6e0:	8d 50 01             	lea    0x1(%eax),%edx
    e6e3:	89 55 f4             	mov    %edx,-0xc(%ebp)
    e6e6:	8b 55 0c             	mov    0xc(%ebp),%edx
    e6e9:	01 d0                	add    %edx,%eax
    e6eb:	0f b6 00             	movzbl (%eax),%eax
    e6ee:	88 01                	mov    %al,(%ecx)
    color->palette[4 * i + 3] = 255; /*alpha*/
    e6f0:	8b 45 08             	mov    0x8(%ebp),%eax
    e6f3:	8b 40 08             	mov    0x8(%eax),%eax
    e6f6:	8b 55 f0             	mov    -0x10(%ebp),%edx
    e6f9:	c1 e2 02             	shl    $0x2,%edx
    e6fc:	83 c2 03             	add    $0x3,%edx
    e6ff:	01 d0                	add    %edx,%eax
    e701:	c6 00 ff             	movb   $0xff,(%eax)
  if(!color->palette && color->palettesize) {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }

  for(i = 0; i != color->palettesize; ++i) {
    e704:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    e708:	8b 45 08             	mov    0x8(%ebp),%eax
    e70b:	8b 40 0c             	mov    0xc(%eax),%eax
    e70e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
    e711:	0f 85 6d ff ff ff    	jne    e684 <readChunk_PLTE+0x86>
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
    e717:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e71c:	c9                   	leave  
    e71d:	c3                   	ret    

0000e71e <readChunk_tRNS>:

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength) {
    e71e:	55                   	push   %ebp
    e71f:	89 e5                	mov    %esp,%ebp
    e721:	83 ec 10             	sub    $0x10,%esp
  unsigned i;
  if(color->colortype == LCT_PALETTE) {
    e724:	8b 45 08             	mov    0x8(%ebp),%eax
    e727:	8b 00                	mov    (%eax),%eax
    e729:	83 f8 03             	cmp    $0x3,%eax
    e72c:	75 4d                	jne    e77b <readChunk_tRNS+0x5d>
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 39;
    e72e:	8b 45 08             	mov    0x8(%ebp),%eax
    e731:	8b 40 0c             	mov    0xc(%eax),%eax
    e734:	3b 45 10             	cmp    0x10(%ebp),%eax
    e737:	7d 0a                	jge    e743 <readChunk_tRNS+0x25>
    e739:	b8 27 00 00 00       	mov    $0x27,%eax
    e73e:	e9 3c 01 00 00       	jmp    e87f <readChunk_tRNS+0x161>

    for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
    e743:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    e74a:	eb 22                	jmp    e76e <readChunk_tRNS+0x50>
    e74c:	8b 45 08             	mov    0x8(%ebp),%eax
    e74f:	8b 40 08             	mov    0x8(%eax),%eax
    e752:	8b 55 fc             	mov    -0x4(%ebp),%edx
    e755:	c1 e2 02             	shl    $0x2,%edx
    e758:	83 c2 03             	add    $0x3,%edx
    e75b:	01 c2                	add    %eax,%edx
    e75d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    e760:	8b 45 fc             	mov    -0x4(%ebp),%eax
    e763:	01 c8                	add    %ecx,%eax
    e765:	0f b6 00             	movzbl (%eax),%eax
    e768:	88 02                	mov    %al,(%edx)
    e76a:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    e76e:	8b 45 10             	mov    0x10(%ebp),%eax
    e771:	39 45 fc             	cmp    %eax,-0x4(%ebp)
    e774:	75 d6                	jne    e74c <readChunk_tRNS+0x2e>
    e776:	e9 ff 00 00 00       	jmp    e87a <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_GREY) {
    e77b:	8b 45 08             	mov    0x8(%ebp),%eax
    e77e:	8b 00                	mov    (%eax),%eax
    e780:	85 c0                	test   %eax,%eax
    e782:	75 59                	jne    e7dd <readChunk_tRNS+0xbf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 30;
    e784:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e788:	74 0a                	je     e794 <readChunk_tRNS+0x76>
    e78a:	b8 1e 00 00 00       	mov    $0x1e,%eax
    e78f:	e9 eb 00 00 00       	jmp    e87f <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e794:	8b 45 08             	mov    0x8(%ebp),%eax
    e797:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
    e79e:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7a1:	0f b6 00             	movzbl (%eax),%eax
    e7a4:	0f b6 c0             	movzbl %al,%eax
    e7a7:	c1 e0 08             	shl    $0x8,%eax
    e7aa:	89 c2                	mov    %eax,%edx
    e7ac:	8b 45 0c             	mov    0xc(%ebp),%eax
    e7af:	83 c0 01             	add    $0x1,%eax
    e7b2:	0f b6 00             	movzbl (%eax),%eax
    e7b5:	0f b6 c0             	movzbl %al,%eax
    e7b8:	01 c2                	add    %eax,%edx
    e7ba:	8b 45 08             	mov    0x8(%ebp),%eax
    e7bd:	89 50 1c             	mov    %edx,0x1c(%eax)
    e7c0:	8b 45 08             	mov    0x8(%ebp),%eax
    e7c3:	8b 50 1c             	mov    0x1c(%eax),%edx
    e7c6:	8b 45 08             	mov    0x8(%ebp),%eax
    e7c9:	89 50 18             	mov    %edx,0x18(%eax)
    e7cc:	8b 45 08             	mov    0x8(%ebp),%eax
    e7cf:	8b 50 18             	mov    0x18(%eax),%edx
    e7d2:	8b 45 08             	mov    0x8(%ebp),%eax
    e7d5:	89 50 14             	mov    %edx,0x14(%eax)
    e7d8:	e9 9d 00 00 00       	jmp    e87a <readChunk_tRNS+0x15c>
  } else if(color->colortype == LCT_RGB) {
    e7dd:	8b 45 08             	mov    0x8(%ebp),%eax
    e7e0:	8b 00                	mov    (%eax),%eax
    e7e2:	83 f8 02             	cmp    $0x2,%eax
    e7e5:	0f 85 88 00 00 00    	jne    e873 <readChunk_tRNS+0x155>
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;
    e7eb:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e7ef:	74 0a                	je     e7fb <readChunk_tRNS+0xdd>
    e7f1:	b8 29 00 00 00       	mov    $0x29,%eax
    e7f6:	e9 84 00 00 00       	jmp    e87f <readChunk_tRNS+0x161>

    color->key_defined = 1;
    e7fb:	8b 45 08             	mov    0x8(%ebp),%eax
    e7fe:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
    color->key_r = 256u * data[0] + data[1];
    e805:	8b 45 0c             	mov    0xc(%ebp),%eax
    e808:	0f b6 00             	movzbl (%eax),%eax
    e80b:	0f b6 c0             	movzbl %al,%eax
    e80e:	c1 e0 08             	shl    $0x8,%eax
    e811:	89 c2                	mov    %eax,%edx
    e813:	8b 45 0c             	mov    0xc(%ebp),%eax
    e816:	83 c0 01             	add    $0x1,%eax
    e819:	0f b6 00             	movzbl (%eax),%eax
    e81c:	0f b6 c0             	movzbl %al,%eax
    e81f:	01 c2                	add    %eax,%edx
    e821:	8b 45 08             	mov    0x8(%ebp),%eax
    e824:	89 50 14             	mov    %edx,0x14(%eax)
    color->key_g = 256u * data[2] + data[3];
    e827:	8b 45 0c             	mov    0xc(%ebp),%eax
    e82a:	83 c0 02             	add    $0x2,%eax
    e82d:	0f b6 00             	movzbl (%eax),%eax
    e830:	0f b6 c0             	movzbl %al,%eax
    e833:	c1 e0 08             	shl    $0x8,%eax
    e836:	89 c2                	mov    %eax,%edx
    e838:	8b 45 0c             	mov    0xc(%ebp),%eax
    e83b:	83 c0 03             	add    $0x3,%eax
    e83e:	0f b6 00             	movzbl (%eax),%eax
    e841:	0f b6 c0             	movzbl %al,%eax
    e844:	01 c2                	add    %eax,%edx
    e846:	8b 45 08             	mov    0x8(%ebp),%eax
    e849:	89 50 18             	mov    %edx,0x18(%eax)
    color->key_b = 256u * data[4] + data[5];
    e84c:	8b 45 0c             	mov    0xc(%ebp),%eax
    e84f:	83 c0 04             	add    $0x4,%eax
    e852:	0f b6 00             	movzbl (%eax),%eax
    e855:	0f b6 c0             	movzbl %al,%eax
    e858:	c1 e0 08             	shl    $0x8,%eax
    e85b:	89 c2                	mov    %eax,%edx
    e85d:	8b 45 0c             	mov    0xc(%ebp),%eax
    e860:	83 c0 05             	add    $0x5,%eax
    e863:	0f b6 00             	movzbl (%eax),%eax
    e866:	0f b6 c0             	movzbl %al,%eax
    e869:	01 c2                	add    %eax,%edx
    e86b:	8b 45 08             	mov    0x8(%ebp),%eax
    e86e:	89 50 1c             	mov    %edx,0x1c(%eax)
    e871:	eb 07                	jmp    e87a <readChunk_tRNS+0x15c>
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/
    e873:	b8 2a 00 00 00       	mov    $0x2a,%eax
    e878:	eb 05                	jmp    e87f <readChunk_tRNS+0x161>

  return 0; /* OK */
    e87a:	b8 00 00 00 00       	mov    $0x0,%eax
}
    e87f:	c9                   	leave  
    e880:	c3                   	ret    

0000e881 <readChunk_bKGD>:


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    e881:	55                   	push   %ebp
    e882:	89 e5                	mov    %esp,%ebp
  if(info->color.colortype == LCT_PALETTE) {
    e884:	8b 45 08             	mov    0x8(%ebp),%eax
    e887:	8b 40 0c             	mov    0xc(%eax),%eax
    e88a:	83 f8 03             	cmp    $0x3,%eax
    e88d:	75 63                	jne    e8f2 <readChunk_bKGD+0x71>
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;
    e88f:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    e893:	74 0a                	je     e89f <readChunk_bKGD+0x1e>
    e895:	b8 2b 00 00 00       	mov    $0x2b,%eax
    e89a:	e9 63 01 00 00       	jmp    ea02 <readChunk_bKGD+0x181>

    /*error: invalid palette index, or maybe this chunk appeared before PLTE*/
    if(data[0] >= info->color.palettesize) return 103;
    e89f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e8a2:	0f b6 00             	movzbl (%eax),%eax
    e8a5:	0f b6 d0             	movzbl %al,%edx
    e8a8:	8b 45 08             	mov    0x8(%ebp),%eax
    e8ab:	8b 40 18             	mov    0x18(%eax),%eax
    e8ae:	39 c2                	cmp    %eax,%edx
    e8b0:	7c 0a                	jl     e8bc <readChunk_bKGD+0x3b>
    e8b2:	b8 67 00 00 00       	mov    $0x67,%eax
    e8b7:	e9 46 01 00 00       	jmp    ea02 <readChunk_bKGD+0x181>

    info->background_defined = 1;
    e8bc:	8b 45 08             	mov    0x8(%ebp),%eax
    e8bf:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = data[0];
    e8c6:	8b 45 0c             	mov    0xc(%ebp),%eax
    e8c9:	0f b6 00             	movzbl (%eax),%eax
    e8cc:	0f b6 d0             	movzbl %al,%edx
    e8cf:	8b 45 08             	mov    0x8(%ebp),%eax
    e8d2:	89 50 38             	mov    %edx,0x38(%eax)
    e8d5:	8b 45 08             	mov    0x8(%ebp),%eax
    e8d8:	8b 50 38             	mov    0x38(%eax),%edx
    e8db:	8b 45 08             	mov    0x8(%ebp),%eax
    e8de:	89 50 34             	mov    %edx,0x34(%eax)
    e8e1:	8b 45 08             	mov    0x8(%ebp),%eax
    e8e4:	8b 50 34             	mov    0x34(%eax),%edx
    e8e7:	8b 45 08             	mov    0x8(%ebp),%eax
    e8ea:	89 50 30             	mov    %edx,0x30(%eax)
    e8ed:	e9 0b 01 00 00       	jmp    e9fd <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
    e8f2:	8b 45 08             	mov    0x8(%ebp),%eax
    e8f5:	8b 40 0c             	mov    0xc(%eax),%eax
    e8f8:	85 c0                	test   %eax,%eax
    e8fa:	74 0b                	je     e907 <readChunk_bKGD+0x86>
    e8fc:	8b 45 08             	mov    0x8(%ebp),%eax
    e8ff:	8b 40 0c             	mov    0xc(%eax),%eax
    e902:	83 f8 04             	cmp    $0x4,%eax
    e905:	75 59                	jne    e960 <readChunk_bKGD+0xdf>
    /*error: this chunk must be 2 bytes for grayscale image*/
    if(chunkLength != 2) return 44;
    e907:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
    e90b:	74 0a                	je     e917 <readChunk_bKGD+0x96>
    e90d:	b8 2c 00 00 00       	mov    $0x2c,%eax
    e912:	e9 eb 00 00 00       	jmp    ea02 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e917:	8b 45 08             	mov    0x8(%ebp),%eax
    e91a:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
    e921:	8b 45 0c             	mov    0xc(%ebp),%eax
    e924:	0f b6 00             	movzbl (%eax),%eax
    e927:	0f b6 c0             	movzbl %al,%eax
    e92a:	c1 e0 08             	shl    $0x8,%eax
    e92d:	89 c2                	mov    %eax,%edx
    e92f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e932:	83 c0 01             	add    $0x1,%eax
    e935:	0f b6 00             	movzbl (%eax),%eax
    e938:	0f b6 c0             	movzbl %al,%eax
    e93b:	01 c2                	add    %eax,%edx
    e93d:	8b 45 08             	mov    0x8(%ebp),%eax
    e940:	89 50 38             	mov    %edx,0x38(%eax)
    e943:	8b 45 08             	mov    0x8(%ebp),%eax
    e946:	8b 50 38             	mov    0x38(%eax),%edx
    e949:	8b 45 08             	mov    0x8(%ebp),%eax
    e94c:	89 50 34             	mov    %edx,0x34(%eax)
    e94f:	8b 45 08             	mov    0x8(%ebp),%eax
    e952:	8b 50 34             	mov    0x34(%eax),%edx
    e955:	8b 45 08             	mov    0x8(%ebp),%eax
    e958:	89 50 30             	mov    %edx,0x30(%eax)
    e95b:	e9 9d 00 00 00       	jmp    e9fd <readChunk_bKGD+0x17c>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
    e960:	8b 45 08             	mov    0x8(%ebp),%eax
    e963:	8b 40 0c             	mov    0xc(%eax),%eax
    e966:	83 f8 02             	cmp    $0x2,%eax
    e969:	74 0f                	je     e97a <readChunk_bKGD+0xf9>
    e96b:	8b 45 08             	mov    0x8(%ebp),%eax
    e96e:	8b 40 0c             	mov    0xc(%eax),%eax
    e971:	83 f8 06             	cmp    $0x6,%eax
    e974:	0f 85 83 00 00 00    	jne    e9fd <readChunk_bKGD+0x17c>
    /*error: this chunk must be 6 bytes for grayscale image*/
    if(chunkLength != 6) return 45;
    e97a:	83 7d 10 06          	cmpl   $0x6,0x10(%ebp)
    e97e:	74 07                	je     e987 <readChunk_bKGD+0x106>
    e980:	b8 2d 00 00 00       	mov    $0x2d,%eax
    e985:	eb 7b                	jmp    ea02 <readChunk_bKGD+0x181>

    /*the values are truncated to bitdepth in the PNG file*/
    info->background_defined = 1;
    e987:	8b 45 08             	mov    0x8(%ebp),%eax
    e98a:	c7 40 2c 01 00 00 00 	movl   $0x1,0x2c(%eax)
    info->background_r = 256u * data[0] + data[1];
    e991:	8b 45 0c             	mov    0xc(%ebp),%eax
    e994:	0f b6 00             	movzbl (%eax),%eax
    e997:	0f b6 c0             	movzbl %al,%eax
    e99a:	c1 e0 08             	shl    $0x8,%eax
    e99d:	89 c2                	mov    %eax,%edx
    e99f:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9a2:	83 c0 01             	add    $0x1,%eax
    e9a5:	0f b6 00             	movzbl (%eax),%eax
    e9a8:	0f b6 c0             	movzbl %al,%eax
    e9ab:	01 c2                	add    %eax,%edx
    e9ad:	8b 45 08             	mov    0x8(%ebp),%eax
    e9b0:	89 50 30             	mov    %edx,0x30(%eax)
    info->background_g = 256u * data[2] + data[3];
    e9b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9b6:	83 c0 02             	add    $0x2,%eax
    e9b9:	0f b6 00             	movzbl (%eax),%eax
    e9bc:	0f b6 c0             	movzbl %al,%eax
    e9bf:	c1 e0 08             	shl    $0x8,%eax
    e9c2:	89 c2                	mov    %eax,%edx
    e9c4:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9c7:	83 c0 03             	add    $0x3,%eax
    e9ca:	0f b6 00             	movzbl (%eax),%eax
    e9cd:	0f b6 c0             	movzbl %al,%eax
    e9d0:	01 c2                	add    %eax,%edx
    e9d2:	8b 45 08             	mov    0x8(%ebp),%eax
    e9d5:	89 50 34             	mov    %edx,0x34(%eax)
    info->background_b = 256u * data[4] + data[5];
    e9d8:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9db:	83 c0 04             	add    $0x4,%eax
    e9de:	0f b6 00             	movzbl (%eax),%eax
    e9e1:	0f b6 c0             	movzbl %al,%eax
    e9e4:	c1 e0 08             	shl    $0x8,%eax
    e9e7:	89 c2                	mov    %eax,%edx
    e9e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    e9ec:	83 c0 05             	add    $0x5,%eax
    e9ef:	0f b6 00             	movzbl (%eax),%eax
    e9f2:	0f b6 c0             	movzbl %al,%eax
    e9f5:	01 c2                	add    %eax,%edx
    e9f7:	8b 45 08             	mov    0x8(%ebp),%eax
    e9fa:	89 50 38             	mov    %edx,0x38(%eax)
  }

  return 0; /* OK */
    e9fd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    ea02:	5d                   	pop    %ebp
    ea03:	c3                   	ret    

0000ea04 <readChunk_tEXt>:

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    ea04:	55                   	push   %ebp
    ea05:	89 e5                	mov    %esp,%ebp
    ea07:	83 ec 28             	sub    $0x28,%esp
  unsigned error = 0;
    ea0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  char *key = 0, *str = 0;
    ea11:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    ea18:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ea1f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ea23:	0f 85 06 01 00 00    	jne    eb2f <readChunk_tEXt+0x12b>
    unsigned length, string2_begin;

    length = 0;
    ea29:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    while(length < chunkLength && data[length] != 0) ++length;
    ea30:	eb 04                	jmp    ea36 <readChunk_tEXt+0x32>
    ea32:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
    ea36:	8b 45 10             	mov    0x10(%ebp),%eax
    ea39:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    ea3c:	73 0f                	jae    ea4d <readChunk_tEXt+0x49>
    ea3e:	8b 55 0c             	mov    0xc(%ebp),%edx
    ea41:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ea44:	01 d0                	add    %edx,%eax
    ea46:	0f b6 00             	movzbl (%eax),%eax
    ea49:	84 c0                	test   %al,%al
    ea4b:	75 e5                	jne    ea32 <readChunk_tEXt+0x2e>
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    ea4d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    ea51:	74 06                	je     ea59 <readChunk_tEXt+0x55>
    ea53:	83 7d e8 4f          	cmpl   $0x4f,-0x18(%ebp)
    ea57:	76 0c                	jbe    ea65 <readChunk_tEXt+0x61>
    ea59:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    ea60:	e9 ca 00 00 00       	jmp    eb2f <readChunk_tEXt+0x12b>

    key = (char*)lodepng_malloc(length + 1);
    ea65:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ea68:	83 c0 01             	add    $0x1,%eax
    ea6b:	83 ec 0c             	sub    $0xc,%esp
    ea6e:	50                   	push   %eax
    ea6f:	e8 73 4b ff ff       	call   35e7 <lodepng_malloc>
    ea74:	83 c4 10             	add    $0x10,%esp
    ea77:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    ea7a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ea7e:	75 0c                	jne    ea8c <readChunk_tEXt+0x88>
    ea80:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ea87:	e9 a3 00 00 00       	jmp    eb2f <readChunk_tEXt+0x12b>

    lodepng_memcpy(key, data, length);
    ea8c:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ea8f:	83 ec 04             	sub    $0x4,%esp
    ea92:	50                   	push   %eax
    ea93:	ff 75 0c             	pushl  0xc(%ebp)
    ea96:	ff 75 f0             	pushl  -0x10(%ebp)
    ea99:	e8 87 4b ff ff       	call   3625 <lodepng_memcpy>
    ea9e:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    eaa1:	8b 55 f0             	mov    -0x10(%ebp),%edx
    eaa4:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eaa7:	01 d0                	add    %edx,%eax
    eaa9:	c6 00 00             	movb   $0x0,(%eax)

    string2_begin = length + 1; /*skip keyword null terminator*/
    eaac:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eaaf:	83 c0 01             	add    $0x1,%eax
    eab2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    length = (unsigned)(chunkLength < string2_begin ? 0 : chunkLength - string2_begin);
    eab5:	8b 45 10             	mov    0x10(%ebp),%eax
    eab8:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
    eabb:	72 08                	jb     eac5 <readChunk_tEXt+0xc1>
    eabd:	8b 45 10             	mov    0x10(%ebp),%eax
    eac0:	2b 45 e4             	sub    -0x1c(%ebp),%eax
    eac3:	eb 05                	jmp    eaca <readChunk_tEXt+0xc6>
    eac5:	b8 00 00 00 00       	mov    $0x0,%eax
    eaca:	89 45 e8             	mov    %eax,-0x18(%ebp)
    str = (char*)lodepng_malloc(length + 1);
    eacd:	8b 45 e8             	mov    -0x18(%ebp),%eax
    ead0:	83 c0 01             	add    $0x1,%eax
    ead3:	83 ec 0c             	sub    $0xc,%esp
    ead6:	50                   	push   %eax
    ead7:	e8 0b 4b ff ff       	call   35e7 <lodepng_malloc>
    eadc:	83 c4 10             	add    $0x10,%esp
    eadf:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/
    eae2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    eae6:	75 09                	jne    eaf1 <readChunk_tEXt+0xed>
    eae8:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    eaef:	eb 3e                	jmp    eb2f <readChunk_tEXt+0x12b>

    lodepng_memcpy(str, data + string2_begin, length);
    eaf1:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eaf4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
    eaf7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    eafa:	01 ca                	add    %ecx,%edx
    eafc:	83 ec 04             	sub    $0x4,%esp
    eaff:	50                   	push   %eax
    eb00:	52                   	push   %edx
    eb01:	ff 75 ec             	pushl  -0x14(%ebp)
    eb04:	e8 1c 4b ff ff       	call   3625 <lodepng_memcpy>
    eb09:	83 c4 10             	add    $0x10,%esp
    str[length] = 0;
    eb0c:	8b 55 ec             	mov    -0x14(%ebp),%edx
    eb0f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    eb12:	01 d0                	add    %edx,%eax
    eb14:	c6 00 00             	movb   $0x0,(%eax)

    error = lodepng_add_text(info, key, str);
    eb17:	83 ec 04             	sub    $0x4,%esp
    eb1a:	ff 75 ec             	pushl  -0x14(%ebp)
    eb1d:	ff 75 f0             	pushl  -0x10(%ebp)
    eb20:	ff 75 08             	pushl  0x8(%ebp)
    eb23:	e8 3f ac ff ff       	call   9767 <lodepng_add_text>
    eb28:	83 c4 10             	add    $0x10,%esp
    eb2b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    break;
    eb2e:	90                   	nop
  }

  lodepng_free(key);
    eb2f:	83 ec 0c             	sub    $0xc,%esp
    eb32:	ff 75 f0             	pushl  -0x10(%ebp)
    eb35:	e8 ce 4a ff ff       	call   3608 <lodepng_free>
    eb3a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    eb3d:	83 ec 0c             	sub    $0xc,%esp
    eb40:	ff 75 ec             	pushl  -0x14(%ebp)
    eb43:	e8 c0 4a ff ff       	call   3608 <lodepng_free>
    eb48:	83 c4 10             	add    $0x10,%esp

  return error;
    eb4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    eb4e:	c9                   	leave  
    eb4f:	c3                   	ret    

0000eb50 <readChunk_zTXt>:

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    eb50:	55                   	push   %ebp
    eb51:	89 e5                	mov    %esp,%ebp
    eb53:	83 ec 38             	sub    $0x38,%esp
  unsigned error = 0;
    eb56:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    eb5d:	8b 45 0c             	mov    0xc(%ebp),%eax
    eb60:	8b 10                	mov    (%eax),%edx
    eb62:	89 55 d0             	mov    %edx,-0x30(%ebp)
    eb65:	8b 50 04             	mov    0x4(%eax),%edx
    eb68:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    eb6b:	8b 50 08             	mov    0x8(%eax),%edx
    eb6e:	89 55 d8             	mov    %edx,-0x28(%ebp)
    eb71:	8b 50 0c             	mov    0xc(%eax),%edx
    eb74:	89 55 dc             	mov    %edx,-0x24(%ebp)
    eb77:	8b 50 10             	mov    0x10(%eax),%edx
    eb7a:	89 55 e0             	mov    %edx,-0x20(%ebp)
    eb7d:	8b 40 14             	mov    0x14(%eax),%eax
    eb80:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  unsigned length, string2_begin;
  char *key = 0;
    eb83:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* str = 0;
    eb8a:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  size_t size = 0;
    eb91:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    eb98:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eb9c:	0f 85 48 01 00 00    	jne    ecea <readChunk_zTXt+0x19a>
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    eba2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    eba9:	eb 04                	jmp    ebaf <readChunk_zTXt+0x5f>
    ebab:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ebaf:	8b 45 14             	mov    0x14(%ebp),%eax
    ebb2:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ebb5:	73 0f                	jae    ebc6 <readChunk_zTXt+0x76>
    ebb7:	8b 55 10             	mov    0x10(%ebp),%edx
    ebba:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ebbd:	01 d0                	add    %edx,%eax
    ebbf:	0f b6 00             	movzbl (%eax),%eax
    ebc2:	84 c0                	test   %al,%al
    ebc4:	75 e5                	jne    ebab <readChunk_zTXt+0x5b>
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    ebc6:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ebc9:	8d 50 02             	lea    0x2(%eax),%edx
    ebcc:	8b 45 14             	mov    0x14(%ebp),%eax
    ebcf:	39 c2                	cmp    %eax,%edx
    ebd1:	72 0c                	jb     ebdf <readChunk_zTXt+0x8f>
    ebd3:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ebda:	e9 0b 01 00 00       	jmp    ecea <readChunk_zTXt+0x19a>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    ebdf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    ebe3:	74 06                	je     ebeb <readChunk_zTXt+0x9b>
    ebe5:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
    ebe9:	76 0c                	jbe    ebf7 <readChunk_zTXt+0xa7>
    ebeb:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    ebf2:	e9 f3 00 00 00       	jmp    ecea <readChunk_zTXt+0x19a>

    key = (char*)lodepng_malloc(length + 1);
    ebf7:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ebfa:	83 c0 01             	add    $0x1,%eax
    ebfd:	83 ec 0c             	sub    $0xc,%esp
    ec00:	50                   	push   %eax
    ec01:	e8 e1 49 ff ff       	call   35e7 <lodepng_malloc>
    ec06:	83 c4 10             	add    $0x10,%esp
    ec09:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    ec0c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    ec10:	75 0c                	jne    ec1e <readChunk_zTXt+0xce>
    ec12:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ec19:	e9 cc 00 00 00       	jmp    ecea <readChunk_zTXt+0x19a>

    lodepng_memcpy(key, data, length);
    ec1e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec21:	83 ec 04             	sub    $0x4,%esp
    ec24:	50                   	push   %eax
    ec25:	ff 75 10             	pushl  0x10(%ebp)
    ec28:	ff 75 ec             	pushl  -0x14(%ebp)
    ec2b:	e8 f5 49 ff ff       	call   3625 <lodepng_memcpy>
    ec30:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    ec33:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ec36:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec39:	01 d0                	add    %edx,%eax
    ec3b:	c6 00 00             	movb   $0x0,(%eax)

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    ec3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec41:	8d 50 01             	lea    0x1(%eax),%edx
    ec44:	8b 45 10             	mov    0x10(%ebp),%eax
    ec47:	01 d0                	add    %edx,%eax
    ec49:	0f b6 00             	movzbl (%eax),%eax
    ec4c:	84 c0                	test   %al,%al
    ec4e:	74 0c                	je     ec5c <readChunk_zTXt+0x10c>
    ec50:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    ec57:	e9 8e 00 00 00       	jmp    ecea <readChunk_zTXt+0x19a>

    string2_begin = length + 2;
    ec5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec5f:	83 c0 02             	add    $0x2,%eax
    ec62:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    ec65:	8b 45 14             	mov    0x14(%ebp),%eax
    ec68:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    ec6b:	76 09                	jbe    ec76 <readChunk_zTXt+0x126>
    ec6d:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    ec74:	eb 74                	jmp    ecea <readChunk_zTXt+0x19a>

    length = (unsigned)chunkLength - string2_begin;
    ec76:	8b 45 14             	mov    0x14(%ebp),%eax
    ec79:	2b 45 e8             	sub    -0x18(%ebp),%eax
    ec7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    zlibsettings.max_output_size = decoder->max_text_size;
    ec7f:	8b 45 0c             	mov    0xc(%ebp),%eax
    ec82:	8b 40 30             	mov    0x30(%eax),%eax
    ec85:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
    ec88:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ec8b:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ec8e:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ec91:	01 d1                	add    %edx,%ecx
    ec93:	83 ec 08             	sub    $0x8,%esp
    ec96:	8d 55 d0             	lea    -0x30(%ebp),%edx
    ec99:	52                   	push   %edx
    ec9a:	50                   	push   %eax
    ec9b:	51                   	push   %ecx
    ec9c:	6a 00                	push   $0x0
    ec9e:	8d 45 c8             	lea    -0x38(%ebp),%eax
    eca1:	50                   	push   %eax
    eca2:	8d 45 cc             	lea    -0x34(%ebp),%eax
    eca5:	50                   	push   %eax
    eca6:	e8 f7 93 ff ff       	call   80a2 <zlib_decompress>
    ecab:	83 c4 20             	add    $0x20,%esp
    ecae:	89 45 f4             	mov    %eax,-0xc(%ebp)
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    ecb1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ecb5:	74 11                	je     ecc8 <readChunk_zTXt+0x178>
    ecb7:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ecba:	8b 45 c8             	mov    -0x38(%ebp),%eax
    ecbd:	39 c2                	cmp    %eax,%edx
    ecbf:	7d 07                	jge    ecc8 <readChunk_zTXt+0x178>
    ecc1:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
    if(error) break;
    ecc8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    eccc:	75 1b                	jne    ece9 <readChunk_zTXt+0x199>
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    ecce:	8b 55 c8             	mov    -0x38(%ebp),%edx
    ecd1:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ecd4:	52                   	push   %edx
    ecd5:	50                   	push   %eax
    ecd6:	ff 75 ec             	pushl  -0x14(%ebp)
    ecd9:	ff 75 08             	pushl  0x8(%ebp)
    ecdc:	e8 60 a9 ff ff       	call   9641 <lodepng_add_text_sized>
    ece1:	83 c4 10             	add    $0x10,%esp
    ece4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    break;
    ece7:	eb 01                	jmp    ecea <readChunk_zTXt+0x19a>
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&str, &size, 0, &data[string2_begin],
                            length, &zlibsettings);
    /*error: compressed text larger than  decoder->max_text_size*/
    if(error && size > zlibsettings.max_output_size) error = 112;
    if(error) break;
    ece9:	90                   	nop
    error = lodepng_add_text_sized(info, key, (char*)str, size);
    break;
  }

  lodepng_free(key);
    ecea:	83 ec 0c             	sub    $0xc,%esp
    eced:	ff 75 ec             	pushl  -0x14(%ebp)
    ecf0:	e8 13 49 ff ff       	call   3608 <lodepng_free>
    ecf5:	83 c4 10             	add    $0x10,%esp
  lodepng_free(str);
    ecf8:	8b 45 cc             	mov    -0x34(%ebp),%eax
    ecfb:	83 ec 0c             	sub    $0xc,%esp
    ecfe:	50                   	push   %eax
    ecff:	e8 04 49 ff ff       	call   3608 <lodepng_free>
    ed04:	83 c4 10             	add    $0x10,%esp

  return error;
    ed07:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    ed0a:	c9                   	leave  
    ed0b:	c3                   	ret    

0000ed0c <readChunk_iTXt>:

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    ed0c:	55                   	push   %ebp
    ed0d:	89 e5                	mov    %esp,%ebp
    ed0f:	83 ec 48             	sub    $0x48,%esp
  unsigned error = 0;
    ed12:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;

  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    ed19:	8b 45 0c             	mov    0xc(%ebp),%eax
    ed1c:	8b 10                	mov    (%eax),%edx
    ed1e:	89 55 c0             	mov    %edx,-0x40(%ebp)
    ed21:	8b 50 04             	mov    0x4(%eax),%edx
    ed24:	89 55 c4             	mov    %edx,-0x3c(%ebp)
    ed27:	8b 50 08             	mov    0x8(%eax),%edx
    ed2a:	89 55 c8             	mov    %edx,-0x38(%ebp)
    ed2d:	8b 50 0c             	mov    0xc(%eax),%edx
    ed30:	89 55 cc             	mov    %edx,-0x34(%ebp)
    ed33:	8b 50 10             	mov    0x10(%eax),%edx
    ed36:	89 55 d0             	mov    %edx,-0x30(%ebp)
    ed39:	8b 40 14             	mov    0x14(%eax),%eax
    ed3c:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
    ed3f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    ed46:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    ed4d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

  while(!error) /*not really a while loop, only used to break on error*/ {
    ed54:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    ed58:	0f 85 d5 02 00 00    	jne    f033 <readChunk_iTXt+0x327>
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/
    ed5e:	83 7d 14 04          	cmpl   $0x4,0x14(%ebp)
    ed62:	7f 0c                	jg     ed70 <readChunk_iTXt+0x64>
    ed64:	c7 45 f4 1e 00 00 00 	movl   $0x1e,-0xc(%ebp)
    ed6b:	e9 c3 02 00 00       	jmp    f033 <readChunk_iTXt+0x327>

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    ed70:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    ed77:	eb 04                	jmp    ed7d <readChunk_iTXt+0x71>
    ed79:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ed7d:	8b 45 14             	mov    0x14(%ebp),%eax
    ed80:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    ed83:	73 0f                	jae    ed94 <readChunk_iTXt+0x88>
    ed85:	8b 55 10             	mov    0x10(%ebp),%edx
    ed88:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed8b:	01 d0                	add    %edx,%eax
    ed8d:	0f b6 00             	movzbl (%eax),%eax
    ed90:	84 c0                	test   %al,%al
    ed92:	75 e5                	jne    ed79 <readChunk_iTXt+0x6d>
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    ed94:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ed97:	8d 50 03             	lea    0x3(%eax),%edx
    ed9a:	8b 45 14             	mov    0x14(%ebp),%eax
    ed9d:	39 c2                	cmp    %eax,%edx
    ed9f:	72 0c                	jb     edad <readChunk_iTXt+0xa1>
    eda1:	c7 45 f4 4b 00 00 00 	movl   $0x4b,-0xc(%ebp)
    eda8:	e9 86 02 00 00       	jmp    f033 <readChunk_iTXt+0x327>
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/
    edad:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    edb1:	74 06                	je     edb9 <readChunk_iTXt+0xad>
    edb3:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    edb7:	76 0c                	jbe    edc5 <readChunk_iTXt+0xb9>
    edb9:	c7 45 f4 59 00 00 00 	movl   $0x59,-0xc(%ebp)
    edc0:	e9 6e 02 00 00       	jmp    f033 <readChunk_iTXt+0x327>

    key = (char*)lodepng_malloc(length + 1);
    edc5:	8b 45 ec             	mov    -0x14(%ebp),%eax
    edc8:	83 c0 01             	add    $0x1,%eax
    edcb:	83 ec 0c             	sub    $0xc,%esp
    edce:	50                   	push   %eax
    edcf:	e8 13 48 ff ff       	call   35e7 <lodepng_malloc>
    edd4:	83 c4 10             	add    $0x10,%esp
    edd7:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/
    edda:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
    edde:	75 0c                	jne    edec <readChunk_iTXt+0xe0>
    ede0:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ede7:	e9 47 02 00 00       	jmp    f033 <readChunk_iTXt+0x327>

    lodepng_memcpy(key, data, length);
    edec:	8b 45 ec             	mov    -0x14(%ebp),%eax
    edef:	83 ec 04             	sub    $0x4,%esp
    edf2:	50                   	push   %eax
    edf3:	ff 75 10             	pushl  0x10(%ebp)
    edf6:	ff 75 e8             	pushl  -0x18(%ebp)
    edf9:	e8 27 48 ff ff       	call   3625 <lodepng_memcpy>
    edfe:	83 c4 10             	add    $0x10,%esp
    key[length] = 0;
    ee01:	8b 55 e8             	mov    -0x18(%ebp),%edx
    ee04:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee07:	01 d0                	add    %edx,%eax
    ee09:	c6 00 00             	movb   $0x0,(%eax)

    /*read the compression method*/
    compressed = data[length + 1];
    ee0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee0f:	8d 50 01             	lea    0x1(%eax),%edx
    ee12:	8b 45 10             	mov    0x10(%ebp),%eax
    ee15:	01 d0                	add    %edx,%eax
    ee17:	0f b6 00             	movzbl (%eax),%eax
    ee1a:	0f b6 c0             	movzbl %al,%eax
    ee1d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/
    ee20:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee23:	8d 50 02             	lea    0x2(%eax),%edx
    ee26:	8b 45 10             	mov    0x10(%ebp),%eax
    ee29:	01 d0                	add    %edx,%eax
    ee2b:	0f b6 00             	movzbl (%eax),%eax
    ee2e:	84 c0                	test   %al,%al
    ee30:	74 0c                	je     ee3e <readChunk_iTXt+0x132>
    ee32:	c7 45 f4 48 00 00 00 	movl   $0x48,-0xc(%ebp)
    ee39:	e9 f5 01 00 00       	jmp    f033 <readChunk_iTXt+0x327>

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    ee3e:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee41:	83 c0 03             	add    $0x3,%eax
    ee44:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    ee47:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    ee4e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ee51:	89 45 f0             	mov    %eax,-0x10(%ebp)
    ee54:	eb 08                	jmp    ee5e <readChunk_iTXt+0x152>
    ee56:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    ee5a:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    ee5e:	8b 45 14             	mov    0x14(%ebp),%eax
    ee61:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    ee64:	73 0f                	jae    ee75 <readChunk_iTXt+0x169>
    ee66:	8b 55 10             	mov    0x10(%ebp),%edx
    ee69:	8b 45 f0             	mov    -0x10(%ebp),%eax
    ee6c:	01 d0                	add    %edx,%eax
    ee6e:	0f b6 00             	movzbl (%eax),%eax
    ee71:	84 c0                	test   %al,%al
    ee73:	75 e1                	jne    ee56 <readChunk_iTXt+0x14a>

    langtag = (char*)lodepng_malloc(length + 1);
    ee75:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee78:	83 c0 01             	add    $0x1,%eax
    ee7b:	83 ec 0c             	sub    $0xc,%esp
    ee7e:	50                   	push   %eax
    ee7f:	e8 63 47 ff ff       	call   35e7 <lodepng_malloc>
    ee84:	83 c4 10             	add    $0x10,%esp
    ee87:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/
    ee8a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
    ee8e:	75 0c                	jne    ee9c <readChunk_iTXt+0x190>
    ee90:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ee97:	e9 97 01 00 00       	jmp    f033 <readChunk_iTXt+0x327>

    lodepng_memcpy(langtag, data + begin, length);
    ee9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ee9f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    eea2:	8b 55 d8             	mov    -0x28(%ebp),%edx
    eea5:	01 ca                	add    %ecx,%edx
    eea7:	83 ec 04             	sub    $0x4,%esp
    eeaa:	50                   	push   %eax
    eeab:	52                   	push   %edx
    eeac:	ff 75 e4             	pushl  -0x1c(%ebp)
    eeaf:	e8 71 47 ff ff       	call   3625 <lodepng_memcpy>
    eeb4:	83 c4 10             	add    $0x10,%esp
    langtag[length] = 0;
    eeb7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
    eeba:	8b 45 ec             	mov    -0x14(%ebp),%eax
    eebd:	01 d0                	add    %edx,%eax
    eebf:	c6 00 00             	movb   $0x0,(%eax)

    /*read the transkey*/
    begin += length + 1;
    eec2:	8b 55 ec             	mov    -0x14(%ebp),%edx
    eec5:	8b 45 d8             	mov    -0x28(%ebp),%eax
    eec8:	01 d0                	add    %edx,%eax
    eeca:	83 c0 01             	add    $0x1,%eax
    eecd:	89 45 d8             	mov    %eax,-0x28(%ebp)
    length = 0;
    eed0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;
    eed7:	8b 45 d8             	mov    -0x28(%ebp),%eax
    eeda:	89 45 f0             	mov    %eax,-0x10(%ebp)
    eedd:	eb 08                	jmp    eee7 <readChunk_iTXt+0x1db>
    eedf:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    eee3:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    eee7:	8b 45 14             	mov    0x14(%ebp),%eax
    eeea:	39 45 f0             	cmp    %eax,-0x10(%ebp)
    eeed:	73 0f                	jae    eefe <readChunk_iTXt+0x1f2>
    eeef:	8b 55 10             	mov    0x10(%ebp),%edx
    eef2:	8b 45 f0             	mov    -0x10(%ebp),%eax
    eef5:	01 d0                	add    %edx,%eax
    eef7:	0f b6 00             	movzbl (%eax),%eax
    eefa:	84 c0                	test   %al,%al
    eefc:	75 e1                	jne    eedf <readChunk_iTXt+0x1d3>

    transkey = (char*)lodepng_malloc(length + 1);
    eefe:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ef01:	83 c0 01             	add    $0x1,%eax
    ef04:	83 ec 0c             	sub    $0xc,%esp
    ef07:	50                   	push   %eax
    ef08:	e8 da 46 ff ff       	call   35e7 <lodepng_malloc>
    ef0d:	83 c4 10             	add    $0x10,%esp
    ef10:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/
    ef13:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
    ef17:	75 0c                	jne    ef25 <readChunk_iTXt+0x219>
    ef19:	c7 45 f4 53 00 00 00 	movl   $0x53,-0xc(%ebp)
    ef20:	e9 0e 01 00 00       	jmp    f033 <readChunk_iTXt+0x327>

    lodepng_memcpy(transkey, data + begin, length);
    ef25:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ef28:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ef2b:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ef2e:	01 ca                	add    %ecx,%edx
    ef30:	83 ec 04             	sub    $0x4,%esp
    ef33:	50                   	push   %eax
    ef34:	52                   	push   %edx
    ef35:	ff 75 e0             	pushl  -0x20(%ebp)
    ef38:	e8 e8 46 ff ff       	call   3625 <lodepng_memcpy>
    ef3d:	83 c4 10             	add    $0x10,%esp
    transkey[length] = 0;
    ef40:	8b 55 e0             	mov    -0x20(%ebp),%edx
    ef43:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ef46:	01 d0                	add    %edx,%eax
    ef48:	c6 00 00             	movb   $0x0,(%eax)

    /*read the actual text*/
    begin += length + 1;
    ef4b:	8b 55 ec             	mov    -0x14(%ebp),%edx
    ef4e:	8b 45 d8             	mov    -0x28(%ebp),%eax
    ef51:	01 d0                	add    %edx,%eax
    ef53:	83 c0 01             	add    $0x1,%eax
    ef56:	89 45 d8             	mov    %eax,-0x28(%ebp)

    length = (unsigned)chunkLength < begin ? 0 : (unsigned)chunkLength - begin;
    ef59:	8b 45 14             	mov    0x14(%ebp),%eax
    ef5c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
    ef5f:	72 08                	jb     ef69 <readChunk_iTXt+0x25d>
    ef61:	8b 45 14             	mov    0x14(%ebp),%eax
    ef64:	2b 45 d8             	sub    -0x28(%ebp),%eax
    ef67:	eb 05                	jmp    ef6e <readChunk_iTXt+0x262>
    ef69:	b8 00 00 00 00       	mov    $0x0,%eax
    ef6e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(compressed) {
    ef71:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
    ef75:	0f 84 90 00 00 00    	je     f00b <readChunk_iTXt+0x2ff>
      unsigned char* str = 0;
    ef7b:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
      size_t size = 0;
    ef82:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
      zlibsettings.max_output_size = decoder->max_text_size;
    ef89:	8b 45 0c             	mov    0xc(%ebp),%eax
    ef8c:	8b 40 30             	mov    0x30(%eax),%eax
    ef8f:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&str, &size, 0, &data[begin],
    ef92:	8b 45 ec             	mov    -0x14(%ebp),%eax
    ef95:	8b 4d 10             	mov    0x10(%ebp),%ecx
    ef98:	8b 55 d8             	mov    -0x28(%ebp),%edx
    ef9b:	01 d1                	add    %edx,%ecx
    ef9d:	83 ec 08             	sub    $0x8,%esp
    efa0:	8d 55 c0             	lea    -0x40(%ebp),%edx
    efa3:	52                   	push   %edx
    efa4:	50                   	push   %eax
    efa5:	51                   	push   %ecx
    efa6:	6a 00                	push   $0x0
    efa8:	8d 45 b8             	lea    -0x48(%ebp),%eax
    efab:	50                   	push   %eax
    efac:	8d 45 bc             	lea    -0x44(%ebp),%eax
    efaf:	50                   	push   %eax
    efb0:	e8 ed 90 ff ff       	call   80a2 <zlib_decompress>
    efb5:	83 c4 20             	add    $0x20,%esp
    efb8:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              length, &zlibsettings);
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
    efbb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    efbf:	74 11                	je     efd2 <readChunk_iTXt+0x2c6>
    efc1:	8b 55 c8             	mov    -0x38(%ebp),%edx
    efc4:	8b 45 b8             	mov    -0x48(%ebp),%eax
    efc7:	39 c2                	cmp    %eax,%edx
    efc9:	7d 07                	jge    efd2 <readChunk_iTXt+0x2c6>
    efcb:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%ebp)
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
    efd2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    efd6:	75 22                	jne    effa <readChunk_iTXt+0x2ee>
    efd8:	8b 55 b8             	mov    -0x48(%ebp),%edx
    efdb:	8b 45 bc             	mov    -0x44(%ebp),%eax
    efde:	83 ec 08             	sub    $0x8,%esp
    efe1:	52                   	push   %edx
    efe2:	50                   	push   %eax
    efe3:	ff 75 e0             	pushl  -0x20(%ebp)
    efe6:	ff 75 e4             	pushl  -0x1c(%ebp)
    efe9:	ff 75 e8             	pushl  -0x18(%ebp)
    efec:	ff 75 08             	pushl  0x8(%ebp)
    efef:	e8 94 a9 ff ff       	call   9988 <lodepng_add_itext_sized>
    eff4:	83 c4 20             	add    $0x20,%esp
    eff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
      lodepng_free(str);
    effa:	8b 45 bc             	mov    -0x44(%ebp),%eax
    effd:	83 ec 0c             	sub    $0xc,%esp
    f000:	50                   	push   %eax
    f001:	e8 02 46 ff ff       	call   3608 <lodepng_free>
    f006:	83 c4 10             	add    $0x10,%esp
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    }

    break;
    f009:	eb 27                	jmp    f032 <readChunk_iTXt+0x326>
      /*error: compressed text larger than  decoder->max_text_size*/
      if(error && size > zlibsettings.max_output_size) error = 112;
      if(!error) error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)str, size);
      lodepng_free(str);
    } else {
      error = lodepng_add_itext_sized(info, key, langtag, transkey, (char*)(data + begin), length);
    f00b:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f00e:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f011:	8b 55 d8             	mov    -0x28(%ebp),%edx
    f014:	01 ca                	add    %ecx,%edx
    f016:	83 ec 08             	sub    $0x8,%esp
    f019:	50                   	push   %eax
    f01a:	52                   	push   %edx
    f01b:	ff 75 e0             	pushl  -0x20(%ebp)
    f01e:	ff 75 e4             	pushl  -0x1c(%ebp)
    f021:	ff 75 e8             	pushl  -0x18(%ebp)
    f024:	ff 75 08             	pushl  0x8(%ebp)
    f027:	e8 5c a9 ff ff       	call   9988 <lodepng_add_itext_sized>
    f02c:	83 c4 20             	add    $0x20,%esp
    f02f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    break;
    f032:	90                   	nop
  }

  lodepng_free(key);
    f033:	83 ec 0c             	sub    $0xc,%esp
    f036:	ff 75 e8             	pushl  -0x18(%ebp)
    f039:	e8 ca 45 ff ff       	call   3608 <lodepng_free>
    f03e:	83 c4 10             	add    $0x10,%esp
  lodepng_free(langtag);
    f041:	83 ec 0c             	sub    $0xc,%esp
    f044:	ff 75 e4             	pushl  -0x1c(%ebp)
    f047:	e8 bc 45 ff ff       	call   3608 <lodepng_free>
    f04c:	83 c4 10             	add    $0x10,%esp
  lodepng_free(transkey);
    f04f:	83 ec 0c             	sub    $0xc,%esp
    f052:	ff 75 e0             	pushl  -0x20(%ebp)
    f055:	e8 ae 45 ff ff       	call   3608 <lodepng_free>
    f05a:	83 c4 10             	add    $0x10,%esp

  return error;
    f05d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f060:	c9                   	leave  
    f061:	c3                   	ret    

0000f062 <readChunk_tIME>:

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f062:	55                   	push   %ebp
    f063:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/
    f065:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
    f069:	74 0a                	je     f075 <readChunk_tIME+0x13>
    f06b:	b8 49 00 00 00       	mov    $0x49,%eax
    f070:	e9 8b 00 00 00       	jmp    f100 <readChunk_tIME+0x9e>

  info->time_defined = 1;
    f075:	8b 45 08             	mov    0x8(%ebp),%eax
    f078:	c7 40 5c 01 00 00 00 	movl   $0x1,0x5c(%eax)
  info->time.year = 256u * data[0] + data[1];
    f07f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f082:	0f b6 00             	movzbl (%eax),%eax
    f085:	0f b6 c0             	movzbl %al,%eax
    f088:	c1 e0 08             	shl    $0x8,%eax
    f08b:	89 c2                	mov    %eax,%edx
    f08d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f090:	83 c0 01             	add    $0x1,%eax
    f093:	0f b6 00             	movzbl (%eax),%eax
    f096:	0f b6 c0             	movzbl %al,%eax
    f099:	01 c2                	add    %eax,%edx
    f09b:	8b 45 08             	mov    0x8(%ebp),%eax
    f09e:	89 50 60             	mov    %edx,0x60(%eax)
  info->time.month = data[2];
    f0a1:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0a4:	83 c0 02             	add    $0x2,%eax
    f0a7:	0f b6 00             	movzbl (%eax),%eax
    f0aa:	0f b6 d0             	movzbl %al,%edx
    f0ad:	8b 45 08             	mov    0x8(%ebp),%eax
    f0b0:	89 50 64             	mov    %edx,0x64(%eax)
  info->time.day = data[3];
    f0b3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0b6:	83 c0 03             	add    $0x3,%eax
    f0b9:	0f b6 00             	movzbl (%eax),%eax
    f0bc:	0f b6 d0             	movzbl %al,%edx
    f0bf:	8b 45 08             	mov    0x8(%ebp),%eax
    f0c2:	89 50 68             	mov    %edx,0x68(%eax)
  info->time.hour = data[4];
    f0c5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0c8:	83 c0 04             	add    $0x4,%eax
    f0cb:	0f b6 00             	movzbl (%eax),%eax
    f0ce:	0f b6 d0             	movzbl %al,%edx
    f0d1:	8b 45 08             	mov    0x8(%ebp),%eax
    f0d4:	89 50 6c             	mov    %edx,0x6c(%eax)
  info->time.minute = data[5];
    f0d7:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0da:	83 c0 05             	add    $0x5,%eax
    f0dd:	0f b6 00             	movzbl (%eax),%eax
    f0e0:	0f b6 d0             	movzbl %al,%edx
    f0e3:	8b 45 08             	mov    0x8(%ebp),%eax
    f0e6:	89 50 70             	mov    %edx,0x70(%eax)
  info->time.second = data[6];
    f0e9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f0ec:	83 c0 06             	add    $0x6,%eax
    f0ef:	0f b6 00             	movzbl (%eax),%eax
    f0f2:	0f b6 d0             	movzbl %al,%edx
    f0f5:	8b 45 08             	mov    0x8(%ebp),%eax
    f0f8:	89 50 74             	mov    %edx,0x74(%eax)

  return 0; /* OK */
    f0fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f100:	5d                   	pop    %ebp
    f101:	c3                   	ret    

0000f102 <readChunk_pHYs>:

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f102:	55                   	push   %ebp
    f103:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/
    f105:	83 7d 10 09          	cmpl   $0x9,0x10(%ebp)
    f109:	74 0a                	je     f115 <readChunk_pHYs+0x13>
    f10b:	b8 4a 00 00 00       	mov    $0x4a,%eax
    f110:	e9 ba 00 00 00       	jmp    f1cf <readChunk_pHYs+0xcd>

  info->phys_defined = 1;
    f115:	8b 45 08             	mov    0x8(%ebp),%eax
    f118:	c7 40 78 01 00 00 00 	movl   $0x1,0x78(%eax)
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    f11f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f122:	0f b6 00             	movzbl (%eax),%eax
    f125:	0f b6 c0             	movzbl %al,%eax
    f128:	c1 e0 08             	shl    $0x8,%eax
    f12b:	89 c2                	mov    %eax,%edx
    f12d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f130:	83 c0 01             	add    $0x1,%eax
    f133:	0f b6 00             	movzbl (%eax),%eax
    f136:	0f b6 c0             	movzbl %al,%eax
    f139:	01 d0                	add    %edx,%eax
    f13b:	c1 e0 08             	shl    $0x8,%eax
    f13e:	89 c2                	mov    %eax,%edx
    f140:	8b 45 0c             	mov    0xc(%ebp),%eax
    f143:	83 c0 02             	add    $0x2,%eax
    f146:	0f b6 00             	movzbl (%eax),%eax
    f149:	0f b6 c0             	movzbl %al,%eax
    f14c:	01 d0                	add    %edx,%eax
    f14e:	c1 e0 08             	shl    $0x8,%eax
    f151:	89 c2                	mov    %eax,%edx
    f153:	8b 45 0c             	mov    0xc(%ebp),%eax
    f156:	83 c0 03             	add    $0x3,%eax
    f159:	0f b6 00             	movzbl (%eax),%eax
    f15c:	0f b6 c0             	movzbl %al,%eax
    f15f:	01 c2                	add    %eax,%edx
    f161:	8b 45 08             	mov    0x8(%ebp),%eax
    f164:	89 50 7c             	mov    %edx,0x7c(%eax)
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
    f167:	8b 45 0c             	mov    0xc(%ebp),%eax
    f16a:	83 c0 04             	add    $0x4,%eax
    f16d:	0f b6 00             	movzbl (%eax),%eax
    f170:	0f b6 c0             	movzbl %al,%eax
    f173:	c1 e0 08             	shl    $0x8,%eax
    f176:	89 c2                	mov    %eax,%edx
    f178:	8b 45 0c             	mov    0xc(%ebp),%eax
    f17b:	83 c0 05             	add    $0x5,%eax
    f17e:	0f b6 00             	movzbl (%eax),%eax
    f181:	0f b6 c0             	movzbl %al,%eax
    f184:	01 d0                	add    %edx,%eax
    f186:	c1 e0 08             	shl    $0x8,%eax
    f189:	89 c2                	mov    %eax,%edx
    f18b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f18e:	83 c0 06             	add    $0x6,%eax
    f191:	0f b6 00             	movzbl (%eax),%eax
    f194:	0f b6 c0             	movzbl %al,%eax
    f197:	01 d0                	add    %edx,%eax
    f199:	c1 e0 08             	shl    $0x8,%eax
    f19c:	89 c2                	mov    %eax,%edx
    f19e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1a1:	83 c0 07             	add    $0x7,%eax
    f1a4:	0f b6 00             	movzbl (%eax),%eax
    f1a7:	0f b6 c0             	movzbl %al,%eax
    f1aa:	01 c2                	add    %eax,%edx
    f1ac:	8b 45 08             	mov    0x8(%ebp),%eax
    f1af:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
  info->phys_unit = data[8];
    f1b5:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1b8:	83 c0 08             	add    $0x8,%eax
    f1bb:	0f b6 00             	movzbl (%eax),%eax
    f1be:	0f b6 d0             	movzbl %al,%edx
    f1c1:	8b 45 08             	mov    0x8(%ebp),%eax
    f1c4:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

  return 0; /* OK */
    f1ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f1cf:	5d                   	pop    %ebp
    f1d0:	c3                   	ret    

0000f1d1 <readChunk_gAMA>:

static unsigned readChunk_gAMA(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f1d1:	55                   	push   %ebp
    f1d2:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 4) return 96; /*invalid gAMA chunk size*/
    f1d4:	83 7d 10 04          	cmpl   $0x4,0x10(%ebp)
    f1d8:	74 07                	je     f1e1 <readChunk_gAMA+0x10>
    f1da:	b8 60 00 00 00       	mov    $0x60,%eax
    f1df:	eb 5d                	jmp    f23e <readChunk_gAMA+0x6d>

  info->gama_defined = 1;
    f1e1:	8b 45 08             	mov    0x8(%ebp),%eax
    f1e4:	c7 80 88 00 00 00 01 	movl   $0x1,0x88(%eax)
    f1eb:	00 00 00 
  info->gama_gamma = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
    f1ee:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1f1:	0f b6 00             	movzbl (%eax),%eax
    f1f4:	0f b6 c0             	movzbl %al,%eax
    f1f7:	c1 e0 08             	shl    $0x8,%eax
    f1fa:	89 c2                	mov    %eax,%edx
    f1fc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f1ff:	83 c0 01             	add    $0x1,%eax
    f202:	0f b6 00             	movzbl (%eax),%eax
    f205:	0f b6 c0             	movzbl %al,%eax
    f208:	01 d0                	add    %edx,%eax
    f20a:	c1 e0 08             	shl    $0x8,%eax
    f20d:	89 c2                	mov    %eax,%edx
    f20f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f212:	83 c0 02             	add    $0x2,%eax
    f215:	0f b6 00             	movzbl (%eax),%eax
    f218:	0f b6 c0             	movzbl %al,%eax
    f21b:	01 d0                	add    %edx,%eax
    f21d:	c1 e0 08             	shl    $0x8,%eax
    f220:	89 c2                	mov    %eax,%edx
    f222:	8b 45 0c             	mov    0xc(%ebp),%eax
    f225:	83 c0 03             	add    $0x3,%eax
    f228:	0f b6 00             	movzbl (%eax),%eax
    f22b:	0f b6 c0             	movzbl %al,%eax
    f22e:	01 c2                	add    %eax,%edx
    f230:	8b 45 08             	mov    0x8(%ebp),%eax
    f233:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)

  return 0; /* OK */
    f239:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f23e:	5d                   	pop    %ebp
    f23f:	c3                   	ret    

0000f240 <readChunk_cHRM>:

static unsigned readChunk_cHRM(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f240:	55                   	push   %ebp
    f241:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 32) return 97; /*invalid cHRM chunk size*/
    f243:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
    f247:	74 0a                	je     f253 <readChunk_cHRM+0x13>
    f249:	b8 61 00 00 00       	mov    $0x61,%eax
    f24e:	e9 7f 02 00 00       	jmp    f4d2 <readChunk_cHRM+0x292>

  info->chrm_defined = 1;
    f253:	8b 45 08             	mov    0x8(%ebp),%eax
    f256:	c7 80 90 00 00 00 01 	movl   $0x1,0x90(%eax)
    f25d:	00 00 00 
  info->chrm_white_x = 16777216u * data[ 0] + 65536u * data[ 1] + 256u * data[ 2] + data[ 3];
    f260:	8b 45 0c             	mov    0xc(%ebp),%eax
    f263:	0f b6 00             	movzbl (%eax),%eax
    f266:	0f b6 c0             	movzbl %al,%eax
    f269:	c1 e0 08             	shl    $0x8,%eax
    f26c:	89 c2                	mov    %eax,%edx
    f26e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f271:	83 c0 01             	add    $0x1,%eax
    f274:	0f b6 00             	movzbl (%eax),%eax
    f277:	0f b6 c0             	movzbl %al,%eax
    f27a:	01 d0                	add    %edx,%eax
    f27c:	c1 e0 08             	shl    $0x8,%eax
    f27f:	89 c2                	mov    %eax,%edx
    f281:	8b 45 0c             	mov    0xc(%ebp),%eax
    f284:	83 c0 02             	add    $0x2,%eax
    f287:	0f b6 00             	movzbl (%eax),%eax
    f28a:	0f b6 c0             	movzbl %al,%eax
    f28d:	01 d0                	add    %edx,%eax
    f28f:	c1 e0 08             	shl    $0x8,%eax
    f292:	89 c2                	mov    %eax,%edx
    f294:	8b 45 0c             	mov    0xc(%ebp),%eax
    f297:	83 c0 03             	add    $0x3,%eax
    f29a:	0f b6 00             	movzbl (%eax),%eax
    f29d:	0f b6 c0             	movzbl %al,%eax
    f2a0:	01 c2                	add    %eax,%edx
    f2a2:	8b 45 08             	mov    0x8(%ebp),%eax
    f2a5:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  info->chrm_white_y = 16777216u * data[ 4] + 65536u * data[ 5] + 256u * data[ 6] + data[ 7];
    f2ab:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2ae:	83 c0 04             	add    $0x4,%eax
    f2b1:	0f b6 00             	movzbl (%eax),%eax
    f2b4:	0f b6 c0             	movzbl %al,%eax
    f2b7:	c1 e0 08             	shl    $0x8,%eax
    f2ba:	89 c2                	mov    %eax,%edx
    f2bc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2bf:	83 c0 05             	add    $0x5,%eax
    f2c2:	0f b6 00             	movzbl (%eax),%eax
    f2c5:	0f b6 c0             	movzbl %al,%eax
    f2c8:	01 d0                	add    %edx,%eax
    f2ca:	c1 e0 08             	shl    $0x8,%eax
    f2cd:	89 c2                	mov    %eax,%edx
    f2cf:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2d2:	83 c0 06             	add    $0x6,%eax
    f2d5:	0f b6 00             	movzbl (%eax),%eax
    f2d8:	0f b6 c0             	movzbl %al,%eax
    f2db:	01 d0                	add    %edx,%eax
    f2dd:	c1 e0 08             	shl    $0x8,%eax
    f2e0:	89 c2                	mov    %eax,%edx
    f2e2:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2e5:	83 c0 07             	add    $0x7,%eax
    f2e8:	0f b6 00             	movzbl (%eax),%eax
    f2eb:	0f b6 c0             	movzbl %al,%eax
    f2ee:	01 c2                	add    %eax,%edx
    f2f0:	8b 45 08             	mov    0x8(%ebp),%eax
    f2f3:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  info->chrm_red_x   = 16777216u * data[ 8] + 65536u * data[ 9] + 256u * data[10] + data[11];
    f2f9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f2fc:	83 c0 08             	add    $0x8,%eax
    f2ff:	0f b6 00             	movzbl (%eax),%eax
    f302:	0f b6 c0             	movzbl %al,%eax
    f305:	c1 e0 08             	shl    $0x8,%eax
    f308:	89 c2                	mov    %eax,%edx
    f30a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f30d:	83 c0 09             	add    $0x9,%eax
    f310:	0f b6 00             	movzbl (%eax),%eax
    f313:	0f b6 c0             	movzbl %al,%eax
    f316:	01 d0                	add    %edx,%eax
    f318:	c1 e0 08             	shl    $0x8,%eax
    f31b:	89 c2                	mov    %eax,%edx
    f31d:	8b 45 0c             	mov    0xc(%ebp),%eax
    f320:	83 c0 0a             	add    $0xa,%eax
    f323:	0f b6 00             	movzbl (%eax),%eax
    f326:	0f b6 c0             	movzbl %al,%eax
    f329:	01 d0                	add    %edx,%eax
    f32b:	c1 e0 08             	shl    $0x8,%eax
    f32e:	89 c2                	mov    %eax,%edx
    f330:	8b 45 0c             	mov    0xc(%ebp),%eax
    f333:	83 c0 0b             	add    $0xb,%eax
    f336:	0f b6 00             	movzbl (%eax),%eax
    f339:	0f b6 c0             	movzbl %al,%eax
    f33c:	01 c2                	add    %eax,%edx
    f33e:	8b 45 08             	mov    0x8(%ebp),%eax
    f341:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
  info->chrm_red_y   = 16777216u * data[12] + 65536u * data[13] + 256u * data[14] + data[15];
    f347:	8b 45 0c             	mov    0xc(%ebp),%eax
    f34a:	83 c0 0c             	add    $0xc,%eax
    f34d:	0f b6 00             	movzbl (%eax),%eax
    f350:	0f b6 c0             	movzbl %al,%eax
    f353:	c1 e0 08             	shl    $0x8,%eax
    f356:	89 c2                	mov    %eax,%edx
    f358:	8b 45 0c             	mov    0xc(%ebp),%eax
    f35b:	83 c0 0d             	add    $0xd,%eax
    f35e:	0f b6 00             	movzbl (%eax),%eax
    f361:	0f b6 c0             	movzbl %al,%eax
    f364:	01 d0                	add    %edx,%eax
    f366:	c1 e0 08             	shl    $0x8,%eax
    f369:	89 c2                	mov    %eax,%edx
    f36b:	8b 45 0c             	mov    0xc(%ebp),%eax
    f36e:	83 c0 0e             	add    $0xe,%eax
    f371:	0f b6 00             	movzbl (%eax),%eax
    f374:	0f b6 c0             	movzbl %al,%eax
    f377:	01 d0                	add    %edx,%eax
    f379:	c1 e0 08             	shl    $0x8,%eax
    f37c:	89 c2                	mov    %eax,%edx
    f37e:	8b 45 0c             	mov    0xc(%ebp),%eax
    f381:	83 c0 0f             	add    $0xf,%eax
    f384:	0f b6 00             	movzbl (%eax),%eax
    f387:	0f b6 c0             	movzbl %al,%eax
    f38a:	01 c2                	add    %eax,%edx
    f38c:	8b 45 08             	mov    0x8(%ebp),%eax
    f38f:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
  info->chrm_green_x = 16777216u * data[16] + 65536u * data[17] + 256u * data[18] + data[19];
    f395:	8b 45 0c             	mov    0xc(%ebp),%eax
    f398:	83 c0 10             	add    $0x10,%eax
    f39b:	0f b6 00             	movzbl (%eax),%eax
    f39e:	0f b6 c0             	movzbl %al,%eax
    f3a1:	c1 e0 08             	shl    $0x8,%eax
    f3a4:	89 c2                	mov    %eax,%edx
    f3a6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3a9:	83 c0 11             	add    $0x11,%eax
    f3ac:	0f b6 00             	movzbl (%eax),%eax
    f3af:	0f b6 c0             	movzbl %al,%eax
    f3b2:	01 d0                	add    %edx,%eax
    f3b4:	c1 e0 08             	shl    $0x8,%eax
    f3b7:	89 c2                	mov    %eax,%edx
    f3b9:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3bc:	83 c0 12             	add    $0x12,%eax
    f3bf:	0f b6 00             	movzbl (%eax),%eax
    f3c2:	0f b6 c0             	movzbl %al,%eax
    f3c5:	01 d0                	add    %edx,%eax
    f3c7:	c1 e0 08             	shl    $0x8,%eax
    f3ca:	89 c2                	mov    %eax,%edx
    f3cc:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3cf:	83 c0 13             	add    $0x13,%eax
    f3d2:	0f b6 00             	movzbl (%eax),%eax
    f3d5:	0f b6 c0             	movzbl %al,%eax
    f3d8:	01 c2                	add    %eax,%edx
    f3da:	8b 45 08             	mov    0x8(%ebp),%eax
    f3dd:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
  info->chrm_green_y = 16777216u * data[20] + 65536u * data[21] + 256u * data[22] + data[23];
    f3e3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3e6:	83 c0 14             	add    $0x14,%eax
    f3e9:	0f b6 00             	movzbl (%eax),%eax
    f3ec:	0f b6 c0             	movzbl %al,%eax
    f3ef:	c1 e0 08             	shl    $0x8,%eax
    f3f2:	89 c2                	mov    %eax,%edx
    f3f4:	8b 45 0c             	mov    0xc(%ebp),%eax
    f3f7:	83 c0 15             	add    $0x15,%eax
    f3fa:	0f b6 00             	movzbl (%eax),%eax
    f3fd:	0f b6 c0             	movzbl %al,%eax
    f400:	01 d0                	add    %edx,%eax
    f402:	c1 e0 08             	shl    $0x8,%eax
    f405:	89 c2                	mov    %eax,%edx
    f407:	8b 45 0c             	mov    0xc(%ebp),%eax
    f40a:	83 c0 16             	add    $0x16,%eax
    f40d:	0f b6 00             	movzbl (%eax),%eax
    f410:	0f b6 c0             	movzbl %al,%eax
    f413:	01 d0                	add    %edx,%eax
    f415:	c1 e0 08             	shl    $0x8,%eax
    f418:	89 c2                	mov    %eax,%edx
    f41a:	8b 45 0c             	mov    0xc(%ebp),%eax
    f41d:	83 c0 17             	add    $0x17,%eax
    f420:	0f b6 00             	movzbl (%eax),%eax
    f423:	0f b6 c0             	movzbl %al,%eax
    f426:	01 c2                	add    %eax,%edx
    f428:	8b 45 08             	mov    0x8(%ebp),%eax
    f42b:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
  info->chrm_blue_x  = 16777216u * data[24] + 65536u * data[25] + 256u * data[26] + data[27];
    f431:	8b 45 0c             	mov    0xc(%ebp),%eax
    f434:	83 c0 18             	add    $0x18,%eax
    f437:	0f b6 00             	movzbl (%eax),%eax
    f43a:	0f b6 c0             	movzbl %al,%eax
    f43d:	c1 e0 08             	shl    $0x8,%eax
    f440:	89 c2                	mov    %eax,%edx
    f442:	8b 45 0c             	mov    0xc(%ebp),%eax
    f445:	83 c0 19             	add    $0x19,%eax
    f448:	0f b6 00             	movzbl (%eax),%eax
    f44b:	0f b6 c0             	movzbl %al,%eax
    f44e:	01 d0                	add    %edx,%eax
    f450:	c1 e0 08             	shl    $0x8,%eax
    f453:	89 c2                	mov    %eax,%edx
    f455:	8b 45 0c             	mov    0xc(%ebp),%eax
    f458:	83 c0 1a             	add    $0x1a,%eax
    f45b:	0f b6 00             	movzbl (%eax),%eax
    f45e:	0f b6 c0             	movzbl %al,%eax
    f461:	01 d0                	add    %edx,%eax
    f463:	c1 e0 08             	shl    $0x8,%eax
    f466:	89 c2                	mov    %eax,%edx
    f468:	8b 45 0c             	mov    0xc(%ebp),%eax
    f46b:	83 c0 1b             	add    $0x1b,%eax
    f46e:	0f b6 00             	movzbl (%eax),%eax
    f471:	0f b6 c0             	movzbl %al,%eax
    f474:	01 c2                	add    %eax,%edx
    f476:	8b 45 08             	mov    0x8(%ebp),%eax
    f479:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  info->chrm_blue_y  = 16777216u * data[28] + 65536u * data[29] + 256u * data[30] + data[31];
    f47f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f482:	83 c0 1c             	add    $0x1c,%eax
    f485:	0f b6 00             	movzbl (%eax),%eax
    f488:	0f b6 c0             	movzbl %al,%eax
    f48b:	c1 e0 08             	shl    $0x8,%eax
    f48e:	89 c2                	mov    %eax,%edx
    f490:	8b 45 0c             	mov    0xc(%ebp),%eax
    f493:	83 c0 1d             	add    $0x1d,%eax
    f496:	0f b6 00             	movzbl (%eax),%eax
    f499:	0f b6 c0             	movzbl %al,%eax
    f49c:	01 d0                	add    %edx,%eax
    f49e:	c1 e0 08             	shl    $0x8,%eax
    f4a1:	89 c2                	mov    %eax,%edx
    f4a3:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4a6:	83 c0 1e             	add    $0x1e,%eax
    f4a9:	0f b6 00             	movzbl (%eax),%eax
    f4ac:	0f b6 c0             	movzbl %al,%eax
    f4af:	01 d0                	add    %edx,%eax
    f4b1:	c1 e0 08             	shl    $0x8,%eax
    f4b4:	89 c2                	mov    %eax,%edx
    f4b6:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4b9:	83 c0 1f             	add    $0x1f,%eax
    f4bc:	0f b6 00             	movzbl (%eax),%eax
    f4bf:	0f b6 c0             	movzbl %al,%eax
    f4c2:	01 c2                	add    %eax,%edx
    f4c4:	8b 45 08             	mov    0x8(%ebp),%eax
    f4c7:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

  return 0; /* OK */
    f4cd:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f4d2:	5d                   	pop    %ebp
    f4d3:	c3                   	ret    

0000f4d4 <readChunk_sRGB>:

static unsigned readChunk_sRGB(LodePNGInfo* info, const unsigned char* data, size_t chunkLength) {
    f4d4:	55                   	push   %ebp
    f4d5:	89 e5                	mov    %esp,%ebp
  if(chunkLength != 1) return 98; /*invalid sRGB chunk size (this one is never ignored)*/
    f4d7:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
    f4db:	74 07                	je     f4e4 <readChunk_sRGB+0x10>
    f4dd:	b8 62 00 00 00       	mov    $0x62,%eax
    f4e2:	eb 24                	jmp    f508 <readChunk_sRGB+0x34>

  info->srgb_defined = 1;
    f4e4:	8b 45 08             	mov    0x8(%ebp),%eax
    f4e7:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
    f4ee:	00 00 00 
  info->srgb_intent = data[0];
    f4f1:	8b 45 0c             	mov    0xc(%ebp),%eax
    f4f4:	0f b6 00             	movzbl (%eax),%eax
    f4f7:	0f b6 d0             	movzbl %al,%edx
    f4fa:	8b 45 08             	mov    0x8(%ebp),%eax
    f4fd:	89 90 b8 00 00 00    	mov    %edx,0xb8(%eax)

  return 0; /* OK */
    f503:	b8 00 00 00 00       	mov    $0x0,%eax
}
    f508:	5d                   	pop    %ebp
    f509:	c3                   	ret    

0000f50a <readChunk_iCCP>:

static unsigned readChunk_iCCP(LodePNGInfo* info, const LodePNGDecoderSettings* decoder,
                               const unsigned char* data, size_t chunkLength) {
    f50a:	55                   	push   %ebp
    f50b:	89 e5                	mov    %esp,%ebp
    f50d:	53                   	push   %ebx
    f50e:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
    f511:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned i;
  size_t size = 0;
    f518:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  /*copy the object to change parameters in it*/
  LodePNGDecompressSettings zlibsettings = decoder->zlibsettings;
    f51f:	8b 45 0c             	mov    0xc(%ebp),%eax
    f522:	8b 10                	mov    (%eax),%edx
    f524:	89 55 cc             	mov    %edx,-0x34(%ebp)
    f527:	8b 50 04             	mov    0x4(%eax),%edx
    f52a:	89 55 d0             	mov    %edx,-0x30(%ebp)
    f52d:	8b 50 08             	mov    0x8(%eax),%edx
    f530:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    f533:	8b 50 0c             	mov    0xc(%eax),%edx
    f536:	89 55 d8             	mov    %edx,-0x28(%ebp)
    f539:	8b 50 10             	mov    0x10(%eax),%edx
    f53c:	89 55 dc             	mov    %edx,-0x24(%ebp)
    f53f:	8b 40 14             	mov    0x14(%eax),%eax
    f542:	89 45 e0             	mov    %eax,-0x20(%ebp)

  unsigned length, string2_begin;

  info->iccp_defined = 1;
    f545:	8b 45 08             	mov    0x8(%ebp),%eax
    f548:	c7 80 bc 00 00 00 01 	movl   $0x1,0xbc(%eax)
    f54f:	00 00 00 
  if(info->iccp_name) lodepng_clear_icc(info);
    f552:	8b 45 08             	mov    0x8(%ebp),%eax
    f555:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f55b:	85 c0                	test   %eax,%eax
    f55d:	74 0e                	je     f56d <readChunk_iCCP+0x63>
    f55f:	83 ec 0c             	sub    $0xc,%esp
    f562:	ff 75 08             	pushl  0x8(%ebp)
    f565:	e8 ca a6 ff ff       	call   9c34 <lodepng_clear_icc>
    f56a:	83 c4 10             	add    $0x10,%esp

  for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
    f56d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    f574:	eb 04                	jmp    f57a <readChunk_iCCP+0x70>
    f576:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    f57a:	8b 45 14             	mov    0x14(%ebp),%eax
    f57d:	39 45 ec             	cmp    %eax,-0x14(%ebp)
    f580:	73 0f                	jae    f591 <readChunk_iCCP+0x87>
    f582:	8b 55 10             	mov    0x10(%ebp),%edx
    f585:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f588:	01 d0                	add    %edx,%eax
    f58a:	0f b6 00             	movzbl (%eax),%eax
    f58d:	84 c0                	test   %al,%al
    f58f:	75 e5                	jne    f576 <readChunk_iCCP+0x6c>
  if(length + 2 >= chunkLength) return 75; /*no null termination, corrupt?*/
    f591:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f594:	8d 50 02             	lea    0x2(%eax),%edx
    f597:	8b 45 14             	mov    0x14(%ebp),%eax
    f59a:	39 c2                	cmp    %eax,%edx
    f59c:	72 0a                	jb     f5a8 <readChunk_iCCP+0x9e>
    f59e:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f5a3:	e9 46 01 00 00       	jmp    f6ee <readChunk_iCCP+0x1e4>
  if(length < 1 || length > 79) return 89; /*keyword too short or long*/
    f5a8:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
    f5ac:	74 06                	je     f5b4 <readChunk_iCCP+0xaa>
    f5ae:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
    f5b2:	76 0a                	jbe    f5be <readChunk_iCCP+0xb4>
    f5b4:	b8 59 00 00 00       	mov    $0x59,%eax
    f5b9:	e9 30 01 00 00       	jmp    f6ee <readChunk_iCCP+0x1e4>

  info->iccp_name = (char*)lodepng_malloc(length + 1);
    f5be:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f5c1:	83 c0 01             	add    $0x1,%eax
    f5c4:	83 ec 0c             	sub    $0xc,%esp
    f5c7:	50                   	push   %eax
    f5c8:	e8 1a 40 ff ff       	call   35e7 <lodepng_malloc>
    f5cd:	83 c4 10             	add    $0x10,%esp
    f5d0:	89 c2                	mov    %eax,%edx
    f5d2:	8b 45 08             	mov    0x8(%ebp),%eax
    f5d5:	89 90 c0 00 00 00    	mov    %edx,0xc0(%eax)
  if(!info->iccp_name) return 83; /*alloc fail*/
    f5db:	8b 45 08             	mov    0x8(%ebp),%eax
    f5de:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
    f5e4:	85 c0                	test   %eax,%eax
    f5e6:	75 0a                	jne    f5f2 <readChunk_iCCP+0xe8>
    f5e8:	b8 53 00 00 00       	mov    $0x53,%eax
    f5ed:	e9 fc 00 00 00       	jmp    f6ee <readChunk_iCCP+0x1e4>

  info->iccp_name[length] = 0;
    f5f2:	8b 45 08             	mov    0x8(%ebp),%eax
    f5f5:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f5fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f5fe:	01 d0                	add    %edx,%eax
    f600:	c6 00 00             	movb   $0x0,(%eax)
  for(i = 0; i != length; ++i) info->iccp_name[i] = (char)data[i];
    f603:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    f60a:	eb 1f                	jmp    f62b <readChunk_iCCP+0x121>
    f60c:	8b 45 08             	mov    0x8(%ebp),%eax
    f60f:	8b 90 c0 00 00 00    	mov    0xc0(%eax),%edx
    f615:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f618:	01 d0                	add    %edx,%eax
    f61a:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f61d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    f620:	01 ca                	add    %ecx,%edx
    f622:	0f b6 12             	movzbl (%edx),%edx
    f625:	88 10                	mov    %dl,(%eax)
    f627:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
    f62b:	8b 45 f0             	mov    -0x10(%ebp),%eax
    f62e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
    f631:	75 d9                	jne    f60c <readChunk_iCCP+0x102>

  if(data[length + 1] != 0) return 72; /*the 0 byte indicating compression must be 0*/
    f633:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f636:	8d 50 01             	lea    0x1(%eax),%edx
    f639:	8b 45 10             	mov    0x10(%ebp),%eax
    f63c:	01 d0                	add    %edx,%eax
    f63e:	0f b6 00             	movzbl (%eax),%eax
    f641:	84 c0                	test   %al,%al
    f643:	74 0a                	je     f64f <readChunk_iCCP+0x145>
    f645:	b8 48 00 00 00       	mov    $0x48,%eax
    f64a:	e9 9f 00 00 00       	jmp    f6ee <readChunk_iCCP+0x1e4>

  string2_begin = length + 2;
    f64f:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f652:	83 c0 02             	add    $0x2,%eax
    f655:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(string2_begin > chunkLength) return 75; /*no null termination, corrupt?*/
    f658:	8b 45 14             	mov    0x14(%ebp),%eax
    f65b:	39 45 e8             	cmp    %eax,-0x18(%ebp)
    f65e:	76 0a                	jbe    f66a <readChunk_iCCP+0x160>
    f660:	b8 4b 00 00 00       	mov    $0x4b,%eax
    f665:	e9 84 00 00 00       	jmp    f6ee <readChunk_iCCP+0x1e4>

  length = (unsigned)chunkLength - string2_begin;
    f66a:	8b 45 14             	mov    0x14(%ebp),%eax
    f66d:	2b 45 e8             	sub    -0x18(%ebp),%eax
    f670:	89 45 ec             	mov    %eax,-0x14(%ebp)
  zlibsettings.max_output_size = decoder->max_icc_size;
    f673:	8b 45 0c             	mov    0xc(%ebp),%eax
    f676:	8b 40 34             	mov    0x34(%eax),%eax
    f679:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  error = zlib_decompress(&info->iccp_profile, &size, 0,
    f67c:	8b 45 ec             	mov    -0x14(%ebp),%eax
    f67f:	8b 4d 10             	mov    0x10(%ebp),%ecx
    f682:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f685:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
    f688:	8b 55 08             	mov    0x8(%ebp),%edx
    f68b:	8d 8a c4 00 00 00    	lea    0xc4(%edx),%ecx
    f691:	83 ec 08             	sub    $0x8,%esp
    f694:	8d 55 cc             	lea    -0x34(%ebp),%edx
    f697:	52                   	push   %edx
    f698:	50                   	push   %eax
    f699:	53                   	push   %ebx
    f69a:	6a 00                	push   $0x0
    f69c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
    f69f:	50                   	push   %eax
    f6a0:	51                   	push   %ecx
    f6a1:	e8 fc 89 ff ff       	call   80a2 <zlib_decompress>
    f6a6:	83 c4 20             	add    $0x20,%esp
    f6a9:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          &data[string2_begin],
                          length, &zlibsettings);
  /*error: ICC profile larger than  decoder->max_icc_size*/
  if(error && size > zlibsettings.max_output_size) error = 113;
    f6ac:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f6b0:	74 11                	je     f6c3 <readChunk_iCCP+0x1b9>
    f6b2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    f6b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f6b8:	39 c2                	cmp    %eax,%edx
    f6ba:	7d 07                	jge    f6c3 <readChunk_iCCP+0x1b9>
    f6bc:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%ebp)
  info->iccp_profile_size = size;
    f6c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f6c6:	89 c2                	mov    %eax,%edx
    f6c8:	8b 45 08             	mov    0x8(%ebp),%eax
    f6cb:	89 90 c8 00 00 00    	mov    %edx,0xc8(%eax)
  if(!error && !info->iccp_profile_size) error = 100; /*invalid ICC profile size*/
    f6d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    f6d5:	75 14                	jne    f6eb <readChunk_iCCP+0x1e1>
    f6d7:	8b 45 08             	mov    0x8(%ebp),%eax
    f6da:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
    f6e0:	85 c0                	test   %eax,%eax
    f6e2:	75 07                	jne    f6eb <readChunk_iCCP+0x1e1>
    f6e4:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
  return error;
    f6eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
    f6ee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    f6f1:	c9                   	leave  
    f6f2:	c3                   	ret    

0000f6f3 <lodepng_inspect_chunk>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_inspect_chunk(LodePNGState* state, size_t pos,
                               const unsigned char* in, size_t insize) {
    f6f3:	55                   	push   %ebp
    f6f4:	89 e5                	mov    %esp,%ebp
    f6f6:	83 ec 28             	sub    $0x28,%esp
  const unsigned char* chunk = in + pos;
    f6f9:	8b 55 0c             	mov    0xc(%ebp),%edx
    f6fc:	8b 45 10             	mov    0x10(%ebp),%eax
    f6ff:	01 d0                	add    %edx,%eax
    f701:	89 45 ec             	mov    %eax,-0x14(%ebp)
  unsigned chunkLength;
  const unsigned char* data;
  unsigned unhandled = 0;
    f704:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned error = 0;
    f70b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  if(pos + 4 > insize) return 30;
    f712:	8b 45 0c             	mov    0xc(%ebp),%eax
    f715:	83 c0 04             	add    $0x4,%eax
    f718:	3b 45 14             	cmp    0x14(%ebp),%eax
    f71b:	7e 0a                	jle    f727 <lodepng_inspect_chunk+0x34>
    f71d:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f722:	e9 43 03 00 00       	jmp    fa6a <lodepng_inspect_chunk+0x377>
  chunkLength = lodepng_chunk_length(chunk);
    f727:	ff 75 ec             	pushl  -0x14(%ebp)
    f72a:	e8 3a 8e ff ff       	call   8569 <lodepng_chunk_length>
    f72f:	83 c4 04             	add    $0x4,%esp
    f732:	89 45 e8             	mov    %eax,-0x18(%ebp)
  if(chunkLength > 2147483647) return 63;
    f735:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f738:	85 c0                	test   %eax,%eax
    f73a:	79 0a                	jns    f746 <lodepng_inspect_chunk+0x53>
    f73c:	b8 3f 00 00 00       	mov    $0x3f,%eax
    f741:	e9 24 03 00 00       	jmp    fa6a <lodepng_inspect_chunk+0x377>
  data = lodepng_chunk_data_const(chunk);
    f746:	ff 75 ec             	pushl  -0x14(%ebp)
    f749:	e8 53 8f ff ff       	call   86a1 <lodepng_chunk_data_const>
    f74e:	83 c4 04             	add    $0x4,%esp
    f751:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if(data + chunkLength + 4 > in + insize) return 30;
    f754:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f757:	8d 50 04             	lea    0x4(%eax),%edx
    f75a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    f75d:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
    f760:	8b 55 14             	mov    0x14(%ebp),%edx
    f763:	8b 45 10             	mov    0x10(%ebp),%eax
    f766:	01 d0                	add    %edx,%eax
    f768:	39 c1                	cmp    %eax,%ecx
    f76a:	76 0a                	jbe    f776 <lodepng_inspect_chunk+0x83>
    f76c:	b8 1e 00 00 00       	mov    $0x1e,%eax
    f771:	e9 f4 02 00 00       	jmp    fa6a <lodepng_inspect_chunk+0x377>

  if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    f776:	68 28 a3 01 00       	push   $0x1a328
    f77b:	ff 75 ec             	pushl  -0x14(%ebp)
    f77e:	e8 33 8e ff ff       	call   85b6 <lodepng_chunk_type_equals>
    f783:	83 c4 08             	add    $0x8,%esp
    f786:	84 c0                	test   %al,%al
    f788:	74 24                	je     f7ae <lodepng_inspect_chunk+0xbb>
    error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    f78a:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f78d:	8b 55 08             	mov    0x8(%ebp),%edx
    f790:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f796:	83 ec 04             	sub    $0x4,%esp
    f799:	50                   	push   %eax
    f79a:	ff 75 e4             	pushl  -0x1c(%ebp)
    f79d:	52                   	push   %edx
    f79e:	e8 5b ee ff ff       	call   e5fe <readChunk_PLTE>
    f7a3:	83 c4 10             	add    $0x10,%esp
    f7a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f7a9:	e9 8a 02 00 00       	jmp    fa38 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    f7ae:	83 ec 08             	sub    $0x8,%esp
    f7b1:	68 2d a3 01 00       	push   $0x1a32d
    f7b6:	ff 75 ec             	pushl  -0x14(%ebp)
    f7b9:	e8 f8 8d ff ff       	call   85b6 <lodepng_chunk_type_equals>
    f7be:	83 c4 10             	add    $0x10,%esp
    f7c1:	84 c0                	test   %al,%al
    f7c3:	74 24                	je     f7e9 <lodepng_inspect_chunk+0xf6>
    error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    f7c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f7c8:	8b 55 08             	mov    0x8(%ebp),%edx
    f7cb:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    f7d1:	83 ec 04             	sub    $0x4,%esp
    f7d4:	50                   	push   %eax
    f7d5:	ff 75 e4             	pushl  -0x1c(%ebp)
    f7d8:	52                   	push   %edx
    f7d9:	e8 40 ef ff ff       	call   e71e <readChunk_tRNS>
    f7de:	83 c4 10             	add    $0x10,%esp
    f7e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f7e4:	e9 4f 02 00 00       	jmp    fa38 <lodepng_inspect_chunk+0x345>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    f7e9:	83 ec 08             	sub    $0x8,%esp
    f7ec:	68 32 a3 01 00       	push   $0x1a332
    f7f1:	ff 75 ec             	pushl  -0x14(%ebp)
    f7f4:	e8 bd 8d ff ff       	call   85b6 <lodepng_chunk_type_equals>
    f7f9:	83 c4 10             	add    $0x10,%esp
    f7fc:	84 c0                	test   %al,%al
    f7fe:	74 24                	je     f824 <lodepng_inspect_chunk+0x131>
    error = readChunk_bKGD(&state->info_png, data, chunkLength);
    f800:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f803:	8b 55 08             	mov    0x8(%ebp),%edx
    f806:	81 c2 98 00 00 00    	add    $0x98,%edx
    f80c:	83 ec 04             	sub    $0x4,%esp
    f80f:	50                   	push   %eax
    f810:	ff 75 e4             	pushl  -0x1c(%ebp)
    f813:	52                   	push   %edx
    f814:	e8 68 f0 ff ff       	call   e881 <readChunk_bKGD>
    f819:	83 c4 10             	add    $0x10,%esp
    f81c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f81f:	e9 14 02 00 00       	jmp    fa38 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    f824:	83 ec 08             	sub    $0x8,%esp
    f827:	68 37 a3 01 00       	push   $0x1a337
    f82c:	ff 75 ec             	pushl  -0x14(%ebp)
    f82f:	e8 82 8d ff ff       	call   85b6 <lodepng_chunk_type_equals>
    f834:	83 c4 10             	add    $0x10,%esp
    f837:	84 c0                	test   %al,%al
    f839:	74 24                	je     f85f <lodepng_inspect_chunk+0x16c>
    error = readChunk_tEXt(&state->info_png, data, chunkLength);
    f83b:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f83e:	8b 55 08             	mov    0x8(%ebp),%edx
    f841:	81 c2 98 00 00 00    	add    $0x98,%edx
    f847:	83 ec 04             	sub    $0x4,%esp
    f84a:	50                   	push   %eax
    f84b:	ff 75 e4             	pushl  -0x1c(%ebp)
    f84e:	52                   	push   %edx
    f84f:	e8 b0 f1 ff ff       	call   ea04 <readChunk_tEXt>
    f854:	83 c4 10             	add    $0x10,%esp
    f857:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f85a:	e9 d9 01 00 00       	jmp    fa38 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    f85f:	83 ec 08             	sub    $0x8,%esp
    f862:	68 3c a3 01 00       	push   $0x1a33c
    f867:	ff 75 ec             	pushl  -0x14(%ebp)
    f86a:	e8 47 8d ff ff       	call   85b6 <lodepng_chunk_type_equals>
    f86f:	83 c4 10             	add    $0x10,%esp
    f872:	84 c0                	test   %al,%al
    f874:	74 25                	je     f89b <lodepng_inspect_chunk+0x1a8>
    error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    f876:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f879:	8b 45 08             	mov    0x8(%ebp),%eax
    f87c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f87f:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f885:	52                   	push   %edx
    f886:	ff 75 e4             	pushl  -0x1c(%ebp)
    f889:	50                   	push   %eax
    f88a:	51                   	push   %ecx
    f88b:	e8 c0 f2 ff ff       	call   eb50 <readChunk_zTXt>
    f890:	83 c4 10             	add    $0x10,%esp
    f893:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f896:	e9 9d 01 00 00       	jmp    fa38 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    f89b:	83 ec 08             	sub    $0x8,%esp
    f89e:	68 41 a3 01 00       	push   $0x1a341
    f8a3:	ff 75 ec             	pushl  -0x14(%ebp)
    f8a6:	e8 0b 8d ff ff       	call   85b6 <lodepng_chunk_type_equals>
    f8ab:	83 c4 10             	add    $0x10,%esp
    f8ae:	84 c0                	test   %al,%al
    f8b0:	74 25                	je     f8d7 <lodepng_inspect_chunk+0x1e4>
    error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    f8b2:	8b 55 e8             	mov    -0x18(%ebp),%edx
    f8b5:	8b 45 08             	mov    0x8(%ebp),%eax
    f8b8:	8b 4d 08             	mov    0x8(%ebp),%ecx
    f8bb:	81 c1 98 00 00 00    	add    $0x98,%ecx
    f8c1:	52                   	push   %edx
    f8c2:	ff 75 e4             	pushl  -0x1c(%ebp)
    f8c5:	50                   	push   %eax
    f8c6:	51                   	push   %ecx
    f8c7:	e8 40 f4 ff ff       	call   ed0c <readChunk_iTXt>
    f8cc:	83 c4 10             	add    $0x10,%esp
    f8cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f8d2:	e9 61 01 00 00       	jmp    fa38 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    f8d7:	83 ec 08             	sub    $0x8,%esp
    f8da:	68 46 a3 01 00       	push   $0x1a346
    f8df:	ff 75 ec             	pushl  -0x14(%ebp)
    f8e2:	e8 cf 8c ff ff       	call   85b6 <lodepng_chunk_type_equals>
    f8e7:	83 c4 10             	add    $0x10,%esp
    f8ea:	84 c0                	test   %al,%al
    f8ec:	74 24                	je     f912 <lodepng_inspect_chunk+0x21f>
    error = readChunk_tIME(&state->info_png, data, chunkLength);
    f8ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f8f1:	8b 55 08             	mov    0x8(%ebp),%edx
    f8f4:	81 c2 98 00 00 00    	add    $0x98,%edx
    f8fa:	83 ec 04             	sub    $0x4,%esp
    f8fd:	50                   	push   %eax
    f8fe:	ff 75 e4             	pushl  -0x1c(%ebp)
    f901:	52                   	push   %edx
    f902:	e8 5b f7 ff ff       	call   f062 <readChunk_tIME>
    f907:	83 c4 10             	add    $0x10,%esp
    f90a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f90d:	e9 26 01 00 00       	jmp    fa38 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    f912:	83 ec 08             	sub    $0x8,%esp
    f915:	68 4b a3 01 00       	push   $0x1a34b
    f91a:	ff 75 ec             	pushl  -0x14(%ebp)
    f91d:	e8 94 8c ff ff       	call   85b6 <lodepng_chunk_type_equals>
    f922:	83 c4 10             	add    $0x10,%esp
    f925:	84 c0                	test   %al,%al
    f927:	74 24                	je     f94d <lodepng_inspect_chunk+0x25a>
    error = readChunk_pHYs(&state->info_png, data, chunkLength);
    f929:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f92c:	8b 55 08             	mov    0x8(%ebp),%edx
    f92f:	81 c2 98 00 00 00    	add    $0x98,%edx
    f935:	83 ec 04             	sub    $0x4,%esp
    f938:	50                   	push   %eax
    f939:	ff 75 e4             	pushl  -0x1c(%ebp)
    f93c:	52                   	push   %edx
    f93d:	e8 c0 f7 ff ff       	call   f102 <readChunk_pHYs>
    f942:	83 c4 10             	add    $0x10,%esp
    f945:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f948:	e9 eb 00 00 00       	jmp    fa38 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    f94d:	83 ec 08             	sub    $0x8,%esp
    f950:	68 50 a3 01 00       	push   $0x1a350
    f955:	ff 75 ec             	pushl  -0x14(%ebp)
    f958:	e8 59 8c ff ff       	call   85b6 <lodepng_chunk_type_equals>
    f95d:	83 c4 10             	add    $0x10,%esp
    f960:	84 c0                	test   %al,%al
    f962:	74 24                	je     f988 <lodepng_inspect_chunk+0x295>
    error = readChunk_gAMA(&state->info_png, data, chunkLength);
    f964:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f967:	8b 55 08             	mov    0x8(%ebp),%edx
    f96a:	81 c2 98 00 00 00    	add    $0x98,%edx
    f970:	83 ec 04             	sub    $0x4,%esp
    f973:	50                   	push   %eax
    f974:	ff 75 e4             	pushl  -0x1c(%ebp)
    f977:	52                   	push   %edx
    f978:	e8 54 f8 ff ff       	call   f1d1 <readChunk_gAMA>
    f97d:	83 c4 10             	add    $0x10,%esp
    f980:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f983:	e9 b0 00 00 00       	jmp    fa38 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
    f988:	83 ec 08             	sub    $0x8,%esp
    f98b:	68 55 a3 01 00       	push   $0x1a355
    f990:	ff 75 ec             	pushl  -0x14(%ebp)
    f993:	e8 1e 8c ff ff       	call   85b6 <lodepng_chunk_type_equals>
    f998:	83 c4 10             	add    $0x10,%esp
    f99b:	84 c0                	test   %al,%al
    f99d:	74 21                	je     f9c0 <lodepng_inspect_chunk+0x2cd>
    error = readChunk_cHRM(&state->info_png, data, chunkLength);
    f99f:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f9a2:	8b 55 08             	mov    0x8(%ebp),%edx
    f9a5:	81 c2 98 00 00 00    	add    $0x98,%edx
    f9ab:	83 ec 04             	sub    $0x4,%esp
    f9ae:	50                   	push   %eax
    f9af:	ff 75 e4             	pushl  -0x1c(%ebp)
    f9b2:	52                   	push   %edx
    f9b3:	e8 88 f8 ff ff       	call   f240 <readChunk_cHRM>
    f9b8:	83 c4 10             	add    $0x10,%esp
    f9bb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f9be:	eb 78                	jmp    fa38 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
    f9c0:	83 ec 08             	sub    $0x8,%esp
    f9c3:	68 5a a3 01 00       	push   $0x1a35a
    f9c8:	ff 75 ec             	pushl  -0x14(%ebp)
    f9cb:	e8 e6 8b ff ff       	call   85b6 <lodepng_chunk_type_equals>
    f9d0:	83 c4 10             	add    $0x10,%esp
    f9d3:	84 c0                	test   %al,%al
    f9d5:	74 21                	je     f9f8 <lodepng_inspect_chunk+0x305>
    error = readChunk_sRGB(&state->info_png, data, chunkLength);
    f9d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
    f9da:	8b 55 08             	mov    0x8(%ebp),%edx
    f9dd:	81 c2 98 00 00 00    	add    $0x98,%edx
    f9e3:	83 ec 04             	sub    $0x4,%esp
    f9e6:	50                   	push   %eax
    f9e7:	ff 75 e4             	pushl  -0x1c(%ebp)
    f9ea:	52                   	push   %edx
    f9eb:	e8 e4 fa ff ff       	call   f4d4 <readChunk_sRGB>
    f9f0:	83 c4 10             	add    $0x10,%esp
    f9f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    f9f6:	eb 40                	jmp    fa38 <lodepng_inspect_chunk+0x345>
  } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
    f9f8:	83 ec 08             	sub    $0x8,%esp
    f9fb:	68 5f a3 01 00       	push   $0x1a35f
    fa00:	ff 75 ec             	pushl  -0x14(%ebp)
    fa03:	e8 ae 8b ff ff       	call   85b6 <lodepng_chunk_type_equals>
    fa08:	83 c4 10             	add    $0x10,%esp
    fa0b:	84 c0                	test   %al,%al
    fa0d:	74 22                	je     fa31 <lodepng_inspect_chunk+0x33e>
    error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
    fa0f:	8b 55 e8             	mov    -0x18(%ebp),%edx
    fa12:	8b 45 08             	mov    0x8(%ebp),%eax
    fa15:	8b 4d 08             	mov    0x8(%ebp),%ecx
    fa18:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fa1e:	52                   	push   %edx
    fa1f:	ff 75 e4             	pushl  -0x1c(%ebp)
    fa22:	50                   	push   %eax
    fa23:	51                   	push   %ecx
    fa24:	e8 e1 fa ff ff       	call   f50a <readChunk_iCCP>
    fa29:	83 c4 10             	add    $0x10,%esp
    fa2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
    fa2f:	eb 07                	jmp    fa38 <lodepng_inspect_chunk+0x345>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  } else {
    /* unhandled chunk is ok (is not an error) */
    unhandled = 1;
    fa31:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
  }

  if(!error && !unhandled && !state->decoder.ignore_crc) {
    fa38:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
    fa3c:	75 29                	jne    fa67 <lodepng_inspect_chunk+0x374>
    fa3e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
    fa42:	75 23                	jne    fa67 <lodepng_inspect_chunk+0x374>
    fa44:	8b 45 08             	mov    0x8(%ebp),%eax
    fa47:	8b 40 18             	mov    0x18(%eax),%eax
    fa4a:	85 c0                	test   %eax,%eax
    fa4c:	75 19                	jne    fa67 <lodepng_inspect_chunk+0x374>
    if(lodepng_chunk_check_crc(chunk)) return 57; /*invalid CRC*/
    fa4e:	83 ec 0c             	sub    $0xc,%esp
    fa51:	ff 75 ec             	pushl  -0x14(%ebp)
    fa54:	e8 53 8c ff ff       	call   86ac <lodepng_chunk_check_crc>
    fa59:	83 c4 10             	add    $0x10,%esp
    fa5c:	85 c0                	test   %eax,%eax
    fa5e:	74 07                	je     fa67 <lodepng_inspect_chunk+0x374>
    fa60:	b8 39 00 00 00       	mov    $0x39,%eax
    fa65:	eb 03                	jmp    fa6a <lodepng_inspect_chunk+0x377>
  }

  return error;
    fa67:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
    fa6a:	c9                   	leave  
    fa6b:	c3                   	ret    

0000fa6c <decodeGeneric>:

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize) {
    fa6c:	55                   	push   %ebp
    fa6d:	89 e5                	mov    %esp,%ebp
    fa6f:	56                   	push   %esi
    fa70:	53                   	push   %ebx
    fa71:	83 ec 40             	sub    $0x40,%esp
  unsigned char IEND = 0;
    fa74:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  const unsigned char* chunk;
  unsigned char* idat; /*the data from idat chunks, zlib compressed*/
  size_t idatsize = 0;
    fa78:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  unsigned char* scanlines = 0;
    fa7f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  size_t scanlines_size = 0, expected_size = 0;
    fa86:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
    fa8d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  size_t outsize = 0;
    fa94:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  /*for unknown chunk order*/
  unsigned unknown = 0;
    fa9b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
    faa2:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/


  /* safe output values in case error happens */
  *out = 0;
    faa9:	8b 45 08             	mov    0x8(%ebp),%eax
    faac:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
    fab2:	8b 45 10             	mov    0x10(%ebp),%eax
    fab5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    fabb:	8b 45 10             	mov    0x10(%ebp),%eax
    fabe:	8b 10                	mov    (%eax),%edx
    fac0:	8b 45 0c             	mov    0xc(%ebp),%eax
    fac3:	89 10                	mov    %edx,(%eax)

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
    fac5:	83 ec 0c             	sub    $0xc,%esp
    fac8:	ff 75 1c             	pushl  0x1c(%ebp)
    facb:	ff 75 18             	pushl  0x18(%ebp)
    face:	ff 75 14             	pushl  0x14(%ebp)
    fad1:	ff 75 10             	pushl  0x10(%ebp)
    fad4:	ff 75 0c             	pushl  0xc(%ebp)
    fad7:	e8 d3 da ff ff       	call   d5af <lodepng_inspect>
    fadc:	83 c4 20             	add    $0x20,%esp
    fadf:	89 c2                	mov    %eax,%edx
    fae1:	8b 45 14             	mov    0x14(%ebp),%eax
    fae4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) return;
    faea:	8b 45 14             	mov    0x14(%ebp),%eax
    faed:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    faf3:	85 c0                	test   %eax,%eax
    faf5:	0f 85 24 0a 00 00    	jne    1051f <decodeGeneric+0xab3>

  if(lodepng_pixel_overflow(*w, *h, &state->info_png.color, &state->info_raw)) {
    fafb:	8b 45 14             	mov    0x14(%ebp),%eax
    fafe:	8d 58 78             	lea    0x78(%eax),%ebx
    fb01:	8b 45 14             	mov    0x14(%ebp),%eax
    fb04:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
    fb0a:	8b 45 10             	mov    0x10(%ebp),%eax
    fb0d:	8b 10                	mov    (%eax),%edx
    fb0f:	8b 45 0c             	mov    0xc(%ebp),%eax
    fb12:	8b 00                	mov    (%eax),%eax
    fb14:	53                   	push   %ebx
    fb15:	51                   	push   %ecx
    fb16:	52                   	push   %edx
    fb17:	50                   	push   %eax
    fb18:	e8 76 97 ff ff       	call   9293 <lodepng_pixel_overflow>
    fb1d:	83 c4 10             	add    $0x10,%esp
    fb20:	85 c0                	test   %eax,%eax
    fb22:	74 12                	je     fb36 <decodeGeneric+0xca>
    CERROR_RETURN(state->error, 92); /*overflow possible due to amount of pixels*/
    fb24:	8b 45 14             	mov    0x14(%ebp),%eax
    fb27:	c7 80 7c 01 00 00 5c 	movl   $0x5c,0x17c(%eax)
    fb2e:	00 00 00 
    fb31:	e9 ea 09 00 00       	jmp    10520 <decodeGeneric+0xab4>
  }

  /*the input filesize is a safe upper bound for the sum of idat chunks size*/
  idat = (unsigned char*)lodepng_malloc(insize);
    fb36:	83 ec 0c             	sub    $0xc,%esp
    fb39:	ff 75 1c             	pushl  0x1c(%ebp)
    fb3c:	e8 a6 3a ff ff       	call   35e7 <lodepng_malloc>
    fb41:	83 c4 10             	add    $0x10,%esp
    fb44:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if(!idat) CERROR_RETURN(state->error, 83); /*alloc fail*/
    fb47:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
    fb4b:	75 12                	jne    fb5f <decodeGeneric+0xf3>
    fb4d:	8b 45 14             	mov    0x14(%ebp),%eax
    fb50:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
    fb57:	00 00 00 
    fb5a:	e9 c1 09 00 00       	jmp    10520 <decodeGeneric+0xab4>

  chunk = &in[33]; /*first byte of the first chunk after the header*/
    fb5f:	8b 45 18             	mov    0x18(%ebp),%eax
    fb62:	83 c0 21             	add    $0x21,%eax
    fb65:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
    fb68:	e9 81 06 00 00       	jmp    101ee <decodeGeneric+0x782>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
    fb6d:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fb70:	8b 45 18             	mov    0x18(%ebp),%eax
    fb73:	29 c2                	sub    %eax,%edx
    fb75:	89 d0                	mov    %edx,%eax
    fb77:	83 c0 0c             	add    $0xc,%eax
    fb7a:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fb7d:	7f 08                	jg     fb87 <decodeGeneric+0x11b>
    fb7f:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fb82:	3b 45 18             	cmp    0x18(%ebp),%eax
    fb85:	73 20                	jae    fba7 <decodeGeneric+0x13b>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    fb87:	8b 45 14             	mov    0x14(%ebp),%eax
    fb8a:	8b 40 20             	mov    0x20(%eax),%eax
    fb8d:	85 c0                	test   %eax,%eax
    fb8f:	0f 85 72 06 00 00    	jne    10207 <decodeGeneric+0x79b>
      CERROR_BREAK(state->error, 30);
    fb95:	8b 45 14             	mov    0x14(%ebp),%eax
    fb98:	c7 80 7c 01 00 00 1e 	movl   $0x1e,0x17c(%eax)
    fb9f:	00 00 00 
    fba2:	e9 6a 06 00 00       	jmp    10211 <decodeGeneric+0x7a5>
    }

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    fba7:	83 ec 0c             	sub    $0xc,%esp
    fbaa:	ff 75 f0             	pushl  -0x10(%ebp)
    fbad:	e8 b7 89 ff ff       	call   8569 <lodepng_chunk_length>
    fbb2:	83 c4 10             	add    $0x10,%esp
    fbb5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
    fbb8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fbbb:	85 c0                	test   %eax,%eax
    fbbd:	79 20                	jns    fbdf <decodeGeneric+0x173>
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
    fbbf:	8b 45 14             	mov    0x14(%ebp),%eax
    fbc2:	8b 40 20             	mov    0x20(%eax),%eax
    fbc5:	85 c0                	test   %eax,%eax
    fbc7:	0f 85 3d 06 00 00    	jne    1020a <decodeGeneric+0x79e>
      CERROR_BREAK(state->error, 63);
    fbcd:	8b 45 14             	mov    0x14(%ebp),%eax
    fbd0:	c7 80 7c 01 00 00 3f 	movl   $0x3f,0x17c(%eax)
    fbd7:	00 00 00 
    fbda:	e9 32 06 00 00       	jmp    10211 <decodeGeneric+0x7a5>
    }

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in) {
    fbdf:	8b 55 f0             	mov    -0x10(%ebp),%edx
    fbe2:	8b 45 18             	mov    0x18(%ebp),%eax
    fbe5:	29 c2                	sub    %eax,%edx
    fbe7:	89 d0                	mov    %edx,%eax
    fbe9:	89 c2                	mov    %eax,%edx
    fbeb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fbee:	01 d0                	add    %edx,%eax
    fbf0:	83 c0 0c             	add    $0xc,%eax
    fbf3:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fbf6:	7f 10                	jg     fc08 <decodeGeneric+0x19c>
    fbf8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fbfb:	8d 50 0c             	lea    0xc(%eax),%edx
    fbfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
    fc01:	01 d0                	add    %edx,%eax
    fc03:	3b 45 18             	cmp    0x18(%ebp),%eax
    fc06:	73 12                	jae    fc1a <decodeGeneric+0x1ae>
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    fc08:	8b 45 14             	mov    0x14(%ebp),%eax
    fc0b:	c7 80 7c 01 00 00 40 	movl   $0x40,0x17c(%eax)
    fc12:	00 00 00 
    fc15:	e9 f7 05 00 00       	jmp    10211 <decodeGeneric+0x7a5>
    }

    data = lodepng_chunk_data_const(chunk);
    fc1a:	83 ec 0c             	sub    $0xc,%esp
    fc1d:	ff 75 f0             	pushl  -0x10(%ebp)
    fc20:	e8 7c 8a ff ff       	call   86a1 <lodepng_chunk_data_const>
    fc25:	83 c4 10             	add    $0x10,%esp
    fc28:	89 45 d0             	mov    %eax,-0x30(%ebp)

    unknown = 0;
    fc2b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT")) {
    fc32:	83 ec 08             	sub    $0x8,%esp
    fc35:	68 64 a3 01 00       	push   $0x1a364
    fc3a:	ff 75 f0             	pushl  -0x10(%ebp)
    fc3d:	e8 74 89 ff ff       	call   85b6 <lodepng_chunk_type_equals>
    fc42:	83 c4 10             	add    $0x10,%esp
    fc45:	84 c0                	test   %al,%al
    fc47:	74 79                	je     fcc2 <decodeGeneric+0x256>
      size_t newsize;
      if(lodepng_addofl(idatsize, chunkLength, &newsize)) CERROR_BREAK(state->error, 95);
    fc49:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fc4c:	83 ec 04             	sub    $0x4,%esp
    fc4f:	8d 55 bc             	lea    -0x44(%ebp),%edx
    fc52:	52                   	push   %edx
    fc53:	50                   	push   %eax
    fc54:	ff 75 ec             	pushl  -0x14(%ebp)
    fc57:	e8 4f 3a ff ff       	call   36ab <lodepng_addofl>
    fc5c:	83 c4 10             	add    $0x10,%esp
    fc5f:	85 c0                	test   %eax,%eax
    fc61:	74 12                	je     fc75 <decodeGeneric+0x209>
    fc63:	8b 45 14             	mov    0x14(%ebp),%eax
    fc66:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    fc6d:	00 00 00 
    fc70:	e9 9c 05 00 00       	jmp    10211 <decodeGeneric+0x7a5>
      if(newsize > insize) CERROR_BREAK(state->error, 95);
    fc75:	8b 45 bc             	mov    -0x44(%ebp),%eax
    fc78:	3b 45 1c             	cmp    0x1c(%ebp),%eax
    fc7b:	7e 13                	jle    fc90 <decodeGeneric+0x224>
    fc7d:	8b 45 14             	mov    0x14(%ebp),%eax
    fc80:	c7 80 7c 01 00 00 5f 	movl   $0x5f,0x17c(%eax)
    fc87:	00 00 00 
    fc8a:	90                   	nop
    fc8b:	e9 81 05 00 00       	jmp    10211 <decodeGeneric+0x7a5>
      lodepng_memcpy(idat + idatsize, data, chunkLength);
    fc90:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fc93:	8b 4d ec             	mov    -0x14(%ebp),%ecx
    fc96:	8b 55 d8             	mov    -0x28(%ebp),%edx
    fc99:	01 ca                	add    %ecx,%edx
    fc9b:	83 ec 04             	sub    $0x4,%esp
    fc9e:	50                   	push   %eax
    fc9f:	ff 75 d0             	pushl  -0x30(%ebp)
    fca2:	52                   	push   %edx
    fca3:	e8 7d 39 ff ff       	call   3625 <lodepng_memcpy>
    fca8:	83 c4 10             	add    $0x10,%esp
      idatsize += chunkLength;
    fcab:	8b 55 ec             	mov    -0x14(%ebp),%edx
    fcae:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fcb1:	01 d0                	add    %edx,%eax
    fcb3:	89 45 ec             	mov    %eax,-0x14(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
    fcb6:	c7 45 dc 03 00 00 00 	movl   $0x3,-0x24(%ebp)
    fcbd:	e9 db 04 00 00       	jmp    1019d <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "IEND")) {
    fcc2:	83 ec 08             	sub    $0x8,%esp
    fcc5:	68 69 a3 01 00       	push   $0x1a369
    fcca:	ff 75 f0             	pushl  -0x10(%ebp)
    fccd:	e8 e4 88 ff ff       	call   85b6 <lodepng_chunk_type_equals>
    fcd2:	83 c4 10             	add    $0x10,%esp
    fcd5:	84 c0                	test   %al,%al
    fcd7:	74 09                	je     fce2 <decodeGeneric+0x276>
      /*IEND chunk*/
      IEND = 1;
    fcd9:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
    fcdd:	e9 bb 04 00 00       	jmp    1019d <decodeGeneric+0x731>
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
    fce2:	83 ec 08             	sub    $0x8,%esp
    fce5:	68 28 a3 01 00       	push   $0x1a328
    fcea:	ff 75 f0             	pushl  -0x10(%ebp)
    fced:	e8 c4 88 ff ff       	call   85b6 <lodepng_chunk_type_equals>
    fcf2:	83 c4 10             	add    $0x10,%esp
    fcf5:	84 c0                	test   %al,%al
    fcf7:	74 44                	je     fd3d <decodeGeneric+0x2d1>
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
    fcf9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fcfc:	8b 55 14             	mov    0x14(%ebp),%edx
    fcff:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fd05:	83 ec 04             	sub    $0x4,%esp
    fd08:	50                   	push   %eax
    fd09:	ff 75 d0             	pushl  -0x30(%ebp)
    fd0c:	52                   	push   %edx
    fd0d:	e8 ec e8 ff ff       	call   e5fe <readChunk_PLTE>
    fd12:	83 c4 10             	add    $0x10,%esp
    fd15:	89 c2                	mov    %eax,%edx
    fd17:	8b 45 14             	mov    0x14(%ebp),%eax
    fd1a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd20:	8b 45 14             	mov    0x14(%ebp),%eax
    fd23:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd29:	85 c0                	test   %eax,%eax
    fd2b:	0f 85 dc 04 00 00    	jne    1020d <decodeGeneric+0x7a1>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
    fd31:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
    fd38:	e9 60 04 00 00       	jmp    1019d <decodeGeneric+0x731>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else if(lodepng_chunk_type_equals(chunk, "tRNS")) {
    fd3d:	83 ec 08             	sub    $0x8,%esp
    fd40:	68 2d a3 01 00       	push   $0x1a32d
    fd45:	ff 75 f0             	pushl  -0x10(%ebp)
    fd48:	e8 69 88 ff ff       	call   85b6 <lodepng_chunk_type_equals>
    fd4d:	83 c4 10             	add    $0x10,%esp
    fd50:	84 c0                	test   %al,%al
    fd52:	74 3d                	je     fd91 <decodeGeneric+0x325>
      /*palette transparency chunk (tRNS). Even though this one is an ancillary chunk , it is still compiled
      in without 'LODEPNG_COMPILE_ANCILLARY_CHUNKS' because it contains essential color information that
      affects the alpha channel of pixels. */
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
    fd54:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fd57:	8b 55 14             	mov    0x14(%ebp),%edx
    fd5a:	81 c2 a4 00 00 00    	add    $0xa4,%edx
    fd60:	83 ec 04             	sub    $0x4,%esp
    fd63:	50                   	push   %eax
    fd64:	ff 75 d0             	pushl  -0x30(%ebp)
    fd67:	52                   	push   %edx
    fd68:	e8 b1 e9 ff ff       	call   e71e <readChunk_tRNS>
    fd6d:	83 c4 10             	add    $0x10,%esp
    fd70:	89 c2                	mov    %eax,%edx
    fd72:	8b 45 14             	mov    0x14(%ebp),%eax
    fd75:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fd7b:	8b 45 14             	mov    0x14(%ebp),%eax
    fd7e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fd84:	85 c0                	test   %eax,%eax
    fd86:	0f 84 11 04 00 00    	je     1019d <decodeGeneric+0x731>
    fd8c:	e9 80 04 00 00       	jmp    10211 <decodeGeneric+0x7a5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      /*background color chunk (bKGD)*/
    } else if(lodepng_chunk_type_equals(chunk, "bKGD")) {
    fd91:	83 ec 08             	sub    $0x8,%esp
    fd94:	68 32 a3 01 00       	push   $0x1a332
    fd99:	ff 75 f0             	pushl  -0x10(%ebp)
    fd9c:	e8 15 88 ff ff       	call   85b6 <lodepng_chunk_type_equals>
    fda1:	83 c4 10             	add    $0x10,%esp
    fda4:	84 c0                	test   %al,%al
    fda6:	74 3d                	je     fde5 <decodeGeneric+0x379>
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
    fda8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fdab:	8b 55 14             	mov    0x14(%ebp),%edx
    fdae:	81 c2 98 00 00 00    	add    $0x98,%edx
    fdb4:	83 ec 04             	sub    $0x4,%esp
    fdb7:	50                   	push   %eax
    fdb8:	ff 75 d0             	pushl  -0x30(%ebp)
    fdbb:	52                   	push   %edx
    fdbc:	e8 c0 ea ff ff       	call   e881 <readChunk_bKGD>
    fdc1:	83 c4 10             	add    $0x10,%esp
    fdc4:	89 c2                	mov    %eax,%edx
    fdc6:	8b 45 14             	mov    0x14(%ebp),%eax
    fdc9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fdcf:	8b 45 14             	mov    0x14(%ebp),%eax
    fdd2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fdd8:	85 c0                	test   %eax,%eax
    fdda:	0f 84 bd 03 00 00    	je     1019d <decodeGeneric+0x731>
    fde0:	e9 2c 04 00 00       	jmp    10211 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "tEXt")) {
    fde5:	83 ec 08             	sub    $0x8,%esp
    fde8:	68 37 a3 01 00       	push   $0x1a337
    fded:	ff 75 f0             	pushl  -0x10(%ebp)
    fdf0:	e8 c1 87 ff ff       	call   85b6 <lodepng_chunk_type_equals>
    fdf5:	83 c4 10             	add    $0x10,%esp
    fdf8:	84 c0                	test   %al,%al
    fdfa:	74 4b                	je     fe47 <decodeGeneric+0x3db>
      /*text chunk (tEXt)*/
      if(state->decoder.read_text_chunks) {
    fdfc:	8b 45 14             	mov    0x14(%ebp),%eax
    fdff:	8b 40 28             	mov    0x28(%eax),%eax
    fe02:	85 c0                	test   %eax,%eax
    fe04:	0f 84 93 03 00 00    	je     1019d <decodeGeneric+0x731>
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
    fe0a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    fe0d:	8b 55 14             	mov    0x14(%ebp),%edx
    fe10:	81 c2 98 00 00 00    	add    $0x98,%edx
    fe16:	83 ec 04             	sub    $0x4,%esp
    fe19:	50                   	push   %eax
    fe1a:	ff 75 d0             	pushl  -0x30(%ebp)
    fe1d:	52                   	push   %edx
    fe1e:	e8 e1 eb ff ff       	call   ea04 <readChunk_tEXt>
    fe23:	83 c4 10             	add    $0x10,%esp
    fe26:	89 c2                	mov    %eax,%edx
    fe28:	8b 45 14             	mov    0x14(%ebp),%eax
    fe2b:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fe31:	8b 45 14             	mov    0x14(%ebp),%eax
    fe34:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe3a:	85 c0                	test   %eax,%eax
    fe3c:	0f 84 5b 03 00 00    	je     1019d <decodeGeneric+0x731>
    fe42:	e9 ca 03 00 00       	jmp    10211 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "zTXt")) {
    fe47:	83 ec 08             	sub    $0x8,%esp
    fe4a:	68 3c a3 01 00       	push   $0x1a33c
    fe4f:	ff 75 f0             	pushl  -0x10(%ebp)
    fe52:	e8 5f 87 ff ff       	call   85b6 <lodepng_chunk_type_equals>
    fe57:	83 c4 10             	add    $0x10,%esp
    fe5a:	84 c0                	test   %al,%al
    fe5c:	74 4c                	je     feaa <decodeGeneric+0x43e>
      /*compressed text chunk (zTXt)*/
      if(state->decoder.read_text_chunks) {
    fe5e:	8b 45 14             	mov    0x14(%ebp),%eax
    fe61:	8b 40 28             	mov    0x28(%eax),%eax
    fe64:	85 c0                	test   %eax,%eax
    fe66:	0f 84 31 03 00 00    	je     1019d <decodeGeneric+0x731>
        state->error = readChunk_zTXt(&state->info_png, &state->decoder, data, chunkLength);
    fe6c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fe6f:	8b 45 14             	mov    0x14(%ebp),%eax
    fe72:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fe75:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fe7b:	52                   	push   %edx
    fe7c:	ff 75 d0             	pushl  -0x30(%ebp)
    fe7f:	50                   	push   %eax
    fe80:	51                   	push   %ecx
    fe81:	e8 ca ec ff ff       	call   eb50 <readChunk_zTXt>
    fe86:	83 c4 10             	add    $0x10,%esp
    fe89:	89 c2                	mov    %eax,%edx
    fe8b:	8b 45 14             	mov    0x14(%ebp),%eax
    fe8e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fe94:	8b 45 14             	mov    0x14(%ebp),%eax
    fe97:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fe9d:	85 c0                	test   %eax,%eax
    fe9f:	0f 84 f8 02 00 00    	je     1019d <decodeGeneric+0x731>
    fea5:	e9 67 03 00 00       	jmp    10211 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "iTXt")) {
    feaa:	83 ec 08             	sub    $0x8,%esp
    fead:	68 41 a3 01 00       	push   $0x1a341
    feb2:	ff 75 f0             	pushl  -0x10(%ebp)
    feb5:	e8 fc 86 ff ff       	call   85b6 <lodepng_chunk_type_equals>
    feba:	83 c4 10             	add    $0x10,%esp
    febd:	84 c0                	test   %al,%al
    febf:	74 4c                	je     ff0d <decodeGeneric+0x4a1>
      /*international text chunk (iTXt)*/
      if(state->decoder.read_text_chunks) {
    fec1:	8b 45 14             	mov    0x14(%ebp),%eax
    fec4:	8b 40 28             	mov    0x28(%eax),%eax
    fec7:	85 c0                	test   %eax,%eax
    fec9:	0f 84 ce 02 00 00    	je     1019d <decodeGeneric+0x731>
        state->error = readChunk_iTXt(&state->info_png, &state->decoder, data, chunkLength);
    fecf:	8b 55 d4             	mov    -0x2c(%ebp),%edx
    fed2:	8b 45 14             	mov    0x14(%ebp),%eax
    fed5:	8b 4d 14             	mov    0x14(%ebp),%ecx
    fed8:	81 c1 98 00 00 00    	add    $0x98,%ecx
    fede:	52                   	push   %edx
    fedf:	ff 75 d0             	pushl  -0x30(%ebp)
    fee2:	50                   	push   %eax
    fee3:	51                   	push   %ecx
    fee4:	e8 23 ee ff ff       	call   ed0c <readChunk_iTXt>
    fee9:	83 c4 10             	add    $0x10,%esp
    feec:	89 c2                	mov    %eax,%edx
    feee:	8b 45 14             	mov    0x14(%ebp),%eax
    fef1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) break;
    fef7:	8b 45 14             	mov    0x14(%ebp),%eax
    fefa:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff00:	85 c0                	test   %eax,%eax
    ff02:	0f 84 95 02 00 00    	je     1019d <decodeGeneric+0x731>
    ff08:	e9 04 03 00 00       	jmp    10211 <decodeGeneric+0x7a5>
      }
    } else if(lodepng_chunk_type_equals(chunk, "tIME")) {
    ff0d:	83 ec 08             	sub    $0x8,%esp
    ff10:	68 46 a3 01 00       	push   $0x1a346
    ff15:	ff 75 f0             	pushl  -0x10(%ebp)
    ff18:	e8 99 86 ff ff       	call   85b6 <lodepng_chunk_type_equals>
    ff1d:	83 c4 10             	add    $0x10,%esp
    ff20:	84 c0                	test   %al,%al
    ff22:	74 3d                	je     ff61 <decodeGeneric+0x4f5>
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
    ff24:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ff27:	8b 55 14             	mov    0x14(%ebp),%edx
    ff2a:	81 c2 98 00 00 00    	add    $0x98,%edx
    ff30:	83 ec 04             	sub    $0x4,%esp
    ff33:	50                   	push   %eax
    ff34:	ff 75 d0             	pushl  -0x30(%ebp)
    ff37:	52                   	push   %edx
    ff38:	e8 25 f1 ff ff       	call   f062 <readChunk_tIME>
    ff3d:	83 c4 10             	add    $0x10,%esp
    ff40:	89 c2                	mov    %eax,%edx
    ff42:	8b 45 14             	mov    0x14(%ebp),%eax
    ff45:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    ff4b:	8b 45 14             	mov    0x14(%ebp),%eax
    ff4e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ff54:	85 c0                	test   %eax,%eax
    ff56:	0f 84 41 02 00 00    	je     1019d <decodeGeneric+0x731>
    ff5c:	e9 b0 02 00 00       	jmp    10211 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "pHYs")) {
    ff61:	83 ec 08             	sub    $0x8,%esp
    ff64:	68 4b a3 01 00       	push   $0x1a34b
    ff69:	ff 75 f0             	pushl  -0x10(%ebp)
    ff6c:	e8 45 86 ff ff       	call   85b6 <lodepng_chunk_type_equals>
    ff71:	83 c4 10             	add    $0x10,%esp
    ff74:	84 c0                	test   %al,%al
    ff76:	74 3d                	je     ffb5 <decodeGeneric+0x549>
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
    ff78:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ff7b:	8b 55 14             	mov    0x14(%ebp),%edx
    ff7e:	81 c2 98 00 00 00    	add    $0x98,%edx
    ff84:	83 ec 04             	sub    $0x4,%esp
    ff87:	50                   	push   %eax
    ff88:	ff 75 d0             	pushl  -0x30(%ebp)
    ff8b:	52                   	push   %edx
    ff8c:	e8 71 f1 ff ff       	call   f102 <readChunk_pHYs>
    ff91:	83 c4 10             	add    $0x10,%esp
    ff94:	89 c2                	mov    %eax,%edx
    ff96:	8b 45 14             	mov    0x14(%ebp),%eax
    ff99:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    ff9f:	8b 45 14             	mov    0x14(%ebp),%eax
    ffa2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    ffa8:	85 c0                	test   %eax,%eax
    ffaa:	0f 84 ed 01 00 00    	je     1019d <decodeGeneric+0x731>
    ffb0:	e9 5c 02 00 00       	jmp    10211 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "gAMA")) {
    ffb5:	83 ec 08             	sub    $0x8,%esp
    ffb8:	68 50 a3 01 00       	push   $0x1a350
    ffbd:	ff 75 f0             	pushl  -0x10(%ebp)
    ffc0:	e8 f1 85 ff ff       	call   85b6 <lodepng_chunk_type_equals>
    ffc5:	83 c4 10             	add    $0x10,%esp
    ffc8:	84 c0                	test   %al,%al
    ffca:	74 3d                	je     10009 <decodeGeneric+0x59d>
      state->error = readChunk_gAMA(&state->info_png, data, chunkLength);
    ffcc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    ffcf:	8b 55 14             	mov    0x14(%ebp),%edx
    ffd2:	81 c2 98 00 00 00    	add    $0x98,%edx
    ffd8:	83 ec 04             	sub    $0x4,%esp
    ffdb:	50                   	push   %eax
    ffdc:	ff 75 d0             	pushl  -0x30(%ebp)
    ffdf:	52                   	push   %edx
    ffe0:	e8 ec f1 ff ff       	call   f1d1 <readChunk_gAMA>
    ffe5:	83 c4 10             	add    $0x10,%esp
    ffe8:	89 c2                	mov    %eax,%edx
    ffea:	8b 45 14             	mov    0x14(%ebp),%eax
    ffed:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
    fff3:	8b 45 14             	mov    0x14(%ebp),%eax
    fff6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
    fffc:	85 c0                	test   %eax,%eax
    fffe:	0f 84 99 01 00 00    	je     1019d <decodeGeneric+0x731>
   10004:	e9 08 02 00 00       	jmp    10211 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "cHRM")) {
   10009:	83 ec 08             	sub    $0x8,%esp
   1000c:	68 55 a3 01 00       	push   $0x1a355
   10011:	ff 75 f0             	pushl  -0x10(%ebp)
   10014:	e8 9d 85 ff ff       	call   85b6 <lodepng_chunk_type_equals>
   10019:	83 c4 10             	add    $0x10,%esp
   1001c:	84 c0                	test   %al,%al
   1001e:	74 3d                	je     1005d <decodeGeneric+0x5f1>
      state->error = readChunk_cHRM(&state->info_png, data, chunkLength);
   10020:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10023:	8b 55 14             	mov    0x14(%ebp),%edx
   10026:	81 c2 98 00 00 00    	add    $0x98,%edx
   1002c:	83 ec 04             	sub    $0x4,%esp
   1002f:	50                   	push   %eax
   10030:	ff 75 d0             	pushl  -0x30(%ebp)
   10033:	52                   	push   %edx
   10034:	e8 07 f2 ff ff       	call   f240 <readChunk_cHRM>
   10039:	83 c4 10             	add    $0x10,%esp
   1003c:	89 c2                	mov    %eax,%edx
   1003e:	8b 45 14             	mov    0x14(%ebp),%eax
   10041:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   10047:	8b 45 14             	mov    0x14(%ebp),%eax
   1004a:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10050:	85 c0                	test   %eax,%eax
   10052:	0f 84 45 01 00 00    	je     1019d <decodeGeneric+0x731>
   10058:	e9 b4 01 00 00       	jmp    10211 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "sRGB")) {
   1005d:	83 ec 08             	sub    $0x8,%esp
   10060:	68 5a a3 01 00       	push   $0x1a35a
   10065:	ff 75 f0             	pushl  -0x10(%ebp)
   10068:	e8 49 85 ff ff       	call   85b6 <lodepng_chunk_type_equals>
   1006d:	83 c4 10             	add    $0x10,%esp
   10070:	84 c0                	test   %al,%al
   10072:	74 3d                	je     100b1 <decodeGeneric+0x645>
      state->error = readChunk_sRGB(&state->info_png, data, chunkLength);
   10074:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   10077:	8b 55 14             	mov    0x14(%ebp),%edx
   1007a:	81 c2 98 00 00 00    	add    $0x98,%edx
   10080:	83 ec 04             	sub    $0x4,%esp
   10083:	50                   	push   %eax
   10084:	ff 75 d0             	pushl  -0x30(%ebp)
   10087:	52                   	push   %edx
   10088:	e8 47 f4 ff ff       	call   f4d4 <readChunk_sRGB>
   1008d:	83 c4 10             	add    $0x10,%esp
   10090:	89 c2                	mov    %eax,%edx
   10092:	8b 45 14             	mov    0x14(%ebp),%eax
   10095:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   1009b:	8b 45 14             	mov    0x14(%ebp),%eax
   1009e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   100a4:	85 c0                	test   %eax,%eax
   100a6:	0f 84 f1 00 00 00    	je     1019d <decodeGeneric+0x731>
   100ac:	e9 60 01 00 00       	jmp    10211 <decodeGeneric+0x7a5>
    } else if(lodepng_chunk_type_equals(chunk, "iCCP")) {
   100b1:	83 ec 08             	sub    $0x8,%esp
   100b4:	68 5f a3 01 00       	push   $0x1a35f
   100b9:	ff 75 f0             	pushl  -0x10(%ebp)
   100bc:	e8 f5 84 ff ff       	call   85b6 <lodepng_chunk_type_equals>
   100c1:	83 c4 10             	add    $0x10,%esp
   100c4:	84 c0                	test   %al,%al
   100c6:	74 3e                	je     10106 <decodeGeneric+0x69a>
      state->error = readChunk_iCCP(&state->info_png, &state->decoder, data, chunkLength);
   100c8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   100cb:	8b 45 14             	mov    0x14(%ebp),%eax
   100ce:	8b 4d 14             	mov    0x14(%ebp),%ecx
   100d1:	81 c1 98 00 00 00    	add    $0x98,%ecx
   100d7:	52                   	push   %edx
   100d8:	ff 75 d0             	pushl  -0x30(%ebp)
   100db:	50                   	push   %eax
   100dc:	51                   	push   %ecx
   100dd:	e8 28 f4 ff ff       	call   f50a <readChunk_iCCP>
   100e2:	83 c4 10             	add    $0x10,%esp
   100e5:	89 c2                	mov    %eax,%edx
   100e7:	8b 45 14             	mov    0x14(%ebp),%eax
   100ea:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) break;
   100f0:	8b 45 14             	mov    0x14(%ebp),%eax
   100f3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   100f9:	85 c0                	test   %eax,%eax
   100fb:	0f 84 9c 00 00 00    	je     1019d <decodeGeneric+0x731>
   10101:	e9 0b 01 00 00       	jmp    10211 <decodeGeneric+0x7a5>
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    } else /*it's not an implemented chunk type, so ignore it: skip over the data*/ {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!state->decoder.ignore_critical && !lodepng_chunk_ancillary(chunk)) {
   10106:	8b 45 14             	mov    0x14(%ebp),%eax
   10109:	8b 40 1c             	mov    0x1c(%eax),%eax
   1010c:	85 c0                	test   %eax,%eax
   1010e:	75 24                	jne    10134 <decodeGeneric+0x6c8>
   10110:	83 ec 0c             	sub    $0xc,%esp
   10113:	ff 75 f0             	pushl  -0x10(%ebp)
   10116:	e8 30 85 ff ff       	call   864b <lodepng_chunk_ancillary>
   1011b:	83 c4 10             	add    $0x10,%esp
   1011e:	84 c0                	test   %al,%al
   10120:	75 12                	jne    10134 <decodeGeneric+0x6c8>
        CERROR_BREAK(state->error, 69);
   10122:	8b 45 14             	mov    0x14(%ebp),%eax
   10125:	c7 80 7c 01 00 00 45 	movl   $0x45,0x17c(%eax)
   1012c:	00 00 00 
   1012f:	e9 dd 00 00 00       	jmp    10211 <decodeGeneric+0x7a5>
      }

      unknown = 1;
   10134:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
   1013b:	8b 45 14             	mov    0x14(%ebp),%eax
   1013e:	8b 40 2c             	mov    0x2c(%eax),%eax
   10141:	85 c0                	test   %eax,%eax
   10143:	74 58                	je     1019d <decodeGeneric+0x731>
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
   10145:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10148:	83 e8 01             	sub    $0x1,%eax
      }

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
   1014b:	83 c0 58             	add    $0x58,%eax
   1014e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   10155:	8b 45 14             	mov    0x14(%ebp),%eax
   10158:	01 d0                	add    %edx,%eax
   1015a:	8d 50 10             	lea    0x10(%eax),%edx
   1015d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10160:	83 e8 01             	sub    $0x1,%eax
   10163:	83 c0 54             	add    $0x54,%eax
   10166:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
   1016d:	8b 45 14             	mov    0x14(%ebp),%eax
   10170:	01 c8                	add    %ecx,%eax
   10172:	83 c0 14             	add    $0x14,%eax
   10175:	83 ec 04             	sub    $0x4,%esp
   10178:	ff 75 f0             	pushl  -0x10(%ebp)
   1017b:	52                   	push   %edx
   1017c:	50                   	push   %eax
   1017d:	e8 15 88 ff ff       	call   8997 <lodepng_chunk_append>
   10182:	83 c4 10             	add    $0x10,%esp
   10185:	89 c2                	mov    %eax,%edx
   10187:	8b 45 14             	mov    0x14(%ebp),%eax
   1018a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   10190:	8b 45 14             	mov    0x14(%ebp),%eax
   10193:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10199:	85 c0                	test   %eax,%eax
   1019b:	75 73                	jne    10210 <decodeGeneric+0x7a4>
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/ {
   1019d:	8b 45 14             	mov    0x14(%ebp),%eax
   101a0:	8b 40 18             	mov    0x18(%eax),%eax
   101a3:	85 c0                	test   %eax,%eax
   101a5:	75 27                	jne    101ce <decodeGeneric+0x762>
   101a7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   101ab:	75 21                	jne    101ce <decodeGeneric+0x762>
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
   101ad:	83 ec 0c             	sub    $0xc,%esp
   101b0:	ff 75 f0             	pushl  -0x10(%ebp)
   101b3:	e8 f4 84 ff ff       	call   86ac <lodepng_chunk_check_crc>
   101b8:	83 c4 10             	add    $0x10,%esp
   101bb:	85 c0                	test   %eax,%eax
   101bd:	74 0f                	je     101ce <decodeGeneric+0x762>
   101bf:	8b 45 14             	mov    0x14(%ebp),%eax
   101c2:	c7 80 7c 01 00 00 39 	movl   $0x39,0x17c(%eax)
   101c9:	00 00 00 
   101cc:	eb 43                	jmp    10211 <decodeGeneric+0x7a5>
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
   101ce:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   101d2:	75 1a                	jne    101ee <decodeGeneric+0x782>
   101d4:	8b 55 1c             	mov    0x1c(%ebp),%edx
   101d7:	8b 45 18             	mov    0x18(%ebp),%eax
   101da:	01 d0                	add    %edx,%eax
   101dc:	83 ec 08             	sub    $0x8,%esp
   101df:	50                   	push   %eax
   101e0:	ff 75 f0             	pushl  -0x10(%ebp)
   101e3:	e8 3f 86 ff ff       	call   8827 <lodepng_chunk_next_const>
   101e8:	83 c4 10             	add    $0x10,%esp
   101eb:	89 45 f0             	mov    %eax,-0x10(%ebp)

  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error) {
   101ee:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
   101f2:	75 1d                	jne    10211 <decodeGeneric+0x7a5>
   101f4:	8b 45 14             	mov    0x14(%ebp),%eax
   101f7:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   101fd:	85 c0                	test   %eax,%eax
   101ff:	0f 84 68 f9 ff ff    	je     fb6d <decodeGeneric+0x101>
   10205:	eb 0a                	jmp    10211 <decodeGeneric+0x7a5>
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   10207:	90                   	nop
   10208:	eb 07                	jmp    10211 <decodeGeneric+0x7a5>

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) {
      if(state->decoder.ignore_end) break; /*other errors may still happen though*/
   1020a:	90                   	nop
   1020b:	eb 04                	jmp    10211 <decodeGeneric+0x7a5>
      /*IEND chunk*/
      IEND = 1;
    } else if(lodepng_chunk_type_equals(chunk, "PLTE")) {
      /*palette chunk (PLTE)*/
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
   1020d:	90                   	nop
   1020e:	eb 01                	jmp    10211 <decodeGeneric+0x7a5>
      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks) {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
   10210:	90                   	nop
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk, in + insize);
  }

  if(!state->error && state->info_png.color.colortype == LCT_PALETTE && !state->info_png.color.palette) {
   10211:	8b 45 14             	mov    0x14(%ebp),%eax
   10214:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1021a:	85 c0                	test   %eax,%eax
   1021c:	75 28                	jne    10246 <decodeGeneric+0x7da>
   1021e:	8b 45 14             	mov    0x14(%ebp),%eax
   10221:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   10227:	83 f8 03             	cmp    $0x3,%eax
   1022a:	75 1a                	jne    10246 <decodeGeneric+0x7da>
   1022c:	8b 45 14             	mov    0x14(%ebp),%eax
   1022f:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   10235:	85 c0                	test   %eax,%eax
   10237:	75 0d                	jne    10246 <decodeGeneric+0x7da>
    state->error = 106; /* error: PNG file must have PLTE chunk if color type is palette */
   10239:	8b 45 14             	mov    0x14(%ebp),%eax
   1023c:	c7 80 7c 01 00 00 6a 	movl   $0x6a,0x17c(%eax)
   10243:	00 00 00 
  }

  if(!state->error) {
   10246:	8b 45 14             	mov    0x14(%ebp),%eax
   10249:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1024f:	85 c0                	test   %eax,%eax
   10251:	0f 85 d2 01 00 00    	jne    10429 <decodeGeneric+0x9bd>
    /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
    If the decompressed size does not match the prediction, the image must be corrupt.*/
    if(state->info_png.interlace_method == 0) {
   10257:	8b 45 14             	mov    0x14(%ebp),%eax
   1025a:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   10260:	85 c0                	test   %eax,%eax
   10262:	75 3a                	jne    1029e <decodeGeneric+0x832>
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   10264:	8b 45 14             	mov    0x14(%ebp),%eax
   10267:	05 a4 00 00 00       	add    $0xa4,%eax
   1026c:	83 ec 0c             	sub    $0xc,%esp
   1026f:	50                   	push   %eax
   10270:	e8 8e 8e ff ff       	call   9103 <lodepng_get_bpp>
   10275:	83 c4 10             	add    $0x10,%esp
   10278:	89 45 cc             	mov    %eax,-0x34(%ebp)
      expected_size = lodepng_get_raw_size_idat(*w, *h, bpp);
   1027b:	8b 4d cc             	mov    -0x34(%ebp),%ecx
   1027e:	8b 45 10             	mov    0x10(%ebp),%eax
   10281:	8b 10                	mov    (%eax),%edx
   10283:	8b 45 0c             	mov    0xc(%ebp),%eax
   10286:	8b 00                	mov    (%eax),%eax
   10288:	83 ec 04             	sub    $0x4,%esp
   1028b:	51                   	push   %ecx
   1028c:	52                   	push   %edx
   1028d:	50                   	push   %eax
   1028e:	e8 cf 8f ff ff       	call   9262 <lodepng_get_raw_size_idat>
   10293:	83 c4 10             	add    $0x10,%esp
   10296:	89 45 e8             	mov    %eax,-0x18(%ebp)
   10299:	e9 60 01 00 00       	jmp    103fe <decodeGeneric+0x992>
    } else {
      size_t bpp = lodepng_get_bpp(&state->info_png.color);
   1029e:	8b 45 14             	mov    0x14(%ebp),%eax
   102a1:	05 a4 00 00 00       	add    $0xa4,%eax
   102a6:	83 ec 0c             	sub    $0xc,%esp
   102a9:	50                   	push   %eax
   102aa:	e8 54 8e ff ff       	call   9103 <lodepng_get_bpp>
   102af:	83 c4 10             	add    $0x10,%esp
   102b2:	89 45 c8             	mov    %eax,-0x38(%ebp)
      /*Adam-7 interlaced: expected size is the sum of the 7 sub-images sizes*/
      expected_size = 0;
   102b5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 7) >> 3, (*h + 7) >> 3, bpp);
   102bc:	8b 45 c8             	mov    -0x38(%ebp),%eax
   102bf:	8b 55 10             	mov    0x10(%ebp),%edx
   102c2:	8b 12                	mov    (%edx),%edx
   102c4:	83 c2 07             	add    $0x7,%edx
   102c7:	89 d1                	mov    %edx,%ecx
   102c9:	c1 e9 03             	shr    $0x3,%ecx
   102cc:	8b 55 0c             	mov    0xc(%ebp),%edx
   102cf:	8b 12                	mov    (%edx),%edx
   102d1:	83 c2 07             	add    $0x7,%edx
   102d4:	c1 ea 03             	shr    $0x3,%edx
   102d7:	83 ec 04             	sub    $0x4,%esp
   102da:	50                   	push   %eax
   102db:	51                   	push   %ecx
   102dc:	52                   	push   %edx
   102dd:	e8 80 8f ff ff       	call   9262 <lodepng_get_raw_size_idat>
   102e2:	83 c4 10             	add    $0x10,%esp
   102e5:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 4) expected_size += lodepng_get_raw_size_idat((*w + 3) >> 3, (*h + 7) >> 3, bpp);
   102e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   102eb:	8b 00                	mov    (%eax),%eax
   102ed:	83 f8 04             	cmp    $0x4,%eax
   102f0:	76 2c                	jbe    1031e <decodeGeneric+0x8b2>
   102f2:	8b 45 c8             	mov    -0x38(%ebp),%eax
   102f5:	8b 55 10             	mov    0x10(%ebp),%edx
   102f8:	8b 12                	mov    (%edx),%edx
   102fa:	83 c2 07             	add    $0x7,%edx
   102fd:	89 d1                	mov    %edx,%ecx
   102ff:	c1 e9 03             	shr    $0x3,%ecx
   10302:	8b 55 0c             	mov    0xc(%ebp),%edx
   10305:	8b 12                	mov    (%edx),%edx
   10307:	83 c2 03             	add    $0x3,%edx
   1030a:	c1 ea 03             	shr    $0x3,%edx
   1030d:	83 ec 04             	sub    $0x4,%esp
   10310:	50                   	push   %eax
   10311:	51                   	push   %ecx
   10312:	52                   	push   %edx
   10313:	e8 4a 8f ff ff       	call   9262 <lodepng_get_raw_size_idat>
   10318:	83 c4 10             	add    $0x10,%esp
   1031b:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 3) >> 2, (*h + 3) >> 3, bpp);
   1031e:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10321:	8b 55 10             	mov    0x10(%ebp),%edx
   10324:	8b 12                	mov    (%edx),%edx
   10326:	83 c2 03             	add    $0x3,%edx
   10329:	89 d1                	mov    %edx,%ecx
   1032b:	c1 e9 03             	shr    $0x3,%ecx
   1032e:	8b 55 0c             	mov    0xc(%ebp),%edx
   10331:	8b 12                	mov    (%edx),%edx
   10333:	83 c2 03             	add    $0x3,%edx
   10336:	c1 ea 02             	shr    $0x2,%edx
   10339:	83 ec 04             	sub    $0x4,%esp
   1033c:	50                   	push   %eax
   1033d:	51                   	push   %ecx
   1033e:	52                   	push   %edx
   1033f:	e8 1e 8f ff ff       	call   9262 <lodepng_get_raw_size_idat>
   10344:	83 c4 10             	add    $0x10,%esp
   10347:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 2) expected_size += lodepng_get_raw_size_idat((*w + 1) >> 2, (*h + 3) >> 2, bpp);
   1034a:	8b 45 0c             	mov    0xc(%ebp),%eax
   1034d:	8b 00                	mov    (%eax),%eax
   1034f:	83 f8 02             	cmp    $0x2,%eax
   10352:	76 2c                	jbe    10380 <decodeGeneric+0x914>
   10354:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10357:	8b 55 10             	mov    0x10(%ebp),%edx
   1035a:	8b 12                	mov    (%edx),%edx
   1035c:	83 c2 03             	add    $0x3,%edx
   1035f:	89 d1                	mov    %edx,%ecx
   10361:	c1 e9 02             	shr    $0x2,%ecx
   10364:	8b 55 0c             	mov    0xc(%ebp),%edx
   10367:	8b 12                	mov    (%edx),%edx
   10369:	83 c2 01             	add    $0x1,%edx
   1036c:	c1 ea 02             	shr    $0x2,%edx
   1036f:	83 ec 04             	sub    $0x4,%esp
   10372:	50                   	push   %eax
   10373:	51                   	push   %ecx
   10374:	52                   	push   %edx
   10375:	e8 e8 8e ff ff       	call   9262 <lodepng_get_raw_size_idat>
   1037a:	83 c4 10             	add    $0x10,%esp
   1037d:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 1) >> 1, (*h + 1) >> 2, bpp);
   10380:	8b 45 c8             	mov    -0x38(%ebp),%eax
   10383:	8b 55 10             	mov    0x10(%ebp),%edx
   10386:	8b 12                	mov    (%edx),%edx
   10388:	83 c2 01             	add    $0x1,%edx
   1038b:	89 d1                	mov    %edx,%ecx
   1038d:	c1 e9 02             	shr    $0x2,%ecx
   10390:	8b 55 0c             	mov    0xc(%ebp),%edx
   10393:	8b 12                	mov    (%edx),%edx
   10395:	83 c2 01             	add    $0x1,%edx
   10398:	d1 ea                	shr    %edx
   1039a:	83 ec 04             	sub    $0x4,%esp
   1039d:	50                   	push   %eax
   1039e:	51                   	push   %ecx
   1039f:	52                   	push   %edx
   103a0:	e8 bd 8e ff ff       	call   9262 <lodepng_get_raw_size_idat>
   103a5:	83 c4 10             	add    $0x10,%esp
   103a8:	01 45 e8             	add    %eax,-0x18(%ebp)
      if(*w > 1) expected_size += lodepng_get_raw_size_idat((*w + 0) >> 1, (*h + 1) >> 1, bpp);
   103ab:	8b 45 0c             	mov    0xc(%ebp),%eax
   103ae:	8b 00                	mov    (%eax),%eax
   103b0:	83 f8 01             	cmp    $0x1,%eax
   103b3:	76 27                	jbe    103dc <decodeGeneric+0x970>
   103b5:	8b 45 c8             	mov    -0x38(%ebp),%eax
   103b8:	8b 55 10             	mov    0x10(%ebp),%edx
   103bb:	8b 12                	mov    (%edx),%edx
   103bd:	83 c2 01             	add    $0x1,%edx
   103c0:	89 d1                	mov    %edx,%ecx
   103c2:	d1 e9                	shr    %ecx
   103c4:	8b 55 0c             	mov    0xc(%ebp),%edx
   103c7:	8b 12                	mov    (%edx),%edx
   103c9:	d1 ea                	shr    %edx
   103cb:	83 ec 04             	sub    $0x4,%esp
   103ce:	50                   	push   %eax
   103cf:	51                   	push   %ecx
   103d0:	52                   	push   %edx
   103d1:	e8 8c 8e ff ff       	call   9262 <lodepng_get_raw_size_idat>
   103d6:	83 c4 10             	add    $0x10,%esp
   103d9:	01 45 e8             	add    %eax,-0x18(%ebp)
      expected_size += lodepng_get_raw_size_idat((*w + 0), (*h + 0) >> 1, bpp);
   103dc:	8b 55 c8             	mov    -0x38(%ebp),%edx
   103df:	8b 45 10             	mov    0x10(%ebp),%eax
   103e2:	8b 00                	mov    (%eax),%eax
   103e4:	d1 e8                	shr    %eax
   103e6:	89 c1                	mov    %eax,%ecx
   103e8:	8b 45 0c             	mov    0xc(%ebp),%eax
   103eb:	8b 00                	mov    (%eax),%eax
   103ed:	83 ec 04             	sub    $0x4,%esp
   103f0:	52                   	push   %edx
   103f1:	51                   	push   %ecx
   103f2:	50                   	push   %eax
   103f3:	e8 6a 8e ff ff       	call   9262 <lodepng_get_raw_size_idat>
   103f8:	83 c4 10             	add    $0x10,%esp
   103fb:	01 45 e8             	add    %eax,-0x18(%ebp)
    }

    state->error = zlib_decompress(&scanlines, &scanlines_size, expected_size, idat, idatsize, &state->decoder.zlibsettings);
   103fe:	8b 45 14             	mov    0x14(%ebp),%eax
   10401:	83 ec 08             	sub    $0x8,%esp
   10404:	50                   	push   %eax
   10405:	ff 75 ec             	pushl  -0x14(%ebp)
   10408:	ff 75 d8             	pushl  -0x28(%ebp)
   1040b:	ff 75 e8             	pushl  -0x18(%ebp)
   1040e:	8d 45 c0             	lea    -0x40(%ebp),%eax
   10411:	50                   	push   %eax
   10412:	8d 45 c4             	lea    -0x3c(%ebp),%eax
   10415:	50                   	push   %eax
   10416:	e8 87 7c ff ff       	call   80a2 <zlib_decompress>
   1041b:	83 c4 20             	add    $0x20,%esp
   1041e:	89 c2                	mov    %eax,%edx
   10420:	8b 45 14             	mov    0x14(%ebp),%eax
   10423:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  if(!state->error && scanlines_size != expected_size) state->error = 91; /*decompressed size doesn't match prediction*/
   10429:	8b 45 14             	mov    0x14(%ebp),%eax
   1042c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10432:	85 c0                	test   %eax,%eax
   10434:	75 15                	jne    1044b <decodeGeneric+0x9df>
   10436:	8b 45 c0             	mov    -0x40(%ebp),%eax
   10439:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1043c:	74 0d                	je     1044b <decodeGeneric+0x9df>
   1043e:	8b 45 14             	mov    0x14(%ebp),%eax
   10441:	c7 80 7c 01 00 00 5b 	movl   $0x5b,0x17c(%eax)
   10448:	00 00 00 
  lodepng_free(idat);
   1044b:	83 ec 0c             	sub    $0xc,%esp
   1044e:	ff 75 d8             	pushl  -0x28(%ebp)
   10451:	e8 b2 31 ff ff       	call   3608 <lodepng_free>
   10456:	83 c4 10             	add    $0x10,%esp

  if(!state->error) {
   10459:	8b 45 14             	mov    0x14(%ebp),%eax
   1045c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   10462:	85 c0                	test   %eax,%eax
   10464:	75 4f                	jne    104b5 <decodeGeneric+0xa49>
    outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
   10466:	8b 45 14             	mov    0x14(%ebp),%eax
   10469:	8d 88 a4 00 00 00    	lea    0xa4(%eax),%ecx
   1046f:	8b 45 10             	mov    0x10(%ebp),%eax
   10472:	8b 10                	mov    (%eax),%edx
   10474:	8b 45 0c             	mov    0xc(%ebp),%eax
   10477:	8b 00                	mov    (%eax),%eax
   10479:	83 ec 04             	sub    $0x4,%esp
   1047c:	51                   	push   %ecx
   1047d:	52                   	push   %edx
   1047e:	50                   	push   %eax
   1047f:	e8 be 8d ff ff       	call   9242 <lodepng_get_raw_size>
   10484:	83 c4 10             	add    $0x10,%esp
   10487:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   1048a:	83 ec 0c             	sub    $0xc,%esp
   1048d:	ff 75 e4             	pushl  -0x1c(%ebp)
   10490:	e8 52 31 ff ff       	call   35e7 <lodepng_malloc>
   10495:	83 c4 10             	add    $0x10,%esp
   10498:	89 c2                	mov    %eax,%edx
   1049a:	8b 45 08             	mov    0x8(%ebp),%eax
   1049d:	89 10                	mov    %edx,(%eax)
    if(!*out) state->error = 83; /*alloc fail*/
   1049f:	8b 45 08             	mov    0x8(%ebp),%eax
   104a2:	8b 00                	mov    (%eax),%eax
   104a4:	85 c0                	test   %eax,%eax
   104a6:	75 0d                	jne    104b5 <decodeGeneric+0xa49>
   104a8:	8b 45 14             	mov    0x14(%ebp),%eax
   104ab:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   104b2:	00 00 00 
  }
  if(!state->error) {
   104b5:	8b 45 14             	mov    0x14(%ebp),%eax
   104b8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   104be:	85 c0                	test   %eax,%eax
   104c0:	75 4c                	jne    1050e <decodeGeneric+0xaa2>
    lodepng_memset(*out, 0, outsize);
   104c2:	8b 45 08             	mov    0x8(%ebp),%eax
   104c5:	8b 00                	mov    (%eax),%eax
   104c7:	83 ec 04             	sub    $0x4,%esp
   104ca:	ff 75 e4             	pushl  -0x1c(%ebp)
   104cd:	6a 00                	push   $0x0
   104cf:	50                   	push   %eax
   104d0:	e8 83 31 ff ff       	call   3658 <lodepng_memset>
   104d5:	83 c4 10             	add    $0x10,%esp
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
   104d8:	8b 45 14             	mov    0x14(%ebp),%eax
   104db:	8d b0 98 00 00 00    	lea    0x98(%eax),%esi
   104e1:	8b 45 10             	mov    0x10(%ebp),%eax
   104e4:	8b 18                	mov    (%eax),%ebx
   104e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   104e9:	8b 08                	mov    (%eax),%ecx
   104eb:	8b 55 c4             	mov    -0x3c(%ebp),%edx
   104ee:	8b 45 08             	mov    0x8(%ebp),%eax
   104f1:	8b 00                	mov    (%eax),%eax
   104f3:	83 ec 0c             	sub    $0xc,%esp
   104f6:	56                   	push   %esi
   104f7:	53                   	push   %ebx
   104f8:	51                   	push   %ecx
   104f9:	52                   	push   %edx
   104fa:	50                   	push   %eax
   104fb:	e8 05 df ff ff       	call   e405 <postProcessScanlines>
   10500:	83 c4 20             	add    $0x20,%esp
   10503:	89 c2                	mov    %eax,%edx
   10505:	8b 45 14             	mov    0x14(%ebp),%eax
   10508:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  }
  lodepng_free(scanlines);
   1050e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   10511:	83 ec 0c             	sub    $0xc,%esp
   10514:	50                   	push   %eax
   10515:	e8 ee 30 ff ff       	call   3608 <lodepng_free>
   1051a:	83 c4 10             	add    $0x10,%esp
   1051d:	eb 01                	jmp    10520 <decodeGeneric+0xab4>
  /* safe output values in case error happens */
  *out = 0;
  *w = *h = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;
   1051f:	90                   	nop
  if(!state->error) {
    lodepng_memset(*out, 0, outsize);
    state->error = postProcessScanlines(*out, scanlines, *w, *h, &state->info_png);
  }
  lodepng_free(scanlines);
}
   10520:	8d 65 f8             	lea    -0x8(%ebp),%esp
   10523:	5b                   	pop    %ebx
   10524:	5e                   	pop    %esi
   10525:	5d                   	pop    %ebp
   10526:	c3                   	ret    

00010527 <lodepng_decode>:

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize) {
   10527:	55                   	push   %ebp
   10528:	89 e5                	mov    %esp,%ebp
   1052a:	56                   	push   %esi
   1052b:	53                   	push   %ebx
   1052c:	83 ec 10             	sub    $0x10,%esp
  *out = 0;
   1052f:	8b 45 08             	mov    0x8(%ebp),%eax
   10532:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  decodeGeneric(out, w, h, state, in, insize);
   10538:	83 ec 08             	sub    $0x8,%esp
   1053b:	ff 75 1c             	pushl  0x1c(%ebp)
   1053e:	ff 75 18             	pushl  0x18(%ebp)
   10541:	ff 75 14             	pushl  0x14(%ebp)
   10544:	ff 75 10             	pushl  0x10(%ebp)
   10547:	ff 75 0c             	pushl  0xc(%ebp)
   1054a:	ff 75 08             	pushl  0x8(%ebp)
   1054d:	e8 1a f5 ff ff       	call   fa6c <decodeGeneric>
   10552:	83 c4 20             	add    $0x20,%esp
  if(state->error) return state->error;
   10555:	8b 45 14             	mov    0x14(%ebp),%eax
   10558:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1055e:	85 c0                	test   %eax,%eax
   10560:	74 0e                	je     10570 <lodepng_decode+0x49>
   10562:	8b 45 14             	mov    0x14(%ebp),%eax
   10565:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1056b:	e9 55 01 00 00       	jmp    106c5 <lodepng_decode+0x19e>
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
   10570:	8b 45 14             	mov    0x14(%ebp),%eax
   10573:	8b 40 24             	mov    0x24(%eax),%eax
   10576:	85 c0                	test   %eax,%eax
   10578:	74 20                	je     1059a <lodepng_decode+0x73>
   1057a:	8b 45 14             	mov    0x14(%ebp),%eax
   1057d:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   10583:	8b 45 14             	mov    0x14(%ebp),%eax
   10586:	83 c0 78             	add    $0x78,%eax
   10589:	83 ec 08             	sub    $0x8,%esp
   1058c:	52                   	push   %edx
   1058d:	50                   	push   %eax
   1058e:	e8 56 89 ff ff       	call   8ee9 <lodepng_color_mode_equal>
   10593:	83 c4 10             	add    $0x10,%esp
   10596:	85 c0                	test   %eax,%eax
   10598:	74 54                	je     105ee <lodepng_decode+0xc7>
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   1059a:	8b 45 14             	mov    0x14(%ebp),%eax
   1059d:	8b 40 24             	mov    0x24(%eax),%eax
   105a0:	85 c0                	test   %eax,%eax
   105a2:	0f 85 13 01 00 00    	jne    106bb <lodepng_decode+0x194>
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
   105a8:	8b 45 14             	mov    0x14(%ebp),%eax
   105ab:	8d 90 a4 00 00 00    	lea    0xa4(%eax),%edx
   105b1:	8b 45 14             	mov    0x14(%ebp),%eax
   105b4:	83 c0 78             	add    $0x78,%eax
   105b7:	83 ec 08             	sub    $0x8,%esp
   105ba:	52                   	push   %edx
   105bb:	50                   	push   %eax
   105bc:	e8 3f 88 ff ff       	call   8e00 <lodepng_color_mode_copy>
   105c1:	83 c4 10             	add    $0x10,%esp
   105c4:	89 c2                	mov    %eax,%edx
   105c6:	8b 45 14             	mov    0x14(%ebp),%eax
   105c9:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) return state->error;
   105cf:	8b 45 14             	mov    0x14(%ebp),%eax
   105d2:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   105d8:	85 c0                	test   %eax,%eax
   105da:	0f 84 db 00 00 00    	je     106bb <lodepng_decode+0x194>
   105e0:	8b 45 14             	mov    0x14(%ebp),%eax
   105e3:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   105e9:	e9 d7 00 00 00       	jmp    106c5 <lodepng_decode+0x19e>
    }
  } else { /*color conversion needed*/
    unsigned char* data = *out;
   105ee:	8b 45 08             	mov    0x8(%ebp),%eax
   105f1:	8b 00                	mov    (%eax),%eax
   105f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from grayscale input color type, to 8-bit grayscale or grayscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
   105f6:	8b 45 14             	mov    0x14(%ebp),%eax
   105f9:	8b 40 78             	mov    0x78(%eax),%eax
   105fc:	83 f8 02             	cmp    $0x2,%eax
   105ff:	74 20                	je     10621 <lodepng_decode+0xfa>
   10601:	8b 45 14             	mov    0x14(%ebp),%eax
   10604:	8b 40 78             	mov    0x78(%eax),%eax
   10607:	83 f8 06             	cmp    $0x6,%eax
   1060a:	74 15                	je     10621 <lodepng_decode+0xfa>
       && !(state->info_raw.bitdepth == 8)) {
   1060c:	8b 45 14             	mov    0x14(%ebp),%eax
   1060f:	8b 40 7c             	mov    0x7c(%eax),%eax
   10612:	83 f8 08             	cmp    $0x8,%eax
   10615:	74 0a                	je     10621 <lodepng_decode+0xfa>
      return 56; /*unsupported color mode conversion*/
   10617:	b8 38 00 00 00       	mov    $0x38,%eax
   1061c:	e9 a4 00 00 00       	jmp    106c5 <lodepng_decode+0x19e>
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
   10621:	8b 45 14             	mov    0x14(%ebp),%eax
   10624:	8d 48 78             	lea    0x78(%eax),%ecx
   10627:	8b 45 10             	mov    0x10(%ebp),%eax
   1062a:	8b 10                	mov    (%eax),%edx
   1062c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1062f:	8b 00                	mov    (%eax),%eax
   10631:	83 ec 04             	sub    $0x4,%esp
   10634:	51                   	push   %ecx
   10635:	52                   	push   %edx
   10636:	50                   	push   %eax
   10637:	e8 06 8c ff ff       	call   9242 <lodepng_get_raw_size>
   1063c:	83 c4 10             	add    $0x10,%esp
   1063f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    *out = (unsigned char*)lodepng_malloc(outsize);
   10642:	83 ec 0c             	sub    $0xc,%esp
   10645:	ff 75 f0             	pushl  -0x10(%ebp)
   10648:	e8 9a 2f ff ff       	call   35e7 <lodepng_malloc>
   1064d:	83 c4 10             	add    $0x10,%esp
   10650:	89 c2                	mov    %eax,%edx
   10652:	8b 45 08             	mov    0x8(%ebp),%eax
   10655:	89 10                	mov    %edx,(%eax)
    if(!(*out)) {
   10657:	8b 45 08             	mov    0x8(%ebp),%eax
   1065a:	8b 00                	mov    (%eax),%eax
   1065c:	85 c0                	test   %eax,%eax
   1065e:	75 0f                	jne    1066f <lodepng_decode+0x148>
      state->error = 83; /*alloc fail*/
   10660:	8b 45 14             	mov    0x14(%ebp),%eax
   10663:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   1066a:	00 00 00 
   1066d:	eb 3c                	jmp    106ab <lodepng_decode+0x184>
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   1066f:	8b 45 10             	mov    0x10(%ebp),%eax
   10672:	8b 08                	mov    (%eax),%ecx
   10674:	8b 45 0c             	mov    0xc(%ebp),%eax
   10677:	8b 10                	mov    (%eax),%edx
                                        &state->info_png.color, *w, *h);
   10679:	8b 45 14             	mov    0x14(%ebp),%eax
   1067c:	8d b0 a4 00 00 00    	lea    0xa4(%eax),%esi
    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    *out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out)) {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
   10682:	8b 45 14             	mov    0x14(%ebp),%eax
   10685:	8d 58 78             	lea    0x78(%eax),%ebx
   10688:	8b 45 08             	mov    0x8(%ebp),%eax
   1068b:	8b 00                	mov    (%eax),%eax
   1068d:	83 ec 08             	sub    $0x8,%esp
   10690:	51                   	push   %ecx
   10691:	52                   	push   %edx
   10692:	56                   	push   %esi
   10693:	53                   	push   %ebx
   10694:	ff 75 f4             	pushl  -0xc(%ebp)
   10697:	50                   	push   %eax
   10698:	e8 51 b6 ff ff       	call   bcee <lodepng_convert>
   1069d:	83 c4 20             	add    $0x20,%esp
   106a0:	89 c2                	mov    %eax,%edx
   106a2:	8b 45 14             	mov    0x14(%ebp),%eax
   106a5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
   106ab:	83 ec 0c             	sub    $0xc,%esp
   106ae:	ff 75 f4             	pushl  -0xc(%ebp)
   106b1:	e8 52 2f ff ff       	call   3608 <lodepng_free>
   106b6:	83 c4 10             	add    $0x10,%esp
   106b9:	eb 01                	jmp    106bc <lodepng_decode+0x195>
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color)) {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert) {
   106bb:	90                   	nop
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw,
                                        &state->info_png.color, *w, *h);
    lodepng_free(data);
  }
  return state->error;
   106bc:	8b 45 14             	mov    0x14(%ebp),%eax
   106bf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   106c5:	8d 65 f8             	lea    -0x8(%ebp),%esp
   106c8:	5b                   	pop    %ebx
   106c9:	5e                   	pop    %esi
   106ca:	5d                   	pop    %ebp
   106cb:	c3                   	ret    

000106cc <lodepng_decode_memory>:

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth) {
   106cc:	55                   	push   %ebp
   106cd:	89 e5                	mov    %esp,%ebp
   106cf:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   106d5:	83 ec 0c             	sub    $0xc,%esp
   106d8:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   106de:	50                   	push   %eax
   106df:	e8 d9 01 00 00       	call   108bd <lodepng_state_init>
   106e4:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   106e7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   106ea:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   106f0:	8b 45 20             	mov    0x20(%ebp),%eax
   106f3:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*disable reading things that this function doesn't output*/
  state.decoder.read_text_chunks = 0;
   106f9:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%ebp)
   10700:	00 00 00 
  state.decoder.remember_unknown_chunks = 0;
   10703:	c7 85 a0 fe ff ff 00 	movl   $0x0,-0x160(%ebp)
   1070a:	00 00 00 
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  error = lodepng_decode(out, w, h, &state, in, insize);
   1070d:	83 ec 08             	sub    $0x8,%esp
   10710:	ff 75 18             	pushl  0x18(%ebp)
   10713:	ff 75 14             	pushl  0x14(%ebp)
   10716:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1071c:	50                   	push   %eax
   1071d:	ff 75 10             	pushl  0x10(%ebp)
   10720:	ff 75 0c             	pushl  0xc(%ebp)
   10723:	ff 75 08             	pushl  0x8(%ebp)
   10726:	e8 fc fd ff ff       	call   10527 <lodepng_decode>
   1072b:	83 c4 20             	add    $0x20,%esp
   1072e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   10731:	83 ec 0c             	sub    $0xc,%esp
   10734:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1073a:	50                   	push   %eax
   1073b:	e8 d7 01 00 00       	call   10917 <lodepng_state_cleanup>
   10740:	83 c4 10             	add    $0x10,%esp
  return error;
   10743:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10746:	c9                   	leave  
   10747:	c3                   	ret    

00010748 <lodepng_decode32>:

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   10748:	55                   	push   %ebp
   10749:	89 e5                	mov    %esp,%ebp
   1074b:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
   1074e:	83 ec 04             	sub    $0x4,%esp
   10751:	6a 08                	push   $0x8
   10753:	6a 06                	push   $0x6
   10755:	ff 75 18             	pushl  0x18(%ebp)
   10758:	ff 75 14             	pushl  0x14(%ebp)
   1075b:	ff 75 10             	pushl  0x10(%ebp)
   1075e:	ff 75 0c             	pushl  0xc(%ebp)
   10761:	ff 75 08             	pushl  0x8(%ebp)
   10764:	e8 63 ff ff ff       	call   106cc <lodepng_decode_memory>
   10769:	83 c4 20             	add    $0x20,%esp
}
   1076c:	c9                   	leave  
   1076d:	c3                   	ret    

0001076e <lodepng_decode24>:

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize) {
   1076e:	55                   	push   %ebp
   1076f:	89 e5                	mov    %esp,%ebp
   10771:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
   10774:	83 ec 04             	sub    $0x4,%esp
   10777:	6a 08                	push   $0x8
   10779:	6a 02                	push   $0x2
   1077b:	ff 75 18             	pushl  0x18(%ebp)
   1077e:	ff 75 14             	pushl  0x14(%ebp)
   10781:	ff 75 10             	pushl  0x10(%ebp)
   10784:	ff 75 0c             	pushl  0xc(%ebp)
   10787:	ff 75 08             	pushl  0x8(%ebp)
   1078a:	e8 3d ff ff ff       	call   106cc <lodepng_decode_memory>
   1078f:	83 c4 20             	add    $0x20,%esp
}
   10792:	c9                   	leave  
   10793:	c3                   	ret    

00010794 <lodepng_decode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth) {
   10794:	55                   	push   %ebp
   10795:	89 e5                	mov    %esp,%ebp
   10797:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer = 0;
   1079a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t buffersize;
  unsigned error;
  /* safe output values in case error happens */
  *out = 0;
   107a1:	8b 45 08             	mov    0x8(%ebp),%eax
   107a4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *w = *h = 0;
   107aa:	8b 45 10             	mov    0x10(%ebp),%eax
   107ad:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
   107b3:	8b 45 10             	mov    0x10(%ebp),%eax
   107b6:	8b 10                	mov    (%eax),%edx
   107b8:	8b 45 0c             	mov    0xc(%ebp),%eax
   107bb:	89 10                	mov    %edx,(%eax)
  error = lodepng_load_file(&buffer, &buffersize, filename);
   107bd:	83 ec 04             	sub    $0x4,%esp
   107c0:	ff 75 14             	pushl  0x14(%ebp)
   107c3:	8d 45 ec             	lea    -0x14(%ebp),%eax
   107c6:	50                   	push   %eax
   107c7:	8d 45 f0             	lea    -0x10(%ebp),%eax
   107ca:	50                   	push   %eax
   107cb:	e8 70 32 ff ff       	call   3a40 <lodepng_load_file>
   107d0:	83 c4 10             	add    $0x10,%esp
   107d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
   107d6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   107da:	75 25                	jne    10801 <lodepng_decode_file+0x6d>
   107dc:	8b 55 ec             	mov    -0x14(%ebp),%edx
   107df:	8b 45 f0             	mov    -0x10(%ebp),%eax
   107e2:	83 ec 04             	sub    $0x4,%esp
   107e5:	ff 75 1c             	pushl  0x1c(%ebp)
   107e8:	ff 75 18             	pushl  0x18(%ebp)
   107eb:	52                   	push   %edx
   107ec:	50                   	push   %eax
   107ed:	ff 75 10             	pushl  0x10(%ebp)
   107f0:	ff 75 0c             	pushl  0xc(%ebp)
   107f3:	ff 75 08             	pushl  0x8(%ebp)
   107f6:	e8 d1 fe ff ff       	call   106cc <lodepng_decode_memory>
   107fb:	83 c4 20             	add    $0x20,%esp
   107fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   10801:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10804:	83 ec 0c             	sub    $0xc,%esp
   10807:	50                   	push   %eax
   10808:	e8 fb 2d ff ff       	call   3608 <lodepng_free>
   1080d:	83 c4 10             	add    $0x10,%esp
  return error;
   10810:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10813:	c9                   	leave  
   10814:	c3                   	ret    

00010815 <lodepng_decode32_file>:

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10815:	55                   	push   %ebp
   10816:	89 e5                	mov    %esp,%ebp
   10818:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
   1081b:	83 ec 08             	sub    $0x8,%esp
   1081e:	6a 08                	push   $0x8
   10820:	6a 06                	push   $0x6
   10822:	ff 75 14             	pushl  0x14(%ebp)
   10825:	ff 75 10             	pushl  0x10(%ebp)
   10828:	ff 75 0c             	pushl  0xc(%ebp)
   1082b:	ff 75 08             	pushl  0x8(%ebp)
   1082e:	e8 61 ff ff ff       	call   10794 <lodepng_decode_file>
   10833:	83 c4 20             	add    $0x20,%esp
}
   10836:	c9                   	leave  
   10837:	c3                   	ret    

00010838 <lodepng_decode24_file>:

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename) {
   10838:	55                   	push   %ebp
   10839:	89 e5                	mov    %esp,%ebp
   1083b:	83 ec 08             	sub    $0x8,%esp
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
   1083e:	83 ec 08             	sub    $0x8,%esp
   10841:	6a 08                	push   $0x8
   10843:	6a 02                	push   $0x2
   10845:	ff 75 14             	pushl  0x14(%ebp)
   10848:	ff 75 10             	pushl  0x10(%ebp)
   1084b:	ff 75 0c             	pushl  0xc(%ebp)
   1084e:	ff 75 08             	pushl  0x8(%ebp)
   10851:	e8 3e ff ff ff       	call   10794 <lodepng_decode_file>
   10856:	83 c4 20             	add    $0x20,%esp
}
   10859:	c9                   	leave  
   1085a:	c3                   	ret    

0001085b <lodepng_decoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings) {
   1085b:	55                   	push   %ebp
   1085c:	89 e5                	mov    %esp,%ebp
  settings->color_convert = 1;
   1085e:	8b 45 08             	mov    0x8(%ebp),%eax
   10861:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
   10868:	8b 45 08             	mov    0x8(%ebp),%eax
   1086b:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->remember_unknown_chunks = 0;
   10872:	8b 45 08             	mov    0x8(%ebp),%eax
   10875:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  settings->max_text_size = 16777216;
   1087c:	8b 45 08             	mov    0x8(%ebp),%eax
   1087f:	c7 40 30 00 00 00 01 	movl   $0x1000000,0x30(%eax)
  settings->max_icc_size = 16777216; /* 16MB is much more than enough for any reasonable ICC profile */
   10886:	8b 45 08             	mov    0x8(%ebp),%eax
   10889:	c7 40 34 00 00 00 01 	movl   $0x1000000,0x34(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
   10890:	8b 45 08             	mov    0x8(%ebp),%eax
   10893:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  settings->ignore_critical = 0;
   1089a:	8b 45 08             	mov    0x8(%ebp),%eax
   1089d:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
  settings->ignore_end = 0;
   108a4:	8b 45 08             	mov    0x8(%ebp),%eax
   108a7:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
  lodepng_decompress_settings_init(&settings->zlibsettings);
   108ae:	8b 45 08             	mov    0x8(%ebp),%eax
   108b1:	50                   	push   %eax
   108b2:	e8 ff 7a ff ff       	call   83b6 <lodepng_decompress_settings_init>
   108b7:	83 c4 04             	add    $0x4,%esp
}
   108ba:	90                   	nop
   108bb:	c9                   	leave  
   108bc:	c3                   	ret    

000108bd <lodepng_state_init>:

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state) {
   108bd:	55                   	push   %ebp
   108be:	89 e5                	mov    %esp,%ebp
   108c0:	83 ec 08             	sub    $0x8,%esp
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
   108c3:	8b 45 08             	mov    0x8(%ebp),%eax
   108c6:	50                   	push   %eax
   108c7:	e8 8f ff ff ff       	call   1085b <lodepng_decoder_settings_init>
   108cc:	83 c4 04             	add    $0x4,%esp
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
   108cf:	8b 45 08             	mov    0x8(%ebp),%eax
   108d2:	83 c0 38             	add    $0x38,%eax
   108d5:	83 ec 0c             	sub    $0xc,%esp
   108d8:	50                   	push   %eax
   108d9:	e8 fc 30 00 00       	call   139da <lodepng_encoder_settings_init>
   108de:	83 c4 10             	add    $0x10,%esp
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
   108e1:	8b 45 08             	mov    0x8(%ebp),%eax
   108e4:	83 c0 78             	add    $0x78,%eax
   108e7:	83 ec 0c             	sub    $0xc,%esp
   108ea:	50                   	push   %eax
   108eb:	e8 06 84 ff ff       	call   8cf6 <lodepng_color_mode_init>
   108f0:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&state->info_png);
   108f3:	8b 45 08             	mov    0x8(%ebp),%eax
   108f6:	05 98 00 00 00       	add    $0x98,%eax
   108fb:	83 ec 0c             	sub    $0xc,%esp
   108fe:	50                   	push   %eax
   108ff:	e8 89 93 ff ff       	call   9c8d <lodepng_info_init>
   10904:	83 c4 10             	add    $0x10,%esp
  state->error = 1;
   10907:	8b 45 08             	mov    0x8(%ebp),%eax
   1090a:	c7 80 7c 01 00 00 01 	movl   $0x1,0x17c(%eax)
   10911:	00 00 00 
}
   10914:	90                   	nop
   10915:	c9                   	leave  
   10916:	c3                   	ret    

00010917 <lodepng_state_cleanup>:

void lodepng_state_cleanup(LodePNGState* state) {
   10917:	55                   	push   %ebp
   10918:	89 e5                	mov    %esp,%ebp
   1091a:	83 ec 08             	sub    $0x8,%esp
  lodepng_color_mode_cleanup(&state->info_raw);
   1091d:	8b 45 08             	mov    0x8(%ebp),%eax
   10920:	83 c0 78             	add    $0x78,%eax
   10923:	83 ec 0c             	sub    $0xc,%esp
   10926:	50                   	push   %eax
   10927:	e8 bd 84 ff ff       	call   8de9 <lodepng_color_mode_cleanup>
   1092c:	83 c4 10             	add    $0x10,%esp
  lodepng_info_cleanup(&state->info_png);
   1092f:	8b 45 08             	mov    0x8(%ebp),%eax
   10932:	05 98 00 00 00       	add    $0x98,%eax
   10937:	83 ec 0c             	sub    $0xc,%esp
   1093a:	50                   	push   %eax
   1093b:	e8 2e 94 ff ff       	call   9d6e <lodepng_info_cleanup>
   10940:	83 c4 10             	add    $0x10,%esp
}
   10943:	90                   	nop
   10944:	c9                   	leave  
   10945:	c3                   	ret    

00010946 <lodepng_state_copy>:

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
   10946:	55                   	push   %ebp
   10947:	89 e5                	mov    %esp,%ebp
   10949:	57                   	push   %edi
   1094a:	56                   	push   %esi
   1094b:	53                   	push   %ebx
   1094c:	83 ec 0c             	sub    $0xc,%esp
  lodepng_state_cleanup(dest);
   1094f:	83 ec 0c             	sub    $0xc,%esp
   10952:	ff 75 08             	pushl  0x8(%ebp)
   10955:	e8 bd ff ff ff       	call   10917 <lodepng_state_cleanup>
   1095a:	83 c4 10             	add    $0x10,%esp
  *dest = *source;
   1095d:	8b 55 08             	mov    0x8(%ebp),%edx
   10960:	8b 45 0c             	mov    0xc(%ebp),%eax
   10963:	89 c3                	mov    %eax,%ebx
   10965:	b8 60 00 00 00       	mov    $0x60,%eax
   1096a:	89 d7                	mov    %edx,%edi
   1096c:	89 de                	mov    %ebx,%esi
   1096e:	89 c1                	mov    %eax,%ecx
   10970:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lodepng_color_mode_init(&dest->info_raw);
   10972:	8b 45 08             	mov    0x8(%ebp),%eax
   10975:	83 c0 78             	add    $0x78,%eax
   10978:	83 ec 0c             	sub    $0xc,%esp
   1097b:	50                   	push   %eax
   1097c:	e8 75 83 ff ff       	call   8cf6 <lodepng_color_mode_init>
   10981:	83 c4 10             	add    $0x10,%esp
  lodepng_info_init(&dest->info_png);
   10984:	8b 45 08             	mov    0x8(%ebp),%eax
   10987:	05 98 00 00 00       	add    $0x98,%eax
   1098c:	83 ec 0c             	sub    $0xc,%esp
   1098f:	50                   	push   %eax
   10990:	e8 f8 92 ff ff       	call   9c8d <lodepng_info_init>
   10995:	83 c4 10             	add    $0x10,%esp
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   10998:	8b 45 0c             	mov    0xc(%ebp),%eax
   1099b:	8d 50 78             	lea    0x78(%eax),%edx
   1099e:	8b 45 08             	mov    0x8(%ebp),%eax
   109a1:	83 c0 78             	add    $0x78,%eax
   109a4:	83 ec 08             	sub    $0x8,%esp
   109a7:	52                   	push   %edx
   109a8:	50                   	push   %eax
   109a9:	e8 52 84 ff ff       	call   8e00 <lodepng_color_mode_copy>
   109ae:	83 c4 10             	add    $0x10,%esp
   109b1:	89 c2                	mov    %eax,%edx
   109b3:	8b 45 08             	mov    0x8(%ebp),%eax
   109b6:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   109bc:	8b 45 08             	mov    0x8(%ebp),%eax
   109bf:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   109c5:	85 c0                	test   %eax,%eax
   109c7:	75 36                	jne    109ff <lodepng_state_copy+0xb9>
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
   109c9:	8b 45 0c             	mov    0xc(%ebp),%eax
   109cc:	8d 90 98 00 00 00    	lea    0x98(%eax),%edx
   109d2:	8b 45 08             	mov    0x8(%ebp),%eax
   109d5:	05 98 00 00 00       	add    $0x98,%eax
   109da:	83 ec 08             	sub    $0x8,%esp
   109dd:	52                   	push   %edx
   109de:	50                   	push   %eax
   109df:	e8 dd 93 ff ff       	call   9dc1 <lodepng_info_copy>
   109e4:	83 c4 10             	add    $0x10,%esp
   109e7:	89 c2                	mov    %eax,%edx
   109e9:	8b 45 08             	mov    0x8(%ebp),%eax
   109ec:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
   109f2:	8b 45 08             	mov    0x8(%ebp),%eax
   109f5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   109fb:	85 c0                	test   %eax,%eax
   109fd:	eb 01                	jmp    10a00 <lodepng_state_copy+0xba>
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source) {
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
   109ff:	90                   	nop
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}
   10a00:	8d 65 f4             	lea    -0xc(%ebp),%esp
   10a03:	5b                   	pop    %ebx
   10a04:	5e                   	pop    %esi
   10a05:	5f                   	pop    %edi
   10a06:	5d                   	pop    %ebp
   10a07:	c3                   	ret    

00010a08 <writeSignature>:
/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */


static unsigned writeSignature(ucvector* out) {
   10a08:	55                   	push   %ebp
   10a09:	89 e5                	mov    %esp,%ebp
   10a0b:	83 ec 10             	sub    $0x10,%esp
  size_t pos = out->size;
   10a0e:	8b 45 08             	mov    0x8(%ebp),%eax
   10a11:	8b 40 04             	mov    0x4(%eax),%eax
   10a14:	89 45 fc             	mov    %eax,-0x4(%ebp)
  const unsigned char signature[] = {137, 80, 78, 71, 13, 10, 26, 10};
   10a17:	c6 45 f4 89          	movb   $0x89,-0xc(%ebp)
   10a1b:	c6 45 f5 50          	movb   $0x50,-0xb(%ebp)
   10a1f:	c6 45 f6 4e          	movb   $0x4e,-0xa(%ebp)
   10a23:	c6 45 f7 47          	movb   $0x47,-0x9(%ebp)
   10a27:	c6 45 f8 0d          	movb   $0xd,-0x8(%ebp)
   10a2b:	c6 45 f9 0a          	movb   $0xa,-0x7(%ebp)
   10a2f:	c6 45 fa 1a          	movb   $0x1a,-0x6(%ebp)
   10a33:	c6 45 fb 0a          	movb   $0xa,-0x5(%ebp)
  /*8 bytes PNG signature, aka the magic bytes*/
  if(!ucvector_resize(out, out->size + 8)) return 83; /*alloc fail*/
   10a37:	8b 45 08             	mov    0x8(%ebp),%eax
   10a3a:	8b 40 04             	mov    0x4(%eax),%eax
   10a3d:	83 c0 08             	add    $0x8,%eax
   10a40:	50                   	push   %eax
   10a41:	ff 75 08             	pushl  0x8(%ebp)
   10a44:	e8 f8 2d ff ff       	call   3841 <ucvector_resize>
   10a49:	83 c4 08             	add    $0x8,%esp
   10a4c:	85 c0                	test   %eax,%eax
   10a4e:	75 07                	jne    10a57 <writeSignature+0x4f>
   10a50:	b8 53 00 00 00       	mov    $0x53,%eax
   10a55:	eb 1e                	jmp    10a75 <writeSignature+0x6d>
  lodepng_memcpy(out->data + pos, signature, 8);
   10a57:	8b 45 08             	mov    0x8(%ebp),%eax
   10a5a:	8b 10                	mov    (%eax),%edx
   10a5c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10a5f:	01 c2                	add    %eax,%edx
   10a61:	6a 08                	push   $0x8
   10a63:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10a66:	50                   	push   %eax
   10a67:	52                   	push   %edx
   10a68:	e8 b8 2b ff ff       	call   3625 <lodepng_memcpy>
   10a6d:	83 c4 0c             	add    $0xc,%esp
  return 0;
   10a70:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10a75:	c9                   	leave  
   10a76:	c3                   	ret    

00010a77 <addChunk_IHDR>:

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method) {
   10a77:	55                   	push   %ebp
   10a78:	89 e5                	mov    %esp,%ebp
   10a7a:	83 ec 10             	sub    $0x10,%esp
  unsigned char *chunk, *data;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 13, "IHDR"));
   10a7d:	68 0c a3 01 00       	push   $0x1a30c
   10a82:	6a 0d                	push   $0xd
   10a84:	ff 75 08             	pushl  0x8(%ebp)
   10a87:	8d 45 f4             	lea    -0xc(%ebp),%eax
   10a8a:	50                   	push   %eax
   10a8b:	e8 cf 7f ff ff       	call   8a5f <lodepng_chunk_init>
   10a90:	83 c4 10             	add    $0x10,%esp
   10a93:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10a96:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10a9a:	74 05                	je     10aa1 <addChunk_IHDR+0x2a>
   10a9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10a9f:	eb 6d                	jmp    10b0e <addChunk_IHDR+0x97>
  data = chunk + 8;
   10aa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10aa4:	83 c0 08             	add    $0x8,%eax
   10aa7:	89 45 f8             	mov    %eax,-0x8(%ebp)

  lodepng_set32bitInt(data + 0, w); /*width*/
   10aaa:	ff 75 0c             	pushl  0xc(%ebp)
   10aad:	ff 75 f8             	pushl  -0x8(%ebp)
   10ab0:	e8 f3 2e ff ff       	call   39a8 <lodepng_set32bitInt>
   10ab5:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(data + 4, h); /*height*/
   10ab8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10abb:	83 c0 04             	add    $0x4,%eax
   10abe:	ff 75 10             	pushl  0x10(%ebp)
   10ac1:	50                   	push   %eax
   10ac2:	e8 e1 2e ff ff       	call   39a8 <lodepng_set32bitInt>
   10ac7:	83 c4 08             	add    $0x8,%esp
  data[8] = (unsigned char)bitdepth; /*bit depth*/
   10aca:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10acd:	83 c0 08             	add    $0x8,%eax
   10ad0:	8b 55 18             	mov    0x18(%ebp),%edx
   10ad3:	88 10                	mov    %dl,(%eax)
  data[9] = (unsigned char)colortype; /*color type*/
   10ad5:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10ad8:	83 c0 09             	add    $0x9,%eax
   10adb:	8b 55 14             	mov    0x14(%ebp),%edx
   10ade:	88 10                	mov    %dl,(%eax)
  data[10] = 0; /*compression method*/
   10ae0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10ae3:	83 c0 0a             	add    $0xa,%eax
   10ae6:	c6 00 00             	movb   $0x0,(%eax)
  data[11] = 0; /*filter method*/
   10ae9:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10aec:	83 c0 0b             	add    $0xb,%eax
   10aef:	c6 00 00             	movb   $0x0,(%eax)
  data[12] = interlace_method; /*interlace method*/
   10af2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10af5:	83 c0 0c             	add    $0xc,%eax
   10af8:	8b 55 1c             	mov    0x1c(%ebp),%edx
   10afb:	88 10                	mov    %dl,(%eax)

  lodepng_chunk_generate_crc(chunk);
   10afd:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b00:	50                   	push   %eax
   10b01:	e8 02 7c ff ff       	call   8708 <lodepng_chunk_generate_crc>
   10b06:	83 c4 04             	add    $0x4,%esp
  return 0;
   10b09:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10b0e:	c9                   	leave  
   10b0f:	c3                   	ret    

00010b10 <addChunk_PLTE>:

/* only adds the chunk if needed (there is a key or palette with alpha) */
static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info) {
   10b10:	55                   	push   %ebp
   10b11:	89 e5                	mov    %esp,%ebp
   10b13:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  size_t i, j = 8;
   10b16:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));
   10b1d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b20:	8b 50 0c             	mov    0xc(%eax),%edx
   10b23:	89 d0                	mov    %edx,%eax
   10b25:	01 c0                	add    %eax,%eax
   10b27:	01 d0                	add    %edx,%eax
   10b29:	68 28 a3 01 00       	push   $0x1a328
   10b2e:	50                   	push   %eax
   10b2f:	ff 75 08             	pushl  0x8(%ebp)
   10b32:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10b35:	50                   	push   %eax
   10b36:	e8 24 7f ff ff       	call   8a5f <lodepng_chunk_init>
   10b3b:	83 c4 10             	add    $0x10,%esp
   10b3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10b41:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10b45:	74 08                	je     10b4f <addChunk_PLTE+0x3f>
   10b47:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10b4a:	e9 95 00 00 00       	jmp    10be4 <addChunk_PLTE+0xd4>

  for(i = 0; i != info->palettesize; ++i) {
   10b4f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10b56:	eb 70                	jmp    10bc8 <addChunk_PLTE+0xb8>
    /*add all channels except alpha channel*/
    chunk[j++] = info->palette[i * 4 + 0];
   10b58:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10b5b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10b5e:	8d 50 01             	lea    0x1(%eax),%edx
   10b61:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10b64:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10b67:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b6a:	8b 40 08             	mov    0x8(%eax),%eax
   10b6d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10b70:	c1 e1 02             	shl    $0x2,%ecx
   10b73:	01 c8                	add    %ecx,%eax
   10b75:	0f b6 00             	movzbl (%eax),%eax
   10b78:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 1];
   10b7a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10b7d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10b80:	8d 50 01             	lea    0x1(%eax),%edx
   10b83:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10b86:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10b89:	8b 45 0c             	mov    0xc(%ebp),%eax
   10b8c:	8b 40 08             	mov    0x8(%eax),%eax
   10b8f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10b92:	c1 e1 02             	shl    $0x2,%ecx
   10b95:	83 c1 01             	add    $0x1,%ecx
   10b98:	01 c8                	add    %ecx,%eax
   10b9a:	0f b6 00             	movzbl (%eax),%eax
   10b9d:	88 02                	mov    %al,(%edx)
    chunk[j++] = info->palette[i * 4 + 2];
   10b9f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10ba2:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10ba5:	8d 50 01             	lea    0x1(%eax),%edx
   10ba8:	89 55 f8             	mov    %edx,-0x8(%ebp)
   10bab:	8d 14 01             	lea    (%ecx,%eax,1),%edx
   10bae:	8b 45 0c             	mov    0xc(%ebp),%eax
   10bb1:	8b 40 08             	mov    0x8(%eax),%eax
   10bb4:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10bb7:	c1 e1 02             	shl    $0x2,%ecx
   10bba:	83 c1 02             	add    $0x2,%ecx
   10bbd:	01 c8                	add    %ecx,%eax
   10bbf:	0f b6 00             	movzbl (%eax),%eax
   10bc2:	88 02                	mov    %al,(%edx)
  unsigned char* chunk;
  size_t i, j = 8;

  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, info->palettesize * 3, "PLTE"));

  for(i = 0; i != info->palettesize; ++i) {
   10bc4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10bc8:	8b 45 0c             	mov    0xc(%ebp),%eax
   10bcb:	8b 40 0c             	mov    0xc(%eax),%eax
   10bce:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   10bd1:	75 85                	jne    10b58 <addChunk_PLTE+0x48>
    chunk[j++] = info->palette[i * 4 + 0];
    chunk[j++] = info->palette[i * 4 + 1];
    chunk[j++] = info->palette[i * 4 + 2];
  }

  lodepng_chunk_generate_crc(chunk);
   10bd3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10bd6:	50                   	push   %eax
   10bd7:	e8 2c 7b ff ff       	call   8708 <lodepng_chunk_generate_crc>
   10bdc:	83 c4 04             	add    $0x4,%esp
  return 0;
   10bdf:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10be4:	c9                   	leave  
   10be5:	c3                   	ret    

00010be6 <addChunk_tRNS>:

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info) {
   10be6:	55                   	push   %ebp
   10be7:	89 e5                	mov    %esp,%ebp
   10be9:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10bec:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

  if(info->colortype == LCT_PALETTE) {
   10bf3:	8b 45 0c             	mov    0xc(%ebp),%eax
   10bf6:	8b 00                	mov    (%eax),%eax
   10bf8:	83 f8 03             	cmp    $0x3,%eax
   10bfb:	0f 85 ae 00 00 00    	jne    10caf <addChunk_tRNS+0xc9>
    size_t i, amount = info->palettesize;
   10c01:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c04:	8b 40 0c             	mov    0xc(%eax),%eax
   10c07:	89 45 f8             	mov    %eax,-0x8(%ebp)
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10c0a:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c0d:	8b 40 0c             	mov    0xc(%eax),%eax
   10c10:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10c13:	eb 23                	jmp    10c38 <addChunk_tRNS+0x52>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10c15:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c18:	8b 40 08             	mov    0x8(%eax),%eax
   10c1b:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10c1e:	83 ea 01             	sub    $0x1,%edx
   10c21:	c1 e2 02             	shl    $0x2,%edx
   10c24:	83 c2 03             	add    $0x3,%edx
   10c27:	01 d0                	add    %edx,%eax
   10c29:	0f b6 00             	movzbl (%eax),%eax
   10c2c:	3c ff                	cmp    $0xff,%al
   10c2e:	75 10                	jne    10c40 <addChunk_tRNS+0x5a>
      --amount;
   10c30:	83 6d f8 01          	subl   $0x1,-0x8(%ebp)
  unsigned char* chunk = 0;

  if(info->colortype == LCT_PALETTE) {
    size_t i, amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i != 0; --i) {
   10c34:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   10c38:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10c3c:	75 d7                	jne    10c15 <addChunk_tRNS+0x2f>
   10c3e:	eb 01                	jmp    10c41 <addChunk_tRNS+0x5b>
      if(info->palette[4 * (i - 1) + 3] != 255) break;
   10c40:	90                   	nop
      --amount;
    }
    if(amount) {
   10c41:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   10c45:	0f 84 63 01 00 00    	je     10dae <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, amount, "tRNS"));
   10c4b:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10c4e:	68 2d a3 01 00       	push   $0x1a32d
   10c53:	50                   	push   %eax
   10c54:	ff 75 08             	pushl  0x8(%ebp)
   10c57:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10c5a:	50                   	push   %eax
   10c5b:	e8 ff 7d ff ff       	call   8a5f <lodepng_chunk_init>
   10c60:	83 c4 10             	add    $0x10,%esp
   10c63:	89 45 f4             	mov    %eax,-0xc(%ebp)
   10c66:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10c6a:	74 08                	je     10c74 <addChunk_tRNS+0x8e>
   10c6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10c6f:	e9 52 01 00 00       	jmp    10dc6 <addChunk_tRNS+0x1e0>
      /*add the alpha channel values from the palette*/
      for(i = 0; i != amount; ++i) chunk[8 + i] = info->palette[4 * i + 3];
   10c74:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10c7b:	eb 25                	jmp    10ca2 <addChunk_tRNS+0xbc>
   10c7d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10c80:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10c83:	83 c2 08             	add    $0x8,%edx
   10c86:	01 c2                	add    %eax,%edx
   10c88:	8b 45 0c             	mov    0xc(%ebp),%eax
   10c8b:	8b 40 08             	mov    0x8(%eax),%eax
   10c8e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
   10c91:	c1 e1 02             	shl    $0x2,%ecx
   10c94:	83 c1 03             	add    $0x3,%ecx
   10c97:	01 c8                	add    %ecx,%eax
   10c99:	0f b6 00             	movzbl (%eax),%eax
   10c9c:	88 02                	mov    %al,(%edx)
   10c9e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10ca2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10ca5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   10ca8:	75 d3                	jne    10c7d <addChunk_tRNS+0x97>
   10caa:	e9 ff 00 00 00       	jmp    10dae <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_GREY) {
   10caf:	8b 45 0c             	mov    0xc(%ebp),%eax
   10cb2:	8b 00                	mov    (%eax),%eax
   10cb4:	85 c0                	test   %eax,%eax
   10cb6:	75 59                	jne    10d11 <addChunk_tRNS+0x12b>
    if(info->key_defined) {
   10cb8:	8b 45 0c             	mov    0xc(%ebp),%eax
   10cbb:	8b 40 10             	mov    0x10(%eax),%eax
   10cbe:	85 c0                	test   %eax,%eax
   10cc0:	0f 84 e8 00 00 00    	je     10dae <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "tRNS"));
   10cc6:	68 2d a3 01 00       	push   $0x1a32d
   10ccb:	6a 02                	push   $0x2
   10ccd:	ff 75 08             	pushl  0x8(%ebp)
   10cd0:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10cd3:	50                   	push   %eax
   10cd4:	e8 86 7d ff ff       	call   8a5f <lodepng_chunk_init>
   10cd9:	83 c4 10             	add    $0x10,%esp
   10cdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10cdf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10ce3:	74 08                	je     10ced <addChunk_tRNS+0x107>
   10ce5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ce8:	e9 d9 00 00 00       	jmp    10dc6 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10ced:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10cf0:	8d 50 08             	lea    0x8(%eax),%edx
   10cf3:	8b 45 0c             	mov    0xc(%ebp),%eax
   10cf6:	8b 40 14             	mov    0x14(%eax),%eax
   10cf9:	c1 e8 08             	shr    $0x8,%eax
   10cfc:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10cfe:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d01:	8d 50 09             	lea    0x9(%eax),%edx
   10d04:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d07:	8b 40 14             	mov    0x14(%eax),%eax
   10d0a:	88 02                	mov    %al,(%edx)
   10d0c:	e9 9d 00 00 00       	jmp    10dae <addChunk_tRNS+0x1c8>
    }
  } else if(info->colortype == LCT_RGB) {
   10d11:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d14:	8b 00                	mov    (%eax),%eax
   10d16:	83 f8 02             	cmp    $0x2,%eax
   10d19:	0f 85 8f 00 00 00    	jne    10dae <addChunk_tRNS+0x1c8>
    if(info->key_defined) {
   10d1f:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d22:	8b 40 10             	mov    0x10(%eax),%eax
   10d25:	85 c0                	test   %eax,%eax
   10d27:	0f 84 81 00 00 00    	je     10dae <addChunk_tRNS+0x1c8>
      CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "tRNS"));
   10d2d:	68 2d a3 01 00       	push   $0x1a32d
   10d32:	6a 06                	push   $0x6
   10d34:	ff 75 08             	pushl  0x8(%ebp)
   10d37:	8d 45 e8             	lea    -0x18(%ebp),%eax
   10d3a:	50                   	push   %eax
   10d3b:	e8 1f 7d ff ff       	call   8a5f <lodepng_chunk_init>
   10d40:	83 c4 10             	add    $0x10,%esp
   10d43:	89 45 ec             	mov    %eax,-0x14(%ebp)
   10d46:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10d4a:	74 05                	je     10d51 <addChunk_tRNS+0x16b>
   10d4c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10d4f:	eb 75                	jmp    10dc6 <addChunk_tRNS+0x1e0>
      chunk[8] = (unsigned char)(info->key_r >> 8);
   10d51:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d54:	8d 50 08             	lea    0x8(%eax),%edx
   10d57:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d5a:	8b 40 14             	mov    0x14(%eax),%eax
   10d5d:	c1 e8 08             	shr    $0x8,%eax
   10d60:	88 02                	mov    %al,(%edx)
      chunk[9] = (unsigned char)(info->key_r & 255);
   10d62:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d65:	8d 50 09             	lea    0x9(%eax),%edx
   10d68:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d6b:	8b 40 14             	mov    0x14(%eax),%eax
   10d6e:	88 02                	mov    %al,(%edx)
      chunk[10] = (unsigned char)(info->key_g >> 8);
   10d70:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d73:	8d 50 0a             	lea    0xa(%eax),%edx
   10d76:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d79:	8b 40 18             	mov    0x18(%eax),%eax
   10d7c:	c1 e8 08             	shr    $0x8,%eax
   10d7f:	88 02                	mov    %al,(%edx)
      chunk[11] = (unsigned char)(info->key_g & 255);
   10d81:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d84:	8d 50 0b             	lea    0xb(%eax),%edx
   10d87:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d8a:	8b 40 18             	mov    0x18(%eax),%eax
   10d8d:	88 02                	mov    %al,(%edx)
      chunk[12] = (unsigned char)(info->key_b >> 8);
   10d8f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10d92:	8d 50 0c             	lea    0xc(%eax),%edx
   10d95:	8b 45 0c             	mov    0xc(%ebp),%eax
   10d98:	8b 40 1c             	mov    0x1c(%eax),%eax
   10d9b:	c1 e8 08             	shr    $0x8,%eax
   10d9e:	88 02                	mov    %al,(%edx)
      chunk[13] = (unsigned char)(info->key_b & 255);
   10da0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10da3:	8d 50 0d             	lea    0xd(%eax),%edx
   10da6:	8b 45 0c             	mov    0xc(%ebp),%eax
   10da9:	8b 40 1c             	mov    0x1c(%eax),%eax
   10dac:	88 02                	mov    %al,(%edx)
    }
  }

  if(chunk) lodepng_chunk_generate_crc(chunk);
   10dae:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10db1:	85 c0                	test   %eax,%eax
   10db3:	74 0c                	je     10dc1 <addChunk_tRNS+0x1db>
   10db5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10db8:	50                   	push   %eax
   10db9:	e8 4a 79 ff ff       	call   8708 <lodepng_chunk_generate_crc>
   10dbe:	83 c4 04             	add    $0x4,%esp
  return 0;
   10dc1:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10dc6:	c9                   	leave  
   10dc7:	c3                   	ret    

00010dc8 <addChunk_IDAT>:

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings) {
   10dc8:	55                   	push   %ebp
   10dc9:	89 e5                	mov    %esp,%ebp
   10dcb:	83 ec 18             	sub    $0x18,%esp
  unsigned error = 0;
   10dce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* zlib = 0;
   10dd5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  size_t zlibsize = 0;
   10ddc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  error = zlib_compress(&zlib, &zlibsize, data, datasize, zlibsettings);
   10de3:	83 ec 0c             	sub    $0xc,%esp
   10de6:	ff 75 14             	pushl  0x14(%ebp)
   10de9:	ff 75 10             	pushl  0x10(%ebp)
   10dec:	ff 75 0c             	pushl  0xc(%ebp)
   10def:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10df2:	50                   	push   %eax
   10df3:	8d 45 f0             	lea    -0x10(%ebp),%eax
   10df6:	50                   	push   %eax
   10df7:	e8 fb 74 ff ff       	call   82f7 <zlib_compress>
   10dfc:	83 c4 20             	add    $0x20,%esp
   10dff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) {
   10e02:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10e06:	75 1b                	jne    10e23 <addChunk_IDAT+0x5b>
    error = lodepng_chunk_createv(out, zlibsize, "IDAT", zlib);
   10e08:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10e0b:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10e0e:	50                   	push   %eax
   10e0f:	68 64 a3 01 00       	push   $0x1a364
   10e14:	52                   	push   %edx
   10e15:	ff 75 08             	pushl  0x8(%ebp)
   10e18:	e8 ea 7c ff ff       	call   8b07 <lodepng_chunk_createv>
   10e1d:	83 c4 10             	add    $0x10,%esp
   10e20:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  lodepng_free(zlib);
   10e23:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10e26:	83 ec 0c             	sub    $0xc,%esp
   10e29:	50                   	push   %eax
   10e2a:	e8 d9 27 ff ff       	call   3608 <lodepng_free>
   10e2f:	83 c4 10             	add    $0x10,%esp
  return error;
   10e32:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   10e35:	c9                   	leave  
   10e36:	c3                   	ret    

00010e37 <addChunk_IEND>:

static unsigned addChunk_IEND(ucvector* out) {
   10e37:	55                   	push   %ebp
   10e38:	89 e5                	mov    %esp,%ebp
  return lodepng_chunk_createv(out, 0, "IEND", 0);
   10e3a:	6a 00                	push   $0x0
   10e3c:	68 69 a3 01 00       	push   $0x1a369
   10e41:	6a 00                	push   $0x0
   10e43:	ff 75 08             	pushl  0x8(%ebp)
   10e46:	e8 bc 7c ff ff       	call   8b07 <lodepng_chunk_createv>
   10e4b:	83 c4 10             	add    $0x10,%esp
}
   10e4e:	c9                   	leave  
   10e4f:	c3                   	ret    

00010e50 <addChunk_tEXt>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring) {
   10e50:	55                   	push   %ebp
   10e51:	89 e5                	mov    %esp,%ebp
   10e53:	83 ec 20             	sub    $0x20,%esp
  unsigned char* chunk = 0;
   10e56:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  size_t keysize = lodepng_strlen(keyword), textsize = lodepng_strlen(textstring);
   10e5d:	ff 75 0c             	pushl  0xc(%ebp)
   10e60:	e8 1e 28 ff ff       	call   3683 <lodepng_strlen>
   10e65:	83 c4 04             	add    $0x4,%esp
   10e68:	89 45 fc             	mov    %eax,-0x4(%ebp)
   10e6b:	ff 75 10             	pushl  0x10(%ebp)
   10e6e:	e8 10 28 ff ff       	call   3683 <lodepng_strlen>
   10e73:	83 c4 04             	add    $0x4,%esp
   10e76:	89 45 f8             	mov    %eax,-0x8(%ebp)
  size_t size = keysize + 1 + textsize;
   10e79:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10e7c:	8d 50 01             	lea    0x1(%eax),%edx
   10e7f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   10e82:	01 d0                	add    %edx,%eax
   10e84:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10e87:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   10e8b:	7e 06                	jle    10e93 <addChunk_tEXt+0x43>
   10e8d:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
   10e91:	7e 07                	jle    10e9a <addChunk_tEXt+0x4a>
   10e93:	b8 59 00 00 00       	mov    $0x59,%eax
   10e98:	eb 74                	jmp    10f0e <addChunk_tEXt+0xbe>
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, size, "tEXt"));
   10e9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10e9d:	68 37 a3 01 00       	push   $0x1a337
   10ea2:	50                   	push   %eax
   10ea3:	ff 75 08             	pushl  0x8(%ebp)
   10ea6:	8d 45 ec             	lea    -0x14(%ebp),%eax
   10ea9:	50                   	push   %eax
   10eaa:	e8 b0 7b ff ff       	call   8a5f <lodepng_chunk_init>
   10eaf:	83 c4 10             	add    $0x10,%esp
   10eb2:	89 45 f0             	mov    %eax,-0x10(%ebp)
   10eb5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   10eb9:	74 05                	je     10ec0 <addChunk_tEXt+0x70>
   10ebb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10ebe:	eb 4e                	jmp    10f0e <addChunk_tEXt+0xbe>
  lodepng_memcpy(chunk + 8, keyword, keysize);
   10ec0:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10ec3:	83 c0 08             	add    $0x8,%eax
   10ec6:	ff 75 fc             	pushl  -0x4(%ebp)
   10ec9:	ff 75 0c             	pushl  0xc(%ebp)
   10ecc:	50                   	push   %eax
   10ecd:	e8 53 27 ff ff       	call   3625 <lodepng_memcpy>
   10ed2:	83 c4 0c             	add    $0xc,%esp
  chunk[8 + keysize] = 0; /*null termination char*/
   10ed5:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10ed8:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10edb:	83 c2 08             	add    $0x8,%edx
   10ede:	01 d0                	add    %edx,%eax
   10ee0:	c6 00 00             	movb   $0x0,(%eax)
  lodepng_memcpy(chunk + 9 + keysize, textstring, textsize);
   10ee3:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10ee6:	8b 55 fc             	mov    -0x4(%ebp),%edx
   10ee9:	83 c2 09             	add    $0x9,%edx
   10eec:	01 d0                	add    %edx,%eax
   10eee:	ff 75 f8             	pushl  -0x8(%ebp)
   10ef1:	ff 75 10             	pushl  0x10(%ebp)
   10ef4:	50                   	push   %eax
   10ef5:	e8 2b 27 ff ff       	call   3625 <lodepng_memcpy>
   10efa:	83 c4 0c             	add    $0xc,%esp
  lodepng_chunk_generate_crc(chunk);
   10efd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10f00:	50                   	push   %eax
   10f01:	e8 02 78 ff ff       	call   8708 <lodepng_chunk_generate_crc>
   10f06:	83 c4 04             	add    $0x4,%esp
  return 0;
   10f09:	b8 00 00 00 00       	mov    $0x0,%eax
}
   10f0e:	c9                   	leave  
   10f0f:	c3                   	ret    

00010f10 <addChunk_zTXt>:

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings) {
   10f10:	55                   	push   %ebp
   10f11:	89 e5                	mov    %esp,%ebp
   10f13:	53                   	push   %ebx
   10f14:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   10f17:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   10f1e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  unsigned char* compressed = 0;
   10f25:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t compressedsize = 0;
   10f2c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   10f33:	ff 75 10             	pushl  0x10(%ebp)
   10f36:	e8 48 27 ff ff       	call   3683 <lodepng_strlen>
   10f3b:	83 c4 04             	add    $0x4,%esp
   10f3e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword);
   10f41:	ff 75 0c             	pushl  0xc(%ebp)
   10f44:	e8 3a 27 ff ff       	call   3683 <lodepng_strlen>
   10f49:	83 c4 04             	add    $0x4,%esp
   10f4c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   10f4f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   10f53:	7e 06                	jle    10f5b <addChunk_zTXt+0x4b>
   10f55:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   10f59:	7e 0a                	jle    10f65 <addChunk_zTXt+0x55>
   10f5b:	b8 59 00 00 00       	mov    $0x59,%eax
   10f60:	e9 c8 00 00 00       	jmp    1102d <addChunk_zTXt+0x11d>

  error = zlib_compress(&compressed, &compressedsize,
   10f65:	83 ec 0c             	sub    $0xc,%esp
   10f68:	ff 75 14             	pushl  0x14(%ebp)
   10f6b:	ff 75 f0             	pushl  -0x10(%ebp)
   10f6e:	ff 75 10             	pushl  0x10(%ebp)
   10f71:	8d 45 dc             	lea    -0x24(%ebp),%eax
   10f74:	50                   	push   %eax
   10f75:	8d 45 e0             	lea    -0x20(%ebp),%eax
   10f78:	50                   	push   %eax
   10f79:	e8 79 73 ff ff       	call   82f7 <zlib_compress>
   10f7e:	83 c4 20             	add    $0x20,%esp
   10f81:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        (const unsigned char*)textstring, textsize, zlibsettings);
  if(!error) {
   10f84:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10f88:	75 29                	jne    10fb3 <addChunk_zTXt+0xa3>
    size_t size = keysize + 2 + compressedsize;
   10f8a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   10f8d:	8d 50 02             	lea    0x2(%eax),%edx
   10f90:	8b 45 dc             	mov    -0x24(%ebp),%eax
   10f93:	01 d0                	add    %edx,%eax
   10f95:	89 45 e8             	mov    %eax,-0x18(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "zTXt");
   10f98:	8b 45 e8             	mov    -0x18(%ebp),%eax
   10f9b:	68 3c a3 01 00       	push   $0x1a33c
   10fa0:	50                   	push   %eax
   10fa1:	ff 75 08             	pushl  0x8(%ebp)
   10fa4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   10fa7:	50                   	push   %eax
   10fa8:	e8 b2 7a ff ff       	call   8a5f <lodepng_chunk_init>
   10fad:	83 c4 10             	add    $0x10,%esp
   10fb0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   10fb3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   10fb7:	75 62                	jne    1101b <addChunk_zTXt+0x10b>
    lodepng_memcpy(chunk + 8, keyword, keysize);
   10fb9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10fbc:	83 c0 08             	add    $0x8,%eax
   10fbf:	83 ec 04             	sub    $0x4,%esp
   10fc2:	ff 75 ec             	pushl  -0x14(%ebp)
   10fc5:	ff 75 0c             	pushl  0xc(%ebp)
   10fc8:	50                   	push   %eax
   10fc9:	e8 57 26 ff ff       	call   3625 <lodepng_memcpy>
   10fce:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   10fd1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10fd4:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10fd7:	83 c2 08             	add    $0x8,%edx
   10fda:	01 d0                	add    %edx,%eax
   10fdc:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   10fdf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   10fe2:	8b 55 ec             	mov    -0x14(%ebp),%edx
   10fe5:	83 c2 09             	add    $0x9,%edx
   10fe8:	01 d0                	add    %edx,%eax
   10fea:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   10fed:	8b 55 dc             	mov    -0x24(%ebp),%edx
   10ff0:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10ff3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   10ff6:	8b 5d ec             	mov    -0x14(%ebp),%ebx
   10ff9:	83 c3 0a             	add    $0xa,%ebx
   10ffc:	01 d9                	add    %ebx,%ecx
   10ffe:	83 ec 04             	sub    $0x4,%esp
   11001:	52                   	push   %edx
   11002:	50                   	push   %eax
   11003:	51                   	push   %ecx
   11004:	e8 1c 26 ff ff       	call   3625 <lodepng_memcpy>
   11009:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   1100c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1100f:	83 ec 0c             	sub    $0xc,%esp
   11012:	50                   	push   %eax
   11013:	e8 f0 76 ff ff       	call   8708 <lodepng_chunk_generate_crc>
   11018:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   1101b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1101e:	83 ec 0c             	sub    $0xc,%esp
   11021:	50                   	push   %eax
   11022:	e8 e1 25 ff ff       	call   3608 <lodepng_free>
   11027:	83 c4 10             	add    $0x10,%esp
  return error;
   1102a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1102d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11030:	c9                   	leave  
   11031:	c3                   	ret    

00011032 <addChunk_iTXt>:

static unsigned addChunk_iTXt(ucvector* out, unsigned compress, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings) {
   11032:	55                   	push   %ebp
   11033:	89 e5                	mov    %esp,%ebp
   11035:	53                   	push   %ebx
   11036:	83 ec 34             	sub    $0x34,%esp
  unsigned error = 0;
   11039:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11040:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  unsigned char* compressed = 0;
   11047:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  size_t compressedsize = 0;
   1104e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  size_t textsize = lodepng_strlen(textstring);
   11055:	ff 75 1c             	pushl  0x1c(%ebp)
   11058:	e8 26 26 ff ff       	call   3683 <lodepng_strlen>
   1105d:	83 c4 04             	add    $0x4,%esp
   11060:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t keysize = lodepng_strlen(keyword), langsize = lodepng_strlen(langtag), transsize = lodepng_strlen(transkey);
   11063:	ff 75 10             	pushl  0x10(%ebp)
   11066:	e8 18 26 ff ff       	call   3683 <lodepng_strlen>
   1106b:	83 c4 04             	add    $0x4,%esp
   1106e:	89 45 ec             	mov    %eax,-0x14(%ebp)
   11071:	ff 75 14             	pushl  0x14(%ebp)
   11074:	e8 0a 26 ff ff       	call   3683 <lodepng_strlen>
   11079:	83 c4 04             	add    $0x4,%esp
   1107c:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1107f:	ff 75 18             	pushl  0x18(%ebp)
   11082:	e8 fc 25 ff ff       	call   3683 <lodepng_strlen>
   11087:	83 c4 04             	add    $0x4,%esp
   1108a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   1108d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   11091:	7e 06                	jle    11099 <addChunk_iTXt+0x67>
   11093:	83 7d ec 4f          	cmpl   $0x4f,-0x14(%ebp)
   11097:	7e 0a                	jle    110a3 <addChunk_iTXt+0x71>
   11099:	b8 59 00 00 00       	mov    $0x59,%eax
   1109e:	e9 9a 01 00 00       	jmp    1123d <addChunk_iTXt+0x20b>

  if(compress) {
   110a3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   110a7:	74 1f                	je     110c8 <addChunk_iTXt+0x96>
    error = zlib_compress(&compressed, &compressedsize,
   110a9:	83 ec 0c             	sub    $0xc,%esp
   110ac:	ff 75 20             	pushl  0x20(%ebp)
   110af:	ff 75 f0             	pushl  -0x10(%ebp)
   110b2:	ff 75 1c             	pushl  0x1c(%ebp)
   110b5:	8d 45 d0             	lea    -0x30(%ebp),%eax
   110b8:	50                   	push   %eax
   110b9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   110bc:	50                   	push   %eax
   110bd:	e8 35 72 ff ff       	call   82f7 <zlib_compress>
   110c2:	83 c4 20             	add    $0x20,%esp
   110c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                          (const unsigned char*)textstring, textsize, zlibsettings);
  }
  if(!error) {
   110c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   110cc:	75 44                	jne    11112 <addChunk_iTXt+0xe0>
    size_t size = keysize + 3 + langsize + 1 + transsize + 1 + (compress ? compressedsize : textsize);
   110ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
   110d1:	8d 50 03             	lea    0x3(%eax),%edx
   110d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
   110d7:	01 d0                	add    %edx,%eax
   110d9:	8d 50 01             	lea    0x1(%eax),%edx
   110dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   110df:	01 d0                	add    %edx,%eax
   110e1:	8d 50 01             	lea    0x1(%eax),%edx
   110e4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   110e8:	74 05                	je     110ef <addChunk_iTXt+0xbd>
   110ea:	8b 45 d0             	mov    -0x30(%ebp),%eax
   110ed:	eb 03                	jmp    110f2 <addChunk_iTXt+0xc0>
   110ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
   110f2:	01 d0                	add    %edx,%eax
   110f4:	89 45 e0             	mov    %eax,-0x20(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iTXt");
   110f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   110fa:	68 41 a3 01 00       	push   $0x1a341
   110ff:	50                   	push   %eax
   11100:	ff 75 08             	pushl  0x8(%ebp)
   11103:	8d 45 d8             	lea    -0x28(%ebp),%eax
   11106:	50                   	push   %eax
   11107:	e8 53 79 ff ff       	call   8a5f <lodepng_chunk_init>
   1110c:	83 c4 10             	add    $0x10,%esp
   1110f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   11112:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11116:	0f 85 0f 01 00 00    	jne    1122b <addChunk_iTXt+0x1f9>
    size_t pos = 8;
   1111c:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
    lodepng_memcpy(chunk + pos, keyword, keysize);
   11123:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11126:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11129:	01 d0                	add    %edx,%eax
   1112b:	83 ec 04             	sub    $0x4,%esp
   1112e:	ff 75 ec             	pushl  -0x14(%ebp)
   11131:	ff 75 10             	pushl  0x10(%ebp)
   11134:	50                   	push   %eax
   11135:	e8 eb 24 ff ff       	call   3625 <lodepng_memcpy>
   1113a:	83 c4 10             	add    $0x10,%esp
    pos += keysize;
   1113d:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11140:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   11143:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11146:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11149:	8d 50 01             	lea    0x1(%eax),%edx
   1114c:	89 55 dc             	mov    %edx,-0x24(%ebp)
   1114f:	01 c8                	add    %ecx,%eax
   11151:	c6 00 00             	movb   $0x0,(%eax)
    chunk[pos++] = (compress ? 1 : 0); /*compression flag*/
   11154:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   11157:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1115a:	8d 50 01             	lea    0x1(%eax),%edx
   1115d:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11160:	01 c8                	add    %ecx,%eax
   11162:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11166:	0f 95 c2             	setne  %dl
   11169:	88 10                	mov    %dl,(%eax)
    chunk[pos++] = 0; /*compression method: 0*/
   1116b:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   1116e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11171:	8d 50 01             	lea    0x1(%eax),%edx
   11174:	89 55 dc             	mov    %edx,-0x24(%ebp)
   11177:	01 c8                	add    %ecx,%eax
   11179:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, langtag, langsize);
   1117c:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1117f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11182:	01 d0                	add    %edx,%eax
   11184:	83 ec 04             	sub    $0x4,%esp
   11187:	ff 75 e8             	pushl  -0x18(%ebp)
   1118a:	ff 75 14             	pushl  0x14(%ebp)
   1118d:	50                   	push   %eax
   1118e:	e8 92 24 ff ff       	call   3625 <lodepng_memcpy>
   11193:	83 c4 10             	add    $0x10,%esp
    pos += langsize;
   11196:	8b 45 e8             	mov    -0x18(%ebp),%eax
   11199:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   1119c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   1119f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   111a2:	8d 50 01             	lea    0x1(%eax),%edx
   111a5:	89 55 dc             	mov    %edx,-0x24(%ebp)
   111a8:	01 c8                	add    %ecx,%eax
   111aa:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + pos, transkey, transsize);
   111ad:	8b 55 d8             	mov    -0x28(%ebp),%edx
   111b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   111b3:	01 d0                	add    %edx,%eax
   111b5:	83 ec 04             	sub    $0x4,%esp
   111b8:	ff 75 e4             	pushl  -0x1c(%ebp)
   111bb:	ff 75 18             	pushl  0x18(%ebp)
   111be:	50                   	push   %eax
   111bf:	e8 61 24 ff ff       	call   3625 <lodepng_memcpy>
   111c4:	83 c4 10             	add    $0x10,%esp
    pos += transsize;
   111c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   111ca:	01 45 dc             	add    %eax,-0x24(%ebp)
    chunk[pos++] = 0; /*null termination char*/
   111cd:	8b 4d d8             	mov    -0x28(%ebp),%ecx
   111d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   111d3:	8d 50 01             	lea    0x1(%eax),%edx
   111d6:	89 55 dc             	mov    %edx,-0x24(%ebp)
   111d9:	01 c8                	add    %ecx,%eax
   111db:	c6 00 00             	movb   $0x0,(%eax)
    if(compress) {
   111de:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   111e2:	74 1e                	je     11202 <addChunk_iTXt+0x1d0>
      lodepng_memcpy(chunk + pos, compressed, compressedsize);
   111e4:	8b 55 d0             	mov    -0x30(%ebp),%edx
   111e7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   111ea:	8b 5d d8             	mov    -0x28(%ebp),%ebx
   111ed:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   111f0:	01 d9                	add    %ebx,%ecx
   111f2:	83 ec 04             	sub    $0x4,%esp
   111f5:	52                   	push   %edx
   111f6:	50                   	push   %eax
   111f7:	51                   	push   %ecx
   111f8:	e8 28 24 ff ff       	call   3625 <lodepng_memcpy>
   111fd:	83 c4 10             	add    $0x10,%esp
   11200:	eb 1a                	jmp    1121c <addChunk_iTXt+0x1ea>
    } else {
      lodepng_memcpy(chunk + pos, textstring, textsize);
   11202:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11205:	8b 45 dc             	mov    -0x24(%ebp),%eax
   11208:	01 d0                	add    %edx,%eax
   1120a:	83 ec 04             	sub    $0x4,%esp
   1120d:	ff 75 f0             	pushl  -0x10(%ebp)
   11210:	ff 75 1c             	pushl  0x1c(%ebp)
   11213:	50                   	push   %eax
   11214:	e8 0c 24 ff ff       	call   3625 <lodepng_memcpy>
   11219:	83 c4 10             	add    $0x10,%esp
    }
    lodepng_chunk_generate_crc(chunk);
   1121c:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1121f:	83 ec 0c             	sub    $0xc,%esp
   11222:	50                   	push   %eax
   11223:	e8 e0 74 ff ff       	call   8708 <lodepng_chunk_generate_crc>
   11228:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   1122b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   1122e:	83 ec 0c             	sub    $0xc,%esp
   11231:	50                   	push   %eax
   11232:	e8 d1 23 ff ff       	call   3608 <lodepng_free>
   11237:	83 c4 10             	add    $0x10,%esp
  return error;
   1123a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1123d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11240:	c9                   	leave  
   11241:	c3                   	ret    

00011242 <addChunk_bKGD>:

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info) {
   11242:	55                   	push   %ebp
   11243:	89 e5                	mov    %esp,%ebp
   11245:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk = 0;
   11248:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA) {
   1124f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11252:	8b 40 0c             	mov    0xc(%eax),%eax
   11255:	85 c0                	test   %eax,%eax
   11257:	74 0b                	je     11264 <addChunk_bKGD+0x22>
   11259:	8b 45 0c             	mov    0xc(%ebp),%eax
   1125c:	8b 40 0c             	mov    0xc(%eax),%eax
   1125f:	83 f8 04             	cmp    $0x4,%eax
   11262:	75 4b                	jne    112af <addChunk_bKGD+0x6d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 2, "bKGD"));
   11264:	68 32 a3 01 00       	push   $0x1a332
   11269:	6a 02                	push   $0x2
   1126b:	ff 75 08             	pushl  0x8(%ebp)
   1126e:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11271:	50                   	push   %eax
   11272:	e8 e8 77 ff ff       	call   8a5f <lodepng_chunk_init>
   11277:	83 c4 10             	add    $0x10,%esp
   1127a:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1127d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   11281:	74 08                	je     1128b <addChunk_bKGD+0x49>
   11283:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11286:	e9 19 01 00 00       	jmp    113a4 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   1128b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1128e:	8d 50 08             	lea    0x8(%eax),%edx
   11291:	8b 45 0c             	mov    0xc(%ebp),%eax
   11294:	8b 40 30             	mov    0x30(%eax),%eax
   11297:	c1 e8 08             	shr    $0x8,%eax
   1129a:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   1129c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1129f:	8d 50 09             	lea    0x9(%eax),%edx
   112a2:	8b 45 0c             	mov    0xc(%ebp),%eax
   112a5:	8b 40 30             	mov    0x30(%eax),%eax
   112a8:	88 02                	mov    %al,(%edx)
   112aa:	e9 dd 00 00 00       	jmp    1138c <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA) {
   112af:	8b 45 0c             	mov    0xc(%ebp),%eax
   112b2:	8b 40 0c             	mov    0xc(%eax),%eax
   112b5:	83 f8 02             	cmp    $0x2,%eax
   112b8:	74 0f                	je     112c9 <addChunk_bKGD+0x87>
   112ba:	8b 45 0c             	mov    0xc(%ebp),%eax
   112bd:	8b 40 0c             	mov    0xc(%eax),%eax
   112c0:	83 f8 06             	cmp    $0x6,%eax
   112c3:	0f 85 86 00 00 00    	jne    1134f <addChunk_bKGD+0x10d>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 6, "bKGD"));
   112c9:	68 32 a3 01 00       	push   $0x1a332
   112ce:	6a 06                	push   $0x6
   112d0:	ff 75 08             	pushl  0x8(%ebp)
   112d3:	8d 45 f0             	lea    -0x10(%ebp),%eax
   112d6:	50                   	push   %eax
   112d7:	e8 83 77 ff ff       	call   8a5f <lodepng_chunk_init>
   112dc:	83 c4 10             	add    $0x10,%esp
   112df:	89 45 f8             	mov    %eax,-0x8(%ebp)
   112e2:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   112e6:	74 08                	je     112f0 <addChunk_bKGD+0xae>
   112e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
   112eb:	e9 b4 00 00 00       	jmp    113a4 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r >> 8);
   112f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   112f3:	8d 50 08             	lea    0x8(%eax),%edx
   112f6:	8b 45 0c             	mov    0xc(%ebp),%eax
   112f9:	8b 40 30             	mov    0x30(%eax),%eax
   112fc:	c1 e8 08             	shr    $0x8,%eax
   112ff:	88 02                	mov    %al,(%edx)
    chunk[9] = (unsigned char)(info->background_r & 255);
   11301:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11304:	8d 50 09             	lea    0x9(%eax),%edx
   11307:	8b 45 0c             	mov    0xc(%ebp),%eax
   1130a:	8b 40 30             	mov    0x30(%eax),%eax
   1130d:	88 02                	mov    %al,(%edx)
    chunk[10] = (unsigned char)(info->background_g >> 8);
   1130f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11312:	8d 50 0a             	lea    0xa(%eax),%edx
   11315:	8b 45 0c             	mov    0xc(%ebp),%eax
   11318:	8b 40 34             	mov    0x34(%eax),%eax
   1131b:	c1 e8 08             	shr    $0x8,%eax
   1131e:	88 02                	mov    %al,(%edx)
    chunk[11] = (unsigned char)(info->background_g & 255);
   11320:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11323:	8d 50 0b             	lea    0xb(%eax),%edx
   11326:	8b 45 0c             	mov    0xc(%ebp),%eax
   11329:	8b 40 34             	mov    0x34(%eax),%eax
   1132c:	88 02                	mov    %al,(%edx)
    chunk[12] = (unsigned char)(info->background_b >> 8);
   1132e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11331:	8d 50 0c             	lea    0xc(%eax),%edx
   11334:	8b 45 0c             	mov    0xc(%ebp),%eax
   11337:	8b 40 38             	mov    0x38(%eax),%eax
   1133a:	c1 e8 08             	shr    $0x8,%eax
   1133d:	88 02                	mov    %al,(%edx)
    chunk[13] = (unsigned char)(info->background_b & 255);
   1133f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11342:	8d 50 0d             	lea    0xd(%eax),%edx
   11345:	8b 45 0c             	mov    0xc(%ebp),%eax
   11348:	8b 40 38             	mov    0x38(%eax),%eax
   1134b:	88 02                	mov    %al,(%edx)
   1134d:	eb 3d                	jmp    1138c <addChunk_bKGD+0x14a>
  } else if(info->color.colortype == LCT_PALETTE) {
   1134f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11352:	8b 40 0c             	mov    0xc(%eax),%eax
   11355:	83 f8 03             	cmp    $0x3,%eax
   11358:	75 32                	jne    1138c <addChunk_bKGD+0x14a>
    CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 1, "bKGD"));
   1135a:	68 32 a3 01 00       	push   $0x1a332
   1135f:	6a 01                	push   $0x1
   11361:	ff 75 08             	pushl  0x8(%ebp)
   11364:	8d 45 f0             	lea    -0x10(%ebp),%eax
   11367:	50                   	push   %eax
   11368:	e8 f2 76 ff ff       	call   8a5f <lodepng_chunk_init>
   1136d:	83 c4 10             	add    $0x10,%esp
   11370:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11373:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11377:	74 05                	je     1137e <addChunk_bKGD+0x13c>
   11379:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1137c:	eb 26                	jmp    113a4 <addChunk_bKGD+0x162>
    chunk[8] = (unsigned char)(info->background_r & 255); /*palette index*/
   1137e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11381:	8d 50 08             	lea    0x8(%eax),%edx
   11384:	8b 45 0c             	mov    0xc(%ebp),%eax
   11387:	8b 40 30             	mov    0x30(%eax),%eax
   1138a:	88 02                	mov    %al,(%edx)
  }
  if(chunk) lodepng_chunk_generate_crc(chunk);
   1138c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1138f:	85 c0                	test   %eax,%eax
   11391:	74 0c                	je     1139f <addChunk_bKGD+0x15d>
   11393:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11396:	50                   	push   %eax
   11397:	e8 6c 73 ff ff       	call   8708 <lodepng_chunk_generate_crc>
   1139c:	83 c4 04             	add    $0x4,%esp
  return 0;
   1139f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   113a4:	c9                   	leave  
   113a5:	c3                   	ret    

000113a6 <addChunk_tIME>:

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time) {
   113a6:	55                   	push   %ebp
   113a7:	89 e5                	mov    %esp,%ebp
   113a9:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 7, "tIME"));
   113ac:	68 46 a3 01 00       	push   $0x1a346
   113b1:	6a 07                	push   $0x7
   113b3:	ff 75 08             	pushl  0x8(%ebp)
   113b6:	8d 45 f8             	lea    -0x8(%ebp),%eax
   113b9:	50                   	push   %eax
   113ba:	e8 a0 76 ff ff       	call   8a5f <lodepng_chunk_init>
   113bf:	83 c4 10             	add    $0x10,%esp
   113c2:	89 45 fc             	mov    %eax,-0x4(%ebp)
   113c5:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   113c9:	74 05                	je     113d0 <addChunk_tIME+0x2a>
   113cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   113ce:	eb 74                	jmp    11444 <addChunk_tIME+0x9e>
  chunk[8] = (unsigned char)(time->year >> 8);
   113d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   113d3:	8d 50 08             	lea    0x8(%eax),%edx
   113d6:	8b 45 0c             	mov    0xc(%ebp),%eax
   113d9:	8b 00                	mov    (%eax),%eax
   113db:	c1 e8 08             	shr    $0x8,%eax
   113de:	88 02                	mov    %al,(%edx)
  chunk[9] = (unsigned char)(time->year & 255);
   113e0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   113e3:	8d 50 09             	lea    0x9(%eax),%edx
   113e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   113e9:	8b 00                	mov    (%eax),%eax
   113eb:	88 02                	mov    %al,(%edx)
  chunk[10] = (unsigned char)time->month;
   113ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
   113f0:	8d 50 0a             	lea    0xa(%eax),%edx
   113f3:	8b 45 0c             	mov    0xc(%ebp),%eax
   113f6:	8b 40 04             	mov    0x4(%eax),%eax
   113f9:	88 02                	mov    %al,(%edx)
  chunk[11] = (unsigned char)time->day;
   113fb:	8b 45 f8             	mov    -0x8(%ebp),%eax
   113fe:	8d 50 0b             	lea    0xb(%eax),%edx
   11401:	8b 45 0c             	mov    0xc(%ebp),%eax
   11404:	8b 40 08             	mov    0x8(%eax),%eax
   11407:	88 02                	mov    %al,(%edx)
  chunk[12] = (unsigned char)time->hour;
   11409:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1140c:	8d 50 0c             	lea    0xc(%eax),%edx
   1140f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11412:	8b 40 0c             	mov    0xc(%eax),%eax
   11415:	88 02                	mov    %al,(%edx)
  chunk[13] = (unsigned char)time->minute;
   11417:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1141a:	8d 50 0d             	lea    0xd(%eax),%edx
   1141d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11420:	8b 40 10             	mov    0x10(%eax),%eax
   11423:	88 02                	mov    %al,(%edx)
  chunk[14] = (unsigned char)time->second;
   11425:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11428:	8d 50 0e             	lea    0xe(%eax),%edx
   1142b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1142e:	8b 40 14             	mov    0x14(%eax),%eax
   11431:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   11433:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11436:	50                   	push   %eax
   11437:	e8 cc 72 ff ff       	call   8708 <lodepng_chunk_generate_crc>
   1143c:	83 c4 04             	add    $0x4,%esp
  return 0;
   1143f:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11444:	c9                   	leave  
   11445:	c3                   	ret    

00011446 <addChunk_pHYs>:

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info) {
   11446:	55                   	push   %ebp
   11447:	89 e5                	mov    %esp,%ebp
   11449:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 9, "pHYs"));
   1144c:	68 4b a3 01 00       	push   $0x1a34b
   11451:	6a 09                	push   $0x9
   11453:	ff 75 08             	pushl  0x8(%ebp)
   11456:	8d 45 f8             	lea    -0x8(%ebp),%eax
   11459:	50                   	push   %eax
   1145a:	e8 00 76 ff ff       	call   8a5f <lodepng_chunk_init>
   1145f:	83 c4 10             	add    $0x10,%esp
   11462:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11465:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   11469:	74 05                	je     11470 <addChunk_pHYs+0x2a>
   1146b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1146e:	eb 51                	jmp    114c1 <addChunk_pHYs+0x7b>
  lodepng_set32bitInt(chunk + 8, info->phys_x);
   11470:	8b 45 0c             	mov    0xc(%ebp),%eax
   11473:	8b 40 7c             	mov    0x7c(%eax),%eax
   11476:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11479:	83 c2 08             	add    $0x8,%edx
   1147c:	50                   	push   %eax
   1147d:	52                   	push   %edx
   1147e:	e8 25 25 ff ff       	call   39a8 <lodepng_set32bitInt>
   11483:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->phys_y);
   11486:	8b 45 0c             	mov    0xc(%ebp),%eax
   11489:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   1148f:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11492:	83 c2 0c             	add    $0xc,%edx
   11495:	50                   	push   %eax
   11496:	52                   	push   %edx
   11497:	e8 0c 25 ff ff       	call   39a8 <lodepng_set32bitInt>
   1149c:	83 c4 08             	add    $0x8,%esp
  chunk[16] = info->phys_unit;
   1149f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   114a2:	8d 50 10             	lea    0x10(%eax),%edx
   114a5:	8b 45 0c             	mov    0xc(%ebp),%eax
   114a8:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
   114ae:	88 02                	mov    %al,(%edx)
  lodepng_chunk_generate_crc(chunk);
   114b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   114b3:	50                   	push   %eax
   114b4:	e8 4f 72 ff ff       	call   8708 <lodepng_chunk_generate_crc>
   114b9:	83 c4 04             	add    $0x4,%esp
  return 0;
   114bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
   114c1:	c9                   	leave  
   114c2:	c3                   	ret    

000114c3 <addChunk_gAMA>:

static unsigned addChunk_gAMA(ucvector* out, const LodePNGInfo* info) {
   114c3:	55                   	push   %ebp
   114c4:	89 e5                	mov    %esp,%ebp
   114c6:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 4, "gAMA"));
   114c9:	68 50 a3 01 00       	push   $0x1a350
   114ce:	6a 04                	push   $0x4
   114d0:	ff 75 08             	pushl  0x8(%ebp)
   114d3:	8d 45 f8             	lea    -0x8(%ebp),%eax
   114d6:	50                   	push   %eax
   114d7:	e8 83 75 ff ff       	call   8a5f <lodepng_chunk_init>
   114dc:	83 c4 10             	add    $0x10,%esp
   114df:	89 45 fc             	mov    %eax,-0x4(%ebp)
   114e2:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   114e6:	74 05                	je     114ed <addChunk_gAMA+0x2a>
   114e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   114eb:	eb 2a                	jmp    11517 <addChunk_gAMA+0x54>
  lodepng_set32bitInt(chunk + 8, info->gama_gamma);
   114ed:	8b 45 0c             	mov    0xc(%ebp),%eax
   114f0:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   114f6:	8b 55 f8             	mov    -0x8(%ebp),%edx
   114f9:	83 c2 08             	add    $0x8,%edx
   114fc:	50                   	push   %eax
   114fd:	52                   	push   %edx
   114fe:	e8 a5 24 ff ff       	call   39a8 <lodepng_set32bitInt>
   11503:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   11506:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11509:	50                   	push   %eax
   1150a:	e8 f9 71 ff ff       	call   8708 <lodepng_chunk_generate_crc>
   1150f:	83 c4 04             	add    $0x4,%esp
  return 0;
   11512:	b8 00 00 00 00       	mov    $0x0,%eax
}
   11517:	c9                   	leave  
   11518:	c3                   	ret    

00011519 <addChunk_cHRM>:

static unsigned addChunk_cHRM(ucvector* out, const LodePNGInfo* info) {
   11519:	55                   	push   %ebp
   1151a:	89 e5                	mov    %esp,%ebp
   1151c:	83 ec 10             	sub    $0x10,%esp
  unsigned char* chunk;
  CERROR_TRY_RETURN(lodepng_chunk_init(&chunk, out, 32, "cHRM"));
   1151f:	68 55 a3 01 00       	push   $0x1a355
   11524:	6a 20                	push   $0x20
   11526:	ff 75 08             	pushl  0x8(%ebp)
   11529:	8d 45 f8             	lea    -0x8(%ebp),%eax
   1152c:	50                   	push   %eax
   1152d:	e8 2d 75 ff ff       	call   8a5f <lodepng_chunk_init>
   11532:	83 c4 10             	add    $0x10,%esp
   11535:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11538:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1153c:	74 08                	je     11546 <addChunk_cHRM+0x2d>
   1153e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11541:	e9 d9 00 00 00       	jmp    1161f <addChunk_cHRM+0x106>
  lodepng_set32bitInt(chunk + 8, info->chrm_white_x);
   11546:	8b 45 0c             	mov    0xc(%ebp),%eax
   11549:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
   1154f:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11552:	83 c2 08             	add    $0x8,%edx
   11555:	50                   	push   %eax
   11556:	52                   	push   %edx
   11557:	e8 4c 24 ff ff       	call   39a8 <lodepng_set32bitInt>
   1155c:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 12, info->chrm_white_y);
   1155f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11562:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   11568:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1156b:	83 c2 0c             	add    $0xc,%edx
   1156e:	50                   	push   %eax
   1156f:	52                   	push   %edx
   11570:	e8 33 24 ff ff       	call   39a8 <lodepng_set32bitInt>
   11575:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 16, info->chrm_red_x);
   11578:	8b 45 0c             	mov    0xc(%ebp),%eax
   1157b:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
   11581:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11584:	83 c2 10             	add    $0x10,%edx
   11587:	50                   	push   %eax
   11588:	52                   	push   %edx
   11589:	e8 1a 24 ff ff       	call   39a8 <lodepng_set32bitInt>
   1158e:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 20, info->chrm_red_y);
   11591:	8b 45 0c             	mov    0xc(%ebp),%eax
   11594:	8b 80 a0 00 00 00    	mov    0xa0(%eax),%eax
   1159a:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1159d:	83 c2 14             	add    $0x14,%edx
   115a0:	50                   	push   %eax
   115a1:	52                   	push   %edx
   115a2:	e8 01 24 ff ff       	call   39a8 <lodepng_set32bitInt>
   115a7:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 24, info->chrm_green_x);
   115aa:	8b 45 0c             	mov    0xc(%ebp),%eax
   115ad:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
   115b3:	8b 55 f8             	mov    -0x8(%ebp),%edx
   115b6:	83 c2 18             	add    $0x18,%edx
   115b9:	50                   	push   %eax
   115ba:	52                   	push   %edx
   115bb:	e8 e8 23 ff ff       	call   39a8 <lodepng_set32bitInt>
   115c0:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 28, info->chrm_green_y);
   115c3:	8b 45 0c             	mov    0xc(%ebp),%eax
   115c6:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
   115cc:	8b 55 f8             	mov    -0x8(%ebp),%edx
   115cf:	83 c2 1c             	add    $0x1c,%edx
   115d2:	50                   	push   %eax
   115d3:	52                   	push   %edx
   115d4:	e8 cf 23 ff ff       	call   39a8 <lodepng_set32bitInt>
   115d9:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 32, info->chrm_blue_x);
   115dc:	8b 45 0c             	mov    0xc(%ebp),%eax
   115df:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   115e5:	8b 55 f8             	mov    -0x8(%ebp),%edx
   115e8:	83 c2 20             	add    $0x20,%edx
   115eb:	50                   	push   %eax
   115ec:	52                   	push   %edx
   115ed:	e8 b6 23 ff ff       	call   39a8 <lodepng_set32bitInt>
   115f2:	83 c4 08             	add    $0x8,%esp
  lodepng_set32bitInt(chunk + 36, info->chrm_blue_y);
   115f5:	8b 45 0c             	mov    0xc(%ebp),%eax
   115f8:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
   115fe:	8b 55 f8             	mov    -0x8(%ebp),%edx
   11601:	83 c2 24             	add    $0x24,%edx
   11604:	50                   	push   %eax
   11605:	52                   	push   %edx
   11606:	e8 9d 23 ff ff       	call   39a8 <lodepng_set32bitInt>
   1160b:	83 c4 08             	add    $0x8,%esp
  lodepng_chunk_generate_crc(chunk);
   1160e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11611:	50                   	push   %eax
   11612:	e8 f1 70 ff ff       	call   8708 <lodepng_chunk_generate_crc>
   11617:	83 c4 04             	add    $0x4,%esp
  return 0;
   1161a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1161f:	c9                   	leave  
   11620:	c3                   	ret    

00011621 <addChunk_sRGB>:

static unsigned addChunk_sRGB(ucvector* out, const LodePNGInfo* info) {
   11621:	55                   	push   %ebp
   11622:	89 e5                	mov    %esp,%ebp
   11624:	83 ec 10             	sub    $0x10,%esp
  unsigned char data = info->srgb_intent;
   11627:	8b 45 0c             	mov    0xc(%ebp),%eax
   1162a:	8b 80 b8 00 00 00    	mov    0xb8(%eax),%eax
   11630:	88 45 ff             	mov    %al,-0x1(%ebp)
  return lodepng_chunk_createv(out, 1, "sRGB", &data);
   11633:	8d 45 ff             	lea    -0x1(%ebp),%eax
   11636:	50                   	push   %eax
   11637:	68 5a a3 01 00       	push   $0x1a35a
   1163c:	6a 01                	push   $0x1
   1163e:	ff 75 08             	pushl  0x8(%ebp)
   11641:	e8 c1 74 ff ff       	call   8b07 <lodepng_chunk_createv>
   11646:	83 c4 10             	add    $0x10,%esp
}
   11649:	c9                   	leave  
   1164a:	c3                   	ret    

0001164b <addChunk_iCCP>:

static unsigned addChunk_iCCP(ucvector* out, const LodePNGInfo* info, LodePNGCompressSettings* zlibsettings) {
   1164b:	55                   	push   %ebp
   1164c:	89 e5                	mov    %esp,%ebp
   1164e:	53                   	push   %ebx
   1164f:	83 ec 24             	sub    $0x24,%esp
  unsigned error = 0;
   11652:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned char* chunk = 0;
   11659:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  unsigned char* compressed = 0;
   11660:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  size_t compressedsize = 0;
   11667:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  size_t keysize = lodepng_strlen(info->iccp_name);
   1166e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11671:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11677:	50                   	push   %eax
   11678:	e8 06 20 ff ff       	call   3683 <lodepng_strlen>
   1167d:	83 c4 04             	add    $0x4,%esp
   11680:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
   11683:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11687:	7e 06                	jle    1168f <addChunk_iCCP+0x44>
   11689:	83 7d f0 4f          	cmpl   $0x4f,-0x10(%ebp)
   1168d:	7e 0a                	jle    11699 <addChunk_iCCP+0x4e>
   1168f:	b8 59 00 00 00       	mov    $0x59,%eax
   11694:	e9 df 00 00 00       	jmp    11778 <addChunk_iCCP+0x12d>
  error = zlib_compress(&compressed, &compressedsize,
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   11699:	8b 45 0c             	mov    0xc(%ebp),%eax
   1169c:	8b 80 c8 00 00 00    	mov    0xc8(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   116a2:	89 c2                	mov    %eax,%edx
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
   116a4:	8b 45 0c             	mov    0xc(%ebp),%eax
   116a7:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
  unsigned char* compressed = 0;
  size_t compressedsize = 0;
  size_t keysize = lodepng_strlen(info->iccp_name);

  if(keysize < 1 || keysize > 79) return 89; /*error: invalid keyword size*/
  error = zlib_compress(&compressed, &compressedsize,
   116ad:	83 ec 0c             	sub    $0xc,%esp
   116b0:	ff 75 10             	pushl  0x10(%ebp)
   116b3:	52                   	push   %edx
   116b4:	50                   	push   %eax
   116b5:	8d 45 e0             	lea    -0x20(%ebp),%eax
   116b8:	50                   	push   %eax
   116b9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   116bc:	50                   	push   %eax
   116bd:	e8 35 6c ff ff       	call   82f7 <zlib_compress>
   116c2:	83 c4 20             	add    $0x20,%esp
   116c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                        info->iccp_profile, info->iccp_profile_size, zlibsettings);
  if(!error) {
   116c8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   116cc:	75 29                	jne    116f7 <addChunk_iCCP+0xac>
    size_t size = keysize + 2 + compressedsize;
   116ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
   116d1:	8d 50 02             	lea    0x2(%eax),%edx
   116d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   116d7:	01 d0                	add    %edx,%eax
   116d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
    error = lodepng_chunk_init(&chunk, out, size, "iCCP");
   116dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   116df:	68 5f a3 01 00       	push   $0x1a35f
   116e4:	50                   	push   %eax
   116e5:	ff 75 08             	pushl  0x8(%ebp)
   116e8:	8d 45 e8             	lea    -0x18(%ebp),%eax
   116eb:	50                   	push   %eax
   116ec:	e8 6e 73 ff ff       	call   8a5f <lodepng_chunk_init>
   116f1:	83 c4 10             	add    $0x10,%esp
   116f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  }
  if(!error) {
   116f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   116fb:	75 69                	jne    11766 <addChunk_iCCP+0x11b>
    lodepng_memcpy(chunk + 8, info->iccp_name, keysize);
   116fd:	8b 45 0c             	mov    0xc(%ebp),%eax
   11700:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   11706:	8b 55 e8             	mov    -0x18(%ebp),%edx
   11709:	83 c2 08             	add    $0x8,%edx
   1170c:	83 ec 04             	sub    $0x4,%esp
   1170f:	ff 75 f0             	pushl  -0x10(%ebp)
   11712:	50                   	push   %eax
   11713:	52                   	push   %edx
   11714:	e8 0c 1f ff ff       	call   3625 <lodepng_memcpy>
   11719:	83 c4 10             	add    $0x10,%esp
    chunk[8 + keysize] = 0; /*null termination char*/
   1171c:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1171f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11722:	83 c2 08             	add    $0x8,%edx
   11725:	01 d0                	add    %edx,%eax
   11727:	c6 00 00             	movb   $0x0,(%eax)
    chunk[9 + keysize] = 0; /*compression method: 0*/
   1172a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1172d:	8b 55 f0             	mov    -0x10(%ebp),%edx
   11730:	83 c2 09             	add    $0x9,%edx
   11733:	01 d0                	add    %edx,%eax
   11735:	c6 00 00             	movb   $0x0,(%eax)
    lodepng_memcpy(chunk + 10 + keysize, compressed, compressedsize);
   11738:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1173b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1173e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   11741:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   11744:	83 c3 0a             	add    $0xa,%ebx
   11747:	01 d9                	add    %ebx,%ecx
   11749:	83 ec 04             	sub    $0x4,%esp
   1174c:	52                   	push   %edx
   1174d:	50                   	push   %eax
   1174e:	51                   	push   %ecx
   1174f:	e8 d1 1e ff ff       	call   3625 <lodepng_memcpy>
   11754:	83 c4 10             	add    $0x10,%esp
    lodepng_chunk_generate_crc(chunk);
   11757:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1175a:	83 ec 0c             	sub    $0xc,%esp
   1175d:	50                   	push   %eax
   1175e:	e8 a5 6f ff ff       	call   8708 <lodepng_chunk_generate_crc>
   11763:	83 c4 10             	add    $0x10,%esp
  }

  lodepng_free(compressed);
   11766:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11769:	83 ec 0c             	sub    $0xc,%esp
   1176c:	50                   	push   %eax
   1176d:	e8 96 1e ff ff       	call   3608 <lodepng_free>
   11772:	83 c4 10             	add    $0x10,%esp
  return error;
   11775:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11778:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1177b:	c9                   	leave  
   1177c:	c3                   	ret    

0001177d <filterScanline>:

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType) {
   1177d:	55                   	push   %ebp
   1177e:	89 e5                	mov    %esp,%ebp
   11780:	56                   	push   %esi
   11781:	53                   	push   %ebx
   11782:	83 ec 14             	sub    $0x14,%esp
   11785:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11788:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  switch(filterType) {
   1178b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
   1178f:	83 f8 04             	cmp    $0x4,%eax
   11792:	0f 87 41 03 00 00    	ja     11ad9 <filterScanline+0x35c>
   11798:	8b 04 85 70 a3 01 00 	mov    0x1a370(,%eax,4),%eax
   1179f:	ff e0                	jmp    *%eax
    case 0: /*None*/
      for(i = 0; i != length; ++i) out[i] = scanline[i];
   117a1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   117a8:	eb 19                	jmp    117c3 <filterScanline+0x46>
   117aa:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117ad:	8b 45 08             	mov    0x8(%ebp),%eax
   117b0:	01 c2                	add    %eax,%edx
   117b2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117b5:	8b 45 0c             	mov    0xc(%ebp),%eax
   117b8:	01 c8                	add    %ecx,%eax
   117ba:	0f b6 00             	movzbl (%eax),%eax
   117bd:	88 02                	mov    %al,(%edx)
   117bf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117c6:	3b 45 14             	cmp    0x14(%ebp),%eax
   117c9:	75 df                	jne    117aa <filterScanline+0x2d>
      break;
   117cb:	e9 0a 03 00 00       	jmp    11ada <filterScanline+0x35d>
    case 1: /*Sub*/
      for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   117d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   117d7:	eb 19                	jmp    117f2 <filterScanline+0x75>
   117d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
   117dc:	8b 45 08             	mov    0x8(%ebp),%eax
   117df:	01 c2                	add    %eax,%edx
   117e1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   117e4:	8b 45 0c             	mov    0xc(%ebp),%eax
   117e7:	01 c8                	add    %ecx,%eax
   117e9:	0f b6 00             	movzbl (%eax),%eax
   117ec:	88 02                	mov    %al,(%edx)
   117ee:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   117f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   117f5:	3b 45 18             	cmp    0x18(%ebp),%eax
   117f8:	75 df                	jne    117d9 <filterScanline+0x5c>
      for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
   117fa:	8b 45 18             	mov    0x18(%ebp),%eax
   117fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11800:	eb 2d                	jmp    1182f <filterScanline+0xb2>
   11802:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11805:	8b 45 08             	mov    0x8(%ebp),%eax
   11808:	01 c2                	add    %eax,%edx
   1180a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1180d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11810:	01 c8                	add    %ecx,%eax
   11812:	0f b6 08             	movzbl (%eax),%ecx
   11815:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11818:	2b 45 18             	sub    0x18(%ebp),%eax
   1181b:	89 c3                	mov    %eax,%ebx
   1181d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11820:	01 d8                	add    %ebx,%eax
   11822:	0f b6 00             	movzbl (%eax),%eax
   11825:	29 c1                	sub    %eax,%ecx
   11827:	89 c8                	mov    %ecx,%eax
   11829:	88 02                	mov    %al,(%edx)
   1182b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1182f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11832:	3b 45 14             	cmp    0x14(%ebp),%eax
   11835:	7c cb                	jl     11802 <filterScanline+0x85>
      break;
   11837:	e9 9e 02 00 00       	jmp    11ada <filterScanline+0x35d>
    case 2: /*Up*/
      if(prevline) {
   1183c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11840:	74 3e                	je     11880 <filterScanline+0x103>
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
   11842:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11849:	eb 28                	jmp    11873 <filterScanline+0xf6>
   1184b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1184e:	8b 45 08             	mov    0x8(%ebp),%eax
   11851:	01 d0                	add    %edx,%eax
   11853:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11856:	8b 55 0c             	mov    0xc(%ebp),%edx
   11859:	01 ca                	add    %ecx,%edx
   1185b:	0f b6 0a             	movzbl (%edx),%ecx
   1185e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   11861:	8b 55 10             	mov    0x10(%ebp),%edx
   11864:	01 da                	add    %ebx,%edx
   11866:	0f b6 12             	movzbl (%edx),%edx
   11869:	29 d1                	sub    %edx,%ecx
   1186b:	89 ca                	mov    %ecx,%edx
   1186d:	88 10                	mov    %dl,(%eax)
   1186f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11873:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11876:	3b 45 14             	cmp    0x14(%ebp),%eax
   11879:	75 d0                	jne    1184b <filterScanline+0xce>
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
      }
      break;
   1187b:	e9 5a 02 00 00       	jmp    11ada <filterScanline+0x35d>
      break;
    case 2: /*Up*/
      if(prevline) {
        for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
      } else {
        for(i = 0; i != length; ++i) out[i] = scanline[i];
   11880:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11887:	eb 19                	jmp    118a2 <filterScanline+0x125>
   11889:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1188c:	8b 45 08             	mov    0x8(%ebp),%eax
   1188f:	01 c2                	add    %eax,%edx
   11891:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11894:	8b 45 0c             	mov    0xc(%ebp),%eax
   11897:	01 c8                	add    %ecx,%eax
   11899:	0f b6 00             	movzbl (%eax),%eax
   1189c:	88 02                	mov    %al,(%edx)
   1189e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   118a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118a5:	3b 45 14             	cmp    0x14(%ebp),%eax
   118a8:	75 df                	jne    11889 <filterScanline+0x10c>
      }
      break;
   118aa:	e9 2b 02 00 00       	jmp    11ada <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
   118af:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   118b3:	0f 84 90 00 00 00    	je     11949 <filterScanline+0x1cc>
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
   118b9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   118c0:	eb 28                	jmp    118ea <filterScanline+0x16d>
   118c2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   118c5:	8b 45 08             	mov    0x8(%ebp),%eax
   118c8:	01 d0                	add    %edx,%eax
   118ca:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   118cd:	8b 55 0c             	mov    0xc(%ebp),%edx
   118d0:	01 ca                	add    %ecx,%edx
   118d2:	0f b6 12             	movzbl (%edx),%edx
   118d5:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   118d8:	8b 4d 10             	mov    0x10(%ebp),%ecx
   118db:	01 d9                	add    %ebx,%ecx
   118dd:	0f b6 09             	movzbl (%ecx),%ecx
   118e0:	d0 e9                	shr    %cl
   118e2:	29 ca                	sub    %ecx,%edx
   118e4:	88 10                	mov    %dl,(%eax)
   118e6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   118ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
   118ed:	3b 45 18             	cmp    0x18(%ebp),%eax
   118f0:	75 d0                	jne    118c2 <filterScanline+0x145>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
   118f2:	8b 45 18             	mov    0x18(%ebp),%eax
   118f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
   118f8:	eb 42                	jmp    1193c <filterScanline+0x1bf>
   118fa:	8b 55 f4             	mov    -0xc(%ebp),%edx
   118fd:	8b 45 08             	mov    0x8(%ebp),%eax
   11900:	01 c2                	add    %eax,%edx
   11902:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11905:	8b 45 0c             	mov    0xc(%ebp),%eax
   11908:	01 c8                	add    %ecx,%eax
   1190a:	0f b6 08             	movzbl (%eax),%ecx
   1190d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11910:	2b 45 18             	sub    0x18(%ebp),%eax
   11913:	89 c3                	mov    %eax,%ebx
   11915:	8b 45 0c             	mov    0xc(%ebp),%eax
   11918:	01 d8                	add    %ebx,%eax
   1191a:	0f b6 00             	movzbl (%eax),%eax
   1191d:	0f b6 d8             	movzbl %al,%ebx
   11920:	8b 75 f4             	mov    -0xc(%ebp),%esi
   11923:	8b 45 10             	mov    0x10(%ebp),%eax
   11926:	01 f0                	add    %esi,%eax
   11928:	0f b6 00             	movzbl (%eax),%eax
   1192b:	0f b6 c0             	movzbl %al,%eax
   1192e:	01 d8                	add    %ebx,%eax
   11930:	d1 f8                	sar    %eax
   11932:	29 c1                	sub    %eax,%ecx
   11934:	89 c8                	mov    %ecx,%eax
   11936:	88 02                	mov    %al,(%edx)
   11938:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1193c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1193f:	3b 45 14             	cmp    0x14(%ebp),%eax
   11942:	7c b6                	jl     118fa <filterScanline+0x17d>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
      }
      break;
   11944:	e9 91 01 00 00       	jmp    11ada <filterScanline+0x35d>
    case 3: /*Average*/
      if(prevline) {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - (prevline[i] >> 1);
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) >> 1);
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11949:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11950:	eb 19                	jmp    1196b <filterScanline+0x1ee>
   11952:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11955:	8b 45 08             	mov    0x8(%ebp),%eax
   11958:	01 c2                	add    %eax,%edx
   1195a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1195d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11960:	01 c8                	add    %ecx,%eax
   11962:	0f b6 00             	movzbl (%eax),%eax
   11965:	88 02                	mov    %al,(%edx)
   11967:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1196b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1196e:	3b 45 18             	cmp    0x18(%ebp),%eax
   11971:	75 df                	jne    11952 <filterScanline+0x1d5>
        for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - (scanline[i - bytewidth] >> 1);
   11973:	8b 45 18             	mov    0x18(%ebp),%eax
   11976:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11979:	eb 2f                	jmp    119aa <filterScanline+0x22d>
   1197b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1197e:	8b 45 08             	mov    0x8(%ebp),%eax
   11981:	01 c2                	add    %eax,%edx
   11983:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11986:	8b 45 0c             	mov    0xc(%ebp),%eax
   11989:	01 c8                	add    %ecx,%eax
   1198b:	0f b6 08             	movzbl (%eax),%ecx
   1198e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11991:	2b 45 18             	sub    0x18(%ebp),%eax
   11994:	89 c3                	mov    %eax,%ebx
   11996:	8b 45 0c             	mov    0xc(%ebp),%eax
   11999:	01 d8                	add    %ebx,%eax
   1199b:	0f b6 00             	movzbl (%eax),%eax
   1199e:	d0 e8                	shr    %al
   119a0:	29 c1                	sub    %eax,%ecx
   119a2:	89 c8                	mov    %ecx,%eax
   119a4:	88 02                	mov    %al,(%edx)
   119a6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   119aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
   119ad:	3b 45 14             	cmp    0x14(%ebp),%eax
   119b0:	7c c9                	jl     1197b <filterScanline+0x1fe>
      }
      break;
   119b2:	e9 23 01 00 00       	jmp    11ada <filterScanline+0x35d>
    case 4: /*Paeth*/
      if(prevline) {
   119b7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   119bb:	0f 84 af 00 00 00    	je     11a70 <filterScanline+0x2f3>
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
   119c1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   119c8:	eb 28                	jmp    119f2 <filterScanline+0x275>
   119ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
   119cd:	8b 45 08             	mov    0x8(%ebp),%eax
   119d0:	01 d0                	add    %edx,%eax
   119d2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   119d5:	8b 55 0c             	mov    0xc(%ebp),%edx
   119d8:	01 ca                	add    %ecx,%edx
   119da:	0f b6 0a             	movzbl (%edx),%ecx
   119dd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
   119e0:	8b 55 10             	mov    0x10(%ebp),%edx
   119e3:	01 da                	add    %ebx,%edx
   119e5:	0f b6 12             	movzbl (%edx),%edx
   119e8:	29 d1                	sub    %edx,%ecx
   119ea:	89 ca                	mov    %ecx,%edx
   119ec:	88 10                	mov    %dl,(%eax)
   119ee:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   119f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   119f5:	3b 45 18             	cmp    0x18(%ebp),%eax
   119f8:	75 d0                	jne    119ca <filterScanline+0x24d>
        for(i = bytewidth; i < length; ++i) {
   119fa:	8b 45 18             	mov    0x18(%ebp),%eax
   119fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11a00:	eb 64                	jmp    11a66 <filterScanline+0x2e9>
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
   11a02:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a05:	8b 45 08             	mov    0x8(%ebp),%eax
   11a08:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   11a0b:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a0e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a11:	01 d0                	add    %edx,%eax
   11a13:	0f b6 00             	movzbl (%eax),%eax
   11a16:	88 45 e7             	mov    %al,-0x19(%ebp)
   11a19:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a1c:	2b 45 18             	sub    0x18(%ebp),%eax
   11a1f:	89 c2                	mov    %eax,%edx
   11a21:	8b 45 10             	mov    0x10(%ebp),%eax
   11a24:	01 d0                	add    %edx,%eax
   11a26:	0f b6 00             	movzbl (%eax),%eax
   11a29:	0f b6 c8             	movzbl %al,%ecx
   11a2c:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a2f:	8b 45 10             	mov    0x10(%ebp),%eax
   11a32:	01 d0                	add    %edx,%eax
   11a34:	0f b6 00             	movzbl (%eax),%eax
   11a37:	0f b6 d0             	movzbl %al,%edx
   11a3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a3d:	2b 45 18             	sub    0x18(%ebp),%eax
   11a40:	89 c6                	mov    %eax,%esi
   11a42:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a45:	01 f0                	add    %esi,%eax
   11a47:	0f b6 00             	movzbl (%eax),%eax
   11a4a:	0f b6 c0             	movzbl %al,%eax
   11a4d:	51                   	push   %ecx
   11a4e:	52                   	push   %edx
   11a4f:	50                   	push   %eax
   11a50:	e8 49 b8 ff ff       	call   d29e <paethPredictor>
   11a55:	83 c4 0c             	add    $0xc,%esp
   11a58:	0f b6 4d e7          	movzbl -0x19(%ebp),%ecx
   11a5c:	29 c1                	sub    %eax,%ecx
   11a5e:	89 c8                	mov    %ecx,%eax
   11a60:	88 03                	mov    %al,(%ebx)
      break;
    case 4: /*Paeth*/
      if(prevline) {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
   11a62:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11a66:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a69:	3b 45 14             	cmp    0x14(%ebp),%eax
   11a6c:	7c 94                	jl     11a02 <filterScanline+0x285>
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
   11a6e:	eb 6a                	jmp    11ada <filterScanline+0x35d>
        for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; ++i) {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      } else {
        for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
   11a70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11a77:	eb 19                	jmp    11a92 <filterScanline+0x315>
   11a79:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11a7c:	8b 45 08             	mov    0x8(%ebp),%eax
   11a7f:	01 c2                	add    %eax,%edx
   11a81:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11a84:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a87:	01 c8                	add    %ecx,%eax
   11a89:	0f b6 00             	movzbl (%eax),%eax
   11a8c:	88 02                	mov    %al,(%edx)
   11a8e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11a92:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11a95:	3b 45 18             	cmp    0x18(%ebp),%eax
   11a98:	75 df                	jne    11a79 <filterScanline+0x2fc>
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
   11a9a:	8b 45 18             	mov    0x18(%ebp),%eax
   11a9d:	89 45 f4             	mov    %eax,-0xc(%ebp)
   11aa0:	eb 2d                	jmp    11acf <filterScanline+0x352>
   11aa2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11aa5:	8b 45 08             	mov    0x8(%ebp),%eax
   11aa8:	01 c2                	add    %eax,%edx
   11aaa:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11aad:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ab0:	01 c8                	add    %ecx,%eax
   11ab2:	0f b6 08             	movzbl (%eax),%ecx
   11ab5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ab8:	2b 45 18             	sub    0x18(%ebp),%eax
   11abb:	89 c3                	mov    %eax,%ebx
   11abd:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ac0:	01 d8                	add    %ebx,%eax
   11ac2:	0f b6 00             	movzbl (%eax),%eax
   11ac5:	29 c1                	sub    %eax,%ecx
   11ac7:	89 c8                	mov    %ecx,%eax
   11ac9:	88 02                	mov    %al,(%edx)
   11acb:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11acf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ad2:	3b 45 14             	cmp    0x14(%ebp),%eax
   11ad5:	7c cb                	jl     11aa2 <filterScanline+0x325>
      }
      break;
   11ad7:	eb 01                	jmp    11ada <filterScanline+0x35d>
    default: return; /*invalid filter type given*/
   11ad9:	90                   	nop
  }
}
   11ada:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11add:	5b                   	pop    %ebx
   11ade:	5e                   	pop    %esi
   11adf:	5d                   	pop    %ebp
   11ae0:	c3                   	ret    

00011ae1 <ilog2>:

/* integer binary logarithm, max return value is 31 */
static size_t ilog2(size_t i) {
   11ae1:	55                   	push   %ebp
   11ae2:	89 e5                	mov    %esp,%ebp
   11ae4:	83 ec 10             	sub    $0x10,%esp
  size_t result = 0;
   11ae7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if(i >= 65536) { result += 16; i >>= 16; }
   11aee:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
   11af5:	7e 08                	jle    11aff <ilog2+0x1e>
   11af7:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
   11afb:	c1 7d 08 10          	sarl   $0x10,0x8(%ebp)
  if(i >= 256) { result += 8; i >>= 8; }
   11aff:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   11b06:	7e 08                	jle    11b10 <ilog2+0x2f>
   11b08:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
   11b0c:	c1 7d 08 08          	sarl   $0x8,0x8(%ebp)
  if(i >= 16) { result += 4; i >>= 4; }
   11b10:	83 7d 08 0f          	cmpl   $0xf,0x8(%ebp)
   11b14:	7e 08                	jle    11b1e <ilog2+0x3d>
   11b16:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
   11b1a:	c1 7d 08 04          	sarl   $0x4,0x8(%ebp)
  if(i >= 4) { result += 2; i >>= 2; }
   11b1e:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
   11b22:	7e 08                	jle    11b2c <ilog2+0x4b>
   11b24:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
   11b28:	c1 7d 08 02          	sarl   $0x2,0x8(%ebp)
  if(i >= 2) { result += 1; /*i >>= 1;*/ }
   11b2c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
   11b30:	7e 04                	jle    11b36 <ilog2+0x55>
   11b32:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return result;
   11b36:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11b39:	c9                   	leave  
   11b3a:	c3                   	ret    

00011b3b <ilog2i>:

/* integer approximation for i * log2(i), helper function for LFS_ENTROPY */
static size_t ilog2i(size_t i) {
   11b3b:	55                   	push   %ebp
   11b3c:	89 e5                	mov    %esp,%ebp
   11b3e:	56                   	push   %esi
   11b3f:	53                   	push   %ebx
   11b40:	83 ec 10             	sub    $0x10,%esp
  size_t l;
  if(i == 0) return 0;
   11b43:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11b47:	75 07                	jne    11b50 <ilog2i+0x15>
   11b49:	b8 00 00 00 00       	mov    $0x0,%eax
   11b4e:	eb 30                	jmp    11b80 <ilog2i+0x45>
  l = ilog2(i);
   11b50:	ff 75 08             	pushl  0x8(%ebp)
   11b53:	e8 89 ff ff ff       	call   11ae1 <ilog2>
   11b58:	83 c4 04             	add    $0x4,%esp
   11b5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* approximate i*log2(i): l is integer logarithm, ((i - (1u << l)) << 1u)
  linearly approximates the missing fractional part multiplied by i */
  return i * l + ((i - (1u << l)) << 1u);
   11b5e:	8b 45 08             	mov    0x8(%ebp),%eax
   11b61:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   11b65:	89 c3                	mov    %eax,%ebx
   11b67:	8b 55 08             	mov    0x8(%ebp),%edx
   11b6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11b6d:	be 01 00 00 00       	mov    $0x1,%esi
   11b72:	89 c1                	mov    %eax,%ecx
   11b74:	d3 e6                	shl    %cl,%esi
   11b76:	89 f0                	mov    %esi,%eax
   11b78:	29 c2                	sub    %eax,%edx
   11b7a:	89 d0                	mov    %edx,%eax
   11b7c:	01 c0                	add    %eax,%eax
   11b7e:	01 d8                	add    %ebx,%eax
}
   11b80:	8d 65 f8             	lea    -0x8(%ebp),%esp
   11b83:	5b                   	pop    %ebx
   11b84:	5e                   	pop    %esi
   11b85:	5d                   	pop    %ebp
   11b86:	c3                   	ret    

00011b87 <filter>:

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* color, const LodePNGEncoderSettings* settings) {
   11b87:	55                   	push   %ebp
   11b88:	89 e5                	mov    %esp,%ebp
   11b8a:	53                   	push   %ebx
   11b8b:	81 ec c4 04 00 00    	sub    $0x4c4,%esp
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7u) / 8u, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(color);
   11b91:	ff 75 18             	pushl  0x18(%ebp)
   11b94:	e8 6a 75 ff ff       	call   9103 <lodepng_get_bpp>
   11b99:	83 c4 04             	add    $0x4,%esp
   11b9c:	89 45 b8             	mov    %eax,-0x48(%ebp)
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = lodepng_get_raw_size_idat(w, 1, bpp) - 1u;
   11b9f:	ff 75 b8             	pushl  -0x48(%ebp)
   11ba2:	6a 01                	push   $0x1
   11ba4:	ff 75 10             	pushl  0x10(%ebp)
   11ba7:	e8 b6 76 ff ff       	call   9262 <lodepng_get_raw_size_idat>
   11bac:	83 c4 0c             	add    $0xc,%esp
   11baf:	83 e8 01             	sub    $0x1,%eax
   11bb2:	89 45 b4             	mov    %eax,-0x4c(%ebp)

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7u) / 8u;
   11bb5:	8b 45 b8             	mov    -0x48(%ebp),%eax
   11bb8:	83 c0 07             	add    $0x7,%eax
   11bbb:	c1 e8 03             	shr    $0x3,%eax
   11bbe:	89 45 b0             	mov    %eax,-0x50(%ebp)
  const unsigned char* prevline = 0;
   11bc1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  unsigned x, y;
  unsigned error = 0;
   11bc8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  LodePNGFilterStrategy strategy = settings->filter_strategy;
   11bcf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11bd2:	8b 40 2c             	mov    0x2c(%eax),%eax
   11bd5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11bd8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   11bdb:	8b 40 28             	mov    0x28(%eax),%eax
   11bde:	85 c0                	test   %eax,%eax
   11be0:	74 1c                	je     11bfe <filter+0x77>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11be2:	8b 45 18             	mov    0x18(%ebp),%eax
   11be5:	8b 00                	mov    (%eax),%eax
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.
  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
   11be7:	83 f8 03             	cmp    $0x3,%eax
   11bea:	74 0b                	je     11bf7 <filter+0x70>
     (color->colortype == LCT_PALETTE || color->bitdepth < 8)) strategy = LFS_ZERO;
   11bec:	8b 45 18             	mov    0x18(%ebp),%eax
   11bef:	8b 40 04             	mov    0x4(%eax),%eax
   11bf2:	83 f8 07             	cmp    $0x7,%eax
   11bf5:	77 07                	ja     11bfe <filter+0x77>
   11bf7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/
   11bfe:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
   11c02:	75 0a                	jne    11c0e <filter+0x87>
   11c04:	b8 1f 00 00 00       	mov    $0x1f,%eax
   11c09:	e9 5b 07 00 00       	jmp    12369 <filter+0x7e2>

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
   11c0e:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
   11c12:	77 7b                	ja     11c8f <filter+0x108>
    unsigned char type = (unsigned char)strategy;
   11c14:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   11c17:	88 45 a1             	mov    %al,-0x5f(%ebp)
    for(y = 0; y != h; ++y) {
   11c1a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11c21:	eb 5f                	jmp    11c82 <filter+0xfb>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   11c23:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c26:	83 c0 01             	add    $0x1,%eax
   11c29:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c2d:	89 45 9c             	mov    %eax,-0x64(%ebp)
      size_t inindex = linebytes * y;
   11c30:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11c33:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11c37:	89 45 98             	mov    %eax,-0x68(%ebp)
      out[outindex] = type; /*filter type byte*/
   11c3a:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11c3d:	8b 45 08             	mov    0x8(%ebp),%eax
   11c40:	01 c2                	add    %eax,%edx
   11c42:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11c46:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   11c48:	0f b6 45 a1          	movzbl -0x5f(%ebp),%eax
   11c4c:	8b 4d 98             	mov    -0x68(%ebp),%ecx
   11c4f:	8b 55 0c             	mov    0xc(%ebp),%edx
   11c52:	01 d1                	add    %edx,%ecx
   11c54:	8b 55 9c             	mov    -0x64(%ebp),%edx
   11c57:	8d 5a 01             	lea    0x1(%edx),%ebx
   11c5a:	8b 55 08             	mov    0x8(%ebp),%edx
   11c5d:	01 da                	add    %ebx,%edx
   11c5f:	50                   	push   %eax
   11c60:	ff 75 b0             	pushl  -0x50(%ebp)
   11c63:	ff 75 b4             	pushl  -0x4c(%ebp)
   11c66:	ff 75 f4             	pushl  -0xc(%ebp)
   11c69:	51                   	push   %ecx
   11c6a:	52                   	push   %edx
   11c6b:	e8 0d fb ff ff       	call   1177d <filterScanline>
   11c70:	83 c4 18             	add    $0x18,%esp
      prevline = &in[inindex];
   11c73:	8b 55 98             	mov    -0x68(%ebp),%edx
   11c76:	8b 45 0c             	mov    0xc(%ebp),%eax
   11c79:	01 d0                	add    %edx,%eax
   11c7b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy >= LFS_ZERO && strategy <= LFS_FOUR) {
    unsigned char type = (unsigned char)strategy;
    for(y = 0; y != h; ++y) {
   11c7e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11c82:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11c85:	3b 45 14             	cmp    0x14(%ebp),%eax
   11c88:	75 99                	jne    11c23 <filter+0x9c>
   11c8a:	e9 d7 06 00 00       	jmp    12366 <filter+0x7df>
      size_t inindex = linebytes * y;
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_MINSUM) {
   11c8f:	83 7d e4 05          	cmpl   $0x5,-0x1c(%ebp)
   11c93:	0f 85 e3 01 00 00    	jne    11e7c <filter+0x2f5>
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   11c99:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    unsigned char type, bestType = 0;
   11ca0:	c6 45 de 00          	movb   $0x0,-0x22(%ebp)

    for(type = 0; type != 5; ++type) {
   11ca4:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11ca8:	eb 2d                	jmp    11cd7 <filter+0x150>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11caa:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
   11cae:	83 ec 0c             	sub    $0xc,%esp
   11cb1:	ff 75 b4             	pushl  -0x4c(%ebp)
   11cb4:	e8 2e 19 ff ff       	call   35e7 <lodepng_malloc>
   11cb9:	83 c4 10             	add    $0x10,%esp
   11cbc:	89 44 9d 84          	mov    %eax,-0x7c(%ebp,%ebx,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11cc0:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11cc4:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11cc8:	85 c0                	test   %eax,%eax
   11cca:	75 07                	jne    11cd3 <filter+0x14c>
   11ccc:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    /*adaptive filtering*/
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned char type, bestType = 0;

    for(type = 0; type != 5; ++type) {
   11cd3:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11cd7:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11cdb:	75 cd                	jne    11caa <filter+0x123>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11cdd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11ce1:	0f 85 6c 01 00 00    	jne    11e53 <filter+0x2cc>
      for(y = 0; y != h; ++y) {
   11ce7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11cee:	e9 54 01 00 00       	jmp    11e47 <filter+0x2c0>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11cf3:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11cf7:	e9 d5 00 00 00       	jmp    11dd1 <filter+0x24a>
          size_t sum = 0;
   11cfc:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11d03:	0f b6 55 df          	movzbl -0x21(%ebp),%edx
   11d07:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d0a:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11d0e:	89 c1                	mov    %eax,%ecx
   11d10:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d13:	01 c1                	add    %eax,%ecx
   11d15:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11d19:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11d1d:	83 ec 08             	sub    $0x8,%esp
   11d20:	52                   	push   %edx
   11d21:	ff 75 b0             	pushl  -0x50(%ebp)
   11d24:	ff 75 b4             	pushl  -0x4c(%ebp)
   11d27:	ff 75 f4             	pushl  -0xc(%ebp)
   11d2a:	51                   	push   %ecx
   11d2b:	50                   	push   %eax
   11d2c:	e8 4c fa ff ff       	call   1177d <filterScanline>
   11d31:	83 c4 20             	add    $0x20,%esp

          /*calculate the sum of the result*/
          if(type == 0) {
   11d34:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11d38:	75 2d                	jne    11d67 <filter+0x1e0>
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
   11d3a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d41:	eb 1a                	jmp    11d5d <filter+0x1d6>
   11d43:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11d47:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11d4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d4e:	01 d0                	add    %edx,%eax
   11d50:	0f b6 00             	movzbl (%eax),%eax
   11d53:	0f b6 c0             	movzbl %al,%eax
   11d56:	01 45 d8             	add    %eax,-0x28(%ebp)
   11d59:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11d5d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11d60:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11d63:	75 de                	jne    11d43 <filter+0x1bc>
   11d65:	eb 4b                	jmp    11db2 <filter+0x22b>
          } else {
            for(x = 0; x != linebytes; ++x) {
   11d67:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11d6e:	eb 3a                	jmp    11daa <filter+0x223>
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              unsigned char s = attempt[type][x];
   11d70:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11d74:	8b 54 85 84          	mov    -0x7c(%ebp,%eax,4),%edx
   11d78:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11d7b:	01 d0                	add    %edx,%eax
   11d7d:	0f b6 00             	movzbl (%eax),%eax
   11d80:	88 45 a2             	mov    %al,-0x5e(%ebp)
              sum += s < 128 ? s : (255U - s);
   11d83:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11d87:	84 c0                	test   %al,%al
   11d89:	78 06                	js     11d91 <filter+0x20a>
   11d8b:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11d8f:	eb 0d                	jmp    11d9e <filter+0x217>
   11d91:	0f b6 45 a2          	movzbl -0x5e(%ebp),%eax
   11d95:	ba ff 00 00 00       	mov    $0xff,%edx
   11d9a:	29 c2                	sub    %eax,%edx
   11d9c:	89 d0                	mov    %edx,%eax
   11d9e:	8b 55 d8             	mov    -0x28(%ebp),%edx
   11da1:	01 d0                	add    %edx,%eax
   11da3:	89 45 d8             	mov    %eax,-0x28(%ebp)

          /*calculate the sum of the result*/
          if(type == 0) {
            for(x = 0; x != linebytes; ++x) sum += (unsigned char)(attempt[type][x]);
          } else {
            for(x = 0; x != linebytes; ++x) {
   11da6:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11daa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11dad:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11db0:	75 be                	jne    11d70 <filter+0x1e9>
              sum += s < 128 ? s : (255U - s);
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum < smallest) {
   11db2:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
   11db6:	74 08                	je     11dc0 <filter+0x239>
   11db8:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11dbb:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   11dbe:	7d 0d                	jge    11dcd <filter+0x246>
            bestType = type;
   11dc0:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11dc4:	88 45 de             	mov    %al,-0x22(%ebp)
            smallest = sum;
   11dc7:	8b 45 d8             	mov    -0x28(%ebp),%eax
   11dca:	89 45 e0             	mov    %eax,-0x20(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11dcd:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11dd1:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11dd5:	0f 85 21 ff ff ff    	jne    11cfc <filter+0x175>
            bestType = type;
            smallest = sum;
          }
        }

        prevline = &in[y * linebytes];
   11ddb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11dde:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11de2:	89 c2                	mov    %eax,%edx
   11de4:	8b 45 0c             	mov    0xc(%ebp),%eax
   11de7:	01 d0                	add    %edx,%eax
   11de9:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   11dec:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11def:	83 c0 01             	add    $0x1,%eax
   11df2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11df6:	89 c2                	mov    %eax,%edx
   11df8:	8b 45 08             	mov    0x8(%ebp),%eax
   11dfb:	01 c2                	add    %eax,%edx
   11dfd:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11e01:	88 02                	mov    %al,(%edx)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   11e03:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11e0a:	eb 2f                	jmp    11e3b <filter+0x2b4>
   11e0c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e0f:	83 c0 01             	add    $0x1,%eax
   11e12:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11e16:	89 c2                	mov    %eax,%edx
   11e18:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e1b:	01 d0                	add    %edx,%eax
   11e1d:	8d 50 01             	lea    0x1(%eax),%edx
   11e20:	8b 45 08             	mov    0x8(%ebp),%eax
   11e23:	01 c2                	add    %eax,%edx
   11e25:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
   11e29:	8b 4c 85 84          	mov    -0x7c(%ebp,%eax,4),%ecx
   11e2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e30:	01 c8                	add    %ecx,%eax
   11e32:	0f b6 00             	movzbl (%eax),%eax
   11e35:	88 02                	mov    %al,(%edx)
   11e37:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11e3b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11e3e:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11e41:	75 c9                	jne    11e0c <filter+0x285>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   11e43:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11e47:	8b 45 ec             	mov    -0x14(%ebp),%eax
   11e4a:	3b 45 14             	cmp    0x14(%ebp),%eax
   11e4d:	0f 85 a0 fe ff ff    	jne    11cf3 <filter+0x16c>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   11e53:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
   11e57:	eb 18                	jmp    11e71 <filter+0x2ea>
   11e59:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
   11e5d:	8b 44 85 84          	mov    -0x7c(%ebp,%eax,4),%eax
   11e61:	83 ec 0c             	sub    $0xc,%esp
   11e64:	50                   	push   %eax
   11e65:	e8 9e 17 ff ff       	call   3608 <lodepng_free>
   11e6a:	83 c4 10             	add    $0x10,%esp
   11e6d:	80 45 df 01          	addb   $0x1,-0x21(%ebp)
   11e71:	80 7d df 05          	cmpb   $0x5,-0x21(%ebp)
   11e75:	75 e2                	jne    11e59 <filter+0x2d2>
   11e77:	e9 ea 04 00 00       	jmp    12366 <filter+0x7df>
  } else if(strategy == LFS_ENTROPY) {
   11e7c:	83 7d e4 06          	cmpl   $0x6,-0x1c(%ebp)
   11e80:	0f 85 17 02 00 00    	jne    1209d <filter+0x516>
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
   11e86:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
    unsigned type, bestType = 0;
   11e8d:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11e94:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11e9b:	eb 33                	jmp    11ed0 <filter+0x349>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   11e9d:	83 ec 0c             	sub    $0xc,%esp
   11ea0:	ff 75 b4             	pushl  -0x4c(%ebp)
   11ea3:	e8 3f 17 ff ff       	call   35e7 <lodepng_malloc>
   11ea8:	83 c4 10             	add    $0x10,%esp
   11eab:	89 c2                	mov    %eax,%edx
   11ead:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11eb0:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   11eb7:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11eba:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11ec1:	85 c0                	test   %eax,%eax
   11ec3:	75 07                	jne    11ecc <filter+0x345>
   11ec5:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t bestSum = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type != 5; ++type) {
   11ecc:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11ed0:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11ed4:	75 c7                	jne    11e9d <filter+0x316>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
   11ed6:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   11eda:	0f 85 8f 01 00 00    	jne    1206f <filter+0x4e8>
      for(y = 0; y != h; ++y) {
   11ee0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11ee7:	e9 77 01 00 00       	jmp    12063 <filter+0x4dc>
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11eec:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   11ef3:	e9 f4 00 00 00       	jmp    11fec <filter+0x465>
          size_t sum = 0;
   11ef8:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   11eff:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11f02:	0f b6 d0             	movzbl %al,%edx
   11f05:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f08:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11f0c:	89 c1                	mov    %eax,%ecx
   11f0e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11f11:	01 c1                	add    %eax,%ecx
   11f13:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11f16:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   11f1d:	83 ec 08             	sub    $0x8,%esp
   11f20:	52                   	push   %edx
   11f21:	ff 75 b0             	pushl  -0x50(%ebp)
   11f24:	ff 75 b4             	pushl  -0x4c(%ebp)
   11f27:	ff 75 f4             	pushl  -0xc(%ebp)
   11f2a:	51                   	push   %ecx
   11f2b:	50                   	push   %eax
   11f2c:	e8 4c f8 ff ff       	call   1177d <filterScanline>
   11f31:	83 c4 20             	add    $0x20,%esp
          lodepng_memset(count, 0, 256 * sizeof(*count));
   11f34:	83 ec 04             	sub    $0x4,%esp
   11f37:	68 00 04 00 00       	push   $0x400
   11f3c:	6a 00                	push   $0x0
   11f3e:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   11f44:	50                   	push   %eax
   11f45:	e8 0e 17 ff ff       	call   3658 <lodepng_memset>
   11f4a:	83 c4 10             	add    $0x10,%esp
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
   11f4d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11f54:	eb 2a                	jmp    11f80 <filter+0x3f9>
   11f56:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11f59:	8b 94 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%edx
   11f60:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11f63:	01 d0                	add    %edx,%eax
   11f65:	0f b6 00             	movzbl (%eax),%eax
   11f68:	0f b6 c0             	movzbl %al,%eax
   11f6b:	8b 94 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%edx
   11f72:	83 c2 01             	add    $0x1,%edx
   11f75:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
   11f7c:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11f80:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11f83:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   11f86:	75 ce                	jne    11f56 <filter+0x3cf>
          ++count[type]; /*the filter type itself is part of the scanline*/
   11f88:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11f8b:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11f92:	8d 50 01             	lea    0x1(%eax),%edx
   11f95:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11f98:	89 94 85 44 fb ff ff 	mov    %edx,-0x4bc(%ebp,%eax,4)
          for(x = 0; x != 256; ++x) {
   11f9f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   11fa6:	eb 1d                	jmp    11fc5 <filter+0x43e>
            sum += ilog2i(count[x]);
   11fa8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11fab:	8b 84 85 44 fb ff ff 	mov    -0x4bc(%ebp,%eax,4),%eax
   11fb2:	83 ec 0c             	sub    $0xc,%esp
   11fb5:	50                   	push   %eax
   11fb6:	e8 80 fb ff ff       	call   11b3b <ilog2i>
   11fbb:	83 c4 10             	add    $0x10,%esp
   11fbe:	01 45 c8             	add    %eax,-0x38(%ebp)
          size_t sum = 0;
          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
          lodepng_memset(count, 0, 256 * sizeof(*count));
          for(x = 0; x != linebytes; ++x) ++count[attempt[type][x]];
          ++count[type]; /*the filter type itself is part of the scanline*/
          for(x = 0; x != 256; ++x) {
   11fc1:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   11fc5:	81 7d f0 00 01 00 00 	cmpl   $0x100,-0x10(%ebp)
   11fcc:	75 da                	jne    11fa8 <filter+0x421>
            sum += ilog2i(count[x]);
          }
          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum > bestSum) {
   11fce:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   11fd2:	74 08                	je     11fdc <filter+0x455>
   11fd4:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11fd7:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
   11fda:	7e 0c                	jle    11fe8 <filter+0x461>
            bestType = type;
   11fdc:	8b 45 d0             	mov    -0x30(%ebp),%eax
   11fdf:	89 45 cc             	mov    %eax,-0x34(%ebp)
            bestSum = sum;
   11fe2:	8b 45 c8             	mov    -0x38(%ebp),%eax
   11fe5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
        /*try the 5 filter types*/
        for(type = 0; type != 5; ++type) {
   11fe8:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   11fec:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   11ff0:	0f 85 02 ff ff ff    	jne    11ef8 <filter+0x371>
            bestType = type;
            bestSum = sum;
          }
        }

        prevline = &in[y * linebytes];
   11ff6:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   11ff9:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   11ffd:	89 c2                	mov    %eax,%edx
   11fff:	8b 45 0c             	mov    0xc(%ebp),%eax
   12002:	01 d0                	add    %edx,%eax
   12004:	89 45 f4             	mov    %eax,-0xc(%ebp)

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   12007:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1200a:	83 c0 01             	add    $0x1,%eax
   1200d:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12011:	89 c2                	mov    %eax,%edx
   12013:	8b 45 08             	mov    0x8(%ebp),%eax
   12016:	01 d0                	add    %edx,%eax
   12018:	8b 55 cc             	mov    -0x34(%ebp),%edx
   1201b:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   1201d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   12024:	eb 31                	jmp    12057 <filter+0x4d0>
   12026:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   12029:	83 c0 01             	add    $0x1,%eax
   1202c:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   12030:	89 c2                	mov    %eax,%edx
   12032:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12035:	01 d0                	add    %edx,%eax
   12037:	8d 50 01             	lea    0x1(%eax),%edx
   1203a:	8b 45 08             	mov    0x8(%ebp),%eax
   1203d:	01 c2                	add    %eax,%edx
   1203f:	8b 45 cc             	mov    -0x34(%ebp),%eax
   12042:	8b 8c 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%ecx
   12049:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1204c:	01 c8                	add    %ecx,%eax
   1204e:	0f b6 00             	movzbl (%eax),%eax
   12051:	88 02                	mov    %al,(%edx)
   12053:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12057:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1205a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   1205d:	75 c7                	jne    12026 <filter+0x49f>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }

    if(!error) {
      for(y = 0; y != h; ++y) {
   1205f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12063:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12066:	3b 45 14             	cmp    0x14(%ebp),%eax
   12069:	0f 85 7d fe ff ff    	jne    11eec <filter+0x365>
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   1206f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
   12076:	eb 1a                	jmp    12092 <filter+0x50b>
   12078:	8b 45 d0             	mov    -0x30(%ebp),%eax
   1207b:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
   12082:	83 ec 0c             	sub    $0xc,%esp
   12085:	50                   	push   %eax
   12086:	e8 7d 15 ff ff       	call   3608 <lodepng_free>
   1208b:	83 c4 10             	add    $0x10,%esp
   1208e:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
   12092:	83 7d d0 05          	cmpl   $0x5,-0x30(%ebp)
   12096:	75 e0                	jne    12078 <filter+0x4f1>
   12098:	e9 c9 02 00 00       	jmp    12366 <filter+0x7df>
  } else if(strategy == LFS_PREDEFINED) {
   1209d:	83 7d e4 08          	cmpl   $0x8,-0x1c(%ebp)
   120a1:	0f 85 89 00 00 00    	jne    12130 <filter+0x5a9>
    for(y = 0; y != h; ++y) {
   120a7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   120ae:	eb 73                	jmp    12123 <filter+0x59c>
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
   120b0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120b3:	83 c0 01             	add    $0x1,%eax
   120b6:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   120ba:	89 45 a8             	mov    %eax,-0x58(%ebp)
      size_t inindex = linebytes * y;
   120bd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   120c0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   120c4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
      unsigned char type = settings->predefined_filters[y];
   120c7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   120ca:	8b 50 30             	mov    0x30(%eax),%edx
   120cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
   120d0:	01 d0                	add    %edx,%eax
   120d2:	0f b6 00             	movzbl (%eax),%eax
   120d5:	88 45 a3             	mov    %al,-0x5d(%ebp)
      out[outindex] = type; /*filter type byte*/
   120d8:	8b 55 a8             	mov    -0x58(%ebp),%edx
   120db:	8b 45 08             	mov    0x8(%ebp),%eax
   120de:	01 c2                	add    %eax,%edx
   120e0:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   120e4:	88 02                	mov    %al,(%edx)
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
   120e6:	0f b6 45 a3          	movzbl -0x5d(%ebp),%eax
   120ea:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
   120ed:	8b 55 0c             	mov    0xc(%ebp),%edx
   120f0:	01 d1                	add    %edx,%ecx
   120f2:	8b 55 a8             	mov    -0x58(%ebp),%edx
   120f5:	8d 5a 01             	lea    0x1(%edx),%ebx
   120f8:	8b 55 08             	mov    0x8(%ebp),%edx
   120fb:	01 da                	add    %ebx,%edx
   120fd:	83 ec 08             	sub    $0x8,%esp
   12100:	50                   	push   %eax
   12101:	ff 75 b0             	pushl  -0x50(%ebp)
   12104:	ff 75 b4             	pushl  -0x4c(%ebp)
   12107:	ff 75 f4             	pushl  -0xc(%ebp)
   1210a:	51                   	push   %ecx
   1210b:	52                   	push   %edx
   1210c:	e8 6c f6 ff ff       	call   1177d <filterScanline>
   12111:	83 c4 20             	add    $0x20,%esp
      prevline = &in[inindex];
   12114:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   12117:	8b 45 0c             	mov    0xc(%ebp),%eax
   1211a:	01 d0                	add    %edx,%eax
   1211c:	89 45 f4             	mov    %eax,-0xc(%ebp)
      }
    }

    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
  } else if(strategy == LFS_PREDEFINED) {
    for(y = 0; y != h; ++y) {
   1211f:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12123:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12126:	3b 45 14             	cmp    0x14(%ebp),%eax
   12129:	75 85                	jne    120b0 <filter+0x529>
   1212b:	e9 36 02 00 00       	jmp    12366 <filter+0x7df>
      unsigned char type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  } else if(strategy == LFS_BRUTE_FORCE) {
   12130:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
   12134:	0f 85 25 02 00 00    	jne    1235f <filter+0x7d8>
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    unsigned char* attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
   1213a:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
    unsigned type = 0, bestType = 0;
   12141:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   12148:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings;
    lodepng_memcpy(&zlibsettings, &settings->zlibsettings, sizeof(LodePNGCompressSettings));
   1214f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12152:	83 ec 04             	sub    $0x4,%esp
   12155:	6a 24                	push   $0x24
   12157:	50                   	push   %eax
   12158:	8d 85 44 fb ff ff    	lea    -0x4bc(%ebp),%eax
   1215e:	50                   	push   %eax
   1215f:	e8 c1 14 ff ff       	call   3625 <lodepng_memcpy>
   12164:	83 c4 10             	add    $0x10,%esp
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
   12167:	c7 85 44 fb ff ff 01 	movl   $0x1,-0x4bc(%ebp)
   1216e:	00 00 00 
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
   12171:	c7 85 5c fb ff ff 00 	movl   $0x0,-0x4a4(%ebp)
   12178:	00 00 00 
    zlibsettings.custom_deflate = 0;
   1217b:	c7 85 60 fb ff ff 00 	movl   $0x0,-0x4a0(%ebp)
   12182:	00 00 00 
    for(type = 0; type != 5; ++type) {
   12185:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   1218c:	eb 33                	jmp    121c1 <filter+0x63a>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
   1218e:	83 ec 0c             	sub    $0xc,%esp
   12191:	ff 75 b4             	pushl  -0x4c(%ebp)
   12194:	e8 4e 14 ff ff       	call   35e7 <lodepng_malloc>
   12199:	83 c4 10             	add    $0x10,%esp
   1219c:	89 c2                	mov    %eax,%edx
   1219e:	8b 45 c0             	mov    -0x40(%ebp),%eax
   121a1:	89 94 85 48 ff ff ff 	mov    %edx,-0xb8(%ebp,%eax,4)
      if(!attempt[type]) error = 83; /*alloc fail*/
   121a8:	8b 45 c0             	mov    -0x40(%ebp),%eax
   121ab:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   121b2:	85 c0                	test   %eax,%eax
   121b4:	75 07                	jne    121bd <filter+0x636>
   121b6:	c7 45 e8 53 00 00 00 	movl   $0x53,-0x18(%ebp)
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type != 5; ++type) {
   121bd:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   121c1:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   121c5:	75 c7                	jne    1218e <filter+0x607>
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
   121c7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   121cb:	0f 85 63 01 00 00    	jne    12334 <filter+0x7ad>
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   121d1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   121d8:	e9 4b 01 00 00       	jmp    12328 <filter+0x7a1>
        for(type = 0; type != 5; ++type) {
   121dd:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   121e4:	e9 c8 00 00 00       	jmp    122b1 <filter+0x72a>
          unsigned testsize = (unsigned)linebytes;
   121e9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   121ec:	89 45 ac             	mov    %eax,-0x54(%ebp)
          /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

          filterScanline(attempt[type], &in[y * linebytes], prevline, linebytes, bytewidth, type);
   121ef:	8b 45 c0             	mov    -0x40(%ebp),%eax
   121f2:	0f b6 d0             	movzbl %al,%edx
   121f5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   121f8:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   121fc:	89 c1                	mov    %eax,%ecx
   121fe:	8b 45 0c             	mov    0xc(%ebp),%eax
   12201:	01 c1                	add    %eax,%ecx
   12203:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12206:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   1220d:	83 ec 08             	sub    $0x8,%esp
   12210:	52                   	push   %edx
   12211:	ff 75 b0             	pushl  -0x50(%ebp)
   12214:	ff 75 b4             	pushl  -0x4c(%ebp)
   12217:	ff 75 f4             	pushl  -0xc(%ebp)
   1221a:	51                   	push   %ecx
   1221b:	50                   	push   %eax
   1221c:	e8 5c f5 ff ff       	call   1177d <filterScanline>
   12221:	83 c4 20             	add    $0x20,%esp
          size[type] = 0;
   12224:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12227:	c7 84 85 5c ff ff ff 	movl   $0x0,-0xa4(%ebp,%eax,4)
   1222e:	00 00 00 00 
          dummy = 0;
   12232:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
   12239:	00 00 00 
          zlib_compress(&dummy, &size[type], attempt[type], testsize, &zlibsettings);
   1223c:	8b 55 ac             	mov    -0x54(%ebp),%edx
   1223f:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12242:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12249:	8d 8d 5c ff ff ff    	lea    -0xa4(%ebp),%ecx
   1224f:	8b 5d c0             	mov    -0x40(%ebp),%ebx
   12252:	c1 e3 02             	shl    $0x2,%ebx
   12255:	01 cb                	add    %ecx,%ebx
   12257:	83 ec 0c             	sub    $0xc,%esp
   1225a:	8d 8d 44 fb ff ff    	lea    -0x4bc(%ebp),%ecx
   12260:	51                   	push   %ecx
   12261:	52                   	push   %edx
   12262:	50                   	push   %eax
   12263:	53                   	push   %ebx
   12264:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
   1226a:	50                   	push   %eax
   1226b:	e8 87 60 ff ff       	call   82f7 <zlib_compress>
   12270:	83 c4 20             	add    $0x20,%esp
          lodepng_free(dummy);
   12273:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   12279:	83 ec 0c             	sub    $0xc,%esp
   1227c:	50                   	push   %eax
   1227d:	e8 86 13 ff ff       	call   3608 <lodepng_free>
   12282:	83 c4 10             	add    $0x10,%esp
          /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || size[type] < smallest) {
   12285:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
   12289:	74 0f                	je     1229a <filter+0x713>
   1228b:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1228e:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   12295:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
   12298:	7d 13                	jge    122ad <filter+0x726>
            bestType = type;
   1229a:	8b 45 c0             	mov    -0x40(%ebp),%eax
   1229d:	89 45 bc             	mov    %eax,-0x44(%ebp)
            smallest = size[type];
   122a0:	8b 45 c0             	mov    -0x40(%ebp),%eax
   122a3:	8b 84 85 5c ff ff ff 	mov    -0xa4(%ebp,%eax,4),%eax
   122aa:	89 45 c4             	mov    %eax,-0x3c(%ebp)
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
        for(type = 0; type != 5; ++type) {
   122ad:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   122b1:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   122b5:	0f 85 2e ff ff ff    	jne    121e9 <filter+0x662>
          if(type == 0 || size[type] < smallest) {
            bestType = type;
            smallest = size[type];
          }
        }
        prevline = &in[y * linebytes];
   122bb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   122be:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   122c2:	89 c2                	mov    %eax,%edx
   122c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   122c7:	01 d0                	add    %edx,%eax
   122c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
   122cc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   122cf:	83 c0 01             	add    $0x1,%eax
   122d2:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   122d6:	89 c2                	mov    %eax,%edx
   122d8:	8b 45 08             	mov    0x8(%ebp),%eax
   122db:	01 d0                	add    %edx,%eax
   122dd:	8b 55 bc             	mov    -0x44(%ebp),%edx
   122e0:	88 10                	mov    %dl,(%eax)
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
   122e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   122e9:	eb 31                	jmp    1231c <filter+0x795>
   122eb:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   122ee:	83 c0 01             	add    $0x1,%eax
   122f1:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   122f5:	89 c2                	mov    %eax,%edx
   122f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   122fa:	01 d0                	add    %edx,%eax
   122fc:	8d 50 01             	lea    0x1(%eax),%edx
   122ff:	8b 45 08             	mov    0x8(%ebp),%eax
   12302:	01 c2                	add    %eax,%edx
   12304:	8b 45 bc             	mov    -0x44(%ebp),%eax
   12307:	8b 8c 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%ecx
   1230e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12311:	01 c8                	add    %ecx,%eax
   12313:	0f b6 00             	movzbl (%eax),%eax
   12316:	88 02                	mov    %al,(%edx)
   12318:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1231c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
   1231f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12322:	75 c7                	jne    122eb <filter+0x764>
    for(type = 0; type != 5; ++type) {
      attempt[type] = (unsigned char*)lodepng_malloc(linebytes);
      if(!attempt[type]) error = 83; /*alloc fail*/
    }
    if(!error) {
      for(y = 0; y != h; ++y) /*try the 5 filter types*/ {
   12324:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   12328:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1232b:	3b 45 14             	cmp    0x14(%ebp),%eax
   1232e:	0f 85 a9 fe ff ff    	jne    121dd <filter+0x656>
        prevline = &in[y * linebytes];
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType][x];
      }
    }
    for(type = 0; type != 5; ++type) lodepng_free(attempt[type]);
   12334:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
   1233b:	eb 1a                	jmp    12357 <filter+0x7d0>
   1233d:	8b 45 c0             	mov    -0x40(%ebp),%eax
   12340:	8b 84 85 48 ff ff ff 	mov    -0xb8(%ebp,%eax,4),%eax
   12347:	83 ec 0c             	sub    $0xc,%esp
   1234a:	50                   	push   %eax
   1234b:	e8 b8 12 ff ff       	call   3608 <lodepng_free>
   12350:	83 c4 10             	add    $0x10,%esp
   12353:	83 45 c0 01          	addl   $0x1,-0x40(%ebp)
   12357:	83 7d c0 05          	cmpl   $0x5,-0x40(%ebp)
   1235b:	75 e0                	jne    1233d <filter+0x7b6>
   1235d:	eb 07                	jmp    12366 <filter+0x7df>
  }
  else return 88; /* unknown filter strategy */
   1235f:	b8 58 00 00 00       	mov    $0x58,%eax
   12364:	eb 03                	jmp    12369 <filter+0x7e2>

  return error;
   12366:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
   12369:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   1236c:	c9                   	leave  
   1236d:	c3                   	ret    

0001236e <addPaddingBits>:

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h) {
   1236e:	55                   	push   %ebp
   1236f:	89 e5                	mov    %esp,%ebp
   12371:	83 ec 20             	sub    $0x20,%esp
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
   12374:	8b 45 10             	mov    0x10(%ebp),%eax
   12377:	2b 45 14             	sub    0x14(%ebp),%eax
   1237a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t obp = 0, ibp = 0; /*bit pointers*/
   1237d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12384:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  for(y = 0; y != h; ++y) {
   1238b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12392:	eb 65                	jmp    123f9 <addPaddingBits+0x8b>
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   12394:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1239b:	eb 2a                	jmp    123c7 <addPaddingBits+0x59>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
   1239d:	ff 75 0c             	pushl  0xc(%ebp)
   123a0:	8d 45 e8             	lea    -0x18(%ebp),%eax
   123a3:	50                   	push   %eax
   123a4:	e8 9d 60 ff ff       	call   8446 <readBitFromReversedStream>
   123a9:	83 c4 08             	add    $0x8,%esp
   123ac:	88 45 f3             	mov    %al,-0xd(%ebp)
      setBitOfReversedStream(&obp, out, bit);
   123af:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
   123b3:	50                   	push   %eax
   123b4:	ff 75 08             	pushl  0x8(%ebp)
   123b7:	8d 45 ec             	lea    -0x14(%ebp),%eax
   123ba:	50                   	push   %eax
   123bb:	e8 08 61 ff ff       	call   84c8 <setBitOfReversedStream>
   123c0:	83 c4 0c             	add    $0xc,%esp
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
    size_t x;
    for(x = 0; x < ilinebits; ++x) {
   123c3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   123c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
   123ca:	3b 45 14             	cmp    0x14(%ebp),%eax
   123cd:	7c ce                	jl     1239d <addPaddingBits+0x2f>
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
   123cf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   123d6:	eb 15                	jmp    123ed <addPaddingBits+0x7f>
   123d8:	6a 00                	push   $0x0
   123da:	ff 75 08             	pushl  0x8(%ebp)
   123dd:	8d 45 ec             	lea    -0x14(%ebp),%eax
   123e0:	50                   	push   %eax
   123e1:	e8 e2 60 ff ff       	call   84c8 <setBitOfReversedStream>
   123e6:	83 c4 0c             	add    $0xc,%esp
   123e9:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   123ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
   123f0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   123f3:	75 e3                	jne    123d8 <addPaddingBits+0x6a>
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y) {
   123f5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   123f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
   123fc:	3b 45 18             	cmp    0x18(%ebp),%eax
   123ff:	75 93                	jne    12394 <addPaddingBits+0x26>
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}
   12401:	90                   	nop
   12402:	c9                   	leave  
   12403:	c3                   	ret    

00012404 <Adam7_interlace>:
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp) {
   12404:	55                   	push   %ebp
   12405:	89 e5                	mov    %esp,%ebp
   12407:	81 ec e0 00 00 00    	sub    $0xe0,%esp
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   1240d:	ff 75 18             	pushl  0x18(%ebp)
   12410:	ff 75 14             	pushl  0x14(%ebp)
   12413:	ff 75 10             	pushl  0x10(%ebp)
   12416:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
   1241c:	50                   	push   %eax
   1241d:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
   12423:	50                   	push   %eax
   12424:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   1242a:	50                   	push   %eax
   1242b:	8d 45 94             	lea    -0x6c(%ebp),%eax
   1242e:	50                   	push   %eax
   1242f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12432:	50                   	push   %eax
   12433:	e8 fc ae ff ff       	call   d334 <Adam7_getpassvalues>
   12438:	83 c4 20             	add    $0x20,%esp

  if(bpp >= 8) {
   1243b:	83 7d 18 07          	cmpl   $0x7,0x18(%ebp)
   1243f:	0f 86 0a 01 00 00    	jbe    1254f <Adam7_interlace+0x14b>
    for(i = 0; i != 7; ++i) {
   12445:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   1244c:	e9 ef 00 00 00       	jmp    12540 <Adam7_interlace+0x13c>
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
   12451:	8b 45 18             	mov    0x18(%ebp),%eax
   12454:	c1 e8 03             	shr    $0x3,%eax
   12457:	89 45 e0             	mov    %eax,-0x20(%ebp)
      for(y = 0; y < passh[i]; ++y)
   1245a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   12461:	e9 c6 00 00 00       	jmp    1252c <Adam7_interlace+0x128>
      for(x = 0; x < passw[i]; ++x) {
   12466:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1246d:	e9 a6 00 00 00       	jmp    12518 <Adam7_interlace+0x114>
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
   12472:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12475:	8b 14 85 b8 a2 01 00 	mov    0x1a2b8(,%eax,4),%edx
   1247c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1247f:	8b 04 85 f0 a2 01 00 	mov    0x1a2f0(,%eax,4),%eax
   12486:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   1248a:	01 d0                	add    %edx,%eax
   1248c:	0f af 45 10          	imul   0x10(%ebp),%eax
   12490:	89 c2                	mov    %eax,%edx
   12492:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12495:	8b 04 85 d4 a2 01 00 	mov    0x1a2d4(,%eax,4),%eax
   1249c:	0f af 45 f8          	imul   -0x8(%ebp),%eax
   124a0:	01 c2                	add    %eax,%edx
   124a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   124a5:	8b 04 85 9c a2 01 00 	mov    0x1a29c(,%eax,4),%eax
   124ac:	01 c2                	add    %eax,%edx
   124ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
   124b1:	0f af c2             	imul   %edx,%eax
   124b4:	89 45 dc             	mov    %eax,-0x24(%ebp)
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
   124b7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   124ba:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   124c1:	89 c1                	mov    %eax,%ecx
   124c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   124c6:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   124ca:	0f af 45 f4          	imul   -0xc(%ebp),%eax
   124ce:	89 c2                	mov    %eax,%edx
   124d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
   124d3:	01 c2                	add    %eax,%edx
   124d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
   124d8:	0f af c2             	imul   %edx,%eax
   124db:	01 c8                	add    %ecx,%eax
   124dd:	89 45 d8             	mov    %eax,-0x28(%ebp)
        for(b = 0; b < bytewidth; ++b) {
   124e0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   124e7:	eb 23                	jmp    1250c <Adam7_interlace+0x108>
          out[pixeloutstart + b] = in[pixelinstart + b];
   124e9:	8b 55 d8             	mov    -0x28(%ebp),%edx
   124ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   124ef:	01 c2                	add    %eax,%edx
   124f1:	8b 45 08             	mov    0x8(%ebp),%eax
   124f4:	01 c2                	add    %eax,%edx
   124f6:	8b 4d dc             	mov    -0x24(%ebp),%ecx
   124f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   124fc:	01 c1                	add    %eax,%ecx
   124fe:	8b 45 0c             	mov    0xc(%ebp),%eax
   12501:	01 c8                	add    %ecx,%eax
   12503:	0f b6 00             	movzbl (%eax),%eax
   12506:	88 02                	mov    %al,(%edx)
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; ++b) {
   12508:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1250c:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1250f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12512:	72 d5                	jb     124e9 <Adam7_interlace+0xe5>
  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   12514:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   12518:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1251b:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   1251f:	3b 45 f8             	cmp    -0x8(%ebp),%eax
   12522:	0f 87 4a ff ff ff    	ja     12472 <Adam7_interlace+0x6e>

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8u;
      for(y = 0; y < passh[i]; ++y)
   12528:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1252c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1252f:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   12533:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   12536:	0f 87 2a ff ff ff    	ja     12466 <Adam7_interlace+0x62>
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8) {
    for(i = 0; i != 7; ++i) {
   1253c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12540:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   12544:	0f 85 07 ff ff ff    	jne    12451 <Adam7_interlace+0x4d>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   1254a:	e9 22 01 00 00       	jmp    12671 <Adam7_interlace+0x26d>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   1254f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   12556:	e9 0c 01 00 00       	jmp    12667 <Adam7_interlace+0x263>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
   1255b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1255e:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12562:	0f af 45 18          	imul   0x18(%ebp),%eax
   12566:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      unsigned olinebits = bpp * w;
   12569:	8b 45 18             	mov    0x18(%ebp),%eax
   1256c:	0f af 45 10          	imul   0x10(%ebp),%eax
   12570:	89 45 d0             	mov    %eax,-0x30(%ebp)
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   12573:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   1257a:	e9 d4 00 00 00       	jmp    12653 <Adam7_interlace+0x24f>
      for(x = 0; x < passw[i]; ++x) {
   1257f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   12586:	e9 b4 00 00 00       	jmp    1263f <Adam7_interlace+0x23b>
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
   1258b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1258e:	8b 14 85 b8 a2 01 00 	mov    0x1a2b8(,%eax,4),%edx
   12595:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12598:	8b 04 85 f0 a2 01 00 	mov    0x1a2f0(,%eax,4),%eax
   1259f:	0f af 45 e8          	imul   -0x18(%ebp),%eax
   125a3:	01 d0                	add    %edx,%eax
   125a5:	0f af 45 d0          	imul   -0x30(%ebp),%eax
   125a9:	89 c2                	mov    %eax,%edx
   125ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
   125ae:	8b 0c 85 9c a2 01 00 	mov    0x1a29c(,%eax,4),%ecx
   125b5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   125b8:	8b 04 85 d4 a2 01 00 	mov    0x1a2d4(,%eax,4),%eax
   125bf:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   125c3:	01 c8                	add    %ecx,%eax
   125c5:	0f af 45 18          	imul   0x18(%ebp),%eax
   125c9:	01 d0                	add    %edx,%eax
   125cb:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
   125d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
   125d4:	8b 84 85 34 ff ff ff 	mov    -0xcc(%ebp,%eax,4),%eax
   125db:	c1 e0 03             	shl    $0x3,%eax
   125de:	89 c1                	mov    %eax,%ecx
   125e0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   125e3:	0f af 45 d4          	imul   -0x2c(%ebp),%eax
   125e7:	89 c2                	mov    %eax,%edx
   125e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   125ec:	0f af 45 18          	imul   0x18(%ebp),%eax
   125f0:	01 d0                	add    %edx,%eax
   125f2:	01 c8                	add    %ecx,%eax
   125f4:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
        for(b = 0; b < bpp; ++b) {
   125fa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   12601:	eb 30                	jmp    12633 <Adam7_interlace+0x22f>
          unsigned char bit = readBitFromReversedStream(&ibp, in);
   12603:	ff 75 0c             	pushl  0xc(%ebp)
   12606:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
   1260c:	50                   	push   %eax
   1260d:	e8 34 5e ff ff       	call   8446 <readBitFromReversedStream>
   12612:	83 c4 08             	add    $0x8,%esp
   12615:	88 45 cf             	mov    %al,-0x31(%ebp)
          setBitOfReversedStream(&obp, out, bit);
   12618:	0f b6 45 cf          	movzbl -0x31(%ebp),%eax
   1261c:	50                   	push   %eax
   1261d:	ff 75 08             	pushl  0x8(%ebp)
   12620:	8d 85 30 ff ff ff    	lea    -0xd0(%ebp),%eax
   12626:	50                   	push   %eax
   12627:	e8 9c 5e ff ff       	call   84c8 <setBitOfReversedStream>
   1262c:	83 c4 0c             	add    $0xc,%esp
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; ++b) {
   1262f:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   12633:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   12636:	3b 45 18             	cmp    0x18(%ebp),%eax
   12639:	72 c8                	jb     12603 <Adam7_interlace+0x1ff>
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
      for(x = 0; x < passw[i]; ++x) {
   1263b:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1263f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12642:	8b 44 85 b0          	mov    -0x50(%ebp,%eax,4),%eax
   12646:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   12649:	0f 87 3c ff ff ff    	ja     1258b <Adam7_interlace+0x187>
    for(i = 0; i != 7; ++i) {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; ++y)
   1264f:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   12653:	8b 45 fc             	mov    -0x4(%ebp),%eax
   12656:	8b 44 85 94          	mov    -0x6c(%ebp,%eax,4),%eax
   1265a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   1265d:	0f 87 1c ff ff ff    	ja     1257f <Adam7_interlace+0x17b>
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  } else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/ {
    for(i = 0; i != 7; ++i) {
   12663:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   12667:	83 7d fc 07          	cmpl   $0x7,-0x4(%ebp)
   1266b:	0f 85 ea fe ff ff    	jne    1255b <Adam7_interlace+0x157>
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}
   12671:	90                   	nop
   12672:	c9                   	leave  
   12673:	c3                   	ret    

00012674 <preProcessScanlines>:

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings) {
   12674:	55                   	push   %ebp
   12675:	89 e5                	mov    %esp,%ebp
   12677:	57                   	push   %edi
   12678:	56                   	push   %esi
   12679:	53                   	push   %ebx
   1267a:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= possible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
   12680:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12683:	83 c0 0c             	add    $0xc,%eax
   12686:	50                   	push   %eax
   12687:	e8 77 6a ff ff       	call   9103 <lodepng_get_bpp>
   1268c:	83 c4 04             	add    $0x4,%esp
   1268f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  unsigned error = 0;
   12692:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

  if(info_png->interlace_method == 0) {
   12699:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1269c:	8b 40 08             	mov    0x8(%eax),%eax
   1269f:	85 c0                	test   %eax,%eax
   126a1:	0f 85 49 01 00 00    	jne    127f0 <preProcessScanlines+0x17c>
    *outsize = h + (h * ((w * bpp + 7u) / 8u)); /*image size plus an extra byte per scanline + possible padding bits*/
   126a7:	8b 45 14             	mov    0x14(%ebp),%eax
   126aa:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   126ae:	83 c0 07             	add    $0x7,%eax
   126b1:	c1 e8 03             	shr    $0x3,%eax
   126b4:	83 c0 01             	add    $0x1,%eax
   126b7:	0f af 45 18          	imul   0x18(%ebp),%eax
   126bb:	89 c2                	mov    %eax,%edx
   126bd:	8b 45 0c             	mov    0xc(%ebp),%eax
   126c0:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   126c2:	8b 45 0c             	mov    0xc(%ebp),%eax
   126c5:	8b 00                	mov    (%eax),%eax
   126c7:	83 ec 0c             	sub    $0xc,%esp
   126ca:	50                   	push   %eax
   126cb:	e8 17 0f ff ff       	call   35e7 <lodepng_malloc>
   126d0:	83 c4 10             	add    $0x10,%esp
   126d3:	89 c2                	mov    %eax,%edx
   126d5:	8b 45 08             	mov    0x8(%ebp),%eax
   126d8:	89 10                	mov    %edx,(%eax)
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/
   126da:	8b 45 08             	mov    0x8(%ebp),%eax
   126dd:	8b 00                	mov    (%eax),%eax
   126df:	85 c0                	test   %eax,%eax
   126e1:	75 10                	jne    126f3 <preProcessScanlines+0x7f>
   126e3:	8b 45 0c             	mov    0xc(%ebp),%eax
   126e6:	8b 00                	mov    (%eax),%eax
   126e8:	85 c0                	test   %eax,%eax
   126ea:	74 07                	je     126f3 <preProcessScanlines+0x7f>
   126ec:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   126f3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   126f7:	0f 85 fb 02 00 00    	jne    129f8 <preProcessScanlines+0x384>
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   126fd:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   12701:	0f 87 bd 00 00 00    	ja     127c4 <preProcessScanlines+0x150>
   12707:	8b 45 14             	mov    0x14(%ebp),%eax
   1270a:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1270e:	89 c2                	mov    %eax,%edx
   12710:	8b 45 14             	mov    0x14(%ebp),%eax
   12713:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12717:	83 c0 07             	add    $0x7,%eax
   1271a:	c1 e8 03             	shr    $0x3,%eax
   1271d:	c1 e0 03             	shl    $0x3,%eax
   12720:	39 c2                	cmp    %eax,%edx
   12722:	0f 84 9c 00 00 00    	je     127c4 <preProcessScanlines+0x150>
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7u) / 8u));
   12728:	8b 45 14             	mov    0x14(%ebp),%eax
   1272b:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1272f:	83 c0 07             	add    $0x7,%eax
   12732:	c1 e8 03             	shr    $0x3,%eax
   12735:	0f af 45 18          	imul   0x18(%ebp),%eax
   12739:	83 ec 0c             	sub    $0xc,%esp
   1273c:	50                   	push   %eax
   1273d:	e8 a5 0e ff ff       	call   35e7 <lodepng_malloc>
   12742:	83 c4 10             	add    $0x10,%esp
   12745:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(!padded) error = 83; /*alloc fail*/
   12748:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   1274c:	75 07                	jne    12755 <preProcessScanlines+0xe1>
   1274e:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
        if(!error) {
   12755:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12759:	75 56                	jne    127b1 <preProcessScanlines+0x13d>
          addPaddingBits(padded, in, ((w * bpp + 7u) / 8u) * 8u, w * bpp, h);
   1275b:	8b 45 14             	mov    0x14(%ebp),%eax
   1275e:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   12762:	89 c2                	mov    %eax,%edx
   12764:	8b 45 14             	mov    0x14(%ebp),%eax
   12767:	0f af 45 dc          	imul   -0x24(%ebp),%eax
   1276b:	83 c0 07             	add    $0x7,%eax
   1276e:	c1 e8 03             	shr    $0x3,%eax
   12771:	c1 e0 03             	shl    $0x3,%eax
   12774:	83 ec 0c             	sub    $0xc,%esp
   12777:	ff 75 18             	pushl  0x18(%ebp)
   1277a:	52                   	push   %edx
   1277b:	50                   	push   %eax
   1277c:	ff 75 10             	pushl  0x10(%ebp)
   1277f:	ff 75 d8             	pushl  -0x28(%ebp)
   12782:	e8 e7 fb ff ff       	call   1236e <addPaddingBits>
   12787:	83 c4 20             	add    $0x20,%esp
          error = filter(*out, padded, w, h, &info_png->color, settings);
   1278a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1278d:	8d 50 0c             	lea    0xc(%eax),%edx
   12790:	8b 45 08             	mov    0x8(%ebp),%eax
   12793:	8b 00                	mov    (%eax),%eax
   12795:	83 ec 08             	sub    $0x8,%esp
   12798:	ff 75 20             	pushl  0x20(%ebp)
   1279b:	52                   	push   %edx
   1279c:	ff 75 18             	pushl  0x18(%ebp)
   1279f:	ff 75 14             	pushl  0x14(%ebp)
   127a2:	ff 75 d8             	pushl  -0x28(%ebp)
   127a5:	50                   	push   %eax
   127a6:	e8 dc f3 ff ff       	call   11b87 <filter>
   127ab:	83 c4 20             	add    $0x20,%esp
   127ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        }
        lodepng_free(padded);
   127b1:	83 ec 0c             	sub    $0xc,%esp
   127b4:	ff 75 d8             	pushl  -0x28(%ebp)
   127b7:	e8 4c 0e ff ff       	call   3608 <lodepng_free>
   127bc:	83 c4 10             	add    $0x10,%esp
    *out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error) {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7u) / 8u) * 8u) {
   127bf:	e9 34 02 00 00       	jmp    129f8 <preProcessScanlines+0x384>
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      } else {
        /*we can immediately filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
   127c4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   127c7:	8d 50 0c             	lea    0xc(%eax),%edx
   127ca:	8b 45 08             	mov    0x8(%ebp),%eax
   127cd:	8b 00                	mov    (%eax),%eax
   127cf:	83 ec 08             	sub    $0x8,%esp
   127d2:	ff 75 20             	pushl  0x20(%ebp)
   127d5:	52                   	push   %edx
   127d6:	ff 75 18             	pushl  0x18(%ebp)
   127d9:	ff 75 14             	pushl  0x14(%ebp)
   127dc:	ff 75 10             	pushl  0x10(%ebp)
   127df:	50                   	push   %eax
   127e0:	e8 a2 f3 ff ff       	call   11b87 <filter>
   127e5:	83 c4 20             	add    $0x20,%esp
   127e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   127eb:	e9 08 02 00 00       	jmp    129f8 <preProcessScanlines+0x384>
  } else /*interlace_method is 1 (Adam7)*/ {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);
   127f0:	ff 75 dc             	pushl  -0x24(%ebp)
   127f3:	ff 75 18             	pushl  0x18(%ebp)
   127f6:	ff 75 14             	pushl  0x14(%ebp)
   127f9:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
   127ff:	50                   	push   %eax
   12800:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
   12806:	50                   	push   %eax
   12807:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
   1280d:	50                   	push   %eax
   1280e:	8d 45 98             	lea    -0x68(%ebp),%eax
   12811:	50                   	push   %eax
   12812:	8d 45 b4             	lea    -0x4c(%ebp),%eax
   12815:	50                   	push   %eax
   12816:	e8 19 ab ff ff       	call   d334 <Adam7_getpassvalues>
   1281b:	83 c4 20             	add    $0x20,%esp

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
   1281e:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
   12824:	8b 45 0c             	mov    0xc(%ebp),%eax
   12827:	89 10                	mov    %edx,(%eax)
    *out = (unsigned char*)lodepng_malloc(*outsize);
   12829:	8b 45 0c             	mov    0xc(%ebp),%eax
   1282c:	8b 00                	mov    (%eax),%eax
   1282e:	83 ec 0c             	sub    $0xc,%esp
   12831:	50                   	push   %eax
   12832:	e8 b0 0d ff ff       	call   35e7 <lodepng_malloc>
   12837:	83 c4 10             	add    $0x10,%esp
   1283a:	89 c2                	mov    %eax,%edx
   1283c:	8b 45 08             	mov    0x8(%ebp),%eax
   1283f:	89 10                	mov    %edx,(%eax)
    if(!(*out)) error = 83; /*alloc fail*/
   12841:	8b 45 08             	mov    0x8(%ebp),%eax
   12844:	8b 00                	mov    (%eax),%eax
   12846:	85 c0                	test   %eax,%eax
   12848:	75 07                	jne    12851 <preProcessScanlines+0x1dd>
   1284a:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
   12851:	8b 45 94             	mov    -0x6c(%ebp),%eax
   12854:	83 ec 0c             	sub    $0xc,%esp
   12857:	50                   	push   %eax
   12858:	e8 8a 0d ff ff       	call   35e7 <lodepng_malloc>
   1285d:	83 c4 10             	add    $0x10,%esp
   12860:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/
   12863:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12867:	75 0e                	jne    12877 <preProcessScanlines+0x203>
   12869:	8b 45 94             	mov    -0x6c(%ebp),%eax
   1286c:	85 c0                	test   %eax,%eax
   1286e:	74 07                	je     12877 <preProcessScanlines+0x203>
   12870:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)

    if(!error) {
   12877:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   1287b:	0f 85 69 01 00 00    	jne    129ea <preProcessScanlines+0x376>
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
   12881:	83 ec 0c             	sub    $0xc,%esp
   12884:	ff 75 dc             	pushl  -0x24(%ebp)
   12887:	ff 75 18             	pushl  0x18(%ebp)
   1288a:	ff 75 14             	pushl  0x14(%ebp)
   1288d:	ff 75 10             	pushl  0x10(%ebp)
   12890:	ff 75 d4             	pushl  -0x2c(%ebp)
   12893:	e8 6c fb ff ff       	call   12404 <Adam7_interlace>
   12898:	83 c4 20             	add    $0x20,%esp
      for(i = 0; i != 7; ++i) {
   1289b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   128a2:	e9 36 01 00 00       	jmp    129dd <preProcessScanlines+0x369>
        if(bpp < 8) {
   128a7:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
   128ab:	0f 87 d6 00 00 00    	ja     12987 <preProcessScanlines+0x313>
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
   128b1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   128b4:	83 c0 01             	add    $0x1,%eax
   128b7:	8b 94 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%edx
   128be:	8b 45 e0             	mov    -0x20(%ebp),%eax
   128c1:	8b 84 85 58 ff ff ff 	mov    -0xa8(%ebp,%eax,4),%eax
   128c8:	29 c2                	sub    %eax,%edx
   128ca:	89 d0                	mov    %edx,%eax
   128cc:	83 ec 0c             	sub    $0xc,%esp
   128cf:	50                   	push   %eax
   128d0:	e8 12 0d ff ff       	call   35e7 <lodepng_malloc>
   128d5:	83 c4 10             	add    $0x10,%esp
   128d8:	89 45 d0             	mov    %eax,-0x30(%ebp)
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
   128db:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
   128df:	75 0c                	jne    128ed <preProcessScanlines+0x279>
   128e1:	c7 45 e4 53 00 00 00 	movl   $0x53,-0x1c(%ebp)
   128e8:	e9 fd 00 00 00       	jmp    129ea <preProcessScanlines+0x376>
          addPaddingBits(padded, &adam7[passstart[i]],
   128ed:	8b 45 e0             	mov    -0x20(%ebp),%eax
   128f0:	8b 44 85 98          	mov    -0x68(%ebp,%eax,4),%eax
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   128f4:	8b 55 e0             	mov    -0x20(%ebp),%edx
   128f7:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   128fb:	0f af 55 dc          	imul   -0x24(%ebp),%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   128ff:	89 d3                	mov    %edx,%ebx
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
   12901:	8b 55 e0             	mov    -0x20(%ebp),%edx
   12904:	8b 54 95 b4          	mov    -0x4c(%ebp,%edx,4),%edx
   12908:	0f af 55 dc          	imul   -0x24(%ebp),%edx
   1290c:	83 c2 07             	add    $0x7,%edx
   1290f:	c1 ea 03             	shr    $0x3,%edx
   12912:	c1 e2 03             	shl    $0x3,%edx
      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
        if(bpp < 8) {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
   12915:	89 d1                	mov    %edx,%ecx
   12917:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1291a:	8b 94 95 78 ff ff ff 	mov    -0x88(%ebp,%edx,4),%edx
   12921:	89 d6                	mov    %edx,%esi
   12923:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   12926:	01 f2                	add    %esi,%edx
   12928:	83 ec 0c             	sub    $0xc,%esp
   1292b:	50                   	push   %eax
   1292c:	53                   	push   %ebx
   1292d:	51                   	push   %ecx
   1292e:	52                   	push   %edx
   1292f:	ff 75 d0             	pushl  -0x30(%ebp)
   12932:	e8 37 fa ff ff       	call   1236e <addPaddingBits>
   12937:	83 c4 20             	add    $0x20,%esp
                         ((passw[i] * bpp + 7u) / 8u) * 8u, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
   1293a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1293d:	8d 58 0c             	lea    0xc(%eax),%ebx
   12940:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12943:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12947:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1294a:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   1294e:	8b 4d 08             	mov    0x8(%ebp),%ecx
   12951:	8b 31                	mov    (%ecx),%esi
   12953:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   12956:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   1295d:	01 f1                	add    %esi,%ecx
   1295f:	83 ec 08             	sub    $0x8,%esp
   12962:	ff 75 20             	pushl  0x20(%ebp)
   12965:	53                   	push   %ebx
   12966:	52                   	push   %edx
   12967:	50                   	push   %eax
   12968:	ff 75 d0             	pushl  -0x30(%ebp)
   1296b:	51                   	push   %ecx
   1296c:	e8 16 f2 ff ff       	call   11b87 <filter>
   12971:	83 c4 20             	add    $0x20,%esp
   12974:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
   12977:	83 ec 0c             	sub    $0xc,%esp
   1297a:	ff 75 d0             	pushl  -0x30(%ebp)
   1297d:	e8 86 0c ff ff       	call   3608 <lodepng_free>
   12982:	83 c4 10             	add    $0x10,%esp
   12985:	eb 4c                	jmp    129d3 <preProcessScanlines+0x35f>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
   12987:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1298a:	8d 70 0c             	lea    0xc(%eax),%esi
   1298d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12990:	8b 54 85 98          	mov    -0x68(%ebp,%eax,4),%edx
   12994:	8b 45 e0             	mov    -0x20(%ebp),%eax
   12997:	8b 44 85 b4          	mov    -0x4c(%ebp,%eax,4),%eax
   1299b:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   1299e:	8b 8c 8d 58 ff ff ff 	mov    -0xa8(%ebp,%ecx,4),%ecx
   129a5:	89 cb                	mov    %ecx,%ebx
   129a7:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   129aa:	01 cb                	add    %ecx,%ebx
   129ac:	8b 4d 08             	mov    0x8(%ebp),%ecx
   129af:	8b 39                	mov    (%ecx),%edi
   129b1:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   129b4:	8b 8c 8d 38 ff ff ff 	mov    -0xc8(%ebp,%ecx,4),%ecx
   129bb:	01 f9                	add    %edi,%ecx
   129bd:	83 ec 08             	sub    $0x8,%esp
   129c0:	ff 75 20             	pushl  0x20(%ebp)
   129c3:	56                   	push   %esi
   129c4:	52                   	push   %edx
   129c5:	50                   	push   %eax
   129c6:	53                   	push   %ebx
   129c7:	51                   	push   %ecx
   129c8:	e8 ba f1 ff ff       	call   11b87 <filter>
   129cd:	83 c4 20             	add    $0x20,%esp
   129d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   129d3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   129d7:	75 10                	jne    129e9 <preProcessScanlines+0x375>

    if(!error) {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i != 7; ++i) {
   129d9:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
   129dd:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
   129e1:	0f 85 c0 fe ff ff    	jne    128a7 <preProcessScanlines+0x233>
   129e7:	eb 01                	jmp    129ea <preProcessScanlines+0x376>
        } else {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
   129e9:	90                   	nop
      }
    }

    lodepng_free(adam7);
   129ea:	83 ec 0c             	sub    $0xc,%esp
   129ed:	ff 75 d4             	pushl  -0x2c(%ebp)
   129f0:	e8 13 0c ff ff       	call   3608 <lodepng_free>
   129f5:	83 c4 10             	add    $0x10,%esp
  }

  return error;
   129f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
   129fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
   129fe:	5b                   	pop    %ebx
   129ff:	5e                   	pop    %esi
   12a00:	5f                   	pop    %edi
   12a01:	5d                   	pop    %ebp
   12a02:	c3                   	ret    

00012a03 <addUnknownChunks>:

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
   12a03:	55                   	push   %ebp
   12a04:	89 e5                	mov    %esp,%ebp
   12a06:	83 ec 10             	sub    $0x10,%esp
  unsigned char* inchunk = data;
   12a09:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a0c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  while((size_t)(inchunk - data) < datasize) {
   12a0f:	eb 47                	jmp    12a58 <addUnknownChunks+0x55>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
   12a11:	8b 45 08             	mov    0x8(%ebp),%eax
   12a14:	8d 50 04             	lea    0x4(%eax),%edx
   12a17:	8b 45 08             	mov    0x8(%ebp),%eax
   12a1a:	ff 75 fc             	pushl  -0x4(%ebp)
   12a1d:	52                   	push   %edx
   12a1e:	50                   	push   %eax
   12a1f:	e8 73 5f ff ff       	call   8997 <lodepng_chunk_append>
   12a24:	83 c4 0c             	add    $0xc,%esp
   12a27:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12a2a:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
   12a2e:	74 05                	je     12a35 <addUnknownChunks+0x32>
   12a30:	8b 45 f8             	mov    -0x8(%ebp),%eax
   12a33:	eb 37                	jmp    12a6c <addUnknownChunks+0x69>
    out->allocsize = out->size; /*fix the allocsize again*/
   12a35:	8b 45 08             	mov    0x8(%ebp),%eax
   12a38:	8b 50 04             	mov    0x4(%eax),%edx
   12a3b:	8b 45 08             	mov    0x8(%ebp),%eax
   12a3e:	89 50 08             	mov    %edx,0x8(%eax)
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
   12a41:	8b 55 10             	mov    0x10(%ebp),%edx
   12a44:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a47:	01 d0                	add    %edx,%eax
   12a49:	50                   	push   %eax
   12a4a:	ff 75 fc             	pushl  -0x4(%ebp)
   12a4d:	e8 ff 5c ff ff       	call   8751 <lodepng_chunk_next>
   12a52:	83 c4 08             	add    $0x8,%esp
   12a55:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize) {
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize) {
   12a58:	8b 55 fc             	mov    -0x4(%ebp),%edx
   12a5b:	8b 45 0c             	mov    0xc(%ebp),%eax
   12a5e:	29 c2                	sub    %eax,%edx
   12a60:	89 d0                	mov    %edx,%eax
   12a62:	3b 45 10             	cmp    0x10(%ebp),%eax
   12a65:	7c aa                	jl     12a11 <addUnknownChunks+0xe>
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk, data + datasize);
  }
  return 0;
   12a67:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12a6c:	c9                   	leave  
   12a6d:	c3                   	ret    

00012a6e <isGrayICCProfile>:

static unsigned isGrayICCProfile(const unsigned char* profile, unsigned size) {
   12a6e:	55                   	push   %ebp
   12a6f:	89 e5                	mov    %esp,%ebp
  the profile is not checked. This is needed only because the PNG specification
  requires using a non-gray color model if there is an ICC profile with "RGB "
  (sadly limiting compression opportunities if the input data is grayscale RGB
  data), and requires using a gray color model if it is "GRAY".
  */
  if(size < 20) return 0;
   12a71:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12a75:	77 07                	ja     12a7e <isGrayICCProfile+0x10>
   12a77:	b8 00 00 00 00       	mov    $0x0,%eax
   12a7c:	eb 40                	jmp    12abe <isGrayICCProfile+0x50>
  return profile[16] == 'G' &&  profile[17] == 'R' &&  profile[18] == 'A' &&  profile[19] == 'Y';
   12a7e:	8b 45 08             	mov    0x8(%ebp),%eax
   12a81:	83 c0 10             	add    $0x10,%eax
   12a84:	0f b6 00             	movzbl (%eax),%eax
   12a87:	3c 47                	cmp    $0x47,%al
   12a89:	75 2e                	jne    12ab9 <isGrayICCProfile+0x4b>
   12a8b:	8b 45 08             	mov    0x8(%ebp),%eax
   12a8e:	83 c0 11             	add    $0x11,%eax
   12a91:	0f b6 00             	movzbl (%eax),%eax
   12a94:	3c 52                	cmp    $0x52,%al
   12a96:	75 21                	jne    12ab9 <isGrayICCProfile+0x4b>
   12a98:	8b 45 08             	mov    0x8(%ebp),%eax
   12a9b:	83 c0 12             	add    $0x12,%eax
   12a9e:	0f b6 00             	movzbl (%eax),%eax
   12aa1:	3c 41                	cmp    $0x41,%al
   12aa3:	75 14                	jne    12ab9 <isGrayICCProfile+0x4b>
   12aa5:	8b 45 08             	mov    0x8(%ebp),%eax
   12aa8:	83 c0 13             	add    $0x13,%eax
   12aab:	0f b6 00             	movzbl (%eax),%eax
   12aae:	3c 59                	cmp    $0x59,%al
   12ab0:	75 07                	jne    12ab9 <isGrayICCProfile+0x4b>
   12ab2:	b8 01 00 00 00       	mov    $0x1,%eax
   12ab7:	eb 05                	jmp    12abe <isGrayICCProfile+0x50>
   12ab9:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12abe:	5d                   	pop    %ebp
   12abf:	c3                   	ret    

00012ac0 <isRGBICCProfile>:

static unsigned isRGBICCProfile(const unsigned char* profile, unsigned size) {
   12ac0:	55                   	push   %ebp
   12ac1:	89 e5                	mov    %esp,%ebp
  /* See comment in isGrayICCProfile*/
  if(size < 20) return 0;
   12ac3:	83 7d 0c 13          	cmpl   $0x13,0xc(%ebp)
   12ac7:	77 07                	ja     12ad0 <isRGBICCProfile+0x10>
   12ac9:	b8 00 00 00 00       	mov    $0x0,%eax
   12ace:	eb 40                	jmp    12b10 <isRGBICCProfile+0x50>
  return profile[16] == 'R' &&  profile[17] == 'G' &&  profile[18] == 'B' &&  profile[19] == ' ';
   12ad0:	8b 45 08             	mov    0x8(%ebp),%eax
   12ad3:	83 c0 10             	add    $0x10,%eax
   12ad6:	0f b6 00             	movzbl (%eax),%eax
   12ad9:	3c 52                	cmp    $0x52,%al
   12adb:	75 2e                	jne    12b0b <isRGBICCProfile+0x4b>
   12add:	8b 45 08             	mov    0x8(%ebp),%eax
   12ae0:	83 c0 11             	add    $0x11,%eax
   12ae3:	0f b6 00             	movzbl (%eax),%eax
   12ae6:	3c 47                	cmp    $0x47,%al
   12ae8:	75 21                	jne    12b0b <isRGBICCProfile+0x4b>
   12aea:	8b 45 08             	mov    0x8(%ebp),%eax
   12aed:	83 c0 12             	add    $0x12,%eax
   12af0:	0f b6 00             	movzbl (%eax),%eax
   12af3:	3c 42                	cmp    $0x42,%al
   12af5:	75 14                	jne    12b0b <isRGBICCProfile+0x4b>
   12af7:	8b 45 08             	mov    0x8(%ebp),%eax
   12afa:	83 c0 13             	add    $0x13,%eax
   12afd:	0f b6 00             	movzbl (%eax),%eax
   12b00:	3c 20                	cmp    $0x20,%al
   12b02:	75 07                	jne    12b0b <isRGBICCProfile+0x4b>
   12b04:	b8 01 00 00 00       	mov    $0x1,%eax
   12b09:	eb 05                	jmp    12b10 <isRGBICCProfile+0x50>
   12b0b:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12b10:	5d                   	pop    %ebp
   12b11:	c3                   	ret    

00012b12 <lodepng_encode>:
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state) {
   12b12:	55                   	push   %ebp
   12b13:	89 e5                	mov    %esp,%ebp
   12b15:	57                   	push   %edi
   12b16:	56                   	push   %esi
   12b17:	53                   	push   %ebx
   12b18:	81 ec 7c 05 00 00    	sub    $0x57c,%esp
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
   12b1e:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  size_t datasize = 0;
   12b25:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  ucvector outv = ucvector_init(NULL, 0);
   12b2c:	8d 45 b0             	lea    -0x50(%ebp),%eax
   12b2f:	6a 00                	push   $0x0
   12b31:	6a 00                	push   $0x0
   12b33:	50                   	push   %eax
   12b34:	e8 6f 0d ff ff       	call   38a8 <ucvector_init>
   12b39:	83 c4 08             	add    $0x8,%esp
  LodePNGInfo info;
  const LodePNGInfo* info_png = &state->info_png;
   12b3c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b3f:	05 98 00 00 00       	add    $0x98,%eax
   12b44:	89 45 dc             	mov    %eax,-0x24(%ebp)

  lodepng_info_init(&info);
   12b47:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12b4d:	50                   	push   %eax
   12b4e:	e8 3a 71 ff ff       	call   9c8d <lodepng_info_init>
   12b53:	83 c4 04             	add    $0x4,%esp

  /*provide some proper output values if error will happen*/
  *out = 0;
   12b56:	8b 45 08             	mov    0x8(%ebp),%eax
   12b59:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  *outsize = 0;
   12b5f:	8b 45 0c             	mov    0xc(%ebp),%eax
   12b62:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  state->error = 0;
   12b68:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b6b:	c7 80 7c 01 00 00 00 	movl   $0x0,0x17c(%eax)
   12b72:	00 00 00 

  /*check input values validity*/
  if((info_png->color.colortype == LCT_PALETTE || state->encoder.force_palette)
   12b75:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b78:	8b 40 0c             	mov    0xc(%eax),%eax
   12b7b:	83 f8 03             	cmp    $0x3,%eax
   12b7e:	74 0a                	je     12b8a <lodepng_encode+0x78>
   12b80:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12b83:	8b 40 6c             	mov    0x6c(%eax),%eax
   12b86:	85 c0                	test   %eax,%eax
   12b88:	74 29                	je     12bb3 <lodepng_encode+0xa1>
      && (info_png->color.palettesize == 0 || info_png->color.palettesize > 256)) {
   12b8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b8d:	8b 40 18             	mov    0x18(%eax),%eax
   12b90:	85 c0                	test   %eax,%eax
   12b92:	74 0d                	je     12ba1 <lodepng_encode+0x8f>
   12b94:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12b97:	8b 40 18             	mov    0x18(%eax),%eax
   12b9a:	3d 00 01 00 00       	cmp    $0x100,%eax
   12b9f:	7e 12                	jle    12bb3 <lodepng_encode+0xa1>
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
   12ba1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ba4:	c7 80 7c 01 00 00 44 	movl   $0x44,0x17c(%eax)
   12bab:	00 00 00 
    goto cleanup;
   12bae:	e9 78 0c 00 00       	jmp    1382b <lodepng_encode+0xd19>
  }
  if(state->encoder.zlibsettings.btype > 2) {
   12bb3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bb6:	8b 40 38             	mov    0x38(%eax),%eax
   12bb9:	83 f8 02             	cmp    $0x2,%eax
   12bbc:	76 12                	jbe    12bd0 <lodepng_encode+0xbe>
    state->error = 61; /*error: invalid btype*/
   12bbe:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bc1:	c7 80 7c 01 00 00 3d 	movl   $0x3d,0x17c(%eax)
   12bc8:	00 00 00 
    goto cleanup;
   12bcb:	e9 5b 0c 00 00       	jmp    1382b <lodepng_encode+0xd19>
  }
  if(info_png->interlace_method > 1) {
   12bd0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bd3:	8b 40 08             	mov    0x8(%eax),%eax
   12bd6:	83 f8 01             	cmp    $0x1,%eax
   12bd9:	76 12                	jbe    12bed <lodepng_encode+0xdb>
    state->error = 71; /*error: invalid interlace mode*/
   12bdb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12bde:	c7 80 7c 01 00 00 47 	movl   $0x47,0x17c(%eax)
   12be5:	00 00 00 
    goto cleanup;
   12be8:	e9 3e 0c 00 00       	jmp    1382b <lodepng_encode+0xd19>
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
   12bed:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bf0:	8b 50 10             	mov    0x10(%eax),%edx
   12bf3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12bf6:	8b 40 0c             	mov    0xc(%eax),%eax
   12bf9:	52                   	push   %edx
   12bfa:	50                   	push   %eax
   12bfb:	e8 a4 5f ff ff       	call   8ba4 <checkColorValidity>
   12c00:	83 c4 08             	add    $0x8,%esp
   12c03:	89 c2                	mov    %eax,%edx
   12c05:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c08:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12c0e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c11:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12c17:	85 c0                	test   %eax,%eax
   12c19:	0f 85 c6 0b 00 00    	jne    137e5 <lodepng_encode+0xcd3>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
   12c1f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c22:	8b 50 7c             	mov    0x7c(%eax),%edx
   12c25:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c28:	8b 40 78             	mov    0x78(%eax),%eax
   12c2b:	52                   	push   %edx
   12c2c:	50                   	push   %eax
   12c2d:	e8 72 5f ff ff       	call   8ba4 <checkColorValidity>
   12c32:	83 c4 08             	add    $0x8,%esp
   12c35:	89 c2                	mov    %eax,%edx
   12c37:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c3a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
  if(state->error) goto cleanup; /*error: invalid color type given*/
   12c40:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c43:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12c49:	85 c0                	test   %eax,%eax
   12c4b:	0f 85 97 0b 00 00    	jne    137e8 <lodepng_encode+0xcd6>

  /* color convert and compute scanline filter types */
  lodepng_info_copy(&info, &state->info_png);
   12c51:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c54:	05 98 00 00 00       	add    $0x98,%eax
   12c59:	83 ec 08             	sub    $0x8,%esp
   12c5c:	50                   	push   %eax
   12c5d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12c63:	50                   	push   %eax
   12c64:	e8 58 71 ff ff       	call   9dc1 <lodepng_info_copy>
   12c69:	83 c4 10             	add    $0x10,%esp
  if(state->encoder.auto_convert) {
   12c6c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12c6f:	8b 40 5c             	mov    0x5c(%eax),%eax
   12c72:	85 c0                	test   %eax,%eax
   12c74:	0f 84 3c 02 00 00    	je     12eb6 <lodepng_encode+0x3a4>
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
   12c7a:	83 ec 0c             	sub    $0xc,%esp
   12c7d:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12c83:	50                   	push   %eax
   12c84:	e8 5f 96 ff ff       	call   c2e8 <lodepng_color_stats_init>
   12c89:	83 c4 10             	add    $0x10,%esp
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12c8c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c8f:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12c95:	85 c0                	test   %eax,%eax
   12c97:	74 2d                	je     12cc6 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12c99:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12c9c:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12ca2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ca5:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12cab:	83 ec 08             	sub    $0x8,%esp
   12cae:	52                   	push   %edx
   12caf:	50                   	push   %eax
   12cb0:	e8 b9 fd ff ff       	call   12a6e <isGrayICCProfile>
   12cb5:	83 c4 10             	add    $0x10,%esp
  lodepng_info_copy(&info, &state->info_png);
  if(state->encoder.auto_convert) {
    LodePNGColorStats stats;
    lodepng_color_stats_init(&stats);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->iccp_defined &&
   12cb8:	85 c0                	test   %eax,%eax
   12cba:	74 0a                	je     12cc6 <lodepng_encode+0x1b4>
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
   12cbc:	c7 85 b8 fe ff ff 00 	movl   $0x0,-0x148(%ebp)
   12cc3:	00 00 00 
    }
    if(info_png->iccp_defined &&
   12cc6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cc9:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12ccf:	85 c0                	test   %eax,%eax
   12cd1:	74 2d                	je     12d00 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
   12cd3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cd6:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12cdc:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12cdf:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12ce5:	83 ec 08             	sub    $0x8,%esp
   12ce8:	52                   	push   %edx
   12ce9:	50                   	push   %eax
   12cea:	e8 d1 fd ff ff       	call   12ac0 <isRGBICCProfile>
   12cef:	83 c4 10             	add    $0x10,%esp
        isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use palette with a GRAY ICC profile, even
      if the palette has only gray colors, so disallow it.*/
      stats.allow_palette = 0;
    }
    if(info_png->iccp_defined &&
   12cf2:	85 c0                	test   %eax,%eax
   12cf4:	74 0a                	je     12d00 <lodepng_encode+0x1ee>
        isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size)) {
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
   12cf6:	c7 85 bc fe ff ff 00 	movl   $0x0,-0x144(%ebp)
   12cfd:	00 00 00 
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
   12d00:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d03:	83 c0 78             	add    $0x78,%eax
   12d06:	83 ec 0c             	sub    $0xc,%esp
   12d09:	50                   	push   %eax
   12d0a:	ff 75 18             	pushl  0x18(%ebp)
   12d0d:	ff 75 14             	pushl  0x14(%ebp)
   12d10:	ff 75 10             	pushl  0x10(%ebp)
   12d13:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12d19:	50                   	push   %eax
   12d1a:	e8 e0 96 ff ff       	call   c3ff <lodepng_compute_color_stats>
   12d1f:	83 c4 20             	add    $0x20,%esp
   12d22:	89 c2                	mov    %eax,%edx
   12d24:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d27:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12d2d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12d30:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12d36:	85 c0                	test   %eax,%eax
   12d38:	0f 85 ad 0a 00 00    	jne    137eb <lodepng_encode+0xcd9>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    if(info_png->background_defined) {
   12d3e:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d41:	8b 40 2c             	mov    0x2c(%eax),%eax
   12d44:	85 c0                	test   %eax,%eax
   12d46:	0f 84 be 00 00 00    	je     12e0a <lodepng_encode+0x2f8>
      /*the background chunk's color must be taken into account as well*/
      unsigned r = 0, g = 0, b = 0;
   12d4c:	c7 85 c8 fe ff ff 00 	movl   $0x0,-0x138(%ebp)
   12d53:	00 00 00 
   12d56:	c7 85 c4 fe ff ff 00 	movl   $0x0,-0x13c(%ebp)
   12d5d:	00 00 00 
   12d60:	c7 85 c0 fe ff ff 00 	movl   $0x0,-0x140(%ebp)
   12d67:	00 00 00 
      LodePNGColorMode mode16 = lodepng_color_mode_make(LCT_RGB, 16);
   12d6a:	8d 85 78 fa ff ff    	lea    -0x588(%ebp),%eax
   12d70:	83 ec 04             	sub    $0x4,%esp
   12d73:	6a 10                	push   $0x10
   12d75:	6a 02                	push   $0x2
   12d77:	50                   	push   %eax
   12d78:	e8 15 61 ff ff       	call   8e92 <lodepng_color_mode_make>
   12d7d:	83 c4 0c             	add    $0xc,%esp
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
   12d80:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d83:	8d 58 0c             	lea    0xc(%eax),%ebx
   12d86:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d89:	8b 48 38             	mov    0x38(%eax),%ecx
   12d8c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d8f:	8b 50 34             	mov    0x34(%eax),%edx
   12d92:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12d95:	8b 40 30             	mov    0x30(%eax),%eax
   12d98:	53                   	push   %ebx
   12d99:	8d 9d 78 fa ff ff    	lea    -0x588(%ebp),%ebx
   12d9f:	53                   	push   %ebx
   12da0:	51                   	push   %ecx
   12da1:	52                   	push   %edx
   12da2:	50                   	push   %eax
   12da3:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
   12da9:	50                   	push   %eax
   12daa:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
   12db0:	50                   	push   %eax
   12db1:	8d 85 c8 fe ff ff    	lea    -0x138(%ebp),%eax
   12db7:	50                   	push   %eax
   12db8:	e8 8a 92 ff ff       	call   c047 <lodepng_convert_rgb>
   12dbd:	83 c4 20             	add    $0x20,%esp
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
   12dc0:	8b 8d c0 fe ff ff    	mov    -0x140(%ebp),%ecx
   12dc6:	8b 95 c4 fe ff ff    	mov    -0x13c(%ebp),%edx
   12dcc:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
   12dd2:	83 ec 0c             	sub    $0xc,%esp
   12dd5:	68 ff ff 00 00       	push   $0xffff
   12dda:	51                   	push   %ecx
   12ddb:	52                   	push   %edx
   12ddc:	50                   	push   %eax
   12ddd:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12de3:	50                   	push   %eax
   12de4:	e8 26 a1 ff ff       	call   cf0f <lodepng_color_stats_add>
   12de9:	83 c4 20             	add    $0x20,%esp
   12dec:	89 c2                	mov    %eax,%edx
   12dee:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12df1:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   12df7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12dfa:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e00:	85 c0                	test   %eax,%eax
   12e02:	74 06                	je     12e0a <lodepng_encode+0x2f8>
   12e04:	90                   	nop
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   12e05:	e9 e1 09 00 00       	jmp    137eb <lodepng_encode+0xcd9>
      lodepng_convert_rgb(&r, &g, &b, info_png->background_r, info_png->background_g, info_png->background_b, &mode16, &info_png->color);
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
   12e0a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e0d:	8d 50 78             	lea    0x78(%eax),%edx
   12e10:	83 ec 04             	sub    $0x4,%esp
   12e13:	8d 85 98 fa ff ff    	lea    -0x568(%ebp),%eax
   12e19:	50                   	push   %eax
   12e1a:	52                   	push   %edx
   12e1b:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e21:	83 c0 0c             	add    $0xc,%eax
   12e24:	50                   	push   %eax
   12e25:	e8 79 a1 ff ff       	call   cfa3 <auto_choose_color>
   12e2a:	83 c4 10             	add    $0x10,%esp
   12e2d:	89 c2                	mov    %eax,%edx
   12e2f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e32:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   12e38:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12e3b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12e41:	85 c0                	test   %eax,%eax
   12e43:	0f 85 a5 09 00 00    	jne    137ee <lodepng_encode+0xcdc>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*also convert the background chunk*/
    if(info_png->background_defined) {
   12e49:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e4c:	8b 40 2c             	mov    0x2c(%eax),%eax
   12e4f:	85 c0                	test   %eax,%eax
   12e51:	74 63                	je     12eb6 <lodepng_encode+0x3a4>
      if(lodepng_convert_rgb(&info.background_r, &info.background_g, &info.background_b,
   12e53:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e56:	8d 58 0c             	lea    0xc(%eax),%ebx
   12e59:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e5c:	8b 48 38             	mov    0x38(%eax),%ecx
   12e5f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e62:	8b 50 34             	mov    0x34(%eax),%edx
   12e65:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12e68:	8b 40 30             	mov    0x30(%eax),%eax
   12e6b:	53                   	push   %ebx
   12e6c:	8d 9d cc fe ff ff    	lea    -0x134(%ebp),%ebx
   12e72:	83 c3 0c             	add    $0xc,%ebx
   12e75:	53                   	push   %ebx
   12e76:	51                   	push   %ecx
   12e77:	52                   	push   %edx
   12e78:	50                   	push   %eax
   12e79:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e7f:	83 c0 38             	add    $0x38,%eax
   12e82:	50                   	push   %eax
   12e83:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e89:	83 c0 34             	add    $0x34,%eax
   12e8c:	50                   	push   %eax
   12e8d:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12e93:	83 c0 30             	add    $0x30,%eax
   12e96:	50                   	push   %eax
   12e97:	e8 ab 91 ff ff       	call   c047 <lodepng_convert_rgb>
   12e9c:	83 c4 20             	add    $0x20,%esp
   12e9f:	85 c0                	test   %eax,%eax
   12ea1:	74 13                	je     12eb6 <lodepng_encode+0x3a4>
          info_png->background_r, info_png->background_g, info_png->background_b, &info.color, &info_png->color)) {
        state->error = 104;
   12ea3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ea6:	c7 80 7c 01 00 00 68 	movl   $0x68,0x17c(%eax)
   12ead:	00 00 00 
        goto cleanup;
   12eb0:	90                   	nop
   12eb1:	e9 75 09 00 00       	jmp    1382b <lodepng_encode+0xd19>
      }
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
  }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  if(info_png->iccp_defined) {
   12eb6:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12eb9:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12ebf:	85 c0                	test   %eax,%eax
   12ec1:	0f 84 b2 00 00 00    	je     12f79 <lodepng_encode+0x467>
    unsigned gray_icc = isGrayICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12ec7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12eca:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12ed0:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ed3:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12ed9:	83 ec 08             	sub    $0x8,%esp
   12edc:	52                   	push   %edx
   12edd:	50                   	push   %eax
   12ede:	e8 8b fb ff ff       	call   12a6e <isGrayICCProfile>
   12ee3:	83 c4 10             	add    $0x10,%esp
   12ee6:	89 45 d8             	mov    %eax,-0x28(%ebp)
    unsigned rgb_icc = isRGBICCProfile(info_png->iccp_profile, info_png->iccp_profile_size);
   12ee9:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12eec:	8b 90 c8 00 00 00    	mov    0xc8(%eax),%edx
   12ef2:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12ef5:	8b 80 c4 00 00 00    	mov    0xc4(%eax),%eax
   12efb:	83 ec 08             	sub    $0x8,%esp
   12efe:	52                   	push   %edx
   12eff:	50                   	push   %eax
   12f00:	e8 bb fb ff ff       	call   12ac0 <isRGBICCProfile>
   12f05:	83 c4 10             	add    $0x10,%esp
   12f08:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    unsigned gray_png = info.color.colortype == LCT_GREY || info.color.colortype == LCT_GREY_ALPHA;
   12f0b:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12f11:	85 c0                	test   %eax,%eax
   12f13:	74 0b                	je     12f20 <lodepng_encode+0x40e>
   12f15:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   12f1b:	83 f8 04             	cmp    $0x4,%eax
   12f1e:	75 07                	jne    12f27 <lodepng_encode+0x415>
   12f20:	b8 01 00 00 00       	mov    $0x1,%eax
   12f25:	eb 05                	jmp    12f2c <lodepng_encode+0x41a>
   12f27:	b8 00 00 00 00       	mov    $0x0,%eax
   12f2c:	89 45 d0             	mov    %eax,-0x30(%ebp)
    if(!gray_icc && !rgb_icc) {
   12f2f:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   12f33:	75 18                	jne    12f4d <lodepng_encode+0x43b>
   12f35:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   12f39:	75 12                	jne    12f4d <lodepng_encode+0x43b>
      state->error = 100; /* Disallowed profile color type for PNG */
   12f3b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f3e:	c7 80 7c 01 00 00 64 	movl   $0x64,0x17c(%eax)
   12f45:	00 00 00 
      goto cleanup;
   12f48:	e9 de 08 00 00       	jmp    1382b <lodepng_encode+0xd19>
    }
    if(gray_icc != gray_png) {
   12f4d:	8b 45 d8             	mov    -0x28(%ebp),%eax
   12f50:	3b 45 d0             	cmp    -0x30(%ebp),%eax
   12f53:	74 24                	je     12f79 <lodepng_encode+0x467>
      /*Not allowed to use RGB/RGBA/palette with GRAY ICC profile or vice versa,
      or in case of auto_convert, it wasn't possible to find appropriate model*/
      state->error = state->encoder.auto_convert ? 102 : 101;
   12f55:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f58:	8b 40 5c             	mov    0x5c(%eax),%eax
   12f5b:	85 c0                	test   %eax,%eax
   12f5d:	74 07                	je     12f66 <lodepng_encode+0x454>
   12f5f:	ba 66 00 00 00       	mov    $0x66,%edx
   12f64:	eb 05                	jmp    12f6b <lodepng_encode+0x459>
   12f66:	ba 65 00 00 00       	mov    $0x65,%edx
   12f6b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f6e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      goto cleanup;
   12f74:	e9 b2 08 00 00       	jmp    1382b <lodepng_encode+0xd19>
    }
  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  if(!lodepng_color_mode_equal(&state->info_raw, &info.color)) {
   12f79:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12f7c:	83 c0 78             	add    $0x78,%eax
   12f7f:	83 ec 08             	sub    $0x8,%esp
   12f82:	8d 95 cc fe ff ff    	lea    -0x134(%ebp),%edx
   12f88:	83 c2 0c             	add    $0xc,%edx
   12f8b:	52                   	push   %edx
   12f8c:	50                   	push   %eax
   12f8d:	e8 57 5f ff ff       	call   8ee9 <lodepng_color_mode_equal>
   12f92:	83 c4 10             	add    $0x10,%esp
   12f95:	85 c0                	test   %eax,%eax
   12f97:	0f 85 f8 00 00 00    	jne    13095 <lodepng_encode+0x583>
    unsigned char* converted;
    size_t size = ((size_t)w * (size_t)h * (size_t)lodepng_get_bpp(&info.color) + 7u) / 8u;
   12f9d:	8b 55 14             	mov    0x14(%ebp),%edx
   12fa0:	8b 45 18             	mov    0x18(%ebp),%eax
   12fa3:	89 d3                	mov    %edx,%ebx
   12fa5:	0f af d8             	imul   %eax,%ebx
   12fa8:	83 ec 0c             	sub    $0xc,%esp
   12fab:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   12fb1:	83 c0 0c             	add    $0xc,%eax
   12fb4:	50                   	push   %eax
   12fb5:	e8 49 61 ff ff       	call   9103 <lodepng_get_bpp>
   12fba:	83 c4 10             	add    $0x10,%esp
   12fbd:	0f af c3             	imul   %ebx,%eax
   12fc0:	83 c0 07             	add    $0x7,%eax
   12fc3:	c1 e8 03             	shr    $0x3,%eax
   12fc6:	89 45 cc             	mov    %eax,-0x34(%ebp)

    converted = (unsigned char*)lodepng_malloc(size);
   12fc9:	83 ec 0c             	sub    $0xc,%esp
   12fcc:	ff 75 cc             	pushl  -0x34(%ebp)
   12fcf:	e8 13 06 ff ff       	call   35e7 <lodepng_malloc>
   12fd4:	83 c4 10             	add    $0x10,%esp
   12fd7:	89 45 c8             	mov    %eax,-0x38(%ebp)
    if(!converted && size) state->error = 83; /*alloc fail*/
   12fda:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
   12fde:	75 13                	jne    12ff3 <lodepng_encode+0x4e1>
   12fe0:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
   12fe4:	74 0d                	je     12ff3 <lodepng_encode+0x4e1>
   12fe6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12fe9:	c7 80 7c 01 00 00 53 	movl   $0x53,0x17c(%eax)
   12ff0:	00 00 00 
    if(!state->error) {
   12ff3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   12ff6:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   12ffc:	85 c0                	test   %eax,%eax
   12ffe:	75 33                	jne    13033 <lodepng_encode+0x521>
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
   13000:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13003:	83 c0 78             	add    $0x78,%eax
   13006:	83 ec 08             	sub    $0x8,%esp
   13009:	ff 75 18             	pushl  0x18(%ebp)
   1300c:	ff 75 14             	pushl  0x14(%ebp)
   1300f:	50                   	push   %eax
   13010:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13016:	83 c0 0c             	add    $0xc,%eax
   13019:	50                   	push   %eax
   1301a:	ff 75 10             	pushl  0x10(%ebp)
   1301d:	ff 75 c8             	pushl  -0x38(%ebp)
   13020:	e8 c9 8c ff ff       	call   bcee <lodepng_convert>
   13025:	83 c4 20             	add    $0x20,%esp
   13028:	89 c2                	mov    %eax,%edx
   1302a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1302d:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    if(!state->error) {
   13033:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13036:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1303c:	85 c0                	test   %eax,%eax
   1303e:	75 35                	jne    13075 <lodepng_encode+0x563>
      state->error = preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
   13040:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13043:	83 c0 38             	add    $0x38,%eax
   13046:	83 ec 04             	sub    $0x4,%esp
   13049:	50                   	push   %eax
   1304a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13050:	50                   	push   %eax
   13051:	ff 75 18             	pushl  0x18(%ebp)
   13054:	ff 75 14             	pushl  0x14(%ebp)
   13057:	ff 75 c8             	pushl  -0x38(%ebp)
   1305a:	8d 45 bc             	lea    -0x44(%ebp),%eax
   1305d:	50                   	push   %eax
   1305e:	8d 45 c0             	lea    -0x40(%ebp),%eax
   13061:	50                   	push   %eax
   13062:	e8 0d f6 ff ff       	call   12674 <preProcessScanlines>
   13067:	83 c4 20             	add    $0x20,%esp
   1306a:	89 c2                	mov    %eax,%edx
   1306c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1306f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    }
    lodepng_free(converted);
   13075:	83 ec 0c             	sub    $0xc,%esp
   13078:	ff 75 c8             	pushl  -0x38(%ebp)
   1307b:	e8 88 05 ff ff       	call   3608 <lodepng_free>
   13080:	83 c4 10             	add    $0x10,%esp
    if(state->error) goto cleanup;
   13083:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13086:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1308c:	85 c0                	test   %eax,%eax
   1308e:	74 4b                	je     130db <lodepng_encode+0x5c9>
   13090:	e9 96 07 00 00       	jmp    1382b <lodepng_encode+0xd19>
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
   13095:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13098:	83 c0 38             	add    $0x38,%eax
   1309b:	83 ec 04             	sub    $0x4,%esp
   1309e:	50                   	push   %eax
   1309f:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   130a5:	50                   	push   %eax
   130a6:	ff 75 18             	pushl  0x18(%ebp)
   130a9:	ff 75 14             	pushl  0x14(%ebp)
   130ac:	ff 75 10             	pushl  0x10(%ebp)
   130af:	8d 45 bc             	lea    -0x44(%ebp),%eax
   130b2:	50                   	push   %eax
   130b3:	8d 45 c0             	lea    -0x40(%ebp),%eax
   130b6:	50                   	push   %eax
   130b7:	e8 b8 f5 ff ff       	call   12674 <preProcessScanlines>
   130bc:	83 c4 20             	add    $0x20,%esp
   130bf:	89 c2                	mov    %eax,%edx
   130c1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130c4:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   130ca:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130cd:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130d3:	85 c0                	test   %eax,%eax
   130d5:	0f 85 16 07 00 00    	jne    137f1 <lodepng_encode+0xcdf>
  /* output all PNG chunks */ {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
   130db:	83 ec 0c             	sub    $0xc,%esp
   130de:	8d 45 b0             	lea    -0x50(%ebp),%eax
   130e1:	50                   	push   %eax
   130e2:	e8 21 d9 ff ff       	call   10a08 <writeSignature>
   130e7:	83 c4 10             	add    $0x10,%esp
   130ea:	89 c2                	mov    %eax,%edx
   130ec:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130ef:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   130f5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   130f8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   130fe:	85 c0                	test   %eax,%eax
   13100:	0f 85 ee 06 00 00    	jne    137f4 <lodepng_encode+0xce2>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
   13106:	8b 8d d4 fe ff ff    	mov    -0x12c(%ebp),%ecx
   1310c:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
   13112:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   13118:	83 ec 08             	sub    $0x8,%esp
   1311b:	51                   	push   %ecx
   1311c:	52                   	push   %edx
   1311d:	50                   	push   %eax
   1311e:	ff 75 18             	pushl  0x18(%ebp)
   13121:	ff 75 14             	pushl  0x14(%ebp)
   13124:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13127:	50                   	push   %eax
   13128:	e8 4a d9 ff ff       	call   10a77 <addChunk_IHDR>
   1312d:	83 c4 20             	add    $0x20,%esp
   13130:	89 c2                	mov    %eax,%edx
   13132:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13135:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   1313b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1313e:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13144:	85 c0                	test   %eax,%eax
   13146:	0f 85 ab 06 00 00    	jne    137f7 <lodepng_encode+0xce5>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
   1314c:	8b 45 98             	mov    -0x68(%ebp),%eax
   1314f:	85 c0                	test   %eax,%eax
   13151:	74 33                	je     13186 <lodepng_encode+0x674>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
   13153:	8b 55 a4             	mov    -0x5c(%ebp),%edx
   13156:	8b 45 98             	mov    -0x68(%ebp),%eax
   13159:	83 ec 04             	sub    $0x4,%esp
   1315c:	52                   	push   %edx
   1315d:	50                   	push   %eax
   1315e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13161:	50                   	push   %eax
   13162:	e8 9c f8 ff ff       	call   12a03 <addUnknownChunks>
   13167:	83 c4 10             	add    $0x10,%esp
   1316a:	89 c2                	mov    %eax,%edx
   1316c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1316f:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13175:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13178:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1317e:	85 c0                	test   %eax,%eax
   13180:	0f 85 74 06 00 00    	jne    137fa <lodepng_encode+0xce8>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
   13186:	8b 45 88             	mov    -0x78(%ebp),%eax
   13189:	85 c0                	test   %eax,%eax
   1318b:	74 39                	je     131c6 <lodepng_encode+0x6b4>
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
   1318d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13190:	83 c0 38             	add    $0x38,%eax
   13193:	83 ec 04             	sub    $0x4,%esp
   13196:	50                   	push   %eax
   13197:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1319d:	50                   	push   %eax
   1319e:	8d 45 b0             	lea    -0x50(%ebp),%eax
   131a1:	50                   	push   %eax
   131a2:	e8 a4 e4 ff ff       	call   1164b <addChunk_iCCP>
   131a7:	83 c4 10             	add    $0x10,%esp
   131aa:	89 c2                	mov    %eax,%edx
   131ac:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131af:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   131b5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131b8:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   131be:	85 c0                	test   %eax,%eax
   131c0:	0f 85 37 06 00 00    	jne    137fd <lodepng_encode+0xceb>
    }
    if(info.srgb_defined) {
   131c6:	8b 45 80             	mov    -0x80(%ebp),%eax
   131c9:	85 c0                	test   %eax,%eax
   131cb:	74 32                	je     131ff <lodepng_encode+0x6ed>
      state->error = addChunk_sRGB(&outv, &info);
   131cd:	83 ec 08             	sub    $0x8,%esp
   131d0:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   131d6:	50                   	push   %eax
   131d7:	8d 45 b0             	lea    -0x50(%ebp),%eax
   131da:	50                   	push   %eax
   131db:	e8 41 e4 ff ff       	call   11621 <addChunk_sRGB>
   131e0:	83 c4 10             	add    $0x10,%esp
   131e3:	89 c2                	mov    %eax,%edx
   131e5:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131e8:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   131ee:	8b 45 1c             	mov    0x1c(%ebp),%eax
   131f1:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   131f7:	85 c0                	test   %eax,%eax
   131f9:	0f 85 01 06 00 00    	jne    13800 <lodepng_encode+0xcee>
    }
    if(info.gama_defined) {
   131ff:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
   13205:	85 c0                	test   %eax,%eax
   13207:	74 32                	je     1323b <lodepng_encode+0x729>
      state->error = addChunk_gAMA(&outv, &info);
   13209:	83 ec 08             	sub    $0x8,%esp
   1320c:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13212:	50                   	push   %eax
   13213:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13216:	50                   	push   %eax
   13217:	e8 a7 e2 ff ff       	call   114c3 <addChunk_gAMA>
   1321c:	83 c4 10             	add    $0x10,%esp
   1321f:	89 c2                	mov    %eax,%edx
   13221:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13224:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1322a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1322d:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13233:	85 c0                	test   %eax,%eax
   13235:	0f 85 c8 05 00 00    	jne    13803 <lodepng_encode+0xcf1>
    }
    if(info.chrm_defined) {
   1323b:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
   13241:	85 c0                	test   %eax,%eax
   13243:	74 32                	je     13277 <lodepng_encode+0x765>
      state->error = addChunk_cHRM(&outv, &info);
   13245:	83 ec 08             	sub    $0x8,%esp
   13248:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1324e:	50                   	push   %eax
   1324f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13252:	50                   	push   %eax
   13253:	e8 c1 e2 ff ff       	call   11519 <addChunk_cHRM>
   13258:	83 c4 10             	add    $0x10,%esp
   1325b:	89 c2                	mov    %eax,%edx
   1325d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13260:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13266:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13269:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1326f:	85 c0                	test   %eax,%eax
   13271:	0f 85 8f 05 00 00    	jne    13806 <lodepng_encode+0xcf4>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
   13277:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   1327d:	83 f8 03             	cmp    $0x3,%eax
   13280:	75 35                	jne    132b7 <lodepng_encode+0x7a5>
      state->error = addChunk_PLTE(&outv, &info.color);
   13282:	83 ec 08             	sub    $0x8,%esp
   13285:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1328b:	83 c0 0c             	add    $0xc,%eax
   1328e:	50                   	push   %eax
   1328f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13292:	50                   	push   %eax
   13293:	e8 78 d8 ff ff       	call   10b10 <addChunk_PLTE>
   13298:	83 c4 10             	add    $0x10,%esp
   1329b:	89 c2                	mov    %eax,%edx
   1329d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132a0:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   132a6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132a9:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   132af:	85 c0                	test   %eax,%eax
   132b1:	0f 85 52 05 00 00    	jne    13809 <lodepng_encode+0xcf7>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
   132b7:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132ba:	8b 40 6c             	mov    0x6c(%eax),%eax
   132bd:	85 c0                	test   %eax,%eax
   132bf:	74 4b                	je     1330c <lodepng_encode+0x7fa>
   132c1:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   132c7:	83 f8 02             	cmp    $0x2,%eax
   132ca:	74 0b                	je     132d7 <lodepng_encode+0x7c5>
   132cc:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
   132d2:	83 f8 06             	cmp    $0x6,%eax
   132d5:	75 35                	jne    1330c <lodepng_encode+0x7fa>
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
   132d7:	83 ec 08             	sub    $0x8,%esp
   132da:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   132e0:	83 c0 0c             	add    $0xc,%eax
   132e3:	50                   	push   %eax
   132e4:	8d 45 b0             	lea    -0x50(%ebp),%eax
   132e7:	50                   	push   %eax
   132e8:	e8 23 d8 ff ff       	call   10b10 <addChunk_PLTE>
   132ed:	83 c4 10             	add    $0x10,%esp
   132f0:	89 c2                	mov    %eax,%edx
   132f2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132f5:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   132fb:	8b 45 1c             	mov    0x1c(%ebp),%eax
   132fe:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13304:	85 c0                	test   %eax,%eax
   13306:	0f 85 00 05 00 00    	jne    1380c <lodepng_encode+0xcfa>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
   1330c:	83 ec 08             	sub    $0x8,%esp
   1330f:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13315:	83 c0 0c             	add    $0xc,%eax
   13318:	50                   	push   %eax
   13319:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1331c:	50                   	push   %eax
   1331d:	e8 c4 d8 ff ff       	call   10be6 <addChunk_tRNS>
   13322:	83 c4 10             	add    $0x10,%esp
   13325:	89 c2                	mov    %eax,%edx
   13327:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1332a:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13330:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13333:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13339:	85 c0                	test   %eax,%eax
   1333b:	0f 85 ce 04 00 00    	jne    1380f <lodepng_encode+0xcfd>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
   13341:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
   13347:	85 c0                	test   %eax,%eax
   13349:	74 32                	je     1337d <lodepng_encode+0x86b>
      state->error = addChunk_bKGD(&outv, &info);
   1334b:	83 ec 08             	sub    $0x8,%esp
   1334e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13354:	50                   	push   %eax
   13355:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13358:	50                   	push   %eax
   13359:	e8 e4 de ff ff       	call   11242 <addChunk_bKGD>
   1335e:	83 c4 10             	add    $0x10,%esp
   13361:	89 c2                	mov    %eax,%edx
   13363:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13366:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   1336c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1336f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13375:	85 c0                	test   %eax,%eax
   13377:	0f 85 95 04 00 00    	jne    13812 <lodepng_encode+0xd00>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
   1337d:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
   13383:	85 c0                	test   %eax,%eax
   13385:	74 32                	je     133b9 <lodepng_encode+0x8a7>
      state->error = addChunk_pHYs(&outv, &info);
   13387:	83 ec 08             	sub    $0x8,%esp
   1338a:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13390:	50                   	push   %eax
   13391:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13394:	50                   	push   %eax
   13395:	e8 ac e0 ff ff       	call   11446 <addChunk_pHYs>
   1339a:	83 c4 10             	add    $0x10,%esp
   1339d:	89 c2                	mov    %eax,%edx
   1339f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133a2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   133a8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133ab:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   133b1:	85 c0                	test   %eax,%eax
   133b3:	0f 85 5c 04 00 00    	jne    13815 <lodepng_encode+0xd03>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
   133b9:	8b 45 9c             	mov    -0x64(%ebp),%eax
   133bc:	85 c0                	test   %eax,%eax
   133be:	74 33                	je     133f3 <lodepng_encode+0x8e1>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
   133c0:	8b 55 a8             	mov    -0x58(%ebp),%edx
   133c3:	8b 45 9c             	mov    -0x64(%ebp),%eax
   133c6:	83 ec 04             	sub    $0x4,%esp
   133c9:	52                   	push   %edx
   133ca:	50                   	push   %eax
   133cb:	8d 45 b0             	lea    -0x50(%ebp),%eax
   133ce:	50                   	push   %eax
   133cf:	e8 2f f6 ff ff       	call   12a03 <addUnknownChunks>
   133d4:	83 c4 10             	add    $0x10,%esp
   133d7:	89 c2                	mov    %eax,%edx
   133d9:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133dc:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   133e2:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133e5:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   133eb:	85 c0                	test   %eax,%eax
   133ed:	0f 85 25 04 00 00    	jne    13818 <lodepng_encode+0xd06>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
   133f3:	8b 45 1c             	mov    0x1c(%ebp),%eax
   133f6:	8d 48 38             	lea    0x38(%eax),%ecx
   133f9:	8b 55 bc             	mov    -0x44(%ebp),%edx
   133fc:	8b 45 c0             	mov    -0x40(%ebp),%eax
   133ff:	51                   	push   %ecx
   13400:	52                   	push   %edx
   13401:	50                   	push   %eax
   13402:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13405:	50                   	push   %eax
   13406:	e8 bd d9 ff ff       	call   10dc8 <addChunk_IDAT>
   1340b:	83 c4 10             	add    $0x10,%esp
   1340e:	89 c2                	mov    %eax,%edx
   13410:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13413:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   13419:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1341c:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13422:	85 c0                	test   %eax,%eax
   13424:	0f 85 f1 03 00 00    	jne    1381b <lodepng_encode+0xd09>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
   1342a:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
   13430:	85 c0                	test   %eax,%eax
   13432:	74 35                	je     13469 <lodepng_encode+0x957>
      state->error = addChunk_tIME(&outv, &info.time);
   13434:	83 ec 08             	sub    $0x8,%esp
   13437:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   1343d:	83 c0 60             	add    $0x60,%eax
   13440:	50                   	push   %eax
   13441:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13444:	50                   	push   %eax
   13445:	e8 5c df ff ff       	call   113a6 <addChunk_tIME>
   1344a:	83 c4 10             	add    $0x10,%esp
   1344d:	89 c2                	mov    %eax,%edx
   1344f:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13452:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   13458:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1345b:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   13461:	85 c0                	test   %eax,%eax
   13463:	0f 85 b5 03 00 00    	jne    1381e <lodepng_encode+0xd0c>
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   13469:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   13470:	e9 12 01 00 00       	jmp    13587 <lodepng_encode+0xa75>
      if(lodepng_strlen(info.text_keys[i]) > 79) {
   13475:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1347b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1347e:	c1 e2 02             	shl    $0x2,%edx
   13481:	01 d0                	add    %edx,%eax
   13483:	8b 00                	mov    (%eax),%eax
   13485:	83 ec 0c             	sub    $0xc,%esp
   13488:	50                   	push   %eax
   13489:	e8 f5 01 ff ff       	call   3683 <lodepng_strlen>
   1348e:	83 c4 10             	add    $0x10,%esp
   13491:	83 f8 4f             	cmp    $0x4f,%eax
   13494:	7e 12                	jle    134a8 <lodepng_encode+0x996>
        state->error = 66; /*text chunk too large*/
   13496:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13499:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   134a0:	00 00 00 
        goto cleanup;
   134a3:	e9 83 03 00 00       	jmp    1382b <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.text_keys[i]) < 1) {
   134a8:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   134ae:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   134b1:	c1 e2 02             	shl    $0x2,%edx
   134b4:	01 d0                	add    %edx,%eax
   134b6:	8b 00                	mov    (%eax),%eax
   134b8:	83 ec 0c             	sub    $0xc,%esp
   134bb:	50                   	push   %eax
   134bc:	e8 c2 01 ff ff       	call   3683 <lodepng_strlen>
   134c1:	83 c4 10             	add    $0x10,%esp
   134c4:	85 c0                	test   %eax,%eax
   134c6:	7f 12                	jg     134da <lodepng_encode+0x9c8>
        state->error = 67; /*text chunk too small*/
   134c8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134cb:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   134d2:	00 00 00 
        goto cleanup;
   134d5:	e9 51 03 00 00       	jmp    1382b <lodepng_encode+0xd19>
      }
      if(state->encoder.text_compression) {
   134da:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134dd:	8b 40 74             	mov    0x74(%eax),%eax
   134e0:	85 c0                	test   %eax,%eax
   134e2:	74 52                	je     13536 <lodepng_encode+0xa24>
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
   134e4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   134e7:	8d 48 38             	lea    0x38(%eax),%ecx
   134ea:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   134f0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   134f3:	c1 e2 02             	shl    $0x2,%edx
   134f6:	01 d0                	add    %edx,%eax
   134f8:	8b 10                	mov    (%eax),%edx
   134fa:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   13500:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
   13503:	c1 e3 02             	shl    $0x2,%ebx
   13506:	01 d8                	add    %ebx,%eax
   13508:	8b 00                	mov    (%eax),%eax
   1350a:	51                   	push   %ecx
   1350b:	52                   	push   %edx
   1350c:	50                   	push   %eax
   1350d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13510:	50                   	push   %eax
   13511:	e8 fa d9 ff ff       	call   10f10 <addChunk_zTXt>
   13516:	83 c4 10             	add    $0x10,%esp
   13519:	89 c2                	mov    %eax,%edx
   1351b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1351e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13524:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13527:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1352d:	85 c0                	test   %eax,%eax
   1352f:	74 52                	je     13583 <lodepng_encode+0xa71>
   13531:	e9 f5 02 00 00       	jmp    1382b <lodepng_encode+0xd19>
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
   13536:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
   1353c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1353f:	c1 e2 02             	shl    $0x2,%edx
   13542:	01 d0                	add    %edx,%eax
   13544:	8b 10                	mov    (%eax),%edx
   13546:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   1354c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   1354f:	c1 e1 02             	shl    $0x2,%ecx
   13552:	01 c8                	add    %ecx,%eax
   13554:	8b 00                	mov    (%eax),%eax
   13556:	83 ec 04             	sub    $0x4,%esp
   13559:	52                   	push   %edx
   1355a:	50                   	push   %eax
   1355b:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1355e:	50                   	push   %eax
   1355f:	e8 ec d8 ff ff       	call   10e50 <addChunk_tEXt>
   13564:	83 c4 10             	add    $0x10,%esp
   13567:	89 c2                	mov    %eax,%edx
   13569:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1356c:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13572:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13575:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1357b:	85 c0                	test   %eax,%eax
   1357d:	0f 85 9e 02 00 00    	jne    13821 <lodepng_encode+0xd0f>
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
    }
    /*tEXt and/or zTXt*/
    for(i = 0; i != info.text_num; ++i) {
   13583:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13587:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   1358d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13590:	0f 85 df fe ff ff    	jne    13475 <lodepng_encode+0x963>
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
   13596:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13599:	8b 40 70             	mov    0x70(%eax),%eax
   1359c:	85 c0                	test   %eax,%eax
   1359e:	0f 84 e3 00 00 00    	je     13687 <lodepng_encode+0xb75>
      unsigned already_added_id_text = 0;
   135a4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      for(i = 0; i != info.text_num; ++i) {
   135ab:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   135b2:	e9 85 00 00 00       	jmp    1363c <lodepng_encode+0xb2a>
        const char* k = info.text_keys[i];
   135b7:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
   135bd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   135c0:	c1 e2 02             	shl    $0x2,%edx
   135c3:	01 d0                	add    %edx,%eax
   135c5:	8b 00                	mov    (%eax),%eax
   135c7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   135ca:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   135cd:	0f b6 00             	movzbl (%eax),%eax
   135d0:	3c 4c                	cmp    $0x4c,%al
   135d2:	75 64                	jne    13638 <lodepng_encode+0xb26>
   135d4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   135d7:	83 c0 01             	add    $0x1,%eax
   135da:	0f b6 00             	movzbl (%eax),%eax
   135dd:	3c 6f                	cmp    $0x6f,%al
   135df:	75 57                	jne    13638 <lodepng_encode+0xb26>
   135e1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   135e4:	83 c0 02             	add    $0x2,%eax
   135e7:	0f b6 00             	movzbl (%eax),%eax
   135ea:	3c 64                	cmp    $0x64,%al
   135ec:	75 4a                	jne    13638 <lodepng_encode+0xb26>
   135ee:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   135f1:	83 c0 03             	add    $0x3,%eax
   135f4:	0f b6 00             	movzbl (%eax),%eax
   135f7:	3c 65                	cmp    $0x65,%al
   135f9:	75 3d                	jne    13638 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   135fb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   135fe:	83 c0 04             	add    $0x4,%eax
   13601:	0f b6 00             	movzbl (%eax),%eax
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
        const char* k = info.text_keys[i];
        /* Could use strcmp, but we're not calling or reimplementing this C library function for this use only */
        if(k[0] == 'L' && k[1] == 'o' && k[2] == 'd' && k[3] == 'e' &&
   13604:	3c 50                	cmp    $0x50,%al
   13606:	75 30                	jne    13638 <lodepng_encode+0xb26>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
   13608:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   1360b:	83 c0 05             	add    $0x5,%eax
   1360e:	0f b6 00             	movzbl (%eax),%eax
   13611:	3c 4e                	cmp    $0x4e,%al
   13613:	75 23                	jne    13638 <lodepng_encode+0xb26>
   13615:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13618:	83 c0 06             	add    $0x6,%eax
   1361b:	0f b6 00             	movzbl (%eax),%eax
   1361e:	3c 47                	cmp    $0x47,%al
   13620:	75 16                	jne    13638 <lodepng_encode+0xb26>
   13622:	8b 45 c4             	mov    -0x3c(%ebp),%eax
   13625:	83 c0 07             	add    $0x7,%eax
   13628:	0f b6 00             	movzbl (%eax),%eax
   1362b:	84 c0                	test   %al,%al
   1362d:	75 09                	jne    13638 <lodepng_encode+0xb26>
          already_added_id_text = 1;
   1362f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
          break;
   13636:	eb 13                	jmp    1364b <lodepng_encode+0xb39>
      }
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id) {
      unsigned already_added_id_text = 0;
      for(i = 0; i != info.text_num; ++i) {
   13638:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   1363c:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
   13642:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13645:	0f 85 6c ff ff ff    	jne    135b7 <lodepng_encode+0xaa5>
           k[4] == 'P' && k[5] == 'N' && k[6] == 'G' && k[7] == '\0') {
          already_added_id_text = 1;
          break;
        }
      }
      if(already_added_id_text == 0) {
   1364b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   1364f:	75 36                	jne    13687 <lodepng_encode+0xb75>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
   13651:	a1 40 e4 01 00       	mov    0x1e440,%eax
   13656:	83 ec 04             	sub    $0x4,%esp
   13659:	50                   	push   %eax
   1365a:	68 84 a3 01 00       	push   $0x1a384
   1365f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13662:	50                   	push   %eax
   13663:	e8 e8 d7 ff ff       	call   10e50 <addChunk_tEXt>
   13668:	83 c4 10             	add    $0x10,%esp
   1366b:	89 c2                	mov    %eax,%edx
   1366d:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13670:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
        if(state->error) goto cleanup;
   13676:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13679:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1367f:	85 c0                	test   %eax,%eax
   13681:	0f 85 9d 01 00 00    	jne    13824 <lodepng_encode+0xd12>
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13687:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1368e:	e9 e6 00 00 00       	jmp    13779 <lodepng_encode+0xc67>
      if(lodepng_strlen(info.itext_keys[i]) > 79) {
   13693:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13699:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1369c:	c1 e2 02             	shl    $0x2,%edx
   1369f:	01 d0                	add    %edx,%eax
   136a1:	8b 00                	mov    (%eax),%eax
   136a3:	83 ec 0c             	sub    $0xc,%esp
   136a6:	50                   	push   %eax
   136a7:	e8 d7 ff fe ff       	call   3683 <lodepng_strlen>
   136ac:	83 c4 10             	add    $0x10,%esp
   136af:	83 f8 4f             	cmp    $0x4f,%eax
   136b2:	7e 12                	jle    136c6 <lodepng_encode+0xbb4>
        state->error = 66; /*text chunk too large*/
   136b4:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136b7:	c7 80 7c 01 00 00 42 	movl   $0x42,0x17c(%eax)
   136be:	00 00 00 
        goto cleanup;
   136c1:	e9 65 01 00 00       	jmp    1382b <lodepng_encode+0xd19>
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
   136c6:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   136cc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   136cf:	c1 e2 02             	shl    $0x2,%edx
   136d2:	01 d0                	add    %edx,%eax
   136d4:	8b 00                	mov    (%eax),%eax
   136d6:	83 ec 0c             	sub    $0xc,%esp
   136d9:	50                   	push   %eax
   136da:	e8 a4 ff fe ff       	call   3683 <lodepng_strlen>
   136df:	83 c4 10             	add    $0x10,%esp
   136e2:	85 c0                	test   %eax,%eax
   136e4:	7f 12                	jg     136f8 <lodepng_encode+0xbe6>
        state->error = 67; /*text chunk too small*/
   136e6:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136e9:	c7 80 7c 01 00 00 43 	movl   $0x43,0x17c(%eax)
   136f0:	00 00 00 
        goto cleanup;
   136f3:	e9 33 01 00 00       	jmp    1382b <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
   136f8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   136fb:	8d 78 38             	lea    0x38(%eax),%edi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   136fe:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
   13704:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13707:	c1 e2 02             	shl    $0x2,%edx
   1370a:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1370c:	8b 30                	mov    (%eax),%esi
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1370e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
   13714:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13717:	c1 e2 02             	shl    $0x2,%edx
   1371a:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1371c:	8b 18                	mov    (%eax),%ebx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1371e:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
   13724:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13727:	c1 e2 02             	shl    $0x2,%edx
   1372a:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1372c:	8b 08                	mov    (%eax),%ecx
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
   1372e:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
   13734:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   13737:	c1 e2 02             	shl    $0x2,%edx
   1373a:	01 d0                	add    %edx,%eax
      }
      if(lodepng_strlen(info.itext_keys[i]) < 1) {
        state->error = 67; /*text chunk too small*/
        goto cleanup;
      }
      state->error = addChunk_iTXt(
   1373c:	8b 10                	mov    (%eax),%edx
   1373e:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13741:	8b 40 74             	mov    0x74(%eax),%eax
   13744:	83 ec 04             	sub    $0x4,%esp
   13747:	57                   	push   %edi
   13748:	56                   	push   %esi
   13749:	53                   	push   %ebx
   1374a:	51                   	push   %ecx
   1374b:	52                   	push   %edx
   1374c:	50                   	push   %eax
   1374d:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13750:	50                   	push   %eax
   13751:	e8 dc d8 ff ff       	call   11032 <addChunk_iTXt>
   13756:	83 c4 20             	add    $0x20,%esp
   13759:	89 c2                	mov    %eax,%edx
   1375b:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1375e:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13764:	8b 45 1c             	mov    0x1c(%ebp),%eax
   13767:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   1376d:	85 c0                	test   %eax,%eax
   1376f:	0f 85 b2 00 00 00    	jne    13827 <lodepng_encode+0xd15>
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
      }
    }
    /*iTXt*/
    for(i = 0; i != info.itext_num; ++i) {
   13775:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   13779:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
   1377f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   13782:	0f 85 0b ff ff ff    	jne    13693 <lodepng_encode+0xb81>
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
   13788:	8b 45 a0             	mov    -0x60(%ebp),%eax
   1378b:	85 c0                	test   %eax,%eax
   1378d:	74 2f                	je     137be <lodepng_encode+0xcac>
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
   1378f:	8b 55 ac             	mov    -0x54(%ebp),%edx
   13792:	8b 45 a0             	mov    -0x60(%ebp),%eax
   13795:	83 ec 04             	sub    $0x4,%esp
   13798:	52                   	push   %edx
   13799:	50                   	push   %eax
   1379a:	8d 45 b0             	lea    -0x50(%ebp),%eax
   1379d:	50                   	push   %eax
   1379e:	e8 60 f2 ff ff       	call   12a03 <addUnknownChunks>
   137a3:	83 c4 10             	add    $0x10,%esp
   137a6:	89 c2                	mov    %eax,%edx
   137a8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137ab:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
      if(state->error) goto cleanup;
   137b1:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137b4:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   137ba:	85 c0                	test   %eax,%eax
   137bc:	75 6c                	jne    1382a <lodepng_encode+0xd18>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    state->error = addChunk_IEND(&outv);
   137be:	83 ec 0c             	sub    $0xc,%esp
   137c1:	8d 45 b0             	lea    -0x50(%ebp),%eax
   137c4:	50                   	push   %eax
   137c5:	e8 6d d6 ff ff       	call   10e37 <addChunk_IEND>
   137ca:	83 c4 10             	add    $0x10,%esp
   137cd:	89 c2                	mov    %eax,%edx
   137cf:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137d2:	89 90 7c 01 00 00    	mov    %edx,0x17c(%eax)
    if(state->error) goto cleanup;
   137d8:	8b 45 1c             	mov    0x1c(%ebp),%eax
   137db:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
   137e1:	85 c0                	test   %eax,%eax
   137e3:	eb 46                	jmp    1382b <lodepng_encode+0xd19>
  if(info_png->interlace_method > 1) {
    state->error = 71; /*error: invalid interlace mode*/
    goto cleanup;
  }
  state->error = checkColorValidity(info_png->color.colortype, info_png->color.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   137e5:	90                   	nop
   137e6:	eb 43                	jmp    1382b <lodepng_encode+0xd19>
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) goto cleanup; /*error: invalid color type given*/
   137e8:	90                   	nop
   137e9:	eb 40                	jmp    1382b <lodepng_encode+0xd19>
      /*the PNG specification does not allow to use grayscale color with RGB ICC profile, so disallow gray.*/
      stats.allow_greyscale = 0;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = lodepng_compute_color_stats(&stats, image, w, h, &state->info_raw);
    if(state->error) goto cleanup;
   137eb:	90                   	nop
   137ec:	eb 3d                	jmp    1382b <lodepng_encode+0xd19>
      state->error = lodepng_color_stats_add(&stats, r, g, b, 65535);
      if(state->error) goto cleanup;
    }
#endif /* LODEPNG_COMPILE_ANCILLARY_CHUNKS */
    state->error = auto_choose_color(&info.color, &state->info_raw, &stats);
    if(state->error) goto cleanup;
   137ee:	90                   	nop
   137ef:	eb 3a                	jmp    1382b <lodepng_encode+0xd19>
    }
    lodepng_free(converted);
    if(state->error) goto cleanup;
  } else {
    state->error = preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);
    if(state->error) goto cleanup;
   137f1:	90                   	nop
   137f2:	eb 37                	jmp    1382b <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    state->error = writeSignature(&outv);
    if(state->error) goto cleanup;
   137f4:	90                   	nop
   137f5:	eb 34                	jmp    1382b <lodepng_encode+0xd19>
    /*IHDR*/
    state->error = addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
    if(state->error) goto cleanup;
   137f7:	90                   	nop
   137f8:	eb 31                	jmp    1382b <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) goto cleanup;
   137fa:	90                   	nop
   137fb:	eb 2e                	jmp    1382b <lodepng_encode+0xd19>
    }
    /*color profile chunks must come before PLTE */
    if(info.iccp_defined) {
      state->error = addChunk_iCCP(&outv, &info, &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   137fd:	90                   	nop
   137fe:	eb 2b                	jmp    1382b <lodepng_encode+0xd19>
    }
    if(info.srgb_defined) {
      state->error = addChunk_sRGB(&outv, &info);
      if(state->error) goto cleanup;
   13800:	90                   	nop
   13801:	eb 28                	jmp    1382b <lodepng_encode+0xd19>
    }
    if(info.gama_defined) {
      state->error = addChunk_gAMA(&outv, &info);
      if(state->error) goto cleanup;
   13803:	90                   	nop
   13804:	eb 25                	jmp    1382b <lodepng_encode+0xd19>
    }
    if(info.chrm_defined) {
      state->error = addChunk_cHRM(&outv, &info);
      if(state->error) goto cleanup;
   13806:	90                   	nop
   13807:	eb 22                	jmp    1382b <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE) {
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   13809:	90                   	nop
   1380a:	eb 1f                	jmp    1382b <lodepng_encode+0xd19>
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA)) {
      /*force_palette means: write suggested palette for truecolor in PLTE chunk*/
      state->error = addChunk_PLTE(&outv, &info.color);
      if(state->error) goto cleanup;
   1380c:	90                   	nop
   1380d:	eb 1c                	jmp    1382b <lodepng_encode+0xd19>
    }
    /*tRNS (this will only add if when necessary) */
    state->error = addChunk_tRNS(&outv, &info.color);
    if(state->error) goto cleanup;
   1380f:	90                   	nop
   13810:	eb 19                	jmp    1382b <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) {
      state->error = addChunk_bKGD(&outv, &info);
      if(state->error) goto cleanup;
   13812:	90                   	nop
   13813:	eb 16                	jmp    1382b <lodepng_encode+0xd19>
    }
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) {
      state->error = addChunk_pHYs(&outv, &info);
      if(state->error) goto cleanup;
   13815:	90                   	nop
   13816:	eb 13                	jmp    1382b <lodepng_encode+0xd19>
    }

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) goto cleanup;
   13818:	90                   	nop
   13819:	eb 10                	jmp    1382b <lodepng_encode+0xd19>
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) goto cleanup;
   1381b:	90                   	nop
   1381c:	eb 0d                	jmp    1382b <lodepng_encode+0xd19>
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) {
      state->error = addChunk_tIME(&outv, &info.time);
      if(state->error) goto cleanup;
   1381e:	90                   	nop
   1381f:	eb 0a                	jmp    1382b <lodepng_encode+0xd19>
      if(state->encoder.text_compression) {
        state->error = addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
        if(state->error) goto cleanup;
      } else {
        state->error = addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
        if(state->error) goto cleanup;
   13821:	90                   	nop
   13822:	eb 07                	jmp    1382b <lodepng_encode+0xd19>
          break;
        }
      }
      if(already_added_id_text == 0) {
        state->error = addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
        if(state->error) goto cleanup;
   13824:	90                   	nop
   13825:	eb 04                	jmp    1382b <lodepng_encode+0xd19>
      }
      state->error = addChunk_iTXt(
          &outv, state->encoder.text_compression,
          info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
          &state->encoder.zlibsettings);
      if(state->error) goto cleanup;
   13827:	90                   	nop
   13828:	eb 01                	jmp    1382b <lodepng_encode+0xd19>
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2]) {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) goto cleanup;
   1382a:	90                   	nop
    state->error = addChunk_IEND(&outv);
    if(state->error) goto cleanup;
  }

cleanup:
  lodepng_info_cleanup(&info);
   1382b:	83 ec 0c             	sub    $0xc,%esp
   1382e:	8d 85 cc fe ff ff    	lea    -0x134(%ebp),%eax
   13834:	50                   	push   %eax
   13835:	e8 34 65 ff ff       	call   9d6e <lodepng_info_cleanup>
   1383a:	83 c4 10             	add    $0x10,%esp
  lodepng_free(data);
   1383d:	8b 45 c0             	mov    -0x40(%ebp),%eax
   13840:	83 ec 0c             	sub    $0xc,%esp
   13843:	50                   	push   %eax
   13844:	e8 bf fd fe ff       	call   3608 <lodepng_free>
   13849:	83 c4 10             	add    $0x10,%esp

  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
   1384c:	8b 55 b0             	mov    -0x50(%ebp),%edx
   1384f:	8b 45 08             	mov    0x8(%ebp),%eax
   13852:	89 10                	mov    %edx,(%eax)
  *outsize = outv.size;
   13854:	8b 55 b4             	mov    -0x4c(%ebp),%edx
   13857:	8b 45 0c             	mov    0xc(%ebp),%eax
   1385a:	89 10                	mov    %edx,(%eax)

  return state->error;
   1385c:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1385f:	8b 80 7c 01 00 00    	mov    0x17c(%eax),%eax
}
   13865:	8d 65 f4             	lea    -0xc(%ebp),%esp
   13868:	5b                   	pop    %ebx
   13869:	5e                   	pop    %esi
   1386a:	5f                   	pop    %edi
   1386b:	5d                   	pop    %ebp
   1386c:	c3                   	ret    

0001386d <lodepng_encode_memory>:

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth) {
   1386d:	55                   	push   %ebp
   1386e:	89 e5                	mov    %esp,%ebp
   13870:	81 ec 98 01 00 00    	sub    $0x198,%esp
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
   13876:	83 ec 0c             	sub    $0xc,%esp
   13879:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   1387f:	50                   	push   %eax
   13880:	e8 38 d0 ff ff       	call   108bd <lodepng_state_init>
   13885:	83 c4 10             	add    $0x10,%esp
  state.info_raw.colortype = colortype;
   13888:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1388b:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
  state.info_raw.bitdepth = bitdepth;
   13891:	8b 45 20             	mov    0x20(%ebp),%eax
   13894:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
  state.info_png.color.colortype = colortype;
   1389a:	8b 45 1c             	mov    0x1c(%ebp),%eax
   1389d:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  state.info_png.color.bitdepth = bitdepth;
   138a3:	8b 45 20             	mov    0x20(%ebp),%eax
   138a6:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
  lodepng_encode(out, outsize, image, w, h, &state);
   138ac:	83 ec 08             	sub    $0x8,%esp
   138af:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   138b5:	50                   	push   %eax
   138b6:	ff 75 18             	pushl  0x18(%ebp)
   138b9:	ff 75 14             	pushl  0x14(%ebp)
   138bc:	ff 75 10             	pushl  0x10(%ebp)
   138bf:	ff 75 0c             	pushl  0xc(%ebp)
   138c2:	ff 75 08             	pushl  0x8(%ebp)
   138c5:	e8 48 f2 ff ff       	call   12b12 <lodepng_encode>
   138ca:	83 c4 20             	add    $0x20,%esp
  error = state.error;
   138cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   138d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_state_cleanup(&state);
   138d3:	83 ec 0c             	sub    $0xc,%esp
   138d6:	8d 85 74 fe ff ff    	lea    -0x18c(%ebp),%eax
   138dc:	50                   	push   %eax
   138dd:	e8 35 d0 ff ff       	call   10917 <lodepng_state_cleanup>
   138e2:	83 c4 10             	add    $0x10,%esp
  return error;
   138e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   138e8:	c9                   	leave  
   138e9:	c3                   	ret    

000138ea <lodepng_encode32>:

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   138ea:	55                   	push   %ebp
   138eb:	89 e5                	mov    %esp,%ebp
   138ed:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
   138f0:	83 ec 04             	sub    $0x4,%esp
   138f3:	6a 08                	push   $0x8
   138f5:	6a 06                	push   $0x6
   138f7:	ff 75 18             	pushl  0x18(%ebp)
   138fa:	ff 75 14             	pushl  0x14(%ebp)
   138fd:	ff 75 10             	pushl  0x10(%ebp)
   13900:	ff 75 0c             	pushl  0xc(%ebp)
   13903:	ff 75 08             	pushl  0x8(%ebp)
   13906:	e8 62 ff ff ff       	call   1386d <lodepng_encode_memory>
   1390b:	83 c4 20             	add    $0x20,%esp
}
   1390e:	c9                   	leave  
   1390f:	c3                   	ret    

00013910 <lodepng_encode24>:

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h) {
   13910:	55                   	push   %ebp
   13911:	89 e5                	mov    %esp,%ebp
   13913:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
   13916:	83 ec 04             	sub    $0x4,%esp
   13919:	6a 08                	push   $0x8
   1391b:	6a 02                	push   $0x2
   1391d:	ff 75 18             	pushl  0x18(%ebp)
   13920:	ff 75 14             	pushl  0x14(%ebp)
   13923:	ff 75 10             	pushl  0x10(%ebp)
   13926:	ff 75 0c             	pushl  0xc(%ebp)
   13929:	ff 75 08             	pushl  0x8(%ebp)
   1392c:	e8 3c ff ff ff       	call   1386d <lodepng_encode_memory>
   13931:	83 c4 20             	add    $0x20,%esp
}
   13934:	c9                   	leave  
   13935:	c3                   	ret    

00013936 <lodepng_encode_file>:

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth) {
   13936:	55                   	push   %ebp
   13937:	89 e5                	mov    %esp,%ebp
   13939:	83 ec 18             	sub    $0x18,%esp
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
   1393c:	83 ec 04             	sub    $0x4,%esp
   1393f:	ff 75 1c             	pushl  0x1c(%ebp)
   13942:	ff 75 18             	pushl  0x18(%ebp)
   13945:	ff 75 14             	pushl  0x14(%ebp)
   13948:	ff 75 10             	pushl  0x10(%ebp)
   1394b:	ff 75 0c             	pushl  0xc(%ebp)
   1394e:	8d 45 ec             	lea    -0x14(%ebp),%eax
   13951:	50                   	push   %eax
   13952:	8d 45 f0             	lea    -0x10(%ebp),%eax
   13955:	50                   	push   %eax
   13956:	e8 12 ff ff ff       	call   1386d <lodepng_encode_memory>
   1395b:	83 c4 20             	add    $0x20,%esp
   1395e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
   13961:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   13965:	75 19                	jne    13980 <lodepng_encode_file+0x4a>
   13967:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1396a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1396d:	83 ec 04             	sub    $0x4,%esp
   13970:	ff 75 08             	pushl  0x8(%ebp)
   13973:	52                   	push   %edx
   13974:	50                   	push   %eax
   13975:	e8 36 01 ff ff       	call   3ab0 <lodepng_save_file>
   1397a:	83 c4 10             	add    $0x10,%esp
   1397d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lodepng_free(buffer);
   13980:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13983:	83 ec 0c             	sub    $0xc,%esp
   13986:	50                   	push   %eax
   13987:	e8 7c fc fe ff       	call   3608 <lodepng_free>
   1398c:	83 c4 10             	add    $0x10,%esp
  return error;
   1398f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   13992:	c9                   	leave  
   13993:	c3                   	ret    

00013994 <lodepng_encode32_file>:

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   13994:	55                   	push   %ebp
   13995:	89 e5                	mov    %esp,%ebp
   13997:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
   1399a:	83 ec 08             	sub    $0x8,%esp
   1399d:	6a 08                	push   $0x8
   1399f:	6a 06                	push   $0x6
   139a1:	ff 75 14             	pushl  0x14(%ebp)
   139a4:	ff 75 10             	pushl  0x10(%ebp)
   139a7:	ff 75 0c             	pushl  0xc(%ebp)
   139aa:	ff 75 08             	pushl  0x8(%ebp)
   139ad:	e8 84 ff ff ff       	call   13936 <lodepng_encode_file>
   139b2:	83 c4 20             	add    $0x20,%esp
}
   139b5:	c9                   	leave  
   139b6:	c3                   	ret    

000139b7 <lodepng_encode24_file>:

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h) {
   139b7:	55                   	push   %ebp
   139b8:	89 e5                	mov    %esp,%ebp
   139ba:	83 ec 08             	sub    $0x8,%esp
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
   139bd:	83 ec 08             	sub    $0x8,%esp
   139c0:	6a 08                	push   $0x8
   139c2:	6a 02                	push   $0x2
   139c4:	ff 75 14             	pushl  0x14(%ebp)
   139c7:	ff 75 10             	pushl  0x10(%ebp)
   139ca:	ff 75 0c             	pushl  0xc(%ebp)
   139cd:	ff 75 08             	pushl  0x8(%ebp)
   139d0:	e8 61 ff ff ff       	call   13936 <lodepng_encode_file>
   139d5:	83 c4 20             	add    $0x20,%esp
}
   139d8:	c9                   	leave  
   139d9:	c3                   	ret    

000139da <lodepng_encoder_settings_init>:
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings) {
   139da:	55                   	push   %ebp
   139db:	89 e5                	mov    %esp,%ebp
  lodepng_compress_settings_init(&settings->zlibsettings);
   139dd:	8b 45 08             	mov    0x8(%ebp),%eax
   139e0:	50                   	push   %eax
   139e1:	e8 71 49 ff ff       	call   8357 <lodepng_compress_settings_init>
   139e6:	83 c4 04             	add    $0x4,%esp
  settings->filter_palette_zero = 1;
   139e9:	8b 45 08             	mov    0x8(%ebp),%eax
   139ec:	c7 40 28 01 00 00 00 	movl   $0x1,0x28(%eax)
  settings->filter_strategy = LFS_MINSUM;
   139f3:	8b 45 08             	mov    0x8(%ebp),%eax
   139f6:	c7 40 2c 05 00 00 00 	movl   $0x5,0x2c(%eax)
  settings->auto_convert = 1;
   139fd:	8b 45 08             	mov    0x8(%ebp),%eax
   13a00:	c7 40 24 01 00 00 00 	movl   $0x1,0x24(%eax)
  settings->force_palette = 0;
   13a07:	8b 45 08             	mov    0x8(%ebp),%eax
   13a0a:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  settings->predefined_filters = 0;
   13a11:	8b 45 08             	mov    0x8(%ebp),%eax
   13a14:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
   13a1b:	8b 45 08             	mov    0x8(%ebp),%eax
   13a1e:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  settings->text_compression = 1;
   13a25:	8b 45 08             	mov    0x8(%ebp),%eax
   13a28:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}
   13a2f:	90                   	nop
   13a30:	c9                   	leave  
   13a31:	c3                   	ret    

00013a32 <lodepng_error_text>:
#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code) {
   13a32:	55                   	push   %ebp
   13a33:	89 e5                	mov    %esp,%ebp
  switch(code) {
   13a35:	83 7d 08 71          	cmpl   $0x71,0x8(%ebp)
   13a39:	0f 87 c1 03 00 00    	ja     13e00 <lodepng_error_text+0x3ce>
   13a3f:	8b 45 08             	mov    0x8(%ebp),%eax
   13a42:	c1 e0 02             	shl    $0x2,%eax
   13a45:	05 c0 b6 01 00       	add    $0x1b6c0,%eax
   13a4a:	8b 00                	mov    (%eax),%eax
   13a4c:	ff e0                	jmp    *%eax
    case 0: return "no error, everything went ok";
   13a4e:	b8 8c a3 01 00       	mov    $0x1a38c,%eax
   13a53:	e9 ad 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
   13a58:	b8 a9 a3 01 00       	mov    $0x1a3a9,%eax
   13a5d:	e9 a3 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
   13a62:	b8 bc a3 01 00       	mov    $0x1a3bc,%eax
   13a67:	e9 99 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
   13a6c:	b8 f4 a3 01 00       	mov    $0x1a3f4,%eax
   13a71:	e9 8f 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 13: return "problem while processing dynamic deflate block";
   13a76:	b8 2c a4 01 00       	mov    $0x1a42c,%eax
   13a7b:	e9 85 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 14: return "problem while processing dynamic deflate block";
   13a80:	b8 2c a4 01 00       	mov    $0x1a42c,%eax
   13a85:	e9 7b 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 15: return "problem while processing dynamic deflate block";
   13a8a:	b8 2c a4 01 00       	mov    $0x1a42c,%eax
   13a8f:	e9 71 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    /*this error could happen if there are only 0 or 1 symbols present in the huffman code:*/
    case 16: return "invalid code while processing dynamic deflate block";
   13a94:	b8 5c a4 01 00       	mov    $0x1a45c,%eax
   13a99:	e9 67 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 17: return "end of out buffer memory reached while inflating";
   13a9e:	b8 90 a4 01 00       	mov    $0x1a490,%eax
   13aa3:	e9 5d 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 18: return "invalid distance code while inflating";
   13aa8:	b8 c4 a4 01 00       	mov    $0x1a4c4,%eax
   13aad:	e9 53 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 19: return "end of out buffer memory reached while inflating";
   13ab2:	b8 90 a4 01 00       	mov    $0x1a490,%eax
   13ab7:	e9 49 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 20: return "invalid deflate block BTYPE encountered while decoding";
   13abc:	b8 ec a4 01 00       	mov    $0x1a4ec,%eax
   13ac1:	e9 3f 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
   13ac6:	b8 24 a5 01 00       	mov    $0x1a524,%eax
   13acb:	e9 35 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>

    /*end of out buffer memory reached while inflating:
    This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
    all the pixels of the image, given the color depth and image dimensions. Something that doesn't
    happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
   13ad0:	b8 90 a4 01 00       	mov    $0x1a490,%eax
   13ad5:	e9 2b 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 23: return "end of in buffer memory reached while inflating";
   13ada:	b8 5c a5 01 00       	mov    $0x1a55c,%eax
   13adf:	e9 21 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 24: return "invalid FCHECK in zlib header";
   13ae4:	b8 8c a5 01 00       	mov    $0x1a58c,%eax
   13ae9:	e9 17 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 25: return "invalid compression method in zlib header";
   13aee:	b8 ac a5 01 00       	mov    $0x1a5ac,%eax
   13af3:	e9 0d 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
   13af8:	b8 d8 a5 01 00       	mov    $0x1a5d8,%eax
   13afd:	e9 03 03 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 27: return "PNG file is smaller than a PNG header";
   13b02:	b8 18 a6 01 00       	mov    $0x1a618,%eax
   13b07:	e9 f9 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
   13b0c:	b8 40 a6 01 00       	mov    $0x1a640,%eax
   13b11:	e9 ef 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 29: return "first chunk is not the header chunk";
   13b16:	b8 74 a6 01 00       	mov    $0x1a674,%eax
   13b1b:	e9 e5 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 30: return "chunk length too large, chunk broken off at end of file";
   13b20:	b8 98 a6 01 00       	mov    $0x1a698,%eax
   13b25:	e9 db 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 31: return "illegal PNG color type or bpp";
   13b2a:	b8 d0 a6 01 00       	mov    $0x1a6d0,%eax
   13b2f:	e9 d1 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 32: return "illegal PNG compression method";
   13b34:	b8 f0 a6 01 00       	mov    $0x1a6f0,%eax
   13b39:	e9 c7 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 33: return "illegal PNG filter method";
   13b3e:	b8 0f a7 01 00       	mov    $0x1a70f,%eax
   13b43:	e9 bd 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 34: return "illegal PNG interlace method";
   13b48:	b8 29 a7 01 00       	mov    $0x1a729,%eax
   13b4d:	e9 b3 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 35: return "chunk length of a chunk is too large or the chunk too small";
   13b52:	b8 48 a7 01 00       	mov    $0x1a748,%eax
   13b57:	e9 a9 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 36: return "illegal PNG filter type encountered";
   13b5c:	b8 84 a7 01 00       	mov    $0x1a784,%eax
   13b61:	e9 9f 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 37: return "illegal bit depth for this color type given";
   13b66:	b8 a8 a7 01 00       	mov    $0x1a7a8,%eax
   13b6b:	e9 95 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 38: return "the palette is too small or too big"; /*0, or more than 256 colors*/
   13b70:	b8 d4 a7 01 00       	mov    $0x1a7d4,%eax
   13b75:	e9 8b 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 39: return "tRNS chunk before PLTE or has more entries than palette size";
   13b7a:	b8 f8 a7 01 00       	mov    $0x1a7f8,%eax
   13b7f:	e9 81 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 40: return "tRNS chunk has wrong size for grayscale image";
   13b84:	b8 38 a8 01 00       	mov    $0x1a838,%eax
   13b89:	e9 77 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 41: return "tRNS chunk has wrong size for RGB image";
   13b8e:	b8 68 a8 01 00       	mov    $0x1a868,%eax
   13b93:	e9 6d 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
   13b98:	b8 90 a8 01 00       	mov    $0x1a890,%eax
   13b9d:	e9 63 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 43: return "bKGD chunk has wrong size for palette image";
   13ba2:	b8 d4 a8 01 00       	mov    $0x1a8d4,%eax
   13ba7:	e9 59 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 44: return "bKGD chunk has wrong size for grayscale image";
   13bac:	b8 00 a9 01 00       	mov    $0x1a900,%eax
   13bb1:	e9 4f 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 45: return "bKGD chunk has wrong size for RGB image";
   13bb6:	b8 30 a9 01 00       	mov    $0x1a930,%eax
   13bbb:	e9 45 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 48: return "empty input buffer given to decoder. Maybe caused by non-existing file?";
   13bc0:	b8 58 a9 01 00       	mov    $0x1a958,%eax
   13bc5:	e9 3b 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 49: return "jumped past memory while generating dynamic huffman tree";
   13bca:	b8 a0 a9 01 00       	mov    $0x1a9a0,%eax
   13bcf:	e9 31 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 50: return "jumped past memory while generating dynamic huffman tree";
   13bd4:	b8 a0 a9 01 00       	mov    $0x1a9a0,%eax
   13bd9:	e9 27 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 51: return "jumped past memory while inflating huffman block";
   13bde:	b8 dc a9 01 00       	mov    $0x1a9dc,%eax
   13be3:	e9 1d 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 52: return "jumped past memory while inflating";
   13be8:	b8 10 aa 01 00       	mov    $0x1aa10,%eax
   13bed:	e9 13 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 53: return "size of zlib data too small";
   13bf2:	b8 33 aa 01 00       	mov    $0x1aa33,%eax
   13bf7:	e9 09 02 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 54: return "repeat symbol in tree while there was no value symbol yet";
   13bfc:	b8 50 aa 01 00       	mov    $0x1aa50,%eax
   13c01:	e9 ff 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lengths. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
   13c06:	b8 8c aa 01 00       	mov    $0x1aa8c,%eax
   13c0b:	e9 f5 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
   13c10:	b8 bc aa 01 00       	mov    $0x1aabc,%eax
   13c15:	e9 eb 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
   13c1a:	b8 08 ab 01 00       	mov    $0x1ab08,%eax
   13c1f:	e9 e1 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
   13c24:	b8 40 ab 01 00       	mov    $0x1ab40,%eax
   13c29:	e9 d7 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 59: return "requested color conversion not supported";
   13c2e:	b8 80 ab 01 00       	mov    $0x1ab80,%eax
   13c33:	e9 cd 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
   13c38:	b8 ac ab 01 00       	mov    $0x1abac,%eax
   13c3d:	e9 c3 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
   13c42:	b8 f8 ab 01 00       	mov    $0x1abf8,%eax
   13c47:	e9 b9 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    /*LodePNG leaves the choice of RGB to grayscale conversion formula to the user.*/
    case 62: return "conversion from color to grayscale not supported";
   13c4c:	b8 4c ac 01 00       	mov    $0x1ac4c,%eax
   13c51:	e9 af 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    /*(2^31-1)*/
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk";
   13c56:	b8 80 ac 01 00       	mov    $0x1ac80,%eax
   13c5b:	e9 a5 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
   13c60:	b8 d0 ac 01 00       	mov    $0x1acd0,%eax
   13c65:	e9 9b 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
   13c6a:	b8 0c ad 01 00       	mov    $0x1ad0c,%eax
   13c6f:	e9 91 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
   13c74:	b8 6c ad 01 00       	mov    $0x1ad6c,%eax
   13c79:	e9 87 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
   13c7e:	b8 cc ad 01 00       	mov    $0x1adcc,%eax
   13c83:	e9 7d 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
   13c88:	b8 28 ae 01 00       	mov    $0x1ae28,%eax
   13c8d:	e9 73 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 71: return "invalid interlace mode given to encoder (must be 0 or 1)";
   13c92:	b8 6c ae 01 00       	mov    $0x1ae6c,%eax
   13c97:	e9 69 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 72: return "while decoding, invalid compression method encountering in zTXt or iTXt chunk (it must be 0)";
   13c9c:	b8 a8 ae 01 00       	mov    $0x1aea8,%eax
   13ca1:	e9 5f 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 73: return "invalid tIME chunk size";
   13ca6:	b8 05 af 01 00       	mov    $0x1af05,%eax
   13cab:	e9 55 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 74: return "invalid pHYs chunk size";
   13cb0:	b8 1d af 01 00       	mov    $0x1af1d,%eax
   13cb5:	e9 4b 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
   13cba:	b8 38 af 01 00       	mov    $0x1af38,%eax
   13cbf:	e9 41 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 76: return "iTXt chunk too short to contain required bytes";
   13cc4:	b8 74 af 01 00       	mov    $0x1af74,%eax
   13cc9:	e9 37 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 77: return "integer overflow in buffer size";
   13cce:	b8 a4 af 01 00       	mov    $0x1afa4,%eax
   13cd3:	e9 2d 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
   13cd8:	b8 c4 af 01 00       	mov    $0x1afc4,%eax
   13cdd:	e9 23 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 79: return "failed to open file for writing";
   13ce2:	b8 e4 af 01 00       	mov    $0x1afe4,%eax
   13ce7:	e9 19 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 80: return "tried creating a tree of 0 symbols";
   13cec:	b8 04 b0 01 00       	mov    $0x1b004,%eax
   13cf1:	e9 0f 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 81: return "lazy matching at pos 0 is impossible";
   13cf6:	b8 28 b0 01 00       	mov    $0x1b028,%eax
   13cfb:	e9 05 01 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 82: return "color conversion to palette requested while a color isn't in palette, or index out of bounds";
   13d00:	b8 50 b0 01 00       	mov    $0x1b050,%eax
   13d05:	e9 fb 00 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 83: return "memory allocation failed";
   13d0a:	b8 ad b0 01 00       	mov    $0x1b0ad,%eax
   13d0f:	e9 f1 00 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 84: return "given image too small to contain all pixels to be encoded";
   13d14:	b8 c8 b0 01 00       	mov    $0x1b0c8,%eax
   13d19:	e9 e7 00 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 86: return "impossible offset in lz77 encoding (internal bug)";
   13d1e:	b8 04 b1 01 00       	mov    $0x1b104,%eax
   13d23:	e9 dd 00 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
   13d28:	b8 38 b1 01 00       	mov    $0x1b138,%eax
   13d2d:	e9 d3 00 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
   13d32:	b8 8c b1 01 00       	mov    $0x1b18c,%eax
   13d37:	e9 c9 00 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 89: return "text chunk keyword too short or long: must have size 1-79";
   13d3c:	b8 d8 b1 01 00       	mov    $0x1b1d8,%eax
   13d41:	e9 bf 00 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    /*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
    case 90: return "windowsize must be a power of two";
   13d46:	b8 14 b2 01 00       	mov    $0x1b214,%eax
   13d4b:	e9 b5 00 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 91: return "invalid decompressed idat size";
   13d50:	b8 38 b2 01 00       	mov    $0x1b238,%eax
   13d55:	e9 ab 00 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 92: return "integer overflow due to too many pixels";
   13d5a:	b8 58 b2 01 00       	mov    $0x1b258,%eax
   13d5f:	e9 a1 00 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 93: return "zero width or height is invalid";
   13d64:	b8 80 b2 01 00       	mov    $0x1b280,%eax
   13d69:	e9 97 00 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 94: return "header chunk must have a size of 13 bytes";
   13d6e:	b8 a0 b2 01 00       	mov    $0x1b2a0,%eax
   13d73:	e9 8d 00 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 95: return "integer overflow with combined idat chunk size";
   13d78:	b8 cc b2 01 00       	mov    $0x1b2cc,%eax
   13d7d:	e9 83 00 00 00       	jmp    13e05 <lodepng_error_text+0x3d3>
    case 96: return "invalid gAMA chunk size";
   13d82:	b8 fb b2 01 00       	mov    $0x1b2fb,%eax
   13d87:	eb 7c                	jmp    13e05 <lodepng_error_text+0x3d3>
    case 97: return "invalid cHRM chunk size";
   13d89:	b8 13 b3 01 00       	mov    $0x1b313,%eax
   13d8e:	eb 75                	jmp    13e05 <lodepng_error_text+0x3d3>
    case 98: return "invalid sRGB chunk size";
   13d90:	b8 2b b3 01 00       	mov    $0x1b32b,%eax
   13d95:	eb 6e                	jmp    13e05 <lodepng_error_text+0x3d3>
    case 99: return "invalid sRGB rendering intent";
   13d97:	b8 43 b3 01 00       	mov    $0x1b343,%eax
   13d9c:	eb 67                	jmp    13e05 <lodepng_error_text+0x3d3>
    case 100: return "invalid ICC profile color type, the PNG specification only allows RGB or GRAY";
   13d9e:	b8 64 b3 01 00       	mov    $0x1b364,%eax
   13da3:	eb 60                	jmp    13e05 <lodepng_error_text+0x3d3>
    case 101: return "PNG specification does not allow RGB ICC profile on gray color types and vice versa";
   13da5:	b8 b4 b3 01 00       	mov    $0x1b3b4,%eax
   13daa:	eb 59                	jmp    13e05 <lodepng_error_text+0x3d3>
    case 102: return "not allowed to set grayscale ICC profile with colored pixels by PNG specification";
   13dac:	b8 08 b4 01 00       	mov    $0x1b408,%eax
   13db1:	eb 52                	jmp    13e05 <lodepng_error_text+0x3d3>
    case 103: return "invalid palette index in bKGD chunk. Maybe it came before PLTE chunk?";
   13db3:	b8 5c b4 01 00       	mov    $0x1b45c,%eax
   13db8:	eb 4b                	jmp    13e05 <lodepng_error_text+0x3d3>
    case 104: return "invalid bKGD color while encoding (e.g. palette index out of range)";
   13dba:	b8 a4 b4 01 00       	mov    $0x1b4a4,%eax
   13dbf:	eb 44                	jmp    13e05 <lodepng_error_text+0x3d3>
    case 105: return "integer overflow of bitsize";
   13dc1:	b8 e8 b4 01 00       	mov    $0x1b4e8,%eax
   13dc6:	eb 3d                	jmp    13e05 <lodepng_error_text+0x3d3>
    case 106: return "PNG file must have PLTE chunk if color type is palette";
   13dc8:	b8 04 b5 01 00       	mov    $0x1b504,%eax
   13dcd:	eb 36                	jmp    13e05 <lodepng_error_text+0x3d3>
    case 107: return "color convert from palette mode requested without setting the palette data in it";
   13dcf:	b8 3c b5 01 00       	mov    $0x1b53c,%eax
   13dd4:	eb 2f                	jmp    13e05 <lodepng_error_text+0x3d3>
    case 108: return "tried to add more than 256 values to a palette";
   13dd6:	b8 90 b5 01 00       	mov    $0x1b590,%eax
   13ddb:	eb 28                	jmp    13e05 <lodepng_error_text+0x3d3>
    /*this limit can be configured in LodePNGDecompressSettings*/
    case 109: return "tried to decompress zlib or deflate data larger than desired max_output_size";
   13ddd:	b8 c0 b5 01 00       	mov    $0x1b5c0,%eax
   13de2:	eb 21                	jmp    13e05 <lodepng_error_text+0x3d3>
    case 110: return "custom zlib or inflate decompression failed";
   13de4:	b8 10 b6 01 00       	mov    $0x1b610,%eax
   13de9:	eb 1a                	jmp    13e05 <lodepng_error_text+0x3d3>
    case 111: return "custom zlib or deflate compression failed";
   13deb:	b8 3c b6 01 00       	mov    $0x1b63c,%eax
   13df0:	eb 13                	jmp    13e05 <lodepng_error_text+0x3d3>
    /*max text size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large text sizes.*/
    case 112: return "compressed text unreasonably large";
   13df2:	b8 68 b6 01 00       	mov    $0x1b668,%eax
   13df7:	eb 0c                	jmp    13e05 <lodepng_error_text+0x3d3>
    /*max ICC size limit can be configured in LodePNGDecoderSettings. This error prevents
    unreasonable memory consumption when decoding due to impossibly large ICC profile*/
    case 113: return "ICC profile unreasonably large";
   13df9:	b8 8c b6 01 00       	mov    $0x1b68c,%eax
   13dfe:	eb 05                	jmp    13e05 <lodepng_error_text+0x3d3>
  }
  return "unknown error code";
   13e00:	b8 ab b6 01 00       	mov    $0x1b6ab,%eax
}
   13e05:	5d                   	pop    %ebp
   13e06:	c3                   	ret    

00013e07 <GetImage>:
#include "loadjpeg.h"

uchar* GetImage(Context* ctx){
   13e07:	55                   	push   %ebp
   13e08:	89 e5                	mov    %esp,%ebp
    return (ctx->compNum == 1) ? ctx->comp[0].pixels : ctx->rgb;
   13e0a:	8b 45 08             	mov    0x8(%ebp),%eax
   13e0d:	8b 40 28             	mov    0x28(%eax),%eax
   13e10:	83 f8 01             	cmp    $0x1,%eax
   13e13:	75 08                	jne    13e1d <GetImage+0x16>
   13e15:	8b 45 08             	mov    0x8(%ebp),%eax
   13e18:	8b 40 54             	mov    0x54(%eax),%eax
   13e1b:	eb 09                	jmp    13e26 <GetImage+0x1f>
   13e1d:	8b 45 08             	mov    0x8(%ebp),%eax
   13e20:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax

}
   13e26:	5d                   	pop    %ebp
   13e27:	c3                   	ret    

00013e28 <GetWidth>:

int GetWidth(Context* ctx){
   13e28:	55                   	push   %ebp
   13e29:	89 e5                	mov    %esp,%ebp
    return ctx->width;
   13e2b:	8b 45 08             	mov    0x8(%ebp),%eax
   13e2e:	8b 40 10             	mov    0x10(%eax),%eax
}
   13e31:	5d                   	pop    %ebp
   13e32:	c3                   	ret    

00013e33 <GetHeight>:

int GetHeight(Context* ctx){
   13e33:	55                   	push   %ebp
   13e34:	89 e5                	mov    %esp,%ebp
    return ctx->height;
   13e36:	8b 45 08             	mov    0x8(%ebp),%eax
   13e39:	8b 40 14             	mov    0x14(%eax),%eax
}
   13e3c:	5d                   	pop    %ebp
   13e3d:	c3                   	ret    

00013e3e <GetImageSize>:

uint GetImageSize(Context* ctx){
   13e3e:	55                   	push   %ebp
   13e3f:	89 e5                	mov    %esp,%ebp
    return ctx->width * ctx->height * ctx->compNum;
   13e41:	8b 45 08             	mov    0x8(%ebp),%eax
   13e44:	8b 50 10             	mov    0x10(%eax),%edx
   13e47:	8b 45 08             	mov    0x8(%ebp),%eax
   13e4a:	8b 40 14             	mov    0x14(%eax),%eax
   13e4d:	0f af d0             	imul   %eax,%edx
   13e50:	8b 45 08             	mov    0x8(%ebp),%eax
   13e53:	8b 40 28             	mov    0x28(%eax),%eax
   13e56:	0f af c2             	imul   %edx,%eax
}
   13e59:	5d                   	pop    %ebp
   13e5a:	c3                   	ret    

00013e5b <_Clip>:

uchar _Clip(const int x){
   13e5b:	55                   	push   %ebp
   13e5c:	89 e5                	mov    %esp,%ebp
    return x < 0 ? 0: ((x > 0xFF) ? 0xFF : (uchar)x);
   13e5e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   13e62:	78 15                	js     13e79 <_Clip+0x1e>
   13e64:	81 7d 08 ff 00 00 00 	cmpl   $0xff,0x8(%ebp)
   13e6b:	7f 05                	jg     13e72 <_Clip+0x17>
   13e6d:	8b 45 08             	mov    0x8(%ebp),%eax
   13e70:	eb 0c                	jmp    13e7e <_Clip+0x23>
   13e72:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13e77:	eb 05                	jmp    13e7e <_Clip+0x23>
   13e79:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13e7e:	5d                   	pop    %ebp
   13e7f:	c3                   	ret    

00013e80 <_Skip>:

void _Skip(Context* ctx, int c){
   13e80:	55                   	push   %ebp
   13e81:	89 e5                	mov    %esp,%ebp
    ctx->pos += c;
   13e83:	8b 45 08             	mov    0x8(%ebp),%eax
   13e86:	8b 50 04             	mov    0x4(%eax),%edx
   13e89:	8b 45 0c             	mov    0xc(%ebp),%eax
   13e8c:	01 c2                	add    %eax,%edx
   13e8e:	8b 45 08             	mov    0x8(%ebp),%eax
   13e91:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size -= c;
   13e94:	8b 45 08             	mov    0x8(%ebp),%eax
   13e97:	8b 40 08             	mov    0x8(%eax),%eax
   13e9a:	2b 45 0c             	sub    0xc(%ebp),%eax
   13e9d:	89 c2                	mov    %eax,%edx
   13e9f:	8b 45 08             	mov    0x8(%ebp),%eax
   13ea2:	89 50 08             	mov    %edx,0x8(%eax)
    ctx->length -= c;
   13ea5:	8b 45 08             	mov    0x8(%ebp),%eax
   13ea8:	8b 40 0c             	mov    0xc(%eax),%eax
   13eab:	2b 45 0c             	sub    0xc(%ebp),%eax
   13eae:	89 c2                	mov    %eax,%edx
   13eb0:	8b 45 08             	mov    0x8(%ebp),%eax
   13eb3:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->size < 0) ctx->result = SyntaxError;
   13eb6:	8b 45 08             	mov    0x8(%ebp),%eax
   13eb9:	8b 40 08             	mov    0x8(%eax),%eax
   13ebc:	85 c0                	test   %eax,%eax
   13ebe:	79 09                	jns    13ec9 <_Skip+0x49>
   13ec0:	8b 45 08             	mov    0x8(%ebp),%eax
   13ec3:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}
   13ec9:	90                   	nop
   13eca:	5d                   	pop    %ebp
   13ecb:	c3                   	ret    

00013ecc <_DecodeLength>:

void _DecodeLength(Context* ctx){
   13ecc:	55                   	push   %ebp
   13ecd:	89 e5                	mov    %esp,%ebp
   13ecf:	83 ec 08             	sub    $0x8,%esp
    if(ctx->size < 2) ERROR_RETURN(SyntaxError);
   13ed2:	8b 45 08             	mov    0x8(%ebp),%eax
   13ed5:	8b 40 08             	mov    0x8(%eax),%eax
   13ed8:	83 f8 01             	cmp    $0x1,%eax
   13edb:	7f 0b                	jg     13ee8 <_DecodeLength+0x1c>
   13edd:	8b 45 08             	mov    0x8(%ebp),%eax
   13ee0:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13ee6:	eb 45                	jmp    13f2d <_DecodeLength+0x61>
    ctx->length = _Decode2Bytes(ctx->pos);
   13ee8:	8b 45 08             	mov    0x8(%ebp),%eax
   13eeb:	8b 40 04             	mov    0x4(%eax),%eax
   13eee:	83 ec 0c             	sub    $0xc,%esp
   13ef1:	50                   	push   %eax
   13ef2:	e8 38 00 00 00       	call   13f2f <_Decode2Bytes>
   13ef7:	83 c4 10             	add    $0x10,%esp
   13efa:	89 c2                	mov    %eax,%edx
   13efc:	8b 45 08             	mov    0x8(%ebp),%eax
   13eff:	89 50 0c             	mov    %edx,0xc(%eax)
    if(ctx->length > ctx->size) ERROR_RETURN(SyntaxError);
   13f02:	8b 45 08             	mov    0x8(%ebp),%eax
   13f05:	8b 50 0c             	mov    0xc(%eax),%edx
   13f08:	8b 45 08             	mov    0x8(%ebp),%eax
   13f0b:	8b 40 08             	mov    0x8(%eax),%eax
   13f0e:	39 c2                	cmp    %eax,%edx
   13f10:	7e 0b                	jle    13f1d <_DecodeLength+0x51>
   13f12:	8b 45 08             	mov    0x8(%ebp),%eax
   13f15:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   13f1b:	eb 10                	jmp    13f2d <_DecodeLength+0x61>
    _Skip(ctx, 2);
   13f1d:	83 ec 08             	sub    $0x8,%esp
   13f20:	6a 02                	push   $0x2
   13f22:	ff 75 08             	pushl  0x8(%ebp)
   13f25:	e8 56 ff ff ff       	call   13e80 <_Skip>
   13f2a:	83 c4 10             	add    $0x10,%esp
}
   13f2d:	c9                   	leave  
   13f2e:	c3                   	ret    

00013f2f <_Decode2Bytes>:

int _Decode2Bytes(const uchar* pos){
   13f2f:	55                   	push   %ebp
   13f30:	89 e5                	mov    %esp,%ebp
    return (pos[0] << 8) | pos[1];
   13f32:	8b 45 08             	mov    0x8(%ebp),%eax
   13f35:	0f b6 00             	movzbl (%eax),%eax
   13f38:	0f b6 c0             	movzbl %al,%eax
   13f3b:	c1 e0 08             	shl    $0x8,%eax
   13f3e:	89 c2                	mov    %eax,%edx
   13f40:	8b 45 08             	mov    0x8(%ebp),%eax
   13f43:	83 c0 01             	add    $0x1,%eax
   13f46:	0f b6 00             	movzbl (%eax),%eax
   13f49:	0f b6 c0             	movzbl %al,%eax
   13f4c:	09 d0                	or     %edx,%eax
}
   13f4e:	5d                   	pop    %ebp
   13f4f:	c3                   	ret    

00013f50 <_DecodeJPEG>:

int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
   13f50:	55                   	push   %ebp
   13f51:	89 e5                	mov    %esp,%ebp
   13f53:	83 ec 08             	sub    $0x8,%esp
    ctx->pos = jpeg;
   13f56:	8b 45 08             	mov    0x8(%ebp),%eax
   13f59:	8b 55 10             	mov    0x10(%ebp),%edx
   13f5c:	89 50 04             	mov    %edx,0x4(%eax)
    ctx->size = size & 0x7FFFFFFF;
   13f5f:	8b 45 14             	mov    0x14(%ebp),%eax
   13f62:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
   13f67:	89 c2                	mov    %eax,%edx
   13f69:	8b 45 08             	mov    0x8(%ebp),%eax
   13f6c:	89 50 08             	mov    %edx,0x8(%eax)
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
   13f6f:	8b 45 08             	mov    0x8(%ebp),%eax
   13f72:	8b 40 08             	mov    0x8(%eax),%eax
   13f75:	83 f8 01             	cmp    $0x1,%eax
   13f78:	7e 1d                	jle    13f97 <_DecodeJPEG+0x47>
   13f7a:	8b 45 08             	mov    0x8(%ebp),%eax
   13f7d:	8b 40 04             	mov    0x4(%eax),%eax
   13f80:	0f b6 00             	movzbl (%eax),%eax
   13f83:	3c ff                	cmp    $0xff,%al
   13f85:	75 10                	jne    13f97 <_DecodeJPEG+0x47>
   13f87:	8b 45 08             	mov    0x8(%ebp),%eax
   13f8a:	8b 40 04             	mov    0x4(%eax),%eax
   13f8d:	83 c0 01             	add    $0x1,%eax
   13f90:	0f b6 00             	movzbl (%eax),%eax
   13f93:	3c d8                	cmp    $0xd8,%al
   13f95:	74 0a                	je     13fa1 <_DecodeJPEG+0x51>
   13f97:	b8 01 00 00 00       	mov    $0x1,%eax
   13f9c:	e9 56 01 00 00       	jmp    140f7 <_DecodeJPEG+0x1a7>
    _Skip(ctx, 2);
   13fa1:	6a 02                	push   $0x2
   13fa3:	ff 75 08             	pushl  0x8(%ebp)
   13fa6:	e8 d5 fe ff ff       	call   13e80 <_Skip>
   13fab:	83 c4 08             	add    $0x8,%esp
    while(!ctx->result){
   13fae:	e9 0a 01 00 00       	jmp    140bd <_DecodeJPEG+0x16d>
        if(ctx->size < 0 || ctx->pos[0] != 0xFF) return SyntaxError;
   13fb3:	8b 45 08             	mov    0x8(%ebp),%eax
   13fb6:	8b 40 08             	mov    0x8(%eax),%eax
   13fb9:	85 c0                	test   %eax,%eax
   13fbb:	78 0d                	js     13fca <_DecodeJPEG+0x7a>
   13fbd:	8b 45 08             	mov    0x8(%ebp),%eax
   13fc0:	8b 40 04             	mov    0x4(%eax),%eax
   13fc3:	0f b6 00             	movzbl (%eax),%eax
   13fc6:	3c ff                	cmp    $0xff,%al
   13fc8:	74 0a                	je     13fd4 <_DecodeJPEG+0x84>
   13fca:	b8 05 00 00 00       	mov    $0x5,%eax
   13fcf:	e9 23 01 00 00       	jmp    140f7 <_DecodeJPEG+0x1a7>
        _Skip(ctx, 2);
   13fd4:	6a 02                	push   $0x2
   13fd6:	ff 75 08             	pushl  0x8(%ebp)
   13fd9:	e8 a2 fe ff ff       	call   13e80 <_Skip>
   13fde:	83 c4 08             	add    $0x8,%esp
        switch(ctx->pos[-1]){
   13fe1:	8b 45 08             	mov    0x8(%ebp),%eax
   13fe4:	8b 40 04             	mov    0x4(%eax),%eax
   13fe7:	83 e8 01             	sub    $0x1,%eax
   13fea:	0f b6 00             	movzbl (%eax),%eax
   13fed:	0f b6 c0             	movzbl %al,%eax
   13ff0:	3d da 00 00 00       	cmp    $0xda,%eax
   13ff5:	74 71                	je     14068 <_DecodeJPEG+0x118>
   13ff7:	3d da 00 00 00       	cmp    $0xda,%eax
   13ffc:	7f 10                	jg     1400e <_DecodeJPEG+0xbe>
   13ffe:	3d c0 00 00 00       	cmp    $0xc0,%eax
   14003:	74 20                	je     14025 <_DecodeJPEG+0xd5>
   14005:	3d c4 00 00 00       	cmp    $0xc4,%eax
   1400a:	74 2c                	je     14038 <_DecodeJPEG+0xe8>
   1400c:	eb 7d                	jmp    1408b <_DecodeJPEG+0x13b>
   1400e:	3d dd 00 00 00       	cmp    $0xdd,%eax
   14013:	74 43                	je     14058 <_DecodeJPEG+0x108>
   14015:	3d fe 00 00 00       	cmp    $0xfe,%eax
   1401a:	74 5f                	je     1407b <_DecodeJPEG+0x12b>
   1401c:	3d db 00 00 00       	cmp    $0xdb,%eax
   14021:	74 25                	je     14048 <_DecodeJPEG+0xf8>
   14023:	eb 66                	jmp    1408b <_DecodeJPEG+0x13b>
            case 0xC0: _DecodeSOF(ctx); break;
   14025:	83 ec 0c             	sub    $0xc,%esp
   14028:	ff 75 08             	pushl  0x8(%ebp)
   1402b:	e8 c9 00 00 00       	call   140f9 <_DecodeSOF>
   14030:	83 c4 10             	add    $0x10,%esp
   14033:	e9 85 00 00 00       	jmp    140bd <_DecodeJPEG+0x16d>
            case 0xC4: _DecodeDHT(ctx); break;
   14038:	83 ec 0c             	sub    $0xc,%esp
   1403b:	ff 75 08             	pushl  0x8(%ebp)
   1403e:	e8 28 05 00 00       	call   1456b <_DecodeDHT>
   14043:	83 c4 10             	add    $0x10,%esp
   14046:	eb 75                	jmp    140bd <_DecodeJPEG+0x16d>
            case 0xDB: _DecodeDQT(ctx); break;
   14048:	83 ec 0c             	sub    $0xc,%esp
   1404b:	ff 75 08             	pushl  0x8(%ebp)
   1404e:	e8 05 07 00 00       	call   14758 <_DecodeDQT>
   14053:	83 c4 10             	add    $0x10,%esp
   14056:	eb 65                	jmp    140bd <_DecodeJPEG+0x16d>
            case 0xDD: _DecodeDRI(ctx); break;
   14058:	83 ec 0c             	sub    $0xc,%esp
   1405b:	ff 75 08             	pushl  0x8(%ebp)
   1405e:	e8 ff 07 00 00       	call   14862 <_DecodeDRI>
   14063:	83 c4 10             	add    $0x10,%esp
   14066:	eb 55                	jmp    140bd <_DecodeJPEG+0x16d>
            case 0xDA: _DecodeSOS(ctx, ZZ); break;
   14068:	83 ec 08             	sub    $0x8,%esp
   1406b:	ff 75 0c             	pushl  0xc(%ebp)
   1406e:	ff 75 08             	pushl  0x8(%ebp)
   14071:	e8 56 08 00 00       	call   148cc <_DecodeSOS>
   14076:	83 c4 10             	add    $0x10,%esp
   14079:	eb 42                	jmp    140bd <_DecodeJPEG+0x16d>
            case 0xFE: _SkipMarker(ctx); break;
   1407b:	83 ec 0c             	sub    $0xc,%esp
   1407e:	ff 75 08             	pushl  0x8(%ebp)
   14081:	e8 a8 15 00 00       	call   1562e <_SkipMarker>
   14086:	83 c4 10             	add    $0x10,%esp
   14089:	eb 32                	jmp    140bd <_DecodeJPEG+0x16d>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
   1408b:	8b 45 08             	mov    0x8(%ebp),%eax
   1408e:	8b 40 04             	mov    0x4(%eax),%eax
   14091:	83 e8 01             	sub    $0x1,%eax
   14094:	0f b6 00             	movzbl (%eax),%eax
   14097:	0f b6 c0             	movzbl %al,%eax
   1409a:	25 f0 00 00 00       	and    $0xf0,%eax
   1409f:	3d e0 00 00 00       	cmp    $0xe0,%eax
   140a4:	75 10                	jne    140b6 <_DecodeJPEG+0x166>
   140a6:	83 ec 0c             	sub    $0xc,%esp
   140a9:	ff 75 08             	pushl  0x8(%ebp)
   140ac:	e8 7d 15 00 00       	call   1562e <_SkipMarker>
   140b1:	83 c4 10             	add    $0x10,%esp
   140b4:	eb 07                	jmp    140bd <_DecodeJPEG+0x16d>
                else return Unsupported;
   140b6:	b8 02 00 00 00       	mov    $0x2,%eax
   140bb:	eb 3a                	jmp    140f7 <_DecodeJPEG+0x1a7>
int _DecodeJPEG(Context* ctx, char* ZZ, const uchar* jpeg, const int size){
    ctx->pos = jpeg;
    ctx->size = size & 0x7FFFFFFF;
    if( (ctx->size < 2) || ((ctx->pos[0] != 0xFF) || (ctx->pos[1] != 0xD8)) ) return NotJPEG;
    _Skip(ctx, 2);
    while(!ctx->result){
   140bd:	8b 45 08             	mov    0x8(%ebp),%eax
   140c0:	8b 00                	mov    (%eax),%eax
   140c2:	85 c0                	test   %eax,%eax
   140c4:	0f 84 e9 fe ff ff    	je     13fb3 <_DecodeJPEG+0x63>
            default:
                if( (ctx->pos[-1] & 0xF0) == 0xE0) _SkipMarker(ctx);
                else return Unsupported;
        }
    }
    if(ctx->result != InternalFinished) return ctx->result;
   140ca:	8b 45 08             	mov    0x8(%ebp),%eax
   140cd:	8b 00                	mov    (%eax),%eax
   140cf:	83 f8 06             	cmp    $0x6,%eax
   140d2:	74 07                	je     140db <_DecodeJPEG+0x18b>
   140d4:	8b 45 08             	mov    0x8(%ebp),%eax
   140d7:	8b 00                	mov    (%eax),%eax
   140d9:	eb 1c                	jmp    140f7 <_DecodeJPEG+0x1a7>
    ctx->result = OK;
   140db:	8b 45 08             	mov    0x8(%ebp),%eax
   140de:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    _Convert(ctx);
   140e4:	83 ec 0c             	sub    $0xc,%esp
   140e7:	ff 75 08             	pushl  0x8(%ebp)
   140ea:	e8 6b 15 00 00       	call   1565a <_Convert>
   140ef:	83 c4 10             	add    $0x10,%esp
    return ctx->result;
   140f2:	8b 45 08             	mov    0x8(%ebp),%eax
   140f5:	8b 00                	mov    (%eax),%eax
 }
   140f7:	c9                   	leave  
   140f8:	c3                   	ret    

000140f9 <_DecodeSOF>:

void _DecodeSOF(Context* ctx){
   140f9:	55                   	push   %ebp
   140fa:	89 e5                	mov    %esp,%ebp
   140fc:	53                   	push   %ebx
   140fd:	83 ec 14             	sub    $0x14,%esp
    _DecodeLength(ctx);
   14100:	83 ec 0c             	sub    $0xc,%esp
   14103:	ff 75 08             	pushl  0x8(%ebp)
   14106:	e8 c1 fd ff ff       	call   13ecc <_DecodeLength>
   1410b:	83 c4 10             	add    $0x10,%esp
    if(ctx->result)return;
   1410e:	8b 45 08             	mov    0x8(%ebp),%eax
   14111:	8b 00                	mov    (%eax),%eax
   14113:	85 c0                	test   %eax,%eax
   14115:	0f 85 4a 04 00 00    	jne    14565 <_DecodeSOF+0x46c>
    if(ctx->length < 9) ERROR_RETURN(SyntaxError);
   1411b:	8b 45 08             	mov    0x8(%ebp),%eax
   1411e:	8b 40 0c             	mov    0xc(%eax),%eax
   14121:	83 f8 08             	cmp    $0x8,%eax
   14124:	7f 0e                	jg     14134 <_DecodeSOF+0x3b>
   14126:	8b 45 08             	mov    0x8(%ebp),%eax
   14129:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1412f:	e9 32 04 00 00       	jmp    14566 <_DecodeSOF+0x46d>
    if(ctx->pos[0] != 8) ERROR_RETURN(Unsupported);
   14134:	8b 45 08             	mov    0x8(%ebp),%eax
   14137:	8b 40 04             	mov    0x4(%eax),%eax
   1413a:	0f b6 00             	movzbl (%eax),%eax
   1413d:	3c 08                	cmp    $0x8,%al
   1413f:	74 0e                	je     1414f <_DecodeSOF+0x56>
   14141:	8b 45 08             	mov    0x8(%ebp),%eax
   14144:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1414a:	e9 17 04 00 00       	jmp    14566 <_DecodeSOF+0x46d>
    ctx->height = _Decode2Bytes(ctx->pos + 1);
   1414f:	8b 45 08             	mov    0x8(%ebp),%eax
   14152:	8b 40 04             	mov    0x4(%eax),%eax
   14155:	83 c0 01             	add    $0x1,%eax
   14158:	83 ec 0c             	sub    $0xc,%esp
   1415b:	50                   	push   %eax
   1415c:	e8 ce fd ff ff       	call   13f2f <_Decode2Bytes>
   14161:	83 c4 10             	add    $0x10,%esp
   14164:	89 c2                	mov    %eax,%edx
   14166:	8b 45 08             	mov    0x8(%ebp),%eax
   14169:	89 50 14             	mov    %edx,0x14(%eax)
    ctx->width = _Decode2Bytes(ctx->pos + 3);
   1416c:	8b 45 08             	mov    0x8(%ebp),%eax
   1416f:	8b 40 04             	mov    0x4(%eax),%eax
   14172:	83 c0 03             	add    $0x3,%eax
   14175:	83 ec 0c             	sub    $0xc,%esp
   14178:	50                   	push   %eax
   14179:	e8 b1 fd ff ff       	call   13f2f <_Decode2Bytes>
   1417e:	83 c4 10             	add    $0x10,%esp
   14181:	89 c2                	mov    %eax,%edx
   14183:	8b 45 08             	mov    0x8(%ebp),%eax
   14186:	89 50 10             	mov    %edx,0x10(%eax)
    ctx->compNum = ctx->pos[5];
   14189:	8b 45 08             	mov    0x8(%ebp),%eax
   1418c:	8b 40 04             	mov    0x4(%eax),%eax
   1418f:	83 c0 05             	add    $0x5,%eax
   14192:	0f b6 00             	movzbl (%eax),%eax
   14195:	0f b6 d0             	movzbl %al,%edx
   14198:	8b 45 08             	mov    0x8(%ebp),%eax
   1419b:	89 50 28             	mov    %edx,0x28(%eax)
    _Skip(ctx, 6);
   1419e:	83 ec 08             	sub    $0x8,%esp
   141a1:	6a 06                	push   $0x6
   141a3:	ff 75 08             	pushl  0x8(%ebp)
   141a6:	e8 d5 fc ff ff       	call   13e80 <_Skip>
   141ab:	83 c4 10             	add    $0x10,%esp
    switch(ctx->compNum){
   141ae:	8b 45 08             	mov    0x8(%ebp),%eax
   141b1:	8b 40 28             	mov    0x28(%eax),%eax
   141b4:	83 f8 01             	cmp    $0x1,%eax
   141b7:	74 13                	je     141cc <_DecodeSOF+0xd3>
   141b9:	83 f8 03             	cmp    $0x3,%eax
   141bc:	74 0e                	je     141cc <_DecodeSOF+0xd3>
        case 1:
        case 3:break;
        default: ERROR_RETURN(Unsupported);
   141be:	8b 45 08             	mov    0x8(%ebp),%eax
   141c1:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   141c7:	e9 9a 03 00 00       	jmp    14566 <_DecodeSOF+0x46d>
    ctx->width = _Decode2Bytes(ctx->pos + 3);
    ctx->compNum = ctx->pos[5];
    _Skip(ctx, 6);
    switch(ctx->compNum){
        case 1:
        case 3:break;
   141cc:	90                   	nop
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
   141cd:	8b 45 08             	mov    0x8(%ebp),%eax
   141d0:	8b 48 0c             	mov    0xc(%eax),%ecx
   141d3:	8b 45 08             	mov    0x8(%ebp),%eax
   141d6:	8b 50 28             	mov    0x28(%eax),%edx
   141d9:	89 d0                	mov    %edx,%eax
   141db:	01 c0                	add    %eax,%eax
   141dd:	01 d0                	add    %edx,%eax
   141df:	39 c1                	cmp    %eax,%ecx
   141e1:	7d 0e                	jge    141f1 <_DecodeSOF+0xf8>
   141e3:	8b 45 08             	mov    0x8(%ebp),%eax
   141e6:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   141ec:	e9 75 03 00 00       	jmp    14566 <_DecodeSOF+0x46d>
    int i, Vmax=0, Hmax=0;
   141f1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   141f8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   141ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14206:	8b 45 08             	mov    0x8(%ebp),%eax
   14209:	83 c0 2c             	add    $0x2c,%eax
   1420c:	89 45 e8             	mov    %eax,-0x18(%ebp)
   1420f:	e9 50 01 00 00       	jmp    14364 <_DecodeSOF+0x26b>
        c->cid = ctx->pos[0];
   14214:	8b 45 08             	mov    0x8(%ebp),%eax
   14217:	8b 40 04             	mov    0x4(%eax),%eax
   1421a:	0f b6 00             	movzbl (%eax),%eax
   1421d:	0f b6 d0             	movzbl %al,%edx
   14220:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14223:	89 10                	mov    %edx,(%eax)
        if(!(c->ssx = ctx->pos[1] >> 4)) ERROR_RETURN(SyntaxError);
   14225:	8b 45 08             	mov    0x8(%ebp),%eax
   14228:	8b 40 04             	mov    0x4(%eax),%eax
   1422b:	83 c0 01             	add    $0x1,%eax
   1422e:	0f b6 00             	movzbl (%eax),%eax
   14231:	c0 e8 04             	shr    $0x4,%al
   14234:	0f b6 d0             	movzbl %al,%edx
   14237:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1423a:	89 50 04             	mov    %edx,0x4(%eax)
   1423d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14240:	8b 40 04             	mov    0x4(%eax),%eax
   14243:	85 c0                	test   %eax,%eax
   14245:	75 0e                	jne    14255 <_DecodeSOF+0x15c>
   14247:	8b 45 08             	mov    0x8(%ebp),%eax
   1424a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14250:	e9 11 03 00 00       	jmp    14566 <_DecodeSOF+0x46d>
        if(!(c->ssy = ctx->pos[1] & 0xF)) ERROR_RETURN(SyntaxError);
   14255:	8b 45 08             	mov    0x8(%ebp),%eax
   14258:	8b 40 04             	mov    0x4(%eax),%eax
   1425b:	83 c0 01             	add    $0x1,%eax
   1425e:	0f b6 00             	movzbl (%eax),%eax
   14261:	0f b6 c0             	movzbl %al,%eax
   14264:	83 e0 0f             	and    $0xf,%eax
   14267:	89 c2                	mov    %eax,%edx
   14269:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1426c:	89 50 08             	mov    %edx,0x8(%eax)
   1426f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14272:	8b 40 08             	mov    0x8(%eax),%eax
   14275:	85 c0                	test   %eax,%eax
   14277:	75 0e                	jne    14287 <_DecodeSOF+0x18e>
   14279:	8b 45 08             	mov    0x8(%ebp),%eax
   1427c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14282:	e9 df 02 00 00       	jmp    14566 <_DecodeSOF+0x46d>
        //ssx, ssy must be 1, 2, 4, 8...
        if(c->ssx & (c->ssx - 1)) ERROR_RETURN(Unsupported);
   14287:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1428a:	8b 50 04             	mov    0x4(%eax),%edx
   1428d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14290:	8b 40 04             	mov    0x4(%eax),%eax
   14293:	83 e8 01             	sub    $0x1,%eax
   14296:	21 d0                	and    %edx,%eax
   14298:	85 c0                	test   %eax,%eax
   1429a:	74 0e                	je     142aa <_DecodeSOF+0x1b1>
   1429c:	8b 45 08             	mov    0x8(%ebp),%eax
   1429f:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   142a5:	e9 bc 02 00 00       	jmp    14566 <_DecodeSOF+0x46d>
        if(c->ssy & (c->ssy - 1)) ERROR_RETURN(Unsupported);
   142aa:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142ad:	8b 50 08             	mov    0x8(%eax),%edx
   142b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142b3:	8b 40 08             	mov    0x8(%eax),%eax
   142b6:	83 e8 01             	sub    $0x1,%eax
   142b9:	21 d0                	and    %edx,%eax
   142bb:	85 c0                	test   %eax,%eax
   142bd:	74 0e                	je     142cd <_DecodeSOF+0x1d4>
   142bf:	8b 45 08             	mov    0x8(%ebp),%eax
   142c2:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   142c8:	e9 99 02 00 00       	jmp    14566 <_DecodeSOF+0x46d>
        if((c->qtselect = ctx->pos[2]) & 0xFC) ERROR_RETURN(SyntaxError);
   142cd:	8b 45 08             	mov    0x8(%ebp),%eax
   142d0:	8b 40 04             	mov    0x4(%eax),%eax
   142d3:	83 c0 02             	add    $0x2,%eax
   142d6:	0f b6 00             	movzbl (%eax),%eax
   142d9:	0f b6 d0             	movzbl %al,%edx
   142dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142df:	89 50 18             	mov    %edx,0x18(%eax)
   142e2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   142e5:	8b 40 18             	mov    0x18(%eax),%eax
   142e8:	25 fc 00 00 00       	and    $0xfc,%eax
   142ed:	85 c0                	test   %eax,%eax
   142ef:	74 0e                	je     142ff <_DecodeSOF+0x206>
   142f1:	8b 45 08             	mov    0x8(%ebp),%eax
   142f4:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   142fa:	e9 67 02 00 00       	jmp    14566 <_DecodeSOF+0x46d>
        _Skip(ctx, 3);
   142ff:	83 ec 08             	sub    $0x8,%esp
   14302:	6a 03                	push   $0x3
   14304:	ff 75 08             	pushl  0x8(%ebp)
   14307:	e8 74 fb ff ff       	call   13e80 <_Skip>
   1430c:	83 c4 10             	add    $0x10,%esp
        ctx->qtused |= 1 << c->qtselect;
   1430f:	8b 45 08             	mov    0x8(%ebp),%eax
   14312:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
   14318:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1431b:	8b 40 18             	mov    0x18(%eax),%eax
   1431e:	bb 01 00 00 00       	mov    $0x1,%ebx
   14323:	89 c1                	mov    %eax,%ecx
   14325:	d3 e3                	shl    %cl,%ebx
   14327:	89 d8                	mov    %ebx,%eax
   14329:	09 c2                	or     %eax,%edx
   1432b:	8b 45 08             	mov    0x8(%ebp),%eax
   1432e:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
        if(c->ssx > Hmax) Hmax =c->ssx;
   14334:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14337:	8b 40 04             	mov    0x4(%eax),%eax
   1433a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1433d:	7e 09                	jle    14348 <_DecodeSOF+0x24f>
   1433f:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14342:	8b 40 04             	mov    0x4(%eax),%eax
   14345:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(c->ssy > Vmax) Vmax =c->ssy;
   14348:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1434b:	8b 40 08             	mov    0x8(%eax),%eax
   1434e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14351:	7e 09                	jle    1435c <_DecodeSOF+0x263>
   14353:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14356:	8b 40 08             	mov    0x8(%eax),%eax
   14359:	89 45 f0             	mov    %eax,-0x10(%ebp)
        default: ERROR_RETURN(Unsupported);
    }
    if(ctx->length < (ctx->compNum * 3)) ERROR_RETURN(SyntaxError);
    int i, Vmax=0, Hmax=0;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   1435c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14360:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   14364:	8b 45 08             	mov    0x8(%ebp),%eax
   14367:	8b 40 28             	mov    0x28(%eax),%eax
   1436a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   1436d:	0f 8f a1 fe ff ff    	jg     14214 <_DecodeSOF+0x11b>
        _Skip(ctx, 3);
        ctx->qtused |= 1 << c->qtselect;
        if(c->ssx > Hmax) Hmax =c->ssx;
        if(c->ssy > Vmax) Vmax =c->ssy;
    }
    ctx->MCUsizex = Hmax << 3;
   14373:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14376:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1437d:	8b 45 08             	mov    0x8(%ebp),%eax
   14380:	89 50 20             	mov    %edx,0x20(%eax)
    ctx->MCUsizey = Vmax << 3;
   14383:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14386:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1438d:	8b 45 08             	mov    0x8(%ebp),%eax
   14390:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
   14393:	8b 45 08             	mov    0x8(%ebp),%eax
   14396:	8b 50 10             	mov    0x10(%eax),%edx
   14399:	8b 45 08             	mov    0x8(%ebp),%eax
   1439c:	8b 40 20             	mov    0x20(%eax),%eax
   1439f:	01 d0                	add    %edx,%eax
   143a1:	8d 48 ff             	lea    -0x1(%eax),%ecx
   143a4:	8b 45 08             	mov    0x8(%ebp),%eax
   143a7:	8b 58 20             	mov    0x20(%eax),%ebx
   143aa:	89 c8                	mov    %ecx,%eax
   143ac:	99                   	cltd   
   143ad:	f7 fb                	idiv   %ebx
   143af:	89 c2                	mov    %eax,%edx
   143b1:	8b 45 08             	mov    0x8(%ebp),%eax
   143b4:	89 50 18             	mov    %edx,0x18(%eax)
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
   143b7:	8b 45 08             	mov    0x8(%ebp),%eax
   143ba:	8b 50 14             	mov    0x14(%eax),%edx
   143bd:	8b 45 08             	mov    0x8(%ebp),%eax
   143c0:	8b 40 24             	mov    0x24(%eax),%eax
   143c3:	01 d0                	add    %edx,%eax
   143c5:	8d 48 ff             	lea    -0x1(%eax),%ecx
   143c8:	8b 45 08             	mov    0x8(%ebp),%eax
   143cb:	8b 58 24             	mov    0x24(%eax),%ebx
   143ce:	89 c8                	mov    %ecx,%eax
   143d0:	99                   	cltd   
   143d1:	f7 fb                	idiv   %ebx
   143d3:	89 c2                	mov    %eax,%edx
   143d5:	8b 45 08             	mov    0x8(%ebp),%eax
   143d8:	89 50 1c             	mov    %edx,0x1c(%eax)
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   143db:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   143e2:	8b 45 08             	mov    0x8(%ebp),%eax
   143e5:	83 c0 2c             	add    $0x2c,%eax
   143e8:	89 45 e8             	mov    %eax,-0x18(%ebp)
   143eb:	e9 fd 00 00 00       	jmp    144ed <_DecodeSOF+0x3f4>
        c->width = (ctx->width * c->ssx + Hmax - 1) / Hmax;
   143f0:	8b 45 08             	mov    0x8(%ebp),%eax
   143f3:	8b 50 10             	mov    0x10(%eax),%edx
   143f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
   143f9:	8b 40 04             	mov    0x4(%eax),%eax
   143fc:	0f af d0             	imul   %eax,%edx
   143ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14402:	01 d0                	add    %edx,%eax
   14404:	83 e8 01             	sub    $0x1,%eax
   14407:	99                   	cltd   
   14408:	f7 7d ec             	idivl  -0x14(%ebp)
   1440b:	89 c2                	mov    %eax,%edx
   1440d:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14410:	89 50 0c             	mov    %edx,0xc(%eax)
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
   14413:	8b 45 08             	mov    0x8(%ebp),%eax
   14416:	8b 50 14             	mov    0x14(%eax),%edx
   14419:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1441c:	8b 40 08             	mov    0x8(%eax),%eax
   1441f:	0f af d0             	imul   %eax,%edx
   14422:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14425:	01 d0                	add    %edx,%eax
   14427:	83 e8 01             	sub    $0x1,%eax
   1442a:	99                   	cltd   
   1442b:	f7 7d f0             	idivl  -0x10(%ebp)
   1442e:	89 c2                	mov    %eax,%edx
   14430:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14433:	89 50 10             	mov    %edx,0x10(%eax)
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
   14436:	8b 45 08             	mov    0x8(%ebp),%eax
   14439:	8b 50 18             	mov    0x18(%eax),%edx
   1443c:	8b 45 08             	mov    0x8(%ebp),%eax
   1443f:	8b 40 20             	mov    0x20(%eax),%eax
   14442:	0f af d0             	imul   %eax,%edx
   14445:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14448:	8b 40 04             	mov    0x4(%eax),%eax
   1444b:	0f af c2             	imul   %edx,%eax
   1444e:	99                   	cltd   
   1444f:	f7 7d ec             	idivl  -0x14(%ebp)
   14452:	89 c2                	mov    %eax,%edx
   14454:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14457:	89 50 14             	mov    %edx,0x14(%eax)
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
   1445a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1445d:	8b 40 0c             	mov    0xc(%eax),%eax
   14460:	83 f8 02             	cmp    $0x2,%eax
   14463:	7f 0b                	jg     14470 <_DecodeSOF+0x377>
   14465:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14468:	8b 40 04             	mov    0x4(%eax),%eax
   1446b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   1446e:	75 16                	jne    14486 <_DecodeSOF+0x38d>
   14470:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14473:	8b 40 10             	mov    0x10(%eax),%eax
   14476:	83 f8 02             	cmp    $0x2,%eax
   14479:	7f 19                	jg     14494 <_DecodeSOF+0x39b>
   1447b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1447e:	8b 40 08             	mov    0x8(%eax),%eax
   14481:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14484:	74 0e                	je     14494 <_DecodeSOF+0x39b>
   14486:	8b 45 08             	mov    0x8(%ebp),%eax
   14489:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   1448f:	e9 d2 00 00 00       	jmp    14566 <_DecodeSOF+0x46d>
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
   14494:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14497:	8b 48 14             	mov    0x14(%eax),%ecx
   1449a:	8b 45 08             	mov    0x8(%ebp),%eax
   1449d:	8b 50 1c             	mov    0x1c(%eax),%edx
   144a0:	8b 45 08             	mov    0x8(%ebp),%eax
   144a3:	8b 40 24             	mov    0x24(%eax),%eax
   144a6:	0f af d0             	imul   %eax,%edx
   144a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   144ac:	8b 40 08             	mov    0x8(%eax),%eax
   144af:	0f af c2             	imul   %edx,%eax
   144b2:	99                   	cltd   
   144b3:	f7 7d f0             	idivl  -0x10(%ebp)
   144b6:	0f af c1             	imul   %ecx,%eax
   144b9:	83 ec 0c             	sub    $0xc,%esp
   144bc:	50                   	push   %eax
   144bd:	e8 45 c5 fe ff       	call   a07 <malloc>
   144c2:	83 c4 10             	add    $0x10,%esp
   144c5:	89 c2                	mov    %eax,%edx
   144c7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   144ca:	89 50 28             	mov    %edx,0x28(%eax)
   144cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
   144d0:	8b 40 28             	mov    0x28(%eax),%eax
   144d3:	85 c0                	test   %eax,%eax
   144d5:	75 0e                	jne    144e5 <_DecodeSOF+0x3ec>
   144d7:	8b 45 08             	mov    0x8(%ebp),%eax
   144da:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   144e0:	e9 81 00 00 00       	jmp    14566 <_DecodeSOF+0x46d>
    }
    ctx->MCUsizex = Hmax << 3;
    ctx->MCUsizey = Vmax << 3;
    ctx->MCUwidth = (ctx->width + ctx->MCUsizex - 1) / ctx->MCUsizex;
    ctx->MCUheight = (ctx->height + ctx->MCUsizey - 1) / ctx->MCUsizey;
    for(i=0, c=ctx->comp; i< ctx->compNum; ++i, ++c){
   144e5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   144e9:	83 45 e8 2c          	addl   $0x2c,-0x18(%ebp)
   144ed:	8b 45 08             	mov    0x8(%ebp),%eax
   144f0:	8b 40 28             	mov    0x28(%eax),%eax
   144f3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   144f6:	0f 8f f4 fe ff ff    	jg     143f0 <_DecodeSOF+0x2f7>
        c->height = (ctx->height * c->ssy + Vmax - 1) / Vmax;
        c->stride = ctx->MCUwidth * ctx->MCUsizex * c->ssx / Hmax;
        if(((c->width < 3) && (c->ssx != Hmax)) || (c->height < 3) && (c->ssy != Vmax)) ERROR_RETURN(Unsupported);
        if(!(c->pixels = (uchar*)malloc(c->stride * (ctx->MCUheight * ctx->MCUsizey * c->ssy / Vmax)))) ERROR_RETURN(OutOfMemory);
    }
    if(ctx->compNum == 3){
   144fc:	8b 45 08             	mov    0x8(%ebp),%eax
   144ff:	8b 40 28             	mov    0x28(%eax),%eax
   14502:	83 f8 03             	cmp    $0x3,%eax
   14505:	75 47                	jne    1454e <_DecodeSOF+0x455>
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
   14507:	8b 45 08             	mov    0x8(%ebp),%eax
   1450a:	8b 50 10             	mov    0x10(%eax),%edx
   1450d:	8b 45 08             	mov    0x8(%ebp),%eax
   14510:	8b 40 14             	mov    0x14(%eax),%eax
   14513:	0f af d0             	imul   %eax,%edx
   14516:	8b 45 08             	mov    0x8(%ebp),%eax
   14519:	8b 40 28             	mov    0x28(%eax),%eax
   1451c:	0f af c2             	imul   %edx,%eax
   1451f:	83 ec 0c             	sub    $0xc,%esp
   14522:	50                   	push   %eax
   14523:	e8 df c4 fe ff       	call   a07 <malloc>
   14528:	83 c4 10             	add    $0x10,%esp
   1452b:	89 c2                	mov    %eax,%edx
   1452d:	8b 45 08             	mov    0x8(%ebp),%eax
   14530:	89 90 c4 02 08 00    	mov    %edx,0x802c4(%eax)
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
   14536:	8b 45 08             	mov    0x8(%ebp),%eax
   14539:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1453f:	85 c0                	test   %eax,%eax
   14541:	75 0b                	jne    1454e <_DecodeSOF+0x455>
   14543:	8b 45 08             	mov    0x8(%ebp),%eax
   14546:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   1454c:	eb 18                	jmp    14566 <_DecodeSOF+0x46d>
    }
    _Skip(ctx, ctx->length);
   1454e:	8b 45 08             	mov    0x8(%ebp),%eax
   14551:	8b 40 0c             	mov    0xc(%eax),%eax
   14554:	83 ec 08             	sub    $0x8,%esp
   14557:	50                   	push   %eax
   14558:	ff 75 08             	pushl  0x8(%ebp)
   1455b:	e8 20 f9 ff ff       	call   13e80 <_Skip>
   14560:	83 c4 10             	add    $0x10,%esp
   14563:	eb 01                	jmp    14566 <_DecodeSOF+0x46d>
    return ctx->result;
 }

void _DecodeSOF(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result)return;
   14565:	90                   	nop
    if(ctx->compNum == 3){
        ctx->rgb = (uchar*)malloc(ctx->width * ctx->height * ctx->compNum);
        if(!ctx->rgb) ERROR_RETURN(OutOfMemory);
    }
    _Skip(ctx, ctx->length);
}
   14566:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14569:	c9                   	leave  
   1456a:	c3                   	ret    

0001456b <_DecodeDHT>:

void _DecodeDHT(Context* ctx){
   1456b:	55                   	push   %ebp
   1456c:	89 e5                	mov    %esp,%ebp
   1456e:	53                   	push   %ebx
   1456f:	83 ec 34             	sub    $0x34,%esp
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
   14572:	83 ec 0c             	sub    $0xc,%esp
   14575:	ff 75 08             	pushl  0x8(%ebp)
   14578:	e8 4f f9 ff ff       	call   13ecc <_DecodeLength>
   1457d:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14580:	8b 45 08             	mov    0x8(%ebp),%eax
   14583:	8b 00                	mov    (%eax),%eax
   14585:	85 c0                	test   %eax,%eax
   14587:	0f 85 c5 01 00 00    	jne    14752 <_DecodeDHT+0x1e7>
    while(ctx->length >= 17){
   1458d:	e9 9c 01 00 00       	jmp    1472e <_DecodeDHT+0x1c3>
        i = ctx->pos[0];
   14592:	8b 45 08             	mov    0x8(%ebp),%eax
   14595:	8b 40 04             	mov    0x4(%eax),%eax
   14598:	0f b6 00             	movzbl (%eax),%eax
   1459b:	0f b6 c0             	movzbl %al,%eax
   1459e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   145a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145a4:	25 ec 00 00 00       	and    $0xec,%eax
   145a9:	85 c0                	test   %eax,%eax
   145ab:	74 0e                	je     145bb <_DecodeDHT+0x50>
   145ad:	8b 45 08             	mov    0x8(%ebp),%eax
   145b0:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   145b6:	e9 98 01 00 00       	jmp    14753 <_DecodeDHT+0x1e8>
        if(i & 0x02) ERROR_RETURN(Unsupported);
   145bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145be:	83 e0 02             	and    $0x2,%eax
   145c1:	85 c0                	test   %eax,%eax
   145c3:	74 0e                	je     145d3 <_DecodeDHT+0x68>
   145c5:	8b 45 08             	mov    0x8(%ebp),%eax
   145c8:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   145ce:	e9 80 01 00 00       	jmp    14753 <_DecodeDHT+0x1e8>
        i =(i | (i >> 3)) & 3;
   145d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   145d6:	c1 f8 03             	sar    $0x3,%eax
   145d9:	0b 45 f4             	or     -0xc(%ebp),%eax
   145dc:	83 e0 03             	and    $0x3,%eax
   145df:	89 45 f4             	mov    %eax,-0xc(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   145e2:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   145e9:	eb 1c                	jmp    14607 <_DecodeDHT+0x9c>
            counts[codelen - 1] = ctx->pos[codelen];
   145eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
   145ee:	8d 50 ff             	lea    -0x1(%eax),%edx
   145f1:	8b 45 08             	mov    0x8(%ebp),%eax
   145f4:	8b 48 04             	mov    0x4(%eax),%ecx
   145f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   145fa:	01 c8                	add    %ecx,%eax
   145fc:	0f b6 00             	movzbl (%eax),%eax
   145ff:	88 44 15 d0          	mov    %al,-0x30(%ebp,%edx,1)
    while(ctx->length >= 17){
        i = ctx->pos[0];
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
        if(i & 0x02) ERROR_RETURN(Unsupported);
        i =(i | (i >> 3)) & 3;
        for(codelen = 1; codelen <= 16; ++codelen){
   14603:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14607:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   1460b:	7e de                	jle    145eb <_DecodeDHT+0x80>
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
   1460d:	83 ec 08             	sub    $0x8,%esp
   14610:	6a 11                	push   $0x11
   14612:	ff 75 08             	pushl  0x8(%ebp)
   14615:	e8 66 f8 ff ff       	call   13e80 <_Skip>
   1461a:	83 c4 10             	add    $0x10,%esp
        VlcCode* vlc = &ctx->vlctable[i][0];
   1461d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14620:	c1 e0 11             	shl    $0x11,%eax
   14623:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14629:	8b 45 08             	mov    0x8(%ebp),%eax
   1462c:	01 d0                	add    %edx,%eax
   1462e:	83 c0 08             	add    $0x8,%eax
   14631:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        remain = spread = 65536;
   14634:	c7 45 e8 00 00 01 00 	movl   $0x10000,-0x18(%ebp)
   1463b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1463e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for(codelen = 1; codelen <= 16; ++codelen){
   14641:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
   14648:	e9 be 00 00 00       	jmp    1470b <_DecodeDHT+0x1a0>
            spread >>= 1;
   1464d:	d1 7d e8             	sarl   -0x18(%ebp)
            curcount = counts[codelen - 1];
   14650:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14653:	83 e8 01             	sub    $0x1,%eax
   14656:	0f b6 44 05 d0       	movzbl -0x30(%ebp,%eax,1),%eax
   1465b:	0f b6 c0             	movzbl %al,%eax
   1465e:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(!curcount) continue;
   14661:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14665:	0f 84 9b 00 00 00    	je     14706 <_DecodeDHT+0x19b>
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
   1466b:	8b 45 08             	mov    0x8(%ebp),%eax
   1466e:	8b 40 0c             	mov    0xc(%eax),%eax
   14671:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   14674:	7d 0e                	jge    14684 <_DecodeDHT+0x119>
   14676:	8b 45 08             	mov    0x8(%ebp),%eax
   14679:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1467f:	e9 cf 00 00 00       	jmp    14753 <_DecodeDHT+0x1e8>
            remain -= curcount << (16 - codelen);
   14684:	b8 10 00 00 00       	mov    $0x10,%eax
   14689:	2b 45 f0             	sub    -0x10(%ebp),%eax
   1468c:	8b 55 e0             	mov    -0x20(%ebp),%edx
   1468f:	89 c1                	mov    %eax,%ecx
   14691:	d3 e2                	shl    %cl,%edx
   14693:	89 d0                	mov    %edx,%eax
   14695:	29 45 ec             	sub    %eax,-0x14(%ebp)
            if(remain < 0) ERROR_RETURN(SyntaxError);
   14698:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1469c:	79 0e                	jns    146ac <_DecodeDHT+0x141>
   1469e:	8b 45 08             	mov    0x8(%ebp),%eax
   146a1:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   146a7:	e9 a7 00 00 00       	jmp    14753 <_DecodeDHT+0x1e8>
            for(i=0; i<curcount; ++i){
   146ac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   146b3:	eb 36                	jmp    146eb <_DecodeDHT+0x180>
                register uchar code = ctx->pos[i];
   146b5:	8b 45 08             	mov    0x8(%ebp),%eax
   146b8:	8b 50 04             	mov    0x4(%eax),%edx
   146bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   146be:	01 d0                	add    %edx,%eax
   146c0:	0f b6 00             	movzbl (%eax),%eax
   146c3:	89 c1                	mov    %eax,%ecx
                register int j = spread;
   146c5:	8b 5d e8             	mov    -0x18(%ebp),%ebx
                while(j--){
   146c8:	eb 14                	jmp    146de <_DecodeDHT+0x173>
                    vlc->bits = (uchar)codelen;
   146ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
   146cd:	89 c2                	mov    %eax,%edx
   146cf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   146d2:	88 10                	mov    %dl,(%eax)
                    vlc->code = code;
   146d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   146d7:	88 48 01             	mov    %cl,0x1(%eax)
                    ++vlc;
   146da:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
                register uchar code = ctx->pos[i];
                register int j = spread;
                while(j--){
   146de:	89 d8                	mov    %ebx,%eax
   146e0:	8d 58 ff             	lea    -0x1(%eax),%ebx
   146e3:	85 c0                	test   %eax,%eax
   146e5:	75 e3                	jne    146ca <_DecodeDHT+0x15f>
            curcount = counts[codelen - 1];
            if(!curcount) continue;
            if(ctx->length < curcount) ERROR_RETURN(SyntaxError);
            remain -= curcount << (16 - codelen);
            if(remain < 0) ERROR_RETURN(SyntaxError);
            for(i=0; i<curcount; ++i){
   146e7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   146eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   146ee:	3b 45 e0             	cmp    -0x20(%ebp),%eax
   146f1:	7c c2                	jl     146b5 <_DecodeDHT+0x14a>
                    vlc->bits = (uchar)codelen;
                    vlc->code = code;
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
   146f3:	83 ec 08             	sub    $0x8,%esp
   146f6:	ff 75 e0             	pushl  -0x20(%ebp)
   146f9:	ff 75 08             	pushl  0x8(%ebp)
   146fc:	e8 7f f7 ff ff       	call   13e80 <_Skip>
   14701:	83 c4 10             	add    $0x10,%esp
   14704:	eb 01                	jmp    14707 <_DecodeDHT+0x19c>
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
            spread >>= 1;
            curcount = counts[codelen - 1];
            if(!curcount) continue;
   14706:	90                   	nop
            counts[codelen - 1] = ctx->pos[codelen];
        }
        _Skip(ctx, 17);
        VlcCode* vlc = &ctx->vlctable[i][0];
        remain = spread = 65536;
        for(codelen = 1; codelen <= 16; ++codelen){
   14707:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1470b:	83 7d f0 10          	cmpl   $0x10,-0x10(%ebp)
   1470f:	0f 8e 38 ff ff ff    	jle    1464d <_DecodeDHT+0xe2>
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14715:	eb 0a                	jmp    14721 <_DecodeDHT+0x1b6>
            vlc->bits = 0;
   14717:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1471a:	c6 00 00             	movb   $0x0,(%eax)
            ++vlc;
   1471d:	83 45 e4 02          	addl   $0x2,-0x1c(%ebp)
                    ++vlc;
                }
            }
            _Skip(ctx, curcount);
        }
        while(remain--){
   14721:	8b 45 ec             	mov    -0x14(%ebp),%eax
   14724:	8d 50 ff             	lea    -0x1(%eax),%edx
   14727:	89 55 ec             	mov    %edx,-0x14(%ebp)
   1472a:	85 c0                	test   %eax,%eax
   1472c:	75 e9                	jne    14717 <_DecodeDHT+0x1ac>
void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 17){
   1472e:	8b 45 08             	mov    0x8(%ebp),%eax
   14731:	8b 40 0c             	mov    0xc(%eax),%eax
   14734:	83 f8 10             	cmp    $0x10,%eax
   14737:	0f 8f 55 fe ff ff    	jg     14592 <_DecodeDHT+0x27>
        while(remain--){
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   1473d:	8b 45 08             	mov    0x8(%ebp),%eax
   14740:	8b 40 0c             	mov    0xc(%eax),%eax
   14743:	85 c0                	test   %eax,%eax
   14745:	74 0c                	je     14753 <_DecodeDHT+0x1e8>
   14747:	8b 45 08             	mov    0x8(%ebp),%eax
   1474a:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14750:	eb 01                	jmp    14753 <_DecodeDHT+0x1e8>

void _DecodeDHT(Context* ctx){
    int i, codelen, remain, spread, curcount;
    uchar counts[16];
    _DecodeLength(ctx);
    if(ctx->result) return;
   14752:	90                   	nop
            vlc->bits = 0;
            ++vlc;
        }
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   14753:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14756:	c9                   	leave  
   14757:	c3                   	ret    

00014758 <_DecodeDQT>:

void _DecodeDQT(Context* ctx){
   14758:	55                   	push   %ebp
   14759:	89 e5                	mov    %esp,%ebp
   1475b:	53                   	push   %ebx
   1475c:	83 ec 14             	sub    $0x14,%esp
    int i;
    uchar* t;
    _DecodeLength(ctx);
   1475f:	83 ec 0c             	sub    $0xc,%esp
   14762:	ff 75 08             	pushl  0x8(%ebp)
   14765:	e8 62 f7 ff ff       	call   13ecc <_DecodeLength>
   1476a:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   1476d:	8b 45 08             	mov    0x8(%ebp),%eax
   14770:	8b 00                	mov    (%eax),%eax
   14772:	85 c0                	test   %eax,%eax
   14774:	0f 85 e2 00 00 00    	jne    1485c <_DecodeDQT+0x104>
    while(ctx->length >= 65){
   1477a:	e9 b8 00 00 00       	jmp    14837 <_DecodeDQT+0xdf>
        i = ctx->pos[0];
   1477f:	8b 45 08             	mov    0x8(%ebp),%eax
   14782:	8b 40 04             	mov    0x4(%eax),%eax
   14785:	0f b6 00             	movzbl (%eax),%eax
   14788:	0f b6 c0             	movzbl %al,%eax
   1478b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(i & 0xEC) ERROR_RETURN(SyntaxError);
   1478e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14791:	25 ec 00 00 00       	and    $0xec,%eax
   14796:	85 c0                	test   %eax,%eax
   14798:	74 0e                	je     147a8 <_DecodeDQT+0x50>
   1479a:	8b 45 08             	mov    0x8(%ebp),%eax
   1479d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   147a3:	e9 b5 00 00 00       	jmp    1485d <_DecodeDQT+0x105>
        if(i & 0x10) ERROR_RETURN(Unsupported);
   147a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   147ab:	83 e0 10             	and    $0x10,%eax
   147ae:	85 c0                	test   %eax,%eax
   147b0:	74 0e                	je     147c0 <_DecodeDQT+0x68>
   147b2:	8b 45 08             	mov    0x8(%ebp),%eax
   147b5:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   147bb:	e9 9d 00 00 00       	jmp    1485d <_DecodeDQT+0x105>
        ctx->qtavail |= 1 << i;
   147c0:	8b 45 08             	mov    0x8(%ebp),%eax
   147c3:	8b 90 b4 00 00 00    	mov    0xb4(%eax),%edx
   147c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   147cc:	bb 01 00 00 00       	mov    $0x1,%ebx
   147d1:	89 c1                	mov    %eax,%ecx
   147d3:	d3 e3                	shl    %cl,%ebx
   147d5:	89 d8                	mov    %ebx,%eax
   147d7:	09 c2                	or     %eax,%edx
   147d9:	8b 45 08             	mov    0x8(%ebp),%eax
   147dc:	89 90 b4 00 00 00    	mov    %edx,0xb4(%eax)
        t =&ctx->qtable[i][0];
   147e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   147e5:	c1 e0 06             	shl    $0x6,%eax
   147e8:	8d 90 b0 00 00 00    	lea    0xb0(%eax),%edx
   147ee:	8b 45 08             	mov    0x8(%ebp),%eax
   147f1:	01 d0                	add    %edx,%eax
   147f3:	83 c0 08             	add    $0x8,%eax
   147f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
   147f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14800:	eb 1f                	jmp    14821 <_DecodeDQT+0xc9>
   14802:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14805:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14808:	01 c2                	add    %eax,%edx
   1480a:	8b 45 08             	mov    0x8(%ebp),%eax
   1480d:	8b 40 04             	mov    0x4(%eax),%eax
   14810:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14813:	83 c1 01             	add    $0x1,%ecx
   14816:	01 c8                	add    %ecx,%eax
   14818:	0f b6 00             	movzbl (%eax),%eax
   1481b:	88 02                	mov    %al,(%edx)
   1481d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14821:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14825:	7e db                	jle    14802 <_DecodeDQT+0xaa>
        _Skip(ctx, 65);
   14827:	83 ec 08             	sub    $0x8,%esp
   1482a:	6a 41                	push   $0x41
   1482c:	ff 75 08             	pushl  0x8(%ebp)
   1482f:	e8 4c f6 ff ff       	call   13e80 <_Skip>
   14834:	83 c4 10             	add    $0x10,%esp
void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
    while(ctx->length >= 65){
   14837:	8b 45 08             	mov    0x8(%ebp),%eax
   1483a:	8b 40 0c             	mov    0xc(%eax),%eax
   1483d:	83 f8 40             	cmp    $0x40,%eax
   14840:	0f 8f 39 ff ff ff    	jg     1477f <_DecodeDQT+0x27>
        ctx->qtavail |= 1 << i;
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
   14846:	8b 45 08             	mov    0x8(%ebp),%eax
   14849:	8b 40 0c             	mov    0xc(%eax),%eax
   1484c:	85 c0                	test   %eax,%eax
   1484e:	74 0d                	je     1485d <_DecodeDQT+0x105>
   14850:	8b 45 08             	mov    0x8(%ebp),%eax
   14853:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14859:	90                   	nop
   1485a:	eb 01                	jmp    1485d <_DecodeDQT+0x105>

void _DecodeDQT(Context* ctx){
    int i;
    uchar* t;
    _DecodeLength(ctx);
    if(ctx->result) return;
   1485c:	90                   	nop
        t =&ctx->qtable[i][0];
        for(i=0; i<64; ++i) t[i] = ctx->pos[i + 1];
        _Skip(ctx, 65);
    }
    if(ctx->length) ERROR_RETURN(SyntaxError);
}
   1485d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14860:	c9                   	leave  
   14861:	c3                   	ret    

00014862 <_DecodeDRI>:

void _DecodeDRI(Context* ctx){
   14862:	55                   	push   %ebp
   14863:	89 e5                	mov    %esp,%ebp
   14865:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   14868:	83 ec 0c             	sub    $0xc,%esp
   1486b:	ff 75 08             	pushl  0x8(%ebp)
   1486e:	e8 59 f6 ff ff       	call   13ecc <_DecodeLength>
   14873:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   14876:	8b 45 08             	mov    0x8(%ebp),%eax
   14879:	8b 00                	mov    (%eax),%eax
   1487b:	85 c0                	test   %eax,%eax
   1487d:	75 4a                	jne    148c9 <_DecodeDRI+0x67>
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
   1487f:	8b 45 08             	mov    0x8(%ebp),%eax
   14882:	8b 40 0c             	mov    0xc(%eax),%eax
   14885:	83 f8 01             	cmp    $0x1,%eax
   14888:	7f 0b                	jg     14895 <_DecodeDRI+0x33>
   1488a:	8b 45 08             	mov    0x8(%ebp),%eax
   1488d:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14893:	eb 35                	jmp    148ca <_DecodeDRI+0x68>
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
   14895:	8b 45 08             	mov    0x8(%ebp),%eax
   14898:	8b 40 04             	mov    0x4(%eax),%eax
   1489b:	83 ec 0c             	sub    $0xc,%esp
   1489e:	50                   	push   %eax
   1489f:	e8 8b f6 ff ff       	call   13f2f <_Decode2Bytes>
   148a4:	83 c4 10             	add    $0x10,%esp
   148a7:	89 c2                	mov    %eax,%edx
   148a9:	8b 45 08             	mov    0x8(%ebp),%eax
   148ac:	89 90 c0 02 08 00    	mov    %edx,0x802c0(%eax)
    _Skip(ctx, ctx->length);
   148b2:	8b 45 08             	mov    0x8(%ebp),%eax
   148b5:	8b 40 0c             	mov    0xc(%eax),%eax
   148b8:	83 ec 08             	sub    $0x8,%esp
   148bb:	50                   	push   %eax
   148bc:	ff 75 08             	pushl  0x8(%ebp)
   148bf:	e8 bc f5 ff ff       	call   13e80 <_Skip>
   148c4:	83 c4 10             	add    $0x10,%esp
   148c7:	eb 01                	jmp    148ca <_DecodeDRI+0x68>
    if(ctx->length) ERROR_RETURN(SyntaxError);
}

void _DecodeDRI(Context* ctx){
    _DecodeLength(ctx);
    if(ctx->result) return;
   148c9:	90                   	nop
    if(ctx->length < 2) ERROR_RETURN(SyntaxError);
    ctx->rstInterval = _Decode2Bytes(ctx->pos);
    _Skip(ctx, ctx->length);
}
   148ca:	c9                   	leave  
   148cb:	c3                   	ret    

000148cc <_DecodeSOS>:

void _DecodeSOS(Context* ctx, char* ZZ){
   148cc:	55                   	push   %ebp
   148cd:	89 e5                	mov    %esp,%ebp
   148cf:	83 ec 28             	sub    $0x28,%esp
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
   148d2:	8b 45 08             	mov    0x8(%ebp),%eax
   148d5:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   148db:	89 45 e0             	mov    %eax,-0x20(%ebp)
   148de:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
    Component* c;
    _DecodeLength(ctx);
   148e5:	83 ec 0c             	sub    $0xc,%esp
   148e8:	ff 75 08             	pushl  0x8(%ebp)
   148eb:	e8 dc f5 ff ff       	call   13ecc <_DecodeLength>
   148f0:	83 c4 10             	add    $0x10,%esp
    if(ctx->result) return;
   148f3:	8b 45 08             	mov    0x8(%ebp),%eax
   148f6:	8b 00                	mov    (%eax),%eax
   148f8:	85 c0                	test   %eax,%eax
   148fa:	0f 85 c2 02 00 00    	jne    14bc2 <_DecodeSOS+0x2f6>
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
   14900:	8b 45 08             	mov    0x8(%ebp),%eax
   14903:	8b 50 0c             	mov    0xc(%eax),%edx
   14906:	8b 45 08             	mov    0x8(%ebp),%eax
   14909:	8b 40 28             	mov    0x28(%eax),%eax
   1490c:	83 c0 02             	add    $0x2,%eax
   1490f:	01 c0                	add    %eax,%eax
   14911:	39 c2                	cmp    %eax,%edx
   14913:	7c 16                	jl     1492b <_DecodeSOS+0x5f>
   14915:	8b 45 08             	mov    0x8(%ebp),%eax
   14918:	8b 40 04             	mov    0x4(%eax),%eax
   1491b:	0f b6 00             	movzbl (%eax),%eax
   1491e:	0f b6 d0             	movzbl %al,%edx
   14921:	8b 45 08             	mov    0x8(%ebp),%eax
   14924:	8b 40 28             	mov    0x28(%eax),%eax
   14927:	39 c2                	cmp    %eax,%edx
   14929:	74 0e                	je     14939 <_DecodeSOS+0x6d>
   1492b:	8b 45 08             	mov    0x8(%ebp),%eax
   1492e:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14934:	e9 8d 02 00 00       	jmp    14bc6 <_DecodeSOS+0x2fa>
    _Skip(ctx, 1);
   14939:	83 ec 08             	sub    $0x8,%esp
   1493c:	6a 01                	push   $0x1
   1493e:	ff 75 08             	pushl  0x8(%ebp)
   14941:	e8 3a f5 ff ff       	call   13e80 <_Skip>
   14946:	83 c4 10             	add    $0x10,%esp
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14949:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14950:	8b 45 08             	mov    0x8(%ebp),%eax
   14953:	83 c0 2c             	add    $0x2c,%eax
   14956:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14959:	e9 ba 00 00 00       	jmp    14a18 <_DecodeSOS+0x14c>
        if(ctx->pos[0] != c->cid) ERROR_RETURN(SyntaxError);
   1495e:	8b 45 08             	mov    0x8(%ebp),%eax
   14961:	8b 40 04             	mov    0x4(%eax),%eax
   14964:	0f b6 00             	movzbl (%eax),%eax
   14967:	0f b6 d0             	movzbl %al,%edx
   1496a:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1496d:	8b 00                	mov    (%eax),%eax
   1496f:	39 c2                	cmp    %eax,%edx
   14971:	74 0e                	je     14981 <_DecodeSOS+0xb5>
   14973:	8b 45 08             	mov    0x8(%ebp),%eax
   14976:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   1497c:	e9 45 02 00 00       	jmp    14bc6 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0xEC) ERROR_RETURN(SyntaxError);
   14981:	8b 45 08             	mov    0x8(%ebp),%eax
   14984:	8b 40 04             	mov    0x4(%eax),%eax
   14987:	83 c0 01             	add    $0x1,%eax
   1498a:	0f b6 00             	movzbl (%eax),%eax
   1498d:	0f b6 c0             	movzbl %al,%eax
   14990:	25 ec 00 00 00       	and    $0xec,%eax
   14995:	85 c0                	test   %eax,%eax
   14997:	74 0e                	je     149a7 <_DecodeSOS+0xdb>
   14999:	8b 45 08             	mov    0x8(%ebp),%eax
   1499c:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   149a2:	e9 1f 02 00 00       	jmp    14bc6 <_DecodeSOS+0x2fa>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
   149a7:	8b 45 08             	mov    0x8(%ebp),%eax
   149aa:	8b 40 04             	mov    0x4(%eax),%eax
   149ad:	83 c0 01             	add    $0x1,%eax
   149b0:	0f b6 00             	movzbl (%eax),%eax
   149b3:	0f b6 c0             	movzbl %al,%eax
   149b6:	83 e0 02             	and    $0x2,%eax
   149b9:	85 c0                	test   %eax,%eax
   149bb:	74 0e                	je     149cb <_DecodeSOS+0xff>
   149bd:	8b 45 08             	mov    0x8(%ebp),%eax
   149c0:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   149c6:	e9 fb 01 00 00       	jmp    14bc6 <_DecodeSOS+0x2fa>
        c->dctabsel = ctx->pos[1] >> 4;
   149cb:	8b 45 08             	mov    0x8(%ebp),%eax
   149ce:	8b 40 04             	mov    0x4(%eax),%eax
   149d1:	83 c0 01             	add    $0x1,%eax
   149d4:	0f b6 00             	movzbl (%eax),%eax
   149d7:	c0 e8 04             	shr    $0x4,%al
   149da:	0f b6 d0             	movzbl %al,%edx
   149dd:	8b 45 dc             	mov    -0x24(%ebp),%eax
   149e0:	89 50 20             	mov    %edx,0x20(%eax)
        c->actabsel = (ctx->pos[1] & 1) | 2;
   149e3:	8b 45 08             	mov    0x8(%ebp),%eax
   149e6:	8b 40 04             	mov    0x4(%eax),%eax
   149e9:	83 c0 01             	add    $0x1,%eax
   149ec:	0f b6 00             	movzbl (%eax),%eax
   149ef:	0f b6 c0             	movzbl %al,%eax
   149f2:	83 e0 01             	and    $0x1,%eax
   149f5:	83 c8 02             	or     $0x2,%eax
   149f8:	89 c2                	mov    %eax,%edx
   149fa:	8b 45 dc             	mov    -0x24(%ebp),%eax
   149fd:	89 50 1c             	mov    %edx,0x1c(%eax)
        _Skip(ctx, 2);
   14a00:	83 ec 08             	sub    $0x8,%esp
   14a03:	6a 02                	push   $0x2
   14a05:	ff 75 08             	pushl  0x8(%ebp)
   14a08:	e8 73 f4 ff ff       	call   13e80 <_Skip>
   14a0d:	83 c4 10             	add    $0x10,%esp
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
    if((ctx->length < (4 + 2 * ctx->compNum)) || (ctx->pos[0] != ctx->compNum)) ERROR_RETURN(SyntaxError);
    _Skip(ctx, 1);
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   14a10:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14a14:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14a18:	8b 45 08             	mov    0x8(%ebp),%eax
   14a1b:	8b 40 28             	mov    0x28(%eax),%eax
   14a1e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14a21:	0f 8f 37 ff ff ff    	jg     1495e <_DecodeSOS+0x92>
        if(ctx->pos[1] & 0x02) ERROR_RETURN(Unsupported);
        c->dctabsel = ctx->pos[1] >> 4;
        c->actabsel = (ctx->pos[1] & 1) | 2;
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
   14a27:	8b 45 08             	mov    0x8(%ebp),%eax
   14a2a:	8b 40 04             	mov    0x4(%eax),%eax
   14a2d:	0f b6 00             	movzbl (%eax),%eax
   14a30:	84 c0                	test   %al,%al
   14a32:	75 10                	jne    14a44 <_DecodeSOS+0x178>
   14a34:	8b 45 08             	mov    0x8(%ebp),%eax
   14a37:	8b 40 04             	mov    0x4(%eax),%eax
   14a3a:	83 c0 01             	add    $0x1,%eax
   14a3d:	0f b6 00             	movzbl (%eax),%eax
   14a40:	3c 3f                	cmp    $0x3f,%al
   14a42:	74 0e                	je     14a52 <_DecodeSOS+0x186>
   14a44:	8b 45 08             	mov    0x8(%ebp),%eax
   14a47:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14a4d:	e9 74 01 00 00       	jmp    14bc6 <_DecodeSOS+0x2fa>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
   14a52:	8b 45 08             	mov    0x8(%ebp),%eax
   14a55:	8b 40 04             	mov    0x4(%eax),%eax
   14a58:	83 c0 02             	add    $0x2,%eax
   14a5b:	0f b6 00             	movzbl (%eax),%eax
   14a5e:	84 c0                	test   %al,%al
   14a60:	74 0e                	je     14a70 <_DecodeSOS+0x1a4>
   14a62:	8b 45 08             	mov    0x8(%ebp),%eax
   14a65:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
   14a6b:	e9 56 01 00 00       	jmp    14bc6 <_DecodeSOS+0x2fa>
    _Skip(ctx, ctx->length);
   14a70:	8b 45 08             	mov    0x8(%ebp),%eax
   14a73:	8b 40 0c             	mov    0xc(%eax),%eax
   14a76:	83 ec 08             	sub    $0x8,%esp
   14a79:	50                   	push   %eax
   14a7a:	ff 75 08             	pushl  0x8(%ebp)
   14a7d:	e8 fe f3 ff ff       	call   13e80 <_Skip>
   14a82:	83 c4 10             	add    $0x10,%esp
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   14a85:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   14a8c:	e9 17 01 00 00       	jmp    14ba8 <_DecodeSOS+0x2dc>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   14a91:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   14a98:	e9 f8 00 00 00       	jmp    14b95 <_DecodeSOS+0x2c9>
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14a9d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14aa4:	8b 45 08             	mov    0x8(%ebp),%eax
   14aa7:	83 c0 2c             	add    $0x2c,%eax
   14aaa:	89 45 dc             	mov    %eax,-0x24(%ebp)
   14aad:	e9 8d 00 00 00       	jmp    14b3f <_DecodeSOS+0x273>
                for(sby=0; sby<c->ssy; ++sby)
   14ab2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   14ab9:	eb 71                	jmp    14b2c <_DecodeSOS+0x260>
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14abb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   14ac2:	eb 59                	jmp    14b1d <_DecodeSOS+0x251>
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
   14ac4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14ac7:	8b 50 28             	mov    0x28(%eax),%edx
   14aca:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14acd:	8b 40 08             	mov    0x8(%eax),%eax
   14ad0:	0f af 45 ec          	imul   -0x14(%ebp),%eax
   14ad4:	89 c1                	mov    %eax,%ecx
   14ad6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   14ad9:	01 c1                	add    %eax,%ecx
   14adb:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14ade:	8b 40 14             	mov    0x14(%eax),%eax
   14ae1:	0f af c8             	imul   %eax,%ecx
   14ae4:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14ae7:	8b 40 04             	mov    0x4(%eax),%eax
   14aea:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14aee:	01 c1                	add    %eax,%ecx
   14af0:	8b 45 e8             	mov    -0x18(%ebp),%eax
   14af3:	01 c8                	add    %ecx,%eax
   14af5:	c1 e0 03             	shl    $0x3,%eax
   14af8:	01 d0                	add    %edx,%eax
   14afa:	50                   	push   %eax
   14afb:	ff 75 dc             	pushl  -0x24(%ebp)
   14afe:	ff 75 0c             	pushl  0xc(%ebp)
   14b01:	ff 75 08             	pushl  0x8(%ebp)
   14b04:	e8 bf 00 00 00       	call   14bc8 <_DecodeBlock>
   14b09:	83 c4 10             	add    $0x10,%esp
                        if(ctx->result) return;
   14b0c:	8b 45 08             	mov    0x8(%ebp),%eax
   14b0f:	8b 00                	mov    (%eax),%eax
   14b11:	85 c0                	test   %eax,%eax
   14b13:	0f 85 ac 00 00 00    	jne    14bc5 <_DecodeSOS+0x2f9>
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
   14b19:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   14b1d:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14b20:	8b 40 04             	mov    0x4(%eax),%eax
   14b23:	3b 45 e8             	cmp    -0x18(%ebp),%eax
   14b26:	7f 9c                	jg     14ac4 <_DecodeSOS+0x1f8>
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
   14b28:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   14b2c:	8b 45 dc             	mov    -0x24(%ebp),%eax
   14b2f:	8b 40 08             	mov    0x8(%eax),%eax
   14b32:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   14b35:	7f 84                	jg     14abb <_DecodeSOS+0x1ef>
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
   14b37:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14b3b:	83 45 dc 2c          	addl   $0x2c,-0x24(%ebp)
   14b3f:	8b 45 08             	mov    0x8(%ebp),%eax
   14b42:	8b 40 28             	mov    0x28(%eax),%eax
   14b45:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14b48:	0f 8f 64 ff ff ff    	jg     14ab2 <_DecodeSOS+0x1e6>
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
                    }
            if(ctx->rstInterval && !(--rstcount)){
   14b4e:	8b 45 08             	mov    0x8(%ebp),%eax
   14b51:	8b 80 c0 02 08 00    	mov    0x802c0(%eax),%eax
   14b57:	85 c0                	test   %eax,%eax
   14b59:	74 36                	je     14b91 <_DecodeSOS+0x2c5>
   14b5b:	83 6d e0 01          	subl   $0x1,-0x20(%ebp)
   14b5f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   14b63:	75 2c                	jne    14b91 <_DecodeSOS+0x2c5>
                _ByteAlign(ctx);
   14b65:	83 ec 0c             	sub    $0xc,%esp
   14b68:	ff 75 08             	pushl  0x8(%ebp)
   14b6b:	e8 9f 0a 00 00       	call   1560f <_ByteAlign>
   14b70:	83 c4 10             	add    $0x10,%esp
                i = _GetBits(ctx, 16);
   14b73:	83 ec 08             	sub    $0x8,%esp
   14b76:	6a 10                	push   $0x10
   14b78:	ff 75 08             	pushl  0x8(%ebp)
   14b7b:	e8 ce 04 00 00       	call   1504e <_GetBits>
   14b80:	83 c4 10             	add    $0x10,%esp
   14b83:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if(((i & 0xFFF8) != 0xFFFD0) || ((i & 7) != nextrst)) ERROR_RETURN(SyntaxError);
   14b86:	8b 45 08             	mov    0x8(%ebp),%eax
   14b89:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14b8f:	eb 35                	jmp    14bc6 <_DecodeSOS+0x2fa>
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
   14b91:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   14b95:	8b 45 08             	mov    0x8(%ebp),%eax
   14b98:	8b 40 18             	mov    0x18(%eax),%eax
   14b9b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
   14b9e:	0f 8f f9 fe ff ff    	jg     14a9d <_DecodeSOS+0x1d1>
        _Skip(ctx, 2);
    }
    if(ctx->pos[0] || (ctx->pos[1] != 0x3F)) ERROR_RETURN(SyntaxError);
    if(ctx->pos[2]) ERROR_RETURN(Unsupported);
    _Skip(ctx, ctx->length);
    for(MCUy=0; MCUy<ctx->MCUheight; ++MCUy)
   14ba4:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   14ba8:	8b 45 08             	mov    0x8(%ebp),%eax
   14bab:	8b 40 1c             	mov    0x1c(%eax),%eax
   14bae:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   14bb1:	0f 8f da fe ff ff    	jg     14a91 <_DecodeSOS+0x1c5>
                nextrst = (nextrst + 1) & 7;
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
   14bb7:	8b 45 08             	mov    0x8(%ebp),%eax
   14bba:	c7 00 06 00 00 00    	movl   $0x6,(%eax)
   14bc0:	eb 04                	jmp    14bc6 <_DecodeSOS+0x2fa>
void _DecodeSOS(Context* ctx, char* ZZ){
    int i, MCUx, MCUy, sbx, sby;
    int rstcount = ctx->rstInterval, nextrst = 0;
    Component* c;
    _DecodeLength(ctx);
    if(ctx->result) return;
   14bc2:	90                   	nop
   14bc3:	eb 01                	jmp    14bc6 <_DecodeSOS+0x2fa>
        for(MCUx=0; MCUx<ctx->MCUwidth; ++MCUx){
            for(i=0, c=ctx->comp; i<ctx->compNum; ++i,++c)
                for(sby=0; sby<c->ssy; ++sby)
                    for(sbx=0; sbx<c->ssx; ++sbx){
                        _DecodeBlock(ctx, ZZ, c, &c->pixels[((MCUy * c->ssy + sby) * c->stride + MCUx * c->ssx + sbx) << 3]);
                        if(ctx->result) return;
   14bc5:	90                   	nop
                rstcount = ctx->rstInterval;
                for(i=0; i<3; ++i) ctx->comp[i].dcpred = 0;
            }
        }
    ctx->result = InternalFinished;
}
   14bc6:	c9                   	leave  
   14bc7:	c3                   	ret    

00014bc8 <_DecodeBlock>:

void _DecodeBlock(Context* ctx, char * ZZ, Component* c, uchar* out){
   14bc8:	55                   	push   %ebp
   14bc9:	89 e5                	mov    %esp,%ebp
   14bcb:	53                   	push   %ebx
   14bcc:	83 ec 14             	sub    $0x14,%esp
    uchar code;
    int value, coef=0;
   14bcf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    memset(ctx->block, 0, sizeof(ctx->block));
   14bd6:	8b 45 08             	mov    0x8(%ebp),%eax
   14bd9:	05 c0 01 08 00       	add    $0x801c0,%eax
   14bde:	83 ec 04             	sub    $0x4,%esp
   14be1:	68 00 01 00 00       	push   $0x100
   14be6:	6a 00                	push   $0x0
   14be8:	50                   	push   %eax
   14be9:	e8 04 b8 fe ff       	call   3f2 <memset>
   14bee:	83 c4 10             	add    $0x10,%esp
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
   14bf1:	8b 45 10             	mov    0x10(%ebp),%eax
   14bf4:	8b 40 20             	mov    0x20(%eax),%eax
   14bf7:	c1 e0 11             	shl    $0x11,%eax
   14bfa:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14c00:	8b 45 08             	mov    0x8(%ebp),%eax
   14c03:	01 d0                	add    %edx,%eax
   14c05:	83 c0 08             	add    $0x8,%eax
   14c08:	83 ec 04             	sub    $0x4,%esp
   14c0b:	6a 00                	push   $0x0
   14c0d:	50                   	push   %eax
   14c0e:	ff 75 08             	pushl  0x8(%ebp)
   14c11:	e8 86 01 00 00       	call   14d9c <_GetVLC>
   14c16:	83 c4 10             	add    $0x10,%esp
   14c19:	89 c2                	mov    %eax,%edx
   14c1b:	8b 45 10             	mov    0x10(%ebp),%eax
   14c1e:	8b 40 24             	mov    0x24(%eax),%eax
   14c21:	01 c2                	add    %eax,%edx
   14c23:	8b 45 10             	mov    0x10(%ebp),%eax
   14c26:	89 50 24             	mov    %edx,0x24(%eax)
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
   14c29:	8b 45 10             	mov    0x10(%ebp),%eax
   14c2c:	8b 50 24             	mov    0x24(%eax),%edx
   14c2f:	8b 45 10             	mov    0x10(%ebp),%eax
   14c32:	8b 48 18             	mov    0x18(%eax),%ecx
   14c35:	8b 45 08             	mov    0x8(%ebp),%eax
   14c38:	c1 e1 06             	shl    $0x6,%ecx
   14c3b:	01 c8                	add    %ecx,%eax
   14c3d:	05 b8 00 00 00       	add    $0xb8,%eax
   14c42:	0f b6 00             	movzbl (%eax),%eax
   14c45:	0f b6 c0             	movzbl %al,%eax
   14c48:	0f af d0             	imul   %eax,%edx
   14c4b:	8b 45 08             	mov    0x8(%ebp),%eax
   14c4e:	89 90 c0 01 08 00    	mov    %edx,0x801c0(%eax)
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
   14c54:	8b 45 10             	mov    0x10(%ebp),%eax
   14c57:	8b 40 1c             	mov    0x1c(%eax),%eax
   14c5a:	c1 e0 11             	shl    $0x11,%eax
   14c5d:	8d 90 b0 01 00 00    	lea    0x1b0(%eax),%edx
   14c63:	8b 45 08             	mov    0x8(%ebp),%eax
   14c66:	01 d0                	add    %edx,%eax
   14c68:	8d 50 08             	lea    0x8(%eax),%edx
   14c6b:	83 ec 04             	sub    $0x4,%esp
   14c6e:	8d 45 ef             	lea    -0x11(%ebp),%eax
   14c71:	50                   	push   %eax
   14c72:	52                   	push   %edx
   14c73:	ff 75 08             	pushl  0x8(%ebp)
   14c76:	e8 21 01 00 00       	call   14d9c <_GetVLC>
   14c7b:	83 c4 10             	add    $0x10,%esp
   14c7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(!code) break;   // EOB
   14c81:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14c85:	84 c0                	test   %al,%al
   14c87:	0f 84 92 00 00 00    	je     14d1f <_DecodeBlock+0x157>
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
   14c8d:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14c91:	0f b6 c0             	movzbl %al,%eax
   14c94:	83 e0 0f             	and    $0xf,%eax
   14c97:	85 c0                	test   %eax,%eax
   14c99:	75 16                	jne    14cb1 <_DecodeBlock+0xe9>
   14c9b:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14c9f:	3c f0                	cmp    $0xf0,%al
   14ca1:	74 0e                	je     14cb1 <_DecodeBlock+0xe9>
   14ca3:	8b 45 08             	mov    0x8(%ebp),%eax
   14ca6:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14cac:	e9 e6 00 00 00       	jmp    14d97 <_DecodeBlock+0x1cf>
        coef += (code >> 4) + 1;
   14cb1:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
   14cb5:	c0 e8 04             	shr    $0x4,%al
   14cb8:	0f b6 c0             	movzbl %al,%eax
   14cbb:	83 c0 01             	add    $0x1,%eax
   14cbe:	01 45 f4             	add    %eax,-0xc(%ebp)
        if(coef>63) ERROR_RETURN(SyntaxError);
   14cc1:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14cc5:	7e 0e                	jle    14cd5 <_DecodeBlock+0x10d>
   14cc7:	8b 45 08             	mov    0x8(%ebp),%eax
   14cca:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14cd0:	e9 c2 00 00 00       	jmp    14d97 <_DecodeBlock+0x1cf>
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
   14cd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14cd8:	8b 45 0c             	mov    0xc(%ebp),%eax
   14cdb:	01 d0                	add    %edx,%eax
   14cdd:	0f b6 00             	movzbl (%eax),%eax
   14ce0:	0f be c8             	movsbl %al,%ecx
   14ce3:	8b 45 10             	mov    0x10(%ebp),%eax
   14ce6:	8b 50 18             	mov    0x18(%eax),%edx
   14ce9:	8b 45 08             	mov    0x8(%ebp),%eax
   14cec:	c1 e2 06             	shl    $0x6,%edx
   14cef:	01 c2                	add    %eax,%edx
   14cf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14cf4:	01 d0                	add    %edx,%eax
   14cf6:	05 b8 00 00 00       	add    $0xb8,%eax
   14cfb:	0f b6 00             	movzbl (%eax),%eax
   14cfe:	0f b6 c0             	movzbl %al,%eax
   14d01:	0f af 45 f0          	imul   -0x10(%ebp),%eax
   14d05:	89 c2                	mov    %eax,%edx
   14d07:	8b 45 08             	mov    0x8(%ebp),%eax
   14d0a:	81 c1 70 00 02 00    	add    $0x20070,%ecx
   14d10:	89 14 88             	mov    %edx,(%eax,%ecx,4)
    }while(coef < 63);
   14d13:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
   14d17:	0f 8e 37 ff ff ff    	jle    14c54 <_DecodeBlock+0x8c>
   14d1d:	eb 01                	jmp    14d20 <_DecodeBlock+0x158>
    memset(ctx->block, 0, sizeof(ctx->block));
    c->dcpred += _GetVLC(ctx, &ctx->vlctable[c->dctabsel][0], 0);
    ctx->block[0] = (c->dcpred) * ctx->qtable[c->qtselect][0];
    do{
        value = _GetVLC(ctx, &ctx->vlctable[c->actabsel][0], &code);
        if(!code) break;   // EOB
   14d1f:	90                   	nop
        if(!(code & 0x0F) && (code != 0xF0)) ERROR_RETURN(SyntaxError);
        coef += (code >> 4) + 1;
        if(coef>63) ERROR_RETURN(SyntaxError);
        ctx->block[(int)ZZ[coef]] = value * ctx->qtable[c->qtselect][coef];
    }while(coef < 63);
    for(coef=0; coef<64; coef+=8) _RowIDCT(&ctx->block[coef]);
   14d20:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14d27:	eb 24                	jmp    14d4d <_DecodeBlock+0x185>
   14d29:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14d2c:	05 70 00 02 00       	add    $0x20070,%eax
   14d31:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   14d38:	8b 45 08             	mov    0x8(%ebp),%eax
   14d3b:	01 d0                	add    %edx,%eax
   14d3d:	83 ec 0c             	sub    $0xc,%esp
   14d40:	50                   	push   %eax
   14d41:	e8 32 03 00 00       	call   15078 <_RowIDCT>
   14d46:	83 c4 10             	add    $0x10,%esp
   14d49:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
   14d4d:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
   14d51:	7e d6                	jle    14d29 <_DecodeBlock+0x161>
    for(coef=0; coef<8; ++coef) _ColIDCT(&ctx->block[coef], &out[coef], c->stride);
   14d53:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   14d5a:	eb 35                	jmp    14d91 <_DecodeBlock+0x1c9>
   14d5c:	8b 45 10             	mov    0x10(%ebp),%eax
   14d5f:	8b 40 14             	mov    0x14(%eax),%eax
   14d62:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   14d65:	8b 55 14             	mov    0x14(%ebp),%edx
   14d68:	01 d1                	add    %edx,%ecx
   14d6a:	8b 55 f4             	mov    -0xc(%ebp),%edx
   14d6d:	81 c2 70 00 02 00    	add    $0x20070,%edx
   14d73:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
   14d7a:	8b 55 08             	mov    0x8(%ebp),%edx
   14d7d:	01 da                	add    %ebx,%edx
   14d7f:	83 ec 04             	sub    $0x4,%esp
   14d82:	50                   	push   %eax
   14d83:	51                   	push   %ecx
   14d84:	52                   	push   %edx
   14d85:	e8 7b 05 00 00       	call   15305 <_ColIDCT>
   14d8a:	83 c4 10             	add    $0x10,%esp
   14d8d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   14d91:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
   14d95:	7e c5                	jle    14d5c <_DecodeBlock+0x194>
}
   14d97:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   14d9a:	c9                   	leave  
   14d9b:	c3                   	ret    

00014d9c <_GetVLC>:

int _GetVLC(Context* ctx, VlcCode* vlc, uchar* code){
   14d9c:	55                   	push   %ebp
   14d9d:	89 e5                	mov    %esp,%ebp
   14d9f:	83 ec 18             	sub    $0x18,%esp
    int value = _ShowBits(ctx, 16);
   14da2:	83 ec 08             	sub    $0x8,%esp
   14da5:	6a 10                	push   $0x10
   14da7:	ff 75 08             	pushl  0x8(%ebp)
   14daa:	e8 c2 00 00 00       	call   14e71 <_ShowBits>
   14daf:	83 c4 10             	add    $0x10,%esp
   14db2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int bits = vlc[value].bits;
   14db5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14db8:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14dbb:	8b 45 0c             	mov    0xc(%ebp),%eax
   14dbe:	01 d0                	add    %edx,%eax
   14dc0:	0f b6 00             	movzbl (%eax),%eax
   14dc3:	0f b6 c0             	movzbl %al,%eax
   14dc6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits){ ctx->result = SyntaxError; return 0; }
   14dc9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14dcd:	75 13                	jne    14de2 <_GetVLC+0x46>
   14dcf:	8b 45 08             	mov    0x8(%ebp),%eax
   14dd2:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14dd8:	b8 00 00 00 00       	mov    $0x0,%eax
   14ddd:	e9 8d 00 00 00       	jmp    14e6f <_GetVLC+0xd3>
    _SkipBits(ctx, bits);
   14de2:	83 ec 08             	sub    $0x8,%esp
   14de5:	ff 75 f0             	pushl  -0x10(%ebp)
   14de8:	ff 75 08             	pushl  0x8(%ebp)
   14deb:	e8 25 02 00 00       	call   15015 <_SkipBits>
   14df0:	83 c4 10             	add    $0x10,%esp
    value = vlc[value].code;
   14df3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14df6:	8d 14 00             	lea    (%eax,%eax,1),%edx
   14df9:	8b 45 0c             	mov    0xc(%ebp),%eax
   14dfc:	01 d0                	add    %edx,%eax
   14dfe:	0f b6 40 01          	movzbl 0x1(%eax),%eax
   14e02:	0f b6 c0             	movzbl %al,%eax
   14e05:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(code) *code = (uchar)value;
   14e08:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   14e0c:	74 0a                	je     14e18 <_GetVLC+0x7c>
   14e0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14e11:	89 c2                	mov    %eax,%edx
   14e13:	8b 45 10             	mov    0x10(%ebp),%eax
   14e16:	88 10                	mov    %dl,(%eax)
    bits = value & 15;
   14e18:	8b 45 f4             	mov    -0xc(%ebp),%eax
   14e1b:	83 e0 0f             	and    $0xf,%eax
   14e1e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(!bits) return 0;
   14e21:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   14e25:	75 07                	jne    14e2e <_GetVLC+0x92>
   14e27:	b8 00 00 00 00       	mov    $0x0,%eax
   14e2c:	eb 41                	jmp    14e6f <_GetVLC+0xd3>
    value = _GetBits(ctx, bits);
   14e2e:	83 ec 08             	sub    $0x8,%esp
   14e31:	ff 75 f0             	pushl  -0x10(%ebp)
   14e34:	ff 75 08             	pushl  0x8(%ebp)
   14e37:	e8 12 02 00 00       	call   1504e <_GetBits>
   14e3c:	83 c4 10             	add    $0x10,%esp
   14e3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(value < (1 << (bits - 1)))
   14e42:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14e45:	83 e8 01             	sub    $0x1,%eax
   14e48:	ba 01 00 00 00       	mov    $0x1,%edx
   14e4d:	89 c1                	mov    %eax,%ecx
   14e4f:	d3 e2                	shl    %cl,%edx
   14e51:	89 d0                	mov    %edx,%eax
   14e53:	3b 45 f4             	cmp    -0xc(%ebp),%eax
   14e56:	7e 14                	jle    14e6c <_GetVLC+0xd0>
        value += ((-1) << bits) + 1;
   14e58:	8b 45 f0             	mov    -0x10(%ebp),%eax
   14e5b:	ba ff ff ff ff       	mov    $0xffffffff,%edx
   14e60:	89 c1                	mov    %eax,%ecx
   14e62:	d3 e2                	shl    %cl,%edx
   14e64:	89 d0                	mov    %edx,%eax
   14e66:	83 c0 01             	add    $0x1,%eax
   14e69:	01 45 f4             	add    %eax,-0xc(%ebp)
    return value;
   14e6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   14e6f:	c9                   	leave  
   14e70:	c3                   	ret    

00014e71 <_ShowBits>:

int _ShowBits(Context* ctx, int bits){
   14e71:	55                   	push   %ebp
   14e72:	89 e5                	mov    %esp,%ebp
   14e74:	53                   	push   %ebx
   14e75:	83 ec 10             	sub    $0x10,%esp
    uchar nextbyte;
    if(!bits) return 0;
   14e78:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   14e7c:	0f 85 4f 01 00 00    	jne    14fd1 <_ShowBits+0x160>
   14e82:	b8 00 00 00 00       	mov    $0x0,%eax
   14e87:	e9 83 01 00 00       	jmp    1500f <_ShowBits+0x19e>
    while(ctx->bufferBits < bits){
        if(ctx->size <= 0){
   14e8c:	8b 45 08             	mov    0x8(%ebp),%eax
   14e8f:	8b 40 08             	mov    0x8(%eax),%eax
   14e92:	85 c0                	test   %eax,%eax
   14e94:	7f 33                	jg     14ec9 <_ShowBits+0x58>
            ctx->buffer = (ctx->buffer << 8) | 0xFF;
   14e96:	8b 45 08             	mov    0x8(%ebp),%eax
   14e99:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14e9f:	c1 e0 08             	shl    $0x8,%eax
   14ea2:	0c ff                	or     $0xff,%al
   14ea4:	89 c2                	mov    %eax,%edx
   14ea6:	8b 45 08             	mov    0x8(%ebp),%eax
   14ea9:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
            ctx->bufferBits += 8;
   14eaf:	8b 45 08             	mov    0x8(%ebp),%eax
   14eb2:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14eb8:	8d 50 08             	lea    0x8(%eax),%edx
   14ebb:	8b 45 08             	mov    0x8(%ebp),%eax
   14ebe:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
            continue;
   14ec4:	e9 08 01 00 00       	jmp    14fd1 <_ShowBits+0x160>
        }
        nextbyte = *ctx->pos++;
   14ec9:	8b 45 08             	mov    0x8(%ebp),%eax
   14ecc:	8b 40 04             	mov    0x4(%eax),%eax
   14ecf:	8d 48 01             	lea    0x1(%eax),%ecx
   14ed2:	8b 55 08             	mov    0x8(%ebp),%edx
   14ed5:	89 4a 04             	mov    %ecx,0x4(%edx)
   14ed8:	0f b6 00             	movzbl (%eax),%eax
   14edb:	88 45 fb             	mov    %al,-0x5(%ebp)
        --ctx->size;
   14ede:	8b 45 08             	mov    0x8(%ebp),%eax
   14ee1:	8b 40 08             	mov    0x8(%eax),%eax
   14ee4:	8d 50 ff             	lea    -0x1(%eax),%edx
   14ee7:	8b 45 08             	mov    0x8(%ebp),%eax
   14eea:	89 50 08             	mov    %edx,0x8(%eax)
        ctx->bufferBits += 8;
   14eed:	8b 45 08             	mov    0x8(%ebp),%eax
   14ef0:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14ef6:	8d 50 08             	lea    0x8(%eax),%edx
   14ef9:	8b 45 08             	mov    0x8(%ebp),%eax
   14efc:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
        ctx->buffer = (ctx->buffer << 8) | nextbyte;
   14f02:	8b 45 08             	mov    0x8(%ebp),%eax
   14f05:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14f0b:	c1 e0 08             	shl    $0x8,%eax
   14f0e:	89 c2                	mov    %eax,%edx
   14f10:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   14f14:	09 c2                	or     %eax,%edx
   14f16:	8b 45 08             	mov    0x8(%ebp),%eax
   14f19:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
        if(nextbyte == 0xFF){
   14f1f:	80 7d fb ff          	cmpb   $0xff,-0x5(%ebp)
   14f23:	0f 85 a8 00 00 00    	jne    14fd1 <_ShowBits+0x160>
            if(ctx->size){
   14f29:	8b 45 08             	mov    0x8(%ebp),%eax
   14f2c:	8b 40 08             	mov    0x8(%eax),%eax
   14f2f:	85 c0                	test   %eax,%eax
   14f31:	0f 84 91 00 00 00    	je     14fc8 <_ShowBits+0x157>
                uchar marker = *ctx->pos++;
   14f37:	8b 45 08             	mov    0x8(%ebp),%eax
   14f3a:	8b 40 04             	mov    0x4(%eax),%eax
   14f3d:	8d 48 01             	lea    0x1(%eax),%ecx
   14f40:	8b 55 08             	mov    0x8(%ebp),%edx
   14f43:	89 4a 04             	mov    %ecx,0x4(%edx)
   14f46:	0f b6 00             	movzbl (%eax),%eax
   14f49:	88 45 fa             	mov    %al,-0x6(%ebp)
                --ctx->size;
   14f4c:	8b 45 08             	mov    0x8(%ebp),%eax
   14f4f:	8b 40 08             	mov    0x8(%eax),%eax
   14f52:	8d 50 ff             	lea    -0x1(%eax),%edx
   14f55:	8b 45 08             	mov    0x8(%ebp),%eax
   14f58:	89 50 08             	mov    %edx,0x8(%eax)
                switch(marker){
   14f5b:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14f5f:	85 c0                	test   %eax,%eax
   14f61:	74 62                	je     14fc5 <_ShowBits+0x154>
   14f63:	3d d9 00 00 00       	cmp    $0xd9,%eax
   14f68:	75 0c                	jne    14f76 <_ShowBits+0x105>
                    case 0: break;
                    case 0xD9: ctx->size = 0; break;
   14f6a:	8b 45 08             	mov    0x8(%ebp),%eax
   14f6d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   14f74:	eb 5b                	jmp    14fd1 <_ShowBits+0x160>
                    default:
                        if((marker & 0xF8) != 0xD0)
   14f76:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14f7a:	25 f8 00 00 00       	and    $0xf8,%eax
   14f7f:	3d d0 00 00 00       	cmp    $0xd0,%eax
   14f84:	74 0b                	je     14f91 <_ShowBits+0x120>
                            ctx->result = SyntaxError;
   14f86:	8b 45 08             	mov    0x8(%ebp),%eax
   14f89:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
   14f8f:	eb 40                	jmp    14fd1 <_ShowBits+0x160>
                        else {
                            ctx->buffer = (ctx->buffer << 8) | marker;
   14f91:	8b 45 08             	mov    0x8(%ebp),%eax
   14f94:	8b 80 b8 01 08 00    	mov    0x801b8(%eax),%eax
   14f9a:	c1 e0 08             	shl    $0x8,%eax
   14f9d:	89 c2                	mov    %eax,%edx
   14f9f:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   14fa3:	09 c2                	or     %eax,%edx
   14fa5:	8b 45 08             	mov    0x8(%ebp),%eax
   14fa8:	89 90 b8 01 08 00    	mov    %edx,0x801b8(%eax)
                            ctx->bufferBits += 8;
   14fae:	8b 45 08             	mov    0x8(%ebp),%eax
   14fb1:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14fb7:	8d 50 08             	lea    0x8(%eax),%edx
   14fba:	8b 45 08             	mov    0x8(%ebp),%eax
   14fbd:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
   14fc3:	eb 0c                	jmp    14fd1 <_ShowBits+0x160>
        if(nextbyte == 0xFF){
            if(ctx->size){
                uchar marker = *ctx->pos++;
                --ctx->size;
                switch(marker){
                    case 0: break;
   14fc5:	90                   	nop
   14fc6:	eb 09                	jmp    14fd1 <_ShowBits+0x160>
                            ctx->buffer = (ctx->buffer << 8) | marker;
                            ctx->bufferBits += 8;
                        }
                }
            }
            else ctx->result = SyntaxError;
   14fc8:	8b 45 08             	mov    0x8(%ebp),%eax
   14fcb:	c7 00 05 00 00 00    	movl   $0x5,(%eax)
}

int _ShowBits(Context* ctx, int bits){
    uchar nextbyte;
    if(!bits) return 0;
    while(ctx->bufferBits < bits){
   14fd1:	8b 45 08             	mov    0x8(%ebp),%eax
   14fd4:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14fda:	3b 45 0c             	cmp    0xc(%ebp),%eax
   14fdd:	0f 8c a9 fe ff ff    	jl     14e8c <_ShowBits+0x1b>
                }
            }
            else ctx->result = SyntaxError;
        }
    }
    return (ctx->buffer >> (ctx->bufferBits - bits)) & ((1 << bits) - 1);
   14fe3:	8b 45 08             	mov    0x8(%ebp),%eax
   14fe6:	8b 90 b8 01 08 00    	mov    0x801b8(%eax),%edx
   14fec:	8b 45 08             	mov    0x8(%ebp),%eax
   14fef:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   14ff5:	2b 45 0c             	sub    0xc(%ebp),%eax
   14ff8:	89 c1                	mov    %eax,%ecx
   14ffa:	d3 fa                	sar    %cl,%edx
   14ffc:	8b 45 0c             	mov    0xc(%ebp),%eax
   14fff:	bb 01 00 00 00       	mov    $0x1,%ebx
   15004:	89 c1                	mov    %eax,%ecx
   15006:	d3 e3                	shl    %cl,%ebx
   15008:	89 d8                	mov    %ebx,%eax
   1500a:	83 e8 01             	sub    $0x1,%eax
   1500d:	21 d0                	and    %edx,%eax
}
   1500f:	83 c4 10             	add    $0x10,%esp
   15012:	5b                   	pop    %ebx
   15013:	5d                   	pop    %ebp
   15014:	c3                   	ret    

00015015 <_SkipBits>:

void _SkipBits(Context* ctx, int bits){
   15015:	55                   	push   %ebp
   15016:	89 e5                	mov    %esp,%ebp
    if(ctx->bufferBits < bits) _ShowBits(ctx, bits);
   15018:	8b 45 08             	mov    0x8(%ebp),%eax
   1501b:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   15021:	3b 45 0c             	cmp    0xc(%ebp),%eax
   15024:	7d 0e                	jge    15034 <_SkipBits+0x1f>
   15026:	ff 75 0c             	pushl  0xc(%ebp)
   15029:	ff 75 08             	pushl  0x8(%ebp)
   1502c:	e8 40 fe ff ff       	call   14e71 <_ShowBits>
   15031:	83 c4 08             	add    $0x8,%esp
    ctx->bufferBits -= bits;
   15034:	8b 45 08             	mov    0x8(%ebp),%eax
   15037:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1503d:	2b 45 0c             	sub    0xc(%ebp),%eax
   15040:	89 c2                	mov    %eax,%edx
   15042:	8b 45 08             	mov    0x8(%ebp),%eax
   15045:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   1504b:	90                   	nop
   1504c:	c9                   	leave  
   1504d:	c3                   	ret    

0001504e <_GetBits>:

int _GetBits(Context* ctx, int bits){
   1504e:	55                   	push   %ebp
   1504f:	89 e5                	mov    %esp,%ebp
   15051:	83 ec 10             	sub    $0x10,%esp
    int res = _ShowBits(ctx, bits);
   15054:	ff 75 0c             	pushl  0xc(%ebp)
   15057:	ff 75 08             	pushl  0x8(%ebp)
   1505a:	e8 12 fe ff ff       	call   14e71 <_ShowBits>
   1505f:	83 c4 08             	add    $0x8,%esp
   15062:	89 45 fc             	mov    %eax,-0x4(%ebp)
    _SkipBits(ctx, bits);
   15065:	ff 75 0c             	pushl  0xc(%ebp)
   15068:	ff 75 08             	pushl  0x8(%ebp)
   1506b:	e8 a5 ff ff ff       	call   15015 <_SkipBits>
   15070:	83 c4 08             	add    $0x8,%esp
    return res;
   15073:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   15076:	c9                   	leave  
   15077:	c3                   	ret    

00015078 <_RowIDCT>:
    W5 = 1609,
    W6 = 1108,
    W7 = 565,
};

void _RowIDCT(int* blk){
   15078:	55                   	push   %ebp
   15079:	89 e5                	mov    %esp,%ebp
   1507b:	57                   	push   %edi
   1507c:	56                   	push   %esi
   1507d:	53                   	push   %ebx
   1507e:	83 ec 38             	sub    $0x38,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   15081:	8b 45 08             	mov    0x8(%ebp),%eax
   15084:	83 c0 10             	add    $0x10,%eax
   15087:	8b 00                	mov    (%eax),%eax
   15089:	c1 e0 0b             	shl    $0xb,%eax
   1508c:	89 45 f0             	mov    %eax,-0x10(%ebp)
        | (x2 = blk[6])
   1508f:	8b 45 08             	mov    0x8(%ebp),%eax
   15092:	8b 40 18             	mov    0x18(%eax),%eax
   15095:	89 45 ec             	mov    %eax,-0x14(%ebp)
   15098:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1509b:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x3 = blk[2])
   1509e:	8b 55 08             	mov    0x8(%ebp),%edx
   150a1:	8b 52 08             	mov    0x8(%edx),%edx
   150a4:	89 55 e8             	mov    %edx,-0x18(%ebp)
   150a7:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x4 = blk[1])
   150aa:	8b 55 08             	mov    0x8(%ebp),%edx
   150ad:	8b 52 04             	mov    0x4(%edx),%edx
   150b0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   150b3:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x5 = blk[7])
   150b6:	8b 55 08             	mov    0x8(%ebp),%edx
   150b9:	8b 52 1c             	mov    0x1c(%edx),%edx
   150bc:	89 55 e0             	mov    %edx,-0x20(%ebp)
   150bf:	0b 45 e0             	or     -0x20(%ebp),%eax
        | (x6 = blk[5])
   150c2:	8b 55 08             	mov    0x8(%ebp),%edx
   150c5:	8b 52 14             	mov    0x14(%edx),%edx
   150c8:	89 55 dc             	mov    %edx,-0x24(%ebp)
   150cb:	0b 45 dc             	or     -0x24(%ebp),%eax
        | (x7 = blk[3])))
   150ce:	8b 55 08             	mov    0x8(%ebp),%edx
   150d1:	8b 52 0c             	mov    0xc(%edx),%edx
   150d4:	89 55 d8             	mov    %edx,-0x28(%ebp)
   150d7:	0b 45 d8             	or     -0x28(%ebp),%eax
    W7 = 565,
};

void _RowIDCT(int* blk){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[4] << 11)
   150da:	85 c0                	test   %eax,%eax
   150dc:	75 68                	jne    15146 <_RowIDCT+0xce>
        | (x4 = blk[1])
        | (x5 = blk[7])
        | (x6 = blk[5])
        | (x7 = blk[3])))
    {
        blk[0] = blk[1] = blk[2] = blk[3] = blk[4] = blk[5] = blk[6] = blk[7] = blk[0] << 3;
   150de:	8b 45 08             	mov    0x8(%ebp),%eax
   150e1:	8d 48 04             	lea    0x4(%eax),%ecx
   150e4:	8b 45 08             	mov    0x8(%ebp),%eax
   150e7:	8d 58 08             	lea    0x8(%eax),%ebx
   150ea:	8b 45 08             	mov    0x8(%ebp),%eax
   150ed:	8d 70 0c             	lea    0xc(%eax),%esi
   150f0:	8b 45 08             	mov    0x8(%ebp),%eax
   150f3:	8d 78 10             	lea    0x10(%eax),%edi
   150f6:	8b 45 08             	mov    0x8(%ebp),%eax
   150f9:	83 c0 14             	add    $0x14,%eax
   150fc:	89 45 c0             	mov    %eax,-0x40(%ebp)
   150ff:	8b 45 08             	mov    0x8(%ebp),%eax
   15102:	83 c0 18             	add    $0x18,%eax
   15105:	89 45 bc             	mov    %eax,-0x44(%ebp)
   15108:	8b 45 08             	mov    0x8(%ebp),%eax
   1510b:	8d 50 1c             	lea    0x1c(%eax),%edx
   1510e:	8b 45 08             	mov    0x8(%ebp),%eax
   15111:	8b 00                	mov    (%eax),%eax
   15113:	c1 e0 03             	shl    $0x3,%eax
   15116:	89 02                	mov    %eax,(%edx)
   15118:	8b 02                	mov    (%edx),%eax
   1511a:	8b 55 bc             	mov    -0x44(%ebp),%edx
   1511d:	89 02                	mov    %eax,(%edx)
   1511f:	89 d0                	mov    %edx,%eax
   15121:	8b 00                	mov    (%eax),%eax
   15123:	8b 55 c0             	mov    -0x40(%ebp),%edx
   15126:	89 02                	mov    %eax,(%edx)
   15128:	89 d0                	mov    %edx,%eax
   1512a:	8b 00                	mov    (%eax),%eax
   1512c:	89 07                	mov    %eax,(%edi)
   1512e:	8b 07                	mov    (%edi),%eax
   15130:	89 06                	mov    %eax,(%esi)
   15132:	8b 06                	mov    (%esi),%eax
   15134:	89 03                	mov    %eax,(%ebx)
   15136:	8b 03                	mov    (%ebx),%eax
   15138:	89 01                	mov    %eax,(%ecx)
   1513a:	8b 11                	mov    (%ecx),%edx
   1513c:	8b 45 08             	mov    0x8(%ebp),%eax
   1513f:	89 10                	mov    %edx,(%eax)
        return;
   15141:	e9 b7 01 00 00       	jmp    152fd <_RowIDCT+0x285>
    }
    x0 = (blk[0] << 11) + 128;
   15146:	8b 45 08             	mov    0x8(%ebp),%eax
   15149:	8b 00                	mov    (%eax),%eax
   1514b:	c1 e0 0b             	shl    $0xb,%eax
   1514e:	83 e8 80             	sub    $0xffffff80,%eax
   15151:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    x8 = W7 * (x4 + x5);
   15154:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15157:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1515a:	01 d0                	add    %edx,%eax
   1515c:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   15162:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x4 = x8 + (W1 - W7) * x4;
   15165:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15168:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   1516e:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15171:	01 d0                	add    %edx,%eax
   15173:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 = x8 - (W1 + W7) * x5;
   15176:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15179:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   1517f:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15182:	01 d0                	add    %edx,%eax
   15184:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = W3 * (x6 + x7);
   15187:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1518a:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1518d:	01 d0                	add    %edx,%eax
   1518f:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   15195:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x6 = x8 - (W3 - W5) * x6;
   15198:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1519b:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   151a1:	8b 45 d0             	mov    -0x30(%ebp),%eax
   151a4:	01 d0                	add    %edx,%eax
   151a6:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x7 = x8 - (W3 + W5) * x7;
   151a9:	8b 45 d8             	mov    -0x28(%ebp),%eax
   151ac:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   151b2:	8b 45 d0             	mov    -0x30(%ebp),%eax
   151b5:	01 d0                	add    %edx,%eax
   151b7:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 = x0 + x1;
   151ba:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   151bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151c0:	01 d0                	add    %edx,%eax
   151c2:	89 45 d0             	mov    %eax,-0x30(%ebp)
    x0 -= x1;
   151c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151c8:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x1 = W6 * (x3 + x2);
   151cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
   151ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
   151d1:	01 d0                	add    %edx,%eax
   151d3:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   151d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x2 = x1 - (W2 + W6) * x2;
   151dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   151df:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   151e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151e8:	01 d0                	add    %edx,%eax
   151ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x3 = x1 + (W2 - W6) * x3;
   151ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
   151f0:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   151f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   151f9:	01 d0                	add    %edx,%eax
   151fb:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x1 = x4 + x6;
   151fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15201:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15204:	01 d0                	add    %edx,%eax
   15206:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x4 -= x6;
   15209:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1520c:	29 45 e4             	sub    %eax,-0x1c(%ebp)
    x6 = x5 + x7;
   1520f:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15212:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15215:	01 d0                	add    %edx,%eax
   15217:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x5 -= x7;
   1521a:	8b 45 d8             	mov    -0x28(%ebp),%eax
   1521d:	29 45 e0             	sub    %eax,-0x20(%ebp)
    x7 = x8 + x3;
   15220:	8b 55 d0             	mov    -0x30(%ebp),%edx
   15223:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15226:	01 d0                	add    %edx,%eax
   15228:	89 45 d8             	mov    %eax,-0x28(%ebp)
    x8 -= x3;
   1522b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1522e:	29 45 d0             	sub    %eax,-0x30(%ebp)
    x3 = x0 + x2;
   15231:	8b 55 d4             	mov    -0x2c(%ebp),%edx
   15234:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15237:	01 d0                	add    %edx,%eax
   15239:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x0 -= x2;
   1523c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1523f:	29 45 d4             	sub    %eax,-0x2c(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   15242:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15245:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15248:	01 d0                	add    %edx,%eax
   1524a:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15250:	83 e8 80             	sub    $0xffffff80,%eax
   15253:	c1 f8 08             	sar    $0x8,%eax
   15256:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   15259:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1525c:	2b 45 e0             	sub    -0x20(%ebp),%eax
   1525f:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   15265:	83 e8 80             	sub    $0xffffff80,%eax
   15268:	c1 f8 08             	sar    $0x8,%eax
   1526b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    blk[0] = (x7 + x1) >> 8;
   1526e:	8b 55 d8             	mov    -0x28(%ebp),%edx
   15271:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15274:	01 d0                	add    %edx,%eax
   15276:	c1 f8 08             	sar    $0x8,%eax
   15279:	89 c2                	mov    %eax,%edx
   1527b:	8b 45 08             	mov    0x8(%ebp),%eax
   1527e:	89 10                	mov    %edx,(%eax)
    blk[1] = (x3 + x2) >> 8;
   15280:	8b 45 08             	mov    0x8(%ebp),%eax
   15283:	83 c0 04             	add    $0x4,%eax
   15286:	8b 4d e8             	mov    -0x18(%ebp),%ecx
   15289:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1528c:	01 ca                	add    %ecx,%edx
   1528e:	c1 fa 08             	sar    $0x8,%edx
   15291:	89 10                	mov    %edx,(%eax)
    blk[2] = (x0 + x4) >> 8;
   15293:	8b 45 08             	mov    0x8(%ebp),%eax
   15296:	83 c0 08             	add    $0x8,%eax
   15299:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
   1529c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   1529f:	01 ca                	add    %ecx,%edx
   152a1:	c1 fa 08             	sar    $0x8,%edx
   152a4:	89 10                	mov    %edx,(%eax)
    blk[3] = (x8 + x6) >> 8;
   152a6:	8b 45 08             	mov    0x8(%ebp),%eax
   152a9:	83 c0 0c             	add    $0xc,%eax
   152ac:	8b 4d d0             	mov    -0x30(%ebp),%ecx
   152af:	8b 55 dc             	mov    -0x24(%ebp),%edx
   152b2:	01 ca                	add    %ecx,%edx
   152b4:	c1 fa 08             	sar    $0x8,%edx
   152b7:	89 10                	mov    %edx,(%eax)
    blk[4] = (x8 - x6) >> 8;
   152b9:	8b 45 08             	mov    0x8(%ebp),%eax
   152bc:	8d 50 10             	lea    0x10(%eax),%edx
   152bf:	8b 45 d0             	mov    -0x30(%ebp),%eax
   152c2:	2b 45 dc             	sub    -0x24(%ebp),%eax
   152c5:	c1 f8 08             	sar    $0x8,%eax
   152c8:	89 02                	mov    %eax,(%edx)
    blk[5] = (x0 - x4) >> 8;
   152ca:	8b 45 08             	mov    0x8(%ebp),%eax
   152cd:	8d 50 14             	lea    0x14(%eax),%edx
   152d0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   152d3:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   152d6:	c1 f8 08             	sar    $0x8,%eax
   152d9:	89 02                	mov    %eax,(%edx)
    blk[6] = (x3 - x2) >> 8;
   152db:	8b 45 08             	mov    0x8(%ebp),%eax
   152de:	8d 50 18             	lea    0x18(%eax),%edx
   152e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
   152e4:	2b 45 ec             	sub    -0x14(%ebp),%eax
   152e7:	c1 f8 08             	sar    $0x8,%eax
   152ea:	89 02                	mov    %eax,(%edx)
    blk[7] = (x7 - x1) >> 8;
   152ec:	8b 45 08             	mov    0x8(%ebp),%eax
   152ef:	8d 50 1c             	lea    0x1c(%eax),%edx
   152f2:	8b 45 d8             	mov    -0x28(%ebp),%eax
   152f5:	2b 45 f0             	sub    -0x10(%ebp),%eax
   152f8:	c1 f8 08             	sar    $0x8,%eax
   152fb:	89 02                	mov    %eax,(%edx)
}
   152fd:	83 c4 38             	add    $0x38,%esp
   15300:	5b                   	pop    %ebx
   15301:	5e                   	pop    %esi
   15302:	5f                   	pop    %edi
   15303:	5d                   	pop    %ebp
   15304:	c3                   	ret    

00015305 <_ColIDCT>:

void _ColIDCT(const int* blk, uchar* out, int stride){
   15305:	55                   	push   %ebp
   15306:	89 e5                	mov    %esp,%ebp
   15308:	83 ec 30             	sub    $0x30,%esp
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   1530b:	8b 45 08             	mov    0x8(%ebp),%eax
   1530e:	83 e8 80             	sub    $0xffffff80,%eax
   15311:	8b 00                	mov    (%eax),%eax
   15313:	c1 e0 08             	shl    $0x8,%eax
   15316:	89 45 f8             	mov    %eax,-0x8(%ebp)
        | (x2 = blk[8 * 6])
   15319:	8b 45 08             	mov    0x8(%ebp),%eax
   1531c:	8b 80 c0 00 00 00    	mov    0xc0(%eax),%eax
   15322:	89 45 f4             	mov    %eax,-0xc(%ebp)
   15325:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15328:	0b 45 f4             	or     -0xc(%ebp),%eax
        | (x3 = blk[8 * 2])
   1532b:	8b 55 08             	mov    0x8(%ebp),%edx
   1532e:	8b 52 40             	mov    0x40(%edx),%edx
   15331:	89 55 f0             	mov    %edx,-0x10(%ebp)
   15334:	0b 45 f0             	or     -0x10(%ebp),%eax
        | (x4 = blk[8 * 1])
   15337:	8b 55 08             	mov    0x8(%ebp),%edx
   1533a:	8b 52 20             	mov    0x20(%edx),%edx
   1533d:	89 55 ec             	mov    %edx,-0x14(%ebp)
   15340:	0b 45 ec             	or     -0x14(%ebp),%eax
        | (x5 = blk[8 * 7])
   15343:	8b 55 08             	mov    0x8(%ebp),%edx
   15346:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
   1534c:	89 55 e8             	mov    %edx,-0x18(%ebp)
   1534f:	0b 45 e8             	or     -0x18(%ebp),%eax
        | (x6 = blk[8 * 5])
   15352:	8b 55 08             	mov    0x8(%ebp),%edx
   15355:	8b 92 a0 00 00 00    	mov    0xa0(%edx),%edx
   1535b:	89 55 e4             	mov    %edx,-0x1c(%ebp)
   1535e:	0b 45 e4             	or     -0x1c(%ebp),%eax
        | (x7 = blk[8 * 3])))
   15361:	8b 55 08             	mov    0x8(%ebp),%edx
   15364:	8b 52 60             	mov    0x60(%edx),%edx
   15367:	89 55 e0             	mov    %edx,-0x20(%ebp)
   1536a:	0b 45 e0             	or     -0x20(%ebp),%eax
    blk[7] = (x7 - x1) >> 8;
}

void _ColIDCT(const int* blk, uchar* out, int stride){
    int x0, x1, x2, x3, x4, x5, x6, x7, x8;
    if(!((x1 = blk[8 * 4] << 8)
   1536d:	85 c0                	test   %eax,%eax
   1536f:	75 45                	jne    153b6 <_ColIDCT+0xb1>
        | (x4 = blk[8 * 1])
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
   15371:	8b 45 08             	mov    0x8(%ebp),%eax
   15374:	8b 00                	mov    (%eax),%eax
   15376:	83 c0 20             	add    $0x20,%eax
   15379:	c1 f8 06             	sar    $0x6,%eax
   1537c:	83 e8 80             	sub    $0xffffff80,%eax
   1537f:	50                   	push   %eax
   15380:	e8 d6 ea ff ff       	call   13e5b <_Clip>
   15385:	83 c4 04             	add    $0x4,%esp
   15388:	0f b6 c0             	movzbl %al,%eax
   1538b:	89 45 f8             	mov    %eax,-0x8(%ebp)
        for (x0 = 8; x0; --x0) {
   1538e:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%ebp)
   15395:	eb 14                	jmp    153ab <_ColIDCT+0xa6>
            *out = (unsigned char)x1;
   15397:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1539a:	89 c2                	mov    %eax,%edx
   1539c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1539f:	88 10                	mov    %dl,(%eax)
            out += stride;
   153a1:	8b 45 10             	mov    0x10(%ebp),%eax
   153a4:	01 45 0c             	add    %eax,0xc(%ebp)
        | (x5 = blk[8 * 7])
        | (x6 = blk[8 * 5])
        | (x7 = blk[8 * 3])))
    {
        x1 = _Clip(((blk[0] + 32) >> 6) + 128);
        for (x0 = 8; x0; --x0) {
   153a7:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
   153ab:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   153af:	75 e6                	jne    15397 <_ColIDCT+0x92>
            *out = (unsigned char)x1;
            out += stride;
        }
        return;
   153b1:	e9 57 02 00 00       	jmp    1560d <_ColIDCT+0x308>
    }
    x0 = (blk[0] << 8) + 8192;
   153b6:	8b 45 08             	mov    0x8(%ebp),%eax
   153b9:	8b 00                	mov    (%eax),%eax
   153bb:	c1 e0 08             	shl    $0x8,%eax
   153be:	05 00 20 00 00       	add    $0x2000,%eax
   153c3:	89 45 fc             	mov    %eax,-0x4(%ebp)
    x8 = W7 * (x4 + x5) + 4;
   153c6:	8b 55 ec             	mov    -0x14(%ebp),%edx
   153c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
   153cc:	01 d0                	add    %edx,%eax
   153ce:	69 c0 35 02 00 00    	imul   $0x235,%eax,%eax
   153d4:	83 c0 04             	add    $0x4,%eax
   153d7:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x4 = (x8 + (W1 - W7) * x4) >> 3;
   153da:	8b 45 ec             	mov    -0x14(%ebp),%eax
   153dd:	69 d0 e4 08 00 00    	imul   $0x8e4,%eax,%edx
   153e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
   153e6:	01 d0                	add    %edx,%eax
   153e8:	c1 f8 03             	sar    $0x3,%eax
   153eb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    x5 = (x8 - (W1 + W7) * x5) >> 3;
   153ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
   153f1:	69 d0 b2 f2 ff ff    	imul   $0xfffff2b2,%eax,%edx
   153f7:	8b 45 dc             	mov    -0x24(%ebp),%eax
   153fa:	01 d0                	add    %edx,%eax
   153fc:	c1 f8 03             	sar    $0x3,%eax
   153ff:	89 45 e8             	mov    %eax,-0x18(%ebp)
    x8 = W3 * (x6 + x7) + 4;
   15402:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   15405:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15408:	01 d0                	add    %edx,%eax
   1540a:	69 c0 68 09 00 00    	imul   $0x968,%eax,%eax
   15410:	83 c0 04             	add    $0x4,%eax
   15413:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x6 = (x8 - (W3 - W5) * x6) >> 3;
   15416:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15419:	69 d0 e1 fc ff ff    	imul   $0xfffffce1,%eax,%edx
   1541f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15422:	01 d0                	add    %edx,%eax
   15424:	c1 f8 03             	sar    $0x3,%eax
   15427:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x7 = (x8 - (W3 + W5) * x7) >> 3;
   1542a:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1542d:	69 d0 4f f0 ff ff    	imul   $0xfffff04f,%eax,%edx
   15433:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15436:	01 d0                	add    %edx,%eax
   15438:	c1 f8 03             	sar    $0x3,%eax
   1543b:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 = x0 + x1;
   1543e:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15441:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15444:	01 d0                	add    %edx,%eax
   15446:	89 45 dc             	mov    %eax,-0x24(%ebp)
    x0 -= x1;
   15449:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1544c:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x1 = W6 * (x3 + x2) + 4;
   1544f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15452:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15455:	01 d0                	add    %edx,%eax
   15457:	69 c0 54 04 00 00    	imul   $0x454,%eax,%eax
   1545d:	83 c0 04             	add    $0x4,%eax
   15460:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x2 = (x1 - (W2 + W6) * x2) >> 3;
   15463:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15466:	69 d0 38 f1 ff ff    	imul   $0xfffff138,%eax,%edx
   1546c:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1546f:	01 d0                	add    %edx,%eax
   15471:	c1 f8 03             	sar    $0x3,%eax
   15474:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x3 = (x1 + (W2 - W6) * x3) >> 3;
   15477:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1547a:	69 d0 20 06 00 00    	imul   $0x620,%eax,%edx
   15480:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15483:	01 d0                	add    %edx,%eax
   15485:	c1 f8 03             	sar    $0x3,%eax
   15488:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x1 = x4 + x6;
   1548b:	8b 55 ec             	mov    -0x14(%ebp),%edx
   1548e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15491:	01 d0                	add    %edx,%eax
   15493:	89 45 f8             	mov    %eax,-0x8(%ebp)
    x4 -= x6;
   15496:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15499:	29 45 ec             	sub    %eax,-0x14(%ebp)
    x6 = x5 + x7;
   1549c:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1549f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154a2:	01 d0                	add    %edx,%eax
   154a4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    x5 -= x7;
   154a7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   154aa:	29 45 e8             	sub    %eax,-0x18(%ebp)
    x7 = x8 + x3;
   154ad:	8b 55 dc             	mov    -0x24(%ebp),%edx
   154b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   154b3:	01 d0                	add    %edx,%eax
   154b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
    x8 -= x3;
   154b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
   154bb:	29 45 dc             	sub    %eax,-0x24(%ebp)
    x3 = x0 + x2;
   154be:	8b 55 fc             	mov    -0x4(%ebp),%edx
   154c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   154c4:	01 d0                	add    %edx,%eax
   154c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    x0 -= x2;
   154c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   154cc:	29 45 fc             	sub    %eax,-0x4(%ebp)
    x2 = (181 * (x4 + x5) + 128) >> 8;
   154cf:	8b 55 ec             	mov    -0x14(%ebp),%edx
   154d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
   154d5:	01 d0                	add    %edx,%eax
   154d7:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   154dd:	83 e8 80             	sub    $0xffffff80,%eax
   154e0:	c1 f8 08             	sar    $0x8,%eax
   154e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    x4 = (181 * (x4 - x5) + 128) >> 8;
   154e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   154e9:	2b 45 e8             	sub    -0x18(%ebp),%eax
   154ec:	69 c0 b5 00 00 00    	imul   $0xb5,%eax,%eax
   154f2:	83 e8 80             	sub    $0xffffff80,%eax
   154f5:	c1 f8 08             	sar    $0x8,%eax
   154f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
    *out = _Clip(((x7 + x1) >> 14) + 128);  out += stride;
   154fb:	8b 55 e0             	mov    -0x20(%ebp),%edx
   154fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
   15501:	01 d0                	add    %edx,%eax
   15503:	c1 f8 0e             	sar    $0xe,%eax
   15506:	83 e8 80             	sub    $0xffffff80,%eax
   15509:	50                   	push   %eax
   1550a:	e8 4c e9 ff ff       	call   13e5b <_Clip>
   1550f:	83 c4 04             	add    $0x4,%esp
   15512:	89 c2                	mov    %eax,%edx
   15514:	8b 45 0c             	mov    0xc(%ebp),%eax
   15517:	88 10                	mov    %dl,(%eax)
   15519:	8b 45 10             	mov    0x10(%ebp),%eax
   1551c:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 + x2) >> 14) + 128);  out += stride;
   1551f:	8b 55 f0             	mov    -0x10(%ebp),%edx
   15522:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15525:	01 d0                	add    %edx,%eax
   15527:	c1 f8 0e             	sar    $0xe,%eax
   1552a:	83 e8 80             	sub    $0xffffff80,%eax
   1552d:	50                   	push   %eax
   1552e:	e8 28 e9 ff ff       	call   13e5b <_Clip>
   15533:	83 c4 04             	add    $0x4,%esp
   15536:	89 c2                	mov    %eax,%edx
   15538:	8b 45 0c             	mov    0xc(%ebp),%eax
   1553b:	88 10                	mov    %dl,(%eax)
   1553d:	8b 45 10             	mov    0x10(%ebp),%eax
   15540:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 + x4) >> 14) + 128);  out += stride;
   15543:	8b 55 fc             	mov    -0x4(%ebp),%edx
   15546:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15549:	01 d0                	add    %edx,%eax
   1554b:	c1 f8 0e             	sar    $0xe,%eax
   1554e:	83 e8 80             	sub    $0xffffff80,%eax
   15551:	50                   	push   %eax
   15552:	e8 04 e9 ff ff       	call   13e5b <_Clip>
   15557:	83 c4 04             	add    $0x4,%esp
   1555a:	89 c2                	mov    %eax,%edx
   1555c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1555f:	88 10                	mov    %dl,(%eax)
   15561:	8b 45 10             	mov    0x10(%ebp),%eax
   15564:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 + x6) >> 14) + 128);  out += stride;
   15567:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1556a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1556d:	01 d0                	add    %edx,%eax
   1556f:	c1 f8 0e             	sar    $0xe,%eax
   15572:	83 e8 80             	sub    $0xffffff80,%eax
   15575:	50                   	push   %eax
   15576:	e8 e0 e8 ff ff       	call   13e5b <_Clip>
   1557b:	83 c4 04             	add    $0x4,%esp
   1557e:	89 c2                	mov    %eax,%edx
   15580:	8b 45 0c             	mov    0xc(%ebp),%eax
   15583:	88 10                	mov    %dl,(%eax)
   15585:	8b 45 10             	mov    0x10(%ebp),%eax
   15588:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x8 - x6) >> 14) + 128);  out += stride;
   1558b:	8b 45 dc             	mov    -0x24(%ebp),%eax
   1558e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
   15591:	c1 f8 0e             	sar    $0xe,%eax
   15594:	83 e8 80             	sub    $0xffffff80,%eax
   15597:	50                   	push   %eax
   15598:	e8 be e8 ff ff       	call   13e5b <_Clip>
   1559d:	83 c4 04             	add    $0x4,%esp
   155a0:	89 c2                	mov    %eax,%edx
   155a2:	8b 45 0c             	mov    0xc(%ebp),%eax
   155a5:	88 10                	mov    %dl,(%eax)
   155a7:	8b 45 10             	mov    0x10(%ebp),%eax
   155aa:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x0 - x4) >> 14) + 128);  out += stride;
   155ad:	8b 45 fc             	mov    -0x4(%ebp),%eax
   155b0:	2b 45 ec             	sub    -0x14(%ebp),%eax
   155b3:	c1 f8 0e             	sar    $0xe,%eax
   155b6:	83 e8 80             	sub    $0xffffff80,%eax
   155b9:	50                   	push   %eax
   155ba:	e8 9c e8 ff ff       	call   13e5b <_Clip>
   155bf:	83 c4 04             	add    $0x4,%esp
   155c2:	89 c2                	mov    %eax,%edx
   155c4:	8b 45 0c             	mov    0xc(%ebp),%eax
   155c7:	88 10                	mov    %dl,(%eax)
   155c9:	8b 45 10             	mov    0x10(%ebp),%eax
   155cc:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x3 - x2) >> 14) + 128);  out += stride;
   155cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
   155d2:	2b 45 f4             	sub    -0xc(%ebp),%eax
   155d5:	c1 f8 0e             	sar    $0xe,%eax
   155d8:	83 e8 80             	sub    $0xffffff80,%eax
   155db:	50                   	push   %eax
   155dc:	e8 7a e8 ff ff       	call   13e5b <_Clip>
   155e1:	83 c4 04             	add    $0x4,%esp
   155e4:	89 c2                	mov    %eax,%edx
   155e6:	8b 45 0c             	mov    0xc(%ebp),%eax
   155e9:	88 10                	mov    %dl,(%eax)
   155eb:	8b 45 10             	mov    0x10(%ebp),%eax
   155ee:	01 45 0c             	add    %eax,0xc(%ebp)
    *out = _Clip(((x7 - x1) >> 14) + 128);
   155f1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   155f4:	2b 45 f8             	sub    -0x8(%ebp),%eax
   155f7:	c1 f8 0e             	sar    $0xe,%eax
   155fa:	83 e8 80             	sub    $0xffffff80,%eax
   155fd:	50                   	push   %eax
   155fe:	e8 58 e8 ff ff       	call   13e5b <_Clip>
   15603:	83 c4 04             	add    $0x4,%esp
   15606:	89 c2                	mov    %eax,%edx
   15608:	8b 45 0c             	mov    0xc(%ebp),%eax
   1560b:	88 10                	mov    %dl,(%eax)
}
   1560d:	c9                   	leave  
   1560e:	c3                   	ret    

0001560f <_ByteAlign>:

void _ByteAlign(Context* ctx){
   1560f:	55                   	push   %ebp
   15610:	89 e5                	mov    %esp,%ebp
    ctx->bufferBits &= 0xF8;
   15612:	8b 45 08             	mov    0x8(%ebp),%eax
   15615:	8b 80 bc 01 08 00    	mov    0x801bc(%eax),%eax
   1561b:	25 f8 00 00 00       	and    $0xf8,%eax
   15620:	89 c2                	mov    %eax,%edx
   15622:	8b 45 08             	mov    0x8(%ebp),%eax
   15625:	89 90 bc 01 08 00    	mov    %edx,0x801bc(%eax)
}
   1562b:	90                   	nop
   1562c:	5d                   	pop    %ebp
   1562d:	c3                   	ret    

0001562e <_SkipMarker>:

void _SkipMarker(Context* ctx){
   1562e:	55                   	push   %ebp
   1562f:	89 e5                	mov    %esp,%ebp
   15631:	83 ec 08             	sub    $0x8,%esp
    _DecodeLength(ctx);
   15634:	83 ec 0c             	sub    $0xc,%esp
   15637:	ff 75 08             	pushl  0x8(%ebp)
   1563a:	e8 8d e8 ff ff       	call   13ecc <_DecodeLength>
   1563f:	83 c4 10             	add    $0x10,%esp
    _Skip(ctx, ctx->length);
   15642:	8b 45 08             	mov    0x8(%ebp),%eax
   15645:	8b 40 0c             	mov    0xc(%eax),%eax
   15648:	83 ec 08             	sub    $0x8,%esp
   1564b:	50                   	push   %eax
   1564c:	ff 75 08             	pushl  0x8(%ebp)
   1564f:	e8 2c e8 ff ff       	call   13e80 <_Skip>
   15654:	83 c4 10             	add    $0x10,%esp
}
   15657:	90                   	nop
   15658:	c9                   	leave  
   15659:	c3                   	ret    

0001565a <_Convert>:

void _Convert(Context* ctx){
   1565a:	55                   	push   %ebp
   1565b:	89 e5                	mov    %esp,%ebp
   1565d:	57                   	push   %edi
   1565e:	56                   	push   %esi
   1565f:	53                   	push   %ebx
   15660:	83 ec 4c             	sub    $0x4c,%esp
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15663:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   1566a:	8b 45 08             	mov    0x8(%ebp),%eax
   1566d:	83 c0 2c             	add    $0x2c,%eax
   15670:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15673:	e9 b2 00 00 00       	jmp    1572a <_Convert+0xd0>
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
   15678:	8b 45 e0             	mov    -0x20(%ebp),%eax
   1567b:	8b 50 0c             	mov    0xc(%eax),%edx
   1567e:	8b 45 08             	mov    0x8(%ebp),%eax
   15681:	8b 40 10             	mov    0x10(%eax),%eax
   15684:	39 c2                	cmp    %eax,%edx
   15686:	7d 11                	jge    15699 <_Convert+0x3f>
   15688:	83 ec 08             	sub    $0x8,%esp
   1568b:	ff 75 e0             	pushl  -0x20(%ebp)
   1568e:	ff 75 08             	pushl  0x8(%ebp)
   15691:	e8 79 02 00 00       	call   1590f <_UpsampleH>
   15696:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   15699:	8b 45 08             	mov    0x8(%ebp),%eax
   1569c:	8b 00                	mov    (%eax),%eax
   1569e:	85 c0                	test   %eax,%eax
   156a0:	0f 85 5d 02 00 00    	jne    15903 <_Convert+0x2a9>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
   156a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
   156a9:	8b 50 10             	mov    0x10(%eax),%edx
   156ac:	8b 45 08             	mov    0x8(%ebp),%eax
   156af:	8b 40 14             	mov    0x14(%eax),%eax
   156b2:	39 c2                	cmp    %eax,%edx
   156b4:	7d 11                	jge    156c7 <_Convert+0x6d>
   156b6:	83 ec 08             	sub    $0x8,%esp
   156b9:	ff 75 e0             	pushl  -0x20(%ebp)
   156bc:	ff 75 08             	pushl  0x8(%ebp)
   156bf:	e8 db 05 00 00       	call   15c9f <_UpsampleV>
   156c4:	83 c4 10             	add    $0x10,%esp
            if(ctx->result) return;
   156c7:	8b 45 08             	mov    0x8(%ebp),%eax
   156ca:	8b 00                	mov    (%eax),%eax
   156cc:	85 c0                	test   %eax,%eax
   156ce:	0f 85 32 02 00 00    	jne    15906 <_Convert+0x2ac>

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
   156d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   156d7:	8b 50 0c             	mov    0xc(%eax),%edx
   156da:	8b 45 08             	mov    0x8(%ebp),%eax
   156dd:	8b 40 10             	mov    0x10(%eax),%eax
   156e0:	39 c2                	cmp    %eax,%edx
   156e2:	7c 94                	jl     15678 <_Convert+0x1e>
   156e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   156e7:	8b 50 10             	mov    0x10(%eax),%edx
   156ea:	8b 45 08             	mov    0x8(%ebp),%eax
   156ed:	8b 40 14             	mov    0x14(%eax),%eax
   156f0:	39 c2                	cmp    %eax,%edx
   156f2:	7c 84                	jl     15678 <_Convert+0x1e>
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
   156f4:	8b 45 e0             	mov    -0x20(%ebp),%eax
   156f7:	8b 50 0c             	mov    0xc(%eax),%edx
   156fa:	8b 45 08             	mov    0x8(%ebp),%eax
   156fd:	8b 40 10             	mov    0x10(%eax),%eax
   15700:	39 c2                	cmp    %eax,%edx
   15702:	7c 10                	jl     15714 <_Convert+0xba>
   15704:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15707:	8b 50 10             	mov    0x10(%eax),%edx
   1570a:	8b 45 08             	mov    0x8(%ebp),%eax
   1570d:	8b 40 14             	mov    0x14(%eax),%eax
   15710:	39 c2                	cmp    %eax,%edx
   15712:	7d 0e                	jge    15722 <_Convert+0xc8>
   15714:	8b 45 08             	mov    0x8(%ebp),%eax
   15717:	c7 00 04 00 00 00    	movl   $0x4,(%eax)
   1571d:	e9 e5 01 00 00       	jmp    15907 <_Convert+0x2ad>
}

void _Convert(Context* ctx){
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
   15722:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
   15726:	83 45 e0 2c          	addl   $0x2c,-0x20(%ebp)
   1572a:	8b 45 08             	mov    0x8(%ebp),%eax
   1572d:	8b 40 28             	mov    0x28(%eax),%eax
   15730:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15733:	7f 9f                	jg     156d4 <_Convert+0x7a>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
        }
        if((c->width < ctx->width) || (c->height < ctx->height)) ERROR_RETURN(InternalError);
    }
    if(ctx->compNum == 3){
   15735:	8b 45 08             	mov    0x8(%ebp),%eax
   15738:	8b 40 28             	mov    0x28(%eax),%eax
   1573b:	83 f8 03             	cmp    $0x3,%eax
   1573e:	0f 85 3d 01 00 00    	jne    15881 <_Convert+0x227>
        // convert to RGB
        int x, yy;
        uchar *prgb = ctx->rgb;
   15744:	8b 45 08             	mov    0x8(%ebp),%eax
   15747:	8b 80 c4 02 08 00    	mov    0x802c4(%eax),%eax
   1574d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        const uchar *py = ctx->comp[0].pixels;
   15750:	8b 45 08             	mov    0x8(%ebp),%eax
   15753:	8b 40 54             	mov    0x54(%eax),%eax
   15756:	89 45 d0             	mov    %eax,-0x30(%ebp)
        const uchar *pcb = ctx->comp[1].pixels;
   15759:	8b 45 08             	mov    0x8(%ebp),%eax
   1575c:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
   15762:	89 45 cc             	mov    %eax,-0x34(%ebp)
        const uchar *pcr = ctx->comp[2].pixels;
   15765:	8b 45 08             	mov    0x8(%ebp),%eax
   15768:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
   1576e:	89 45 c8             	mov    %eax,-0x38(%ebp)
        for(yy=ctx->height; yy; --yy){
   15771:	8b 45 08             	mov    0x8(%ebp),%eax
   15774:	8b 40 14             	mov    0x14(%eax),%eax
   15777:	89 45 d8             	mov    %eax,-0x28(%ebp)
   1577a:	e9 f3 00 00 00       	jmp    15872 <_Convert+0x218>
            for(x=0; x<ctx->width; ++x){
   1577f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
   15786:	e9 b6 00 00 00       	jmp    15841 <_Convert+0x1e7>
                register int y = py[x] << 8;
   1578b:	8b 55 dc             	mov    -0x24(%ebp),%edx
   1578e:	8b 45 d0             	mov    -0x30(%ebp),%eax
   15791:	01 d0                	add    %edx,%eax
   15793:	0f b6 00             	movzbl (%eax),%eax
   15796:	0f b6 c0             	movzbl %al,%eax
   15799:	c1 e0 08             	shl    $0x8,%eax
   1579c:	89 c3                	mov    %eax,%ebx
                register int cb = pcb[x] - 128;
   1579e:	8b 55 dc             	mov    -0x24(%ebp),%edx
   157a1:	8b 45 cc             	mov    -0x34(%ebp),%eax
   157a4:	01 d0                	add    %edx,%eax
   157a6:	0f b6 00             	movzbl (%eax),%eax
   157a9:	0f b6 c0             	movzbl %al,%eax
   157ac:	8d 78 80             	lea    -0x80(%eax),%edi
                register int cr = pcr[x] - 128;
   157af:	8b 55 dc             	mov    -0x24(%ebp),%edx
   157b2:	8b 45 c8             	mov    -0x38(%ebp),%eax
   157b5:	01 d0                	add    %edx,%eax
   157b7:	0f b6 00             	movzbl (%eax),%eax
   157ba:	0f b6 c0             	movzbl %al,%eax
   157bd:	83 c0 80             	add    $0xffffff80,%eax
   157c0:	89 c1                	mov    %eax,%ecx
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
   157c2:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   157c5:	8d 46 01             	lea    0x1(%esi),%eax
   157c8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   157cb:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
   157ce:	89 c8                	mov    %ecx,%eax
   157d0:	69 c0 67 01 00 00    	imul   $0x167,%eax,%eax
   157d6:	01 d8                	add    %ebx,%eax
   157d8:	83 e8 80             	sub    $0xffffff80,%eax
   157db:	c1 f8 08             	sar    $0x8,%eax
   157de:	83 ec 0c             	sub    $0xc,%esp
   157e1:	50                   	push   %eax
   157e2:	e8 74 e6 ff ff       	call   13e5b <_Clip>
   157e7:	83 c4 10             	add    $0x10,%esp
   157ea:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
   157ec:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   157ef:	8d 46 01             	lea    0x1(%esi),%eax
   157f2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   157f5:	6b c7 a8             	imul   $0xffffffa8,%edi,%eax
   157f8:	8d 14 18             	lea    (%eax,%ebx,1),%edx
   157fb:	69 45 b4 49 ff ff ff 	imul   $0xffffff49,-0x4c(%ebp),%eax
   15802:	01 d0                	add    %edx,%eax
   15804:	83 e8 80             	sub    $0xffffff80,%eax
   15807:	c1 f8 08             	sar    $0x8,%eax
   1580a:	83 ec 0c             	sub    $0xc,%esp
   1580d:	50                   	push   %eax
   1580e:	e8 48 e6 ff ff       	call   13e5b <_Clip>
   15813:	83 c4 10             	add    $0x10,%esp
   15816:	88 06                	mov    %al,(%esi)
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
   15818:	8b 75 d4             	mov    -0x2c(%ebp),%esi
   1581b:	8d 46 01             	lea    0x1(%esi),%eax
   1581e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
   15821:	69 c7 c6 01 00 00    	imul   $0x1c6,%edi,%eax
   15827:	01 d8                	add    %ebx,%eax
   15829:	83 e8 80             	sub    $0xffffff80,%eax
   1582c:	c1 f8 08             	sar    $0x8,%eax
   1582f:	83 ec 0c             	sub    $0xc,%esp
   15832:	50                   	push   %eax
   15833:	e8 23 e6 ff ff       	call   13e5b <_Clip>
   15838:	83 c4 10             	add    $0x10,%esp
   1583b:	88 06                	mov    %al,(%esi)
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
            for(x=0; x<ctx->width; ++x){
   1583d:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
   15841:	8b 45 08             	mov    0x8(%ebp),%eax
   15844:	8b 40 10             	mov    0x10(%eax),%eax
   15847:	3b 45 dc             	cmp    -0x24(%ebp),%eax
   1584a:	0f 8f 3b ff ff ff    	jg     1578b <_Convert+0x131>
                register int cr = pcr[x] - 128;
                *prgb++ = _Clip((y + 359 * cr + 128) >> 8);
                *prgb++ = _Clip((y - 88 * cb - 183 * cr + 128) >> 8);
                *prgb++ = _Clip((y + 454 * cb + 128) >> 8);
            }
            py += ctx->comp[0].stride;
   15850:	8b 45 08             	mov    0x8(%ebp),%eax
   15853:	8b 40 40             	mov    0x40(%eax),%eax
   15856:	01 45 d0             	add    %eax,-0x30(%ebp)
            pcb += ctx->comp[1].stride;
   15859:	8b 45 08             	mov    0x8(%ebp),%eax
   1585c:	8b 40 6c             	mov    0x6c(%eax),%eax
   1585f:	01 45 cc             	add    %eax,-0x34(%ebp)
            pcr += ctx->comp[2].stride;
   15862:	8b 45 08             	mov    0x8(%ebp),%eax
   15865:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
   1586b:	01 45 c8             	add    %eax,-0x38(%ebp)
        int x, yy;
        uchar *prgb = ctx->rgb;
        const uchar *py = ctx->comp[0].pixels;
        const uchar *pcb = ctx->comp[1].pixels;
        const uchar *pcr = ctx->comp[2].pixels;
        for(yy=ctx->height; yy; --yy){
   1586e:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
   15872:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15876:	0f 85 03 ff ff ff    	jne    1577f <_Convert+0x125>
   1587c:	e9 86 00 00 00       	jmp    15907 <_Convert+0x2ad>
            py += ctx->comp[0].stride;
            pcb += ctx->comp[1].stride;
            pcr += ctx->comp[2].stride;
        }
    }
    else if(ctx->comp[0].width != ctx->comp[0].stride){
   15881:	8b 45 08             	mov    0x8(%ebp),%eax
   15884:	8b 50 38             	mov    0x38(%eax),%edx
   15887:	8b 45 08             	mov    0x8(%ebp),%eax
   1588a:	8b 40 40             	mov    0x40(%eax),%eax
   1588d:	39 c2                	cmp    %eax,%edx
   1588f:	74 76                	je     15907 <_Convert+0x2ad>
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
   15891:	8b 45 08             	mov    0x8(%ebp),%eax
   15894:	8b 50 54             	mov    0x54(%eax),%edx
   15897:	8b 45 08             	mov    0x8(%ebp),%eax
   1589a:	8b 40 40             	mov    0x40(%eax),%eax
   1589d:	01 d0                	add    %edx,%eax
   1589f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
   158a2:	8b 45 08             	mov    0x8(%ebp),%eax
   158a5:	8b 50 54             	mov    0x54(%eax),%edx
   158a8:	8b 45 08             	mov    0x8(%ebp),%eax
   158ab:	8b 40 38             	mov    0x38(%eax),%eax
   158ae:	01 d0                	add    %edx,%eax
   158b0:	89 45 c0             	mov    %eax,-0x40(%ebp)
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   158b3:	8b 45 08             	mov    0x8(%ebp),%eax
   158b6:	8b 40 3c             	mov    0x3c(%eax),%eax
   158b9:	83 e8 01             	sub    $0x1,%eax
   158bc:	89 45 bc             	mov    %eax,-0x44(%ebp)
   158bf:	eb 2e                	jmp    158ef <_Convert+0x295>
            memmove(pout, pin, ctx->comp[0].width);
   158c1:	8b 45 08             	mov    0x8(%ebp),%eax
   158c4:	8b 40 38             	mov    0x38(%eax),%eax
   158c7:	83 ec 04             	sub    $0x4,%esp
   158ca:	50                   	push   %eax
   158cb:	ff 75 c4             	pushl  -0x3c(%ebp)
   158ce:	ff 75 c0             	pushl  -0x40(%ebp)
   158d1:	e8 72 ac fe ff       	call   548 <memmove>
   158d6:	83 c4 10             	add    $0x10,%esp
            pin += ctx->comp[0].stride;
   158d9:	8b 45 08             	mov    0x8(%ebp),%eax
   158dc:	8b 40 40             	mov    0x40(%eax),%eax
   158df:	01 45 c4             	add    %eax,-0x3c(%ebp)
            pout += ctx->comp[0].width;
   158e2:	8b 45 08             	mov    0x8(%ebp),%eax
   158e5:	8b 40 38             	mov    0x38(%eax),%eax
   158e8:	01 45 c0             	add    %eax,-0x40(%ebp)
    else if(ctx->comp[0].width != ctx->comp[0].stride){
        // grayscale -> only remove stride
        uchar *pin = &ctx->comp[0].pixels[ctx->comp[0].stride];
        uchar *pout = &ctx->comp[0].pixels[ctx->comp[0].width];
        int y;
        for(y = ctx->comp[0].height - 1; y; --y){
   158eb:	83 6d bc 01          	subl   $0x1,-0x44(%ebp)
   158ef:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
   158f3:	75 cc                	jne    158c1 <_Convert+0x267>
            memmove(pout, pin, ctx->comp[0].width);
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
   158f5:	8b 45 08             	mov    0x8(%ebp),%eax
   158f8:	8b 50 38             	mov    0x38(%eax),%edx
   158fb:	8b 45 08             	mov    0x8(%ebp),%eax
   158fe:	89 50 40             	mov    %edx,0x40(%eax)
   15901:	eb 04                	jmp    15907 <_Convert+0x2ad>
    int i;
    Component* c;
    for(i=0, c=ctx->comp; i<ctx->compNum; ++i, ++c){
        while((c->width < ctx->width) || (c->height < ctx->height)){
            if(c->width < ctx->width) _UpsampleH(ctx, c);
            if(ctx->result) return;
   15903:	90                   	nop
   15904:	eb 01                	jmp    15907 <_Convert+0x2ad>
            if(c->height < ctx->height) _UpsampleV(ctx, c);
            if(ctx->result) return;
   15906:	90                   	nop
            pin += ctx->comp[0].stride;
            pout += ctx->comp[0].width;
        }
        ctx->comp[0].stride = ctx->comp[0].width;
    }
}
   15907:	8d 65 f4             	lea    -0xc(%ebp),%esp
   1590a:	5b                   	pop    %ebx
   1590b:	5e                   	pop    %esi
   1590c:	5f                   	pop    %edi
   1590d:	5d                   	pop    %ebp
   1590e:	c3                   	ret    

0001590f <_UpsampleH>:
    CF3Z = (-3),
    CF2A = (139),
    CF2B = (-11),
};

void _UpsampleH(Context* ctx, Component* c){
   1590f:	55                   	push   %ebp
   15910:	89 e5                	mov    %esp,%ebp
   15912:	53                   	push   %ebx
   15913:	83 ec 24             	sub    $0x24,%esp
    const int xmax = c->width - 3;
   15916:	8b 45 0c             	mov    0xc(%ebp),%eax
   15919:	8b 40 0c             	mov    0xc(%eax),%eax
   1591c:	83 e8 03             	sub    $0x3,%eax
   1591f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    uchar *out, *lin, *lout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15922:	8b 45 0c             	mov    0xc(%ebp),%eax
   15925:	8b 50 0c             	mov    0xc(%eax),%edx
   15928:	8b 45 0c             	mov    0xc(%ebp),%eax
   1592b:	8b 40 10             	mov    0x10(%eax),%eax
   1592e:	0f af c2             	imul   %edx,%eax
   15931:	01 c0                	add    %eax,%eax
   15933:	83 ec 0c             	sub    $0xc,%esp
   15936:	50                   	push   %eax
   15937:	e8 cb b0 fe ff       	call   a07 <malloc>
   1593c:	83 c4 10             	add    $0x10,%esp
   1593f:	89 45 e0             	mov    %eax,-0x20(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15942:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   15946:	75 0e                	jne    15956 <_UpsampleH+0x47>
   15948:	8b 45 08             	mov    0x8(%ebp),%eax
   1594b:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15951:	e9 44 03 00 00       	jmp    15c9a <_UpsampleH+0x38b>
    lin = c->pixels;
   15956:	8b 45 0c             	mov    0xc(%ebp),%eax
   15959:	8b 40 28             	mov    0x28(%eax),%eax
   1595c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    lout = out;
   1595f:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15962:	89 45 f0             	mov    %eax,-0x10(%ebp)
    y =c->height;
   15965:	8b 45 0c             	mov    0xc(%ebp),%eax
   15968:	8b 40 10             	mov    0x10(%eax),%eax
   1596b:	89 45 e8             	mov    %eax,-0x18(%ebp)
   while(y--){
   1596e:	e9 e0 02 00 00       	jmp    15c53 <_UpsampleH+0x344>
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
   15973:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15976:	0f b6 00             	movzbl (%eax),%eax
   15979:	0f b6 c0             	movzbl %al,%eax
   1597c:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15982:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15985:	83 c0 01             	add    $0x1,%eax
   15988:	0f b6 00             	movzbl (%eax),%eax
   1598b:	0f b6 c0             	movzbl %al,%eax
   1598e:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15991:	01 d0                	add    %edx,%eax
   15993:	83 ec 0c             	sub    $0xc,%esp
   15996:	50                   	push   %eax
   15997:	e8 c4 06 00 00       	call   16060 <CF>
   1599c:	83 c4 10             	add    $0x10,%esp
   1599f:	89 c2                	mov    %eax,%edx
   159a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   159a4:	88 10                	mov    %dl,(%eax)
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
   159a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   159a9:	8d 58 01             	lea    0x1(%eax),%ebx
   159ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159af:	0f b6 00             	movzbl (%eax),%eax
   159b2:	0f b6 c0             	movzbl %al,%eax
   159b5:	6b c8 68             	imul   $0x68,%eax,%ecx
   159b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159bb:	83 c0 01             	add    $0x1,%eax
   159be:	0f b6 00             	movzbl (%eax),%eax
   159c1:	0f b6 d0             	movzbl %al,%edx
   159c4:	89 d0                	mov    %edx,%eax
   159c6:	01 c0                	add    %eax,%eax
   159c8:	01 d0                	add    %edx,%eax
   159ca:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   159d1:	01 d0                	add    %edx,%eax
   159d3:	01 c1                	add    %eax,%ecx
   159d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   159d8:	83 c0 02             	add    $0x2,%eax
   159db:	0f b6 00             	movzbl (%eax),%eax
   159de:	0f b6 d0             	movzbl %al,%edx
   159e1:	89 d0                	mov    %edx,%eax
   159e3:	01 c0                	add    %eax,%eax
   159e5:	01 d0                	add    %edx,%eax
   159e7:	f7 d8                	neg    %eax
   159e9:	01 c8                	add    %ecx,%eax
   159eb:	83 ec 0c             	sub    $0xc,%esp
   159ee:	50                   	push   %eax
   159ef:	e8 6c 06 00 00       	call   16060 <CF>
   159f4:	83 c4 10             	add    $0x10,%esp
   159f7:	88 03                	mov    %al,(%ebx)
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
   159f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
   159fc:	8d 58 02             	lea    0x2(%eax),%ebx
   159ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a02:	0f b6 00             	movzbl (%eax),%eax
   15a05:	0f b6 c0             	movzbl %al,%eax
   15a08:	c1 e0 02             	shl    $0x2,%eax
   15a0b:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15a12:	29 c2                	sub    %eax,%edx
   15a14:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a17:	83 c0 01             	add    $0x1,%eax
   15a1a:	0f b6 00             	movzbl (%eax),%eax
   15a1d:	0f b6 c0             	movzbl %al,%eax
   15a20:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15a23:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15a26:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a29:	83 c0 02             	add    $0x2,%eax
   15a2c:	0f b6 00             	movzbl (%eax),%eax
   15a2f:	0f b6 d0             	movzbl %al,%edx
   15a32:	89 d0                	mov    %edx,%eax
   15a34:	c1 e0 03             	shl    $0x3,%eax
   15a37:	01 d0                	add    %edx,%eax
   15a39:	f7 d8                	neg    %eax
   15a3b:	01 c8                	add    %ecx,%eax
   15a3d:	83 ec 0c             	sub    $0xc,%esp
   15a40:	50                   	push   %eax
   15a41:	e8 1a 06 00 00       	call   16060 <CF>
   15a46:	83 c4 10             	add    $0x10,%esp
   15a49:	88 03                	mov    %al,(%ebx)
        for (x = 0; x < xmax; ++x) {
   15a4b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15a52:	e9 fa 00 00 00       	jmp    15b51 <_UpsampleH+0x242>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
   15a57:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15a5a:	01 c0                	add    %eax,%eax
   15a5c:	8d 50 03             	lea    0x3(%eax),%edx
   15a5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15a62:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   15a65:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15a68:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a6b:	01 d0                	add    %edx,%eax
   15a6d:	0f b6 00             	movzbl (%eax),%eax
   15a70:	0f b6 d0             	movzbl %al,%edx
   15a73:	89 d0                	mov    %edx,%eax
   15a75:	c1 e0 03             	shl    $0x3,%eax
   15a78:	01 d0                	add    %edx,%eax
   15a7a:	f7 d8                	neg    %eax
   15a7c:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15a7f:	8d 4a 01             	lea    0x1(%edx),%ecx
   15a82:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15a85:	01 ca                	add    %ecx,%edx
   15a87:	0f b6 12             	movzbl (%edx),%edx
   15a8a:	0f b6 d2             	movzbl %dl,%edx
   15a8d:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15a90:	01 c2                	add    %eax,%edx
   15a92:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15a95:	8d 48 02             	lea    0x2(%eax),%ecx
   15a98:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15a9b:	01 c8                	add    %ecx,%eax
   15a9d:	0f b6 00             	movzbl (%eax),%eax
   15aa0:	0f b6 c0             	movzbl %al,%eax
   15aa3:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15aa6:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15aa9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15aac:	8d 50 03             	lea    0x3(%eax),%edx
   15aaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ab2:	01 d0                	add    %edx,%eax
   15ab4:	0f b6 00             	movzbl (%eax),%eax
   15ab7:	0f b6 d0             	movzbl %al,%edx
   15aba:	89 d0                	mov    %edx,%eax
   15abc:	01 c0                	add    %eax,%eax
   15abe:	01 d0                	add    %edx,%eax
   15ac0:	f7 d8                	neg    %eax
   15ac2:	01 c8                	add    %ecx,%eax
   15ac4:	83 ec 0c             	sub    $0xc,%esp
   15ac7:	50                   	push   %eax
   15ac8:	e8 93 05 00 00       	call   16060 <CF>
   15acd:	83 c4 10             	add    $0x10,%esp
   15ad0:	88 03                	mov    %al,(%ebx)
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
   15ad2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15ad5:	01 c0                	add    %eax,%eax
   15ad7:	8d 50 04             	lea    0x4(%eax),%edx
   15ada:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15add:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
   15ae0:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15ae3:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ae6:	01 d0                	add    %edx,%eax
   15ae8:	0f b6 00             	movzbl (%eax),%eax
   15aeb:	0f b6 d0             	movzbl %al,%edx
   15aee:	89 d0                	mov    %edx,%eax
   15af0:	01 c0                	add    %eax,%eax
   15af2:	01 d0                	add    %edx,%eax
   15af4:	f7 d8                	neg    %eax
   15af6:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15af9:	8d 4a 01             	lea    0x1(%edx),%ecx
   15afc:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15aff:	01 ca                	add    %ecx,%edx
   15b01:	0f b6 12             	movzbl (%edx),%edx
   15b04:	0f b6 d2             	movzbl %dl,%edx
   15b07:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15b0a:	01 c2                	add    %eax,%edx
   15b0c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15b0f:	8d 48 02             	lea    0x2(%eax),%ecx
   15b12:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b15:	01 c8                	add    %ecx,%eax
   15b17:	0f b6 00             	movzbl (%eax),%eax
   15b1a:	0f b6 c0             	movzbl %al,%eax
   15b1d:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15b20:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15b23:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15b26:	8d 50 03             	lea    0x3(%eax),%edx
   15b29:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b2c:	01 d0                	add    %edx,%eax
   15b2e:	0f b6 00             	movzbl (%eax),%eax
   15b31:	0f b6 d0             	movzbl %al,%edx
   15b34:	89 d0                	mov    %edx,%eax
   15b36:	c1 e0 03             	shl    $0x3,%eax
   15b39:	01 d0                	add    %edx,%eax
   15b3b:	f7 d8                	neg    %eax
   15b3d:	01 c8                	add    %ecx,%eax
   15b3f:	83 ec 0c             	sub    $0xc,%esp
   15b42:	50                   	push   %eax
   15b43:	e8 18 05 00 00       	call   16060 <CF>
   15b48:	83 c4 10             	add    $0x10,%esp
   15b4b:	88 03                	mov    %al,(%ebx)
    y =c->height;
   while(y--){
        lout[0] = CF(CF2A * lin[0] + CF2B * lin[1]);
        lout[1] = CF(CF3X * lin[0] + CF3Y * lin[1] + CF3Z * lin[2]);
        lout[2] = CF(CF3A * lin[0] + CF3B * lin[1] + CF3C * lin[2]);
        for (x = 0; x < xmax; ++x) {
   15b4d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   15b51:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15b54:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   15b57:	0f 8c fa fe ff ff    	jl     15a57 <_UpsampleH+0x148>
            lout[(x << 1) + 3] = CF(CF4A * lin[x] + CF4B * lin[x + 1] + CF4C * lin[x + 2] + CF4D * lin[x + 3]);
            lout[(x << 1) + 4] = CF(CF4D * lin[x] + CF4C * lin[x + 1] + CF4B * lin[x + 2] + CF4A * lin[x + 3]);
        }
        lin += c->stride;
   15b5d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b60:	8b 40 14             	mov    0x14(%eax),%eax
   15b63:	01 45 f4             	add    %eax,-0xc(%ebp)
        lout += c->width << 1;
   15b66:	8b 45 0c             	mov    0xc(%ebp),%eax
   15b69:	8b 40 0c             	mov    0xc(%eax),%eax
   15b6c:	01 c0                	add    %eax,%eax
   15b6e:	01 45 f0             	add    %eax,-0x10(%ebp)
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
   15b71:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15b74:	8d 58 fd             	lea    -0x3(%eax),%ebx
   15b77:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b7a:	83 e8 01             	sub    $0x1,%eax
   15b7d:	0f b6 00             	movzbl (%eax),%eax
   15b80:	0f b6 c0             	movzbl %al,%eax
   15b83:	c1 e0 02             	shl    $0x2,%eax
   15b86:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15b8d:	29 c2                	sub    %eax,%edx
   15b8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15b92:	83 e8 02             	sub    $0x2,%eax
   15b95:	0f b6 00             	movzbl (%eax),%eax
   15b98:	0f b6 c0             	movzbl %al,%eax
   15b9b:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15b9e:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15ba1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ba4:	83 e8 03             	sub    $0x3,%eax
   15ba7:	0f b6 00             	movzbl (%eax),%eax
   15baa:	0f b6 d0             	movzbl %al,%edx
   15bad:	89 d0                	mov    %edx,%eax
   15baf:	c1 e0 03             	shl    $0x3,%eax
   15bb2:	01 d0                	add    %edx,%eax
   15bb4:	f7 d8                	neg    %eax
   15bb6:	01 c8                	add    %ecx,%eax
   15bb8:	83 ec 0c             	sub    $0xc,%esp
   15bbb:	50                   	push   %eax
   15bbc:	e8 9f 04 00 00       	call   16060 <CF>
   15bc1:	83 c4 10             	add    $0x10,%esp
   15bc4:	88 03                	mov    %al,(%ebx)
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
   15bc6:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15bc9:	8d 58 fe             	lea    -0x2(%eax),%ebx
   15bcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bcf:	83 e8 01             	sub    $0x1,%eax
   15bd2:	0f b6 00             	movzbl (%eax),%eax
   15bd5:	0f b6 c0             	movzbl %al,%eax
   15bd8:	6b c8 68             	imul   $0x68,%eax,%ecx
   15bdb:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bde:	83 e8 02             	sub    $0x2,%eax
   15be1:	0f b6 00             	movzbl (%eax),%eax
   15be4:	0f b6 d0             	movzbl %al,%edx
   15be7:	89 d0                	mov    %edx,%eax
   15be9:	01 c0                	add    %eax,%eax
   15beb:	01 d0                	add    %edx,%eax
   15bed:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15bf4:	01 d0                	add    %edx,%eax
   15bf6:	01 c1                	add    %eax,%ecx
   15bf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15bfb:	83 e8 03             	sub    $0x3,%eax
   15bfe:	0f b6 00             	movzbl (%eax),%eax
   15c01:	0f b6 d0             	movzbl %al,%edx
   15c04:	89 d0                	mov    %edx,%eax
   15c06:	01 c0                	add    %eax,%eax
   15c08:	01 d0                	add    %edx,%eax
   15c0a:	f7 d8                	neg    %eax
   15c0c:	01 c8                	add    %ecx,%eax
   15c0e:	83 ec 0c             	sub    $0xc,%esp
   15c11:	50                   	push   %eax
   15c12:	e8 49 04 00 00       	call   16060 <CF>
   15c17:	83 c4 10             	add    $0x10,%esp
   15c1a:	88 03                	mov    %al,(%ebx)
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
   15c1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15c1f:	8d 58 ff             	lea    -0x1(%eax),%ebx
   15c22:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c25:	83 e8 01             	sub    $0x1,%eax
   15c28:	0f b6 00             	movzbl (%eax),%eax
   15c2b:	0f b6 c0             	movzbl %al,%eax
   15c2e:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15c34:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15c37:	83 e8 02             	sub    $0x2,%eax
   15c3a:	0f b6 00             	movzbl (%eax),%eax
   15c3d:	0f b6 c0             	movzbl %al,%eax
   15c40:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15c43:	01 d0                	add    %edx,%eax
   15c45:	83 ec 0c             	sub    $0xc,%esp
   15c48:	50                   	push   %eax
   15c49:	e8 12 04 00 00       	call   16060 <CF>
   15c4e:	83 c4 10             	add    $0x10,%esp
   15c51:	88 03                	mov    %al,(%ebx)
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    lin = c->pixels;
    lout = out;
    y =c->height;
   while(y--){
   15c53:	8b 45 e8             	mov    -0x18(%ebp),%eax
   15c56:	8d 50 ff             	lea    -0x1(%eax),%edx
   15c59:	89 55 e8             	mov    %edx,-0x18(%ebp)
   15c5c:	85 c0                	test   %eax,%eax
   15c5e:	0f 85 0f fd ff ff    	jne    15973 <_UpsampleH+0x64>
        lout += c->width << 1;
        lout[-3] = CF(CF3A * lin[-1] + CF3B * lin[-2] + CF3C * lin[-3]);
        lout[-2] = CF(CF3X * lin[-1] + CF3Y * lin[-2] + CF3Z * lin[-3]);
        lout[-1] = CF(CF2A * lin[-1] + CF2B * lin[-2]);
    }
    c->width <<= 1;
   15c64:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c67:	8b 40 0c             	mov    0xc(%eax),%eax
   15c6a:	8d 14 00             	lea    (%eax,%eax,1),%edx
   15c6d:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c70:	89 50 0c             	mov    %edx,0xc(%eax)
    c->stride = c->width;
   15c73:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c76:	8b 50 0c             	mov    0xc(%eax),%edx
   15c79:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c7c:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   15c7f:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c82:	8b 40 28             	mov    0x28(%eax),%eax
   15c85:	83 ec 0c             	sub    $0xc,%esp
   15c88:	50                   	push   %eax
   15c89:	e8 37 ac fe ff       	call   8c5 <free>
   15c8e:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   15c91:	8b 45 0c             	mov    0xc(%ebp),%eax
   15c94:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15c97:	89 50 28             	mov    %edx,0x28(%eax)
}
   15c9a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   15c9d:	c9                   	leave  
   15c9e:	c3                   	ret    

00015c9f <_UpsampleV>:
void _UpsampleV(Context* ctx, Component* c){
   15c9f:	55                   	push   %ebp
   15ca0:	89 e5                	mov    %esp,%ebp
   15ca2:	83 ec 28             	sub    $0x28,%esp
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
   15ca5:	8b 45 0c             	mov    0xc(%ebp),%eax
   15ca8:	8b 40 0c             	mov    0xc(%eax),%eax
   15cab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
   15cae:	8b 45 0c             	mov    0xc(%ebp),%eax
   15cb1:	8b 40 14             	mov    0x14(%eax),%eax
   15cb4:	89 45 e0             	mov    %eax,-0x20(%ebp)
   15cb7:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15cba:	01 c0                	add    %eax,%eax
   15cbc:	89 45 dc             	mov    %eax,-0x24(%ebp)
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
   15cbf:	8b 45 0c             	mov    0xc(%ebp),%eax
   15cc2:	8b 50 0c             	mov    0xc(%eax),%edx
   15cc5:	8b 45 0c             	mov    0xc(%ebp),%eax
   15cc8:	8b 40 10             	mov    0x10(%eax),%eax
   15ccb:	0f af c2             	imul   %edx,%eax
   15cce:	01 c0                	add    %eax,%eax
   15cd0:	83 ec 0c             	sub    $0xc,%esp
   15cd3:	50                   	push   %eax
   15cd4:	e8 2e ad fe ff       	call   a07 <malloc>
   15cd9:	83 c4 10             	add    $0x10,%esp
   15cdc:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if(!out) ERROR_RETURN(OutOfMemory);
   15cdf:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   15ce3:	75 0e                	jne    15cf3 <_UpsampleV+0x54>
   15ce5:	8b 45 08             	mov    0x8(%ebp),%eax
   15ce8:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
   15cee:	e9 6b 03 00 00       	jmp    1605e <_UpsampleV+0x3bf>
    for(x = 0; x<w; ++x){
   15cf3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   15cfa:	e9 1d 03 00 00       	jmp    1601c <_UpsampleV+0x37d>
        cin = &c->pixels[x];
   15cff:	8b 45 0c             	mov    0xc(%ebp),%eax
   15d02:	8b 50 28             	mov    0x28(%eax),%edx
   15d05:	8b 45 ec             	mov    -0x14(%ebp),%eax
   15d08:	01 d0                	add    %edx,%eax
   15d0a:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cout = &out[x];
   15d0d:	8b 55 ec             	mov    -0x14(%ebp),%edx
   15d10:	8b 45 d8             	mov    -0x28(%ebp),%eax
   15d13:	01 d0                	add    %edx,%eax
   15d15:	89 45 f0             	mov    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
   15d18:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d1b:	0f b6 00             	movzbl (%eax),%eax
   15d1e:	0f b6 c0             	movzbl %al,%eax
   15d21:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15d27:	8b 4d e0             	mov    -0x20(%ebp),%ecx
   15d2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d2d:	01 c8                	add    %ecx,%eax
   15d2f:	0f b6 00             	movzbl (%eax),%eax
   15d32:	0f b6 c0             	movzbl %al,%eax
   15d35:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   15d38:	01 d0                	add    %edx,%eax
   15d3a:	83 ec 0c             	sub    $0xc,%esp
   15d3d:	50                   	push   %eax
   15d3e:	e8 1d 03 00 00       	call   16060 <CF>
   15d43:	83 c4 10             	add    $0x10,%esp
   15d46:	89 c2                	mov    %eax,%edx
   15d48:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15d4b:	88 10                	mov    %dl,(%eax)
   15d4d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15d50:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
   15d53:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d56:	0f b6 00             	movzbl (%eax),%eax
   15d59:	0f b6 c0             	movzbl %al,%eax
   15d5c:	6b c8 68             	imul   $0x68,%eax,%ecx
   15d5f:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15d62:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d65:	01 d0                	add    %edx,%eax
   15d67:	0f b6 00             	movzbl (%eax),%eax
   15d6a:	0f b6 d0             	movzbl %al,%edx
   15d6d:	89 d0                	mov    %edx,%eax
   15d6f:	01 c0                	add    %eax,%eax
   15d71:	01 d0                	add    %edx,%eax
   15d73:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15d7a:	01 d0                	add    %edx,%eax
   15d7c:	01 c1                	add    %eax,%ecx
   15d7e:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15d81:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15d84:	01 d0                	add    %edx,%eax
   15d86:	0f b6 00             	movzbl (%eax),%eax
   15d89:	0f b6 d0             	movzbl %al,%edx
   15d8c:	89 d0                	mov    %edx,%eax
   15d8e:	01 c0                	add    %eax,%eax
   15d90:	01 d0                	add    %edx,%eax
   15d92:	f7 d8                	neg    %eax
   15d94:	01 c8                	add    %ecx,%eax
   15d96:	83 ec 0c             	sub    $0xc,%esp
   15d99:	50                   	push   %eax
   15d9a:	e8 c1 02 00 00       	call   16060 <CF>
   15d9f:	83 c4 10             	add    $0x10,%esp
   15da2:	89 c2                	mov    %eax,%edx
   15da4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15da7:	88 10                	mov    %dl,(%eax)
   15da9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15dac:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
   15daf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15db2:	0f b6 00             	movzbl (%eax),%eax
   15db5:	0f b6 c0             	movzbl %al,%eax
   15db8:	c1 e0 02             	shl    $0x2,%eax
   15dbb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15dc2:	89 d1                	mov    %edx,%ecx
   15dc4:	29 c1                	sub    %eax,%ecx
   15dc6:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15dc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15dcc:	01 d0                	add    %edx,%eax
   15dce:	0f b6 00             	movzbl (%eax),%eax
   15dd1:	0f b6 c0             	movzbl %al,%eax
   15dd4:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15dd7:	01 c1                	add    %eax,%ecx
   15dd9:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15ddc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ddf:	01 d0                	add    %edx,%eax
   15de1:	0f b6 00             	movzbl (%eax),%eax
   15de4:	0f b6 d0             	movzbl %al,%edx
   15de7:	89 d0                	mov    %edx,%eax
   15de9:	c1 e0 03             	shl    $0x3,%eax
   15dec:	01 d0                	add    %edx,%eax
   15dee:	f7 d8                	neg    %eax
   15df0:	01 c8                	add    %ecx,%eax
   15df2:	83 ec 0c             	sub    $0xc,%esp
   15df5:	50                   	push   %eax
   15df6:	e8 65 02 00 00       	call   16060 <CF>
   15dfb:	83 c4 10             	add    $0x10,%esp
   15dfe:	89 c2                	mov    %eax,%edx
   15e00:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e03:	88 10                	mov    %dl,(%eax)
   15e05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15e08:	01 45 f0             	add    %eax,-0x10(%ebp)
        cin += s1;
   15e0b:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15e0e:	01 45 f4             	add    %eax,-0xc(%ebp)
        for(y=c->height-3; y; --y) {
   15e11:	8b 45 0c             	mov    0xc(%ebp),%eax
   15e14:	8b 40 10             	mov    0x10(%eax),%eax
   15e17:	83 e8 03             	sub    $0x3,%eax
   15e1a:	89 45 e8             	mov    %eax,-0x18(%ebp)
   15e1d:	e9 e6 00 00 00       	jmp    15f08 <_UpsampleV+0x269>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
   15e22:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15e25:	f7 d8                	neg    %eax
   15e27:	89 c2                	mov    %eax,%edx
   15e29:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e2c:	01 d0                	add    %edx,%eax
   15e2e:	0f b6 00             	movzbl (%eax),%eax
   15e31:	0f b6 d0             	movzbl %al,%edx
   15e34:	89 d0                	mov    %edx,%eax
   15e36:	c1 e0 03             	shl    $0x3,%eax
   15e39:	01 d0                	add    %edx,%eax
   15e3b:	f7 d8                	neg    %eax
   15e3d:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15e40:	0f b6 12             	movzbl (%edx),%edx
   15e43:	0f b6 d2             	movzbl %dl,%edx
   15e46:	6b d2 6f             	imul   $0x6f,%edx,%edx
   15e49:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15e4c:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15e4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e52:	01 d0                	add    %edx,%eax
   15e54:	0f b6 00             	movzbl (%eax),%eax
   15e57:	0f b6 c0             	movzbl %al,%eax
   15e5a:	6b c0 1d             	imul   $0x1d,%eax,%eax
   15e5d:	01 c1                	add    %eax,%ecx
   15e5f:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15e62:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e65:	01 d0                	add    %edx,%eax
   15e67:	0f b6 00             	movzbl (%eax),%eax
   15e6a:	0f b6 d0             	movzbl %al,%edx
   15e6d:	89 d0                	mov    %edx,%eax
   15e6f:	01 c0                	add    %eax,%eax
   15e71:	01 d0                	add    %edx,%eax
   15e73:	f7 d8                	neg    %eax
   15e75:	01 c8                	add    %ecx,%eax
   15e77:	83 ec 0c             	sub    $0xc,%esp
   15e7a:	50                   	push   %eax
   15e7b:	e8 e0 01 00 00       	call   16060 <CF>
   15e80:	83 c4 10             	add    $0x10,%esp
   15e83:	89 c2                	mov    %eax,%edx
   15e85:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15e88:	88 10                	mov    %dl,(%eax)
   15e8a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15e8d:	01 45 f0             	add    %eax,-0x10(%ebp)
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
   15e90:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15e93:	f7 d8                	neg    %eax
   15e95:	89 c2                	mov    %eax,%edx
   15e97:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15e9a:	01 d0                	add    %edx,%eax
   15e9c:	0f b6 00             	movzbl (%eax),%eax
   15e9f:	0f b6 d0             	movzbl %al,%edx
   15ea2:	89 d0                	mov    %edx,%eax
   15ea4:	01 c0                	add    %eax,%eax
   15ea6:	01 d0                	add    %edx,%eax
   15ea8:	f7 d8                	neg    %eax
   15eaa:	8b 55 f4             	mov    -0xc(%ebp),%edx
   15ead:	0f b6 12             	movzbl (%edx),%edx
   15eb0:	0f b6 d2             	movzbl %dl,%edx
   15eb3:	6b d2 1d             	imul   $0x1d,%edx,%edx
   15eb6:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
   15eb9:	8b 55 e0             	mov    -0x20(%ebp),%edx
   15ebc:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ebf:	01 d0                	add    %edx,%eax
   15ec1:	0f b6 00             	movzbl (%eax),%eax
   15ec4:	0f b6 c0             	movzbl %al,%eax
   15ec7:	6b c0 6f             	imul   $0x6f,%eax,%eax
   15eca:	01 c1                	add    %eax,%ecx
   15ecc:	8b 55 dc             	mov    -0x24(%ebp),%edx
   15ecf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ed2:	01 d0                	add    %edx,%eax
   15ed4:	0f b6 00             	movzbl (%eax),%eax
   15ed7:	0f b6 d0             	movzbl %al,%edx
   15eda:	89 d0                	mov    %edx,%eax
   15edc:	c1 e0 03             	shl    $0x3,%eax
   15edf:	01 d0                	add    %edx,%eax
   15ee1:	f7 d8                	neg    %eax
   15ee3:	01 c8                	add    %ecx,%eax
   15ee5:	83 ec 0c             	sub    $0xc,%esp
   15ee8:	50                   	push   %eax
   15ee9:	e8 72 01 00 00       	call   16060 <CF>
   15eee:	83 c4 10             	add    $0x10,%esp
   15ef1:	89 c2                	mov    %eax,%edx
   15ef3:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15ef6:	88 10                	mov    %dl,(%eax)
   15ef8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15efb:	01 45 f0             	add    %eax,-0x10(%ebp)
            cin += s1;
   15efe:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f01:	01 45 f4             	add    %eax,-0xc(%ebp)
        cout = &out[x];
        *cout = CF(CF2A * cin[0] + CF2B * cin[s1]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[s1] + CF3Z * cin[s2]);  cout += w;
        *cout = CF(CF3A * cin[0] + CF3B * cin[s1] + CF3C * cin[s2]);  cout += w;
        cin += s1;
        for(y=c->height-3; y; --y) {
   15f04:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
   15f08:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   15f0c:	0f 85 10 ff ff ff    	jne    15e22 <_UpsampleV+0x183>
            *cout = CF(CF4A * cin[-s1] + CF4B * cin[0] + CF4C * cin[s1] + CF4D * cin[s2]);  cout += w;
            *cout = CF(CF4D * cin[-s1] + CF4C * cin[0] + CF4B * cin[s1] + CF4A * cin[s2]);  cout += w;
            cin += s1;
        }
        cin += s1;
   15f12:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f15:	01 45 f4             	add    %eax,-0xc(%ebp)
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
   15f18:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f1b:	0f b6 00             	movzbl (%eax),%eax
   15f1e:	0f b6 c0             	movzbl %al,%eax
   15f21:	c1 e0 02             	shl    $0x2,%eax
   15f24:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15f2b:	29 c2                	sub    %eax,%edx
   15f2d:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f30:	f7 d8                	neg    %eax
   15f32:	89 c1                	mov    %eax,%ecx
   15f34:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f37:	01 c8                	add    %ecx,%eax
   15f39:	0f b6 00             	movzbl (%eax),%eax
   15f3c:	0f b6 c0             	movzbl %al,%eax
   15f3f:	6b c0 6d             	imul   $0x6d,%eax,%eax
   15f42:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
   15f45:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15f48:	f7 d8                	neg    %eax
   15f4a:	89 c2                	mov    %eax,%edx
   15f4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f4f:	01 d0                	add    %edx,%eax
   15f51:	0f b6 00             	movzbl (%eax),%eax
   15f54:	0f b6 d0             	movzbl %al,%edx
   15f57:	89 d0                	mov    %edx,%eax
   15f59:	c1 e0 03             	shl    $0x3,%eax
   15f5c:	01 d0                	add    %edx,%eax
   15f5e:	f7 d8                	neg    %eax
   15f60:	01 c8                	add    %ecx,%eax
   15f62:	83 ec 0c             	sub    $0xc,%esp
   15f65:	50                   	push   %eax
   15f66:	e8 f5 00 00 00       	call   16060 <CF>
   15f6b:	83 c4 10             	add    $0x10,%esp
   15f6e:	89 c2                	mov    %eax,%edx
   15f70:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15f73:	88 10                	mov    %dl,(%eax)
   15f75:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15f78:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
   15f7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f7e:	0f b6 00             	movzbl (%eax),%eax
   15f81:	0f b6 c0             	movzbl %al,%eax
   15f84:	6b c8 68             	imul   $0x68,%eax,%ecx
   15f87:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15f8a:	f7 d8                	neg    %eax
   15f8c:	89 c2                	mov    %eax,%edx
   15f8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15f91:	01 d0                	add    %edx,%eax
   15f93:	0f b6 00             	movzbl (%eax),%eax
   15f96:	0f b6 d0             	movzbl %al,%edx
   15f99:	89 d0                	mov    %edx,%eax
   15f9b:	01 c0                	add    %eax,%eax
   15f9d:	01 d0                	add    %edx,%eax
   15f9f:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   15fa6:	01 d0                	add    %edx,%eax
   15fa8:	01 c1                	add    %eax,%ecx
   15faa:	8b 45 dc             	mov    -0x24(%ebp),%eax
   15fad:	f7 d8                	neg    %eax
   15faf:	89 c2                	mov    %eax,%edx
   15fb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15fb4:	01 d0                	add    %edx,%eax
   15fb6:	0f b6 00             	movzbl (%eax),%eax
   15fb9:	0f b6 d0             	movzbl %al,%edx
   15fbc:	89 d0                	mov    %edx,%eax
   15fbe:	01 c0                	add    %eax,%eax
   15fc0:	01 d0                	add    %edx,%eax
   15fc2:	f7 d8                	neg    %eax
   15fc4:	01 c8                	add    %ecx,%eax
   15fc6:	83 ec 0c             	sub    $0xc,%esp
   15fc9:	50                   	push   %eax
   15fca:	e8 91 00 00 00       	call   16060 <CF>
   15fcf:	83 c4 10             	add    $0x10,%esp
   15fd2:	89 c2                	mov    %eax,%edx
   15fd4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   15fd7:	88 10                	mov    %dl,(%eax)
   15fd9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   15fdc:	01 45 f0             	add    %eax,-0x10(%ebp)
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
   15fdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15fe2:	0f b6 00             	movzbl (%eax),%eax
   15fe5:	0f b6 c0             	movzbl %al,%eax
   15fe8:	69 d0 8b 00 00 00    	imul   $0x8b,%eax,%edx
   15fee:	8b 45 e0             	mov    -0x20(%ebp),%eax
   15ff1:	f7 d8                	neg    %eax
   15ff3:	89 c1                	mov    %eax,%ecx
   15ff5:	8b 45 f4             	mov    -0xc(%ebp),%eax
   15ff8:	01 c8                	add    %ecx,%eax
   15ffa:	0f b6 00             	movzbl (%eax),%eax
   15ffd:	0f b6 c0             	movzbl %al,%eax
   16000:	6b c0 f5             	imul   $0xfffffff5,%eax,%eax
   16003:	01 d0                	add    %edx,%eax
   16005:	83 ec 0c             	sub    $0xc,%esp
   16008:	50                   	push   %eax
   16009:	e8 52 00 00 00       	call   16060 <CF>
   1600e:	83 c4 10             	add    $0x10,%esp
   16011:	89 c2                	mov    %eax,%edx
   16013:	8b 45 f0             	mov    -0x10(%ebp),%eax
   16016:	88 10                	mov    %dl,(%eax)
    const int w = c->width, s1 = c->stride, s2 = s1 + s1;
    uchar *out, *cin, *cout;
    int x, y;
    out = (uchar*)malloc((c->width * c->height) << 1);
    if(!out) ERROR_RETURN(OutOfMemory);
    for(x = 0; x<w; ++x){
   16018:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   1601c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1601f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
   16022:	0f 8c d7 fc ff ff    	jl     15cff <_UpsampleV+0x60>
        cin += s1;
        *cout = CF(CF3A * cin[0] + CF3B * cin[-s1] + CF3C * cin[-s2]);  cout += w;
        *cout = CF(CF3X * cin[0] + CF3Y * cin[-s1] + CF3Z * cin[-s2]);  cout += w;
        *cout = CF(CF2A * cin[0] + CF2B * cin[-s1]);
    }
    c->height <<= 1;
   16028:	8b 45 0c             	mov    0xc(%ebp),%eax
   1602b:	8b 40 10             	mov    0x10(%eax),%eax
   1602e:	8d 14 00             	lea    (%eax,%eax,1),%edx
   16031:	8b 45 0c             	mov    0xc(%ebp),%eax
   16034:	89 50 10             	mov    %edx,0x10(%eax)
    c->stride = c->width;
   16037:	8b 45 0c             	mov    0xc(%ebp),%eax
   1603a:	8b 50 0c             	mov    0xc(%eax),%edx
   1603d:	8b 45 0c             	mov    0xc(%ebp),%eax
   16040:	89 50 14             	mov    %edx,0x14(%eax)
    free(c->pixels);
   16043:	8b 45 0c             	mov    0xc(%ebp),%eax
   16046:	8b 40 28             	mov    0x28(%eax),%eax
   16049:	83 ec 0c             	sub    $0xc,%esp
   1604c:	50                   	push   %eax
   1604d:	e8 73 a8 fe ff       	call   8c5 <free>
   16052:	83 c4 10             	add    $0x10,%esp
    c->pixels = out;
   16055:	8b 45 0c             	mov    0xc(%ebp),%eax
   16058:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1605b:	89 50 28             	mov    %edx,0x28(%eax)
}
   1605e:	c9                   	leave  
   1605f:	c3                   	ret    

00016060 <CF>:

uchar CF(const int x){
   16060:	55                   	push   %ebp
   16061:	89 e5                	mov    %esp,%ebp
    return _Clip((x + 64) >> 7);
   16063:	8b 45 08             	mov    0x8(%ebp),%eax
   16066:	83 c0 40             	add    $0x40,%eax
   16069:	c1 f8 07             	sar    $0x7,%eax
   1606c:	50                   	push   %eax
   1606d:	e8 e9 dd ff ff       	call   13e5b <_Clip>
   16072:	83 c4 04             	add    $0x4,%esp
}
   16075:	c9                   	leave  
   16076:	c3                   	ret    
